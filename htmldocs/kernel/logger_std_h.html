<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>logger_std_h</h1><h1>logger_std_h</h1><p>Standard handler for Logger.</p><p>This is the standard handler for Logger.
Multiple instances of this handler can be added to
Logger, and each instance prints logs to <strong>standard_io</strong>,
<strong>standard_error</strong>, or to file.The handler has an overload protection mechanism that keeps the handler
process and the Kernel application alive during high loads of log 
events. How overload protection works, and how to configure it, is
described in the
<a href="./logger_chapter#overload_protection">logger_chapter#overload_protection</a>.To add a new instance of the standard handler, use
<a href="./logger#add_handler-3">logger#add_handler-3</a>. The handler configuration argument is a map which can contain
general configuration parameters, as documented in the
<a href="./logger_chapter#handler_configuration">logger_chapter#handler_configuration</a>, and handler specific parameters. The specific data
is stored in a sub map with the key <strong>config</strong>, and can contain the
following parameters:<dl><dt><a name="type"></a><strong>type = standard_io | standard_error | file</strong></dt><dd> <p>Specifies the log destination.</p> <p>The value is set when the handler is added, and it cannot
be changed in runtime.</p> <p>Defaults to <strong>standard_io</strong>, unless
parameter <a href="#file">file</a> is
given, in which case it defaults to <strong>file</strong>.</p> </dd><dt><a name="file"></a><strong>file = </strong><a href="./file#type-filename">file#type-filename</a></dt><dd> <p>This specifies the name of the log file when the handler is
of type <strong>file</strong>.</p> <p>The value is set when the handler is added, and it cannot
be changed in runtime.</p> <p>Defaults to the same name as the handler identity, in the
current directory.</p> </dd><dt><a name="modes"></a><strong>modes = [</strong><a href="./file#type-mode">file#type-mode</a><strong>]</strong></dt><dd> <p>This specifies the file modes to use when opening the log
file,
see <a href="./file#open-2">file#open-2</a>.
If <strong>modes</strong> are not specified, the default list used
is <strong>[raw,append,delayed_write]</strong>. If <strong>modes</strong> are
specified, the list replaces the default modes list with the
following adjustments:</p> <ul><li> If <strong>raw</strong> is not found in the list, it is added. </li><li> If none of <strong>write</strong>, <strong>append</strong> or <strong>exclusive</strong> is found in the list, <strong>append</strong> is added.</li><li>If none of <strong>delayed_write</strong> or <strong>{delayed_write,Size,Delay}</strong> is found in the list, <strong>delayed_write</strong> is added.</li></ul> <p>Log files are always UTF-8 encoded. The encoding cannot be
changed by setting the mode <strong>{encoding,Encoding}</strong>.</p> <p>The value is set when the handler is added, and it cannot
be changed in runtime.</p> <p>Defaults to <strong>[raw,append,delayed_write]</strong>.</p> </dd><dt><a name="max_no_bytes"></a><strong>max_no_bytes = pos_integer() | infinity</strong></dt><dd> <p>This parameter specifies if the log file should be rotated
or not. The value <strong>infinity</strong> means the log file will
grow indefinitely, while an integer value specifies at which
file size (bytes) the file is rotated.</p> <p>Defaults to <strong>infinity</strong>.</p> </dd><dt><a name="max_no_files"></a><strong>max_no_files = non_neg_integer()</strong></dt><dd> <p>This parameter specifies the number of rotated log file
archives to keep. This has meaning only
if <a href="#max_no_bytes">max_no_bytes</a>
is set to an integer value.</p> <p>The log archives are
named <strong>FileName.0</strong>, <strong>FileName.1</strong>,
... <strong>FileName.N</strong>, where <strong>FileName</strong> is the name of
the current log file. <strong>FileName.0</strong> is the newest of the
archives. The maximum value for <strong>N</strong> is the value
of <strong>max_no_files</strong> minus 1.</p> <p>Notice that setting this value to <strong>0</strong> does not turn of
rotation. It only specifies that no archives are kept.</p> <p>Defaults to <strong>0</strong>.</p> </dd><dt><a name="compress_on_rotate"></a><strong>compress_on_rotate = boolean()</strong></dt><dd> <p>This parameter specifies if the rotated log file archives
shall be compressed or not. If set to <strong>true</strong>, all
archives are compressed with <strong>gzip</strong>, and renamed
to <strong>FileName.N.gz</strong></p> <p><strong>compress_on_rotate</strong> has no meaning if <a href="#max_no_bytes">max_no_bytes</a> has the
value <strong>infinity</strong>.</p> <p>Defaults to <strong>false</strong>.</p> </dd><dt><a name="file_check"></a><strong>file_check = non_neg_integer()</strong></dt><dd> <p>When <strong>logger_std_h</strong> logs to a file, it reads the file
information of the log file prior to each write
operation. This is to make sure the file still exists and
has the same inode as when it was opened. This implies some
performance loss, but ensures that no log events are lost in
the case when the file has been removed or renamed by an
external actor.</p> <p>In order to allow minimizing the performance loss, the
<strong>file_check</strong> parameter can be set to a positive integer
value, <strong>N</strong>. The handler will then skip reading the file
information prior to writing, as long as no more
than <strong>N</strong> milliseconds have passed since it was last
read.</p> <p>Notice that the risk of loosing log events grows when
the <strong>file_check</strong> value grows.</p> <p>Defaults to 0.</p> </dd><dt><strong>filesync_repeat_interval = pos_integer() | no_repeat</strong></dt><dd> <p>This value, in milliseconds, specifies how often the handler does
a file sync operation to write buffered data to disk. The handler attempts
the operation repeatedly, but only performs a new sync if something has
actually been logged.</p> <p>If <strong>no_repeat</strong> is set as value, the repeated file sync operation
is disabled, and it is the operating system settings that determine
how quickly or slowly data is written to disk. The user can also call
the <a href="./logger_std_h#filesync-1">logger_std_h#filesync-1</a>
function to perform a file sync.</p> <p>Defaults to <strong>5000</strong> milliseconds.</p> </dd></dl>Other configuration parameters exist, to be used for customizing
the overload protection behaviour. The same parameters are used both in the
standard handler and the disk_log handler, and are documented in the
<a href="./logger_chapter#overload_protection">logger_chapter#overload_protection</a>.Notice that if changing the configuration of the handler in
runtime, the <strong>type</strong>, <strong>file</strong>, or <strong>modes</strong> parameters
must not be modified.Example of adding a standard handler:<pre><code class="">
logger:add_handler(my_standard_h, logger_std_h,
                   #{config =&gt; #{file =&gt; "./system_info.log",
                                 filesync_repeat_interval =&gt; 1000}}).
    </code></pre>To set the default handler, that starts initially with
the Kernel application, to log to file instead of <strong>standard_io</strong>,
change the Kernel default logger configuration. Example:<pre><code class="">
erl -kernel logger '[{handler,default,logger_std_h,
                      #{config =&gt; #{file =&gt; "./log.log"}}}]'
    </code></pre>An example of how to replace the standard handler with a disk_log handler
at startup is found in the
<a href="logger_disk_log_h">logger_disk_log_h</a>
manual.</p><h1>Functions</h1><h2>filesync/1</h2><p>Writes buffered data to disk.</p><p>Write buffered data to disk.</p><h2>See Also</h2><p><a href="logger">logger</a>,
<a href="logger_disk_log_h">logger_disk_log_h</a></p></body></html>