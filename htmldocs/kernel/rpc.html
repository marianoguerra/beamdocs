<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>rpc</h1><h1>rpc</h1><p>Remote Procedure Call services.</p><p>This module contains services similar to Remote
Procedure Calls. It also contains broadcast facilities and
parallel evaluators. A remote procedure call is a method to call
a function on a remote node and collect the answer. It is used
for collecting information on a remote node, or for running a
function with some specific side effects on the remote node.</p><h1>Data Types</h1><span class="name">key</span><p>As returned by
<a href="#async_call/4">async_call/4</a>.</p><h1>Functions</h1><h2>abcast/2</h2><p>Broadcast a message asynchronously to a registered process on all nodes.</p><p>Equivalent to <strong>abcast([node()|nodes()], <span class="anno">Name</span>, <span class="anno">Msg</span>)</strong>.</p><h2>abcast/3</h2><p>Broadcast a message asynchronously to a registered process on specific nodes.</p><p>Broadcasts the message <strong><span class="anno">Msg</span></strong> asynchronously to
the registered process <strong><span class="anno">Name</span></strong> on the specified
nodes.</p><h2>async_call/4</h2><p>Evaluate a function call on a node, asynchronous version.</p><p>Implements <em>call streams with promises</em>, a type of
RPC that does not suspend the caller until the result is
finished. Instead, a key is returned, which can be used
later to collect the value. The key can be viewed as a
promise to deliver the answer.</p><p>In this case, the key <strong><span class="anno">Key</span></strong> is returned, which
can be used in a subsequent call to
<a href="#yield/1">yield/1</a> or
<a href="#nb_yield/1">nb_yield/1</a>
to retrieve the value of evaluating <strong>apply(<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Args</span>)</strong> on node
<strong><span class="anno">Node</span></strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><a href="#yield/1">yield/1</a> and
<a href="#nb_yield/1">nb_yield/1</a>
must be called by the same process from which this function
was made otherwise they will never yield correctly.</p></div><h2>block_call/4</h2><p>Evaluate a function call on a node in the RPC server's context.</p><p>Same as <a href="#call/4">call/4</a>,
but the RPC server at <strong><span class="anno">Node</span></strong> does
not create a separate process to handle the call. Thus,
this function can be used if the intention of the call is to
block the RPC server from any other incoming requests until
the request has been handled. The function can also be used
for efficiency reasons when very small fast functions are
evaluated, for example, BIFs that are guaranteed not to
suspend.</p><h2>block_call/5</h2><p>Evaluate a function call on a node in the RPC server's context.</p><p>Same as
<a href="#block_call/4">block_call/4</a>,
but with a time-out value in the same manner as
<a href="#call/5">call/5</a>.</p><h2>call/4</h2><p>Evaluate a function call on a node.</p><p>Evaluates <strong>apply(<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Args</span>)</strong> on node <strong><span class="anno">Node</span></strong> and returns
the corresponding value <strong><span class="anno">Res</span></strong>, or
<strong>{badrpc, <span class="anno">Reason</span>}</strong> if the call fails.</p><h2>call/5</h2><p>Evaluate a function call on a node.</p><p>Evaluates <strong>apply(<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Args</span>)</strong> on node <strong><span class="anno">Node</span></strong> and returns
the corresponding value <strong><span class="anno">Res</span></strong>, or
<strong>{badrpc, <span class="anno">Reason</span>}</strong> if the call fails.
<strong><span class="anno">Timeout</span></strong> is
a time-out value in milliseconds. If the call times out,
<strong><span class="anno">Reason</span></strong> is <strong>timeout</strong>.</p><p>If the reply arrives after the call times out, no message
contaminates the caller's message queue, as this
function spawns off a middleman process to act as (a void)
destination for such an orphan reply. This feature also makes
this function more expensive than <strong>call/4</strong> at
the caller's end.</p><h2>cast/4</h2><p>Run a function on a node ignoring the result.</p><p>Evaluates <strong>apply(<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Args</span>)</strong> on node
<strong><span class="anno">Node</span></strong>. No response is delivered and the calling
process is not suspended until the evaluation is complete, as
is the case with
<a href="#call/4">call/4</a>.</p><h2>eval_everywhere/3</h2><p>Run a function on all nodes, ignoring the result.</p><p>Equivalent to <strong>eval_everywhere([node()|nodes()], <span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Args</span>)</strong>.</p><h2>eval_everywhere/4</h2><p>Run a function on specific nodes, ignoring the result.</p><p>Evaluates <strong>apply(<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Args</span>)</strong> on
the specified nodes. No answers are collected.</p><h2>multi_server_call/2</h2><p>Interact with the servers on a number of nodes.</p><p>Equivalent to <strong>multi_server_call([node()|nodes()], <span class="anno">Name</span>, <span class="anno">Msg</span>)</strong>.</p><h2>multi_server_call/3</h2><p>Interact with the servers on a number of nodes.</p><p>Can be used when interacting with servers called
<strong><span class="anno">Name</span></strong> on the specified nodes. It is assumed that
the servers receive messages in the format
<strong>{From, <span class="anno">Msg</span>}</strong> and reply using
<strong>From ! {<span class="anno">Name</span>, Node, <span class="anno">Reply</span>}</strong>, where
<strong>Node</strong> is the name of the node where the server is located.
The function returns <strong>{<span class="anno">Replies</span>, <span class="anno">BadNodes</span>}</strong>, where <strong><span class="anno">Replies</span></strong> is a
list of all <strong><span class="anno">Reply</span></strong> values, and
<strong><span class="anno">BadNodes</span></strong> is one of the following:</p><ul><li>A list of the nodes that do not exist</li><li>A list of the nodes where the server does not exist</li><li>A list of the nodes where the server terminated before sending any reply.</li></ul><h2>multicall/3</h2><p>Evaluate a function call on a number of nodes.</p><p>Equivalent to <strong>multicall([node()|nodes()], <span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Args</span>, infinity)</strong>.</p><h2>multicall/4</h2><p>Evaluate a function call on a number of nodes.</p><p>Equivalent to <strong>multicall(<span class="anno">Nodes</span>, <span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Args</span>, infinity)</strong>.</p><h2>multicall/4</h2><p>Evaluate a function call on a number of nodes.</p><p>Equivalent to <strong>multicall([node()|nodes()], <span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Args</span>, <span class="anno">Timeout</span>)</strong>.</p><h2>multicall/5</h2><p>Evaluate a function call on a number of nodes.</p><p>In contrast to an RPC, a multicall is an RPC that is sent
concurrently from one client to multiple servers. This is
useful for collecting information from a set of nodes,
or for calling a function on a set of nodes to achieve some
side effects. It is semantically the same as iteratively
making a series of RPCs on all the nodes, but the multicall
is faster, as all the requests are sent at the same time
and are collected one by one as they come back.</p><p>The function evaluates <strong>apply(<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Args</span>)</strong>
on the specified nodes and collects the answers. It returns
<strong>{<span class="anno">ResL</span>, <span class="anno">BadNodes</span>}</strong>, where
<strong><span class="anno">BadNodes</span></strong> is a list
of the nodes that do not exist,
and <strong><span class="anno">ResL</span></strong> is a list of the return values,
or <strong>{badrpc, <span class="anno">Reason</span>}</strong> for failing calls.
<strong><span class="anno">Timeout</span></strong> is a time (integer) in milliseconds, or
<strong>infinity</strong>.</p><p>The following example is useful when new object code is to
be loaded on all nodes in the network, and indicates
some side effects that RPCs can produce:</p><pre><code class="">
%% Find object code for module Mod
{Mod, Bin, File} = code:get_object_code(Mod),

%% and load it on all nodes including this one
{ResL, _} = rpc:multicall(code, load_binary, [Mod, File, Bin]),

%% and then maybe check the ResL list.</code></pre><h2>nb_yield/1</h2><p>Deliver the result of evaluating a function call on a node (non-blocking).</p><p>Equivalent to <strong>nb_yield(<span class="anno">Key</span>, 0)</strong>.</p><h2>nb_yield/2</h2><p>Deliver the result of evaluating a function call on a node (non-blocking).</p><p>Non-blocking version of
<a href="#yield/1">yield/1</a>. It returns
the tuple <strong>{value, <span class="anno">Val</span>}</strong> when the computation is
finished, or <strong>timeout</strong> when <strong><span class="anno">Timeout</span></strong>
milliseconds has elapsed.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function must be called by the same process from which
<a href="#async_call/4">async_call/4</a>
was made otherwise it will only return <strong>timeout</strong>.</p></div><h2>parallel_eval/1</h2><p>Evaluate many function calls on all nodes in parallel.</p><p>Evaluates, for every tuple in <strong><span class="anno">FuncCalls</span></strong>,
<strong>apply(<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Args</span>)</strong> on some node in
the network. Returns the list of return values, in the same
order as in <strong><span class="anno">FuncCalls</span></strong>.</p><h2>pinfo/1</h2><p>Information about a process.</p><p>Location transparent version of the BIF
<a href="../erts/erlang#process_info/1">erts/erlang#process_info/1</a> in ERTS.</p><h2>pinfo/2</h2><h2>pinfo/2</h2><p>Information about a process.</p><p>Location transparent version of the BIF
<a href="../erts/erlang#process_info/2">erts/erlang#process_info/2</a> in ERTS.</p><h2>pmap/3</h2><p>Parallel evaluation of mapping a function over a list.</p><p>Evaluates <strong>apply(<span class="anno">Module</span>, <span class="anno">Function</span>, [<span class="anno">Elem</span>|<span class="anno">ExtraArgs</span>])</strong> for every element
<strong><span class="anno">Elem</span></strong> in <strong><span class="anno">List1</span></strong>, in parallel.
Returns the list of return values, in the same order as in
<strong><span class="anno">List1</span></strong>.</p><h2>sbcast/2</h2><p>Broadcast a message synchronously to a registered process on all nodes.</p><p>Equivalent to <strong>sbcast([node()|nodes()], <span class="anno">Name</span>, <span class="anno">Msg</span>)</strong>.</p><h2>sbcast/3</h2><p>Broadcast a message synchronously to a registered process on specific nodes.</p><p>Broadcasts the message <strong><span class="anno">Msg</span></strong> synchronously to
the registered process <strong><span class="anno">Name</span></strong> on the specified
nodes.</p><p>Returns <strong>{<span class="anno">GoodNodes</span>, <span class="anno">BadNodes</span>}</strong>,
where <strong><span class="anno">GoodNodes</span></strong> is the list of nodes that have
<strong><span class="anno">Name</span></strong> as a registered process.</p><p>The function is synchronous in the sense that it is known
that all servers have received the message when the call
returns. It is not possible to know that the servers have
processed the message.</p><p>Any further messages sent to the servers, after this
function has returned, are received by all servers after
this message.</p><h2>server_call/4</h2><p>Interact with a server on a node.</p><p>Can be used when interacting with a server called
<strong><span class="anno">Name</span></strong> on node <strong><span class="anno">Node</span></strong>. It is
assumed that the server receives messages in the format
<strong>{From, <span class="anno">Msg</span>}</strong> and replies using
<strong>From ! {<span class="anno">ReplyWrapper</span>, <span class="anno">Node</span>, <span class="anno">Reply</span>}</strong>. This function makes such
a server call and ensures that the entire call is packed into
an atomic transaction, which either succeeds or fails. It
never hangs, unless the server itself hangs.</p><p>The function returns the answer <strong><span class="anno">Reply</span></strong> as
produced by the server <strong><span class="anno">Name</span></strong>, or
<strong>{error, <span class="anno">Reason</span>}</strong>.</p><h2>yield/1</h2><p>Deliver the result of evaluating a function call on a node (blocking).</p><p>Returns the promised answer from a previous
<a href="#async_call/4">async_call/4</a>.
If the answer is available, it is
returned immediately. Otherwise, the calling process is
suspended until the answer arrives from <strong>Node</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function must be called by the same process from which
<a href="#async_call/4">async_call/4</a>
was made otherwise it will never return.</p></div></body></html>