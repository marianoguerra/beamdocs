<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>error_handler</h1><h1>error_handler</h1><p>Default system error handler.</p><p>This module defines what happens when certain types
of errors occur.</p><h1>Functions</h1><h2>raise_undef_exception/3</h2><p>Raise an undef exception.</p><dl><dt>Args</dt><dd> A (possibly empty) list of arguments <strong>Arg1,..,ArgN</strong> </dd></dl><p>Raises an <strong>undef</strong> exception with a stacktrace, indicating
that <strong><span class="anno">Module</span>:<span class="anno">Function</span>/N</strong> is
undefined.
</p><h2>undefined_function/3</h2><p>Called when an undefined function is encountered.</p><dl><dt>Args</dt><dd> A (possibly empty) list of arguments <strong>Arg1,..,ArgN</strong> </dd></dl><p>This function is called by the runtime system if a call is made to
<strong><span class="anno">Module</span>:<span class="anno">Function</span>(Arg1,.., ArgN)</strong> and
<strong><span class="anno">Module</span>:<span class="anno">Function</span>/N</strong> is undefined.
Notice that this function is evaluated inside the process
making the original call.</p><p>This function first attempts to autoload
<strong><span class="anno">Module</span></strong>. If that is not possible,
an <strong>undef</strong> exception is raised.</p><p>If it is possible to load <strong><span class="anno">Module</span></strong>
and function <strong><span class="anno">Function</span>/N</strong> is exported,
it is called.</p><p>Otherwise, if function <strong>'$handle_undefined_function'/2</strong>
is exported, it is called as
<strong>'$handle_undefined_function'(</strong><span class="anno">Function</span>,
<span class="anno">Args</span>).
</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Defining <strong>'$handle_undefined_function'/2</strong> in
ordinary application code is highly discouraged. It is very
easy to make subtle errors that can take a long time to
debug. Furthermore, none of the tools for static code
analysis (such as Dialyzer and Xref) supports the use of
<strong>'$handle_undefined_function'/2</strong> and no such support
will be added. Only use this function after having carefully
considered other, less dangerous, solutions. One example of
potential legitimate use is creating stubs for other
sub-systems during testing and debugging.
</p></div><p>Otherwise an <strong>undef</strong> exception is raised.</p><h2>undefined_lambda/3</h2><p>Called when an undefined lambda (fun) is encountered.</p><dl><dt>Args</dt><dd> A (possibly empty) list of arguments <strong>Arg1,..,ArgN</strong> </dd></dl><p>This function is evaluated if a call is made to
<strong><span class="anno">Fun</span>(Arg1,.., ArgN)</strong> when the module defining
the fun is not loaded. The function is evaluated inside the process
making the original call.</p><p>If <strong><span class="anno">Module</span></strong> is interpreted, the interpreter is invoked
and the return value of the interpreted
<strong><span class="anno">Fun</span>(Arg1,.., ArgN)</strong> call is returned.</p><p>Otherwise, it returns, if possible, the value of
<strong>apply(<span class="anno">Fun</span>, <span class="anno">Args</span>)</strong> after an attempt
is made to autoload <strong><span class="anno">Module</span></strong>. If this is not possible,
the call fails with exit reason <strong>undef</strong>.</p><h2>Notes</h2><p>The code in <strong>error_handler</strong> is complex. Do not
change it without fully understanding the interaction between
the error handler, the <strong>init</strong> process of the code server,
and the I/O mechanism of the code.</p><p>Code changes that seem small can cause a deadlock,
as unforeseen consequences can occur. The use of <strong>input</strong> is
dangerous in this type of code.</p></body></html>