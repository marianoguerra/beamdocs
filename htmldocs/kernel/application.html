<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>application</h1><h1>application</h1><p>Generic OTP application functions</p><p>In OTP, <em>application</em> denotes a component implementing
some specific functionality, that can be started and stopped as a
unit, and that can be reused in other systems. This
module interacts with <em>application controller</em>, a process
started at every Erlang runtime system. This module contains functions
for controlling applications (for example, starting and stopping
applications), and functions to access information about
applications (for example, configuration parameters).An application is defined by an <em>application specification</em>.
The specification is normally located in an
<em>application resource file</em> named <strong>Application.app</strong>,
where <strong>Application</strong> is the application name. For details
about the application specification, see
<a href="app">app</a>.This module can also be viewed as a behaviour for an application
implemented according to the OTP design principles as a
supervision tree. The definition of how to start and stop
the tree is to be located in an <em>application callback module</em>,
exporting a predefined set of functions.For details about applications and behaviours, see
<a href="./des_princ">OTP Design Principles</a>.</p><h1>Data Types</h1><span class="name">start_type</span><span class="name">restart_type</span><span class="name">tuple_of(T)</span><p>A tuple where the elements are of type <strong>T</strong>.</p><h1>Functions</h1><h2>ensure_all_started/1</h2><h2>ensure_all_started/2</h2><p>Load and start an application and its dependencies, recursively.</p><p>Equivalent to calling
<a href="#start/1">start/1</a>
repeatedly on all dependencies that are not yet started for an application.</p><p>Returns <strong>{ok, AppNames}</strong> for a successful start or for an already started
application (which is, however, omitted from the <strong>AppNames</strong> list).</p><p>The function reports <strong>{error, {AppName,Reason}}</strong> for errors, where
<strong>Reason</strong> is any possible reason returned by
<a href="#start/1">start/1</a>
when starting a specific dependency.</p><p>If an error occurs, the applications started by the function are stopped
to bring the set of running applications back to its initial state.</p><h2>ensure_started/1</h2><h2>ensure_started/2</h2><p>Load and start an application.</p><p>Equivalent to
<a href="#start/1">start/1</a>
except it returns <strong>ok</strong> for already started applications.</p><h2>get_all_env/0</h2><h2>get_all_env/1</h2><p>Get the configuration parameters for an application.</p><p>Returns the configuration parameters and their values for
<strong><span class="anno">Application</span></strong>. If the argument is omitted, it defaults to
the application of the calling process.</p><p>If the specified application is not loaded, or if the process
executing the call does not belong to any application,
the function returns <strong>[]</strong>.</p><h2>get_all_key/0</h2><h2>get_all_key/1</h2><p>Get the application specification keys.</p><p>Returns the application specification keys and their values
for <strong><span class="anno">Application</span></strong>. If the argument is omitted, it
defaults to the application of the calling process.</p><p>If the specified application is not loaded, the function
returns <strong>undefined</strong>. If the process executing the call
does not belong to any application, the function returns
<strong>[]</strong>.</p><h2>get_application/0</h2><h2>get_application/1</h2><p>Get the name of an application containing a certain process or module.</p><p>Returns the name of the application to which the process
<strong><span class="anno">Pid</span></strong> or the module <strong><span class="anno">Module</span></strong> belongs. Providing no
argument is the same as calling
<strong>get_application(self())</strong>.</p><p>If the specified process does not belong to any application,
or if the specified process or module does not exist,
the function returns <strong>undefined</strong>.</p><h2>get_env/1</h2><h2>get_env/2</h2><p>Get the value of a configuration parameter.</p><p>Returns the value of configuration parameter <strong><span class="anno">Par</span></strong>
for <strong><span class="anno">Application</span></strong>. If the application argument is
omitted, it defaults to the application of the calling
process.</p><p>Returns <strong>undefined</strong> if any of the following applies:</p><ul><li>The specified application is not loaded.</li><li>The configuration parameter does not exist.</li><li>The process executing the call does not belong to any application.</li></ul><h2>get_env/3</h2><p>Get the value of a configuration parameter using a default.</p><p>Works like <a href="#get_env/2">get_env/2</a> but returns
value <strong><span class="anno">Def</span></strong> when configuration parameter
<strong><span class="anno">Par</span></strong> does not exist.</p><h2>get_key/1</h2><h2>get_key/2</h2><p>Get the value of an application specification key.</p><p>Returns the value of the application specification key
<strong><span class="anno">Key</span></strong> for <strong><span class="anno">Application</span></strong>. If the application
argument is omitted, it defaults to the application of
the calling process.</p><p>Returns <strong>undefined</strong> if any of the following applies:</p><ul><li>The specified application is not loaded.</li><li>The specification key does not exist.</li><li>The process executing the call does not belong to any application.</li></ul><h2>load/1</h2><h2>load/2</h2><p>Load an application.</p><ul><li>application_spec</li></ul><ul><li>application_opt</li></ul><p>Loads the application specification for an application into
the application controller. It also loads the application
specifications for any included applications. Notice that
the function does not load the Erlang object code.</p><p>The application can be specified by its name <strong><span class="anno">Application</span></strong>.
In this case, the application controller searches the code
path for the application resource file <strong><span class="anno">Application</span>.app</strong>
and loads the specification it contains.</p><p>The application specification can also be specified directly as a
tuple <strong><span class="anno">AppSpec</span></strong>, having the format and
contents as described in
<a href="app">app</a>.</p><p>If <strong><span class="anno">Distributed</span> == {<span class="anno">Application</span>,[<span class="anno">Time</span>,]<span class="anno">Nodes</span>}</strong>,
the application becomes distributed. The argument overrides
the value for the application in the Kernel configuration
parameter <strong>distributed</strong>. <strong><span class="anno">Application</span></strong> must be
the application name (same as in the first argument).
If a node crashes and <strong><span class="anno">Time</span></strong> is specified,
the application controller waits for <strong><span class="anno">Time</span></strong>
milliseconds before attempting to restart the application on
another node. If <strong><span class="anno">Time</span></strong> is not specified, it
defaults to <strong>0</strong> and the application is restarted
immediately.</p><p><strong><span class="anno">Nodes</span></strong> is a list of node names where the application
can run, in priority from left to right. Node names can be
grouped using tuples to indicate that they have the same
priority.</p><p><em>Example:</em></p><pre><code class="">
Nodes = [cp1@cave, {cp2@cave, cp3@cave}]</code></pre><p>This means that the application is preferably to be started
at <strong>cp1@cave</strong>. If <strong>cp1@cave</strong> is down,
the application is to be started at <strong>cp2@cave</strong>
or <strong>cp3@cave</strong>.</p><p>If <strong>Distributed == default</strong>, the value for
the application in the Kernel configuration parameter
<strong>distributed</strong> is used.</p><h2>loaded_applications/0</h2><p>Get the currently loaded applications.</p><p>Returns a list with information about the applications, and included
applications, which are loaded using <strong>load/1,2</strong>.
<strong><span class="anno">Application</span></strong> is the application name.
<strong><span class="anno">Description</span></strong> and <strong><span class="anno">Vsn</span></strong> are the values
of their <strong>description</strong> and <strong>vsn</strong> application specification
keys, respectively.</p><h2>set_env/1</h2><h2>set_env/2</h2><p>Sets the configuration parameters of multiple applications.</p><p>Sets the configuration <strong><span class="anno">Config</span></strong> for multiple
applications. It is equivalent to calling <strong>set_env/4</strong> on
each application individially, except it is more efficient.
The given <strong><span class="anno">Config</span></strong> is validated before the
configuration is set.</p><p><strong>set_env/2</strong> uses the standard <strong>gen_server</strong> time-out
value (5000 ms). Option <strong>timeout</strong> can be specified
if another time-out value is useful, for example, in situations
where the application controller is heavily loaded.</p><p>Option <strong>persistent</strong> can be set to <strong>true</strong>
to guarantee that parameters set with <strong>set_env/2</strong>
are not overridden by those defined in the application resource
file on load. This means that persistent values will stick after the application
is loaded and also on application reload.</p><p>If an application is given more than once or if an application
has the same key given more than once, the behaviour is undefined
and a warning message will be logged. In future releases, an error
will be raised.</p><p><strong>set_env/1</strong> is equivalent to <strong>set_env(Config, [])</strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Use this function only if you know what you are doing,
that is, on your own applications. It is very
application-dependent and
configuration parameter-dependent when and how often
the value is read by the application. Careless use
of this function can put the application in a
weird, inconsistent, and malfunctioning state.</p></div><h2>permit/2</h2><p>Change the permission for an application to run at a node.</p><p>Changes the permission for <strong><span class="anno">Application</span></strong> to run at
the current node. The application must be loaded using
<strong>load/1,2</strong> for the function to have effect.</p><p>If the permission of a loaded, but not started, application
is set to <strong>false</strong>, <strong>start</strong> returns <strong>ok</strong> but
the application is not started until the permission is
set to <strong>true</strong>.</p><p>If the permission of a running application is set to
<strong>false</strong>, the application is stopped. If
the permission later is set to <strong>true</strong>, it is
restarted.</p><p>If the application is distributed, setting the permission to
<strong>false</strong> means that the application will be started at, or
moved to, another node according to how its distribution is
configured
(see <a href="#load/2">load/2</a>).</p><p>The function does not return until the application is
started, stopped, or successfully moved to another node.
However, in some cases where permission is set to <strong>true</strong>,
the function returns <strong>ok</strong> even though the application
is not started. This is true when an application
cannot start because of dependencies to other
applications that are not yet started. When they are
started, <strong>Application</strong> is started as well.</p><p>By default, all applications are loaded with permission
<strong>true</strong> on all nodes. The permission can be configured
using the Kernel configuration parameter <strong>permissions</strong>.</p><h2>set_env/3</h2><h2>set_env/4</h2><p>Set the value of a configuration parameter.</p><p>Sets the value of configuration parameter <strong><span class="anno">Par</span></strong> for
<strong><span class="anno">Application</span></strong>.</p><p><strong>set_env/4</strong> uses the standard <strong>gen_server</strong> time-out
value (5000 ms). Option <strong>timeout</strong> can be specified
if another time-out value is useful, for example, in situations
where the application controller is heavily loaded.</p><p>If <strong>set_env/4</strong> is called before the application is loaded,
the application environment values specified in file <strong>Application.app</strong>
override the ones previously set. This is also true for application
reloads.</p><p>Option <strong>persistent</strong> can be set to <strong>true</strong>
to guarantee that parameters set with <strong>set_env/4</strong>
are not overridden by those defined in the application resource
file on load. This means that persistent values will stick after the application
is loaded and also on application reload.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Use this function only if you know what you are doing,
that is, on your own applications. It is very
application-dependent and
configuration parameter-dependent when and how often
the value is read by the application. Careless use
of this function can put the application in a
weird, inconsistent, and malfunctioning state.</p></div><h2>start/1</h2><h2>start/2</h2><p>Load and start an application.</p><p>Starts <strong><span class="anno">Application</span></strong>. If it is not loaded,
the application controller first loads it using
<strong>load/1</strong>. It ensures that any included applications
are loaded, but does not start them. That is assumed to be
taken care of in the code for <strong><span class="anno">Application</span></strong>.</p><p>The application controller checks the value of
the application specification key <strong>applications</strong>, to
ensure that all applications needed to be started before
this application are running. Otherwise,
<strong>{error,{not_started,App}}</strong> is returned, where <strong>App</strong>
is the name of the missing application.</p><p>The application controller then creates an <em>application master</em>
for the application. The application master becomes the
group leader of all the processes in the application. I/O is
forwarded to the previous group leader, though, this is just
a way to identify processes that belong to the application.
Used for example to find itself from any process, or,
reciprocally, to kill them all when it terminates.</p><p>
The application master starts the application by calling
the application callback function <strong>Module:start/2</strong> as
defined by the application specification key <strong>mod</strong>.</p><p>Argument <strong><span class="anno">Type</span></strong> specifies the type of
the application. If omitted, it defaults to <strong>temporary</strong>.</p><ul><li>If a permanent application terminates, all other applications and the entire Erlang node are also terminated.</li><li> <ul><li>If a transient application terminates with <strong>Reason == normal</strong>, this is reported but no other applications are terminated.</li><li>If a transient application terminates abnormally, all other applications and the entire Erlang node are also terminated.</li></ul> </li><li>If a temporary application terminates, this is reported but no other applications are terminated.</li></ul><p>Notice that an application can always be stopped
explicitly by calling <strong>stop/1</strong>. Regardless of the type of
the application, no other applications are affected.</p><p>Notice also that the transient type is of little practical use,
because when a supervision tree terminates, the reason is set to
<strong>shutdown</strong>, not <strong>normal</strong>.</p><h2>start_type/0</h2><p>Get the start type of an ongoing application startup.</p><p>This function is intended to be called by a process belonging
to an application, when the application is started, to
determine the start type, which is <strong><span class="anno">StartType</span></strong> or
<strong>local</strong>.</p><p>For a description of <strong><span class="anno">StartType</span></strong>, see
<a href="#start_type">start_type</a>.</p><p><strong>local</strong> is returned if only parts of the application are
restarted (by a supervisor), or if the function is
called outside a startup.</p><p>If the process executing the call does not belong to any
application, the function returns <strong>undefined</strong>.</p><h2>stop/1</h2><p>Stop an application.</p><p>Stops <strong><span class="anno">Application</span></strong>. The application master calls
<strong>Module:prep_stop/1</strong>, if such a function is defined, and
then tells the top supervisor of the application to shut down
(see <a href="./supervisor">stdlib/supervisor</a>).
This means that the entire
supervision tree, including included applications, is
terminated in reversed start order. After the shutdown,
the application master calls <strong>Module:stop/1</strong>.
<strong>Module</strong> is the callback module as defined by
the application specification key <strong>mod</strong>.</p><p>Last, the application master terminates. Notice that all
processes with the application master as group leader, that is,
processes spawned from a process belonging to the application,
are also terminated.</p><p>When stopped, the application is still loaded.</p><p>To stop a distributed application, <strong>stop/1</strong>
must be called on all nodes where it can execute (that is,
on all nodes where it has been started). The call to
<strong>stop/1</strong> on the node where the application currently
executes stops its execution. The application is not
moved between nodes, as <strong>stop/1</strong> is called on
the node where the application currently executes before
<strong>stop/1</strong> is called on the other nodes.</p><h2>takeover/2</h2><p>Take over a distributed application.</p><p>Takes over the distributed application
<strong><span class="anno">Application</span></strong>, which executes at another node
<strong>Node</strong>. At the current node, the application is
restarted by calling
<strong>Module:start({takeover,Node},StartArgs)</strong>. <strong>Module</strong>
and <strong>StartArgs</strong> are retrieved from the loaded application
specification. The application at the other node is not
stopped until the startup is completed, that is, when
<strong>Module:start/2</strong> and any calls to
<strong>Module:start_phase/3</strong> have returned.</p><p>Thus, two instances of the application run simultaneously
during the takeover, so that data can be transferred
from the old to the new instance. If this is not an acceptable
behavior, parts of the old instance can be shut down when
the new instance is started. However, the application cannot
be stopped entirely, at least the top supervisor
must remain alive.</p><p>For a description of <strong>Type</strong>, see
<a href="#start/1">start/1</a>.</p><h2>unload/1</h2><p>Unload an application.</p><p>Unloads the application specification for <strong><span class="anno">Application</span></strong>
from the application controller. It also unloads
the application specifications for any included applications.
Notice that the function does not purge the Erlang
object code.</p><h2>unset_env/2</h2><h2>unset_env/3</h2><p>Unset the value of a configuration parameter.</p><p>Removes the configuration parameter <strong><span class="anno">Par</span></strong> and its value
for <strong><span class="anno">Application</span></strong>.</p><p><strong>unset_env/2</strong> uses the standard <strong>gen_server</strong>
time-out value (5000 ms). Option <strong>timeout</strong> can be
specified if another time-out value is useful, for example, in
situations where the application controller is heavily loaded.</p><p><strong>unset_env/3</strong> also allows the persistent option to be passed
(see <a href="#set_env/4">set_env/4</a>).</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Use this function only if you know what you are doing,
that is, on your own applications. It is very
application-dependent and configuration
parameter-dependent when and how often
the value is read by the application. Careless use
of this function can put the application in a
weird, inconsistent, and malfunctioning state.</p></div><h2>which_applications/0</h2><h2>which_applications/1</h2><p>Get the currently running applications.</p><p>Returns a list with information about the applications that
are currently running. <strong><span class="anno">Application</span></strong> is the application
name. <strong><span class="anno">Description</span></strong> and <strong><span class="anno">Vsn</span></strong> are the
values of their <strong>description</strong> and <strong>vsn</strong> application specification
keys, respectively.</p><p><strong>which_applications/0</strong> uses the standard
<strong>gen_server</strong> time-out value (5000 ms). A <strong><span class="anno">Timeout</span></strong>
argument can be specified if another time-out value is useful,
for example, in situations where the application controller
is heavily loaded.</p><h2>Callback Module</h2><p>The following functions are to be exported from an
<strong>application</strong> callback module.</p><h1>Functions</h1><h2>Module:start(StartType, StartArgs) -&gt; {ok, Pid} | {ok, Pid, State} | {error, Reason}</h2><p>Start an application.</p><ul><li><span class="v">StartType = </span></li><li><span class="v">StartArgs = term()</span></li><li><span class="v">Pid = pid()</span></li><li><span class="v">State = term()</span></li></ul><p>This function is called whenever an application is started
using <strong>start/1,2</strong>, and is to start
the processes of the application. If the application is
structured according to the OTP design principles as a
supervision tree, this means starting the top supervisor of
the tree.</p><p><a name="start_type"></a><strong>StartType</strong> defines the type of start:</p><ul><li><strong>normal</strong> if it is a normal startup.</li><li><strong>normal</strong> also if the application is distributed and started at the current node because of a failover from another node, and the application specification key <strong>start_phases == undefined</strong>.</li><li><strong>{takeover,Node}</strong> if the application is distributed and started at the current node because of a takeover from <strong>Node</strong>, either because <strong>takeover/2</strong> has been called or because the current node has higher priority than <strong>Node</strong>.</li><li><strong>{failover,Node}</strong> if the application is distributed and started at the current node because of a failover from <strong>Node</strong>, and the application specification key <strong>start_phases /= undefined</strong>.</li></ul><p><strong>StartArgs</strong> is the <strong>StartArgs</strong> argument defined by
the application specification key <strong>mod</strong>.</p><p>The function is to return <strong>{ok,Pid}</strong> or
<strong>{ok,Pid,State}</strong>, where <strong>Pid</strong> is the pid of the top
supervisor and <strong>State</strong> is any term. If omitted,
<strong>State</strong> defaults to <strong>[]</strong>. If the application
is stopped later, <strong>State</strong> is passed to
<strong>Module:prep_stop/1</strong>.</p><h2>Module:start_phase(Phase, StartType, PhaseArgs) -&gt; ok | {error, Reason}</h2><p>Extended start of an application.</p><ul><li><span class="v">Phase = atom()</span></li><li><span class="v">StartType = </span></li><li><span class="v">PhaseArgs = term()</span></li><li><span class="v">Pid = pid()</span></li><li><span class="v">State = state()</span></li></ul><p>Starts an application with included
applications, when synchronization is needed between
processes in the different applications during startup.</p><p>The start phases are defined by the application specification
key <strong>start_phases == [{Phase,PhaseArgs}]</strong>. For included
applications, the set of phases must be a subset of the set of
phases defined for the including application.</p><p>The function is called for each start phase (as defined for
the primary application) for the primary application and all
included applications, for which the start phase is defined.</p><p>For a description of <strong>StartType</strong>, see
<a href="#Module:start/2">Module:start/2</a>.</p><h2>Module:prep_stop(State) -&gt; NewState</h2><p>Prepare an application for termination.</p><ul><li><span class="v">State = NewState = term()</span></li></ul><p>This function is called when an application is about to be
stopped, before shutting down the processes of
the application.</p><p><strong>State</strong> is the state returned from
<strong>Module:start/2</strong>, or <strong>[]</strong> if no state was returned.
<strong>NewState</strong> is any term and is passed to
<strong>Module:stop/1</strong>.</p><p>The function is optional. If it is not defined, the processes
are terminated and then <strong>Module:stop(State)</strong> is called.</p><h2>Module:stop(State)</h2><p>Clean up after termination of an application.</p><ul><li><span class="v">State = term()</span></li></ul><p>This function is called whenever an application has stopped.
It is intended to be the opposite of <strong>Module:start/2</strong>
and is to do any necessary cleaning up. The return value is
ignored.</p><p><strong>State</strong> is the return value of <strong>Module:prep_stop/1</strong>,
if such a function exists. Otherwise <strong>State</strong> is taken from
the return value of <strong>Module:start/2</strong>.</p><h2>Module:config_change(Changed, New, Removed) -&gt; ok</h2><p>Update the configuration parameters for an application.</p><ul><li><span class="v">Changed = [{Par,Val}]</span></li><li><span class="v">New = [{Par,Val}]</span></li><li><span class="v">Removed = [Par]</span></li><li><span class="v">Â Par = atom()</span></li><li><span class="v">Â Val = term()</span></li></ul><p>This function is called by an application after a code
replacement, if the configuration parameters have changed.</p><p><strong>Changed</strong> is a list of parameter-value tuples including all
configuration parameters with changed values.</p><p><strong>New</strong> is a list of parameter-value tuples including all
added configuration parameters.</p><p><strong>Removed</strong> is a list of all removed parameters.</p><h2>See Also</h2><p><a href="./des_princ">OTP Design Principles</a>,
<a href="kernel_app">kernel(6)</a>,
<a href="app">app(4)</a></p></body></html>