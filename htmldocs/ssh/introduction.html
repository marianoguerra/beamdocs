<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Introduction</h1><p>SSH is a protocol for secure remote logon and
other secure network services over an insecure network.</p><h2>Scope and Purpose</h2><p>SSH provides a single, full-duplex, and byte-oriented connection between
client and server. The protocol also provides privacy, integrity,
server authentication, and man-in-the-middle protection.</p><p>The <strong>ssh</strong> application is an implementation of the SSH Transport, Connection and Authentication
Layer Protocols in Erlang. It provides the following:</p><ul><li>API functions to write customized SSH clients and servers applications</li><li>The Erlang shell available over SSH</li><li>An SFTP client (<a href="ssh_sftp">ssh_sftp</a>) and server (<a href="ssh_sftp">ssh_sftpd</a>)</li></ul><h2>Prerequisites</h2><p>It is assumed that the reader is familiar with the Erlang programming language,
concepts of <em>OTP</em>, and has a basic understanding of <em>public keys</em>.</p><h2>SSH Protocol Overview</h2><p>Conceptually, the SSH protocol can be partitioned into four
layers:</p><img src="SSH_protocols.png" title="SSH Protocol Architecture"></img><h2>Transport Protocol</h2><p>The SSH Transport Protocol is a secure, low-level transport.
It provides strong encryption, cryptographic host
authentication, and integrity protection. A minimum of
Message Authentication Code (MAC) and encryption
algorithms are supported. For details, see the
<a href="ssh">ssh(3)</a> manual page in <strong>ssh</strong>.</p><h2>Authentication Protocol</h2><p>The SSH Authentication Protocol is a general-purpose user
authentication protocol run over the SSH Transport Layer
Protocol. The <strong>ssh</strong> application supports user authentication as follows:
</p><ul><li> Using public key technology. RSA and DSA, X509-certificates are not supported. </li><li> Using keyboard-interactive authentication. This is suitable for interactive authentication methods that do not need any special software support on the client side. Instead, all authentication data is entered from the keyboard. </li><li> Using a pure password-based authentication scheme. Here, the plain text password is encrypted before sent over the network. </li></ul><p>Several configuration options for
authentication handling are available in
<a href="./ssh#connect-3">ssh:connect/[3,4]</a>
and <a href="./ssh#daemon-2">ssh:daemon/[2,3]</a>.</p><p>
The public key handling can be customized by implementing
the following behaviours from <strong>ssh</strong>:</p><ul><li>Module <a href="ssh_client_key_api">ssh_client_key_api</a>. </li><li>Module <a href="ssh_server_key_api">ssh_server_key_api</a>. </li></ul><h2>Connection Protocol</h2><p>The SSH Connection Protocol provides application-support
services over the transport pipe, for example, channel multiplexing,
flow control, remote program execution, signal propagation, and
connection forwarding. Functions for handling the SSH
Connection Protocol can be found in the module <a href="ssh_connection">ssh_connection</a> in <strong>ssh</strong>.
</p><h2>Channels</h2><p>All terminal sessions, forwarded connections, and so on, are
channels. Multiple channels are multiplexed into a single
connection. All channels are flow-controlled. This means that no
data is sent to a channel peer until a message is received to
indicate that window space is available.
The <em>initial window size</em> specifies how many bytes of channel
data that can be sent to the channel peer without adjusting the
window. Typically, an SSH client opens a channel, sends data (commands),
receives data (control information), and then closes the channel.
The <a href="ssh_client_channel">ssh_client_channel</a> behaviour
handles generic parts of SSH channel management. This makes it easy
to write your own SSH client/server processes that use flow-control
and thus opens for more focus on the application logic.
</p><p>Channels come in the following three flavors:</p><ul><li><em>Subsystem</em> - Named services that can be run as part of an SSH server, such as SFTP <a href="ssh_sftpd">(ssh_sftpd)</a>, that is built into the SSH daemon (server) by default, but it can be disabled. The Erlang <strong>ssh</strong> daemon can be configured to run any Erlang- implemented SSH subsystem. </li><li><em>Shell</em> - Interactive shell. By default the Erlang daemon runs the Erlang shell. The shell can be customized by providing your own read-eval-print loop. You can also provide your own Command-Line Interface (CLI) implementation, but that is much more work. </li><li><em>Exec</em> - One-time remote execution of commands. See function <a href="./ssh_connection#exec-4">ssh_connection:exec/4</a> for more information.</li></ul><h2>Where to Find More Information</h2><p>
For detailed information about the SSH protocol, refer to the
following Request for Comments(RFCs):
</p><ul><li><a href="http://www.ietf.org/rfc/rfc4250.txt">RFC 4250</a> - Protocol Assigned Numbers</li><li><a href="http://www.ietf.org/rfc/rfc4251.txt">RFC 4251</a> - Protocol Architecture</li><li><a href="http://www.ietf.org/rfc/rfc4252.txt">RFC 4252</a> - Authentication Protocol</li><li><a href="http://www.ietf.org/rfc/rfc4253.txt">RFC 4253</a> - Transport Layer Protocol</li><li><a href="http://www.ietf.org/rfc/rfc4254.txt">RFC 4254</a> - Connection Protocol</li><li><a href="http://www.ietf.org/rfc/rfc4344.txt">RFC 4344</a> - Transport Layer Encryption Modes</li><li><a href="http://www.ietf.org/rfc/rfc4716.txt">RFC 4716</a> - Public Key File Format</li></ul></body></html>