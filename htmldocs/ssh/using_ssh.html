<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Getting Started</h1><h2>General Information</h2><p>The following examples use the utility function
<a href="./ssh#start-0"> ssh:start/0</a> to start
all needed applications (<strong>crypto</strong>, <strong>public_key</strong>, and <strong>ssh</strong>).
All examples are run in an Erlang shell, or in a bash shell, using <em>openssh</em>
to illustrate how the <strong>ssh</strong> application can be used. The
examples are run as the user <strong>otptest</strong> on a local network where the
user is authorized to log in over <strong>ssh</strong> to the host <em>tarlop</em>.
</p><p>If nothing else is stated, it is presumed that the <strong>otptest</strong> user
has an entry in the <em>authorized_keys</em> file of <em>tarlop</em>
(allowed to log in over <strong>ssh</strong> without entering a password).
Also, <em>tarlop</em> is a known host in the <strong>known_hosts</strong>
file of the user <strong>otptest</strong>. This means that host-verification
can be done without user-interaction.
</p><h2>Using the Erlang ssh Terminal Client</h2><p>The user <strong>otptest</strong>, which has bash as default shell, uses the
<strong>ssh:shell/1</strong> client to connect to the <em>openssh</em> daemon running on a
host called <em>tarlop</em>:</p><pre><code class="erl">
      1&gt;  ssh:start().
      ok
      2&gt; {ok, S} = ssh:shell("tarlop").
      otptest@tarlop:&gt; pwd
      /home/otptest
      otptest@tarlop:&gt; exit
      logout
      3&gt;
    </code></pre><a name="Running an Erlang ssh Daemon"></a><h2>Running an Erlang ssh Daemon</h2><p>The
<a href="./ssh_file#type-system_dir_daemon_option">ssh_file#type-system_dir_daemon_option</a>
option must be a directory containing a host key file and it defaults to <strong>/etc/ssh</strong>.
For details, see Section Configuration Files in <a href="SSH_app">ssh(6)</a>.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Normally, the <strong>/etc/ssh</strong> directory is only readable by root.</p></div><p>The option <a href="./ssh_file#type-user_dir_common_option">ssh_file#type-user_dir_common_option</a>
defaults to directory <strong>users ~/.ssh</strong>.</p><p><em>Step 1.</em> To run the example without root privileges,
generate new keys and host keys:</p><pre><code class="">
      $bash&gt; ssh-keygen -t rsa -f /tmp/ssh_daemon/ssh_host_rsa_key
      [...]
      $bash&gt; ssh-keygen -t rsa -f /tmp/otptest_user/.ssh/id_rsa
      [...]
    </code></pre><p><em>Step 2.</em> Create the file <strong>/tmp/otptest_user/.ssh/authorized_keys</strong>
and add the content of <strong>/tmp/otptest_user/.ssh/id_rsa.pub</strong>.</p><p><em>Step 3.</em> Start the Erlang <strong>ssh</strong> daemon:</p><pre><code class="erl">
      1&gt; ssh:start().
      ok
      2&gt; {ok, Sshd} = ssh:daemon(8989, [{system_dir, "/tmp/ssh_daemon"},
                                        {user_dir, "/tmp/otptest_user/.ssh"}]).
      {ok,&lt;0.54.0&gt;}
      3&gt;
    </code></pre><p><em>Step 4.</em> Use the <em>openssh</em> client from a shell to connect
to the Erlang <strong>ssh</strong> daemon:</p><pre><code class="">
      $bash&gt; ssh tarlop -p 8989  -i /tmp/otptest_user/.ssh/id_rsa\
             -o UserKnownHostsFile=/tmp/otptest_user/.ssh/known_hosts
      The authenticity of host 'tarlop' can't be established.
      RSA key fingerprint is 14:81:80:50:b1:1f:57:dd:93:a8:2d:2f:dd:90:ae:a8.
      Are you sure you want to continue connecting (yes/no)? yes
      Warning: Permanently added 'tarlop' (RSA) to the list of known hosts.
      Eshell V5.10  (abort with ^G)
      1&gt;
    </code></pre><p>There are two ways of shutting down an <strong>ssh</strong> daemon,
see <em>Step 5a</em> and <em>Step 5b</em>.</p><p><em>Step 5a.</em> Shut down the Erlang <strong>ssh</strong> daemon so that it
stops the listener but leaves existing connections, started by the listener,
operational:</p><pre><code class="erl">
      3&gt; ssh:stop_listener(Sshd).
      ok
      4&gt;
    </code></pre><p><em>Step 5b.</em> Shut down the Erlang <strong>ssh</strong> daemon so that it
stops the listener and all connections started by the listener:</p><pre><code class="erl">
      3&gt; ssh:stop_daemon(Sshd)
      ok
      4&gt;
    </code></pre><h2>One-Time Execution</h2><p>In the following example, the Erlang shell is the client process
that receives the channel replies.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The number of received messages in this example depends on which OS
and which shell that is used on the machine running the <strong>ssh</strong> daemon.
See also <a href="./ssh_connection#exec-4">ssh_connection:exec/4</a>.
</p></div><p>Do a one-time execution of a remote command over <strong>ssh</strong>:</p><pre><code class="erl">
      1&gt;  ssh:start().
      ok
      2&gt; {ok, ConnectionRef} = ssh:connect("tarlop", 22, []).
      {ok,&lt;0.57.0&gt;}
      3&gt;{ok, ChannelId} =  ssh_connection:session_channel(ConnectionRef, infinity).
      {ok,0}
      4&gt; success = ssh_connection:exec(ConnectionRef, ChannelId, "pwd", infinity).
      5&gt;  flush().
      Shell got {ssh_cm,&lt;0.57.0&gt;,{data,0,0,&lt;&lt;"/home/otptest\n"&gt;&gt;}}
      Shell got {ssh_cm,&lt;0.57.0&gt;,{eof,0}}
      Shell got {ssh_cm,&lt;0.57.0&gt;,{exit_status,0,0}}
      Shell got {ssh_cm,&lt;0.57.0&gt;,{closed,0}}
      ok
      6&gt;
    </code></pre><p>Notice that only the channel is closed. The connection is still up and can
handle other channels:</p><pre><code class="erl">
      6&gt; {ok, NewChannelId} =  ssh_connection:session_channel(ConnectionRef, infinity).
        {ok,1}
	...
    </code></pre><h2>SFTP Server</h2><p>Start the Erlang <strong>ssh</strong> daemon with the SFTP subsystem:</p><pre><code class="erl">
      1&gt; ssh:start().
      ok
      2&gt; ssh:daemon(8989, [{system_dir, "/tmp/ssh_daemon"},
                           {user_dir, "/tmp/otptest_user/.ssh"},
                           {subsystems, [ssh_sftpd:subsystem_spec([{cwd, "/tmp/sftp/example"}])
                                        ]}]).
      {ok,&lt;0.54.0&gt;}
      3&gt;
    </code></pre><p>Run the OpenSSH SFTP client:</p><pre><code class="erl">
      $bash&gt; sftp -oPort=8989 -o IdentityFile=/tmp/otptest_user/.ssh/id_rsa\
             -o UserKnownHostsFile=/tmp/otptest_user/.ssh/known_hosts tarlop
      Connecting to tarlop...
      sftp&gt; pwd
      Remote working directory: /tmp/sftp/example
      sftp&gt;
    </code></pre><h2>SFTP Client</h2><p>Fetch a file with the Erlang SFTP client:</p><pre><code class="erl">
      1&gt; ssh:start().
      ok
      2&gt; {ok, ChannelPid, Connection} = ssh_sftp:start_channel("tarlop", []).
      {ok,&lt;0.57.0&gt;,&lt;0.51.0&gt;}
      3&gt;  ssh_sftp:read_file(ChannelPid, "/home/otptest/test.txt").
      {ok,&lt;&lt;"This is a test file\n"&gt;&gt;}
    </code></pre><h2>SFTP Client with TAR Compression and Encryption</h2><p>Example of writing and then reading a tar file follows:</p><pre><code class="erl">
      {ok,HandleWrite} = ssh_sftp:open_tar(ChannelPid, ?tar_file_name, [write]),
      ok = erl_tar:add(HandleWrite, .... ),
      ok = erl_tar:add(HandleWrite, .... ),
      ...
      ok = erl_tar:add(HandleWrite, .... ),
      ok = erl_tar:close(HandleWrite),

      %% And for reading
      {ok,HandleRead} = ssh_sftp:open_tar(ChannelPid, ?tar_file_name, [read]),
      {ok,NameValueList} = erl_tar:extract(HandleRead,[memory]),
      ok = erl_tar:close(HandleRead),
    </code></pre><p>The previous write and read example can be extended with encryption and decryption as follows:</p><pre><code class="erl">
%% First three parameters depending on which crypto type we select:
Key = &lt;&lt;"This is a 256 bit key. abcdefghi"&gt;&gt;,
Ivec0 = crypto:strong_rand_bytes(16),
DataSize = 1024,  % DataSize rem 16 = 0 for aes_cbc

%% Initialization of the CryptoState, in this case it is the Ivector.
InitFun = fun() -&gt; {ok, Ivec0, DataSize} end,

%% How to encrypt:
EncryptFun =
    fun(PlainBin,Ivec) -&gt;
        EncryptedBin = crypto:block_encrypt(aes_cbc256, Key, Ivec, PlainBin),
        {ok, EncryptedBin, crypto:next_iv(aes_cbc,EncryptedBin)}
    end,

%% What to do with the very last block:
CloseFun =
    fun(PlainBin, Ivec) -&gt;
        EncryptedBin = crypto:block_encrypt(aes_cbc256, Key, Ivec,
                                            pad(16,PlainBin) %% Last chunk
                                           ),
       {ok, EncryptedBin}
    end,

Cw = {InitFun,EncryptFun,CloseFun},
{ok,HandleWrite} = ssh_sftp:open_tar(ChannelPid, ?tar_file_name, [write,{crypto,Cw}]),
ok = erl_tar:add(HandleWrite, .... ),
ok = erl_tar:add(HandleWrite, .... ),
...
ok = erl_tar:add(HandleWrite, .... ),
ok = erl_tar:close(HandleWrite),

%% And for decryption (in this crypto example we could use the same InitFun
%% as for encryption):
DecryptFun =
    fun(EncryptedBin,Ivec) -&gt;
        PlainBin = crypto:block_decrypt(aes_cbc256, Key, Ivec, EncryptedBin),
       {ok, PlainBin, crypto:next_iv(aes_cbc,EncryptedBin)}
    end,

Cr = {InitFun,DecryptFun},
{ok,HandleRead} = ssh_sftp:open_tar(ChannelPid, ?tar_file_name, [read,{crypto,Cw}]),
{ok,NameValueList} = erl_tar:extract(HandleRead,[memory]),
ok = erl_tar:close(HandleRead),
    </code></pre><a name="usersguide_creating_a_subsystem"></a><h2>Creating a Subsystem</h2><p>A small <strong>ssh</strong> subsystem that echoes N bytes can be implemented as shown
in the following example:</p><pre><code class="erl">
-module(ssh_echo_server).
-behaviour(ssh_server_channel). % replaces ssh_daemon_channel
-record(state, {
	  n,
	  id,
	  cm
	 }).
-export([init/1, handle_msg/2, handle_ssh_msg/2, terminate/2]).

init([N]) -&gt;
    {ok, #state{n = N}}.

handle_msg({ssh_channel_up, ChannelId, ConnectionManager}, State) -&gt;
    {ok, State#state{id = ChannelId,
		     cm = ConnectionManager}}.

handle_ssh_msg({ssh_cm, CM, {data, ChannelId, 0, Data}}, #state{n = N} = State) -&gt;
    M = N - size(Data),
    case M &gt; 0 of
	true -&gt;
	   ssh_connection:send(CM, ChannelId, Data),
	   {ok, State#state{n = M}};
	false -&gt;
	   &lt;&lt;SendData:N/binary, _/binary&gt;&gt; = Data,
           ssh_connection:send(CM, ChannelId, SendData),
           ssh_connection:send_eof(CM, ChannelId),
	   {stop, ChannelId, State}
    end;
handle_ssh_msg({ssh_cm, _ConnectionManager,
		{data, _ChannelId, 1, Data}}, State) -&gt;
    error_logger:format(standard_error, " ~p~n", [binary_to_list(Data)]),
    {ok, State};

handle_ssh_msg({ssh_cm, _ConnectionManager, {eof, _ChannelId}}, State) -&gt;
    {ok, State};

handle_ssh_msg({ssh_cm, _, {signal, _, _}}, State) -&gt;
    %% Ignore signals according to RFC 4254 section 6.9.
    {ok, State};

handle_ssh_msg({ssh_cm, _, {exit_signal, ChannelId, _, _Error, _}},
	       State) -&gt;
    {stop, ChannelId,  State};

handle_ssh_msg({ssh_cm, _, {exit_status, ChannelId, _Status}}, State) -&gt;
    {stop, ChannelId, State}.

terminate(_Reason, _State) -&gt;
    ok.
 </code></pre><p>The subsystem can be run on the host <em>tarlop</em> with the generated keys,
as described in Section <a href="#Running an Erlang ssh Daemon"> Running an Erlang ssh Daemon</a>:</p><pre><code class="erl">
   1&gt; ssh:start().
   ok
   2&gt; ssh:daemon(8989, [{system_dir, "/tmp/ssh_daemon"},
                        {user_dir, "/tmp/otptest_user/.ssh"}
                        {subsystems, [{"echo_n", {ssh_echo_server, [10]}}]}]).
   {ok,&lt;0.54.0&gt;}
   3&gt;
 </code></pre><pre><code class="erl">
   1&gt; ssh:start().
   ok
   2&gt;{ok, ConnectionRef} = ssh:connect("tarlop", 8989, [{user_dir, "/tmp/otptest_user/.ssh"}]).
    {ok,&lt;0.57.0&gt;}
   3&gt;{ok, ChannelId} = ssh_connection:session_channel(ConnectionRef, infinity).
   4&gt; success = ssh_connection:subsystem(ConnectionRef, ChannelId, "echo_n", infinity).
   5&gt; ok = ssh_connection:send(ConnectionRef, ChannelId, "0123456789", infinity).
   6&gt; flush().
   {ssh_msg, &lt;0.57.0&gt;, {data, 0, 1, "0123456789"}}
   {ssh_msg, &lt;0.57.0&gt;, {eof, 0}}
   {ssh_msg, &lt;0.57.0&gt;, {closed, 0}}
   7&gt; {error, closed} = ssh_connection:send(ConnectionRef, ChannelId, "10", infinity).
 </code></pre><p>See also <a href="ssh_client_channel">ssh_client_channel(3)</a> (replaces ssh_channel(3)).</p></body></html>