<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>ssh_connection</h1><h1>ssh_connection</h1><p>
    This module provides API functions to send SSH Connection Protocol 
    events to the other side of an SSH channel.
</p><p>The <a href="http://www.ietf.org/rfc/rfc4254.txt">SSH Connection Protocol</a> 
is used by clients and servers, that is, SSH channels, to communicate over the 
SSH connection. The API functions in this module send SSH Connection Protocol events,
which are received as messages by the remote channel.
If the receiving channel is an Erlang process, the
messages have the format
<strong>{ssh_cm, connection_ref(), ssh_event_msg()}</strong>.
If the <a href="ssh_client_channel">ssh_client_channel</a> behavior is used to
implement the channel process, these messages are handled by
<a href="./ssh_client_channel#Module:handle_ssh_msg-2">handle_ssh_msg/2</a>.</p><h2>DATA TYPES</h2><p>Type definitions that are used more than once in this module,
or abstractions to indicate the intended use of the data
type, or both:</p><dl><dt><strong>boolean() =</strong></dt><dd><p><strong>true | false </strong></p></dd><dt><strong>string() =</strong></dt><dd><p>list of ASCII characters</p></dd><dt><strong>timeout() =</strong></dt><dd><p><strong>infinity | integer()</strong> in milliseconds</p></dd><dt><strong>connection_ref() =</strong></dt><dd><p>opaque() -as returned by
<strong>ssh:connect/3</strong> or sent to an SSH channel processes</p></dd><dt><strong>channel_id() =</strong></dt><dd><p><strong>integer()</strong></p></dd><dt><strong>ssh_data_type_code() =</strong></dt><dd><p><strong>1</strong> ("stderr") | <strong>0</strong> ("normal") are
valid values, see
<a href="http://www.ietf.org/rfc/rfc4254.txt">RFC 4254</a> Section 5.2.</p></dd><dt><strong>ssh_request_status() =</strong></dt><dd><p> <strong>success | failure</strong></p></dd><dt><strong>event() =</strong></dt><dd><p><strong>{ssh_cm, connection_ref(), ssh_event_msg()}</strong></p></dd><dt><strong>ssh_event_msg() =</strong></dt><dd><p><strong>data_events() | status_events() | terminal_events()</strong></p></dd><dt><strong>reason() =</strong></dt><dd><p><strong>timeout | closed</strong></p></dd></dl><dl><dt><em>data_events()</em></dt><dd> <dl><dt><strong>{data, channel_id(), ssh_data_type_code(), Data :: binary()}</strong></dt><dd><p>Data has arrived on the channel. This event is sent as a
result of calling <a href="./ssh_connection#send-3"> ssh_connection:send/[3,4,5]</a>.</p></dd><dt><strong>{eof, channel_id()}</strong></dt><dd><p>Indicates that the other side sends no more data.
This event is sent as a result of calling <a href="./ssh_connection#send_eof-2"> ssh_connection:send_eof/2</a>.
</p></dd></dl> </dd><dt><em>status_events()</em></dt><dd> <dl><dt><strong>{signal, channel_id(), ssh_signal()}</strong></dt><dd><p>A signal can be delivered to the remote process/service
using the following message. Some systems do not support
signals, in which case they are to ignore this message. There is
currently no function to generate this event as the signals
referred to are on OS-level and not something generated by an
Erlang program.</p></dd><dt><strong>{exit_signal, channel_id(), ExitSignal :: string(), ErrorMsg ::string(), LanguageString :: string()}</strong></dt><dd><p>A remote execution can terminate violently because of a signal.
Then this message can be received. For details on valid string
values, see <a href="http://www.ietf.org/rfc/rfc4254.txt">RFC 4254</a>
Section 6.10, which shows a special case of these signals.</p></dd><dt><strong>{exit_status, channel_id(), ExitStatus :: integer()}</strong></dt><dd><p>When the command running at the other end terminates, the
following message can be sent to return the exit status of the
command. A zero <strong>exit_status</strong> usually means that the command
terminated successfully. This event is sent as a result of calling
<a href="./ssh_connection#exit_status-3"> ssh_connection:exit_status/3</a>.</p></dd><dt><strong>{closed, channel_id()}</strong></dt><dd><p>This event is sent as a result of calling
<a href="./ssh_connection#close-2">ssh_connection:close/2</a>.
Both the handling of this event and sending it are taken care of by the
<a href="ssh_client_channel">ssh_client_channel</a> behavior.</p></dd></dl> </dd><dt><em>terminal_events()</em></dt><dd> <p>Channels implementing a shell and command execution on the
server side are to handle the following messages that can be sent by client-
channel processes.</p> <p>Events that include a <strong>WantReply</strong> expect the event handling
process to call <a href="./ssh_connection#reply_request-4"> ssh_connection:reply_request/4</a>
with the boolean value of <strong>WantReply</strong> as the second argument.</p> <dl><dt><strong>{env, channel_id(), WantReply :: boolean(), Var ::string(), Value :: string()}</strong></dt><dd><p>Environment variables can be passed to the shell/command
to be started later. This event is sent as a result of calling <a href="./ssh_connection#setenv-5"> ssh_connection:setenv/5</a>.
</p></dd><dt><strong>{pty, channel_id(), WantReply :: boolean(), {Terminal :: string(), CharWidth :: integer(), RowHeight :: integer(), PixelWidth :: integer(), PixelHeight :: integer(), TerminalModes :: [{Opcode  :: atom() | integer(), Value :: integer()}]}}</strong></dt><dd><p>A pseudo-terminal has been requested for the
session. <strong>Terminal</strong> is the value of the TERM environment
variable value, that is, <strong>vt100</strong>. Zero dimension parameters must
be ignored. The character/row dimensions override the pixel
dimensions (when non-zero). Pixel dimensions refer to the
drawable area of the window. <strong>Opcode</strong> in the
<strong>TerminalModes</strong> list is the mnemonic name, represented
as a lowercase Erlang atom, defined in
<a href="http://www.ietf.org/rfc/rfc4254.txt">RFC 4254</a>, Section 8.
It can also be an <strong>Opcode</strong> if the mnemonic name is not listed in the
RFC. Example: <strong>OP code: 53, mnemonic name ECHO erlang atom: echo</strong>. This event is sent as a result of calling <a href="./ssh_connection#ptty_alloc/4">ssh_connection:ptty_alloc/4</a>.</p></dd><dt><strong>{shell, WantReply :: boolean()}</strong></dt><dd><p>This message requests that the user default shell
is started at the other end. This event is sent as a result of calling
<a href="./ssh_connection#shell-2"> ssh_connection:shell/2</a>.
</p></dd><dt><strong>{window_change, channel_id(), CharWidth() :: integer(), RowHeight :: integer(), PixWidth :: integer(), PixHeight :: integer()}</strong></dt><dd><p>When the window (terminal) size changes on the client
side, it <em>can</em> send a message to the server side to inform it of
the new dimensions. No API function generates this event.</p></dd><dt><strong>{exec, channel_id(), WantReply :: boolean(), Cmd :: string()}</strong></dt><dd><p>This message requests that the server starts
execution of the given command. This event is sent as a result of calling <a href="./ssh_connection#exec-4">ssh_connection:exec/4 </a>.
</p></dd></dl> </dd></dl><h1>Functions</h1><h2>adjust_window(ConnectionRef, ChannelId, NumOfBytes) -&gt; ok</h2><p>Adjusts the SSH flow control window.</p><ul><li><span class="v">ConnectionRef = connection_ref()</span></li><li><span class="v">ChannelId = channel_id()</span></li><li><span class="v">NumOfBytes = integer()</span></li></ul><p>Adjusts the SSH flow control window. This is to be done by both the
client- and server-side channel processes.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Channels implemented with the <a href="ssh_client_channel"> ssh_client_channel</a>
behavior do not normally need to call this function as flow control
is handled by the behavior. The behavior adjusts the window every time
the callback <a href="./ssh_client_channel#Module:handle_ssh_msg-2"> handle_ssh_msg/2</a> returns after processing channel data.</p></div><h2>close(ConnectionRef, ChannelId) -&gt; ok</h2><p>Sends a close message on the channel <strong>ChannelId</strong>.</p><ul><li><span class="v">ConnectionRef = connection_ref()</span></li><li><span class="v">ChannelId = channel_id()</span></li></ul><p>A server- or client-channel process can choose to close their session by
sending a close event.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is called by the <strong>ssh_client_channel</strong>
behavior when the channel is terminated, see <a href="ssh_client_channel"> ssh_client_channel(3)</a>. Thus, channels implemented
with the behavior are not to call this function explicitly.</p></div><h2>exec(ConnectionRef, ChannelId, Command, TimeOut) -&gt; ssh_request_status() |
     {error, reason()}</h2><p>Requests that the server starts the execution of the given command.</p><ul><li><span class="v">ConnectionRef = connection_ref()</span></li><li><span class="v">ChannelId = channel_id()</span></li><li><span class="v">Command = string()</span></li><li><span class="v">Timeout = timeout()</span></li></ul><p>Is to be called by a client-channel process to request that the server starts
executing the given command. The result is several messages according to the
following pattern. The last message is a channel close message, as the <strong>exec</strong>
request is a one-time execution that closes the channel when it is done.</p><dl><dt><strong>N x {ssh_cm, connection_ref(), {data, channel_id(), ssh_data_type_code(), Data :: binary()}}</strong></dt><dd><p>The result of executing the command can be only one line
or thousands of lines depending on the command.</p></dd><dt><strong>0 or 1 x {ssh_cm, connection_ref(), {eof, channel_id()}}</strong></dt><dd><p>Indicates that no more data is to be sent.</p></dd><dt><strong>0 or 1 x {ssh_cm, connection_ref(), {exit_signal, channel_id(), ExitSignal :: string(), ErrorMsg :: string(), LanguageString :: string()}}</strong></dt><dd><p>Not all systems send signals. For details on valid string
values, see RFC 4254, Section 6.10</p></dd><dt><strong>0 or 1 x {ssh_cm, connection_ref(), {exit_status, channel_id(), ExitStatus :: integer()}}</strong></dt><dd><p>It is recommended by the SSH Connection Protocol to send this
message, but that is not always the case.</p></dd><dt><strong>1 x {ssh_cm, connection_ref(), {closed, channel_id()}}</strong></dt><dd><p>Indicates that the <strong>ssh_client_channel</strong> started for the
execution of the command has now been shut down.</p></dd></dl><h2>exit_status(ConnectionRef, ChannelId, Status) -&gt; ok</h2><p>Sends the exit status of a command to the client.</p><ul><li><span class="v">ConnectionRef = connection_ref() </span></li><li><span class="v">ChannelId = channel_id()</span></li><li><span class="v">Status = integer()</span></li></ul><p>Is to be called by a server-channel process to send the exit status of a command
to the client.</p><h2>ptty_alloc(ConnectionRef, ChannelId, Options) -&gt;</h2><h2>ptty_alloc(ConnectionRef, ChannelId, Options, Timeout) -&gt;  &gt; ssh_request_status() |
     {error, reason()}</h2><p>Sends an SSH Connection Protocol <strong>pty_req</strong>, to allocate a pseudo-terminal.</p><ul><li><span class="v">ConnectionRef = connection_ref()</span></li><li><span class="v">ChannelId = channel_id()</span></li><li><span class="v">Options = proplists:proplist()</span></li></ul><p>Sends an SSH Connection Protocol <strong>pty_req</strong>, to allocate a pseudo-terminal.
Is to be called by an SSH client process.</p><p>Options:</p><dl><dt>{term, string()}</dt><dd><p>Defaults to <em>os:getenv("TERM")</em> or <em>vt100</em>
if it is undefined.</p></dd><dt>{width, integer()}</dt><dd><p>Defaults to 80 if <strong>pixel_width</strong> is not defined.</p></dd><dt>{height, integer()}</dt><dd><p>Defaults to 24 if <strong>pixel_height</strong> is not defined.</p></dd><dt>{pixel_width, integer()}</dt><dd><p>Is disregarded if <strong>width</strong> is defined.</p></dd><dt>{pixel_height, integer()}</dt><dd><p>Is disregarded if <strong>height</strong> is defined.</p></dd><dt>{pty_opts, [{posix_atom(), integer()}]}</dt><dd><p>Option can be an empty list. Otherwise, see possible <em>POSIX</em> names
in Section 8 in <a href="http://www.ietf.org/rfc/rfc4254.txt"> RFC 4254</a>.</p> </dd></dl><h2>reply_request(ConnectionRef, WantReply, Status, ChannelId) -&gt; ok</h2><p>Sends status replies to requests that want such replies.</p><ul><li><span class="v">ConnectionRef = connection_ref()</span></li><li><span class="v">WantReply =  boolean()</span></li><li><span class="v">Status = ssh_request_status()</span></li><li><span class="v">ChannelId = channel_id()</span></li></ul><p>Sends status replies to requests where the requester has
stated that it wants a status report, that is, <strong>WantReply = true</strong>.
If <strong>WantReply</strong> is <strong>false</strong>, calling this function becomes a
"noop". Is to be called while handling an SSH Connection
Protocol message containing a <strong>WantReply</strong> boolean value.</p><h2>send(ConnectionRef, ChannelId, Data) -&gt;</h2><h2>send(ConnectionRef, ChannelId, Data, Timeout) -&gt;</h2><h2>send(ConnectionRef, ChannelId, Type, Data) -&gt;</h2><h2>send(ConnectionRef, ChannelId, Type, Data, TimeOut) -&gt;
       ok | {error, timeout} | {error, closed}</h2><p>Sends channel data.</p><ul><li><span class="v">ConnectionRef = connection_ref()</span></li><li><span class="v">ChannelId = channel_id()</span></li><li><span class="v">Data = binary()</span></li><li><span class="v">Type = ssh_data_type_code()</span></li><li><span class="v">Timeout = timeout()</span></li></ul><p>Is to be called by client- and server-channel processes to send data to each other.
</p><p>The function <a href="../ssh/ssh_connection#subsystem/4">subsystem/4</a> and subsequent
calls of <strong>send/3,4,5</strong> must be executed in the same process.
</p><h2>send_eof(ConnectionRef, ChannelId) -&gt; ok | {error, closed}</h2><p>Sends EOF on channel <strong>ChannelId</strong>.</p><ul><li><span class="v">ConnectionRef = connection_ref()</span></li><li><span class="v">ChannelId = channel_id()</span></li></ul><p>Sends EOF on channel <strong>ChannelId</strong>.</p><h2>session_channel(ConnectionRef, Timeout) -&gt;</h2><h2>session_channel(ConnectionRef, InitialWindowSize,
       MaxPacketSize, Timeout) -&gt; {ok, channel_id()} | {error, reason()}</h2><p>Opens a channel for an SSH session.</p><ul><li><span class="v">ConnectionRef = connection_ref()</span></li><li><span class="v">InitialWindowSize = integer()</span></li><li><span class="v">MaxPacketSize = integer()</span></li><li><span class="v">Timeout = timeout()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Opens a channel for an SSH session. The channel id returned from this function
is the id used as input to the other functions in this module.</p><h2>setenv(ConnectionRef, ChannelId, Var, Value, TimeOut) -&gt; ssh_request_status() |
      {error, reason()}</h2><p>Environment variables can be passed to the shell/command to be started later.</p><ul><li><span class="v">ConnectionRef = connection_ref()</span></li><li><span class="v">ChannelId = channel_id()</span></li><li><span class="v">Var = string()</span></li><li><span class="v">Value = string()</span></li><li><span class="v">Timeout = timeout()</span></li></ul><p>Environment variables can be passed before starting the
shell/command. Is to be called by a client channel processes.</p><h2>shell(ConnectionRef, ChannelId) -&gt; ok | failure | {error, closed}
</h2><p>Requests that the user default shell (typically defined in /etc/passwd in Unix systems) is to be executed at the server end.</p><ul><li><span class="v">ConnectionRef = connection_ref()</span></li><li><span class="v">ChannelId = channel_id()</span></li></ul><p>Is to be called by a client channel process to request that the user default
shell (typically defined in /etc/passwd in Unix systems) is executed
at the server end.</p><p>Note: the return value is <strong>ok</strong> instead of <strong>success</strong> unlike in other
functions in this module. This is a fault that was introduced so long ago that
any change would break a large number of existing software.
</p><h2>subsystem(ConnectionRef, ChannelId, Subsystem, Timeout) -&gt; ssh_request_status() |
      {error, reason()}</h2><p>Requests to execute a predefined subsystem on the server.</p><ul><li><span class="v">ConnectionRef = connection_ref()</span></li><li><span class="v">ChannelId = channel_id()</span></li><li><span class="v">Subsystem = string()</span></li><li><span class="v">Timeout = timeout()</span></li></ul><p>Is to be called by a client-channel process for requesting to execute a predefined
subsystem on the server.
</p><p>The function <strong>subsystem/4</strong> and subsequent calls of 
<a href="../ssh/ssh_connection#send/3">send/3,4,5</a> must be executed in the same process.
</p></body></html>