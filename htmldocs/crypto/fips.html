<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>FIPS mode</h1><p>
<a name="fips"></a>
This chapter describes FIPS mode support in the crypto application.
</p><h2>Background</h2><p>OpenSSL can be built to provide FIPS 140-2 validated
cryptographic services. It is not the OpenSSL application that is
validated, but a special software component called the OpenSSL
FIPS Object Module. However applications do not use this Object
Module directly, but through the regular API of the OpenSSL
library.</p><p>The crypto application supports using OpenSSL in FIPS mode. In
this scenario only the validated algorithms provided by the Object
Module are accessible, other algorithms usually available in
OpenSSL (like md5) or implemented in the Erlang code (like SRP)
are disabled.</p><h2>Enabling FIPS mode</h2><ul><li> <p>Build or install the FIPS Object Module and a FIPS enabled
OpenSSL library.</p> <p>You should read and precisely follow the instructions of
the <a href="http://csrc.nist.gov/groups/STM/cmvp/documents/140-1/140sp/140sp1747.pdf">Security Policy</a> and <a href="https://www.openssl.org/docs/fips/UserGuide-2.0.pdf">User Guide</a>.</p> <div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>It is very easy to build a working OpenSSL FIPS
Object Module and library from the source. However it <em>does not</em> qualify as FIPS 140-2 validated if the numerous
restrictions in the Security Policy are not properly
followed.</p></div> </li><li> <p>Configure and build Erlang/OTP with FIPS support:</p> <pre>
$ <span class="input">cd $ERL_TOP</span>
$ <span class="input">./otp_build configure --enable-fips</span>
...
checking for FIPS_mode_set... yes
...
$ <span class="input">make</span>
        </pre> <p>If <strong>FIPS_mode_set</strong> returns <strong>no</strong> the OpenSSL
library is not FIPS enabled and crypto won't support FIPS mode
either.</p> </li><li> <p>Set the <strong>fips_mode</strong> configuration setting of the
crypto application to <strong>true</strong> <em>before loading the crypto module</em>.</p> <p>The best place is in the <strong>sys.config</strong> system
configuration file of the release.</p> </li><li> Start and use the crypto application as usual. However take care to avoid the non-FIPS validated algorithms, they will all throw exception <strong>not_supported</strong>. </li></ul><p>Entering and leaving FIPS mode on a node already running crypto
is not supported. The reason is that OpenSSL is designed to
prevent an application requesting FIPS mode to end up accidentally
running in non-FIPS mode. If entering FIPS mode fails (e.g. the
Object Module is not found or is compromised) any subsequent use
of the OpenSSL API would terminate the emulator.</p><p>An on-the-fly FIPS mode change would thus have to be performed
in a critical section protected from any concurrently running
crypto operations. Furthermore in case of failure all crypto calls
would have to be disabled from the Erlang or nif code. This would
be too much effort put into this not too important feature.</p><h2>Incompatibilities with regular builds</h2><p>The Erlang API of the crypto application is identical
regardless of building with or without FIPS support. However the
nif code internally uses a different OpenSSL API.</p><p>This means that the context (an opaque type) returned from
streaming crypto functions (<strong>hash_(init|update|final)</strong>,
<strong>hmac_(init|update|final)</strong> and
<strong>stream_(init|encrypt|decrypt)</strong>) is different and
incompatible with regular builds when compiling crypto with FIPS
support.</p><h2>Common caveats</h2><p>In FIPS mode non-validated algorithms are disabled. This may
cause some unexpected problems in application relying on
crypto.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Do not try to work around these problems by using
alternative implementations of the missing algorithms! An
application can only claim to be using a FIPS 140-2 validated
cryptographic module if it uses it exclusively for every
cryptographic operation.</p></div><h2>Restrictions on key sizes</h2><p>Although public key algorithms are supported in FIPS mode
they can only be used with secure key sizes. The Security Policy
requires the following minimum values:
</p><dl><dt>RSA</dt><dd>1024 bit</dd><dt>DSS</dt><dd>1024 bit</dd><dt>EC algorithms</dt><dd>160 bit</dd></dl><h2>Restrictions on elliptic curves</h2><p>The Erlang API allows using arbitrary curve parameters, but
in FIPS mode only those allowed by the Security Policy shall be
used.</p><h2>Avoid md5 for hashing</h2><p>Md5 is a popular choice as a hash function, but it is not
secure enough to be validated. Try to use sha instead wherever
possible.</p><p>For exceptional, non-cryptographic use cases one may consider
switching to <strong>erlang:md5/1</strong> as well.</p><h2>Certificates and encrypted keys</h2><p>As md5 is not available in FIPS mode it is only possible to
use certificates that were signed using sha hashing. When
validating an entire certificate chain all certificates
(including the root CA's) must comply with this rule.</p><p>For similar dependency on the md5 and des algorithms most
encrypted private keys in PEM format do not work
either. However, the PBES2 encryption scheme allows the use of
stronger FIPS verified algorithms which is a viable
alternative.</p><h2>SNMP v3 limitations</h2><p>It is only possible to use <strong>usmHMACSHAAuthProtocol</strong> and
<strong>usmAesCfb128Protocol</strong> for authentication and privacy
respectively in FIPS mode. The snmp application however won't
restrict selecting disabled protocols in any way, and using them
would result in run time crashes.</p><h2>TLS 1.2 is required</h2><p>All SSL and TLS versions prior to TLS 1.2 use a combination
of md5 and sha1 hashes in the handshake for various purposes:</p><ul><li>Authenticating the integrity of the handshake messages.</li><li>In the exchange of DH parameters in cipher suites providing non-anonymous PFS (perfect forward secrecy).</li><li>In the PRF (pseud-random function) to generate keying materials in cipher suites not using PFS.</li></ul><p>OpenSSL handles these corner cases in FIPS mode, however the
Erlang crypto and ssl applications are not prepared for them and
therefore you are limited to TLS 1.2 in FIPS mode.</p><p>On the other hand it worth mentioning that at least all
cipher suites that would rely on non-validated algorithms are
automatically disabled in FIPS mode.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Certificates using weak (md5) digests may also cause
problems in TLS. Although TLS 1.2 has an extension for
specifying which type of signatures are accepted, and in FIPS
mode the ssl application will use it properly, most TLS
implementations ignore this extension and simply send whatever
certificates they were configured with.</p></div></body></html>