<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Debugger</h1><h1>Debugger</h1><h4>Scope</h4><p>Debugger is a graphical user interface for the Erlang
interpreter, which can be used for debugging and testing of
Erlang programs. For example, breakpoints can be set, code can be
single-stepped and variable values can be displayed and changed.
</p><p>The Erlang interpreter can also be accessed through the interface
module <a href="int">int</a>.
</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Debugger might at some point
start tracing on the processes that execute the interpreted
code. This means that a conflict occurs if tracing by other
means is started on any of these processes.</p></div><h4>Prerequisites</h4><p>It is assumed that the reader is familiar with the Erlang
programming language.</p><p>Modules to be debugged must include debug information,
for example, <strong>erlc +debug_info MODULE.erl</strong>.</p><h4>Getting Started</h4><p>To use Debugger, the basic steps are as follows:</p><p><em>Step 1.</em> Start Debugger by calling
<strong>debugger:start()</strong>.</p><p>The <a href="#monitor">Monitor window</a> is
displayed with information about all debugged processes,
interpreted modules, and selected options. Initially there are
normally no debugged processes. First, it must be specified which
modules that are to be <em>debugged</em> (also called
<em>interpreted</em>). Proceed as follows:</p><p><em>Step 2.</em> Select <em>Module &gt; Interpret...</em> in the
Monitor window.</p><p>The <a href="#interpret">Interpret Modules window</a>
is displayed.</p><p><em>Step 3.</em> Select the appropriate modules from the Interpret
Dialog window.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Only modules compiled with option <strong>debug_info</strong> set can be
interpreted. Non-interpretable modules are displayed within
parenthesis in the Interpret Modules window.</p></div><p><em>Step 4.</em> In the Monitor window, select
<em>Module &gt; the module to be interpreted &gt; View</em>.</p><p>The contents of the source file is displayed in the
<a href="#view">View Module window</a>.</p><p><em>Step 5.</em> Set the
<a href="#breakpoints">breakpoints</a>, if any.</p><p><em>Step 6.</em> Start the program to be debugged. This is done
the normal way from the Erlang shell.</p><p>All processes executing code in interpreted modules are displayed
in the Monitor window.</p><p><em>Step 7.</em> To <em>attach</em> to one of these processes,
double-click it, or select the process and then choose
<em>Process &gt; Attach</em>. Attaching to a process opens an
<a href="#attach">Attach Process window</a> for this
process.</p><p><em>Step 8.</em> From the Attach Process window, you can control
the process execution, inspect variable values, set breakpoints,
and so on.</p><a name="breakpoints"></a><h4>Breakpoints and Break Dialog Windows</h4><p>Once the appropriate modules are interpreted, breakpoints can
be set at relevant locations in the source code. Breakpoints are
specified on a line basis. When a process reaches a breakpoint,
it stops and waits for commands (<em>Step</em>, <em>Skip</em>,
<em>Continue</em> ...) from the user.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>When a process reaches a breakpoint, only that process is
stopped. Other processes are not affected.</p></div><p>Breakpoints are created and deleted using the <em>Break</em> menu of
either the Monitor window, View Module window, or Attach Process
window.</p><h4>Executable Lines</h4><p>To have an effect, a breakpoint must be set at an
<em>executable line</em>, which is a line of code containing an
executable expression such as a matching or a function call.
A blank line or a line containing a comment, function head, or
pattern in a <strong>case</strong> statement or <strong>receive</strong> statement is not
executable.</p><p>In the following example, lines 2, 4, 6, 8, and 11 are
executable lines:</p><pre>
1: is_loaded(Module,Compiled) -&gt;
2:   case get_file(Module,Compiled) of
3:     {ok,File} -&gt;
4:       case code:which(Module) of
5:         ?TAG -&gt;
6:           {loaded,File};
7:         _ -&gt;
8:           unloaded
9:       end;
10:    false -&gt;
11:      false
12:  end.</pre><h4>Status and Trigger Action</h4><p>A breakpoint can be either <em>active</em> or
<em>inactive</em>. Inactive breakpoints are ignored.</p><p>Each breakpoint has a <em>trigger action</em> that specifies
what is to happen when a process has reached it (and stopped):</p><ul><li><em>Enable</em> - Breakpoint is to remain active (default). </li><li><em>Disable</em> - Breakpoint is to be made inactive.</li><li><em>Delete</em> - Breakpoint is to be deleted.</li></ul><h4>Line Breakpoints</h4><p>A line breakpoint is created at a certain line in a module.</p><img src="images/line_break_dialog.jpg" title="Line Break Dialog Window"></img><p>Right-click the <em>Module</em> entry to open a popup menu from
which the appropriate module can be selected.</p><p>A line breakpoint can also be created (and deleted) by
double-clicking the line when the module is displayed in
the View Module window or Attach Process window.</p><h4>Conditional Breakpoints</h4><p>A conditional breakpoint is created at a certain line in
the module, but a process reaching the breakpoint stops
only if a specified condition is true.</p><p>The condition is specified by the user as a module name
<strong>CModule</strong> and a function name <strong>CFunction</strong>. When a
process reaches the breakpoint,
<strong>CModule:CFunction(Bindings)</strong> is evaluated. If and
only if this function call returns <strong>true</strong>, the process
stops. If the function call returns <strong>false</strong>,
the breakpoint is silently ignored.</p><p><strong>Bindings</strong> is a list of variable bindings. To retrieve the
value of <strong>Variable</strong> (given as an atom), use function
<a href="./int#get_binding/2">int#get_binding/2</a>.
The function returns <strong>unbound</strong> or <strong>{value,Value}</strong>.</p><img src="images/cond_break_dialog.jpg" title="Conditional Break Dialog Window"></img><p>Right-click the <em>Module</em> entry to open a popup menu from
which the appropriate module can be selected.</p><p><em>Example:</em></p><p>A conditional breakpoint calling
<strong>c_test:c_break/1</strong> is added at line 6 in module
<strong>fact</strong>. Each time the breakpoint is reached, the function is
called. When <strong>N</strong> is equal to 3, the function returns
<strong>true</strong> and the process stops.</p><p>Extract from <strong>fact.erl</strong>:</p><pre>
5. fac(0) -&gt; 1;
6. fac(N) when N &gt; 0, is_integer(N) -&gt; N * fac(N-1).</pre><p>Definition of <strong>c_test:c_break/1</strong>:</p><pre>
-module(c_test).
-export([c_break/1]).

c_break(Bindings) -&gt;
    case int:get_binding('N', Bindings) of
        {value, 3} -&gt;
            true;
        _ -&gt;
            false
    end.</pre><h4>Function Breakpoints</h4><p>A function breakpoint is a set of line breakpoints, one at
the first line of each clause in the specified function.</p><img src="images/function_break_dialog.jpg" title="Function Break Dialog Window"></img><p>To open a popup menu from which the appropriate module can be
selected, right-click the <em>Module</em> entry.</p><p>To bring up all functions of the module in the listbox,
click the <em>OK</em> button (or press the <em>Return</em>
or <em>Tab</em> key) when a module name has been specified,.</p><a name="stack_trace"></a><h4>Stack Trace</h4><p>The Erlang emulator keeps track of a <em>stack trace</em>,
information about recent function calls. This information is
used if an error occurs, for example:</p><pre>
1&gt; <span class="input">catch a+1.</span>
{'EXIT',{badarith,[{erlang,'+',[a,1],[]},
                   {erl_eval,do_apply,6,[{file,"erl_eval.erl"},{line,573}]},
                   {erl_eval,expr,5,[{file,"erl_eval.erl"},{line,357}]},
                   {shell,exprs,7,[{file,"shell.erl"},{line,674}]},
                   {shell,eval_exprs,7,[{file,"shell.erl"},{line,629}]},
                   {shell,eval_loop,3,[{file,"shell.erl"},{line,614}]}]}}</pre><p>For details about the stack trace, see section
<a href="./errors">Errors and Error Handling</a>
in the Erlang Reference Manual.</p><p>Debugger emulates the stack trace by keeping track of recently
called interpreted functions. (The real stack trace cannot be
used, as it shows which functions of Debugger have been
called, rather than which interpreted functions.)</p><p>This information can be used to traverse the chain of function
calls, using the <em>Up</em> and <em>Down</em> buttons in the
<a href="#attach">Attach Process window</a>.</p><p>By default, Debugger only saves information about recursive
function calls, that is, function calls that have not yet returned
a value (option <em>Stack On, No Tail</em>).</p><p>Sometimes, however, it can be useful to save all calls, even
tail-recursive calls. This is done with option
<em>Stack On, Tail</em>. Notice that this option consumes more
memory and slows down execution of interpreted functions when there
are many tail-recursive calls.</p><p>To turn off the Debugger stack trace facility, select option
<em>Stack Off</em>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If an error occurs, the stack trace becomes empty in this
case.</p></div><p>For information about how to change the stack trace option, see
section <a href="#monitor">Monitor Window</a>.</p><a name="monitor"></a><h4>Monitor Window</h4><p>The Monitor window is the main window of Debugger and displays the
following:</p><ul><li><p>A listbox containing the names of all interpreted
modules</p> <p>Double-clicking a module brings up the View Module window.</p> </li><li><p>Which options are selected</p></li><li><p>Information about all debugged processes, that is, all
processes that have been or are executing code in interpreted
modules</p></li></ul><img src="images/monitor.jpg" title="Monitor Window"></img><p>The <em>Auto Attach</em> boxes, <em>Stack Trace</em> label,
<em>Back Trace Size</em> label, and <em>Strings</em> box display
some options set. For details about these options, see section
<a href="#options">Options Menu</a>.</p><h4>Process Grid</h4><dl><dt><em>Pid</em></dt><dd><p>The process identifier.</p></dd><dt><em>Initial Call</em></dt><dd><p>The first call to an interpreted function by this
process. (<strong>Module:Function/Arity</strong>)</p></dd><dt><em>Name</em></dt><dd><p>The registered name, if any. If a registered name is not
displayed, it can be that Debugger received information about
the process before the name was registered. Try selecting
<em>Edit &gt; Refresh</em>.</p></dd><dt><em>Status</em></dt><dd><p>The current status, one of the following:</p> <dl><dt><em>idle</em></dt><dd><p>The interpreted function call has returned a value, and
the process is no longer executing interpreted code.</p></dd><dt><em>running</em></dt><dd><p>The process is running.</p></dd><dt><em>waiting</em></dt><dd><p>The process is waiting in a <strong>receive</strong>
statement.</p></dd><dt><em>break</em></dt><dd><p>The process is stopped at a breakpoint.</p></dd><dt><em>exit</em></dt><dd><p>The process has terminated.</p></dd><dt><em>no_conn</em></dt><dd><p>There is no connection to the node where
the process is located.</p></dd></dl> </dd><dt><em>Information</em></dt><dd><p>More information, if any. If the process is
stopped at a breakpoint, the field contains information
about the location <strong>{Module,Line}</strong>. If the process has
terminated, the field contains the exit reason.</p></dd></dl><h4>File Menu</h4><dl><dt><em>Load Settings...</em></dt><dd><p>Tries to load and restore Debugger settings from a file
previously saved using <em>Save Settings...</em> (see below).
Any errors are silently ignored.</p> <p>Notice that settings saved by Erlang/OTP R16B01 or later
cannot be read by Erlang/OTP R16B or earlier.</p> </dd><dt><em>Save Settings...</em></dt><dd><p>Saves Debugger settings to a file. The settings include
the set of interpreted files, breakpoints, and the selected
options. The settings can be restored in a later Debugger
session using <em>Load Settings...</em> (see above).
Any errors are silently ignored.</p> </dd><dt><em>Exit</em></dt><dd><p>Stops Debugger.</p></dd></dl><h4>Edit Menu</h4><dl><dt><em>Refresh</em></dt><dd><p>Updates information about debugged processes. Information
about all terminated processes are removed from the window. All
Attach Process windows for terminated processes are closed.</p></dd><dt><em>Kill All</em></dt><dd><p>Terminates all processes listed in the window using
<strong>exit(Pid,kill)</strong>.</p></dd></dl><h4>Module Menu</h4><dl><dt><em>Interpret...</em></dt><dd><p>Opens the
<a href="#interpret">Interpret Modules window</a>,
where new modules to be interpreted can be specified.</p></dd><dt><em>Delete All</em></dt><dd><p>Stops interpreting all modules. Processes executing in
interpreted modules terminate.</p></dd></dl><p>For each interpreted module, a corresponding entry is added to
the <em>Module</em> menu, with the following submenu:</p><dl><dt><em>Delete</em></dt><dd><p>Stops interpreting the selected module. Processes
executing in this module terminate.</p></dd><dt><em>View</em></dt><dd><p>Opens a
<a href="#view">View Module window</a>, displaying the
contents of the selected module.</p></dd></dl><h4>Process Menu</h4><p>The following menu items apply to the currently selected
process, provided it is stopped at a breakpoint (for details, see
section 
<a href="#attach">Attach Process window</a>):</p><dl><dt><em>Step</em></dt><dd></dd><dt><em>Next</em></dt><dd></dd><dt><em>Continue</em></dt><dd></dd><dt><em>Finish</em></dt><dd></dd></dl><p>The following menu items apply to the currently selected
process:</p><dl><dt><em>Attach</em></dt><dd><p>Attaches to the process and open an
<a href="#attach">Attach Process window</a>.</p></dd><dt><em>Kill</em></dt><dd><p>Terminates the process using <strong>exit(Pid,kill)</strong>.</p></dd></dl><h4>Break Menu</h4><p>The items in this menu are used to create and delete breakpoints.
For details, see section
<a href="#breakpoints">Breakpoints</a>.</p><dl><dt><em>Line Break...</em></dt><dd><p>Sets a line breakpoint.</p></dd><dt><em>Conditional Break...</em></dt><dd><p>Sets a conditional breakpoint.</p></dd><dt><em>Function Break...</em></dt><dd><p>Sets a function breakpoint.</p></dd><dt><em>Enable All</em></dt><dd><p>Enables all breakpoints.</p></dd><dt><em>Disable All</em></dt><dd><p>Disables all breakpoints.</p></dd><dt><em>Delete All</em></dt><dd><p>Removes all breakpoints.</p></dd></dl><p>For each breakpoint, a corresponding entry is added to the
<em>Break</em> menu, from which it is possible to disable, enable,
or delete the breakpoint, and to change its trigger action.</p><a name="options"></a><h4>Options Menu</h4><dl><dt><em>Trace Window</em></dt><dd><p>Sets the areas to be visible in an
<a href="#attach">Attach Process window</a>.
Does not affect existing Attach Process windows.</p> </dd><dt><em>Auto Attach</em></dt><dd><p>Sets the events a debugged process is to be attached
to automatically. Affects existing debugged processes.</p> <ul><li><p><em>First Call</em> - The first time a process calls
a function in an interpreted module.</p></li><li><p><em>On Exit</em> - At process termination.</p></li><li><p><em>On Break</em> - When a process reaches a
breakpoint.</p></li></ul> </dd><dt><em>Stack Trace</em></dt><dd><p>Sets the stack trace option, see section
<a href="#stack_trace">Stack Trace</a>. Does not
affect existing debugged processes.</p> <ul><li><p><em>Stack On, Tail</em> - Saves information about all
current calls.</p></li><li><p><em>Stack On, No Tail</em> - Saves information about
current calls, discarding previous information when a tail
recursive call is made.</p></li><li><p><em>Stack Off</em> - Does not save any information about
current calls.</p></li></ul> </dd><dt><em>Strings</em></dt><dd><p>Sets the integer lists to be printed as strings.
Does not affect existing debugged processes.</p> <ul><li><p><em>Use range of +pc flag</em> - Uses the printable
character range set by the <strong>erl(1)</strong> flag
<a href="../erts/erl#printable_character_range">erts/erl#printable_character_range</a>.</p> </li></ul> </dd><dt><em>Back Trace Size...</em></dt><dd><p>Sets how many call frames to be fetched when
inspecting the call stack from the Attach Process window.
Does not affect existing Attach Process windows.</p> </dd></dl><h4>Windows Menu</h4><p>Contains a menu item for each open Debugger window. Selecting
one of the items raises the corresponding window.</p><h4>Help Menu</h4><dl><dt><em>Help</em></dt><dd><p>Shows the Debugger documentation. This function requires a
web browser.</p></dd></dl><a name="interpret"></a><h4>Interpret Modules Window</h4><p>The Interpret Modules window is used for selecting which modules
to interpret. Initially, the window displays the modules (<strong>erl</strong>
files) and subdirectories of the current working directory.</p><p>Interpretable modules are modules for which a <strong>.beam</strong> file,
compiled with option <strong>debug_info</strong> set, is located in the same
directory as the source code, or in an <strong>ebin</strong> directory next
to it.</p><p>Modules for which these requirements are not fulfilled are
not interpretable and are therefore displayed within parentheses.</p><p>Option <strong>debug_info</strong> causes <em>debug information</em> or
<em>abstract code</em> to be added to the <strong>.beam</strong> file.
This increases the file size and makes it possible to
reconstruct the source code. It is therefore recommended not to
include debug information in code aimed for target systems.</p><p>An example of how to compile code with debug information using
<strong>erlc</strong>:</p><pre>
% erlc +debug_info module.erl</pre><p>An example of how to compile code with debug information from
the Erlang shell:</p><pre>
4&gt; c(module, debug_info).</pre><img src="images/interpret.jpg" title="Interpret Modules Window"></img><p>To browse the file hierarchy and interpret the appropriate modules,
either select a module name and click <em>Choose</em> (or
press carriage return), or double-click the module name.
Interpreted modules have the type <strong>erl src</strong>.</p><p>To interpret all displayed modules in the chosen directory, click
<em>All</em>.</p><p>To close the window, click <em>Done</em>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>When Debugger is started in global mode (which is the default, see
<a href="./debugger#start/0">debugger:start/0</a>),
modules added (or deleted) for interpretation are added (or
deleted) on all known Erlang nodes.</p></div><a name="attach"></a><h4>Attach Process Window</h4><p>From an Attach Process window, you can interact with a
debugged process. One window is opened for each process that has
been attached to. Notice that when attaching to a process, its
execution is automatically stopped.</p><img src="images/attach.jpg" title="Attach Process Window"></img><p>The window is divided into the following five parts:</p><ul><li><p>The Code area, displaying the code being executed. The code
is indented and each line is prefixed with its line number.
If the process execution is stopped, the current line is
marked with <strong>--&gt;</strong>. An existing break point at a line
is marked with a stop symbol. In the example shown in the
illustration, the execution stopped at line 6, before
the execution of <strong>fac/1</strong>.</p> <p>Active breakpoints are displayed in red and inactive
breakpoints in blue.</p> </li><li><p>The Button area, with buttons for quick access to frequently
used functions in the <em>Process</em> menu.</p></li><li><p>The Evaluator area, where you can evaluate functions
within the context of the debugged process, if that
process execution is stopped.</p></li><li><p>The Bindings area, displaying all variables bindings. If you
click a variable name, the value is displayed in the Evaluator area.
Double-click a variable name to open a window where
the variable value can be edited. Notice however that pid, port,
reference, or fun
values cannot be edited unless they can be represented in the
running system.</p> </li><li><p>The Trace area, which displays a trace output for the
process.</p> <dl><dt><strong>++ (N) &lt;L&gt;</strong></dt><dd><p>Function call, where <strong>N</strong> is the call level and
<strong>L</strong> the line number.</p></dd><dt><strong>-- (N)</strong></dt><dd><p>Function return value</p>.</dd><dt><strong>==&gt; Pid : Msg</strong></dt><dd><p>The message <strong>Msg</strong> is sent to process
<strong>Pid</strong>.</p></dd><dt><strong>&lt;== Msg</strong></dt><dd><p>The message <strong>Msg</strong> is received.</p></dd><dt><strong>++ (N) receive</strong></dt><dd><p>Waiting in a <strong>receive</strong>.</p></dd><dt><strong>++ (N) receive with timeout</strong></dt><dd><p>Waiting in a <strong>receive...after</strong>.</p></dd></dl> <p>The Trace area also displays Back Trace, a summary of the
current function calls on the stack.</p> </li></ul><p>Using the <em>Options</em> menu, you can set which areas to be
displayed. By default, all areas except the Trace area are displayed.</p><h4>File Menu</h4><dl><dt><em>Close</em></dt><dd><p>Closes this window and detach from the process.</p> </dd></dl><h4>Edit Menu</h4><dl><dt><em>Go to line...</em></dt><dd><p>Goes to a specified line number.</p></dd><dt><em>Search...</em></dt><dd><p>Searches for a specified string.</p></dd></dl><h4>Process Menu</h4><dl><dt><em>Step</em></dt><dd><p>Executes the current code line, stepping into any
(interpreted) function calls.</p></dd><dt><em>Next</em></dt><dd><p>Executes the current code line and stop at the next
line.</p></dd><dt><em>Continue</em></dt><dd><p>Continues the execution.</p></dd><dt><em>Finish</em></dt><dd><p>Continues the execution until the current function
returns.</p></dd><dt><em>Skip</em></dt><dd><p>Skips the current code line and stop at the next
line. If used on the last line in a function body,
the function returns <strong>skipped</strong>.</p></dd><dt><em>Time Out</em></dt><dd><p>Simulates a time-out when executing a
<strong>receive...after</strong> statement.</p></dd><dt><em>Stop</em></dt><dd><p>Stops the execution of a running process, that is, make
the process stop at a breakpoint. The command takes
effect (visibly) the next time the process receives a
message.</p></dd><dt><em>Where</em></dt><dd><p>Verifies that the current location of the execution is
visible in the code area.</p></dd><dt><em>Kill</em></dt><dd><p>Terminates the process using <strong>exit(Pid,kill)</strong>.</p> </dd><dt><em>Messages</em></dt><dd><p>Inspects the message queue of the process. The queue is
displayed in the Evaluator area.</p></dd><dt><em>Back Trace</em></dt><dd><p>Displays the back trace of the process, a summary of
the current function calls on the stack, in the Trace area.
Requires that the Trace area is visible and that the Stack
Trace option is <em>Stack On, Tail</em> or
<em>Stack On, No Tail</em>.</p> </dd><dt><em>Up</em></dt><dd><p>Inspects the previous function call on the stack,
showing the location and variable bindings.</p></dd><dt><em>Down</em></dt><dd><p>Inspects the next function call on the stack, showing
the location and variable bindings.</p></dd></dl><h4>Options Menu</h4><dl><dt><em>Trace Window</em></dt><dd><p>Sets which areas are to be visible. Does not affect
other Attach Process windows.</p></dd><dt><em>Stack Trace</em></dt><dd><p>Same as in the <a href="#monitor">Monitor window</a>, but only affects the debugged
process the window is attached to.</p></dd><dt><em>Strings</em></dt><dd><p>Same as in the <a href="#monitor">Monitor window</a>, but only affects the debugged
process the window is attached to.</p></dd><dt><em>Back Trace Size...</em></dt><dd><p>Sets how many call frames are to be fetched when
inspecting the call stack. Does not affect other Attach
Process windows.</p></dd></dl><h4>Break, Windows, and Help Menus</h4><p>The <em>Break</em>, <em>Windows</em>, and <em>Help</em> menus
are the same as in the
<a href="#monitor">Monitor Window</a>, except
that the <em>Breaks</em> menu applies only to local
breakpoints.</p><a name="view"></a><h4>View Module Window</h4><p>The View Module window displays the contents of an interpreted
module and makes it possible to set breakpoints.</p><img src="images/view.jpg" title="View Module Window"></img><p>The source code is indented and each line is prefixed with its
line number.</p><p>Clicking a line highlights it and selects it to be the target
of the breakpoint functions available from the <em>Break</em> menu.
To set a line breakpoint on a line, double-click it.
To remove the breakpoint, double-click the line with an existing
breakpoint.</p><p>Breakpoints are marked with a stop symbol.</p><h4>File and Edit Menus</h4><p>The <em>File</em> and <em>Edit</em> menus are the same as in the
<a href="#attach">Attach Process Window</a>.</p><h4>Break, Windows, and Help Menus</h4><p>The <em>Break</em>, <em>Windows</em>, and <em>Help</em> menus
are the same as in the
<a href="#monitor">Monitor Window</a>, except
that the <em>Break</em> menu applies only to local breakpoints.</p><h4>Performance</h4><p>Execution of interpreted code is naturally slower than for
regularly compiled modules. Using Debugger also increases
the number of processes in the system, as for each debugged
process another process (the meta process) is created.</p><p>It is also worth to keep in mind that programs with timers can
behave differently when debugged. This is especially true when
stopping the execution of a process (for example, at a
breakpoint). Time-outs can then occur in other processes that
continue execution as normal.</p><h4>Code Loading Mechanism</h4><p>Code loading works almost as usual, except that interpreted
modules are also stored in a database and debugged processes
use only this stored code. Reinterpreting an interpreted
module results in the new version being stored as well, but
does not affect existing processes executing an older version
of the code. This means that the code replacement mechanism of
Erlang does not work for debugged processes.</p><h4>Debugging Remote Nodes</h4><p>By using
<a href="./debugger#start/1">debugger:start/1</a>,
you can specify if Debugger is to be started in local or global
mode:</p><pre>
debugger:start(local | global)</pre><p>If no argument is provided, Debugger starts in global mode.</p><p>In local mode, code is interpreted only at the current node.
In global mode, code is interpreted at all known nodes. Processes
at other nodes executing interpreted code are automatically
displayed in the Monitor window and can be attached to like any other
debugged process.</p><p>It is possible, but definitely not recommended, to start Debugger
in global mode on more than one node in a network, as the nodes
interfere with each other, leading to inconsistent behavior.</p><h3>debugger</h3><p>Erlang Debugger.</p><p>Erlang Debugger for debugging and testing of Erlang programs.</p><h3>Functions</h3><h4>start()</h4><h4>start(File)</h4><h4>start(Mode)</h4><h4>start(Mode, File)</h4><p>Start Debugger.</p><ul><li><span class="v">Mode = local | global</span></li><li><span class="v">File = string()</span></li></ul><p>Starts Debugger.</p><p>If a filename is specified as argument, Debugger tries to load
its settings from this file. For details about settings, see
the User's Guide.</p><p>If <strong>local</strong> is specified as argument, Debugger interprets
code only at the current node. If <strong>global</strong> is specified as
argument, Debugger interprets code at all known nodes, this
is the default.</p><h4>quick(Module, Name, Args)</h4><p>Debug a process.</p><ul><li><span class="v">Module = Name = atom()</span></li><li><span class="v">Args = [term()]</span></li></ul><p>Debugs a single process. The module <strong>Module</strong> is interpreted
and <strong>apply(Module,Name,Args)</strong> is called. This opens an
Attach Process window. For details, see the User's Guide.</p><h3>i</h3><p>Debugger/Interpreter Interface.</p><p>The <strong>i</strong> module provides short forms for some of
the functions used by the graphical Debugger and some of
the functions in module
<a href="int">int</a>, the Erlang interpreter.This module also provides facilities for displaying status
information about interpreted processes and break points.It is possible to attach to interpreted processes by giving
the corresponding process identity only. By default, an attachment
window is displayed. Processes at other Erlang nodes can be
attached manually or automatically.By preference, these functions can be included in module
<a href="./shell_default">stdlib/shell_default</a>.
By default, they are included in that module.</p><h3>Functions</h3><h4>im() -&gt; pid()</h4><p>Start a graphical monitor.</p><p>Starts a new graphical monitor. This is the Monitor window,
the main window of Debugger. All the Debugger and
interpreter functionality is accessed from the Monitor window.
This window displays the status of all processes that 
have been or are executing interpreted modules.</p><h4>ii(AbsModules) -&gt; ok</h4><h4>ii(AbsModule) -&gt; {module, Module} | error</h4><h4>ini(AbsModules) -&gt; ok</h4><h4>ini(AbsModule) -&gt; {module, Module} | error</h4><p>Interpret a module.</p><ul><li><span class="v">AbsModules = [AbsModule]</span></li><li><span class="v">AbsModule = Module | File</span></li><li><span class="v">Â Module = atom()</span></li><li><span class="v">Â File = string()</span></li></ul><p>Interprets the specified module(s). <strong>ii/1</strong> interprets
the module(s) only at the current node, see
<a href="./int#i/1">int:i/1</a>. <strong>ini/1</strong>
interprets the module(s) at all known nodes, see
<a href="./int#ni/1">int:ni/1</a>.</p><h4>iq(AbsModule) -&gt; ok</h4><h4>inq(AbsModule) -&gt; ok</h4><p>Stop interpreting a module.</p><ul><li><span class="v">AbsModule = Module | File</span></li><li><span class="v">Â Module = atom()</span></li><li><span class="v">Â File = string()</span></li></ul><p>Stops interpreting the specified module. <strong>iq/1</strong> stops
interpreting the module only at the current node. <strong>inq/1</strong>
stops interpreting the module at all known nodes.</p><h4>il() -&gt; ok</h4><p>Make a printout of all interpreted modules</p><p>Makes a printout of all interpreted modules.
Modules are printed together with the full path name of the 
corresponding source code file.</p><h4>ip() -&gt; ok</h4><p>Print the current status of all interpreted processes.</p><p>Prints the current status of all interpreted processes.</p><h4>ic() -&gt; ok</h4><p>Clear information about processes executing interpreted code.</p><p>Clears information about processes executing interpreted code
by removing all information about terminated processes.</p><h4>iaa(Flags) -&gt; true</h4><h4>iaa(Flags, Function) -&gt; true</h4><p>Set when and how to attach to a process.</p><ul><li><span class="v">Flags = [init | break | exit]</span></li><li><span class="v">Function = {Module,Name,Args}</span></li><li><span class="v">Â Module = Name = atom()</span></li><li><span class="v">Â Args = [term()]</span></li></ul><p>Sets when and how to attach to a debugged process
automatically, see
<a href="./int#auto_attach/0">int:auto_attach/2</a>.
<strong>Function</strong> defaults to the standard function used by
Debugger.</p><h4>ist(Flag) -&gt; true</h4><p>Set how to save call frames.</p><ul><li><span class="v">Flag = all | no_tail | false</span></li></ul><p>Sets how to save call frames in the stack, see
<a href="./int#stack_trace/0">int:stack_trace/1</a>.</p><h4>ia(Pid) -&gt; ok | no_proc</h4><p>Attache to a process.</p><ul><li><span class="v">Pid = pid()</span></li></ul><p>Attaches to the debugged process <strong>Pid</strong>. An
Attach Process window is opened for the process.</p><h4>ia(X,Y,Z) -&gt; ok | no_proc</h4><p>Attache to a process.</p><ul><li><span class="v">X = Y = Z = int()</span></li></ul><p>Same as <strong>ia(Pid)</strong>, where <strong>Pid</strong> is the result of
calling the shell function <strong>pid(X,Y,Z)</strong>.</p><h4>ia(Pid, Function) -&gt; ok | no_proc</h4><p>Attache to a process.</p><ul><li><span class="v">Pid = pid()</span></li><li><span class="v">Function = {Module,Name}</span></li><li><span class="v">Â Module = Name = atom()</span></li></ul><p>Attaches to the debugged process <strong>Pid</strong>. The interpreter
calls <strong>spawn(Module, Name, [Pid])</strong> (and ignores
the result).</p><h4>ia(X,Y,Z, Function) -&gt; ok | no_proc</h4><p>Attache to a process.</p><ul><li><span class="v">X = Y = Z = int()</span></li><li><span class="v">Function = {Module,Name}</span></li><li><span class="v">Â Module = Name = atom()</span></li></ul><p>Same as <strong>ia(Pid, Function)</strong>, where <strong>Pid</strong> is
the result of calling the shell function <strong>pid(X,Y,Z)</strong>.
An attached process is expected to call the unofficial
function <strong>int:attached(Pid)</strong> and to be able to handle
messages from the interpreter. For an example, see
<strong>dbg_wx_trace.erl</strong>.</p><h4>ib(Module, Line) -&gt; ok | {error, break_exists}</h4><p>Create a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Creates a breakpoint at <strong>Line</strong> in <strong>Module</strong>.</p><h4>ib(Module, Name, Arity) -&gt; ok | {error, function_not_found}
</h4><p>Create breakpoints in the specified function.</p><ul><li><span class="v">Module = Name = atom()</span></li><li><span class="v">Arity = int()</span></li></ul><p>Creates breakpoints at the first line of every clause of 
function <strong>Module:Name/Arity</strong>.</p><h4>ir() -&gt; ok</h4><p>Delete all breakpoints.</p><p>Deletes all breakpoints.</p><h4>ir(Module) -&gt; ok</h4><p>Delete all breakpoints in a module.</p><ul><li><span class="v">Module = atom()</span></li></ul><p>Deletes all breakpoints in <strong>Module</strong>.</p><h4>ir(Module, Line) -&gt; ok</h4><p>Delete a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Deletes the breakpoint at <strong>Line</strong> in <strong>Module</strong>.</p><h4>ir(Module, Name, Arity) -&gt; ok | {error, function_not_found}
</h4><p>Delete breakpoints from the specified function.</p><ul><li><span class="v">Module = Name = atom()</span></li><li><span class="v">Arity = int()</span></li></ul><p>Deletes the breakpoints at the first line of every clause of 
function <strong>Module:Name/Arity</strong>.</p><h4>ibd(Module, Line) -&gt; ok</h4><p>Make a breakpoint inactive.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Makes the breakpoint at <strong>Line</strong> in <strong>Module</strong> inactive.</p><h4>ibe(Module, Line) -&gt; ok</h4><p>Make a breakpoint active.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Makes the breakpoint at <strong>Line</strong> in <strong>Module</strong> active.</p><h4>iba(Module, Line, Action) -&gt; ok</h4><p>Set the trigger action of a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li><li><span class="v">Action = enable | disable | delete</span></li></ul><p>Sets the trigger action of the breakpoint at <strong>Line</strong> in
<strong>Module</strong> to <strong>Action</strong>.</p><h4>ibc(Module, Line, Function) -&gt; ok</h4><p>Set the conditional test of a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li><li><span class="v">Function = {Module,Name}</span></li><li><span class="v">Â Name = atom()</span></li></ul><p>Sets the conditional test of the breakpoint at <strong>Line</strong> in
<strong>Module</strong> to <strong>Function</strong>.</p><p>The conditional test is performed by calling
<strong>Module:Name(Bindings)</strong>, where <strong>Bindings</strong> is
the current variable bindings. The function must return
<strong>true</strong> (break) or <strong>false</strong> (do not break).
To retrieve the value of a variable <strong>Var</strong>, use
<a href="./int#get_binding/2">int:get_binding(Var, Bindings)</a>.</p><h4>ipb() -&gt; ok</h4><p>Print all existing breakpoints.</p><p>Prints all existing breakpoints.</p><h4>ipb(Module) -&gt; ok</h4><p>Print all existing breakpoints in a module.</p><ul><li><span class="v">Module = atom()</span></li></ul><p>Prints all existing breakpoints in <strong>Module</strong>.</p><h4>iv() -&gt; atom()</h4><p>Return the current version number of the interpreter. </p><p>Returns the current version number of the interpreter.
Same as the version number of the Debugger application.</p><h4>help() -&gt; ok</h4><p>Print help text.</p><p>Prints help text.</p><h4>See Also</h4><p><a href="int">int</a></p><h3>int</h3><p>Interpreter Interface.</p><p>The Erlang interpreter provides mechanisms for breakpoints and
stepwise execution of code. It is primarily intended to be used by
Debugger, see the User's Guide and
<a href="debugger">debugger</a>.The following can be done from the shell:<ul><li>Specify the modules to be interpreted.</li><li>Specify breakpoints.</li><li>Monitor the current status of all processes executing code in interpreted modules, also processes at other Erlang nodes. </li></ul>By <em>attaching to</em> a process executing interpreted code, it
is possible to examine variable bindings and order stepwise
execution. This is done by sending and receiving information
to/from the process through a third process, called the meta
process. You can implement your own attached process. See
<strong>int.erl</strong> for available functions and <strong>dbg_wx_trace.erl</strong>
for possible messages.The interpreter depends on the Kernel, STDLIB, and
GS applications. This means that modules belonging to any of
these applications are not allowed to be interpreted, as it could lead
to a deadlock or emulator crash. This also applies to modules
belonging to the Debugger application.</p><a name="int_breakpoints"></a><h4>Breakpoints</h4><p>Breakpoints are specified on a line basis. When a process
executing code in an interpreted module reaches a breakpoint, it
stops. This means that a breakpoint must be set at an
executable line, that is, a code line containing an executable
expression.</p><p>A breakpoint has the following:</p><ul><li>A status, which is <em>active</em> or <em>inactive</em>. An inactive breakpoint is ignored.</li><li>A trigger action. When a breakpoint is reached, the trigger action specifies if the breakpoint is to continue as active (<em>enable</em>), or to become inactive (<em>disable</em>), or to be removed (<em>delete</em>).</li><li>Optionally an associated condition. A condition is a tuple <strong>{Module,Name}</strong>. When the breakpoint is reached, <strong>Module:Name(Bindings)</strong> is called. If it evaluates to <strong>true</strong>, execution stops. If it evaluates to <strong>false</strong>, the breakpoint is ignored. <strong>Bindings</strong> contains the current variable bindings. To retrieve the value for a specified variable, use <strong>get_binding</strong>.</li></ul><p>By default, a breakpoint is active, has trigger action
<strong>enable</strong>, and has no associated condition. For details
about breakpoints, see the User's Guide.</p><h3>Functions</h3><h4>i(AbsModule) -&gt; {module,Module} | error</h4><h4>i(AbsModules) -&gt; ok</h4><h4>ni(AbsModule) -&gt; {module,Module} | error</h4><h4>ni(AbsModules) -&gt; ok</h4><p>Interpret a module.</p><ul><li><span class="v">AbsModules = [AbsModule]</span></li><li><span class="v">AbsModule = Module | File | [Module | File]</span></li><li><span class="v">Â Module = atom()</span></li><li><span class="v">Â File = string()</span></li></ul><p>Interprets the specified module(s). <strong>i/1</strong> interprets
the module only at the current node. <strong>ni/1</strong> interprets
the module at all known nodes.</p><p>A module can be specified by its module name (atom) or
filename.</p><p>If specified by its module name, the object code
<strong>Module.beam</strong> is searched for in the current path.
The source code <strong>Module.erl</strong> is searched for first in
the same directory as the object code, then in an <strong>src</strong>
directory next to it.</p><p>If specified by its filename, the filename can include a path
and the <strong>.erl</strong> extension can  be omitted. The object code
<strong>Module.beam</strong> is searched for first in the same directory
as the source code, then in an <strong>ebin</strong> directory next to
it, and then in the current path.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The interpreter requires both the source code and the object
code. The object code <em>must</em> include debug
information, that is, only modules compiled with option
<strong>debug_info</strong> set can be interpreted.</p></div><p>The functions returns <strong>{module,Module}</strong> if the module
was interpreted, otherwise <strong>error</strong> is returned.</p><p>The argument can also be a list of modules or filenames, in
which case the function tries to interpret each module as
specified earlier. The function then always returns <strong>ok</strong>,
but prints some information to <strong>stdout</strong> if a module
cannot be interpreted.</p><h4>n(AbsModule) -&gt; ok</h4><h4>nn(AbsModule) -&gt; ok</h4><p>Stop interpreting a module.</p><ul><li><span class="v">AbsModule = Module | File | [Module | File]</span></li><li><span class="v">Â Module = atom()</span></li><li><span class="v">Â File = string()</span></li></ul><p>Stops interpreting the specified module. <strong>n/1</strong> stops
interpreting the module only at the current node. <strong>nn/1</strong>
stops interpreting the module at all known nodes.</p><p>As for <strong>i/1</strong> and <strong>ni/1</strong>, a module can be specified by
its module name or filename.</p><h4>interpreted() -&gt; [Module]</h4><p>Get all interpreted modules.</p><ul><li><span class="v">Module = atom()</span></li></ul><p>Returns a list with all interpreted modules.</p><h4>file(Module) -&gt; File | {error,not_loaded}</h4><p>Get the filename for an interpreted module.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">File = string()</span></li></ul><p>Returns the source code filename <strong>File</strong> for an
interpreted module <strong>Module</strong>.</p><h4>interpretable(AbsModule) -&gt; true | {error,Reason}</h4><p>Check if a module can be interpreted.</p><ul><li><span class="v">AbsModule = Module | File</span></li><li><span class="v">Â Module = atom()</span></li><li><span class="v">Â File = string()</span></li><li><span class="v">Reason = no_src | no_beam | no_debug_info | badarg | {app,App}</span></li><li><span class="v">Â App = atom()</span></li></ul><p>Checks if a module can be interpreted. The module can be
specified by its module name <strong>Module</strong> or its source
filename <strong>File</strong>. If specified by a module name, the module
is searched for in the code path.</p><p>The function returns <strong>true</strong> if all of the following
apply:</p><ul><li>Both source code and object code for the module is found.</li><li>The module has been compiled with option <strong>debug_info</strong> set.</li><li>The module does not belong to any of the applications Kernel, STDLIB, GS, or Debugger.</li></ul><p>The function returns <strong>{error,Reason}</strong> if the module cannot
be interpreted. <strong>Reason</strong> can have the following values:</p><dl><dt><strong>no_src</strong></dt><dd><p>No source code is found.
It is assumed that the source code and object code are located
either in the same directory, or in <strong>src</strong> and <strong>ebin</strong>
directories next to each other.</p></dd><dt><strong>no_beam</strong></dt><dd><p>No object code is found.
It is assumed that the source code and object code are located
either in the same directory, or in <strong>src</strong> and <strong>ebin</strong>
directories next to each other.</p></dd><dt><strong>no_debug_info</strong></dt><dd><p>The module has not been compiled with option
<strong>debug_info</strong> set.</p></dd><dt><strong>badarg</strong></dt><dd><p><strong>AbsModule</strong> is not found. This could be because
the specified file does not exist, or because
<strong>code:which/1</strong> does not return a BEAM filename,
which is the case not only for non-existing modules but also
for modules that are preloaded or cover-compiled.</p></dd><dt><strong>{app,App}</strong></dt><dd><p><strong>App</strong> is <strong>kernel</strong>, <strong>stdlib</strong>, <strong>gs</strong>,
or <strong>debugger</strong> if <strong>AbsModule</strong> belongs to one of these
applications.</p></dd></dl><p>Notice that the function can return <strong>true</strong> for a module
that in fact is not interpretable in the case where
the module is marked as sticky or resides in a directory
marked as sticky. The reason is that this is not discovered
until the interpreter tries to load the module.</p><h4>auto_attach() -&gt; false | {Flags,Function}</h4><h4>auto_attach(false)</h4><h4>auto_attach(Flags, Function)</h4><p>Get and set when and how to attach to a process.</p><ul><li><span class="v">Flags = [init | break | exit]</span></li><li><span class="v">Function = {Module,Name,Args}</span></li><li><span class="v">Â Module = Name = atom()</span></li><li><span class="v">Â Args = [term()]</span></li></ul><p>Gets and sets when and how to attach automatically to a
process executing code in interpreted modules. <strong>false</strong>
means never attach automatically, this is the default.
Otherwise automatic attach is defined by a list of flags and
a function. The following flags can be specified:</p><ul><li><strong>init</strong> - Attach when a process for the first time calls an interpreted function.</li><li><strong>break</strong> - Attach whenever a process reaches a breakpoint.</li><li><strong>exit</strong> - Attach when a process terminates.</li></ul><p>When the specified event occurs, the function <strong>Function</strong>
is called as:</p><pre>
spawn(Module, Name, [Pid | Args])</pre><p><strong>Pid</strong> is the pid of the process executing interpreted
code.</p><h4>stack_trace() -&gt; Flag</h4><h4>stack_trace(Flag)</h4><p>Get and set if and how to save call frames.</p><ul><li><span class="v">Flag = all | no_tail | false</span></li></ul><p>Gets and sets how to save call frames in the stack. Saving
call frames makes it possible to inspect the call chain of a
process, and is also used to emulate the stack trace if an
error (an exception of class error) occurs. The following
flags can be specified:</p><dl><dt><strong>all</strong></dt><dd><p>Save information about all current calls,
that is, function calls that have not yet returned a value.</p> </dd><dt><strong>no_tail</strong></dt><dd><p>Save information about current calls,
but discard previous information when a tail recursive call
is made. This option consumes less memory and can be
necessary to use for processes with long lifetimes and many
tail recursive calls. This is the default.</p></dd><dt><strong>false</strong></dt><dd><p>Save no information about currentcalls.</p></dd></dl><h4>break(Module, Line) -&gt; ok | {error,break_exists}</h4><p>Create a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Creates a breakpoint at <strong>Line</strong> in <strong>Module</strong>.</p><h4>delete_break(Module, Line) -&gt; ok</h4><p>Delete a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Deletes the breakpoint at <strong>Line</strong> in <strong>Module</strong>.</p><h4>break_in(Module, Name, Arity) -&gt; ok
	| {error,function_not_found}</h4><p>Create breakpoints in the specified function.</p><ul><li><span class="v">Module = Name = atom()</span></li><li><span class="v">Arity = int()</span></li></ul><p>Creates a breakpoint at the first line of every clause of 
function <strong>Module:Name/Arity</strong>.</p><h4>del_break_in(Module, Name, Arity) -&gt; ok
	| {error,function_not_found}</h4><p>Delete breakpoints from the specified function.</p><ul><li><span class="v">Module = Name = atom()</span></li><li><span class="v">Arity = int()</span></li></ul><p>Deletes the breakpoints at the first line of every clause of 
function <strong>Module:Name/Arity</strong>.</p><h4>no_break() -&gt; ok</h4><h4>no_break(Module) -&gt; ok</h4><p>Delete all breakpoints.</p><p>Deletes all breakpoints, or all breakpoints in <strong>Module</strong>.</p><h4>disable_break(Module, Line) -&gt; ok</h4><p>Make a breakpoint inactive.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Makes the breakpoint at <strong>Line</strong> in <strong>Module</strong> inactive.</p><h4>enable_break(Module, Line) -&gt; ok</h4><p>Make a breakpoint active.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Makes the breakpoint at <strong>Line</strong> in <strong>Module</strong> active.</p><h4>action_at_break(Module, Line, Action) -&gt; ok</h4><p>Set the trigger action of a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li><li><span class="v">Action = enable | disable | delete</span></li></ul><p>Sets the trigger action of the breakpoint at <strong>Line</strong> in
<strong>Module</strong> to <strong>Action</strong>.</p><h4>test_at_break(Module, Line, Function) -&gt; ok</h4><p>Set the conditional test of a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li><li><span class="v">Function = {Module,Name}</span></li><li><span class="v">Â Name = atom()</span></li></ul><p>Sets the conditional test of the breakpoint at <strong>Line</strong> in
<strong>Module</strong> to <strong>Function</strong>. The function must
fulfill the requirements specified in section
<a href="#int_breakpoints">Breakpoints</a>.</p><h4>get_binding(Var, Bindings) -&gt; {value,Value} | unbound</h4><p>Retrieve a variable binding.</p><ul><li><span class="v">Var = atom()</span></li><li><span class="v">Bindings = term()</span></li><li><span class="v">Value = term()</span></li></ul><p>Retrieves the binding of <strong>Var</strong>. This function is
intended to be used by the conditional function of a
breakpoint.</p><h4>all_breaks() -&gt; [Break]</h4><h4>all_breaks(Module) -&gt; [Break]</h4><p>Get all breakpoints.</p><ul><li><span class="v">Break = {Point,Options}</span></li><li><span class="v">Â Point = {Module,Line}</span></li><li><span class="v">Â Â Module = atom()</span></li><li><span class="v">Â Â Line = int()</span></li><li><span class="v">Â Options = [Status,Trigger,null,Cond|]</span></li><li><span class="v">Â Â Status = active | inactive</span></li><li><span class="v">Â Â Trigger = enable | disable | delete</span></li><li><span class="v">Â Â Cond = null | Function</span></li><li><span class="v">Â Â Â Function = {Module,Name}</span></li><li><span class="v">Â Â Â Â Name = atom()</span></li></ul><p>Gets all breakpoints, or all breakpoints in <strong>Module</strong>.</p><h4>snapshot() -&gt; [Snapshot]</h4><p>Get information about all processes executing interpreted code.</p><ul><li><span class="v">Snapshot = {Pid, Function, Status, Info}</span></li><li><span class="v">Â Pid = pid()</span></li><li><span class="v">Â Function = {Module,Name,Args}</span></li><li><span class="v">Â Â Module = Name = atom()</span></li><li><span class="v">Â Â Args = [term()]</span></li><li><span class="v">Â Status = idle | running | waiting | break | exit | no_conn</span></li><li><span class="v">Â Info = {} | {Module,Line} | ExitReason</span></li><li><span class="v">Â Â Line = int()</span></li><li><span class="v">Â Â ExitReason = term()</span></li></ul><p>Gets information about all processes executing interpreted code.
</p><ul><li><strong>Pid</strong> - Process identifier.</li><li><strong>Function</strong> - First interpreted function called by the process.</li><li><strong>Status</strong> - Current status of the process.</li><li><strong>Info</strong> - More information.</li></ul><p><strong>Status</strong> is one of the following:</p><ul><li><strong>idle</strong> - The process is no longer executing interpreted code. <strong>Info={}</strong>.</li><li><strong>running</strong> - The process is running. <strong>Info={}</strong>. </li><li><strong>waiting</strong> - The process is waiting at a <strong>receive</strong>. <strong>Info={}</strong>.</li><li><strong>break</strong> - Process execution is stopped, normally at a breakpoint. <strong>Info={Module,Line}</strong>.</li><li><strong>exit</strong> - The process is terminated. <strong>Info=ExitReason</strong>.</li><li><strong>no_conn</strong> - The connection is down to the node where the process is running. <strong>Info={}</strong>.</li></ul><h4>clear() -&gt; ok</h4><p>Clear information about processes executing interpreted code.</p><p>Clears information about processes executing interpreted code
by removing all information about terminated processes.</p><h4>continue(Pid) -&gt; ok | {error,not_interpreted}</h4><h4>continue(X,Y,Z) -&gt; ok | {error,not_interpreted}</h4><p>Resume process execution.</p><ul><li><span class="v">Pid = pid()</span></li><li><span class="v">X = Y = Z = int()</span></li></ul><p>Resumes process execution for <strong>Pid</strong> or
<strong>c:pid(X,Y,Z)</strong>.</p></body></html>