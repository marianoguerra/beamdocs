<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>i</h1><h1>i</h1><p>Debugger/Interpreter Interface.</p><p>The <strong>i</strong> module provides short forms for some of
the functions used by the graphical Debugger and some of
the functions in module
<a href="int">int</a>, the Erlang interpreter.This module also provides facilities for displaying status
information about interpreted processes and break points.It is possible to attach to interpreted processes by giving
the corresponding process identity only. By default, an attachment
window is displayed. Processes at other Erlang nodes can be
attached manually or automatically.By preference, these functions can be included in module
<a href="./shell_default">stdlib/shell_default</a>.
By default, they are included in that module.</p><h1>Functions</h1><h2>im() -&gt; pid()</h2><p>Start a graphical monitor.</p><p>Starts a new graphical monitor. This is the Monitor window,
the main window of Debugger. All the Debugger and
interpreter functionality is accessed from the Monitor window.
This window displays the status of all processes that 
have been or are executing interpreted modules.</p><h2>ii(AbsModules) -&gt; ok</h2><h2>ii(AbsModule) -&gt; {module, Module} | error</h2><h2>ini(AbsModules) -&gt; ok</h2><h2>ini(AbsModule) -&gt; {module, Module} | error</h2><p>Interpret a module.</p><ul><li><span class="v">AbsModules = [AbsModule]</span></li><li><span class="v">AbsModule = Module | File</span></li><li><span class="v">Â Module = atom()</span></li><li><span class="v">Â File = string()</span></li></ul><p>Interprets the specified module(s). <strong>ii/1</strong> interprets
the module(s) only at the current node, see
<a href="./int#i/1">int:i/1</a>. <strong>ini/1</strong>
interprets the module(s) at all known nodes, see
<a href="./int#ni/1">int:ni/1</a>.</p><h2>iq(AbsModule) -&gt; ok</h2><h2>inq(AbsModule) -&gt; ok</h2><p>Stop interpreting a module.</p><ul><li><span class="v">AbsModule = Module | File</span></li><li><span class="v">Â Module = atom()</span></li><li><span class="v">Â File = string()</span></li></ul><p>Stops interpreting the specified module. <strong>iq/1</strong> stops
interpreting the module only at the current node. <strong>inq/1</strong>
stops interpreting the module at all known nodes.</p><h2>il() -&gt; ok</h2><p>Make a printout of all interpreted modules</p><p>Makes a printout of all interpreted modules.
Modules are printed together with the full path name of the 
corresponding source code file.</p><h2>ip() -&gt; ok</h2><p>Print the current status of all interpreted processes.</p><p>Prints the current status of all interpreted processes.</p><h2>ic() -&gt; ok</h2><p>Clear information about processes executing interpreted code.</p><p>Clears information about processes executing interpreted code
by removing all information about terminated processes.</p><h2>iaa(Flags) -&gt; true</h2><h2>iaa(Flags, Function) -&gt; true</h2><p>Set when and how to attach to a process.</p><ul><li><span class="v">Flags = [init | break | exit]</span></li><li><span class="v">Function = {Module,Name,Args}</span></li><li><span class="v">Â Module = Name = atom()</span></li><li><span class="v">Â Args = [term()]</span></li></ul><p>Sets when and how to attach to a debugged process
automatically, see
<a href="./int#auto_attach/0">int:auto_attach/2</a>.
<strong>Function</strong> defaults to the standard function used by
Debugger.</p><h2>ist(Flag) -&gt; true</h2><p>Set how to save call frames.</p><ul><li><span class="v">Flag = all | no_tail | false</span></li></ul><p>Sets how to save call frames in the stack, see
<a href="./int#stack_trace/0">int:stack_trace/1</a>.</p><h2>ia(Pid) -&gt; ok | no_proc</h2><p>Attache to a process.</p><ul><li><span class="v">Pid = pid()</span></li></ul><p>Attaches to the debugged process <strong>Pid</strong>. An
Attach Process window is opened for the process.</p><h2>ia(X,Y,Z) -&gt; ok | no_proc</h2><p>Attache to a process.</p><ul><li><span class="v">X = Y = Z = int()</span></li></ul><p>Same as <strong>ia(Pid)</strong>, where <strong>Pid</strong> is the result of
calling the shell function <strong>pid(X,Y,Z)</strong>.</p><h2>ia(Pid, Function) -&gt; ok | no_proc</h2><p>Attache to a process.</p><ul><li><span class="v">Pid = pid()</span></li><li><span class="v">Function = {Module,Name}</span></li><li><span class="v">Â Module = Name = atom()</span></li></ul><p>Attaches to the debugged process <strong>Pid</strong>. The interpreter
calls <strong>spawn(Module, Name, [Pid])</strong> (and ignores
the result).</p><h2>ia(X,Y,Z, Function) -&gt; ok | no_proc</h2><p>Attache to a process.</p><ul><li><span class="v">X = Y = Z = int()</span></li><li><span class="v">Function = {Module,Name}</span></li><li><span class="v">Â Module = Name = atom()</span></li></ul><p>Same as <strong>ia(Pid, Function)</strong>, where <strong>Pid</strong> is
the result of calling the shell function <strong>pid(X,Y,Z)</strong>.
An attached process is expected to call the unofficial
function <strong>int:attached(Pid)</strong> and to be able to handle
messages from the interpreter. For an example, see
<strong>dbg_wx_trace.erl</strong>.</p><h2>ib(Module, Line) -&gt; ok | {error, break_exists}</h2><p>Create a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Creates a breakpoint at <strong>Line</strong> in <strong>Module</strong>.</p><h2>ib(Module, Name, Arity) -&gt; ok | {error, function_not_found}
</h2><p>Create breakpoints in the specified function.</p><ul><li><span class="v">Module = Name = atom()</span></li><li><span class="v">Arity = int()</span></li></ul><p>Creates breakpoints at the first line of every clause of 
function <strong>Module:Name/Arity</strong>.</p><h2>ir() -&gt; ok</h2><p>Delete all breakpoints.</p><p>Deletes all breakpoints.</p><h2>ir(Module) -&gt; ok</h2><p>Delete all breakpoints in a module.</p><ul><li><span class="v">Module = atom()</span></li></ul><p>Deletes all breakpoints in <strong>Module</strong>.</p><h2>ir(Module, Line) -&gt; ok</h2><p>Delete a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Deletes the breakpoint at <strong>Line</strong> in <strong>Module</strong>.</p><h2>ir(Module, Name, Arity) -&gt; ok | {error, function_not_found}
</h2><p>Delete breakpoints from the specified function.</p><ul><li><span class="v">Module = Name = atom()</span></li><li><span class="v">Arity = int()</span></li></ul><p>Deletes the breakpoints at the first line of every clause of 
function <strong>Module:Name/Arity</strong>.</p><h2>ibd(Module, Line) -&gt; ok</h2><p>Make a breakpoint inactive.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Makes the breakpoint at <strong>Line</strong> in <strong>Module</strong> inactive.</p><h2>ibe(Module, Line) -&gt; ok</h2><p>Make a breakpoint active.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Makes the breakpoint at <strong>Line</strong> in <strong>Module</strong> active.</p><h2>iba(Module, Line, Action) -&gt; ok</h2><p>Set the trigger action of a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li><li><span class="v">Action = enable | disable | delete</span></li></ul><p>Sets the trigger action of the breakpoint at <strong>Line</strong> in
<strong>Module</strong> to <strong>Action</strong>.</p><h2>ibc(Module, Line, Function) -&gt; ok</h2><p>Set the conditional test of a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li><li><span class="v">Function = {Module,Name}</span></li><li><span class="v">Â Name = atom()</span></li></ul><p>Sets the conditional test of the breakpoint at <strong>Line</strong> in
<strong>Module</strong> to <strong>Function</strong>.</p><p>The conditional test is performed by calling
<strong>Module:Name(Bindings)</strong>, where <strong>Bindings</strong> is
the current variable bindings. The function must return
<strong>true</strong> (break) or <strong>false</strong> (do not break).
To retrieve the value of a variable <strong>Var</strong>, use
<a href="./int#get_binding/2">int:get_binding(Var, Bindings)</a>.</p><h2>ipb() -&gt; ok</h2><p>Print all existing breakpoints.</p><p>Prints all existing breakpoints.</p><h2>ipb(Module) -&gt; ok</h2><p>Print all existing breakpoints in a module.</p><ul><li><span class="v">Module = atom()</span></li></ul><p>Prints all existing breakpoints in <strong>Module</strong>.</p><h2>iv() -&gt; atom()</h2><p>Return the current version number of the interpreter. </p><p>Returns the current version number of the interpreter.
Same as the version number of the Debugger application.</p><h2>help() -&gt; ok</h2><p>Print help text.</p><p>Prints help text.</p><h2>See Also</h2><p><a href="int">int</a></p></body></html>