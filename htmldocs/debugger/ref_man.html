<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Debugger Reference Manual</h1><h2>debugger</h2><p>Erlang Debugger.</p><p>Erlang Debugger for debugging and testing of Erlang programs.</p><h2>Functions</h2><h3>start()</h3><h3>start(File)</h3><h3>start(Mode)</h3><h3>start(Mode, File)</h3><p>Start Debugger.</p><ul><li><span class="v">Mode = local | global</span></li><li><span class="v">File = string()</span></li></ul><p>Starts Debugger.</p><p>If a filename is specified as argument, Debugger tries to load
its settings from this file. For details about settings, see
the User's Guide.</p><p>If <strong>local</strong> is specified as argument, Debugger interprets
code only at the current node. If <strong>global</strong> is specified as
argument, Debugger interprets code at all known nodes, this
is the default.</p><h3>quick(Module, Name, Args)</h3><p>Debug a process.</p><ul><li><span class="v">Module = Name = atom()</span></li><li><span class="v">Args = [term()]</span></li></ul><p>Debugs a single process. The module <strong>Module</strong> is interpreted
and <strong>apply(Module,Name,Args)</strong> is called. This opens an
Attach Process window. For details, see the User's Guide.</p><h2>i</h2><p>Debugger/Interpreter Interface.</p><p>The <strong>i</strong> module provides short forms for some of
the functions used by the graphical Debugger and some of
the functions in module
<a href="int">int</a>, the Erlang interpreter.This module also provides facilities for displaying status
information about interpreted processes and break points.It is possible to attach to interpreted processes by giving
the corresponding process identity only. By default, an attachment
window is displayed. Processes at other Erlang nodes can be
attached manually or automatically.By preference, these functions can be included in module
<a href="./shell_default">stdlib/shell_default</a>.
By default, they are included in that module.</p><h2>Functions</h2><h3>im() -&gt; pid()</h3><p>Start a graphical monitor.</p><p>Starts a new graphical monitor. This is the Monitor window,
the main window of Debugger. All the Debugger and
interpreter functionality is accessed from the Monitor window.
This window displays the status of all processes that 
have been or are executing interpreted modules.</p><h3>ii(AbsModules) -&gt; ok</h3><h3>ii(AbsModule) -&gt; {module, Module} | error</h3><h3>ini(AbsModules) -&gt; ok</h3><h3>ini(AbsModule) -&gt; {module, Module} | error</h3><p>Interpret a module.</p><ul><li><span class="v">AbsModules = [AbsModule]</span></li><li><span class="v">AbsModule = Module | File</span></li><li><span class="v">Â Module = atom()</span></li><li><span class="v">Â File = string()</span></li></ul><p>Interprets the specified module(s). <strong>ii/1</strong> interprets
the module(s) only at the current node, see
<a href="./int#i/1">int:i/1</a>. <strong>ini/1</strong>
interprets the module(s) at all known nodes, see
<a href="./int#ni/1">int:ni/1</a>.</p><h3>iq(AbsModule) -&gt; ok</h3><h3>inq(AbsModule) -&gt; ok</h3><p>Stop interpreting a module.</p><ul><li><span class="v">AbsModule = Module | File</span></li><li><span class="v">Â Module = atom()</span></li><li><span class="v">Â File = string()</span></li></ul><p>Stops interpreting the specified module. <strong>iq/1</strong> stops
interpreting the module only at the current node. <strong>inq/1</strong>
stops interpreting the module at all known nodes.</p><h3>il() -&gt; ok</h3><p>Make a printout of all interpreted modules</p><p>Makes a printout of all interpreted modules.
Modules are printed together with the full path name of the 
corresponding source code file.</p><h3>ip() -&gt; ok</h3><p>Print the current status of all interpreted processes.</p><p>Prints the current status of all interpreted processes.</p><h3>ic() -&gt; ok</h3><p>Clear information about processes executing interpreted code.</p><p>Clears information about processes executing interpreted code
by removing all information about terminated processes.</p><h3>iaa(Flags) -&gt; true</h3><h3>iaa(Flags, Function) -&gt; true</h3><p>Set when and how to attach to a process.</p><ul><li><span class="v">Flags = [init | break | exit]</span></li><li><span class="v">Function = {Module,Name,Args}</span></li><li><span class="v">Â Module = Name = atom()</span></li><li><span class="v">Â Args = [term()]</span></li></ul><p>Sets when and how to attach to a debugged process
automatically, see
<a href="./int#auto_attach/0">int:auto_attach/2</a>.
<strong>Function</strong> defaults to the standard function used by
Debugger.</p><h3>ist(Flag) -&gt; true</h3><p>Set how to save call frames.</p><ul><li><span class="v">Flag = all | no_tail | false</span></li></ul><p>Sets how to save call frames in the stack, see
<a href="./int#stack_trace/0">int:stack_trace/1</a>.</p><h3>ia(Pid) -&gt; ok | no_proc</h3><p>Attache to a process.</p><ul><li><span class="v">Pid = pid()</span></li></ul><p>Attaches to the debugged process <strong>Pid</strong>. An
Attach Process window is opened for the process.</p><h3>ia(X,Y,Z) -&gt; ok | no_proc</h3><p>Attache to a process.</p><ul><li><span class="v">X = Y = Z = int()</span></li></ul><p>Same as <strong>ia(Pid)</strong>, where <strong>Pid</strong> is the result of
calling the shell function <strong>pid(X,Y,Z)</strong>.</p><h3>ia(Pid, Function) -&gt; ok | no_proc</h3><p>Attache to a process.</p><ul><li><span class="v">Pid = pid()</span></li><li><span class="v">Function = {Module,Name}</span></li><li><span class="v">Â Module = Name = atom()</span></li></ul><p>Attaches to the debugged process <strong>Pid</strong>. The interpreter
calls <strong>spawn(Module, Name, [Pid])</strong> (and ignores
the result).</p><h3>ia(X,Y,Z, Function) -&gt; ok | no_proc</h3><p>Attache to a process.</p><ul><li><span class="v">X = Y = Z = int()</span></li><li><span class="v">Function = {Module,Name}</span></li><li><span class="v">Â Module = Name = atom()</span></li></ul><p>Same as <strong>ia(Pid, Function)</strong>, where <strong>Pid</strong> is
the result of calling the shell function <strong>pid(X,Y,Z)</strong>.
An attached process is expected to call the unofficial
function <strong>int:attached(Pid)</strong> and to be able to handle
messages from the interpreter. For an example, see
<strong>dbg_wx_trace.erl</strong>.</p><h3>ib(Module, Line) -&gt; ok | {error, break_exists}</h3><p>Create a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Creates a breakpoint at <strong>Line</strong> in <strong>Module</strong>.</p><h3>ib(Module, Name, Arity) -&gt; ok | {error, function_not_found}
</h3><p>Create breakpoints in the specified function.</p><ul><li><span class="v">Module = Name = atom()</span></li><li><span class="v">Arity = int()</span></li></ul><p>Creates breakpoints at the first line of every clause of 
function <strong>Module:Name/Arity</strong>.</p><h3>ir() -&gt; ok</h3><p>Delete all breakpoints.</p><p>Deletes all breakpoints.</p><h3>ir(Module) -&gt; ok</h3><p>Delete all breakpoints in a module.</p><ul><li><span class="v">Module = atom()</span></li></ul><p>Deletes all breakpoints in <strong>Module</strong>.</p><h3>ir(Module, Line) -&gt; ok</h3><p>Delete a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Deletes the breakpoint at <strong>Line</strong> in <strong>Module</strong>.</p><h3>ir(Module, Name, Arity) -&gt; ok | {error, function_not_found}
</h3><p>Delete breakpoints from the specified function.</p><ul><li><span class="v">Module = Name = atom()</span></li><li><span class="v">Arity = int()</span></li></ul><p>Deletes the breakpoints at the first line of every clause of 
function <strong>Module:Name/Arity</strong>.</p><h3>ibd(Module, Line) -&gt; ok</h3><p>Make a breakpoint inactive.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Makes the breakpoint at <strong>Line</strong> in <strong>Module</strong> inactive.</p><h3>ibe(Module, Line) -&gt; ok</h3><p>Make a breakpoint active.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Makes the breakpoint at <strong>Line</strong> in <strong>Module</strong> active.</p><h3>iba(Module, Line, Action) -&gt; ok</h3><p>Set the trigger action of a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li><li><span class="v">Action = enable | disable | delete</span></li></ul><p>Sets the trigger action of the breakpoint at <strong>Line</strong> in
<strong>Module</strong> to <strong>Action</strong>.</p><h3>ibc(Module, Line, Function) -&gt; ok</h3><p>Set the conditional test of a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li><li><span class="v">Function = {Module,Name}</span></li><li><span class="v">Â Name = atom()</span></li></ul><p>Sets the conditional test of the breakpoint at <strong>Line</strong> in
<strong>Module</strong> to <strong>Function</strong>.</p><p>The conditional test is performed by calling
<strong>Module:Name(Bindings)</strong>, where <strong>Bindings</strong> is
the current variable bindings. The function must return
<strong>true</strong> (break) or <strong>false</strong> (do not break).
To retrieve the value of a variable <strong>Var</strong>, use
<a href="./int#get_binding/2">int:get_binding(Var, Bindings)</a>.</p><h3>ipb() -&gt; ok</h3><p>Print all existing breakpoints.</p><p>Prints all existing breakpoints.</p><h3>ipb(Module) -&gt; ok</h3><p>Print all existing breakpoints in a module.</p><ul><li><span class="v">Module = atom()</span></li></ul><p>Prints all existing breakpoints in <strong>Module</strong>.</p><h3>iv() -&gt; atom()</h3><p>Return the current version number of the interpreter. </p><p>Returns the current version number of the interpreter.
Same as the version number of the Debugger application.</p><h3>help() -&gt; ok</h3><p>Print help text.</p><p>Prints help text.</p><h3>See Also</h3><p><a href="int">int</a></p><h2>int</h2><p>Interpreter Interface.</p><p>The Erlang interpreter provides mechanisms for breakpoints and
stepwise execution of code. It is primarily intended to be used by
Debugger, see the User's Guide and
<a href="debugger">debugger</a>.The following can be done from the shell:<ul><li>Specify the modules to be interpreted.</li><li>Specify breakpoints.</li><li>Monitor the current status of all processes executing code in interpreted modules, also processes at other Erlang nodes. </li></ul>By <em>attaching to</em> a process executing interpreted code, it
is possible to examine variable bindings and order stepwise
execution. This is done by sending and receiving information
to/from the process through a third process, called the meta
process. You can implement your own attached process. See
<strong>int.erl</strong> for available functions and <strong>dbg_wx_trace.erl</strong>
for possible messages.The interpreter depends on the Kernel, STDLIB, and
GS applications. This means that modules belonging to any of
these applications are not allowed to be interpreted, as it could lead
to a deadlock or emulator crash. This also applies to modules
belonging to the Debugger application.</p><a name="int_breakpoints"></a><h3>Breakpoints</h3><p>Breakpoints are specified on a line basis. When a process
executing code in an interpreted module reaches a breakpoint, it
stops. This means that a breakpoint must be set at an
executable line, that is, a code line containing an executable
expression.</p><p>A breakpoint has the following:</p><ul><li>A status, which is <em>active</em> or <em>inactive</em>. An inactive breakpoint is ignored.</li><li>A trigger action. When a breakpoint is reached, the trigger action specifies if the breakpoint is to continue as active (<em>enable</em>), or to become inactive (<em>disable</em>), or to be removed (<em>delete</em>).</li><li>Optionally an associated condition. A condition is a tuple <strong>{Module,Name}</strong>. When the breakpoint is reached, <strong>Module:Name(Bindings)</strong> is called. If it evaluates to <strong>true</strong>, execution stops. If it evaluates to <strong>false</strong>, the breakpoint is ignored. <strong>Bindings</strong> contains the current variable bindings. To retrieve the value for a specified variable, use <strong>get_binding</strong>.</li></ul><p>By default, a breakpoint is active, has trigger action
<strong>enable</strong>, and has no associated condition. For details
about breakpoints, see the User's Guide.</p><h2>Functions</h2><h3>i(AbsModule) -&gt; {module,Module} | error</h3><h3>i(AbsModules) -&gt; ok</h3><h3>ni(AbsModule) -&gt; {module,Module} | error</h3><h3>ni(AbsModules) -&gt; ok</h3><p>Interpret a module.</p><ul><li><span class="v">AbsModules = [AbsModule]</span></li><li><span class="v">AbsModule = Module | File | [Module | File]</span></li><li><span class="v">Â Module = atom()</span></li><li><span class="v">Â File = string()</span></li></ul><p>Interprets the specified module(s). <strong>i/1</strong> interprets
the module only at the current node. <strong>ni/1</strong> interprets
the module at all known nodes.</p><p>A module can be specified by its module name (atom) or
filename.</p><p>If specified by its module name, the object code
<strong>Module.beam</strong> is searched for in the current path.
The source code <strong>Module.erl</strong> is searched for first in
the same directory as the object code, then in an <strong>src</strong>
directory next to it.</p><p>If specified by its filename, the filename can include a path
and the <strong>.erl</strong> extension can  be omitted. The object code
<strong>Module.beam</strong> is searched for first in the same directory
as the source code, then in an <strong>ebin</strong> directory next to
it, and then in the current path.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The interpreter requires both the source code and the object
code. The object code <em>must</em> include debug
information, that is, only modules compiled with option
<strong>debug_info</strong> set can be interpreted.</p></div><p>The functions returns <strong>{module,Module}</strong> if the module
was interpreted, otherwise <strong>error</strong> is returned.</p><p>The argument can also be a list of modules or filenames, in
which case the function tries to interpret each module as
specified earlier. The function then always returns <strong>ok</strong>,
but prints some information to <strong>stdout</strong> if a module
cannot be interpreted.</p><h3>n(AbsModule) -&gt; ok</h3><h3>nn(AbsModule) -&gt; ok</h3><p>Stop interpreting a module.</p><ul><li><span class="v">AbsModule = Module | File | [Module | File]</span></li><li><span class="v">Â Module = atom()</span></li><li><span class="v">Â File = string()</span></li></ul><p>Stops interpreting the specified module. <strong>n/1</strong> stops
interpreting the module only at the current node. <strong>nn/1</strong>
stops interpreting the module at all known nodes.</p><p>As for <strong>i/1</strong> and <strong>ni/1</strong>, a module can be specified by
its module name or filename.</p><h3>interpreted() -&gt; [Module]</h3><p>Get all interpreted modules.</p><ul><li><span class="v">Module = atom()</span></li></ul><p>Returns a list with all interpreted modules.</p><h3>file(Module) -&gt; File | {error,not_loaded}</h3><p>Get the filename for an interpreted module.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">File = string()</span></li></ul><p>Returns the source code filename <strong>File</strong> for an
interpreted module <strong>Module</strong>.</p><h3>interpretable(AbsModule) -&gt; true | {error,Reason}</h3><p>Check if a module can be interpreted.</p><ul><li><span class="v">AbsModule = Module | File</span></li><li><span class="v">Â Module = atom()</span></li><li><span class="v">Â File = string()</span></li><li><span class="v">Reason = no_src | no_beam | no_debug_info | badarg | {app,App}</span></li><li><span class="v">Â App = atom()</span></li></ul><p>Checks if a module can be interpreted. The module can be
specified by its module name <strong>Module</strong> or its source
filename <strong>File</strong>. If specified by a module name, the module
is searched for in the code path.</p><p>The function returns <strong>true</strong> if all of the following
apply:</p><ul><li>Both source code and object code for the module is found.</li><li>The module has been compiled with option <strong>debug_info</strong> set.</li><li>The module does not belong to any of the applications Kernel, STDLIB, GS, or Debugger.</li></ul><p>The function returns <strong>{error,Reason}</strong> if the module cannot
be interpreted. <strong>Reason</strong> can have the following values:</p><dl><dt><strong>no_src</strong></dt><dd><p>No source code is found.
It is assumed that the source code and object code are located
either in the same directory, or in <strong>src</strong> and <strong>ebin</strong>
directories next to each other.</p></dd><dt><strong>no_beam</strong></dt><dd><p>No object code is found.
It is assumed that the source code and object code are located
either in the same directory, or in <strong>src</strong> and <strong>ebin</strong>
directories next to each other.</p></dd><dt><strong>no_debug_info</strong></dt><dd><p>The module has not been compiled with option
<strong>debug_info</strong> set.</p></dd><dt><strong>badarg</strong></dt><dd><p><strong>AbsModule</strong> is not found. This could be because
the specified file does not exist, or because
<strong>code:which/1</strong> does not return a BEAM filename,
which is the case not only for non-existing modules but also
for modules that are preloaded or cover-compiled.</p></dd><dt><strong>{app,App}</strong></dt><dd><p><strong>App</strong> is <strong>kernel</strong>, <strong>stdlib</strong>, <strong>gs</strong>,
or <strong>debugger</strong> if <strong>AbsModule</strong> belongs to one of these
applications.</p></dd></dl><p>Notice that the function can return <strong>true</strong> for a module
that in fact is not interpretable in the case where
the module is marked as sticky or resides in a directory
marked as sticky. The reason is that this is not discovered
until the interpreter tries to load the module.</p><h3>auto_attach() -&gt; false | {Flags,Function}</h3><h3>auto_attach(false)</h3><h3>auto_attach(Flags, Function)</h3><p>Get and set when and how to attach to a process.</p><ul><li><span class="v">Flags = [init | break | exit]</span></li><li><span class="v">Function = {Module,Name,Args}</span></li><li><span class="v">Â Module = Name = atom()</span></li><li><span class="v">Â Args = [term()]</span></li></ul><p>Gets and sets when and how to attach automatically to a
process executing code in interpreted modules. <strong>false</strong>
means never attach automatically, this is the default.
Otherwise automatic attach is defined by a list of flags and
a function. The following flags can be specified:</p><ul><li><strong>init</strong> - Attach when a process for the first time calls an interpreted function.</li><li><strong>break</strong> - Attach whenever a process reaches a breakpoint.</li><li><strong>exit</strong> - Attach when a process terminates.</li></ul><p>When the specified event occurs, the function <strong>Function</strong>
is called as:</p><pre>
spawn(Module, Name, [Pid | Args])</pre><p><strong>Pid</strong> is the pid of the process executing interpreted
code.</p><h3>stack_trace() -&gt; Flag</h3><h3>stack_trace(Flag)</h3><p>Get and set if and how to save call frames.</p><ul><li><span class="v">Flag = all | no_tail | false</span></li></ul><p>Gets and sets how to save call frames in the stack. Saving
call frames makes it possible to inspect the call chain of a
process, and is also used to emulate the stack trace if an
error (an exception of class error) occurs. The following
flags can be specified:</p><dl><dt><strong>all</strong></dt><dd><p>Save information about all current calls,
that is, function calls that have not yet returned a value.</p> </dd><dt><strong>no_tail</strong></dt><dd><p>Save information about current calls,
but discard previous information when a tail recursive call
is made. This option consumes less memory and can be
necessary to use for processes with long lifetimes and many
tail recursive calls. This is the default.</p></dd><dt><strong>false</strong></dt><dd><p>Save no information about currentcalls.</p></dd></dl><h3>break(Module, Line) -&gt; ok | {error,break_exists}</h3><p>Create a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Creates a breakpoint at <strong>Line</strong> in <strong>Module</strong>.</p><h3>delete_break(Module, Line) -&gt; ok</h3><p>Delete a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Deletes the breakpoint at <strong>Line</strong> in <strong>Module</strong>.</p><h3>break_in(Module, Name, Arity) -&gt; ok
	| {error,function_not_found}</h3><p>Create breakpoints in the specified function.</p><ul><li><span class="v">Module = Name = atom()</span></li><li><span class="v">Arity = int()</span></li></ul><p>Creates a breakpoint at the first line of every clause of 
function <strong>Module:Name/Arity</strong>.</p><h3>del_break_in(Module, Name, Arity) -&gt; ok
	| {error,function_not_found}</h3><p>Delete breakpoints from the specified function.</p><ul><li><span class="v">Module = Name = atom()</span></li><li><span class="v">Arity = int()</span></li></ul><p>Deletes the breakpoints at the first line of every clause of 
function <strong>Module:Name/Arity</strong>.</p><h3>no_break() -&gt; ok</h3><h3>no_break(Module) -&gt; ok</h3><p>Delete all breakpoints.</p><p>Deletes all breakpoints, or all breakpoints in <strong>Module</strong>.</p><h3>disable_break(Module, Line) -&gt; ok</h3><p>Make a breakpoint inactive.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Makes the breakpoint at <strong>Line</strong> in <strong>Module</strong> inactive.</p><h3>enable_break(Module, Line) -&gt; ok</h3><p>Make a breakpoint active.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li></ul><p>Makes the breakpoint at <strong>Line</strong> in <strong>Module</strong> active.</p><h3>action_at_break(Module, Line, Action) -&gt; ok</h3><p>Set the trigger action of a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li><li><span class="v">Action = enable | disable | delete</span></li></ul><p>Sets the trigger action of the breakpoint at <strong>Line</strong> in
<strong>Module</strong> to <strong>Action</strong>.</p><h3>test_at_break(Module, Line, Function) -&gt; ok</h3><p>Set the conditional test of a breakpoint.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Line = int()</span></li><li><span class="v">Function = {Module,Name}</span></li><li><span class="v">Â Name = atom()</span></li></ul><p>Sets the conditional test of the breakpoint at <strong>Line</strong> in
<strong>Module</strong> to <strong>Function</strong>. The function must
fulfill the requirements specified in section
<a href="#int_breakpoints">Breakpoints</a>.</p><h3>get_binding(Var, Bindings) -&gt; {value,Value} | unbound</h3><p>Retrieve a variable binding.</p><ul><li><span class="v">Var = atom()</span></li><li><span class="v">Bindings = term()</span></li><li><span class="v">Value = term()</span></li></ul><p>Retrieves the binding of <strong>Var</strong>. This function is
intended to be used by the conditional function of a
breakpoint.</p><h3>all_breaks() -&gt; [Break]</h3><h3>all_breaks(Module) -&gt; [Break]</h3><p>Get all breakpoints.</p><ul><li><span class="v">Break = {Point,Options}</span></li><li><span class="v">Â Point = {Module,Line}</span></li><li><span class="v">Â Â Module = atom()</span></li><li><span class="v">Â Â Line = int()</span></li><li><span class="v">Â Options = [Status,Trigger,null,Cond|]</span></li><li><span class="v">Â Â Status = active | inactive</span></li><li><span class="v">Â Â Trigger = enable | disable | delete</span></li><li><span class="v">Â Â Cond = null | Function</span></li><li><span class="v">Â Â Â Function = {Module,Name}</span></li><li><span class="v">Â Â Â Â Name = atom()</span></li></ul><p>Gets all breakpoints, or all breakpoints in <strong>Module</strong>.</p><h3>snapshot() -&gt; [Snapshot]</h3><p>Get information about all processes executing interpreted code.</p><ul><li><span class="v">Snapshot = {Pid, Function, Status, Info}</span></li><li><span class="v">Â Pid = pid()</span></li><li><span class="v">Â Function = {Module,Name,Args}</span></li><li><span class="v">Â Â Module = Name = atom()</span></li><li><span class="v">Â Â Args = [term()]</span></li><li><span class="v">Â Status = idle | running | waiting | break | exit | no_conn</span></li><li><span class="v">Â Info = {} | {Module,Line} | ExitReason</span></li><li><span class="v">Â Â Line = int()</span></li><li><span class="v">Â Â ExitReason = term()</span></li></ul><p>Gets information about all processes executing interpreted code.
</p><ul><li><strong>Pid</strong> - Process identifier.</li><li><strong>Function</strong> - First interpreted function called by the process.</li><li><strong>Status</strong> - Current status of the process.</li><li><strong>Info</strong> - More information.</li></ul><p><strong>Status</strong> is one of the following:</p><ul><li><strong>idle</strong> - The process is no longer executing interpreted code. <strong>Info={}</strong>.</li><li><strong>running</strong> - The process is running. <strong>Info={}</strong>. </li><li><strong>waiting</strong> - The process is waiting at a <strong>receive</strong>. <strong>Info={}</strong>.</li><li><strong>break</strong> - Process execution is stopped, normally at a breakpoint. <strong>Info={Module,Line}</strong>.</li><li><strong>exit</strong> - The process is terminated. <strong>Info=ExitReason</strong>.</li><li><strong>no_conn</strong> - The connection is down to the node where the process is running. <strong>Info={}</strong>.</li></ul><h3>clear() -&gt; ok</h3><p>Clear information about processes executing interpreted code.</p><p>Clears information about processes executing interpreted code
by removing all information about terminated processes.</p><h3>continue(Pid) -&gt; ok | {error,not_interpreted}</h3><h3>continue(X,Y,Z) -&gt; ok | {error,not_interpreted}</h3><p>Resume process execution.</p><ul><li><span class="v">Pid = pid()</span></li><li><span class="v">X = Y = Z = int()</span></li></ul><p>Resumes process execution for <strong>Pid</strong> or
<strong>c:pid(X,Y,Z)</strong>.</p></body></html>