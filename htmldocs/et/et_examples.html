<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Advanced examples</h1><h2>A simulated Mnesia transaction</h2><p>The Erlang code for running the simulated <strong>Mnesia</strong> transaction
example in the previous chapter is included in the
<strong>et/examples/et_demo.erl</strong> file:</p><pre><code class="">

sim_trans() -&gt;
    sim_trans([]).

sim_trans(ExtraOptions) -&gt;
    Options = [{dict_insert, {filter, mgr_actors}, fun mgr_actors/1}],
    {ok, Viewer} = et_viewer:start_link(Options ++ ExtraOptions),
    Collector = et_viewer:get_collector_pid(Viewer),
    et_collector:report_event(Collector, 60, my_shell, mnesia_tm, start_outer, 
                              "Start outer transaction"),
    et_collector:report_event(Collector, 40, mnesia_tm, my_shell, new_tid, 
                              "New transaction id is 4711"),
    et_collector:report_event(Collector, 20, my_shell, mnesia_locker, try_write_lock, 
                              "Acquire write lock for {my_tab, key}"),
    et_collector:report_event(Collector, 10, mnesia_locker, my_shell, granted,
                              "You got the write lock for {my_tab, key}"),
    et_collector:report_event(Collector, 60, my_shell, do_commit,
                              "Perform  transaction commit"),
    et_collector:report_event(Collector, 40, my_shell, mnesia_locker, release_tid,
                              "Release all locks for transaction 4711"),
    et_collector:report_event(Collector, 60, my_shell, mnesia_tm, delete_transaction,
                              "End of outer transaction"),
    et_collector:report_event(Collector, 20, my_shell, end_outer,
                              "Transaction returned {atomic, ok}"),
    {collector, Collector}.
</code></pre><pre><code class="">

mgr_actors(E) when is_record(E, event) -&gt;
    Actor = fun(A) -&gt;
               case A of
                   mnesia_tm     -&gt; trans_mgr;
                   mnesia_locker -&gt; lock_mgr;
                   _             -&gt; A
               end
            end,
    {true, E#event{from = Actor(E#event.from),
                   to = Actor(E#event.to),
                   contents = [{orig_from, E#event.from},
                               {orig_to,   E#event.to},
                               {orig_contents, E#event.contents}]}}.</code></pre><p>If you invoke the <strong>et_demo:sim_trans()</strong> function, a
<strong>Viewer</strong> window will pop up and the sequence trace will be
almost the same as if the following <strong>Mnesia</strong> transaction
would have been run:</p><pre><code class="">
mnesia:transaction(fun() -&gt; mnesia:write({my_tab, key, val}) end).</code></pre><p>And the viewer window will look like:</p><pre><code class="">
Erlang R13B03 (erts-5.7.4) [64-bit] [smp:4:4] [rq:4] [async-threads:0] [kernel-poll:false]

Eshell V5.7.4  (abort with ^G)
1&gt; {ok, Viewer} = et_viewer:start([]).
{ok,&lt;0.40.0&gt;;}
2&gt; et_demo:sim_trans().
{ok,{table_handle,&lt;0.45.0&gt;,24596,trace_ts,
     #Fun&lt;et_collector.0.62831470&gt;}}</code></pre><img src="sim_trans.png" title="A simulated Mnesia transaction which writes one record"></img><h2>Some convenient functions used in the Mnesia transaction
    example</h2><p>The <strong>module_as_actor</strong> filter converts the <strong>Event Records</strong> so the module names becomes actors and the invoked
functions becomes labels. If the information about who the caller
was it will be displayed as an arrow directed from the caller to
the callee. The <strong>[{message, {caller}}, {return_trace}]</strong>
options to <strong>dbg:tpl/2</strong> function will imply the necessary
information in the Erlang traces.  Here follows the
<strong>module_as_actor</strong> filter:</p><pre><code class="">

module_as_actor(E) when is_record(E, event) -&gt;
    case lists:keysearch(mfa, 1, E#event.contents) of
        {value, {mfa, {M, F, _A}}} -&gt;
            case lists:keysearch(pam_result, 1, E#event.contents) of
                {value, {pam_result, {M2, _F2, _A2}}} -&gt;
                    {true, E#event{label = F, from = M2, to = M}};
                _ -&gt;
                    {true, E#event{label = F, from = M, to = M}}
            end;
        _ -&gt;
            false
    end.</code></pre><p>The <strong>plain_process_info</strong> filter does not alter the
<strong>Event Records</strong>.  It merely ensures that the event not
related to processes are skipped:</p><pre><code class="">

plain_process_info(E) when is_record(E, event) -&gt;
    case E#event.label of
        send                          -&gt; true;
        send_to_non_existing_process  -&gt; true;
        'receive'                     -&gt; true;
        spawn                         -&gt; true;
        exit                          -&gt; true;
        link                          -&gt; true;
        unlink                        -&gt; true;
        getting_linked                -&gt; true;
        {seq_send, _Label}            -&gt; true;
        {seq_receive, _Label}         -&gt; true;
        {seq_print, _Label}           -&gt; true;
        {drop, _N}                    -&gt; true;
        _                             -&gt; false
    end.</code></pre><p>The <strong>plain_process_info_nolink</strong> filter does not alter the
<strong>Event Records</strong>. It do makes use of the
<strong>plain_process_info</strong> , but do also ensure that the process
info related to linking and unlinking is skipped:</p><pre><code class="">

plain_process_info_nolink(E) when is_record(E, event) -&gt;
    (E#event.label /= link) and
    (E#event.label /= unlink) and
    (E#event.label /= getting_linked) and
    plain_process_info(E). </code></pre><p>In order to simplify the startup of an <strong>et_viewer</strong> process
with the filters mentioned above, plus some others (that also are
found in <strong>et/examples/et_demo.erl</strong> src/et_collector.erl the
<strong>et_demo:start/0,1</strong> functions can be used:</p><pre><code class="">

start() -&gt;
    start([]).

start(ExtraOptions) -&gt;
    Options = [{trace_global, true},
               {parent_pid, undefined},
               {max_actors, infinity},
               {max_events, 1000},
               {active_filter, module_as_actor}],
    et_viewer:start_link(filters() ++ Options ++ ExtraOptions).</code></pre><p>A simple one-liner starts the tool:</p><pre><code class="">
          erl -pa ../examples -s et_demo</code></pre><p>The filters are included by the following parameters:</p><pre><code class="">

filters() -&gt;
    [{dict_insert, {filter, module_as_actor},
                   fun module_as_actor/1},
     {dict_insert, {filter, plain_process_info},
                   fun plain_process_info/1},
     {dict_insert, {filter, plain_process_info_nolink},
                   fun plain_process_info_nolink/1},
     {dict_insert, {filter, named_process_info},
                   fun named_process_info/1},
     {dict_insert, {filter, named_process_info_nolink},
                   fun named_process_info_nolink/1},
     {dict_insert, {filter, node_process_info},
                   fun node_process_info/1},
     {dict_insert, {filter, node_process_info_nolink},
                   fun node_process_info_nolink/1},
     {dict_insert, {filter, application_as_actor},
                   fun application_as_actor/1}
    ].</code></pre><h2>Erlang trace of a real Mnesia transaction</h2><p>The following piece of code <strong>et_demo:trace_mnesia/0</strong>
activates call tracing of both local and external function calls
for all modules in the <strong>Mnesia</strong> application. The call traces
are configured cover all processes (both existing and those that
are spawned in the future) and include timestamps for trace
data. It do also activate tracing of process related events for
<strong>Mnesia</strong>'s static processes plus the calling process (that is
your shell). Please, observe that the <strong>whereis/1</strong> call in the
following code requires that both the traced <strong>Mnesia</strong>
application and the <strong>et_viewer</strong> is running on the same
node:</p><pre><code class="">

trace_mnesia() -&gt;
    Modules = mnesia:ms(),
    Spec = [{message, {caller}}, {return_trace}],
    Flags = [send, 'receive', procs, timestamp],
    dbg:p(all, [call, timestamp]),
    [dbg:tpl(M, [{'_', [], Spec}]) || M &lt;- Modules],
    LocallyRunningServers = [M || M &lt;- Modules, whereis(M) /= undefined],
    [dbg:p(whereis(RS), Flags) || RS &lt;- LocallyRunningServers],
    dbg:p(self(), Flags),
    LocallyRunningServers.</code></pre><p>The <strong>et_demo:live_trans/0</strong> function starts the global
<strong>Collector</strong>, starts a <strong>Viewer</strong>, starts <strong>Mnesia</strong>,
creates a local table, activates tracing (as described above) and
registers the shell process is as 'my_shell' for clarity. Finally
a simple <strong>Mnesia</strong> transaction that writes a single record
is run:</p><pre><code class="">

live_trans() -&gt;
    live_trans([]).

live_trans(ExtraOptions) -&gt;
    Options = [{title, "Mnesia tracer"},
	       {hide_actions, true},
	       {active_filter, named_process_info_nolink}],
    et_demo:start(Options ++ ExtraOptions),
    mnesia:start(),
    mnesia:create_table(my_tab, [{ram_copies, [node()]}]),
    et_demo:trace_mnesia(),
    register(my_shell, self()),

    mnesia:transaction(fun() -&gt; mnesia:write({my_tab, key, val}) end).</code></pre><p>Now we run the <strong>et_demo:live_trans/0</strong> function:</p><pre><code class="">
erl -pa ../examples
Erlang R13B03 (erts-5.7.4) [64-bit] [smp:4:4] [rq:4]
                           [async-threads:0] [kernel-poll:false]

Eshell V5.7.4  (abort with ^G)
1&gt; et_demo:live_trans().
{atomic,ok}</code></pre><p>Please, explore the different filters in order to see how the traced
transaction can be seen from different point of views:</p><img src="live_trans.png" title="A real Mnesia transaction which writes one record"></img><h2>Erlang trace of Megaco startup</h2><p>The <strong>Event Tracer (ET)</strong> tool was initially written in
order to demonstrate how messages where sent over the
<strong>Megaco</strong> protocol. This were back in the old days before the
standard bodies of <strong>IETF</strong> and <strong>ITU</strong> had approved
<strong>Megaco</strong> (also called <strong>H.248</strong>) as an international
standard.</p><p>In the <strong>Megaco</strong> application of Erlang/OTP, the code is
carefully instrumented with calls to <strong>et:trace_me/5</strong>. For
each call a detail level is given in order to enable dynamic
control of the trace level in a simple manner.</p><p>The <strong>megaco_filter</strong> module implements a customized filter
for <strong>Megaco</strong> messages. It does also make use of
<strong>trace_global</strong> combined with usage of the
<strong>trace_pattern</strong>:</p><pre><code class="">
-module(megaco_filter).
-export([start/0]).

start() -&gt;
    Options =
        [{event_order, event_ts},
         {scale, 3},
         {max_actors, infinity},
         {trace_pattern, {megaco, max}},
         {trace_global, true},
         {dict_insert, {filter, megaco_filter}, fun filter/1},
         {active_filter, megaco_filter},
         {title, "Megaco tracer - Erlang/OTP"}],
    et_viewer:start(Options).</code></pre><p>First we start an Erlang node with a global <strong>Collector</strong>
and its <strong>Viewer</strong>.</p><pre><code class="">
erl -sname observer
Erlang R13B03 (erts-5.7.4) [64-bit] [smp:4:4] [rq:4] [async-threads:0] [kernel-poll:false]

Eshell V5.7.4  (abort with ^G)
(observer@falco)1&gt; megaco_filter:start().
{ok,&lt;0.48.0&gt;}</code></pre><p>Secondly we start another Erlang node which we connect the
observer node, before we start the application that we want to
trace. In this case we start a Media Gateway Controller that
listens for both TCP and UDP on the text and binary ports for
Megaco:</p><pre><code class="">
erl -sname mgc -pa ../../megaco/examples/simple
Erlang R13B03 (erts-5.7.4) [64-bit] [smp:4:4] [rq:4] [async-threads:0] [kernel-poll:false]

Eshell V5.7.4  (abort with ^G)
(mgc@falco)1&gt; net:ping(observer@falco).
pong
(mgc@falco)2&gt; megaco:start().
ok
(mgc@falco)3&gt; megaco_simple_mgc:start().
{ok,[{ok,2944,
         {megaco_receive_handle,{deviceName,"controller"},
                                megaco_pretty_text_encoder,[],megaco_tcp,dynamic}},
     {ok,2944,
         {megaco_receive_handle,{deviceName,"controller"},
                                megaco_pretty_text_encoder,[],megaco_udp,dynamic}},
     {ok,2945,
         {megaco_receive_handle,{deviceName,"controller"},
                                megaco_binary_encoder,[],megaco_tcp,dynamic}},
     {ok,2945,
         {megaco_receive_handle,{deviceName,"controller"},
                                megaco_binary_encoder,[],megaco_udp,dynamic}}]}</code></pre><p>And finally we start an Erlang node for the Media Gateways and
connect to the observer node. Each Media Gateway connects to the
controller and sends an initial Service Change message. The
controller accepts the gateways and sends a reply to each one
using the same transport mechanism and message encoding according
to the preference of each gateway. That is all combinations of
TCP/IP transport, UDP/IP transport, text encoding and ASN.1 BER
encoding:</p><pre><code class="">
Erlang R13B03 (erts-5.7.4) [64-bit] [smp:4:4] [rq:4] [async-threads:0] [kernel-poll:false]

Eshell V5.7.4  (abort with ^G)
(mg@falco)1&gt; net:ping(observer@falco).
pong
(mg@falco)2&gt; megaco_simple_mg:start().
[{{deviceName,"gateway_tt"},
  {error,{start_user,megaco_not_started}}},
 {{deviceName,"gateway_tb"},
  {error,{start_user,megaco_not_started}}},
 {{deviceName,"gateway_ut"},
  {error,{start_user,megaco_not_started}}},
 {{deviceName,"gateway_ub"},
  {error,{start_user,megaco_not_started}}}]
(mg@falco)3&gt; megaco:start().
ok
(mg@falco)4&gt; megaco_simple_mg:start().
[{{deviceName,"gateway_tt"},
  {1,
   {ok,[{'ActionReply',0,asn1_NOVALUE,asn1_NOVALUE,
            [{serviceChangeReply,
                 {'ServiceChangeReply',
                     [{megaco_term_id,false,["root"]}],
                     {serviceChangeResParms,
                         {'ServiceChangeResParm',
                             {deviceName,"controller"},
                             asn1_NOVALUE,asn1_NOVALUE,asn1_NOVALUE,
                             asn1_NOVALUE}}}}]}]}}},
 {{deviceName,"gateway_tb"},
  {1,
   {ok,[{'ActionReply',0,asn1_NOVALUE,asn1_NOVALUE,
            [{serviceChangeReply,
                 {'ServiceChangeReply',
                     [{megaco_term_id,false,["root"]}],
                     {serviceChangeResParms,
                         {'ServiceChangeResParm',
                             {deviceName,"controller"},
                             asn1_NOVALUE,asn1_NOVALUE,asn1_NOVALUE,
                             asn1_NOVALUE}}}}]}]}}},
 {{deviceName,"gateway_ut"},
  {1,
   {ok,[{'ActionReply',0,asn1_NOVALUE,asn1_NOVALUE,
            [{serviceChangeReply,
                 {'ServiceChangeReply',
                     [{megaco_term_id,false,["root"]}],
                     {serviceChangeResParms,
                         {'ServiceChangeResParm',
                             {deviceName,"controller"},
                             asn1_NOVALUE,asn1_NOVALUE,asn1_NOVALUE,
                             asn1_NOVALUE}}}}]}]}}},
 {{deviceName,"gateway_ub"},
  {1,
   {ok,[{'ActionReply',0,asn1_NOVALUE,asn1_NOVALUE,
            [{serviceChangeReply,
                 {'ServiceChangeReply',
                     [{megaco_term_id,false,["root"]}],
                     {serviceChangeResParms,
                         {'ServiceChangeResParm',
                             {deviceName,"controller"},
                             asn1_NOVALUE,asn1_NOVALUE,
                             asn1_NOVALUE,...}}}}]}]}}}]</code></pre><p>The <strong>Megaco</strong> adopted viewer looks like this, when we have clicked
on the <em>[gateway_tt]</em> actor name in order to only display the events
regarding that actor:</p><img src="megaco_tracer.png" title="The viewer adopted for Megaco"></img><p>A pretty printed <strong>Megaco</strong> message looks like this:</p><img src="megaco_filter.png" title="A textual Megaco message"></img><p>And the corresponding internal form for the same <strong>Megaco</strong> message
looks like this:</p><img src="megaco_collector.png" title="The internal form of a Megaco message"></img></body></html>