<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Event Tracer (ET) Reference Manual</h1><p>The Event Tracer (ET) uses the built-in trace mechanism in Erlang
and provides tools for collection and graphical viewing of trace data.</p><h2>et</h2><p>Main API of the Event Trace (ET) application</p><p>Interface module for the Event Trace (ET) application</p><h2>Functions</h2><h3>trace_me(DetailLevel, From, To, Label, Contents) -&gt; hopefully_traced</h3><p>A function that is intended to be traced.</p><ul><li><span class="v">DetailLevel = integer(X) when X =&lt; 0, X &gt;= 100</span></li><li><span class="v">From        = actor()</span></li><li><span class="v">To          = actor()</span></li><li><span class="v">Label       = atom() | string() | term()</span></li><li><span class="v">Contents    = [{Key, Value}] | term()</span></li><li><span class="v">actor()     = term()</span></li></ul><p>A function that is intended to be traced.</p><p>This function is intended to be invoked at strategic places
in user applications in order to enable simplified
tracing. The functions are extremely light weight as they do
nothing besides returning an atom. The functions are designed
for being traced. The global tracing mechanism in
<strong>et_collector</strong> defaults to set its trace pattern to these
functions.</p><p>The label is intended to provide a brief summary of the
event. It is preferred to use an atom but a string would also
do.</p><p>The contents can be any term but in order to simplify
post processing of the traced events, a plain list
of {Key, Value} tuples is preferred.</p><p>Some events, such as messages, are directed from some actor to another.
Other events (termed actions) may be undirected and only have one actor.</p><h3>trace_me(DetailLevel, FromTo, Label, Contents) -&gt; hopefully_traced</h3><p>A function that is intended to be traced.</p><p>Invokes <strong>et:trace_me/5</strong> with both <strong>From</strong> and <strong>To</strong>
set to <strong>FromTo</strong>.</p><h3>phone_home(DetailLevel, FromTo, Label, Contents) -&gt; hopefully_traced</h3><h3>phone_home(DetailLevel, From, To, Label, Contents) -&gt; hopefully_traced</h3><p>Send a signal to the outer space</p><p>These functions sends a signal to the outer space and the
caller hopes that someone is listening. In other words, they
invoke <strong>et:trace_me/4</strong> and <strong>et:trace_me/5</strong>
respectively.</p><h3>report_event(DetailLevel, FromTo, Label, Contents) -&gt; hopefully_traced</h3><h3>report_event(DetailLevel, From, To, Label, Contents) -&gt; hopefully_traced</h3><p>Deprecated functions</p><p>Deprecated functions which for the time being are kept for
backwards compatibility. Invokes <strong>et:trace_me/4</strong> and
<strong>et:trace_me/5</strong> respectively.</p><h2>et_collector</h2><p>Collect trace events and provide a backing storage appropriate for iteration</p><p>Interface module for the Event Trace (ET) application</p><h2>Functions</h2><h3>start_link(Options) -&gt; {ok, CollectorPid} | {error, Reason}</h3><p>Start a collector process</p><ul><li><span class="v">Options = [option()]</span></li><li><span class="v">option() = {parent_pid, pid()} | {event_order, event_order()} | {dict_insert, {filter, collector}, collector_fun()} | {dict_insert, {filter, event_filter_name()}, event_filter_fun()} | {dict_insert, {subscriber, pid()}, dict_val()} | {dict_insert, dict_key(), dict_val()} | {dict_delete, dict_key()} | {trace_client, trace_client()} | {trace_global, boolean()} |  {trace_pattern, trace_pattern()} | {trace_port, integer()} |  {trace_max_queue, integer()}</span></li><li><span class="v">event_order() = trace_ts | event_ts</span></li><li><span class="v">trace_pattern() = {report_module(), extended_dbg_match_spec()} | undefined</span></li><li><span class="v">report_module() = atom() | undefined</span></li><li><span class="v">extended_dbg_match_spec() = detail_level() | dbg_match_spec()</span></li><li><span class="v">detail_level() = min | max | integer(X) when X =&lt; 0, X &gt;= 100</span></li><li><span class="v">trace_client() =  {event_file, file_name()} | {dbg_trace_type(), dbg_trace_parameters()}</span></li><li><span class="v">file_name() = string()</span></li><li><span class="v">collector_fun() = trace_filter_fun() | event_filter_fun()</span></li><li><span class="v">trace_filter_fun() = fun(TraceData) -&gt; false | true | {true, NewEvent}</span></li><li><span class="v">event_filter_fun() = fun(Event) -&gt; false | true | {true, NewEvent}</span></li><li><span class="v">event_filter_name() = atom()</span></li><li><span class="v">TraceData = erlang_trace_data()</span></li><li><span class="v">Event = NewEvent = record(event)</span></li><li><span class="v">dict_key() = term()</span></li><li><span class="v">dict_val() = term()</span></li><li><span class="v">CollectorPid = pid()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Start a collector process.</p><p>The collector collects trace events and keeps them ordered by their
timestamp. The timestamp may either reflect the time when the
actual trace data was generated (trace_ts) or when the trace data
was transformed into an event record (event_ts). If the time stamp
is missing in the trace data (missing timestamp option to
erlang:trace/4) the trace_ts will be set to the event_ts.</p><p>Events are reported to the collector directly with the report
function or indirectly via one or more trace clients. All reported
events are first filtered thru the collector filter before they are
stored by the collector. By replacing the default collector filter
with a customized dito it is possible to allow any trace data as
input. The collector filter is a dictionary entry with the
predefined key {filter, collector} and the value is a fun of
arity 1. See et_selector:make_event/1 for interface details,
such as which erlang:trace/1 tuples that are accepted.</p><p>The collector has a built-in dictionary service. Any term may be
stored as value in the dictionary and bound to a unique key. When
new values are inserted with an existing key, the new values will
overwrite the existing ones. Processes may subscribe on dictionary
updates by using {subscriber, pid()} as dictionary key. All
dictionary updates will be propagated to the subscriber processes
matching the pattern {{subscriber, '_'}, '_'} where the first '_'
is interpreted as a pid().</p><p>In global trace mode, the collector will automatically
start tracing on all connected Erlang nodes. When a node
connects, a port tracer will be started on that node and a
corresponding trace client on the collector node.</p><p>Default values:</p><ul><li>parent_pid - self().</li><li>event_order - trace_ts.</li><li>trace_global - false.</li><li>trace_pattern - undefined.</li><li>trace_port - 4711.</li><li>trace_max_queue - 50.</li></ul><h3>stop(CollectorPid) -&gt; ok</h3><p>Stop a collector process</p><ul><li><span class="v">CollectorPid = pid()</span></li></ul><p>Stop a collector process.</p><h3>save_event_file(CollectorPid, FileName, Options) -&gt; ok | {error, Reason}</h3><p>Save the events to a file</p><ul><li><span class="v">CollectorPid = pid()</span></li><li><span class="v">FileName = string()</span></li><li><span class="v">Options = [option()]</span></li><li><span class="v">Reason = term()</span></li><li><span class="v">option() = event_option() | file_option() | table_option()</span></li><li><span class="v">event_option() = existing</span></li><li><span class="v">file_option() = write | append</span></li><li><span class="v">table_option() = keep | clear</span></li></ul><p>Save the events to a file.</p><p>By default the currently stored events (existing) are
written to a brand new file (write) and the events are
kept (keep) after they have been written to the file.</p><p>Instead of keeping the events after writing them to file,
it is possible to remove all stored events after they
have successfully written to file (clear).</p><p>The options defaults to existing, write and keep.</p><h3>load_event_file(CollectorPid, FileName) -&gt; {ok, BadBytes} | exit(Reason)</h3><p>Load the event table from a file</p><ul><li><span class="v">CollectorPid = pid()</span></li><li><span class="v">FileName = string()</span></li><li><span class="v">BadBytes = integer(X) where X &gt;= 0</span></li><li><span class="v">Reason = term()</span></li></ul><p>Load the event table from a file.</p><h3>report(Handle, TraceOrEvent) -&gt; {ok, Continuation} | exit(Reason)</h3><h3>report_event(Handle, DetailLevel, FromTo, Label, Contents) -&gt; {ok, Continuation} | exit(Reason)</h3><h3>report_event(Handle, DetailLevel, From, To, Label, Contents) -&gt; {ok, Continuation} | exit(Reason)</h3><p>Report an event to the collector</p><ul><li><span class="v">Handle = Initial | Continuation</span></li><li><span class="v">Initial = collector_pid()</span></li><li><span class="v">collector_pid() = pid()</span></li><li><span class="v">Continuation = record(table_handle)</span></li><li><span class="v">TraceOrEvent = record(event) | dbg_trace_tuple() | end_of_trace</span></li><li><span class="v">Reason = term()</span></li><li><span class="v">DetailLevel = integer(X) when X =&lt; 0, X &gt;= 100</span></li><li><span class="v">From        = actor()</span></li><li><span class="v">To          = actor()</span></li><li><span class="v">FromTo      = actor()</span></li><li><span class="v">Label       = atom() | string() | term()</span></li><li><span class="v">Contents    = [{Key, Value}] | term()</span></li><li><span class="v">actor()  = term()</span></li></ul><p>Report an event to the collector.</p><p>All events are filtered thru the collector filter, which
optionally may transform or discard the event. The first
call should use the pid of the collector process as
report handle, while subsequent calls should use the
table handle.</p><h3>make_key(Type, Stuff) -&gt; Key</h3><p>Make a key out of an event record or an old key</p><ul><li><span class="v">Type = record(table_handle) | trace_ts | event_ts</span></li><li><span class="v">Stuff = record(event) | Key</span></li><li><span class="v">Key = record(event_ts) | record(trace_ts)</span></li></ul><p>Make a key out of an event record or an old key.</p><h3>get_table_handle(CollectorPid) -&gt; Handle</h3><p>Return a table handle</p><ul><li><span class="v">CollectorPid = pid()</span></li><li><span class="v">Handle = record(table_handle)</span></li></ul><p>Return a table handle.</p><h3>get_global_pid() -&gt; CollectorPid | exit(Reason)</h3><p>Return a the identity of the globally registered collector if there is any</p><ul><li><span class="v">CollectorPid = pid()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Return a the identity of the globally registered
collector if there is any.</p><h3>change_pattern(CollectorPid, RawPattern) -&gt; {old_pattern, TracePattern}</h3><p>Change active trace pattern globally on all trace nodes</p><ul><li><span class="v">CollectorPid = pid()</span></li><li><span class="v">RawPattern = {report_module(), extended_dbg_match_spec()}</span></li><li><span class="v">report_module() = atom() | undefined</span></li><li><span class="v">extended_dbg_match_spec() = detail_level() | dbg_match_spec()</span></li><li><span class="v">RawPattern = detail_level()</span></li><li><span class="v">detail_level() = min | max | integer(X) when X =&lt; 0, X &gt;= 100</span></li><li><span class="v">TracePattern = {report_module(), dbg_match_spec_match_spec()}</span></li></ul><p>Change active trace pattern globally on all trace nodes.</p><h3>dict_insert(CollectorPid, {filter, collector}, FilterFun) -&gt; ok</h3><h3>dict_insert(CollectorPid, {subscriber, SubscriberPid}, Void) -&gt; ok</h3><h3>dict_insert(CollectorPid, Key, Val) -&gt; ok</h3><p>Insert a dictionary entry and send a {et, {dict_insert, Key, Val}} tuple to all registered subscribers.</p><ul><li><span class="v">CollectorPid = pid()</span></li><li><span class="v">FilterFun = filter_fun() </span></li><li><span class="v">SubscriberPid = pid()</span></li><li><span class="v">Void = term()</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Val = term()</span></li></ul><p>Insert a dictionary entry
and send a {et, {dict_insert, Key, Val}} tuple
to all registered subscribers.</p><p>If the entry is a new subscriber, it will imply that
the new subscriber process first will get one message
for each already stored dictionary entry, before it
and all old subscribers will get this particular entry.
The collector process links to and then supervises the
subscriber process. If the subscriber process dies it
will imply that it gets unregistered as with a normal
dict_delete/2.</p><h3>dict_lookup(CollectorPid, Key) -&gt; [Val]</h3><p>Lookup a dictionary entry and return zero or one value</p><ul><li><span class="v">CollectorPid = pid()</span></li><li><span class="v">FilterFun = filter_fun() </span></li><li><span class="v">CollectorPid = pid()</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Val = term()</span></li></ul><p>Lookup a dictionary entry and return zero or one value.</p><h3>dict_delete(CollectorPid, Key) -&gt; ok</h3><p>Delete a dictionary entry and send a {et, {dict_delete, Key}} tuple to all registered subscribers.</p><ul><li><span class="v">CollectorPid = pid()</span></li><li><span class="v">SubscriberPid = pid()</span></li><li><span class="v">Key = {subscriber, SubscriberPid} | term()</span></li></ul><p>Delete a dictionary entry
and send a {et, {dict_delete, Key}} tuple
to all registered subscribers.</p><p>If the deleted entry is a registered subscriber, it will
imply that the subscriber process gets is unregistered as
subscriber as well as it gets it final message.</p><h3>dict_match(CollectorPid, Pattern) -&gt; [Match]</h3><p>Match some dictionary entries</p><ul><li><span class="v">CollectorPid = pid()</span></li><li><span class="v">Pattern = '_' | {key_pattern(), val_pattern()}</span></li><li><span class="v">key_pattern() = ets_match_object_pattern()</span></li><li><span class="v">val_pattern() = ets_match_object_pattern()</span></li><li><span class="v">Match = {key(), val()}</span></li><li><span class="v">key() = term()</span></li><li><span class="v">val() = term()</span></li></ul><p>Match some dictionary entries</p><h3>multicast(_CollectorPid, Msg) -&gt; ok</h3><p>Sends a message to all registered subscribers</p><ul><li><span class="v">CollectorPid = pid()</span></li><li><span class="v">CollectorPid = pid()</span></li><li><span class="v">Msg = term()</span></li></ul><p>Sends a message to all registered subscribers.</p><h3>start_trace_client(CollectorPid, Type, Parameters) -&gt; file_loaded | {trace_client_pid, pid()} | exit(Reason)</h3><p>Load raw Erlang trace from a file, port or process.</p><ul><li><span class="v">Type       = dbg_trace_client_type()</span></li><li><span class="v">Parameters = dbg_trace_client_parameters()</span></li><li><span class="v">Pid        = dbg_trace_client_pid()</span></li></ul><p>Load raw Erlang trace from a file, port or process.</p><h3>iterate(Handle, Prev, Limit) -&gt; NewAcc</h3><p>Iterates over the currently stored events</p><p>Short for iterate(Handle, Prev, Limit, undefined, Prev) -&gt; NewAcc</p><h3>iterate(Handle, Prev, Limit, Fun, Acc) -&gt; NewAcc</h3><p>Iterate over the currently stored events</p><ul><li><span class="v">Handle = collector_pid() | table_handle()</span></li><li><span class="v">Prev = first | last | event_key()</span></li><li><span class="v">Limit = done() | forward() | backward()</span></li><li><span class="v">collector_pid() = pid()</span></li><li><span class="v">table_handle() = record(table_handle)</span></li><li><span class="v">event_key() = record(event) | record(event_ts) | record(trace_ts)</span></li><li><span class="v">done() = 0</span></li><li><span class="v">forward() = infinity | integer(X) where X &gt; 0</span></li><li><span class="v">backward() = '-infinity' | integer(X) where X &lt; 0</span></li><li><span class="v">Fun = fun(Event, Acc) -&gt; NewAcc</span></li><li><span class="v">Acc = NewAcc = term()</span></li></ul><p>Iterate over the currently stored events.</p><p>Iterates over the currently stored events and applies
a function for each event. The iteration may be performed
forwards or backwards and may be limited to a maximum
number of events (abs(Limit)).</p><h3>clear_table(Handle) -&gt; ok</h3><p>Clear the event table</p><ul><li><span class="v">Handle = collector_pid() | table_handle()</span></li><li><span class="v">collector_pid() = pid()</span></li><li><span class="v">table_handle() = record(table_handle)</span></li></ul><p>Clear the event table.</p><h2>et_selector</h2><p>Define event transforms and trace patterns</p><h2>Functions</h2><h3>make_pattern(RawPattern) -&gt; TracePattern</h3><p>Makes a trace pattern suitable to feed change_pattern/1</p><ul><li><span class="v">RawPattern = detail_level()</span></li><li><span class="v">TracePattern = erlang_trace_pattern_match_spec()</span></li><li><span class="v">detail_level() = min | max | integer(X) when X &gt;= 0, X =&lt; 100</span></li></ul><p>Makes a trace pattern suitable to feed change_pattern/1</p><p>Min detail level deactivates tracing of calls to <strong>et:trace_me/4,5</strong></p><p>Max detail level activates tracing of all calls to <strong>et:trace_me/4,5</strong></p><p>integer(X) detail level activates tracing of all calls to
<strong>et:trace_me/4,5</strong> whose detail level argument is lesser than
X.</p><p>See also <strong>erlang:trace_pattern/2</strong> for more info about its <strong>match_spec()</strong></p><h3>change_pattern(Pattern) -&gt; ok</h3><p>Activates/deactivates tracing by changing the current trace pattern</p><ul><li><span class="v">Pattern = detail_level() | empty_match_spec() | erlang_trace_pattern_match_spec()</span></li><li><span class="v">detail_level() = min | max | integer(X) when  X &gt;= 0, X =&lt; 100</span></li><li><span class="v">empty_match_spec() = [] </span></li></ul><p>Activates/deactivates tracing by changing the current trace pattern.</p><p><strong>min</strong> detail level deactivates tracing of calls to <strong>et:trace_me/4,5</strong></p><p><strong>max</strong> detail level activates tracing of all calls to <strong>et:trace_me/4,5</strong></p><p><strong>integer(X)</strong> detail level activates tracing of all
calls to <strong>et:trace_me/4,5</strong> whose detail level argument is
lesser than <strong>X</strong>.</p><p>An empty match spec deactivates tracing of calls to <strong>et:trace_me/4,5</strong></p><p>Other match specs activates tracing of calls to
<strong>et:trace_me/4,5</strong> accordingly with
<strong>erlang:trace_pattern/2</strong>.</p><h3>parse_event(Mod, ValidTraceData) -&gt; false | true | {true, Event}</h3><p>Transforms trace data and makes an event record out of it</p><ul><li><span class="v">Mod = module_name() | undefined</span></li><li><span class="v">module_name() = atom()</span></li><li><span class="v">ValidTraceData = erlang_trace_data() | record(event)</span></li><li><span class="v">erlang_trace_data() = {trace, Pid, Label, Info} |  {trace, Pid, Label, Info, Extra} |  {trace_ts, Pid, Label, Info, ReportedTS} |  {trace_ts, Pid, Label, Info, Extra, ReportedTS} |  {seq_trace, Label, Info} |  {seq_trace, Label, Info, ReportedTS} |  {drop, NumberOfDroppedItems}</span></li></ul><p>Transforms trace data and makes an event record out of it.</p><p>See <strong>erlang:trace/3</strong> for more info about the semantics of the
trace data.</p><p>An event record consists of the following fields:</p><dl><dt><em>detail_level</em></dt><dd><p>Noise has a high level as opposed to essentials.</p></dd><dt><em>trace_ts</em></dt><dd><p>Time when the trace was generated.  Same as
event_ts if omitted in trace data.</p></dd><dt><em>event_ts</em></dt><dd><p>Time when the event record was created.</p></dd><dt><em>from</em></dt><dd><p>From actor, such as sender of a message.</p></dd><dt><em>to</em></dt><dd><p>To actor, such as receiver of message.</p></dd><dt><em>label</em></dt><dd><p>Label intended to provide a brief event summary.</p></dd><dt><em>contents</em></dt><dd><p>All nitty gritty details of the event.</p></dd></dl><p>See <strong>et:trace_me/4</strong>and <strong>et:trace_me/5</strong> for details.</p><p>Returns:</p><dl><dt><em>{true, Event}</em></dt><dd><p>where Event is an #event{} record representing the
trace data</p></dd><dt><em>true</em></dt><dd><p>means that the trace data already is an event
record and that it is valid as it is. No transformation is
needed.</p></dd><dt><em>false</em></dt><dd><p>means that the trace data is uninteresting and
should be dropped</p></dd></dl><h2>et_viewer</h2><p>Displays a sequence chart for trace events (messages/actions)</p><h2>Functions</h2><h3>file(FileName) -&gt; {ok, ViewerPid} | {error, Reason}</h3><p>Start a new event viewer and a corresponding collector and load them with trace events from a trace file.</p><ul><li><span class="v">FileName() = string()</span></li><li><span class="v">ViewerPid = pid()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Start a new event viewer and a corresponding collector
and load them with trace events from a trace file.</p><h3>start() -&gt; ok</h3><p>Simplified start of a sequence chart viewer with global tracing activated.</p><p>Simplified start of a sequence chart viewer with
global tracing activated.</p><p>Convenient to be used from the command line
(erl -s et_viewer).</p><h3>start(Options) -&gt; ok</h3><p>Start of a sequence chart viewer without linking to the parent process.</p><p>Start of a sequence chart viewer without linking
to the parent process.</p><h3>start_link(Options) -&gt; {ok, ViewerPid} | {error, Reason}</h3><p>Start a sequence chart viewer for trace events (messages/actions)</p><ul><li><span class="v">Options = [option() | collector_option()]</span></li><li><span class="v">option() = {parent_pid, extended_pid()} | {title, term()} | {detail_level, detail_level()} | {is_suspended, boolean()} | {scale, integer()} | {width, integer()} | {height, integer()} | {collector_pid, extended_pid()} | {event_order, event_order()} | {active_filter, atom()} | {max_actors, extended_integer()} | {trace_pattern, et_collector_trace_pattern()} | {trace_port, et_collector_trace_port()} | {trace_global, et_collector_trace_global()} | {trace_client, et_collector_trace_client()} | {dict_insert, {filter, filter_name()}, event_filter_fun()} | {dict_insert, et_collector_dict_key(), et_collector_dict_val()} | {dict_delete, {filter, filter_name()}} | {dict_delete, et_collector_dict_key()} | {actors, actors()} | {first_event, first_key()} | {hide_unknown, boolean()} | {hide_actions, boolean()} | {display_mode, display_mode()}</span></li><li><span class="v">extended_pid() = pid() | undefined</span></li><li><span class="v">detail_level() = min | max | integer(X) when X &gt;=0, X =&lt; 100</span></li><li><span class="v">event_order() = trace_ts | event_ts</span></li><li><span class="v">extended_integer() = integer() | infinity</span></li><li><span class="v">display_mode() = all | {search_actors, direction(), first_key(), actors()}</span></li><li><span class="v">direction() = forward | reverse</span></li><li><span class="v">first_key() = event_key()</span></li><li><span class="v">actors() = [term()]</span></li><li><span class="v">filter_name() = atom()</span></li><li><span class="v">filter_fun() =  fun(Event) -&gt; false | true | {true, NewEvent}</span></li><li><span class="v">Event = NewEvent = record(event)</span></li><li><span class="v">ViewerPid = pid()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Start a sequence chart viewer for trace events
(messages/actions)</p><p>A filter_fun() takes an event record as sole argument
and returns false | true | {true, NewEvent}.</p><p>If the <strong>collector_pid</strong> is <strong>undefined</strong> a new 
<strong>et_collector</strong> will be started with the following
parameter settings: <strong>parent_pid</strong>, <strong>event_order</strong>,
<strong>trace_global</strong>, <strong>trace_pattern</strong>, <strong>trace_port</strong>, <strong>trace_max_queue</strong>,
<strong>trace_client</strong>, <strong>dict_insert</strong> and <strong>dict_delete</strong>.
The new <strong>et_viewer</strong> will register itself as an <strong>et_collector</strong> 
subscriber.
</p><p>Default values:</p><ul><li>parent_pid - self().</li><li>title - "et_viewer".</li><li>detail_level - max.</li><li>is_suspended - false.</li><li>scale - 2.</li><li>width - 800.</li><li>height - 600.</li><li>collector_pid - undefined.</li><li>event_order - trace_ts.</li><li>active_filter - collector.</li><li>max_actors - 5.</li><li>actors - ["UNKNOWN"].</li><li>first_event - first.</li><li>hide_unknown - false.</li><li>hide_actions - false.</li><li>display_mode - all.</li></ul><h3>get_collector_pid(ViewerPid) -&gt; CollectorPid</h3><p>Returns the identifier of the collector process</p><ul><li><span class="v">ViewerPid = pid()</span></li><li><span class="v">CollectorPid = pid()</span></li></ul><p>Returns the identifier of the collector process.</p><h3>stop(ViewerPid) -&gt; ok</h3><p>Stops a viewer</p><ul><li><span class="v">ViewerPid = pid()</span></li></ul><p>Stops a viewer process.</p></body></html>