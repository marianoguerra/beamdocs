<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>appup</h1><h1>appup</h1><p>Application upgrade file</p><p>The <em>application upgrade file</em> defines how an application
is upgraded or downgraded in a running system.This file is used by the functions in 
<a href="systools">systools</a> 
when generating a release upgrade file <strong>relup</strong>.</p><h2>File Syntax</h2><p>The application upgrade file is to be called
<strong>Application.appup</strong>, where <strong>Application</strong> is the
application name. The file is to be located in the <strong>ebin</strong>
directory for the application.</p><p>The <strong>.appup</strong> file contains one single Erlang term, which
defines the instructions used to upgrade or downgrade
the application. The file has the following syntax:</p><pre><code class="">
{Vsn,
  [{UpFromVsn, Instructions}, ...],
  [{DownToVsn, Instructions}, ...]}.</code></pre><dl><dt><strong>Vsn = string()</strong></dt><dd><p>Current application version.</p></dd><dt><strong>UpFromVsn = string() | binary()</strong></dt><dd><p>An earlier
application version to upgrade from. If it is a
string, it is interpreted as a specific version
number. If it is a binary, it is interpreted as a
regular expression that can match multiple version
numbers.</p></dd><dt><strong>DownToVsn = string() | binary()</strong></dt><dd><p>An earlier
application version to downgrade to. If it is a
string, it is  interpreted as a specific version
number. If it is a binary, it is interpreted as a
regular expression that can match multiple version
numbers.</p></dd><dt><strong>Instructions</strong></dt><dd><p>A list of <em>release upgrade instructions</em>, see
<a href="#Release Upgrade Instructions">Release Upgrade Instructions</a>. It is recommended to use
high-level instructions only. These are automatically
translated to low-level instructions by <strong>systools</strong> when
creating the <strong>relup</strong> file.</p></dd></dl><p>To avoid duplication of upgrade instructions, it is
allowed to use regular expressions to specify <strong>UpFromVsn</strong>
and <strong>DownToVsn</strong>. To be considered a regular expression, the
version identifier must be specified as a binary. For example,
the following match all versions <strong>2.1.x</strong>, where <strong>x</strong> is
any number:</p><pre><code class="">
&lt;&lt;"2\\.1\\.[0-9]+"&gt;&gt;</code></pre><p>Notice that the regular expression must match the complete
version string, so this example works for, for example,
<strong>2.1.1</strong>, but not for <strong>2.1.1.1</strong>.</p><a name="Release Upgrade Instructions"></a><h2>Release Upgrade Instructions</h2><p>Release upgrade instructions are interpreted by the release
handler when an upgrade or downgrade is made. For more
information about release handling, see
<a href="./release_handling">OTP Design Principles</a> in <em>System Documentation</em>.</p><p>A process is said to <em>use</em> a module <strong>Mod</strong> if
<strong>Mod</strong> is listed in the <strong>Modules</strong> part of the child
specification used to start the process, see
<a href="./supervisor">stdlib/supervisor</a>.
In the case of 
<a href="./gen_event">stdlib/gen_event</a>, 
an event manager process is said to use <strong>Mod</strong> if <strong>Mod</strong> 
is an installed event handler.</p><h2>High-Level Instructions</h2><pre>
{update, Mod}
{update, Mod, supervisor}
{update, Mod, Change}
{update, Mod, DepMods}
{update, Mod, Change, DepMods}
{update, Mod, Change, PrePurge, PostPurge, DepMods}
{update, Mod, Timeout, Change, PrePurge, PostPurge, DepMods}
{update, Mod, ModType, Timeout, Change, PrePurge, PostPurge, DepMods}
  Mod = atom()
  ModType = static | dynamic
  Timeout = int()&gt;0 | default | infinity
  Change = soft | {advanced,Extra}
    Extra = term()
  PrePurge = PostPurge = soft_purge | brutal_purge
  DepMods = [Mod]</pre><p>Synchronized code replacement of processes using module
<strong>Mod</strong>.</p><p>All those processes are suspended using 
<a href="../stdlib/sys#suspend/1">stdlib/sys#suspend/1</a>,
the new module version is loaded, and
then the processes are resumed using 
<a href="../stdlib/sys#resume/1">stdlib/sys#resume/1</a>.</p><dl><dt><strong>Change</strong></dt><dd><p>Defaults to <strong>soft</strong> and defines the type of
code change. If it is set to <strong>{advanced,Extra}</strong>, implemented
processes using 
<a href="./gen_server">stdlib/gen_server</a>, 
<a href="./gen_fsm">stdlib/gen_fsm</a>,
<a href="./gen_statem">stdlib/gen_statem</a>, or
<a href="./gen_event">stdlib/gen_event</a> 
transform their internal state by calling the callback function
<strong>code_change</strong>. Special processes call the callback
function <strong>system_code_change/4</strong>. In both cases, the term
<strong>Extra</strong> is passed as an argument to the callback
function.</p></dd><dt><strong>PrePurge</strong></dt><dd><p>Defaults to <strong>brutal_purge</strong>. It controls
what action to take with processes executing old code
before loading the new module version. If the value
is <strong>brutal_purge</strong>, the processes are killed. If the value is
<strong>soft_purge</strong>, 
<a href="./release_handler#install_release/1">release_handler#install_release/1</a>
returns <strong>{error,{old_processes,Mod}}</strong>.</p></dd><dt><strong>PostPurge</strong></dt><dd><p>Defaults to <strong>brutal_purge</strong>. It controls
what action to take with processes that are executing old code
when the new module version has been loaded. If the value
is <strong>brutal_purge</strong>, the code is purged when the release is
made permanent and the processes are killed. If the value is
<strong>soft_purge</strong>, the release handler purges the old code
when no remaining processes execute the code.</p></dd><dt><strong>DepMods</strong></dt><dd><p>Defaults to <strong>[]</strong> and defines other modules that
<strong>Mod</strong> is dependent on. In the <strong>relup</strong> file, instructions 
for suspending processes using <strong>Mod</strong> come before
instructions for suspending processes using modules in
<strong>DepMods</strong> when upgrading, and conversely when downgrading.
In case of circular dependencies, the order of the instructions in
the <strong>appup</strong> file is kept.</p></dd><dt><strong>Timeout</strong></dt><dd><p>Defines the time-out when suspending processes.
If no value or <strong>default</strong> is specified, the default value for
<a href="../stdlib/sys#suspend/1">stdlib/sys#suspend/1</a> 
is used.</p></dd><dt><strong>ModType</strong></dt><dd><p>Defaults to <strong>dynamic</strong>. It specifies if
the code is "dynamic", that is, if a process using the module
spontaneously switches to new code, or if it is "static".
When doing an advanced update and upgrade, the new version of a
dynamic module is loaded before the process is asked to change
code. When downgrading, the process is asked to change code before
loading the new version. For static modules, the new version is
loaded before the process is asked to change code, both in
the case of upgrading and downgrading. Callback modules are
dynamic.</p></dd></dl><p><strong>update</strong> with argument <strong>supervisor</strong> is used when
changing the start specification of a supervisor.</p><pre>
{load_module, Mod}
{load_module, Mod, DepMods}
{load_module, Mod, PrePurge, PostPurge, DepMods}
  Mod = atom()
  PrePurge = PostPurge = soft_purge | brutal_purge
  DepMods = [Mod]</pre><p>Simple code replacement of the module <strong>Mod</strong>.</p><p>For a description of <strong>PrePurge</strong> and <strong>PostPurge</strong>,
see <strong>update</strong> above.</p><p><strong>DepMods</strong> defaults to <strong>[]</strong> and defines which other modules
<strong>Mod</strong> is dependent on. In the <strong>relup</strong> file, instructions for
loading these modules come before the instruction for loading
<strong>Mod</strong> when upgrading, and conversely when downgrading.</p><pre>
{add_module, Mod}
{add_module, Mod, DepMods}
  Mod = atom()
  DepMods = [Mod]</pre><p>Loads a new module <strong>Mod</strong>.</p><p><strong>DepMods</strong> defaults to <strong>[]</strong> and defines which other modules
<strong>Mod</strong> is dependent on. In the <strong>relup</strong> file, instructions
related to these modules come before the instruction for
loading <strong>Mod</strong> when upgrading, and conversely when
downgrading.</p><pre>
{delete_module, Mod}
{delete_module, Mod, DepMods}
  Mod = atom()</pre><p>Deletes a module <strong>Mod</strong> using the low-level instructions
<strong>remove</strong> and <strong>purge</strong>.</p><p><strong>DepMods</strong> defaults to <strong>[]</strong> and defines which other modules
<strong>Mod</strong> is dependent on. In the <strong>relup</strong> file, instructions
related to these modules come before the instruction for
removing <strong>Mod</strong> when upgrading, and conversely when
downgrading.</p><pre>
{add_application, Application}
{add_application, Application, Type}
  Application = atom()
  Type = permanent | transient | temporary | load | none</pre><p>Adding an application means that the modules defined by
the <strong>modules</strong> key in the <strong>.app</strong> file are loaded using
<strong>add_module</strong>.</p><p><strong>Type</strong> defaults to <strong>permanent</strong> and specifies the start type
of the application. If <strong>Type = permanent | transient | temporary</strong>,
the application is loaded and started in the corresponding way, see
<a href="./application">kernel/application</a>.
If <strong>Type = load</strong>, the application is only loaded.
If <strong>Type = none</strong>, the application is not loaded and not
started, although the code for its modules is loaded.</p><pre>
{remove_application, Application}
  Application = atom()</pre><p>Removing an application means that the application is stopped,
the modules are unloaded using <strong>delete_module</strong>, and then
the application specification is unloaded from the application
controller.</p><pre>
{restart_application, Application}
  Application = atom()</pre><p>Restarting an application means that the application is stopped
and then started again, similar to using the instructions
<strong>remove_application</strong> and <strong>add_application</strong> in sequence.
Note that, even if the application has been started before the
release upgrade is performed, <strong>restart_application</strong> may only
<strong>load</strong> it rather than <strong>start</strong> it, depending on the
application's <strong>start type</strong>:
If <strong>Type = load</strong>, the application is only loaded.
If <strong>Type = none</strong>, the application is not loaded and not
started, although the code for its modules is loaded.
</p><h2>Low-Level Instructions</h2><pre>
{load_object_code, {App, Vsn, [Mod]}}
  App = Mod = atom()
  Vsn = string()</pre><p>Reads each <strong>Mod</strong> from directory <strong>App-Vsn/ebin</strong> as
a binary. It does not load the modules. The instruction is to be
placed first in the script to read all new code from the file
to make the suspend-load-resume cycle less time-consuming.</p><pre>
point_of_no_return</pre><p>If a crash occurs after this instruction, the system cannot
recover and is restarted from the old release version.
The instruction must only occur once in a script. It is to be
placed after all <strong>load_object_code</strong> instructions.</p><pre>
{load, {Mod, PrePurge, PostPurge}}
  Mod = atom()
  PrePurge = PostPurge = soft_purge | brutal_purge</pre><p>Before this instruction occurs, <strong>Mod</strong> must have been loaded
using <strong>load_object_code</strong>. This instruction loads the module.
<strong>PrePurge</strong> is ignored. For a description of <strong>PostPurge</strong>,
see the high-level instruction <strong>update</strong> earlier.</p><pre>
{remove, {Mod, PrePurge, PostPurge}}
  Mod = atom()
  PrePurge = PostPurge = soft_purge | brutal_purge</pre><p>Makes the current version of <strong>Mod</strong> old.
<strong>PrePurge</strong> is ignored. For a description of <strong>PostPurge</strong>,
see the high-level instruction <strong>update</strong> earlier.</p><pre>
{purge, [Mod]}
  Mod = atom()</pre><p>Purges each module <strong>Mod</strong>, that is, removes the old code.
Notice that any process executing purged code is killed.</p><pre>
{suspend, [Mod | {Mod, Timeout}]}
  Mod = atom()
  Timeout = int()&gt;0 | default | infinity</pre><p>Tries to suspend all processes using a module <strong>Mod</strong>. If a
process does not respond, it is ignored. This can cause
the process to die, either because it crashes when it
spontaneously switches to new code, or as a result of a purge
operation. If no <strong>Timeout</strong> is specified or <strong>default</strong> is
specified, the default value for 
<a href="../stdlib/sys#suspend/1">stdlib/sys#suspend/1</a> 
is used.</p><pre>
{resume, [Mod]}
  Mod = atom()</pre><p>Resumes all suspended processes using a module <strong>Mod</strong>.</p><pre>
{code_change, [{Mod, Extra}]}
{code_change, Mode, [{Mod, Extra}]}
  Mod = atom()
  Mode = up | down
  Extra = term()</pre><p><strong>Mode</strong> defaults to <strong>up</strong> and specifies if it is an
upgrade or downgrade. This instruction sends a <strong>code_change</strong>
system message to all processes using a module <strong>Mod</strong> by
calling function 
<a href="../stdlib/sys#change_code/4">stdlib/sys#change_code/4</a>, 
passing term <strong>Extra</strong> as argument.</p><pre>
{stop, [Mod]}
  Mod = atom()</pre><p>Stops all processes using a module <strong>Mod</strong> by calling
<a href="../stdlib/supervisor#terminate_child/2">stdlib/supervisor#terminate_child/2</a>. 
This instruction is useful
when the simplest way to change code is to stop and restart the
processes that run the code.</p><pre>
{start, [Mod]}
  Mod = atom()</pre><p>Starts all stopped processes using a module <strong>Mod</strong> by calling
<a href="../stdlib/supervisor#restart_child/2">stdlib/supervisor#restart_child/2</a>.</p><pre>
{sync_nodes, Id, [Node]}
{sync_nodes, Id, {M, F, A}}
  Id = term()
  Node = node()
  M = F = atom()
  A = [term()]</pre><p><strong>apply(M, F, A)</strong> must return a list of nodes.</p><p>This instruction synchronizes the release installation with other
nodes. Each <strong>Node</strong> must evaluate this command with the same
<strong>Id</strong>. The local node waits for all other nodes to evaluate
the instruction before execution continues. If a node goes
down, it is considered to be an unrecoverable error, and
the local node is restarted from the old release. There is no
time-out for this instruction, which means that it can hang
forever.</p><pre>
{apply, {M, F, A}}
  M = F = atom()
  A = [term()]</pre><p>Evaluates <strong>apply(M, F, A)</strong>.</p><p>If the instruction appears before instruction
<strong>point_of_no_return</strong>, a failure is caught.
<a href="./release_handler#install_release/1">release_handler#install_release/1</a> 
then returns <strong>{error,{'EXIT',Reason}}</strong>, unless <strong>{error,Error}</strong> 
is thrown or returned. Then it returns <strong>{error,Error}</strong>.</p><p>If the instruction appears after instruction
<strong>point_of_no_return</strong> and the function call fails, the
system is restarted.</p><pre>
restart_new_emulator</pre><p>This instruction is used when the application ERTS,
Kernel, STDLIB, or SASL is
upgraded. It shuts down the current emulator and starts a new
one. All processes are terminated gracefully, and the new
version of ERTS, Kernel, STDLIB, and
SASL are used when the emulator restarts.
Only one <strong>restart_new_emulator</strong> instruction is allowed
in the <strong>relup</strong> file, and it must be placed first.
<a href="./systools#make_relup/3">systools#make_relup/3</a>
ensures this when the <strong>relup</strong> file is generated. The rest of the
instructions in the <strong>relup</strong> file is executed after the
restart as a part of the boot script.</p><p>An info report is written when the upgrade is completed.
To programmatically determine if the upgrade is complete,
call <a href="./release_handler#which_releases/0">release_handler#which_releases/0</a> and check if the
expected release has status <strong>current</strong>.</p><p>The new release must still be made permanent after the upgrade
is completed, otherwise the old emulator is started if there is
an emulator restart.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>As stated earlier, instruction <strong>restart_new_emulator</strong>
causes the emulator to be restarted with new versions of
ERTS&gt;, Kernel, STDLIB, and SASL.
However, all other applications do at startup run their old
versions in this new emulator. This is usually no problem,
but every now and then incompatible changes occur to the
core applications, which can cause
trouble in this setting. Such incompatible changes (when
functions are removed) are normally preceded by a deprecation
over two major releases. To ensure that your application is not
crashed by an incompatible change, always remove any call to
deprecated functions as soon as possible.</p></div><pre>
restart_emulator</pre><p>This instruction is similar to <strong>restart_new_emulator</strong>,
except it must be placed at the end of the <strong>relup</strong> file.
It is not related to an upgrade of the emulator or the core
applications, but can be used by any application when a complete
reboot of the system is required.</p><p>When generating the <strong>relup</strong> file,
<a href="./systools#make_relup/3">systools#make_relup/3</a>
ensures that there is only one <strong>restart_emulator</strong>
instruction and that it is the last instruction in the
<strong>relup</strong> file.</p><h2>See Also</h2><p><a href="release_handler">release_handler</a>,
<a href="relup">relup</a>,
<a href="./supervisor">stdlib/supervisor</a>,
<a href="systools">systools</a></p></body></html>