<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>release_handler</h1><h1>release_handler</h1><p>Unpacking and Installation of Release Packages</p><p>The <em>release handler</em> process belongs to the SASL
application, which is responsible for <em>release handling</em>,
that is, unpacking, installation, and removal of release packages.An introduction to release handling and an example is provided in
<a href="./release_handling">OTP Design Principles</a> in <em>System Documentation</em>.A <em>release package</em> is a compressed tar file containing
code for a certain version of a release, created by calling
<a href="./systools#make_tar/1">systools#make_tar/1</a>.
The release package is to be located in the <strong>$ROOT/releases</strong>
directory of the previous version of the release, where
<strong>$ROOT</strong> is the installation root directory,
<a href="../kernel/code#root_dir/0">kernel/code#root_dir/0</a>.
Another <strong>releases</strong> directory can be specified using the SASL
configuration parameter <strong>releases_dir</strong> or the OS environment
variable <strong>RELDIR</strong>. The release handler must have write access
to this directory to install the new release.
The persistent state of the release handler is stored there in a
file called <strong>RELEASES</strong>.A release package is always to contain:<ul><li>A release resource file, <strong>Name.rel</strong></li><li>A boot script, <strong>Name.boot</strong></li></ul>The <strong>.rel</strong> file contains information about the release: its name,
version, and which ERTS and application versions it uses.A release package can also contain:<ul><li>A release upgrade file, <strong>relup</strong></li><li>A system configuration file, <strong>sys.config</strong></li><li>A system configuration source file, <strong>sys.config.src</strong></li></ul>The <strong>relup</strong> file contains instructions for how to upgrade
to, or downgrade from, this version of the release.The release package can be <em>unpacked</em>, which extracts
the files. An unpacked release can be <em>installed</em>.
The currently used version of the release is then upgraded or
downgraded to the specified version by evaluating the instructions
in the <strong>relup</strong> file. An installed release can be made
<em>permanent</em>. Only one permanent release can exist in
the system, and this release is used if the system
is restarted. An installed release, except the permanent one,
can be <em>removed</em>. When a release is removed, all files
belonging to that release only are deleted.Each release version has a status, which can be
<strong>unpacked</strong>, <strong>current</strong>, <strong>permanent</strong>, or <strong>old</strong>.
There is always one latest release, which either has status
<strong>permanent</strong> (normal case) or <strong>current</strong> (installed, but
not yet made permanent). The meaning of the status values are
illustrated in the following table:<pre>
        Status     Action                NextStatus
        -------------------------------------------
        -          unpack                unpacked
        unpacked   install               current
                   remove                -
        current    make_permanent        permanent
                   install other         old
                   remove                -
        permanent  make other permanent  old
                   install               permanent
        old        reboot_old            permanent
                   install               current
                   remove                -</pre>The release handler process is a locally registered process on
each node. When a release is installed in a distributed system,
the release handler on each node must be called. The release
installation can be synchronized between nodes. From an operator
view, it can be unsatisfactory to specify each node. The aim is
to install one release package in the system, no matter how many
nodes there are. It is recommended that
software management functions are written that take care of
this problem. Such a function can have knowledge of the system
architecture, so it can contact each individual release handler
to install the package.For release handling to work properly, the runtime system must
know which release it is running. It
must also be able to change (in runtime) which boot script and
system configuration file are to be used if the system is
restarted. This is taken care of automatically if Erlang is
started as an embedded system. Read about this in
<a href="./users_guide">Embedded System</a> in
<em>System Documentation</em>. In this case, the system
configuration file <strong>sys.config</strong> is mandatory.The installation of a new release can restart the system. Which
program to use is specified by the SASL configuration
parameter <strong>start_prg</strong>, which defaults
to <strong>$ROOT/bin/start</strong>.The emulator restart on Windows NT expects that the system is
started using the <strong>erlsrv</strong> program (as a service).
Furthermore, the release handler expects that the service is named
<strong>NodeName</strong>_<strong>Release</strong>, where <strong>NodeName</strong> is
the first part of the Erlang node name (up to, but not including
the "@") and <strong>Release</strong> is the current release version.
The release handler furthermore expects that a
program like <strong>start_erl.exe</strong> is specified as "machine" to
<strong>erlsrv</strong>. During upgrading with restart, a new service
is registered and started. The new service is set to
automatic and the old service is removed when the new release
is made permanent.The release handler at a node running on a diskless machine,
or with a read-only file system, must be configured accordingly
using the following SASL configuration parameters (for
details, see <a href="sasl_app">sasl(6)</a>):<dl><dt><strong>masters</strong></dt><dd> <p>This node uses some master nodes to store
and fetch release information. All master nodes must be
operational whenever release information is written by this
node.</p> </dd><dt><strong>client_directory</strong></dt><dd> <p>The <strong>client_directory</strong> in the directory structure of
the master nodes must be specified.</p> </dd><dt><strong>static_emulator</strong></dt><dd> <p>This parameter specifies if the Erlang emulator is
statically installed at the client node. A node with a static
emulator cannot dynamically switch to a new emulator, as
the executable files are statically written into memory.</p> </dd></dl>The release handler can also be used to unpack and
install release packages when not running Erlang as an embedded
system. However, in this case the user must somehow ensure that
correct boot scripts and configuration files are used if
the system must be restarted.Functions are provided for using another file structure
than the structure defined in OTP. These functions can be used
to test a release upgrade locally.</p><h1>Functions</h1><h2>check_install_release(Vsn) -&gt; {ok, OtherVsn, Descr} | {error, Reason}</h2><h2>check_install_release(Vsn,Opts) -&gt; {ok, OtherVsn, Descr} | {error, Reason}</h2><p>Checks installation of a release in the system.</p><ul><li><span class="v">Vsn = OtherVsn = string()</span></li><li><span class="v">Opts = [Opt]</span></li><li><span class="v">Opt = purge</span></li><li><span class="v">Descr = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Checks if the specified version <strong>Vsn</strong> of the release
can be installed. The release must not have status
<strong>current</strong>. Issues warnings if <strong>relup</strong> file or
<strong>sys.config</strong> is not present. If <strong>relup</strong> file is present,
its contents are checked and <strong>{error,Reason}</strong> is
returned if an error is found. Also checks that all required
applications are present and that all new code can be loaded;
<strong>{error,Reason}</strong> is returned if an error is found.</p><p>Evaluates all instructions that occur before
the <strong>point_of_no_return</strong> instruction in the release
upgrade script.</p><p>Returns the same as 
<a href="#install_release/1">install_release/1</a>.
<strong>Descr</strong> defaults to "" if no <strong>relup</strong> file is found.</p><p>If option <strong>purge</strong> is specified, all old code that can
be soft-purged is purged after all other checks are
successfully completed. This can be useful to
reduce the time needed by <a href="#install_release/1">install_release/1</a>.</p><h2>create_RELEASES(Root, RelDir, RelFile, AppDirs) -&gt; ok | {error, Reason}</h2><p>Creates an initial <strong>RELEASES</strong> file.</p><ul><li><span class="v">Root = RelDir = RelFile = string()</span></li><li><span class="v">AppDirs = [{App, Vsn, Dir}]</span></li><li><span class="v">Â App = atom()</span></li><li><span class="v">Â Vsn = Dir = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Creates an initial <strong>RELEASES</strong> file to be used by the
release handler. This file must exist to install new
releases.</p><p><strong>Root</strong> is the root of the installation (<strong>$ROOT</strong>) as
described earlier. <strong>RelDir</strong> is the directory where
the <strong>RELEASES</strong> file is to be created (normally
<strong>$ROOT/releases</strong>). <strong>RelFile</strong> is the name
of the <strong>.rel</strong> file that describes the initial release,
including the extension <strong>.rel</strong>.</p><p><strong>AppDirs</strong> can be used to specify from where the modules
for the specified applications are to be loaded. <strong>App</strong> is
the name of an application, <strong>Vsn</strong> is the version, and
<strong>Dir</strong> is the name of the directory where <strong>App-Vsn</strong>
is located. The corresponding modules are to be located under
<strong>Dir/App-Vsn/ebin</strong>. The directories for applications not
specified in <strong>AppDirs</strong> are assumed to be located in
<strong>$ROOT/lib</strong>.</p><h2>install_file(Vsn, File) -&gt; ok | {error, Reason}</h2><p>Installs a release file in the release structure.</p><ul><li><span class="v">Vsn = File = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Installs a release-dependent file in the release structure.
The release-dependent file must be in
the release structure when a new release is installed:
<strong>start.boot</strong>, <strong>relup</strong>, and <strong>sys.config</strong>.</p><p>The function can be called, for example, when these files
are generated at the target. The function is to be called after
<a href="#set_unpacked/2">set_unpacked/2</a> 
has been called.</p><h2>install_release(Vsn) -&gt; {ok, OtherVsn, Descr} | {error, Reason}</h2><h2>install_release(Vsn, [Opt]) -&gt; {ok, OtherVsn, Descr} | {continue_after_restart, OtherVsn, Descr} | {error, Reason}</h2><p>Installs a release in the system.</p><ul><li><span class="v">Vsn = OtherVsn = string()</span></li><li><span class="v">Opt = {error_action, Action} | {code_change_timeout, Timeout}</span></li><li><span class="v">Â Â Â | {suspend_timeout, Timeout} | {update_paths, Bool}</span></li><li><span class="v">Â Action = restart | reboot</span></li><li><span class="v">Â Timeout = default | infinity | pos_integer()</span></li><li><span class="v">Â Bool = boolean()</span></li><li><span class="v">Descr = term()</span></li><li><span class="v">Reason = {illegal_option, Opt} | {already_installed, Vsn} | {change_appl_data, term()} | {missing_base_app, OtherVsn, App} | {could_not_create_hybrid_boot, term()} | term()</span></li><li><span class="v">App = atom()</span></li></ul><p>Installs the specified version <strong>Vsn</strong> of the release.
Looks first for a <strong>relup</strong> file for <strong>Vsn</strong> and a
script <strong>{UpFromVsn,Descr1,Instructions1}</strong> in this file
for upgrading from the current version. If not found,
the function looks for a <strong>relup</strong> file for the current
version and a script <strong>{Vsn,Descr2,Instructions2}</strong> in this
file for downgrading to <strong>Vsn</strong>.</p><p>If a script is found, the first thing that happens is that
the application specifications are updated according to
the <strong>.app</strong> files and <strong>sys.config</strong> belonging to
the release version <strong>Vsn</strong>.</p><p>After the application specifications have been updated,
the instructions in the script are evaluated and the function
returns <strong>{ok,OtherVsn,Descr}</strong> if successful.
<strong>OtherVsn</strong> and <strong>Descr</strong> are the version
(<strong>UpFromVsn</strong> or <strong>Vsn</strong>) and description
(<strong>Descr1</strong> or <strong>Descr2</strong>) as specified in the script.</p><p>If <strong>{continue_after_restart,OtherVsn,Descr}</strong> is
returned, the emulator is restarted
before the upgrade instructions are executed. This
occurs if the emulator or any of the applications
Kernel, STDLIB, or SASL
are updated. The new emulator version
and these core applications execute after the restart.
For all other applications the old versions are
started and the upgrade is performed as normal by
executing the upgrade instructions.</p><p>If a recoverable error occurs, the function returns
<strong>{error,Reason}</strong> and the original application
specifications are restored. If a non-recoverable error
occurs, the system is restarted.</p><p><em>Options</em>:</p><dl><dt><strong>error_action</strong></dt><dd><p>Defines if the node is to be
restarted 
(<a href="../erts/init#restart/0">erts/init#restart/0</a>) 
or rebooted
(<a href="../erts/init#reboot/0">erts/init#reboot/0</a>) 
if there is an error during
the installation. Default is <strong>restart</strong>.</p></dd><dt><strong>code_change_timeout</strong></dt><dd><p>Defines the time-out
for all calls to 
<a href="../stdlib/sys#change_code/4">stdlib/sys#change_code/4</a>.
If no value is specified or <strong>default</strong> is specified, the 
default value defined in <strong>sys</strong> is used.</p></dd><dt><strong>suspend_timeout</strong></dt><dd><p>Defines the time-out for 
all calls to 
<a href="../stdlib/sys#suspend/1">stdlib/sys#suspend/1</a>.
If no value is specified, the values defined by the <strong>Timeout</strong> 
parameter of the <strong>upgrade</strong> or <strong>suspend</strong> instructions are used.
If <strong>default</strong> is specified, the default value defined in
<strong>sys</strong> is used.</p></dd><dt><strong>{update_paths,Bool}</strong></dt><dd><p>Indicates if all
application code paths are to be updated (<strong>Bool==true</strong>)
or if only code paths for modified applications are to be
updated (<strong>Bool==false</strong>, default). This option has only
effect for other application directories than the default
<strong>$ROOT/lib/App-Vsn</strong>, that is, application directories
specified in argument <strong>AppDirs</strong> in a call to
<a href="#create_RELEASES/4">create_RELEASES/4</a> or 
<a href="#set_unpacked/2">set_unpacked/2</a>.</p> <p><em>Example:</em></p> <p>In the current version <strong>CurVsn</strong> of a release, the
application directory of <strong>myapp</strong> is
<strong>$ROOT/lib/myapp-1.0</strong>. A new version <strong>NewVsn</strong> is
unpacked outside the release handler and the release
handler is informed about this with a call as follows:</p> <pre><code class="">
release_handler:set_unpacked(RelFile, [{myapp,"1.0","/home/user"},...]).
=&gt; {ok,NewVsn}</code></pre> <p>If <strong>NewVsn</strong> is installed with option
<strong>{update_paths,true}</strong>, then
<a href="../kernel/code#lib_dir/1">kernel/code#lib_dir/1</a>
returns <strong>/home/user/myapp-1.0</strong>.</p></dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Installing a new release can be time consuming if
there are many processes in the system. The reason is that
each process must be checked for references to old code
before a module can be purged. This check can lead to
garbage collections and copying of data.</p><p>To speed up the execution of
<a href="#install_release/1">install_release/1</a>, 
first call <a href="#check_install_release/1">check_install_release/1</a>,
using option <strong>purge</strong>. This does the same
check for old code. Then purges all modules that can be
soft-purged. The purged modules do then no longer have any
old code, and 
<a href="#install_release/1">install_release/1</a>
does not need to do the
checks.</p><p>This does not reduce the overall time for the
upgrade, but it allows checks and purge to be executed
in the background before the real upgrade is started.</p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>When upgrading the emulator from a version older than OTP
R15, an attempt is made to load new application beam
code into the old emulator. Sometimes the new beam
format cannot be read by the old emulator, so the code
loading fails and the complete upgrade is terminated. To
overcome this problem, the new application code is to be
compiled with the old emulator. For more information about
emulator upgrade from pre OTP R15 versions, see
<a href="./appup_cookbook">Design Principles</a> in <em>System Documentation</em>.</p></div><h2>make_permanent(Vsn) -&gt; ok | {error, Reason}</h2><p>Makes the specified release version permanent.</p><ul><li><span class="v">Vsn = string()</span></li><li><span class="v">Reason = {bad_status, Status} | term()</span></li></ul><p>Makes the specified release version <strong>Vsn</strong>
permanent.</p><h2>remove_release(Vsn) -&gt; ok | {error, Reason}</h2><p>Removes a release from the system.</p><ul><li><span class="v">Vsn = string()</span></li><li><span class="v">Reason = {permanent, Vsn} | client_node | term()</span></li></ul><p>Removes a release and its files from the system.
The release must not be the permanent release. Removes only
the files and directories not in use by another release.</p><h2>reboot_old_release(Vsn) -&gt; ok | {error, Reason}</h2><p>Reboots the system from an old release.</p><ul><li><span class="v">Vsn = string()</span></li><li><span class="v">Reason = {bad_status, Status} | term()</span></li></ul><p>Reboots the system by making the old release permanent, and
calls 
<a href="../erts/init#reboot/0">erts/init#reboot/0</a> 
directly. The release must have status <strong>old</strong>.</p><h2>set_removed(Vsn) -&gt; ok | {error, Reason}</h2><p>Marks a release as removed.</p><ul><li><span class="v">Vsn = string()</span></li><li><span class="v">Reason = {permanent, Vsn} | term()</span></li></ul><p>Makes it possible to handle removal of releases outside
the release handler. Tells the release handler that
the release is removed from the system. This function does
not delete any files.</p><h2>set_unpacked(RelFile, AppDirs) -&gt; {ok, Vsn} | {error, Reason}</h2><p>Marks a release as unpacked.</p><ul><li><span class="v">RelFile = string()</span></li><li><span class="v">AppDirs = [{App, Vsn, Dir}]</span></li><li><span class="v">Â App = atom()</span></li><li><span class="v">Â Vsn = Dir = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Makes it possible to handle unpacking of releases outside
the release handler. Tells the release handler that
the release is unpacked. <strong>Vsn</strong> is extracted from
the release resource file <strong>RelFile</strong>.</p><p><strong>AppDirs</strong> can be used to specify from where the modules
for the specified applications are to be loaded. <strong>App</strong> is
the name of an application, <strong>Vsn</strong> is the version, and
<strong>Dir</strong> is the name of the directory where <strong>App-Vsn</strong>
is located. The corresponding modules are to be located under
<strong>Dir/App-Vsn/ebin</strong>. The directories for applications not
specified in <strong>AppDirs</strong> are assumed to be located in
<strong>$ROOT/lib</strong>.</p><h2>unpack_release(Name) -&gt; {ok, Vsn} | {error, Reason}</h2><p>Unpacks a release package.</p><ul><li><span class="v">Name = Vsn = string()</span></li><li><span class="v">Reason = client_node | term()</span></li></ul><p>Unpacks a release package <strong>Name.tar.gz</strong> located in
the <strong>releases</strong> directory.</p><p>Performs some checks on the package, for example, checks
that all mandatory files are present, and extracts its
contents.</p><h2>which_releases() -&gt; [{Name, Vsn, Apps, Status}]</h2><p>Returns all known releases.</p><ul><li><span class="v">Name = Vsn = string()</span></li><li><span class="v">Apps = ["App-Vsn"]</span></li><li><span class="v">Status = unpacked | current | permanent | old</span></li></ul><p>Returns all releases known to the release handler.</p><h2>which_releases(Status) -&gt; [{Name, Vsn, Apps, Status}]</h2><p>Returns all known releases of a specific status.</p><ul><li><span class="v">Name = Vsn = string()</span></li><li><span class="v">Apps = ["App-Vsn"]</span></li><li><span class="v">Status = unpacked | current | permanent | old</span></li></ul><p>Returns all releases, known to the release handler, of a
specific status.</p><h2>Application Upgrade/Downgrade</h2><p>The following functions can be used to test upgrade and downgrade
of single applications (instead of upgrading/downgrading an entire
release). A script corresponding to the instructions in the
<strong>relup</strong> file is created
on-the-fly, based on the <strong>.appup</strong> file for the application,
and evaluated exactly in the same way as <strong>release_handler</strong>
does.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>These functions are primarily intended for simplified testing
of <strong>.appup</strong> files. They are not run within the context of
the <strong>release_handler</strong> process. They must therefore
<em>not</em> be used together with calls to
<a href="#install_release/1">install_release/1</a>, 
as this causes the
<strong>release_handler</strong> to end up in an inconsistent state.</p><p>No persistent information is updated, so these functions can
be used on any Erlang node, embedded or not. Also, using these
functions does not affect which code is loaded if there is
a reboot.</p><p>If the upgrade or downgrade fails, the application can end up
in an inconsistent state.</p></div><h1>Functions</h1><h2>upgrade_app(App, Dir) -&gt; {ok, Unpurged} | restart_emulator | {error, Reason}</h2><p>Upgrades to a new application version.</p><ul><li><span class="v">App = atom()</span></li><li><span class="v">Dir = string()</span></li><li><span class="v">Unpurged = [Module]</span></li><li><span class="v">Â Module = atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Upgrades an application <strong>App</strong> from the current
version to a new version located in <strong>Dir</strong> according to
the <strong>.appup</strong> file.</p><p><strong>App</strong> is the name of the application, which must be
started. <strong>Dir</strong> is the new library directory of
<strong>App</strong>. The corresponding modules as well as
the <strong>.app</strong> and <strong>.appup</strong> files are to be located
under <strong>Dir/ebin</strong>.</p><p>The function looks in the <strong>.appup</strong> file and tries to
find an upgrade script from the current version of
the application using
<a href="#upgrade_script/2">upgrade_script/2</a>.
This script is evaluated using
<a href="#eval_appup_script/4">eval_appup_script/4</a>,
exactly in the same way as
<a href="#install_release/1">install_release/1</a>
does.</p><p>Returns one of the following:</p><ul><li><strong>{ok, Unpurged}</strong> if evaluating the script is successful, where <strong>Unpurged</strong> is a list of unpurged modules</li><li><strong>restart_emulator</strong> if this instruction is encountered in the script</li><li><strong>{error, Reason}</strong> if an error occurred when finding or evaluating the script</li></ul><p>If the <strong>restart_new_emulator</strong> instruction is found in
the script, 
<a href="#upgrade_app/2">upgrade_app/2</a> 
returns <strong>{error,restart_new_emulator}</strong>. This because
<strong>restart_new_emulator</strong> requires a new version of the
emulator to be started before the rest of the upgrade
instructions can be executed, and this can only be done by
<a href="#install_release/1">install_release/1</a>.</p><h2>downgrade_app(App, Dir) -&gt;</h2><h2>downgrade_app(App, OldVsn, Dir) -&gt; {ok, Unpurged} | restart_emulator | {error, Reason}</h2><p>Downgrades to a previous application version.</p><ul><li><span class="v">App = atom()</span></li><li><span class="v">Dir = OldVsn = string()</span></li><li><span class="v">Unpurged = [Module]</span></li><li><span class="v">Â Module = atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Downgrades an application <strong>App</strong> from the current
version to a previous version <strong>OldVsn</strong> located in
<strong>Dir</strong> according to the <strong>.appup</strong> file.</p><p><strong>App</strong> is the name of the application, which must be
started. <strong>OldVsn</strong> is the previous application version
and can be omitted if <strong>Dir</strong> is of
the format <strong>"App-OldVsn"</strong>. <strong>Dir</strong> is the library
directory of the previous version of <strong>App</strong>.
The corresponding modules and the old <strong>.app</strong> file
are to be located under <strong>Dir/ebin</strong>. The <strong>.appup</strong>
file is to be located in the <strong>ebin</strong> directory of
the <em>current</em> library directory of the application
(<a href="../kernel/code#lib_dir/1">kernel/code#lib_dir/1</a>).</p><p>The function looks in the <strong>.appup</strong> file and tries to
find a downgrade script to the previous version of
the application using
<a href="#downgrade_script/3">downgrade_script/3</a>.
This script is evaluated using
<a href="#eval_appup_script/4">eval_appup_script/4</a>,
exactly in the same way as
<a href="#install_release/1">install_release/1</a>
does.</p><p>Returns one of the following:</p><ul><li><strong>{ok, Unpurged}</strong> if evaluating the script is successful, where <strong>Unpurged</strong> is a list of unpurged modules</li><li><strong>restart_emulator</strong> if this instruction is encountered in the script</li><li><strong>{error, Reason}</strong> if an error occurred when finding or evaluating the script</li></ul><h2>upgrade_script(App, Dir) -&gt; {ok, NewVsn, Script}</h2><p>Finds an application upgrade script.</p><ul><li><span class="v">App = atom()</span></li><li><span class="v">Dir = string()</span></li><li><span class="v">NewVsn = string()</span></li><li><span class="v">Script = Instructions</span></li></ul><p>Tries to find an application upgrade script for <strong>App</strong>
from the current version to a new version located in
<strong>Dir</strong>.</p><p>The upgrade script can then be evaluated using
<a href="#eval_appup_script/4">eval_appup_script/4</a>.
It is recommended to use
<a href="#upgrade_app/2">upgrade_app/2</a>
instead, but this function (<strong>upgrade_script</strong>) is useful
to inspect the contents of the script.</p><p><strong>App</strong> is the name of the application, which must be
started. <strong>Dir</strong> is the new library directory of
<strong>App</strong>. The corresponding modules as well as
the <strong>.app</strong> and <strong>.appup</strong> files are to be located
under <strong>Dir/ebin</strong>.</p><p>The function looks in the <strong>.appup</strong> file and tries to
find an upgrade script from the current application version.
High-level instructions are translated to
low-level instructions. The instructions are sorted in
the same manner as when generating a <strong>relup</strong> file.</p><p>Returns <strong>{ok, NewVsn, Script}</strong> if successful, where
<strong>NewVsn</strong> is the new application version.
For details about <strong>Script</strong>, see 
<a href="appup">appup</a>.</p><p>Failure: If a script cannot be found, the function fails
with an appropriate error reason.</p><h2>downgrade_script(App, OldVsn, Dir) -&gt; {ok, Script}</h2><p>Finds an application downgrade script.</p><ul><li><span class="v">App = atom()</span></li><li><span class="v">OldVsn = Dir = string()</span></li><li><span class="v">Script = Instructions</span></li></ul><p>Tries to find an application downgrade script for <strong>App</strong>
from the current version to a previous version <strong>OldVsn</strong>
located in <strong>Dir</strong>.</p><p>The downgrade script can then be evaluated using
<a href="#eval_appup_script/4">eval_appup_script/4</a>.
It is recommended to use
<a href="#downgrade_app/2">downgrade_app/2</a>
instead, but this function (<strong>downgrade_script</strong>) is useful
to inspect the contents of the script.</p><p><strong>App</strong> is the name of the application, which must be
started. <strong>Dir</strong> is the previous library directory of
<strong>App</strong>. The corresponding modules and
the old <strong>.app</strong> file are to be located under
<strong>Dir/ebin</strong>. The <strong>.appup</strong> file is to be located in
the <strong>ebin</strong> directory of the <em>current</em> library
directory of the application 
(<a href="../kernel/code#lib_dir/1">)</a>.</p><p>The function looks in the <strong>.appup</strong> file and tries to
find a downgrade script from the current application version.
High-level instructions are translated to
low-level instructions. The instructions are sorted in
the same manner as when generating a <strong>relup</strong> file.</p><p>Returns <strong>{ok, Script}</strong> if successful. 
For details about <strong>Script</strong>, see 
<a href="appup">appup</a>.</p><p>Failure: If a script cannot be found, the function fails
with an appropriate error reason.</p><h2>eval_appup_script(App, ToVsn, ToDir, Script) -&gt; {ok, Unpurged} | restart_emulator | {error, Reason}</h2><p>Evaluates an application upgrade or downgrade script.</p><ul><li><span class="v">App = atom()</span></li><li><span class="v">ToVsn = ToDir = string()</span></li><li><span class="v">Script</span></li><li><span class="d">See , </span></li><li><span class="v">Unpurged = [Module]</span></li><li><span class="v">Â Module = atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Evaluates an application upgrade or downgrade script
<strong>Script</strong>, the result from calling
<a href="#upgrade_script/2">upgrade_script/2</a> or
<a href="#downgrade_script/3">downgrade_script/3</a>,
exactly in the same way as
<a href="#install_release/1">install_release/1</a>
does.</p><p><strong>App</strong> is the name of the application, which must be
started. <strong>ToVsn</strong> is the version to be upgraded/downgraded
to, and <strong>ToDir</strong> is the library directory of this version.
The corresponding modules as well as the <strong>.app</strong> and
<strong>.appup</strong> files are to be located under <strong>Dir/ebin</strong>.</p><p>Returns one of the following:</p><ul><li><strong>{ok, Unpurged}</strong> if evaluating the script is successful, where <strong>Unpurged</strong> is a list of unpurged modules</li><li><strong>restart_emulator</strong> if this instruction is encountered in the script</li><li><strong>{error, Reason}</strong> if an error occurred when finding or evaluating the script</li></ul><p>If the <strong>restart_new_emulator</strong> instruction is found in
the script, 
<a href="#eval_appup_script/4">eval_appup_script/4</a>
returns <strong>{error,restart_new_emulator}</strong>. This because
<strong>restart_new_emulator</strong> requires a new version of the
emulator to be started before the rest of the upgrade
instructions can be executed, and this can only be done by
<a href="#install_release/1">install_release/1</a>.</p><h2>Typical Error Reasons</h2><dl><dt><strong>{bad_masters, Masters}</strong></dt><dd><p>The master nodes <strong>Masters</strong> are not alive.</p></dd><dt><strong>{bad_rel_file, File}</strong></dt><dd><p>Specified <strong>.rel</strong> file <strong>File</strong> cannot be read or
does not contain a single term.</p></dd><dt><strong>{bad_rel_data, Data}</strong></dt><dd><p>Specified <strong>.rel</strong> file does not contain a recognized
release specification, but another term <strong>Data</strong>.</p></dd><dt><strong>{bad_relup_file, File}</strong></dt><dd><p>Specified <strong>relup</strong> file <strong>Relup</strong> contains bad
data.</p></dd><dt><strong>{cannot_extract_file, Name, Reason}</strong></dt><dd><p>Problems when extracting from a tar file,
<a href="../stdlib/erl_tar#extract/2">stdlib/erl_tar#extract/2</a>
returned <strong>{error, {Name, Reason}}</strong>.</p></dd><dt><strong>{existing_release, Vsn}</strong></dt><dd><p>Specified release version <strong>Vsn</strong> is already
in use.</p></dd><dt><strong>{Master, Reason, When}</strong></dt><dd><p>Some operation, indicated by the term <strong>When</strong>, failed
on the master node <strong>Master</strong> with the specified error
reason <strong>Reason</strong>.</p></dd><dt><strong>{no_matching_relup, Vsn, CurrentVsn}</strong></dt><dd><p>Cannot find a script for upgrading/downgrading between
<strong>CurrentVsn</strong> and <strong>Vsn</strong>.</p></dd><dt><strong>{no_such_directory, Path}</strong></dt><dd><p>The directory <strong>Path</strong>does not exist.</p></dd><dt><strong>{no_such_file, Path}</strong></dt><dd><p>The path <strong>Path</strong> (file or directory) does not
exist.</p></dd><dt><strong>{no_such_file, {Master, Path}}</strong></dt><dd><p>The path <strong>Path</strong> (file or directory) does not exist at
the master node <strong>Master</strong>.</p></dd><dt><strong>{no_such_release, Vsn}</strong></dt><dd><p>The specified release version <strong>Vsn</strong> does not
exist.</p></dd><dt><strong>{not_a_directory, Path}</strong></dt><dd><p><strong>Path</strong> exists but is not a directory.</p></dd><dt><strong>{Posix, File}</strong></dt><dd><p>Some file operation failed for <strong>File</strong>. <strong>Posix</strong>
is an atom named from the Posix error codes, such as
<strong>enoent</strong>, <strong>eacces</strong>, or <strong>eisdir</strong>. See
<a href="./file">kernel/file</a>
in Kernel.</p></dd><dt><strong>Posix</strong></dt><dd><p>Some file operation failed, as for the previous item in
the list.</p></dd></dl><h2>See Also</h2><p><a href="./users_guide">OTP Design Principles</a>,
<a href="./config">kernel/config</a>,
<a href="rel">rel</a>,
<a href="relup">relup</a>,
<a href="script">script</a>,
<a href="./sys">stdlib/sys</a>,
<a href="systools">systools</a></p></body></html>