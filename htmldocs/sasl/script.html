<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>script</h1><h1>script</h1><p>Boot script</p><p>The <em>boot script</em> describes how the Erlang runtime system
is started. It contains instructions on which code to load and
which processes and applications to start.Command <strong>erl -boot Name</strong> starts the system with a boot
file called <strong>Name.boot</strong>, which is generated from the
<strong>Name.script</strong> file, using 
<a href="./systools#script2boot/1">systools#script2boot/1</a>.The <strong>.script</strong> file is generated by <strong>systools</strong> from a
<strong>.rel</strong> file and from <strong>.app</strong> files.</p><h2>File Syntax</h2><p>The boot script is stored in a file with extension
<strong>.script</strong>. The file has the following syntax:</p><pre><code class="">
{script, {Name, Vsn},
 [
  {progress, loading},
  {preLoaded, [Mod1, Mod2, ...]},
  {path, [Dir1,"$ROOT/Dir",...]}.
  {primLoad, [Mod1, Mod2, ...]},
  ...
  {kernel_load_completed},
  {progress, loaded},
  {kernelProcess, Name, {Mod, Func, Args}},
  ...
  {apply, {Mod, Func, Args}},
  ...
  {progress, started}]}.</code></pre><dl><dt><strong>Name = string()</strong></dt><dd><p>Defines the system name.</p></dd><dt><strong>Vsn = string()</strong></dt><dd><p>Defines the system version.</p></dd><dt><strong>{progress, Term}</strong></dt><dd><p>Sets the "progress" of the initialization
program. The
<a href="../erts/init#get_status/0">erts/init#get_status/0</a>
function returns the current value of the progress, which is
<strong>{InternalStatus,Term}</strong>.</p></dd><dt><strong>{path, [Dir]}</strong></dt><dd><p><strong>Dir</strong> is a string. This
argument sets the load path of the system to <strong>[Dir]</strong>. The
load path used to load modules is obtained from the initial
load path, which is given in the script file, together with
any path flags that were supplied in the command-line
arguments. The command-line arguments modify the path as
follows:</p> <ul><li><strong>-pa Dir1 Dir2 ... DirN</strong> adds the directories <strong>DirN, DirN-1, ..., Dir2, Dir1</strong> to the front of the initial load path.</li><li><strong>-pz Dir1 Dir2 ... DirN</strong> adds the directories <strong>Dir1, Dir2, ..., DirN</strong> to the end of the initial load path.</li><li> <p><strong>-path Dir1 Dir2 ... DirN</strong> defines a set of
directories <strong>Dir1, Dir2, ..., DirN</strong>, which replace
the search path given in the script file. Directory names
in the path are interpreted as follows:</p> <ul><li>Directory names starting with <strong>/</strong> are assumed to be absolute path names.</li><li>Directory names not starting with <strong>/</strong> are assumed to be relative the current working directory.</li><li>The special <strong>$ROOT</strong> variable can only be used in the script, not as a command-line argument. The given directory is relative the Erlang installation directory.</li></ul> </li></ul> </dd><dt><strong>{primLoad, [Mod]}</strong></dt><dd><p>Loads the modules <strong>[Mod]</strong>
from the directories specified in <strong>Path</strong>. The script
interpreter fetches the appropriate module by calling
<a href="../erts/erl_prim_loader#get_file/1">erts/erl_prim_loader#get_file/1</a>. A fatal error
that terminates the system occurs if the module cannot be
located.</p></dd><dt><strong>{kernel_load_completed}</strong></dt><dd><p>Indicates that all modules
that <em>must</em> be loaded <em>before</em> any processes
are started are loaded. In interactive mode, all
<strong>{primLoad,[Mod]}</strong> commands interpreted after this
command are ignored, and these modules are loaded on demand.
In embedded mode, <strong>kernel_load_completed</strong> is ignored, and
all modules are loaded during system start.</p></dd><dt><strong>{kernelProcess, Name, {Mod, Func, Args}}</strong></dt><dd><p>Starts the
"kernel process" <strong>Name</strong>
by evaluating <strong>apply(Mod, Func, Args)</strong>. The start function is
to return <strong>{ok, Pid}</strong> or <strong>ignore</strong>. The <strong>init</strong>
process monitors the behavior of <strong>Pid</strong> and terminates
the system if <strong>Pid</strong> dies. Kernel processes are key
components of the runtime system. Users do not normally add
new kernel processes.</p></dd><dt><strong>{apply, {Mod, Func, Args}}</strong>.</dt><dd><p>The init process
evaluates <strong>apply(Mod, Func, Args)</strong>. The system
terminates if this results in an error. The boot procedure
hangs if this function never returns.</p></dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>In an interactive system, the code loader provides
demand-driven code loading, but in an embedded system
the code loader loads all code immediately. The same
version of <a href="./code">kernel/code</a>
is used in both cases. The code server calls
<a href="../erts/init#get_argument/1">erts/init#get_argument/1</a>
to determine if it is to run in demand mode or non-demand
driven mode.</p></div><h2>See Also</h2><p><a href="systools">systools</a></p></body></html>