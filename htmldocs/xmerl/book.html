<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>xmerl</h1><h1>xmerl</h1><p>The <em>xmerl</em> application 
contains modules with support for processing of xml files compliant to XML 1.0.
</p><h4>Introduction</h4><h4>Features</h4><p>The <em>xmerl</em> XML parser is able to parse XML documents
according to the XML 1.0 standard. As default it performs
well-formed parsing, (syntax checks and checks of well-formed
constraints). Optionally one can also use xmerl as a validating
parser, (validate according to referenced DTD and validating
constraints). By means of for example the xmerl_xs module it is
possible to transform the parsed result to other formats,
e.g. text, HTML, XML etc.</p><h4>Overview</h4><p>This document does not give an introduction to XML. There
are a lot of books available that describe XML from
different views. At the <a href="http://www.w3.org">www.W3.org</a> site you will find
the <a href="http://www.w3.org/TR/REC-xml/">XML 1.0 specification</a> and other related specs. One site were
you can find tutorials on XML and related specs is <a href="http://www.zvon.org">ZVON.org</a>.</p><p>However, here you will find some examples of how to use
and to what you can use xmerl. A detailed description of the
user interface can be found in the reference manual.</p><p>There are two known shortcomings in xmerl:</p><ul><li>It cannot retrieve external entities on the Internet by a URL reference, only resources in the local file system.</li><li>xmerl can parse Unicode encoded data. But, it fails on tag names, attribute names and other mark-up names that are encoded Unicode characters not mapping on ASCII.</li></ul><p>By parsing an XML document you will get a record,
displaying the structure of the document, as return
value. The record also holds the data of the document. xmerl
is convenient to use in for instance the following scenarios:</p><p>You need to retrieve data from XML documents. Your
Erlang software can handle information from the XML document
by extracting data from the data structure received by
parsing.</p><p>It is also possible to do further processing of parsed
XML with xmerl. If you want to change format of the XML
document to for instance HTML, text or other XML format you
can transform it. There is support for such transformations
in xmerl.</p><p>One may also convert arbitrary data to XML. So it for
instance is easy to make it readable by humans. In this case
you first create xmerl data structures out of your data, then
transform it to XML. </p><p>You can find examples of these three examples of usage
below.</p><h4>xmerl User Interface Data Structure</h4><p>The following records used by xmerl to save the parsed
data are defined in <strong>xmerl.hrl</strong></p><p>The result of a successful parsing is a tuple
<strong>{DataStructure,M}</strong>. <strong>M</strong> is the XML production Misc,
which is the mark-up that comes after the element of the
document. It is returned "as is". <strong>DataStructure</strong> is an
<strong>xmlElement</strong> record, that among others have the fields
<strong>name</strong>, <strong>parents</strong>, <strong>attributes</strong> and
<strong>content</strong> like:</p><pre>
#xmlElement{name=Name,
            ...
            parents=Parents,
            ...
            attributes=Attrs,
            content=Content,
            ...}    </pre><p>The name of the element is found in the <strong>name</strong>
field. In the <strong>parents</strong> field is the names of the parent
elements saved. Parents is a list of tuples where the first
element in each tuple is the name of the parent element. The
list is in reverse order.</p><p>The record <strong>xmlAttribute</strong> holds the name and value of
an attribute in the fields <strong>name</strong> and <strong>value</strong>. All
attributes of an element is a list of xmlAttribute in the
field <strong>attributes</strong> of the xmlElement record.
</p><p>The <strong>content</strong> field of the top element is a list of
records that shows the structure and data of the document. If
it is a simple document like: </p><pre>
&lt;?xml version="1.0"?&gt;
&lt;dog&gt;
Grand Danois
&lt;/dog&gt;    </pre><p>The parse result will be:</p><pre>
#xmlElement{name = dog,
            ...
            parents = [],
            ...
            attributes = [],
            content = [{xmlText,[{dog,1}],1,[],"\
Grand Danois\
",text}],
            ...
            }    </pre><p>Where the content of the top element is:
<strong>[{xmlText,[{dog,1}],1,[],"\ Grand Danois\ ",text}]</strong>. Text will be returned in <strong>xmlText</strong> records. Though,
usually documents are more complex, and the content of the top
element will in that case be a nested structure with
xmlElement records that in turn may have complex content. All of
this reflects the structure of the XML document.</p><p>Space characters between mark-up as <strong>space</strong>,
<strong>tab</strong> and <strong>line feed</strong> are normalized and returned as
xmlText records.</p><h4>Errors</h4><p>An unsuccessful parse results in an error, which may be a
tuple <strong>{error,Reason}</strong> or an exit:
<strong>{'EXIT',Reason}</strong>. According to the XML 1.0 standard
there are <strong>fatal error</strong> and <strong>error</strong> situations. The
fatal errors <em>must</em> be detected by a conforming parser
while an error <em>may</em> be detected. Both categories of
errors are reported as fatal errors by this version of xmerl,
most often as an exit.</p><h4>Getting Started</h4><p>In the following examples we use the XML file
"motorcycles.xml" and the corresponding DTD
"motorcycles.dtd". motorcycles.xml looks like:
<a name="motorcyclesxml"></a>
</p><pre><code class="">

&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE motorcycles SYSTEM "motorcycles.dtd"&gt;
&lt;motorcycles&gt;
  &lt;bike year="2000" color="black"&gt;
    &lt;name&gt;
      &lt;manufacturer&gt;Suzuki&lt;/manufacturer&gt;
      &lt;brandName&gt;Suzuki VL 1500&lt;/brandName&gt;
      &lt;additionalName&gt;Intruder&lt;/additionalName&gt;
    &lt;/name&gt;
    &lt;engine&gt;V-engine, 2-cylinders, 1500 cc&lt;/engine&gt;
    &lt;kind&gt;custom&lt;/kind&gt;
    &lt;drive&gt;cardan&lt;/drive&gt;
    &lt;accessories&gt;Sissy bar, luggage carrier,V&amp;amp;H exhaust pipes&lt;/accessories&gt;
  &lt;/bike&gt;
  &lt;date&gt;2004.08.25&lt;/date&gt;
  &lt;bike year="1983" color="read pearl"&gt;
    &lt;name&gt;
      &lt;manufacturer&gt;Yamaha&lt;/manufacturer&gt;
      &lt;brandName&gt;XJ 400&lt;/brandName&gt;
    &lt;/name&gt;
    &lt;engine&gt;4 cylinder, 400 cc&lt;/engine&gt;
    &lt;kind&gt;alround&lt;/kind&gt;
    &lt;drive&gt;chain&lt;/drive&gt;
    &lt;comment&gt;Good shape!&lt;/comment&gt;
  &lt;/bike&gt;
&lt;/motorcycles&gt;
</code></pre><p>and motorcycles.dtd looks like: </p><pre><code class="">

&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!ELEMENT motorcycles (bike,date?)+ &gt;
&lt;!ELEMENT bike        (name,engine,kind,drive, accessories?,comment?) &gt;
&lt;!ELEMENT name        (manufacturer,brandName,additionalName?) &gt;
&lt;!ELEMENT manufacturer       (#PCDATA)&gt;
&lt;!ELEMENT brandName         (#PCDATA)&gt;
&lt;!ELEMENT additionalName    (#PCDATA)&gt;
&lt;!ELEMENT engine             (#PCDATA)&gt;
&lt;!ELEMENT kind               (#PCDATA)&gt;
&lt;!ELEMENT drive              (#PCDATA)&gt;
&lt;!ELEMENT comment            (#PCDATA)&gt;
&lt;!ELEMENT accessories        (#PCDATA)&gt;

&lt;!-- Date of the format yyyy.mm.dd --&gt;
&lt;!ELEMENT date              (#PCDATA)&gt;
&lt;!ATTLIST  bike year NMTOKEN #REQUIRED
                color NMTOKENS #REQUIRED
                condition (useless | bad | serviceable | moderate | good |
                           excellent | new | outstanding) "excellent" &gt;
</code></pre><p>If you want to parse the XML file motorcycles.xml you run
it in the Erlang shell like:</p><pre>
3&gt; {ParsResult,Misc}=xmerl_scan:file("motorcycles.xml"). 
{{xmlElement,motorcycles,
             motorcycles,
             [],
             {xmlNamespace,[],[]},
             [],
             1,
             [],
             [{xmlText,[{motorcycles,1}],1,[],"\
  ",text},
              {xmlElement,bike,
                          bike,
                          [],
                          {xmlNamespace,[],[]},
                          [{motorcycles,1}],
                          2,
                          [{xmlAttribute,year,[],[],[],[]|...},
                           {xmlAttribute,color,[],[],[]|...}],
                          [{xmlText,[{bike,2},{motorcycles|...}],
                                    1,
                                    []|...},
                           {xmlElement,name,name,[]|...},
                           {xmlText,[{...}|...],3|...},
                           {xmlElement,engine|...},
                           {xmlText|...},
                           {...}|...],
                          [],
                          ".",
                          undeclared},
              ...
              ],
             [],
             ".",
             undeclared},
 []}
4&gt;     </pre><p>If you instead receives the XML doc as a string you can
parse it by <strong>xmerl_scan:string/1</strong>. Both file/2 and string/2
exists where the second argument is a list of options to the
parser, see the <a href="xmerl_scan">reference manual</a>.</p><h4>Example: Extracting Data From XML Content</h4><p>In this example consider the situation where you want to
examine a particular data in the XML file. For instance, you
want to check for how long each motorcycle have been recorded.</p><p>Take a look at the DTD and observe that the structure of an
XML document that is conformant to this DTD must have one
motorcycles element (the root element). The motorcycles element
must have at least one bike element. After each bike element it
may be a date element. The content of the date element is
#PCDATA (Parsed Character DATA), i.e. raw text. Observe that if
#PCDATA must have a <strong>"&lt;"</strong> or a <strong>"&amp;"</strong> character it must
be written as <strong>"&amp;lt;"</strong> and <strong>"&amp;amp;"</strong>
respectively. Also other character entities exists similar to
the ones in HTML and SGML.</p><p>If you successfully parse the XML file with the validation
on as in:
<strong>xmerl_scan:file('motorcycles.xml',[{validation,true}])</strong>
you know that the XML document is valid and has the structure
according to the DTD.</p><p>Thus, knowing the allowed structure it is easy to write a
program that traverses the data structure and picks the
information in the xmlElements records with name date.</p><p>Observe that white space: each space, tab or line feed,
between mark-up results in an xmlText record.</p><h4>Example: Create XML Out Of Arbitrary Data</h4><p>For this task there are more than one way to go. The "brute
force" method is to create the records you need and feed your
data in the content and attribute fields of the appropriate
element.</p><p>There is support for this in xmerl by the "simple-form"
format. You can put your data in a simple-form data structure
and feed it into
<strong>xmerl:export_simple(Content,Callback,RootAttributes)</strong>. Content
may be a mixture of simple-form and xmerl records as xmlElement
and xmlText.</p><p>The Types are:</p><ul><li>Content = [Element]</li><li>Callback = atom()</li><li>RootAttributes = [Attributes]</li></ul><p>Element is any of:</p><ul><li>{Tag, Attributes, Content}</li><li>{Tag, Content}</li><li>Tag</li><li>IOString</li><li>#xmlText{}</li><li>#xmlElement{}</li><li>#xmlPI{}</li><li>#xmlComment{}</li><li>#xmlDecl{}</li></ul><p>The simple-form structure is any of <strong>{Tag, Attributes, Content}</strong>, <strong>{Tag, Content}</strong> or <strong>Tag</strong> where:</p><ul><li>Tag = atom()</li><li>Attributes = [{Name, Value}| #xmlAttribute{}]</li><li>Name = atom()</li><li>Value = IOString | atom() | integer()</li></ul><p>See also reference manual for 
<a href="./xmerl#export_simple-3">xmerl</a></p><p>If you want to add the information about a black Harley
Davidsson 1200 cc Sportster motorcycle from 2003 that is in
shape as new in the motorcycles.xml document you can put the
data in a simple-form data structure like:</p><pre>
Data =
  {bike,
     [{year,"2003"},{color,"black"},{condition,"new"}],
     [{name,
         [{manufacturer,["Harley Davidsson"]},
          {brandName,["XL1200C"]},
          {additionalName,["Sportster"]}]},
      {engine,
         ["V-engine, 2-cylinders, 1200 cc"]},
      {kind,["custom"]},
      {drive,["belt"]}]}    </pre><p>In order to append this data to the end of the
motorcycles.xml document you have to parse the file and add Data
to the end of the root element content.</p><pre>
    {RootEl,Misc}=xmerl_scan:file('motorcycles.xml'),
    #xmlElement{content=Content} = RootEl,
    NewContent=Content++lists:flatten([Data]),
    NewRootEl=RootEl#xmlElement{content=NewContent},    </pre><p>Then you can run it through the export_simple/2 function: </p><pre>
    {ok,IOF}=file:open('new_motorcycles.xml',[write]),
    Export=xmerl:export_simple([NewRootEl],xmerl_xml),
    io:format(IOF,"~s~n",[lists:flatten(Export)]),    </pre><a name="new_motorcyclesxml"></a><p>The result would be: </p><pre><code class="">

&lt;?xml version="1.0"?&gt;&lt;motorcycles&gt;
  &lt;bike year="2000" color="black"&gt;
    &lt;name&gt;
      &lt;manufacturer&gt;Suzuki&lt;/manufacturer&gt;
      &lt;brandName&gt;Suzuki VL 1500&lt;/brandName&gt;
      &lt;additionalName&gt;Intruder&lt;/additionalName&gt;
    &lt;/name&gt;
    &lt;engine&gt;V-engine, 2-cylinders, 1500 cc&lt;/engine&gt;
    &lt;kind&gt;custom&lt;/kind&gt;
    &lt;drive&gt;cardan&lt;/drive&gt;
    &lt;accessories&gt;Sissy bar, luggage carrier,V&amp;amp;H exhaust pipes&lt;/accessories&gt;
  &lt;/bike&gt;
  &lt;date&gt;2004.08.25&lt;/date&gt;
  &lt;bike year="1983" color="read pearl"&gt;
    &lt;name&gt;
      &lt;manufacturer&gt;Yamaha&lt;/manufacturer&gt;
      &lt;brandName&gt;XJ 400&lt;/brandName&gt;
    &lt;/name&gt;
    &lt;engine&gt;4 cylinder, 400 cc&lt;/engine&gt;
    &lt;kind&gt;alround&lt;/kind&gt;
    &lt;drive&gt;chain&lt;/drive&gt;
    &lt;comment&gt;Good shape!&lt;/comment&gt;
  &lt;/bike&gt;
&lt;bike year="2003" color="black" condition="new"&gt;&lt;name&gt;&lt;manufacturer&gt;Harley Davidsson&lt;/manufacturer&gt;&lt;brandName&gt;XL1200C&lt;/brandName&gt;&lt;additionalName&gt;Sportster&lt;/additionalName&gt;&lt;/name&gt;&lt;engine&gt;V-engine, 2-cylinders, 1200 cc&lt;/engine&gt;&lt;kind&gt;custom&lt;/kind&gt;&lt;drive&gt;belt&lt;/drive&gt;&lt;/bike&gt;&lt;/motorcycles&gt;
</code></pre><p>If it is important to get similar indentation and newlines
as in the original document you have to add #xmlText{} records
with space and newline values in appropriate places. It may also
be necessary to keep the original prolog where the DTD is
referenced. If so, it is possible to pass a RootAttribute
<strong>{prolog,Value}</strong> to <strong>export_simple/3</strong>. The following
example code fixes those changes in the previous example:</p><pre>
    Data =
      [#xmlText{value="  "},
       {bike,[{year,"2003"},{color,"black"},{condition,"new"}],
             [#xmlText{value="\
    "},
              {name,[#xmlText{value="\
      "},
                     {manufacturer,["Harley Davidsson"]},
                     #xmlText{value="\
      "},
                     {brandName,["XL1200C"]},
                     #xmlText{value="\
      "},
                     {additionalName,["Sportster"]},
                     #xmlText{value="\
    "}]},
              {engine,["V-engine, 2-cylinders, 1200 cc"]},
              #xmlText{value="\
    "},
              {kind,["custom"]},
              #xmlText{value="\
    "},
              {drive,["belt"]},
              #xmlText{value="\
  "}]},
       #xmlText{value="\
"}],
    ...
    NewContent=Content++lists:flatten([Data]),
    NewRootEl=RootEl#xmlElement{content=NewContent},
    ...
    Prolog = ["&lt;?xml version=\\"1.0\\" encoding=\\"utf-8\\" ?&gt;
&lt;!DOCTYPE motorcycles SYSTEM \\"motorcycles.dtd\\"&gt;\
"],
    Export=xmerl:export_simple([NewRootEl],xmerl_xml,[{prolog,Prolog}]),
    ...    </pre><p>The result will be: </p><pre><code class="">

&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE motorcycles SYSTEM "motorcycles.dtd"&gt;
&lt;motorcycles&gt;
  &lt;bike year="2000" color="black"&gt;
    &lt;name&gt;
      &lt;manufacturer&gt;Suzuki&lt;/manufacturer&gt;
      &lt;brandName&gt;Suzuki VL 1500&lt;/brandName&gt;
      &lt;additionalName&gt;Intruder&lt;/additionalName&gt;
    &lt;/name&gt;
    &lt;engine&gt;V-engine, 2-cylinders, 1500 cc&lt;/engine&gt;
    &lt;kind&gt;custom&lt;/kind&gt;
    &lt;drive&gt;cardan&lt;/drive&gt;
    &lt;accessories&gt;Sissy bar, luggage carrier,V&amp;amp;H exhaust pipes&lt;/accessories&gt;
  &lt;/bike&gt;
  &lt;date&gt;2004.08.25&lt;/date&gt;
  &lt;bike year="1983" color="read pearl"&gt;
    &lt;name&gt;
      &lt;manufacturer&gt;Yamaha&lt;/manufacturer&gt;
      &lt;brandName&gt;XJ 400&lt;/brandName&gt;
    &lt;/name&gt;
    &lt;engine&gt;4 cylinder, 400 cc&lt;/engine&gt;
    &lt;kind&gt;alround&lt;/kind&gt;
    &lt;drive&gt;chain&lt;/drive&gt;
    &lt;comment&gt;Good shape!&lt;/comment&gt;
  &lt;/bike&gt;
  &lt;bike year="2003" color="black" condition="new"&gt;
    &lt;name&gt;
      &lt;manufacturer&gt;Harley Davidsson&lt;/manufacturer&gt;
      &lt;brandName&gt;XL1200C&lt;/brandName&gt;
      &lt;additionalName&gt;Sportster&lt;/additionalName&gt;
    &lt;/name&gt;&lt;engine&gt;V-engine, 2-cylinders, 1200 cc&lt;/engine&gt;
    &lt;kind&gt;custom&lt;/kind&gt;
    &lt;drive&gt;belt&lt;/drive&gt;
  &lt;/bike&gt;
&lt;/motorcycles&gt;
</code></pre><h4>Example: Transforming XML To HTML</h4><p>Assume that you want to transform the <a href="#motorcyclesxml">motorcycles.xml</a> document to
HTML. If you want the same structure and tags of the resulting
HTML document as of the XML document then you can use the
<strong>xmerl:export/2</strong> function. The following:</p><pre>
2&gt; {Doc,Misc}=xmerl_scan:file('motorcycles.xml').
{{xmlElement,motorcycles,
             motorcycles,
             [],
             {xmlNamespace,[],[]},
             [],
             1,
             [],
             [{xmlText,[{motorcycles,1}],1,[],"\
  ",text},
              {xmlElement,bike,
...
3&gt; DocHtml=xmerl:export([Doc],xmerl_html).
["&lt;!DOCTYPE HTML PUBLIC \\"",
 "-//W3C//DTD HTML 4.01 Transitional//EN",
 "\\"",
 [],
 "&gt;\
",
 [[["&lt;","motorcycles","&gt;"],
   ["\
  ",
    [["&lt;",
      "bike",
      [[" ","year","=\\"","2000","\\""],[" ","color","=\\"","black","\\""]],
      "&gt;"],
...    </pre><p>Will give the result <a href="result_export.html">result_export.html</a></p><p>Perhaps you want to do something more arranged for human
reading. Suppose that you want to list all different brands in
the beginning with links to each group of motorcycles. You also
want all motorcycles sorted by brand, then some flashy colors
on top of it. Thus you rearrange the order of the elements and
put in arbitrary HTML tags. This is possible to do by means of
the <a href="http://www.w3.org/Style/XSL/">XSL Transformation (XSLT)</a> like functionality in xmerl. </p><p>Even though the following example shows one way to transform data
from XML to HTML it also applies to transformations to other
formats.</p><p><strong>xmerl_xs</strong> does not implement the entire XSLT
specification but the basic functionality. For all details see
the <a href="xmerl_xs">reference manual</a></p><p>First, some words about the xmerl_xs functionality:</p><p>You need to write template functions to be able to control
what kind of output you want. Thus if you want to encapsulate a
<strong>bike</strong> element in &lt;p&gt; tags you simply write a
function:</p><pre>
template(E = #xmlElement{name='bike'}) -&gt;
    ["&lt;p&gt;",xslapply(fun template/1,E),"&lt;/p&gt;"];    </pre><p>With <strong>xslapply</strong> you tell the XSLT processor in which
order it should traverse the XML structure. By default it goes
in preorder traversal, but with the following we make a
deliberate choice to break that order:</p><pre>
template(E = #xmlElement{name='bike'}) -&gt;
    ["&lt;p&gt;",xslapply(fun template/1,select("bike/name/manufacturer")),"&lt;/p&gt;"];    </pre><p>If you want to output the content of an XML element or an attribute you will get the value as a string by the <strong>value_of</strong> function:</p><pre>
template(E = #xmlElement{name='motorcycles'}) -&gt;
    ["&lt;p&gt;",value_of(select("bike/name/manufacturer",E),"&lt;/p&gt;"];    </pre><p>In the xmerl_xs functions you can provide a select(String)
call, which is an <a href="http://www.w3.org/TR/xpath">XPath</a>
functionality. For more details see the xmerl_xs <a href="xmerl_xs_examples.html">tutorial</a>.</p><p>Now, back to the example where we wanted to make the output
more arranged. With the template:</p><pre>
template(E = #xmlElement{name='motorcycles'}) -&gt;
    [    "&lt;head&gt;\
&lt;title&gt;motorcycles&lt;/title&gt;\
&lt;/head&gt;\
",
         "&lt;body&gt;\
",
\011 "&lt;h1&gt;Used Motorcycles&lt;/h1&gt;\
",
\011 "&lt;ul&gt;\
",
\011 remove_duplicates(value_of(select("bike/name/manufacturer",E))),
\011 "\
&lt;/ul&gt;\
",
\011 sort_by_manufacturer(xslapply(fun template/1, E)),
         "&lt;/body&gt;\
",
\011 "&lt;/html&gt;\
"];    </pre><p>We match on the top element and embed the inner parts in an
HTML body. Then we extract the string values of all motorcycle
brands, sort them and removes duplicates by
<strong>remove_duplicates(value_of(select("bike/name/manufacturer", E)))</strong>. We also process the substructure of the top element
and pass it to a function that sorts all motorcycle information
by brand according to the task formulation in the beginning of
this example.</p><p>The next template matches on the <strong>bike</strong> element:</p><pre>
template(E = #xmlElement{name='bike'}) -&gt;
    {value_of(select("name/manufacturer",E)),["&lt;dt&gt;",xslapply(fun template/1,select("name",E)),"&lt;/dt&gt;",
    "&lt;dd&gt;&lt;ul&gt;\
",
    "&lt;li style="color:green"&gt;Manufacturing year: ",xslapply(fun template/1,select("@year",E)),"&lt;/li&gt;\
",
    "&lt;li style="color:red"&gt;Color: ",xslapply(fun template/1,select("@color",E)),"&lt;/li&gt;\
",
    "&lt;li style="color:blue"&gt;Shape : ",xslapply(fun template/1,select("@condition",E)),"&lt;/li&gt;\
",
    "&lt;/ul&gt;&lt;/dd&gt;\
"]};    </pre><p>This creates a tuple with the brand of the motorcycle and
the output format. We use the brand name only for sorting
purpose. We have to end the template function with the "built
in clause" <strong>template(E) -&gt; built_in_rules(fun template/1, E).</strong></p><p>The entire program is motorcycles2html.erl:</p><pre><code class="">

%%%-------------------------------------------------------------------
%%% File    : motorcycles2html.erl
%%% Author  : Bertil Karlsson &lt;bertil@localhost.localdomain&gt;
%%% Description : 
%%%
%%% Created :  2 Sep 2004 by Bertil Karlsson &lt;bertil@localhost.localdomain&gt;
%%%-------------------------------------------------------------------
-module(motorcycles2html).

-include_lib("xmerl/include/xmerl.hrl").

-import(xmerl_xs, 
	[ xslapply/2, value_of/1, select/2, built_in_rules/2 ]).

-export([process_xml/1,process_to_file/2,process_to_file/1]).

process_xml(Doc) -&gt;
    template(Doc).

process_to_file(FileName) -&gt;
    process_to_file(FileName,'motorcycles.xml').

process_to_file(FileName,XMLDoc) -&gt;
    case file:open(FileName,[write]) of
	{ok,IOF} -&gt;
	    {XMLContent,_} = xmerl_scan:file(XMLDoc),
	    TransformedXML=process_xml(XMLContent),
	    io:format(IOF,"~s",[TransformedXML]),
	    file:close(IOF);
	{error,Reason} -&gt;
	    io:format("could not open file due to ~p.~n",[Reason])
    end.

%%% templates
template(E = #xmlElement{name='motorcycles'}) -&gt;
    [    "&lt;head&gt;\n&lt;title&gt;motorcycles&lt;/title&gt;\n&lt;/head&gt;\n",
         "&lt;body&gt;\n",
	 "&lt;h1&gt;Used Motorcycles&lt;/h1&gt;\n",
	 "&lt;ul&gt;\n",
	 remove_duplicates(value_of(select("bike/name/manufacturer",E))),
	 "\n&lt;/ul&gt;\n",
	 sort_by_manufacturer(xslapply(fun template/1, E)),
         "&lt;/body&gt;\n",
	 "&lt;/html&gt;\n"];
template(E = #xmlElement{name='bike'}) -&gt;
    {value_of(select("name/manufacturer",E)),["&lt;dt&gt;",xslapply(fun template/1,select("name",E)),"&lt;/dt&gt;",
    "&lt;dd&gt;&lt;ul&gt;\n",
    "&lt;li style=\"color:green\"&gt;Manufacturing year: ",xslapply(fun template/1,select("@year",E)),"&lt;/li&gt;\n",
    "&lt;li style=\"color:red\"&gt;Color: ",xslapply(fun template/1,select("@color",E)),"&lt;/li&gt;\n",
    "&lt;li style=\"color:blue\"&gt;Shape : ",xslapply(fun template/1,select("@condition",E)),"&lt;/li&gt;\n",
    "&lt;/ul&gt;&lt;/dd&gt;\n"]};
template(E) -&gt; built_in_rules(fun template/1, E).


%%%%%%%%%%% helper routines  

%% sorts on the bike name element, unwraps the bike information and
%% inserts a line feed and indentation on each bike element.
sort_by_manufacturer(L) -&gt;
    Tuples=[X1||X1={_,_} &lt;- L],
    SortedTS = lists:keysort(1,Tuples),
    InsertRefName_UnWrap=
	fun([{[Name],V}|Rest],Name,F)-&gt;
		[V|F(Rest,Name,F)];
	   ([{[Name],V}|Rest],_PreviousName,F) -&gt;
		[["&lt;a name=\"",Name,"\"&gt;&lt;/&gt;"],V|F(Rest,Name,F)];
	   ([],_,_) -&gt; []
	end,
    SortedRefed=InsertRefName_UnWrap(SortedTS,no_name,InsertRefName_UnWrap),
%    SortedTs=[Y||{X,Y}&lt;-lists:keysort(1,Tuples)],
    WS = "\n    ",
    Fun=fun([H|T],Acc,F)-&gt;
		F(T,[H,WS|Acc],F);
	   ([],Acc,_F)-&gt;
		lists:reverse([WS|Acc])
	end,
    if length(SortedRefed) &gt; 0 -&gt;
	    Fun(SortedRefed,[],Fun);
       true -&gt; []
    end.

    
%% removes all but the first of an element in L and inserts a html
%% reference for each list element.
remove_duplicates(L) -&gt;
    remove_duplicates(L,[]).

remove_duplicates([],Acc) -&gt; 
    make_ref(lists:sort(lists:reverse(Acc)));
remove_duplicates([A|L],Acc) -&gt; 
    case lists:delete(A,L) of
	L -&gt;
	    remove_duplicates(L,[A|Acc]);
	L1 -&gt; 
	    remove_duplicates([A|L1],[Acc])
    end.

make_ref([]) -&gt; [];
make_ref([H]) when is_atom(H) -&gt;
    "&lt;ul&gt;&lt;a href=\"#"++atom_to_list(H)++"\"&gt;"++atom_to_list(H)++"&lt;/a&gt;&lt;/ul&gt;";
make_ref([H]) when is_list(H) -&gt;
    "&lt;ul&gt;&lt;a href=\"#"++H++"\"&gt;\s"++H++"&lt;/a&gt;&lt;/ul&gt;";
make_ref([H|T]) when is_atom(H) -&gt;
    ["&lt;ul&gt;&lt;a href=\"#"++atom_to_list(H)++"\"&gt;\s"++atom_to_list(H)++",\n&lt;/a&gt;&lt;/ul&gt;"
     |make_ref(T)];
make_ref([H|T]) when is_list(H) -&gt;
    ["&lt;ul&gt;&lt;a href=\"#"++H++"\"&gt;\s"++H++",\n&lt;/a&gt;&lt;/ul&gt;"|make_ref(T)].
</code></pre><p>If we run it like this:
<strong>motorcycles2html:process_to_file('result_xs.html', 'motorcycles2.xml').</strong> The result will be <a href="result_xs.html">result_xs.html</a>. When the
input file is of the same structure as the previous
"motorcycles" XML files but it has a little more 'bike'
elements and the 'manufacturer' elements are not in order.</p><p>The <em>xmerl</em> application 
contains modules with support for processing of xml files compliant to XML 1.0.</p><h3>xmerl_scan</h3><p>This module is the interface to the XML parser, it handles XML 1.0.</p><p>This module is the interface to the XML parser, it handles XML 1.0.
The XML parser is activated through
<strong>xmerl_scan:string/[1,2]</strong> or
<strong>xmerl_scan:file/[1,2]</strong>.
It returns records of the type defined in xmerl.hrl.
See also <a href="xmerl_examples.html">tutorial</a> on customization
functions.</p><h4>DATA TYPES</h4><a name="types"></a><dl><dt><a name="type-document"></a>document() = <a href="#type-xmlElement">xmlElement()</a> | <a href="#type-xmlDocument">xmlDocument()</a></dt><dd> <p>
The document returned by <strong>xmerl_scan:string/[1,2]</strong> and
<strong>xmerl_scan:file/[1,2]</strong>. The type of the returned record depends on
the value of the document option passed to the function.
</p> </dd><dt><a name="type-global_state"></a>global_state()</dt><dd> <p>
The global state of the scanner, represented by the #xmerl_scanner{} record.
</p> </dd><dt><a name="type-option_list"></a>option_list()</dt><dd> <p>Options allow to customize the behaviour of the
scanner.
See also <a href="xmerl_examples.html">tutorial</a> on customization
functions.
</p> <p>
Possible options are:
</p> <dl><dt><strong>{acc_fun, Fun}</strong></dt><dd><p>Call back function to accumulate contents of entity.</p></dd><dt><strong>{continuation_fun, Fun} | {continuation_fun, Fun, ContinuationState}</strong></dt><dd><p>Call back function to decide what to do if the scanner runs into EOF
before the document is complete.</p></dd><dt><strong>{event_fun, Fun} | {event_fun, Fun, EventState}</strong></dt><dd><p>Call back function to handle scanner events.</p></dd><dt><strong>{fetch_fun, Fun} | {fetch_fun, Fun, FetchState}</strong></dt><dd><p>Call back function to fetch an external resource.</p></dd><dt><strong>{hook_fun, Fun} | {hook_fun, Fun, HookState}</strong></dt><dd><p>Call back function to process the document entities once
identified.</p></dd><dt><strong>{close_fun, Fun}</strong></dt><dd><p>Called when document has been completely parsed.</p></dd><dt><strong>{rules, ReadFun, WriteFun, RulesState} | {rules, Rules}</strong></dt><dd><p>Handles storing of scanner information when parsing.</p></dd><dt><strong>{user_state, UserState}</strong></dt><dd><p>Global state variable accessible from all customization functions</p></dd><dt><strong>{fetch_path, PathList}</strong></dt><dd><p>PathList is a list of
directories to search when fetching files. If the file in question
is not in the fetch_path, the URI will be used as a file
name.</p></dd><dt><strong>{space, Flag}</strong></dt><dd><p>'preserve' (default) to preserve spaces, 'normalize' to
accumulate consecutive whitespace and replace it with one space.</p></dd><dt><strong>{line, Line}</strong></dt><dd><p>To specify starting line for scanning in document which contains
fragments of XML.</p></dd><dt><strong>{namespace_conformant, Flag}</strong></dt><dd><p>Controls whether to behave as a namespace conformant XML parser,
'false' (default) to not otherwise 'true'.</p></dd><dt><strong>{validation, Flag}</strong></dt><dd><p>Controls whether to process as a validating XML parser:
'off' (default) no validation, or validation 'dtd' by DTD or 'schema'
by XML Schema. 'false' and 'true' options are obsolete
(i.e. they may be removed in a future release), if used 'false'
equals 'off' and 'true' equals 'dtd'.</p></dd><dt><strong>{schemaLocation, [{Namespace,Link}|...]}</strong></dt><dd><p>Tells explicitly which XML Schema documents to use to validate
the XML document. Used together with the
<strong>{validation,schema}</strong> option.</p></dd><dt><strong>{quiet, Flag}</strong></dt><dd><p>Set to 'true' if xmerl should behave quietly and not output any
information to standard output (default 'false').</p></dd><dt><strong>{doctype_DTD, DTD}</strong></dt><dd><p>Allows to specify DTD name when it isn't available in the XML
document. This option has effect only together with
<strong>{validation,'dtd'</strong> option.</p></dd><dt><strong>{xmlbase, Dir}</strong></dt><dd><p>XML Base directory. If using string/1 default is current directory.
If using file/1 default is directory of given file.</p></dd><dt><strong>{encoding, Enc}</strong></dt><dd><p>Set default character set used (default UTF-8).
This character set is used only if not explicitly given by the XML
declaration. </p></dd><dt><strong>{document, Flag}</strong></dt><dd><p>Set to 'true' if xmerl should return a complete XML document
as an xmlDocument record (default 'false').</p></dd><dt><strong>{comments, Flag}</strong></dt><dd><p>Set to 'false' if xmerl should skip comments otherwise they will
be returned as xmlComment records (default 'true').</p></dd><dt><strong>{default_attrs, Flag}</strong></dt><dd><p>Set to 'true' if xmerl should add to elements missing attributes
with a defined default value (default 'false').</p></dd></dl> </dd><dt><a name="type-xmlDocument"></a>xmlDocument() = #xmlDocument{}</dt><dd> <p>The record definition is found in xmerl.hrl.</p> </dd><dt><a name="type-xmlElement"></a>xmlElement() = #xmlElement{}</dt><dd> <p>The record definition is found in xmerl.hrl.</p> </dd></dl><h3>Functions</h3><h4>accumulate_whitespace(T::string(), S::, X3::atom(), Acc::string()) -&gt; {Acc, T1, S1}</h4><p>Function to accumulate and normalize whitespace.</p><a name="accumulate_whitespace-4"></a><p>Function to accumulate and normalize whitespace.</p><h4>cont_state(S::) -&gt;</h4><p>Equivalent to cont_state(ContinuationState, S). </p><a name="cont_state-1"></a><p>Equivalent to <a href="#cont_state-2">cont_state(ContinuationState, S)</a>.</p><h4>cont_state(X::ContinuationState, S::) -&gt;</h4><p>For controlling the ContinuationState, to be used in a continuation function, and called when the parser encounters the end of the byte stream.</p><a name="cont_state-2"></a><p>For controlling the ContinuationState, to be used in a continuation
function, and called when the parser encounters the end of the byte stream.
See <a href="xmerl_examples.html">tutorial</a> on customization functions.</p><h4>event_state(S::) -&gt;</h4><p>Equivalent to event_state(EventState, S). </p><a name="event_state-1"></a><p>Equivalent to <a href="#event_state-2">event_state(EventState, S)</a>.</p><h4>event_state(X::EventState, S::) -&gt;</h4><p>For controlling the EventState, to be used in an event function, and called at the beginning and at the end of a parsed entity.</p><a name="event_state-2"></a><p>For controlling the EventState, to be used in an event
function, and called at the beginning and at the end of a parsed entity.
See <a href="xmerl_examples.html">tutorial</a> on customization functions.</p><h4>fetch_state(S::) -&gt;</h4><p>Equivalent to fetch_state(FetchState, S). </p><a name="fetch_state-1"></a><p>Equivalent to <a href="#fetch_state-2">fetch_state(FetchState, S)</a>.</p><h4>fetch_state(X::FetchState, S::) -&gt;</h4><p>For controlling the FetchState, to be used in a fetch function, and called when the parser fetch an external resource (eg.</p><a name="fetch_state-2"></a><p>For controlling the FetchState, to be used in a fetch
function, and called when the parser fetch an external resource (eg. a DTD).
See <a href="xmerl_examples.html">tutorial</a> on customization functions.</p><h4>file(Filename::string()) -&gt; {, Rest}</h4><p>Equivalent to file(Filename, []). </p><ul><li><span class="v">Rest = list()</span></li></ul><a name="file-1"></a><p>Equivalent to <a href="#file-2">file(Filename, [])</a>.</p><h4>file(Filename::string(), Options::) -&gt; {, Rest}</h4><p>Parse file containing an XML document.</p><ul><li><span class="v">Rest = list()</span></li></ul><a name="file-2"></a><p>Parse file containing an XML document</p><h4>hook_state(S::) -&gt;</h4><p>Equivalent to hook_state(HookState, S). </p><a name="hook_state-1"></a><p>Equivalent to <a href="#hook_state-2">hook_state(HookState, S)</a>.</p><h4>hook_state(X::HookState, S::) -&gt;</h4><p>For controlling the HookState, to be used in a hook function, and called when the parser has parsed a complete entity.</p><a name="hook_state-2"></a><p>For controlling the HookState, to be used in a hook
function, and called when the parser has parsed a complete entity.
See <a href="xmerl_examples.html">tutorial</a> on customization functions.</p><h4>rules_state(S::) -&gt;</h4><p>Equivalent to rules_state(RulesState, S). </p><a name="rules_state-1"></a><p>Equivalent to <a href="#rules_state-2">rules_state(RulesState, S)</a>.</p><h4>rules_state(X::RulesState, S::) -&gt;</h4><p>For controlling the RulesState, to be used in a rules function, and called when the parser store scanner information in a rules database.</p><a name="rules_state-2"></a><p>For controlling the RulesState, to be used in a rules
function, and called when the parser store scanner information in a rules
database.
See <a href="xmerl_examples.html">tutorial</a> on customization functions.</p><h4>string(Text::list()) -&gt; {, Rest}</h4><p>Equivalent to string(Text, []). </p><ul><li><span class="v">Rest = list()</span></li></ul><a name="string-1"></a><p>Equivalent to <a href="#string-2">string(Text, [])</a>.</p><h4>string(Text::list(), Options::) -&gt; {, Rest}</h4><p>Parse string containing an XML document.</p><ul><li><span class="v">Rest = list()</span></li></ul><a name="string-2"></a><p>Parse string containing an XML document</p><h4>user_state(S::) -&gt;</h4><p>Equivalent to user_state(UserState, S). </p><a name="user_state-1"></a><p>Equivalent to <a href="#user_state-2">user_state(UserState, S)</a>.</p><h4>user_state(X::UserState, S::) -&gt;</h4><p>For controlling the UserState, to be used in a user function.</p><a name="user_state-2"></a><p>For controlling the UserState, to be used in a user function.
See <a href="xmerl_examples.html">tutorial</a> on customization functions.</p><h3>Authors</h3><h3>xmerl</h3><p>Functions for exporting XML data to an external format.</p><p>Functions for exporting XML data to an external format.
</p><h3>Functions</h3><h4>callbacks(Module) -&gt; Result</h4><p>Find the list of inherited callback modules for a given module.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Result = [atom()]</span></li></ul><a name="callbacks-1"></a><p>Find the list of inherited callback modules for a given module.</p><h4>export(Content, Callback) -&gt; ExportedFormat</h4><p>Equivalent to export(Data, Callback, []). </p><a name="export-2"></a><p>Equivalent to <a href="#export-3">export(Data, Callback, [])</a>.</p><h4>export(Content, Callback, RootAttributes) -&gt; ExportedFormat</h4><p>Exports normal, well-formed XML content, using the specified callback-module.</p><ul><li><span class="v">Content = [Element]</span></li><li><span class="v">Callback = atom()</span></li><li><span class="v">RootAttributes = [XmlAttributes]</span></li></ul><a name="export-3"></a><p>Exports normal, well-formed XML content, using the specified
callback-module.
</p><p><strong>Element</strong> is any of:</p><ul><li><p><strong>#xmlText{}</strong></p></li><li><p><strong>#xmlElement{}</strong></p></li><li><p><strong>#xmlPI{}</strong></p></li><li><p><strong>#xmlComment{}</strong></p></li><li><p><strong>#xmlDecl{}</strong></p></li></ul><p>(See <strong>xmerl.hrl</strong> for the record definitions.)
Text in <strong>#xmlText{}</strong> elements can be deep lists of
characters and/or binaries.</p><p><strong>RootAttributes</strong> is a list of
<strong>#xmlAttribute{}</strong> attributes for the <strong>#root#</strong>
element, which implicitly becomes the parent of the given
<strong>Content</strong>. The tag-handler function for
<strong>#root#</strong> is thus called with the complete exported data of
<strong>Content</strong>. Root attributes can be used to specify
e.g. encoding or other metadata of an XML or HTML document.</p><p>The <strong>Callback</strong> module should contain hook functions for
all tags present in the data structure. A hook function must have the
following format:</p><pre>    Tag(Data, Attributes, Parents, E)</pre><p>where <strong>E</strong> is the corresponding <strong>#xmlElement{}</strong>,
<strong>Data</strong> is the already-exported contents of <strong>E</strong>
and <strong>Attributes</strong> is the list of
<strong>#xmlAttribute{}</strong> records of <strong>E</strong>. Finally,
<strong>Parents</strong> is the list of parent nodes of <strong>E</strong>,
on the form <strong>[{ParentTag::atom(), ParentPosition::integer()}]</strong>.</p><p>The hook function should return either the data to be exported, or
a tuple <strong>{'#xml-alias#', NewTag::atom()}</strong>, or a tuple
<strong>{'#xml-redefine#', Content}</strong>, where <strong>Content</strong>
is a content list (which can be on simple-form; see
<strong>export_simple/2</strong> for details).</p><p>A callback module can inherit definitions from other callback
modules, through the required function <strong>'#xml-interitance#() -&gt; [ModuleName::atom()]</strong>.</p><p><em>See also:</em> <a href="#export-2">export/2</a>, <a href="#export_simple-3">export_simple/3</a>.</p><h4>export_content(Es::Content, Callbacks) -&gt; term()</h4><p>Exports normal XML content directly, without further context.</p><ul><li><span class="v">Content = [Element]</span></li><li><span class="v">Callback = [atom()]</span></li></ul><a name="export_content-2"></a><p>Exports normal XML content directly, without further context.</p><h4>export_element(E, CB) -&gt; term()
</h4><p>Exports a normal XML element directly, without further context.</p><a name="export_element-2"></a><p>Exports a normal XML element directly, without further context.</p><h4>export_element(E, CallbackModule, CallbackState) -&gt; ExportedFormat</h4><p>For on-the-fly exporting during parsing (SAX style) of the XML document.</p><a name="export_element-3"></a><p>For on-the-fly exporting during parsing (SAX style) of the XML
document.</p><h4>export_simple(Content, Callback) -&gt; ExportedFormat</h4><p>Equivalent to export_simple(Content, Callback, []). </p><a name="export_simple-2"></a><p>Equivalent to <a href="#export_simple-3">export_simple(Content, Callback, [])</a>.</p><h4>export_simple(Content, Callback, RootAttrs::RootAttributes) -&gt; ExportedFormat</h4><p>Exports "simple-form" XML content, using the specified callback-module.</p><ul><li><span class="v">Content = [Element]</span></li><li><span class="v">Callback = atom()</span></li><li><span class="v">RootAttributes = [XmlAttributes]</span></li></ul><a name="export_simple-3"></a><p>Exports "simple-form" XML content, using the specified
callback-module.
</p><p><strong>Element</strong> is any of:</p><ul><li><p><strong>{Tag, Attributes, Content}</strong></p></li><li><p><strong>{Tag, Content}</strong></p></li><li><p><strong>Tag</strong></p></li><li><p><strong>IOString</strong></p></li><li><p><strong>#xmlText{}</strong></p></li><li><p><strong>#xmlElement{}</strong></p></li><li><p><strong>#xmlPI{}</strong></p></li><li><p><strong>#xmlComment{}</strong></p></li><li><p><strong>#xmlDecl{}</strong></p></li></ul><p>where</p><ul><li><p><strong>Tag = atom()</strong></p></li><li><p><strong>Attributes = [{Name, Value}]</strong></p></li><li><p><strong>Name = atom()</strong></p></li><li><p><strong>Value = IOString | atom() | integer()</strong></p></li></ul><p>Normal-form XML elements can thus be included in the simple-form
representation. Note that content lists must be flat. An
<strong>IOString</strong> is a (possibly deep) list of characters and/or
binaries.</p><p><strong>RootAttributes</strong> is a list of:</p><ul><li><p><strong>XmlAttributes = #xmlAttribute{}</strong></p></li></ul><p>See <strong>export/3</strong> for details on the callback module and
the root attributes. The XML-data is always converted to normal form
before being passed to the callback module.</p><p><em>See also:</em> <a href="#export-3">export/3</a>, <a href="#export_simple-2">export_simple/2</a>.</p><h4>export_simple_content(Content, Callback) -&gt; term()
</h4><p>Exports simple XML content directly, without further context.</p><a name="export_simple_content-2"></a><p>Exports simple XML content directly, without further context.</p><h4>export_simple_element(Content, Callback) -&gt; term()
</h4><p>Exports a simple XML element directly, without further context.</p><a name="export_simple_element-2"></a><p>Exports a simple XML element directly, without further context.</p><h3>Authors</h3><h3>xmerl_xs</h3><p>
       Erlang has similarities to XSLT since both languages
 	have a functional programming approach.</p><p>
Erlang has similarities to XSLT since both languages
have a functional programming approach. Using <strong>xmerl_xpath</strong>	 
it is possible to write XSLT like transforms in Erlang.XSLT stylesheets are often used when transforming XML
documents, to other XML documents or (X)HTML for presentation.
XSLT contains quite many
functions and learning them all may take some effort.
This document assumes a basic level of
understanding of XSLT.
Since XSLT is based on a functional programming approach
with pattern matching and recursion it is possible to write
similar style sheets in Erlang. At least for basic
transforms. This
document describes how to use the XPath implementation together
with Erlangs pattern matching and a couple of functions to write
XSLT like transforms.This approach is probably easier for an Erlanger but
if you need to use real XSLT stylesheets in order to "comply to
the standard" there is an adapter available to the Sablotron
XSLT package which is written i C++.
See also the <a href="xmerl_xs_examples.html">Tutorial</a>.
</p><h3>Functions</h3><h4>built_in_rules(Fun, E) -&gt; List</h4><p>The default fallback behaviour.</p><a name="built_in_rules-2"></a><p>The default fallback behaviour. Template funs should end with:
<br/><strong>template(E) -&gt; built_in_rules(fun template/1, E)</strong>.</p><h4>select(String::string(), E) -&gt; E</h4><p>Extracts the nodes from the xml tree according to XPath.</p><a name="select-2"></a><p>Extracts the nodes from the xml tree according to XPath.</p><p><em>See also:</em> <a href="#value_of-1">value_of/1</a>.</p><h4>value_of(E) -&gt; List</h4><p>Concatenates all text nodes within the tree.</p><ul><li><span class="v">E = term()</span></li></ul><a name="value_of-1"></a><p>Concatenates all text nodes within the tree.</p><p>Example:</p><br/><pre>
  &lt;xsl:template match="title"&gt;
    &lt;div align="center"&gt;
      &lt;h1&gt;&lt;xsl:value-of select="." /&gt;&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/xsl:template&gt;
  </pre><p>becomes:</p><br/><pre>
   template(E = #xmlElement{name='title'}) -&gt;
     ["&lt;div align="center"&gt;&lt;h1&gt;",
       value_of(select(".", E)), "&lt;/h1&gt;&lt;/div&gt;"]
  </pre><h4>xslapply(Fun::Function, EList::list()) -&gt; List</h4><p>xslapply is a wrapper to make things look similar to   xsl:apply-templates.</p><ul><li><span class="v">Function = () -&gt; list()</span></li></ul><a name="xslapply-2"></a><p>xslapply is a wrapper to make things look similar to  
xsl:apply-templates.</p><p>Example, original XSLT:</p><br/><pre>
  &lt;xsl:template match="doc/title"&gt;
    &lt;h1&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/h1&gt;
  &lt;/xsl:template&gt;
  </pre><p>becomes in Erlang:</p><br/><pre>
  template(E = #xmlElement{ parents=[{'doc',_}|_], name='title'}) -&gt;
    ["&lt;h1&gt;",
     xslapply(fun template/1, E),
     "&lt;/h1&gt;"];
  </pre><h3>Authors</h3><h3>xmerl_eventp</h3><p>Simple event-based front-ends to xmerl_scan for processing
  of XML documents in streams and for parsing in SAX style.</p><p>Simple event-based front-ends to xmerl_scan for processing
of XML documents in streams and for parsing in SAX style.
Each contain more elaborate settings of xmerl_scan that makes usage of
the customization functions.
</p><h4>DATA TYPES</h4><a name="types"></a><dl><dt><a name="type-option_list"></a>option_list()</dt><dd> <p>Options allow to customize the behaviour of the
scanner.
See also <a href="xmerl_examples.html">tutorial</a> on customization
functions.
</p> <p>
Possible options are:
</p> <dl><dt><strong>{acc_fun, Fun}</strong></dt><dd><p>Call back function to accumulate contents of entity.</p></dd><dt><strong>{continuation_fun, Fun} | {continuation_fun, Fun, ContinuationState}</strong></dt><dd><p>Call back function to decide what to do if the scanner runs into EOF
before the document is complete.</p></dd><dt><strong>{event_fun, Fun} | {event_fun, Fun, EventState}</strong></dt><dd><p>Call back function to handle scanner events.</p></dd><dt><strong>{fetch_fun, Fun} | {fetch_fun, Fun, FetchState}</strong></dt><dd><p>Call back function to fetch an external resource.</p></dd><dt><strong>{hook_fun, Fun} | {hook_fun, Fun, HookState}</strong></dt><dd><p>Call back function to process the document entities once
identified.</p></dd><dt><strong>{close_fun, Fun}</strong></dt><dd><p>Called when document has been completely parsed.</p></dd><dt><strong>{rules, ReadFun, WriteFun, RulesState} | {rules, Rules}</strong></dt><dd><p>Handles storing of scanner information when parsing.</p></dd><dt><strong>{user_state, UserState}</strong></dt><dd><p>Global state variable accessible from all customization functions</p></dd><dt><strong>{fetch_path, PathList}</strong></dt><dd><p>PathList is a list of
directories to search when fetching files. If the file in question
is not in the fetch_path, the URI will be used as a file
name.</p></dd><dt><strong>{space, Flag}</strong></dt><dd><p>'preserve' (default) to preserve spaces, 'normalize' to
accumulate consecutive whitespace and replace it with one space.</p></dd><dt><strong>{line, Line}</strong></dt><dd><p>To specify starting line for scanning in document which contains
fragments of XML.</p></dd><dt><strong>{namespace_conformant, Flag}</strong></dt><dd><p>Controls whether to behave as a namespace conformant XML parser,
'false' (default) to not otherwise 'true'.</p></dd><dt><strong>{validation, Flag}</strong></dt><dd><p>Controls whether to process as a validating XML parser:
'off' (default) no validation, or validation 'dtd' by DTD or 'schema'
by XML Schema. 'false' and 'true' options are obsolete
(i.e. they may be removed in a future release), if used 'false'
equals 'off' and 'true' equals 'dtd'.</p></dd><dt><strong>{schemaLocation, [{Namespace,Link}|...]}</strong></dt><dd><p>Tells explicitly which XML Schema documents to use to validate
the XML document. Used together with the
<strong>{validation,schema}</strong> option.</p></dd><dt><strong>{quiet, Flag}</strong></dt><dd><p>Set to 'true' if xmerl should behave quietly and not output any
information to standard output (default 'false').</p></dd><dt><strong>{doctype_DTD, DTD}</strong></dt><dd><p>Allows to specify DTD name when it isn't available in the XML
document. This option has effect only together with
<strong>{validation,'dtd'</strong> option.</p></dd><dt><strong>{xmlbase, Dir}</strong></dt><dd><p>XML Base directory. If using string/1 default is current directory.
If using file/1 default is directory of given file.</p></dd><dt><strong>{encoding, Enc}</strong></dt><dd><p>Set default character set used (default UTF-8).
This character set is used only if not explicitly given by the XML
declaration. </p></dd><dt><strong>{document, Flag}</strong></dt><dd><p>Set to 'true' if xmerl should return a complete XML document
as an xmlDocument record (default 'false').</p></dd><dt><strong>{comments, Flag}</strong></dt><dd><p>Set to 'false' if xmerl should skip comments otherwise they will
be returned as xmlComment records (default 'true').</p></dd><dt><strong>{default_attrs, Flag}</strong></dt><dd><p>Set to 'true' if xmerl should add to elements missing attributes
with a defined default value (default 'false').</p></dd></dl> </dd><dt><a name="type-xmlElement"></a>xmlElement() = #xmlElement{}</dt><dd> </dd></dl><h3>Functions</h3><h4>file_sax(Fname::string(), CallBackModule::atom(), UserState, Options::) -&gt; NewUserState</h4><p>Parse file containing an XML document, SAX style.</p><a name="file_sax-4"></a><p>Parse file containing an XML document, SAX style.
Wrapper for a call to the XML parser <strong>xmerl_scan</strong> with a
<strong>hook_fun</strong> for using xmerl export functionality directly after
an entity is parsed.</p><h4>stream(Fname::string(), Options::) -&gt;</h4><p>Parse file containing an XML document as a stream, DOM style.</p><a name="stream-2"></a><p>Parse file containing an XML document as a stream, DOM style.
Wrapper for a call to the XML parser <strong>xmerl_scan</strong> with a
<strong>continuation_fun</strong> for handling streams of XML data.
Note that the <strong>continuation_fun</strong>, <strong>acc_fun</strong>,
<strong>fetch_fun</strong>, <strong>rules</strong> and <strong>close_fun</strong>
options cannot be user defined using this parser.</p><h4>stream_sax(Fname, CallBack::CallBackModule, UserState, Options) -&gt;</h4><p>Parse file containing an XML document as a stream, SAX style.</p><ul><li><span class="v">Fname = string()</span></li><li><span class="v">CallBackModule = atom()</span></li><li><span class="v">Options = </span></li></ul><a name="stream_sax-4"></a><p>Parse file containing an XML document as a stream, SAX style.
Wrapper for a call to the XML parser <strong>xmerl_scan</strong> with a
<strong>continuation_fun</strong> for handling streams of XML data.
Note that the <strong>continuation_fun</strong>, <strong>acc_fun</strong>,
<strong>fetch_fun</strong>, <strong>rules</strong>, <strong>hook_fun</strong>,
<strong>close_fun</strong> and <strong>user_state</strong> options cannot be user
defined using this parser.</p><h4>string_sax(String::list(), CallBackModule::atom(), UserState, Options::) -&gt;</h4><p>Parse file containing an XML document, SAX style.</p><a name="string_sax-4"></a><p>Parse file containing an XML document, SAX style.
Wrapper for a call to the XML parser <strong>xmerl_scan</strong> with a
<strong>hook_fun</strong> for using xmerl export functionality directly after
an entity is parsed.</p><h3>Authors</h3><h3>xmerl_xpath</h3><p>The xmerl_xpath module handles the entire XPath 1.0 spec.</p><p>The xmerl_xpath module handles the entire XPath 1.0 spec.
XPath expressions typically occur in XML attributes and are used to address
parts of an XML document.
The grammar is defined in <strong>xmerl_xpath_parse.yrl</strong>.
The core functions are defined in <strong>xmerl_xpath_pred.erl</strong>.Some useful shell commands for debugging the XPath parser<pre>
 c(xmerl_xpath_scan).
 yecc:yecc("xmerl_xpath_parse.yrl", "xmerl_xpath_parse", true, []).
 c(xmerl_xpath_parse).

 xmerl_xpath_parse:parse(xmerl_xpath_scan:tokens("position() &gt; -1")).
 xmerl_xpath_parse:parse(xmerl_xpath_scan:tokens("5 * 6 div 2")).
 xmerl_xpath_parse:parse(xmerl_xpath_scan:tokens("5 + 6 mod 2")).
 xmerl_xpath_parse:parse(xmerl_xpath_scan:tokens("5 * 6")).
 xmerl_xpath_parse:parse(xmerl_xpath_scan:tokens("-----6")).
 xmerl_xpath_parse:parse(xmerl_xpath_scan:tokens("parent::node()")).
 xmerl_xpath_parse:parse(xmerl_xpath_scan:tokens("descendant-or-self::node()")).
 xmerl_xpath_parse:parse(xmerl_xpath_scan:tokens("parent::processing-instruction('foo')")).
  </pre></p><h4>DATA TYPES</h4><a name="types"></a><dl><dt><a name="type-docEntity"></a>docEntity() = #xmlDocument{} | [<a href="#type-docNodes">docNodes()</a>]</dt><dd> </dd><dt><a name="type-docNodes"></a>docNodes() = #xmlElement{} | #xmlAttribute{} | #xmlText{} | #xmlPI{} | #xmlComment{} | #xmlNsNode{}</dt><dd> </dd><dt><a name="type-nodeEntity"></a>nodeEntity() = #xmlElement{} | #xmlAttribute{} | #xmlText{} | #xmlPI{} | #xmlComment{} | #xmlNsNode{} | #xmlDocument{}</dt><dd> </dd><dt><a name="type-option_list"></a>option_list()</dt><dd> <p>Options allows to customize the behaviour of the
XPath scanner.
</p> <p>
Possible options are:
</p> <dl><dt><strong>{namespace, #xmlNamespace}</strong></dt><dd><p>Set namespace nodes, from XmlNamspace, in xmlContext</p></dd><dt><strong>{namespace, Nodes}</strong></dt><dd><p>Set namespace nodes in xmlContext.</p></dd></dl> </dd><dt><a name="type-parentList"></a>parentList() = [{atom(), integer()}]</dt><dd> </dd><dt><a name="type-xPathString"></a>xPathString() = string()</dt><dd> </dd></dl><h3>Functions</h3><h4>string(Str, Doc) -&gt; [] | Scalar</h4><p>Equivalent to string(Str, Doc, []). </p><a name="string-2"></a><p>Equivalent to <a href="#string-3">string(Str, Doc, [])</a>.</p><h4>string(Str, Doc, Options) -&gt; [] | Scalar</h4><p>Equivalent to string(Str, Doc, [], Doc, Options). </p><a name="string-3"></a><p>Equivalent to <a href="#string-5">string(Str, Doc, [], Doc, Options)</a>.</p><h4>string(Str, Node, Parents, Doc, Options) -&gt; [] | Scalar</h4><p>Extracts the nodes from the parsed XML tree according to XPath.</p><ul><li><span class="v">Str = </span></li><li><span class="v">Node = </span></li><li><span class="v">Parents = </span></li><li><span class="v">Doc = </span></li><li><span class="v">Options = </span></li><li><span class="v">Scalar = #xmlObj{}</span></li></ul><a name="string-5"></a><p>Extracts the nodes from the parsed XML tree according to XPath.
xmlObj is a record with fields type and value,
where type is boolean | number | string</p><h3>Authors</h3><h3>xmerl_xsd</h3><p>Interface module for XML Schema validation.</p><p>Interface module for XML Schema validation.
It handles the W3.org
<a href="http://www.w3.org/XML/Schema#dev">specifications</a>
of XML Schema second edition 28 october 2004. For an introduction to
XML Schema study <a href="http://www.w3.org/TR/xmlschema-0/">part 0.</a>
An XML structure is validated by xmerl_xsd:validate/[2,3].</p><h4>DATA TYPES</h4><a name="types"></a><dl><dt><a name="type-filename"></a>filename() = string()</dt><dd> </dd><dt><a name="type-global_state"></a>global_state()</dt><dd> <p>The global state of the validator. It is
representated by the <strong>#xsd_state{}</strong> record.
</p> </dd><dt><a name="type-option_list"></a>option_list()</dt><dd> <p>Options allow to customize the behaviour of the
validation.
</p> <p>
Possible options are :
</p> <dl><dt><strong>{tab2file,boolean()}</strong></dt><dd><p>Enables saving of abstract structure on file for debugging
purpose.</p></dd><dt><strong>{xsdbase,filename()}</strong></dt><dd><p>XSD Base directory.</p></dd><dt><strong>{fetch_fun,FetchFun}</strong></dt><dd><p>Call back function to fetch an external resource.</p></dd><dt><strong>{fetch_path,PathList}</strong></dt><dd><p>PathList is a list of directories to search when fetching files.
If the file in question is not in the fetch_path, the URI will
be used as a file name.</p></dd><dt><strong>{state,State}</strong></dt><dd><p>It is possible by this option to provide a state with process
information from an earlier validation.</p></dd></dl> </dd></dl><h3>Functions</h3><h4>file2state(FileName) -&gt; {ok, State} | {error, Reason}</h4><p>Reads the schema state with all information of the processed schema from a file created with state2file/[1,2].</p><ul><li><span class="v">State = </span></li><li><span class="v">FileName = string()</span></li></ul><a name="file2state-1"></a><p>Reads the schema state with all information of the processed
schema from a file created with <strong>state2file/[1,2]</strong>.  The
format of this file is internal. The state can then be used
validating an XML document.</p><h4>format_error(L::Errors) -&gt; Result</h4><p>Formats error descriptions to human readable strings.</p><ul><li><span class="v">Errors = tuple() | [tuple()]</span></li><li><span class="v">Result = string() | [string()]</span></li></ul><a name="format_error-1"></a><p>Formats error descriptions to human readable strings.</p><h4>process_schema(Schema) -&gt; Result</h4><p>Equivalent to process_schema(Schema, []). </p><a name="process_schema-1"></a><p>Equivalent to <a href="#process_schema-2">process_schema(Schema, [])</a>.</p><h4>process_schema(Schema, Options) -&gt; Result</h4><p>Reads the referenced XML schema and checks that it is valid.</p><ul><li><span class="v">Schema = string()</span></li><li><span class="v">Result = {ok, State} | {error, Reason}</span></li><li><span class="v">State = </span></li><li><span class="v">Reason = [ErrorReason] | ErrorReason</span></li><li><span class="v">Options = </span></li></ul><a name="process_schema-2"></a><p>Reads the referenced XML schema and checks that it is valid.
Returns the <strong>global_state()</strong> with schema info or an
error reason. The error reason may be a list of several errors
or a single error encountered during the processing.</p><h4>process_schemas(Schemas) -&gt; Result</h4><p>Equivalent to process_schema(Schemas, []). </p><a name="process_schemas-1"></a><p>Equivalent to <a href="#process_schema-2">process_schema(Schemas, [])</a>.</p><h4>process_schemas(Schemas, Options) -&gt; Result</h4><p>Reads the referenced XML schemas and controls they are valid.</p><ul><li><span class="v">Schemas = [{NameSpace, string()} | Schemas] | []</span></li><li><span class="v">Result = {ok, State} | {error, Reason}</span></li><li><span class="v">Reason = [ErrorReason] | ErrorReason</span></li><li><span class="v">Options = </span></li></ul><a name="process_schemas-2"></a><p>Reads the referenced XML schemas and controls they are valid.
Returns the <strong>global_state()</strong> with schema info or an
error reason. The error reason may be a list of several errors
or a single error encountered during the processing.</p><h4>process_validate(Schema, Xml::Element) -&gt; Result</h4><p>Equivalent to process_validate(Schema, Xml, []). </p><a name="process_validate-2"></a><p>Equivalent to <a href="#process_validate-3">process_validate(Schema, Xml, [])</a>.</p><h4>process_validate(Schema, Xml::Element, Opts::Options) -&gt; Result</h4><p>Validates a parsed well-formed XML element towards an XML schema.</p><ul><li><span class="v">Schema = string()</span></li><li><span class="v">Element = XmlElement</span></li><li><span class="v">Options = </span></li><li><span class="v">Result = {ValidXmlElement, State} | {error, Reason}</span></li><li><span class="v">Reason = [ErrorReason] | ErrorReason</span></li></ul><a name="process_validate-3"></a><p>Validates a parsed well-formed XML element towards an XML
schema.  </p><p> Validates in two steps. First it processes the schema,
saves the type and structure info in an ets table and then
validates the element towards the schema.</p><p> Usage example:</p><p>
<strong>1&gt;{E,_} = xmerl_scan:file("my_XML_document.xml").</strong><br/>
<strong>2&gt;{E2,_} = xmerl_xsd:validate("my_XML_Schema.xsd",E).</strong>
</p><p> Observe that E2 may differ from E if for instance there are default
values defined in <strong>my_XML_Schema.xsd</strong>.</p><h4>state2file(S::State) -&gt; ok | {error, Reason}</h4><p>Same as state2file(State,SchemaName).</p><a name="state2file-1"></a><p>Same as state2file(State,SchemaName)</p><p>The name of the saved file is the same as the name of the
schema, but with <strong>.xss</strong> extension.</p><h4>state2file(S::State, FileName) -&gt; ok | {error, Reason}</h4><p>Saves the schema state with all information of the processed schema in a file.</p><ul><li><span class="v">State = </span></li><li><span class="v">FileName = string()</span></li></ul><a name="state2file-2"></a><p>Saves the schema state with all information of the processed
schema in a file. You can provide the file name for the saved
state. FileName is saved with the <strong>.xss</strong> extension
added.</p><h4>validate(Xml::Element, State) -&gt; Result</h4><p>Equivalent to validate(Element, State, []). </p><a name="validate-2"></a><p>Equivalent to <a href="#validate-3">validate(Element, State, [])</a>.</p><h4>validate(Xml::Element, State, Opts::Options) -&gt; Result</h4><p>Validates a parsed well-formed XML element (Element).</p><ul><li><span class="v">Element = XmlElement</span></li><li><span class="v">Options = </span></li><li><span class="v">Result = {ValidElement, } | {error, Reasons}</span></li><li><span class="v">ValidElement = XmlElement</span></li><li><span class="v">State = </span></li><li><span class="v">Reasons = [ErrorReason] | ErrorReason</span></li></ul><a name="validate-3"></a><p>Validates a parsed well-formed XML element (Element).
</p><p>A call to validate/2 or validate/3 must provide a well formed
parsed XML element <strong>#xmlElement{}</strong> and a State,
<strong>global_state()</strong>, which holds necessary information from
an already processed schema.
Thus validate enables reuse of the schema information and
therefore if one shall validate several times towards the same
schema it reduces time consumption.</p><p>The result, ValidElement, is the valid element that conforms to the
post-schema-validation infoset. When the validator finds an error it
tries to continue and reports a list of all errors found. In those cases
an unexpected error is found it may cause a single error reason.
</p><p> Usage example:</p><p>
<strong>1&gt;{E,_} = xmerl_scan:file("my_XML_document.xml").</strong><br/>
<strong>2&gt;{ok,S} = xmerl_xsd:process_schema("my_XML_Schema.xsd").</strong><br/>
<strong>3&gt;{E2,_} = xmerl_xsd:validate(E,S).</strong>
</p><p> Observe that E2 may differ from E if for instance there are default
values defined in <strong>my_XML_Schema.xsd</strong>.</p><h3>Authors</h3><h3>xmerl_sax_parser</h3><p>XML SAX parser API</p><p>
A SAX parser for XML that sends the events through a callback interface.
SAX is the <em>Simple API for XML</em>, originally a Java-only API. SAX was the first widely adopted API for 
XML in Java, and is a <em>de facto</em> standard where there are versions for several programming language 
environments other than Java.
</p><h4>DATA TYPES</h4><dl><dt><strong>option()</strong></dt><dd> <p>
Options used to customize the behaviour of the parser.
Possible options are:
</p> <dl><dt><strong>{continuation_fun, ContinuationFun}</strong></dt><dd> <a href="#ContinuationFun/1">ContinuationFun</a> is a call back function to decide what to do if  the parser runs into EOF before the document is complete.  </dd><dt><strong>{continuation_state, term()}</strong></dt><dd> State that is accessible in the continuation call back function.  </dd><dt><strong>{event_fun, EventFun}</strong></dt><dd> <a href="#EventFun/3">EventFun</a> is the call back function for parser events.  </dd><dt><strong>{event_state, term()}</strong></dt><dd> State that is accessible in the event call back function.  </dd><dt><strong>{file_type, FileType}</strong></dt><dd> Flag that tells the parser if it's parsing a DTD or a normal XML file (default normal). <ul><li><strong>FileType = normal | dtd</strong></li></ul> </dd><dt><strong>{encoding, Encoding}</strong></dt><dd> Set default character set used (default UTF-8). This character set is used only if not explicitly  given by the XML document. <ul><li><strong>Encoding = utf8 | {utf16,big} | {utf16,little} | latin1 | list</strong></li></ul> </dd><dt><strong>skip_external_dtd</strong></dt><dd> Skips the external DTD during parsing. </dd></dl> </dd><dt></dt><dd>  </dd><dt><strong>event()</strong></dt><dd> <p>
The SAX events that are sent to the user via the callback.
</p> <dl><dt><strong>startDocument</strong></dt><dd> Receive notification of the beginning of a document. The SAX parser will send this event only once  before any other event callbacks. </dd><dt><strong>endDocument</strong></dt><dd> Receive notification of the end of a document. The SAX parser will send this event only once, and it will  be the last event during the parse.  </dd><dt><strong>{startPrefixMapping, Prefix, Uri}</strong></dt><dd> Begin the scope of a prefix-URI Namespace mapping. Note that start/endPrefixMapping events are not guaranteed to be properly nested relative to each other:  all startPrefixMapping events will occur immediately before the corresponding startElement event, and all  endPrefixMapping  events will occur immediately after the corresponding endElement event, but their  order is not otherwise guaranteed. There will not be start/endPrefixMapping events for the "xml" prefix, since it is predeclared and immutable. <ul><li><strong>Prefix = string()</strong></li><li><strong>Uri = string()</strong></li></ul> </dd><dt><strong>{endPrefixMapping, Prefix}</strong></dt><dd> End the scope of a prefix-URI mapping. <ul><li><strong>Prefix = string()</strong></li></ul> </dd><dt><strong>{startElement, Uri, LocalName, QualifiedName, Attributes}</strong></dt><dd> Receive notification of the beginning of an element. The Parser will send this event at the beginning of every element in the XML document;  there will be a corresponding endElement event for every startElement event (even when the element is empty).  All of the element's content will be reported, in order, before the corresponding endElement event. <ul><li><strong>Uri = string()</strong></li><li><strong>LocalName = string()</strong></li><li><strong>QualifiedName = {Prefix, LocalName}</strong></li><li><strong>Prefix = string()</strong></li><li><strong>Attributes = [{Uri, Prefix, AttributeName, Value}]</strong></li><li><strong>AttributeName = string()</strong></li><li><strong>Value = string()</strong></li></ul> </dd><dt><strong>{endElement, Uri, LocalName, QualifiedName}</strong></dt><dd> Receive notification of the end of an element. The SAX parser will send this event at the end of every element in the XML document; there will be a corresponding startElement event for every endElement event (even when the element is empty). <ul><li><strong>Uri = string()</strong></li><li><strong>LocalName = string()</strong></li><li><strong>QualifiedName = {Prefix, LocalName}</strong></li><li><strong>Prefix = string()</strong></li></ul> </dd><dt><strong>{characters, string()}</strong></dt><dd> Receive notification of character data.  </dd><dt><strong>{ignorableWhitespace, string()}</strong></dt><dd> Receive notification of ignorable whitespace in element content. </dd><dt><strong>{processingInstruction, Target, Data}</strong></dt><dd> Receive notification of a processing instruction. The Parser will send this event once for each processing instruction found:  note that processing instructions may occur before or after the main document element. <ul><li><strong>Target = string()</strong></li><li><strong>Data = string()</strong></li></ul> </dd><dt><strong>{comment, string()}</strong></dt><dd> Report an XML comment anywhere in the document (both inside and outside of the document element). </dd><dt><strong>startCDATA</strong></dt><dd> Report the start of a CDATA section. The contents of the CDATA section will be reported  through the regular characters event. </dd><dt><strong>endCDATA</strong></dt><dd> Report the end of a CDATA section. </dd><dt><strong>{startDTD, Name, PublicId, SystemId}</strong></dt><dd> Report the start of DTD declarations, it's reporting the start of the DOCTYPE declaration. If the document has no DOCTYPE declaration, this event will not be sent. <ul><li><strong>Name = string()</strong></li><li><strong>PublicId = string()</strong></li><li><strong>SystemId = string()</strong></li></ul> </dd><dt><strong>endDTD</strong></dt><dd> Report the end of DTD declarations, it's reporting the end of the DOCTYPE declaration. </dd><dt><strong>{startEntity, SysId}</strong></dt><dd>  Report the beginning of some internal and external XML entities. ??? </dd><dt><strong>{endEntity, SysId}</strong></dt><dd> Report the end of an entity. ??? </dd><dt><strong>{elementDecl, Name, Model}</strong></dt><dd> Report an element type declaration.    The content model will consist of the string "EMPTY", the string "ANY", or a parenthesised group,  optionally followed by an occurrence indicator. The model will be normalized so that all parameter  entities are fully resolved and all whitespace is removed,and will include the enclosing parentheses.  Other normalization (such as removing redundant parentheses or simplifying occurrence indicators)  is at the discretion of the parser. <ul><li><strong>Name = string()</strong></li><li><strong>Model = string()</strong></li></ul> </dd><dt><strong>{attributeDecl, ElementName, AttributeName, Type, Mode, Value}</strong></dt><dd> Report an attribute type declaration. <ul><li><strong>ElementName = string()</strong></li><li><strong>AttributeName = string()</strong></li><li><strong>Type = string()</strong></li><li><strong>Mode = string()</strong></li><li><strong>Value = string()</strong></li></ul> </dd><dt><strong>{internalEntityDecl, Name, Value}</strong></dt><dd> Report an internal entity declaration. <ul><li><strong>Name = string()</strong></li><li><strong>Value = string()</strong></li></ul> </dd><dt><strong>{externalEntityDecl, Name, PublicId, SystemId}</strong></dt><dd> Report a parsed external entity declaration. <ul><li><strong>Name = string()</strong></li><li><strong>PublicId = string()</strong></li><li><strong>SystemId = string()</strong></li></ul> </dd><dt><strong>{unparsedEntityDecl, Name, PublicId, SystemId, Ndata}</strong></dt><dd> Receive notification of an unparsed entity declaration event. <ul><li><strong>Name = string()</strong></li><li><strong>PublicId = string()</strong></li><li><strong>SystemId = string()</strong></li><li><strong>Ndata = string()</strong></li></ul> </dd><dt><strong>{notationDecl, Name, PublicId, SystemId}</strong></dt><dd> Receive notification of a notation declaration event. <ul><li><strong>Name = string()</strong></li><li><strong>PublicId = string()</strong></li><li><strong>SystemId = string()</strong></li></ul> </dd></dl> </dd><dt><strong>unicode_char()</strong></dt><dd> Integer representing valid unicode codepoint. </dd><dt><strong>unicode_binary()</strong></dt><dd> Binary with characters encoded in UTF-8 or UTF-16. </dd><dt><strong>latin1_binary()</strong></dt><dd> Binary with characters encoded in iso-latin-1. </dd></dl><h3>Functions</h3><h4>file(Filename, Options) -&gt; Result</h4><p>Parse file containing an XML document.</p><ul><li><span class="v">Filename = string()</span></li><li><span class="v">Options = [option()]</span></li><li><span class="v">Result = {ok, EventState, Rest} |</span></li><li><span class="v">{Tag, Location, Reason, EndTags, EventState}</span></li><li><span class="v">Rest = unicode_binary() | latin1_binary()</span></li><li><span class="v">Tag = atom() (fatal_error, or user defined tag)</span></li><li><span class="v">Location = {CurrentLocation, EntityName, LineNo}</span></li><li><span class="v">CurrentLocation = string()</span></li><li><span class="v">EntityName = string()</span></li><li><span class="v">LineNo = integer()</span></li><li><span class="v">EventState = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Parse file containing an XML document. This functions uses a default continuation function to read the file in blocks.</p><h4>stream(Xml, Options) -&gt; Result</h4><p>Parse a stream containing an XML document.</p><ul><li><span class="v">Xml = unicode_binary() | latin1_binary() | [unicode_char()]</span></li><li><span class="v">Options = [option()]</span></li><li><span class="v">Result = {ok, EventState, Rest} |</span></li><li><span class="v">{Tag, Location, Reason, EndTags, EventState}</span></li><li><span class="v">Rest =  unicode_binary() | latin1_binary() | [unicode_char()]</span></li><li><span class="v">Tag = atom() (fatal_error or user defined tag)</span></li><li><span class="v">Location = {CurrentLocation, EntityName, LineNo}</span></li><li><span class="v">CurrentLocation = string()</span></li><li><span class="v">EntityName = string()</span></li><li><span class="v">LineNo = integer()</span></li><li><span class="v">EventState = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Parse a stream containing an XML document.</p><h4>CALLBACK FUNCTIONS</h4><p>
The callback interface is based on that the user sends a fun with the 
correct signature to the parser.
</p><h3>Functions</h3><h4>ContinuationFun(State) -&gt; {NewBytes, NewState}</h4><p>Continuation call back function.</p><ul><li><span class="v">State = NewState = term()</span></li><li><span class="v">NewBytes = binary() | list() (should be same as start input in stream/2)</span></li></ul><p>
This function is called whenever the parser runs out of input data.
If the function can't get hold of more input an empty list or binary 
(depends on start input in stream/2) is returned.
Other types of errors is handled through exceptions. Use throw/1 to send the 
following tuple {Tag = atom(), Reason = string()} if the continuation function encounters a fatal error. 
Tag is an atom that identifies the functional entity that sends the exception 
and Reason is a string that describes the problem.
</p><h4>EventFun(Event, Location, State) -&gt; NewState</h4><p>Event call back function.</p><ul><li><span class="v">Event = event()</span></li><li><span class="v">Location = {CurrentLocation, Entityname, LineNo}</span></li><li><span class="v">CurrentLocation = string()</span></li><li><span class="v">Entityname = string()</span></li><li><span class="v">LineNo = integer()</span></li><li><span class="v">State = NewState = term()</span></li></ul><p>
This function is called for every event sent by the parser. 
The error handling is done through exceptions. Use throw/1 to send the 
following tuple {Tag = atom(), Reason = string()} if the application encounters a fatal error. 
Tag is an atom that identifies the functional entity that sends the exception 
and Reason is a string that describes the problem.
</p></body></html>