<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>xmerl_xsd</h1><h1>xmerl_xsd</h1><p>Interface module for XML Schema validation.</p><p>Interface module for XML Schema validation.
It handles the W3.org
<a href="http://www.w3.org/XML/Schema#dev">specifications</a>
of XML Schema second edition 28 october 2004. For an introduction to
XML Schema study <a href="http://www.w3.org/TR/xmlschema-0/">part 0.</a>
An XML structure is validated by xmerl_xsd:validate/[2,3].</p><h2>DATA TYPES</h2><a name="types"></a><dl><dt><a name="type-filename"></a>filename() = string()</dt><dd> </dd><dt><a name="type-global_state"></a>global_state()</dt><dd> <p>The global state of the validator. It is
representated by the <strong>#xsd_state{}</strong> record.
</p> </dd><dt><a name="type-option_list"></a>option_list()</dt><dd> <p>Options allow to customize the behaviour of the
validation.
</p> <p>
Possible options are :
</p> <dl><dt><strong>{tab2file,boolean()}</strong></dt><dd><p>Enables saving of abstract structure on file for debugging
purpose.</p></dd><dt><strong>{xsdbase,filename()}</strong></dt><dd><p>XSD Base directory.</p></dd><dt><strong>{fetch_fun,FetchFun}</strong></dt><dd><p>Call back function to fetch an external resource.</p></dd><dt><strong>{fetch_path,PathList}</strong></dt><dd><p>PathList is a list of directories to search when fetching files.
If the file in question is not in the fetch_path, the URI will
be used as a file name.</p></dd><dt><strong>{state,State}</strong></dt><dd><p>It is possible by this option to provide a state with process
information from an earlier validation.</p></dd></dl> </dd></dl><h1>Functions</h1><h2>file2state(FileName) -&gt; {ok, State} | {error, Reason}</h2><p>Reads the schema state with all information of the processed schema from a file created with state2file/[1,2].</p><ul><li><span class="v">State = </span></li><li><span class="v">FileName = string()</span></li></ul><a name="file2state-1"></a><p>Reads the schema state with all information of the processed
schema from a file created with <strong>state2file/[1,2]</strong>.  The
format of this file is internal. The state can then be used
validating an XML document.</p><h2>format_error(L::Errors) -&gt; Result</h2><p>Formats error descriptions to human readable strings.</p><ul><li><span class="v">Errors = tuple() | [tuple()]</span></li><li><span class="v">Result = string() | [string()]</span></li></ul><a name="format_error-1"></a><p>Formats error descriptions to human readable strings.</p><h2>process_schema(Schema) -&gt; Result</h2><p>Equivalent to process_schema(Schema, []). </p><a name="process_schema-1"></a><p>Equivalent to <a href="#process_schema-2">process_schema(Schema, [])</a>.</p><h2>process_schema(Schema, Options) -&gt; Result</h2><p>Reads the referenced XML schema and checks that it is valid.</p><ul><li><span class="v">Schema = string()</span></li><li><span class="v">Result = {ok, State} | {error, Reason}</span></li><li><span class="v">State = </span></li><li><span class="v">Reason = [ErrorReason] | ErrorReason</span></li><li><span class="v">Options = </span></li></ul><a name="process_schema-2"></a><p>Reads the referenced XML schema and checks that it is valid.
Returns the <strong>global_state()</strong> with schema info or an
error reason. The error reason may be a list of several errors
or a single error encountered during the processing.</p><h2>process_schemas(Schemas) -&gt; Result</h2><p>Equivalent to process_schema(Schemas, []). </p><a name="process_schemas-1"></a><p>Equivalent to <a href="#process_schema-2">process_schema(Schemas, [])</a>.</p><h2>process_schemas(Schemas, Options) -&gt; Result</h2><p>Reads the referenced XML schemas and controls they are valid.</p><ul><li><span class="v">Schemas = [{NameSpace, string()} | Schemas] | []</span></li><li><span class="v">Result = {ok, State} | {error, Reason}</span></li><li><span class="v">Reason = [ErrorReason] | ErrorReason</span></li><li><span class="v">Options = </span></li></ul><a name="process_schemas-2"></a><p>Reads the referenced XML schemas and controls they are valid.
Returns the <strong>global_state()</strong> with schema info or an
error reason. The error reason may be a list of several errors
or a single error encountered during the processing.</p><h2>process_validate(Schema, Xml::Element) -&gt; Result</h2><p>Equivalent to process_validate(Schema, Xml, []). </p><a name="process_validate-2"></a><p>Equivalent to <a href="#process_validate-3">process_validate(Schema, Xml, [])</a>.</p><h2>process_validate(Schema, Xml::Element, Opts::Options) -&gt; Result</h2><p>Validates a parsed well-formed XML element towards an XML schema.</p><ul><li><span class="v">Schema = string()</span></li><li><span class="v">Element = XmlElement</span></li><li><span class="v">Options = </span></li><li><span class="v">Result = {ValidXmlElement, State} | {error, Reason}</span></li><li><span class="v">Reason = [ErrorReason] | ErrorReason</span></li></ul><a name="process_validate-3"></a><p>Validates a parsed well-formed XML element towards an XML
schema.  </p><p> Validates in two steps. First it processes the schema,
saves the type and structure info in an ets table and then
validates the element towards the schema.</p><p> Usage example:</p><p>
<strong>1&gt;{E,_} = xmerl_scan:file("my_XML_document.xml").</strong><br/>
<strong>2&gt;{E2,_} = xmerl_xsd:validate("my_XML_Schema.xsd",E).</strong>
</p><p> Observe that E2 may differ from E if for instance there are default
values defined in <strong>my_XML_Schema.xsd</strong>.</p><h2>state2file(S::State) -&gt; ok | {error, Reason}</h2><p>Same as state2file(State,SchemaName).</p><a name="state2file-1"></a><p>Same as state2file(State,SchemaName)</p><p>The name of the saved file is the same as the name of the
schema, but with <strong>.xss</strong> extension.</p><h2>state2file(S::State, FileName) -&gt; ok | {error, Reason}</h2><p>Saves the schema state with all information of the processed schema in a file.</p><ul><li><span class="v">State = </span></li><li><span class="v">FileName = string()</span></li></ul><a name="state2file-2"></a><p>Saves the schema state with all information of the processed
schema in a file. You can provide the file name for the saved
state. FileName is saved with the <strong>.xss</strong> extension
added.</p><h2>validate(Xml::Element, State) -&gt; Result</h2><p>Equivalent to validate(Element, State, []). </p><a name="validate-2"></a><p>Equivalent to <a href="#validate-3">validate(Element, State, [])</a>.</p><h2>validate(Xml::Element, State, Opts::Options) -&gt; Result</h2><p>Validates a parsed well-formed XML element (Element).</p><ul><li><span class="v">Element = XmlElement</span></li><li><span class="v">Options = </span></li><li><span class="v">Result = {ValidElement, } | {error, Reasons}</span></li><li><span class="v">ValidElement = XmlElement</span></li><li><span class="v">State = </span></li><li><span class="v">Reasons = [ErrorReason] | ErrorReason</span></li></ul><a name="validate-3"></a><p>Validates a parsed well-formed XML element (Element).
</p><p>A call to validate/2 or validate/3 must provide a well formed
parsed XML element <strong>#xmlElement{}</strong> and a State,
<strong>global_state()</strong>, which holds necessary information from
an already processed schema.
Thus validate enables reuse of the schema information and
therefore if one shall validate several times towards the same
schema it reduces time consumption.</p><p>The result, ValidElement, is the valid element that conforms to the
post-schema-validation infoset. When the validator finds an error it
tries to continue and reports a list of all errors found. In those cases
an unexpected error is found it may cause a single error reason.
</p><p> Usage example:</p><p>
<strong>1&gt;{E,_} = xmerl_scan:file("my_XML_document.xml").</strong><br/>
<strong>2&gt;{ok,S} = xmerl_xsd:process_schema("my_XML_Schema.xsd").</strong><br/>
<strong>3&gt;{E2,_} = xmerl_xsd:validate(E,S).</strong>
</p><p> Observe that E2 may differ from E if for instance there are default
values defined in <strong>my_XML_Schema.xsd</strong>.</p><h1>Authors</h1></body></html>