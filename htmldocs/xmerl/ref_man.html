<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>xmerl Reference Manual</h1><p>The <em>xmerl</em> application 
contains modules with support for processing of xml files compliant to XML 1.0.</p><h2>xmerl_scan</h2><p>This module is the interface to the XML parser, it handles XML 1.0.</p><p>This module is the interface to the XML parser, it handles XML 1.0.
The XML parser is activated through
<strong>xmerl_scan:string/[1,2]</strong> or
<strong>xmerl_scan:file/[1,2]</strong>.
It returns records of the type defined in xmerl.hrl.
See also <a href="xmerl_examples.html">tutorial</a> on customization
functions.</p><h3>DATA TYPES</h3><a name="types"></a><dl><dt><a name="type-document"></a>document() = <a href="#type-xmlElement">xmlElement()</a> | <a href="#type-xmlDocument">xmlDocument()</a></dt><dd> <p>
The document returned by <strong>xmerl_scan:string/[1,2]</strong> and
<strong>xmerl_scan:file/[1,2]</strong>. The type of the returned record depends on
the value of the document option passed to the function.
</p> </dd><dt><a name="type-global_state"></a>global_state()</dt><dd> <p>
The global state of the scanner, represented by the #xmerl_scanner{} record.
</p> </dd><dt><a name="type-option_list"></a>option_list()</dt><dd> <p>Options allow to customize the behaviour of the
scanner.
See also <a href="xmerl_examples.html">tutorial</a> on customization
functions.
</p> <p>
Possible options are:
</p> <dl><dt><strong>{acc_fun, Fun}</strong></dt><dd><p>Call back function to accumulate contents of entity.</p></dd><dt><strong>{continuation_fun, Fun} | {continuation_fun, Fun, ContinuationState}</strong></dt><dd><p>Call back function to decide what to do if the scanner runs into EOF
before the document is complete.</p></dd><dt><strong>{event_fun, Fun} | {event_fun, Fun, EventState}</strong></dt><dd><p>Call back function to handle scanner events.</p></dd><dt><strong>{fetch_fun, Fun} | {fetch_fun, Fun, FetchState}</strong></dt><dd><p>Call back function to fetch an external resource.</p></dd><dt><strong>{hook_fun, Fun} | {hook_fun, Fun, HookState}</strong></dt><dd><p>Call back function to process the document entities once
identified.</p></dd><dt><strong>{close_fun, Fun}</strong></dt><dd><p>Called when document has been completely parsed.</p></dd><dt><strong>{rules, ReadFun, WriteFun, RulesState} | {rules, Rules}</strong></dt><dd><p>Handles storing of scanner information when parsing.</p></dd><dt><strong>{user_state, UserState}</strong></dt><dd><p>Global state variable accessible from all customization functions</p></dd><dt><strong>{fetch_path, PathList}</strong></dt><dd><p>PathList is a list of
directories to search when fetching files. If the file in question
is not in the fetch_path, the URI will be used as a file
name.</p></dd><dt><strong>{space, Flag}</strong></dt><dd><p>'preserve' (default) to preserve spaces, 'normalize' to
accumulate consecutive whitespace and replace it with one space.</p></dd><dt><strong>{line, Line}</strong></dt><dd><p>To specify starting line for scanning in document which contains
fragments of XML.</p></dd><dt><strong>{namespace_conformant, Flag}</strong></dt><dd><p>Controls whether to behave as a namespace conformant XML parser,
'false' (default) to not otherwise 'true'.</p></dd><dt><strong>{validation, Flag}</strong></dt><dd><p>Controls whether to process as a validating XML parser:
'off' (default) no validation, or validation 'dtd' by DTD or 'schema'
by XML Schema. 'false' and 'true' options are obsolete
(i.e. they may be removed in a future release), if used 'false'
equals 'off' and 'true' equals 'dtd'.</p></dd><dt><strong>{schemaLocation, [{Namespace,Link}|...]}</strong></dt><dd><p>Tells explicitly which XML Schema documents to use to validate
the XML document. Used together with the
<strong>{validation,schema}</strong> option.</p></dd><dt><strong>{quiet, Flag}</strong></dt><dd><p>Set to 'true' if xmerl should behave quietly and not output any
information to standard output (default 'false').</p></dd><dt><strong>{doctype_DTD, DTD}</strong></dt><dd><p>Allows to specify DTD name when it isn't available in the XML
document. This option has effect only together with
<strong>{validation,'dtd'</strong> option.</p></dd><dt><strong>{xmlbase, Dir}</strong></dt><dd><p>XML Base directory. If using string/1 default is current directory.
If using file/1 default is directory of given file.</p></dd><dt><strong>{encoding, Enc}</strong></dt><dd><p>Set default character set used (default UTF-8).
This character set is used only if not explicitly given by the XML
declaration. </p></dd><dt><strong>{document, Flag}</strong></dt><dd><p>Set to 'true' if xmerl should return a complete XML document
as an xmlDocument record (default 'false').</p></dd><dt><strong>{comments, Flag}</strong></dt><dd><p>Set to 'false' if xmerl should skip comments otherwise they will
be returned as xmlComment records (default 'true').</p></dd><dt><strong>{default_attrs, Flag}</strong></dt><dd><p>Set to 'true' if xmerl should add to elements missing attributes
with a defined default value (default 'false').</p></dd></dl> </dd><dt><a name="type-xmlDocument"></a>xmlDocument() = #xmlDocument{}</dt><dd> <p>The record definition is found in xmerl.hrl.</p> </dd><dt><a name="type-xmlElement"></a>xmlElement() = #xmlElement{}</dt><dd> <p>The record definition is found in xmerl.hrl.</p> </dd></dl><h2>Functions</h2><h3>accumulate_whitespace(T::string(), S::, X3::atom(), Acc::string()) -&gt; {Acc, T1, S1}</h3><p>Function to accumulate and normalize whitespace.</p><a name="accumulate_whitespace-4"></a><p>Function to accumulate and normalize whitespace.</p><h3>cont_state(S::) -&gt;</h3><p>Equivalent to cont_state(ContinuationState, S). </p><a name="cont_state-1"></a><p>Equivalent to <a href="#cont_state-2">cont_state(ContinuationState, S)</a>.</p><h3>cont_state(X::ContinuationState, S::) -&gt;</h3><p>For controlling the ContinuationState, to be used in a continuation function, and called when the parser encounters the end of the byte stream.</p><a name="cont_state-2"></a><p>For controlling the ContinuationState, to be used in a continuation
function, and called when the parser encounters the end of the byte stream.
See <a href="xmerl_examples.html">tutorial</a> on customization functions.</p><h3>event_state(S::) -&gt;</h3><p>Equivalent to event_state(EventState, S). </p><a name="event_state-1"></a><p>Equivalent to <a href="#event_state-2">event_state(EventState, S)</a>.</p><h3>event_state(X::EventState, S::) -&gt;</h3><p>For controlling the EventState, to be used in an event function, and called at the beginning and at the end of a parsed entity.</p><a name="event_state-2"></a><p>For controlling the EventState, to be used in an event
function, and called at the beginning and at the end of a parsed entity.
See <a href="xmerl_examples.html">tutorial</a> on customization functions.</p><h3>fetch_state(S::) -&gt;</h3><p>Equivalent to fetch_state(FetchState, S). </p><a name="fetch_state-1"></a><p>Equivalent to <a href="#fetch_state-2">fetch_state(FetchState, S)</a>.</p><h3>fetch_state(X::FetchState, S::) -&gt;</h3><p>For controlling the FetchState, to be used in a fetch function, and called when the parser fetch an external resource (eg.</p><a name="fetch_state-2"></a><p>For controlling the FetchState, to be used in a fetch
function, and called when the parser fetch an external resource (eg. a DTD).
See <a href="xmerl_examples.html">tutorial</a> on customization functions.</p><h3>file(Filename::string()) -&gt; {, Rest}</h3><p>Equivalent to file(Filename, []). </p><ul><li><span class="v">Rest = list()</span></li></ul><a name="file-1"></a><p>Equivalent to <a href="#file-2">file(Filename, [])</a>.</p><h3>file(Filename::string(), Options::) -&gt; {, Rest}</h3><p>Parse file containing an XML document.</p><ul><li><span class="v">Rest = list()</span></li></ul><a name="file-2"></a><p>Parse file containing an XML document</p><h3>hook_state(S::) -&gt;</h3><p>Equivalent to hook_state(HookState, S). </p><a name="hook_state-1"></a><p>Equivalent to <a href="#hook_state-2">hook_state(HookState, S)</a>.</p><h3>hook_state(X::HookState, S::) -&gt;</h3><p>For controlling the HookState, to be used in a hook function, and called when the parser has parsed a complete entity.</p><a name="hook_state-2"></a><p>For controlling the HookState, to be used in a hook
function, and called when the parser has parsed a complete entity.
See <a href="xmerl_examples.html">tutorial</a> on customization functions.</p><h3>rules_state(S::) -&gt;</h3><p>Equivalent to rules_state(RulesState, S). </p><a name="rules_state-1"></a><p>Equivalent to <a href="#rules_state-2">rules_state(RulesState, S)</a>.</p><h3>rules_state(X::RulesState, S::) -&gt;</h3><p>For controlling the RulesState, to be used in a rules function, and called when the parser store scanner information in a rules database.</p><a name="rules_state-2"></a><p>For controlling the RulesState, to be used in a rules
function, and called when the parser store scanner information in a rules
database.
See <a href="xmerl_examples.html">tutorial</a> on customization functions.</p><h3>string(Text::list()) -&gt; {, Rest}</h3><p>Equivalent to string(Text, []). </p><ul><li><span class="v">Rest = list()</span></li></ul><a name="string-1"></a><p>Equivalent to <a href="#string-2">string(Text, [])</a>.</p><h3>string(Text::list(), Options::) -&gt; {, Rest}</h3><p>Parse string containing an XML document.</p><ul><li><span class="v">Rest = list()</span></li></ul><a name="string-2"></a><p>Parse string containing an XML document</p><h3>user_state(S::) -&gt;</h3><p>Equivalent to user_state(UserState, S). </p><a name="user_state-1"></a><p>Equivalent to <a href="#user_state-2">user_state(UserState, S)</a>.</p><h3>user_state(X::UserState, S::) -&gt;</h3><p>For controlling the UserState, to be used in a user function.</p><a name="user_state-2"></a><p>For controlling the UserState, to be used in a user function.
See <a href="xmerl_examples.html">tutorial</a> on customization functions.</p><h2>Authors</h2><h2>xmerl</h2><p>Functions for exporting XML data to an external format.</p><p>Functions for exporting XML data to an external format.
</p><h2>Functions</h2><h3>callbacks(Module) -&gt; Result</h3><p>Find the list of inherited callback modules for a given module.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Result = [atom()]</span></li></ul><a name="callbacks-1"></a><p>Find the list of inherited callback modules for a given module.</p><h3>export(Content, Callback) -&gt; ExportedFormat</h3><p>Equivalent to export(Data, Callback, []). </p><a name="export-2"></a><p>Equivalent to <a href="#export-3">export(Data, Callback, [])</a>.</p><h3>export(Content, Callback, RootAttributes) -&gt; ExportedFormat</h3><p>Exports normal, well-formed XML content, using the specified callback-module.</p><ul><li><span class="v">Content = [Element]</span></li><li><span class="v">Callback = atom()</span></li><li><span class="v">RootAttributes = [XmlAttributes]</span></li></ul><a name="export-3"></a><p>Exports normal, well-formed XML content, using the specified
callback-module.
</p><p><strong>Element</strong> is any of:</p><ul><li><p><strong>#xmlText{}</strong></p></li><li><p><strong>#xmlElement{}</strong></p></li><li><p><strong>#xmlPI{}</strong></p></li><li><p><strong>#xmlComment{}</strong></p></li><li><p><strong>#xmlDecl{}</strong></p></li></ul><p>(See <strong>xmerl.hrl</strong> for the record definitions.)
Text in <strong>#xmlText{}</strong> elements can be deep lists of
characters and/or binaries.</p><p><strong>RootAttributes</strong> is a list of
<strong>#xmlAttribute{}</strong> attributes for the <strong>#root#</strong>
element, which implicitly becomes the parent of the given
<strong>Content</strong>. The tag-handler function for
<strong>#root#</strong> is thus called with the complete exported data of
<strong>Content</strong>. Root attributes can be used to specify
e.g. encoding or other metadata of an XML or HTML document.</p><p>The <strong>Callback</strong> module should contain hook functions for
all tags present in the data structure. A hook function must have the
following format:</p><pre>    Tag(Data, Attributes, Parents, E)</pre><p>where <strong>E</strong> is the corresponding <strong>#xmlElement{}</strong>,
<strong>Data</strong> is the already-exported contents of <strong>E</strong>
and <strong>Attributes</strong> is the list of
<strong>#xmlAttribute{}</strong> records of <strong>E</strong>. Finally,
<strong>Parents</strong> is the list of parent nodes of <strong>E</strong>,
on the form <strong>[{ParentTag::atom(), ParentPosition::integer()}]</strong>.</p><p>The hook function should return either the data to be exported, or
a tuple <strong>{'#xml-alias#', NewTag::atom()}</strong>, or a tuple
<strong>{'#xml-redefine#', Content}</strong>, where <strong>Content</strong>
is a content list (which can be on simple-form; see
<strong>export_simple/2</strong> for details).</p><p>A callback module can inherit definitions from other callback
modules, through the required function <strong>'#xml-interitance#() -&gt; [ModuleName::atom()]</strong>.</p><p><em>See also:</em> <a href="#export-2">export/2</a>, <a href="#export_simple-3">export_simple/3</a>.</p><h3>export_content(Es::Content, Callbacks) -&gt; term()</h3><p>Exports normal XML content directly, without further context.</p><ul><li><span class="v">Content = [Element]</span></li><li><span class="v">Callback = [atom()]</span></li></ul><a name="export_content-2"></a><p>Exports normal XML content directly, without further context.</p><h3>export_element(E, CB) -&gt; term()
</h3><p>Exports a normal XML element directly, without further context.</p><a name="export_element-2"></a><p>Exports a normal XML element directly, without further context.</p><h3>export_element(E, CallbackModule, CallbackState) -&gt; ExportedFormat</h3><p>For on-the-fly exporting during parsing (SAX style) of the XML document.</p><a name="export_element-3"></a><p>For on-the-fly exporting during parsing (SAX style) of the XML
document.</p><h3>export_simple(Content, Callback) -&gt; ExportedFormat</h3><p>Equivalent to export_simple(Content, Callback, []). </p><a name="export_simple-2"></a><p>Equivalent to <a href="#export_simple-3">export_simple(Content, Callback, [])</a>.</p><h3>export_simple(Content, Callback, RootAttrs::RootAttributes) -&gt; ExportedFormat</h3><p>Exports "simple-form" XML content, using the specified callback-module.</p><ul><li><span class="v">Content = [Element]</span></li><li><span class="v">Callback = atom()</span></li><li><span class="v">RootAttributes = [XmlAttributes]</span></li></ul><a name="export_simple-3"></a><p>Exports "simple-form" XML content, using the specified
callback-module.
</p><p><strong>Element</strong> is any of:</p><ul><li><p><strong>{Tag, Attributes, Content}</strong></p></li><li><p><strong>{Tag, Content}</strong></p></li><li><p><strong>Tag</strong></p></li><li><p><strong>IOString</strong></p></li><li><p><strong>#xmlText{}</strong></p></li><li><p><strong>#xmlElement{}</strong></p></li><li><p><strong>#xmlPI{}</strong></p></li><li><p><strong>#xmlComment{}</strong></p></li><li><p><strong>#xmlDecl{}</strong></p></li></ul><p>where</p><ul><li><p><strong>Tag = atom()</strong></p></li><li><p><strong>Attributes = [{Name, Value}]</strong></p></li><li><p><strong>Name = atom()</strong></p></li><li><p><strong>Value = IOString | atom() | integer()</strong></p></li></ul><p>Normal-form XML elements can thus be included in the simple-form
representation. Note that content lists must be flat. An
<strong>IOString</strong> is a (possibly deep) list of characters and/or
binaries.</p><p><strong>RootAttributes</strong> is a list of:</p><ul><li><p><strong>XmlAttributes = #xmlAttribute{}</strong></p></li></ul><p>See <strong>export/3</strong> for details on the callback module and
the root attributes. The XML-data is always converted to normal form
before being passed to the callback module.</p><p><em>See also:</em> <a href="#export-3">export/3</a>, <a href="#export_simple-2">export_simple/2</a>.</p><h3>export_simple_content(Content, Callback) -&gt; term()
</h3><p>Exports simple XML content directly, without further context.</p><a name="export_simple_content-2"></a><p>Exports simple XML content directly, without further context.</p><h3>export_simple_element(Content, Callback) -&gt; term()
</h3><p>Exports a simple XML element directly, without further context.</p><a name="export_simple_element-2"></a><p>Exports a simple XML element directly, without further context.</p><h2>Authors</h2><h2>xmerl_xs</h2><p>
       Erlang has similarities to XSLT since both languages
 	have a functional programming approach.</p><p>
Erlang has similarities to XSLT since both languages
have a functional programming approach. Using <strong>xmerl_xpath</strong>	 
it is possible to write XSLT like transforms in Erlang.XSLT stylesheets are often used when transforming XML
documents, to other XML documents or (X)HTML for presentation.
XSLT contains quite many
functions and learning them all may take some effort.
This document assumes a basic level of
understanding of XSLT.
Since XSLT is based on a functional programming approach
with pattern matching and recursion it is possible to write
similar style sheets in Erlang. At least for basic
transforms. This
document describes how to use the XPath implementation together
with Erlangs pattern matching and a couple of functions to write
XSLT like transforms.This approach is probably easier for an Erlanger but
if you need to use real XSLT stylesheets in order to "comply to
the standard" there is an adapter available to the Sablotron
XSLT package which is written i C++.
See also the <a href="xmerl_xs_examples.html">Tutorial</a>.
</p><h2>Functions</h2><h3>built_in_rules(Fun, E) -&gt; List</h3><p>The default fallback behaviour.</p><a name="built_in_rules-2"></a><p>The default fallback behaviour. Template funs should end with:
<br/><strong>template(E) -&gt; built_in_rules(fun template/1, E)</strong>.</p><h3>select(String::string(), E) -&gt; E</h3><p>Extracts the nodes from the xml tree according to XPath.</p><a name="select-2"></a><p>Extracts the nodes from the xml tree according to XPath.</p><p><em>See also:</em> <a href="#value_of-1">value_of/1</a>.</p><h3>value_of(E) -&gt; List</h3><p>Concatenates all text nodes within the tree.</p><ul><li><span class="v">E = term()</span></li></ul><a name="value_of-1"></a><p>Concatenates all text nodes within the tree.</p><p>Example:</p><br/><pre>
  &lt;xsl:template match="title"&gt;
    &lt;div align="center"&gt;
      &lt;h1&gt;&lt;xsl:value-of select="." /&gt;&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/xsl:template&gt;
  </pre><p>becomes:</p><br/><pre>
   template(E = #xmlElement{name='title'}) -&gt;
     ["&lt;div align="center"&gt;&lt;h1&gt;",
       value_of(select(".", E)), "&lt;/h1&gt;&lt;/div&gt;"]
  </pre><h3>xslapply(Fun::Function, EList::list()) -&gt; List</h3><p>xslapply is a wrapper to make things look similar to   xsl:apply-templates.</p><ul><li><span class="v">Function = () -&gt; list()</span></li></ul><a name="xslapply-2"></a><p>xslapply is a wrapper to make things look similar to  
xsl:apply-templates.</p><p>Example, original XSLT:</p><br/><pre>
  &lt;xsl:template match="doc/title"&gt;
    &lt;h1&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/h1&gt;
  &lt;/xsl:template&gt;
  </pre><p>becomes in Erlang:</p><br/><pre>
  template(E = #xmlElement{ parents=[{'doc',_}|_], name='title'}) -&gt;
    ["&lt;h1&gt;",
     xslapply(fun template/1, E),
     "&lt;/h1&gt;"];
  </pre><h2>Authors</h2><h2>xmerl_eventp</h2><p>Simple event-based front-ends to xmerl_scan for processing
  of XML documents in streams and for parsing in SAX style.</p><p>Simple event-based front-ends to xmerl_scan for processing
of XML documents in streams and for parsing in SAX style.
Each contain more elaborate settings of xmerl_scan that makes usage of
the customization functions.
</p><h3>DATA TYPES</h3><a name="types"></a><dl><dt><a name="type-option_list"></a>option_list()</dt><dd> <p>Options allow to customize the behaviour of the
scanner.
See also <a href="xmerl_examples.html">tutorial</a> on customization
functions.
</p> <p>
Possible options are:
</p> <dl><dt><strong>{acc_fun, Fun}</strong></dt><dd><p>Call back function to accumulate contents of entity.</p></dd><dt><strong>{continuation_fun, Fun} | {continuation_fun, Fun, ContinuationState}</strong></dt><dd><p>Call back function to decide what to do if the scanner runs into EOF
before the document is complete.</p></dd><dt><strong>{event_fun, Fun} | {event_fun, Fun, EventState}</strong></dt><dd><p>Call back function to handle scanner events.</p></dd><dt><strong>{fetch_fun, Fun} | {fetch_fun, Fun, FetchState}</strong></dt><dd><p>Call back function to fetch an external resource.</p></dd><dt><strong>{hook_fun, Fun} | {hook_fun, Fun, HookState}</strong></dt><dd><p>Call back function to process the document entities once
identified.</p></dd><dt><strong>{close_fun, Fun}</strong></dt><dd><p>Called when document has been completely parsed.</p></dd><dt><strong>{rules, ReadFun, WriteFun, RulesState} | {rules, Rules}</strong></dt><dd><p>Handles storing of scanner information when parsing.</p></dd><dt><strong>{user_state, UserState}</strong></dt><dd><p>Global state variable accessible from all customization functions</p></dd><dt><strong>{fetch_path, PathList}</strong></dt><dd><p>PathList is a list of
directories to search when fetching files. If the file in question
is not in the fetch_path, the URI will be used as a file
name.</p></dd><dt><strong>{space, Flag}</strong></dt><dd><p>'preserve' (default) to preserve spaces, 'normalize' to
accumulate consecutive whitespace and replace it with one space.</p></dd><dt><strong>{line, Line}</strong></dt><dd><p>To specify starting line for scanning in document which contains
fragments of XML.</p></dd><dt><strong>{namespace_conformant, Flag}</strong></dt><dd><p>Controls whether to behave as a namespace conformant XML parser,
'false' (default) to not otherwise 'true'.</p></dd><dt><strong>{validation, Flag}</strong></dt><dd><p>Controls whether to process as a validating XML parser:
'off' (default) no validation, or validation 'dtd' by DTD or 'schema'
by XML Schema. 'false' and 'true' options are obsolete
(i.e. they may be removed in a future release), if used 'false'
equals 'off' and 'true' equals 'dtd'.</p></dd><dt><strong>{schemaLocation, [{Namespace,Link}|...]}</strong></dt><dd><p>Tells explicitly which XML Schema documents to use to validate
the XML document. Used together with the
<strong>{validation,schema}</strong> option.</p></dd><dt><strong>{quiet, Flag}</strong></dt><dd><p>Set to 'true' if xmerl should behave quietly and not output any
information to standard output (default 'false').</p></dd><dt><strong>{doctype_DTD, DTD}</strong></dt><dd><p>Allows to specify DTD name when it isn't available in the XML
document. This option has effect only together with
<strong>{validation,'dtd'</strong> option.</p></dd><dt><strong>{xmlbase, Dir}</strong></dt><dd><p>XML Base directory. If using string/1 default is current directory.
If using file/1 default is directory of given file.</p></dd><dt><strong>{encoding, Enc}</strong></dt><dd><p>Set default character set used (default UTF-8).
This character set is used only if not explicitly given by the XML
declaration. </p></dd><dt><strong>{document, Flag}</strong></dt><dd><p>Set to 'true' if xmerl should return a complete XML document
as an xmlDocument record (default 'false').</p></dd><dt><strong>{comments, Flag}</strong></dt><dd><p>Set to 'false' if xmerl should skip comments otherwise they will
be returned as xmlComment records (default 'true').</p></dd><dt><strong>{default_attrs, Flag}</strong></dt><dd><p>Set to 'true' if xmerl should add to elements missing attributes
with a defined default value (default 'false').</p></dd></dl> </dd><dt><a name="type-xmlElement"></a>xmlElement() = #xmlElement{}</dt><dd> </dd></dl><h2>Functions</h2><h3>file_sax(Fname::string(), CallBackModule::atom(), UserState, Options::) -&gt; NewUserState</h3><p>Parse file containing an XML document, SAX style.</p><a name="file_sax-4"></a><p>Parse file containing an XML document, SAX style.
Wrapper for a call to the XML parser <strong>xmerl_scan</strong> with a
<strong>hook_fun</strong> for using xmerl export functionality directly after
an entity is parsed.</p><h3>stream(Fname::string(), Options::) -&gt;</h3><p>Parse file containing an XML document as a stream, DOM style.</p><a name="stream-2"></a><p>Parse file containing an XML document as a stream, DOM style.
Wrapper for a call to the XML parser <strong>xmerl_scan</strong> with a
<strong>continuation_fun</strong> for handling streams of XML data.
Note that the <strong>continuation_fun</strong>, <strong>acc_fun</strong>,
<strong>fetch_fun</strong>, <strong>rules</strong> and <strong>close_fun</strong>
options cannot be user defined using this parser.</p><h3>stream_sax(Fname, CallBack::CallBackModule, UserState, Options) -&gt;</h3><p>Parse file containing an XML document as a stream, SAX style.</p><ul><li><span class="v">Fname = string()</span></li><li><span class="v">CallBackModule = atom()</span></li><li><span class="v">Options = </span></li></ul><a name="stream_sax-4"></a><p>Parse file containing an XML document as a stream, SAX style.
Wrapper for a call to the XML parser <strong>xmerl_scan</strong> with a
<strong>continuation_fun</strong> for handling streams of XML data.
Note that the <strong>continuation_fun</strong>, <strong>acc_fun</strong>,
<strong>fetch_fun</strong>, <strong>rules</strong>, <strong>hook_fun</strong>,
<strong>close_fun</strong> and <strong>user_state</strong> options cannot be user
defined using this parser.</p><h3>string_sax(String::list(), CallBackModule::atom(), UserState, Options::) -&gt;</h3><p>Parse file containing an XML document, SAX style.</p><a name="string_sax-4"></a><p>Parse file containing an XML document, SAX style.
Wrapper for a call to the XML parser <strong>xmerl_scan</strong> with a
<strong>hook_fun</strong> for using xmerl export functionality directly after
an entity is parsed.</p><h2>Authors</h2><h2>xmerl_xpath</h2><p>The xmerl_xpath module handles the entire XPath 1.0 spec.</p><p>The xmerl_xpath module handles the entire XPath 1.0 spec.
XPath expressions typically occur in XML attributes and are used to address
parts of an XML document.
The grammar is defined in <strong>xmerl_xpath_parse.yrl</strong>.
The core functions are defined in <strong>xmerl_xpath_pred.erl</strong>.Some useful shell commands for debugging the XPath parser<pre>
 c(xmerl_xpath_scan).
 yecc:yecc("xmerl_xpath_parse.yrl", "xmerl_xpath_parse", true, []).
 c(xmerl_xpath_parse).

 xmerl_xpath_parse:parse(xmerl_xpath_scan:tokens("position() &gt; -1")).
 xmerl_xpath_parse:parse(xmerl_xpath_scan:tokens("5 * 6 div 2")).
 xmerl_xpath_parse:parse(xmerl_xpath_scan:tokens("5 + 6 mod 2")).
 xmerl_xpath_parse:parse(xmerl_xpath_scan:tokens("5 * 6")).
 xmerl_xpath_parse:parse(xmerl_xpath_scan:tokens("-----6")).
 xmerl_xpath_parse:parse(xmerl_xpath_scan:tokens("parent::node()")).
 xmerl_xpath_parse:parse(xmerl_xpath_scan:tokens("descendant-or-self::node()")).
 xmerl_xpath_parse:parse(xmerl_xpath_scan:tokens("parent::processing-instruction('foo')")).
  </pre></p><h3>DATA TYPES</h3><a name="types"></a><dl><dt><a name="type-docEntity"></a>docEntity() = #xmlDocument{} | [<a href="#type-docNodes">docNodes()</a>]</dt><dd> </dd><dt><a name="type-docNodes"></a>docNodes() = #xmlElement{} | #xmlAttribute{} | #xmlText{} | #xmlPI{} | #xmlComment{} | #xmlNsNode{}</dt><dd> </dd><dt><a name="type-nodeEntity"></a>nodeEntity() = #xmlElement{} | #xmlAttribute{} | #xmlText{} | #xmlPI{} | #xmlComment{} | #xmlNsNode{} | #xmlDocument{}</dt><dd> </dd><dt><a name="type-option_list"></a>option_list()</dt><dd> <p>Options allows to customize the behaviour of the
XPath scanner.
</p> <p>
Possible options are:
</p> <dl><dt><strong>{namespace, #xmlNamespace}</strong></dt><dd><p>Set namespace nodes, from XmlNamspace, in xmlContext</p></dd><dt><strong>{namespace, Nodes}</strong></dt><dd><p>Set namespace nodes in xmlContext.</p></dd></dl> </dd><dt><a name="type-parentList"></a>parentList() = [{atom(), integer()}]</dt><dd> </dd><dt><a name="type-xPathString"></a>xPathString() = string()</dt><dd> </dd></dl><h2>Functions</h2><h3>string(Str, Doc) -&gt; [] | Scalar</h3><p>Equivalent to string(Str, Doc, []). </p><a name="string-2"></a><p>Equivalent to <a href="#string-3">string(Str, Doc, [])</a>.</p><h3>string(Str, Doc, Options) -&gt; [] | Scalar</h3><p>Equivalent to string(Str, Doc, [], Doc, Options). </p><a name="string-3"></a><p>Equivalent to <a href="#string-5">string(Str, Doc, [], Doc, Options)</a>.</p><h3>string(Str, Node, Parents, Doc, Options) -&gt; [] | Scalar</h3><p>Extracts the nodes from the parsed XML tree according to XPath.</p><ul><li><span class="v">Str = </span></li><li><span class="v">Node = </span></li><li><span class="v">Parents = </span></li><li><span class="v">Doc = </span></li><li><span class="v">Options = </span></li><li><span class="v">Scalar = #xmlObj{}</span></li></ul><a name="string-5"></a><p>Extracts the nodes from the parsed XML tree according to XPath.
xmlObj is a record with fields type and value,
where type is boolean | number | string</p><h2>Authors</h2><h2>xmerl_xsd</h2><p>Interface module for XML Schema validation.</p><p>Interface module for XML Schema validation.
It handles the W3.org
<a href="http://www.w3.org/XML/Schema#dev">specifications</a>
of XML Schema second edition 28 october 2004. For an introduction to
XML Schema study <a href="http://www.w3.org/TR/xmlschema-0/">part 0.</a>
An XML structure is validated by xmerl_xsd:validate/[2,3].</p><h3>DATA TYPES</h3><a name="types"></a><dl><dt><a name="type-filename"></a>filename() = string()</dt><dd> </dd><dt><a name="type-global_state"></a>global_state()</dt><dd> <p>The global state of the validator. It is
representated by the <strong>#xsd_state{}</strong> record.
</p> </dd><dt><a name="type-option_list"></a>option_list()</dt><dd> <p>Options allow to customize the behaviour of the
validation.
</p> <p>
Possible options are :
</p> <dl><dt><strong>{tab2file,boolean()}</strong></dt><dd><p>Enables saving of abstract structure on file for debugging
purpose.</p></dd><dt><strong>{xsdbase,filename()}</strong></dt><dd><p>XSD Base directory.</p></dd><dt><strong>{fetch_fun,FetchFun}</strong></dt><dd><p>Call back function to fetch an external resource.</p></dd><dt><strong>{fetch_path,PathList}</strong></dt><dd><p>PathList is a list of directories to search when fetching files.
If the file in question is not in the fetch_path, the URI will
be used as a file name.</p></dd><dt><strong>{state,State}</strong></dt><dd><p>It is possible by this option to provide a state with process
information from an earlier validation.</p></dd></dl> </dd></dl><h2>Functions</h2><h3>file2state(FileName) -&gt; {ok, State} | {error, Reason}</h3><p>Reads the schema state with all information of the processed schema from a file created with state2file/[1,2].</p><ul><li><span class="v">State = </span></li><li><span class="v">FileName = string()</span></li></ul><a name="file2state-1"></a><p>Reads the schema state with all information of the processed
schema from a file created with <strong>state2file/[1,2]</strong>.  The
format of this file is internal. The state can then be used
validating an XML document.</p><h3>format_error(L::Errors) -&gt; Result</h3><p>Formats error descriptions to human readable strings.</p><ul><li><span class="v">Errors = tuple() | [tuple()]</span></li><li><span class="v">Result = string() | [string()]</span></li></ul><a name="format_error-1"></a><p>Formats error descriptions to human readable strings.</p><h3>process_schema(Schema) -&gt; Result</h3><p>Equivalent to process_schema(Schema, []). </p><a name="process_schema-1"></a><p>Equivalent to <a href="#process_schema-2">process_schema(Schema, [])</a>.</p><h3>process_schema(Schema, Options) -&gt; Result</h3><p>Reads the referenced XML schema and checks that it is valid.</p><ul><li><span class="v">Schema = string()</span></li><li><span class="v">Result = {ok, State} | {error, Reason}</span></li><li><span class="v">State = </span></li><li><span class="v">Reason = [ErrorReason] | ErrorReason</span></li><li><span class="v">Options = </span></li></ul><a name="process_schema-2"></a><p>Reads the referenced XML schema and checks that it is valid.
Returns the <strong>global_state()</strong> with schema info or an
error reason. The error reason may be a list of several errors
or a single error encountered during the processing.</p><h3>process_schemas(Schemas) -&gt; Result</h3><p>Equivalent to process_schema(Schemas, []). </p><a name="process_schemas-1"></a><p>Equivalent to <a href="#process_schema-2">process_schema(Schemas, [])</a>.</p><h3>process_schemas(Schemas, Options) -&gt; Result</h3><p>Reads the referenced XML schemas and controls they are valid.</p><ul><li><span class="v">Schemas = [{NameSpace, string()} | Schemas] | []</span></li><li><span class="v">Result = {ok, State} | {error, Reason}</span></li><li><span class="v">Reason = [ErrorReason] | ErrorReason</span></li><li><span class="v">Options = </span></li></ul><a name="process_schemas-2"></a><p>Reads the referenced XML schemas and controls they are valid.
Returns the <strong>global_state()</strong> with schema info or an
error reason. The error reason may be a list of several errors
or a single error encountered during the processing.</p><h3>process_validate(Schema, Xml::Element) -&gt; Result</h3><p>Equivalent to process_validate(Schema, Xml, []). </p><a name="process_validate-2"></a><p>Equivalent to <a href="#process_validate-3">process_validate(Schema, Xml, [])</a>.</p><h3>process_validate(Schema, Xml::Element, Opts::Options) -&gt; Result</h3><p>Validates a parsed well-formed XML element towards an XML schema.</p><ul><li><span class="v">Schema = string()</span></li><li><span class="v">Element = XmlElement</span></li><li><span class="v">Options = </span></li><li><span class="v">Result = {ValidXmlElement, State} | {error, Reason}</span></li><li><span class="v">Reason = [ErrorReason] | ErrorReason</span></li></ul><a name="process_validate-3"></a><p>Validates a parsed well-formed XML element towards an XML
schema.  </p><p> Validates in two steps. First it processes the schema,
saves the type and structure info in an ets table and then
validates the element towards the schema.</p><p> Usage example:</p><p>
<strong>1&gt;{E,_} = xmerl_scan:file("my_XML_document.xml").</strong><br/>
<strong>2&gt;{E2,_} = xmerl_xsd:validate("my_XML_Schema.xsd",E).</strong>
</p><p> Observe that E2 may differ from E if for instance there are default
values defined in <strong>my_XML_Schema.xsd</strong>.</p><h3>state2file(S::State) -&gt; ok | {error, Reason}</h3><p>Same as state2file(State,SchemaName).</p><a name="state2file-1"></a><p>Same as state2file(State,SchemaName)</p><p>The name of the saved file is the same as the name of the
schema, but with <strong>.xss</strong> extension.</p><h3>state2file(S::State, FileName) -&gt; ok | {error, Reason}</h3><p>Saves the schema state with all information of the processed schema in a file.</p><ul><li><span class="v">State = </span></li><li><span class="v">FileName = string()</span></li></ul><a name="state2file-2"></a><p>Saves the schema state with all information of the processed
schema in a file. You can provide the file name for the saved
state. FileName is saved with the <strong>.xss</strong> extension
added.</p><h3>validate(Xml::Element, State) -&gt; Result</h3><p>Equivalent to validate(Element, State, []). </p><a name="validate-2"></a><p>Equivalent to <a href="#validate-3">validate(Element, State, [])</a>.</p><h3>validate(Xml::Element, State, Opts::Options) -&gt; Result</h3><p>Validates a parsed well-formed XML element (Element).</p><ul><li><span class="v">Element = XmlElement</span></li><li><span class="v">Options = </span></li><li><span class="v">Result = {ValidElement, } | {error, Reasons}</span></li><li><span class="v">ValidElement = XmlElement</span></li><li><span class="v">State = </span></li><li><span class="v">Reasons = [ErrorReason] | ErrorReason</span></li></ul><a name="validate-3"></a><p>Validates a parsed well-formed XML element (Element).
</p><p>A call to validate/2 or validate/3 must provide a well formed
parsed XML element <strong>#xmlElement{}</strong> and a State,
<strong>global_state()</strong>, which holds necessary information from
an already processed schema.
Thus validate enables reuse of the schema information and
therefore if one shall validate several times towards the same
schema it reduces time consumption.</p><p>The result, ValidElement, is the valid element that conforms to the
post-schema-validation infoset. When the validator finds an error it
tries to continue and reports a list of all errors found. In those cases
an unexpected error is found it may cause a single error reason.
</p><p> Usage example:</p><p>
<strong>1&gt;{E,_} = xmerl_scan:file("my_XML_document.xml").</strong><br/>
<strong>2&gt;{ok,S} = xmerl_xsd:process_schema("my_XML_Schema.xsd").</strong><br/>
<strong>3&gt;{E2,_} = xmerl_xsd:validate(E,S).</strong>
</p><p> Observe that E2 may differ from E if for instance there are default
values defined in <strong>my_XML_Schema.xsd</strong>.</p><h2>Authors</h2><h2>xmerl_sax_parser</h2><p>XML SAX parser API</p><p>
A SAX parser for XML that sends the events through a callback interface.
SAX is the <em>Simple API for XML</em>, originally a Java-only API. SAX was the first widely adopted API for 
XML in Java, and is a <em>de facto</em> standard where there are versions for several programming language 
environments other than Java.
</p><h3>DATA TYPES</h3><dl><dt><strong>option()</strong></dt><dd> <p>
Options used to customize the behaviour of the parser.
Possible options are:
</p> <dl><dt><strong>{continuation_fun, ContinuationFun}</strong></dt><dd> <a href="#ContinuationFun/1">ContinuationFun</a> is a call back function to decide what to do if  the parser runs into EOF before the document is complete.  </dd><dt><strong>{continuation_state, term()}</strong></dt><dd> State that is accessible in the continuation call back function.  </dd><dt><strong>{event_fun, EventFun}</strong></dt><dd> <a href="#EventFun/3">EventFun</a> is the call back function for parser events.  </dd><dt><strong>{event_state, term()}</strong></dt><dd> State that is accessible in the event call back function.  </dd><dt><strong>{file_type, FileType}</strong></dt><dd> Flag that tells the parser if it's parsing a DTD or a normal XML file (default normal). <ul><li><strong>FileType = normal | dtd</strong></li></ul> </dd><dt><strong>{encoding, Encoding}</strong></dt><dd> Set default character set used (default UTF-8). This character set is used only if not explicitly  given by the XML document. <ul><li><strong>Encoding = utf8 | {utf16,big} | {utf16,little} | latin1 | list</strong></li></ul> </dd><dt><strong>skip_external_dtd</strong></dt><dd> Skips the external DTD during parsing. </dd></dl> </dd><dt></dt><dd>  </dd><dt><strong>event()</strong></dt><dd> <p>
The SAX events that are sent to the user via the callback.
</p> <dl><dt><strong>startDocument</strong></dt><dd> Receive notification of the beginning of a document. The SAX parser will send this event only once  before any other event callbacks. </dd><dt><strong>endDocument</strong></dt><dd> Receive notification of the end of a document. The SAX parser will send this event only once, and it will  be the last event during the parse.  </dd><dt><strong>{startPrefixMapping, Prefix, Uri}</strong></dt><dd> Begin the scope of a prefix-URI Namespace mapping. Note that start/endPrefixMapping events are not guaranteed to be properly nested relative to each other:  all startPrefixMapping events will occur immediately before the corresponding startElement event, and all  endPrefixMapping  events will occur immediately after the corresponding endElement event, but their  order is not otherwise guaranteed. There will not be start/endPrefixMapping events for the "xml" prefix, since it is predeclared and immutable. <ul><li><strong>Prefix = string()</strong></li><li><strong>Uri = string()</strong></li></ul> </dd><dt><strong>{endPrefixMapping, Prefix}</strong></dt><dd> End the scope of a prefix-URI mapping. <ul><li><strong>Prefix = string()</strong></li></ul> </dd><dt><strong>{startElement, Uri, LocalName, QualifiedName, Attributes}</strong></dt><dd> Receive notification of the beginning of an element. The Parser will send this event at the beginning of every element in the XML document;  there will be a corresponding endElement event for every startElement event (even when the element is empty).  All of the element's content will be reported, in order, before the corresponding endElement event. <ul><li><strong>Uri = string()</strong></li><li><strong>LocalName = string()</strong></li><li><strong>QualifiedName = {Prefix, LocalName}</strong></li><li><strong>Prefix = string()</strong></li><li><strong>Attributes = [{Uri, Prefix, AttributeName, Value}]</strong></li><li><strong>AttributeName = string()</strong></li><li><strong>Value = string()</strong></li></ul> </dd><dt><strong>{endElement, Uri, LocalName, QualifiedName}</strong></dt><dd> Receive notification of the end of an element. The SAX parser will send this event at the end of every element in the XML document; there will be a corresponding startElement event for every endElement event (even when the element is empty). <ul><li><strong>Uri = string()</strong></li><li><strong>LocalName = string()</strong></li><li><strong>QualifiedName = {Prefix, LocalName}</strong></li><li><strong>Prefix = string()</strong></li></ul> </dd><dt><strong>{characters, string()}</strong></dt><dd> Receive notification of character data.  </dd><dt><strong>{ignorableWhitespace, string()}</strong></dt><dd> Receive notification of ignorable whitespace in element content. </dd><dt><strong>{processingInstruction, Target, Data}</strong></dt><dd> Receive notification of a processing instruction. The Parser will send this event once for each processing instruction found:  note that processing instructions may occur before or after the main document element. <ul><li><strong>Target = string()</strong></li><li><strong>Data = string()</strong></li></ul> </dd><dt><strong>{comment, string()}</strong></dt><dd> Report an XML comment anywhere in the document (both inside and outside of the document element). </dd><dt><strong>startCDATA</strong></dt><dd> Report the start of a CDATA section. The contents of the CDATA section will be reported  through the regular characters event. </dd><dt><strong>endCDATA</strong></dt><dd> Report the end of a CDATA section. </dd><dt><strong>{startDTD, Name, PublicId, SystemId}</strong></dt><dd> Report the start of DTD declarations, it's reporting the start of the DOCTYPE declaration. If the document has no DOCTYPE declaration, this event will not be sent. <ul><li><strong>Name = string()</strong></li><li><strong>PublicId = string()</strong></li><li><strong>SystemId = string()</strong></li></ul> </dd><dt><strong>endDTD</strong></dt><dd> Report the end of DTD declarations, it's reporting the end of the DOCTYPE declaration. </dd><dt><strong>{startEntity, SysId}</strong></dt><dd>  Report the beginning of some internal and external XML entities. ??? </dd><dt><strong>{endEntity, SysId}</strong></dt><dd> Report the end of an entity. ??? </dd><dt><strong>{elementDecl, Name, Model}</strong></dt><dd> Report an element type declaration.    The content model will consist of the string "EMPTY", the string "ANY", or a parenthesised group,  optionally followed by an occurrence indicator. The model will be normalized so that all parameter  entities are fully resolved and all whitespace is removed,and will include the enclosing parentheses.  Other normalization (such as removing redundant parentheses or simplifying occurrence indicators)  is at the discretion of the parser. <ul><li><strong>Name = string()</strong></li><li><strong>Model = string()</strong></li></ul> </dd><dt><strong>{attributeDecl, ElementName, AttributeName, Type, Mode, Value}</strong></dt><dd> Report an attribute type declaration. <ul><li><strong>ElementName = string()</strong></li><li><strong>AttributeName = string()</strong></li><li><strong>Type = string()</strong></li><li><strong>Mode = string()</strong></li><li><strong>Value = string()</strong></li></ul> </dd><dt><strong>{internalEntityDecl, Name, Value}</strong></dt><dd> Report an internal entity declaration. <ul><li><strong>Name = string()</strong></li><li><strong>Value = string()</strong></li></ul> </dd><dt><strong>{externalEntityDecl, Name, PublicId, SystemId}</strong></dt><dd> Report a parsed external entity declaration. <ul><li><strong>Name = string()</strong></li><li><strong>PublicId = string()</strong></li><li><strong>SystemId = string()</strong></li></ul> </dd><dt><strong>{unparsedEntityDecl, Name, PublicId, SystemId, Ndata}</strong></dt><dd> Receive notification of an unparsed entity declaration event. <ul><li><strong>Name = string()</strong></li><li><strong>PublicId = string()</strong></li><li><strong>SystemId = string()</strong></li><li><strong>Ndata = string()</strong></li></ul> </dd><dt><strong>{notationDecl, Name, PublicId, SystemId}</strong></dt><dd> Receive notification of a notation declaration event. <ul><li><strong>Name = string()</strong></li><li><strong>PublicId = string()</strong></li><li><strong>SystemId = string()</strong></li></ul> </dd></dl> </dd><dt><strong>unicode_char()</strong></dt><dd> Integer representing valid unicode codepoint. </dd><dt><strong>unicode_binary()</strong></dt><dd> Binary with characters encoded in UTF-8 or UTF-16. </dd><dt><strong>latin1_binary()</strong></dt><dd> Binary with characters encoded in iso-latin-1. </dd></dl><h2>Functions</h2><h3>file(Filename, Options) -&gt; Result</h3><p>Parse file containing an XML document.</p><ul><li><span class="v">Filename = string()</span></li><li><span class="v">Options = [option()]</span></li><li><span class="v">Result = {ok, EventState, Rest} |</span></li><li><span class="v">Â Â Â {Tag, Location, Reason, EndTags, EventState}</span></li><li><span class="v">Rest = unicode_binary() | latin1_binary()</span></li><li><span class="v">Tag = atom() (fatal_error, or user defined tag)</span></li><li><span class="v">Location = {CurrentLocation, EntityName, LineNo}</span></li><li><span class="v">CurrentLocation = string()</span></li><li><span class="v">EntityName = string()</span></li><li><span class="v">LineNo = integer()</span></li><li><span class="v">EventState = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Parse file containing an XML document. This functions uses a default continuation function to read the file in blocks.</p><h3>stream(Xml, Options) -&gt; Result</h3><p>Parse a stream containing an XML document.</p><ul><li><span class="v">Xml = unicode_binary() | latin1_binary() | [unicode_char()]</span></li><li><span class="v">Options = [option()]</span></li><li><span class="v">Result = {ok, EventState, Rest} |</span></li><li><span class="v">Â Â Â {Tag, Location, Reason, EndTags, EventState}</span></li><li><span class="v">Rest =  unicode_binary() | latin1_binary() | [unicode_char()]</span></li><li><span class="v">Tag = atom() (fatal_error or user defined tag)</span></li><li><span class="v">Location = {CurrentLocation, EntityName, LineNo}</span></li><li><span class="v">CurrentLocation = string()</span></li><li><span class="v">EntityName = string()</span></li><li><span class="v">LineNo = integer()</span></li><li><span class="v">EventState = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Parse a stream containing an XML document.</p><h3>CALLBACK FUNCTIONS</h3><p>
The callback interface is based on that the user sends a fun with the 
correct signature to the parser.
</p><h2>Functions</h2><h3>ContinuationFun(State) -&gt; {NewBytes, NewState}</h3><p>Continuation call back function.</p><ul><li><span class="v">State = NewState = term()</span></li><li><span class="v">NewBytes = binary() | list() (should be same as start input in stream/2)</span></li></ul><p>
This function is called whenever the parser runs out of input data.
If the function can't get hold of more input an empty list or binary 
(depends on start input in stream/2) is returned.
Other types of errors is handled through exceptions. Use throw/1 to send the 
following tuple {Tag = atom(), Reason = string()} if the continuation function encounters a fatal error. 
Tag is an atom that identifies the functional entity that sends the exception 
and Reason is a string that describes the problem.
</p><h3>EventFun(Event, Location, State) -&gt; NewState</h3><p>Event call back function.</p><ul><li><span class="v">Event = event()</span></li><li><span class="v">Location = {CurrentLocation, Entityname, LineNo}</span></li><li><span class="v">CurrentLocation = string()</span></li><li><span class="v">Entityname = string()</span></li><li><span class="v">LineNo = integer()</span></li><li><span class="v">State = NewState = term()</span></li></ul><p>
This function is called for every event sent by the parser. 
The error handling is done through exceptions. Use throw/1 to send the 
following tuple {Tag = atom(), Reason = string()} if the application encounters a fatal error. 
Tag is an atom that identifies the functional entity that sends the exception 
and Reason is a string that describes the problem.
</p></body></html>