<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>erl_error</h1><h1>erl_error</h1><p>Error print routines.</p><p>This module contains some error printing routines taken
from "Advanced Programming in the UNIX Environment"
by W. Richard Stevens.These functions are all called in the same manner as
<strong>printf()</strong>, that is, with a string containing format
specifiers followed by a list of corresponding arguments. All output from
these functions is to <strong>stderr</strong>.</p><h1>Functions</h1><h2>erl_err_msg(FormatStr, ... ):void</h2><p>Non-fatal error, and not system call error.</p><ul><li><span class="v">const char *FormatStr;</span></li></ul><p>The message provided by the caller is printed. This
function is simply a wrapper for <strong>fprintf()</strong>.</p><h2>erl_err_quit(FormatStr, ... ):void</h2><p>Fatal error, but not system call error.</p><ul><li><span class="v">const char *FormatStr;</span></li></ul><p>Use this function when a fatal error has occurred that
is not because of a system call. The message provided by the
caller is printed and the process terminates with exit
value <strong>1</strong>. This function does not return.</p><h2>erl_err_ret(FormatStr, ... ):void</h2><p>Non-fatal system call error.</p><ul><li><span class="v">const char *FormatStr;</span></li></ul><p>Use this function after a failed system call. The message
provided by the caller is printed followed by a string
describing the reason for failure.</p><h2>erl_err_sys(FormatStr, ... ):void</h2><p>Fatal system call error.</p><ul><li><span class="v">const char *FormatStr;</span></li></ul><p>Use this function after a failed system call. The message
provided by the caller is printed followed by a string
describing the reason for failure, and the process
terminates with exit value <strong>1</strong>. This function does not
return.</p><h2>Error Reporting</h2><p>Most functions in <strong>Erl_Interface</strong> report failures to the caller by
returning some otherwise meaningless value (typically
<strong>NULL</strong>
or a negative number). As this only tells you that things did not
go well, examine the error code in <strong>erl_errno</strong> if you
want to find out more about the failure.</p><h1>Functions</h1><h2>erl_errno:volatile int</h2><p>Variable <strong>erl_errno</strong> contains the Erl_Interface error number. You can change the value if you wish. </p><p><strong>erl_errno</strong> is initially (at program startup) zero
and is then set by many <strong>Erl_Interface</strong> functions on failure to
a non-zero error code to indicate what kind of error it
encountered. A successful function call can change
<strong>erl_errno</strong> (by calling some other function that
fails), but no function does never set it to zero. This means
that you cannot use <strong>erl_errno</strong> to see <em>if</em> a
function call failed. Instead, each function reports failure
in its own way (usually by returning a negative number or
<strong>NULL</strong>), in which case you can examine
<strong>erl_errno</strong> for details.</p><p><strong>erl_errno</strong> uses the error codes defined in your
system's <strong>&lt;errno.h&gt;</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><strong>erl_errno</strong> is a "modifiable lvalue" (just
like ISO C defines <strong>errno</strong> to be) rather than a
variable. This means it can be implemented as a macro
(expanding to, for example, <strong>*_erl_errno()</strong>).
For reasons of thread safety (or task safety), this is exactly what
we do on most platforms.</p></div></body></html>