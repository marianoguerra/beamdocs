<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Erl_Interface</h1><h1>Erl_Interface</h1><h4>Deprecation and Removal</h4><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The support for VxWorks is deprecated as of OTP 22, and
will be removed in OTP 23.</p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The old legacy <strong>erl_interface</strong> library (functions
with prefix <strong>erl_</strong>) is deprecated as of OTP 22, and will be
removed in OTP 23. This does not apply to the <strong>ei</strong>
library. Reasonably new <strong>gcc</strong> compilers will issue deprecation
warnings. In order to disable these warnings, define the macro
<strong>EI_NO_DEPR_WARN</strong>.</p></div><h4>Introduction</h4><p>The <strong>Erl_Interface</strong> library contains functions that help you
integrate programs written in C and Erlang. The functions in
<strong>Erl_Interface</strong> support the following:</p><ul><li>Manipulation of data represented as Erlang data types</li><li>Conversion of data between C and Erlang formats</li><li>Encoding and decoding of Erlang data types for transmission or storage</li><li>Communication between C nodes and Erlang processes</li><li>Backup and restore of C node state to and from <a href="./mnesia">Mnesia</a></li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>By default, the <strong>Erl_Interface</strong> libraries are only guaranteed
to be compatible with other Erlang/OTP components from the same
release as the libraries themselves. For information about how to
communicate with Erlang/OTP components from earlier releases, see
function <a href="./ei#ei_set_compat_rel">ei#ei_set_compat_rel</a> and
<a href="./erl_eterm#erl_set_compat_rel">erl_eterm#erl_set_compat_rel</a>.</p></div><h4>Scope</h4><p>In the following sections, these topics are described:</p><ul><li>Compiling your code for use with <strong>Erl_Interface</strong></li><li>Initializing <strong>Erl_Interface</strong></li><li>Encoding, decoding, and sending Erlang terms</li><li>Building terms and patterns</li><li>Pattern matching</li><li>Connecting to a distributed Erlang node</li><li>Using the Erlang Port Mapper Daemon (EPMD)</li><li>Sending and receiving Erlang messages</li><li>Remote procedure calls</li><li>Using global names</li><li>Using the registry</li></ul><h4>Prerequisites</h4><p>It is assumed that the reader is familiar with the Erlang programming
language.</p><h4>Compiling and Linking Your Code</h4><p>To use any of the <strong>Erl_Interface</strong> functions, include the
following lines in your code:</p><pre><code class="">
#include "erl_interface.h"
#include "ei.h"    </code></pre><p>Determine where the top directory of your OTP installation is.
To find this, start Erlang and enter the following
command at the Eshell prompt:</p><pre><code class="">
Eshell V4.7.4  (abort with ^G)
1&gt; code:root_dir().
/usr/local/otp    </code></pre><p>To compile your code, ensure that your C compiler knows where
to find <strong>erl_interface.h</strong> by specifying an appropriate
<strong>-I</strong> argument on the command line, or add it to
the <strong>CFLAGS</strong> definition in your
<strong>Makefile</strong>. The correct value for this path is
<strong>$OTPROOT/lib/erl_interface-$EIVSN/include</strong>,
where:</p><ul><li> <p><strong>$OTPROOT</strong> is the path reported by
<strong>code:root_dir/0</strong> in the example above.</p> </li><li> <p><strong>$EIVSN</strong> is the version of the <strong>Erl_Interface</strong> application,
for example, <strong>erl_interface-3.2.3</strong>.</p> </li></ul><p>Compiling the code:</p><pre><code class="">
$ cc -c -I/usr/local/otp/lib/erl_interface-3.2.3/include myprog.c    </code></pre><p>When linking:</p><ul><li>Specify the path to <strong>liberl_interface.a</strong> and <strong>libei.a</strong> with <strong>-L$OTPROOT/lib/erl_interface-3.2.3/lib</strong>.</li><li>Specify the name of the libraries with <strong>-lerl_interface -lei</strong>.</li></ul><p>Do this on the command line or add the flags to the
<strong>LDFLAGS</strong> definition in your
<strong>Makefile</strong>.</p><p>Linking the code:</p><pre><code class="">
$ ld -L/usr/local/otp/lib/erl_interface-3.2.3/
                            lib myprog.o -lerl_interface -lei -o myprog    </code></pre><p>On some systems it can be necessary to link with some more
libraries (for example, <strong>libnsl.a</strong> and
<strong>libsocket.a</strong> on Solaris, or
<strong>wsock32.lib</strong> on Windows) to use the
communication facilities of <strong>Erl_Interface</strong>.</p><p>If you use the <strong>Erl_Interface</strong> functions in a threaded
application based on POSIX threads or Solaris threads, then
<strong>Erl_Interface</strong> needs access to some of the synchronization
facilities in your threads package. You must specify extra
compiler flags to indicate which of the packages you use. Define
<strong>_REENTRANT</strong> and either <strong>STHREADS</strong> or
<strong>PTHREADS</strong>. The default is to use POSIX threads if
<strong>_REENTRANT</strong> is specified.</p><h4>Initializing the Libraries</h4><p>
Before calling any of the other functions in the <strong>erl_interface</strong>
and <strong>ei</strong> libraries, call <strong>erl_init()</strong> exactly once to initialize
both libraries.
<strong>erl_init()</strong> takes two arguments. However, the arguments
are no longer used by <strong>erl_interface</strong> and are therefore to be
specified as <strong>erl_init(NULL,0)</strong>.
</p><p>
If you only use the <strong>ei</strong> library, instead initialize it by calling
<strong>ei_init()</strong> exactly once before calling any other functions in
the <strong>ei</strong> library.
</p><h4>Encoding, Decoding, and Sending Erlang Terms</h4><p>Data sent between distributed Erlang nodes is encoded in the
Erlang external format. You must therefore encode and decode
Erlang terms into byte streams if you want to use the distribution
protocol to communicate between a C program and Erlang.</p><p>The <strong>Erl_Interface</strong> library supports this activity. It has
several C functions that create and manipulate Erlang data
structures. The library also contains an encode and a decode function.
The following example shows how to create and encode an Erlang tuple
<strong>{tobbe,3928}</strong>:</p><pre><code class="">
ETERM *arr[2], *tuple;
char buf[BUFSIZ];
int i;
  
arr[0] = erl_mk_atom("tobbe");
arr[1] = erl_mk_integer(3928);
tuple  = erl_mk_tuple(arr, 2);
i = erl_encode(tuple, buf);    </code></pre><p>Alternatively, you can use <strong>erl_send()</strong> and
<strong>erl_receive_msg</strong>, which handle the encoding and
decoding of messages transparently.</p><p>For a complete description, see the following modules:</p><ul><li><a href="erl_eterm">erl_eterm</a> for creating Erlang terms</li><li><a href="erl_marshal">erl_marshal</a> for encoding and decoding routines</li></ul><a name="building_terms_and_patterns"></a><h4>Building Terms and Patterns</h4><p>The previous example can be simplified by using the
<a href="erl_format">erl_format</a> module
to create an Erlang term:</p><pre><code class="">
ETERM *ep;
ep = erl_format("{~a,~i}", "tobbe", 3928);    </code></pre><p>For a complete description of the different format directives, see
the <a href="erl_format">erl_format</a> module.</p><p>The following example is more complex:</p><pre><code class="">
ETERM *ep;
ep = erl_format("[{name,~a},{age,~i},{data,~w}]",
                 "madonna", 
                 21, 
                 erl_format("[{adr,~s,~i}]", "E-street", 42));
erl_free_compound(ep);      </code></pre><p>As in the previous examples, it is your responsibility to free the
memory allocated for Erlang terms. In this example,
<strong>erl_free_compound()</strong> ensures that the complete term
pointed to by <strong>ep</strong> is released. This is necessary
because the pointer from the second call to <strong>erl_format</strong> is lost.</p><p>The following example shows a slightly different solution:</p><pre><code class="">
ETERM *ep,*ep2;
ep2 = erl_format("[{adr,~s,~i}]","E-street",42);
ep  = erl_format("[{name,~a},{age,~i},{data,~w}]",
                 "madonna", 21, ep2);
erl_free_term(ep);  
erl_free_term(ep2);      </code></pre><p>In this case, you free the two terms independently. The order in
which you free the terms <strong>ep</strong> and <strong>ep2</strong>
is not important,
because the <strong>Erl_Interface</strong> library uses reference counting to
determine when it is safe to remove objects.</p><p>If you are unsure whether you have freed the terms properly, you
can use the following function to see the status of the fixed term
allocator:</p><pre><code class="">
long allocated, freed;

erl_eterm_statistics(&amp;allocated,&amp;freed);
printf("currently allocated blocks: %ld\n",allocated);
printf("length of freelist: %ld\n",freed);

/* really free the freelist */
erl_eterm_release();
    </code></pre><p>For more information, see the
<a href="erl_malloc">erl_malloc</a> module.</p><h4>Pattern Matching</h4><p>An Erlang pattern is a term that can contain unbound variables or
<strong>"do not care"</strong> symbols. Such a pattern can be matched
against a
term and, if the match is successful, any unbound variables in the
pattern will be bound as a side effect. The content of a bound
variable can then be retrieved:</p><pre><code class="">
ETERM *pattern;
pattern = erl_format("{madonna,Age,_}");    </code></pre><p>The <a href="./erl_format#erl_match">erl_format#erl_match</a> function
performs pattern matching. It takes a
pattern and a term and tries to match them. As a side effect any unbound
variables in the pattern will be bound. In the following example, a
pattern is created with a variable <strong>Age</strong>, which is included at two
positions in the tuple. The pattern match is performed as follows:</p><ul><li> <p><strong>erl_match</strong> binds the contents of <strong>Age</strong> to <strong>21</strong>
the first time it reaches the variable.</p> </li><li> <p>The second occurrence of <strong>Age</strong> causes a test for
equality between the terms, as <strong>Age</strong> is already bound to
<strong>21</strong>. As <strong>Age</strong> is bound to <strong>21</strong>, the equality test
succeeds and the match continues until the end of the pattern.</p> </li><li> <p>If the end of the pattern is reached, the match succeeds and you
can retrieve the contents of the variable.</p> </li></ul><pre><code class="">
ETERM *pattern,*term;
pattern = erl_format("{madonna,Age,Age}");
term    = erl_format("{madonna,21,21}");
if (erl_match(pattern, term)) {
  fprintf(stderr, "Yes, they matched: Age = ");
  ep = erl_var_content(pattern, "Age"); 
  erl_print_term(stderr, ep);
  fprintf(stderr,"\n");
  erl_free_term(ep);
}
erl_free_term(pattern);
erl_free_term(term);    </code></pre><p>For more information, see the
<a href="./erl_format#erl_match">erl_format#erl_match</a> function.</p><h4>Connecting to a Distributed Erlang Node</h4><p>To connect to a distributed Erlang node, you must first
initialize the connection routine with
<a href="./erl_connect#erl_connect_init">erl_connect#erl_connect_init</a>,
which stores information, such as the hostname, node name, and IP
address for later use:</p><pre><code class="">
int identification_number = 99;
int creation=1;
char *cookie="a secret cookie string"; /* An example */
erl_connect_init(identification_number, cookie, creation);    </code></pre><p>For more information, see the
<a href="erl_connect">erl_connect</a> module.</p><p>After initialization, you set up the connection to the Erlang node.
To specify the Erlang node you want to connect to, use
<strong>erl_connect()</strong>. The following example sets up the
connection and is to result in a valid socket file descriptor:</p><pre><code class="">
int sockfd;
char *nodename="xyz@chivas.du.etx.ericsson.se"; /* An example */
if ((sockfd = erl_connect(nodename)) &lt; 0)
  erl_err_quit("ERROR: erl_connect failed");    </code></pre><p><strong>erl_err_quit()</strong> prints the specified string and
terminates the program. For more information, see the
<a href="erl_error">erl_error</a> module.</p><h4>Using EPMD</h4><p><a href="./epmd">erts/epmd</a>
is the Erlang Port Mapper Daemon. Distributed
Erlang nodes register with <strong>epmd</strong> on the local host to
indicate to other nodes that they exist and can accept connections.
<strong>epmd</strong> maintains a register of
node and port number information, and when a node wishes to connect to
another node, it first contacts <strong>epmd</strong> to find the
correct port number to connect to.</p><p>When you use
<a href="erl_connect">erl_connect</a>
to connect to an Erlang node, a connection is first made to
<strong>epmd</strong> and, if the node is known, a
connection is then made to the Erlang node.</p><p>C nodes can also register themselves with <strong>epmd</strong>
if they want other
nodes in the system to be able to find and connect to them.</p><p>Before registering with <strong>epmd</strong>, you must first
create a listen socket and bind it to a port. Then:</p><pre><code class="">
int pub;

pub = erl_publish(port);    </code></pre><p><strong>pub</strong> is a file descriptor now connected to
<strong>epmd</strong>. <strong>epmd</strong>
monitors the other end of the connection. If it detects that the
connection has been closed, the node becomes unregistered. So, if you
explicitly close the descriptor or if your node fails, it becomes
unregistered from <strong>epmd</strong>.</p><p>Notice that on some systems (such as VxWorks), a failed node is
not detected by this mechanism, as the operating system does not
automatically close descriptors that were left open when the node
failed. If a node has failed in this way, <strong>epmd</strong>
prevents you from
registering a new node with the old name, as it thinks that the old
name is still in use. In this case, you must unregister the name
explicitly:</p><pre><code class="">
erl_unpublish(node);    </code></pre><p>This causes <strong>epmd</strong> to close the connection from the
far end. Notice
that if the name was in fact still in use by a node, the results of
this operation are unpredictable. Also, doing this does not cause the
local end of the connection to close, so resources can be consumed.</p><h4>Sending and Receiving Erlang Messages</h4><p>Use one of the following two functions to send messages:</p><ul><li><a href="./erl_connect#erl_send">erl_connect#erl_send</a></li><li><a href="./erl_connect#erl_reg_send">erl_connect#erl_reg_send</a></li></ul><p>As in Erlang, messages can be sent to a
pid or to a registered name. It is easier to send a
message to a registered name, as it avoids the problem of finding
a suitable pid.</p><p>Use one of the following two functions to receive messages:</p><ul><li><a href="./erl_connect#erl_receive">erl_connect#erl_receive</a></li><li><a href="./erl_connect#erl_receive_msg">erl_connect#erl_receive_msg</a></li></ul><p><strong>erl_receive()</strong> receives the message into a buffer,
while <strong>erl_receive_msg()</strong> decodes the message into an
Erlang term.</p><h4>Example of Sending Messages</h4><p>In the following example, <strong>{Pid, hello_world}</strong> is
sent to a registered process <strong>my_server</strong>. The message
is encoded by <strong>erl_send()</strong>:</p><pre><code class="">
extern const char *erl_thisnodename(void);
extern short erl_thiscreation(void);
#define SELF(fd) erl_mk_pid(erl_thisnodename(),fd,0,erl_thiscreation())
ETERM *arr[2], *emsg;
int sockfd, creation=1;
  
arr[0] = SELF(sockfd);
arr[1] = erl_mk_atom("Hello world");
emsg   = erl_mk_tuple(arr, 2);
  
erl_reg_send(sockfd, "my_server", emsg);
erl_free_term(emsg);      </code></pre><p>The first element of the tuple that is sent is your own
pid. This enables <strong>my_server</strong> to reply.
For more information about the primitives, see the
<a href="erl_connect">erl_connect</a> module.</p><h4>Example of Receiving Messages</h4><p>In this example, <strong>{Pid, Something}</strong> is received. The
received pid is then used to return
<strong>{goodbye,Pid}</strong>.</p><pre><code class="">
ETERM *arr[2], *answer;
int sockfd,rc;
char buf[BUFSIZE];
ErlMessage emsg;
  
if ((rc = erl_receive_msg(sockfd , buf, BUFSIZE, &amp;emsg)) == ERL_MSG) {
   arr[0] = erl_mk_atom("goodbye");
   arr[1] = erl_element(1, emsg.msg); 
   answer = erl_mk_tuple(arr, 2);
   erl_send(sockfd, arr[1], answer);
   erl_free_term(answer);
   erl_free_term(emsg.msg);
   erl_free_term(emsg.to);
}      </code></pre><p>To provide robustness, a distributed Erlang node
occasionally polls all its connected neighbors in an attempt to
detect failed nodes or communication links. A node that receives such
a message is expected to respond immediately with an
<strong>ERL_TICK</strong> message. This is done automatically by
<strong>erl_receive()</strong>. However, when this has occurred,
<strong>erl_receive</strong> returns <strong>ERL_TICK</strong> to
the caller without storing a message into the
<strong>ErlMessage</strong> structure.</p><p>When a message has been received, it is the caller's responsibility
to free the received message <strong>emsg.msg</strong> and
<strong>emsg.to</strong> or <strong>emsg.from</strong>,
depending on the type of message received.</p><p>For more information, see the
<a href="erl_connect">erl_connect</a> and
<a href="erl_eterm">erl_eterm</a> modules.</p><h4>Remote Procedure Calls</h4><p>An Erlang node acting as a client to another Erlang node
typically sends a request and waits for a reply. Such a request is
included in a function call at a remote node and is called a remote
procedure call.</p><p>The following example shows how the
<strong>Erl_Interface</strong> library supports remote procedure calls:</p><pre><code class="">
char modname[]=THE_MODNAME;
ETERM *reply,*ep;
ep = erl_format("[~a,[]]", modname);
if (!(reply = erl_rpc(fd, "c", "c", ep)))
  erl_err_msg("&lt;ERROR&gt; when compiling file: %s.erl !\n", modname);
erl_free_term(ep);
ep = erl_format("{ok,_}");
if (!erl_match(ep, reply))
  erl_err_msg("&lt;ERROR&gt; compiler errors !\n");
erl_free_term(ep);
erl_free_term(reply);    </code></pre><p><strong>c:c/1</strong> is called to compile the specified module on
the remote node. <strong>erl_match()</strong> checks that the
compilation was
successful by testing for the expected <strong>ok</strong>.</p><p>For more information about <strong>erl_rpc()</strong> and its
companions <strong>erl_rpc_to()</strong> and
<strong>erl_rpc_from()</strong>, see the
<a href="erl_connect">erl_connect</a> module.</p><h4>Using Global Names</h4><p>A C node has access to names registered through the
<a href="./global">kernel/global</a>
module in Kernel. Names can be looked up, allowing the C node to send messages
to named Erlang services. C nodes can also register global names,
allowing them to provide named services to Erlang processes or other C
nodes.</p><p><strong>Erl_Interface</strong> does not provide a native implementation of the
global service. Instead it uses the global services provided by a "nearby"
Erlang node. To use the services described in this section,
it is necessary to first open a connection to an Erlang node.</p><p>To see what names there are:</p><pre><code class="">
char **names;
int count;
int i;

names = erl_global_names(fd,&amp;count);

if (names) 
  for (i=0; i&lt;count; i++) 
    printf("%s\n",names[i]);

free(names);    </code></pre><p><a href="./erl_global#erl_global_names">erl_global#erl_global_names</a>
allocates and returns a buffer containing
all the names known to the <strong>global</strong> module in <strong>Kernel</strong>.
<strong>count</strong> is initialized to
indicate the number of names in the array. The array of strings in names
is terminated by a <strong>NULL</strong> pointer, so it is not necessary to use
<strong>count</strong> to determine when the last name is reached.</p><p>It is the caller's responsibility to free the array.
<strong>erl_global_names</strong> allocates the array and all the strings
using a single call to <strong>malloc()</strong>, so
<strong>free(names)</strong> is all that is necessary.</p><p>To look up one of the names:</p><pre><code class="">
ETERM *pid;
char node[256];

pid = erl_global_whereis(fd,"schedule",node);    </code></pre><p>If <strong>"schedule"</strong> is known to the
<strong>global</strong> module in <strong>Kernel</strong>, an Erlang pid is
returned that can be used to send messages to the schedule service.
Also, <strong>node</strong> is initialized to contain the name of
the node where the service is registered, so that you can make a
connection to it by simply passing the variable to
<a href="erl_connect">erl_connect</a>.</p><p>Before registering a name, you should already have registered your
port number with <strong>epmd</strong>. This is not strictly necessary,
but if you
neglect to do so, then other nodes wishing to communicate with your
service cannot find or connect to your process.</p><p>Create a pid that Erlang processes can use to communicate with your
service:</p><pre><code class="">
ETERM *pid;

pid = erl_mk_pid(thisnode,14,0,0);
erl_global_register(fd,servicename,pid);    </code></pre><p>After registering the name, use
<a href="./erl_connect#erl_accept">erl_connect#erl_accept</a>
to wait for incoming connections.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Remember to free <strong>pid</strong> later with
<a href="./erl_malloc#erl_free_term">erl_malloc#erl_free_term</a>.</p></div><p>To unregister a name:</p><pre><code class="">
erl_global_unregister(fd,servicename);    </code></pre><h4>Using the Registry</h4><p>This section describes the use of the registry, a simple mechanism
for storing key-value pairs in a C-node, as well as backing them up or
restoring them from an <strong>Mnesia</strong> table on an Erlang node. For more
detailed information about the individual API functions, see the
<a href="registry">registry</a> module.</p><p>Keys are strings, that is, <strong>NULL</strong>-terminated arrays of characters, and
values are arbitrary objects. Although integers and floating point numbers
are treated specially by the registry, you can store strings or binary
objects of any type as pointers.</p><p>To start, open a registry:</p><pre><code class="">
ei_reg *reg;

reg = ei_reg_open(45);    </code></pre><p>The number <strong>45</strong> in the example indicates the approximate number of
objects that you expect to store in the registry. Internally the
registry uses hash tables with collision chaining, so there is no
absolute upper limit on the number of objects that the registry can
contain, but if performance or memory usage is important, then you
are to choose a number accordingly. The registry can be resized later.</p><p>You can open as many registries as you like (if memory permits).</p><p>Objects are stored and retrieved through set and get functions.
The following example shows how to store integers, floats, strings,
and arbitrary binary objects:</p><pre><code class="">
struct bonk *b = malloc(sizeof(*b));
char *name = malloc(7);

ei_reg_setival(reg,"age",29); 
ei_reg_setfval(reg,"height",1.85);

strcpy(name,"Martin");
ei_reg_setsval(reg,"name",name); 

b-&gt;l = 42;
b-&gt;m = 12;
ei_reg_setpval(reg,"jox",b,sizeof(*b));    </code></pre><p>If you try to store an object in the registry and there is an
existing object with the same key, the new value replaces the old
one. This is done regardless of whether the new object and the old one
have the same type, so you can, for example, replace a string with an
integer. If the existing value is a string or binary, it is freed
before the new value is assigned.</p><p>Stored values are retrieved from the registry as follows:</p><pre><code class="">
long i;
double f;
char *s;
struct bonk *b;
int size;

i = ei_reg_getival(reg,"age");
f = ei_reg_getfval(reg,"height");
s = ei_reg_getsval(reg,"name");
b = ei_reg_getpval(reg,"jox",&amp;size);    </code></pre><p>In all the above examples, the object must exist and it must be of
the right type for the specified operation. If you do not know the
type of an object, you can ask:</p><pre><code class="">
struct ei_reg_stat buf;

ei_reg_stat(reg,"name",&amp;buf);    </code></pre><p>Buf is initialized to contain object attributes.</p><p>Objects can be removed from the registry:</p><pre><code class="">
ei_reg_delete(reg,"name");    </code></pre><p>When you are finished with a registry, close it to remove all the
objects and free the memory back to the system:</p><pre><code class="">
ei_reg_close(reg);    </code></pre><h4>Backing Up the Registry to Mnesia</h4><p>The contents of a registry can be backed up to
<a href="./mnesia">mnesia/mnesia</a> on a "nearby" Erlang
node. You must provide an open connection to the Erlang node
(see <a href="erl_connect">erl_connect</a>).
Also, <strong>Mnesia</strong> 3.0 or later must be running
on the Erlang node before the backup is initiated:</p><pre><code class="">
ei_reg_dump(fd, reg, "mtab", dumpflags);      </code></pre><p>This example back up the contents of the registry to the
specified <strong>Mnesia</strong> table <strong>"mtab"</strong>.
Once a registry has been backed
up to <strong>Mnesia</strong> like this, more backups only affect
objects that have been modified since the most recent backup, that is,
objects that have been created, changed, or deleted. The backup
operation is done as a single atomic transaction, so that either the
entire backup is performed or none of it.</p><p>Likewise, a registry can be restored from a <strong>Mnesia</strong> table:</p><pre><code class="">
ei_reg_restore(fd, reg, "mtab");      </code></pre><p>This reads the entire contents of <strong>"mtab"</strong> into the
specified registry. After the restore, all the objects in the registry
are marked as unmodified, so a later backup only affects
objects that you have modified since the restore.</p><p>Notice that if you restore to a non-empty registry, objects in the
table overwrite objects in the registry with the same keys. Also,
the <em>entire</em> contents of the registry is marked as unmodified
after the restore, including any modified objects that were not
overwritten by the restore operation. This may not be your
intention.</p><h4>Storing Strings and Binaries</h4><p>When string or binary objects are stored in the registry it is
important that some simple guidelines are followed.</p><p>Most importantly, the object must have been created with a single call
to <strong>malloc()</strong> (or similar), so that it can later be
removed by a single call to <strong>free()</strong>.
Objects are freed by the registry
when it is closed, or when you assign a new value to an object that
previously contained a string or binary.</p><p>Notice that if you store binary objects that are context-dependent
(for example, containing pointers or open file descriptors),
they lose their meaning if they are backed up to a <strong>Mnesia</strong> table
and later restored in a different context.</p><p>When you retrieve a stored string or binary value from the registry,
the registry maintains a pointer to the object and you are passed a
copy of that pointer. You should never free an object retrieved in
this manner because when the registry later attempts to free it, a
runtime error occurs that likely causes the C-node to crash.</p><p>You are free to modify the contents of an object retrieved this way.
However, when you do so, the registry is not aware of your changes,
possibly causing it to be missed the next time you make an
<strong>Mnesia</strong> backup of the registry contents. This can be avoided if
you mark the object as dirty after any such changes with
<a href="./registry#ei_reg_markdirty">registry#ei_reg_markdirty</a>, or pass appropriate flags to
<a href="./registry#ei_reg_dump">registry#ei_reg_dump</a>.</p><h3>ei</h3><p>Routines for handling the Erlang binary term format.</p><p>The library <strong>ei</strong> contains macros and functions to encode
and decode the Erlang binary term format.<strong>ei</strong> allows you to convert atoms, lists, numbers, and
binaries to and from the binary format. This is useful when
writing port programs and drivers. <strong>ei</strong> uses a given
buffer, no dynamic memory (except
<strong>ei_decode_fun()</strong>) and is often quite fast.<strong>ei</strong> also handles C-nodes, C-programs that talks Erlang
distribution with Erlang nodes (or other C-nodes) using the
Erlang distribution format. The difference between <strong>ei</strong>
and <strong>erl_interface</strong> is that <strong>ei</strong> uses
the binary format directly when sending and receiving terms. It is also
thread safe, and using threads, one process can handle multiple
C-nodes. The <strong>erl_interface</strong> library is built on top of
<strong>ei</strong>, but of legacy reasons, it does not allow for
multiple C-nodes. In general, <strong>ei</strong> is the preferred way
of doing C-nodes.The decode and encode functions use a buffer and an index into the
buffer, which points at the point where to encode and
decode. The index is updated to point right after the term
encoded/decoded. No checking is done whether the term fits in
the buffer or not. If encoding goes outside the buffer, the
program can crash.All functions take two parameters:<ul><li><p><strong>buf</strong> is a pointer to
the buffer where the binary data is or will be.</p> </li><li><p><strong>index</strong> is a pointer to an index into the
buffer. This parameter is incremented with the size of the term
decoded/encoded.</p> </li></ul>The data is thus at <strong>buf[*index]</strong> when an
<strong>ei</strong> function is called.All encode functions assume that the <strong>buf</strong> and
<strong>index</strong> parameters point to a buffer large enough for
the data. To get the size of an encoded term, without encoding it,
pass <strong>NULL</strong> instead of a buffer pointer. Parameter
<strong>index</strong> is incremented, but nothing will be encoded. This
is the way in <strong>ei</strong> to "preflight" term encoding.There are also encode functions that use a dynamic buffer. It
is often more convenient to use these to encode data. All encode
functions comes in two versions; those starting with
<strong>ei_x</strong> use a dynamic buffer.All functions return <strong>0</strong> if successful, otherwise
<strong>-1</strong> (for example, if a term is not of the expected
type, or the data to decode is an invalid Erlang term).Some of the decode functions need a pre-allocated buffer. This
buffer must be allocated large enough, and for non-compound types
the <strong>ei_get_type()</strong>
function returns the size required (notice that for strings an
extra byte is needed for the <strong>NULL</strong>-terminator).</p><h4>Data Types</h4><dl><dt><a name="erlang_char_encoding"></a>erlang_char_encoding</dt><dd> <pre><code class="">
typedef enum {
    ERLANG_ASCII = 1,
    ERLANG_LATIN1 = 2,
    ERLANG_UTF8 = 4
} erlang_char_encoding;</code></pre> <p>The character encodings used for atoms. <strong>ERLANG_ASCII</strong>
represents 7-bit ASCII. Latin-1 and UTF-8 are different extensions
of 7-bit ASCII. All 7-bit ASCII characters are valid Latin-1 and
UTF-8 characters. ASCII and Latin-1 both represent each character
by one byte. An UTF-8 character can consist of 1-4 bytes.
Notice that these constants are bit-flags and can be combined with
bitwise OR.</p> </dd></dl><h3>Functions</h3><h4>ei_decode_atom(const char *buf, int *index, char *p):int</h4><p>Decode an atom.</p><p>Decodes an atom from the binary format. The <strong>NULL</strong>-terminated
name of the atom is placed at <strong>p</strong>. At most
<strong>MAXATOMLEN</strong> bytes can be placed in the buffer.</p><h4>ei_decode_atom_as(const char *buf, int *index, char *p, int plen, erlang_char_encoding want, erlang_char_encoding* was, erlang_char_encoding* result):int</h4><p>Decode an atom.</p><p>Decodes an atom from the binary format. The <strong>NULL</strong>-terminated
name of the atom is placed in buffer at <strong>p</strong> of length <strong>plen</strong>
bytes.</p><p>The wanted string encoding is specified by
<a href="#erlang_char_encoding">erlang_char_encoding</a>.
The original encoding used in the binary format (Latin-1 or UTF-8) can
be obtained from <strong>*was</strong>. The encoding of the resulting string
(7-bit ASCII, Latin-1, or UTF-8) can be obtained from <strong>*result</strong>.
Both <strong>was</strong> and <strong>result</strong> can be <strong>NULL</strong>. <strong>*result</strong>
can differ from <strong>want</strong> if <strong>want</strong> is a bitwise OR'd
combination like <strong>ERLANG_LATIN1|ERLANG_UTF8</strong> or if
<strong>*result</strong> turns out to be pure 7-bit ASCII
(compatible with both Latin-1 and UTF-8).</p><p>This function fails if the atom is too long for the buffer
or if it cannot be represented with encoding <strong>want</strong>.</p><p>This function was introduced in Erlang/OTP R16 as part of a first
step to support UTF-8 atoms.</p><h4>ei_decode_bignum(const char *buf, int *index, mpz_t obj):int</h4><p>Decode a GMP arbitrary precision integer.</p><p>Decodes an integer in the binary format to a GMP
<strong>mpz_t</strong> integer. To use this function, the <strong>ei</strong>
library must be configured and compiled to use the GMP library.</p><h4>ei_decode_binary(const char *buf, int *index, void *p, long *len):int</h4><p>Decode a binary.</p><p>Decodes a binary from the binary format. Parameter
<strong>len</strong> is set to the actual size of the
binary. Notice that <strong>ei_decode_binary()</strong> assumes that
there is enough room for the binary. The size required can be
fetched by <strong>ei_get_type()</strong>.</p><h4>ei_decode_bitstring(const char *buf, int *index, const char **pp, unsigned int *bitoffsp, size_t *nbitsp):int</h4><p>Decode a bitstring.</p><p>Decodes a bit string from the binary format.</p><dl><dt><strong>pp</strong></dt><dd><p>Either <strong>NULL</strong> or <strong>*pp</strong> returns a pointer to
the first byte of the bit string. The returned bit string is
readable as long as the buffer pointed to by <strong>buf</strong> is
readable and not written to.</p> </dd><dt><strong>bitoffsp</strong></dt><dd><p>Either <strong>NULL</strong> or <strong>*bitoffsp</strong> returns the
number of unused bits in the first byte pointed to by
<strong>*pp</strong>. The value of <strong>*bitoffsp</strong> is between 0 and 7.
Unused bits in the first byte are the most significant bits.</p> </dd><dt><strong>nbitsp</strong></dt><dd><p>Either <strong>NULL</strong> or <strong>*nbitsp</strong> returns the length
of the bit string in <em>bits</em>.</p> </dd></dl><p>Returns <strong>0</strong> if it was a bit string term.</p><p>The number of <em>bytes</em> pointed to by <strong>*pp</strong>, which are
part of the bit string, is <strong>(*bitoffsp + *nbitsp + 7)/8</strong>. If
<strong>(*bitoffsp + *bitsp)%8 &gt; 0</strong> then only <strong>(*bitoffsp + *bitsp)%8</strong> bits of the last byte are used. Unused bits in
the last byte are the least significant bits.</p><p>The values of unused bits in the first and last byte are undefined
and cannot be relied on.</p><p>Number of bits may be divisible by 8, which means a binary
decodable by <strong>ei_decode_binary</strong> is also decodable by
<strong>ei_decode_bitstring</strong>.</p><h4>ei_decode_boolean(const char *buf, int *index, int *p):int</h4><p>Decode a boolean.</p><p>Decodes a boolean value from the binary format.
A boolean is actually an atom, <strong>true</strong> decodes 1
and <strong>false</strong> decodes 0.</p><h4>ei_decode_char(const char *buf, int *index, char *p):int</h4><p>Decode an 8-bit integer between 0-255.</p><p>Decodes a char (8-bit) integer between 0-255 from the binary format.
For historical reasons the returned integer is of
type <strong>char</strong>. Your C code is to  consider the
returned value to be of type <strong>unsigned char</strong> even if
the C compilers and system can define <strong>char</strong> to be
signed.</p><h4>ei_decode_double(const char *buf, int *index, double *p):int</h4><p>Decode a double.</p><p>Decodes a double-precision (64-bit) floating
point number from the binary format.</p><h4>ei_decode_ei_term(const char* buf, int* index, ei_term* term):int</h4><p>Decode a term, without previous knowledge of type.</p><p>Decodes any term, or at least tries to. If the term
pointed at by <strong>*index</strong> in <strong>buf</strong> fits
in the <strong>term</strong> union, it is decoded, and the
appropriate field in <strong>term-&gt;value</strong> is set, and
<strong>*index</strong> is incremented by the term size.</p><p>The function returns <strong>1</strong> on successful decoding, <strong>-1</strong> on
error, and <strong>0</strong> if the term seems alright, but does not fit in the
<strong>term</strong> structure. If <strong>1</strong> is returned, the
<strong>index</strong> is incremented, and <strong>term</strong>
contains the decoded term.</p><p>The <strong>term</strong> structure contains the arity for a tuple
or list, size for a binary, string, or atom. It contains
a term if it is any of the following: integer, float, atom,
pid, port, or ref.</p><h4>ei_decode_fun(const char *buf, int *index, erlang_fun *p):int</h4><h4>free_fun(erlang_fun* f):void</h4><p>Decode a fun.</p><p>Decodes a fun from the binary format. Parameter
<strong>p</strong> is to be <strong>NULL</strong> or point to an
<strong>erlang_fun</strong> structure. This is the only decode
function that allocates memory. When the <strong>erlang_fun</strong>
is no longer needed, it is to be freed with
<strong>free_fun</strong>. (This has to do with the arbitrary size
of the environment for a fun.)</p><h4>ei_decode_list_header(const char *buf, int *index, int *arity):int</h4><p>Decode a list.</p><p>Decodes a list header from the binary
format. The number of elements is returned in
<strong>arity</strong>. The <strong>arity+1</strong> elements
follow (the last one is the tail of the list, normally an empty list).
If <strong>arity</strong> is <strong>0</strong>, it is an empty
list.</p><p>Notice that lists are encoded as strings if they consist
entirely of integers in the range 0..255. This function do
not decode such strings, use <strong>ei_decode_string()</strong>
instead.</p><h4>ei_decode_long(const char *buf, int *index, long *p):int</h4><p>Decode integer.</p><p>Decodes a long integer from the binary format.
If the code is 64 bits, the function <strong>ei_decode_long()</strong> is
the same as <strong>ei_decode_longlong()</strong>.</p><h4>ei_decode_longlong(const char *buf, int *index, long long *p):int</h4><p>Decode integer.</p><p>Decodes a GCC <strong>long long</strong> or Visual C++
<strong>__int64</strong>
(64-bit) integer from the binary format. This
function is missing in the VxWorks port.</p><h4>ei_decode_map_header(const char *buf, int *index, int *arity):int</h4><p>Decode a map.</p><p>Decodes a map header from the binary
format. The number of key-value pairs is returned in
<strong>*arity</strong>. Keys and values follow in this order:
<strong>K1, V1, K2, V2, ..., Kn, Vn</strong>. This makes a total of
<strong>arity*2</strong> terms. If <strong>arity</strong> is zero, it is an empty map.
A correctly encoded map does not have duplicate keys.</p><h4>ei_decode_pid(const char *buf, int *index, erlang_pid *p):int</h4><p>Decode a <strong>pid</strong>.</p><p>Decodes a process identifier (pid) from the binary format.</p><h4>ei_decode_port(const char *buf, int *index, erlang_port *p):int</h4><p>Decode a port.</p><p>Decodes a port identifier from the binary format.</p><h4>ei_decode_ref(const char *buf, int *index, erlang_ref *p):int</h4><p>Decode a reference.</p><p>Decodes a reference from the binary format.</p><h4>ei_decode_string(const char *buf, int *index, char *p):int</h4><p>Decode a string.</p><p>Decodes a string from the binary format. A
string in Erlang is a list of integers between 0 and
255. Notice that as the string is just a list, sometimes
lists are encoded as strings by <strong>term_to_binary/1</strong>,
even if it was not intended.</p><p>The string is copied to <strong>p</strong>, and enough space must
be allocated. The returned string is <strong>NULL</strong>-terminated, so you
must add an extra byte to the memory requirement.</p><h4>ei_decode_term(const char *buf, int *index, void *t):int</h4><p>Decode a <strong>ETERM</strong>.</p><p>Decodes a term from the binary format. The term
is return in <strong>t</strong> as a <strong>ETERM*</strong>, so
<strong>t</strong> is actually an <strong>ETERM**</strong> (see
<a href="erl_eterm">erl_eterm</a>).
The term is later to be deallocated.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is deprecated as of OTP 22 and will be removed in
OTP 23 together with the old legacy <strong>erl_interface</strong> library (functions
with prefix <strong>erl_</strong>).</p></div><h4>ei_decode_trace(const char *buf, int *index, erlang_trace *p):int</h4><p>Decode a trace token.</p><p>Decodes an Erlang trace token from the binary format.</p><h4>ei_decode_tuple_header(const char *buf, int *index, int *arity):int</h4><p>Decode a tuple.</p><p>Decodes a tuple header, the number of elements
is returned in <strong>arity</strong>. The tuple elements follow
in order in the buffer.</p><h4>ei_decode_ulong(const char *buf, int *index, unsigned long *p):int</h4><p>Decode unsigned integer.</p><p>Decodes an unsigned long integer from the binary format.
If the code is 64 bits, the function <strong>ei_decode_ulong()</strong> is
the same as <strong>ei_decode_ulonglong()</strong>.</p><h4>ei_decode_ulonglong(const char *buf, int *index, unsigned long long *p):int</h4><p>Decode unsigned integer.</p><p>Decodes a GCC <strong>unsigned long long</strong> or Visual C++
<strong>unsigned __int64</strong> (64-bit) integer from the binary
format. This function is missing in the VxWorks port.</p><h4>ei_decode_version(const char *buf, int *index, int *version):int</h4><p>Decode an empty list (<strong>nil</strong>).</p><p>Decodes the version magic number for the
Erlang binary term format. It must be the first token in a
binary term.</p><h4>ei_encode_atom(char *buf, int *index, const char *p):int</h4><h4>ei_encode_atom_len(char *buf, int *index, const char *p, int len):int</h4><h4>ei_x_encode_atom(ei_x_buff* x, const char *p):int</h4><h4>ei_x_encode_atom_len(ei_x_buff* x, const char *p, int len):int</h4><p>Encode an atom.</p><p>Encodes an atom in the binary format. Parameter <strong>p</strong>
is the name of the atom in Latin-1 encoding. Only up to
<strong>MAXATOMLEN-1</strong> bytes
are encoded. The name is to be <strong>NULL</strong>-terminated, except for
the <strong>ei_x_encode_atom_len()</strong> function.</p><h4>ei_encode_atom_as(char *buf, int *index, const char *p, erlang_char_encoding from_enc, erlang_char_encoding to_enc):int</h4><h4>ei_encode_atom_len_as(char *buf, int *index, const char *p, int len, erlang_char_encoding from_enc, erlang_char_encoding to_enc):int</h4><h4>ei_x_encode_atom_as(ei_x_buff* x, const char *p, erlang_char_encoding from_enc, erlang_char_encoding to_enc):int</h4><h4>ei_x_encode_atom_len_as(ei_x_buff* x, const char *p, int len, erlang_char_encoding from_enc, erlang_char_encoding to_enc):int</h4><p>Encode an atom.</p><p>Encodes an atom in the binary format. Parameter <strong>p</strong> is the name of the atom with
character encoding
<a href="#erlang_char_encoding">erlang_char_encoding</a>
(ASCII, Latin-1, or UTF-8). The name must either be <strong>NULL</strong>-terminated or
a function variant with a <strong>len</strong> parameter must be used.</p><p>The encoding fails if <strong>p</strong> is not a valid string in encoding
<strong>from_enc</strong>.</p><p>Argument <strong>to_enc</strong> is ignored. As from Erlang/OTP 20 the encoding is always
done in UTF-8 which is readable by nodes as old as Erlang/OTP R16.</p><h4>ei_encode_bignum(char *buf, int *index, mpz_t obj):int</h4><h4>ei_x_encode_bignum(ei_x_buff *x, mpz_t obj):int</h4><p>Encode an arbitrary precision integer.</p><p>Encodes a GMP <strong>mpz_t</strong> integer to binary format.
To use this function, the <strong>ei</strong> library must be configured and
compiled to use the GMP library.</p><h4>ei_encode_binary(char *buf, int *index, const void *p, long len):int</h4><h4>ei_x_encode_binary(ei_x_buff* x, const void *p, long len):int</h4><p>Encode a binary.</p><p>Encodes a binary in the binary format. The data is at
<strong>p</strong>, of <strong>len</strong> bytes length.</p><h4>ei_encode_bitstring(char *buf, int *index, const char *p, size_t bitoffs, size_t nbits):int</h4><h4>ei_x_encode_bitstring(ei_x_buff* x, const char *p, size_t bitoffs, size_t nbits):int</h4><p>Encode a bitstring.</p><p>Encodes a bit string in the binary format.</p><p>The data is at <strong>p</strong>. The length of the bit string is <strong>nbits</strong>
bits. The first <strong>bitoffs</strong> bits of the data at <strong>p</strong> are unused.
The first byte which is part of the bit string is
<strong>p[bitoffs/8]</strong>. The <strong>bitoffs%8</strong> most significant bits of
the first byte <strong>p[bitoffs/8]</strong> are unused.</p><p>The number of bytes which is part of the bit string is <strong>(bitoffs + nbits + 7)/8</strong>. If <strong>(bitoffs + nbits)%8 &gt; 0</strong> then only <strong>(bitoffs + nbits)%8</strong> bits of the last byte are used. Unused bits in
the last byte are the least significant bits.</p><p>The values of unused bits are disregarded and does not need to be
cleared.</p><h4>ei_encode_boolean(char *buf, int *index, int p):int</h4><h4>ei_x_encode_boolean(ei_x_buff* x, int p):int</h4><p>Encode a boolean.</p><p>Encodes a boolean value as the atom <strong>true</strong> if
<strong>p</strong> is not zero, or <strong>false</strong> if <strong>p</strong> is
zero.</p><h4>ei_encode_char(char *buf, int *index, char p):int</h4><h4>ei_x_encode_char(ei_x_buff* x, char p):int</h4><p>Encode an 8-bit integer between 0-255.</p><p>Encodes a char (8-bit) as an integer between 0-255 in the binary
format. For historical reasons the integer argument is of
type <strong>char</strong>. Your C code is to consider the specified
argument to be of type <strong>unsigned char</strong> even if
the C compilers and system may define <strong>char</strong> to be
signed.</p><h4>ei_encode_double(char *buf, int *index, double p):int</h4><h4>ei_x_encode_double(ei_x_buff* x, double p):int</h4><p>Encode a double float.</p><p>Encodes a double-precision (64-bit) floating point number in
the binary format.</p><p>Returns <strong>-1</strong> if the floating point
number is not finite.</p><h4>ei_encode_empty_list(char* buf, int* index):int</h4><h4>ei_x_encode_empty_list(ei_x_buff* x):int</h4><p>Encode an empty list (<strong>nil</strong>).</p><p>Encodes an empty list. It is often used at the tail of a list.</p><h4>ei_encode_fun(char *buf, int *index, const erlang_fun *p):int</h4><h4>ei_x_encode_fun(ei_x_buff* x, const erlang_fun* fun):int</h4><p>Encode a fun.</p><p>Encodes a fun in the binary format. Parameter <strong>p</strong>
points to an <strong>erlang_fun</strong> structure. The
<strong>erlang_fun</strong> is not freed automatically, the
<strong>free_fun</strong> is to be called if the fun is not needed
after encoding.</p><h4>ei_encode_list_header(char *buf, int *index, int arity):int</h4><h4>ei_x_encode_list_header(ei_x_buff* x, int arity):int</h4><p>Encode a list.</p><p>Encodes a list header, with a specified
arity. The next <strong>arity+1</strong> terms are the elements
(actually its <strong>arity</strong> cons cells) and the tail of the
list. Lists and tuples are encoded recursively, so that a
list can contain another list or tuple.</p><p>For example, to encode the list
<strong>[c, d, [e | f]]</strong>:</p><pre>
ei_encode_list_header(buf, &amp;i, 3);
ei_encode_atom(buf, &amp;i, "c");
ei_encode_atom(buf, &amp;i, "d");
ei_encode_list_header(buf, &amp;i, 1);
ei_encode_atom(buf, &amp;i, "e");
ei_encode_atom(buf, &amp;i, "f");
ei_encode_empty_list(buf, &amp;i);</pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>It may seem that there is no way to create a list without
knowing the number of elements in advance. But indeed
there is a way. Notice that the list <strong>[a, b, c]</strong>
can be written as <strong>[a | [b | [c]]]</strong>.
Using this, a list can be written as conses.</p></div><p>To encode a list, without knowing the arity in advance:</p><pre>
while (something()) {
    ei_x_encode_list_header(&amp;x, 1);
    ei_x_encode_ulong(&amp;x, i); /* just an example */
}
ei_x_encode_empty_list(&amp;x);</pre><h4>ei_encode_long(char *buf, int *index, long p):int</h4><h4>ei_x_encode_long(ei_x_buff* x, long p):int</h4><p>Encode integer.</p><p>Encodes a long integer in the binary format.
If the code is 64 bits, the function <strong>ei_encode_long()</strong> is
the same as <strong>ei_encode_longlong()</strong>.</p><h4>ei_encode_longlong(char *buf, int *index, long long p):int</h4><h4>ei_x_encode_longlong(ei_x_buff* x, long long p):int</h4><p>Encode integer.</p><p>Encodes a GCC <strong>long long</strong> or Visual C++
<strong>__int64</strong> (64-bit) integer in the binary format.
This function is missing in the VxWorks port.</p><h4>ei_encode_map_header(char *buf, int *index, int arity):int</h4><h4>ei_x_encode_map_header(ei_x_buff* x, int arity):int</h4><p>Encode a map.</p><p>Encodes a map header, with a specified arity. The next
<strong>arity*2</strong> terms encoded will be the keys and values of the map
encoded in the following order: <strong>K1, V1, K2, V2, ..., Kn, Vn</strong>.
</p><p>For example, to encode the map <strong>#{a =&gt; "Apple", b =&gt; "Banana"}</strong>:</p><pre>
ei_x_encode_map_header(&amp;x, 2);
ei_x_encode_atom(&amp;x, "a");
ei_x_encode_string(&amp;x, "Apple");
ei_x_encode_atom(&amp;x, "b");
ei_x_encode_string(&amp;x, "Banana");</pre><p>A correctly encoded map cannot have duplicate keys.</p><h4>ei_encode_pid(char *buf, int *index, const erlang_pid *p):int</h4><h4>ei_x_encode_pid(ei_x_buff* x, const erlang_pid *p):int</h4><p>Encode a pid.</p><p>Encodes an Erlang process identifier (pid) in the binary
format. Parameter <strong>p</strong> points to an
<strong>erlang_pid</strong> structure (which should have been
obtained earlier with <strong>ei_decode_pid()</strong>).</p><h4>ei_encode_port(char *buf, int *index, const erlang_port *p):int</h4><h4>ei_x_encode_port(ei_x_buff* x, const erlang_port *p):int</h4><p>Encode a port.</p><p>Encodes an Erlang port in the binary format. Parameter
<strong>p</strong> points to a <strong>erlang_port</strong>
structure (which should have been obtained earlier with
<strong>ei_decode_port()</strong>).</p><h4>ei_encode_ref(char *buf, int *index, const erlang_ref *p):int</h4><h4>ei_x_encode_ref(ei_x_buff* x, const erlang_ref *p):int</h4><p>Encode a ref.</p><p>Encodes an Erlang reference in the binary format. Parameter
<strong>p</strong> points to a <strong>erlang_ref</strong>
structure (which should have been obtained earlier with
<strong>ei_decode_ref()</strong>).</p><h4>ei_encode_string(char *buf, int *index, const char *p):int</h4><h4>ei_encode_string_len(char *buf, int *index, const char *p, int len):int</h4><h4>ei_x_encode_string(ei_x_buff* x, const char *p):int</h4><h4>ei_x_encode_string_len(ei_x_buff* x, const char* s, int len):int</h4><p>Encode a string.</p><p>Encodes a string in the binary format. (A string in Erlang
is a list, but is encoded as a character array in the binary
format.) The string is to be <strong>NULL</strong>-terminated, except for
the <strong>ei_x_encode_string_len()</strong> function.</p><h4>ei_encode_term(char *buf, int *index, void *t):int</h4><h4>ei_x_encode_term(ei_x_buff* x, void *t):int</h4><p>Encode an <strong>erl_interface</strong> term.</p><p>Encodes an <strong>ETERM</strong>, as obtained from
<strong>erl_interface</strong>. Parameter <strong>t</strong> is
actually an <strong>ETERM</strong> pointer. This function
does not free the <strong>ETERM</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>These functions are deprecated as of OTP 22 and will be removed in
OTP 23 together with the old legacy <strong>erl_interface</strong> library
(functions with prefix <strong>erl_</strong>).</p></div><h4>ei_encode_trace(char *buf, int *index, const erlang_trace *p):int</h4><h4>ei_x_encode_trace(ei_x_buff* x, const erlang_trace *p):int</h4><p>Encode a trace token.</p><p>Encodes an Erlang trace token in the binary format.
Parameter <strong>p</strong> points to a
<strong>erlang_trace</strong> structure (which should have been
obtained earlier with <strong>ei_decode_trace()</strong>).</p><h4>ei_encode_tuple_header(char *buf, int *index, int arity):int</h4><h4>ei_x_encode_tuple_header(ei_x_buff* x, int arity):int</h4><p>Encode a tuple.</p><p>Encodes a tuple header, with a specified
arity. The next <strong>arity</strong> terms encoded will be the
elements of the tuple. Tuples and lists are encoded
recursively, so that a tuple can contain another tuple or list.</p><p>For example, to encode the tuple <strong>{a, {b, {}}}</strong>:</p><pre>
ei_encode_tuple_header(buf, &amp;i, 2);
ei_encode_atom(buf, &amp;i, "a");
ei_encode_tuple_header(buf, &amp;i, 2);
ei_encode_atom(buf, &amp;i, "b");
ei_encode_tuple_header(buf, &amp;i, 0);</pre><h4>ei_encode_ulong(char *buf, int *index, unsigned long p):int</h4><h4>ei_x_encode_ulong(ei_x_buff* x, unsigned long p):int</h4><p>Encode unsigned integer.</p><p>Encodes an unsigned long integer in the binary format.
If the code is 64 bits, the function <strong>ei_encode_ulong()</strong> is
the same as <strong>ei_encode_ulonglong()</strong>.</p><h4>ei_encode_ulonglong(char *buf, int *index, unsigned long long p):int</h4><h4>ei_x_encode_ulonglong(ei_x_buff* x, unsigned long long p):int</h4><p>Encode unsigned integer.</p><p>Encodes a GCC <strong>unsigned long long</strong> or Visual C++
<strong>unsigned __int64</strong> (64-bit) integer in the binary
format. This function is missing in the VxWorks port.</p><h4>ei_encode_version(char *buf, int *index):int</h4><h4>ei_x_encode_version(ei_x_buff* x):int</h4><p>Encode version.</p><p>Encodes a version magic number for the binary format. Must
be the first token in a binary term.</p><h4>ei_get_type(const char *buf, const int *index, int *type, int *size):int</h4><p>Fetch the type and size of an encoded term.</p><p>Returns the type in <strong>*type</strong> and size in
<strong>*size</strong> of the encoded term. For strings and atoms,
size is the number of characters <em>not</em> including the
terminating <strong>NULL</strong>. For binaries and bitstrings, <strong>*size</strong> is
the number of bytes. For lists, tuples and maps, <strong>*size</strong> is the
arity of the object. For other types, <strong>*size</strong> is 0. In all
cases, <strong>index</strong> is left unchanged.</p><h4>ei_init(void):int</h4><p>Initialize the ei library.</p><p>Initialize the <strong>ei</strong> library. This function should be called once
(and only once) before calling any other functionality in the <strong>ei</strong>
library. However, note the exception below.</p><p>If the <strong>ei</strong> library is used together with the <strong>erl_interface</strong>
library, this function should <em>not</em> be called directly. It will be
called by the <strong>erl_init()</strong> function which should be used to initialize
the combination of the two libraries instead.</p><p>On success zero is returned. On failure a posix error code is returned.</p><h4>ei_print_term(FILE* fp, const char* buf, int* index):int</h4><h4>ei_s_print_term(char** s, const char* buf, int* index):int</h4><p>Print a term in clear text.</p><p>Prints a term, in clear text, to the file
specified by <strong>fp</strong>, or the buffer pointed to by
<strong>s</strong>. It
tries to resemble the term printing in the Erlang shell.</p><p>In <strong>ei_s_print_term()</strong>, parameter
<strong>s</strong> is to
point to a dynamically (malloc) allocated string of
<strong>BUFSIZ</strong> bytes or a <strong>NULL</strong> pointer. The string
can be reallocated (and <strong>*s</strong> can be updated) by this
function if the result is more than <strong>BUFSIZ</strong>
characters. The string returned is <strong>NULL</strong>-terminated.</p><p>The return value is the number of characters written to the file
or string, or <strong>-1</strong> if <strong>buf[index]</strong> does not
contain a valid term.
Unfortunately, I/O errors on <strong>fp</strong> is not checked.</p><p>Argument <strong>index</strong> is updated, that is, this function
can be viewed as a decode function that decodes a term into a
human-readable format.</p><h4>ei_set_compat_rel(release_number):void</h4><p>Set the ei library in compatibility mode.</p><ul><li><span class="v">unsigned release_number;</span></li></ul><a name="ei_set_compat_rel"></a><p>In general, the <strong>ei</strong> library is guaranteed
to be compatible with other Erlang/OTP components that are 2 major
releases older or newer than the <strong>ei</strong> library itself.</p><p>Sometimes an exception to the above rule has to be made to make new
features (or even bug fixes) possible. A call to
<strong>ei_set_compat_rel(release_number)</strong> sets
the <strong>ei</strong> library in compatibility mode of OTP release
<strong>release_number</strong>.</p><p>The only useful value for <strong>release_number</strong> is currently
<strong>21</strong>. This will only be useful and have an effect if <em>bit strings</em> or <em>export funs</em> are received from a connected
node. Before OTP 22, bit strings and export funs were not supported by
<strong>ei</strong>. They were instead encoded using an undocumented fallback
tuple format when sent from the emulator to <strong>ei</strong>:</p><dl><dt><strong>Bit string</strong></dt><dd><p>The term <strong>&lt;&lt;42, 1:1&gt;&gt;</strong> was encoded as
<strong>{&lt;&lt;42, 128&gt;&gt;, 1}</strong>. The first element of the tuple is a
binary and the second element denotes how many bits of the last bytes
are part of the bit string. In this example only the most significant
bit of the last byte (128) is part of the bit string.</p> </dd><dt><strong>Export fun</strong></dt><dd><p>The term <strong>fun lists:map/2</strong> was encoded as
<strong>{lists,map}</strong>. A tuple with the module, function and a missing
arity.</p> </dd></dl><p>If <strong>ei_set_compat_rel(21)</strong> is <em>not</em> called then a connected
emulator will send bit strings and export funs correctly encoded. The
functions <a href="#ei_decode_bitstring">ei_decode_bitstring</a>
and <a href="#ei_decode_fun">ei_decode_fun</a>
has to be used to decode such terms. Calling
<strong>ei_set_compat_rel(21)</strong> should only be done as a workaround to
keep an old implementation alive, which expects to receive the
undocumented tuple formats for bit strings and/or export funs.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If this function is called, it can only be called once
and must be called before any other functions in the
<strong>ei</strong> library are called.</p></div><h4>ei_skip_term(const char* buf, int* index):int</h4><p>Skip a term.</p><p>Skips a term in the specified buffer;
recursively skips elements of lists and tuples, so that a
full term is skipped. This is a way to get the size of an
Erlang term.</p><p><strong>buf</strong> is the buffer.</p><p><strong>index</strong> is updated to point right after the term
in the buffer.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This can be useful when you want to hold arbitrary
terms: skip them and copy the binary term data to some
buffer.</p></div><p>Returns <strong>0</strong> on success, otherwise
<strong>-1</strong>.</p><h4>ei_x_append(ei_x_buff* x, const ei_x_buff* x2):int</h4><h4>ei_x_append_buf(ei_x_buff* x, const char* buf, int len):int</h4><p>Append a buffer at the end.</p><p>Appends data at the end of buffer <strong>x</strong>.</p><h4>ei_x_format(ei_x_buff* x, const char* fmt, ...):int</h4><h4>ei_x_format_wo_ver(ei_x_buff* x, const char *fmt, ... ):int</h4><p>Format a term from a format string and parameters.</p><p>Formats a term, given as a string, to a buffer.
Works like a sprintf for Erlang terms.
<strong>fmt</strong> contains a format string, with arguments like
<strong>~d</strong>, to insert terms from variables. The following
formats are supported (with the C types given):</p><pre>
~a  An atom, char*
~c  A character, char
~s  A string, char*
~i  An integer, int
~l  A long integer, long int
~u  A unsigned long integer, unsigned long int
~f  A float, float
~d  A double float, double float
~p  An Erlang pid, erlang_pid*</pre><p>For example, to encode a tuple with some stuff:</p><pre>
ei_x_format("{~a,~i,~d}", "numbers", 12, 3.14159)
encodes the tuple {numbers,12,3.14159}</pre><p><strong>ei_x_format_wo_ver()</strong> formats into a buffer,
without the initial version byte.</p><h4>ei_x_free(ei_x_buff* x):int</h4><p>Free a buffer.</p><p>Frees an <strong>ei_x_buff</strong> buffer.
The memory used by the buffer is returned to the OS.</p><h4>ei_x_new(ei_x_buff* x):int</h4><h4>ei_x_new_with_version(ei_x_buff* x):int</h4><p>Allocate a new buffer.</p><p>Allocates a new <strong>ei_x_buff</strong> buffer. The
fields of the structure pointed to by parameter <strong>x</strong>
is filled in, and a default buffer is allocated.
<strong>ei_x_new_with_version()</strong> also puts an initial
version byte, which is used in the binary format (so that
<strong>ei_x_encode_version()</strong> will not be needed.)</p><h4>Debug Information</h4><p>Some tips on what to check when the emulator does not seem to
receive the terms that you send:</p><ul><li>Be careful with the version header, use <strong>ei_x_new_with_version()</strong> when appropriate.</li><li>Turn on distribution tracing on the Erlang node.</li><li>Check the result codes from <strong>ei_decode_-calls</strong>.</li></ul><h4>See Also</h4><p><a href="erl_eterm">erl_eterm</a></p><h3>ei_connect</h3><p>Communicate with distributed Erlang.</p><p>This module enables C-programs to communicate with Erlang nodes,
using the Erlang distribution over TCP/IP.A C-node appears to Erlang as a <em>hidden node</em>.
That is, Erlang processes that know the name of the
C-node can communicate with it in a normal manner, but
the node name is not shown in the listing provided by
<a href="../erts/erlang#nodes/0">erts/erlang#nodes/0</a>
in <strong>ERTS</strong>.The environment variable <strong>ERL_EPMD_PORT</strong> can be used
to indicate which logical cluster a C-node belongs to.</p><h4>Time-Out Functions</h4><p>Most functions appear in a version with the suffix
<strong>_tmo</strong> appended to the function name. Those functions
take an extra argument, a time-out in <em>milliseconds</em>. The
semantics is this: for each communication primitive involved in
the operation, if the primitive does not complete within the time
specified, the function returns an error and
<strong>erl_errno</strong> is set to <strong>ETIMEDOUT</strong>.
With communication primitive is meant an operation on the socket, like
<strong>connect</strong>, <strong>accept</strong>,
<strong>recv</strong>, or <strong>send</strong>.</p><p>Clearly the time-outs are for implementing fault tolerance,
not to keep hard real-time promises. The <strong>_tmo</strong> functions
are for detecting non-responsive peers and to avoid blocking on
socket operations.</p><p>A time-out value of <strong>0</strong> (zero) means that time-outs are
disabled. Calling a <strong>_tmo</strong> function with the last
argument as <strong>0</strong> is therefore the same thing as calling
the function without the <strong>_tmo</strong> suffix.</p><p>As with all other functions starting with <strong>ei_</strong>,
you are <em>not</em> expected
to put the socket in non-blocking mode yourself in the program. Every
use of non-blocking mode is embedded inside the time-out
functions. The socket will always be back in blocking mode after
the operations are completed (regardless of the result). To
avoid problems, leave the socket options alone. <strong>ei</strong> handles
any socket options that need modification.</p><p>In all other senses, the <strong>_tmo</strong> functions inherit all
the return values and the semantics from the functions without
the <strong>_tmo</strong> suffix.</p><a name="ussi"></a><h4>User Supplied Socket Implementation</h4><p>By default <strong>ei</strong> supplies a TCP/IPv4 socket interface
that is used when communicating. The user can however plug in
his/her own IPv4 socket implementation. This, for example, in order
to communicate over TLS. A user supplied socket implementation
is plugged in by passing a
<a href="#ei_socket_callbacks">callback structure</a>
to either
<a href="#ei_connect_init">ei_connect_init</a>
or
<a href="#ei_connect_init">ei_connect_init</a>.</p><p>All callbacks in the <strong>ei_socket_callbacks</strong> structure
<em>should</em> return zero on success; and a posix error
code on failure.</p><p>The <strong>addr</strong> argument of the <strong>listen</strong>, <strong>accept</strong>,
and <strong>connect</strong> callbacks refer to appropriate address
structure for currently used protocol. Currently <strong>ei</strong>
only supports IPv4. That is, at this time <strong>addr</strong> always
points to a <strong>struct sockaddr_in</strong> structure.</p><p>The <strong>ei_socket_callbacks</strong> structure may be enlarged in
the future. All fields not set, <em>needs</em> to be zeroed out.</p><a name="ei_socket_callbacks"></a><pre><code class="">
typedef struct {
    int flags;
    int (*socket)(void **ctx, void *setup_ctx);
    int	(*close)(void *ctx);
    int (*listen)(void *ctx, void *addr, int *len, int backlog);
    int (*accept)(void **ctx, void *addr, int *len, unsigned tmo);
    int (*connect)(void *ctx, void *addr, int len, unsigned tmo);
    int (*writev)(void *ctx, const void *iov, int iovcnt, ssize_t *len, unsigned tmo);
    int (*write)(void *ctx, const char *buf, ssize_t *len, unsigned tmo);
    int (*read)(void *ctx, char *buf, ssize_t *len, unsigned tmo);
    int (*handshake_packet_header_size)(void *ctx, int *sz);
    int (*connect_handshake_complete)(void *ctx);
    int (*accept_handshake_complete)(void *ctx);
    int (*get_fd)(void *ctx, int *fd);
} ei_socket_callbacks;
        </code></pre><dl><dt><strong>flags</strong></dt><dd> <p>Flags informing <strong>ei</strong> about the behaviour of the
callbacks. Flags should be bitwise or:ed together. If no flag,
is set, the <strong>flags</strong> field should contain <strong>0</strong>. Currently,
supported flags:</p> <dl><dt><strong>EI_SCLBK_FLG_FULL_IMPL</strong></dt><dd> <p>
If set, the <strong>accept()</strong>, <strong>connect()</strong>,
<strong>writev()</strong>, <strong>write()</strong>, and <strong>read()</strong> callbacks
implements timeouts. The timeout is passed in the <strong>tmo</strong>
argument and is given in milli seconds. Note that the
<strong>tmo</strong> argument to these callbacks differ from the
timeout arguments in the <strong>ei</strong> API. Zero means a zero
timeout. That is, poll and timeout immediately unless the
operation is successful. <strong>EI_SCLBK_INF_TMO</strong>
(max <strong>unsigned</strong>) means infinite timeout. The file
descriptor is in blocking mode when a callback is called,
and it must be in blocking mode when the callback returns.
</p> <p>
If not set, <strong>ei</strong> will implement the timeout using
<strong>select()</strong> in order to determine when to call the
callbacks and when to time out. The <strong>tmo</strong> arguments
of the <strong>accept()</strong>, <strong>connect()</strong>, <strong>writev()</strong>,
<strong>write()</strong>, and <strong>read()</strong> callbacks should be
ignored. The callbacks may be called in non-blocking mode.
The callbacks are not allowed to change between blocking
and non-blocking mode. In order for this to work,
<strong>select()</strong> needs to interact with the socket primitives
used the same way as it interacts with the ordinary socket
primitives. If this is not the case, the callbacks
<em>need</em> to implement timeouts and this flag should
be set.
</p> </dd></dl> <p>More flags may be introduced in the future.</p> </dd><dt><strong>int (*socket)(void **ctx, void *setup_ctx)</strong></dt><dd> <p>Create a socket and a context for the socket.</p> <p>On success it should set <strong>*ctx</strong> to point to a context for
the created socket. This context will be passed to all other
socket callbacks. This function will be passed the same
<strong>setup_context</strong> as passed to the preceeding
<a href="#ei_connect_init">ei_connect_init</a>
or
<a href="#ei_connect_init">ei_connect_init</a>
call.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>During the lifetime of a socket, the pointer <strong>*ctx</strong>
<em>has</em> to remain the same. That is, it cannot later be
relocated.</p></div> <p>This callback is mandatory.</p> </dd><dt><strong>int (*close)(void *ctx)</strong></dt><dd> <p>Close the socket identified by <strong>ctx</strong> and destroy the context.</p> <p>This callback is mandatory.</p> </dd><dt><strong>int (*listen)(void *ctx, void *addr, int *len, int backlog)</strong></dt><dd> <p>Bind the socket identified by <strong>ctx</strong> to a local interface
and then listen on it.</p> <p>The <strong>addr</strong> and <strong>len</strong> arguments are both input and output
arguments. When called <strong>addr</strong> points to an address structure of
lenght <strong>*len</strong> containing information on how to bind the socket.
Uppon return this callback should have updated the structure referred
by <strong>addr</strong> with information on how the socket actually was bound.
<strong>*len</strong> should be updated to reflect the size of <strong>*addr</strong>
updated. <strong>backlog</strong> identifies the size of the backlog for the
listen socket.</p> <p>This callback is mandatory.</p> </dd><dt><strong>int (*accept)(void **ctx, void *addr, int *len, unsigned tmo)</strong></dt><dd> <p>Accept connections on the listen socket identified by
<strong>*ctx</strong>.</p> <p>When a connection is accepted, a new context for the accepted
connection should be created and <strong>*ctx</strong> should be updated
to point to the new context for the accepted connection. When
called <strong>addr</strong> points to an uninitialized address structure
of lenght <strong>*len</strong>. Uppon return this callback should have
updated this structure with information about the client address.
<strong>*len</strong> should be updated to reflect the size of <strong>*addr</strong>
updated.
</p> <p>If the <strong>EI_SCLBK_FLG_FULL_IMPL</strong> flag has been set,
<strong>tmo</strong> contains timeout time in milliseconds.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>During the lifetime of a socket, the pointer <strong>*ctx</strong>
<em>has</em> to remain the same. That is, it cannot later be
relocated.</p></div> <p>This callback is mandatory.</p> </dd><dt><strong>int (*connect)(void *ctx, void *addr, int len, unsigned tmo)</strong></dt><dd> <p>Connect the socket identified by <strong>ctx</strong> to the address
identified by <strong>addr</strong>.</p> <p>When called <strong>addr</strong> points to an address structure of
lenght <strong>len</strong> containing information on where to connect.</p> <p>If the <strong>EI_SCLBK_FLG_FULL_IMPL</strong> flag has been set,
<strong>tmo</strong> contains timeout time in milliseconds.</p> <p>This callback is mandatory.</p> </dd><dt><strong>int (*writev)(void *ctx, const void *iov, long iovcnt, ssize_t *len, unsigned tmo)</strong></dt><dd> <p>Write data on the connected socket identified by <strong>ctx</strong>.</p> <p><strong>iov</strong> points to an array of <strong>struct iovec</strong> structures of
length <strong>iovcnt</strong> containing data to write to the socket. On success,
this callback should set <strong>*len</strong> to the amount of bytes successfully
written on the socket.</p> <p>If the <strong>EI_SCLBK_FLG_FULL_IMPL</strong> flag has been set,
<strong>tmo</strong> contains timeout time in milliseconds.</p> <p>This callback is optional. Set the <strong>writev</strong> field
in the the <strong>ei_socket_callbacks</strong> structure to <strong>NULL</strong> if not
implemented.</p> </dd><dt><strong>int (*write)(void *ctx, const char *buf, ssize_t *len, unsigned tmo)</strong></dt><dd> <p>Write data on the connected socket identified by <strong>ctx</strong>.</p> <p>When called <strong>buf</strong> points to a buffer of length <strong>*len</strong>
containing the data to write on the socket. On success, this callback
should set <strong>*len</strong> to the amount of bytes successfully written on
the socket.</p> <p>If the <strong>EI_SCLBK_FLG_FULL_IMPL</strong> flag has been set,
<strong>tmo</strong> contains timeout time in milliseconds.</p> <p>This callback is mandatory.</p> </dd><dt><strong>int (*read)(void *ctx, char *buf, ssize_t *len, unsigned tmo)</strong></dt><dd> <p>Read data on the connected socket identified by <strong>ctx</strong>.</p> <p><strong>buf</strong> points to a buffer of length <strong>*len</strong> where the
read data should be placed. On success, this callback should update
<strong>*len</strong> to the amount of bytes successfully read on the socket.</p> <p>If the <strong>EI_SCLBK_FLG_FULL_IMPL</strong> flag has been set,
<strong>tmo</strong> contains timeout time in milliseconds.</p> <p>This callback is mandatory.</p> </dd><dt><strong>int (*handshake_packet_header_size)(void *ctx, int *sz)</strong></dt><dd> <p>Inform about handshake packet header size to use during the Erlang
distribution handshake.</p> <p>On success, <strong>*sz</strong> should be set to the handshake packet header
size to use. Valid values are <strong>2</strong> and <strong>4</strong>. Erlang TCP
distribution use a handshake packet size of <strong>2</strong> and Erlang TLS
distribution use a handshake packet size of <strong>4</strong>.</p> <p>This callback is mandatory.</p> </dd><dt><strong>int (*connect_handshake_complete)(void *ctx)</strong></dt><dd> <p>Called when a locally started handshake has completed successfully.</p> <p>This callback is optional. Set the <strong>connect_handshake_complete</strong> field
in the <strong>ei_socket_callbacks</strong> structure to <strong>NULL</strong> if not implemented.</p>	 </dd><dt><strong>int (*accept_handshake_complete)(void *ctx)</strong></dt><dd> <p>Called when a remotely started handshake has completed successfully.</p> <p>This callback is optional. Set the <strong>accept_handshake_complete</strong> field in
the <strong>ei_socket_callbacks</strong> structure to <strong>NULL</strong> if not implemented.</p> </dd><dt><strong>int (*get_fd)(void *ctx, int *fd)</strong></dt><dd> <p>Inform about file descriptor used by the socket which is identified
by <strong>ctx</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>During the lifetime of a socket, the file descriptor
<em>has</em> to remain the same. That is, repeated calls to this
callback with the same context <strong>should</strong> always report the same
file descriptor.</p><p>The file descriptor <em>has</em> to be a real file descriptor.
That is, no other operation should be able to get the same file
descriptor until it has been released by the <strong>close()</strong>
callback.</p></div> <p>This callback is mandatory.</p> </dd></dl><h3>Functions</h3><h4>ei_gethostbyaddr(const char *addr, int len, int type):struct hostent *</h4><h4>ei_gethostbyaddr_r(const char *addr, int length,  int type,  struct hostent *hostp, char *buffer,   int buflen,  int *h_errnop):struct hostent *</h4><h4>ei_gethostbyname(const char *name):struct hostent *</h4><h4>ei_gethostbyname_r(const char *name,  struct hostent *hostp,  char *buffer,  int buflen,  int *h_errnop):struct hostent *</h4><p>Name lookup functions.</p><p>Convenience functions for some common name lookup functions.</p><h4>ei_accept(ei_cnode *ec, int listensock, ErlConnect *conp):int</h4><p>Accept a connection from another node.</p><p>Used by a server process to accept a
connection from a client process.</p><ul><li> <p><strong>ec</strong> is the C-node structure.</p> </li><li> <p><strong>listensock</strong> is an open socket descriptor on
which <strong>listen()</strong> has previously been called.</p> </li><li> <p><strong>conp</strong> is a pointer to an
<strong>ErlConnect</strong> struct, described as follows:</p> <pre><code class="">
typedef struct {
  char ipadr[4];             
  char nodename[MAXNODELEN];
} ErlConnect;
        </code></pre> </li></ul><p>On success, <strong>conp</strong> is filled in with the address and
node name of the connecting client and a file descriptor is
returned. On failure, <strong>ERL_ERROR</strong> is returned and
<strong>erl_errno</strong> is set to <strong>EIO</strong>.</p><h4>ei_accept_tmo(ei_cnode *ec, int listensock, ErlConnect *conp, unsigned timeout_ms):int</h4><p>Accept a connection from another node with optional time-out.</p><p>Equivalent to
<strong>ei_accept</strong> with an optional time-out argument,
see the description at the beginning of this manual page.</p><h4>ei_close_connection(int fd):int</h4><p>Close a connection.</p><p>Closes a previously opened connection or listen socket.</p><h4>ei_connect(ei_cnode* ec, char *nodename):int</h4><h4>ei_xconnect(ei_cnode* ec, Erl_IpAddr adr, char *alivename):int</h4><p>Establish a connection to an Erlang node.</p><p>Sets up a connection to an Erlang node.</p><p><strong>ei_xconnect()</strong> requires the IP address of the
remote host and the alive name of the remote node to be
specified. <strong>ei_connect()</strong> provides an alternative
interface and determines the information from the node name
provided.</p><ul><li><strong>addr</strong> is the 32-bit IP address of the remote host.</li><li><strong>alive</strong> is the alivename of the remote node. </li><li><strong>node</strong> is the name of the remote node.</li></ul><p>These functions return an open file descriptor on success, or
a negative value indicating that an error occurred. In the latter
case they set <strong>erl_errno</strong> to one of the
following:</p><dl><dt><strong>EHOSTUNREACH</strong></dt><dd>The remote host <strong>node</strong> is unreachable.</dd><dt><strong>ENOMEM</strong></dt><dd>No more memory is available.</dd><dt><strong>EIO</strong></dt><dd>I/O error.</dd></dl><p>Also, <strong>errno</strong> values from
<strong>socket</strong><em>(2)</em> and
<strong>connect</strong><em>(2)</em>
system calls may be propagated into <strong>erl_errno</strong>.</p><p><em>Example:</em></p><pre><code class="">
#define NODE   "madonna@chivas.du.etx.ericsson.se"
#define ALIVE  "madonna"
#define IP_ADDR "150.236.14.75"

/*** Variant 1 ***/
int fd = ei_connect(&amp;ec, NODE);

/*** Variant 2 ***/
struct in_addr addr;
addr.s_addr = inet_addr(IP_ADDR);
fd = ei_xconnect(&amp;ec, &amp;addr, ALIVE);
        </code></pre><h4>ei_connect_init(ei_cnode* ec, const char* this_node_name, const char *cookie, short creation):int</h4><h4>ei_connect_init_ussi(ei_cnode* ec, const char* this_node_name, const char *cookie, short creation, ei_socket_callbacks *cbs, int cbs_sz, void *setup_context):int</h4><h4>ei_connect_xinit(ei_cnode* ec, const char *thishostname, const char *thisalivename, const char *thisnodename, Erl_IpAddr thisipaddr, const char *cookie, short creation):int</h4><h4>ei_connect_xinit_ussi(ei_cnode* ec, const char *thishostname, const char *thisalivename, const char *thisnodename, Erl_IpAddr thisipaddr, const char *cookie, short creation, ei_socket_callbacks *cbs, int cbs_sz, void *setup_context):int</h4><p>Initialize for a connection.</p><p>Initializes the <strong>ec</strong> structure, to
identify the node name and cookie of the server. One of them
must be called before other functions that works on the
<strong>ei_cnode</strong> type or a file descriptor associated with
a connection to another node is used.</p><ul><li> <p><strong>ec</strong> is a structure containing information about
the C-node. It is used in other <strong>ei</strong> functions
for connecting and receiving data.</p> </li><li> <p><strong>this_node_name</strong> is the registered name of the
process (the name before '@').</p> </li><li> <p><strong>cookie</strong> is the cookie for the node.</p> </li><li> <p><strong>creation</strong> identifies a specific instance of a
C-node. It can help prevent the node from receiving messages
sent to an earlier process with the same registered name.</p> </li><li> <p><strong>thishostname</strong> is the name of the machine we are
running on. If long names are to be used, they are to be fully
qualified (that is, <strong>durin.erix.ericsson.se</strong>
instead of <strong>durin</strong>).</p> </li><li> <p><strong>thisalivename</strong> is the registered name of the
process.</p> </li><li> <p><strong>thisnodename</strong> is the full name of the node,
that is, <strong>einode@durin</strong>.</p> </li><li> <p><strong>thispaddr</strong> if the IP address of the host.</p> </li><li> <p><strong>cbs</strong> is a pointer to a
<a href="#ei_socket_callbacks">callback structure</a>
implementing and alternative socket interface.</p> </li><li> <p><strong>cbs_sz</strong> is the size of the structure
pointed to by <strong>cbs</strong>.</p> </li><li> <p><strong>setup_context</strong> is a pointer to a structure that
will be passed as second argument to the <strong>socket</strong> callback
in the <strong>cbs</strong> structure.</p> </li></ul><p>A C-node acting as a server is assigned a creation
number when it calls <strong>ei_publish()</strong>.</p><p>A connection is closed by simply closing the socket.
For information about how to close the socket gracefully (when
there are outgoing packets before close), see the relevant system
documentation.</p><p>These functions return a negative value indicating that an error
occurred.</p><p><em>Example 1:</em></p><pre><code class="">
int n = 0;
struct in_addr addr;
ei_cnode ec;
addr.s_addr = inet_addr("150.236.14.75");
if (ei_connect_xinit(&amp;ec,
                     "chivas",
                     "madonna",
                     "madonna@chivas.du.etx.ericsson.se",
                     &amp;addr;
                     "cookie...",
                     n++) &lt; 0) {
    fprintf(stderr,"ERROR when initializing: %d",erl_errno);
    exit(-1);
}
        </code></pre><p><em>Example 2:</em></p><pre><code class="">
if (ei_connect_init(&amp;ec, "madonna", "cookie...", n++) &lt; 0) {
    fprintf(stderr,"ERROR when initializing: %d",erl_errno);
    exit(-1);
}
        </code></pre><h4>ei_connect_tmo(ei_cnode* ec, char *nodename, unsigned timeout_ms):int</h4><h4>ei_xconnect_tmo(ei_cnode* ec, Erl_IpAddr adr, char *alivename, unsigned timeout_ms):int</h4><p>Establish a connection to an Erlang node with optional time-out.</p><p>Equivalent to
<strong>ei_connect</strong> and <strong>ei_xconnect</strong> with an optional time-out
argument, see the description at the beginning of this manual
page.</p><h4>ei_get_tracelevel(void):int</h4><h4>ei_set_tracelevel(int level):void</h4><p>Get and set functions for tracing.</p><p>Used to set tracing on the distribution. The levels are different
verbosity levels. A higher level means more information. See also
section <a href="#debug_information"> Debug Information</a>.</p><p>These functions are not thread safe.</p><h4>ei_listen(ei_cnode *ec, int *port, int backlog):int</h4><h4>ei_xlisten(ei_cnode *ec, Erl_IpAddr adr, int *port, int backlog):int</h4><p>Create a listen socket.</p><p>Used by a server process to setup a listen socket which
later can be used for accepting connections from client processes.
</p><ul><li> <p><strong>ec</strong> is the C-node structure.</p> </li><li> <p><strong>adr</strong> is local interface to bind to.</p> </li><li> <p><strong>port</strong> is a pointer to an integer containing the
port number to bind to. If <strong>*port</strong> equals <strong>0</strong>
when calling <strong>ei_listen()</strong>, the socket will be bound to
an ephemeral port. On success, <strong>ei_listen()</strong> will update
the value of <strong>*port</strong> to the port actually bound to.
</p> </li><li> <p><strong>backlog</strong> is maximum backlog of pending connections.</p> </li></ul><p><strong>ei_listen</strong> will create a socket, bind to a port on the
local interface identified by <strong>adr</strong> (or all local interfaces if
<strong>ei_listen()</strong> is called), and mark the socket as a passive socket
(that is, a socket that will be used for accepting incoming connections).
</p><p>
On success, a file descriptor is returned which can be used in a call to
<strong>ei_accept()</strong>. On failure, <strong>ERL_ERROR</strong> is returned and
<strong>erl_errno</strong> is set to <strong>EIO</strong>.</p><h4>ei_publish(ei_cnode *ec, int port):int</h4><p>Publish a node name.</p><p>Used by a server process to register
with the local name server EPMD, thereby allowing
other processes to send messages by using the registered name.
Before calling either of these functions, the process should
have called <strong>bind()</strong> and <strong>listen()</strong>
on an open socket.</p><ul><li> <p><strong>ec</strong> is the C-node structure.</p> </li><li> <p><strong>port</strong> is the local name to register, and is to
be the same as the port number that was previously bound to the
socket.</p> </li><li> <p><strong>addr</strong> is the 32-bit IP address of the local
host.</p> </li></ul><p>To unregister with EPMD, simply close the returned descriptor. Do
not use <strong>ei_unpublish()</strong>, which is deprecated
anyway.</p><p>On success, the function returns a descriptor connecting the
calling process to EPMD. On failure, <strong>-1</strong> is returned and
<strong>erl_errno</strong> is set to <strong>EIO</strong>.</p><p>Also, <strong>errno</strong> values from
<strong>socket</strong><em>(2)</em> and
<strong>connect</strong><em>(2)</em> system calls may be propagated
into <strong>erl_errno</strong>.</p><h4>ei_publish_tmo(ei_cnode *ec, int port, unsigned timeout_ms):int</h4><p>Publish a node name with optional time-out.</p><p>Equivalent to
<strong>ei_publish</strong> with an optional time-out argument,
see the description at the beginning of this manual page.</p><h4>ei_receive(int fd, unsigned char* bufp, int bufsize):int</h4><p>Receive a message.</p><p>Receives a message consisting of a sequence
of bytes in the Erlang external format.</p><ul><li> <p><strong>fd</strong> is an open descriptor to an Erlang
connection. It is obtained from a previous
<strong>ei_connect</strong> or <strong>ei_accept</strong>.</p> </li><li> <p><strong>bufp</strong> is a buffer large enough to hold the
expected message.</p> </li><li> <p><strong>bufsize</strong> indicates the size of
<strong>bufp</strong>.</p> </li></ul><p>If a <em>tick</em> occurs, that is, the Erlang node on the
other end of the connection has polled this node to see if it
is still alive, the function returns <strong>ERL_TICK</strong> and
no message is placed in the buffer. Also,
<strong>erl_errno</strong> is set to <strong>EAGAIN</strong>.</p><p>On success, the message is placed in the specified buffer
and the function returns the number of bytes actually read. On
failure, the function returns <strong>ERL_ERROR</strong> and sets
<strong>erl_errno</strong> to one of the following:</p><dl><dt><strong>EAGAIN</strong></dt><dd>Temporary error: Try again.</dd><dt><strong>EMSGSIZE</strong></dt><dd>Buffer is too small.</dd><dt><strong>EIO</strong></dt><dd>I/O error.</dd></dl><h4>ei_receive_encoded(int fd, char **mbufp, int *bufsz,  erlang_msg *msg, int *msglen):int</h4><p>Obsolete function for receiving a message.</p><p>This function is retained for compatibility with code
generated by the interface compiler and with code following
examples in the same application.</p><p>In essence, the function performs the same operation as
<strong>ei_xreceive_msg</strong>, but instead of using an
<strong>ei_x_buff</strong>, the function expects a pointer to a character
pointer (<strong>mbufp</strong>), where the character pointer
is to point to a memory area allocated by <strong>malloc</strong>.
Argument <strong>bufsz</strong> is to be a pointer to an integer
containing the exact size (in bytes) of the memory area. The function
may reallocate the memory area and will in such cases put the new
size in <strong>*bufsz</strong> and update
<strong>*mbufp</strong>.</p><p>Returns either <strong>ERL_TICK</strong> or the
<strong>msgtype</strong> field of the
<strong>erlang_msg *msg</strong>. The length
of the message is put in <strong>*msglen</strong>. On error
a value <strong>&lt; 0</strong> is returned.</p><p>It is recommended to use <strong>ei_xreceive_msg</strong> instead when
possible, for the sake of readability. However, the function will
be retained in the interface for compatibility and
will <em>not</em> be removed in future releases without prior
notice.</p><h4>ei_receive_encoded_tmo(int fd, char **mbufp, int *bufsz,  erlang_msg *msg, int *msglen, unsigned timeout_ms):int</h4><p>Obsolete function for receiving a message with time-out. </p><p>Equivalent to
<strong>ei_receive_encoded</strong> with an optional time-out argument,
see the description at the beginning of this manual page.</p><h4>ei_receive_msg(int fd, erlang_msg* msg, ei_x_buff* x):int</h4><h4>ei_xreceive_msg(int fd, erlang_msg* msg, ei_x_buff* x):int</h4><p>Receive a message.</p><p>Receives a message to the buffer in <strong>x</strong>.
<strong>ei_xreceive_msg</strong> allows the buffer in
<strong>x</strong> to grow, but <strong>ei_receive_msg</strong>
fails if the message is larger than the pre-allocated buffer in
<strong>x</strong>.</p><ul><li><strong>fd</strong> is an open descriptor to an Erlang connection.</li><li><strong>msg</strong> is a pointer to an <strong>erlang_msg</strong> structure and contains information on the message received.</li><li><strong>x</strong> is buffer obtained from <strong>ei_x_new</strong>.</li></ul><p>On success, the functions return <strong>ERL_MSG</strong> and the
<strong>msg</strong> struct is initialized.
<strong>erlang_msg</strong> is defined as follows:</p><pre><code class="">
typedef struct {
    long msgtype;
    erlang_pid from;
    erlang_pid to;
    char toname[MAXATOMLEN+1];
    char cookie[MAXATOMLEN+1];
    erlang_trace token;
} erlang_msg;
        </code></pre><p><strong>msgtype</strong> identifies the type of message, and is
one of the following:</p><dl><dt><strong>ERL_SEND</strong></dt><dd> <p>Indicates that an ordinary send operation has occurred.
<strong>msg-&gt;to</strong> contains the pid of the recipient (the
C-node).</p> </dd><dt><strong>ERL_REG_SEND</strong></dt><dd> <p>A registered send operation occurred.
<strong>msg-&gt;from</strong> contains the pid of the sender.</p> </dd><dt><strong>ERL_LINK</strong> or <strong>ERL_UNLINK</strong></dt><dd> <p><strong>msg-&gt;to</strong> and
<strong>msg-&gt;from</strong> contain the pids of the
sender and recipient of the link or unlink.</p> </dd><dt><strong>ERL_EXIT</strong></dt><dd> <p>Indicates a broken link. <strong>msg-&gt;to</strong> and
<strong>msg-&gt;from</strong> contain the pids of the linked
processes.</p> </dd></dl><p>The return value is the same as for
<a href="#ei_receive">ei_receive</a>.</p><h4>ei_receive_msg_tmo(int fd, erlang_msg* msg, ei_x_buff* x, unsigned imeout_ms):int</h4><h4>ei_xreceive_msg_tmo(int fd, erlang_msg* msg, ei_x_buff* x, unsigned timeout_ms):int</h4><p>Receive a message with optional time-out.</p><p>Equivalent to <strong>ei_receive_msg</strong> and <strong>ei_xreceive_msg</strong>
with an optional time-out argument,
see the description at the beginning of this manual page.</p><h4>ei_receive_tmo(int fd, unsigned char* bufp, int bufsize, unsigned timeout_ms):int</h4><p>Receive a message with optional time-out.</p><p>Equivalent to
<strong>ei_receive</strong> with an optional time-out argument,
see the description at the beginning of this manual page.</p><h4>ei_reg_send(ei_cnode* ec, int fd, char* server_name, char* buf, int len):int</h4><p>Send a message to a registered name.</p><p>Sends an Erlang term to a registered process.</p><ul><li> <p><strong>fd</strong> is an open descriptor to an Erlang
connection.</p> </li><li><strong>server_name</strong> is the registered name of the intended recipient.</li><li><strong>buf</strong> is the buffer containing the term in binary format.</li><li><strong>len</strong> is the length of the message in bytes. </li></ul><p>Returns <strong>0</strong> if successful, otherwise <strong>-1</strong>. In
the latter case it sets <strong>erl_errno</strong> to
<strong>EIO</strong>.</p><p><em>Example:</em></p><p>Send the atom "ok" to the process "worker":</p><pre><code class="">
ei_x_buff x;
ei_x_new_with_version(&amp;x);
ei_x_encode_atom(&amp;x, "ok");
if (ei_reg_send(&amp;ec, fd, x.buff, x.index) &lt; 0)
    handle_error();
        </code></pre><h4>ei_reg_send_tmo(ei_cnode* ec, int fd, char* server_name, char* buf, int len, unsigned timeout_ms):int</h4><p>Send a message to a registered name with optional time-out </p><p>Equivalent to
<strong>ei_reg_send</strong> with an optional time-out argument,
see the description at the beginning of this manual page.</p><h4>ei_rpc(ei_cnode *ec, int fd, char *mod, char *fun, const char *argbuf, int argbuflen, ei_x_buff *x):int</h4><h4>ei_rpc_to(ei_cnode *ec, int fd, char *mod, char *fun, const char *argbuf, int argbuflen):int</h4><h4>ei_rpc_from(ei_cnode *ec, int fd, int timeout, erlang_msg *msg, ei_x_buff *x):int</h4><p>Remote Procedure Call from C to Erlang.</p><p>Supports calling Erlang functions on remote nodes.
<strong>ei_rpc_to()</strong> sends an RPC request to a remote node
and <strong>ei_rpc_from()</strong> receives the results of such a
call. <strong>ei_rpc()</strong> combines the functionality of these
two functions by sending an RPC request and waiting for the results.
See also <a href="../kernel/rpc#call/4">kernel/rpc#call/4</a> in Kernel.</p><ul><li> <p><strong>ec</strong> is the C-node structure previously
initiated by a call to <strong>ei_connect_init()</strong> or
<strong>ei_connect_xinit()</strong>.</p> </li><li> <p><strong>fd</strong> is an open descriptor to an Erlang
connection.</p> </li><li> <p><strong>timeout</strong> is the maximum time (in milliseconds)
to wait for results. Specify <strong>ERL_NO_TIMEOUT</strong> to
wait forever.
<strong>ei_rpc()</strong> waits infinitely for the answer,
that is, the call will never time out.</p> </li><li> <p><strong>mod</strong> is the name of the module containing the
function to be run on the remote node.</p> </li><li> <p><strong>fun</strong> is the name of the function to run.</p> </li><li> <p><strong>argbuf</strong> is a pointer to a buffer with an
encoded Erlang list, without a version magic number, containing
the arguments to be passed to the function.</p> </li><li> <p><strong>argbuflen</strong> is the length of the buffer
containing the encoded Erlang list.</p> </li><li> <p><strong>msg</strong> is structure of type
<strong>erlang_msg</strong> and contains information on the
message
received. For a description of the <strong>erlang_msg</strong>
format, see <a href="#ei_receive_msg">ei_receive_msg</a>.</p> </li><li> <p><strong>x</strong> points to the dynamic buffer that receives
the result. For <strong>ei_rpc()</strong> this is the result
without the version magic number. For
<strong>ei_rpc_from()</strong> the result returns a version
magic number and a 2-tuple <strong>{rex,Reply}</strong>.</p> </li></ul><p><strong>ei_rpc()</strong> returns the number of bytes in the
result on success and <strong>-1</strong> on failure.
<strong>ei_rpc_from()</strong> returns the
number of bytes, otherwise one of <strong>ERL_TICK</strong>,
<strong>ERL_TIMEOUT</strong>,
and <strong>ERL_ERROR</strong>. When failing, all three
functions set <strong>erl_errno</strong> to one of the
following:</p><dl><dt><strong>EIO</strong></dt><dd>I/O error.</dd><dt><strong>ETIMEDOUT</strong></dt><dd>Time-out expired.</dd><dt><strong>EAGAIN</strong></dt><dd>Temporary error: Try again.</dd></dl><p><em>Example:</em></p><p>Check to see if an Erlang process is alive:</p><pre><code class="">
int index = 0, is_alive;
ei_x_buff args, result;

ei_x_new(&amp;result);
ei_x_new(&amp;args);
ei_x_encode_list_header(&amp;args, 1);
ei_x_encode_pid(&amp;args, &amp;check_pid);
ei_x_encode_empty_list(&amp;args);

if (ei_rpc(&amp;ec, fd, "erlang", "is_process_alive",
           args.buff, args.index, &amp;result) &lt; 0)
    handle_error();

if (ei_decode_version(result.buff, &amp;index) &lt; 0
    || ei_decode_bool(result.buff, &amp;index, &amp;is_alive) &lt; 0)
    handle_error();
        </code></pre><h4>ei_self(ei_cnode *ec):erlang_pid *</h4><p>Retrieve the pid of the C-node.</p><p>Retrieves the pid of the C-node. Every C-node
has a (pseudo) pid used in <strong>ei_send_reg</strong>,
<strong>ei_rpc</strong>,
and others. This is contained in a field in the <strong>ec</strong>
structure. It will be safe for a long time to fetch this
field directly from the <strong>ei_cnode</strong> structure.</p><h4>ei_send(int fd, erlang_pid* to, char* buf, int len):int</h4><p>Send a message.</p><p>Sends an Erlang term to a process.</p><ul><li><strong>fd</strong> is an open descriptor to an Erlang connection.</li><li><strong>to</strong> is the pid of the intended recipient of the message.</li><li><strong>buf</strong> is the buffer containing the term in binary format.</li><li><strong>len</strong> is the length of the message in bytes. </li></ul><p>Returns <strong>0</strong> if successful, otherwise <strong>-1</strong>. In
the latter case it sets <strong>erl_errno</strong> to
<strong>EIO</strong>.</p><h4>ei_send_encoded(int fd, erlang_pid* to, char* buf, int len):int</h4><p>Obsolete function to send a message.</p><p>Works exactly as <strong>ei_send</strong>, the alternative name is retained for
backward compatibility. The function will <em>not</em> be
removed without prior notice.</p><h4>ei_send_encoded_tmo(int fd, erlang_pid* to, char* buf, int len, unsigned timeout_ms):int</h4><p>Obsolete function to send a message with optional time-out. </p><p>Equivalent to
<strong>ei_send_encoded</strong> with an optional time-out argument,
see the description at the beginning of this manual page.</p><h4>ei_send_reg_encoded(int fd, const erlang_pid *from, const char *to, const char *buf, int len):int</h4><p>Obsolete function to send a message to a registered name. </p><p>This function is retained for compatibility with code
generated by the interface compiler and with code following
examples in the same application.</p><p>The function works as <strong>ei_reg_send</strong> with one
exception. Instead of taking <strong>ei_cnode</strong> as first
argument, it takes a second argument, an
<strong>erlang_pid</strong>,
which is to be the process identifier of the sending process
(in the Erlang distribution protocol).</p><p>A suitable <strong>erlang_pid</strong> can be constructed from the
<strong>ei_cnode</strong> structure by the following example
code:</p><pre><code class="">
ei_cnode ec;
erlang_pid *self;
int fd; /* the connection fd */
...
self = ei_self(&amp;ec);
self-&gt;num = fd;
        </code></pre><h4>ei_send_reg_encoded_tmo(int fd, const erlang_pid *from, const char *to, const char *buf, int len):int</h4><p>Obsolete function to send a message to a registered name with time-out.</p><p>Equivalent to
<strong>ei_send_reg_encoded</strong> with an optional time-out argument,
see the description at the beginning of this manual page.</p><h4>ei_send_tmo(int fd, erlang_pid* to, char* buf, int len, unsigned timeout_ms):int</h4><p>Send a message with optional time-out.</p><p>Equivalent to
<strong>ei_send</strong> with an optional time-out argument,
see the description at the beginning of this manual page.</p><h4>ei_thisnodename(ei_cnode *ec):const char *</h4><h4>ei_thishostname(ei_cnode *ec):const char *</h4><h4>ei_thisalivename(ei_cnode *ec):const char *</h4><p>Retrieve some values.</p><p>Can be used to retrieve information about
the C-node. These values are initially set with
<strong>ei_connect_init()</strong> or
<strong>ei_connect_xinit()</strong>.</p><p>These function simply fetch the appropriate field from the
<strong>ec</strong>
structure. Read the field directly will probably be safe for
a long time, so these functions are not really needed.</p><h4>ei_unpublish(ei_cnode *ec):int</h4><p>Forcefully unpublish a node name.</p><p>Can be called by a process to unregister a
specified node from EPMD on the local host. This is, however, usually
not allowed, unless EPMD was started with flag
<strong>-relaxed_command_check</strong>, which it normally is not.</p><p>To unregister a node you have published, you should
close the descriptor that was returned by
<strong>ei_publish()</strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release.</p></div><p><strong>ec</strong> is the node structure of the node to
unregister.</p><p>If the node was successfully unregistered from EPMD, the
function returns <strong>0</strong>. Otherwise, <strong>-1</strong> is returned and
<strong>erl_errno</strong> is set to <strong>EIO</strong>.</p><h4>ei_unpublish_tmo(ei_cnode *ec, unsigned timeout_ms):int</h4><p>Unpublish a node name with optional time-out.</p><p>Equivalent to
<strong>ei_unpublish</strong> with an optional time-out argument,
see the description at the beginning of this manual page.</p><a name="debug_information"></a><h4>Debug Information</h4><p>If a connection attempt fails, the following can be checked:</p><ul><li><strong>erl_errno</strong>.</li><li>That the correct cookie was used</li><li>That EPMD is running</li><li>That the remote Erlang node on the other side is running the same version of Erlang as the <strong>ei</strong> library</li><li>That environment variable <strong>ERL_EPMD_PORT</strong> is set correctly</li></ul><p>The connection attempt can be traced by setting a trace level by either
using <strong>ei_set_tracelevel</strong> or by setting environment
variable <strong>EI_TRACELEVEL</strong>.
The trace levels have the following messages:</p><ul><li>1: Verbose error messages</li><li>2: Above messages and verbose warning messages</li><li>3: Above messages and progress reports for connection handling </li><li>4: Above messages and progress reports for communication</li><li>5: Above messages and progress reports for data conversion</li></ul><h3>registry</h3><p>Store and back up key-value pairs.</p><p>This module provides support for storing key-value
pairs in a table known as a registry, backing up registries to
<a href="./mnesia">Mnesia</a>
in an atomic manner, and later restoring the contents of a
registry from <strong>Mnesia</strong>.</p><h3>Functions</h3><h4>ei_reg_close(reg):int</h4><p>Close a registry.</p><ul><li><span class="v">ei_reg *reg;</span></li></ul><p>A registry that has previously been created with
<strong>ei_reg_open()</strong> is closed, and all the objects it
contains are freed.</p><p><strong>reg</strong> is the registry to close.</p><p>Returns <strong>0</strong>.</p><h4>ei_reg_delete(reg,key):int</h4><p>Delete an object from the registry.</p><ul><li><span class="v">ei_reg *reg;</span></li><li><span class="v">const char *key;</span></li></ul><p>Deletes an object from the registry. The object is not
removed from the registry, it is only marked for later
removal so that on later backups to <strong>Mnesia</strong>, the
corresponding object can be removed from the <strong>Mnesia</strong> table as
well. If another object is later created with the same key, the
object will be reused. </p><p>The object is removed from the registry after a call to
<strong>ei_reg_dump()</strong> or <strong>ei_reg_purge()</strong>.
</p><ul><li><strong>reg</strong> is the registry containing <strong>key</strong>.</li><li><strong>key</strong> is the object to remove.</li></ul><p>Returns <strong>0</strong> on success, otherwise <strong>-1</strong>.</p><h4>ei_reg_dump(fd,reg,mntab,flags):int</h4><p>Back up a registry to Mnesia.</p><ul><li><span class="v">int fd;</span></li><li><span class="v">ei_reg *reg;</span></li><li><span class="v">const char *mntab;</span></li><li><span class="v">int flags;</span></li></ul><p>Dumps the contents of a registry to a <strong>Mnesia</strong> table in an
atomic manner, that is, either all data or no data is updated.
If any errors are encountered while backing up
the data, the entire operation is aborted.</p><ul><li><strong>fd</strong> is an open connection to Erlang. <strong>Mnesia</strong> 3.0 or later must be running on the Erlang node. </li><li><strong>reg</strong> is the registry to back up.</li><li><strong>mntab</strong> is the name of the <strong>Mnesia</strong> table where the backed up data is to be placed. If the table does not exist, it is created automatically using configurable defaults. For information about configuring this behavior, see <a href="./mnesia">mnesia/mnesia</a>.</li></ul><p>If <strong>flags</strong> is <strong>0</strong>, the backup includes only
those objects that have been created, modified, or deleted since the
last backup or restore (that is, an incremental backup). After the
backup, any objects that were marked dirty are now clean, and any
objects that had been marked for deletion are deleted.</p><p>Alternatively, setting flags to <strong>EI_FORCE</strong> causes a full
backup to be done, and <strong>EI_NOPURGE</strong> causes the deleted objects
to be left in the registry afterwards. These can be bitwise OR'ed
together if both behaviors are desired. If <strong>EI_NOPURGE</strong> was
specified, <strong>ei_reg_purge()</strong> can be used to
explicitly remove the deleted items from the registry later.</p><p>Returns <strong>0</strong> on success, otherwise <strong>-1</strong>.</p><h4>ei_reg_getfval(reg,key):double</h4><p>Get a floating point object.</p><ul><li><span class="v">ei_reg *reg;</span></li><li><span class="v">const char *key;</span></li></ul><p>Gets the value associated with <strong>key</strong> in the
registry. The value must be a floating point type.</p><ul><li><strong>reg</strong> is the registry where the object will be looked up.</li><li><strong>key</strong> is the name of the object to look up. </li></ul><p>On success, the function returns the value associated with
<strong>key</strong>.
If the object is not found or if it is not a floating point
object, <strong>-1.0</strong> is returned. To avoid problems with in-band error
reporting (that is, if you cannot distinguish between <strong>-1.0</strong> and
a valid result), use the more general function
<strong>ei_reg_getval()</strong> instead.</p><h4>ei_reg_getival(reg,key):int</h4><p>Get an integer object.</p><ul><li><span class="v">ei_reg *reg;</span></li><li><span class="v">const char *key;</span></li></ul><p>Gets the value associated with <strong>key</strong> in the
registry. The value must be an integer.</p><ul><li><strong>reg</strong> is the registry where the object will be looked up.</li><li><strong>key</strong> is the name of the object to look up. </li></ul><p>On success, the function returns the value associated with
<strong>key</strong>.
If the object is not found or if it is not an integer
object, <strong>-1</strong> is returned. To avoid problems with in-band error
reporting (that is, if you cannot distinguish between <strong>-1</strong> and a
valid result), use the more general function
<strong>ei_reg_getval()</strong> instead.</p><h4>ei_reg_getpval(reg,key,size):const void *</h4><p>Get a binary object.</p><ul><li><span class="v">ei_reg *reg;</span></li><li><span class="v">const char *key;</span></li><li><span class="v">int size;</span></li></ul><p>Gets the value associated with <strong>key</strong> in the
registry. The value must be a binary (pointer) type.</p><ul><li><strong>reg</strong> is the registry where the object will be looked up.</li><li><strong>key</strong> is the name of the object to look up. </li><li><strong>size</strong> is initialized to contain the length in bytes of the object, if it is found.</li></ul><p>On success, the function returns the value associated with
<strong>key</strong> and indicates its length in
<strong>size</strong>.
If the object is not found or if it is not a binary object,
<strong>NULL</strong> is returned. To avoid problems with in-band error
reporting (that is, if you cannot distinguish between <strong>NULL</strong> and
a valid result), use the more general function
<strong>ei_reg_getval()</strong> instead.</p><h4>ei_reg_getsval(reg,key):const char *</h4><p>Get a string object.</p><ul><li><span class="v">ei_reg *reg;</span></li><li><span class="v">const char *key;</span></li></ul><p>Gets the value associated with <strong>key</strong> in the
registry. The value must be a string.</p><ul><li><strong>reg</strong> is the registry where the object will be looked up.</li><li><strong>key</strong> is the name of the object to look up. </li></ul><p>On success, the function returns the value associated with
<strong>key</strong>. If the object is not found or if it is not a
string, <strong>NULL</strong> is returned. To avoid problems with in-band error
reporting (that is, if you cannot distinguish between <strong>NULL</strong> and
a valid result), use the more general function
<strong>ei_reg_getval()</strong> instead.</p><h4>ei_reg_getval(reg,key,flags,v,...):int</h4><p>Get any object.</p><ul><li><span class="v">ei_reg *reg;</span></li><li><span class="v">const char *key;</span></li><li><span class="v">int flags;</span></li><li><span class="v">void *v (see below)</span></li></ul><p>A general function for retrieving any kind of
object from the registry.</p><ul><li> <p><strong>reg</strong> is the registry where the object will be
looked up.</p> </li><li> <p><strong>key</strong> is the name of the object to look up.</p> </li><li> <p><strong>flags</strong> indicates the type of object that you
are looking for. If <strong>flags</strong> is <strong>0</strong>, any
kind of object is returned.
If <strong>flags</strong> is <strong>EI_INT</strong>, <strong>EI_FLT</strong>,
<strong>EI_STR</strong>, or <strong>EI_BIN</strong>, then only values of
that kind are returned.</p> <p>The buffer pointed to by <strong>v</strong>
must be large enough to hold the return data, that is, it must be
a pointer to one of <strong>int</strong>,
<strong>double</strong>, <strong>char*</strong>, or
<strong>void*</strong>, respectively.</p> <p>If <strong>flags</strong> is <strong>EI_BIN</strong>, a fifth argument
<strong>int *size</strong> is required, so that the size of the
object can be returned.</p> </li></ul><p>On success, <strong>v</strong> (and <strong>size</strong> if the
object is binary) is initialized with the value associated
with <strong>key</strong>, and the function returns <strong>EI_INT</strong>,
<strong>EI_FLT</strong>, <strong>EI_STR</strong>, or <strong>EI_BIN</strong>, indicating the type
of object. On failure, <strong>-1</strong> is returned and the
arguments are not updated.</p><h4>ei_reg_markdirty(reg,key):int</h4><p>Mark an object as dirty.</p><ul><li><span class="v">ei_reg *reg;</span></li><li><span class="v">const char *key;</span></li></ul><p>Marks a registry object as dirty. This ensures that
it is included in the next backup to <strong>Mnesia</strong>. Normally this
operation is not necessary, as all of the normal registry
'set' functions do this automatically. However, if you have
retrieved the value of a string or binary object from the
registry and modified the contents, then the change is
invisible to the registry and the object is assumed to be
unmodified. This function allows you to make such modifications
and then let the registry know about them.</p><ul><li><strong>reg</strong> is the registry containing the object. </li><li><strong>key</strong> is the name of the object to mark. </li></ul><p>Returns <strong>0</strong> on success, otherwise <strong>-1</strong>.</p><h4>ei_reg_open(size):ei_reg *</h4><p>Create and open a registry.</p><ul><li><span class="v">int size;</span></li></ul><p>Opens (creates) a registry, which initially is empty. To
close the registry later, use <strong>ei_reg_close()</strong>.</p><p><strong>size</strong> is the approximate number of objects you
intend to store in the registry. As the registry uses a hash table
with collision chaining, no absolute upper limit exists on the
number of objects that can be stored in it. However, for reasons
of efficiency, it is a good idea to choose a number that is
appropriate for your needs. To change the size later, use
<strong>ei_reg_resize()</strong>. Notice that the number
you provide is increased to the nearest larger prime number.</p><p>Returns an empty registry on success, otherwise <strong>NULL</strong>.</p><h4>ei_reg_purge(reg):int</h4><p>Remove deleted objects.</p><ul><li><span class="v">ei_reg *reg;</span></li></ul><p>Removes all objects marked for deletion. When objects
are deleted with <strong>ei_reg_delete()</strong> they are not
removed from the registry, only marked for later removal.
On a later backup to <strong>Mnesia</strong>, the
objects can also be removed from the <strong>Mnesia</strong> table. If you are
not backing up to <strong>Mnesia</strong>, you may wish to remove the objects
manually with this function.</p><p><strong>reg</strong> is a registry containing objects marked for
deletion.</p><p>Returns <strong>0</strong> on success, otherwise <strong>-1</strong>.</p><h4>ei_reg_resize(reg,newsize):int</h4><p>Resize a registry.</p><ul><li><span class="v">ei_reg *reg;</span></li><li><span class="v">int newsize;</span></li></ul><p>Changes the size of a registry.</p><p><strong>newsize</strong> is the new size to make the registry. The
number is increased to the nearest larger prime number.</p><p>On success, the registry is resized, all contents
rehashed, and <strong>0</strong> is returned. On failure, the
registry is left unchanged and <strong>-1</strong> is returned.</p><h4>ei_reg_restore(fd,reg,mntab):int</h4><p>Restore a registry from Mnesia.</p><ul><li><span class="v">int fd;</span></li><li><span class="v">ei_reg *reg;</span></li><li><span class="v">const char *mntab;</span></li></ul><p>The contents of a <strong>Mnesia</strong> table are read into the registry.</p><ul><li><strong>fd</strong> is an open connection to Erlang. <strong>Mnesia</strong> 3.0 or later must be running on the Erlang node. </li><li><strong>reg</strong> is the registry where the data is to be placed.</li><li><strong>mntab</strong> is the name of the <strong>Mnesia</strong> table to read data from.</li></ul><p>Notice that only tables of a certain format can be
restored, that is, those that have been created and backed up to
with <strong>ei_reg_dump()</strong>. If the registry was not empty
before the operation, the contents of the table are added to the
contents of the registry. If the table contains objects with the
same keys as those already in the registry, the registry objects
are overwritten with the new values. If the registry
contains objects that were not in the table, they are
unchanged by this operation.</p><p>After the restore operation, the entire contents of the
registry is marked as unmodified. Notice that this includes any
objects that were modified before the restore and not
overwritten by the restore.</p><p>Returns <strong>0</strong> on success, otherwise <strong>-1</strong>.</p><h4>ei_reg_setfval(reg,key,f):int</h4><p>Assign a floating point object.</p><ul><li><span class="v">ei_reg *reg;</span></li><li><span class="v">const char *key;</span></li><li><span class="v">double f;</span></li></ul><p>Creates a key-value pair with the specified <strong>key</strong>
and floating point value <strong>f</strong>. If an object already
exists with the same <strong>key</strong>, the new value replaces
the old one. If the previous value was a binary or string, it is
freed with <strong>free()</strong>.</p><ul><li><strong>reg</strong> is the registry where the object is to be placed.</li><li><strong>key</strong> is the object name.</li><li><strong>f</strong> is the floating point value to assign. </li></ul><p>Returns <strong>0</strong> on success, otherwise <strong>-1</strong>.</p><h4>ei_reg_setival(reg,key,i):int</h4><p>Assign an integer object.</p><ul><li><span class="v">ei_reg *reg;</span></li><li><span class="v">const char *key;</span></li><li><span class="v">int i;</span></li></ul><p>Creates a key-value pair with the specified <strong>key</strong>
and integer value <strong>i</strong>. If an object already exists
with the same <strong>key</strong>, the new value replaces the old
one. If the previous value was a binary or string, it is freed with
<strong>free()</strong>.</p><ul><li><strong>reg</strong> is the registry where the object is to be placed.</li><li><strong>key</strong> is the object name.</li><li><strong>i</strong> is the integer value to assign.</li></ul><p>Returns <strong>0</strong> on success, otherwise <strong>-1</strong>.</p><h4>ei_reg_setpval(reg,key,p,size):int</h4><p>Assign a binary object.</p><ul><li><span class="v">ei_reg *reg;</span></li><li><span class="v">const char *key;</span></li><li><span class="v">const void *p;</span></li><li><span class="v">int size;</span></li></ul><p>Creates a key-value pair with the specified <strong>key</strong>
whose "value" is the binary object pointed to by <strong>p</strong>.
If an object already exists with the same <strong>key</strong>,
the new value replaces the old one. If the previous value was a
binary or string, it is freed with <strong>free()</strong>.</p><ul><li><strong>reg</strong> is the registry where the object is to be placed.</li><li><strong>key</strong> is the object name.</li><li><strong>p</strong> is a pointer to the binary object. The object itself must have been created through a single call to <strong>malloc()</strong> or a similar function, so that the registry can later delete it if necessary by calling <strong>free()</strong>.</li><li><strong>size</strong> is the length in bytes of the binary object.</li></ul><p>Returns <strong>0</strong> on success, otherwise <strong>-1</strong>.</p><h4>ei_reg_setsval(reg,key,s):int</h4><p>Assign a string object.</p><ul><li><span class="v">ei_reg *reg;</span></li><li><span class="v">const char *key;</span></li><li><span class="v">const char *s;</span></li></ul><p>Creates a key-value pair with the specified <strong>key</strong>
whose "value" is the specified string <strong>s</strong>. If an
object already exists with the same <strong>key</strong>, the new
value replaces the old one. If the previous value was a binary or
string, it is freed with <strong>free()</strong>.</p><ul><li><strong>reg</strong> is the registry where the object is to be placed.</li><li><strong>key</strong> is the object name.</li><li><strong>s</strong> is the string to assign. The string itself must have been created through a single call to <strong>malloc()</strong> or similar a function, so that the registry can later delete it if necessary by calling <strong>free()</strong>.</li></ul><p>Returns <strong>0</strong> on success, otherwise <strong>-1</strong>.</p><h4>ei_reg_setval(reg,key,flags,v,...):int</h4><p>Assign a value to any object type.</p><ul><li><span class="v">ei_reg *reg;</span></li><li><span class="v">const char *key;</span></li><li><span class="v">int flags;</span></li><li><span class="v">v (see below)</span></li></ul><p>Creates a key-value pair with the specified <strong>key</strong>
whose value is specified by <strong>v</strong>. If an object already
exists with the same <strong>key</strong>, the new value replaces
the old one. If the previous value was a binary or string, it is freed
with <strong>free()</strong>.</p><ul><li> <p><strong>reg</strong> is the registry where the object is to be
placed.</p> </li><li> <p><strong>key</strong> is the object name.</p> </li><li> <p><strong>flags</strong> indicates the type of the object
specified by <strong>v</strong>. Flags must be one of
<strong>EI_INT</strong>, <strong>EI_FLT</strong>, <strong>EI_STR</strong>, and <strong>EI_BIN</strong>,
indicating whether
<strong>v</strong> is <strong>int</strong>,
<strong>double</strong>, <strong>char*</strong>, or
<strong>void*</strong>.</p> <p>If <strong>flags</strong> is <strong>EI_BIN</strong>, a fifth argument
<strong>size</strong> is required, indicating the size
in bytes of the object pointed to by <strong>v</strong>.</p> </li></ul><p>If you wish to store an arbitrary pointer in the registry,
specify a <strong>size</strong> of <strong>0</strong>. In this case, the
object itself is not transferred by an
<strong>ei_reg_dump()</strong> operation, only the pointer
value.</p><p>Returns <strong>0</strong> on success, otherwise <strong>-1</strong>.</p><h4>ei_reg_stat(reg,key,obuf):int</h4><p>Get object information.</p><ul><li><span class="v">ei_reg *reg;</span></li><li><span class="v">const char *key;</span></li><li><span class="v">struct ei_reg_stat *obuf;</span></li></ul><p>Returns information about an object.</p><ul><li><strong>reg</strong> is the registry containing the object. </li><li><strong>key</strong> is the object name.</li><li><strong>obuf</strong> is a pointer to an <strong>ei_reg_stat</strong> structure, defined as follows:</li></ul><pre><code class="">
struct ei_reg_stat {
  int attr;
  int size;
};
        </code></pre><p>In <strong>attr</strong> the attributes of the object are stored
as the logical <em>OR</em> of its type (one of <strong>EI_INT</strong>,
<strong>EI_FLT</strong>, <strong>EI_BIN</strong>, and <strong>EI_STR</strong>),
whether it is marked for deletion (<strong>EI_DELET</strong>), and whether it
has been modified since the last backup to <strong>Mnesia</strong>
(<strong>EI_DIRTY</strong>).</p><p>Field <strong>size</strong> indicates the size in bytes required
to store <strong>EI_STR</strong> (including the terminating <strong>0</strong>) and
<strong>EI_BIN</strong> objects, or <strong>0</strong> for <strong>EI_INT</strong> and
<strong>EI_FLT</strong>.</p><p>Returns <strong>0</strong> and initializes <strong>obuf</strong> on success,
otherwise <strong>-1</strong>.</p><h4>ei_reg_tabstat(reg,obuf):int</h4><p>Get registry information.</p><ul><li><span class="v">ei_reg *reg;</span></li><li><span class="v">struct ei_reg_tabstat *obuf;</span></li></ul><p>Returns information about a registry. Using information
returned by this function, you can see whether the size of the
registry is suitable for the amount of data it contains.</p><ul><li><strong>reg</strong> is the registry to return information about.</li><li><strong>obuf</strong> is a pointer to an <strong>ei_reg_tabstat</strong> structure, defined as follows: </li></ul><pre><code class="">
struct ei_reg_tabstat {
  int size;  
  int nelem; 
  int npos;  
  int collisions; 
};
        </code></pre><p>Field <strong>size</strong> indicates the number of hash positions
in the registry. This is the number you provided when you
created or last resized the registry, rounded up to the nearest
prime number.</p><ul><li><strong>nelem</strong> indicates the number of elements stored in the registry. It includes objects that are deleted but not purged.</li><li><strong>npos</strong> indicates the number of unique positions that are occupied in the registry.</li><li><strong>collisions</strong> indicates how many elements are sharing positions in the registry.</li></ul><p>On success, <strong>0</strong> is returned and
<strong>obuf</strong> is initialized to contain table statistics,
otherwise <strong>-1</strong> is returned.</p><h3>erl_connect</h3><p>Communicate with distributed Erlang.</p><p>This module provides support for communication between distributed
Erlang nodes and C-nodes, in a manner that is transparent to Erlang
processes.A C-node appears to Erlang as a <em>hidden node</em>.
That is, Erlang processes that know the name of the
C-node can communicate with it in a normal manner, but
the node name does not appear in the listing provided by
<a href="../erts/erlang#nodes/0">erts/erlang#nodes/0</a>
in <strong>ERTS</strong>.</p><h3>Functions</h3><h4>erl_accept(listensock, conp):int</h4><p>Accept a connection.</p><ul><li><span class="v">int listensock;</span></li><li><span class="v">ErlConnect *conp;</span></li></ul><p>This function is used by a server process to accept a
connection from a client process.</p><ul><li><strong>listensock</strong> is an open socket descriptor on which <strong>listen()</strong> has previously been called.</li><li><strong>conp</strong> is a pointer to an <strong>ErlConnect</strong> struct, described as follows:</li></ul><pre><code class="">
typedef struct {
  char ipadr[4];
  char nodename[MAXNODELEN];
} ErlConnect;
        </code></pre><p>On success, <strong>conp</strong> is filled in with the address and
node name of the connecting client and a file descriptor is
returned. On failure, <strong>ERL_ERROR</strong> is returned and
<strong>erl_errno</strong> is set to <strong>EIO</strong>.</p><h4>erl_close_connection(fd):int</h4><p>Close a connection to an Erlang node.</p><ul><li><span class="v">int fd;</span></li></ul><p>Closes an open connection to an Erlang node.</p><p><strong>Fd</strong> is a file descriptor obtained from
<strong>erl_connect()</strong> or
<strong>erl_xconnect()</strong>.</p><p>Returns <strong>0</strong> on success. If the call fails, a non-zero value
is returned, and the reason for the error can be obtained with the
appropriate platform-dependent call.</p><h4>erl_connect(node):int</h4><h4>erl_xconnect(addr, alive):int</h4><p>Establish a connection to an Erlang node.</p><ul><li><span class="v">char *node, *alive;</span></li><li><span class="v">struct in_addr *addr;</span></li></ul><p>Sets up a connection to an Erlang node.</p><p><strong>erl_xconnect()</strong> requires the IP address of the
remote host and the alivename of the remote node to be
specified. <strong>erl_connect()</strong> provides an alternative
interface, and determines the information from the node name
provided.</p><ul><li><strong>addr</strong> is the 32-bit IP address of the remote host.</li><li><strong>alive</strong> is the alivename of the remote node. </li><li><strong>node</strong> is the name of the remote node.</li></ul><p>Returns an open file descriptor on success, otherwise a negative
value. In the latter case <strong>erl_errno</strong> is set to one
of:</p><dl><dt><strong>EHOSTUNREACH</strong></dt><dd>The remote host <strong>node</strong> is unreachable.</dd><dt><strong>ENOMEM</strong></dt><dd>No more memory is available.</dd><dt><strong>EIO</strong></dt><dd>I/O error.</dd></dl><p>Also, <strong>errno</strong> values from
<strong>socket</strong><em>(2)</em> and
<strong>connect</strong><em>(2)</em>
system calls can be propagated into <strong>erl_errno</strong>.</p><p><em>Example:</em></p><pre><code class="">
#define NODE   "madonna@chivas.du.etx.ericsson.se"
#define ALIVE  "madonna"
#define IP_ADDR "150.236.14.75"

/*** Variant 1 ***/
erl_connect( NODE );

/*** Variant 2 ***/
struct in_addr addr;
addr = inet_addr(IP_ADDR);
erl_xconnect( &amp;addr , ALIVE );
        </code></pre><h4>erl_connect_init(number, cookie, creation):int</h4><h4>erl_connect_xinit(host, alive, node, addr, cookie, creation):int</h4><p>Initialize communication.</p><ul><li><span class="v">int number;</span></li><li><span class="v">char *cookie;</span></li><li><span class="v">short creation;</span></li><li><span class="v">char *host,*alive,*node;</span></li><li><span class="v">struct in_addr *addr;</span></li></ul><p>Initializes the <strong>erl_connect</strong> module.
In particular, these functions are used to identify the name of the
C-node from which they are called. One of these functions must
be called before any of the other functions in the <strong>erl_connect</strong>
module are used.</p><p><strong>erl_connect_xinit()</strong> stores for later use
information about:</p><ul><li>Hostname of the node, <strong>host</strong></li><li>Alivename, <strong>alive</strong></li><li>Node name, <strong>node</strong></li><li>IP address, <strong>addr</strong></li><li>Cookie, <strong>cookie</strong></li><li>Creation number, <strong>creation</strong></li></ul><p><strong>erl_connect_init()</strong>
provides an alternative interface that does not require as much
information from the caller. Instead,
<strong>erl_connect_init()</strong>
uses <strong>gethostbyname()</strong> to obtain default values.</p><p>If you use <strong>erl_connect_init()</strong>, your node will
have a short name, that is, it will not be fully qualified. If you
need to use fully qualified (long) names, use
<strong>erl_connect_xinit()</strong> instead.</p><ul><li> <p><strong>host</strong> is the name of the host on which the node
is running.</p> </li><li> <p><strong>alive</strong> is the alivename of the node.</p> </li><li> <p><strong>node</strong> is the node name. It is to
be of the form <em>alivename@hostname</em>.</p> </li><li> <p><strong>addr</strong> is the 32-bit IP address of
<strong>host</strong>.</p> </li><li> <p><strong>cookie</strong> is the authorization string required
for access to the remote node. If <strong>NULL</strong>, the user
<strong>HOME</strong> directory is searched for a cookie file
<strong>.erlang.cookie</strong>. The path to
the home directory is retrieved from environment variable
<strong>HOME</strong> on Unix and from the
<strong>HOMEDRIVE</strong> and
<strong>HOMEPATH</strong> variables on Windows. For more
details, see the <a href="./auth">kernel/auth</a> module in Kernel.</p> </li><li> <p><strong>creation</strong> helps identifying a particular
instance of a C-node. In particular, it can help prevent us from
receiving messages sent to an earlier process with the same
registered name.</p> </li></ul><p>A C-node acting as a server is assigned a creation number
when it calls <strong>erl_publish()</strong>.</p><p><strong>number</strong> is used by
<strong>erl_connect_init()</strong> to
construct the actual node name. In Example 2
below, <em>"c17@a.DNS.name"</em> is the resulting node name.</p><p><em>Example 1:</em></p><pre><code class="">
struct in_addr addr;
addr = inet_addr("150.236.14.75");
if (!erl_connect_xinit("chivas",
                       "madonna",
                       "madonna@chivas.du.etx.ericsson.se",
                       &amp;addr;
                       "samplecookiestring..."),
                       0)
  erl_err_quit("&lt;ERROR&gt; when initializing !");
        </code></pre><p><em>Example 2:</em></p><pre><code class="">
if (!erl_connect_init(17, "samplecookiestring...", 0))
  erl_err_quit("&lt;ERROR&gt; when initializing !");
        </code></pre><h4>erl_publish(port):int</h4><p>Publish a node name.</p><ul><li><span class="v">int port;</span></li></ul><p>This function is used by a server process to register
with the local name server EPMD, thereby allowing
other processes to send messages by using the registered name.
Before calling this function, the process should
have called <strong>bind()</strong> and <strong>listen()</strong>
on an open socket.</p><p><strong>port</strong> is the local name to register, and is to be
the same as the port number that was previously bound to the
socket.</p><p>To unregister with EPMD, simply close the returned descriptor.</p><p>On success, a descriptor connecting the calling process to EPMD is
returned. On failure, <strong>-1</strong> is returned and
<strong>erl_errno</strong> is set to:</p><dl><dt><strong>EIO</strong></dt><dd>I/O error.</dd></dl><p>Also, <strong>errno</strong> values from
<strong>socket</strong><em>(2)</em>
and <strong>connect</strong><em>(2)</em> system calls can be
propagated into <strong>erl_errno</strong>.</p><h4>erl_receive(fd, bufp, bufsize):int</h4><p>Receive a message.</p><ul><li><span class="v">int fd;</span></li><li><span class="v">char *bufp;</span></li><li><span class="v">int bufsize;</span></li></ul><p>Receives a message consisting of a sequence
of bytes in the Erlang external format.</p><ul><li><strong>fd</strong> is an open descriptor to an Erlang connection.</li><li><strong>bufp</strong> is a buffer large enough to hold the expected message.</li><li><strong>bufsize</strong> indicates the size of <strong>bufp</strong>.</li></ul><p>If a <em>tick</em> occurs, that is, the Erlang node on the
other end of the connection has polled this node to see if it
is still alive, the function returns <strong>ERL_TICK</strong> and
no message is placed in the buffer. Also,
<strong>erl_errno</strong> is set to <strong>EAGAIN</strong>.</p><p>On success, the message is placed in the specified buffer
and the function returns the number of bytes actually read. On
failure, the function returns a negative value and sets
<strong>erl_errno</strong> to one of:</p><dl><dt><strong>EAGAIN</strong></dt><dd>Temporary error: Try again.</dd><dt><strong>EMSGSIZE</strong></dt><dd>Buffer is too small.</dd><dt><strong>EIO</strong></dt><dd>I/O error.</dd></dl><h4>erl_receive_msg(fd, bufp, bufsize, emsg):int</h4><p>Receive and decode a message.</p><ul><li><span class="v">int fd;</span></li><li><span class="v">unsigned char *bufp;</span></li><li><span class="v">int bufsize;</span></li><li><span class="v">ErlMessage *emsg;</span></li></ul><p>Receives the message into the specified buffer
and decodes into <strong>(ErlMessage *) emsg</strong>.</p><ul><li><strong>fd</strong> is an open descriptor to an Erlang connection.</li><li><strong>bufp</strong> is a buffer large enough to hold the expected message.</li><li><strong>bufsize</strong> indicates the size of <strong>bufp</strong>.</li><li>&gt;<strong>emsg</strong> is a pointer to an <strong>ErlMessage</strong> structure into which the message will be decoded. <strong>ErlMessage</strong> is defined as follows:</li></ul><pre><code class="">
typedef struct {
  int type;
  ETERM *msg;
  ETERM *to;
  ETERM *from;
  char to_name[MAXREGLEN];
} ErlMessage;
        </code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The definition of <strong>ErlMessage</strong> has changed since
earlier versions of <strong>Erl_Interface</strong>.</p></div><p><strong>type</strong> identifies the type of message, one of the
following:</p><dl><dt><strong>ERL_SEND</strong></dt><dd> <p>An ordinary send operation has occurred and
<strong>emsg-&gt;to</strong> contains the pid of the recipient.
The message is in <strong>emsg-&gt;msg</strong>.</p> </dd><dt><strong>ERL_REG_SEND</strong></dt><dd> <p>A registered send operation has occurred and
<strong>emsg-&gt;from</strong> contains the pid of the sender.
The message is in <strong>emsg-&gt;msg</strong>.</p> </dd><dt><strong>ERL_LINK</strong> or <strong>ERL_UNLINK</strong> </dt><dd> <p><strong>emsg-&gt;to</strong> and <strong>emsg-&gt;from</strong>
contain the pids of the sender and recipient of the link or
unlink. <strong>emsg-&gt;msg</strong> is not used.</p> </dd><dt><strong>ERL_EXIT</strong></dt><dd> <p>A link is broken. <strong>emsg-&gt;to</strong> and
<strong>emsg-&gt;from</strong> contain the pids of the linked
processes, and <strong>emsg-&gt;msg</strong> contains the reason
for the exit.</p> </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>It is the caller's responsibility to release the
memory pointed to by <strong>emsg-&gt;msg</strong>,
<strong>emsg-&gt;to</strong>, and
<strong>emsg-&gt;from</strong>.</p></div><p>If a <em>tick</em> occurs, that is, the Erlang node on the
other end of the connection has polled this node to see if it
is still alive, the function returns <strong>ERL_TICK</strong>
indicating that the tick has been received and responded to,
but no message is placed in the buffer. In this case you
are to call <strong>erl_receive_msg()</strong> again.</p><p>On success, the function returns <strong>ERL_MSG</strong> and the
<strong>Emsg</strong> struct is initialized as described above, or
<strong>ERL_TICK</strong>, in which case no message is returned. On
failure, the function returns <strong>ERL_ERROR</strong> and sets
<strong>erl_errno</strong> to one of:</p><dl><dt><strong>EMSGSIZE</strong></dt><dd>Buffer is too small.</dd><dt><strong>ENOMEM</strong></dt><dd>No more memory is available.</dd><dt><strong>EIO</strong></dt><dd>I/O error.</dd></dl><h4>erl_reg_send(fd, to, msg):int</h4><p>Send a message to a registered name.</p><ul><li><span class="v">int fd;</span></li><li><span class="v">char *to;</span></li><li><span class="v">ETERM *msg;</span></li></ul><p>Sends an Erlang term to a registered process.</p><ul><li><strong>fd</strong> is an open descriptor to an Erlang connection.</li><li><strong>to</strong> is a string containing the registered name of the intended recipient of the message.</li><li><strong>msg</strong> is the Erlang term to be sent.</li></ul><p>Returns <strong>1</strong> on success, otherwise <strong>0</strong>. In
the latter case <strong>erl_errno</strong> is set to one of:</p><dl><dt><strong>ENOMEM</strong></dt><dd>No more memory is available.</dd><dt><strong>EIO</strong></dt><dd>I/O error.</dd></dl><h4>erl_rpc(fd, mod, fun, args):ETERM *</h4><h4>erl_rpc_from(fd, timeout, emsg):int</h4><h4>erl_rpc_to(fd, mod, fun, args):int</h4><p>Remote Procedure Call.</p><ul><li><span class="v">int fd, timeout;</span></li><li><span class="v">char *mod, *fun;</span></li><li><span class="v">ETERM *args;</span></li><li><span class="v">ErlMessage *emsg;</span></li></ul><p>Supports calling Erlang functions on remote nodes.
<strong>erl_rpc_to()</strong> sends an RPC request to a remote node
and <strong>erl_rpc_from()</strong> receives the results of such a
call. <strong>erl_rpc()</strong> combines the functionality of
these two functions by sending an RPC request and waiting for the
results. See also <a href="../kernel/rpc#call/4">kernel/rpc#call/4</a> in <strong>Kernel</strong>.</p><ul><li><strong>fd</strong> is an open descriptor to an Erlang connection.</li><li><strong>timeout</strong> is the maximum time (in milliseconds) to wait for results. To wait forever, specify <strong>ERL_NO_TIMEOUT</strong>. When <strong>erl_rpc()</strong> calls <strong>erl_rpc_from()</strong>, the call will never timeout.</li><li><strong>mod</strong> is the name of the module containing the function to be run on the remote node.</li><li><strong>fun</strong> is the name of the function to run. </li><li><strong>args</strong> is an Erlang list, containing the arguments to be passed to the function.</li><li><strong>emsg</strong> is a message containing the result of the function call.</li></ul><p>The actual message returned by the RPC server
is a 2-tuple <strong>{rex,Reply}</strong>. If you use
<strong>erl_rpc_from()</strong> in your code, this is the message
you will need to parse. If you use <strong>erl_rpc()</strong>, the
tuple itself is parsed for you, and the message returned to your
program is the Erlang term containing <strong>Reply</strong> only.
Replies to RPC requests are always <strong>ERL_SEND</strong> messages.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>It is the caller's responsibility to free the returned
<strong>ETERM</strong> structure and the memory pointed to by
<strong>emsg-&gt;msg</strong> and <strong>emsg-&gt;to</strong>.</p></div><p><strong>erl_rpc()</strong> returns the remote function's return
value on success, otherwise <strong>NULL</strong>.</p><p><strong>erl_rpc_to()</strong> returns <strong>0</strong> on
success, otherwise a negative number.</p><p><strong>erl_rcp_from()</strong> returns <strong>ERL_MSG</strong>
on success (with <strong>Emsg</strong> now
containing the reply tuple), otherwise one of
<strong>ERL_TICK</strong>, <strong>ERL_TIMEOUT</strong>, or
<strong>ERL_ERROR</strong>.</p><p>When failing,
all three functions set <strong>erl_errno</strong> to one of:</p><dl><dt><strong>ENOMEM</strong></dt><dd>No more memory is available.</dd><dt><strong>EIO</strong></dt><dd>I/O error.</dd><dt><strong>ETIMEDOUT</strong></dt><dd>Timeout has expired.</dd><dt><strong>EAGAIN</strong></dt><dd>Temporary error: Try again.</dd></dl><h4>erl_send(fd, to, msg):int</h4><p>Send a message.</p><ul><li><span class="v">int fd;</span></li><li><span class="v">ETERM *to, *msg;</span></li></ul><p>Sends an Erlang term to a process.</p><ul><li><strong>fd</strong> is an open descriptor to an Erlang connection.</li><li><strong>to</strong> is an Erlang term containing the pid of the intended recipient of the message.</li><li>&gt;<strong>msg</strong> is the Erlang term to be sent.</li></ul><p>Returns <strong>1</strong> on success, otherwise <strong>0</strong>. In
the latter case <strong>erl_errno</strong> is set to one of:</p><dl><dt><strong>EINVAL</strong></dt><dd>Invalid argument: <strong>to</strong> is not a valid Erlang pid.</dd><dt><strong>ENOMEM</strong></dt><dd>No more memory is available.</dd><dt><strong>EIO</strong></dt><dd>I/O error.</dd></dl><h4>erl_thisalivename():const char *</h4><h4>erl_thiscookie():const char *</h4><h4>erl_thiscreation():short</h4><h4>erl_thishostname():const char *</h4><h4>erl_thisnodename():const char *</h4><p>Retrieve some values.</p><p>Retrieves information about
the C-node. These values are initially set with
<strong>erl_connect_init()</strong> or
<strong>erl_connect_xinit()</strong>.</p><h4>erl_unpublish(alive):int</h4><p>Forcefully unpublish a node name.</p><ul><li><span class="v">char *alive;</span></li></ul><p>This function can be called by a process to unregister a
specified node from EPMD on the local host. This is, however, usually
not allowed, unless EPMD was started with flag
<strong>-relaxed_command_check</strong>, which it normally is not.</p><p>To unregister a node you have published, you should instead
close the descriptor that was returned by
<strong>ei_publish()</strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release.</p></div><p><strong>alive</strong> is the name of the node to unregister, that
is, the first component of the node name, without
<strong>@hostname</strong>.</p><p>If the node was successfully unregistered from EPMD, <strong>0</strong> is
returned, otherwise <strong>-1</strong> is returned and
<strong>erl_errno</strong> is set to <strong>EIO</strong>.</p><h4>erl_xreceive_msg(fd, bufpp, bufsizep, emsg):int</h4><p>Receive and decode a message.</p><ul><li><span class="v">int fd;</span></li><li><span class="v">unsigned char **bufpp;</span></li><li><span class="v">int *bufsizep;</span></li><li><span class="v">ErlMessage *emsg;</span></li></ul><p>Similar to <strong>erl_receive_msg</strong>. The difference is
that <strong>erl_xreceive_msg</strong> expects the buffer to
have been allocated by <strong>malloc</strong>, and reallocates it
if the received
message does not fit into the original buffer. Therefore
both buffer and buffer length are given as pointers; their values
can change by the call.</p><p>On success, the function returns <strong>ERL_MSG</strong> and the
<strong>Emsg</strong> struct is initialized as described above, or
<strong>ERL_TICK</strong>, in which case no message is returned. On
failure, the function returns <strong>ERL_ERROR</strong> and sets
<strong>erl_errno</strong> to one of:</p><dl><dt><strong>EMSGSIZE</strong></dt><dd>Buffer is too small.</dd><dt><strong>ENOMEM</strong></dt><dd>No more memory is available.</dd><dt><strong>EIO</strong></dt><dd>I/O error.</dd></dl><h4>erl_gethostbyaddr(addr, length, type):struct hostent *</h4><h4>erl_gethostbyaddr_r(addr, length, type, hostp, buffer, buflen, h_errnop):struct hostent *</h4><h4>erl_gethostbyname(name):struct hostent *</h4><h4>erl_gethostbyname_r(name, hostp, buffer, buflen, h_errnop):struct hostent *</h4><p>Name lookup functions.</p><ul><li><span class="v">const char *name;</span></li><li><span class="v">const char *addr;</span></li><li><span class="v">int length;</span></li><li><span class="v">int type;</span></li><li><span class="v">struct hostent *hostp;</span></li><li><span class="v">char *buffer;</span></li><li><span class="v">int buflen;</span></li><li><span class="v">int *h_errnop;</span></li></ul><p>Convenience functions for some common name lookup functions.</p><h4>Debug Information</h4><p>If a connection attempt fails, the following can be checked:</p><ul><li><strong>erl_errno</strong></li><li>That the correct cookie was used</li><li>That EPMD is running</li><li>That the remote Erlang node on the other side is running the same version of Erlang as the <strong>erl_interface</strong> library</li></ul><h3>erl_error</h3><p>Error print routines.</p><p>This module contains some error printing routines taken
from "Advanced Programming in the UNIX Environment"
by W. Richard Stevens.These functions are all called in the same manner as
<strong>printf()</strong>, that is, with a string containing format
specifiers followed by a list of corresponding arguments. All output from
these functions is to <strong>stderr</strong>.</p><h3>Functions</h3><h4>erl_err_msg(FormatStr, ... ):void</h4><p>Non-fatal error, and not system call error.</p><ul><li><span class="v">const char *FormatStr;</span></li></ul><p>The message provided by the caller is printed. This
function is simply a wrapper for <strong>fprintf()</strong>.</p><h4>erl_err_quit(FormatStr, ... ):void</h4><p>Fatal error, but not system call error.</p><ul><li><span class="v">const char *FormatStr;</span></li></ul><p>Use this function when a fatal error has occurred that
is not because of a system call. The message provided by the
caller is printed and the process terminates with exit
value <strong>1</strong>. This function does not return.</p><h4>erl_err_ret(FormatStr, ... ):void</h4><p>Non-fatal system call error.</p><ul><li><span class="v">const char *FormatStr;</span></li></ul><p>Use this function after a failed system call. The message
provided by the caller is printed followed by a string
describing the reason for failure.</p><h4>erl_err_sys(FormatStr, ... ):void</h4><p>Fatal system call error.</p><ul><li><span class="v">const char *FormatStr;</span></li></ul><p>Use this function after a failed system call. The message
provided by the caller is printed followed by a string
describing the reason for failure, and the process
terminates with exit value <strong>1</strong>. This function does not
return.</p><h4>Error Reporting</h4><p>Most functions in <strong>Erl_Interface</strong> report failures to the caller by
returning some otherwise meaningless value (typically
<strong>NULL</strong>
or a negative number). As this only tells you that things did not
go well, examine the error code in <strong>erl_errno</strong> if you
want to find out more about the failure.</p><h3>Functions</h3><h4>erl_errno:volatile int</h4><p>Variable <strong>erl_errno</strong> contains the Erl_Interface error number. You can change the value if you wish. </p><p><strong>erl_errno</strong> is initially (at program startup) zero
and is then set by many <strong>Erl_Interface</strong> functions on failure to
a non-zero error code to indicate what kind of error it
encountered. A successful function call can change
<strong>erl_errno</strong> (by calling some other function that
fails), but no function does never set it to zero. This means
that you cannot use <strong>erl_errno</strong> to see <em>if</em> a
function call failed. Instead, each function reports failure
in its own way (usually by returning a negative number or
<strong>NULL</strong>), in which case you can examine
<strong>erl_errno</strong> for details.</p><p><strong>erl_errno</strong> uses the error codes defined in your
system's <strong>&lt;errno.h&gt;</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><strong>erl_errno</strong> is a "modifiable lvalue" (just
like ISO C defines <strong>errno</strong> to be) rather than a
variable. This means it can be implemented as a macro
(expanding to, for example, <strong>*_erl_errno()</strong>).
For reasons of thread safety (or task safety), this is exactly what
we do on most platforms.</p></div><h3>erl_eterm</h3><p>Functions for Erlang term construction.</p><p>This module provides functions for creating and manipulating
Erlang terms.An Erlang term is represented by a C structure of type
<strong>ETERM</strong>. Applications should not reference any fields
in this structure directly, as it can be changed in future releases
to provide faster and more compact term storage. Instead,
applications should use the macros and functions provided.Each of the following macros takes a single <strong>ETERM</strong> pointer as an
argument. The macros return a non-zero value if the test is true,
otherwise <strong>0</strong>.<dl><dt><strong>ERL_IS_INTEGER(t)</strong></dt><dd>True if <strong>t</strong> is an integer.</dd><dt><strong>ERL_IS_UNSIGNED_INTEGER(t)</strong></dt><dd>True if <strong>t</strong> is an integer.</dd><dt><strong>ERL_IS_FLOAT(t)</strong></dt><dd>True if <strong>t</strong> is a floating point number.</dd><dt><strong>ERL_IS_ATOM(t)</strong></dt><dd>True if <strong>t</strong> is an atom.</dd><dt><strong>ERL_IS_PID(t)</strong></dt><dd>True if <strong>t</strong> is a pid (process identifier).</dd><dt><strong>ERL_IS_PORT(t)</strong></dt><dd>True if <strong>t</strong> is a port.</dd><dt><strong>ERL_IS_REF(t)</strong></dt><dd>True if <strong>t</strong> is a reference.</dd><dt><strong>ERL_IS_TUPLE(t)</strong></dt><dd>True if <strong>t</strong> is a tuple.</dd><dt><strong>ERL_IS_BINARY(t)</strong></dt><dd>True if <strong>t</strong> is a binary.</dd><dt><strong>ERL_IS_LIST(t)</strong></dt><dd>True if <strong>t</strong> is a list with zero or more elements.</dd><dt><strong>ERL_IS_EMPTY_LIST(t)</strong></dt><dd>True if <strong>t</strong> is an empty list.</dd><dt><strong>ERL_IS_CONS(t)</strong></dt><dd>True if <strong>t</strong> is a list with at least one element.</dd></dl>The following macros can be used for retrieving parts of Erlang
terms. None of these do any type checking. Results are undefined
if you pass an <strong>ETERM*</strong> containing the wrong type. For example,
passing a tuple to <strong>ERL_ATOM_PTR()</strong> likely results in garbage.<dl><dt><strong>char *ERL_ATOM_PTR(t)</strong></dt><dd></dd><dt><strong>char *ERL_ATOM_PTR_UTF8(t)</strong></dt><dd>A string representing atom <strong>t</strong>.</dd><dt><strong>int ERL_ATOM_SIZE(t)</strong></dt><dd></dd><dt><strong>int ERL_ATOM_SIZE_UTF8(t)</strong></dt><dd>The length (in bytes) of atom <strong>t</strong>.</dd><dt><strong>void *ERL_BIN_PTR(t)</strong></dt><dd>A pointer to the contents of <strong>t</strong>.</dd><dt><strong>int ERL_BIN_SIZE(t)</strong></dt><dd>The length (in bytes) of binary object <strong>t</strong>.</dd><dt><strong>int ERL_INT_VALUE(t)</strong></dt><dd>The integer of <strong>t</strong>.</dd><dt><strong>unsigned int ERL_INT_UVALUE(t)</strong></dt><dd>The unsigned integer value of <strong>t</strong>.</dd><dt><strong>double ERL_FLOAT_VALUE(t)</strong></dt><dd>The floating point value of <strong>t</strong>.</dd><dt><strong>ETERM *ERL_PID_NODE(t)</strong></dt><dd></dd><dt><strong>ETERM *ERL_PID_NODE_UTF8(t)</strong></dt><dd>The node in pid <strong>t</strong>.</dd><dt><strong>int ERL_PID_NUMBER(t)</strong></dt><dd>The sequence number in pid <strong>t</strong>.</dd><dt><strong>int ERL_PID_SERIAL(t)</strong></dt><dd>The serial number in pid <strong>t</strong>.</dd><dt><strong>int ERL_PID_CREATION(t)</strong></dt><dd>The creation number in pid <strong>t</strong>.</dd><dt><strong>int ERL_PORT_NUMBER(t)</strong></dt><dd>The sequence number in port <strong>t</strong>.</dd><dt><strong>int ERL_PORT_CREATION(t)</strong></dt><dd>The creation number in port <strong>t</strong>.</dd><dt><strong>ETERM *ERL_PORT_NODE(t)</strong></dt><dd></dd><dt><strong>ETERM *ERL_PORT_NODE_UTF8(t)</strong></dt><dd>The node in port <strong>t</strong>.</dd><dt><strong>int ERL_REF_NUMBER(t)</strong></dt><dd>The first part of the reference number in ref <strong>t</strong>. Use only for compatibility.</dd><dt><strong>int ERL_REF_NUMBERS(t)</strong></dt><dd>Pointer to the array of reference numbers in ref <strong>t</strong>.</dd><dt><strong>int ERL_REF_LEN(t)</strong></dt><dd>The number of used reference numbers in ref <strong>t</strong>.</dd><dt><strong>int ERL_REF_CREATION(t)</strong></dt><dd>The creation number in ref <strong>t</strong>.</dd><dt><strong>int ERL_TUPLE_SIZE(t)</strong></dt><dd>The number of elements in tuple <strong>t</strong>.</dd><dt><strong>ETERM *ERL_CONS_HEAD(t)</strong></dt><dd>The head element of list <strong>t</strong>.</dd><dt><strong>ETERM *ERL_CONS_TAIL(t)</strong></dt><dd>A list representing the tail elements of list <strong>t</strong>.</dd></dl></p><h3>Functions</h3><h4>erl_cons(head, tail):ETERM *</h4><p>Prepend a term to the head of a list.</p><ul><li><span class="v">ETERM *head;</span></li><li><span class="v">ETERM *tail;</span></li></ul><p>Concatenates two Erlang terms, prepending <strong>head</strong>
onto <strong>tail</strong> and thereby creating a
<strong>cons</strong> cell.
To make a proper list, <strong>tail</strong> is always to be a list
or an empty list. Notice that <strong>NULL</strong> is not a valid list.</p><ul><li><strong>head</strong> is the new term to be added.</li><li><strong>tail</strong> is the existing list to which <strong>head</strong> is concatenated.</li></ul><p>The function returns a new list.</p><p><strong>ERL_CONS_HEAD(list)</strong> and
<strong>ERL_CONS_TAIL(list)</strong>
can be used to retrieve the head and tail components
from the list. <strong>erl_hd(list)</strong> and
<strong>erl_tl(list)</strong> do
the same thing, but check that the argument really is a list.</p><p><em>Example:</em></p><pre><code class="">
ETERM *list,*anAtom,*anInt;
anAtom = erl_mk_atom("madonna");
anInt  = erl_mk_int(21);
list   = erl_mk_empty_list();
list   = erl_cons(anAtom, list);
list   = erl_cons(anInt, list);
 ... /* do some work */
erl_free_compound(list);
        </code></pre><h4>erl_copy_term(term):ETERM *</h4><p>Create a copy of an Erlang term.</p><ul><li><span class="v">ETERM *term;</span></li></ul><p>Creates and returns a copy of the Erlang term
<strong>term</strong>.</p><h4>erl_element(position, tuple):ETERM *</h4><p>Extract an element from an Erlang tuple.</p><ul><li><span class="v">int position;</span></li><li><span class="v">ETERM *tuple;</span></li></ul><p>Extracts a specified element from an Erlang tuple.</p><ul><li><strong>position</strong> specifies which element to retrieve from <strong>tuple</strong>. The elements are numbered starting from 1.</li><li><strong>tuple</strong> is an Erlang term containing at least <strong>position</strong> elements.</li></ul><p>Returns a new Erlang term corresponding to the requested element, or
<strong>NULL</strong> if <strong>position</strong> was greater
than the arity of <strong>tuple</strong>.</p><h4>erl_hd(list):ETERM *</h4><p>Extract the first element from a list.</p><ul><li><span class="v">ETERM *list;</span></li></ul><p>Extracts the first element from a list.</p><p><strong>list</strong> is an Erlang term containing a list.</p><p>Returns an Erlang term corresponding to the head
head element in the list, or a <strong>NULL</strong> pointer if
<strong>list</strong> was not a list.</p><h4>erl_init(NULL, 0):void</h4><p>Initialization routine.</p><ul><li><span class="v">void *NULL;</span></li><li><span class="v">int 0;</span></li></ul><p>This function must be called before any of the others in the
<strong>Erl_Interface</strong> library to initialize the
library functions. The arguments must be specified as
<strong>erl_init(NULL,0)</strong>.</p><h4>erl_iolist_length(list):int</h4><p>Return the length of an I/O list.</p><ul><li><span class="v">ETERM *list;</span></li></ul><p>Returns the length of an I/O list.</p><p><strong>list</strong> is an Erlang term containing an I/O list.</p><p>Returns the length of <strong>list</strong>, or
<strong>-1</strong> if <strong>list</strong> is not an I/O list.</p><p>For the definition of an I/O list, see
<a href="#erl_iolist_to_binary">erl_iolist_to_binary</a>.</p><h4>erl_iolist_to_binary(term):ETERM *</h4><p>Convert an I/O list to a binary.</p><ul><li><span class="v">ETERM *list;</span></li></ul><p>Converts an I/O list to a binary term.</p><p><strong>list</strong> is an Erlang term containing a list.</p><p>Returns an Erlang binary term, or <strong>NULL</strong> if
<strong>list</strong> was not an I/O list.</p><p>Informally, an I/O list is a deep list of characters and
binaries that can be sent to an Erlang port. In BNF, an I/O
list is formally defined as follows:</p><pre><code class="">
iolist ::= []
        |   Binary
        |   [iohead | iolist]
        ;
iohead ::= Binary
        |   Byte (integer in the range [0..255])
        |   iolist
        ;
        </code></pre><h4>erl_iolist_to_string(list):char *</h4><p>Convert an I/O list to a <strong>NULL</strong>-terminated string.</p><ul><li><span class="v">ETERM *list;</span></li></ul><p>Converts an I/O list to a <strong>NULL</strong>-terminated C string.</p><p><strong>list</strong> is an Erlang term containing an I/O list.
The I/O list must not contain the integer 0, as C strings may not
contain this value except as a terminating marker.</p><p>Returns a pointer to a dynamically allocated
buffer containing a string. If <strong>list</strong> is not an I/O
list, or if <strong>list</strong> contains the integer 0,
<strong>NULL</strong> is returned. It
is the caller's responsibility to free the allocated buffer
with <strong>erl_free()</strong>.</p><p>For the definition of an I/O list, see
<a href="#erl_iolist_to_binary">erl_iolist_to_binary</a>.</p><h4>erl_length(list):int</h4><p>Determine the length of a list.</p><ul><li><span class="v">ETERM *list;</span></li></ul><p>Determines the length of a proper list.</p><p><strong>list</strong> is an Erlang term containing a proper list.
In a proper list, all tails except the last point to another list
cell, and the last tail points to an empty list.</p><p>Returns <strong>-1</strong> if <strong>list</strong> is not a proper
list.</p><h4>erl_mk_atom(string):ETERM *</h4><p>Create an atom.</p><ul><li><span class="v">const char *string;</span></li></ul><p>Creates an atom.</p><p><strong>string</strong> is the sequence of characters that will be
used to create the atom.</p><p>Returns an Erlang term containing an atom. Notice that it is
the caller's responsibility to ensure that <strong>string</strong>
contains a valid name for an atom.</p><p><strong>ERL_ATOM_PTR(atom)</strong> and
<strong>ERL_ATOM_PTR_UTF8(atom)</strong>
can be used to retrieve the atom name (as a <strong>NULL</strong>-terminated string).
<strong>ERL_ATOM_SIZE(atom)</strong>
and <strong>ERL_ATOM_SIZE_UTF8(atom)</strong> return the length
of the atom name.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The UTF-8 variants were introduced in Erlang/OTP R16 and the
string returned by <strong>ERL_ATOM_PTR(atom)</strong> was not
<strong>NULL</strong>-terminated on older releases.</p></div><h4>erl_mk_binary(bptr, size):ETERM *</h4><p>Create a binary object.</p><ul><li><span class="v">char *bptr;</span></li><li><span class="v">int size;</span></li></ul><p>Produces an Erlang binary object from a
buffer containing a sequence of bytes.</p><ul><li><strong>bptr</strong> is a pointer to a buffer containing data to be converted.</li><li><strong>size</strong> indicates the length of <strong>bptr</strong>.</li></ul><p>Returns an Erlang binary object.</p><p><strong>ERL_BIN_PTR(bin)</strong> retrieves a pointer to
the binary data. <strong>ERL_BIN_SIZE(bin)</strong> retrieves the
size.</p><h4>erl_mk_empty_list():ETERM *</h4><p>Create an empty Erlang list.</p><p>Creates and returns an empty Erlang list.
Notice that <strong>NULL</strong> is not used to represent an empty list;
Use this function instead.</p><h4>erl_mk_estring(string, len):ETERM *</h4><p>Create an Erlang string.</p><ul><li><span class="v">char *string;</span></li><li><span class="v">int len;</span></li></ul><p>Creates a list from a sequence of bytes.</p><ul><li><strong>string</strong> is a buffer containing a sequence of bytes. The buffer does not need to be <strong>NULL</strong>-terminated.</li><li><strong>len</strong> is the length of <strong>string</strong>.</li></ul><p>Returns an Erlang list object corresponding to
the character sequence in <strong>string</strong>.</p><h4>erl_mk_float(f):ETERM *</h4><p>Create an Erlang float.</p><ul><li><span class="v">double f;</span></li></ul><p>Creates an Erlang float.</p><p><strong>f</strong> is a value to be converted to an Erlang
float.</p><p>Returns an Erlang float object with the value
specified in <strong>f</strong> or <strong>NULL</strong> if
<strong>f</strong> is not finite.</p><p><strong>ERL_FLOAT_VALUE(t)</strong> can be used to retrieve the
value from an Erlang float.</p><h4>erl_mk_int(n):ETERM *</h4><p>Create an Erlang integer.</p><ul><li><span class="v">int n;</span></li></ul><p>Creates an Erlang integer.</p><p><strong>n</strong> is a value to be converted to an Erlang
integer.</p><p>Returns an Erlang integer object with the
value specified in <strong>n</strong>.</p><p><strong>ERL_INT_VALUE(t)</strong> can be used to retrieve the
value from an Erlang integer.</p><h4>erl_mk_list(array, arrsize):ETERM *</h4><p>Create a list from an array.</p><ul><li><span class="v">ETERM **array;</span></li><li><span class="v">int arrsize;</span></li></ul><p>Creates an Erlang list from an array of Erlang terms, such
that each element in the list corresponds to one element in
the array.</p><ul><li><strong>array</strong> is an array of Erlang terms.</li><li><strong>arrsize</strong> is the number of elements in <strong>array</strong>.</li></ul><p>The function creates an Erlang list object, whose length
<strong>arrsize</strong> and whose elements are taken from the
terms in <strong>array</strong>.</p><h4>erl_mk_long_ref(node, n1, n2, n3, creation):ETERM *</h4><p>Create an Erlang reference.</p><ul><li><span class="v">const char *node;</span></li><li><span class="v">unsigned int n1, n2, n3;</span></li><li><span class="v">unsigned int creation;</span></li></ul><p>Creates an Erlang reference, with 82 bits.</p><ul><li><strong>node</strong> is the name of the C-node.</li><li><strong>n1</strong>, <strong>n2</strong>, and <strong>n3</strong> can be seen as one big number <strong>n1*2^64+n2*2^32+n3</strong>, which is to be chosen uniquely for each reference created for a given C-node.</li><li><strong>creation</strong> is an arbitrary number.</li></ul><p>Notice that <strong>n3</strong> and <strong>creation</strong>
are limited in precision, so only the low 18 and 2 bits of these
numbers are used.</p><p>Returns an Erlang reference object.</p><p><strong>ERL_REF_NODE(ref)</strong>,
<strong>ERL_REF_NUMBERS(ref)</strong>,
<strong>ERL_REF_LEN(ref)</strong>, and
<strong>ERL_REF_CREATION(ref)</strong> can be used to retrieve the
values used to create the reference.</p><h4>erl_mk_pid(node, number, serial, creation):ETERM *</h4><p>Create a process identifier.</p><ul><li><span class="v">const char *node;</span></li><li><span class="v">unsigned int number;</span></li><li><span class="v">unsigned int serial;</span></li><li><span class="v">unsigned int creation;</span></li></ul><p>Creates an Erlang process identifier (pid). The
resulting pid can be used by Erlang processes wishing to
communicate with the C-node.</p><ul><li><strong>node</strong> is the name of the C-node.</li><li><strong>number</strong>, <strong>serial</strong>, and <strong>creation</strong> are arbitrary numbers. Notice that these are limited in precision, so only the low 15, 3, and 2 bits of these numbers are used.</li></ul><p>Returns an Erlang pid object.</p><p><strong>ERL_PID_NODE(pid)</strong>,
<strong>ERL_PID_NUMBER(pid)</strong>,
<strong>ERL_PID_SERIAL(pid)</strong>, and
<strong>ERL_PID_CREATION(pid)</strong>
can be used to retrieve the four values used to create the pid.</p><h4>erl_mk_port(node, number, creation):ETERM *</h4><p>Create a port identifier.</p><ul><li><span class="v">const char *node;</span></li><li><span class="v">unsigned int number;</span></li><li><span class="v">unsigned int creation;</span></li></ul><p>Creates an Erlang port identifier.</p><ul><li><strong>node</strong> is the name of the C-node.</li><li><strong>number</strong> and <strong>creation</strong> are arbitrary numbers. Notice that these are limited in precision, so only the low 18 and 2 bits of these numbers are used.</li></ul><p>Returns an Erlang port object.</p><p><strong>ERL_PORT_NODE(port)</strong>,
<strong>ERL_PORT_NUMBER(port)</strong>,
and <strong>ERL_PORT_CREATION</strong> can be used to retrieve the
three values used to create the port.</p><h4>erl_mk_ref(node, number, creation):ETERM *</h4><p>Create an old Erlang reference.</p><ul><li><span class="v">const char *node;</span></li><li><span class="v">unsigned int number;</span></li><li><span class="v">unsigned int creation;</span></li></ul><p>Creates an old Erlang reference, with
only 18 bits - use <strong>erl_mk_long_ref</strong> instead.</p><ul><li><strong>node</strong> is the name of the C-node.</li><li><strong>number</strong> is to be chosen uniquely for each reference created for a given C-node.</li><li><strong>creation</strong> is an arbitrary number.</li></ul><p>Notice that <strong>number</strong> and <strong>creation</strong>
are limited in precision, so only the low 18 and 2 bits of these
numbers are used.</p><p>Returns an Erlang reference object.</p><p><strong>ERL_REF_NODE(ref)</strong>,
<strong>ERL_REF_NUMBER(ref)</strong>, and
<strong>ERL_REF_CREATION(ref)</strong> can be used to retrieve the
three values used to create the reference.</p><h4>erl_mk_string(string):ETERM *</h4><p>Create a string.</p><ul><li><span class="v">char *string;</span></li></ul><p>Creates a list from a <strong>NULL</strong>-terminated string.</p><p><strong>string</strong> is a <strong>NULL</strong>-terminated sequence of
characters
(that is, a C string) from which the list will be created.</p><p>Returns an Erlang list.</p><h4>erl_mk_tuple(array, arrsize):ETERM *</h4><p>Create an Erlang tuple from an array.</p><ul><li><span class="v">ETERM **array;</span></li><li><span class="v">int arrsize;</span></li></ul><p>Creates an Erlang tuple from an array of Erlang terms.</p><ul><li><strong>array</strong> is an array of Erlang terms.</li><li><strong>arrsize</strong> is the number of elements in <strong>array</strong>.</li></ul><p>The function creates an Erlang tuple, whose arity is
<strong>size</strong> and whose elements are taken from the terms
in <strong>array</strong>.</p><p>To retrieve the size of a tuple, either use function
<strong>erl_size</strong> (which checks the type of the
checked term and works for a binary as well as for a tuple) or
<strong>ERL_TUPLE_SIZE(tuple)</strong> returns the arity of a tuple.
<strong>erl_size()</strong> does the same thing, but it checks
that the argument is a tuple.
<strong>erl_element(index,tuple)</strong> returns the element
corresponding to a given position in the tuple.</p><h4>erl_mk_uint(n):ETERM *</h4><p>Create an unsigned integer.</p><ul><li><span class="v">unsigned int n;</span></li></ul><p>Creates an Erlang unsigned integer.</p><p><strong>n</strong> is a value to be converted to an Erlang
unsigned integer.</p><p>Returns an Erlang unsigned integer object with
the value specified in <strong>n</strong>.</p><p><strong>ERL_INT_UVALUE(t)</strong> can be used to retrieve the
value from an Erlang unsigned integer.</p><h4>erl_mk_var(name):ETERM *</h4><p>Create an Erlang variable.</p><ul><li><span class="v">char *name;</span></li></ul><p>Creates an unbound Erlang variable. The variable can later be bound
through pattern matching or assignment.</p><p><strong>name</strong> specifies a name for the variable.</p><p>Returns an Erlang variable object with the
name <strong>name</strong>.</p><h4>erl_print_term(stream, term):int</h4><p>Print an Erlang term.</p><ul><li><span class="v">FILE *stream;</span></li><li><span class="v">ETERM *term;</span></li></ul><p>Prints the specified Erlang term to the specified output stream.</p><ul><li><strong>stream</strong> indicates where the function is to send its output.</li><li><strong>term</strong> is the Erlang term to print.</li></ul><p>Returns the number of characters written on success, otherwise a
negative value.</p><h4>erl_set_compat_rel(release_number):void</h4><p>Set the Erl_Interface library in compatibility mode.</p><ul><li><span class="v">unsigned release_number;</span></li></ul><p>By default, the <strong>Erl_Interface</strong> library is only
guaranteed to be compatible with other Erlang/OTP components from the
same release as the <strong>Erl_Interface</strong> library itself.
For example, <strong>Erl_Interface</strong> from Erlang/OTP R10
is not compatible
with an Erlang emulator from Erlang/OTP R9 by default.</p><p>A call to <strong>erl_set_compat_rel(release_number)</strong> sets
the <strong>Erl_Interface</strong> library in compatibility mode of
release <strong>release_number</strong>. Valid range of
<strong>release_number</strong>
is [7, current release]. This makes it possible to
communicate with Erlang/OTP components from earlier releases.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If this function is called, it may only be called once
directly after the call to function
<a href="#erl_init">erl_init()</a>.</p></div><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>You may run into trouble if this feature is used
carelessly. Always ensure that all communicating
components are either from the same Erlang/OTP release, or
from release X and release Y where all components
from release Y are in compatibility mode of release X.</p></div><h4>erl_size(term):int</h4><p>Return the arity of a tuple or binary.</p><ul><li><span class="v">ETERM *term;</span></li></ul><p>Returns either the arity of an Erlang tuple or the
number of bytes in an Erlang binary object.</p><p><strong>term</strong> is an Erlang tuple or an Erlang binary
object.</p><p>Returns the size of <strong>term</strong> as described
above, or <strong>-1</strong> if <strong>term</strong> is not one of the two
supported types.</p><h4>erl_tl(list):ETERM *</h4><p>Extract the tail from a list.</p><ul><li><span class="v">ETERM *list;</span></li></ul><p>Extracts the tail from a list.</p><p><strong>list</strong> is an Erlang term containing a list.</p><p>Returns an Erlang list corresponding to the
original list minus the first element, or <strong>NULL</strong> pointer if
<strong>list</strong> was not a list.</p><h4>erl_var_content(term, name):ETERM *</h4><p>Extract the content of a variable.</p><ul><li><span class="v">ETERM *term;</span></li><li><span class="v">char *name;</span></li></ul><p>Returns the contents of the specified variable in an Erlang term.</p><ul><li><strong>term</strong> is an Erlang term. In order for this function to succeed, <strong>term</strong> must either be an Erlang variable with the specified name, or it must be an Erlang list or tuple containing a variable with the specified name. Other Erlang types cannot contain variables.</li><li><strong>name</strong> is the name of an Erlang variable. </li></ul><p>Returns the Erlang object corresponding to the value of
<strong>name</strong> in <strong>term</strong>. If no variable
with the name <strong>name</strong> is found in
<strong>term</strong>, or if <strong>term</strong> is
not a valid Erlang term, <strong>NULL</strong> is returned.</p><h3>erl_format</h3><p>Create and match Erlang terms.</p><p>This module contains two routines: one general function for
creating Erlang terms and one for pattern matching Erlang terms.</p><h3>Functions</h3><h4>erl_format(FormatStr, ...):ETERM *</h4><p>Create an Erlang term.</p><ul><li><span class="v">char *FormatStr;</span></li></ul><p>A general function for creating Erlang terms using
a format specifier and a corresponding set of arguments, much
in the way <strong>printf()</strong> works.</p><p><strong>FormatStr</strong> is a format specification string.
The valid format specifiers are as follows:</p><ul><li><strong>~i</strong> - Integer</li><li><strong>~f</strong> - Floating point</li><li><strong>~a</strong> - Atom</li><li><strong>~s</strong> - String</li><li><strong>~w</strong> - Arbitrary Erlang term</li></ul><p>For each format specifier included in <strong>FormatStr</strong>,
there must be a corresponding argument following
<strong>FormatStr</strong>. An Erlang term is built according to
<strong>FormatStr</strong> with values and Erlang terms substituted
from the corresponding arguments, and according to the individual
format specifiers. For example:</p><pre><code class="">
erl_format("[{name,~a},{age,~i},{data,~w}]",
           "madonna",
           21,
           erl_format("[{adr,~s,~i}]","E-street",42));
        </code></pre><p>This creates an <strong>(ETERM *)</strong> structure corresponding
to the Erlang term
<strong>[{name,madonna},{age,21},{data,[{adr,"E-street",42}]}]</strong></p><p>The function returns an Erlang term, or <strong>NULL</strong> if
<strong>FormatStr</strong> does not describe a valid Erlang
term.</p><h4>erl_match(Pattern, Term):int</h4><p>Perform pattern matching.</p><ul><li><span class="v">ETERM *Pattern,*Term;</span></li></ul><p>This function is used to perform pattern matching similar
to that done in Erlang. For matching rules and more examples, see
section <a href="./patterns"> Pattern Matching</a> in the Erlang Reference Manual.</p><ul><li><strong>Pattern</strong> is an Erlang term, possibly containing unbound variables.</li><li><strong>Term</strong> is an Erlang term that we wish to match against <strong>Pattern</strong>.</li></ul><p><strong>Term</strong> and <strong>Pattern</strong> are compared
and any unbound variables in <strong>Pattern</strong> are bound to
corresponding values in <strong>Term</strong>.</p><p>If <strong>Term</strong> and <strong>Pattern</strong> can be
matched, the function returns a non-zero value and binds any unbound
variables in <strong>Pattern</strong>. If <strong>Term</strong>
and <strong>Pattern</strong> do
not match, <strong>0</strong> is returned. For example:</p><pre><code class="">
ETERM *term, *pattern, *pattern2;
term1    = erl_format("{14,21}");
term2    = erl_format("{19,19}");
pattern1 = erl_format("{A,B}");
pattern2 = erl_format("{F,F}");
if (erl_match(pattern1, term1)) {
  /* match succeeds:
   * A gets bound to 14, 
   * B gets bound to 21 
   */
  ...  
}
if (erl_match(pattern2, term1)) {
  /* match fails because F cannot be 
   * bound to two separate values, 14 and 21
   */
  ...
}
if (erl_match(pattern2, term2)) {
  /* match succeeds and F gets bound to 19 */
  ...
}
        </code></pre><p><strong>erl_var_content()</strong> can be used to retrieve the
content of any variables bound as a result of a call to
<strong>erl_match()</strong>.</p><h3>erl_global</h3><p>Access globally registered names.</p><p>This module provides support for registering, looking
up, and unregistering names in the <strong>global</strong> module.
For more information, see
<a href="./global">kernel/global</a>.Notice that the functions below perform an RPC using an open file
descriptor provided by the caller. This file descriptor must
not be used for other traffic during the global operation, as the
function can then receive unexpected data and fail.</p><h3>Functions</h3><h4>erl_global_names(fd,count):char **</h4><p>Obtain list of global names.</p><ul><li><span class="v">int fd;</span></li><li><span class="v">int *count;</span></li></ul><p>Retrieves a list of all known global names.</p><ul><li><strong>fd</strong> is an open descriptor to an Erlang connection.</li><li><strong>count</strong> is the address of an integer, or <strong>NULL</strong>. If <strong>count</strong> is not <strong>NULL</strong>, it is set by the function to the number of names found.</li></ul><p>On success, the function returns an array of strings, each
containing a single registered name, and sets
<strong>count</strong> to
the number of names found. The array is terminated
by a single <strong>NULL</strong> pointer. On failure, the function returns
<strong>NULL</strong> and <strong>count</strong> is not modified.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>It is the caller's responsibility to free the array
afterwards. It has been allocated by the function with a
single call to <strong>malloc()</strong>, so a single
<strong>free()</strong> is all that is necessary.</p></div><h4>erl_global_register(fd,name,pid):int</h4><p>Register a name in global.</p><ul><li><span class="v">int fd;</span></li><li><span class="v">const char *name;</span></li><li><span class="v">ETERM *pid;</span></li></ul><p>Registers a name in <strong>global</strong>.</p><ul><li><strong>fd</strong> is an open descriptor to an Erlang connection.</li><li><strong>name</strong> is the name to register in <strong>global</strong>.</li><li><strong>pid</strong> is the pid that is to be associated with <strong>name</strong>. This value is returned by <strong>global</strong> when processes request the location of <strong>name</strong>. </li></ul><p>Returns <strong>0</strong> on success, otherwise <strong>-1</strong>.</p><h4>erl_global_unregister(fd,name):int</h4><p>Unregister a name from global.</p><ul><li><span class="v">int fd;</span></li><li><span class="v">const char *name;</span></li></ul><p>Unregisters a name from <strong>global</strong>.</p><ul><li><strong>fd</strong> is an open descriptor to an Erlang connection.</li><li><strong>name</strong> is the name to unregister from <strong>global</strong>.</li></ul><p>Returns <strong>0</strong> on success, otherwise <strong>-1</strong>.</p><h4>erl_global_whereis(fd,name,node):ETERM *</h4><p>Look up a name in global.</p><ul><li><span class="v">int fd;</span></li><li><span class="v">const char *name;</span></li><li><span class="v">char *node;</span></li></ul><p>Looks up a name in <strong>global</strong>.</p><ul><li><strong>fd</strong> is an open descriptor to an Erlang connection.</li><li><strong>name</strong> is the name that is to be looked up in <strong>global</strong>.</li></ul><p>If <strong>node</strong> is not <strong>NULL</strong>, it is a pointer to a
buffer where the function can fill in the name of the node where
<strong>name</strong> is found. <strong>node</strong> can be
passed directly to <strong>erl_connect()</strong> if necessary.</p><p>On success, the function returns an Erlang pid containing the address
of the specified name, and the node is initialized to
the node name where <strong>name</strong> is found. On failure,
<strong>NULL</strong> is returned and <strong>node</strong> is not
modified.</p><h3>erl_malloc</h3><p>Memory allocation functions.</p><p>This module provides functions for allocating and deallocating
memory.</p><h3>Functions</h3><h4>erl_alloc_eterm(etype):ETERM *</h4><p>Allocate an ETERM structure.</p><ul><li><span class="v">unsigned char etype;</span></li></ul><p>Allocates an <strong>(ETERM)</strong> structure.</p><p>Specify <strong>etype</strong> as one of the following
constants:</p><ul><li><strong>ERL_INTEGER</strong> </li><li><strong>ERL_U_INTEGER</strong> (unsigned integer) </li><li><strong>ERL_ATOM</strong> </li><li><strong>ERL_PID</strong> (Erlang process identifier) </li><li><strong>ERL_PORT</strong> </li><li><strong>ERL_REF</strong> (Erlang reference) </li><li><strong>ERL_LIST</strong> </li><li><strong>ERL_EMPTY_LIST</strong> </li><li><strong>ERL_TUPLE</strong> </li><li><strong>ERL_BINARY</strong> </li><li><strong>ERL_FLOAT</strong> </li><li><strong>ERL_VARIABLE</strong> </li><li><strong>ERL_SMALL_BIG</strong> (bignum) </li><li><strong>ERL_U_SMALL_BIG</strong> (bignum) </li></ul><p><strong>ERL_SMALL_BIG</strong> and
<strong>ERL_U_SMALL_BIG</strong> are for
creating Erlang <strong>bignums</strong>, which can contain integers
of any size. The size of an integer in Erlang is machine-dependent,
but any integer &gt; 2^28 requires a bignum.</p><h4>erl_eterm_release(void):void</h4><p>Clear the ETERM freelist.</p><p>Clears the freelist, where blocks are placed when they are
released by <strong>erl_free_term()</strong> and
<strong>erl_free_compound()</strong>.</p><h4>erl_eterm_statistics(allocated, freed):void</h4><p>Report term allocation statistics.</p><ul><li><span class="v">long *allocated;</span></li><li><span class="v">long *freed;</span></li></ul><p>Reports term allocation statistics.</p><p><strong>allocated</strong> and <strong>freed</strong> are
initialized to
contain information about the fix-allocator used to allocate
<strong>ETERM</strong> components.</p><ul><li> <p><strong>allocated</strong> is the number of blocks currently
allocated to <strong>ETERM</strong> objects.</p> </li><li> <p><strong>freed</strong> is the length of the freelist, where
blocks are placed when they are
released by <strong>erl_free_term()</strong> and
<strong>erl_free_compound()</strong>.</p> </li></ul><h4>erl_free(ptr):void</h4><p>Free some memory.</p><ul><li><span class="v">void *ptr;</span></li></ul><p>Calls the standard
<strong>free()</strong> function.</p><h4>erl_free_array(array, size):void</h4><p>Free an array of ETERM structures.</p><ul><li><span class="v">ETERM **array;</span></li><li><span class="v">int size;</span></li></ul><p>Frees an array of Erlang terms.</p><ul><li><strong>array</strong> is an array of ETERM* objects.</li><li><strong>size</strong> is the number of terms in the array. </li></ul><h4>erl_free_compound(t):void</h4><p>Free an array of ETERM structures.</p><ul><li><span class="v">ETERM *t;</span></li></ul><p>Normally it is the programmer's responsibility to free each
Erlang term that has been returned from any of the
<strong>Erl_Interface</strong> functions. However, as many of the
functions that build new Erlang terms in fact share objects
with other existing terms, it can be difficult for the
programmer to maintain pointers to all such terms to
free them individually.</p><p><strong>erl_free_compound()</strong> recursively frees all of the
subterms associated with a specified Erlang term, regardless of
whether we are still holding pointers to the subterms.</p><p>For an example, see section
<a href="./ei_users_guide#building_terms_and_patterns">Building Terms and Patterns</a>
in the User's Guide.</p><h4>erl_free_term(t):void</h4><p>Free an ETERM structure.</p><ul><li><span class="v">ETERM *t;</span></li></ul><p>Frees an Erlang term.</p><h4>erl_malloc(size):void</h4><p>Allocate some memory.</p><ul><li><span class="v">long size;</span></li></ul><p>Calls the standard
<strong>malloc()</strong> function.</p><h3>erl_marshal</h3><p>Encoding and decoding of Erlang terms.</p><p>This module contains functions for encoding Erlang terms into
a sequence of bytes, and for decoding Erlang terms from a
sequence of bytes.</p><h3>Functions</h3><h4>erl_compare_ext(bufp1, bufp2):int</h4><p>Compare encoded byte sequences.</p><ul><li><span class="v">unsigned char *bufp1,*bufp2;</span></li></ul><p>Compares two encoded terms.</p><ul><li><strong>bufp1</strong> is a buffer containing an encoded Erlang term term1.</li><li><strong>bufp2</strong> is a buffer containing an encoded Erlang term term2.</li></ul><p>Returns <strong>0</strong> if the terms are equal, <strong>-1</strong> if
<strong>term1</strong> &lt; <strong>term2</strong>, or <strong>1</strong> if <strong>term2</strong> &lt;
<strong>term1</strong>.</p><h4>erl_decode(bufp):ETERM *</h4><h4>erl_decode_buf(bufpp):ETERM *</h4><p>Convert a term from Erlang external format.</p><ul><li><span class="v">unsigned char *bufp;</span></li><li><span class="v">unsigned char **bufpp;</span></li></ul><p><strong>erl_decode()</strong> and
<strong>erl_decode_buf()</strong> decode
the contents of a buffer and return the corresponding
Erlang term. <strong>erl_decode_buf()</strong> provides a simple
mechanism for dealing with several encoded terms stored
consecutively in the buffer.</p><ul><li> <p><strong>bufp</strong> is a pointer to a buffer containing one
or more encoded Erlang terms.</p> </li><li> <p><strong>bufpp</strong> is the address of a buffer pointer. The
buffer contains one or more consecutively encoded Erlang terms.
Following a successful call to
<strong>erl_decode_buf()</strong>, <strong>bufpp</strong> is
updated so that it points to the next encoded term.</p> </li></ul><p><strong>erl_decode()</strong> returns an Erlang term
corresponding to the contents of <strong>bufp</strong> on success,
otherwise <strong>NULL</strong>. <strong>erl_decode_buf()</strong>
returns an Erlang
term corresponding to the first of the consecutive terms in
<strong>bufpp</strong> and moves <strong>bufpp</strong> forward
to point to the
next term in the buffer. On failure, each of the functions
return <strong>NULL</strong>.</p><h4>erl_encode(term, bufp):int</h4><h4>erl_encode_buf(term, bufpp):int</h4><p>Convert a term into Erlang external format.</p><ul><li><span class="v">ETERM *term;</span></li><li><span class="v">unsigned char *bufp;</span></li><li><span class="v">unsigned char **bufpp;</span></li></ul><p><strong>erl_encode()</strong> and
<strong>erl_encode_buf()</strong> encode
Erlang terms into external format for storage or transmission.
<strong>erl_encode_buf()</strong> provides a simple mechanism for
encoding several terms consecutively in the same buffer.</p><ul><li> <p><strong>term</strong> is an Erlang term to be encoded.</p> </li><li> <p><strong>bufp</strong> is a pointer to a buffer containing one or
more encoded Erlang terms.</p> </li><li> <p><strong>bufpp</strong> is a pointer to a pointer to a buffer
containing one or more consecutively encoded Erlang terms.
Following a successful call to
<strong>erl_encode_buf()</strong>, <strong>bufpp</strong> is updated so
that it points to the
position for the next encoded term.</p> </li></ul><p>These functions return the number of bytes written to buffer
on success, otherwise <strong>0</strong>.</p><p>Notice that no bounds checking is done on the buffer. It is
the caller's responsibility to ensure that the buffer is
large enough to hold the encoded terms. You can either use a
static buffer that is large enough to hold the terms you expect
to need in your program, or use <strong>erl_term_len()</strong>
to determine the exact requirements for a given term.</p><p>The following can help you estimate the buffer
requirements for a term. Notice that this information is
implementation-specific, and can change in future versions.
If you are unsure, use <strong>erl_term_len()</strong>.</p><p>Erlang terms are encoded with a 1 byte tag that
identifies the type of object, a 2- or 4-byte length field,
and then the data itself. Specifically:</p><dl><dt><strong>Tuples</strong></dt><dd>Need 5 bytes, plus the space for each element.</dd><dt><strong>Lists</strong></dt><dd>Need 5 bytes, plus the space for each element, and 1 more byte for the empty list at the end.</dd><dt><strong>Strings and atoms</strong></dt><dd>Need 3 bytes, plus 1 byte for each character (the terminating 0 is not encoded). Really long strings (more than 64k characters) are encoded as lists. Atoms cannot contain more than 256 characters.</dd><dt><strong>Integers</strong></dt><dd>Need 5 bytes.</dd><dt><strong>Characters</strong></dt><dd>(Integers &lt; 256) need 2 bytes.</dd><dt><strong>Floating point numbers</strong></dt><dd>Need 32 bytes.</dd><dt><strong>Pids</strong></dt><dd>Need 10 bytes, plus the space for the node name, which is an atom.</dd><dt><strong>Ports and Refs</strong></dt><dd>Need 6 bytes, plus the space for the node name, which is an atom.</dd></dl><p>The total space required is the result calculated
from the information above, plus 1 more byte for a 
version identifier.</p><h4>erl_ext_size(bufp):int</h4><p>Count elements in encoded term.</p><ul><li><span class="v">unsigned char *bufp;</span></li></ul><p>Returns the number of elements in an encoded term.</p><h4>erl_ext_type(bufp):unsigned char</h4><p>Determine type of an encoded byte sequence.</p><ul><li><span class="v">unsigned char *bufp;</span></li></ul><p>Identifies and returns the type of Erlang term encoded
in a buffer. It skips a trailing <em>magic</em> identifier.</p><p>Returns <strong>0</strong> if the type cannot be determined or
one of:</p><ul><li><strong>ERL_INTEGER</strong> </li><li><strong>ERL_ATOM</strong> </li><li><strong>ERL_PID</strong> (Erlang process identifier) </li><li><strong>ERL_PORT</strong> </li><li><strong>ERL_REF</strong> (Erlang reference) </li><li><strong>ERL_EMPTY_LIST</strong> </li><li><strong>ERL_LIST</strong> </li><li><strong>ERL_TUPLE</strong> </li><li><strong>ERL_FLOAT</strong> </li><li><strong>ERL_BINARY</strong> </li><li><strong>ERL_FUNCTION</strong> </li></ul><h4>erl_peek_ext(bufp, pos):unsigned char *</h4><p>Step over encoded term.</p><ul><li><span class="v">unsigned char *bufp;</span></li><li><span class="v">int pos;</span></li></ul><p>This function is used for stepping over one or more
encoded terms in a buffer, to directly access later term.</p><ul><li><strong>bufp</strong> is a pointer to a buffer containing one or more encoded Erlang terms.</li><li><strong>pos</strong> indicates how many terms to step over in the buffer.</li></ul><p>Returns a pointer to a subterm that can be
used in a later call to <strong>erl_decode()</strong> to retrieve
the term at that position. If there is no term, or
<strong>pos</strong> would exceed the size of the terms in the
buffer, <strong>NULL</strong> is returned.</p><h4>erl_term_len(t):int</h4><p>Determine encoded size of term.</p><ul><li><span class="v">ETERM *t;</span></li></ul><p>Determines the buffer space that would be
needed by <strong>t</strong> if it were encoded into Erlang external
format by <strong>erl_encode()</strong>.</p><p>Returns the size in bytes.</p><h3>erl_call</h3><p>Call/start a distributed Erlang node.</p><p><strong>erl_call</strong> makes it possible to start and/or
communicate with a distributed Erlang node. It is built upon the
<strong>Erl_Interface</strong> library as an example application.
Its purpose is to use a Unix shell script to interact with a distributed
Erlang node. It performs all communication with the Erlang
<em>rex server</em>, using the standard Erlang RPC facility. It does not
require any special software to be run at the Erlang target node.The main use is to either start a distributed Erlang node
or to make an ordinary function call. However, it is also
possible to pipe an Erlang module to <strong>erl_call</strong> and have
it compiled, or to pipe a sequence of Erlang expressions to be evaluated
(similar to the Erlang shell).Options, which cause <strong>stdin</strong> to be read, can be used
with advantage,
as scripts from within (Unix) shell scripts. Another nice use
of <strong>erl_call</strong> could be from (HTTP) CGI-bin scripts.</p><h3>Functions</h3><h4>erl_call &lt;options&gt;</h4><p>Start/call Erlang.</p><p>Starts/calls Erlang.</p><p>Each option flag is described below with its name, type, and
meaning.</p><dl><dt><strong>-a [Mod [Fun [Args]]]]</strong></dt><dd> <p>(<em>Optional.</em>) Applies the specified function
and returns the result. <strong>Mod</strong> must be specified.
However, <strong>start</strong> and <strong>[]</strong> are assumed for unspecified
<strong>Fun</strong> and <strong>Args</strong>, respectively.
<strong>Args</strong> is to be in the same format as for
<a href="../erts/erlang#apply/3">erts/erlang#apply/3</a> in <strong>ERTS</strong>.</p> <p>Notice that this flag takes exactly one argument, so quoting
can be necessary to group <strong>Mod</strong>,
<strong>Fun</strong>, and <strong>Args</strong> in a manner
dependent on the behavior of your command shell.</p> </dd><dt><strong>-c Cookie</strong></dt><dd> <p>(<em>Optional.</em>) Use this option to specify a certain cookie.
If no cookie is specified, the <strong>~/.erlang.cookie</strong>
file is read and its content is used as cookie. The Erlang node
we want to communicate with must have the same cookie.</p> </dd><dt><strong>-d</strong></dt><dd> <p>(<em>Optional.</em>) Debug mode. This causes all I/O to be output
to the <strong>~/.erl_call.out.Nodename</strong> file, where
<strong>Nodename</strong>
is the node name of the Erlang node in question.</p> </dd><dt><strong>-e</strong></dt><dd> <p>(<em>Optional.</em>) Reads a sequence of Erlang expressions,
separated by comma (,) and ended with a full stop (.), from
<strong>stdin</strong> until EOF (Control-D). Evaluates the
expressions and returns the result from the last expression.
Returns <strong>{ok,Result}</strong> on success.</p> </dd><dt><strong>-h HiddenName</strong></dt><dd> <p>(<em>Optional.</em>) Specifies the name of the hidden node
that <strong>erl_call</strong> represents.</p> </dd><dt><strong>-m</strong></dt><dd> <p>(<em>Optional.</em>) Reads an Erlang module from
<strong>stdin</strong> and compiles it.</p> </dd><dt><strong>-n Node</strong></dt><dd> <p>(One of <strong>-n, -name, -sname</strong> is required.)
Has the same meaning as <strong>-name</strong> and can still be
used for backward compatibility reasons.</p> </dd><dt><strong>-name Node</strong></dt><dd> <p>(One of <strong>-n, -name, -sname</strong> is required.)
<strong>Node</strong> is the name of the node to be
started or communicated with. It is assumed that
<strong>Node</strong> is started with
<strong>erl -name</strong>, which means that fully
qualified long node names are used. If option
<strong>-s</strong> is specified, an Erlang node will (if
necessary) be started with <strong>erl -name</strong>.</p> </dd><dt><strong>-q</strong></dt><dd> <p>(<em>Optional.</em>) Halts the Erlang node specified
with switch <strong>-n</strong>. This switch overrides switch <strong>-s</strong>.</p> </dd><dt><strong>-r</strong></dt><dd> <p>(<em>Optional.</em>) Generates a random name of the hidden node
that <strong>erl_call</strong> represents.</p> </dd><dt><strong>-s</strong></dt><dd> <p>(<em>Optional.</em>) Starts a distributed Erlang node if
necessary. This means that in a sequence of calls, where
'<strong>-s</strong>' and '<strong>-n Node</strong>' are
constant, only the first call starts the Erlang node. This makes
the rest of the communication very fast. This flag is currently
only available on Unix-like platforms (Linux, Mac OS X, Solaris,
and so on).</p> </dd><dt><strong>-sname Node</strong></dt><dd> <p>(One of <strong>-n, -name, -sname</strong> is required.)
<strong>Node</strong> is the name of the node to be started
or communicated with. It is assumed that <strong>Node</strong>
is started with <strong>erl -sname</strong>, which means that
short node names are used. If option <strong>-s</strong> is
specified, an Erlang node is started (if necessary) with
<strong>erl -sname</strong>.</p> </dd><dt><strong>-v</strong></dt><dd> <p>(<em>Optional.</em>) Prints a lot of <strong>verbose</strong>
information. This is only useful for the developer and maintainer
of <strong>erl_call</strong>.</p> </dd><dt><strong>-x ErlScript</strong></dt><dd> <p>(<em>Optional.</em>) Specifies another name of the Erlang
startup script to be used. If not specified, the standard
<strong>erl</strong> startup script is used.</p> </dd></dl><h4>Examples</h4><p>To start an Erlang node and call <strong>erlang:time/0</strong>:</p><pre><code class="">
erl_call -s -a 'erlang time' -n madonna
{18,27,34}
    </code></pre><p>To terminate an Erlang node by calling
<strong>erlang:halt/0</strong>:</p><pre><code class="">
erl_call -s -a 'erlang halt' -n madonna
    </code></pre><p>To apply with many arguments:</p><pre><code class="">
erl_call -s -a 'lists seq [1,10]' -n madonna
    </code></pre><p>To evaluate some expressions
(<em>the input ends with EOF (Control-D)</em>):</p><pre><code class="">
erl_call -s -e -n madonna
statistics(runtime),
X=1,
Y=2,
{_,T}=statistics(runtime),
{X+Y,T}.
^D
{ok,{3,0}}
    </code></pre><p>To compile a module and run it (<em>again, the input ends with EOF (Control-D)</em>):</p><p>(In the example, the output has been formatted afterwards.)</p><pre><code class="">
erl_call -s -m -a procnames -n madonna
-module(procnames).
-compile(export_all).
start() -&gt;
        P = processes(),
        F = fun(X) -&gt; {X,process_info(X,registered_name)} end,
        lists:map(F,[],P).
^D
[{&lt;madonna@chivas.du.etx.ericsson.se,0,0&gt;,
                  {registered_name,init}},
 {&lt;madonna@chivas.du.etx.ericsson.se,2,0&gt;,
                  {registered_name,erl_prim_loader}},
 {&lt;madonna@chivas.du.etx.ericsson.se,4,0&gt;,
                  {registered_name,error_logger}},
 {&lt;madonna@chivas.du.etx.ericsson.se,5,0&gt;,
                  {registered_name,application_controller}},
 {&lt;madonna@chivas.du.etx.ericsson.se,6,0&gt;,
                  {registered_name,kernel}},
 {&lt;madonna@chivas.du.etx.ericsson.se,7,0&gt;,
                  []},
 {&lt;madonna@chivas.du.etx.ericsson.se,8,0&gt;,
                  {registered_name,kernel_sup}},
 {&lt;madonna@chivas.du.etx.ericsson.se,9,0&gt;,
                  {registered_name,net_sup}},
 {&lt;madonna@chivas.du.etx.ericsson.se,10,0&gt;,
                  {registered_name,net_kernel}},
 {&lt;madonna@chivas.du.etx.ericsson.se,11,0&gt;,
                  []},
 {&lt;madonna@chivas.du.etx.ericsson.se,12,0&gt;,
                  {registered_name,global_name_server}},
 {&lt;madonna@chivas.du.etx.ericsson.se,13,0&gt;,
                  {registered_name,auth}},
 {&lt;madonna@chivas.du.etx.ericsson.se,14,0&gt;,
                  {registered_name,rex}},
 {&lt;madonna@chivas.du.etx.ericsson.se,15,0&gt;,
                  []},
 {&lt;madonna@chivas.du.etx.ericsson.se,16,0&gt;,
                  {registered_name,file_server}},
 {&lt;madonna@chivas.du.etx.ericsson.se,17,0&gt;,
                  {registered_name,code_server}},
 {&lt;madonna@chivas.du.etx.ericsson.se,20,0&gt;,
                  {registered_name,user}},
 {&lt;madonna@chivas.du.etx.ericsson.se,38,0&gt;,
                  []}]
    </code></pre></body></html>