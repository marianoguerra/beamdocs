<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Erl_Interface User's Guide</h1><h2>Deprecation and Removal</h2><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The support for VxWorks is deprecated as of OTP 22, and
will be removed in OTP 23.</p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The old legacy <strong>erl_interface</strong> library (functions
with prefix <strong>erl_</strong>) is deprecated as of OTP 22, and will be
removed in OTP 23. This does not apply to the <strong>ei</strong>
library. Reasonably new <strong>gcc</strong> compilers will issue deprecation
warnings. In order to disable these warnings, define the macro
<strong>EI_NO_DEPR_WARN</strong>.</p></div><h2>Introduction</h2><p>The <strong>Erl_Interface</strong> library contains functions that help you
integrate programs written in C and Erlang. The functions in
<strong>Erl_Interface</strong> support the following:</p><ul><li>Manipulation of data represented as Erlang data types</li><li>Conversion of data between C and Erlang formats</li><li>Encoding and decoding of Erlang data types for transmission or storage</li><li>Communication between C nodes and Erlang processes</li><li>Backup and restore of C node state to and from <a href="./mnesia">Mnesia</a></li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>By default, the <strong>Erl_Interface</strong> libraries are only guaranteed
to be compatible with other Erlang/OTP components from the same
release as the libraries themselves. For information about how to
communicate with Erlang/OTP components from earlier releases, see
function <a href="./ei#ei_set_compat_rel">ei#ei_set_compat_rel</a> and
<a href="./erl_eterm#erl_set_compat_rel">erl_eterm#erl_set_compat_rel</a>.</p></div><h2>Scope</h2><p>In the following sections, these topics are described:</p><ul><li>Compiling your code for use with <strong>Erl_Interface</strong></li><li>Initializing <strong>Erl_Interface</strong></li><li>Encoding, decoding, and sending Erlang terms</li><li>Building terms and patterns</li><li>Pattern matching</li><li>Connecting to a distributed Erlang node</li><li>Using the Erlang Port Mapper Daemon (EPMD)</li><li>Sending and receiving Erlang messages</li><li>Remote procedure calls</li><li>Using global names</li><li>Using the registry</li></ul><h2>Prerequisites</h2><p>It is assumed that the reader is familiar with the Erlang programming
language.</p><h2>Compiling and Linking Your Code</h2><p>To use any of the <strong>Erl_Interface</strong> functions, include the
following lines in your code:</p><pre><code class="">
#include "erl_interface.h"
#include "ei.h"    </code></pre><p>Determine where the top directory of your OTP installation is.
To find this, start Erlang and enter the following
command at the Eshell prompt:</p><pre><code class="">
Eshell V4.7.4  (abort with ^G)
1&gt; code:root_dir().
/usr/local/otp    </code></pre><p>To compile your code, ensure that your C compiler knows where
to find <strong>erl_interface.h</strong> by specifying an appropriate
<strong>-I</strong> argument on the command line, or add it to
the <strong>CFLAGS</strong> definition in your
<strong>Makefile</strong>. The correct value for this path is
<strong>$OTPROOT/lib/erl_interface-$EIVSN/include</strong>,
where:</p><ul><li> <p><strong>$OTPROOT</strong> is the path reported by
<strong>code:root_dir/0</strong> in the example above.</p> </li><li> <p><strong>$EIVSN</strong> is the version of the <strong>Erl_Interface</strong> application,
for example, <strong>erl_interface-3.2.3</strong>.</p> </li></ul><p>Compiling the code:</p><pre><code class="">
$ cc -c -I/usr/local/otp/lib/erl_interface-3.2.3/include myprog.c    </code></pre><p>When linking:</p><ul><li>Specify the path to <strong>liberl_interface.a</strong> and <strong>libei.a</strong> with <strong>-L$OTPROOT/lib/erl_interface-3.2.3/lib</strong>.</li><li>Specify the name of the libraries with <strong>-lerl_interface -lei</strong>.</li></ul><p>Do this on the command line or add the flags to the
<strong>LDFLAGS</strong> definition in your
<strong>Makefile</strong>.</p><p>Linking the code:</p><pre><code class="">
$ ld -L/usr/local/otp/lib/erl_interface-3.2.3/
                            lib myprog.o -lerl_interface -lei -o myprog    </code></pre><p>On some systems it can be necessary to link with some more
libraries (for example, <strong>libnsl.a</strong> and
<strong>libsocket.a</strong> on Solaris, or
<strong>wsock32.lib</strong> on Windows) to use the
communication facilities of <strong>Erl_Interface</strong>.</p><p>If you use the <strong>Erl_Interface</strong> functions in a threaded
application based on POSIX threads or Solaris threads, then
<strong>Erl_Interface</strong> needs access to some of the synchronization
facilities in your threads package. You must specify extra
compiler flags to indicate which of the packages you use. Define
<strong>_REENTRANT</strong> and either <strong>STHREADS</strong> or
<strong>PTHREADS</strong>. The default is to use POSIX threads if
<strong>_REENTRANT</strong> is specified.</p><h2>Initializing the Libraries</h2><p>
Before calling any of the other functions in the <strong>erl_interface</strong>
and <strong>ei</strong> libraries, call <strong>erl_init()</strong> exactly once to initialize
both libraries.
<strong>erl_init()</strong> takes two arguments. However, the arguments
are no longer used by <strong>erl_interface</strong> and are therefore to be
specified as <strong>erl_init(NULL,0)</strong>.
</p><p>
If you only use the <strong>ei</strong> library, instead initialize it by calling
<strong>ei_init()</strong> exactly once before calling any other functions in
the <strong>ei</strong> library.
</p><h2>Encoding, Decoding, and Sending Erlang Terms</h2><p>Data sent between distributed Erlang nodes is encoded in the
Erlang external format. You must therefore encode and decode
Erlang terms into byte streams if you want to use the distribution
protocol to communicate between a C program and Erlang.</p><p>The <strong>Erl_Interface</strong> library supports this activity. It has
several C functions that create and manipulate Erlang data
structures. The library also contains an encode and a decode function.
The following example shows how to create and encode an Erlang tuple
<strong>{tobbe,3928}</strong>:</p><pre><code class="">
ETERM *arr[2], *tuple;
char buf[BUFSIZ];
int i;
  
arr[0] = erl_mk_atom("tobbe");
arr[1] = erl_mk_integer(3928);
tuple  = erl_mk_tuple(arr, 2);
i = erl_encode(tuple, buf);    </code></pre><p>Alternatively, you can use <strong>erl_send()</strong> and
<strong>erl_receive_msg</strong>, which handle the encoding and
decoding of messages transparently.</p><p>For a complete description, see the following modules:</p><ul><li><a href="erl_eterm">erl_eterm</a> for creating Erlang terms</li><li><a href="erl_marshal">erl_marshal</a> for encoding and decoding routines</li></ul><a name="building_terms_and_patterns"></a><h2>Building Terms and Patterns</h2><p>The previous example can be simplified by using the
<a href="erl_format">erl_format</a> module
to create an Erlang term:</p><pre><code class="">
ETERM *ep;
ep = erl_format("{~a,~i}", "tobbe", 3928);    </code></pre><p>For a complete description of the different format directives, see
the <a href="erl_format">erl_format</a> module.</p><p>The following example is more complex:</p><pre><code class="">
ETERM *ep;
ep = erl_format("[{name,~a},{age,~i},{data,~w}]",
                 "madonna", 
                 21, 
                 erl_format("[{adr,~s,~i}]", "E-street", 42));
erl_free_compound(ep);      </code></pre><p>As in the previous examples, it is your responsibility to free the
memory allocated for Erlang terms. In this example,
<strong>erl_free_compound()</strong> ensures that the complete term
pointed to by <strong>ep</strong> is released. This is necessary
because the pointer from the second call to <strong>erl_format</strong> is lost.</p><p>The following example shows a slightly different solution:</p><pre><code class="">
ETERM *ep,*ep2;
ep2 = erl_format("[{adr,~s,~i}]","E-street",42);
ep  = erl_format("[{name,~a},{age,~i},{data,~w}]",
                 "madonna", 21, ep2);
erl_free_term(ep);  
erl_free_term(ep2);      </code></pre><p>In this case, you free the two terms independently. The order in
which you free the terms <strong>ep</strong> and <strong>ep2</strong>
is not important,
because the <strong>Erl_Interface</strong> library uses reference counting to
determine when it is safe to remove objects.</p><p>If you are unsure whether you have freed the terms properly, you
can use the following function to see the status of the fixed term
allocator:</p><pre><code class="">
long allocated, freed;

erl_eterm_statistics(&amp;allocated,&amp;freed);
printf("currently allocated blocks: %ld\n",allocated);
printf("length of freelist: %ld\n",freed);

/* really free the freelist */
erl_eterm_release();
    </code></pre><p>For more information, see the
<a href="erl_malloc">erl_malloc</a> module.</p><h2>Pattern Matching</h2><p>An Erlang pattern is a term that can contain unbound variables or
<strong>"do not care"</strong> symbols. Such a pattern can be matched
against a
term and, if the match is successful, any unbound variables in the
pattern will be bound as a side effect. The content of a bound
variable can then be retrieved:</p><pre><code class="">
ETERM *pattern;
pattern = erl_format("{madonna,Age,_}");    </code></pre><p>The <a href="./erl_format#erl_match">erl_format#erl_match</a> function
performs pattern matching. It takes a
pattern and a term and tries to match them. As a side effect any unbound
variables in the pattern will be bound. In the following example, a
pattern is created with a variable <strong>Age</strong>, which is included at two
positions in the tuple. The pattern match is performed as follows:</p><ul><li> <p><strong>erl_match</strong> binds the contents of <strong>Age</strong> to <strong>21</strong>
the first time it reaches the variable.</p> </li><li> <p>The second occurrence of <strong>Age</strong> causes a test for
equality between the terms, as <strong>Age</strong> is already bound to
<strong>21</strong>. As <strong>Age</strong> is bound to <strong>21</strong>, the equality test
succeeds and the match continues until the end of the pattern.</p> </li><li> <p>If the end of the pattern is reached, the match succeeds and you
can retrieve the contents of the variable.</p> </li></ul><pre><code class="">
ETERM *pattern,*term;
pattern = erl_format("{madonna,Age,Age}");
term    = erl_format("{madonna,21,21}");
if (erl_match(pattern, term)) {
  fprintf(stderr, "Yes, they matched: Age = ");
  ep = erl_var_content(pattern, "Age"); 
  erl_print_term(stderr, ep);
  fprintf(stderr,"\n");
  erl_free_term(ep);
}
erl_free_term(pattern);
erl_free_term(term);    </code></pre><p>For more information, see the
<a href="./erl_format#erl_match">erl_format#erl_match</a> function.</p><h2>Connecting to a Distributed Erlang Node</h2><p>To connect to a distributed Erlang node, you must first
initialize the connection routine with
<a href="./erl_connect#erl_connect_init">erl_connect#erl_connect_init</a>,
which stores information, such as the hostname, node name, and IP
address for later use:</p><pre><code class="">
int identification_number = 99;
int creation=1;
char *cookie="a secret cookie string"; /* An example */
erl_connect_init(identification_number, cookie, creation);    </code></pre><p>For more information, see the
<a href="erl_connect">erl_connect</a> module.</p><p>After initialization, you set up the connection to the Erlang node.
To specify the Erlang node you want to connect to, use
<strong>erl_connect()</strong>. The following example sets up the
connection and is to result in a valid socket file descriptor:</p><pre><code class="">
int sockfd;
char *nodename="xyz@chivas.du.etx.ericsson.se"; /* An example */
if ((sockfd = erl_connect(nodename)) &lt; 0)
  erl_err_quit("ERROR: erl_connect failed");    </code></pre><p><strong>erl_err_quit()</strong> prints the specified string and
terminates the program. For more information, see the
<a href="erl_error">erl_error</a> module.</p><h2>Using EPMD</h2><p><a href="./epmd">erts/epmd</a>
is the Erlang Port Mapper Daemon. Distributed
Erlang nodes register with <strong>epmd</strong> on the local host to
indicate to other nodes that they exist and can accept connections.
<strong>epmd</strong> maintains a register of
node and port number information, and when a node wishes to connect to
another node, it first contacts <strong>epmd</strong> to find the
correct port number to connect to.</p><p>When you use
<a href="erl_connect">erl_connect</a>
to connect to an Erlang node, a connection is first made to
<strong>epmd</strong> and, if the node is known, a
connection is then made to the Erlang node.</p><p>C nodes can also register themselves with <strong>epmd</strong>
if they want other
nodes in the system to be able to find and connect to them.</p><p>Before registering with <strong>epmd</strong>, you must first
create a listen socket and bind it to a port. Then:</p><pre><code class="">
int pub;

pub = erl_publish(port);    </code></pre><p><strong>pub</strong> is a file descriptor now connected to
<strong>epmd</strong>. <strong>epmd</strong>
monitors the other end of the connection. If it detects that the
connection has been closed, the node becomes unregistered. So, if you
explicitly close the descriptor or if your node fails, it becomes
unregistered from <strong>epmd</strong>.</p><p>Notice that on some systems (such as VxWorks), a failed node is
not detected by this mechanism, as the operating system does not
automatically close descriptors that were left open when the node
failed. If a node has failed in this way, <strong>epmd</strong>
prevents you from
registering a new node with the old name, as it thinks that the old
name is still in use. In this case, you must unregister the name
explicitly:</p><pre><code class="">
erl_unpublish(node);    </code></pre><p>This causes <strong>epmd</strong> to close the connection from the
far end. Notice
that if the name was in fact still in use by a node, the results of
this operation are unpredictable. Also, doing this does not cause the
local end of the connection to close, so resources can be consumed.</p><h2>Sending and Receiving Erlang Messages</h2><p>Use one of the following two functions to send messages:</p><ul><li><a href="./erl_connect#erl_send">erl_connect#erl_send</a></li><li><a href="./erl_connect#erl_reg_send">erl_connect#erl_reg_send</a></li></ul><p>As in Erlang, messages can be sent to a
pid or to a registered name. It is easier to send a
message to a registered name, as it avoids the problem of finding
a suitable pid.</p><p>Use one of the following two functions to receive messages:</p><ul><li><a href="./erl_connect#erl_receive">erl_connect#erl_receive</a></li><li><a href="./erl_connect#erl_receive_msg">erl_connect#erl_receive_msg</a></li></ul><p><strong>erl_receive()</strong> receives the message into a buffer,
while <strong>erl_receive_msg()</strong> decodes the message into an
Erlang term.</p><h2>Example of Sending Messages</h2><p>In the following example, <strong>{Pid, hello_world}</strong> is
sent to a registered process <strong>my_server</strong>. The message
is encoded by <strong>erl_send()</strong>:</p><pre><code class="">
extern const char *erl_thisnodename(void);
extern short erl_thiscreation(void);
#define SELF(fd) erl_mk_pid(erl_thisnodename(),fd,0,erl_thiscreation())
ETERM *arr[2], *emsg;
int sockfd, creation=1;
  
arr[0] = SELF(sockfd);
arr[1] = erl_mk_atom("Hello world");
emsg   = erl_mk_tuple(arr, 2);
  
erl_reg_send(sockfd, "my_server", emsg);
erl_free_term(emsg);      </code></pre><p>The first element of the tuple that is sent is your own
pid. This enables <strong>my_server</strong> to reply.
For more information about the primitives, see the
<a href="erl_connect">erl_connect</a> module.</p><h2>Example of Receiving Messages</h2><p>In this example, <strong>{Pid, Something}</strong> is received. The
received pid is then used to return
<strong>{goodbye,Pid}</strong>.</p><pre><code class="">
ETERM *arr[2], *answer;
int sockfd,rc;
char buf[BUFSIZE];
ErlMessage emsg;
  
if ((rc = erl_receive_msg(sockfd , buf, BUFSIZE, &amp;emsg)) == ERL_MSG) {
   arr[0] = erl_mk_atom("goodbye");
   arr[1] = erl_element(1, emsg.msg); 
   answer = erl_mk_tuple(arr, 2);
   erl_send(sockfd, arr[1], answer);
   erl_free_term(answer);
   erl_free_term(emsg.msg);
   erl_free_term(emsg.to);
}      </code></pre><p>To provide robustness, a distributed Erlang node
occasionally polls all its connected neighbors in an attempt to
detect failed nodes or communication links. A node that receives such
a message is expected to respond immediately with an
<strong>ERL_TICK</strong> message. This is done automatically by
<strong>erl_receive()</strong>. However, when this has occurred,
<strong>erl_receive</strong> returns <strong>ERL_TICK</strong> to
the caller without storing a message into the
<strong>ErlMessage</strong> structure.</p><p>When a message has been received, it is the caller's responsibility
to free the received message <strong>emsg.msg</strong> and
<strong>emsg.to</strong> or <strong>emsg.from</strong>,
depending on the type of message received.</p><p>For more information, see the
<a href="erl_connect">erl_connect</a> and
<a href="erl_eterm">erl_eterm</a> modules.</p><h2>Remote Procedure Calls</h2><p>An Erlang node acting as a client to another Erlang node
typically sends a request and waits for a reply. Such a request is
included in a function call at a remote node and is called a remote
procedure call.</p><p>The following example shows how the
<strong>Erl_Interface</strong> library supports remote procedure calls:</p><pre><code class="">
char modname[]=THE_MODNAME;
ETERM *reply,*ep;
ep = erl_format("[~a,[]]", modname);
if (!(reply = erl_rpc(fd, "c", "c", ep)))
  erl_err_msg("&lt;ERROR&gt; when compiling file: %s.erl !\n", modname);
erl_free_term(ep);
ep = erl_format("{ok,_}");
if (!erl_match(ep, reply))
  erl_err_msg("&lt;ERROR&gt; compiler errors !\n");
erl_free_term(ep);
erl_free_term(reply);    </code></pre><p><strong>c:c/1</strong> is called to compile the specified module on
the remote node. <strong>erl_match()</strong> checks that the
compilation was
successful by testing for the expected <strong>ok</strong>.</p><p>For more information about <strong>erl_rpc()</strong> and its
companions <strong>erl_rpc_to()</strong> and
<strong>erl_rpc_from()</strong>, see the
<a href="erl_connect">erl_connect</a> module.</p><h2>Using Global Names</h2><p>A C node has access to names registered through the
<a href="./global">kernel/global</a>
module in Kernel. Names can be looked up, allowing the C node to send messages
to named Erlang services. C nodes can also register global names,
allowing them to provide named services to Erlang processes or other C
nodes.</p><p><strong>Erl_Interface</strong> does not provide a native implementation of the
global service. Instead it uses the global services provided by a "nearby"
Erlang node. To use the services described in this section,
it is necessary to first open a connection to an Erlang node.</p><p>To see what names there are:</p><pre><code class="">
char **names;
int count;
int i;

names = erl_global_names(fd,&amp;count);

if (names) 
  for (i=0; i&lt;count; i++) 
    printf("%s\n",names[i]);

free(names);    </code></pre><p><a href="./erl_global#erl_global_names">erl_global#erl_global_names</a>
allocates and returns a buffer containing
all the names known to the <strong>global</strong> module in <strong>Kernel</strong>.
<strong>count</strong> is initialized to
indicate the number of names in the array. The array of strings in names
is terminated by a <strong>NULL</strong> pointer, so it is not necessary to use
<strong>count</strong> to determine when the last name is reached.</p><p>It is the caller's responsibility to free the array.
<strong>erl_global_names</strong> allocates the array and all the strings
using a single call to <strong>malloc()</strong>, so
<strong>free(names)</strong> is all that is necessary.</p><p>To look up one of the names:</p><pre><code class="">
ETERM *pid;
char node[256];

pid = erl_global_whereis(fd,"schedule",node);    </code></pre><p>If <strong>"schedule"</strong> is known to the
<strong>global</strong> module in <strong>Kernel</strong>, an Erlang pid is
returned that can be used to send messages to the schedule service.
Also, <strong>node</strong> is initialized to contain the name of
the node where the service is registered, so that you can make a
connection to it by simply passing the variable to
<a href="erl_connect">erl_connect</a>.</p><p>Before registering a name, you should already have registered your
port number with <strong>epmd</strong>. This is not strictly necessary,
but if you
neglect to do so, then other nodes wishing to communicate with your
service cannot find or connect to your process.</p><p>Create a pid that Erlang processes can use to communicate with your
service:</p><pre><code class="">
ETERM *pid;

pid = erl_mk_pid(thisnode,14,0,0);
erl_global_register(fd,servicename,pid);    </code></pre><p>After registering the name, use
<a href="./erl_connect#erl_accept">erl_connect#erl_accept</a>
to wait for incoming connections.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Remember to free <strong>pid</strong> later with
<a href="./erl_malloc#erl_free_term">erl_malloc#erl_free_term</a>.</p></div><p>To unregister a name:</p><pre><code class="">
erl_global_unregister(fd,servicename);    </code></pre><h2>Using the Registry</h2><p>This section describes the use of the registry, a simple mechanism
for storing key-value pairs in a C-node, as well as backing them up or
restoring them from an <strong>Mnesia</strong> table on an Erlang node. For more
detailed information about the individual API functions, see the
<a href="registry">registry</a> module.</p><p>Keys are strings, that is, <strong>NULL</strong>-terminated arrays of characters, and
values are arbitrary objects. Although integers and floating point numbers
are treated specially by the registry, you can store strings or binary
objects of any type as pointers.</p><p>To start, open a registry:</p><pre><code class="">
ei_reg *reg;

reg = ei_reg_open(45);    </code></pre><p>The number <strong>45</strong> in the example indicates the approximate number of
objects that you expect to store in the registry. Internally the
registry uses hash tables with collision chaining, so there is no
absolute upper limit on the number of objects that the registry can
contain, but if performance or memory usage is important, then you
are to choose a number accordingly. The registry can be resized later.</p><p>You can open as many registries as you like (if memory permits).</p><p>Objects are stored and retrieved through set and get functions.
The following example shows how to store integers, floats, strings,
and arbitrary binary objects:</p><pre><code class="">
struct bonk *b = malloc(sizeof(*b));
char *name = malloc(7);

ei_reg_setival(reg,"age",29); 
ei_reg_setfval(reg,"height",1.85);

strcpy(name,"Martin");
ei_reg_setsval(reg,"name",name); 

b-&gt;l = 42;
b-&gt;m = 12;
ei_reg_setpval(reg,"jox",b,sizeof(*b));    </code></pre><p>If you try to store an object in the registry and there is an
existing object with the same key, the new value replaces the old
one. This is done regardless of whether the new object and the old one
have the same type, so you can, for example, replace a string with an
integer. If the existing value is a string or binary, it is freed
before the new value is assigned.</p><p>Stored values are retrieved from the registry as follows:</p><pre><code class="">
long i;
double f;
char *s;
struct bonk *b;
int size;

i = ei_reg_getival(reg,"age");
f = ei_reg_getfval(reg,"height");
s = ei_reg_getsval(reg,"name");
b = ei_reg_getpval(reg,"jox",&amp;size);    </code></pre><p>In all the above examples, the object must exist and it must be of
the right type for the specified operation. If you do not know the
type of an object, you can ask:</p><pre><code class="">
struct ei_reg_stat buf;

ei_reg_stat(reg,"name",&amp;buf);    </code></pre><p>Buf is initialized to contain object attributes.</p><p>Objects can be removed from the registry:</p><pre><code class="">
ei_reg_delete(reg,"name");    </code></pre><p>When you are finished with a registry, close it to remove all the
objects and free the memory back to the system:</p><pre><code class="">
ei_reg_close(reg);    </code></pre><h2>Backing Up the Registry to Mnesia</h2><p>The contents of a registry can be backed up to
<a href="./mnesia">mnesia/mnesia</a> on a "nearby" Erlang
node. You must provide an open connection to the Erlang node
(see <a href="erl_connect">erl_connect</a>).
Also, <strong>Mnesia</strong> 3.0 or later must be running
on the Erlang node before the backup is initiated:</p><pre><code class="">
ei_reg_dump(fd, reg, "mtab", dumpflags);      </code></pre><p>This example back up the contents of the registry to the
specified <strong>Mnesia</strong> table <strong>"mtab"</strong>.
Once a registry has been backed
up to <strong>Mnesia</strong> like this, more backups only affect
objects that have been modified since the most recent backup, that is,
objects that have been created, changed, or deleted. The backup
operation is done as a single atomic transaction, so that either the
entire backup is performed or none of it.</p><p>Likewise, a registry can be restored from a <strong>Mnesia</strong> table:</p><pre><code class="">
ei_reg_restore(fd, reg, "mtab");      </code></pre><p>This reads the entire contents of <strong>"mtab"</strong> into the
specified registry. After the restore, all the objects in the registry
are marked as unmodified, so a later backup only affects
objects that you have modified since the restore.</p><p>Notice that if you restore to a non-empty registry, objects in the
table overwrite objects in the registry with the same keys. Also,
the <em>entire</em> contents of the registry is marked as unmodified
after the restore, including any modified objects that were not
overwritten by the restore operation. This may not be your
intention.</p><h2>Storing Strings and Binaries</h2><p>When string or binary objects are stored in the registry it is
important that some simple guidelines are followed.</p><p>Most importantly, the object must have been created with a single call
to <strong>malloc()</strong> (or similar), so that it can later be
removed by a single call to <strong>free()</strong>.
Objects are freed by the registry
when it is closed, or when you assign a new value to an object that
previously contained a string or binary.</p><p>Notice that if you store binary objects that are context-dependent
(for example, containing pointers or open file descriptors),
they lose their meaning if they are backed up to a <strong>Mnesia</strong> table
and later restored in a different context.</p><p>When you retrieve a stored string or binary value from the registry,
the registry maintains a pointer to the object and you are passed a
copy of that pointer. You should never free an object retrieved in
this manner because when the registry later attempts to free it, a
runtime error occurs that likely causes the C-node to crash.</p><p>You are free to modify the contents of an object retrieved this way.
However, when you do so, the registry is not aware of your changes,
possibly causing it to be missed the next time you make an
<strong>Mnesia</strong> backup of the registry contents. This can be avoided if
you mark the object as dirty after any such changes with
<a href="./registry#ei_reg_markdirty">registry#ei_reg_markdirty</a>, or pass appropriate flags to
<a href="./registry#ei_reg_dump">registry#ei_reg_dump</a>.</p></body></html>