<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>cerl</h1><h1>cerl</h1><p>Core Erlang abstract syntax trees.</p><p>Core Erlang abstract syntax trees. This module defines an abstract data type for representing Core
Erlang source code as syntax trees.A recommended starting point for the first-time user is the
documentation of the function <a href="#type-1">type/1</a>.<em>NOTES:</em>This module deals with the composition and decomposition of
<em>syntactic</em> entities (as opposed to semantic ones); its
purpose is to hide all direct references to the data structures
used to represent these entities. With few exceptions, the
functions in this module perform no semantic interpretation of
their inputs, and in general, the user is assumed to pass
type-correct arguments - if this is not done, the effects are not
defined.Currently, the internal data structure used is the same as
the record-based data structures used traditionally in the Beam
compiler.The internal representations of abstract syntax trees are
subject to change without notice, and should not be documented
outside this module. Furthermore, we do not give any guarantees on
how an abstract syntax tree may or may not be represented, <em>with the following exceptions</em>: no syntax tree is represented by a
single atom, such as <strong>none</strong>, by a list constructor
<strong>[X | Y]</strong>, or by the empty list <strong>[]</strong>. This
can be relied on when writing functions that operate on syntax
trees.</p><h2>DATA TYPES</h2><a name="types"></a><dl><dt><a name="type-c_binary"></a>c_binary() = #c_binary{}</dt><dd> </dd><dt><a name="type-c_bitstr"></a>c_bitstr() = #c_bitstr{}</dt><dd> </dd><dt><a name="type-c_call"></a>c_call() = #c_call{}</dt><dd> </dd><dt><a name="type-c_clause"></a>c_clause() = #c_clause{}</dt><dd> </dd><dt><a name="type-c_cons"></a>c_cons() = #c_cons{}</dt><dd> </dd><dt><a name="type-c_fun"></a>c_fun() = #c_fun{}</dt><dd> </dd><dt><a name="type-c_let"></a>c_let() = #c_let{}</dt><dd> </dd><dt><a name="type-c_literal"></a>c_literal() = #c_literal{}</dt><dd> </dd><dt><a name="type-c_map"></a>c_map() = #c_map{}</dt><dd> </dd><dt><a name="type-c_map_pair"></a>c_map_pair() = #c_map_pair{}</dt><dd> </dd><dt><a name="type-c_module"></a>c_module() = #c_module{}</dt><dd> </dd><dt><a name="type-c_tuple"></a>c_tuple() = #c_tuple{}</dt><dd> </dd><dt><a name="type-c_values"></a>c_values() = #c_values{}</dt><dd> </dd><dt><a name="type-c_var"></a>c_var() = #c_var{}</dt><dd> </dd><dt><a name="type-cerl"></a>cerl()</dt><dd> <p>An abstract Core Erlang syntax tree.</p> <p>Every abstract syntax tree has a <em>type</em>, given by the
function <a href="#type-1">type/1</a>.  In addition,
each syntax tree has a list of <em>user annotations</em> (cf.  <a href="#get_ann-1">get_ann/1</a>), which are included
in the Core Erlang syntax.</p> </dd><dt><a name="type-map_op"></a>map_op() = #c_literal{val=assoc} | #c_literal{val=exact}</dt><dd> </dd><dt><a name="type-var_name"></a>var_name() = integer() | atom() | {atom(), integer()}</dt><dd> </dd></dl><h1>Functions</h1><h2>abstract(Term::term()) -&gt;</h2><p>Creates a syntax tree corresponding to an Erlang term.</p><a name="abstract-1"></a><p>Creates a syntax tree corresponding to an Erlang term.
<strong>Term</strong> must be a literal term, i.e., one that can be  
represented as a source code literal. Thus, it may not contain a  
process identifier, port, reference, binary or function value as a  
subterm.</p><p>Note: This is a constant time operation.</p><p><em>See also:</em> <a href="#ann_abstract-2">ann_abstract/2</a>, <a href="#concrete-1">concrete/1</a>, <a href="#is_literal-1">is_literal/1</a>, <a href="#is_literal_term-1">is_literal_term/1</a>.</p><h2>add_ann(Annotations::[term()], Node::) -&gt;</h2><p>Appends Annotations to the list of user annotations of Node.</p><a name="add_ann-2"></a><p>Appends <strong>Annotations</strong> to the list of user
annotations of <strong>Node</strong>.</p><p>Note: this is equivalent to <strong>set_ann(Node, Annotations ++ get_ann(Node))</strong>, but potentially more efficient.</p><p><em>See also:</em> <a href="#get_ann-1">get_ann/1</a>, <a href="#set_ann-2">set_ann/2</a>.</p><h2>alias_pat(Node::) -&gt;</h2><p>Returns the pattern subtree of an abstract pattern alias.</p><a name="alias_pat-1"></a><p>Returns the pattern subtree of an abstract pattern alias.
</p><p><em>See also:</em> <a href="#c_alias-2">c_alias/2</a>.</p><h2>alias_var(Node::) -&gt;</h2><p>Returns the variable subtree of an abstract pattern alias.</p><a name="alias_var-1"></a><p>Returns the variable subtree of an abstract pattern alias.
</p><p><em>See also:</em> <a href="#c_alias-2">c_alias/2</a>.</p><h2>ann_abstract(Annotations::[term()], Term::term()) -&gt;</h2><p> </p><a name="ann_abstract-2"></a><p><em>See also:</em> <a href="#abstract-1">abstract/1</a>.</p><h2>ann_c_alias(As::[term()], Variable::, Pattern::) -&gt;</h2><p> </p><a name="ann_c_alias-3"></a><p><em>See also:</em> <a href="#c_alias-2">c_alias/2</a>.</p><h2>ann_c_apply(As::[term()], Operator::, Arguments::[]) -&gt;</h2><p> </p><a name="ann_c_apply-3"></a><p><em>See also:</em> <a href="#c_apply-2">c_apply/2</a>.</p><h2>ann_c_atom(As::[term()], Name) -&gt;</h2><p> </p><ul><li><span class="v">Name = atom() | string()</span></li></ul><a name="ann_c_atom-2"></a><p><em>See also:</em> <a href="#c_atom-1">c_atom/1</a>.</p><h2>ann_c_binary(As::[term()], Segments::[]) -&gt;</h2><p> </p><a name="ann_c_binary-2"></a><p><em>See also:</em> <a href="#c_binary-1">c_binary/1</a>.</p><h2>ann_c_bitstr(As::[term()], Value::, Size::, Type::, Flags::) -&gt;</h2><p>Equivalent to ann_c_bitstr(As, Value, Size, abstract(1), Type, Flags). </p><a name="ann_c_bitstr-5"></a><p>Equivalent to <a href="#ann_c_bitstr-6">ann_c_bitstr(As, Value, Size, abstract(1), Type, Flags)</a>.</p><h2>ann_c_bitstr(As::[term()], Value::, Size::, Unit::, Type::, Flags::) -&gt;</h2><p> </p><a name="ann_c_bitstr-6"></a><p><em>See also:</em> <a href="#ann_c_bitstr-5">ann_c_bitstr/5</a>, <a href="#c_bitstr-5">c_bitstr/5</a>.</p><h2>ann_c_call(As::[term()], Module::, Name::, Arguments::[]) -&gt;</h2><p> </p><a name="ann_c_call-4"></a><p><em>See also:</em> <a href="#c_call-3">c_call/3</a>.</p><h2>ann_c_case(As::[term()], Argument::, Clauses::[]) -&gt;</h2><p> </p><a name="ann_c_case-3"></a><p><em>See also:</em> <a href="#c_case-2">c_case/2</a>.</p><h2>ann_c_catch(As::[term()], Body::) -&gt;</h2><p> </p><a name="ann_c_catch-2"></a><p><em>See also:</em> <a href="#c_catch-1">c_catch/1</a>.</p><h2>ann_c_char(As::[term()], Value::char()) -&gt;</h2><p> </p><a name="ann_c_char-2"></a><p><em>See also:</em> <a href="#c_char-1">c_char/1</a>.</p><h2>ann_c_clause(As::[term()], Patterns::[], Body::) -&gt;</h2><p>Equivalent to ann_c_clause(As, Patterns, c_atom(true), Body). </p><a name="ann_c_clause-3"></a><p>Equivalent to <a href="#ann_c_clause-4">ann_c_clause(As, Patterns, c_atom(true), Body)</a>.</p><p><em>See also:</em> <a href="#c_clause-3">c_clause/3</a>.</p><h2>ann_c_clause(As::[term()], Patterns::[], Guard::, Body::) -&gt;</h2><p> </p><a name="ann_c_clause-4"></a><p><em>See also:</em> <a href="#ann_c_clause-3">ann_c_clause/3</a>, <a href="#c_clause-3">c_clause/3</a>.</p><h2>ann_c_cons(As::[term()], Head::, Tail::) -&gt;</h2><p> </p><a name="ann_c_cons-3"></a><p><em>See also:</em> <a href="#c_cons-2">c_cons/2</a>.</p><h2>ann_c_cons_skel(As::[term()], Head::, Tail::) -&gt;</h2><p> </p><a name="ann_c_cons_skel-3"></a><p><em>See also:</em> <a href="#c_cons_skel-2">c_cons_skel/2</a>.</p><h2>ann_c_float(As::[term()], Value::float()) -&gt;</h2><p> </p><a name="ann_c_float-2"></a><p><em>See also:</em> <a href="#c_float-1">c_float/1</a>.</p><h2>ann_c_fname(As::[term()], Name::atom(), Arity::arity()) -&gt;</h2><p>Equivalent to ann_c_var(As, {Atom, Arity}). </p><a name="ann_c_fname-3"></a><p>Equivalent to <a href="#ann_c_var-2">ann_c_var(As, {Atom, Arity})</a>.</p><p><em>See also:</em> <a href="#c_fname-2">c_fname/2</a>.</p><h2>ann_c_fun(As::[term()], Variables::[], Body::) -&gt;</h2><p> </p><a name="ann_c_fun-3"></a><p><em>See also:</em> <a href="#c_fun-2">c_fun/2</a>.</p><h2>ann_c_int(As::[term()], Value::integer()) -&gt;</h2><p> </p><a name="ann_c_int-2"></a><p><em>See also:</em> <a href="#c_int-1">c_int/1</a>.</p><h2>ann_c_let(As::[term()], Variables::[], Argument::, Body::) -&gt;</h2><p> </p><a name="ann_c_let-4"></a><p><em>See also:</em> <a href="#c_let-3">c_let/3</a>.</p><h2>ann_c_letrec(As::[term()], Definitions::[{,}], Body::) -&gt;</h2><p> </p><a name="ann_c_letrec-3"></a><p><em>See also:</em> <a href="#c_letrec-2">c_letrec/2</a>.</p><h2>ann_c_map(As::[term()], Es::[]) -&gt;|</h2><p> </p><a name="ann_c_map-2"></a><h2>ann_c_map(As::[term()], C_literal::|, Es::[]) -&gt;|</h2><p> </p><a name="ann_c_map-3"></a><h2>ann_c_map_pair(As::[term()], Op::, K::, V::) -&gt;</h2><p> </p><a name="ann_c_map_pair-4"></a><h2>ann_c_map_pattern(As::[term()], Pairs::[]) -&gt;</h2><p> </p><a name="ann_c_map_pattern-2"></a><h2>ann_c_module(As::[term()], Name::, Exports, Es::Definitions) -&gt;</h2><p> </p><ul><li><span class="v">Exports = []</span></li><li><span class="v">Definitions = [{, }]</span></li></ul><a name="ann_c_module-4"></a><p><em>See also:</em> <a href="#ann_c_module-5">ann_c_module/5</a>, <a href="#c_module-3">c_module/3</a>.</p><h2>ann_c_module(As::[term()], Name::, Exports, Attrs::Attributes, Es::Definitions) -&gt;</h2><p> </p><ul><li><span class="v">Exports = []</span></li><li><span class="v">Attributes = [{, }]</span></li><li><span class="v">Definitions = [{, }]</span></li></ul><a name="ann_c_module-5"></a><p><em>See also:</em> <a href="#ann_c_module-4">ann_c_module/4</a>, <a href="#c_module-4">c_module/4</a>.</p><h2>ann_c_nil(As::[term()]) -&gt;</h2><p> </p><a name="ann_c_nil-1"></a><p><em>See also:</em> <a href="#c_nil-0">c_nil/0</a>.</p><h2>ann_c_primop(As::[term()], Name::, Arguments::[]) -&gt;</h2><p> </p><a name="ann_c_primop-3"></a><p><em>See also:</em> <a href="#c_primop-2">c_primop/2</a>.</p><h2>ann_c_receive(As::[term()], Clauses::[]) -&gt;</h2><p>Equivalent to ann_c_receive(As, Clauses, c_atom(infinity), c_atom(true)). </p><a name="ann_c_receive-2"></a><p>Equivalent to <a href="#ann_c_receive-4">ann_c_receive(As, Clauses, c_atom(infinity), c_atom(true))</a>.</p><p><em>See also:</em> <a href="#c_atom-1">c_atom/1</a>, <a href="#c_receive-3">c_receive/3</a>.</p><h2>ann_c_receive(As::[term()], Clauses::[], Timeout::, Action::) -&gt;</h2><p> </p><a name="ann_c_receive-4"></a><p><em>See also:</em> <a href="#ann_c_receive-2">ann_c_receive/2</a>, <a href="#c_receive-3">c_receive/3</a>.</p><h2>ann_c_seq(As::[term()], Argument::, Body::) -&gt;</h2><p> </p><a name="ann_c_seq-3"></a><p><em>See also:</em> <a href="#c_seq-2">c_seq/2</a>.</p><h2>ann_c_string(As::[term()], Value::string()) -&gt;</h2><p> </p><a name="ann_c_string-2"></a><p><em>See also:</em> <a href="#c_string-1">c_string/1</a>.</p><h2>ann_c_try(As::[term()], Expression::, Variables::[], Body::, EVars::[], Handler::) -&gt;</h2><p> </p><a name="ann_c_try-6"></a><p><em>See also:</em> <a href="#c_try-5">c_try/5</a>.</p><h2>ann_c_tuple(As::[term()], Elements::[]) -&gt;</h2><p> </p><a name="ann_c_tuple-2"></a><p><em>See also:</em> <a href="#c_tuple-1">c_tuple/1</a>.</p><h2>ann_c_tuple_skel(As::[term()], Elements::[]) -&gt;</h2><p> </p><a name="ann_c_tuple_skel-2"></a><p><em>See also:</em> <a href="#c_tuple_skel-1">c_tuple_skel/1</a>.</p><h2>ann_c_values(As::[term()], Elements::[]) -&gt;</h2><p> </p><a name="ann_c_values-2"></a><p><em>See also:</em> <a href="#c_values-1">c_values/1</a>.</p><h2>ann_c_var(As::[term()], Name::) -&gt;</h2><p> </p><a name="ann_c_var-2"></a><p><em>See also:</em> <a href="#c_var-1">c_var/1</a>.</p><h2>ann_make_data(As::[term()], Type::, Elements::[]) -&gt;</h2><p> </p><a name="ann_make_data-3"></a><p><em>See also:</em> <a href="#make_data-2">make_data/2</a>.</p><h2>ann_make_data_skel(As::[term()], Type::, Elements::[]) -&gt;</h2><p> </p><a name="ann_make_data_skel-3"></a><p><em>See also:</em> <a href="#make_data_skel-2">make_data_skel/2</a>.</p><h2>ann_make_list(As::[term()], List::[]) -&gt;</h2><p>Equivalent to ann_make_list(As, List, none). </p><a name="ann_make_list-2"></a><p>Equivalent to <a href="#ann_make_list-3">ann_make_list(As, List, none)</a>.</p><h2>ann_make_list(As::[term()], List::[], Tail) -&gt;</h2><p> </p><ul><li><span class="v">Tail =  | none</span></li></ul><a name="ann_make_list-3"></a><p><em>See also:</em> <a href="#ann_make_list-2">ann_make_list/2</a>, <a href="#make_list-2">make_list/2</a>.</p><h2>ann_make_tree(As::[term()], Type::, Groups::[[]]) -&gt;</h2><p>Creates a syntax tree with the given annotations, type and subtrees.</p><a name="ann_make_tree-3"></a><p>Creates a syntax tree with the given annotations, type and
subtrees. See <strong>make_tree/2</strong> for details.
</p><p><em>See also:</em> <a href="#make_tree-2">make_tree/2</a>.</p><h2>apply_args(Node::) -&gt; []</h2><p>Returns the list of argument subtrees of an abstract function application.</p><a name="apply_args-1"></a><p>Returns the list of argument subtrees of an abstract function
application.
</p><p><em>See also:</em> <a href="#apply_arity-1">apply_arity/1</a>, <a href="#c_apply-2">c_apply/2</a>.</p><h2>apply_arity(Node::) -&gt; arity()</h2><p>Returns the number of argument subtrees of an abstract   function application.</p><a name="apply_arity-1"></a><p>Returns the number of argument subtrees of an abstract  
function application.</p><p>Note: this is equivalent to
<strong>length(apply_args(Node))</strong>, but potentially more
efficient.</p><p><em>See also:</em> <a href="#apply_args-1">apply_args/1</a>, <a href="#c_apply-2">c_apply/2</a>.</p><h2>apply_op(Node::) -&gt;</h2><p>Returns the operator subtree of an abstract function application.</p><a name="apply_op-1"></a><p>Returns the operator subtree of an abstract function
application.
</p><p><em>See also:</em> <a href="#c_apply-2">c_apply/2</a>.</p><h2>atom_lit(Node::) -&gt; string()</h2><p>Returns the literal string represented by an abstract   atom.</p><a name="atom_lit-1"></a><p>Returns the literal string represented by an abstract  
atom. This always includes surrounding single-quote characters.</p><p>Note that an abstract atom may have several literal
representations, and that the representation yielded by this
function is not fixed; e.g.,
<strong>atom_lit(c_atom("a\012b"))</strong> could yield the string
<strong>"\'a\\nb\'"</strong>.</p><p><em>See also:</em> <a href="#c_atom-1">c_atom/1</a>.</p><h2>atom_name(Node::) -&gt; string()</h2><p>Returns the printname of an abstract atom.</p><a name="atom_name-1"></a><p>Returns the printname of an abstract atom.
</p><p><em>See also:</em> <a href="#c_atom-1">c_atom/1</a>.</p><h2>atom_val(Node::) -&gt; atom()</h2><p>Returns the value represented by an abstract atom.</p><a name="atom_val-1"></a><p>Returns the value represented by an abstract atom.
</p><p><em>See also:</em> <a href="#c_atom-1">c_atom/1</a>.</p><h2>binary_segments(Node::) -&gt; []</h2><p>Returns the list of segment subtrees of an abstract binary-template.</p><a name="binary_segments-1"></a><p>Returns the list of segment subtrees of an abstract
binary-template.
</p><p><em>See also:</em> <a href="#c_binary-1">c_binary/1</a>, <a href="#c_bitstr-5">c_bitstr/5</a>.</p><h2>bitstr_bitsize(Node::) -&gt; any | all | utf | integer()</h2><p>Returns the total size in bits of an abstract bit-string template.</p><a name="bitstr_bitsize-1"></a><p>Returns the total size in bits of an abstract bit-string
template. If the size field is an integer literal, the result is the
product of the size and unit values; if the size field is the atom
literal <strong>all</strong>, the atom <strong>all</strong> is returned.
If the size is not a literal, the atom <strong>any</strong> is returned.
</p><p><em>See also:</em> <a href="#c_bitstr-5">c_bitstr/5</a>.</p><h2>bitstr_flags(Node::) -&gt;</h2><p>Returns the flags subtree of an abstract bit-string template.</p><a name="bitstr_flags-1"></a><p>Returns the flags subtree of an abstract bit-string template.
</p><p><em>See also:</em> <a href="#c_bitstr-5">c_bitstr/5</a>.</p><h2>bitstr_size(Node::) -&gt;</h2><p>Returns the size subtree of an abstract bit-string template.</p><a name="bitstr_size-1"></a><p>Returns the size subtree of an abstract bit-string template.
</p><p><em>See also:</em> <a href="#c_bitstr-5">c_bitstr/5</a>.</p><h2>bitstr_type(Node::) -&gt;</h2><p>Returns the type subtree of an abstract bit-string template.</p><a name="bitstr_type-1"></a><p>Returns the type subtree of an abstract bit-string template.
</p><p><em>See also:</em> <a href="#c_bitstr-5">c_bitstr/5</a>.</p><h2>bitstr_unit(Node::) -&gt;</h2><p>Returns the unit subtree of an abstract bit-string template.</p><a name="bitstr_unit-1"></a><p>Returns the unit subtree of an abstract bit-string template.
</p><p><em>See also:</em> <a href="#c_bitstr-5">c_bitstr/5</a>.</p><h2>bitstr_val(Node::) -&gt;</h2><p>Returns the value subtree of an abstract bit-string template.</p><a name="bitstr_val-1"></a><p>Returns the value subtree of an abstract bit-string template.
</p><p><em>See also:</em> <a href="#c_bitstr-5">c_bitstr/5</a>.</p><h2>c_alias(Variable::, Pattern::) -&gt;</h2><p>Creates an abstract pattern alias.</p><a name="c_alias-2"></a><p>Creates an abstract pattern alias. The result represents
"<strong>Variable = Pattern</strong>".
</p><p><em>See also:</em> <a href="#alias_pat-1">alias_pat/1</a>, <a href="#alias_var-1">alias_var/1</a>, <a href="#ann_c_alias-3">ann_c_alias/3</a>, <a href="#c_clause-3">c_clause/3</a>, <a href="#is_c_alias-1">is_c_alias/1</a>, <a href="#update_c_alias-3">update_c_alias/3</a>.</p><h2>c_apply(Operator::, Arguments::[]) -&gt;</h2><p>Creates an abstract function application.</p><a name="c_apply-2"></a><p>Creates an abstract function application. If
<strong>Arguments</strong> is <strong>[A1, ..., An]</strong>, the result
represents "<strong>apply Operator(A1, ..., An)</strong>".
</p><p><em>See also:</em> <a href="#ann_c_apply-3">ann_c_apply/3</a>, <a href="#apply_args-1">apply_args/1</a>, <a href="#apply_arity-1">apply_arity/1</a>, <a href="#apply_op-1">apply_op/1</a>, <a href="#c_call-3">c_call/3</a>, <a href="#c_primop-2">c_primop/2</a>, <a href="#is_c_apply-1">is_c_apply/1</a>, <a href="#update_c_apply-3">update_c_apply/3</a>.</p><h2>c_atom(Name) -&gt;</h2><p>Creates an abstract atom literal.</p><ul><li><span class="v">Name = atom() | string()</span></li></ul><a name="c_atom-1"></a><p>Creates an abstract atom literal.  The print name of the atom
is the character sequence represented by <strong>Name</strong>.</p><p>Note: passing a string as argument to this function causes a
corresponding atom to be created for the internal representation.</p><p><em>See also:</em> <a href="#ann_c_atom-2">ann_c_atom/2</a>, <a href="#atom_lit-1">atom_lit/1</a>, <a href="#atom_name-1">atom_name/1</a>, <a href="#atom_val-1">atom_val/1</a>, <a href="#is_c_atom-1">is_c_atom/1</a>.</p><h2>c_binary(Segments::[]) -&gt;</h2><p>Creates an abstract binary-template.</p><a name="c_binary-1"></a><p>Creates an abstract binary-template. A binary object is in
this context a sequence of an arbitrary number of bits. (The number
of bits used to be evenly divisible by 8, but after the
introduction of bit strings in the Erlang language, the choice was
made to use the binary template for all bit strings.) It is
specified by zero or more bit-string template <em>segments</em> of
arbitrary lengths (in number of bits). If <strong>Segments</strong> is
<strong>[S1, ..., Sn]</strong>, the result represents
"<strong>#{S1, ..., Sn}#</strong>". All the
<strong>Si</strong> must have type <strong>bitstr</strong>.
</p><p><em>See also:</em> <a href="#ann_c_binary-2">ann_c_binary/2</a>, <a href="#binary_segments-1">binary_segments/1</a>, <a href="#c_bitstr-5">c_bitstr/5</a>, <a href="#is_c_binary-1">is_c_binary/1</a>, <a href="#update_c_binary-2">update_c_binary/2</a>.</p><h2>c_bitstr(Value::, Type::, Flags::) -&gt;</h2><p>Equivalent to c_bitstr(Value, abstract(all), abstract(1), Type, Flags). </p><a name="c_bitstr-3"></a><p>Equivalent to <a href="#c_bitstr-5">c_bitstr(Value, abstract(all), abstract(1), Type, Flags)</a>.</p><h2>c_bitstr(Value::, Size::, Type::, Flags::) -&gt;</h2><p>Equivalent to c_bitstr(Value, Size, abstract(1), Type, Flags). </p><a name="c_bitstr-4"></a><p>Equivalent to <a href="#c_bitstr-5">c_bitstr(Value, Size, abstract(1), Type, Flags)</a>.</p><h2>c_bitstr(Value::, Size::, Unit::, Type::, Flags::) -&gt;</h2><p>Creates an abstract bit-string template.</p><a name="c_bitstr-5"></a><p>Creates an abstract bit-string template. These can only occur as
components of an abstract binary-template (see <a href="#c_binary-1">c_binary/1</a>).
The result represents "<strong>#&lt;Value&gt;(Size, Unit, Type, Flags)</strong>", where
<strong>Unit</strong> must represent a positive integer constant,
<strong>Type</strong> must represent a constant atom (one of
<strong>'integer'</strong>, <strong>'float'</strong>, or
<strong>'binary'</strong>), and <strong>Flags</strong> must represent a
constant list <strong>"[F1, ..., Fn]"</strong> where
all the <strong>Fi</strong> are atoms.
</p><p><em>See also:</em> <a href="#ann_c_bitstr-6">ann_c_bitstr/6</a>, <a href="#bitstr_flags-1">bitstr_flags/1</a>, <a href="#bitstr_size-1">bitstr_size/1</a>, <a href="#bitstr_type-1">bitstr_type/1</a>, <a href="#bitstr_unit-1">bitstr_unit/1</a>, <a href="#bitstr_val-1">bitstr_val/1</a>, <a href="#c_binary-1">c_binary/1</a>, <a href="#is_c_bitstr-1">is_c_bitstr/1</a>, <a href="#update_c_bitstr-6">update_c_bitstr/6</a>.</p><h2>c_call(Module::, Name::, Arguments::[]) -&gt;</h2><p>Creates an abstract inter-module call.</p><a name="c_call-3"></a><p>Creates an abstract inter-module call. If
<strong>Arguments</strong> is <strong>[A1, ..., An]</strong>, the result
represents "<strong>call Module:Name(A1, ..., An)</strong>".
</p><p><em>See also:</em> <a href="#ann_c_call-4">ann_c_call/4</a>, <a href="#c_apply-2">c_apply/2</a>, <a href="#c_primop-2">c_primop/2</a>, <a href="#call_args-1">call_args/1</a>, <a href="#call_arity-1">call_arity/1</a>, <a href="#call_module-1">call_module/1</a>, <a href="#call_name-1">call_name/1</a>, <a href="#is_c_call-1">is_c_call/1</a>, <a href="#update_c_call-4">update_c_call/4</a>.</p><h2>c_case(Argument::, Clauses::[]) -&gt;</h2><p>Creates an abstract case-expression.</p><a name="c_case-2"></a><p>Creates an abstract case-expression. If <strong>Clauses</strong>
is <strong>[C1, ..., Cn]</strong>, the result represents "<strong>case Argument of C1 ... Cn end</strong>". <strong>Clauses</strong> must not be empty.
</p><p><em>See also:</em> <a href="#ann_c_case-3">ann_c_case/3</a>, <a href="#c_clause-3">c_clause/3</a>, <a href="#case_arg-1">case_arg/1</a>, <a href="#case_arity-1">case_arity/1</a>, <a href="#case_clauses-1">case_clauses/1</a>, <a href="#is_c_case-1">is_c_case/1</a>, <a href="#update_c_case-3">update_c_case/3</a>.</p><h2>c_catch(Body::) -&gt;</h2><p>Creates an abstract catch-expression.</p><a name="c_catch-1"></a><p>Creates an abstract catch-expression. The result represents
"<strong>catch Body</strong>".</p><p>Note: catch-expressions can be rewritten as try-expressions, and
will eventually be removed from Core Erlang.</p><p><em>See also:</em> <a href="#ann_c_catch-2">ann_c_catch/2</a>, <a href="#c_try-5">c_try/5</a>, <a href="#catch_body-1">catch_body/1</a>, <a href="#is_c_catch-1">is_c_catch/1</a>, <a href="#update_c_catch-2">update_c_catch/2</a>.</p><h2>c_char(Value) -&gt;</h2><p>Creates an abstract character literal.</p><ul><li><span class="v">Value = char() | integer()</span></li></ul><a name="c_char-1"></a><p>Creates an abstract character literal. If the local
implementation of Erlang defines <strong>char()</strong> as a subset of
<strong>integer()</strong>, this function is equivalent to
<strong>c_int/1</strong>. Otherwise, if the given value is an integer,
it will be converted to the character with the corresponding
code. The lexical representation of a character is
"<strong>$Char</strong>", where <strong>Char</strong> is a single
printing character or an escape sequence.
</p><p><em>See also:</em> <a href="#ann_c_char-2">ann_c_char/2</a>, <a href="#c_int-1">c_int/1</a>, <a href="#c_string-1">c_string/1</a>, <a href="#char_lit-1">char_lit/1</a>, <a href="#char_val-1">char_val/1</a>, <a href="#is_c_char-1">is_c_char/1</a>, <a href="#is_print_char-1">is_print_char/1</a>.</p><h2>c_clause(Patterns::[], Body::) -&gt;</h2><p>Equivalent to c_clause(Patterns, c_atom(true), Body). </p><a name="c_clause-2"></a><p>Equivalent to <a href="#c_clause-3">c_clause(Patterns, c_atom(true), Body)</a>.</p><p><em>See also:</em> <a href="#c_atom-1">c_atom/1</a>.</p><h2>c_clause(Patterns::[], Guard::, Body::) -&gt;</h2><p>Creates an an abstract clause.</p><a name="c_clause-3"></a><p>Creates an an abstract clause. If <strong>Patterns</strong> is
<strong>[P1, ..., Pn]</strong>, the result represents
"<strong>&lt;P1, ..., Pn&gt; when Guard -&gt; Body</strong>".
</p><p><em>See also:</em> <a href="#ann_c_clause-4">ann_c_clause/4</a>, <a href="#c_case-2">c_case/2</a>, <a href="#c_clause-2">c_clause/2</a>, <a href="#c_receive-3">c_receive/3</a>, <a href="#clause_arity-1">clause_arity/1</a>, <a href="#clause_body-1">clause_body/1</a>, <a href="#clause_guard-1">clause_guard/1</a>, <a href="#clause_pats-1">clause_pats/1</a>, <a href="#clause_vars-1">clause_vars/1</a>, <a href="#is_c_clause-1">is_c_clause/1</a>, <a href="#update_c_clause-4">update_c_clause/4</a>.</p><h2>c_cons(Head::, Tail::) -&gt;</h2><p>Creates an abstract list constructor.</p><a name="c_cons-2"></a><p>Creates an abstract list constructor. The result represents
"<strong>[Head | Tail]</strong>". Note that if both
<strong>Head</strong> and <strong>Tail</strong> have type
<strong>literal</strong>, then the result will also have type
<strong>literal</strong>, and annotations on <strong>Head</strong> and
<strong>Tail</strong> are lost.</p><p>Recall that in Erlang, the tail element of a list constructor is
not necessarily a list.</p><p><em>See also:</em> <a href="#ann_c_cons-3">ann_c_cons/3</a>, <a href="#c_cons_skel-2">c_cons_skel/2</a>, <a href="#c_nil-0">c_nil/0</a>, <a href="#cons_hd-1">cons_hd/1</a>, <a href="#cons_tl-1">cons_tl/1</a>, <a href="#is_c_cons-1">is_c_cons/1</a>, <a href="#is_c_list-1">is_c_list/1</a>, <a href="#list_elements-1">list_elements/1</a>, <a href="#list_length-1">list_length/1</a>, <a href="#make_list-2">make_list/2</a>, <a href="#update_c_cons-3">update_c_cons/3</a>.</p><h2>c_cons_skel(Head::, Tail::) -&gt;</h2><p>Creates an abstract list constructor skeleton.</p><a name="c_cons_skel-2"></a><p>Creates an abstract list constructor skeleton. Does not fold
constant literals, i.e., the result always has type
<strong>cons</strong>, representing "<strong>[Head | Tail]</strong>".</p><p>This function is occasionally useful when it is necessary to have
annotations on the subnodes of a list constructor node, even when the
subnodes are constant literals. Note however that
<strong>is_literal/1</strong> will yield <strong>false</strong> and
<strong>concrete/1</strong> will fail if passed the result from this
function.</p><p><strong>fold_literal/1</strong> can be used to revert a node to the
normal-form representation.</p><p><em>See also:</em> <a href="#ann_c_cons_skel-3">ann_c_cons_skel/3</a>, <a href="#c_cons-2">c_cons/2</a>, <a href="#c_nil-0">c_nil/0</a>, <a href="#concrete-1">concrete/1</a>, <a href="#fold_literal-1">fold_literal/1</a>, <a href="#is_c_cons-1">is_c_cons/1</a>, <a href="#is_c_list-1">is_c_list/1</a>, <a href="#is_literal-1">is_literal/1</a>, <a href="#update_c_cons_skel-3">update_c_cons_skel/3</a>.</p><h2>c_float(Value::float()) -&gt;</h2><p>Creates an abstract floating-point literal.</p><a name="c_float-1"></a><p>Creates an abstract floating-point literal.  The lexical
representation is the decimal floating-point numeral of
<strong>Value</strong>.
</p><p><em>See also:</em> <a href="#ann_c_float-2">ann_c_float/2</a>, <a href="#float_lit-1">float_lit/1</a>, <a href="#float_val-1">float_val/1</a>, <a href="#is_c_float-1">is_c_float/1</a>.</p><h2>c_fname(Name::atom(), Arity::arity()) -&gt;</h2><p>Equivalent to c_var({Name, Arity}). </p><a name="c_fname-2"></a><p>Equivalent to <a href="#c_var-1">c_var({Name, Arity})</a>.</p><p><em>See also:</em> <a href="#ann_c_fname-3">ann_c_fname/3</a>, <a href="#fname_arity-1">fname_arity/1</a>, <a href="#fname_id-1">fname_id/1</a>, <a href="#is_c_fname-1">is_c_fname/1</a>, <a href="#update_c_fname-3">update_c_fname/3</a>.</p><h2>c_fun(Variables::[], Body::) -&gt;</h2><p>Creates an abstract fun-expression.</p><a name="c_fun-2"></a><p>Creates an abstract fun-expression. If <strong>Variables</strong>
is <strong>[V1, ..., Vn]</strong>, the result represents "<strong>fun (V1, ..., Vn) -&gt; Body</strong>". All the
<strong>Vi</strong> must have type <strong>var</strong>.
</p><p><em>See also:</em> <a href="#ann_c_fun-3">ann_c_fun/3</a>, <a href="#fun_arity-1">fun_arity/1</a>, <a href="#fun_body-1">fun_body/1</a>, <a href="#fun_vars-1">fun_vars/1</a>, <a href="#is_c_fun-1">is_c_fun/1</a>, <a href="#update_c_fun-3">update_c_fun/3</a>.</p><h2>c_int(Value::integer()) -&gt;</h2><p>Creates an abstract integer literal.</p><a name="c_int-1"></a><p>Creates an abstract integer literal. The lexical
representation is the canonical decimal numeral of
<strong>Value</strong>.
</p><p><em>See also:</em> <a href="#ann_c_int-2">ann_c_int/2</a>, <a href="#c_char-1">c_char/1</a>, <a href="#int_lit-1">int_lit/1</a>, <a href="#int_val-1">int_val/1</a>, <a href="#is_c_int-1">is_c_int/1</a>.</p><h2>c_let(Variables::[], Argument::, Body::) -&gt;</h2><p>Creates an abstract let-expression.</p><a name="c_let-3"></a><p>Creates an abstract let-expression. If <strong>Variables</strong>
is <strong>[V1, ..., Vn]</strong>, the result represents "<strong>let &lt;V1, ..., Vn&gt; = Argument in Body</strong>".  All the <strong>Vi</strong> must have type
<strong>var</strong>.
</p><p><em>See also:</em> <a href="#ann_c_let-4">ann_c_let/4</a>, <a href="#is_c_let-1">is_c_let/1</a>, <a href="#let_arg-1">let_arg/1</a>, <a href="#let_arity-1">let_arity/1</a>, <a href="#let_body-1">let_body/1</a>, <a href="#let_vars-1">let_vars/1</a>, <a href="#update_c_let-4">update_c_let/4</a>.</p><h2>c_letrec(Definitions::[{,}], Body::) -&gt;</h2><p>Creates an abstract letrec-expression.</p><a name="c_letrec-2"></a><p>Creates an abstract letrec-expression. If
<strong>Definitions</strong> is <strong>[{V1, F1}, ..., {Vn, Fn}]</strong>,
the result represents "<strong>letrec V1 = F1 ... Vn = Fn in Body</strong>.  All the
<strong>Vi</strong> must have type <strong>var</strong> and represent
function names.  All the <strong>Fi</strong> must have type
<strong>'fun'</strong>.
</p><p><em>See also:</em> <a href="#ann_c_letrec-3">ann_c_letrec/3</a>, <a href="#is_c_letrec-1">is_c_letrec/1</a>, <a href="#letrec_body-1">letrec_body/1</a>, <a href="#letrec_defs-1">letrec_defs/1</a>, <a href="#letrec_vars-1">letrec_vars/1</a>, <a href="#update_c_letrec-3">update_c_letrec/3</a>.</p><h2>c_map(Pairs::[]) -&gt;</h2><p> </p><a name="c_map-1"></a><h2>c_map_pair(Key::, Val::) -&gt;</h2><p> </p><a name="c_map_pair-2"></a><h2>c_map_pair_exact(Key::, Val::) -&gt;</h2><p> </p><a name="c_map_pair_exact-2"></a><h2>c_map_pattern(Pairs::[]) -&gt;</h2><p> </p><a name="c_map_pattern-1"></a><h2>c_module(Name::, Exports, Es::Definitions) -&gt;</h2><p>Equivalent to c_module(Name, Exports, [], Definitions). </p><ul><li><span class="v">Exports = []</span></li><li><span class="v">Definitions = [{, }]</span></li></ul><a name="c_module-3"></a><p>Equivalent to <a href="#c_module-4">c_module(Name, Exports, [], Definitions)</a>.</p><h2>c_module(Name::, Exports, Attrs::Attributes, Es::Definitions) -&gt;</h2><p>Creates an abstract module definition.</p><ul><li><span class="v">Exports = []</span></li><li><span class="v">Attributes = [{, }]</span></li><li><span class="v">Definitions = [{, }]</span></li></ul><a name="c_module-4"></a><p>Creates an abstract module definition. The result represents
</p><pre>
    module Name [E1, ..., Ek]
      attributes [K1 = T1, ...,
                  Km = Tm]
      V1 = F1
      ...
      Vn = Fn
    end</pre><p>
</p><p>if <strong>Exports</strong> = <strong>[E1, ..., Ek]</strong>,
<strong>Attributes</strong> = <strong>[{K1, T1}, ..., {Km, Tm}]</strong>,
and <strong>Definitions</strong> = <strong>[{V1, F1}, ..., {Vn, Fn}]</strong>.</p><p><strong>Name</strong> and all the <strong>Ki</strong> must be atom
literals, and all the <strong>Ti</strong> must be constant literals. All
the <strong>Vi</strong> and <strong>Ei</strong> must have type
<strong>var</strong> and represent function names. All the
<strong>Fi</strong> must have type <strong>'fun'</strong>.</p><p><em>See also:</em> <a href="#ann_c_module-4">ann_c_module/4</a>, <a href="#ann_c_module-5">ann_c_module/5</a>, <a href="#c_atom-1">c_atom/1</a>, <a href="#c_fun-2">c_fun/2</a>, <a href="#c_module-3">c_module/3</a>, <a href="#c_var-1">c_var/1</a>, <a href="#is_literal-1">is_literal/1</a>, <a href="#module_attrs-1">module_attrs/1</a>, <a href="#module_defs-1">module_defs/1</a>, <a href="#module_exports-1">module_exports/1</a>, <a href="#module_name-1">module_name/1</a>, <a href="#module_vars-1">module_vars/1</a>, <a href="#update_c_module-5">update_c_module/5</a>.</p><h2>c_nil() -&gt;</h2><p>Creates an abstract empty list.</p><a name="c_nil-0"></a><p>Creates an abstract empty list. The result represents
"<strong>[]</strong>". The empty list is traditionally called "nil".
</p><p><em>See also:</em> <a href="#ann_c_nil-1">ann_c_nil/1</a>, <a href="#c_cons-2">c_cons/2</a>, <a href="#is_c_list-1">is_c_list/1</a>.</p><h2>c_primop(Name::, Arguments::[]) -&gt;</h2><p>Creates an abstract primitive operation call.</p><a name="c_primop-2"></a><p>Creates an abstract primitive operation call. If
<strong>Arguments</strong> is <strong>[A1, ..., An]</strong>, the result
represents "<strong>primop Name(A1, ..., An)</strong>". <strong>Name</strong> must be an atom literal.
</p><p><em>See also:</em> <a href="#ann_c_primop-3">ann_c_primop/3</a>, <a href="#c_apply-2">c_apply/2</a>, <a href="#c_call-3">c_call/3</a>, <a href="#is_c_primop-1">is_c_primop/1</a>, <a href="#primop_args-1">primop_args/1</a>, <a href="#primop_arity-1">primop_arity/1</a>, <a href="#primop_name-1">primop_name/1</a>, <a href="#update_c_primop-3">update_c_primop/3</a>.</p><h2>c_receive(Clauses::[]) -&gt;</h2><p>Equivalent to c_receive(Clauses, c_atom(infinity), c_atom(true)). </p><a name="c_receive-1"></a><p>Equivalent to <a href="#c_receive-3">c_receive(Clauses, c_atom(infinity), c_atom(true))</a>.</p><p><em>See also:</em> <a href="#c_atom-1">c_atom/1</a>.</p><h2>c_receive(Clauses::[], Timeout::, Action::) -&gt;</h2><p>Creates an abstract receive-expression.</p><a name="c_receive-3"></a><p>Creates an abstract receive-expression. If
<strong>Clauses</strong> is <strong>[C1, ..., Cn]</strong>, the result
represents "<strong>receive C1 ... Cn after Timeout -&gt; Action end</strong>".
</p><p><em>See also:</em> <a href="#ann_c_receive-4">ann_c_receive/4</a>, <a href="#c_receive-1">c_receive/1</a>, <a href="#is_c_receive-1">is_c_receive/1</a>, <a href="#receive_action-1">receive_action/1</a>, <a href="#receive_clauses-1">receive_clauses/1</a>, <a href="#receive_timeout-1">receive_timeout/1</a>, <a href="#update_c_receive-4">update_c_receive/4</a>.</p><h2>c_seq(Argument::, Body::) -&gt;</h2><p>Creates an abstract sequencing expression.</p><a name="c_seq-2"></a><p>Creates an abstract sequencing expression. The result
represents "<strong>do Argument Body</strong>".
</p><p><em>See also:</em> <a href="#ann_c_seq-3">ann_c_seq/3</a>, <a href="#is_c_seq-1">is_c_seq/1</a>, <a href="#seq_arg-1">seq_arg/1</a>, <a href="#seq_body-1">seq_body/1</a>, <a href="#update_c_seq-3">update_c_seq/3</a>.</p><h2>c_string(Value::string()) -&gt;</h2><p>Creates an abstract string literal.</p><a name="c_string-1"></a><p>Creates an abstract string literal. Equivalent to creating an
abstract list of the corresponding character literals
(cf. <strong>is_c_string/1</strong>), but is typically more
efficient. The lexical representation of a string is
"<strong>"Chars"</strong>", where <strong>Chars</strong> is a
sequence of printing characters or spaces.
</p><p><em>See also:</em> <a href="#ann_c_string-2">ann_c_string/2</a>, <a href="#c_char-1">c_char/1</a>, <a href="#is_c_string-1">is_c_string/1</a>, <a href="#is_print_string-1">is_print_string/1</a>, <a href="#string_lit-1">string_lit/1</a>, <a href="#string_val-1">string_val/1</a>.</p><h2>c_try(Argument::, Variables::[], Body::, ExceptionVars::[], Handler::) -&gt;</h2><p>Creates an abstract try-expression.</p><a name="c_try-5"></a><p>Creates an abstract try-expression. If <strong>Variables</strong> is
<strong>[V1, ..., Vn]</strong> and <strong>ExceptionVars</strong> is
<strong>[X1, ..., Xm]</strong>, the result represents "<strong>try Argument of &lt;V1, ..., Vn&gt; -&gt; Body catch &lt;X1, ..., Xm&gt; -&gt; Handler</strong>". All the <strong>Vi</strong> and <strong>Xi</strong>
must have type <strong>var</strong>.
</p><p><em>See also:</em> <a href="#ann_c_try-6">ann_c_try/6</a>, <a href="#c_catch-1">c_catch/1</a>, <a href="#is_c_try-1">is_c_try/1</a>, <a href="#try_arg-1">try_arg/1</a>, <a href="#try_body-1">try_body/1</a>, <a href="#try_vars-1">try_vars/1</a>, <a href="#update_c_try-6">update_c_try/6</a>.</p><h2>c_tuple(Elements::[]) -&gt;</h2><p>Creates an abstract tuple.</p><a name="c_tuple-1"></a><p>Creates an abstract tuple. If <strong>Elements</strong> is
<strong>[E1, ..., En]</strong>, the result represents
"<strong>{E1, ..., En}</strong>".  Note that if all
nodes in <strong>Elements</strong> have type <strong>literal</strong>, or if
<strong>Elements</strong> is empty, then the result will also have type
<strong>literal</strong> and annotations on nodes in
<strong>Elements</strong> are lost.</p><p>Recall that Erlang has distinct 1-tuples, i.e., <strong>{X}</strong>
is always distinct from <strong>X</strong> itself.</p><p><em>See also:</em> <a href="#ann_c_tuple-2">ann_c_tuple/2</a>, <a href="#c_tuple_skel-1">c_tuple_skel/1</a>, <a href="#is_c_tuple-1">is_c_tuple/1</a>, <a href="#tuple_arity-1">tuple_arity/1</a>, <a href="#tuple_es-1">tuple_es/1</a>, <a href="#update_c_tuple-2">update_c_tuple/2</a>.</p><h2>c_tuple_skel(Elements::[]) -&gt;</h2><p>Creates an abstract tuple skeleton.</p><a name="c_tuple_skel-1"></a><p>Creates an abstract tuple skeleton. Does not fold constant
literals, i.e., the result always has type <strong>tuple</strong>,
representing "<strong>{E1, ..., En}</strong>", if
<strong>Elements</strong> is <strong>[E1, ..., En]</strong>.</p><p>This function is occasionally useful when it is necessary to have
annotations on the subnodes of a tuple node, even when all the
subnodes are constant literals. Note however that
<strong>is_literal/1</strong> will yield <strong>false</strong> and
<strong>concrete/1</strong> will fail if passed the result from this
function.</p><p><strong>fold_literal/1</strong> can be used to revert a node to the
normal-form representation.</p><p><em>See also:</em> <a href="#ann_c_tuple_skel-2">ann_c_tuple_skel/2</a>, <a href="#c_tuple-1">c_tuple/1</a>, <a href="#concrete-1">concrete/1</a>, <a href="#fold_literal-1">fold_literal/1</a>, <a href="#is_c_tuple-1">is_c_tuple/1</a>, <a href="#is_literal-1">is_literal/1</a>, <a href="#tuple_es-1">tuple_es/1</a>, <a href="#update_c_tuple_skel-2">update_c_tuple_skel/2</a>.</p><h2>c_values(Elements::[]) -&gt;</h2><p>Creates an abstract value list.</p><a name="c_values-1"></a><p>Creates an abstract value list. If <strong>Elements</strong> is
<strong>[E1, ..., En]</strong>, the result represents
"<strong>&lt;E1, ..., En&gt;</strong>".
</p><p><em>See also:</em> <a href="#ann_c_values-2">ann_c_values/2</a>, <a href="#is_c_values-1">is_c_values/1</a>, <a href="#update_c_values-2">update_c_values/2</a>, <a href="#values_arity-1">values_arity/1</a>, <a href="#values_es-1">values_es/1</a>.</p><h2>c_var(Name::) -&gt;</h2><p>Creates an abstract variable.</p><ul><li><span class="v">var_name() = integer() | atom() | {atom(), integer()}</span></li></ul><a name="c_var-1"></a><p>Creates an abstract variable. A variable is identified by its
name, given by the <strong>Name</strong> parameter.</p><p>If a name is given by a single atom, it should either be a
"simple" atom which does not need to be single-quoted in Erlang, or
otherwise its print name should correspond to a proper Erlang
variable, i.e., begin with an uppercase character or an
underscore. Names on the form <strong>{A, N}</strong> represent
function name variables "<strong>A/N</strong>"; these
are special variables which may be bound only in the function
definitions of a module or a <strong>letrec</strong>.  They may not be
bound in <strong>let</strong> expressions and cannot occur in clause
patterns. The atom <strong>A</strong> in a function name may be any
atom; the integer <strong>N</strong> must be nonnegative. The functions
<strong>c_fname/2</strong> etc. are utilities for handling function
name variables.</p><p>When printing variable names, they must have the form of proper
Core Erlang variables and function names. E.g., a name represented
by an integer such as <strong>42</strong> could be formatted as
"<strong>_42</strong>", an atom <strong>'Xxx'</strong> simply as
"<strong>Xxx</strong>", and an atom <strong>foo</strong> as
"<strong>_foo</strong>". However, one must assure that any two valid
distinct names are never mapped to the same strings.  Tuples such
as <strong>{foo, 2}</strong> representing function names can simply by
formatted as "<strong>'foo'/2</strong>", with no risk of conflicts.</p><p><em>See also:</em> <a href="#ann_c_var-2">ann_c_var/2</a>, <a href="#c_fname-2">c_fname/2</a>, <a href="#c_letrec-2">c_letrec/2</a>, <a href="#c_module-4">c_module/4</a>, <a href="#is_c_var-1">is_c_var/1</a>, <a href="#update_c_var-2">update_c_var/2</a>, <a href="#var_name-1">var_name/1</a>.</p><h2>call_args(Node::) -&gt; []</h2><p>Returns the list of argument subtrees of an abstract inter-module call.</p><a name="call_args-1"></a><p>Returns the list of argument subtrees of an abstract
inter-module call.
</p><p><em>See also:</em> <a href="#c_call-3">c_call/3</a>, <a href="#call_arity-1">call_arity/1</a>.</p><h2>call_arity(Node::) -&gt; arity()</h2><p>Returns the number of argument subtrees of an abstract   inter-module call.</p><a name="call_arity-1"></a><p>Returns the number of argument subtrees of an abstract  
inter-module call.</p><p>Note: this is equivalent to
<strong>length(call_args(Node))</strong>, but potentially more
efficient.</p><p><em>See also:</em> <a href="#c_call-3">c_call/3</a>, <a href="#call_args-1">call_args/1</a>.</p><h2>call_module(Node::) -&gt;</h2><p>Returns the module subtree of an abstract inter-module call.</p><a name="call_module-1"></a><p>Returns the module subtree of an abstract inter-module call.
</p><p><em>See also:</em> <a href="#c_call-3">c_call/3</a>.</p><h2>call_name(Node::) -&gt;</h2><p>Returns the name subtree of an abstract inter-module call.</p><a name="call_name-1"></a><p>Returns the name subtree of an abstract inter-module call.
</p><p><em>See also:</em> <a href="#c_call-3">c_call/3</a>.</p><h2>case_arg(Node::) -&gt;</h2><p>Returns the argument subtree of an abstract case-expression.</p><a name="case_arg-1"></a><p>Returns the argument subtree of an abstract case-expression.
</p><p><em>See also:</em> <a href="#c_case-2">c_case/2</a>.</p><h2>case_arity(Node::) -&gt; integer()</h2><p>Equivalent to clause_arity(hd(case_clauses(Node))), but potentially more efficient.</p><a name="case_arity-1"></a><p>Equivalent to
<strong>clause_arity(hd(case_clauses(Node)))</strong>, but potentially
more efficient.
</p><p><em>See also:</em> <a href="#c_case-2">c_case/2</a>, <a href="#case_clauses-1">case_clauses/1</a>, <a href="#clause_arity-1">clause_arity/1</a>.</p><h2>case_clauses(Node::) -&gt; []</h2><p>Returns the list of clause subtrees of an abstract case-expression.</p><a name="case_clauses-1"></a><p>Returns the list of clause subtrees of an abstract
case-expression.
</p><p><em>See also:</em> <a href="#c_case-2">c_case/2</a>, <a href="#case_arity-1">case_arity/1</a>.</p><h2>catch_body(Node::) -&gt;</h2><p>Returns the body subtree of an abstract catch-expression.</p><a name="catch_body-1"></a><p>Returns the body subtree of an abstract catch-expression.
</p><p><em>See also:</em> <a href="#c_catch-1">c_catch/1</a>.</p><h2>char_lit(Node::) -&gt; string()</h2><p>Returns the literal string represented by an abstract character.</p><a name="char_lit-1"></a><p>Returns the literal string represented by an abstract
character. This includes a leading <strong>$</strong>
character. Currently, all characters that are not in the set of ISO
8859-1 (Latin-1) "printing" characters will be escaped.
</p><p><em>See also:</em> <a href="#c_char-1">c_char/1</a>.</p><h2>char_val(Node::) -&gt; char()</h2><p>Returns the value represented by an abstract character literal.</p><a name="char_val-1"></a><p>Returns the value represented by an abstract character literal.
</p><p><em>See also:</em> <a href="#c_char-1">c_char/1</a>.</p><h2>clause_arity(Node::) -&gt; integer()</h2><p>Returns the number of pattern subtrees of an abstract clause.</p><a name="clause_arity-1"></a><p>Returns the number of pattern subtrees of an abstract clause.</p><p>Note: this is equivalent to
<strong>length(clause_pats(Node))</strong>, but potentially more
efficient.</p><p><em>See also:</em> <a href="#c_clause-3">c_clause/3</a>, <a href="#clause_pats-1">clause_pats/1</a>.</p><h2>clause_body(Node::) -&gt;</h2><p>Returns the body subtree of an abstract clause.</p><a name="clause_body-1"></a><p>Returns the body subtree of an abstract clause.
</p><p><em>See also:</em> <a href="#c_clause-3">c_clause/3</a>.</p><h2>clause_guard(Node::) -&gt;</h2><p>Returns the guard subtree of an abstract clause.</p><a name="clause_guard-1"></a><p>Returns the guard subtree of an abstract clause.
</p><p><em>See also:</em> <a href="#c_clause-3">c_clause/3</a>.</p><h2>clause_pats(Node::) -&gt; []</h2><p>Returns the list of pattern subtrees of an abstract clause.</p><a name="clause_pats-1"></a><p>Returns the list of pattern subtrees of an abstract clause.
</p><p><em>See also:</em> <a href="#c_clause-3">c_clause/3</a>, <a href="#clause_arity-1">clause_arity/1</a>.</p><h2>clause_vars(Clause::) -&gt; []</h2><p>Returns the list of all abstract variables in the patterns of an abstract clause.</p><a name="clause_vars-1"></a><p>Returns the list of all abstract variables in the patterns of
an abstract clause. The order of listing is not defined.
</p><p><em>See also:</em> <a href="#c_clause-3">c_clause/3</a>, <a href="#pat_list_vars-1">pat_list_vars/1</a>.</p><h2>concrete(Node::) -&gt; term()</h2><p>Returns the Erlang term represented by a syntax tree.</p><a name="concrete-1"></a><p>Returns the Erlang term represented by a syntax tree.  An
exception is thrown if <strong>Node</strong> does not represent a  
literal term.</p><p>Note: This is a constant time operation.</p><p><em>See also:</em> <a href="#abstract-1">abstract/1</a>, <a href="#is_literal-1">is_literal/1</a>.</p><h2>cons_hd(C_cons::) -&gt;</h2><p>Returns the head subtree of an abstract list constructor.</p><a name="cons_hd-1"></a><p>Returns the head subtree of an abstract list constructor.
</p><p><em>See also:</em> <a href="#c_cons-2">c_cons/2</a>.</p><h2>cons_tl(C_cons::) -&gt;</h2><p>Returns the tail subtree of an abstract list constructor.</p><a name="cons_tl-1"></a><p>Returns the tail subtree of an abstract list constructor.</p><p>Recall that the tail does not necessarily represent a proper
list.</p><p><em>See also:</em> <a href="#c_cons-2">c_cons/2</a>.</p><h2>copy_ann(Source::, Target::) -&gt;</h2><p>Copies the list of user annotations from Source to Target.</p><a name="copy_ann-2"></a><p>Copies the list of user annotations from <strong>Source</strong>
to <strong>Target</strong>.</p><p>Note: this is equivalent to <strong>set_ann(Target, get_ann(Source))</strong>, but potentially more efficient.</p><p><em>See also:</em> <a href="#get_ann-1">get_ann/1</a>, <a href="#set_ann-2">set_ann/2</a>.</p><h2>data_arity(Node::) -&gt; integer()</h2><p>Returns the number of subtrees of a data constructor node.</p><a name="data_arity-1"></a><p>Returns the number of subtrees of a data constructor
node. This is equivalent to <strong>length(data_es(Node))</strong>, but
potentially more efficient.
</p><p><em>See also:</em> <a href="#data_es-1">data_es/1</a>, <a href="#is_data-1">is_data/1</a>.</p><h2>data_es(Node::) -&gt; []</h2><p>Returns the list of subtrees of a data constructor node.</p><a name="data_es-1"></a><p>Returns the list of subtrees of a data constructor node. If  
the arity of the constructor is zero, the result is the empty list.</p><p>Note: if <strong>data_type(Node)</strong> is <strong>cons</strong>, the
number of subtrees is exactly two. If <strong>data_type(Node)</strong>
is <strong>{atomic, Value}</strong>, the number of subtrees is
zero.</p><p><em>See also:</em> <a href="#data_arity-1">data_arity/1</a>, <a href="#data_type-1">data_type/1</a>, <a href="#is_data-1">is_data/1</a>, <a href="#make_data-2">make_data/2</a>.</p><h2>data_type(Node::) -&gt;</h2><p>Returns a type descriptor for a data constructor node.</p><ul><li><span class="v">dtype() = cons | tuple | {atomic, Value}</span></li><li><span class="v">Value = integer() | float() | atom() | []</span></li></ul><a name="data_type-1"></a><p>Returns a type descriptor for a data constructor
node. (Cf. <strong>is_data/1</strong>.) This is mainly useful for
comparing types and for constructing new nodes of the same type
(cf. <strong>make_data/2</strong>). If <strong>Node</strong> represents an
integer, floating-point number, atom or empty list, the result is
<strong>{atomic, Value}</strong>, where <strong>Value</strong> is the value
of <strong>concrete(Node)</strong>, otherwise the result is either
<strong>cons</strong> or <strong>tuple</strong>.</p><p>Type descriptors can be compared for equality or order (in the
Erlang term order), but remember that floating-point values should
in general never be tested for equality.</p><p><em>See also:</em> <a href="#concrete-1">concrete/1</a>, <a href="#is_data-1">is_data/1</a>, <a href="#make_data-2">make_data/2</a>, <a href="#type-1">type/1</a>.</p><h2>float_lit(Node::) -&gt; string()</h2><p>Returns the numeral string represented by a floating-point literal node.</p><a name="float_lit-1"></a><p>Returns the numeral string represented by a floating-point
literal node.</p><p><em>See also:</em> <a href="#c_float-1">c_float/1</a>.</p><h2>float_val(Node::) -&gt; float()</h2><p>Returns the value represented by a floating-point literal node.</p><a name="float_val-1"></a><p>Returns the value represented by a floating-point literal
node.</p><p><em>See also:</em> <a href="#c_float-1">c_float/1</a>.</p><h2>fname_arity(C_var::) -&gt; arity()</h2><p>Returns the arity part of an abstract function name variable.</p><a name="fname_arity-1"></a><p>Returns the arity part of an abstract function name variable.
</p><p><em>See also:</em> <a href="#c_fname-2">c_fname/2</a>, <a href="#fname_id-1">fname_id/1</a>.</p><h2>fname_id(C_var::) -&gt; atom()</h2><p>Returns the identifier part of an abstract function name variable.</p><a name="fname_id-1"></a><p>Returns the identifier part of an abstract function name
variable.
</p><p><em>See also:</em> <a href="#c_fname-2">c_fname/2</a>, <a href="#fname_arity-1">fname_arity/1</a>.</p><h2>fold_literal(Node::) -&gt;</h2><p>Assures that literals have a compact representation.</p><a name="fold_literal-1"></a><p>Assures that literals have a compact representation. This is
occasionally useful if <strong>c_cons_skel/2</strong>,
<strong>c_tuple_skel/1</strong> or <strong>unfold_literal/1</strong> were
used in the construction of <strong>Node</strong>, and you want to revert
to the normal "folded" representation of literals. If
<strong>Node</strong> represents a tuple or list constructor, its
elements are rewritten recursively, and the node is reconstructed
using <strong>c_cons/2</strong> or <strong>c_tuple/1</strong>, respectively;
otherwise, <strong>Node</strong> is not changed.
</p><p><em>See also:</em> <a href="#c_cons-2">c_cons/2</a>, <a href="#c_cons_skel-2">c_cons_skel/2</a>, <a href="#c_tuple-1">c_tuple/1</a>, <a href="#c_tuple_skel-1">c_tuple_skel/1</a>, <a href="#is_literal-1">is_literal/1</a>, <a href="#unfold_literal-1">unfold_literal/1</a>.</p><h2>from_records(Tree::record()) -&gt;</h2><p>Translates an explicit record representation to a corresponding abstract syntax tree.</p><ul><li><span class="v">record_types() = c_alias | c_apply | c_call | c_case | c_catch | c_clause | c_cons | c_fun | c_let | c_letrec | c_lit | c_module | c_primop | c_receive | c_seq | c_try | c_tuple | c_values | c_var</span></li></ul><a name="from_records-1"></a><p>Translates an explicit record representation to a
corresponding abstract syntax tree.  The records are defined in the
file "<strong>core_parse.hrl</strong>".
</p><p><em>See also:</em> <a href="#to_records-1">to_records/1</a>, <a href="#type-1">type/1</a>.</p><h2>fun_arity(Node::) -&gt; arity()</h2><p>Returns the number of parameter subtrees of an abstract   fun-expression.</p><a name="fun_arity-1"></a><p>Returns the number of parameter subtrees of an abstract  
fun-expression.</p><p>Note: this is equivalent to <strong>length(fun_vars(Node))</strong>,
but potentially more efficient.</p><p><em>See also:</em> <a href="#c_fun-2">c_fun/2</a>, <a href="#fun_vars-1">fun_vars/1</a>.</p><h2>fun_body(Node::) -&gt;</h2><p>Returns the body subtree of an abstract fun-expression.</p><a name="fun_body-1"></a><p>Returns the body subtree of an abstract fun-expression.
</p><p><em>See also:</em> <a href="#c_fun-2">c_fun/2</a>.</p><h2>fun_vars(Node::) -&gt; []</h2><p>Returns the list of parameter subtrees of an abstract fun-expression.</p><a name="fun_vars-1"></a><p>Returns the list of parameter subtrees of an abstract
fun-expression.
</p><p><em>See also:</em> <a href="#c_fun-2">c_fun/2</a>, <a href="#fun_arity-1">fun_arity/1</a>.</p><h2>get_ann(Node::) -&gt; [term()]</h2><p>Returns the list of user annotations associated with a syntax tree node.</p><a name="get_ann-1"></a><p>Returns the list of user annotations associated with a syntax
tree node. For a newly created node, this is the empty list. The
annotations may be any terms.
</p><p><em>See also:</em> <a href="#set_ann-2">set_ann/2</a>.</p><h2>int_lit(Node::) -&gt; string()</h2><p>Returns the numeral string represented by an integer literal node.</p><a name="int_lit-1"></a><p>Returns the numeral string represented by an integer literal
node.</p><p><em>See also:</em> <a href="#c_int-1">c_int/1</a>.</p><h2>int_val(Node::) -&gt; integer()</h2><p>Returns the value represented by an integer literal node.</p><a name="int_val-1"></a><p>Returns the value represented by an integer literal node.</p><p><em>See also:</em> <a href="#c_int-1">c_int/1</a>.</p><h2>is_c_alias(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract pattern alias, otherwise false.</p><a name="is_c_alias-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
pattern alias, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_alias-2">c_alias/2</a>.</p><h2>is_c_apply(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract function application, otherwise false.</p><a name="is_c_apply-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
function application, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_apply-2">c_apply/2</a>.</p><h2>is_c_atom(Node::) -&gt; boolean()</h2><p>Returns true if Node represents an atom literal, otherwise false.</p><a name="is_c_atom-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> represents an
atom literal, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_atom-1">c_atom/1</a>.</p><h2>is_c_binary(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract binary-template; otherwise false.</p><a name="is_c_binary-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
binary-template; otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_binary-1">c_binary/1</a>.</p><h2>is_c_bitstr(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract bit-string template; otherwise false.</p><a name="is_c_bitstr-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
bit-string template; otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_bitstr-5">c_bitstr/5</a>.</p><h2>is_c_call(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract inter-module call expression; otherwise false.</p><a name="is_c_call-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
inter-module call expression; otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_call-3">c_call/3</a>.</p><h2>is_c_case(C_case::) -&gt; boolean()</h2><p>Returns true if Node is an abstract case-expression; otherwise false.</p><a name="is_c_case-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
case-expression; otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_case-2">c_case/2</a>.</p><h2>is_c_catch(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract catch-expression, otherwise false.</p><a name="is_c_catch-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
catch-expression, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_catch-1">c_catch/1</a>.</p><h2>is_c_char(Node::) -&gt; boolean()</h2><p>Returns true if Node may represent a character literal, otherwise false.</p><a name="is_c_char-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> may represent a
character literal, otherwise <strong>false</strong>.</p><p>If the local implementation of Erlang defines
<strong>char()</strong> as a subset of <strong>integer()</strong>, then
<strong>is_c_int(Node)</strong> will also yield
<strong>true</strong>.</p><p><em>See also:</em> <a href="#c_char-1">c_char/1</a>, <a href="#is_print_char-1">is_print_char/1</a>.</p><h2>is_c_clause(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract clause, otherwise false.</p><a name="is_c_clause-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
clause, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_clause-3">c_clause/3</a>.</p><h2>is_c_cons(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract list constructor, otherwise false.</p><a name="is_c_cons-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
list constructor, otherwise <strong>false</strong>.</p><h2>is_c_float(Node::) -&gt; boolean()</h2><p>Returns true if Node represents a floating-point literal, otherwise false.</p><a name="is_c_float-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> represents a
floating-point literal, otherwise <strong>false</strong>.</p><p><em>See also:</em> <a href="#c_float-1">c_float/1</a>.</p><h2>is_c_fname(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract function name variable, otherwise false.</p><a name="is_c_fname-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
function name variable, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_fname-2">c_fname/2</a>, <a href="#c_var-1">c_var/1</a>, <a href="#var_name-1">var_name/1</a>.</p><h2>is_c_fun(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract fun-expression, otherwise false.</p><a name="is_c_fun-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
fun-expression, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_fun-2">c_fun/2</a>.</p><h2>is_c_int(Node::) -&gt; boolean()</h2><p>Returns true if Node represents an integer literal, otherwise false.</p><a name="is_c_int-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> represents an
integer literal, otherwise <strong>false</strong>.</p><p><em>See also:</em> <a href="#c_int-1">c_int/1</a>.</p><h2>is_c_let(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract let-expression, otherwise false.</p><a name="is_c_let-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
let-expression, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_let-3">c_let/3</a>.</p><h2>is_c_letrec(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract letrec-expression, otherwise false.</p><a name="is_c_letrec-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
letrec-expression, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_letrec-2">c_letrec/2</a>.</p><h2>is_c_list(Node::) -&gt; boolean()</h2><p>Returns true if Node represents a proper list, otherwise false.</p><a name="is_c_list-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> represents a
proper list, otherwise <strong>false</strong>. A proper list is either
the empty list <strong>[]</strong>, or a cons cell <strong>[Head | Tail]</strong>, where recursively <strong>Tail</strong> is a  
proper list.</p><p>Note: Because <strong>Node</strong> is a syntax tree, the actual
run-time values corresponding to its subtrees may often be partially
or completely unknown. Thus, if <strong>Node</strong> represents e.g.
"<strong>[... | Ns]</strong>" (where <strong>Ns</strong> is a variable), then
the function will return <strong>false</strong>, because it is not known
whether <strong>Ns</strong> will be bound to a list at run-time. If
<strong>Node</strong> instead represents e.g. "<strong>[1, 2, 3]</strong>" or
"<strong>[A | []]</strong>", then the function will return
<strong>true</strong>.</p><p><em>See also:</em> <a href="#c_cons-2">c_cons/2</a>, <a href="#c_nil-0">c_nil/0</a>, <a href="#list_elements-1">list_elements/1</a>, <a href="#list_length-1">list_length/1</a>.</p><h2>is_c_map(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract map constructor, otherwise false.</p><a name="is_c_map-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
map constructor, otherwise <strong>false</strong>.</p><h2>is_c_map_empty(C_map::|) -&gt; boolean()</h2><p> </p><a name="is_c_map_empty-1"></a><h2>is_c_map_pattern(C_map::) -&gt; boolean()</h2><p> </p><a name="is_c_map_pattern-1"></a><h2>is_c_module(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract module definition, otherwise false.</p><a name="is_c_module-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
module definition, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#type-1">type/1</a>.</p><h2>is_c_nil(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract empty list, otherwise false.</p><a name="is_c_nil-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
empty list, otherwise <strong>false</strong>.</p><h2>is_c_primop(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract primitive operation call, otherwise false.</p><a name="is_c_primop-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
primitive operation call, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_primop-2">c_primop/2</a>.</p><h2>is_c_receive(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract receive-expression, otherwise false.</p><a name="is_c_receive-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
receive-expression, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_receive-3">c_receive/3</a>.</p><h2>is_c_seq(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract sequencing expression, otherwise false.</p><a name="is_c_seq-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
sequencing expression, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_seq-2">c_seq/2</a>.</p><h2>is_c_string(Node::) -&gt; boolean()</h2><p>Returns true if Node may represent a string literal, otherwise false.</p><a name="is_c_string-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> may represent a
string literal, otherwise <strong>false</strong>. Strings are defined
as lists of characters; see <strong>is_c_char/1</strong> for details.
</p><p><em>See also:</em> <a href="#c_string-1">c_string/1</a>, <a href="#is_c_char-1">is_c_char/1</a>, <a href="#is_print_string-1">is_print_string/1</a>.</p><h2>is_c_try(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract try-expression, otherwise false.</p><a name="is_c_try-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
try-expression, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_try-5">c_try/5</a>.</p><h2>is_c_tuple(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract tuple, otherwise false.</p><a name="is_c_tuple-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
tuple, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_tuple-1">c_tuple/1</a>.</p><h2>is_c_values(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract value list; otherwise false.</p><a name="is_c_values-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
value list; otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_values-1">c_values/1</a>.</p><h2>is_c_var(Node::) -&gt; boolean()</h2><p>Returns true if Node is an abstract variable, otherwise false.</p><a name="is_c_var-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is an abstract
variable, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#c_var-1">c_var/1</a>.</p><h2>is_data(Node::) -&gt; boolean()</h2><p>Returns true if Node represents a data constructor, otherwise false.</p><a name="is_data-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> represents a
data constructor, otherwise <strong>false</strong>. Data constructors
are cons cells, tuples, and atomic literals.
</p><p><em>See also:</em> <a href="#data_arity-1">data_arity/1</a>, <a href="#data_es-1">data_es/1</a>, <a href="#data_type-1">data_type/1</a>.</p><h2>is_leaf(Node::) -&gt; boolean()</h2><p>Returns true if Node is a leaf node, otherwise false.</p><a name="is_leaf-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is a leaf node,
otherwise <strong>false</strong>. The current leaf node types are
<strong>literal</strong> and <strong>var</strong>.</p><p>Note: all literals (cf. <strong>is_literal/1</strong>) are leaf
nodes, even if they represent structured (constant) values such as
<strong>{foo, [bar, baz]}</strong>. Also note that variables are leaf
nodes but not literals.</p><p><em>See also:</em> <a href="#is_literal-1">is_literal/1</a>, <a href="#type-1">type/1</a>.</p><h2>is_literal(Node::) -&gt; boolean()</h2><p>Returns true if Node represents a literal term, otherwise false.</p><a name="is_literal-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> represents a
literal term, otherwise <strong>false</strong>. This function returns
<strong>true</strong> if and only if the value of
<strong>concrete(Node)</strong> is defined.</p><p>Note: This is a constant time operation.</p><p><em>See also:</em> <a href="#abstract-1">abstract/1</a>, <a href="#concrete-1">concrete/1</a>, <a href="#fold_literal-1">fold_literal/1</a>.</p><h2>is_literal_term(Term::term()) -&gt; boolean()</h2><p>Returns true if Term can be represented as a literal, otherwise false.</p><a name="is_literal_term-1"></a><p>Returns <strong>true</strong> if <strong>Term</strong> can be
represented as a literal, otherwise <strong>false</strong>. This
function takes time proportional to the size of <strong>Term</strong>.
</p><p><em>See also:</em> <a href="#abstract-1">abstract/1</a>.</p><h2>is_print_char(Node::) -&gt; boolean()</h2><p>Returns true if Node may represent a "printing" character, otherwise false.</p><a name="is_print_char-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> may represent a
"printing" character, otherwise <strong>false</strong>. (Cf.
<strong>is_c_char/1</strong>.)  A "printing" character has either a
given graphical representation, or a "named" escape sequence such
as "<strong>\n</strong>". Currently, only ISO 8859-1 (Latin-1)
character values are recognized.
</p><p><em>See also:</em> <a href="#c_char-1">c_char/1</a>, <a href="#is_c_char-1">is_c_char/1</a>.</p><h2>is_print_string(Node::) -&gt; boolean()</h2><p>Returns true if Node may represent a string literal containing only "printing" characters, otherwise false.</p><a name="is_print_string-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> may represent a
string literal containing only "printing" characters, otherwise
<strong>false</strong>. See <strong>is_c_string/1</strong> and
<strong>is_print_char/1</strong> for details. Currently, only ISO
8859-1 (Latin-1) character values are recognized.
</p><p><em>See also:</em> <a href="#c_string-1">c_string/1</a>, <a href="#is_c_string-1">is_c_string/1</a>, <a href="#is_print_char-1">is_print_char/1</a>.</p><h2>let_arg(Node::) -&gt;</h2><p>Returns the argument subtree of an abstract let-expression.</p><a name="let_arg-1"></a><p>Returns the argument subtree of an abstract let-expression.
</p><p><em>See also:</em> <a href="#c_let-3">c_let/3</a>.</p><h2>let_arity(Node::) -&gt; integer()</h2><p>Returns the number of left-hand side variables of an abstract   let-expression.</p><a name="let_arity-1"></a><p>Returns the number of left-hand side variables of an abstract  
let-expression.</p><p>Note: this is equivalent to <strong>length(let_vars(Node))</strong>,
but potentially more efficient.</p><p><em>See also:</em> <a href="#c_let-3">c_let/3</a>, <a href="#let_vars-1">let_vars/1</a>.</p><h2>let_body(Node::) -&gt;</h2><p>Returns the body subtree of an abstract let-expression.</p><a name="let_body-1"></a><p>Returns the body subtree of an abstract let-expression.
</p><p><em>See also:</em> <a href="#c_let-3">c_let/3</a>.</p><h2>let_vars(Node::) -&gt; []</h2><p>Returns the list of left-hand side variables of an abstract let-expression.</p><a name="let_vars-1"></a><p>Returns the list of left-hand side variables of an abstract
let-expression.
</p><p><em>See also:</em> <a href="#c_let-3">c_let/3</a>, <a href="#let_arity-1">let_arity/1</a>.</p><h2>letrec_body(Node::) -&gt;</h2><p>Returns the body subtree of an abstract letrec-expression.</p><a name="letrec_body-1"></a><p>Returns the body subtree of an abstract letrec-expression.
</p><p><em>See also:</em> <a href="#c_letrec-2">c_letrec/2</a>.</p><h2>letrec_defs(Node::) -&gt; [{,}]</h2><p>Returns the list of definitions of an abstract letrec-expression.</p><a name="letrec_defs-1"></a><p>Returns the list of definitions of an abstract
letrec-expression. If <strong>Node</strong> represents "<strong>letrec V1 = F1 ... Vn = Fn in Body</strong>", the returned value is <strong>[{V1, F1}, ..., {Vn, Fn}]</strong>.
</p><p><em>See also:</em> <a href="#c_letrec-2">c_letrec/2</a>.</p><h2>letrec_vars(Node::) -&gt; []</h2><p>Returns the list of left-hand side function variable subtrees of a letrec-expression.</p><a name="letrec_vars-1"></a><p>Returns the list of left-hand side function variable subtrees
of a letrec-expression. If <strong>Node</strong> represents
"<strong>letrec V1 = F1 ... Vn = Fn in Body</strong>", the returned value is
<strong>[V1, ..., Vn]</strong>.
</p><p><em>See also:</em> <a href="#c_letrec-2">c_letrec/2</a>.</p><h2>list_elements(C_cons::) -&gt; []</h2><p>Returns the list of element subtrees of an abstract list.</p><a name="list_elements-1"></a><p>Returns the list of element subtrees of an abstract list.
<strong>Node</strong> must represent a proper list. E.g., if
<strong>Node</strong> represents "<strong>[X1, X2 | [X3, X4 | []]</strong>", then
<strong>list_elements(Node)</strong> yields the list <strong>[X1, X2, X3, X4]</strong>.
</p><p><em>See also:</em> <a href="#c_cons-2">c_cons/2</a>, <a href="#c_nil-0">c_nil/0</a>, <a href="#is_c_list-1">is_c_list/1</a>, <a href="#list_length-1">list_length/1</a>, <a href="#make_list-2">make_list/2</a>.</p><h2>list_length(Node::) -&gt; integer()</h2><p>Returns the number of element subtrees of an abstract list.</p><a name="list_length-1"></a><p>Returns the number of element subtrees of an abstract list.
<strong>Node</strong> must represent a proper list. E.g., if
<strong>Node</strong> represents "<strong>[X1 | [X2, X3 | [X4, X5, X6]]]</strong>", then <strong>list_length(Node)</strong> returns the  
integer 6.</p><p>Note: this is equivalent to
<strong>length(list_elements(Node))</strong>, but potentially more
efficient.</p><p><em>See also:</em> <a href="#c_cons-2">c_cons/2</a>, <a href="#c_nil-0">c_nil/0</a>, <a href="#is_c_list-1">is_c_list/1</a>, <a href="#list_elements-1">list_elements/1</a>.</p><h2>make_data(Type::, Elements::[]) -&gt;</h2><p>Creates a data constructor node with the specified type and subtrees.</p><a name="make_data-2"></a><p>Creates a data constructor node with the specified type and
subtrees. (Cf. <strong>data_type/1</strong>.)  An exception is thrown
if the length of <strong>Elements</strong> is invalid for the given
<strong>Type</strong>; see <strong>data_es/1</strong> for arity constraints
on constructor types.
</p><p><em>See also:</em> <a href="#ann_make_data-3">ann_make_data/3</a>, <a href="#data_es-1">data_es/1</a>, <a href="#data_type-1">data_type/1</a>, <a href="#make_data_skel-2">make_data_skel/2</a>, <a href="#update_data-3">update_data/3</a>.</p><h2>make_data_skel(Type::, Elements::[]) -&gt;</h2><p>Like make_data/2, but analogous to c_tuple_skel/1 and c_cons_skel/2.</p><a name="make_data_skel-2"></a><p>Like <strong>make_data/2</strong>, but analogous to
<strong>c_tuple_skel/1</strong> and <strong>c_cons_skel/2</strong>.
</p><p><em>See also:</em> <a href="#ann_make_data_skel-3">ann_make_data_skel/3</a>, <a href="#c_cons_skel-2">c_cons_skel/2</a>, <a href="#c_tuple_skel-1">c_tuple_skel/1</a>, <a href="#make_data-2">make_data/2</a>, <a href="#update_data_skel-3">update_data_skel/3</a>.</p><h2>make_list(List) -&gt; Node</h2><p>Equivalent to make_list(List, none). </p><a name="make_list-1"></a><p>Equivalent to <a href="#make_list-2">make_list(List, none)</a>.</p><h2>make_list(List::[], Tail) -&gt;</h2><p>Creates an abstract list from the elements in List and the optional Tail.</p><ul><li><span class="v">Tail =  | none</span></li></ul><a name="make_list-2"></a><p>Creates an abstract list from the elements in <strong>List</strong>
and the optional <strong>Tail</strong>. If <strong>Tail</strong> is
<strong>none</strong>, the result will represent a nil-terminated list,
otherwise it represents "<strong>[... | Tail]</strong>".
</p><p><em>See also:</em> <a href="#ann_make_list-3">ann_make_list/3</a>, <a href="#c_cons-2">c_cons/2</a>, <a href="#c_nil-0">c_nil/0</a>, <a href="#list_elements-1">list_elements/1</a>, <a href="#update_list-3">update_list/3</a>.</p><h2>make_tree(Type::, Groups::[[]]) -&gt;</h2><p>Creates a syntax tree with the given type and subtrees.</p><a name="make_tree-2"></a><p>Creates a syntax tree with the given type and subtrees.
<strong>Type</strong> must be a node type name
(cf. <strong>type/1</strong>) that does not denote a leaf node type
(cf. <strong>is_leaf/1</strong>).  <strong>Groups</strong> must be a
<em>nonempty</em> list of groups of syntax trees, representing the
subtrees of a node of the given type, in left-to-right order as
they would occur in the printed program text, grouped by category
as done by <strong>subtrees/1</strong>.</p><p>The result of <strong>ann_make_tree(get_ann(Node), type(Node), subtrees(Node))</strong> (cf. <strong>update_tree/2</strong>) represents
the same source code text as the original <strong>Node</strong>,
assuming that <strong>subtrees(Node)</strong> yields a nonempty
list. However, it does not necessarily have the exact same data
representation as <strong>Node</strong>.</p><p><em>See also:</em> <a href="#ann_make_tree-3">ann_make_tree/3</a>, <a href="#is_leaf-1">is_leaf/1</a>, <a href="#subtrees-1">subtrees/1</a>, <a href="#type-1">type/1</a>, <a href="#update_tree-2">update_tree/2</a>.</p><h2>map_arg(C_literal::|) -&gt;|</h2><p> </p><a name="map_arg-1"></a><h2>map_es(C_literal::|) -&gt; []</h2><p> </p><a name="map_es-1"></a><h2>map_pair_key(C_map_pair::) -&gt;</h2><p> </p><a name="map_pair_key-1"></a><h2>map_pair_op(C_map_pair::) -&gt;</h2><p> </p><a name="map_pair_op-1"></a><h2>map_pair_val(C_map_pair::) -&gt;</h2><p> </p><a name="map_pair_val-1"></a><h2>meta(Tree::) -&gt;</h2><p>Creates a meta-representation of a syntax tree.</p><a name="meta-1"></a><p>Creates a meta-representation of a syntax tree. The result
represents an Erlang expression "<strong>MetaTree</strong>"
which, if evaluated, will yield a new syntax tree representing the
same source code text as <strong>Tree</strong> (although the actual
data representation may be different). The expression represented
by <strong>MetaTree</strong> is <em>implementation independent</em>  
with regard to the data structures used by the abstract syntax tree  
implementation.</p><p>Any node in <strong>Tree</strong> whose node type is
<strong>var</strong> (cf. <strong>type/1</strong>), and whose list of
annotations (cf. <strong>get_ann/1</strong>) contains the atom
<strong>meta_var</strong>, will remain unchanged in the resulting tree,
except that exactly one occurrence of <strong>meta_var</strong> is
removed from its annotation list.</p><p>The main use of the function <strong>meta/1</strong> is to transform
a data structure <strong>Tree</strong>, which represents a piece of
program code, into a form that is <em>representation independent when printed</em>. E.g., suppose <strong>Tree</strong> represents a
variable named "V". Then (assuming a function <strong>print/1</strong>
for printing syntax trees), evaluating
<strong>print(abstract(Tree))</strong> - simply using
<strong>abstract/1</strong> to map the actual data structure onto a
syntax tree representation - would output a string that might look
something like "<strong>{var, ..., 'V'}</strong>", which is obviously
dependent on the implementation of the abstract syntax trees. This
could e.g. be useful for caching a syntax tree in a file. However,
in some situations like in a program generator generator (with two
"generator"), it may be unacceptable.  Using
<strong>print(meta(Tree))</strong> instead would output a
<em>representation independent</em> syntax tree generating
expression; in the above case, something like
"<strong>cerl:c_var('V')</strong>".</p><p>The implementation tries to generate compact code with respect
to literals and lists.</p><p><em>See also:</em> <a href="#abstract-1">abstract/1</a>, <a href="#get_ann-1">get_ann/1</a>, <a href="#type-1">type/1</a>.</p><h2>module_attrs(Node::) -&gt; [{,}]</h2><p>Returns the list of pairs of attribute key/value subtrees of an abstract module definition.</p><a name="module_attrs-1"></a><p>Returns the list of pairs of attribute key/value subtrees of
an abstract module definition.
</p><p><em>See also:</em> <a href="#c_module-4">c_module/4</a>.</p><h2>module_defs(Node::) -&gt; [{,}]</h2><p>Returns the list of function definitions of an abstract module definition.</p><a name="module_defs-1"></a><p>Returns the list of function definitions of an abstract module
definition.
</p><p><em>See also:</em> <a href="#c_module-4">c_module/4</a>.</p><h2>module_exports(Node::) -&gt; []</h2><p>Returns the list of exports subtrees of an abstract module definition.</p><a name="module_exports-1"></a><p>Returns the list of exports subtrees of an abstract module
definition.
</p><p><em>See also:</em> <a href="#c_module-4">c_module/4</a>.</p><h2>module_name(Node::) -&gt;</h2><p>Returns the name subtree of an abstract module definition.</p><a name="module_name-1"></a><p>Returns the name subtree of an abstract module definition.
</p><p><em>See also:</em> <a href="#c_module-4">c_module/4</a>.</p><h2>module_vars(Node::) -&gt; []</h2><p>Returns the list of left-hand side function variable subtrees of an abstract module definition.</p><a name="module_vars-1"></a><p>Returns the list of left-hand side function variable subtrees
of an abstract module definition.
</p><p><em>See also:</em> <a href="#c_module-4">c_module/4</a>.</p><h2>pat_list_vars(Patterns::[]) -&gt; []</h2><p>Returns the list of all abstract variables in the given patterns.</p><a name="pat_list_vars-1"></a><p>Returns the list of all abstract variables in the given
patterns. An exception is thrown if some element in
<strong>Patterns</strong> does not represent a well-formed Core Erlang
clause pattern. The order of listing is not defined.
</p><p><em>See also:</em> <a href="#clause_vars-1">clause_vars/1</a>, <a href="#pat_vars-1">pat_vars/1</a>.</p><h2>pat_vars(Pattern::) -&gt; []</h2><p>Returns the list of all abstract variables in a pattern.</p><a name="pat_vars-1"></a><p>Returns the list of all abstract variables in a pattern. An
exception is thrown if <strong>Node</strong> does not represent a
well-formed Core Erlang clause pattern. The order of listing is not
defined.
</p><p><em>See also:</em> <a href="#clause_vars-1">clause_vars/1</a>, <a href="#pat_list_vars-1">pat_list_vars/1</a>.</p><h2>primop_args(Node::) -&gt; []</h2><p>Returns the list of argument subtrees of an abstract primitive operation call.</p><a name="primop_args-1"></a><p>Returns the list of argument subtrees of an abstract primitive
operation call.
</p><p><em>See also:</em> <a href="#c_primop-2">c_primop/2</a>, <a href="#primop_arity-1">primop_arity/1</a>.</p><h2>primop_arity(Node::) -&gt; arity()</h2><p>Returns the number of argument subtrees of an abstract   primitive operation call.</p><a name="primop_arity-1"></a><p>Returns the number of argument subtrees of an abstract  
primitive operation call.</p><p>Note: this is equivalent to
<strong>length(primop_args(Node))</strong>, but potentially more
efficient.</p><p><em>See also:</em> <a href="#c_primop-2">c_primop/2</a>, <a href="#primop_args-1">primop_args/1</a>.</p><h2>primop_name(Node::) -&gt;</h2><p>Returns the name subtree of an abstract primitive operation call.</p><a name="primop_name-1"></a><p>Returns the name subtree of an abstract primitive operation
call.
</p><p><em>See also:</em> <a href="#c_primop-2">c_primop/2</a>.</p><h2>receive_action(Node::) -&gt;</h2><p>Returns the action subtree of an abstract receive-expression.</p><a name="receive_action-1"></a><p>Returns the action subtree of an abstract receive-expression.
</p><p><em>See also:</em> <a href="#c_receive-3">c_receive/3</a>.</p><h2>receive_clauses(Node::) -&gt; []</h2><p>Returns the list of clause subtrees of an abstract receive-expression.</p><a name="receive_clauses-1"></a><p>Returns the list of clause subtrees of an abstract
receive-expression.
</p><p><em>See also:</em> <a href="#c_receive-3">c_receive/3</a>.</p><h2>receive_timeout(Node::) -&gt;</h2><p>Returns the timeout subtree of an abstract receive-expression.</p><a name="receive_timeout-1"></a><p>Returns the timeout subtree of an abstract receive-expression.
</p><p><em>See also:</em> <a href="#c_receive-3">c_receive/3</a>.</p><h2>seq_arg(Node::) -&gt;</h2><p>Returns the argument subtree of an abstract sequencing expression.</p><a name="seq_arg-1"></a><p>Returns the argument subtree of an abstract sequencing
expression.
</p><p><em>See also:</em> <a href="#c_seq-2">c_seq/2</a>.</p><h2>seq_body(Node::) -&gt;</h2><p>Returns the body subtree of an abstract sequencing expression.</p><a name="seq_body-1"></a><p>Returns the body subtree of an abstract sequencing expression.
</p><p><em>See also:</em> <a href="#c_seq-2">c_seq/2</a>.</p><h2>set_ann(Node::, Annotations::[term()]) -&gt;</h2><p>Sets the list of user annotations of Node to Annotations.</p><a name="set_ann-2"></a><p>Sets the list of user annotations of <strong>Node</strong> to
<strong>Annotations</strong>.
</p><p><em>See also:</em> <a href="#add_ann-2">add_ann/2</a>, <a href="#copy_ann-2">copy_ann/2</a>, <a href="#get_ann-1">get_ann/1</a>.</p><h2>string_lit(Node::) -&gt; string()</h2><p>Returns the literal string represented by an abstract string.</p><a name="string_lit-1"></a><p>Returns the literal string represented by an abstract string.
This includes surrounding double-quote characters
<strong>"..."</strong>. Currently, characters that are not in the set
of ISO 8859-1 (Latin-1) "printing" characters will be escaped,
except for spaces.
</p><p><em>See also:</em> <a href="#c_string-1">c_string/1</a>.</p><h2>string_val(Node::) -&gt; string()</h2><p>Returns the value represented by an abstract string literal.</p><a name="string_val-1"></a><p>Returns the value represented by an abstract string literal.
</p><p><em>See also:</em> <a href="#c_string-1">c_string/1</a>.</p><h2>subtrees(Node::) -&gt; [[]]</h2><p>Returns the grouped list of all subtrees of a node.</p><a name="subtrees-1"></a><p>Returns the grouped list of all subtrees of a node. If
<strong>Node</strong> is a leaf node (cf. <strong>is_leaf/1</strong>), this
is the empty list, otherwise the result is always a nonempty list,
containing the lists of subtrees of <strong>Node</strong>, in  
left-to-right order as they occur in the printed program text, and  
grouped by category. Often, each group contains only a single  
subtree.</p><p>Depending on the type of <strong>Node</strong>, the size of some
groups may be variable (e.g., the group consisting of all the
elements of a tuple), while others always contain the same number
of elements - usually exactly one (e.g., the group containing the
argument expression of a case-expression). Note, however, that the
exact structure of the returned list (for a given node type) should
in general not be depended upon, since it might be subject to
change without notice.</p><p>The function <strong>subtrees/1</strong> and the constructor functions
<strong>make_tree/2</strong> and <strong>update_tree/2</strong> can be a
great help if one wants to traverse a syntax tree, visiting all its
subtrees, but treat nodes of the tree in a uniform way in most or all
cases. Using these functions makes this simple, and also assures that
your code is not overly sensitive to extensions of the syntax tree
data type, because any node types not explicitly handled by your code
can be left to a default case.</p><p>For example:
</p><pre>
    postorder(F, Tree) -&gt;
        F(case subtrees(Tree) of
            [] -&gt; Tree;
            List -&gt; update_tree(Tree,
                                [[postorder(F, Subtree)
                                  || Subtree &lt;- Group]
                                 || Group &lt;- List])
          end).
  </pre><p>
maps the function <strong>F</strong> on <strong>Tree</strong> and all its
subtrees, doing a post-order traversal of the syntax tree. (Note
the use of <strong>update_tree/2</strong> to preserve annotations.) For
a simple function like:
</p><pre>
    f(Node) -&gt;
        case type(Node) of
            atom -&gt; atom("a_" ++ atom_name(Node));
            _ -&gt; Node
        end.
  </pre><p>
the call <strong>postorder(fun f/1, Tree)</strong> will yield a new
representation of <strong>Tree</strong> in which all atom names have
been extended with the prefix "a_", but nothing else (including
annotations) has been changed.</p><p><em>See also:</em> <a href="#is_leaf-1">is_leaf/1</a>, <a href="#make_tree-2">make_tree/2</a>, <a href="#update_tree-2">update_tree/2</a>.</p><h2>to_records(Tree::) -&gt; record()</h2><p>Translates an abstract syntax tree to a corresponding explicit record representation.</p><a name="to_records-1"></a><p>Translates an abstract syntax tree to a corresponding explicit
record representation. The records are defined in the file
"<strong>cerl.hrl</strong>".
</p><p><em>See also:</em> <a href="#from_records-1">from_records/1</a>, <a href="#type-1">type/1</a>.</p><h2>try_arg(Node::) -&gt;</h2><p>Returns the expression subtree of an abstract try-expression.</p><a name="try_arg-1"></a><p>Returns the expression subtree of an abstract try-expression.
</p><p><em>See also:</em> <a href="#c_try-5">c_try/5</a>.</p><h2>try_body(Node::) -&gt;</h2><p>Returns the success body subtree of an abstract try-expression.</p><a name="try_body-1"></a><p>Returns the success body subtree of an abstract try-expression.
</p><p><em>See also:</em> <a href="#c_try-5">c_try/5</a>.</p><h2>try_evars(Node::) -&gt; []</h2><p>Returns the list of exception variable subtrees of an abstract try-expression.</p><a name="try_evars-1"></a><p>Returns the list of exception variable subtrees of an abstract
try-expression.
</p><p><em>See also:</em> <a href="#c_try-5">c_try/5</a>.</p><h2>try_handler(Node::) -&gt;</h2><p>Returns the exception body subtree of an abstract try-expression.</p><a name="try_handler-1"></a><p>Returns the exception body subtree of an abstract
try-expression.
</p><p><em>See also:</em> <a href="#c_try-5">c_try/5</a>.</p><h2>try_vars(Node::) -&gt; []</h2><p>Returns the list of success variable subtrees of an abstract try-expression.</p><a name="try_vars-1"></a><p>Returns the list of success variable subtrees of an abstract
try-expression.
</p><p><em>See also:</em> <a href="#c_try-5">c_try/5</a>.</p><h2>tuple_arity(Node::) -&gt; integer()</h2><p>Returns the number of element subtrees of an abstract tuple.</p><a name="tuple_arity-1"></a><p>Returns the number of element subtrees of an abstract tuple.</p><p>Note: this is equivalent to <strong>length(tuple_es(Node))</strong>,
but potentially more efficient.</p><p><em>See also:</em> <a href="#c_tuple-1">c_tuple/1</a>, <a href="#tuple_es-1">tuple_es/1</a>.</p><h2>tuple_es(C_tuple::) -&gt; []</h2><p>Returns the list of element subtrees of an abstract tuple.</p><a name="tuple_es-1"></a><p>Returns the list of element subtrees of an abstract tuple.
</p><p><em>See also:</em> <a href="#c_tuple-1">c_tuple/1</a>.</p><h2>type(Node::) -&gt; atom()</h2><p>Returns the type tag of Node.</p><a name="type-1"></a><p>Returns the type tag of <strong>Node</strong>. Current node types  
are:</p><p>
alias
apply
binary
bitstr
call
case
catch
clause
<br/>
cons
fun
let
letrec
literal
map
map_pair
module
<br/>
primop
receive
seq
try
tuple
values
var
<br/>
</p><p>Note: The name of the primary constructor function for a node
type is always the name of the type itself, prefixed by
"<strong>c_</strong>"; recognizer predicates are correspondingly
prefixed by "<strong>is_c_</strong>". Furthermore, to simplify
preservation of annotations (cf. <strong>get_ann/1</strong>), there are
analogous constructor functions prefixed by "<strong>ann_c_</strong>"
and "<strong>update_c_</strong>", for setting the annotation list of
the new node to either a specific value or to the annotations of an
existing node, respectively.</p><p><em>See also:</em> <a href="#abstract-1">abstract/1</a>, <a href="#c_alias-2">c_alias/2</a>, <a href="#c_apply-2">c_apply/2</a>, <a href="#c_binary-1">c_binary/1</a>, <a href="#c_bitstr-5">c_bitstr/5</a>, <a href="#c_call-3">c_call/3</a>, <a href="#c_case-2">c_case/2</a>, <a href="#c_catch-1">c_catch/1</a>, <a href="#c_clause-3">c_clause/3</a>, <a href="#c_cons-2">c_cons/2</a>, <a href="#c_fun-2">c_fun/2</a>, <a href="#c_let-3">c_let/3</a>, <a href="#c_letrec-2">c_letrec/2</a>, <a href="#c_module-3">c_module/3</a>, <a href="#c_primop-2">c_primop/2</a>, <a href="#c_receive-1">c_receive/1</a>, <a href="#c_seq-2">c_seq/2</a>, <a href="#c_try-5">c_try/5</a>, <a href="#c_tuple-1">c_tuple/1</a>, <a href="#c_values-1">c_values/1</a>, <a href="#c_var-1">c_var/1</a>, <a href="#data_type-1">data_type/1</a>, <a href="#from_records-1">from_records/1</a>, <a href="#get_ann-1">get_ann/1</a>, <a href="#meta-1">meta/1</a>, <a href="#subtrees-1">subtrees/1</a>, <a href="#to_records-1">to_records/1</a>.</p><h2>unfold_literal(Node::) -&gt;</h2><p>Assures that literals have a fully expanded representation.</p><a name="unfold_literal-1"></a><p>Assures that literals have a fully expanded representation. If
<strong>Node</strong> represents a literal tuple or list constructor, its
elements are rewritten recursively, and the node is reconstructed
using <strong>c_cons_skel/2</strong> or <strong>c_tuple_skel/1</strong>,
respectively; otherwise, <strong>Node</strong> is not changed. The <a href="#fold_literal-1">fold_literal/1</a> can be used to revert to the normal compact
representation.
</p><p><em>See also:</em> <a href="#c_cons-2">c_cons/2</a>, <a href="#c_cons_skel-2">c_cons_skel/2</a>, <a href="#c_tuple-1">c_tuple/1</a>, <a href="#c_tuple_skel-1">c_tuple_skel/1</a>, <a href="#fold_literal-1">fold_literal/1</a>, <a href="#is_literal-1">is_literal/1</a>.</p><h2>update_c_alias(Old::, Variable::, Pattern::) -&gt;</h2><p> </p><a name="update_c_alias-3"></a><p><em>See also:</em> <a href="#c_alias-2">c_alias/2</a>.</p><h2>update_c_apply(Old::, Operator::, Arguments::[]) -&gt;</h2><p> </p><a name="update_c_apply-3"></a><p><em>See also:</em> <a href="#c_apply-2">c_apply/2</a>.</p><h2>update_c_binary(Old::, Segments::[]) -&gt;</h2><p> </p><a name="update_c_binary-2"></a><p><em>See also:</em> <a href="#c_binary-1">c_binary/1</a>.</p><h2>update_c_bitstr(Old::, Value::, Size::, Type::, Flags::) -&gt;</h2><p>Equivalent to update_c_bitstr(Node, Value, Size, abstract(1), Type, Flags). </p><a name="update_c_bitstr-5"></a><p>Equivalent to <a href="#update_c_bitstr-6">update_c_bitstr(Node, Value, Size, abstract(1), Type, Flags)</a>.</p><h2>update_c_bitstr(Old::, Value::, Size::, Unit::, Type::, Flags::) -&gt;</h2><p> </p><a name="update_c_bitstr-6"></a><p><em>See also:</em> <a href="#c_bitstr-5">c_bitstr/5</a>, <a href="#update_c_bitstr-5">update_c_bitstr/5</a>.</p><h2>update_c_call(Old::, Module::, Name::, Arguments::[]) -&gt;</h2><p> </p><a name="update_c_call-4"></a><p><em>See also:</em> <a href="#c_call-3">c_call/3</a>.</p><h2>update_c_case(Old::, Argument::, Clauses::[]) -&gt;</h2><p> </p><a name="update_c_case-3"></a><p><em>See also:</em> <a href="#c_case-2">c_case/2</a>.</p><h2>update_c_catch(Old::, Body::) -&gt;</h2><p> </p><a name="update_c_catch-2"></a><p><em>See also:</em> <a href="#c_catch-1">c_catch/1</a>.</p><h2>update_c_clause(Old::, Patterns::[], Guard::, Body::) -&gt;</h2><p> </p><a name="update_c_clause-4"></a><p><em>See also:</em> <a href="#c_clause-3">c_clause/3</a>.</p><h2>update_c_cons(Old::, Head::, Tail::) -&gt;</h2><p> </p><a name="update_c_cons-3"></a><p><em>See also:</em> <a href="#c_cons-2">c_cons/2</a>.</p><h2>update_c_cons_skel(Old::, Head::, Tail::) -&gt;</h2><p> </p><a name="update_c_cons_skel-3"></a><p><em>See also:</em> <a href="#c_cons_skel-2">c_cons_skel/2</a>.</p><h2>update_c_fname(Old::, Name::atom()) -&gt;</h2><p>Like update_c_fname/3, but takes the arity from Node.</p><a name="update_c_fname-2"></a><p>Like <strong>update_c_fname/3</strong>, but takes the arity from
<strong>Node</strong>.</p><p><em>See also:</em> <a href="#c_fname-2">c_fname/2</a>, <a href="#update_c_fname-3">update_c_fname/3</a>.</p><h2>update_c_fname(Old::, Name::atom(), Arity::arity()) -&gt;</h2><p>Equivalent to update_c_var(Old, {Atom, Arity}). </p><a name="update_c_fname-3"></a><p>Equivalent to <a href="#update_c_var-2">update_c_var(Old, {Atom, Arity})</a>.</p><p><em>See also:</em> <a href="#c_fname-2">c_fname/2</a>, <a href="#update_c_fname-2">update_c_fname/2</a>.</p><h2>update_c_fun(Old::, Variables::[], Body::) -&gt;</h2><p> </p><a name="update_c_fun-3"></a><p><em>See also:</em> <a href="#c_fun-2">c_fun/2</a>.</p><h2>update_c_let(Node::, Variables::[], Argument::, Body::) -&gt;</h2><p> </p><a name="update_c_let-4"></a><p><em>See also:</em> <a href="#c_let-3">c_let/3</a>.</p><h2>update_c_letrec(Old::, Definitions::[{,}], Body::) -&gt;</h2><p> </p><a name="update_c_letrec-3"></a><p><em>See also:</em> <a href="#c_letrec-2">c_letrec/2</a>.</p><h2>update_c_map(C_map::, M::, Es::[]) -&gt;|</h2><p> </p><a name="update_c_map-3"></a><h2>update_c_map_pair(Old::, Op::, K::, V::) -&gt;</h2><p> </p><a name="update_c_map_pair-4"></a><h2>update_c_module(Old::, Name::, Exports, Attrs::Attributes, Es::Definitions) -&gt;</h2><p> </p><ul><li><span class="v">Exports = []</span></li><li><span class="v">Attributes = [{, }]</span></li><li><span class="v">Definitions = [{, }]</span></li></ul><a name="update_c_module-5"></a><p><em>See also:</em> <a href="#c_module-4">c_module/4</a>.</p><h2>update_c_primop(Old::, Name::, Arguments::[]) -&gt;</h2><p> </p><a name="update_c_primop-3"></a><p><em>See also:</em> <a href="#c_primop-2">c_primop/2</a>.</p><h2>update_c_receive(Old::, Clauses::[], Timeout::, Action::) -&gt;</h2><p> </p><a name="update_c_receive-4"></a><p><em>See also:</em> <a href="#c_receive-3">c_receive/3</a>.</p><h2>update_c_seq(Old::, Argument::, Body::) -&gt;</h2><p> </p><a name="update_c_seq-3"></a><p><em>See also:</em> <a href="#c_seq-2">c_seq/2</a>.</p><h2>update_c_try(Old::, Expression::, Variables::[], Body::, EVars::[], Handler::) -&gt;</h2><p> </p><a name="update_c_try-6"></a><p><em>See also:</em> <a href="#c_try-5">c_try/5</a>.</p><h2>update_c_tuple(Old::, Elements::[]) -&gt;</h2><p> </p><a name="update_c_tuple-2"></a><p><em>See also:</em> <a href="#c_tuple-1">c_tuple/1</a>.</p><h2>update_c_tuple_skel(Old::, Elements::[]) -&gt;</h2><p> </p><a name="update_c_tuple_skel-2"></a><p><em>See also:</em> <a href="#c_tuple_skel-1">c_tuple_skel/1</a>.</p><h2>update_c_values(Old::, Elements::[]) -&gt;</h2><p> </p><a name="update_c_values-2"></a><p><em>See also:</em> <a href="#c_values-1">c_values/1</a>.</p><h2>update_c_var(Old::, Name::) -&gt;</h2><p> </p><a name="update_c_var-2"></a><p><em>See also:</em> <a href="#c_var-1">c_var/1</a>.</p><h2>update_data(Old::, Type::, Elements::[]) -&gt;</h2><p> </p><a name="update_data-3"></a><p><em>See also:</em> <a href="#make_data-2">make_data/2</a>.</p><h2>update_data_skel(Old::, Type::, Elements::[]) -&gt;</h2><p> </p><a name="update_data_skel-3"></a><p><em>See also:</em> <a href="#make_data_skel-2">make_data_skel/2</a>.</p><h2>update_list(Old::, List::[]) -&gt;</h2><p>Equivalent to update_list(Old, List, none). </p><a name="update_list-2"></a><p>Equivalent to <a href="#update_list-3">update_list(Old, List, none)</a>.</p><h2>update_list(Old::, List::[], Tail) -&gt;</h2><p> </p><ul><li><span class="v">Tail =  | none</span></li></ul><a name="update_list-3"></a><p><em>See also:</em> <a href="#make_list-2">make_list/2</a>, <a href="#update_list-2">update_list/2</a>.</p><h2>update_tree(Old::, Groups::[[]]) -&gt;</h2><p>Creates a syntax tree with the given subtrees, and the same type and annotations as the Old node.</p><a name="update_tree-2"></a><p>Creates a syntax tree with the given subtrees, and the same
type and annotations as the <strong>Old</strong> node. This is
equivalent to <strong>ann_make_tree(get_ann(Node), type(Node), Groups)</strong>, but potentially more efficient.
</p><p><em>See also:</em> <a href="#ann_make_tree-3">ann_make_tree/3</a>, <a href="#get_ann-1">get_ann/1</a>, <a href="#type-1">type/1</a>, <a href="#update_tree-3">update_tree/3</a>.</p><h2>update_tree(Old::, Type::, Groups::[[]]) -&gt;</h2><p>Creates a syntax tree with the given type and subtrees, and the same annotations as the Old node.</p><a name="update_tree-3"></a><p>Creates a syntax tree with the given type and subtrees, and
the same annotations as the <strong>Old</strong> node. This is
equivalent to <strong>ann_make_tree(get_ann(Node), Type, Groups)</strong>, but potentially more efficient.
</p><p><em>See also:</em> <a href="#ann_make_tree-3">ann_make_tree/3</a>, <a href="#get_ann-1">get_ann/1</a>, <a href="#update_tree-2">update_tree/2</a>.</p><h2>values_arity(Node::) -&gt; integer()</h2><p>Returns the number of element subtrees of an abstract value   list.</p><a name="values_arity-1"></a><p>Returns the number of element subtrees of an abstract value  
list.</p><p>Note: This is equivalent to
<strong>length(values_es(Node))</strong>, but potentially more
efficient.</p><p><em>See also:</em> <a href="#c_values-1">c_values/1</a>, <a href="#values_es-1">values_es/1</a>.</p><h2>values_es(Node::) -&gt; []</h2><p>Returns the list of element subtrees of an abstract value list.</p><a name="values_es-1"></a><p>Returns the list of element subtrees of an abstract value
list.
</p><p><em>See also:</em> <a href="#c_values-1">c_values/1</a>, <a href="#values_arity-1">values_arity/1</a>.</p><h2>var_name(Node::) -&gt;</h2><p>Returns the name of an abstract variable.</p><a name="var_name-1"></a><p>Returns the name of an abstract variable.
</p><p><em>See also:</em> <a href="#c_var-1">c_var/1</a>.</p><h1>Authors</h1><span class="aname">Richard Carlsson</span><span class="email">carlsson.richard@gmail.com</span></body></html>