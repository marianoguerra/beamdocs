<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>leex</h1><h1>leex</h1><p>Lexical analyzer generator for Erlang</p><p>A regular expression based lexical analyzer generator for
Erlang, similar to lex or flex.</p><h2>DATA TYPES</h2><pre><code class="">
ErrorInfo = {ErrorLine,module(),error_descriptor()}
ErrorLine = integer()
Token = tuple()</code></pre><h1>Functions</h1><h2>file(FileName) -&gt; LeexRet</h2><h2>file(FileName, Options) -&gt; LeexRet</h2><p>Generate a lexical analyzer</p><ul><li><span class="v">FileName = filename()</span></li><li><span class="v">Options = Option | [Option]</span></li><li><span class="v">Option =Â -Â see belowÂ -</span></li><li><span class="v">LeexRet = {ok, Scannerfile} | {ok, Scannerfile, Warnings} | error | {error, Errors, Warnings}</span></li><li><span class="v">Scannerfile = filename()</span></li><li><span class="v">Warnings = Errors = [{filename(), [ErrorInfo]}]</span></li><li><span class="v">ErrorInfo  = {ErrorLine, module(), Reason}</span></li><li><span class="v">ErrorLine = integer()</span></li><li><span class="v">Reason =Â -Â formatable by format_error/1Â -</span></li></ul><p>Generates a lexical analyzer from the definition in the input
file. The input file has the extension <strong>.xrl</strong>. This is
added to the filename if it is not given. The resulting module
is the Xrl filename without the <strong>.xrl</strong> extension.</p><p>The current options are:</p><dl><dt><strong>dfa_graph</strong></dt><dd><p>Generates a <strong>.dot</strong> file which contains a
description of the DFA in a format which can be viewed with
Graphviz, <strong>www.graphviz.com</strong>.</p> </dd><dt><strong>{includefile,Includefile}</strong></dt><dd><p>Uses a specific or customised prologue file
instead of default
<strong>lib/parsetools/include/leexinc.hrl</strong> which is
otherwise included.</p> </dd><dt><strong>{report_errors, bool()}</strong></dt><dd><p>Causes errors to be printed as they occur. Default is
<strong>true</strong>.</p> </dd><dt><strong>{report_warnings, bool()}</strong></dt><dd><p>Causes warnings to be printed as they occur. Default is
<strong>true</strong>.</p> </dd><dt><strong>warnings_as_errors</strong></dt><dd> <p>Causes warnings to be treated as errors.</p> </dd><dt><strong>{report, bool()}</strong></dt><dd><p>This is a short form for both <strong>report_errors</strong> and
<strong>report_warnings</strong>.</p> </dd><dt><strong>{return_errors, bool()}</strong></dt><dd><p>If this flag is set, <strong>{error, Errors, Warnings}</strong>
is returned when there are errors. Default is <strong>false</strong>.</p> </dd><dt><strong>{return_warnings, bool()}</strong></dt><dd><p>If this flag is set, an extra field containing
<strong>Warnings</strong> is added to the tuple returned upon
success. Default is <strong>false</strong>.</p> </dd><dt><strong>{return, bool()}</strong></dt><dd><p>This is a short form for both <strong>return_errors</strong> and
<strong>return_warnings</strong>.</p> </dd><dt><strong>{scannerfile, Scannerfile}</strong></dt><dd><p><strong>Scannerfile</strong> is the name of the file that
will contain the Erlang scanner code that is generated.
The default (<strong>""</strong>) is to add the extension
<strong>.erl</strong> to <strong>FileName</strong> stripped of the
<strong>.xrl</strong> extension.</p> </dd><dt><strong>{verbose, bool()}</strong></dt><dd><p>Outputs information from parsing the input file and
generating the internal tables.</p> </dd></dl><p>Any of the Boolean options can be set to <strong>true</strong> by 
stating the name of the option. For example, <strong>verbose</strong>
is equivalent to <strong>{verbose, true}</strong>.</p><p>Leex will add the extension <strong>.hrl</strong> to the 
<strong>Includefile</strong> name and the extension <strong>.erl</strong> to the
<strong>Scannerfile</strong> name, unless the extension is already
there.</p><h2>format_error(ErrorInfo) -&gt; Chars</h2><p>Return an English description of a an error tuple.</p><ul><li><span class="v">Chars = [char() | Chars]</span></li></ul><p>Returns a string which describes the error
<strong>ErrorInfo</strong> returned when there is an error in a
regular expression.</p><h2>GENERATED SCANNER EXPORTS</h2><p>The following functions are exported by the generated scanner.</p><h1>Functions</h1><h2>string(String) -&gt; StringRet</h2><h2>string(String, StartLine) -&gt; StringRet</h2><p>Generated by Leex</p><ul><li><span class="v">String = string()</span></li><li><span class="v">StringRet = {ok,Tokens,EndLine} | ErrorInfo</span></li><li><span class="v">Tokens = [Token]</span></li><li><span class="v">EndLine = StartLine = integer()</span></li></ul><p>Scans <strong>String</strong> and returns all the tokens in it, or an
error.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>It is an error if not all of the characters in
<strong>String</strong> are consumed.</p></div><h2>token(Cont, Chars) -&gt; {more,Cont1} | {done,TokenRet,RestChars}
</h2><h2>token(Cont, Chars, StartLine) -&gt; {more,Cont1} 
             | {done,TokenRet,RestChars}
</h2><p>Generated by Leex</p><ul><li><span class="v">Cont = [] | Cont1</span></li><li><span class="v">Cont1 = tuple()</span></li><li><span class="v">Chars = RestChars = string() | eof</span></li><li><span class="v">TokenRet = {ok, Token, EndLine}  | {eof, EndLine} | ErrorInfo</span></li><li><span class="v">StartLine = EndLine = integer()</span></li></ul><p>This is a re-entrant call to try and scan one token from
<strong>Chars</strong>. If there are enough characters in <strong>Chars</strong>
to either scan a token or detect an error then this will be
returned with <strong>{done,...}</strong>. Otherwise
<strong>{cont,Cont}</strong> will be returned where <strong>Cont</strong> is
used in the next call to <strong>token()</strong> with more characters
to try an scan the token. This is continued until a token
has been scanned. <strong>Cont</strong> is initially <strong>[]</strong>.</p><p>It is not designed to be called directly by an application
but used through the i/o system where it can typically be
called in an application by:</p><pre><code class="">
io:request(InFile, {get_until,Prompt,Module,token,[Line]})
  -&gt; TokenRet</code></pre><h2>tokens(Cont, Chars) -&gt; {more,Cont1} | {done,TokensRet,RestChars}
</h2><h2>tokens(Cont, Chars, StartLine) -&gt; 
               {more,Cont1} | {done,TokensRet,RestChars}
</h2><p>Generated by Leex</p><ul><li><span class="v">Cont = [] | Cont1</span></li><li><span class="v">Cont1 = tuple()</span></li><li><span class="v">Chars = RestChars = string() | eof</span></li><li><span class="v">TokensRet = {ok, Tokens, EndLine}  | {eof, EndLine} | ErrorInfo</span></li><li><span class="v">Tokens = [Token]</span></li><li><span class="v">StartLine = EndLine = integer()</span></li></ul><p>This is a re-entrant call to try and scan tokens from
<strong>Chars</strong>. If there are enough characters in <strong>Chars</strong>
to either scan tokens or detect an error then this will be
returned with <strong>{done,...}</strong>. Otherwise
<strong>{cont,Cont}</strong> will be returned where <strong>Cont</strong> is
used in the next call to <strong>tokens()</strong> with more
characters to try an scan the tokens. This is continued
until all tokens have been scanned. <strong>Cont</strong> is initially
<strong>[]</strong>.</p><p>This functions differs from <strong>token</strong> in that it will
continue to scan tokens upto and including an
<strong>{end_token,Token}</strong> has been scanned (see next
section). It will then return all the tokens. This is
typically used for scanning grammars like Erlang where there
is an explicit end token, <strong>'.'</strong>. If no end token is
found then the whole file will be scanned and returned. If
an error occurs then all tokens upto and including the next
end token will be skipped.</p><p>It is not designed to be called directly by an application
but used through the i/o system where it can typically be
called in an application by:</p><pre><code class="">
io:request(InFile, {get_until,Prompt,Module,tokens,[Line]})
  -&gt; TokensRet</code></pre><h2>Input File Format</h2><p>Erlang style comments starting with a <strong>%</strong> are allowed in
scanner files. A definition file has the following format:</p><pre><code class="">
&lt;Header&gt;

Definitions.

&lt;Macro Definitions&gt;

Rules.

&lt;Token Rules&gt;

Erlang code.

&lt;Erlang code&gt;</code></pre><p>The "Definitions.", "Rules." and "Erlang code." headings are
mandatory and must occur at the beginning of a source line. The
&lt;Header&gt;, &lt;Macro Definitions&gt; and &lt;Erlang code&gt;
sections may be empty but there must be at least one rule.</p><p>Macro definitions have the following format:</p><pre><code class="">
NAME = VALUE</code></pre><p>and there must be spaces around <strong>=</strong>. Macros can be used in
the regular expressions of rules by writing <strong>{NAME}</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>When macros are expanded in expressions the macro calls
are replaced by the macro value without any form of quoting or
enclosing in parentheses.</p></div><p>Rules have the following format:</p><pre><code class="">
&lt;Regexp&gt; : &lt;Erlang code&gt;.</code></pre><p>The &lt;Regexp&gt; must occur at the start of a line and not
include any blanks; use <strong>\t</strong> and <strong>\s</strong> to include TAB
and SPACE characters in the regular expression. If &lt;Regexp&gt;
matches then the corresponding &lt;Erlang code&gt; is evaluated to
generate a token. With the Erlang code the following predefined
variables are available:</p><dl><dt><strong>TokenChars</strong></dt><dd><p>A list of the characters in the matched token.</p> </dd><dt><strong>TokenLen</strong></dt><dd><p>The number of characters in the matched token.</p> </dd><dt><strong>TokenLine</strong></dt><dd><p>The line number where the token occurred.</p> </dd></dl><p>The code must return:</p><dl><dt><strong>{token,Token}</strong></dt><dd><p>Return <strong>Token</strong> to the caller.</p> </dd><dt><strong>{end_token,Token}</strong></dt><dd><p>Return <strong>Token</strong> and is last token in a tokens call.</p> </dd><dt><strong>skip_token</strong></dt><dd><p>Skip this token completely.</p> </dd><dt><strong>{error,ErrString}</strong></dt><dd><p>An error in the token, <strong>ErrString</strong> is a string
describing the error.</p> </dd></dl><p>It is also possible to push back characters into the input
characters with the following returns:</p><ul><li><strong>{token,Token,PushBackList}</strong></li><li><strong>{end_token,Token,PushBackList}</strong></li><li><strong>{skip_token,PushBackList}</strong></li></ul><p>These have the same meanings as the normal returns but the
characters in <strong>PushBackList</strong> will be prepended to the input
characters and scanned for the next token. Note that pushing
back a newline will mean the line numbering will no longer be
correct.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Pushing back characters gives you unexpected
possibilities to cause the scanner to loop!</p></div><p>The following example would match a simple Erlang integer or
float and return a token which could be sent to the Erlang
parser:</p><pre><code class="">
D = [0-9]

{D}+ :
  {token,{integer,TokenLine,list_to_integer(TokenChars)}}.

{D}+\.{D}+((E|e)(\+|\-)?{D}+)? :
  {token,{float,TokenLine,list_to_float(TokenChars)}}.</code></pre><p>The Erlang code in the "Erlang code." section is written into
the output file directly after the module declaration and
predefined exports declaration so it is possible to add extra
exports, define imports and other attributes which are then
visible in the whole file.</p><h2>Regular Expressions</h2><p>The regular expressions allowed here is a subset of the set
found in <strong>egrep</strong> and in the AWK programming language, as
defined in the book, The AWK Programming Language, by A. V. Aho,
B. W. Kernighan, P. J. Weinberger. They are composed of the
following characters:</p><dl><dt><strong>c</strong></dt><dd><p>Matches the non-metacharacter c.</p> </dd><dt><strong>\c</strong></dt><dd><p>Matches the escape sequence or literal character c.</p> </dd><dt><strong>.</strong></dt><dd><p>Matches any character.</p> </dd><dt><strong>^</strong></dt><dd><p>Matches the beginning of a string.</p> </dd><dt><strong>$</strong></dt><dd><p>Matches the end of a string.</p></dd><dt><strong>[abc...]</strong></dt><dd><p>Character class, which matches any of the characters
<strong>abc...</strong>. Character ranges are specified by a pair of
characters separated by a <strong>-</strong>.</p> </dd><dt><strong>[^abc...]</strong></dt><dd><p>Negated character class, which matches any character
except <strong>abc...</strong>.</p> </dd><dt><strong>r1 | r2</strong></dt><dd><p>Alternation. It matches either <strong>r1</strong> or <strong>r2</strong>.</p> </dd><dt><strong>r1r2</strong></dt><dd><p>Concatenation. It matches <strong>r1</strong> and then <strong>r2</strong>.</p> </dd><dt><strong>r+</strong></dt><dd><p>Matches one or more <strong>rs</strong>.</p> </dd><dt><strong>r*</strong></dt><dd><p>Matches zero or more <strong>rs</strong>.</p> </dd><dt><strong>r?</strong></dt><dd><p>Matches zero or one <strong>rs</strong>.</p> </dd><dt><strong>(r)</strong></dt><dd><p>Grouping. It matches <strong>r</strong>.</p> </dd></dl><p>The escape sequences allowed are the same as for Erlang strings:</p><dl><dt><strong>\b</strong></dt><dd><p>Backspace.</p></dd><dt><strong>\f</strong></dt><dd><p>Form feed.</p></dd><dt><strong>\n</strong></dt><dd><p>Newline (line feed).</p></dd><dt><strong>\r</strong></dt><dd><p>Carriage return.</p></dd><dt><strong>\t</strong></dt><dd><p>Tab.</p></dd><dt><strong>\e</strong></dt><dd><p>Escape.</p></dd><dt><strong>\v</strong></dt><dd><p>Vertical tab.</p></dd><dt><strong>\s</strong></dt><dd><p>Space.</p></dd><dt><strong>\d</strong></dt><dd><p>Delete.</p></dd><dt><strong>\ddd</strong></dt><dd><p>The octal value <strong>ddd</strong>.</p></dd><dt><strong>\xhh</strong></dt><dd><p>The hexadecimal value <strong>hh</strong>.</p></dd><dt><strong>\x{h...}</strong></dt><dd><p>The hexadecimal value <strong>h...</strong>.</p></dd><dt><strong>\c</strong></dt><dd><p>Any other character literally, for example <strong>\\</strong> for
backslash, <strong>\"</strong> for <strong>"</strong>.</p> </dd></dl><p>The following examples define simplified versions of a few
Erlang data types:</p><pre><code class=""> 
Atoms [a-z][0-9a-zA-Z_]*

Variables [A-Z_][0-9a-zA-Z_]*

Floats (\+|-)?[0-9]+\.[0-9]+((E|e)(\+|-)?[0-9]+)?</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Anchoring a regular expression with <strong>^</strong> and <strong>$</strong>
is not implemented in the current version of Leex and just
generates a parse error.</p></div></body></html>