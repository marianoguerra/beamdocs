<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Mnesia Reference Manual</h1><p>The Mnesia application is a distributed Database Management
System (DBMS), appropriate for telecommunications applications and other
Erlang applications, which require continuous operation and exhibit soft
real-time properties.</p><h2>mnesia</h2><p>A distributed telecommunications DBMS</p><p>The following are some of the most important and attractive
capabilities provided by Mnesia:<ul><li>A relational/object hybrid data model that is suitable for telecommunications applications. </li><li>A DBMS query language, Query List Comprehension (QLC) as an add-on library. </li><li>Persistence. Tables can be coherently kept on disc and in the main memory. </li><li>Replication. Tables can be replicated at several nodes. </li><li>Atomic transactions. A series of table manipulation operations can be grouped into a single atomic transaction. </li><li>Location transparency. Programs can be written without knowledge of the actual data location. </li><li>Extremely fast real-time data searches. </li><li>Schema manipulation routines. The DBMS can be reconfigured at runtime without stopping the system. </li></ul>This Reference Manual describes the Mnesia API. This
includes functions that define and manipulate Mnesia
tables.All functions in this Reference Manual can be used in any
combination with queries using the list comprehension notation.
For information about the query notation, see the
<a href="./qlc">qlc</a>
manual page in STDLIB.Data in Mnesia is organized as a set of tables. Each table
has a name that must be an atom. Each table is made up of
Erlang records. The user is responsible for the record
definitions. Each table also has a set of properties. The
following are some of the properties that are associated with each
table:<ul><li> <p><strong>type</strong>. Each table can have <strong>set</strong>,
<strong>ordered_set</strong>, or <strong>bag</strong> semantics. Notice that
currently <strong>ordered_set</strong> is not supported for
<strong>disc_only_copies</strong>.</p> <p>If a table is of type <strong>set</strong>, each key leads to
either one or zero records.</p> <p>If a new item is inserted with the same key as an
existing record, the old record is overwritten. However,
if a table is of type <strong>bag</strong>, each key can map to
several records. All records in type <strong>bag</strong> tables are
unique, only the keys can be duplicated.</p> </li><li> <p><strong>record_name</strong>. All records stored in a table must
have the same name. The records must be instances of the
same record type.</p> </li><li> <p><strong>ram_copies</strong>. A table can be replicated on a number
of Erlang nodes. Property <strong>ram_copies</strong> specifies a
list of Erlang nodes where RAM copies are kept. These
copies can be dumped to disc at regular intervals. However,
updates to these copies are not written to disc on a
transaction basis.</p> </li><li> <p><strong>disc_copies</strong>. This property
specifies a list of Erlang nodes where the table is kept in
RAM and on disc. All updates of the table are
performed in the actual table and are also logged to disc.
If a table is of type <strong>disc_copies</strong> at a certain node,
the entire table is resident in RAM memory and on disc.
Each transaction performed on the table is appended to a
<strong>LOG</strong> file and written into the RAM table.</p> </li><li> <p><strong>disc_only_copies</strong>. Some, or all, table replicas
can be kept on disc only. These replicas are considerably
slower than the RAM-based replicas.</p> </li><li> <p><strong>index</strong>. This is a list of attribute names, or
integers, which specify the tuple positions on which
Mnesia is to build and maintain an extra index
table.</p> </li><li> <p><strong>local_content</strong>. When an application requires
tables whose contents are local to each node,
<strong>local_content</strong> tables can be used. The table name
is known to all Mnesia nodes, but its content is
unique on each node. This means that access to such a table
must be done locally. Set field <strong>local_content</strong> to
<strong>true</strong> to enable the <strong>local_content</strong>
behavior. Default is <strong>false</strong>.</p> </li><li> <p><strong>majority</strong>. This attribute is <strong>true</strong> or
<strong>false</strong>; default is <strong>false</strong>. When <strong>true</strong>,
a majority of the table replicas must be available for an
update to succeed. Majority checking can be enabled on
tables with mission-critical data, where it is vital to
avoid inconsistencies because of network splits.</p> </li><li> <p><strong>snmp</strong>. Each (set-based) Mnesia table can be
automatically turned into a Simple Network Management
Protocol (SNMP) ordered table as well.
This property specifies the types of the SNMP keys.</p> </li><li> <p><strong>attributes</strong>. The names of the attributes for the
records that are inserted in the table.</p> </li></ul>For information about the complete set of table properties
and their details, see <strong>mnesia:create_table/2</strong>.This Reference Manual uses a table of persons to illustrate
various examples. The following record definition is assumed:<pre><code class="">
-record(person, {name,
                 age = 0,
                 address = unknown,
                 salary = 0,
                 children = []}),</code></pre>The first record attribute is the primary key, or key
for short.The function descriptions are sorted in alphabetical order.
It is recommended to start to read about
<strong>mnesia:create_table/2</strong>, <strong>mnesia:lock/2</strong>, and
<strong>mnesia:activity/4</strong> before you continue and learn
about the rest.Writing or deleting in transaction-context creates a local
copy of each modified record during the transaction. During
iteration, that is, <strong>mnesia:fold[lr]/4</strong>,
<strong>mnesia:next/2</strong>, <strong>mnesia:prev/2</strong>, and
<strong>mnesia:snmp_get_next_index/2</strong>, Mnesia
compensates for every written or deleted record, which can
reduce the performance.If possible, avoid writing or deleting records in the same
transaction before iterating over the table.</p><h2>Functions</h2><h3>abort(Reason) -&gt; transaction abort</h3><p>Terminates the current transaction.</p><p>Makes the transaction silently
return the tuple <strong>{aborted, Reason}</strong>.
Termination of a Mnesia transaction means that
an exception is thrown to an enclosing <strong>catch</strong>.
Thus, the expression <strong>catch mnesia:abort(x)</strong> does
not terminate the transaction.</p><h3>activate_checkpoint(Args) -&gt; {ok,Name,Nodes} | {error,Reason}</h3><p>Activates a checkpoint.</p><a name="activate_checkpoint"></a><p>A checkpoint is a consistent view of the system.
A checkpoint can be activated on a set of tables.
This checkpoint can then be traversed and
presents a view of the system as it existed at the time when
the checkpoint was activated, even if the tables are
being or have been manipulated.</p><p><strong>Args</strong> is a list of the following tuples:</p><ul><li> <p><strong>{name,Name}</strong>. <strong>Name</strong> is the checkpoint name.
Each checkpoint must have a name that is unique to the
associated nodes. The name can be reused only once the
checkpoint has been deactivated. By default, a name
that is probably unique is generated.</p> </li><li> <p><strong>{max,MaxTabs}</strong>. <strong>MaxTabs</strong> is a list of
tables that are to be included in the checkpoint.
Default is <strong>[]</strong>. For these tables, the redundancy is
maximized and checkpoint information is retained together
with all replicas. The checkpoint becomes more fault
tolerant if the tables have several replicas. When a new
replica is added by the schema manipulation
function <strong>mnesia:add_table_copy/3</strong>, a retainer is
also attached automatically.</p> </li><li> <p><strong>{min,MinTabs}</strong>. <strong>MinTabs</strong> is a list of
tables that are to be included in the checkpoint.
Default is []. For these tables, the redundancy is
minimized and the checkpoint information is only retained
with one replica, preferably on the local node.</p> </li><li> <p><strong>{allow_remote,Bool}</strong>. <strong>false</strong> means that
all retainers must be local. The checkpoint cannot be
activated if a table does not reside locally.
<strong>true</strong> allows retainers to be allocated on any
node. Default is <strong>true</strong>.</p> </li><li> <p><strong>{ram_overrides_dump,Bool}</strong>. Only applicable
for <strong>ram_copies</strong>. <strong>Bool</strong> allows you to choose
to back up the table state as it is in RAM, or as it is
on disc. <strong>true</strong> means that the latest committed
records in RAM are to be included in the checkpoint.
These are the records that the application accesses.
<strong>false</strong> means that the records dumped to <strong>DAT</strong>
files are to be included in the checkpoint. These
records are loaded at startup. Default is <strong>false</strong>.</p> </li></ul><p>Returns <strong>{ok,Name,Nodes}</strong> or <strong>{error,Reason}</strong>.
<strong>Name</strong> is the (possibly generated) checkpoint name.
<strong>Nodes</strong> are the nodes that
are involved in the checkpoint. Only nodes that keep a
checkpoint retainer know about the checkpoint.</p><h3>activity(AccessContext, Fun [, Args]) -&gt; ResultOfFun | exit(Reason)</h3><p>Executes <strong>Fun</strong> in <strong>AccessContext</strong>.</p><a name="activity_2_3"></a><p>Calls <strong>mnesia:activity(AccessContext, Fun, Args, AccessMod)</strong>, where <strong>AccessMod</strong> is the default
access callback module obtained by
<strong>mnesia:system_info(access_module)</strong>. <strong>Args</strong>
defaults to <strong>[]</strong> (empty list).</p><h3>activity(AccessContext, Fun, Args, AccessMod) -&gt; ResultOfFun | exit(Reason)</h3><p>Executes <strong>Fun</strong> in <strong>AccessContext</strong>.</p><a name="activity_4"></a><p>Executes the functional object <strong>Fun</strong>
with argument <strong>Args</strong>.</p><p>The code that executes inside the activity can
consist of a series of table manipulation functions, which are
performed in an <strong>AccessContext</strong>. Currently, the following
access contexts are supported:</p><dl><dt><strong>transaction</strong></dt><dd> <p>Short for <strong>{transaction, infinity}</strong></p> </dd><dt><strong>{transaction, Retries}</strong></dt><dd> <p>Calls <strong>mnesia:transaction(Fun, Args, Retries)</strong>.
Notice that the result from <strong>Fun</strong> is
returned if the transaction is successful (atomic),
otherwise the function exits with an abort reason.</p> </dd><dt><strong>sync_transaction</strong></dt><dd> <p>Short for <strong>{sync_transaction, infinity}</strong></p> </dd><dt><strong>{sync_transaction, Retries}</strong></dt><dd> <p>Calls <strong>mnesia:sync_transaction(Fun, Args, Retries)</strong>.
Notice that the result from <strong>Fun</strong> is
returned if the transaction is successful (atomic),
otherwise the function exits with an abort reason.</p> </dd><dt><strong>async_dirty</strong></dt><dd> <p>Calls <strong>mnesia:async_dirty(Fun, Args)</strong>.</p> </dd><dt><strong>sync_dirty</strong></dt><dd> <p>Calls <strong>mnesia:sync_dirty(Fun, Args)</strong>.</p> </dd><dt><strong>ets</strong></dt><dd> <p>Calls <strong>mnesia:ets(Fun, Args)</strong>.</p> </dd></dl><p>This function (<strong>mnesia:activity/4</strong>) differs in an
important way from the functions <strong>mnesia:transaction</strong>,
<strong>mnesia:sync_transaction</strong>,
<strong>mnesia:async_dirty</strong>, <strong>mnesia:sync_dirty</strong>, and
<strong>mnesia:ets</strong>. Argument <strong>AccessMod</strong>
is the name of a callback module, which implements the
<strong>mnesia_access</strong> behavior.</p><p>Mnesia forwards calls to the following functions:</p><ul><li>mnesia:lock/2 (read_lock_table/1, write_lock_table/1) </li><li>mnesia:write/3 (write/1, s_write/1) </li><li>mnesia:delete/3 (delete/1, s_delete/1) </li><li>mnesia:delete_object/3 (delete_object/1, s_delete_object/1) </li><li>mnesia:read/3 (read/1, wread/1) </li><li>mnesia:match_object/3 (match_object/1) </li><li>mnesia:all_keys/1 </li><li>mnesia:first/1 </li><li>mnesia:last/1 </li><li>mnesia:prev/2 </li><li>mnesia:next/2 </li><li>mnesia:index_match_object/4 (index_match_object/2) </li><li>mnesia:index_read/3 </li><li>mnesia:table_info/2 </li></ul><p>to the corresponding:</p><ul><li>AccessMod:lock(ActivityId, Opaque, LockItem, LockKind) </li><li>AccessMod:write(ActivityId, Opaque, Tab, Rec, LockKind) </li><li>AccessMod:delete(ActivityId, Opaque, Tab, Key, LockKind) </li><li>AccessMod:delete_object(ActivityId, Opaque, Tab, RecXS, LockKind) </li><li>AccessMod:read(ActivityId, Opaque, Tab, Key, LockKind) </li><li>AccessMod:match_object(ActivityId, Opaque, Tab, Pattern, LockKind) </li><li>AccessMod:all_keys(ActivityId, Opaque, Tab, LockKind) </li><li>AccessMod:first(ActivityId, Opaque, Tab) </li><li>AccessMod:last(ActivityId, Opaque, Tab) </li><li>AccessMod:prev(ActivityId, Opaque, Tab, Key) </li><li>AccessMod:next(ActivityId, Opaque, Tab, Key) </li><li>AccessMod:index_match_object(ActivityId, Opaque, Tab, Pattern, Attr, LockKind) </li><li>AccessMod:index_read(ActivityId, Opaque, Tab, SecondaryKey, Attr, LockKind) </li><li>AccessMod:table_info(ActivityId, Opaque, Tab, InfoItem) </li></ul><p><strong>ActivityId</strong> is a record that represents the identity
of the enclosing Mnesia activity. The first field
(obtained with <strong>element(1, ActivityId)</strong>) contains an
atom, which can be interpreted as the activity type:
<strong>ets</strong>, <strong>async_dirty</strong>, <strong>sync_dirty</strong>, or
<strong>tid</strong>. <strong>tid</strong> means that the activity is a
transaction. The structure of the rest of the identity
record is internal to Mnesia.</p><p><strong>Opaque</strong> is an opaque data structure that is internal
to Mnesia.</p><h3>add_table_copy(Tab, Node, Type) -&gt; {aborted, R} | {atomic, ok}</h3><p>Copies a table to a remote node.</p><a name="add_table_copy"></a><p>Makes another copy of a table at the node <strong>Node</strong>.
Argument <strong>Type</strong> must be either of the atoms
<strong>ram_copies</strong>, <strong>disc_copies</strong>, or
<strong>disc_only_copies</strong>. For example, the following call
ensures that a disc replica of the <strong>person</strong> table also
exists at node <strong>Node</strong>:</p><pre><code class="">
mnesia:add_table_copy(person, Node, disc_copies)</code></pre><p>This function can also be used to add a replica of the
table named <strong>schema</strong>.</p><h3>add_table_index(Tab, AttrName) -&gt; {aborted, R} | {atomic, ok}</h3><p>Creates an index for a table.</p><a name="add_table_index"></a><p>Table indexes can be used whenever the user
wants to use frequently some other field than the key field
to look up records. If this other field has an associated
index, these lookups can occur in constant time
and space. For example, if your application wishes to use
field <strong>age</strong> to find efficiently all persons with
a specific age, it can be a good idea to have an index on
field <strong>age</strong>. This can be done with the following
call:</p><pre><code class="">
mnesia:add_table_index(person, age)</code></pre><p>Indexes do not come for free. They occupy space that is
proportional to the table size, and they cause insertions
into the table to execute slightly slower.</p><h3>all_keys(Tab) -&gt; KeyList | transaction abort</h3><p>Returns all keys in a table.</p><a name="all_keys"></a><p>Returns a list of all keys in the table named <strong>Tab</strong>.
The semantics of this function is context-sensitive.
For more information, see <strong>mnesia:activity/4</strong>. In
transaction-context, it acquires a read lock on the entire
table.</p><h3>async_dirty(Fun, [, Args]) -&gt; ResultOfFun | exit(Reason)</h3><p>Calls the <strong>Fun</strong> in a context that is not protected by a transaction.</p><a name="async_dirty"></a><p>Calls the <strong>Fun</strong> in a context that is not protected by
a transaction. The Mnesia function calls performed in
the <strong>Fun</strong> are mapped to the corresponding dirty
functions. This still involves logging, replication, and
subscriptions, but there is no locking, local transaction
storage, or commit protocols involved. Checkpoint retainers
and indexes are updated, but they are updated dirty. As
for normal <strong>mnesia:dirty_*</strong> operations, the operations
are performed semi-asynchronously. For details, see
<strong>mnesia:activity/4</strong> and the User's Guide.</p><p>The Mnesia tables can be manipulated without
using transactions. This has some serious disadvantages, but
is considerably faster, as the transaction manager is not
involved and no locks are set. A dirty operation does,
however, guarantee a certain level of consistency, and
the dirty operations cannot return garbled records.
All dirty operations provide location transparency
to the programmer, and a program does not have to be aware
of the whereabouts of a certain table to function.</p><p>Notice that it is more than ten times more efficient to
read records dirty than within a transaction.</p><p>Depending on the application, it can be a good idea to use
the dirty functions for certain operations. Almost all
Mnesia functions that can be called within
transactions have a dirty equivalent, which is much more
efficient.</p><p>However, notice that there is a risk that the database can
be left in an inconsistent state if dirty operations are
used to update it. Dirty operations are only to be used
for performance reasons when it is absolutely necessary.</p><p>Notice that calling (nesting) <strong>mnesia:[a]sync_dirty</strong>
inside a transaction-context inherits the transaction
semantics.</p><h3>backup(Opaque [, BackupMod]) -&gt; ok | {error,Reason}</h3><p>Backs up all tables in the database.</p><a name="backup"></a><p>Activates a new checkpoint covering all Mnesia tables,
including the schema, with maximum degree of redundancy, and
performs a backup using <strong>backup_checkpoint/2/3</strong>. The
default value of the backup callback module <strong>BackupMod</strong>
is obtained by <strong>mnesia:system_info(backup_module)</strong>.</p><h3>backup_checkpoint(Name, Opaque [, BackupMod]) -&gt; ok | {error,Reason}</h3><p>Backs up all tables in a checkpoint.</p><a name="backup_checkpoint"></a><p>The tables are backed up to external media using backup
module <strong>BackupMod</strong>. Tables with the local contents
property are backed up as they exist on the current
node. <strong>BackupMod</strong> is the default backup callback
module obtained by
<strong>mnesia:system_info(backup_module)</strong>. For information
about the exact callback interface (the
<strong>mnesia_backup behavior</strong>), see the User's Guide.</p><h3>change_config(Config, Value) -&gt; {error, Reason} | {ok, ReturnValue}</h3><p>Changes a configuration parameter.</p><a name="change_config"></a><p><strong>Config</strong> is to be an atom of the following
configuration parameters:</p><dl><dt><strong>extra_db_nodes</strong></dt><dd> <p><strong>Value</strong> is a list of nodes that Mnesia
is to try to connect to. <strong>ReturnValue</strong> is those
nodes in <strong>Value</strong> that Mnesia is connected
to.</p> <p>Notice that this function must only be used to connect
to newly started RAM nodes (N.D.R.S.N.) with an empty
schema. If, for example, this function is used after
the network has been partitioned, it can lead to
inconsistent tables.</p> <p>Notice that Mnesia can be connected to other
nodes than those returned in <strong>ReturnValue</strong>.</p> </dd><dt><strong>dc_dump_limit</strong></dt><dd> <p><strong>Value</strong> is a number. See the description in
<a href="#configuration_parameters">Section Configuration Parameters</a>. <strong>ReturnValue</strong>
is the new value. Notice that this configuration
parameter is not persistent. It is lost when
Mnesia has stopped.</p> </dd></dl><h3>change_table_access_mode(Tab, AccessMode) -&gt; {aborted, R} | {atomic, ok}</h3><p>Changes the access mode for the table.</p><a name="change_table_access_mode"></a><p><strong>AcccessMode</strong> is by default the atom
<strong>read_write</strong> but it can also be set to the atom
<strong>read_only</strong>. If <strong>AccessMode</strong> is set to
<strong>read_only</strong>, updates to the table cannot be
performed. At startup, Mnesia always loads
<strong>read_only</strong> tables locally regardless of when and if
Mnesia is terminated on other nodes.</p><h3>change_table_copy_type(Tab, Node, To) -&gt; {aborted, R} | {atomic, ok}</h3><p>Changes the storage type of a table.</p><a name="change_table_copy_type"></a><p>For example:</p><pre><code class="">
mnesia:change_table_copy_type(person, node(), disc_copies)</code></pre><p>Transforms the <strong>person</strong> table from a RAM table into
a disc-based table at <strong>Node</strong>.</p><p>This function can also be used to change the storage type
of the table named <strong>schema</strong>. The schema table can only
have <strong>ram_copies</strong> or <strong>disc_copies</strong> as the storage
type. If the storage type of the schema is <strong>ram_copies</strong>,
no other table can be disc-resident on that node.</p><h3>change_table_load_order(Tab, LoadOrder) -&gt; {aborted, R} | {atomic, ok}</h3><p>Changes the load order priority for the table.</p><a name="change_table_load_order"></a><p>The <strong>LoadOrder</strong> priority is by default <strong>0</strong> (zero)
but can be set to any integer. The tables with the highest
<strong>LoadOrder</strong> priority are loaded first at startup.</p><h3>change_table_majority(Tab, Majority) -&gt; {aborted, R} | {atomic, ok}</h3><p>Changes the majority check setting for the table.</p><p><strong>Majority</strong> must be a boolean. Default is <strong>false</strong>.
When <strong>true</strong>, a majority of the table replicas must be
available for an update to succeed. When used on fragmented
tables, <strong>Tab</strong> must be the base table name. Directly
changing the majority setting on individual fragments is
not allowed.</p><h3>clear_table(Tab) -&gt; {aborted, R} | {atomic, ok}</h3><p>Deletes all entries in a table.</p><a name="clear_table"></a><p>Deletes all entries in the table <strong>Tab</strong>.</p><h3>create_schema(DiscNodes) -&gt; ok | {error,Reason}</h3><p>Creates a new schema on the specified nodes.</p><a name="create_schema"></a><p>Creates a new database on disc. Various files are
created in the local Mnesia directory of each node.
Notice that the directory must be unique for each node.
Two nodes must never share the same directory. If possible,
use a local disc device to improve performance.</p><p><strong>mnesia:create_schema/1</strong> fails if any of the
Erlang nodes given as <strong>DiscNodes</strong> are not alive, if
Mnesia is running on any of the nodes, or if any
of the nodes already have a schema. Use
<strong>mnesia:delete_schema/1</strong> to get rid of old faulty
schemas.</p><p>Notice that only nodes with disc are to be included in
<strong>DiscNodes</strong>. Disc-less nodes, that is, nodes where
all tables including the schema only resides in RAM,
must not be included.</p><h3>create_table(Name, TabDef) -&gt; {atomic, ok} | {aborted, Reason}</h3><p>Creates a Mnesia table called <strong>Name</strong>with properties as described by argument <strong>TabDef</strong>.</p><a name="create_table"></a><p>Creates a Mnesia table called
<strong>Name</strong> according to argument <strong>TabDef</strong>. This
list must be a list of <strong>{Item, Value}</strong> tuples,
where the following values are allowed:</p><ul><li> <p><strong>{access_mode, Atom}</strong>. The access mode is by
default the atom <strong>read_write</strong> but it can also be
set to the atom <strong>read_only</strong>. If <strong>AccessMode</strong>
is set to <strong>read_only</strong>, updates to the table
cannot be performed.</p> <p>At startup, Mnesia always loads <strong>read_only</strong>
table locally regardless of when and if Mnesia is
terminated on other nodes. This argument returns the
access mode of the table. The access mode can be
<strong>read_only</strong> or <strong>read_write</strong>.</p> </li><li> <p><strong>{attributes, AtomList}</strong> is a list of the
attribute names for the records that are supposed to
populate the table. Default is <strong>[key, val]</strong>.
The table must at least have one extra attribute in
addition to the key.</p> <p>When accessing single attributes in a record, it is
not necessary, or even recommended, to hard code any
attribute names as atoms. Use construct
<strong>record_info(fields, RecordName)</strong> instead. It can
be used for records of type <strong>RecordName</strong>.</p> </li><li> <p><strong>{disc_copies, Nodelist}</strong>, where
<strong>Nodelist</strong> is a list of the nodes where this table
is supposed to have disc copies. If a table replica is
of type <strong>disc_copies</strong>, all write operations on this
particular replica of the table are written to disc and
to the RAM copy of the table.</p> <p>It is possible to have a replicated table of type
<strong>disc_copies</strong> on one node and another type on
another node.  Default is <strong>[]</strong>.</p> </li><li> <p><strong>{disc_only_copies, Nodelist}</strong>, where
<strong>Nodelist</strong> is a list of the nodes where this table
is supposed to have <strong>disc_only_copies</strong>. A disc only
table replica is kept on disc only and unlike the other
replica types, the contents of the replica do not
reside in RAM. These replicas are considerably slower
than replicas held in RAM.</p> </li><li> <p><strong>{index, Intlist}</strong>, where
<strong>Intlist</strong> is a list of attribute names (atoms) or
record fields for which Mnesia is to build and
maintain an extra index table. The <strong>qlc</strong> query
compiler <em>may</em> be able to optimize queries
if there are indexes available.</p> </li><li> <p><strong>{load_order, Integer}</strong>. The load order
priority is by default <strong>0</strong> (zero) but can be set
to any integer. The tables with the highest load order
priority are loaded first at startup.</p> </li><li> <p><strong>{majority, Flag}</strong>, where <strong>Flag</strong> must be a
boolean. If <strong>true</strong>, any (non-dirty) update to the
table is aborted, unless a majority of the table
replicas are available for the commit. When used on a
fragmented table, all fragments are given the same
the same majority setting.</p> </li><li> <p><strong>{ram_copies, Nodelist}</strong>, where
<strong>Nodelist</strong> is a list of the nodes where this table
is supposed to have RAM copies. A table replica of type
<strong>ram_copies</strong> is not written to disc on a per
transaction basis. <strong>ram_copies</strong> replicas can be
dumped to disc with the function
<strong>mnesia:dump_tables(Tabs)</strong>. Default value for
this attribute is <strong>[node()]</strong>.</p> </li><li> <p><strong>{record_name, Name}</strong>, where <strong>Name</strong> must
be an atom. All records stored in the table must have
this name as the first element. It defaults to the same
name as the table name.</p> </li><li> <p><strong>{snmp, SnmpStruct}</strong>. For a description of
<strong>SnmpStruct</strong>, see <strong>mnesia:snmp_open_table/2</strong>.
If this attribute is present in <strong>ArgList</strong> to
<strong>mnesia:create_table/2</strong>, the table is immediately
accessible by SNMP. Therefore applications that use
SNMP to manipulate and control the system can be
designed easily, since Mnesia provides a
direct mapping between the logical tables that make up
an SNMP control application and the physical data that
makes up a Mnesia table.</p> </li><li> <p><strong>{storage_properties, [{Backend, Properties}]</strong>
forwards more properties to the back end storage.
<strong>Backend</strong> can currently be <strong>ets</strong> or <strong>dets</strong>.
<strong>Properties</strong> is a list of options sent to the
back end storage during table creation. <strong>Properties</strong>
cannot contain properties already used by Mnesia,
such as <strong>type</strong> or <strong>named_table</strong>.</p> <p>For example:</p> <pre><code class="">
mnesia:create_table(table, [{ram_copies, [node()]}, {disc_only_copies, nodes()},
       {storage_properties,
        [{ets, [compressed]}, {dets, [{auto_save, 5000}]} ]}])</code></pre> </li><li> <p><strong>{type, Type}</strong>, where <strong>Type</strong> must be
either of the atoms <strong>set</strong>, <strong>ordered_set</strong>, or
<strong>bag</strong>. Default is <strong>set</strong>. In a
<strong>set</strong>, all records have unique keys. In a
<strong>bag</strong>, several records can have the same key, but
the record content is unique. If a non-unique record is
stored, the old conflicting records are overwritten.</p> <p>Notice that currently <strong>ordered_set</strong> is not
supported for <strong>disc_only_copies</strong>.</p> </li><li> <p><strong>{local_content, Bool}</strong>, where <strong>Bool</strong> is
<strong>true</strong> or <strong>false</strong>. Default is <strong>false</strong>.</p> </li></ul><p>For example, the following call creates the <strong>person</strong>
table (defined earlier) and replicates it on two nodes:</p><pre><code class="">
mnesia:create_table(person,
    [{ram_copies, [N1, N2]},
     {attributes, record_info(fields, person)}]).</code></pre><p>If it is required that Mnesia must build and
maintain an extra index table on attribute <strong>address</strong>
of all the <strong>person</strong> records that are inserted in the
table, the following code would be issued:</p><pre><code class="">
mnesia:create_table(person,
    [{ram_copies, [N1, N2]},
     {index, [address]},
     {attributes, record_info(fields, person)}]).
   </code></pre><p>The specification of <strong>index</strong> and <strong>attributes</strong>
can be hard-coded as <strong>{index, [2]}</strong> and
<strong>{attributes, [name, age, address, salary, children]}</strong>,
respectively.</p><p><strong>mnesia:create_table/2</strong> writes records into the
table <strong>schema</strong>. This function, and all other
schema manipulation functions, are implemented with the
normal transaction management system. This guarantees that
schema updates are performed on all nodes in an atomic
manner.</p><h3>deactivate_checkpoint(Name) -&gt; ok | {error, Reason}</h3><p>Deactivates a checkpoint.</p><a name="deactivate_checkpoint"></a><p>The checkpoint is automatically deactivated when some of
the tables involved have no retainer attached to them. This
can occur when nodes go down or when a replica is deleted.
Checkpoints are also deactivated with this function.
<strong>Name</strong> is the name of an active checkpoint.</p><h3>del_table_copy(Tab, Node) -&gt; {aborted, R} | {atomic, ok}</h3><p>Deletes the replica of table <strong>Tab</strong> at node <strong>Node</strong>.</p><a name="del_table_copy"></a><p>Deletes the replica of table <strong>Tab</strong> at node <strong>Node</strong>.
When the last replica is deleted with this
function, the table disappears entirely.</p><p>This function can also be used to delete a replica of
the table named <strong>schema</strong>. The Mnesia node is
then removed. Notice that Mnesia must be
stopped on the node first.</p><h3>del_table_index(Tab, AttrName) -&gt; {aborted, R} | {atomic, ok}</h3><p>Deletes an index in a table.</p><a name="del_table_index"></a><p>Deletes the index on attribute with name
<strong>AttrName</strong> in a table.</p><h3>delete({Tab, Key}) -&gt; transaction abort | ok</h3><p>Deletes all records in table <strong>Tab</strong> with the key <strong>Key</strong>.</p><a name="delete_2"></a><p>Calls <strong>mnesia:delete(Tab, Key, write)</strong>.</p><h3>delete(Tab, Key, LockKind) -&gt; transaction abort | ok</h3><p>Deletes all records in table <strong>Tab</strong>with the key <strong>Key</strong>.</p><a name="delete_3"></a><p>Deletes all records in table <strong>Tab</strong> with the key
<strong>Key</strong>.</p><p>The semantics of this function is context-sensitive.
For details, see <strong>mnesia:activity/4</strong>. In
transaction-context, it acquires a lock of type
<strong>LockKind</strong> in the record.
Currently, the lock types <strong>write</strong> and
<strong>sticky_write</strong> are supported.</p><h3>delete_object(Record) -&gt; transaction abort | ok</h3><p>Delete a record.</p><a name="delete_object_1"></a><p>Calls <strong>mnesia:delete_object(Tab, Record, write)</strong>, where
<strong>Tab</strong> is <strong>element(1, Record)</strong>.</p><h3>delete_object(Tab, Record, LockKind) -&gt; transaction abort | ok</h3><p>Deletes a record.</p><a name="delete_object_3"></a><p>If a table is of type <strong>bag</strong>, it can sometimes be
needed to delete only some of the records with a certain
key. This can be done with the function <strong>delete_object/3</strong>.
A complete record must be supplied to this function.</p><p>The semantics of this function is context-sensitive.
For details, see <strong>mnesia:activity/4</strong>. In
transaction-context, it acquires a lock of type
<strong>LockKind</strong> on the record.
Currently, the lock types <strong>write</strong> and
<strong>sticky_write</strong> are supported.</p><h3>delete_schema(DiscNodes) -&gt; ok | {error,Reason}</h3><p>Deletes the schema on the given nodes.</p><a name="delete_schema"></a><p>Deletes a database created with
<strong>mnesia:create_schema/1</strong>.
<strong>mnesia:delete_schema/1</strong> fails if any of the Erlang
nodes given as <strong>DiscNodes</strong> are not alive, or if
Mnesia is running on any of the nodes.</p><p>After the database is deleted, it can still be possible
to start Mnesia as a disc-less node. This depends
on how configuration parameter <strong>schema_location</strong> is
set.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Use this function with extreme caution, as it makes
existing persistent data obsolete. Think twice before
using it.</p></div><h3>delete_table(Tab) -&gt; {aborted, Reason} | {atomic, ok}</h3><p>Deletes permanently all replicas of table <strong>Tab</strong>.</p><a name="delete_table"></a><p>Permanently deletes all replicas of table <strong>Tab</strong>.</p><h3>dirty_all_keys(Tab) -&gt; KeyList | exit({aborted, Reason})</h3><p>Dirty search for all record keys in table.</p><a name="delete_all_keys"></a><p>Dirty equivalent of the function <strong>mnesia:all_keys/1</strong>.</p><h3>dirty_delete({Tab, Key}) -&gt; ok | exit({aborted, Reason})</h3><p>Dirty delete of a record.</p><a name="dirty_delete"></a><p>Calls <strong>mnesia:dirty_delete(Tab, Key)</strong>.</p><h3>dirty_delete(Tab, Key) -&gt; ok | exit({aborted, Reason})</h3><p>Dirty delete of a record.</p><p>Dirty equivalent of the function <strong>mnesia:delete/3</strong>.</p><h3>dirty_delete_object(Record)</h3><p>Dirty delete of a record.</p><a name="dirty_delete_object_1"></a><p>Calls <strong>mnesia:dirty_delete_object(Tab, Record)</strong>,
where <strong>Tab</strong> is <strong>element(1, Record)</strong>.</p><h3>dirty_delete_object(Tab, Record)</h3><p>Dirty delete of a record.</p><p>Dirty equivalent of the function <strong>mnesia:delete_object/3</strong>.</p><h3>dirty_first(Tab) -&gt;  Key | exit({aborted, Reason})</h3><p>Returns the key for the first record in a table.</p><a name="dirty_first"></a><p>Records in <strong>set</strong> or <strong>bag</strong> tables are not ordered. 
However, there is an ordering of the records that is unknown
to the user. Therefore, a table can be traversed by this
function with the function <strong>mnesia:dirty_next/2</strong>.
</p><p>If there are no records in the table, this function
returns the atom <strong>'$end_of_table'</strong>. It is therefore
highly undesirable, but not disallowed, to use this atom
as the key for any user records.</p><h3>dirty_index_match_object(Pattern, Pos)</h3><p>Dirty pattern match using index.</p><a name="dirty_index_match_object_2"></a><p>Starts
<strong>mnesia:dirty_index_match_object(Tab, Pattern, Pos)</strong>,
where <strong>Tab</strong> is <strong>element(1, Pattern)</strong>.</p><h3>dirty_index_match_object(Tab, Pattern, Pos)</h3><p>Dirty pattern match using index.</p><p>Dirty equivalent of the function
<strong>mnesia:index_match_object/4</strong>.</p><h3>dirty_index_read(Tab, SecondaryKey, Pos)</h3><p>Dirty read using index.</p><a name="dirty_index_read"></a><p>Dirty equivalent of the function
<strong>mnesia:index_read/3</strong>.</p><h3>dirty_last(Tab) -&gt; Key | exit({aborted, Reason})</h3><p>Returns the key for the last record in a table.</p><a name="dirty_last"></a><p>Works exactly like <strong>mnesia:dirty_first/1</strong> but returns
the last object in Erlang term order for the <strong>ordered_set</strong>
table type. For all other table types,
<strong>mnesia:dirty_first/1</strong> and
<strong>mnesia:dirty_last/1</strong> are synonyms.</p><h3>dirty_match_object(Pattern) -&gt; RecordList | exit({aborted, Reason})</h3><p>Dirty pattern match pattern.</p><a name="dirty_match_object_1"></a><p>Calls <strong>mnesia:dirty_match_object(Tab, Pattern)</strong>,
where <strong>Tab</strong> is <strong>element(1, Pattern)</strong>.</p><h3>dirty_match_object(Tab, Pattern) -&gt; RecordList | exit({aborted, Reason})</h3><p>Dirty pattern match pattern.</p><p>Dirty equivalent of the function
<strong>mnesia:match_object/3</strong>.</p><h3>dirty_next(Tab, Key) -&gt; Key | exit({aborted, Reason})</h3><p>Return the next key in a table.</p><a name="dirty_next"></a><p>Traverses a table and
performs operations on all records in the table.
When the end of the table is reached, the special key
<strong>'$end_of_table'</strong> is returned. Otherwise, the function
returns a key that can be used to read the actual record. The
behavior is undefined if another Erlang process performs write
operations on the table while it is being traversed with the
function <strong>mnesia:dirty_next/2</strong>.</p><h3>dirty_prev(Tab, Key) -&gt; Key | exit({aborted, Reason})</h3><p>Returns the previous key in a table.</p><a name="dirty_prev"></a><p>Works exactly like <strong>mnesia:dirty_next/2</strong> but returns
the previous object in Erlang term order for the
<strong>ordered_set</strong> table type. For all other table types,
<strong>mnesia:dirty_next/2</strong> and
<strong>mnesia:dirty_prev/2</strong> are synonyms.</p><h3>dirty_read({Tab, Key}) -&gt; ValueList | exit({aborted, Reason}</h3><p>Dirty read of records.</p><a name="dirty_read"></a><p>Calls <strong>mnesia:dirty_read(Tab, Key)</strong>.</p><h3>dirty_read(Tab, Key) -&gt; ValueList | exit({aborted, Reason}</h3><p>Dirty read of records.</p><p>Dirty equivalent of the function <strong>mnesia:read/3</strong>.</p><h3>dirty_select(Tab, MatchSpec) -&gt; ValueList | exit({aborted, Reason}</h3><p>Dirty matches the objects in <strong>Tab</strong> against <strong>MatchSpec</strong>.</p><a name="dirty_select"></a><p>Dirty equivalent of the function <strong>mnesia:select/2</strong>.</p><h3>dirty_slot(Tab, Slot) -&gt; RecordList | exit({aborted, Reason})</h3><p>Returns the list of records that are associated with <strong>Slot</strong> in a table.</p><a name="dirty_slot"></a><p>Traverses a table in a
manner similar to the function <strong>mnesia:dirty_next/2</strong>.
A table has a number of slots that range from 0 (zero) to
an unknown upper bound. The function
<strong>mnesia:dirty_slot/2</strong> returns the special atom
<strong>'$end_of_table'</strong> when the end of the table is reached.
The behavior of this function is undefined if a write
operation is performed on the table while it is being
traversed.</p><h3>dirty_update_counter({Tab, Key}, Incr) -&gt; NewVal | exit({aborted, Reason})</h3><p>Dirty update of a counter record.</p><a name="dirty_update_counter"></a><p>Calls <strong>mnesia:dirty_update_counter(Tab, Key, Incr)</strong>.</p><h3>dirty_update_counter(Tab, Key, Incr) -&gt; NewVal | exit({aborted, Reason})</h3><p>Dirty update of a counter record.</p><p>Mnesia has no special counter records. However,
records of the form <strong>{Tab, Key, Integer}</strong> can be used
as (possibly disc-resident) counters when <strong>Tab</strong> is a
<strong>set</strong>. This function updates a counter with a positive
or negative number. However, counters can never become less
than zero. There are two significant differences between
this function and the action of first reading the record,
performing the arithmetics, and then writing the record:</p><ul><li>It is much more efficient. </li><li><strong>mnesia:dirty_update_counter/3</strong> is performed as an atomic operation although it is not protected by a transaction. </li></ul><p>If two processes perform <strong>mnesia:dirty_update_counter/3</strong>
simultaneously, both updates take effect without the
risk of losing one of the updates. The new value
<strong>NewVal</strong> of the counter is returned.</p><p>If <strong>Key</strong> do not exists, a new record is created with
value <strong>Incr</strong> if it is larger than 0, otherwise it is
set to 0.</p><h3>dirty_write(Record) -&gt; ok | exit({aborted, Reason})</h3><p>Dirty write of a record.</p><a name="dirty_write_1"></a><p>Calls <strong>mnesia:dirty_write(Tab, Record)</strong>,
where <strong>Tab</strong> is <strong>element(1, Record)</strong>.</p><h3>dirty_write(Tab, Record) -&gt; ok | exit({aborted, Reason})</h3><p>Dirty write of a record.</p><p>Dirty equivalent of the function <strong>mnesia:write/3</strong>.</p><h3>dump_log() -&gt; dumped</h3><p>Performs a user-initiated dump of the local log file.</p><a name="dump_log"></a><p>Performs a user-initiated dump of the local log file.
This is usually not necessary, as Mnesia by default
manages this automatically. See configuration parameters
<a href="#dump_log_time_threshold">dump_log_time_threshold</a>
and
<a href="#dump_log_write_threshold">dump_log_write_threshold</a>.
</p><h3>dump_tables(TabList) -&gt; {atomic, ok} | {aborted, Reason}</h3><p>Dumps all RAM tables to disc.</p><a name="dump_tables"></a><p>Dumps a set of <strong>ram_copies</strong> tables
to disc. The next time the system is started, these tables
are initiated with the data found in the files that are the
result of this dump. None of the tables can have
disc-resident replicas.</p><h3>dump_to_textfile(Filename)</h3><p>Dumps local tables into a text file.</p><a name="dump_to_textfile"></a><p>Dumps all local tables of a Mnesia system into a
text file, which can be edited (by a normal text editor)
and then be reloaded with
<strong>mnesia:load_textfile/1</strong>. Only use this function for
educational purposes. Use other functions to deal with real
backups.</p><h3>error_description(Error) -&gt; String</h3><p>Returns a string describing a particular Mnesia error.</p><a name="error_description"></a><p>All Mnesia transactions, including all the schema
update functions, either return value <strong>{atomic, Val}</strong>
or the tuple <strong>{aborted, Reason}</strong>. <strong>Reason</strong> can
be either of the atoms in the following list. The
function <strong>error_description/1</strong> returns a descriptive
string that describes the error.</p><ul><li><strong>nested_transaction</strong>. Nested transactions are not allowed in this context. </li><li><strong>badarg</strong>. Bad or invalid argument, possibly bad type. </li><li><strong>no_transaction</strong>. Operation not allowed outside transactions. </li><li><strong>combine_error</strong>. Table options illegally combined. </li><li><strong>bad_index</strong>. Index already exists, or was out of bounds. </li><li><strong>already_exists</strong>. Schema option to be activated is already on. </li><li><strong>index_exists</strong>. Some operations cannot be performed on tables with an index. </li><li><strong>no_exists</strong>. Tried to perform operation on non-existing (not-alive) item. </li><li><strong>system_limit</strong>. A system limit was exhausted. </li><li><strong>mnesia_down</strong>. A transaction involves records on a remote node, which became unavailable before the transaction was completed. Records are no longer available elsewhere in the network. </li><li><strong>not_a_db_node</strong>. A node was mentioned that does not exist in the schema. </li><li><strong>bad_type</strong>. Bad type specified in argument. </li><li><strong>node_not_running</strong>. Node is not running. </li><li><strong>truncated_binary_file</strong>. Truncated binary in file. </li><li><strong>active</strong>. Some delete operations require that all active records are removed. </li><li><strong>illegal</strong>. Operation not supported on this record. </li></ul><p><strong>Error</strong> can be <strong>Reason</strong>,
<strong>{error, Reason}</strong>, or <strong>{aborted, Reason}</strong>.
<strong>Reason</strong> can be an atom or a tuple with <strong>Reason</strong>
as an atom in the first field.</p><p>The following examples illustrate a function that returns an error,
and the method to retrieve more detailed error information:</p><ul><li>The function <a href="#create_table/2">mnesia:create_table(bar, [{attributes, 3.14}])</a> returns the tuple <strong>{aborted,Reason}</strong>, where <strong>Reason</strong> is the tuple <strong>{bad_type,bar,3.14000}</strong>.</li><li>The function <a href="#error_description/1">mnesia:error_description(Reason)</a> returns the term <strong>{"Bad type on some provided arguments",bar,3.14000}</strong>, which is an error description suitable for display.</li></ul><h3>ets(Fun, [, Args]) -&gt; ResultOfFun | exit(Reason)</h3><p>Calls the <strong>Fun</strong> in a raw context that is not protected by a transaction.</p><a name="ets"></a><p>Calls the <strong>Fun</strong> in a raw context that is not protected by
a transaction. The Mnesia function call is performed in
the <strong>Fun</strong> and performed directly on the local ETS
tables on the assumption that the local storage type is
<strong>ram_copies</strong> and the tables are not replicated to other
nodes. Subscriptions are not triggered and checkpoints are
not updated, but it is extremely fast. This function can
also be applied to <strong>disc_copies</strong> tables if all
operations are read only. For details, see
<strong>mnesia:activity/4</strong> and the User's Guide.</p><p>Notice that calling (nesting) a <strong>mnesia:ets</strong> inside a
transaction-context inherits the transaction semantics.</p><h3>first(Tab) -&gt;  Key | transaction abort</h3><p>Returns the key for the first record in a table.</p><a name="first"></a><p>Records in <strong>set</strong> or <strong>bag</strong> tables are not ordered.
However, there is an ordering of the records that is unknown
to the user. A table can therefore be traversed by this
function with the function <strong>mnesia:next/2</strong>.</p><p>If there are no records in the table, this function
returns the atom <strong>'$end_of_table'</strong>. It is therefore
highly undesirable, but not disallowed, to use this atom
as the key for any user records.</p><h3>foldl(Function, Acc, Table) -&gt; NewAcc | transaction abort</h3><p>Calls <strong>Function</strong> for each record in <strong>Table</strong>.</p><a name="foldl"></a><p>Iterates over the table <strong>Table</strong> and calls
<strong>Function(Record, NewAcc)</strong> for each <strong>Record</strong> in
the table. The term returned from <strong>Function</strong> is used
as the second argument in the next call to <strong>Function</strong>.</p><p><strong>foldl</strong> returns the same term as the last call to
<strong>Function</strong> returned.</p><h3>foldr(Function, Acc, Table) -&gt; NewAcc | transaction abort</h3><p>Calls <strong>Function</strong> for each record in <strong>Table</strong>.</p><a name="foldr"></a><p>Works exactly like <strong>foldl/3</strong> but iterates the table
in the opposite order for the <strong>ordered_set</strong> table type.
For all other table types, <strong>foldr/3</strong> and
<strong>foldl/3</strong> are synonyms.</p><h3>force_load_table(Tab) -&gt; yes | ErrorDescription</h3><p>Forces a table to be loaded into the system.</p><a name="force_load_table"></a><p>The Mnesia algorithm for table load can lead to a
situation where a table cannot be loaded. This situation
occurs when a node is started and Mnesia concludes, or
suspects, that another copy of the table was active after
this local copy became inactive because of a system crash.</p><p>If this situation is not acceptable, this function can be
used to override the strategy of the Mnesia table
load algorithm. This can lead to a situation where some
transaction effects are lost with an inconsistent database as
result, but for some applications high availability is more
important than consistent data.</p><h3>index_match_object(Pattern, Pos) -&gt; transaction abort | ObjList</h3><p>Matches records and uses index information.</p><a name="index_match_object_2"></a><p>Starts
<strong>mnesia:index_match_object(Tab, Pattern, Pos, read)</strong>,
where <strong>Tab</strong> is <strong>element(1, Pattern)</strong>.</p><h3>index_match_object(Tab, Pattern, Pos, LockKind) -&gt; transaction abort | ObjList</h3><p>Matches records and uses index information.</p><a name="index_match_object_4"></a><p>In a manner similar to the function <strong>mnesia:index_read/3</strong>,
any index information can be used when trying to match records.
This function takes a pattern that obeys the same rules as the
function <strong>mnesia:match_object/3</strong>, except that this function
requires the following conditions:</p><ul><li> <p>The table <strong>Tab</strong> must have an index on
position <strong>Pos</strong>.</p> </li><li> <p>The element in position <strong>Pos</strong> in
<strong>Pattern</strong> must be bound. <strong>Pos</strong> is
an integer (<strong>#record.Field</strong>) or an attribute name.</p> </li></ul><p>The two index search functions described here are
automatically started when searching tables with <strong>qlc</strong>
list comprehensions and also when using the low-level
<strong>mnesia:[dirty_]match_object</strong> functions.</p><p>The semantics of this function is context-sensitive.
For details, see <strong>mnesia:activity/4</strong>. In
transaction-context, it acquires a lock of type
<strong>LockKind</strong> on the entire table or on a single record.
Currently, the lock type <strong>read</strong> is supported.</p><h3>index_read(Tab, SecondaryKey, Pos) -&gt; transaction abort | RecordList</h3><p>Reads records through index table.</p><a name="index_read"></a><p>Assume that there is an index on position <strong>Pos</strong> for a
certain record type. This function can be used to read the
records without knowing the actual key for the record. For
example, with an index in position 1 of table <strong>person</strong>,
the call <strong>mnesia:index_read(person, 36, #person.age)</strong>
returns a list of all persons with age 36. <strong>Pos</strong> can
also be an attribute name (atom), but if the notation
<strong>mnesia:index_read(person, 36, age)</strong> is used, the
field position is searched for in runtime, for each call.</p><p>The semantics of this function is context-sensitive.
For details, see <strong>mnesia:activity/4</strong>. In
transaction-context, it acquires a read lock on the entire
table.</p><h3>info() -&gt; ok</h3><p>Prints system information on the terminal.</p><a name="info"></a><p>Prints system information on the terminal.
This function can be used even if Mnesia is not
started. However, more information is displayed if
Mnesia is started.</p><h3>install_fallback(Opaque) -&gt; ok | {error,Reason}</h3><p>Installs a backup as fallback.</p><a name="install_fallback_1"></a><p>Calls <strong>mnesia:install_fallback(Opaque, Args)</strong>, where
<strong>Args</strong> is <strong>[{scope, global}]</strong>.</p><h3>install_fallback(Opaque), BackupMod) -&gt; ok | {error,Reason}</h3><p>Installs a backup as fallback.</p><p>Calls <strong>mnesia:install_fallback(Opaque, Args)</strong>, where
<strong>Args</strong> is <strong>[{scope, global}, {module, BackupMod}]</strong>.</p><h3>install_fallback(Opaque, Args) -&gt; ok | {error,Reason}</h3><p>Installs a backup as fallback.</p><p>Installs a backup as fallback. The fallback is used to
restore the database at the next startup. Installation of
fallbacks requires Erlang to be operational on all the
involved nodes, but it does not matter if Mnesia
is running or not. The installation of the fallback fails
if the local node is not one of the disc-resident nodes
in the backup.</p><p><strong>Args</strong> is a list of the following tuples:</p><ul><li> <p><strong>{module, BackupMod}</strong>.
All accesses of the backup media are performed through
a callback module named <strong>BackupMod</strong>. Argument
<strong>Opaque</strong> is forwarded to the callback module,
which can interpret it as it wishes. The default
callback module is called <strong>mnesia_backup</strong> and it
interprets argument <strong>Opaque</strong> as a local
filename. The default for this module is also
configurable through configuration parameter
<strong>-mnesia mnesia_backup</strong>.</p> </li><li> <p><strong>{scope, Scope}</strong>.
The <strong>Scope</strong> of a fallback is either
<strong>global</strong> for the entire database or <strong>local</strong>
for one node. By default, the installation of a fallback
is a global operation, which either is performed on all
nodes with a disc-resident schema or none. Which nodes
that are disc-resident is determined from the
schema information in the backup.</p> <p>If <strong>Scope</strong> of the operation is <strong>local</strong>,
the fallback is only installed on the local node.</p> </li><li> <p><strong>{mnesia_dir, AlternateDir}</strong>.
This argument is only valid if the scope of the
installation is <strong>local</strong>. Normally the installation
of a fallback is targeted to the Mnesia directory,
as configured with configuration parameter
<strong>-mnesia dir</strong>. But by explicitly supplying an
<strong>AlternateDir</strong>, the fallback is installed there
regardless of the Mnesia directory configuration
parameter setting. After installation of a fallback on
an alternative Mnesia directory, that directory
is fully prepared for use as an active Mnesia
directory.</p> <p>This is a dangerous feature that must be
used with care. By unintentional mixing of directories,
you can easily end up with an inconsistent database, if
the same backup is installed on more than one directory.</p> </li></ul><h3>is_transaction() -&gt; boolean</h3><p>Checks if code is running in a transaction.</p><a name="is_transaction"></a><p>When this function is executed inside a transaction-context,
it returns <strong>true</strong>, otherwise <strong>false</strong>.</p><h3>last(Tab) -&gt; Key | transaction abort</h3><p>Returns the key for the last record in a table.</p><p>Works exactly like
<strong>mnesia:first/1</strong>, but returns the last object in
Erlang term order for the <strong>ordered_set</strong> table type.
For all other table types, <strong>mnesia:first/1</strong> and
<strong>mnesia:last/1</strong> are synonyms.</p><h3>load_textfile(Filename)</h3><p>Loads tables from a text file.</p><a name="load_textfile"></a><p>Loads a series of definitions and data found in the
text file (generated with <strong>mnesia:dump_to_textfile/1</strong>)
into Mnesia. This function also starts Mnesia
and possibly creates a new schema. This function is
intended for educational purposes only. It is recommended
to use other functions to deal with real backups.</p><h3>lock(LockItem, LockKind) -&gt; Nodes | ok | transaction abort</h3><p>Explicit grab lock.</p><a name="lock"></a><p>Write locks are normally acquired on all nodes where a
replica of the table resides (and is active). Read locks
are acquired on one node (the local node if a local
replica exists). Most of the context-sensitive access
functions acquire an implicit lock if they are started in a
transaction-context. The granularity of a lock can either
be a single record or an entire table.</p><p>The normal use is to call the function without checking
the return value, as it exits if it fails and the
transaction is restarted by the transaction manager. It
returns all the locked nodes if a write lock is acquired
and <strong>ok</strong> if it was a read lock.</p><p>The function <strong>mnesia:lock/2</strong> is intended to support
explicit locking on tables, but is also intended for
situations when locks need to be acquired regardless of
how tables are replicated. Currently, two kinds of
<strong>LockKind</strong> are supported:</p><dl><dt><strong>write</strong></dt><dd> <p>Write locks are exclusive. This means that if one
transaction manages to acquire a write lock on an item,
no other transaction can acquire any kind of lock on
the same item.</p> </dd><dt><strong>read</strong></dt><dd> <p>Read locks can be shared. This means that if one
transaction manages to acquire a read lock on an item,
other transactions can also acquire a read lock on the
same item. However, if someone has a read lock, no one
can acquire a write lock at the same item. If someone
has a write lock, no one can acquire either a read lock
or a write lock at the same item.</p> </dd></dl><p>Conflicting lock requests are automatically queued if there
is no risk of a deadlock. Otherwise the transaction must be
terminated and executed again. Mnesia does this
automatically as long as the upper limit of the maximum
<strong>retries</strong> is not reached. For details, see
<strong>mnesia:transaction/3</strong>.</p><p>For the sake of completeness, sticky write locks are also
described here even if a sticky write lock is not
supported by this function:</p><dl><dt><strong>sticky_write</strong></dt><dd> <p>Sticky write locks are a mechanism that can be used
to optimize write lock acquisition. If your application
uses replicated tables mainly for fault tolerance (as
opposed to read access optimization purpose), sticky
locks can be the best option available.</p> <p>When a sticky write lock is acquired, all nodes are
informed which node is locked. Then,
sticky lock requests from the same node are
performed as a local operation without any
communication with other nodes. The sticky lock
lingers on the node even after the transaction
ends. For details, see the User's Guide.</p> </dd></dl><p>Currently, this function supports two kinds of
<strong>LockItem</strong>:</p><dl><dt><strong>{table, Tab}</strong></dt><dd> <p>This acquires a lock of type <strong>LockKind</strong> on the
entire table <strong>Tab</strong>.</p> </dd><dt><strong>{global, GlobalKey, Nodes}</strong></dt><dd> <p>This acquires a lock of type <strong>LockKind</strong> on the
global resource <strong>GlobalKey</strong>. The lock is acquired
on all active nodes in the <strong>Nodes</strong> list.</p> </dd></dl><p>Locks are released when the outermost transaction ends.</p><p>The semantics of this function is context-sensitive.
For details, see <strong>mnesia:activity/4</strong>. In
transaction-context, it acquires locks, otherwise it
ignores the request.</p><h3>match_object(Pattern) -&gt; transaction abort | RecList</h3><p>Matches <strong>Pattern</strong> for records.</p><a name="match_object_1"></a><p>Calls <strong>mnesia:match_object(Tab, Pattern, read)</strong>, where
<strong>Tab</strong> is <strong>element(1, Pattern)</strong>.</p><h3>match_object(Tab, Pattern, LockKind) -&gt; transaction abort | RecList</h3><p>Matches <strong>Pattern</strong> for records.</p><a name="match_object_3"></a><p>Takes a pattern with "don't care" variables
denoted as a <strong>'_'</strong> parameter. This function returns
a list of records that matched the pattern.
Since the second element
of a record in a table is considered to be the key for the
record, the performance of this function depends on whether
this key is bound or not.</p><p>For example, the call <strong>mnesia:match_object(person, {person, '_', 36, '_', '_'}, read)</strong> returns a list of
all person records with an <strong>age</strong> field of 36.</p><p>The function <strong>mnesia:match_object/3</strong>
automatically uses indexes if these exist. However, no
heuristics are performed to select the best index.</p><p>The semantics of this function is context-sensitive.
For details, see <strong>mnesia:activity/4</strong>. In
transaction-context, it acquires a lock of type
<strong>LockKind</strong> on the entire table or a single record.
Currently, the lock type <strong>read</strong> is supported.</p><h3>move_table_copy(Tab, From, To) -&gt; {aborted, Reason} | {atomic, ok}</h3><p>Moves the copy of table <strong>Tab</strong> from node <strong>From</strong> to node <strong>To</strong>.</p><a name="move_table_copy"></a><p>Moves the copy of table <strong>Tab</strong> from node
<strong>From</strong> to node <strong>To</strong>.</p><p>The storage type is preserved. For example, a RAM table
moved from one node remains a RAM on the new node. Other
transactions can still read and write in
the table while it is being moved.</p><p>This function cannot be used on <strong>local_content</strong> tables.</p><h3>next(Tab, Key) -&gt; Key | transaction abort</h3><p>Returns the next key in a table.</p><a name="next"></a><p>Traverses a table and
performs operations on all records in the table. When
the end of the table is reached, the special key
<strong>'$end_of_table'</strong> is returned. Otherwise the function
returns a key that can be used to read the actual record.</p><h3>prev(Tab, Key) -&gt; Key | transaction abort</h3><p>Returns the previous key in a table.</p><p>Works exactly like
<strong>mnesia:next/2</strong>, but returns the previous object in
Erlang term order for the <strong>ordered_set</strong> table type.
For all other table types, <strong>mnesia:next/2</strong> and
<strong>mnesia:prev/2</strong> are synonyms.</p><h3>read({Tab, Key}) -&gt; transaction abort | RecordList</h3><p>Reads records(s) with a given key.</p><a name="read_2"></a><p>Calls function <strong>mnesia:read(Tab, Key, read)</strong>.</p><h3>read(Tab, Key) -&gt; transaction abort | RecordList</h3><p>Reads records(s) with a given key.</p><p>Calls function <strong>mnesia:read(Tab, Key, read)</strong>.</p><h3>read(Tab, Key, LockKind) -&gt; transaction abort | RecordList</h3><p>Reads records(s) with a given key.</p><a name="read_3"></a><p>Reads all records from table <strong>Tab</strong> with
key <strong>Key</strong>. This function has the same semantics
regardless of the location of <strong>Tab</strong>. If the table is
of type <strong>bag</strong>, the function
<strong>mnesia:read(Tab, Key)</strong> can
return an arbitrarily long list. If the table is of type
<strong>set</strong>, the list is either of length 1, or <strong>[]</strong>.</p><p>The semantics of this function is context-sensitive.
For details, see <strong>mnesia:activity/4</strong>. In
transaction-context, it acquires a lock of type
<strong>LockKind</strong>. Currently, the lock types <strong>read</strong>,
<strong>write</strong>, and <strong>sticky_write</strong> are supported.</p><p>If the user wants to update the record, it is more
efficient to use <strong>write/sticky_write</strong> as the
<strong>LockKind</strong>. If majority checking is active on the
table, it is checked as soon as a write lock is
attempted. This can be used to end quickly if the
majority condition is not met.</p><h3>read_lock_table(Tab) -&gt; ok | transaction abort</h3><p>Sets a read lock on an entire table.</p><a name="read_lock_table"></a><p>Calls the function
<strong>mnesia:lock({table, Tab}, read)</strong>.</p><h3>report_event(Event) -&gt; ok</h3><p>Reports a user event to the Mnesia event handler.</p><a name="report_event"></a><p>When tracing a system of Mnesia applications it is
useful to be able to interleave Mnesia own events with
application-related events that give information about the
application context.</p><p>Whenever the application begins a
new and demanding Mnesia task, or if it enters a new
interesting phase in its execution, it can be a good idea to
use <strong>mnesia:report_event/1</strong>. <strong>Event</strong> can be
any term and generates a <strong>{mnesia_user, Event}</strong> event
for any processes that subscribe to Mnesia system
events.</p><h3>restore(Opaque, Args) -&gt; {atomic, RestoredTabs} |{aborted, Reason}</h3><p>Online restore of backup.</p><a name="restore"></a><p>With this function, tables can be restored online from a
backup without restarting Mnesia.
<strong>Opaque</strong> is forwarded to the backup module.
<strong>Args</strong> is a list of the following tuples:</p><ul><li> <strong>{module,BackupMod}</strong>. The backup module <strong>BackupMod</strong> is used to access the backup media. If omitted, the default backup module is used. </li><li><strong>{skip_tables, TabList}</strong>, where <strong>TabList</strong> is a list of tables that is not to be read from the backup. </li><li><strong>{clear_tables, TabList}</strong>, where <strong>TabList</strong> is a list of tables that is to be cleared before the records from the backup are inserted. That is, all records in the tables are deleted before the tables are restored. Schema information about the tables is not cleared or read from the backup. </li><li><strong>{keep_tables, TabList}</strong>, where <strong>TabList</strong> is a list of tables that is not to be cleared before the records from the backup are inserted. That is, the records in the backup are added to the records in the table. Schema information about the tables is not cleared or read from the backup. </li><li><strong>{recreate_tables, TabList}</strong>, where <strong>TabList</strong> is a list of tables that is to be recreated before the records from the backup are inserted. The tables are first deleted and then created with the schema information from the backup. All the nodes in the backup need to be operational. </li><li><strong>{default_op, Operation}</strong>, where <strong>Operation</strong> is either of the operations <strong>skip_tables</strong>, <strong>clear_tables</strong>, <strong>keep_tables</strong>, or <strong>recreate_tables</strong>. The default operation specifies which operation that is to be used on tables from the backup that is not specified in any of the mentioned lists. If omitted, operation <strong>clear_tables</strong> is used. </li></ul><p>The affected tables are write-locked during the
restoration. However, regardless of the lock conflicts caused
by this, the applications can continue to do their work while
the restoration is being performed. The restoration is
performed as one single transaction.</p><p>If the database is huge,
it it not always possible to restore it online. In such
cases, restore the old database by installing a
fallback and then restart.</p><h3>s_delete({Tab, Key}) -&gt; ok | transaction abort</h3><p>Sets sticky lock and delete records.</p><a name="s_delete"></a><p>Calls the function
<strong>mnesia:delete(Tab, Key, sticky_write)</strong></p><h3>s_delete_object(Record) -&gt; ok | transaction abort</h3><p>Sets sticky lock and delete record.</p><a name="s_delete_object"></a><p>Calls the function
<strong>mnesia:delete_object(Tab, Record, sticky_write)</strong>,
where <strong>Tab</strong> is <strong>element(1, Record)</strong>.</p><h3>s_write(Record) -&gt; ok | transaction abort</h3><p>Writes <strong>Record</strong> and sets sticky lock.</p><a name="s_write"></a><p>Calls the function
<strong>mnesia:write(Tab, Record, sticky_write)</strong>,
where <strong>Tab</strong> is <strong>element(1, Record)</strong>.</p><h3>schema() -&gt; ok</h3><p>Prints information about all table definitions on the terminal.</p><p>Prints information about all table definitions on the terminal.</p><h3>schema(Tab) -&gt; ok</h3><p>Prints information about one table definition on the terminal.</p><p>Prints information about one table definition on the terminal.</p><h3>select(Tab, MatchSpec [, Lock]) -&gt; transaction abort | [Object]</h3><p>Matches the objects in <strong>Tab</strong> against <strong>MatchSpec</strong>.</p><a name="select_2_3"></a><p>Matches the objects in table <strong>Tab</strong> using a
<strong>match_spec</strong> as described in the
<a href="../stdlib/ets#select/3">ets:select/3</a>.
Optionally a lock
<strong>read</strong> or <strong>write</strong> can be given as the third
argument. Default is <strong>read</strong>. The return value depends
on <strong>MatchSpec</strong>.</p><p>Notice that for best performance, <strong>select</strong> is to be
used before any modifying operations are done on that table
in the same transaction. That is, do not use <strong>write</strong>
or <strong>delete</strong> before a <strong>select</strong>.</p><p>In its simplest forms, the <strong>match_spec</strong> look as
follows:</p><ul><li><strong>MatchSpec = [MatchFunction]</strong></li><li><strong>MatchFunction = {MatchHead, [Guard], [Result]}</strong></li><li><strong>MatchHead = tuple() | record()</strong></li><li><strong>Guard =  {"Guardtest name", ...}</strong></li><li><strong>Result = "Term construct"</strong></li></ul><p>For a complete description of <strong>select</strong>, see the
<a href="./index">ERTS</a> User's Guide and the
<a href="./ets">ets</a> manual page in
STDLIB.</p><p>For example, to find the names of all male persons older
than 30 in table <strong>Tab</strong>:</p><pre><code class="">
MatchHead = #person{name='$1', sex=male, age='$2', _='_'},
Guard = {'&gt;', '$2', 30},
Result = '$1',
mnesia:select(Tab,[{MatchHead, [Guard], [Result]}]),</code></pre><h3>select(Tab, MatchSpec, NObjects, Lock) -&gt; transaction abort | {[Object],Cont} | '$end_of_table'</h3><p>Matches the objects in <strong>Tab</strong> against <strong>MatchSpec</strong>.</p><a name="select_4"></a><p>Matches the objects in table <strong>Tab</strong> using a
<strong>match_spec</strong> as described in the
<a href="./index">ERTS</a> User's Guide,
and returns a chunk of terms and a continuation.
The wanted number of returned terms is specified by
argument <strong>NObjects</strong>. The lock argument can be
<strong>read</strong> or <strong>write</strong>. The continuation is to be
used as argument to <strong>mnesia:select/1</strong>,
if more or all answers are needed.</p><p>Notice that for best performance, <strong>select</strong> is to be
used before any modifying operations are done on that table
in the same transaction. That is, do not use
<strong>mnesia:write</strong> or <strong>mnesia:delete</strong> before a
<strong>mnesia:select</strong>. For efficiency, <strong>NObjects</strong> is
a recommendation only and the result can contain anything
from an empty list to all available results.</p><h3>select(Cont) -&gt; transaction abort | {[Object],Cont} | '$end_of_table'</h3><p>Continues selecting objects.</p><p>Selects more objects with the match specification initiated
by <strong>mnesia:select/4</strong>.</p><p>Notice that any modifying operations, that is,
<strong>mnesia:write</strong> or <strong>mnesia:delete</strong>, that are done
between the <strong>mnesia:select/4</strong> and <strong>mnesia:select/1</strong>
calls are not visible in the result.</p><h3>set_debug_level(Level) -&gt; OldLevel</h3><p>Changes the internal debug level of Mnesia.</p><a name="set_debug_level"></a><p>Changes the internal debug level of Mnesia.
For details, see
<a href="#configuration_parameters">Section Configuration Parameters</a>.</p><h3>set_master_nodes(MasterNodes) -&gt; ok | {error, Reason}</h3><p>Sets the master nodes for all tables.</p><a name="set_master_nodes_1"></a><p>For each table Mnesia determines its replica nodes
(<strong>TabNodes</strong>) and starts
<strong>mnesia:set_master_nodes(Tab, TabMasterNodes)</strong>. where
<strong>TabMasterNodes</strong> is the intersection of
<strong>MasterNodes</strong> and <strong>TabNodes</strong>. For semantics, see
<strong>mnesia:set_master_nodes/2</strong>.</p><h3>set_master_nodes(Tab, MasterNodes) -&gt; ok | {error, Reason}</h3><p>Sets the master nodes for a table.</p><a name="set_master_nodes_2"></a><p>If the application detects a
communication failure (in a potentially partitioned network)
that can have caused an inconsistent database, it can use the
function <strong>mnesia:set_master_nodes(Tab, MasterNodes)</strong> to
define from which nodes each table is to be loaded.
At startup, the Mnesia normal table load algorithm is
bypassed and the table is loaded from one of the master nodes
defined for the table, regardless of when and if Mnesia
terminated on other nodes. <strong>MasterNodes</strong> can only
contain nodes where the table has a replica. If the
<strong>MasterNodes</strong> list is empty, the master node recovery
mechanism for the particular table is reset, and the
normal load mechanism is used at the next restart.</p><p>The master node setting is always local. It can be
changed regardless if Mnesia is started or not.</p><p>The database can also become inconsistent if
configuration parameter <strong>max_wait_for_decision</strong> is used
or if <strong>mnesia:force_load_table/1</strong> is used.</p><h3>snmp_close_table(Tab) -&gt; {aborted, R} | {atomic, ok}</h3><p>Removes the possibility for SNMP to manipulate the table.</p><p>Removes the possibility for SNMP to manipulate the table.</p><h3>snmp_get_mnesia_key(Tab, RowIndex) -&gt; {ok, Key} | undefined</h3><p>Gets the corresponding Mnesia key from an SNMP index.</p><ul><li><span class="v">Tab ::= atom()</span></li><li><span class="v">RowIndex ::= [integer()]</span></li><li><span class="v">Key ::= key() | {key(), key(), ...}</span></li><li><span class="v">key() ::= integer() | string() | [integer()]</span></li></ul><p>Transforms an SNMP index to the corresponding Mnesia
key. If the SNMP table has multiple keys, the key is a tuple
of the key columns.</p><h3>snmp_get_next_index(Tab, RowIndex) -&gt; {ok, NextIndex} | endOfTable</h3><p>Gets the index of the next lexicographical row.</p><ul><li><span class="v">Tab ::= atom()</span></li><li><span class="v">RowIndex ::= [integer()]</span></li><li><span class="v">NextIndex ::= [integer()]</span></li></ul><p><strong>RowIndex</strong> can specify a non-existing row.
Specifically, it can be the empty list. Returns the index
of the next lexicographical row. If <strong>RowIndex</strong> is the
empty list, this function returns the index of the first row
in the table.</p><h3>snmp_get_row(Tab, RowIndex) -&gt; {ok, Row} | undefined</h3><p>Retrieves a row indexed by an SNMP index.</p><ul><li><span class="v">Tab ::= atom()</span></li><li><span class="v">RowIndex ::= [integer()]</span></li><li><span class="v">Row ::= record(Tab)</span></li></ul><p>Reads a row by its SNMP index. This index is specified as
an SNMP Object Identifier, a list of integers.</p><h3>snmp_open_table(Tab, SnmpStruct) -&gt; {aborted, R} | {atomic, ok}</h3><p>Organizes a Mnesia table as an SNMP table.</p><ul><li><span class="v">Tab ::= atom()</span></li><li><span class="v">SnmpStruct ::= [{key, type()}]</span></li><li><span class="v">type() ::= type_spec() | {type_spec(), type_spec(), ...}</span></li><li><span class="v">type_spec() ::= fix_string | string | integer</span></li></ul><p>A direct one-to-one mapping can be established between
Mnesia tables and SNMP tables. Many telecommunication
applications are controlled and monitored by the SNMP
protocol. This connection between Mnesia and SNMP
makes it simple and convenient to achieve this mapping.</p><p>Argument <strong>SnmpStruct</strong> is a list of SNMP
information. Currently, the only information needed is
information about the key types in the table. Multiple
keys cannot be handled in Mnesia, but many SNMP
tables have multiple keys. Therefore, the following
convention is used: if a table has multiple keys, these must
always be stored as a tuple of the keys. Information about
the key types is specified as a tuple of atoms describing
the types. The only significant type is <strong>fix_string</strong>.
This means that a string has a fixed size.</p><p>For example, the following causes table <strong>person</strong>
to be ordered as an SNMP table:</p><pre><code class="">
mnesia:snmp_open_table(person, [{key, string}])</code></pre><p>Consider the following schema for a table of company
employees. Each employee is identified by department number
and name. The other table column stores the telephone
number:</p><pre><code class="">
mnesia:create_table(employee,
    [{snmp, [{key, {integer, string}}]},
     {attributes, record_info(fields, employees)}]),</code></pre><p>The corresponding SNMP table would have three columns:
<strong>department</strong>, <strong>name</strong>, and <strong>telno</strong>.</p><p>An option is to have table columns that are not visible
through the SNMP protocol. These columns must be the last
columns of the table. In the previous example, the SNMP
table could have columns <strong>department</strong> and <strong>name</strong>
only. The application could then use column <strong>telno</strong>
internally, but it would not be visible to the SNMP
managers.</p><p>In a table monitored by SNMP, all elements must be
integers, strings, or lists of integers.</p><p>When a table is SNMP ordered, modifications are more
expensive than usual, O(logN). Also, more memory is used.</p><p>Notice that only the lexicographical SNMP ordering is
implemented in Mnesia, not the actual SNMP monitoring.</p><h3>start() -&gt; ok | {error, Reason}</h3><p>Starts a local Mnesia system.</p><a name="start"></a><p>Mnesia startup is asynchronous. The function call
<strong>mnesia:start()</strong> returns the atom <strong>ok</strong> and then
starts to initialize the different tables. Depending on the
size of the database, this can take some time, and the
application programmer must wait for the tables that the
application needs before they can be used. This is achieved
by using the function <strong>mnesia:wait_for_tables/2</strong>.</p><p>The startup procedure for a set of Mnesia nodes is a
fairly complicated operation. A Mnesia system consists
of a set of nodes, with Mnesia started locally on all
participating nodes. Normally, each node has a directory where
all the Mnesia files are written. This directory is
referred to as the Mnesia directory. Mnesia can
also be started on disc-less nodes. For more information
about disc-less nodes, see <strong>mnesia:create_schema/1</strong>
and the User's Guide.</p><p>The set of nodes that makes up a Mnesia system is kept
in a schema. Mnesia nodes can be added to or removed
from the schema. The initial schema is normally created on
disc with the function <strong>mnesia:create_schema/1</strong>. On
disc-less nodes, a tiny default schema is generated each time
Mnesia is started. During the startup procedure,
Mnesia exchanges schema information between the nodes
to verify that the table definitions are compatible.</p><p>Each schema has a unique cookie, which can be regarded as a
unique schema identifier. The cookie must be the same on all
nodes where Mnesia is supposed to run. For details,
see the User's Guide.</p><p>The schema file and all other files that Mnesia
needs are kept in the Mnesia directory. The
command-line option <strong>-mnesia dir Dir</strong> can be used to
specify the location of this directory to the Mnesia
system. If no such command-line option is found, the name
of the directory defaults to <strong>Mnesia.Node</strong>.</p><p><strong>application:start(mnesia)</strong> can also be used.</p><h3>stop() -&gt; stopped</h3><p>Stops Mnesia locally.</p><a name="stop"></a><p>Stops Mnesia locally on the current node.</p><p><strong>application:stop(mnesia)</strong> can also be used.</p><h3>subscribe(EventCategory) -&gt; {ok, Node} | {error, Reason}</h3><p>Subscribes to events of type <strong>EventCategory</strong>.</p><a name="subscribe"></a><p>Ensures that a copy of all events of type
<strong>EventCategory</strong> is sent to the caller. The available
event types are described in the <a href="./Mnesia_chap5#event_handling">User's Guide</a>.</p><h3>sync_dirty(Fun, [, Args]) -&gt; ResultOfFun | exit(Reason)</h3><p>Calls the <strong>Fun</strong> in a context that is not protected by a transaction.</p><a name="sync_dirty"></a><p>Calls the <strong>Fun</strong> in a context that is not protected by
a transaction. The Mnesia function calls performed in
the <strong>Fun</strong> are mapped to the corresponding dirty functions.
It is performed in almost the same context as
<strong>mnesia:async_dirty/1,2</strong>. The difference is that the
operations are performed synchronously. The caller waits for
the updates to be performed on all active replicas before
the <strong>Fun</strong> returns. For details, see
<strong>mnesia:activity/4</strong> and the User's Guide.</p><h3>sync_log() -&gt; ok | {error, Reason}</h3><p>Performs a file sync of the local log file.</p><p>Ensures that the local transaction log file is synced to disk.
On a single node system, data written to disk tables since the
last dump can be lost if there is a power outage.
See <a href="#dump_log/0">dump_log/0</a>.</p><h3>sync_transaction(Fun, [[, Args], Retries]) -&gt; {aborted, Reason} | {atomic, ResultOfFun}</h3><p>Synchronously executes a transaction.</p><a name="sync_transaction"></a><p>Waits until data have been committed and
logged to disk (if disk is used) on every involved node before
it returns, otherwise it behaves as
<strong>mnesia:transaction/[1,2,3]</strong>.</p><p>This functionality can be used to avoid that one process
overloads a database on another node.</p><h3>system_info(InfoKey) -&gt; Info | exit({aborted, Reason})</h3><p>Returns information about the Mnesia system.</p><a name="system_info"></a><p>Returns information about the Mnesia system, such as
transaction statistics, <strong>db_nodes</strong>, and configuration
parameters. The valid keys are as follows:</p><ul><li> <p><strong>all</strong>. Returns a list of all local system
information. Each element is a <strong>{InfoKey, InfoVal}</strong>
tuple.</p> <p>New <strong>InfoKey</strong>s can be added and old
undocumented <strong>InfoKey</strong>s can be removed without
notice.</p> </li><li> <p><strong>access_module</strong>. Returns the name of module that is
configured to be the activity access callback module.</p> </li><li> <p><strong>auto_repair</strong>. Returns <strong>true</strong> or <strong>false</strong>
to indicate if Mnesia is configured to start the
auto-repair facility on corrupted disc files.</p> </li><li> <p><strong>backup_module</strong>. Returns the name of the module
that is configured to be the backup callback module.</p> </li><li> <p><strong>checkpoints</strong>. Returns a list of the names of the
checkpoints currently active on this node.</p> </li><li> <p><strong>event_module</strong>. Returns the name of the module
that is the event handler callback module.</p> </li><li> <p><strong>db_nodes</strong>. Returns the nodes that make up the
persistent database. Disc-less nodes are only included
in the list of nodes if they explicitly have been added
to the schema, for example, with
<strong>mnesia:add_table_copy/3</strong>. The function can be
started even if Mnesia is not yet running.</p> </li><li> <p><strong>debug</strong>. Returns the current debug level of
Mnesia.</p> </li><li> <p><strong>directory</strong>. Returns the name of the Mnesia
directory. It can be called even if Mnesia is
not yet running.</p> </li><li> <p><strong>dump_log_load_regulation</strong>. Returns a boolean that
tells if Mnesia is configured to regulate the
dumper process load.</p> <p>This feature is temporary and will be removed in future
releases.</p> </li><li> <p><strong>dump_log_time_threshold</strong>. Returns the time
threshold for transaction log dumps in milliseconds.</p> </li><li> <p><strong>dump_log_update_in_place</strong>. Returns a boolean that
tells if Mnesia is configured to perform the
updates in the Dets files directly, or if the
updates are to be performed in a copy of the Dets
files.</p> </li><li> <p><strong>dump_log_write_threshold</strong>.
Returns the write threshold for transaction log dumps as
the number of writes to the transaction log.</p> </li><li> <p><strong>extra_db_nodes</strong>. Returns a list
of extra <strong>db_nodes</strong> to be contacted at startup.</p> </li><li> <p><strong>fallback_activated</strong>. Returns <strong>true</strong>
if a fallback is activated, otherwise <strong>false</strong>.</p> </li><li> <p><strong>held_locks</strong>. Returns a list of all
locks held by the local Mnesia lock manager.</p> </li><li> <p><strong>is_running</strong>. Returns <strong>yes</strong> or <strong>no</strong> to
indicate if Mnesia is running. It can
also return <strong>starting</strong> or <strong>stopping</strong>. Can be
called even if Mnesia is not yet running.</p> </li><li> <p><strong>local_tables</strong>. Returns a list
of all tables that are configured to reside locally.</p> </li><li> <p><strong>lock_queue</strong>. Returns a list of
all transactions that are queued for execution by the
local lock manager.</p> </li><li> <p><strong>log_version</strong>. Returns the version
number of the Mnesia transaction log format.</p> </li><li> <p><strong>master_node_tables</strong>. Returns a
list of all tables with at least one master node.</p> </li><li> <p><strong>protocol_version</strong>. Returns the version number of
the Mnesia inter-process communication protocol.</p> </li><li> <p><strong>running_db_nodes</strong>. Returns a list of nodes where
Mnesia currently is running. This function can be
called even if Mnesia is not yet running, but it
then has slightly different semantics.</p> <p>If Mnesia is down on the local node, the function
returns those other <strong>db_nodes</strong> and
<strong>extra_db_nodes</strong> that for the moment are
operational.</p> <p>If Mnesia is started, the function returns
those nodes that Mnesia on the local node is fully
connected to. Only those nodes that Mnesia has
exchanged schema information with are included as
<strong>running_db_nodes</strong>. After the merge of schemas, the
local Mnesia system is fully operable and
applications can perform access of remote replicas.
Before the schema merge, Mnesia only operates
locally. Sometimes there are more nodes included in the
<strong>running_db_nodes</strong> list than all <strong>db_nodes</strong>
and <strong>extra_db_nodes</strong> together.</p> </li><li> <p><strong>schema_location</strong>. Returns the
initial schema location.</p> </li><li> <p><strong>subscribers</strong>. Returns a list of
local processes currently subscribing to system events.</p> </li><li> <p><strong>tables</strong>. Returns a list of all
locally known tables.</p> </li><li> <p><strong>transactions</strong>. Returns a list
of all currently active local transactions.</p> </li><li> <p><strong>transaction_failures</strong>. Returns a
number that indicates how many transactions have
failed since Mnesia was started.</p> </li><li> <p><strong>transaction_commits</strong>. Returns a
number that indicates how many transactions have
terminated successfully since Mnesia was started.</p> </li><li> <p><strong>transaction_restarts</strong>. Returns a
number that indicates how many transactions have been
restarted since Mnesia was started.</p> </li><li> <p><strong>transaction_log_writes</strong>.
Returns a number that indicates how many write
operations that have been performed to the transaction
log since startup.</p> </li><li> <p><strong>use_dir</strong>. Returns a boolean that indicates if
the Mnesia directory is used or not. Can be
started even if Mnesia is not yet running.</p> </li><li> <p><strong>version</strong>. Returns the current
version number of Mnesia.</p> </li></ul><h3>table(Tab [,[Option]]) -&gt; QueryHandle</h3><p>Return a QLC query handle.</p><a name="table"></a><p>Returns a Query List Comprehension (QLC) query handle,
see the <a href="./qlc">qlc(3)</a>
manual page in STDLIB. The module <strong>qlc</strong>
implements a query language that can use Mnesia
tables as sources of data. Calling
<strong>mnesia:table/1,2</strong> is the means to make the
<strong>mnesia</strong> table <strong>Tab</strong> usable to QLC.</p><p><strong>Option</strong> can contain Mnesia
options or QLC options. Mnesia recognizes the
following options (any other option is forwarded to
QLC).</p><ul><li><strong>{lock, Lock}</strong>, where <strong>lock</strong> can be <strong>read</strong> or <strong>write</strong>. Default is <strong>read</strong>. </li><li><strong>{n_objects,Number}</strong>, where <strong>n_objects</strong> specifies (roughly) the number of objects returned from Mnesia to QLC. Queries to remote tables can need a larger chunk to reduce network overhead. By default, <strong>100</strong> objects at a time are returned. </li><li><strong>{traverse, SelectMethod}</strong>, where <strong>traverse</strong> determines the method to traverse the whole table (if needed). The default method is <strong>select</strong>. </li></ul><p>There are two alternatives for <strong>select</strong>:</p><ul><li> <p><strong>select</strong>. The table is traversed by calling
<strong>mnesia:select/4</strong> and <strong>mnesia:select/1</strong>.
The match specification (the second argument of
<strong>select/3</strong>) is assembled by QLC: simple filters
are translated into equivalent match specifications.
More complicated filters need to be applied to all
objects returned by <strong>select/3</strong> given a match
specification that matches all objects.</p> </li><li> <p><strong>{select, MatchSpec}</strong>. As for <strong>select</strong>,
the table is traversed by calling <strong>mnesia:select/3</strong>
and <strong>mnesia:select/1</strong>. The difference is that the
match specification is explicitly given. This is how to
state match specifications that cannot easily be
expressed within the syntax provided by QLC.</p> </li></ul><h3>table_info(Tab, InfoKey) -&gt; Info | exit({aborted, Reason})</h3><p>Returns local information about table.</p><a name="table_info"></a><p>The <strong>table_info/2</strong> function takes two arguments.
The first is the name of a Mnesia table.
The second is one of the following keys:</p><ul><li> <p><strong>all</strong>. Returns a list of all local table
information. Each element is a
<strong>{InfoKey, ItemVal}</strong> tuple.</p> <p>New <strong>InfoItem</strong>s can be added and old undocumented
<strong>InfoItem</strong>s can be removed without notice.</p> </li><li> <p><strong>access_mode</strong>. Returns the
access mode of the table. The access mode can be
<strong>read_only</strong> or <strong>read_write</strong>.</p> </li><li> <p><strong>arity</strong>. Returns the arity of
records in the table as specified in the schema.</p> </li><li> <p><strong>attributes</strong>. Returns the table
attribute names that are specified in the schema.</p> </li><li> <p><strong>checkpoints</strong>. Returns the names
of the currently active checkpoints, which involve this
table on this node.</p> </li><li> <p><strong>cookie</strong>. Returns a table cookie,
which is a unique system-generated identifier for the
table. The cookie is used internally to ensure that two
different table definitions using the same table name
cannot accidentally be intermixed. The cookie is
generated when the table is created initially.</p> </li><li> <p><strong>disc_copies</strong>. Returns the nodes where a
<strong>disc_copy</strong> of the table resides according to the
schema.</p> </li><li> <p><strong>disc_only_copies</strong>. Returns the nodes where a
<strong>disc_only_copy</strong> of the table resides
according to the schema.</p> </li><li> <p><strong>index</strong>. Returns the list of
index position integers for the table.</p> </li><li> <p><strong>load_node</strong>. Returns the name of
the node that Mnesia loaded the table from. The
structure of the returned value is unspecified, but
can be useful for debugging purposes.</p> </li><li> <p><strong>load_order</strong>. Returns the load
order priority of the table. It is an integer and
defaults to <strong>0</strong> (zero).</p> </li><li> <p><strong>load_reason</strong>. Returns the
reason of why Mnesia decided to load the table.
The structure of the returned value is unspecified, but
can be useful for debugging purposes.</p> </li><li> <p><strong>local_content</strong>. Returns <strong>true</strong> or
<strong>false</strong> to indicate if the table is configured to
have locally unique content on each node.</p> </li><li> <p><strong>master_nodes</strong>. Returns the master nodes of a
table.</p> </li><li> <p><strong>memory</strong>. Returns the number of
words allocated to the table on this node.</p> </li><li> <p><strong>ram_copies</strong>. Returns the nodes where a
<strong>ram_copy</strong> of the table resides according to the
schema.</p> </li><li> <p><strong>record_name</strong>. Returns the
record name, common for all records in the table.</p> </li><li> <p><strong>size</strong>. Returns the number of
records inserted in the table.</p> </li><li> <p><strong>snmp</strong>. Returns the SNMP struct. <strong>[]</strong> means
that the table currently has no SNMP properties.</p> </li><li> <p><strong>storage_type</strong>. Returns the local
storage type of the table. It can be <strong>disc_copies</strong>,
<strong>ram_copies</strong>, <strong>disc_only_copies</strong>, or the atom
<strong>unknown</strong>. <strong>unknown</strong> is returned for all
tables that only reside remotely.</p> </li><li> <p><strong>subscribers</strong>. Returns a list
of local processes currently subscribing to local table
events that involve this table on this node.</p> </li><li> <p><strong>type</strong>. Returns the table type, which is
<strong>bag</strong>, <strong>set</strong>, or <strong>ordered_set</strong>.</p> </li><li> <p><strong>user_properties</strong>. Returns the
user-associated table properties of the table. It is a
list of the stored property records.</p> </li><li> <p><strong>version</strong>. Returns the current
version of the table definition. The table version is
incremented when the table definition is changed. The
table definition can be incremented directly when it
has been changed in a schema transaction, or
when a committed table definition is merged with
table definitions from other nodes during startup.</p> </li><li> <p><strong>where_to_read</strong>. Returns the node
where the table can be read. If value <strong>nowhere</strong>
is returned, either the table is not loaded or it
resides at a remote node that is not running.</p> </li><li> <p><strong>where_to_write</strong>. Returns a list of the nodes
that currently hold an active replica of the table.</p> </li><li> <p><strong>wild_pattern</strong>. Returns a
structure that can be given to the various match
functions for a certain table. A record tuple is where
all record fields have value <strong>'_'</strong>.</p> </li></ul><h3>transaction(Fun [[, Args], Retries]) -&gt; {aborted, Reason} | {atomic, ResultOfFun}</h3><p>Executes a transaction.</p><a name="transaction"></a><p>Executes the functional object <strong>Fun</strong>
with arguments <strong>Args</strong> as a transaction.</p><p>The code that executes inside the transaction
can consist of a series of table manipulation functions.
If something goes wrong inside the transaction as a result
of a user error or a certain table not being available, the
entire transaction is terminated and the function
<strong>transaction/1</strong> returns the tuple
<strong>{aborted, Reason}</strong>.</p><p>If all is going well, <strong>{atomic, ResultOfFun}</strong> is
returned, where <strong>ResultOfFun</strong> is the value of the
last expression in <strong>Fun</strong>.</p><p>A function that adds a family to the database can be
written as follows if there is a structure
<strong>{family, Father, Mother, ChildrenList}</strong>:</p><pre><code class="">
add_family({family, F, M, Children}) -&gt;
    ChildOids = lists:map(fun oid/1, Children),
    Trans = fun() -&gt;      
        mnesia:write(F#person{children = ChildOids}, 
        mnesia:write(M#person{children = ChildOids},
        Write = fun(Child) -&gt; mnesia:write(Child) end,
        lists:foreach(Write, Children)
    end,
    mnesia:transaction(Trans).

oid(Rec) -&gt; {element(1, Rec), element(2, Rec)}.</code></pre><p>This code adds a set of people to the database. Running
this code within one transaction ensures that either the whole
family is added to the database, or the whole transaction
terminates. For example, if the last child is badly formatted,
or the executing process terminates because of an
<strong>'EXIT'</strong> signal while executing the family code, the
transaction terminates. Thus, the situation where half a
family is added can never occur.</p><p>It is also useful to update the database within a transaction
if several processes concurrently update the same records.
For example, the function <strong>raise(Name, Amount)</strong>, which
adds <strong>Amount</strong> to the salary field of a person, is to
be implemented as follows:</p><pre><code class="">
raise(Name, Amount) -&gt;
    mnesia:transaction(fun() -&gt;
        case mnesia:wread({person, Name}) of
            [P] -&gt;
                Salary = Amount + P#person.salary,
                P2 = P#person{salary = Salary},
                mnesia:write(P2);
            _ -&gt;
                mnesia:abort("No such person")
        end
    end).</code></pre><p>When this function executes within a transaction,
several processes running on different nodes can concurrently
execute the function <strong>raise/2</strong> without interfering
with each other.</p><p>Since Mnesia detects deadlocks, a transaction can be
restarted any number of times. This function attempts a
restart as specified in <strong>Retries</strong>. <strong>Retries</strong> must
be an integer greater than 0 or the atom <strong>infinity</strong>.
Default is <strong>infinity</strong>.</p><h3>transform_table(Tab, Fun, NewAttributeList, NewRecordName) -&gt; {aborted, R} | {atomic, ok}</h3><p>Changes format on all records in table <strong>Tab</strong>.</p><a name="transform_table_4"></a><p>Applies argument <strong>Fun</strong> to all
records in the table. <strong>Fun</strong> is a function that takes a
record of the old type and returns a transformed record of
the new type. Argument <strong>Fun</strong> can also be the atom
<strong>ignore</strong>, which indicates that only the metadata
about the table is updated. Use of
<strong>ignore</strong> is not recommended, but included
as a possibility for the user do to an own transformation.</p><p><strong>NewAttributeList</strong> and <strong>NewRecordName</strong>
specify the attributes and the new record type of the
converted table. Table name always remains unchanged. If
<strong>record_name</strong> is changed, only the Mnesia
functions that use table identifiers work, for example,
<strong>mnesia:write/3</strong> works, but not <strong>mnesia:write/1</strong>.</p><h3>transform_table(Tab, Fun, NewAttributeList) -&gt; {aborted, R} | {atomic, ok}</h3><p>Changes format on all records in table <strong>Tab</strong>.</p><p>Calls <strong>mnesia:transform_table(Tab, Fun, NewAttributeList, RecName)</strong>, where <strong>RecName</strong> is
<strong>mnesia:table_info(Tab, record_name)</strong>.</p><h3>traverse_backup(Source, [SourceMod,] Target, [TargetMod,] Fun, Acc) -&gt; {ok, LastAcc} | {error, Reason}</h3><p>Traversal of a backup.</p><a name="traverse_backup"></a><p>Iterates over a backup, either to transform it into a
new backup, or read it. The arguments are explained briefly
here. For details, see the User's Guide.</p><ul><li><strong>SourceMod</strong> and <strong>TargetMod</strong> are the names of the modules that actually access the backup media. </li><li><strong>Source</strong> and <strong>Target</strong> are opaque data used exclusively by modules <strong>SourceMod</strong> and <strong>TargetMod</strong> to initialize the backup media. </li><li><strong>Acc</strong> is an initial accumulator value. </li><li><strong>Fun(BackupItems, Acc)</strong> is applied to each item in the backup. The <strong>Fun</strong> must return a tuple <strong>{BackupItems,NewAcc}</strong>, where <strong>BackupItems</strong> is a list of valid backup items, and <strong>NewAcc</strong> is a new accumulator value. The returned backup items are written in the target backup.  </li><li><strong>LastAcc</strong> is the last accumulator value. This is the last <strong>NewAcc</strong> value that was returned by <strong>Fun</strong>. </li></ul><h3>uninstall_fallback() -&gt; ok | {error,Reason}</h3><p>Uninstalls a fallback.</p><a name="uninstall_fallback_0"></a><p>Calls the function
<strong>mnesia:uninstall_fallback([{scope, global}])</strong>.</p><h3>uninstall_fallback(Args) -&gt; ok | {error,Reason}</h3><p>Uninstalls a fallback.</p><p>Deinstalls a fallback before it
has been used to restore the database. This is normally a
distributed operation that is either performed on all
nodes with disc resident schema, or none. Uninstallation of
fallbacks requires Erlang to be operational on all
involved nodes, but it does not matter if Mnesia is
running or not. Which nodes that are considered as
disc-resident nodes is determined from the schema
information in the local fallback.</p><p><strong>Args</strong> is a list of the following tuples:</p><ul><li><strong>{module, BackupMod}</strong>. For semantics, see <strong>mnesia:install_fallback/2</strong>. </li><li><strong>{scope, Scope}</strong>. For semantics, see <strong>mnesia:install_fallback/2</strong>. </li><li><strong>{mnesia_dir, AlternateDir}</strong>. For semantics, see <strong>mnesia:install_fallback/2</strong>. </li></ul><h3>unsubscribe(EventCategory) -&gt; {ok, Node} | {error, Reason}</h3><p>Subscribes to events of type <strong>EventCategory</strong>.</p><a name="unsubscribe"></a><p>Stops sending events of type
<strong>EventCategory</strong> to the caller.</p><p><strong>Node</strong> is the local node.</p><h3>wait_for_tables(TabList, Timeout) -&gt; ok | {timeout, BadTabList} | {error, Reason}</h3><p>Waits for tables to be accessible.</p><a name="wait_for_tables"></a><p>Some applications need to wait for certain tables to be
accessible to do useful work. <strong>mnesia:wait_for_tables/2</strong>
either hangs until all tables in <strong>TabList</strong> are accessible,
or until <strong>timeout</strong> is reached.</p><h3>wread({Tab, Key}) -&gt; transaction abort | RecordList</h3><p>Reads records with given key.</p><a name="wread"></a><p>Calls the function <strong>mnesia:read(Tab, Key, write)</strong>.</p><h3>write(Record) -&gt; transaction abort | ok</h3><p>Writes a record into the database.</p><a name="write_1"></a><p>Calls the function <strong>mnesia:write(Tab, Record, write)</strong>,
where <strong>Tab</strong> is <strong>element(1, Record)</strong>.</p><h3>write(Tab, Record, LockKind) -&gt; transaction abort | ok</h3><p>Writes a record into the database.</p><a name="write_3"></a><p>Writes record <strong>Record</strong> to table <strong>Tab</strong>.</p><p>The function returns <strong>ok</strong>, or terminates if an error
occurs. For example, the transaction terminates if no
<strong>person</strong> table exists.</p><p>The semantics of this function is context-sensitive. For
details, see <strong>mnesia:activity/4</strong>. In
transaction-context, it acquires a lock of type
<strong>LockKind</strong>. The lock types <strong>write</strong> and
<strong>sticky_write</strong> are supported.</p><h3>write_lock_table(Tab) -&gt; ok | transaction abort</h3><p>Sets write lock on an entire table.</p><a name="write_lock_table"></a><p>Calls the function
<strong>mnesia:lock({table, Tab}, write)</strong>.</p><h3>Configuration Parameters</h3><a name="configuration_parameters"></a><p>Mnesia reads the following application configuration
parameters:</p><ul><li> <p><strong>-mnesia access_module Module</strong>. The name of the
Mnesia activity access callback module. Default is
<strong>mnesia</strong>.</p> </li><li> <p><strong>-mnesia auto_repair true | false</strong>. This flag
controls if Mnesia automatically tries to repair
files that have not been properly closed. Default is
<strong>true</strong>.</p> </li><li> <p><strong>-mnesia backup_module Module</strong>. The name of the
Mnesia backup callback module. Default is
<strong>mnesia_backup</strong>.</p> </li><li> <p><strong>-mnesia debug Level</strong>. Controls the debug level
of Mnesia. The possible values are as follows:</p> <dl><dt><strong>none</strong></dt><dd> <p>No trace outputs. This is the default.</p> </dd><dt><strong>verbose</strong></dt><dd> <p>Activates tracing of important debug events. These
events generate <strong>{mnesia_info, Format, Args}</strong>
system events. Processes can subscribe to these events with
<strong>mnesia:subscribe/1</strong>. The events are always sent to
the Mnesia event handler.</p> </dd><dt><strong>debug</strong></dt><dd> <p>Activates all events at the verbose level plus full
trace of all debug events. These debug events generate
<strong>{mnesia_info, Format, Args}</strong> system events.
Processes can subscribe to these events with
<strong>mnesia:subscribe/1</strong>. The events are always sent to
the Mnesia event handler. On this debug level,
the Mnesia event handler starts subscribing to
updates in the schema table.</p> </dd><dt><strong>trace</strong></dt><dd> <p>Activates all events at the debug level. On this
level, the Mnesia event handler starts subscribing
to updates on all Mnesia tables. This level is
intended only for debugging small toy systems, as many
large events can be generated.</p> </dd><dt><strong>false</strong></dt><dd>An alias for none. </dd><dt><strong>true</strong></dt><dd>An alias for debug. </dd></dl> </li><li> <p><strong>-mnesia core_dir Directory</strong>. The name of the
directory where Mnesia core files is stored, or
false. Setting it implies that also RAM-only nodes
generate a core file if a crash occurs.</p> </li><li> <p><strong>-mnesia dc_dump_limit Number</strong>. Controls how often
<strong>disc_copies</strong> tables are dumped from memory.
Tables are dumped when 
<strong>filesize(Log) &gt; (filesize(Tab)/Dc_dump_limit)</strong>.
Lower values reduce CPU overhead but increase disk space
and startup times. Default is 4.</p> </li><li> <p><strong>-mnesia dir Directory</strong>. The name of the directory
where all Mnesia data is stored. The directory name
must be unique for the current node. Two nodes must never
share the the same Mnesia directory. The results
are unpredictable.</p> </li><li> <p><strong>-mnesia dump_disc_copies_at_startup true | false</strong>.
If set to false, this disables the dumping of <strong>disc_copies</strong>
tables during startup while tables are being loaded. The default
is true.</p> </li><li> <p><strong>-mnesia dump_log_load_regulation true | false</strong>.
Controls if log dumps are to be performed as fast as
possible, or if the dumper is to do its own load
regulation. Default is <strong>false</strong>.</p> <p>This feature is temporary and will be removed in a
future release</p> </li><li> <p><strong>-mnesia dump_log_update_in_place true | false</strong>.
Controls if log dumps are performed on a copy of the
original data file, or if the log dump is performed
on the original data file. Default is <strong>true</strong></p> </li><li> <a name=" dump_log_write_threshold"></a> <p><strong>-mnesia dump_log_write_threshold Max</strong>.
<strong>Max</strong> is an integer that specifies the maximum
number of writes allowed to the transaction log before
a new dump of the log is performed. Default is <strong>100</strong>
log writes.</p> </li><li> <a name=" dump_log_time_threshold"></a> <p><strong>-mnesia dump_log_time_threshold Max</strong>.
<strong>Max</strong> is an integer that specifies the dump log
interval in milliseconds. Default is 3 minutes. If a
dump has not been performed within
<strong>dump_log_time_threshold</strong> milliseconds, a new dump
is performed regardless of the number of writes
performed.</p> </li><li> <p><strong>-mnesia event_module Module</strong>. The name of the
Mnesia event handler callback module. Default is
<strong>mnesia_event</strong>.</p> </li><li> <p><strong>-mnesia extra_db_nodes Nodes</strong> specifies a list of
nodes, in addition to the ones found in the schema, with
which Mnesia is also to establish contact. Default
is <strong>[]</strong> (empty list).</p> </li><li> <p><strong>-mnesia fallback_error_function {UserModule, UserFunc}</strong>.
Specifies a user-supplied callback function, which is
called if a fallback is installed and Mnesia goes
down on another node. Mnesia calls the function
with one argument, the name of the dying node, for example,
<strong>UserModule:UserFunc(DyingNode)</strong>. Mnesia must
be restarted, otherwise the database can be inconsistent.
The default behavior is to terminate Mnesia.</p> </li><li> <p><strong>-mnesia max_wait_for_decision Timeout</strong>. Specifies
how long Mnesia waits for other nodes to share their
knowledge about the outcome of an unclear transaction. By
default, <strong>Timeout</strong> is set to the atom <strong>infinity</strong>.
This implies that if Mnesia upon startup detects
a "heavyweight transaction" whose outcome is unclear, the
local Mnesia waits until Mnesia is started
on some (in the worst case all) of the other nodes that were
involved in the interrupted transaction. This is a rare
situation, but if it occurs, Mnesia does not guess if
the transaction on the other nodes was committed or
terminated. Mnesia waits until it knows the outcome
and then acts accordingly.</p> <p>If <strong>Timeout</strong> is set to an integer value in
milliseconds, Mnesia forces "heavyweight transactions"
to be finished, even if the outcome of the transaction for
the moment is unclear. After <strong>Timeout</strong> milliseconds,
Mnesia commits or terminates the transaction and
continues with the startup. This can lead to a situation
where the transaction is committed on some nodes and
terminated on other nodes. If the transaction is a
schema transaction, the inconsistency can be fatal.</p> </li><li> <p><strong>-mnesia no_table_loaders NUMBER</strong>. Specifies the number
of parallel table loaders during start. More loaders can be
good if the network latency is high or if many tables
contain few records. Default is <strong>2</strong>.</p> </li><li> <p><strong>-mnesia send_compressed Level</strong>. Specifies the level of
compression to be used when copying a table from the local
node to another one. Default is <strong>0</strong>.</p> <p><strong>Level</strong> must be an integer in the interval
<strong>[0, 9]</strong>, where <strong>0</strong> means no compression and
<strong>9</strong> means maximum compression. Before setting it to a
non-zero value, ensure that the remote nodes
understand this configuration.</p> </li><li> <p><strong>-mnesia schema_location Loc</strong>. Controls where
Mnesia looks for its schema. Parameter
<strong>Loc</strong> can be one of the following atoms:</p> <dl><dt><strong>disc</strong></dt><dd> <p>Mandatory disc. The schema is assumed to be located
in the Mnesia directory. If the schema cannot
be found, Mnesia refuses to start. This is the
old behavior.</p> </dd><dt><strong>ram</strong></dt><dd> <p>Mandatory RAM. The schema resides in RAM
only. At startup, a tiny new schema is generated. This
default schema only contains the definition of the schema
table and only resides on the local node. Since no other
nodes are found in the default schema, configuration
parameter <strong>extra_db_nodes</strong> must be used to let the
node share its table definitions with other nodes.</p> <p>Parameter <strong>extra_db_nodes</strong> can also be
used on disc based nodes.</p> </dd><dt><strong>opt_disc</strong></dt><dd> <p>Optional disc. The schema can reside on disc or in
RAM. If the schema is found on disc, Mnesia
starts as a disc-based node and the storage type of
the schema table is <strong>disc_copies</strong>. If no schema is
found on disc, Mnesia starts as a disc-less node
and the storage type of the schema table is
<strong>ram_copies</strong>. Default value for the application
parameter is <strong>opt_disc</strong>.</p> </dd></dl> </li></ul><p>First, the SASL application parameters are checked,
then the command-line flags are checked, and finally, the
default value is chosen.</p><h3>See Also</h3><p><a href="./application">application(3)</a>,
<a href="./dets">dets(3)</a>,
<a href="./disk_log">disk_log(3)</a>,
<a href="./ets">ets(3)</a>,
<a href="./mnesia_registry">mnesia_registry(3)</a>,
<a href="./qlc">qlc(3)</a></p><h2>mnesia_frag_hash</h2><p>Defines mnesia_frag_hash callback behavior</p><p>This module defines a callback behavior for user-defined hash
functions of fragmented tables.Which module that is selected to implement the <strong>mnesia_frag_hash</strong>
behavior for a particular fragmented table is specified together
with the other <strong>frag_properties</strong>. The <strong>hash_module</strong> defines
the module name. The <strong>hash_state</strong> defines the initial hash state.This module implements dynamic hashing, which is a kind of hashing
that grows nicely when new fragments are added. It is well
suited for scalable hash tables.</p><h2>Functions</h2><h3>init_state(Tab, State) -&gt; NewState | abort(Reason)</h3><p>Initiates the hash state for a new table.</p><ul><li><span class="v">Tab = atom()</span></li><li><span class="v">State = term()</span></li><li><span class="v">NewState = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Starts when a fragmented table is
created with the function <strong>mnesia:create_table/2</strong> or
when a normal (unfragmented) table is converted to be a
fragmented table with <strong>mnesia:change_table_frag/2</strong>.</p><p>Notice that the function <strong>add_frag/2</strong> is started
one time for each of the other fragments (except number 1)
as a part of the table creation procedure.</p><p><strong>State</strong> is the initial value of the <strong>hash_state</strong>
<strong>frag_property</strong>. <strong>NewState</strong> is stored as
<strong>hash_state</strong> among the other <strong>frag_properties</strong>.</p><h3>add_frag(State) -&gt; {NewState, IterFrags, AdditionalLockFrags} | abort(Reason)</h3><p>Starts when a new fragment is added to a fragmented table.</p><ul><li><span class="v">State = term()</span></li><li><span class="v">NewState = term()</span></li><li><span class="v">IterFrags = [integer()]</span></li><li><span class="v">AdditionalLockFrags = [integer()]</span></li><li><span class="v">Reason = term()</span></li></ul><p>To scale well, it is a good idea to ensure that the
records are evenly distributed over all fragments, including
the new one.</p><p><strong>NewState</strong> is stored as <strong>hash_state</strong> among the
other <strong>frag_properties</strong>.</p><p>As a part of the <strong>add_frag</strong> procedure, Mnesia iterates
over all fragments corresponding to the <strong>IterFrags</strong> numbers
and starts <strong>key_to_frag_number(NewState,RecordKey)</strong> for
each record. If the new fragment differs from the old
fragment, the record is moved to the new fragment.</p><p>As the <strong>add_frag</strong> procedure is a part of a schema
transaction, Mnesia acquires write locks on the
affected tables. That is, both the fragments corresponding
to <strong>IterFrags</strong> and those corresponding to
<strong>AdditionalLockFrags</strong>.</p><h3>del_frag(State) -&gt;  {NewState, IterFrags, AdditionalLockFrags} | abort(Reason)</h3><p>Starts when a fragment is deleted from a fragmented table.</p><ul><li><span class="v">State = term()</span></li><li><span class="v">NewState = term()</span></li><li><span class="v">IterFrags = [integer()]</span></li><li><span class="v">AdditionalLockFrags = [integer()]</span></li><li><span class="v">Reason = term()</span></li></ul><p><strong>NewState</strong> is stored as <strong>hash_state</strong> among the
other <strong>frag_properties</strong>.</p><p>As a part of the <strong>del_frag</strong> procedure, Mnesia iterates
over all fragments corresponding to the <strong>IterFrags</strong> numbers
and starts <strong>key_to_frag_number(NewState,RecordKey)</strong> for
each record. If the new fragment differs from the old
fragment, the record is moved to the new fragment.</p><p>Notice that all records in the last fragment must be moved to
another fragment, as the entire fragment is deleted.</p><p>As the <strong>del_frag</strong> procedure is a part of a schema
transaction, Mnesia acquires write locks on the
affected tables. That is, both the fragments corresponding
to <strong>IterFrags</strong> and those corresponding to
<strong>AdditionalLockFrags</strong>.</p><h3>key_to_frag_number(State, Key) -&gt; FragNum | abort(Reason)</h3><p>Resolves the key of a record into a fragment number.</p><ul><li><span class="v">FragNum = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Starts whenever Mnesia needs to determine
which fragment a certain record belongs to. It is typically
started at <strong>read</strong>, <strong>write</strong>, and <strong>delete</strong>.</p><h3>match_spec_to_frag_numbers(State, MatchSpec) -&gt; FragNums | abort(Reason)</h3><p>Resolves a <strong>MatchSpec</strong> into a list of fragment numbers.</p><ul><li><span class="v">MatcSpec = ets_select_match_spec()</span></li><li><span class="v">FragNums = [FragNum]</span></li><li><span class="v">FragNum = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>This function is called whenever Mnesia needs to determine
which fragments that need to be searched for a <strong>MatchSpec</strong>.
It is typically called by <strong>select</strong> and
<strong>match_object</strong>.</p><h3>See Also</h3><p><a href="./mnesia">mnesia(3)</a></p><h2>mnesia_registry</h2><p>Dump support for registries in erl_interface.</p><p>This module is usually part of the <strong>erl_interface</strong>
application, but is currently part of the Mnesia
application.This module is mainly intended for internal use within OTP,
but it has two functions that are exported for public use.On C-nodes, <strong>erl_interface</strong> has support for registry
tables. These tables reside in RAM on the C-node, but can also
be dumped into Mnesia tables. By default, the dumping
of registry tables through <strong>erl_interface</strong> causes a
corresponding Mnesia table to be created with
<strong>mnesia_registry:create_table/1</strong>, if necessary.Tables that are created with these functions can be
administered as all other Mnesia tables. They can be
included in backups, replicas can be added, and so on.
The tables are normal Mnesia tables owned by the user
of the corresponding <strong>erl_interface</strong> registries.</p><h2>Functions</h2><h3>create_table(Tab) -&gt; ok | exit(Reason)</h3><p>Creates a registry table in Mnesia.</p><p>A wrapper function for <strong>mnesia:create_table/2</strong>,
which creates a table (if there is no existing table)
with an appropriate set of <strong>attributes</strong>. The table
only resides on the local node and its storage type is
the same as the <strong>schema</strong> table on the local node,
that is, <strong>{ram_copies,[node()]}</strong> or
<strong>{disc_copies,[node()]}</strong>.</p><p>This function is used by <strong>erl_interface</strong> to
create the Mnesia table if it does not already
exist.</p><h3>create_table(Tab, TabDef) -&gt; ok | exit(Reason)</h3><p>Creates a customized registry table in Mnesia.</p><p>A wrapper function for <strong>mnesia:create_table/2</strong>,
which creates a table (if there is no existing table)
with an appropriate set of <strong>attributes</strong>. The
attributes and <strong>TabDef</strong> are forwarded to
<strong>mnesia:create_table/2</strong>. For example, if the table
is to reside as <strong>disc_only_copies</strong> on all nodes,
a call looks as follows:</p><pre><code class="">
          TabDef = [{{disc_only_copies, node()|nodes()]}],
          mnesia_registry:create_table(my_reg, TabDef)</code></pre><h3>See Also</h3><p><a href="./index">erl_interface(3)</a>,
<a href="./mnesia">mnesia(3)</a></p></body></html>