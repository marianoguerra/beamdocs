<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Transactions and Other Access Contexts</h1><p>This section describes the <strong>Mnesia</strong> transaction system and
the transaction properties that make <strong>Mnesia</strong> a fault-tolerant,
distributed Database Management System (DBMS).</p><p>This section also describes the locking functions,
including table locks and sticky locks, as well as alternative
functions that bypass the transaction system in favor of improved
speed and reduced overhead. These functions are called "dirty
operations". The use of nested transactions is also described.
The following topics are included:</p><ul><li>Transaction properties, which include atomicity, consistency, isolation, and durability</li><li>Locking</li><li>Dirty operations</li><li>Record names versus table names</li><li>Activity concept and various access contexts</li><li>Nested transactions</li><li>Pattern matching</li><li>Iteration</li></ul><a name="trans_prop"></a><h2>Transaction Properties</h2><p>Transactions are important when designing fault-tolerant,
distributed systems. A <strong>Mnesia</strong> transaction is a mechanism
by which a series of database operations can be executed as one
functional block. The functional block that is run as a
transaction is called a Functional Object (Fun), and this code can
read, write, and delete <strong>Mnesia</strong> records. The Fun is evaluated
as a transaction that either commits or terminates. If a transaction
succeeds in executing the Fun, it replicates the action on all nodes
involved, or terminates if an error occurs.</p><p>The following example shows a transaction that raises the
salary of certain employee numbers:</p><pre><code class="">

raise(Eno, Raise) -&gt;
    F = fun() -&gt;
                [E] = mnesia:read(employee, Eno, write),
                Salary = E#employee.salary + Raise,
                New = E#employee{salary = Salary},
                mnesia:write(New)
        end,
    mnesia:transaction(F).</code></pre><p>The function <strong>raise/2</strong> contains a Fun
made up of four code lines. This Fun is called by the statement
<strong>mnesia:transaction(F)</strong> and returns a value.</p><p>The <strong>Mnesia</strong> transaction system facilitates the construction of
reliable, distributed systems by providing the following important
properties:</p><ul><li>The transaction handler ensures that a Fun, which is placed inside a transaction, does not interfere with operations embedded in other transactions when it executes a series of operations on tables.   </li><li>The transaction handler ensures that either all operations in the transaction are performed successfully on all nodes atomically, or the transaction fails without permanent effect on any node. </li><li>The <strong>Mnesia</strong> transactions have four important properties, called <em>A</em>tomicity, <em>C</em>onsistency, <em>I</em>solation, and <em>D</em>urability (ACID). These properties are described in the following sections.</li></ul><h2>Atomicity</h2><p>Atomicity means that database changes that are
executed by a transaction take effect on all nodes involved, or
on none of the nodes. That is, the transaction either
succeeds entirely, or it fails entirely.</p><p>Atomicity is important when it is needed to write
atomically more than one record in the same
transaction. The function <strong>raise/2</strong>, shown in the previous
example, writes one record only. The function <strong>insert_emp/3</strong>,
shown in the program listing in
<a href="./Mnesia_chap2#getting_started">Getting Started</a>, writes the record
<strong>employee</strong> as well as employee relations, such as
<strong>at_dep</strong> and <strong>in_proj</strong>, into the database. If this
latter code is run inside a transaction, the transaction
handler ensures that the transaction either succeeds completely,
or not at all.</p><p><strong>Mnesia</strong> is a distributed DBMS where data can be replicated
on several nodes. In many applications, it is important that a
series of write operations are performed atomically inside a
transaction. The atomicity property ensures that a transaction
takes effect on all nodes, or none.</p><h2>Consistency</h2><p>The consistency property ensures that
a transaction always leaves the DBMS in a consistent state. For
example, <strong>Mnesia</strong> ensures that no inconsistencies occur if
Erlang, <strong>Mnesia</strong>, or the computer crashes while a write
operation is in progress.</p><h2>Isolation</h2><p>The isolation property ensures that
transactions that execute on different nodes in a network, and
access and manipulate the same data records, do not interfere
with each other. The isolation property makes it possible to
execute the function <strong>raise/2</strong> concurrently. A classical
problem in concurrency control theory is the "lost update
problem".</p><p>The isolation property is in particular useful if the following
circumstances occur where an employee (with employee number
123) and two processes (P1 and P2) are concurrently trying to
raise the salary for the employee:</p><ul><li><em>Step 1:</em> The initial value of the employees salary is, for example, 5. Process P1 starts to execute, reads the employee record, and adds 2 to the salary.</li><li><em>Step 2:</em> Process P1 is for some reason pre-empted and process P2 has the opportunity to run.</li><li><em>Step 3:</em> Process P2 reads the record, adds 3 to the salary, and finally writes a new employee record with the salary set to 8.</li><li><em>Step 4:</em> Process P1 starts to run again and writes its employee record with salary set to 7, thus effectively overwriting and undoing the work performed by process P2. The update performed by P2 is lost.</li></ul><p>A transaction system makes it possible to execute two or more
processes concurrently that manipulate the same record.
The programmer does not need to check that the
updates are synchronous; this is overseen by the
transaction handler. All programs accessing the database through
the transaction system can be written as if they had sole access
to the data.</p><h2>Durability</h2><p>The durability property ensures that
changes made to the DBMS by a transaction are permanent. Once a
transaction is committed, all changes made to the database are
durable, that is, they are written safely to disc and do not
become corrupted and do not disappear.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The described durability feature does not entirely apply to
situations where <strong>Mnesia</strong> is configured as a "pure"
primary memory database.</p></div><h2>Locking</h2><p>Different transaction managers employ different strategies to
satisfy the isolation property. <strong>Mnesia</strong> uses the standard
technique of two phase locking. That is, locks are set on records
before they are read or written. <strong>Mnesia</strong> uses the following
lock types:</p><ul><li><em>Read locks</em>. A read lock is set on one replica of a record before it can be read. </li><li><em>Write locks</em>. Whenever a transaction writes to a record, write locks are first set on all replicas of that particular record. </li><li><em>Read table locks</em>. If a transaction traverses an entire table in search for a record that satisfies some particular property, it is most inefficient to set read locks on the records one by one. It is also memory consuming, as the read locks themselves can take up considerable space if the table is large. Therefore, <strong>Mnesia</strong> can set a read lock on an entire table. </li><li><em>Write table locks</em>. If a transaction writes many records to one table, a write lock can be set on the entire table. </li><li><em>Sticky locks</em>. These are write locks that stay in place at a node after the transaction that initiated the lock has terminated.</li></ul><p><strong>Mnesia</strong> employs a strategy whereby functions, such as
<a href="./mnesia#read/1">mnesia:read/1</a>
acquire the necessary locks dynamically as
the transactions execute. <strong>Mnesia</strong> automatically sets and
releases the locks and the programmer does not need to code these
operations.</p><p>Deadlocks can occur when concurrent processes set and release
locks on the same records. <strong>Mnesia</strong> employs a "wait-die"
strategy to resolve
these situations. If <strong>Mnesia</strong> suspects that a deadlock can
occur when a transaction tries to set a lock, the transaction is
forced to release all its locks and sleep for a while. The Fun
in the transaction is evaluated once more.</p><p>It is therefore important that the code inside the Fun given to
<a href="./mnesia#transaction/2">mnesia#transaction/2</a>
is pure. Some strange results can
occur if, for example, messages are sent by the transaction
Fun. The following example illustrates this situation:</p><pre><code class="">

bad_raise(Eno, Raise) -&gt;
    F = fun() -&gt;
                [E] = mnesia:read({employee, Eno}),
                Salary = E#employee.salary + Raise,
                New = E#employee{salary = Salary},
                io:format("Trying to write ... ~n", []),
                mnesia:write(New)
        end,
    mnesia:transaction(F).</code></pre><p>This transaction can write the text <strong>"Trying to write ... "</strong>
1000 times to the terminal. However, <strong>Mnesia</strong> guarantees
that each transaction will eventually run. As a result,
<strong>Mnesia</strong> is not only deadlock free, but also livelock free.</p><p>The <strong>Mnesia</strong> programmer cannot prioritize one particular
transaction to execute before other transactions that are waiting
to execute. As a result, the <strong>Mnesia</strong> DBMS transaction system is
not suitable for hard real-time applications. However, <strong>Mnesia</strong>
contains other features that have real-time properties.</p><p><strong>Mnesia</strong> dynamically sets and releases locks as transactions
execute. It is therefore dangerous to execute code with
transaction side-effects. In particular, a <strong>receive</strong>
statement inside a transaction can lead to a situation where the
transaction hangs and never returns, which in turn can cause locks
not to release. This situation can bring the whole system to a
standstill, as other transactions that execute in other
processes, or on other nodes, are forced to wait for the defective
transaction.</p><p>If a transaction terminates abnormally, <strong>Mnesia</strong>
automatically releases the locks held by the transaction.</p><p>Up to now, examples of a number of functions that can be used
inside a transaction have been shown. The following list shows
the <em>simplest</em> <strong>Mnesia</strong> functions that work with
transactions. Notice that these functions must be embedded in a
transaction. If no enclosing transaction (or other enclosing
<strong>Mnesia</strong> activity) exists, they all fail.</p><ul><li><a href="./mnesia#transaction/2">mnesia:transaction(Fun) -&gt; {aborted, Reason} |{atomic, Value}</a> executes one transaction with the functional object <strong>Fun</strong> as the single parameter. </li><li><a href="./mnesia#read/1">mnesia:read({Tab, Key}) -&gt; transaction abort | RecordList</a> reads all records with <strong>Key</strong> as key from table <strong>Tab</strong>. This function has the same semantics regardless of the location of <strong>Table</strong>. If the table is of type <strong>bag</strong>, <strong>read({Tab, Key})</strong> can return an arbitrarily long list. If the table is of type <strong>set</strong>, the list is either of length one or <strong>[]</strong>. </li><li><a href="./mnesia#wread/1">mnesia:wread({Tab, Key}) -&gt; transaction abort | RecordList</a> behaves the same way as the previously listed function <strong>read/1</strong>, except that it acquires a write lock instead of a read lock. To execute a transaction that reads a record, modifies the record, and then writes the record, it is slightly more efficient to set the write lock immediately. When a <a href="./mnesia#read/1">mnesia:read/1</a> is issued, followed by a <a href="./mnesia#write/1">mnesia:write/1</a> the first read lock must be upgraded to a write lock when the write operation is executed. </li><li><a href="./mnesia#write/1">mnesia:write(Record) -&gt; transaction abort | ok</a> writes a record into the database. Argument <strong>Record</strong> is an instance of a record. The function returns <strong>ok</strong>, or terminates the transaction if an error occurs. </li><li><a href="./mnesia#delete/1">mnesia:delete({Tab, Key}) -&gt; transaction abort | ok</a> deletes all records with the given key. </li><li><a href="./mnesia#delete_object/1">mnesia:delete_object(Record) -&gt; transaction abort | ok</a> deletes records with the OID <strong>Record</strong>. Use this function to delete only some records in a table of type <strong>bag</strong>.</li></ul><h2>Sticky Locks</h2><p>As previously stated, the locking strategy used by <strong>Mnesia</strong>
is to lock one record when reading a record, and lock all replicas
of a record when writing a record. However, some
applications use <strong>Mnesia</strong> mainly for its fault-tolerant
qualities. These applications can be configured with one
node doing all the heavy work, and a standby node that is ready
to take over if the main node fails. Such applications can
benefit from using sticky locks instead of the normal locking
scheme.</p><p>A sticky lock is a lock that stays in place at a node, after
the transaction that first acquired the lock has terminated. To
illustrate this, assume that the following transaction is
executed:</p><pre><code class="">
        F = fun() -&gt;
              mnesia:write(#foo{a = kalle})
            end,
        mnesia:transaction(F).</code></pre><p>The <strong>foo</strong> table is replicated on the two nodes <strong>N1</strong>
and <strong>N2</strong>.</p><p>Normal locking requires the following:</p><ul><li>One network RPC (two messages) to acquire the write lock </li><li>Three network messages to execute the two-phase commit protocol </li></ul><p>If sticky locks are used, the code must first be changed as
follows:</p><pre><code class="">
        F = fun() -&gt;
              mnesia:s_write(#foo{a = kalle})
            end,
        mnesia:transaction(F).</code></pre><p>This code uses the function
<a href="./mnesia#s_write/1">s_write/1</a>
instead of the function
<a href="./mnesia#write/1">write/1</a>
The function <strong>s_write/1</strong> sets a
sticky lock instead of a normal lock. If the table is not
replicated, sticky locks have no special effect. If the table is
replicated, and a sticky lock is set on node <strong>N1</strong>, this
lock then sticks to node <strong>N1</strong>. The next time you try to
set a sticky lock on the same record at node <strong>N1</strong>,
<strong>Mnesia</strong> detects that the lock is already set and do no
network operation to acquire the lock.</p><p>It is more efficient to set a local lock than it is to set
a networked lock. Sticky locks can therefore benefit an
application that uses a replicated table and perform most of the
work on only one of the nodes.</p><p>If a record is stuck at node <strong>N1</strong> and you try to set a
sticky lock for the record on node <strong>N2</strong>, the record must be
unstuck. This operation is expensive and reduces performance.
The unsticking is done automatically if you issue <strong>s_write/1</strong>
requests at <strong>N2</strong>.</p><h2>Table Locks</h2><p><strong>Mnesia</strong> supports read and write locks on whole tables as a
complement to the normal locks on single records. As previously
stated, <strong>Mnesia</strong> sets and releases locks automatically, and
the programmer does not need to code these operations. However,
transactions that read and write many records in a
specific table execute more efficiently if the
transaction is started by setting a table lock on this table. This
blocks other concurrent transactions from the table. The
following two functions are used to set explicit table locks for
read and write operations:</p><ul><li><a href="./mnesia#read_lock_table/1">mnesia:read_lock_table(Tab)</a> sets a read lock on table <strong>Tab</strong>.</li><li><a href="./mnesia#write_lock_table/1">mnesia:write_lock_table(Tab)</a> sets a write lock on table <strong>Tab</strong>.</li></ul><p>Alternative syntax for acquisition of table locks is as
follows:</p><pre><code class="">
        mnesia:lock({table, Tab}, read)
        mnesia:lock({table, Tab}, write)</code></pre><p>The matching operations in <strong>Mnesia</strong> can either lock the
entire table or only a single record (when the key is bound in
the pattern).</p><h2>Global Locks</h2><p>Write locks are normally acquired on all nodes where a
replica of the table resides (and is active). Read locks are
acquired on one node (the local one if a local
replica exists).</p><p>The function
<a href="./mnesia#lock/2">mnesia:lock/2</a>
is intended to support table locks (as mentioned previously)
but also for situations when locks need to be
acquired regardless of how tables have been replicated:</p><pre><code class="">
        mnesia:lock({global, GlobalKey, Nodes}, LockKind)

        LockKind ::= read | write | ...</code></pre><p>The lock is acquired on <strong>LockItem</strong> on all nodes in the
node list.</p><h2>Dirty Operations</h2><p>In many applications, the overhead of processing a transaction
can result in a loss of performance. Dirty operation are short
cuts that bypass much of the processing and increase the speed
of the transaction.</p><p>Dirty operation are often useful, for example, in a
datagram routing application
where <strong>Mnesia</strong> stores the routing table, and it is time
consuming to start a whole transaction every time a packet is
received. <strong>Mnesia</strong> has therefore functions that manipulate
tables without using transactions. This alternative
to processing is known as a dirty operation. However, notice the
trade-off in avoiding the overhead of transaction processing:</p><ul><li>The atomicity and the isolation properties of <strong>Mnesia</strong> are lost. </li><li>The isolation property is compromised, because other Erlang processes, which use transaction to manipulate the data, do not get the benefit of isolation if dirty operations simultaneously are used to read and write records from the same table. </li></ul><p>The major advantage of dirty operations is that they execute
much faster than equivalent operations that are processed as
functional objects within a transaction.</p><p>Dirty operations
are written to disc if they are performed on a table of type
<strong>disc_copies</strong> or type <strong>disc_only_copies</strong>. <strong>Mnesia</strong>
also ensures that all replicas of a table are updated if a
dirty write operation is performed on a table.</p><p>A dirty operation ensures a certain level of consistency.
For example, dirty operations cannot return
garbled records. Hence, each individual read or write operation
is performed in an atomic manner.</p><p>All dirty functions execute a call to <strong>exit({aborted, Reason})</strong>
on failure. Even if the following functions are
executed inside a transaction no locks are acquired. The
following functions are available:</p><ul><li><a href="./mnesia#dirty_read/1">mnesia:dirty_read({Tab, Key})</a> reads one or more records from <strong>Mnesia</strong>. </li><li><a href="./mnesia#dirty_write/1">mnesia:dirty_write(Record)</a> writes the record <strong>Record</strong>. </li><li><a href="./mnesia#dirty_delete/1">mnesia:dirty_delete({Tab, Key})</a> deletes one or more records with key <strong>Key</strong>. </li><li><a href="./mnesia#dirty_delete_object/1">mnesia:dirty_delete_object(Record)</a> is the dirty operation alternative to the function <a href="./mnesia#delete_object/1">delete_object/1</a>. </li><li> <p><a href="./mnesia#dirty_first/1">mnesia:dirty_first(Tab)</a>
returns the "first" key in table <strong>Tab</strong>.</p> <p>Records in <strong>set</strong> or <strong>bag</strong> tables are not sorted.
However, there is a record order that is unknown to the user.
This means that a table can be traversed by this function
with the function
<a href="./mnesia#dirty_next/2">mnesia:dirty_next/2</a>.</p> <p>If there are no records in the table, this function
returns the atom <strong>'$end_of_table'</strong>. It is not
recommended to use this atom as the key for any user
records.</p> </li><li><p><a href="./mnesia#dirty_next/2">mnesia:dirty_next(Tab, Key)</a>
returns the "next" key in table <strong>Tab</strong>. This function makes it
possible to traverse a table and perform some operation on all
records in the table. When the end of the table is reached, the
special key <strong>'$end_of_table'</strong> is returned. Otherwise, the
function returns a key that can be used to read the actual
record.</p> <p>The behavior is undefined if any process performs a write
operation on the table while traversing the table with the
function
<a href="./mnesia#dirty_next/2">dirty_next/2</a>
This is because <strong>write</strong>
operations on a <strong>Mnesia</strong> table can lead to internal
reorganizations of the table itself. This is an implementation
detail, but remember that the dirty functions are low-level
functions.</p> </li><li><a href="./mnesia#dirty_last/1">mnesia:dirty_last(Tab)</a> works exactly like <a href="./mnesia#dirty_first/1">mnesia:dirty_first/1</a> but returns the last object in Erlang term order for the table type <strong>ordered_set</strong>. For all other table types, <strong>mnesia:dirty_first/1</strong> and  <strong>mnesia:dirty_last/1</strong> are synonyms. </li><li><a href="./mnesia#dirty_prev/2">mnesia:dirty_prev(Tab, Key)</a> works exactly like <strong>mnesia:dirty_next/2</strong> but returns the previous object in Erlang term order for the table type <strong>ordered_set</strong>. For all other table types, <strong>mnesia:dirty_next/2</strong> and <strong>mnesia:dirty_prev/2</strong> are synonyms. </li><li> <p><a href="./mnesia#dirty_slot/2">mnesia:dirty_slot(Tab, Slot)</a>
returns the list of records that are associated with <strong>Slot</strong>
in a table. It can be used to traverse a table in a manner
similar to the function <strong>dirty_next/2</strong>. A table has a
number of slots that range from zero to some unknown upper
bound. The function <strong>dirty_slot/2</strong> returns the special
atom <strong>'$end_of_table'</strong> when the end of the table is
reached.</p> <p>The behavior of this function is undefined if the
table is written on while being
traversed. The function
<a href="./mnesia#read_lock_table/1">mnesia:read_lock_table(Tab)</a>
can be used to ensure that no transaction-protected writes
are performed during the iteration.</p> </li><li><p><a href="./mnesia#dirty_update_counter/2">mnesia:dirty_update_counter({Tab,Key}, Val)</a>.
Counters are positive integers with a value greater than or
equal to zero. Updating a counter adds <strong>Val</strong> and the
counter where <strong>Val</strong> is a positive or negative integer.</p> <p><strong>Mnesia</strong> has no special counter records. However, records
of the form <strong>{TabName, Key, Integer}</strong> can be used as
counters, and can be persistent.</p> <p>Transaction-protected updates of counter records are not
possible.</p> <p>There are two significant differences when using this
function instead of reading the record, performing the
arithmetic, and writing the record:</p> <ul><li>It is much more efficient. </li><li>The funcion <a href="./mnesia#dirty_update_counter/2">dirty_update_counter/2</a> is performed as an atomic operation although it is not protected by a transaction. Therfore no table update is lost if two processes simultaneously execute the function <strong>dirty_update_counter/2</strong>. </li></ul> </li><li><a href="./mnesia#dirty_match_object/2">mnesia:dirty_match_object(Pat)</a> is the dirty equivalent of <a href="./mnesia#match_object/1">mnesia:match_object/1</a>. </li><li><a href="./mnesia#dirty_select/2">mnesia:dirty_select(Tab, Pat)</a> is the dirty equivalent of <a href="./mnesia#select/2"> mnesia:select/2</a>. </li><li><a href="./mnesia#dirty_index_match_object/2">mnesia:dirty_index_match_object(Pat, Pos)</a> is the dirty equivalent of <a href="./mnesia#index_match_object/2">mnesia:index_match_object/2</a>. </li><li><a href="./mnesia#dirty_index_read/3">mnesia:dirty_index_read(Tab, SecondaryKey, Pos)</a> is the dirty equivalent of <a href="./mnesia#index_read/3">mnesia:index_read/3</a>. </li><li><a href="./mnesia#dirty_all_keys/1">mnesia:dirty_all_keys(Tab)</a> is the dirty equivalent of <a href="./mnesia#all_keys/1"> mnesia:all_keys/1</a>. </li></ul><a name="recordnames_tablenames"></a><h2>Record Names versus Table Names</h2><p>In <strong>Mnesia</strong>, all records in a table must have the same name.
All the records must be instances of the same
record type. The record name, however, does not necessarily have
to be the same as the table name, although this is the case in
most of the examples in this User's Guide. If a table is created
without property <strong>record_name</strong>, the following code ensures
that all records in the tables have the same name as the table:</p><pre><code class="">
      mnesia:create_table(subscriber, [])</code></pre><p>However, if the table is created with an explicit record name
as argument, as shown in the following example, subscriber records
can be stored in both of the tables regardless of the table
names:</p><pre><code class="">
      TabDef = [{record_name, subscriber}],
      mnesia:create_table(my_subscriber, TabDef),
      mnesia:create_table(your_subscriber, TabDef).</code></pre><p>To access such tables, simplified access functions
(as described earlier) cannot be used. For example,
writing a subscriber record into a table requires the function
<a href="./mnesia#write/3">mnesia:write/3</a>
instead of the simplified functions
<a href="./mnesia#write/1">mnesia:write/1</a>
and
<a href="./mnesia#s_write/1">mnesia:s_write/1</a>:</p><pre><code class="">
      mnesia:write(subscriber, #subscriber{}, write)
      mnesia:write(my_subscriber, #subscriber{}, sticky_write)
      mnesia:write(your_subscriber, #subscriber{}, write)</code></pre><p>The following simple code illustrates the
relationship between the simplified access functions used in
most of the examples and their more flexible counterparts:</p><pre><code class="">
      mnesia:dirty_write(Record) -&gt;
        Tab = element(1, Record),
        mnesia:dirty_write(Tab, Record).
      
      mnesia:dirty_delete({Tab, Key}) -&gt;
        mnesia:dirty_delete(Tab, Key).
      
      mnesia:dirty_delete_object(Record) -&gt;
        Tab = element(1, Record),
        mnesia:dirty_delete_object(Tab, Record) 
      
      mnesia:dirty_update_counter({Tab, Key}, Incr) -&gt;
        mnesia:dirty_update_counter(Tab, Key, Incr).
      
      mnesia:dirty_read({Tab, Key}) -&gt;
        Tab = element(1, Record),
        mnesia:dirty_read(Tab, Key).
      
      mnesia:dirty_match_object(Pattern) -&gt;
        Tab = element(1, Pattern),
        mnesia:dirty_match_object(Tab, Pattern).
      
      mnesia:dirty_index_match_object(Pattern, Attr) 
        Tab = element(1, Pattern),
        mnesia:dirty_index_match_object(Tab, Pattern, Attr).
      
      mnesia:write(Record) -&gt;
        Tab = element(1, Record),
        mnesia:write(Tab, Record, write).
      
      mnesia:s_write(Record) -&gt;
        Tab = element(1, Record),
        mnesia:write(Tab, Record, sticky_write).
      
      mnesia:delete({Tab, Key}) -&gt;
        mnesia:delete(Tab, Key, write).
      
      mnesia:s_delete({Tab, Key}) -&gt;
        mnesia:delete(Tab, Key, sticky_write).
      
      mnesia:delete_object(Record) -&gt;
        Tab = element(1, Record),
        mnesia:delete_object(Tab, Record, write).
      
      mnesia:s_delete_object(Record) -&gt;
        Tab = element(1, Record),
        mnesia:delete_object(Tab, Record, sticky_write).
      
      mnesia:read({Tab, Key}) -&gt;
        mnesia:read(Tab, Key, read).
      
      mnesia:wread({Tab, Key}) -&gt;
        mnesia:read(Tab, Key, write).
      
      mnesia:match_object(Pattern) -&gt;
        Tab = element(1, Pattern),
        mnesia:match_object(Tab, Pattern, read).
      
      mnesia:index_match_object(Pattern, Attr) -&gt;
        Tab = element(1, Pattern),
        mnesia:index_match_object(Tab, Pattern, Attr, read).</code></pre><h2>Activity Concept and Various Access Contexts</h2><p>As previously described, a Functional Object (Fun) performing
table access operations, as listed here, can be passed
on as arguments to the function
<a href="./mnesia#transaction/2">mnesia:transaction/1,2,3</a>:
</p><ul><li> <a href="./mnesia#write/3">mnesia:write/3 (write/1, s_write/1)</a> </li><li> <a href="./mnesia#delete/3">mnesia:delete/3</a> (<a href="./mnesia#delete/1">mnesia:delete/1</a>, <a href="./mnesia#s_delete/1">mnesia:s_delete/1</a>) </li><li> <a href="./mnesia#delete_object/3">mnesia:delete_object/3</a> (<a href="./mnesia#delete_object/1">mnesia:delete_object/1</a>, <a href="./mnesia#s_delete_object/1">mnesia:s_delete_object/1</a>) </li><li> <a href="./mnesia#read/3">mnesia:read/3</a> (<a href="./mnesia#read/1">mnesia:read/1</a>, <a href="./mnesia#wread/1">mnesia:wread/1</a>) </li><li> <a href="./mnesia#match_object/3">mnesia:match_object/2</a> (<a href="./mnesia#match_object/1">mnesia:match_object/1</a>) </li><li> <a href="./mnesia#select/2">mnesia:select/3</a> (<a href="./mnesia#select/2">mnesia:select/2</a>) </li><li> <a href="./mnesia#foldl/3">mnesia:foldl/3</a> (<strong>mnesia:foldl/4</strong>, <a href="./mnesia#foldr/3">mnesia:foldr/3</a>, <strong>mnesia:foldr/4</strong>) </li><li> <a href="./mnesia#all_keys/1">mnesia:all_keys/1</a> </li><li> <a href="./mnesia#index_match_object/4">mnesia:index_match_object/4</a> (<a href="./mnesia#index_match_object/2">mnesia:index_match_object/2</a>) </li><li> <a href="./mnesia#index_read/3">mnesia:index_read/3</a> </li><li> <a href="./mnesia#lock/2">mnesia:lock/2</a> (<a href="./mnesia#read_lock_table/1">mnesia:read_lock_table/1</a>, <a href="./mnesia#write_lock_table/1">mnesia:write_lock_table/1</a>) </li><li> <a href="./mnesia#table_info/2">mnesia:table_info/2</a> </li></ul><p>These functions are performed in a
transaction context involving mechanisms, such as locking, logging,
replication, checkpoints, subscriptions, and commit protocols.
However, the same function can also be
evaluated in other activity contexts.</p><p>The following activity access contexts are currently supported:</p><ul><li><strong>transaction</strong></li><li><strong>sync_transaction</strong></li><li><strong>async_dirty</strong></li><li><strong>sync_dirty</strong></li><li><strong>ets</strong></li></ul><p>By passing the same "fun" as argument to the function
<a href="./mnesia#sync_transaction/3">mnesia:sync_transaction(Fun [, Args])</a>
it is performed
in synced transaction context. Synced transactions wait until all
active replicas has committed the transaction (to disc) before
returning from the <strong>mnesia:sync_transaction</strong> call. Using
<strong>sync_transaction</strong> is useful in the following cases:</p><ul><li>When an application executes on several nodes and wants to be sure that the update is performed on the remote nodes before a remote process is spawned or a message is sent to a remote process.</li><li>When a combining transaction writes with "dirty_reads", that is, the functions <strong>dirty_match_object</strong>, <strong>dirty_read</strong>, <strong>dirty_index_read</strong>, <strong>dirty_select</strong>, and so on.</li><li>When an application performs frequent or voluminous updates that can overload <strong>Mnesia</strong> on other nodes.</li></ul><p>By passing the same "fun" as argument to the function
<a href="./mnesia#async_dirty/2">mnesia:async_dirty(Fun [, Args])</a>,
it is performed in dirty context. The function calls are mapped to
the corresponding dirty functions. This still involves logging,
replication, and subscriptions but no locking,
local transaction storage, or commit protocols are involved.
Checkpoint retainers are updated but updated
"dirty". Thus, they are updated asynchronously. The
functions wait for the operation to be performed on one
node but not the others. If the table resides locally, no waiting
occurs.</p><p>By passing the same "fun" as an argument to the function
<a href="./mnesia#sync_dirty/2">mnesia:sync_dirty(Fun [, Args])</a>,
it is performed in almost the same context as the function
<a href="./mnesia#async_dirty/2">mnesia:async_dirty/1,2</a>.
The difference is that the operations are performed
synchronously. The caller waits for the updates to be
performed on all active replicas. Using <strong>mnesia:sync_dirty/1,2</strong>
is useful in the following cases:</p><ul><li>When an application executes on several nodes and wants to be sure that the update is performed on the remote nodes before a remote process is spawned or a message is sent to a remote process.</li><li>When an application performs frequent or voluminous updates that can overload <strong>Mnesia</strong> on the nodes.</li></ul><p>To check if your code is executed within a transaction, use
the function
<a href="./mnesia#is_transaction/0">mnesia:is_transaction/0</a>.
It returns <strong>true</strong> when called
inside a transaction context, otherwise <strong>false</strong>.</p><p><strong>Mnesia</strong> tables with storage type <strong>RAM_copies</strong> and
<strong>disc_copies</strong> are implemented internally as
<strong>ets</strong> tables. Applications can access the these tables
directly. This is only
recommended if all options have been weighed and the possible
outcomes are understood. By passing the earlier mentioned "fun"
to the function
<a href="./mnesia#ets/2">mnesia:ets(Fun [, Args])</a>,
it is performed but in a raw
context. The operations are performed directly on the
local <strong>ets</strong> tables, assuming that the local storage type is
<strong>RAM_copies</strong> and that the table is not replicated on other
nodes.</p><p>Subscriptions are not triggered and no checkpoints are updated,
but this operation is blindingly fast. Disc resident
tables are not to be updated with the <strong>ets</strong> function, as the
disc is not updated.</p><p>The Fun can also be passed as an argument to the function
<a href="./mnesia#activity-4">mnesia:activity/2,3,4</a>,
which enables use of customized
activity access callback modules. It can either be obtained
directly by stating the module name as argument, or implicitly
by use of configuration parameter <strong>access_module</strong>. A
customized callback module can be used for several purposes,
such as providing triggers, integrity constraints, runtime
statistics, or virtual tables.</p><p>The callback module does not have
to access real <strong>Mnesia</strong> tables, it is free to do whatever
it wants as long as the callback interface is fulfilled.</p><p><a href="Mnesia_App_B">Appendix B, Activity Access Callback Interface</a> provides the
source code, <strong>mnesia_frag.erl</strong>, for one alternative
implementation. The context-sensitive function
<a href="./mnesia#table_info/2">mnesia:table_info/2</a>
can be used to provide virtual
information about a table. One use of this is to perform
<strong>QLC</strong> queries within an activity context with a
customized callback module. By providing table information about
table indexes and other <strong>QLC</strong> requirements, <strong>QLC</strong> can
be used as a generic query language to access virtual tables.</p><p>QLC queries can be performed in all these activity
contexts (<strong>transaction</strong>, <strong>sync_transaction</strong>,
<strong>async_dirty</strong>, <strong>sync_dirty</strong>, and <strong>ets</strong>). The
<strong>ets</strong> activity only works if the table has no indexes.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The function <strong>mnesia:dirty_*</strong> always executes with
<strong>async_dirty</strong> semantics regardless of which activity
access contexts that are started. It can even start contexts
without any enclosing activity access context.</p></div><h2>Nested Transactions</h2><p>Transactions can be nested in an arbitrary fashion. A child
transaction must run in the same process as its parent. When a
child transaction terminates, the caller of the child transaction
gets return value <strong>{aborted, Reason}</strong> and any work performed
by the child is erased. If a child transaction commits, the
records written by the child are propagated to the parent.</p><p>No locks are released when child transactions terminate. Locks
created by a sequence of nested transactions are kept until
the topmost transaction terminates. Furthermore, any update
performed by a nested transaction is only propagated
in such a manner so that the parent of the nested transaction
sees the updates. No final commitment is done until
the top-level transaction terminates.
So, although a nested transaction returns <strong>{atomic, Val}</strong>,
if the enclosing parent transaction terminates, the entire
nested operation terminates.</p><p>The ability to have nested transaction with identical semantics
as top-level transaction makes it easier to write
library functions that manipulate <strong>Mnesia</strong> tables.</p><p>Consider a function that adds a subscriber to a telephony
system:</p><pre>
      add_subscriber(S) -&gt;
          mnesia:transaction(fun() -&gt;
              case mnesia:read( ..........</pre><p>This function needs to be called as a transaction.
Assume that you wish to write a function that
both calls the function <strong>add_subscriber/1</strong> and
is in itself protected by the context of a transaction.
By calling <strong>add_subscriber/1</strong> from within
another transaction, a nested transaction is created.</p><p>Also, different activity access contexts can be mixed while
nesting. However, the dirty ones (<strong>async_dirty</strong>,
<strong>sync_dirty</strong>, and <strong>ets</strong>) inherit the transaction
semantics if they are called inside a transaction and thus
grab locks and use two or three phase commit.</p><p><em>Example:</em></p><pre>
      add_subscriber(S) -&gt;
          mnesia:transaction(fun() -&gt;
             %% Transaction context 
             mnesia:read({some_tab, some_data}),
             mnesia:sync_dirty(fun() -&gt;
                 %% Still in a transaction context.
                 case mnesia:read( ..) ..end), end).
      add_subscriber2(S) -&gt;
          mnesia:sync_dirty(fun() -&gt;
             %% In dirty context 
             mnesia:read({some_tab, some_data}),
             mnesia:transaction(fun() -&gt;
                 %% In a transaction context.
                 case mnesia:read( ..) ..end), end).</pre><h2>Pattern Matching</h2><a name="matching"></a><p>When the function
<a href="./mnesia#read/3">mnesia:read/3</a>
cannot be used, <strong>Mnesia</strong>
provides the programmer with several functions for matching
records against a pattern. The most useful ones
are the following:</p><pre><code class="">
      mnesia:select(Tab, MatchSpecification, LockKind) -&gt;
          transaction abort | [ObjectList]
      mnesia:select(Tab, MatchSpecification, NObjects, Lock) -&gt;  
          transaction abort | {[Object],Continuation} | '$end_of_table'
      mnesia:select(Cont) -&gt;
          transaction abort | {[Object],Continuation} | '$end_of_table'
      mnesia:match_object(Tab, Pattern, LockKind) -&gt;
          transaction abort | RecordList</code></pre><p>These functions match a <strong>Pattern</strong> against all records in
table <strong>Tab</strong>. In a
<a href="./mnesia#select/2">mnesia:select</a>
call, <strong>Pattern</strong> is
a part of <strong>MatchSpecification</strong> described in the following. It
is not necessarily performed as an exhaustive search of the entire
table. By using indexes and bound values in the key of the
pattern, the actual work done by the function can be condensed
into a few hash lookups. Using <strong>ordered_set</strong> tables can reduce
the search space if the keys are partially bound.</p><p>The pattern provided to the functions must be a valid record,
and the first element of the provided tuple must be the
<strong>record_name</strong> of the table. The special element <strong>'_'</strong>
matches any data structure in Erlang (also known as an Erlang
term). The special elements <strong>'$&lt;number&gt;'</strong>
behave as Erlang variables, that is, they match anything,
bind the first occurrence, and match the
coming occurrences of that variable against the bound value.</p><p>Use function
<a href="./mnesia#table_info/2">mnesia:table_info(Tab, wild_pattern)</a>
to obtain a basic pattern, which matches all records in a table,
or use the default value in record creation.
Do not make the pattern hard-coded, as this makes the code more
vulnerable to future changes of the record definition.</p><p><em>Example:</em></p><pre><code class="">
      Wildpattern = mnesia:table_info(employee, wild_pattern), 
      %% Or use
      Wildpattern = #employee{_ = '_'},</code></pre><p>For the employee table, the wild pattern looks as follows:</p><pre><code class="">
      {employee, '_', '_', '_', '_', '_',' _'}.</code></pre><p>To constrain the match, it is needed to replace some
of the <strong>'_'</strong> elements. The code for matching out
all female employees looks as follows:</p><pre><code class="">
      Pat = #employee{sex = female, _ = '_'},
      F = fun() -&gt; mnesia:match_object(Pat) end,
      Females = mnesia:transaction(F).</code></pre><p>The match function can also be used to check the equality of
different attributes. For example, to find all employees with
an employee number equal to their room number:</p><pre><code class="">
      Pat = #employee{emp_no = '$1', room_no = '$1', _ = '_'},
      F = fun() -&gt; mnesia:match_object(Pat) end,
      Odd = mnesia:transaction(F).</code></pre><p>The function
<a href="./mnesia#match_object/3">mnesia:match_object/3</a>
lacks some important features that
<a href="./mnesia#select/2">mnesia:select/3</a>
have. For example,
<strong>mnesia:match_object/3</strong> can only return the matching records,
and it cannot express constraints other than equality. To find
the names of the male employees on the second floor:</p><pre><code class="">

      MatchHead = #employee{name='$1', sex=male, room_no={'$2', '_'}, _='_'},
      Guard = [{'&gt;=', '$2', 220},{'&lt;', '$2', 230}],
      Result = '$1',
      mnesia:select(employee,[{MatchHead, Guard, [Result]}])</code></pre><p>The function <strong>select</strong> can be used to add more constraints
and create output that cannot be done with
<strong>mnesia:match_object/3</strong>.</p><p>The second argument to <strong>select</strong> is a <strong>MatchSpecification</strong>.
A <strong>MatchSpecification</strong> is a list of <strong>MatchFunction</strong>s, where
each <strong>MatchFunction</strong> consists of a tuple containing
<strong>{MatchHead, MatchCondition, MatchBody}</strong>:</p><ul><li><strong>MatchHead</strong> is the same pattern as used in <strong>mnesia:match_object/3</strong> described earlier.</li><li><strong>MatchCondition</strong> is a list of extra constraints applied to each record.</li><li><strong>MatchBody</strong> constructs the return values.</li></ul><p>For details about the match specifications, see
"Match Specifications in Erlang" in
<a href="./index">ERTS</a> User's Guide.
For more information, see the
<a href="./ets">ets</a> and
<a href="./dets">dets</a>
manual pages in <strong>STDLIB</strong>.</p><p>The functions
<a href="./mnesia#select/4">select/4</a> and
<a href="./mnesia#select/2">select/1</a>
are used to
get a limited number of results, where <strong>Continuation</strong>
gets the next chunk of results. <strong>Mnesia</strong> uses
<strong>NObjects</strong> as a recommendation only. Thus, more or less
results than specified with <strong>NObjects</strong> can be returned in
the result list, even the empty list can be returned even
if there are more results to collect.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>There is a severe performance penalty in using
<strong>mnesia:select/[1|2|3|4]</strong> after any modifying operation
is done on that table in the same transaction. That is, avoid
using
<a href="./mnesia#write/1">mnesia:write/1</a> or
<a href="./mnesia#delete/1">mnesia:delete/1</a>
before <strong>mnesia:select</strong> in the same transaction.</p></div><p>If the key attribute is bound in a pattern, the match operation
is efficient. However, if the key attribute in a pattern is
given as <strong>'_'</strong> or <strong>'$1'</strong>, the whole <strong>employee</strong>
table must be searched for records that match. Hence if the table is
large, this can become a time-consuming operation, but it can be
remedied with indexes (see
<a href="./Mnesia_chap5#indexing">Indexing</a>)
if the function
<a href="./mnesia#match_object/1">mnesia:match_object</a>
is used.</p><p>QLC queries can also be used to search <strong>Mnesia</strong> tables. By
using the function
<a href="./mnesia#table/1">mnesia:table/[1|2]</a>
as the generator inside a QLC
query, you let the query operate on a <strong>Mnesia</strong> table.
<strong>Mnesia</strong>-specific options to <strong>mnesia:table/2</strong> are
<strong>{lock, Lock}</strong>, <strong>{n_objects,Integer}</strong>, and
<strong>{traverse, SelMethod}</strong>:</p><ul><li><strong>lock</strong> specifies whether <strong>Mnesia</strong> is to acquire a read or write lock on the table.</li><li><strong>n_objects</strong> specifies how many results are to be returned in each chunk to QLC.</li><li><strong>traverse</strong> specifies which function <strong>Mnesia</strong> is to use to traverse the table. Default <strong>select</strong> is used, but by using <strong>{traverse, {select, MatchSpecification}}</strong> as an option to <a href="./mnesia#table/1">mnesia:table/2</a> the user can specify its own view of the table.</li></ul><p>If no options are specified, a read lock is acquired, 100
results are returned in each chunk, and <strong>select</strong> is used
to traverse the table, that is:</p><pre><code class="">
      mnesia:table(Tab) -&gt;
          mnesia:table(Tab, [{n_objects,100},{lock, read}, {traverse, select}]).</code></pre><p>The function
<a href="./mnesia#all_keys/1">mnesia:all_keys(Tab)</a>
returns all keys in a table.</p><h2>Iteration</h2><a name="iteration"></a><p><strong>Mnesia</strong> provides the following functions that iterate over all
the records in a table:</p><pre><code class="">
      mnesia:foldl(Fun, Acc0, Tab) -&gt; NewAcc | transaction abort
      mnesia:foldr(Fun, Acc0, Tab) -&gt; NewAcc | transaction abort
      mnesia:foldl(Fun, Acc0, Tab, LockType) -&gt; NewAcc | transaction abort
      mnesia:foldr(Fun, Acc0, Tab, LockType) -&gt; NewAcc | transaction abort</code></pre><p>These functions iterate over the <strong>Mnesia</strong> table <strong>Tab</strong>
and apply the function <strong>Fun</strong> to each record. <strong>Fun</strong>
takes two arguments, the first is a record from the
table, and the second is the accumulator.
<strong>Fun</strong> returns a new accumulator.</p><p>The first time <strong>Fun</strong> is applied, <strong>Acc0</strong> is
the second argument. The next time <strong>Fun</strong> is called,
the return value from the previous call is used as the
second argument. The term the last call to <strong>Fun</strong> returns
is the return value of the function
<a href="./mnesia#foldl/3">mnesia:foldl/3</a> or
<a href="./mnesia#foldr/3">mnesia:foldr/3</a>.</p><p>The difference between these functions is the
order the table is accessed for <strong>ordered_set</strong> tables.
For other table types the functions are equivalent.</p><p><strong>LockType</strong> specifies what type of lock that is to be
acquired for the iteration, default is <strong>read</strong>. If
records are written or deleted during the iteration, a write
lock is to be acquired.</p><p>These functions can be used to find records in a table
when it is impossible to write constraints for the function
<a href="./mnesia#match_object/3">mnesia:match_object/3</a>,
or when you want to perform some action on certain records.</p><p>For example, finding all the employees who have a salary
less than 10 can look as follows:</p><pre><code class="">
      find_low_salaries() -&gt;
        Constraint = 
             fun(Emp, Acc) when Emp#employee.salary &lt; 10 -&gt;
                    [Emp | Acc];
                (_, Acc) -&gt;
                    Acc
             end,
        Find = fun() -&gt; mnesia:foldl(Constraint, [], employee) end,
        mnesia:transaction(Find).
    </code></pre><p>To raise the salary to 10 for everyone with a salary less than 10
and return the sum of all raises:</p><pre><code class="">
      increase_low_salaries() -&gt;
         Increase = 
             fun(Emp, Acc) when Emp#employee.salary &lt; 10 -&gt;
                    OldS = Emp#employee.salary,
                    ok = mnesia:write(Emp#employee{salary = 10}),
                    Acc + 10 - OldS;
                (_, Acc) -&gt;
                    Acc
             end,
        IncLow = fun() -&gt; mnesia:foldl(Increase, 0, employee, write) end,
        mnesia:transaction(IncLow).
    </code></pre><p>Many nice things can be done with the iterator functions but take
some caution about performance and memory use for large tables.</p><p>Call these iteration functions on nodes that contain a replica of
the table. Each call to the function <strong>Fun</strong> access the table
and if the table resides on another node it generates much
unnecessary network traffic.</p><p><strong>Mnesia</strong> also provides some functions that make it possible
for the user to iterate over the table. The order of the iteration
is unspecified if the table is not of type <strong>ordered_set</strong>:</p><pre><code class="">
      mnesia:first(Tab) -&gt;  Key | transaction abort
      mnesia:last(Tab)  -&gt;  Key | transaction abort
      mnesia:next(Tab,Key)  -&gt;  Key | transaction abort
      mnesia:prev(Tab,Key)  -&gt;  Key | transaction abort
      mnesia:snmp_get_next_index(Tab,Index) -&gt; {ok, NextIndex} | endOfTable</code></pre><p>The order of <strong>first</strong>/<strong>last</strong> and <strong>next</strong>/<strong>prev</strong>
is only valid for
<strong>ordered_set</strong> tables, they are synonyms for other tables.
When the end of the table is reached, the special key
<strong>'$end_of_table'</strong> is returned.</p><p>If records are written and deleted during the traversal, use
the function
<a href="./mnesia#foldl">mnesia:foldl/3</a> or
<a href="./mnesia#foldr">mnesia:foldr/3</a>
with a <strong>write</strong> lock. Or the function
<a href="./mnesia#write_lock_table/1">mnesia:write_lock_table/1</a>
when using <strong>first</strong> and <strong>next</strong>.</p><p>Writing or deleting in transaction context creates a local copy
of each modified record. Thus, modifying each record in a large
table uses much memory. <strong>Mnesia</strong> compensates for every
written or deleted record during the iteration in a transaction
context, which can reduce the performance. If possible, avoid writing
or deleting records in the same transaction before iterating over the
table.</p><p>In dirty context, that is, <strong>sync_dirty</strong> or <strong>async_dirty</strong>,
the modified records are not stored in a local copy; instead,
each record is updated separately. This generates much
network traffic if the table has a replica on another node and
has all the other drawbacks that dirty operations
have. Especially for commands
<a href="./mnesia#first/1">mnesia:first/1</a> and
<a href="./mnesia#next/2">mnesia:next/2</a>,
the same drawbacks as described previously for
<a href="./mnesia#dirty_first/1">mnesia:dirty_first/1</a>
and
<a href="./mnesia#dirty_next/2">mnesia:dirty_next/2</a>
applies, that
is, no writing to the table is to be done during iteration.</p></body></html>