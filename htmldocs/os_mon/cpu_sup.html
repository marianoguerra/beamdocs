<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>cpu_sup</h1><h1>cpu_sup</h1><p>A CPU Load and CPU Utilization Supervisor Process</p><p><strong>cpu_sup</strong> is a process which supervises the CPU load
and CPU utilization. It is part of the OS_Mon application, see
<a href="os_mon_app">os_mon(6)</a>. Available for Unix,
although CPU utilization values (<strong>util/0,1</strong>) are only
available for Solaris, Linux and FreeBSD.The load values are proportional to how long time a runnable
Unix process has to spend in the run queue before it is scheduled.
Accordingly, higher values mean more system load. The returned
value divided by 256 produces the figure displayed by <strong>rup</strong>
and <strong>top</strong>. What is displayed as 2.00 in <strong>rup</strong>, is
displayed as load up to the second mark in <strong>xload</strong>.For example, <strong>rup</strong> displays a load of 128 as 0.50, and
512 as 2.00.If the user wants to view load values as percentage of machine
capacity, then this way of measuring presents a problem, because
the load values are not restricted to a fixed interval. In this
case, the following simple mathematical transformation can
produce the load value as a percentage:<pre><code class="">
      PercentLoad = 100 * (1 - D/(D + Load))
    </code></pre><strong>D</strong> determines which load value should be associated with
which percentage. Choosing <strong>D</strong> = 50 means that 128 is 60% 
load, 256 is 80%, 512 is 90%, and so on.Another way of measuring system load is to divide the number of
busy CPU cycles by the total number of CPU cycles. This produces 
values in the 0-100 range immediately. However, this method hides 
the fact that a machine can be more or less saturated. CPU
utilization is therefore a better name than system load for this
measure.A server which receives just enough requests to never become
idle will score a CPU utilization of 100%. If the server receives
50% more requests, it will still score 100%. When the system load
is calculated with the percentage formula shown previously,
the load will increase from 80% to 87%.The <strong>avg1/0</strong>, <strong>avg5/0</strong>, and <strong>avg15/0</strong> functions
can be used for retrieving system load values, and
the <strong>util/0</strong> and <strong>util/1</strong> functions can be used for
retrieving CPU utilization values.When run on Linux, <strong>cpu_sup</strong> assumes that the <strong>/proc</strong>
file system is present and accessible by <strong>cpu_sup</strong>. If it is
not, <strong>cpu_sup</strong> will terminate.</p><h1>Functions</h1><h2>nprocs() -&gt; UnixProcesses | {error, Reason}</h2><p>Get the number of UNIX processes running on this host</p><ul><li><span class="v">UnixProcesses = int()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Returns the number of UNIX processes running on this machine.
This is a crude way of measuring the system load, but it may
be of interest in some cases.</p><p>Returns 0 if <strong>cpu_sup</strong> is not available.</p><h2>avg1() -&gt; SystemLoad | {error, Reason}</h2><p>Get the system load average for the last minute</p><ul><li><span class="v">SystemLoad = int()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Returns the average system load in the last minute, as
described above. 0 represents no load, 256 represents the load
reported as 1.00 by <strong>rup</strong>.</p><p>Returns 0 if <strong>cpu_sup</strong> is not available.</p><h2>avg5() -&gt; SystemLoad | {error, Reason}</h2><p>Get the system load average for the last five minutes</p><ul><li><span class="v">SystemLoad = int()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Returns the average system load in the last five minutes, as
described above. 0 represents no load, 256 represents the load
reported as 1.00 by <strong>rup</strong>.</p><p>Returns 0 if <strong>cpu_sup</strong> is not available.</p><h2>avg15() -&gt; SystemLoad | {error, Reason}</h2><p>Get the system load average for the last fifteen minutes</p><ul><li><span class="v">SystemLoad = int()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Returns the average system load in the last 15 minutes, as
described above. 0 represents no load, 256 represents the load
reported as 1.00 by <strong>rup</strong>.</p><p>Returns 0 if <strong>cpu_sup</strong> is not available.</p><h2>util() -&gt; CpuUtil | {error, Reason}</h2><p>Get the CPU utilization</p><ul><li><span class="v">CpuUtil = float()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Returns CPU utilization since the last call to
<strong>util/0</strong> or <strong>util/1</strong> by the calling process.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The returned value of the first call to <strong>util/0</strong> or
<strong>util/1</strong> by a process will on most systems be the CPU
utilization since system boot, but this is not guaranteed
and the value should therefore be regarded as garbage. This
also applies to the first call after a restart of
<strong>cpu_sup</strong>.</p></div><p>The CPU utilization is defined as the sum of the percentage
shares of the CPU cycles spent in all busy processor states
(see <strong>util/1</strong> below) in average on all CPUs.</p><p>Returns 0 if <strong>cpu_sup</strong> is not available.</p><h2>util(Opts) -&gt; UtilSpec | {error, Reason}</h2><p>Get the CPU utilization</p><ul><li><span class="v">Opts = [detailed | per_cpu]</span></li><li><span class="v">UtilSpec = UtilDesc | [UtilDesc]</span></li><li><span class="v">Â UtilDesc = {Cpus, Busy, NonBusy, Misc}</span></li><li><span class="v">Â Â Cpus = all | int() | [int()]()</span></li><li><span class="v">Â Â Busy = NonBusy = {State, Share} | Share</span></li><li><span class="v">Â Â Â State = user | nice_user | kernel</span></li><li><span class="v">Â Â Â Â | wait | idle | atom()</span></li><li><span class="v">Â Â Â Share = float()</span></li><li><span class="v">Â Â Misc = []</span></li><li><span class="v">Reason = term()</span></li></ul><p>Returns CPU utilization since the last call to
<strong>util/0</strong> or <strong>util/1</strong> by the calling process, in
more detail than <strong>util/0</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The returned value of the first call to <strong>util/0</strong> or
<strong>util/1</strong> by a process will on most systems be the CPU
utilization since system boot, but this is not guaranteed
and the value should therefore be regarded as garbage. This
also applies to the first call after a restart of
<strong>cpu_sup</strong>.</p></div><p>Currently recognized options:</p><dl><dt><strong>detailed</strong></dt><dd> <p>The returned <strong>UtilDesc</strong>(s) will be even more
detailed.</p> </dd><dt><strong>per_cpu</strong></dt><dd> <p>Each CPU will be specified separately (assuming this
information can be retrieved from the operating system),
that is, a list with one <strong>UtilDesc</strong> per CPU will be
returned.</p> </dd></dl><p>Description of <strong>UtilDesc = {Cpus, Busy, NonBusy, Misc}</strong>:</p><dl><dt><strong>Cpus</strong></dt><dd> <p>If the <strong>detailed</strong> and/or <strong>per_cpu</strong> option is
given, this is the CPU number, or a list of the CPU
numbers.</p> <p>If not, this is the atom <strong>all</strong> which implies that
the <strong>UtilDesc</strong> contains information about all CPUs.</p> </dd><dt><strong>Busy</strong></dt><dd> <p>If the <strong>detailed</strong> option is given, this is a list
of <strong>{State, Share}</strong> tuples, where each tuple
contains information about a processor state that has
been identified as a busy processor state (see below).
The atom <strong>State</strong> is the name of the state, and
the float <strong>Share</strong> represents the percentage share of
the CPU cycles spent in this state since the last call to
<strong>util/0</strong> or <strong>util/1</strong>.</p> <p>If not, this is the sum of the percentage shares of
the CPU cycles spent in all states identified as busy.</p> <p>If the <strong>per_cpu</strong> is not given, the value(s)
presented are the average of all CPUs.</p> </dd><dt><strong>NonBusy</strong></dt><dd> <p>Similar to <strong>Busy</strong>, but for processor states that
have been identified as non-busy (see below).</p> </dd><dt><strong>Misc</strong></dt><dd> <p>Currently unused; reserved for future use.</p> </dd></dl><p>Currently these processor states are identified as busy:</p><dl><dt><strong>user</strong></dt><dd> <p>Executing code in user mode.</p> </dd><dt><strong>nice_user</strong></dt><dd> <p>Executing code in low priority (nice) user mode.
This state is currently only identified on Linux.</p> </dd><dt><strong>kernel</strong></dt><dd> <p>Executing code in kernel mode.</p> </dd></dl><p>Currently these processor states are identified as non-busy:</p><dl><dt><strong>wait</strong></dt><dd> <p>Waiting. This state is currently only identified on
Solaris.</p> </dd><dt><strong>idle</strong></dt><dd> <p>Idle.</p> </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Identified processor states may be different on different
operating systems and may change between different versions
of <strong>cpu_sup</strong> on the same operating system. The sum of
the percentage shares of the CPU cycles spent in all busy
and all non-busy processor states will always add up to
100%, though.</p></div><p>Returns <strong>{all,0,0,[]}</strong> if <strong>cpu_sup</strong> is not
available.</p><h2>See Also</h2><p><a href="os_mon_app">os_mon(3)</a></p></body></html>