<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>The Jinterface Package</h1><p>The <a href="java/com/ericsson/otp/erlang/package-summary">Jinterface</a> package provides 
a set of tools for communication with Erlang processes. It can also be used for communication with 
other Java processes using the same package, as well as C processes using the Erl_Interface library.  </p><p>The set of classes in the package can be divided into two categories:
those that provide the actual communication, and those that provide a
Java representation of the Erlang data types. The latter are all
subclasses of OtpErlangObject, and they are identified by the
OtpErlang prefix.</p><p>Since this package provides a mechanism for communicating with Erlang,
message recipients can be Erlang processes or instances of
com.ericsson.otp.erlang.OtpMbox, both of which are identified with
pids and possibly registered names. When pids or mailboxes are
mentioned as message senders or recipients in this section, it should
assumed that even Erlang processes are included, unless specified
otherwise.
The classes in
<a href="java/com/ericsson/otp/erlang/package-summary">Jinterface</a> support the following:</p><ul><li>manipulation of data represented as Erlang data types</li><li>conversion of data between Java and Erlang formats</li><li>encoding and decoding of Erlang data types for transmission or storage</li><li>communication between Java nodes and Erlang processes</li></ul><p>In the following sections, these topics are described:</p><ul><li>mapping of Erlang types to Java</li><li>encoding, decoding, and sending Erlang terms</li><li>connecting to a distributed Erlang node</li><li>using nodes, mailboxes and EPMD</li><li>sending and receiving Erlang messages and data</li><li>remote procedure calls</li><li>linking to remote processes</li><li>compiling your code for use with Jinterface</li><li>tracing message flow</li></ul><h2>Mapping of Basic Erlang Types to Java</h2><p>This section describes the mapping of Erlang basic types to Java. </p><table class="table table-bordered table-hover table-striped"><caption>Mapping of Erlang basic types to Java</caption><tbody><tr><td>Erlang type</td><td>Java type</td></tr><tr><td>atom</td><td><a href="java/com/ericsson/otp/erlang/OtpErlangAtom">OtpErlangAtom</a></td></tr><tr><td>binary</td><td><a href="java/com/ericsson/otp/erlang/OtpErlangBinary">OtpErlangBinary</a></td></tr><tr><td>floating point types</td><td><a href="java/com/ericsson/otp/erlang/OtpErlangFloat">OtpErlangFloat</a>or <a href="java/com/ericsson/otp/erlang/OtpErlangDouble">OtpErlangDouble</a>, depending on the floating point value size</td></tr><tr><td>integral types</td><td>One of <a href="java/com/ericsson/otp/erlang/OtpErlangByte">OtpErlangByte</a>,<a href="java/com/ericsson/otp/erlang/OtpErlangChar">OtpErlangChar</a>,<a href="java/com/ericsson/otp/erlang/OtpErlangShort">OtpErlangShort</a>,<a href="java/com/ericsson/otp/erlang/OtpErlangUShort">OtpErlangUShort</a>,<a href="java/com/ericsson/otp/erlang/OtpErlangInt">OtpErlangInt</a>,<a href="java/com/ericsson/otp/erlang/OtpErlangUInt">OtpErlangUInt</a>or<a href="java/com/ericsson/otp/erlang/OtpErlangLong">OtpErlangLong</a>, depending on the integral value size and sign</td></tr><tr><td>list</td><td><a href="java/com/ericsson/otp/erlang/OtpErlangList">OtpErlangList</a></td></tr><tr><td>pid</td><td><a href="java/com/ericsson/otp/erlang/OtpErlangPid">OtpErlangPid</a></td></tr><tr><td>port</td><td><a href="java/com/ericsson/otp/erlang/OtpErlangPort">OtpErlangPort</a></td></tr><tr><td>ref</td><td><a href="java/com/ericsson/otp/erlang/OtpErlangRef">OtpErlangRef</a></td></tr><tr><td>tuple</td><td><a href="java/com/ericsson/otp/erlang/OtpErlangTuple">OtpErlangTuple</a></td></tr><tr><td>map</td><td><a href="java/com/ericsson/otp/erlang/OtpErlangMap">OtpErlangMap</a></td></tr><tr><td>term</td><td><a href="java/com/ericsson/otp/erlang/OtpErlangObject">OtpErlangObject</a></td></tr></tbody></table><h2>Special Mapping Issues</h2><p>The atoms <strong>true</strong> and <strong>false</strong> are special atoms, used as boolean values. 
The class <a href="java/com/ericsson/otp/erlang/OtpErlangBoolean">OtpErlangBoolean</a> can be used to represent these.</p><p>Lists in Erlang are also used to describe sequences of printable characters (strings).
A convenience class <a href="java/com/ericsson/otp/erlang/OtpErlangString">OtpErlangString</a>
is provided to represent Erlang strings.</p><h2>Nodes</h2><p>A node as defined by Erlang/OTP is an instance of the Erlang Runtime
System, a virtual machine roughly equivalent to a JVM. Each node has a
unique name in the form of an identifier composed partly of the
hostname on which the node is running, e.g "gurka@sallad.com". Several
such nodes can run on the same host as long as their names are unique.
The class <a href="java/com/ericsson/otp/erlang/OtpNode">OtpNode</a> 
represents an Erlang node. It is created with a name
and optionally a port number on which it listens for incoming
connections. Before creating an instance of 
<a href="java/com/ericsson/otp/erlang/OtpNode">OtpNode</a>, 
ensure that Epmd is running on the host machine. See the Erlang documentation 
for more information about Epmd. In this example, the host name is appended
automatically to the identifier, and the port number is chosen by the
underlying system:</p><pre><code class="">
OtpNode node = new OtpNode("gurka");    </code></pre><h2>Mailboxes</h2><p>Erlang processes running on an Erlang node are identified by process
identifiers (pids) and, optionally, by registered names unique within
the node. Each Erlang process has an implicit mailbox that is used to
receive messages; the mailbox is identified with the pid of the
process.</p><p>Jinterface provides a similar mechanism with the class 
<a href="java/com/ericsson/otp/erlang/OtpMbox">OtpMbox</a>, a
mailbox that can be used to send and receive messages asynchronously.
Each OtpMbox is identified with a unique pid and , optionally, a registered 
name unique within the 
<a href="java/com/ericsson/otp/erlang/OtpNode">OtpNode</a>. </p><p>Applications are free to create mailboxes as necessary. This is done
as follows:</p><pre><code class="">
        OtpMbox mbox = node.createMbox();    </code></pre><p>The mailbox created in the above example has no registered name,
although it does have a pid. The pid can be obtained from the mailbox
and included in messages sent from the mailbox, so that remote
processes are able to respond. </p><p>An application can register a name for a mailbox, either when the
mailbox is initially created:</p><pre><code class="">
        OtpMbox mbox = node.createMbox("server");    </code></pre><p>or later on, as necessary:</p><pre><code class="">
        OtpMbox mbox = node.createMbox();
        mbox.registerName("server");    </code></pre><p>Registered names are usually necessary in order to start
communication, since it is impossible to know in advance the pid of a
remote process. If a well-known name for one of the processes is
chosen in advance and known by all communicating parties within an
application, each mailbox can send an initial message to the named
mailbox, which then can identify the sender pid.</p><h2>Connections</h2><p>It is not necessary to explicitly set up communication with a remote
node. Simply sending a message to a mailbox on that node will cause
the OtpNode to create a connection if one does not already exist. Once
the connection is established, subsequent messages to the same node
will reuse the same connection.</p><p>It is possible to check for the existence of a remote node before
attempting to communicate with it. Here we send a ping message to the
remote node to see if it is alive and accepting connections:</p><pre><code class="">
        if (node.ping("remote",2000)) {
          System.out.println("remote is up");
        }
        else {
          System.out.println("remote is not up");
       }    </code></pre><p>If the call to ping() succeeds, a connection to the remote node has
been established. Note that it is not necessary to ping remote nodes
before communicating with them, but by using ping you can determine if
the remote exists before attempting to communicate with it.</p><p>Connections are only permitted by nodes using the same security
cookie. The cookie is a short string provided either as an argument
when creating OtpNode objects, or found in the user's home directory
in the file <strong>.erlang.cookie</strong>. When a connection attempt is made, the
string is used as part of the authentication process. If you are
having trouble getting communication to work, use the trace facility
(described later in this document) to show the connection
establishment. A likely problem is that the cookies are different.</p><p>Connections are never broken explicitly. If a node fails or is closed,
a connection may be broken however.</p><h2>Transport Factory</h2><p>All necessary connections are made using methods of
<a href="java/com/ericsson/otp/erlang/OtpTransportFactory">OtpTransportFactory</a>
interface. Default OtpTransportFactory implementation is based on standard Socket class.
User may provide custom transport factory as needed. See java doc for details.</p><h2>Sending and Receiving Messages</h2><p>Messages sent with this package must be instances of 
<a href="java/com/ericsson/otp/erlang/OtpErlangObject">OtpErlangObject</a>
or one of its subclasses. Message can be sent to processes or pids,
either by specifying the pid of the remote, or its registered name and
node.</p><p>In this example, we create a message containing our own pid so the
echo process can reply:</p><pre><code class="">
        OtpErlangObject[] msg = new OtpErlangObject[2];
        msg[0] = mbox.self();
        msg[1] = new OtpErlangAtom("hello, world");
        OtpErlangTuple tuple = new OtpErlangTuple(msg);    </code></pre><p>When we send the message, a connection will be created:</p><pre><code class="">
        mbox.send("echo", "gurka@sallad.com", tuple);    </code></pre><p>And here we receive the reply:</p><pre><code class="">
        OtpErlangObject reply = mbox.receive();    </code></pre><p>Messages are sent asynchronously, so the call to <strong>send()</strong> returns as
soon as the message has been dispatched to the underlying
communication layer. This means that you receive no indication whether
the operation completed successfully or the remote even existed. If
you need this kind of confirmation, you should wait for a response
from the remote process.</p><p>The echo server itself might look like this:</p><pre><code class="">
    OtpNode self = new OtpNode("gurka");
    OtpMbox mbox = self.createMbox("echo");
    OtpErlangObject o;
    OtpErlangTuple msg;
    OtpErlangPid from;
    
    while (true) {
      try {
        o = mbox.receive();
        if (o instanceof OtpErlangTuple) {
          msg = (OtpErlangTuple)o;
          from = (OtpErlangPid)(msg.elementAt(0));
          mbox.send(from,msg.elementAt(1));
      }
      catch (Exception e) {
        System.out.println("" + e);
      }
    }    </code></pre><p>In the examples above, only one mailbox was created on each node.
however you are free to create as many mailboxes on each node as you
like. You are also free to create as many nodes as you like on each
JVM, however because each node uses some limited system resources such
as file descriptors, it is recommended that you create only a small
number of nodes (such as one) on each JVM.</p><h2>Sending Arbitrary Data</h2><p>This package was originally intended to be used for communicating
between Java and Erlang, and for that reason the send and receive
methods all use Java representations of Erlang data types. </p><p>However it is possible to use the package to communicate with remote
processes written in Java as well, and in these cases it may be
desirable to send other data types.</p><p>The simplest way to do this is to encapsulate arbitrary data in
messages of type 
<a href="java/com/ericsson/otp/erlang/OtpErlangBinary">OtpErlangBinary</a>. 
The OtpErlangBinary class can be created from arbitrary Java objects that implement the 
Serializable or Externalizable interface:</p><pre><code class="">
        o = new MyClass(foo);
        mbox.send(remote,new OtpErlangBinary(o));    </code></pre><p>The example above will cause the object to be serialized and
encapsulated in an OtpErlangBinary before being sent. The recipient
will receive an OtpErlangBinary but can extract the original object
from it:</p><pre><code class="">
        msg = mbox.receive();
        if (msg instanceof OtpErlangBinary) {
           OtpErlangBinary b = (OtpErlangBinary)msg;
           MyClass o = (MyClass)(b.getObject());
        }    </code></pre><h2>Linking to Remote Processes</h2><p>Erlang defines a concept known as linked processes. A link is an
implicit connection between two processes that causes an exception to
be raised in one of the processes if the other process terminates for
any reason. Links are bidirectional: it does not matter which of the
two processes created the link or which of the linked processes
eventually terminates; an exception will be raised in the remaining
process. Links are also idempotent: at most one link can exist between
two given processes, only one operation is necessary to remove the
link.</p><p>Jinterface provides a similar mechanism. Also here, no distinction is
made between mailboxes and Erlang processes. A link can be created to
a remote mailbox or process when its pid is known:</p><pre><code class="">
        mbox.link(remote);    </code></pre><p>The link can be removed by either of the processes in a similar manner:</p><pre><code class="">
        mbox.unlink(remote);    </code></pre><p>If the remote process terminates while the link is still in place, an
exception will be raised on a subsequent call to receive():</p><pre><code class="">
        try {
          msg = mbox.receive();
        }
        catch (OtpErlangExit e) {
          System.out.println("Remote pid " + e.pid() + " has terminated");
        }
        catch (OtpErlangDecodeException f) {
          System.out.println("Received message could not be decoded: " + f);
        }    </code></pre><p>When a mailbox is explicitly closed, exit messages will be sent in
order to break any outstanding links. If a mailbox is never closed but
instead goes out of scope, the objects <strong>finalize()</strong> method will call
<strong>close()</strong>. However since Java provides no guarantees about when or even
if finalize() will be called, it is important that your application
explicitly closes mailboxes when they are no longer needed if you
want links to work in a timely manner. 
</p><h2>Using EPMD</h2><p>Epmd is the Erlang Port Mapper Daemon. Distributed Erlang nodes
register with epmd on the localhost to indicate to other nodes that
they exist and can accept connections. Epmd maintains a register of
node and port number information, and when a node wishes to connect to
another node, it first contacts epmd in order to find out the correct
port number to connect to.</p><p>The basic interaction with EPMD is done through instances of 
<a href="java/com/ericsson/otp/erlang/OtpEpmd">OtpEpmd</a> class.
Nodes wishing to contact other nodes must first request information 
from Epmd before a connection can be set up, however this is done automatically 
by <a href="./java/com/ericsson/otp/erlang/OtpSelf#connect-com.ericsson.otp.erlang.OtpPeer-">OtpSelf.connect()</a> when necessary. </p><p>When you use <a href="./java/com/ericsson/otp/erlang/OtpSelf#connect-com.ericsson.otp.erlang.OtpPeer-">OtpSelf.connect()</a> to connect to an Erlang node, 
a connection is first made to epmd and, if the node is known, a
connection is then made to the Erlang node.</p><p>Java nodes can also register themselves with epmd if they want other
nodes in the system to be able to find and connect to them.
This is done by call to method <a href="./java/com/ericsson/otp/erlang/OtpEpmd#publishPort-com.ericsson.otp.erlang.OtpLocalNode-">OtpEpmd.publishPort()</a>.</p><p>Be aware that on some systems (such as VxWorks), a failed node will
not be detected by this mechanism since the operating system does not
automatically close descriptors that were left open when the node
failed. If a node has failed in this way, epmd will prevent you from
registering a new node with the old name, since it thinks that the old
name is still in use. In this case, you must unregister the name
explicitly, by using <a href="./java/com/ericsson/otp/erlang/OtpEpmd#unPublishPort-com.ericsson.otp.erlang.OtpLocalNode-">OtpEpmd.unPublishPort()</a></p><p>This will cause epmd to close the connection from the far end. Note
that if the name was in fact still in use by a node, the results of
this operation are unpredictable. Also, doing this does not cause the
local end of the connection to close, so resources may be consumed.</p><h2>Remote Procedure Calls</h2><p>An Erlang node acting as a client to another Erlang node
typically sends a request and waits for a reply. Such a request is
included in a function call at a remote node and is called a remote
procedure call. Remote procedure calls are supported through the class
<a href="java/com/ericsson/otp/erlang/OtpConnection">OtpConnection</a>.
The following example shows how the
<a href="java/com/ericsson/otp/erlang/OtpConnection">OtpConnection</a> 
class is used for remote procedure calls:</p><pre><code class="">

OtpSelf self = new OtpSelf("client", "hejsan" ); 
OtpPeer other  = new OtpPeer("server@balin"); 
OtpConnection connection = self.connect(other); 

connection.sendRPC("erlang","date",new OtpErlangList());
OtpErlangObject received = connection.receiveRPC(); 
    </code></pre><p><strong>erlang:date/0</strong> is just called to get the date tuple
from a remote host. </p><h2>Compiling and Loading Your Code</h2><p>In order to use any of the <a href="java/com/ericsson/otp/erlang/package-summary">Jinterface</a> 
classes, include the following line in your code:</p><pre><code class="">
import com.ericsson.otp.erlang.*;    </code></pre><p>Determine where the top directory of your OTP installation is. You
can find this out by starting Erlang and entering the following
command at the Eshell prompt:</p><pre><code class="">
Eshell V4.9.1.2  (abort with ^G)
1&gt; code:root_dir().
/usr/local/otp    </code></pre><p>To compile your code, make sure that your Java compiler knows where
to find the file <strong>OtpErlang.jar</strong> which contains the package.
This is done by specifying an appropriate <strong>-classpath</strong>
argument on the command line, or by adding it to the <strong>CLASSPATH</strong>
definition in your <strong>Makefile</strong>. The correct value for this path is
<strong>$OTPROOT/lib/jinterface</strong><em>Vsn</em><strong>/priv/OtpErlang.jar</strong>, where <strong>$OTPROOT</strong> 
is the path reported by <strong>code:root_dir/0</strong> in the above example and <em>Vsn</em> is the version of Jinterface, for example <strong>jinterface-1.2</strong></p><pre><code class="">
$ javac -classpath ".:/usr/local/otp/lib/jinterface-1.2/priv/OtpErlang.jar" 
                    myclass.java    </code></pre><p>When running your program, you will also need to specify the path to
<strong>OtpErlang.jar</strong> in a similar way.</p><pre><code class="">
$ java ".:/usr/local/otp/lib/jinterface-1.2/priv/OtpErlang.jar" myclass    </code></pre><h2>Tracing</h2><p>Communication between nodes can be traced by setting a system property
before the communication classes in this package are initialized. 
The value system property "OtpConnection.trace" is the default trace
level for all connections. Normally the default trace level is zero,
i.e. no tracing is performed. By setting 
<a href="java/com/ericsson/otp/erlang/OtpConnection">OtpConnection.trace</a> 
to some non-zero value, the communication protocol can be shown in more or
less detail. The valid values are:</p><ul><li>0: no tracing is performed</li><li>1: only ordinary send and reg-send messages are shown</li><li>2: control messages such as link, unlink and exit are shown</li><li>3: connection setup (handshake) is shown</li><li>4: epmd requests are shown</li></ul><p>Each level also includes the information shown by all lower levels.</p></body></html>