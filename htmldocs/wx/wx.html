<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>wx</h1><h1>wx</h1><p>A port of wxWidgets.</p><p>A port of <a href="http://www.wxwidgets.org/">wxWidgets</a>.This is the base api of <a href="http://www.wxwidgets.org/">wxWidgets</a>.  
This module contains functions for  
starting and stopping the wx-server, as well as  other utility functions.wxWidgets is object oriented, and not functional. Thus, in wxErlang a  
module represents a class, and the object created by this class  
has an own type, wxCLASS().  This module represents the base  
class, and all other wxMODULE's are sub-classes of this class.Objects of a class are created with wxCLASS:new(...) and destroyed with  
wxCLASS:destroy(). Member functions are called with wxCLASS:member(Object, ...)  
instead of as in C++ Object.member(...).Sub class modules inherit (non static) functions from their parents.  
The inherited functions are not documented in the sub-classes.This erlang port of wxWidgets tries to be a one-to-one mapping with
the original wxWidgets library. Some things are different though,
as the optional arguments use property lists and can be in any
order. The main difference is the event handling which is different
from the original library. See <a href="wxEvtHandler">wxEvtHandler</a>.The following classes are implemented directly as erlang types: <br/>
wxPoint={x,y},wxSize={w,h},wxRect={x,y,w,h},wxColour={r,g,b [,a]},
wxString=<a href="../stdlib/unicode#type-chardata">unicode:chardata()</a>,  
wxGBPosition={r,c},wxGBSpan={rs,cs},wxGridCellCoords={r,c}.wxWidgets uses a process specific environment, which is created by
<a href="./wx#new-0">wx:new/0</a>.  To be able to use the environment from other
processes, call <a href="#get_env-0">get_env/0</a> to retrieve the environment and
<a href="#set_env-1">set_env/1</a> to assign the environment in the other process.Global (classless) functions are located in the wx_misc module.</p><h2>DATA TYPES</h2><a name="types"></a><dl><dt><a name="type-wx_colour"></a>wx_colour() = {R::byte(), G::byte(), B::byte()} | <a href="#type-wx_colour4">wx_colour4()</a></dt><dd> </dd><dt><a name="type-wx_colour4"></a>wx_colour4() = {R::byte(), G::byte(), B::byte(), A::byte()}</dt><dd> </dd><dt><a name="type-wx_datetime"></a>wx_datetime() = {{Year::integer(), Month::integer(), Day::integer()}, {Hour::integer(), Minute::integer(), Second::integer()}}</dt><dd> <p>  In Local Timezone</p> </dd><dt><a name="type-wx_enum"></a>wx_enum() = integer()</dt><dd> <p>  Constant defined in wx.hrl</p> </dd><dt><a name="type-wx_env"></a>wx_env() = #wx_env{}</dt><dd> <p>  Opaque process environment</p> </dd><dt><a name="type-wx_memory"></a>wx_memory() = binary() | #wx_mem{}</dt><dd> <p>  Opaque memory reference</p> </dd><dt><a name="type-wx_object"></a>wx_object() = #wx_ref{}</dt><dd> <p>  Opaque object reference</p> </dd><dt><a name="type-wx_wxHtmlLinkInfo"></a>wx_wxHtmlLinkInfo() = #wxHtmlLinkInfo{href=<a href="./unicode#type-chardata">unicode:chardata()</a>, target=<a href="./unicode#type-chardata">unicode:chardata()</a>}</dt><dd> </dd><dt><a name="type-wx_wxMouseState"></a>wx_wxMouseState() = #wxMouseState{x=integer(), y=integer(), leftDown=boolean(), middleDown=boolean(), rightDown=boolean(), controlDown=boolean(), shiftDown=boolean(), altDown=boolean(), metaDown=boolean(), cmdDown=boolean()}</dt><dd> <p>  See #wxMouseState{} defined in wx.hrl</p> </dd></dl><h1>Functions</h1><h2>parent_class(X1) -&gt; term()
</h2><p> </p><a name="parent_class-1"></a><h2>new() -&gt;</h2><p>Starts a wx server.</p><a name="new-0"></a><p>Starts a wx server.</p><h2>new(Options::[Option]) -&gt;</h2><p>Starts a wx server.</p><ul><li><span class="v">Option = {debug, list() | atom()} | {silent_start, boolean()}</span></li></ul><a name="new-1"></a><p>Starts a wx server.
Option may be {debug, Level}, see debug/1.
Or {silent_start, Bool}, which causes error messages at startup to
be suppressed. The latter can be used as a silent test of whether
wx is properly installed or not.</p><h2>destroy() -&gt; ok</h2><p>Stops a wx server.</p><a name="destroy-0"></a><p>Stops a wx server.</p><h2>get_env() -&gt;</h2><p>Gets this process's current wx environment.</p><a name="get_env-0"></a><p>Gets this process's current wx environment.
Can be sent to other processes to allow them use this process wx environment.</p><p><em>See also:</em> <a href="#set_env-1">set_env/1</a>.</p><h2>set_env(Wx_env::) -&gt; ok</h2><p>Sets the process wx environment, allows this process to use another process wx environment.</p><a name="set_env-1"></a><p>Sets the process wx environment, allows this process to use
another process wx environment.</p><h2>null() -&gt;</h2><p>Returns the null object.</p><a name="null-0"></a><p>Returns the null object</p><h2>is_null(Wx_ref::) -&gt; boolean()</h2><p>Returns true if object is null, false otherwise.</p><a name="is_null-1"></a><p>Returns true if object is null, false otherwise</p><h2>equal(Wx_ref::, X2::) -&gt; boolean()</h2><p>Returns true if both arguments references the same object, false otherwise.</p><a name="equal-2"></a><p>Returns true if both arguments references the same object, false otherwise</p><h2>getObjectType(Wx_ref::) -&gt; atom()</h2><p>Returns the object type.</p><a name="getObjectType-1"></a><p>Returns the object type</p><h2>typeCast(Old::, NewType::atom()) -&gt;</h2><p>Casts the object to class NewType.</p><a name="typeCast-2"></a><p>Casts the object to class NewType.
It is needed when using functions like wxWindow:findWindow/2, which
returns a generic wxObject type.</p><h2>batch(Fun::function()) -&gt; term()</h2><p>Batches all wx commands used in the fun.</p><a name="batch-1"></a><p>Batches all <strong>wx</strong> commands
used in the fun.  Improves performance of the command processing by
grabbing the wxWidgets thread so that no event processing will be
done before the complete batch of commands is invoked.
</p><p><em>See also:</em> <a href="#foldl-3">foldl/3</a>, <a href="#foldr-3">foldr/3</a>, <a href="#foreach-2">foreach/2</a>, <a href="#map-2">map/2</a>.</p><h2>foreach(Fun::function(), List::list()) -&gt; ok</h2><p>Behaves like //stdlib/lists:foreach/2 but batches wx commands.</p><a name="foreach-2"></a><p>Behaves like <a href="../stdlib/lists#foreach/2">lists:foreach/2</a> but batches wx commands. See <a href="#batch-1">batch/1</a>.</p><h2>map(Fun::function(), List::list()) -&gt; list()</h2><p>Behaves like //stdlib/lists:map/2 but batches wx commands.</p><a name="map-2"></a><p>Behaves like <a href="../stdlib/lists#map/2">lists:map/2</a> but batches wx commands. See <a href="#batch-1">batch/1</a>.</p><h2>foldl(Fun::function(), Acc::term(), List::list()) -&gt; term()</h2><p>Behaves like //stdlib/lists:foldl/3 but batches wx commands.</p><a name="foldl-3"></a><p>Behaves like <a href="../stdlib/lists#foldl/3">lists:foldl/3</a> but batches wx commands. See <a href="#batch-1">batch/1</a>.</p><h2>foldr(Fun::function(), Acc::term(), List::list()) -&gt; term()</h2><p>Behaves like //stdlib/lists:foldr/3 but batches wx commands.</p><a name="foldr-3"></a><p>Behaves like <a href="../stdlib/lists#foldr/3">lists:foldr/3</a> but batches wx commands. See <a href="#batch-1">batch/1</a>.</p><h2>create_memory(Size::integer()) -&gt;</h2><p>Creates a memory area (of Size in bytes) which can be used by an external library (i.e.</p><a name="create_memory-1"></a><p>Creates a memory area (of Size in bytes) which can be used by an external library (i.e. opengl).  
It is up to the client to keep a reference to this object so it does  
not get garbage collected by erlang while still in use by the external  
library.</p><p>This is far from erlang's intentional usage and can crash the erlang emulator.
Use it carefully.</p><h2>get_memory_bin(Wx_mem::) -&gt; binary()</h2><p>Returns the memory area as a binary.</p><a name="get_memory_bin-1"></a><p>Returns the memory area as a binary.</p><h2>retain_memory(Wx_mem::) -&gt; ok</h2><p>Saves the memory from deletion until release_memory/1 is called.</p><a name="retain_memory-1"></a><p>Saves the memory from deletion until release_memory/1 is called.
If release_memory/1 is not called the memory will not be garbage collected.</p><h2>release_memory(Wx_mem::) -&gt; ok</h2><p> </p><a name="release_memory-1"></a><h2>debug(Debug::Level | [Level]) -&gt; ok</h2><p>Sets debug level.</p><ul><li><span class="v">Level = none | verbose | trace | driver | integer()</span></li></ul><a name="debug-1"></a><p>Sets debug level. If debug level is 'verbose' or 'trace'
each call is printed on console. If Level is 'driver' each allocated
object and deletion is printed on the console.</p><h2>demo() -&gt; ok | {error, atom()}</h2><p>Starts a wxErlang demo if examples directory exists and is compiled.</p><a name="demo-0"></a><p>Starts a wxErlang demo if examples directory exists and is compiled</p><h1>Authors</h1></body></html>