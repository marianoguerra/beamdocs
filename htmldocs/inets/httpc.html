<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>httpc</h1><h1>httpc</h1><p>An HTTP/1.1 client</p><p>This module provides the API to an HTTP/1.1 compatible client according 
to <a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>. 
Caching is not supported.Some examples are provided in the <a href="http_client">Inets User's Guide</a>.</p><h2>DATA TYPES</h2><a name="DATA_TYPES"></a><p>Type definitions that are used more than once in
this module:</p><p><strong>boolean() = true | false</strong></p><p><strong>string()</strong> = list of ASCII characters</p><p><strong>request_id() = reference()</strong></p><p><strong>profile() = atom()</strong></p><p><strong>path() = string()</strong> representing a file path or directory path</p><p><strong>ip_address()</strong> = See the
<a href="./inet">inet(3)</a> manual page in Kernel.</p><p><strong>socket_opt()</strong> = See the options used by
<a href="./gen_tcp">gen_tcp(3)</a> <strong>gen_tcp(3)</strong> and 
<a href="./ssl">ssl(3)</a> connect(s)</p><h2>HTTP DATA TYPES</h2><p>Type definitions related to HTTP:</p><p><strong>method() = head | get | put | post | trace | options | delete | patch</strong></p><dl><dt><strong>request()</strong></dt><dd><p>= <strong>{url(), headers()}</strong></p> <p>| <strong>{url(), headers(), content_type(), body()}</strong></p> </dd></dl><p><strong>url() = string()</strong> syntax according to the URI definition in
<a href="http://www.ietf.org/rfc/rfc2396.txt">RFC 2396</a>, 
for example <strong>"http://www.erlang.org"</strong></p><p><strong>status_line() = {http_version(), status_code(), reason_phrase()}</strong></p><p><strong>http_version() = string()</strong>, for example, <strong>"HTTP/1.1"</strong></p><p><strong>status_code() = integer()</strong></p><p><strong>reason_phrase() = string()</strong></p><p><strong>content_type() = string()</strong></p><p><strong>headers() = [header()]</strong></p><p><strong>header() = {field(), value()}</strong></p><p><strong>field() = string()</strong></p><p><strong>value() = string()</strong></p><dl><dt><strong>body()</strong></dt><dd><p>= <strong>string() | binary()</strong></p> <p>| <strong>{fun(accumulator())</strong></p> <p><strong> -&gt; body_processing_result(), accumulator()}</strong></p> <p>| <strong>{chunkify, fun(accumulator())</strong></p> <p><strong> -&gt; body_processing_result(), accumulator()}</strong></p> </dd></dl><p><strong>body_processing_result() = eof | {ok, iolist(), accumulator()}</strong></p><p><strong>accumulator() = term()</strong></p><p><strong>filename() = string()</strong></p><p>For more information about HTTP, see
<a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>.</p><h2>SSL DATA TYPES</h2><p>See <a href="./ssl">ssl(3)</a> for information
about <strong>SSL</strong> options (<strong>ssloptions()</strong>). </p><h2>HTTP CLIENT SERVICE START/STOP</h2><p>An HTTP client can be configured to start when starting the <strong>Inets</strong>
application or started dynamically in runtime by calling the
<strong>Inets</strong> application API <strong>inets:start(httpc, ServiceConfig)</strong>
or <strong>inets:start(httpc,  ServiceConfig, How)</strong>,
see <a href="inets">inets(3)</a>.
The configuration options are as follows:</p><dl><dt>{profile, profile()}</dt><dd><p>Name of the profile, see
<a href="#DATA_TYPES">DATA TYPES</a>.
This option is mandatory.</p></dd><dt>{data_dir, path()}</dt><dd><p>Directory where the profile
can save persistent data. If omitted, all cookies are treated
as session cookies.</p></dd></dl><p>The client can be stopped using <strong>inets:stop(httpc, Pid)</strong> or
<strong>inets:stop(httpc, Profile)</strong>.</p><h1>Functions</h1><h2>cancel_request(RequestId) -&gt;</h2><h2>cancel_request(RequestId, Profile) -&gt; ok</h2><p>Cancels an asynchronous HTTP request.</p><ul><li><span class="v">RequestId = request_id() - A unique identifier as returned by request/4</span></li><li><span class="v">Profile = profile() | pid()</span></li><li><span class="d">When started stand_alone only the pid can be used.</span></li></ul><p>Cancels an asynchronous HTTP request. Notice that this does not guarantee
that the request response is not delivered. Because it is asynchronous,
the request can already have been completed when the cancellation arrives.
</p><h2>cookie_header(Url) -&gt;</h2><h2>cookie_header(Url, Profile | Opts) -&gt; header() | {error, Reason}</h2><h2>cookie_header(Url, Opts, Profile) -&gt; header() | {error, Reason}</h2><p>Returns the cookie header that would have been sent when making a request to URL using the profile <strong>Profile</strong>.</p><ul><li><span class="v">Url = url()</span></li><li><span class="v">Opts = [cookie_header_opt()]</span></li><li><span class="v">Profile = profile() | pid()</span></li><li><span class="d">When started stand_alone.</span></li><li><span class="v">cookie_header_opt() = {ipv6_host_with_brackets, boolean()}</span></li></ul><p>Returns the cookie header that would have been sent
when making a request to <strong>Url</strong> using profile <strong>Profile</strong>.
If no profile is specified, the default profile is used.</p><p>Option <strong>ipv6_host_with_bracket</strong> deals with how to 
parse IPv6 addresses. For details,
see argument <strong>Options</strong> of
<a href="#request-4">request/[4,5]</a>.</p><h2>get_options(OptionItems) -&gt; {ok, Values} | {error, Reason}</h2><h2>get_options(OptionItems, Profile) -&gt; {ok, Values} | {error, Reason}</h2><p>Gets the currently used options.</p><ul><li><span class="v">OptionItems = all | [option_item()]</span></li><li><span class="v">option_item() = proxy | https_proxy | max_sessions |  keep_alive_timeout |  max_keep_alive_length |  pipeline_timeout |  max_pipeline_length |  cookies |  ipfamily |  ip |  port |  socket_opts |  verbose | unix_socket</span></li><li><span class="v">Profile = profile() | pid()</span></li><li><span class="d">When started stand_alone only the pid can used.</span></li><li><span class="v">Values = [{option_item(), term()}]</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retrieves the options currently used by the client.</p><h2>info() -&gt; list()</h2><h2>info(Profile) -&gt; list()</h2><p>Produces a list of miscellaneous information.</p><ul><li><span class="v">Profile = profile() | pid()</span></li><li><span class="d">When started stand_alone only the pid can be used.</span></li></ul><p>Produces a list of miscellaneous information. 
Intended for debugging. 
If no profile is specified, the default profile is used.</p><h2>reset_cookies() -&gt; void()</h2><h2>reset_cookies(Profile) -&gt; void()</h2><p>Resets the cookie database.</p><ul><li><span class="v">Profile = profile() | pid()</span></li><li><span class="d">When started stand_alone only the pid can be used.</span></li></ul><p>Resets (clears) the cookie database for the specified 
<strong>Profile</strong>. If no profile is specified the default profile 
is used.</p><h2>request(Url) -&gt;</h2><h2>request(Url, Profile) -&gt; {ok, Result} | {error, Reason}</h2><p>Sends a get HTTP request.</p><ul><li><span class="v">Url = url()</span></li><li><span class="v">Result = {status_line(), headers(), Body} |  {status_code(), Body} | request_id()</span></li><li><span class="v">Body = string() | binary()</span></li><li><span class="v">Profile = profile() | pid()</span></li><li><span class="d">When started stand_alone only the pid can be used.</span></li><li><span class="v">Reason = term()</span></li></ul><p>Equivalent to <strong>httpc:request(get, {Url, []}, [], [])</strong>.</p><h2>request(Method, Request, HTTPOptions, Options) -&gt;</h2><h2>request(Method, Request, HTTPOptions, Options, Profile) -&gt; {ok, Result} | {ok, saved_to_file} | {error, Reason}</h2><p>Sends an HTTP request.</p><ul><li><span class="v">Method = method()</span></li><li><span class="v">Request = request()</span></li><li><span class="v">HTTPOptions = http_options()</span></li><li><span class="v">http_options() = [http_option()]</span></li><li><span class="v">http_option() = {timeout,         timeout()} |  {connect_timeout, timeout()} |  {ssl,             ssloptions()} |  {essl,            ssloptions()} |  {autoredirect,    boolean()} |  {proxy_auth, {userstring(), passwordstring()}} |  {version,         http_version()} |  {relaxed,         boolean()}</span></li><li><span class="v">timeout() = integer() &gt;= 0 | infinity</span></li><li><span class="v">Options = options()</span></li><li><span class="v">options() = [option()]</span></li><li><span class="v">option() = {sync,                    boolean()} |  {stream,                  stream_to()} |  {body_format,             body_format()} |  {full_result,             boolean()} |  {headers_as_is,           boolean() | {socket_opts,             socket_opts()} |  {receiver,                receiver()} | {ipv6_host_with_brackets, boolean()}</span></li><li><span class="v">stream_to() = none | self | {self, once} | filename()</span></li><li><span class="v">socket_opts() = [socket_opt()]</span></li><li><span class="v">receiver() = pid() | function()/1 | {Module, Function, Args}</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Function = atom()</span></li><li><span class="v">Args = list()</span></li><li><span class="v">body_format() = string | binary</span></li><li><span class="v">Result = {status_line(), headers(), Body} |  {status_code(), Body} | request_id()</span></li><li><span class="v">Body = string() | binary()</span></li><li><span class="v">Profile = profile() | pid()</span></li><li><span class="d">When started stand_alone only the pid can be used.</span></li><li><span class="v">Reason = term()</span></li></ul><p>Sends an HTTP request. The function can be both synchronous
and asynchronous. In the latter case, the function returns
<strong>{ok, RequestId}</strong> and then the information is delivered
to the <strong>receiver</strong> depending on that value.</p><p>HTTP option (<strong>http_option()</strong>) details:</p><a name="request2_http_options"></a><dl><dt><strong>timeout</strong></dt><dd> <p>Time-out time for the request.</p> <p>The clock starts ticking when the request is sent.</p> <p>Time is in milliseconds.</p> <p>Default is <strong>infinity</strong>.</p> </dd><dt><strong>connect_timeout</strong></dt><dd> <p>Connection time-out time, used during the initial request, 
when the client is <em>connecting</em> to the server.</p> <p>Time is in milliseconds.</p> <p>Default is the value of option <strong>timeout</strong>.</p> </dd><dt><strong>ssl</strong></dt><dd> <p>This is the <strong>SSL/TLS</strong> connectin configuration option.</p> <p>Defaults to <strong>[]</strong>. See <a href="./ssl">ssl:connect/[2,3,4]</a>  for available options.</p> </dd><dt><strong>autoredirect</strong></dt><dd> <p>The client automatically retrieves the information
from the new URI and returns that as the result, instead 
of a 30X-result code.</p> <p>For some 30X-result codes, automatic redirect 
is not allowed. In these cases the 30X-result is always
returned.</p> <p>Default is <strong>true</strong>.</p> </dd><dt><strong>proxy_auth</strong></dt><dd> <p>A proxy-authorization header using the provided username and 
password is added to the request.</p> </dd><dt><strong>version</strong></dt><dd> <p>Can be used to make the client act as an <strong>HTTP/1.0</strong> or
<strong>HTTP/0.9</strong> client. By default this is an <strong>HTTP/1.1</strong> 
client. When using <strong>HTTP/1.0</strong> persistent connections are 
not used.</p> <p>Default is the string <strong>"HTTP/1.1"</strong>.</p> </dd><dt><strong>relaxed</strong></dt><dd> <p>If set to <strong>true</strong>, workarounds for known server deviations 
from the HTTP-standard are enabled.</p> <p>Default is <strong>false</strong>.</p> </dd></dl><p>Option (<strong>option()</strong>) details:</p><dl><dt><strong>sync</strong></dt><dd> <p>Option for the request to be synchronous or asynchronous.</p> <p>Default is <strong>true</strong>.</p> </dd><dt><strong>stream</strong></dt><dd> <p>Streams the body of a 200 or 206 response to the calling 
process or to a file. When streaming to the calling process 
using option <strong>self</strong>, the following stream messages
are sent to that process: <strong>{http, {RequestId, stream_start, Headers}}, {http, {RequestId, stream, BinBodyPart}}, and {http, {RequestId, stream_end, Headers}}</strong>.</p> <p>When streaming to the calling processes using option
<strong>{self, once}</strong>, the first message has an extra
element, that is, <strong>{http, {RequestId, stream_start, Headers, Pid}}</strong>.
This is the process id to be used as an argument to
<strong>httpc:stream_next/1</strong> to trigger the next message to be sent to
the calling process.</p> <p>Notice that chunked encoding can add
headers so that there are more headers in the <strong>stream_end</strong>
message than in <strong>stream_start</strong>.
When streaming to a file and the request is asynchronous, the
message <strong>{http, {RequestId, saved_to_file}}</strong> is sent.</p> <p>Default is <strong>none</strong>.</p> </dd><dt><strong>body_format</strong></dt><dd> <p>Defines if the body is to be delivered as a string or 
binary. This option is only valid for the synchronous 
request.</p> <p>Default is <strong>string</strong>.</p> </dd><dt><strong>full_result</strong></dt><dd> <p>Defines if a "full result" is to be returned to the caller (that is,
the body, the headers, and the entire status line) or not 
(the body and the status code).</p> <p>Default is <strong>true</strong>.</p> </dd><dt><strong>headers_as_is</strong></dt><dd> <p>Defines if the headers provided by the user are to be made 
lower case or to be regarded as case sensitive.</p> <p>The HTTP standard requires them to be 
case insensitive. Use this feature only if there is 
no other way to communicate with the server or for testing 
purpose. When this option is used, no headers 
are automatically added. All necessary headers must be
provided by the user.</p> <p>Default is <strong>false</strong>.</p> </dd><dt><strong>socket_opts</strong></dt><dd> <p>Socket options to be used for this request.</p> <p>Overrides any value set by function
<a href="#set_options-1">set_options</a>.</p> <p>The validity of the options is <em>not</em> checked by
the HTTP client they are assumed to be correct and passed
on to ssl application and inet driver, which may reject
them if they are not correct.
</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Persistent connections are not supported when setting the
<strong>socket_opts</strong> option. When <strong>socket_opts</strong> is not
set the current implementation assumes the requests to the
same host, port combination will use the same socket options.
</p></div> <p>By default the socket options set by function
<a href="#set_options-1">set_options/[1,2]</a> 
are used when establishing a connection.</p> </dd><dt><strong>receiver</strong></dt><dd> <p>Defines how the client delivers the result of an
asynchronous request (<strong>sync</strong> has the value 
<strong>false</strong>).</p> <dl><dt><strong>pid()</strong></dt><dd> <p>Messages are sent to this process in the format 
<strong>{http, ReplyInfo}</strong>.</p> </dd><dt><strong>function/1</strong></dt><dd> <p>Information is delivered to the receiver through calls 
to the provided fun <strong>Receiver(ReplyInfo)</strong>.</p> </dd><dt><strong>{Module, Function, Args}</strong></dt><dd> <p>Information is delivered to the receiver through calls 
to the callback function 
<strong>apply(Module, Function, [ReplyInfo | Args])</strong>.</p> </dd></dl> <p>In all of these cases, <strong>ReplyInfo</strong> has the following
structure:</p> <pre>
{RequestId, saved_to_file}
{RequestId, {error, Reason}}
{RequestId, Result}
{RequestId, stream_start, Headers}
{RequestId, stream_start, Headers, HandlerPid}
{RequestId, stream, BinBodyPart}
{RequestId, stream_end, Headers}</pre> <p>Default is the <strong>pid</strong> of the process calling the request 
function (<strong>self()</strong>). </p> <a name="ipv6_host_with_brackets"></a> </dd><dt><strong>ipv6_host_with_brackets</strong></dt><dd> <p>Defines when parsing the Host-Port part of an URI with an IPv6 address 
with brackets, if those brackets are to be retained (<strong>true</strong>) 
or stripped (<strong>false</strong>).</p> <p>Default is <strong>false</strong>.</p> </dd></dl><h2>set_options(Options) -&gt;</h2><h2>set_options(Options, Profile) -&gt; ok | {error, Reason}</h2><p>Sets options to be used for subsequent requests.</p><ul><li><span class="v">Options = [Option]</span></li><li><span class="v">Option = {proxy, {Proxy, NoProxy}}</span></li><li><span class="v">| {https_proxy, {Proxy, NoProxy}}</span></li><li><span class="v">| {max_sessions, MaxSessions}</span></li><li><span class="v">| {max_keep_alive_length, MaxKeepAlive}</span></li><li><span class="v">| {keep_alive_timeout, KeepAliveTimeout}</span></li><li><span class="v">| {max_pipeline_length, MaxPipeline}</span></li><li><span class="v">| {pipeline_timeout, PipelineTimeout}</span></li><li><span class="v">| {cookies, CookieMode}</span></li><li><span class="v">| {ipfamily, IpFamily}</span></li><li><span class="v">| {ip, IpAddress}</span></li><li><span class="v">| {port, Port}</span></li><li><span class="v">| {socket_opts, socket_opts()}</span></li><li><span class="v">| {verbose, VerboseMode}</span></li><li><span class="v">| {unix_socket, UnixSocket}</span></li><li><span class="v">Proxy = {Hostname, Port}</span></li><li><span class="v">Hostname = string()</span></li><li><span class="d">Example: "localhost" or "foo.bar.se"</span></li><li><span class="v">Port = integer()</span></li><li><span class="d">Example: 8080</span></li><li><span class="v">NoProxy = [NoProxyDesc]</span></li><li><span class="v">NoProxyDesc = DomainDesc | HostName | IPDesc</span></li><li><span class="v">DomainDesc = "*.Domain"</span></li><li><span class="d">Example: "*.ericsson.se"</span></li><li><span class="v">IpDesc = string()</span></li><li><span class="d">Example: "134.138" or "[FEDC:BA98"  (all IP addresses starting with 134.138 or FEDC:BA98),  "66.35.250.150" or "[2010:836B:4179::836B:4179]" (a complete IP address).  proxy defaults to {undefined, []},  that is, no proxy is configured and  https_proxy defaults to the value of proxy.</span></li><li><span class="v">MaxSessions = integer()</span></li><li><span class="d">Maximum number of persistent connections to a host. Default is 2.</span></li><li><span class="v">MaxKeepAlive = integer()</span></li><li><span class="d">Maximum number of outstanding requests on the same connection to  a host. Default is 5.</span></li><li><span class="v">KeepAliveTimeout = integer()</span></li><li><span class="d">If a persistent connection is idle longer than the  keep_alive_timeout in milliseconds,  the client closes the connection. The server can also have such a time-out but do not take that for granted. Default is 120000 (= 2 min).</span></li><li><span class="v">MaxPipeline = integer()</span></li><li><span class="d">Maximum number of outstanding requests on a pipelined connection  to a host. Default is 2.</span></li><li><span class="v">PipelineTimeout = integer()</span></li><li><span class="d">If a persistent connection is idle longer than the  pipeline_timeout in milliseconds,  the client closes the connection. Default is 0, which results in pipelining not being used.</span></li><li><span class="v">CookieMode = enabled | disabled | verify</span></li><li><span class="d">If cookies are enabled, all valid cookies are automatically  saved in the cookie database of the client manager. If option verify is used, function store_cookies/2 has to be called for the cookies to be saved.  Default is disabled.</span></li><li><span class="v">IpFamily = inet | inet6 | local</span></li><li><span class="d">Default is inet.</span></li><li><span class="v">IpAddress = ip_address()</span></li><li><span class="d">If the host has several network interfaces, this option specifies  which one to use.  See   for details.</span></li><li><span class="v">Port = integer()</span></li><li><span class="d">Local port number to use.  See   for details.</span></li><li><span class="v">socket_opts() = [socket_opt()]</span></li><li><span class="d">The options are appended to the socket options used by the  client.  These are the default values when a new request handler is started (for the initial connect). They are passed directly  to the underlying transport (gen_tcp or SSL)  without verification.</span></li><li><span class="v">VerboseMode = false | verbose | debug | trace</span></li><li><span class="d">Default is false. This option is used to switch on (or off)  different levels of Erlang trace on the client.  It is a debug feature.</span></li><li><span class="v">Profile = profile() | pid()</span></li><li><span class="d">When started stand_alone only the pid can be used.</span></li><li><span class="v">UnixSocket = path()</span></li><li><span class="d"> Experimental option for sending HTTP requests over a unix domain socket. The value of unix_socket shall be the full path to a unix domain socket file with read/write permissions for the erlang process. Default is undefined. </span></li></ul><p>Sets options to be used for subsequent requests.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If possible, the client keeps its connections
alive and uses persistent connections
with or without pipeline depending on configuration
and current circumstances. The HTTP/1.1 specification does not
provide a guideline for how many requests that are
ideal to be sent on a persistent connection.
This depends much on the application.</p><p>A long queue of requests can cause a
user-perceived delay, as earlier requests can take a long time
to complete. The HTTP/1.1 specification suggests a
limit of two persistent connections per server, which is the
default value of option <strong>max_sessions</strong>.</p><p>
The current implementation assumes the requests to the same host, port
combination will use the same socket options.
</p></div><a name="get_options"></a><h2>store_cookies(SetCookieHeaders, Url) -&gt;</h2><h2>store_cookies(SetCookieHeaders, Url, Profile) -&gt; ok | {error, Reason}</h2><p>Saves the cookies defined in <strong>SetCookieHeaders</strong> in the  client profile cookie database.</p><ul><li><span class="v">SetCookieHeaders = headers() - where field = "set-cookie"</span></li><li><span class="v">Url = url()</span></li><li><span class="v">Profile = profile() | pid()</span></li><li><span class="d">When started stand_alone only the pid can be used.</span></li></ul><p>Saves the cookies defined in <strong>SetCookieHeaders</strong>
in the client profile cookie database.
Call this function if option <strong>cookies</strong> is set to <strong>verify</strong>.
If no profile is specified, the default profile is used.</p><h2>stream_next(Pid) -&gt; ok</h2><p>Triggers the next message to be streamed, that is, the same behavior as active one for sockets. </p><ul><li><span class="v">Pid = pid()</span></li><li><span class="d">As received in the stream_start message</span></li></ul><p>Triggers the next message to be streamed, that is,
the same behavior as active ones for sockets.</p><a name="verify_cookies"></a><a name="store_cookies"></a><h2>which_cookies() -&gt; cookies()</h2><h2>which_cookies(Profile) -&gt; cookies()</h2><p>Dumps the entire cookie database.</p><ul><li><span class="v">Profile = profile() | pid()</span></li><li><span class="d">When started stand_alone only the pid can be used.</span></li><li><span class="v">cookies() = [cookie_stores()]</span></li><li><span class="v">cookie_stores() = {cookies, cookies()} | {session_cookies, cookies()}</span></li><li><span class="v">cookies() = [cookie()]</span></li><li><span class="v">cookie() = term()</span></li></ul><p>Produces a list of the entire cookie database.
Intended for debugging/testing purposes. 
If no profile is specified, the default profile is used.</p><h2>which_sessions() -&gt; session_info()</h2><h2>which_sessions(Profile) -&gt; session_info()</h2><p>Produces a slightly processed dump of the sessions database.</p><ul><li><span class="v">Profile = profile() | pid()</span></li><li><span class="d">When started stand_alone only the pid can be used.</span></li><li><span class="v">session_info() = {GoodSessions, BadSessions, NonSessions}</span></li><li><span class="v">GoodSessions = session()</span></li><li><span class="v">BadSessions = tuple()</span></li><li><span class="v">NonSessions = term()</span></li></ul><p>Produces a slightly processed dump of the session 
database. It is intended for debugging. 
If no profile is specified, the default profile is used.</p><h2>SEE ALSO</h2><p><a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>, 
<a href="inets">inets(3)</a>,
<a href="./gen_tcp">gen_tcp(3)</a>, 
<a href="./ssl">ssl(3)</a>
</p></body></html>