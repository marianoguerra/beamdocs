<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>httpd_util</h1><h1>httpd_util</h1><p>Miscellaneous utility functions to be used when implementing 
  Erlang web server API modules.</p><p>This module provides the Erlang web server API module
programmer with miscellaneous utility functions.<a name="convert_request_date"></a></p><h1>Functions</h1><h2>convert_request_date(DateString) -&gt; ErlDate|bad_date</h2><p>Converts the date to the Erlang date format.</p><ul><li><span class="v">DateString = string()</span></li><li><span class="v">ErlDate = calendar:datetime() </span></li></ul><p><strong>convert_request_date/1</strong> converts <strong>DateString</strong> to 
the Erlang date format. <strong>DateString</strong> must be in one of the 
three date formats defined in 
<a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>.</p><h2>create_etag(FileInfo) -&gt; Etag</h2><p>Calculates the Etag for a file.</p><ul><li><span class="v">FileInfo = file_info()</span></li><li><span class="v">Etag = string()</span></li></ul><p><strong>create_etag/1</strong> calculates the Etag for a file from its
size and time for last modification. <strong>FileInfo</strong> is a record defined 
in <strong>kernel/include/file.hrl</strong>.</p><h2>day(NthDayOfWeek) -&gt; DayOfWeek</h2><p>Converts the day of the week  (integer [1-7]) to an abbreviated string.</p><ul><li><span class="v">NthDayOfWeek = 1-7</span></li><li><span class="v">DayOfWeek = string()</span></li></ul><p><strong>day/1</strong> converts the day of the week
(<strong>NthDayOfWeek</strong>) from an integer (1-7) to an abbreviated
string, that is:</p><p>1 = "Mon", 2 = "Tue", ..., 7 = "Sat".</p><h2>decode_hex(HexValue) -&gt; DecValue</h2><p>Converts a hexadecimal value into its decimal equivalent.</p><ul><li><span class="v">HexValue = DecValue = string()</span></li></ul><p>Converts the hexadecimal value <strong>HexValue</strong> into its
decimal equivalent (<strong>DecValue</strong>).</p><h2>flatlength(NestedList) -&gt; Size</h2><p>Computes the size of a possibly nested list.</p><ul><li><span class="v">NestedList = list()</span></li><li><span class="v">Size = integer()</span></li></ul><p><strong>flatlength/1</strong> computes the size of the possibly nested
list <strong>NestedList</strong>, which can contain binaries.</p><h2>hexlist_to_integer(HexString) -&gt; Number</h2><p>Converts a hexadecimal string to an integer.</p><ul><li><span class="v">Number = integer()</span></li><li><span class="v">HexString = string()</span></li></ul><p><strong>hexlist_to_integer</strong> converts the hexadecimal value of 
<strong>HexString</strong> to an integer.</p><h2>integer_to_hexlist(Number) -&gt; HexString</h2><p>Converts an integer to a hexadecimal string.</p><ul><li><span class="v">Number = integer()</span></li><li><span class="v">HexString = string()</span></li></ul><p><strong>integer_to_hexlist/1</strong> returns a string representing
<strong>Number</strong> in a hexadecimal form.</p><h2>lookup(ETSTable,Key) -&gt; Result</h2><h2>lookup(ETSTable,Key,Undefined) -&gt; Result</h2><p>Extracts the first value associated with a <strong>Key</strong>  in an ETS table.</p><ul><li><span class="v">ETSTable = ets_table()</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Result = term() | undefined | Undefined</span></li><li><span class="v">Undefined = term()</span></li></ul><p><strong>lookup</strong> extracts <strong>{Key,Value}</strong> tuples from
<strong>ETSTable</strong> and returns the <strong>Value</strong> associated  
with <strong>Key</strong>. If <strong>ETSTable</strong> is of type <strong>bag</strong>,
only the first <strong>Value</strong> associated with <strong>Key</strong> is
returned. <strong>lookup/2</strong> returns <strong>undefined</strong> and
<strong>lookup/3</strong> returns <strong>Undefined</strong> if no <strong>Value</strong>
is found.</p><h2>lookup_mime(ConfigDB,Suffix)</h2><h2>lookup_mime(ConfigDB,Suffix,Undefined) -&gt; MimeType</h2><p>Returns the MIME type associated with a specific file suffix.</p><ul><li><span class="v">ConfigDB = ets_table()</span></li><li><span class="v">Suffix = string()</span></li><li><span class="v">MimeType = string() | undefined | Undefined</span></li><li><span class="v">Undefined = term()</span></li></ul><p><strong>lookup_mime</strong> returns the MIME type associated with a
specific file suffix as specified in the file <strong>mime.types</strong>
(located in the 
<span class="path">
	config directory</span>).</p><h2>lookup_mime_default(ConfigDB,Suffix)</h2><h2>lookup_mime_default(ConfigDB,Suffix,Undefined) -&gt; MimeType</h2><p>Returns the MIME type associated with a specific file suffix  or the value of the DefaultType.</p><ul><li><span class="v">ConfigDB = ets_table()</span></li><li><span class="v">Suffix = string()</span></li><li><span class="v">MimeType = string() | undefined | Undefined</span></li><li><span class="v">Undefined = term()</span></li></ul><p><strong>lookup_mime_default</strong> returns the MIME type associated
with a specific file suffix as specified in the
<strong>mime.types</strong> file (located in the
<span class="path">
	    config  directory</span>). 
If no appropriate association is found, the value of <strong>DefaultType</strong> is
returned.</p><h2>message(StatusCode,PhraseArgs,ConfigDB) -&gt; Message</h2><p>Returns an informative HTTP 1.1 status string in HTML.</p><ul><li><span class="v">StatusCode = 301 | 400 | 403 | 404 | 500 | 501 | 504</span></li><li><span class="v">PhraseArgs = term()</span></li><li><span class="v">ConfigDB = ets_table</span></li><li><span class="v">Message = string()</span></li></ul><p><strong>message/3</strong> returns an informative HTTP 1.1 status
string in HTML. Each <strong>StatusCode</strong> requires a specific
<strong>PhraseArgs</strong>:
</p><dl><dt><strong>301</strong></dt><dd><p><strong>string()</strong>: A URL pointing at the new document
position.</p></dd><dt><strong>400 | 401 | 500</strong></dt><dd><p><strong>none</strong> (no <strong>PhraseArgs</strong>).</p></dd><dt><strong>403 | 404</strong></dt><dd><p><strong>string()</strong>: A <strong>Request-URI</strong> as described in
<a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>.</p> </dd><dt><strong>501</strong></dt><dd><p><strong>{Method,RequestURI,HTTPVersion}</strong>: The HTTP
<strong>Method</strong>, <strong>Request-URI</strong>, and <strong>HTTP-Version</strong>
as defined in RFC 2616.</p></dd><dt><strong>504</strong></dt><dd><p><strong>string()</strong>: A string describing why the service
was unavailable.</p></dd></dl><h2>month(NthMonth) -&gt; Month</h2><p>Converts the month as an integer (1-12) to an abbreviated string.</p><ul><li><span class="v">NthMonth = 1-12</span></li><li><span class="v">Month = string()</span></li></ul><p><strong>month/1</strong> converts the month <strong>NthMonth</strong> as an
integer (1-12) to an abbreviated string, that is: </p><p>1 = "Jan", 2 = "Feb", ..., 12 = "Dec".</p><h2>multi_lookup(ETSTable,Key) -&gt; Result</h2><p>Extracts the values associated with a key in an ETS table.</p><ul><li><span class="v">ETSTable = ets_table()</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Result = [term()]</span></li></ul><p><strong>multi_lookup</strong> extracts all <strong>{Key,Value}</strong> tuples
from an <strong>ETSTable</strong> and returns <em>all</em> <strong>Values</strong> 
associated with <strong>Key</strong> in a list.</p><h2>reason_phrase(StatusCode) -&gt; Description</h2><p>Returns the description of an HTTP 1.1 status code.</p><ul><li><span class="v">StatusCode = 100| 200 | 201 | 202 | 204 | 205 | 206 | 300 | 301 | 302 | 303 | 304 | 400 | 401 | 402 | 403 | 404 | 405 | 406 | 410 411 | 412 | 413 | 414 415 | 416 | 417 | 500 | 501 | 502 | 503 | 504 | 505</span></li><li><span class="v">Description = string()</span></li></ul><p><strong>reason_phrase</strong> returns <strong>Description</strong> of an
HTTP 1.1 <strong>StatusCode</strong>, for example, 200 is "OK" and 201
is "Created". For more information, see
<a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>.</p><h2>rfc1123_date() -&gt; RFC1123Date</h2><h2>rfc1123_date(Date) -&gt; RFC1123Date</h2><p>Returns the current date in RFC 1123 format.</p><ul><li><span class="v"> Date = calendar:datetime()</span></li><li><span class="v">RFC1123Date = string()</span></li></ul><p><strong>rfc1123_date/0</strong> returns the current date in RFC 1123
format. <strong>rfc_date/1</strong> converts the date in the Erlang format
to the RFC 1123 date format.</p><h2>split(String,RegExp,N) -&gt; SplitRes</h2><p>Splits a string in N chunks using a regular expression.</p><ul><li><span class="v">String = RegExp = string()</span></li><li><span class="v">SplitRes = {ok, FieldList} | {error, errordesc()}</span></li><li><span class="v">Fieldlist = [string()]</span></li><li><span class="v">N = integer</span></li></ul><p><strong>split/3</strong> splits <strong>String</strong> in <strong>N</strong> chunks
using <strong>RegExp</strong>. <strong>split/3</strong> is equivalent to
<strong>regexp:split/2</strong> with the exception that <strong>N</strong>
defines the maximum number of fields in
<strong>FieldList</strong>.</p><h2>split_script_path(RequestLine) -&gt; Splitted</h2><p>Splits a <strong>RequestLine</strong> in a file reference to an executable,  and a <strong>QueryString</strong> or a <strong>PathInfo</strong>string.</p><ul><li><span class="v">RequestLine = string()</span></li><li><span class="v">Splitted = not_a_script | {Path, PathInfo, QueryString}</span></li><li><span class="v">Path = QueryString = PathInfo = string()</span></li></ul><p><strong>split_script_path/1</strong> is equivalent to
<strong>split_path/1</strong> with one exception. If the longest
possible path is not a regular, accessible, and executable
file, then <strong>not_a_script</strong> is returned.</p><h2>split_path(RequestLine) -&gt; {Path,QueryStringOrPathInfo}</h2><p>Splits a <strong>RequestLine</strong> in a file reference, and a  <strong>QueryString</strong> or a <strong>PathInfo</strong> string.</p><ul><li><span class="v">RequestLine = Path = QueryStringOrPathInfo = string()</span></li></ul><p><strong>split_path/1</strong> splits <strong>RequestLine</strong> in a file
reference (<strong>Path</strong>), and a <strong>QueryString</strong> or a
<strong>PathInfo</strong> string as specified in
<a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>.
A <strong>QueryString</strong> is isolated from <strong>Path</strong> with a
question mark (<strong>?</strong>) and <strong>PathInfo</strong> with a slash
(/). In the case of a <strong>QueryString</strong>, everything before
<strong>?</strong> is a <strong>Path</strong> and everything after <strong>?</strong> is a
<strong>QueryString</strong>. In the case of a <strong>PathInfo</strong>,
<strong>RequestLine</strong> is scanned from left-to-right on the hunt
for longest possible <strong>Path</strong> being a file or a
directory. Everything after the longest possible
<strong>Path</strong>, isolated with a <strong>/</strong>, is regarded as
<strong>PathInfo</strong>. The resulting <strong>Path</strong> is decoded using
<strong>decode_hex/1</strong> before delivery.</p><h2>strip(String) -&gt; Stripped</h2><p>Returns <strong>String</strong> where the leading and trailing space  tabs are removed.</p><ul><li><span class="v">String = Stripped = string()</span></li></ul><p><strong>strip/1</strong> removes any leading or trailing linear white
space from the string. Linear white space is to be read as
horizontal tab or space.</p><h2>suffix(FileName) -&gt; Suffix</h2><p>Extracts the file suffix from a given filename.</p><ul><li><span class="v">FileName = Suffix = string()</span></li></ul><p><strong>suffix/1</strong> is equivalent to
<strong>filename:extension/1</strong> with the exception that
<strong>Suffix</strong> is returned without a leading dot (<strong>.</strong>).</p><h2>SEE ALSO</h2><p><a href="httpd">httpd(3)</a></p></body></html>