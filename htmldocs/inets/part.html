<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Inets User's Guide</h1><p>The <strong>Inets</strong> application provides a set of 
Internet-related services as follows:<ul><li>An <span class="term">HTTP</span> client and server</li></ul>The HTTP client and server are HTTP 1.1 compliant as
defined in
<a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>.</p><h3>Purpose</h3><p><strong>Inets</strong> is a container for Internet clients and servers
including the following:</p><ul><li>An <span class="term">HTTP</span> client and server</li></ul><p>The HTTP client and server are HTTP 1.1 compliant as
defined in 
<a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>.</p><h3>Prerequisites</h3><p>It is assumed that the reader is familiar with the Erlang
programming language, concepts of OTP, and has a basic
understanding of and HTTP protocol.</p><h3>Service Concept</h3><p>Each client and server in <strong>Inets</strong> is viewed as a service.
Services can be configured to be started at application startup or
dynamically in runtime. To run <strong>Inets</strong> as a distributed 
application that handles application failover and takeover, 
configure the services to be started at application startup. 
When starting the <strong>Inets</strong> application, the <strong>Inets</strong> 
top supervisor starts a number of subsupervisors and worker 
processes for handling the provided services.
When starting services dynamically, new children are added to the 
supervision tree, unless the service is started with the standalone 
option. In this case the service is linked to the calling process 
and all OTP application features, such as soft upgrade, are lost.</p><p>Services to be configured for startup at application startup are to 
be put into the Erlang node configuration file
on the following form:</p><pre>
      [{inets, [{services, ListofConfiguredServices}]}].</pre><p>For details of what to put in the list of configured services, 
see the documentation for the services to be configured.</p><h3>Configuration</h3><p>The HTTP client default profile is started when the <strong>Inets</strong>
application is started and is then available to all processes on
that Erlang node. Other profiles can also be started at
application startup, or profiles can be started and stopped
dynamically in runtime. Each client profile spawns a new
process to handle each request, unless a persistent connection 
can be used with or without pipelining.
The client adds a <strong>host</strong> header and an empty
<strong>te</strong> header if there are no such headers present in the request.</p><p>The client supports IPv6 as long as the underlying mechanisms also do
so.</p><p>The following is to be put in the Erlang node application configuration file
to start a profile at application startup:</p><pre>
      [{inets, [{services, [{httpc, PropertyList}]}]}]</pre><p>For valid properties, see 
<a href="httpc">httpc(3)</a>. </p><h3>Getting Started</h3><p>Start <strong>Inets</strong>:</p><pre><code class="erl">
 1 &gt; inets:start().
      ok</code></pre><p>The following calls use the default client profile.
Use the proxy <strong>"www-proxy.mycompany.com:8000"</strong>,
except from requests to localhost. This applies to all the
following requests.</p><p>Example:</p><pre><code class="erl">
      2 &gt; httpc:set_options([{proxy, {{"www-proxy.mycompany.com", 8000},
      ["localhost"]}}]).
      ok</code></pre><p>The following is an ordinary synchronous request:</p><pre><code class="erl">
      3 &gt; {ok, {{Version, 200, ReasonPhrase}, Headers, Body}} =
      httpc:request(get, {"http://www.erlang.org", []}, [], []).</code></pre><p>With all the default values presented, a get request can also be written
as follows:</p><pre><code class="erl">
      4 &gt; {ok, {{Version, 200, ReasonPhrase}, Headers, Body}} =
      httpc:request("http://www.erlang.org").</code></pre><p>The following is an ordinary asynchronous request:</p><pre><code class="erl">
      5 &gt; {ok, RequestId} =
      httpc:request(get, {"http://www.erlang.org", []}, [], [{sync, false}]).</code></pre><p>The result is sent to the calling process as
<strong>{http, {ReqestId, Result}}</strong>.</p><p>In this case, the calling process is the shell, so the following
result is received:</p><pre><code class="erl">
      6 &gt; receive {http, {RequestId, Result}} -&gt; ok after 500 -&gt; error end.
      ok</code></pre><p>This sends a request with a specified connection header:</p><pre><code class="erl">
      7 &gt; {ok, {{NewVersion, 200, NewReasonPhrase}, NewHeaders, NewBody}} =
      httpc:request(get, {"http://www.erlang.org", [{"connection", "close"}]},
      [], []).</code></pre><p>This sends an HTTP request over a unix domain socket (experimental):</p><pre><code class="erl">
      8 &gt; httpc:set_options([{ipfamily, local},
      {unix_socket,"/tmp/unix_socket/consul_http.sock"}]).
      9 &gt; {ok, {{NewVersion, 200, NewReasonPhrase}, NewHeaders, NewBody}} =
      httpc:request(put, {"http:///v1/kv/foo", [], [], "hello"}, [], []).</code></pre><p>Start an HTTP client profile:</p><pre><code class="">
      10 &gt; {ok, Pid} = inets:start(httpc, [{profile, foo}]).
      {ok, &lt;0.45.0&gt;}       
      </code></pre><p>The new profile has no proxy settings, so the connection is refused:</p><pre><code class="erl">
      11 &gt; httpc:request("http://www.erlang.org", foo).
      {error, econnrefused}</code></pre><p>Stop the HTTP client profile:</p><pre><code class="erl">
      12 &gt; inets:stop(httpc, foo).
      ok</code></pre><p>Alternative way to stop the HTTP client profile:</p><pre><code class="erl">
      13 &gt; inets:stop(httpc, Pid).
      ok</code></pre><h3>Configuration</h3><a name="config"></a><p>The HTTP server, also referred to as httpd, handles HTTP requests
as described in 
<a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>
with a few exceptions, such as gateway
and proxy functionality. The server supports IPv6 as long as the
underlying mechanisms also do so.</p><p>The server implements numerous features, such as:</p><ul><li>Secure Sockets Layer (SSL)</li><li>Erlang Scripting Interface (ESI)</li><li>Common Gateway Interface (CGI)</li><li>User Authentication (using Mnesia, Dets or plain text database)</li><li>Common Logfile Format (with or without disk_log(3) support)</li><li>URL Aliasing</li><li>Action Mappings</li><li>Directory Listings</li></ul><p>The configuration of the server is provided as an Erlang
property list. For backwards compatibility, a configuration
file using apache-style configuration directives is
supported.</p><p>As of <strong>Inets</strong> 5.0 the HTTP server is an easy to
start/stop and customize web server providing the most basic
web server functionality. Inets is designed for embedded systems
and if you want a full-fledged web server there are exists other 
erlang open source alternatives.</p><p>Almost all server functionality has been implemented using an
especially crafted server API, which is described in the Erlang Web
Server API. This API can be used
to enhance the core server functionality, for example with custom
logging and authentication.</p><p>The following is to be put in the Erlang node application configuration 
file to start an HTTP server at application startup:</p><pre><code class="erl">
      [{inets, [{services, [{httpd, [{proplist_file,
                 "/var/tmp/server_root/conf/8888_props.conf"}]},
                {httpd, [{proplist_file,
                 "/var/tmp/server_root/conf/8080_props.conf"}]}]}]}].</code></pre><p>The server is configured using an Erlang property list.
For the available properties, see
<a href="httpd">httpd(3)</a>.
For backwards compatibility, apache-like configuration files
are also supported.
</p><p>The available configuration properties are as follows:</p><pre><code class="">
     httpd_service() -&gt; {httpd, httpd()}
     httpd()         -&gt; [httpd_config()] 
     httpd_config()  -&gt; {file, file()} |
                        {proplist_file, file()}
                        {debug, debug()} |
                        {accept_timeout, integer()}
     debug()         -&gt; disable | [debug_options()]
     debug_options() -&gt; {all_functions, modules()} | 
                        {exported_functions, modules()} |
                        {disable, modules()}
     modules()       -&gt; [atom()]</code></pre><p>Here:</p><dl><dt><strong>{file, file()}</strong></dt><dd><p>If you use an old apace-like configuration file.</p></dd><dt><strong>{proplist_file, file()}</strong></dt><dd><p>File containing an Erlang property
list, followed by a full stop, describing the HTTP server
configuration.</p></dd><dt><strong>{debug, debug()}</strong></dt><dd><p>Can enable trace on all functions or only exported functions 
on chosen modules.</p></dd><dt><strong>{accept_timeout, integer()}</strong></dt><dd><p>Sets the wanted time-out value for
the server to set up a request connection.</p></dd></dl><h3>Getting Started</h3><a name="using_http_server_api"></a><p>Start <strong>Inets</strong>:</p><pre><code class="">
      1 &gt; inets:start().
      ok</code></pre><p>Start an HTTP server with minimal required configuration.
If you specify port <strong>0</strong>, an arbitrary available port is
used, and you can use function <strong>info</strong> to find which port 
number that was picked:</p><pre><code class="">
      2 &gt; {ok, Pid} = inets:start(httpd, [{port, 0},
      {server_name,"httpd_test"}, {server_root,"/tmp"},
      {document_root,"/tmp/htdocs"}, {bind_address, "localhost"}]).
      {ok, 0.79.0}      </code></pre><p>Call <strong>info</strong>:</p><pre><code class="">
      3 &gt;  httpd:info(Pid).
      [{mime_types,[{"html","text/html"},{"htm","text/html"}]},
      {server_name,"httpd_test"},
      {bind_address, {127,0,0,1}},
      {server_root,"/tmp"},
      {port,59408},
      {document_root,"/tmp/htdocs"}]</code></pre><p>Reload the configuration without restarting the server:
</p><pre><code class="">
    4 &gt; httpd:reload_config([{port, 59408},
      {server_name,"httpd_test"}, {server_root,"/tmp/www_test"},
      {document_root,"/tmp/www_test/htdocs"},
      {bind_address, "localhost"}], non_disturbing).
    ok.</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><strong>port</strong> and <strong>bind_address</strong> cannot be changed. 
Clients trying to access the server during the reload
get a service temporary unavailable answer.</p></div><pre><code class="">
      5 &gt;  httpd:info(Pid, [server_root, document_root]).
      [{server_root,"/tmp/www_test"},{document_root,"/tmp/www_test/htdocs"}] </code></pre><pre><code class="">
      6 &gt; ok = inets:stop(httpd, Pid).</code></pre><p>Alternative:</p><pre><code class="">
      6 &gt; ok = inets:stop(httpd, {{127,0,0,1}, 59408}).</code></pre><p>Notice that <strong>bind_address</strong> must be the IP address reported 
by function <strong>info</strong> and cannot be the hostname that is allowed 
when putting in <strong>bind_address</strong>.</p><h3>Htaccess - User Configurable Authentication</h3><a name="htaccess"></a><p>Web server users without server administrative privileges
that need to manage authentication of web pages that are local 
to their user can use the per-directory runtime configurable 
user-authentication scheme <strong>htaccess</strong>. 
It works as follows:</p><ul><li>Each directory in the path to the requested asset is searched for an access file (default is <strong>.htaccess</strong>), which  restricts the web servers rights to respond to a request.  If an access file is found, the rules in that file is applied to the request.</li><li>The rules in an access file apply to files in the same directory and in subdirectories. If there exists more than one access file in the path to an asset, the rules in the access file nearest the requested asset is applied.</li><li>To change the rules that restrict the use of  an asset, the user only needs write access  to the directory where the asset is.</li><li>All access files in the path to a requested asset are read once per request. This means that the load on the server increases when <strong>htaccess</strong> is used.</li><li>If a directory is limited both by authentication directives  in the HTTP server configuration file and by the <strong>htaccess</strong>  files, the user must be allowed to get access to the file by both  methods for the request to succeed.</li></ul><h3>Access Files Directives</h3><p>In every directory under <strong>DocumentRoot</strong> or under an
<strong>Alias</strong> a user can place an access file. An access file
is a plain text file that specifies the restrictions to
consider before the web server answers to a
request. If there are more than one access file in the path
to the requested asset, the directives in the access file in
the directory nearest the asset is used.</p><dl><dt><em>"allow"</em></dt><dd> <p><em>Syntax:</em> <strong>Allow</strong> from subnet <strong>subnet | from all</strong></p> <p><em>Default:</em> <strong>from all</strong></p> <p>Same as directive <strong>allow</strong> for the server configuration file.</p> </dd><dt><em>"AllowOverRide"</em></dt><dd>   <p><em>Syntax:</em> <strong>AllowOverRide</strong> <strong>all | none | Directives</strong></p> <p><em>Default:</em> <strong>none</strong></p> <p><strong>AllowOverRide</strong> specifies the parameters that
access files in subdirectories are not allowed to alter the value 
for. If the parameter is set to <strong>none</strong>, no further 
access files is parsed.
</p> <p>If only one access file exists, setting this parameter to
<strong>none</strong> can ease the burden on the server as the server
then stops looking for access files.</p> </dd><dt><em>"AuthGroupfile"</em></dt><dd> <p><em>Syntax:</em> <strong>AuthGroupFile</strong> Filename</p> <p><em>Default:</em> <strong>none</strong></p> <p><strong>AuthGroupFile</strong> indicates which file that contains the list
of groups. The filename must contain the absolute path to the
file. The format of the file is one group per row and
every row contains the name of the group and the members
of the group, separated by a space, for example:</p> <pre>
GroupName: Member1 Member2 .... MemberN</pre> </dd><dt><em>"AuthName"</em></dt><dd> <p><em>Syntax:</em> <strong>AuthName</strong> auth-domain</p> <p><em>Default:</em> <strong>none</strong></p> <p>Same as directive <strong>AuthName</strong> for the server 
configuration file.</p> </dd><dt><em>"AuthType"</em></dt><dd> <p><em>Syntax:</em> <strong>AuthType</strong> <strong>Basic</strong></p> <p><em>Default:</em> <strong>Basic</strong></p> <p><strong>AuthType</strong> specifies which authentication scheme to
be used. Only Basic Authenticating using UUEncoding of
the password and user ID is implemented.</p> </dd><dt><em>"AuthUserFile"</em></dt><dd> <p><em>Syntax:</em> <strong>AuthUserFile</strong> Filename</p> <p><em>Default:</em><strong>none</strong></p> <p><strong>AuthUserFile</strong> indicates which file that contains the list
of users. The filename must contain the absolute path to the
file. The username and password are not encrypted so do not
place the file with users in a directory that is accessible
through the web server. The format of the file is one user per row.
Every row contains <strong>UserName</strong> and <strong>Password</strong> separated 
by a colon, for example:</p> <pre>
UserName:Password
UserName:Password</pre> </dd><dt><em>"deny"</em></dt><dd> <p><em>Syntax:</em> <strong>deny</strong> from subnet <strong>subnet | from all</strong></p> <p><em>Context:</em> Limit</p> <p>Same as directive <strong>deny</strong> for the server configuration file.</p> </dd><dt><em>"Limit"</em></dt><dd>  <p><em>Syntax:</em> <strong>&lt;Limit</strong> RequestMethods<strong>&gt;</strong></p> <p><em>Default:</em> <strong>none</strong></p> <p><strong>&lt;Limit&gt;</strong> and <strong>&lt;/Limit&gt;</strong> are used to enclose
a group of directives applying only to requests using
the specified methods. If no request method is specified,
all request methods are verified against the restrictions.</p> <p>Example:</p> <pre>
&lt;Limit POST GET HEAD&gt;
  order allow deny
  require group group1
  allow from 123.145.244.5
&lt;/Limit&gt;</pre> </dd><dt><em>"order"</em></dt><dd>    <p><em>Syntax:</em> <strong>order</strong> <strong>allow deny | deny allow</strong></p> <p><em>Default:</em> <strong>allow deny</strong></p> <p><strong>order</strong> defines if the deny or allow control is to
be performed first.</p> <p>If the order is set to <strong>allow deny</strong>, the users
network address is first controlled to be in the allow subset. 
If the user network address is not in the allowed subset, the user
is denied to get the asset. If the network address is in the
allowed subset, a second control is performed. That is,
the user network address is not in the subset of network
addresses to be denied as specified by parameter <strong>deny</strong>.</p> <p>If the order is set to <strong>deny allow</strong>, only users from networks
specified to be in the allowed subset succeeds to request  
assets in the limited area.</p> </dd><dt><em>"require"</em></dt><dd>  <p><em>Syntax:</em> <strong>require</strong>
<strong>group group1 group2... | user user1 user2...</strong></p> <p><em>Default:</em> <strong>none</strong></p> <p><em>Context:</em> Limit</p> <p>For more information, see directive <strong>require</strong>  in
<a href="mod_auth">mod_auth(3)</a>.</p> </dd></dl><h3>Dynamic Web Pages</h3><a name="dynamic_we_pages"></a><p><strong>Inets</strong> HTTP server provides two ways of creating dynamic web
pages, each with its own advantages and disadvantages:</p><dl><dt><em>CGI scripts</em></dt><dd><p>Common Gateway Interface (CGI) scripts can be written 
in any programming language. CGI scripts are standardized and 
supported by most web servers. The drawback with CGI scripts is that 
they are resource-intensive because of their design. CGI requires the 
server to fork a new OS process for each executable it needs to start.
</p></dd><dt><em>ESI-functions</em></dt><dd><p>Erlang Server Interface (ESI) functions provide a tight and efficient
interface to the execution of Erlang functions. This interface,
on the other hand, is <strong>Inets</strong> specific.</p></dd></dl><h3>CGI Version 1.1, RFC 3875</h3><p>The module <strong>mod_cgi</strong> enables execution of 
<a href="http://www.ietf.org/rfc/rfc3875.txt">CGI scripts</a>
on the server. A file matching the definition of a
ScriptAlias config directive is treated as a CGI script. A CGI
script is executed by the server and its output is returned to
the client.</p><p>The CGI script response comprises a message header and a
message body, separated by a blank line. The message header
contains one or more header fields. The body can be
empty.</p><p>Example:</p><pre><code class="">"Content-Type:text/plain\nAccept-Ranges:none\n\nsome very
	plain text"</code></pre><p>The server interprets the message headers and most of them
are transformed into HTTP headers and sent back to the
client together with the message-body.</p><p>Support for CGI-1.1 is implemented in accordance with 
<a href="http://www.ietf.org/rfc/rfc3875.txt">RFC 3875</a>.</p><h3>ESI</h3><p>The Erlang server interface is implemented by
module <strong>mod_esi</strong>.</p><h3>ERL Scheme</h3><p>The erl scheme is designed to mimic plain CGI, but without
the extra overhead. An URL that calls an Erlang <strong>erl</strong> function
has the following syntax (regular expression): </p><pre><code class="">
http://your.server.org/***/Module[:/]Function(?QueryString|/PathInfo)</code></pre><p>*** depends on how the ErlScriptAlias config
directive has been used.</p><p>The module <strong>Module</strong> referred to must be found in the code
path, and it must define a function <strong>Function</strong> with an arity
of two or three. It is preferable to implement a function
with arity three, as it permits to send chunks of the
web page to the client during the generation
phase instead of first generating the whole web page and
then sending it to the client. The option to implement a
function with arity two is only kept for
backwards compatibility reasons.
For implementation details of the ESI callback function, 
see <a href="mod_esi">mod_esi(3)</a>.</p><h3>EVAL Scheme</h3><p>The eval scheme is straight-forward and does not mimic the
behavior of plain CGI. An URL that calls an Erlang <strong>eval</strong>
function has the following syntax:</p><pre><code class="">
http://your.server.org/***/Mod:Func(Arg1,...,ArgN)</code></pre><p>*** depends on how the ErlScriptAlias config
directive has been used.</p><p>The module <strong>Mod</strong> referred to must be found in the code
path and data returned by the function <strong>Func</strong> is passed
back to the client. Data returned from the
function must take the form as specified in
the CGI specification. For implementation details of the ESI 
callback function, 
see <a href="mod_esi">mod_esi(3)</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The eval scheme can seriously threaten the
integrity of the Erlang node housing a web server, for
example:</p><pre><code class="">
http://your.server.org/eval?httpd_example:print(atom_to_list(apply(erlang,halt,[])))</code></pre><p>This effectively closes down the Erlang node.
Therefore, use the erl scheme instead, until this
security breach is fixed.</p><p>Today there are no good ways of solving this problem
and therefore the eval scheme can be removed in future
release of <strong>Inets</strong>.</p></div><h3>Logging</h3><a name="logging"></a><p>Three types of logs are supported: transfer logs,
security logs, and error logs. The de-facto standard Common
Logfile Format is used for the transfer and security logging.
There are numerous statistics programs available to analyze Common
Logfile Format. The Common Logfile Format looks as follows:
</p><p><em>remotehost rfc931 authuser [date] "request" status bytes</em></p><p>Here:</p><dl><dt><em>remotehost</em></dt><dd>Remote hostname.</dd><dt><em>rfc931</em></dt><dd>The client remote username (<a href="http://www.ietf.org/rfc/rfc931.txt">RFC 931</a>).</dd><dt><em>authuser</em></dt><dd>The username used for authentication.</dd><dt><em>[date]</em></dt><dd>Date and time of the request (<a href="http://www.ietf.org/rfc/rfc1123.txt">RFC 1123</a>).</dd><dt><em>"request"</em></dt><dd>The request line exactly as it came from the client (<a href="http://www.ietf.org/rfc/rfc1945.txt">RFC 1945</a>).</dd><dt><em>status</em></dt><dd>The HTTP status code returned to the client  (<a href="http://www.ietf.org/rfc/rfc1945.txt">RFC 1945</a>).</dd><dt><em>bytes</em></dt><dd>The content-length of the document transferred. </dd></dl><p>Internal server errors are recorded in the error log file. The
format of this file is a more unplanned format than the logs using
Common Logfile Format, but conforms to the following syntax:
</p><p><em>[date]</em> access to <em>path</em> failed for
<em>remotehost</em>, reason: <em>reason</em></p><h3>Erlang Web Server API</h3><p>The process of handling an HTTP request involves several steps,
such as:</p><ul><li>Setting up connections, sending and receiving data.</li><li>URI to filename translation.</li><li>Authentication/access checks.</li><li>Retrieving/generating the response.</li><li>Logging.</li></ul><p>To provide customization and extensibility of the request 
handling of the HTTP servers, most of these steps are handled by 
one or more modules. These modules can be replaced or removed at 
runtime and new ones can be added. For each request, all modules are
traversed in the order specified by the module directive in the
server configuration file. Some parts, mainly the communication-
related steps, are considered server core functionality and are
not implemented using the Erlang web server API. A description of
functionality implemented by the Erlang webserver API is described
in <a href="#Inets_Web_Server_Modules">Section  Inets Web Server Modules</a>.</p><p>A module can use data generated by previous modules in the
Erlang webserver API module sequence or generate data to be used
by consecutive Erlang Web Server API modules. This is
possible owing to an internal list of key-value tuples, referred to
as interaction data.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Interaction data enforces module dependencies and
is to be avoided if possible. This means that the order
of modules in the modules property is significant.</p></div><h3>API Description</h3><p>Each module that implements server functionality
using the Erlang web server API is to implement the following
call back functions:</p><ul><li><strong>do/1</strong> (mandatory) - the function called when a request is to be handled</li><li><strong>load/2</strong></li><li><strong>store/2</strong></li><li><strong>remove/1</strong></li></ul><p>The latter functions are needed only when new config
directives are to be introduced. For details, see
<a href="httpd">httpd(3)</a>.</p><h3>Inets Web Server Modules</h3><a name="Inets_Web_Server_Modules"></a><p>The convention is that
all modules implementing some web server functionality has the
name <strong>mod_*</strong>. When configuring the web server, an appropriate
selection of these modules is to be present in the module
directive. Notice that there are some interaction dependencies
to take into account, so the order of the modules cannot be
random.</p><h3>mod_action - Filetype/Method-Based Script Execution</h3><p>This module runs CGI scripts whenever a file of a
certain type or HTTP method (see 
<a href="http://tools.ietf.org/html/rfc1945">RFC 1945</a>)
is requested.
</p><p>Uses the following Erlang Web Server API interaction data:
</p><ul><li><strong>real_name</strong> - from <a href="mod_alias">mod_alias</a>.</li></ul><p>Exports the following Erlang Web Server API interaction data, if possible:
</p><dl><dt><strong>{new_request_uri, RequestURI}</strong></dt><dd>An alternative <strong>RequestURI</strong> has been generated.</dd></dl><h3>mod_alias - URL Aliasing</h3><p>The <a href="mod_alias">mod_alias</a>
module makes it possible to map different parts of the
host file system into the document tree, that is, creates aliases and
redirections.</p><p>Exports the following Erlang Web Server API interaction data, if possible:
</p><dl><dt><strong>{real_name, PathData}</strong></dt><dd><strong>PathData</strong> is the argument used for API function  <a href="./mod_alias#path/3">mod_alias:path/3</a>.</dd></dl><h3>mod_auth - User Authentication</h3><p>The <a href="mod_auth">mod_auth(3)</a> 
module provides for basic user authentication using
textual files, Dets databases as well as Mnesia databases.</p><p>Uses the following Erlang Web Server API interaction data:
</p><ul><li><strong>real_name</strong> - from <a href="mod_alias">mod_alias</a></li></ul><p>Exports the following Erlang Web Server API interaction data:
</p><dl><dt><strong>{remote_user, User}</strong></dt><dd>The username used for authentication.</dd></dl><h3>Mnesia As Authentication Database</h3><p>If Mnesia is used as storage method, Mnesia must be
started before the HTTP server. The first time Mnesia is
started, the schema and the tables must be created before
Mnesia is started. A simple example of a module with two
functions that creates and start Mnesia is provided
here. Function <strong>first_start/0</strong> is to be used the first
time. It creates the schema and the tables.
<strong>start/0</strong> is to be used in consecutive startups. 
<strong>start/0</strong> starts Mnesia and waits for the tables to
be initiated. This function must only be used when the
schema and the tables are already created.</p><pre><code class="">
-module(mnesia_test).
-export([start/0,load_data/0]).
-include_lib("mod_auth.hrl").

first_start() -&gt;
    mnesia:create_schema([node()]),
    mnesia:start(),
    mnesia:create_table(httpd_user,
                        [{type, bag},
                         {disc_copies, [node()]},
                         {attributes, record_info(fields, 
                                                  httpd_user)}]),
    mnesia:create_table(httpd_group,
                        [{type, bag},
                         {disc_copies, [node()]},          
                         {attributes, record_info(fields, 
                                                  httpd_group)}]),
    mnesia:wait_for_tables([httpd_user, httpd_group], 60000).

start() -&gt;
    mnesia:start(),
    mnesia:wait_for_tables([httpd_user, httpd_group], 60000).  </code></pre><p>To create the Mnesia tables, we use two records defined in
<strong>mod_auth.hrl</strong>, so that file must be included. <strong>first_start/0</strong> 
creates a schema that specifies on which nodes the database is to reside. 
Then it starts Mnesia and creates the tables. The first argument
is the name of the tables, the second argument is a list of options of 
how to create the table, see 
<a href="./mnesia">mnesia/mnesia</a>, documentation for
more information. As the implementation of the <strong>mod_auth_mnesia</strong> 
saves one row for each user, the type must be <strong>bag</strong>.
When the schema and the tables are created, function
<a href="../mnesia/mnesia#start-0">mnesia:start/0</a>
is used to start Mnesia  and
waits for the tables to be loaded. Mnesia uses the
directory specified as <strong>mnesia_dir</strong> at startup if specified,
otherwise Mnesia uses the current directory. For security
reasons, ensure that the Mnesia tables are stored outside
the document tree of the HTTP server. If they are placed in the
directory which it protects, clients can download the tables. 
Only the Dets and Mnesia storage
methods allow writing of dynamic user data to disk. <strong>plain</strong> is
a read only method.</p><h3>mod_cgi - CGI Scripts</h3><p>This module handles invoking of CGI scripts.</p><h3>mod_dir - Directories</h3><p>This module generates an HTML directory listing
(Apache-style) if a client sends a request for a directory
instead of a file. This module must be removed from the
Modules config directive if directory listings is unwanted.</p><p>Uses the following Erlang Web Server API interaction data:
</p><ul><li><strong>real_name</strong> - from <a href="mod_alias">mod_alias</a></li></ul><p>Exports the following Erlang Web Server API interaction data:
</p><dl><dt><strong>{mime_type, MimeType}</strong></dt><dd>The file suffix of the incoming URL mapped into a <strong>MimeType</strong>.</dd></dl><h3>mod_disk_log - Logging Using Disk_Log.</h3><p>Standard logging using the "Common Logfile Format" and
<a href="./disk_log">disk_log(3)</a>.</p><p>Uses the following Erlang Web Server API interaction data:
</p><ul><li><strong>remote_user</strong> - from <strong>mod_auth</strong></li></ul><h3>mod_esi - Erlang Server Interface</h3><p>The <a href="mod_esi">mod_esi(3)</a>
module implements the Erlang Server Interface (ESI) providing a 
tight and efficient interface to the execution of Erlang functions.</p><p>Uses the following Erlang web server API interaction data:
</p><ul><li><strong>remote_user</strong> - from <strong>mod_auth</strong></li></ul><p>Exports the following Erlang web server API interaction data:
</p><dl><dt><strong>{mime_type, MimeType}</strong></dt><dd>The file suffix of the incoming URL mapped into a <strong>MimeType</strong></dd></dl><h3>mod_get - Regular GET Requests</h3><p>This module is responsible for handling GET requests to regular 
files. GET requests for parts of files is handled by <strong>mod_range</strong>.</p><p>Uses the following Erlang web server API interaction data:
</p><ul><li><strong>real_name</strong> - from <a href="mod_alias">mod_alias</a></li></ul><h3>mod_head - Regular HEAD Requests</h3><p>This module is responsible for handling HEAD requests to regular 
files. HEAD requests for dynamic content is handled by each module 
responsible for dynamic content.</p><p>Uses the following Erlang Web Server API interaction data:
</p><ul><li><strong>real_name</strong> - from <a href="mod_alias">mod_alias</a></li></ul><h3>mod_htaccess - User Configurable Access</h3><p>This module provides per-directory user configurable access
control.</p><p>Uses the following Erlang Web Server API interaction data:
</p><ul><li><strong>real_name</strong> - from <a href="mod_alias">mod_alias</a></li></ul><p>Exports the following Erlang Web Server API interaction data:
</p><dl><dt><strong>{remote_user_name, User}</strong></dt><dd>The username used for authentication.</dd></dl><h3>mod_log - Logging Using Text Files.</h3><p>Standard logging using the "Common Logfile Format" and text
files.</p><p>Uses the following Erlang Web Server API interaction data:
</p><ul><li><strong>remote_user</strong> - from <strong>mod_auth</strong></li></ul><h3>mod_range - Requests with Range Headers</h3><p>This module responses to requests for one or many ranges of a
file. This is especially useful when downloading large files,
as a broken download can be resumed.</p><p>Notice that request for multiple parts of a document report a
size of zero to the log file.</p><p>Uses the following Erlang Web Server API interaction data:
</p><ul><li><strong>real_name</strong> - from <a href="mod_alias">mod_alias</a></li></ul><h3>mod_response_control - Requests with If* Headers</h3><p>This module controls that the conditions in the requests are
fulfilled. For example, a request can specify that the answer
only is of interest if the content is unchanged since the last
retrieval. If the content is changed, the range request is to
be converted to a request for the whole file instead.</p><p>If a client sends more than one of the header fields that 
restricts the servers right to respond, the standard does not 
specify how this is to be handled.
<a href="httpd">httpd(3)</a> controls each 
field in the following order and if one of the fields does not 
match the current state, the request is rejected with a proper 
response:</p><p><strong>If-modified</strong></p><p><strong>If-Unmodified</strong></p><p><strong>If-Match</strong></p><p><strong>If-Nomatch</strong></p><p>Uses the following Erlang Web Server API interaction data:
</p><ul><li><strong>real_name</strong> - from  <a href="mod_alias">mod_alias</a></li></ul><p>Exports the following Erlang Web Server API interaction data:
</p><dl><dt><strong>{if_range, send_file}</strong></dt><dd>The conditions for the range request are not fulfilled. The response must not be treated as a range request, instead it must be treated as an ordinary get request.</dd></dl><h3>mod_security - Security Filter</h3><p>The <a href="mod_security">mod_security</a> 
module serves as a filter for authenticated requests
handled in <a href="mod_auth">mod_auth(3)</a>. 
It provides a possibility to restrict users from 
access for a specified amount of time if they fail to
authenticate several times. It logs failed authentication as
well as blocking of users, and it calls a configurable
callback module when the events occur.</p><p>There is also an
API to block or unblock users manually. This API can also list 
blocked users or users who have been authenticated within a 
configurable amount of time.</p><h3>mod_trace - TRACE Request</h3><p><strong>mod_trace</strong> is responsible for handling of TRACE requests.
Trace is a new request method in HTTP/1.1. The intended use of
trace requests is for testing. The body of the trace response is
the request message that the responding web server or proxy
received.</p></body></html>