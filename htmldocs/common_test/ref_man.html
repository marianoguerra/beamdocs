<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Common Test Reference Manual</h1><h2>common_test</h2><p>A framework for automated testing of any target nodes.</p><p>The <strong>Common Test</strong> framework is an environment for
implementing and performing automatic and semi-automatic execution of
test cases.In brief, <strong>Common Test</strong> supports:<ul><li>Automated execution of test suites (sets of test cases)</li><li>Logging of events during execution</li><li>HTML presentation of test suite results</li><li>HTML presentation of test suite code</li><li>Support functions for test suite authors</li><li>Step-by-step execution of test cases</li></ul>The following section describes the mandatory and optional test suite
functions that <strong>Common Test</strong> calls during test execution.
For more details, see section
<a href="write_test_chapter">Writing Test Suites</a>
in the User's Guide.</p><h3>Test Case Callback Functions</h3><p>The following functions define the callback interface
for a test suite.</p><h2>Functions</h2><h3>Module:all() -&gt; Tests | {skip,Reason}</h3><p>Returns the list of all test case groups and test cases in the module.</p><ul><li><span class="v">Tests = [TestCase | {testcase,TestCase,TCRepeatProps} | {group,GroupName} | {group,GroupName,Properties} | {group,GroupName,Properties,SubGroups}]</span></li><li><span class="v">TestCase = atom()</span></li><li><span class="v">TCRepeatProps = [{repeat,N} | {repeat_until_ok,N} | {repeat_until_fail,N}]</span></li><li><span class="v">GroupName = atom()</span></li><li><span class="v">Properties = [parallel | sequence | Shuffle | {GroupRepeatType,N}] | default</span></li><li><span class="v">SubGroups = [{GroupName,Properties} | {GroupName,Properties,SubGroups}]</span></li><li><span class="v">Shuffle = shuffle | {shuffle,Seed}</span></li><li><span class="v">Seed = {integer(),integer(),integer()}</span></li><li><span class="v">GroupRepeatType = repeat | repeat_until_all_ok | repeat_until_all_fail | repeat_until_any_ok | repeat_until_any_fail</span></li><li><span class="v">N = integer() | forever</span></li><li><span class="v">Reason = term()</span></li></ul><p>MANDATORY</p><p>Returns the list of all test cases and test case groups in the
test suite module to be executed. This list also specifies the
order the cases and groups are executed by <strong>Common Test</strong>.
A test case is represented by an atom,
the name of the test case function, or a <strong>testcase</strong> tuple
indicating that the test case shall be repeated. A test case group is
represented by a <strong>group</strong> tuple, where <strong>GroupName</strong>,
an atom, is the name of the group (defined in
<a href="#Module:groups-0">Module:groups-0</a>).
Execution properties for groups can also be specified, both
for a top-level group and for any of its subgroups.
Group execution properties specified here override
properties in the group definition (see
<a href="#Module:groups-0">Module:groups-0</a>).
(With value <strong>default</strong>, the group definition properties
are used).</p><p>If <strong>{skip,Reason}</strong> is returned, all test cases
in the module are skipped and <strong>Reason</strong>
is printed on the HTML result page.</p><p>For details on groups, see section
<a href="./write_test_chapter#test_case_groups">Test Case Groups</a> in the User's Guide.</p><h3>Module:groups() -&gt; GroupDefs</h3><p>Returns a list of test case group definitions.</p><ul><li><span class="v">GroupDefs = [Group]</span></li><li><span class="v">Group = {GroupName,Properties,GroupsAndTestCases}</span></li><li><span class="v">GroupName = atom()</span></li><li><span class="v">Properties = [parallel | sequence | Shuffle | {GroupRepeatType,N}]</span></li><li><span class="v">GroupsAndTestCases = [Group | {group,GroupName} | TestCase | {testcase,TestCase,TCRepeatProps}]</span></li><li><span class="v">TestCase = atom()</span></li><li><span class="v">TCRepeatProps = [{repeat,N} | {repeat_until_ok,N} | {repeat_until_fail,N}]</span></li><li><span class="v">Shuffle = shuffle | {shuffle,Seed}</span></li><li><span class="v">Seed = {integer(),integer(),integer()}</span></li><li><span class="v">GroupRepeatType = repeat | repeat_until_all_ok | repeat_until_all_fail | repeat_until_any_ok | repeat_until_any_fail</span></li><li><span class="v">N = integer() | forever</span></li></ul><p>OPTIONAL</p><p>Defines test case groups. For details, see section
<a href="./write_test_chapter#test_case_groups">Test Case  Groups</a> in the User's Guide.</p><h3>Module:suite() -&gt; [Info]</h3><p>Test suite info function (providing default data for the suite).</p><ul><li><span class="v">Info = {timetrap,Time} | {require,Required} | {require,Name,Required} | {userdata,UserData} | {silent_connections,Conns} | {stylesheet,CSSFile} | {ct_hooks, CTHs}</span></li><li><span class="v">Time = TimeVal | TimeFunc</span></li><li><span class="v">TimeVal = MilliSec | {seconds,integer()} | {minutes,integer()} | {hours,integer()}</span></li><li><span class="v">TimeFunc = {Mod,Func,Args} | Fun</span></li><li><span class="v">MilliSec = integer()</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">Func = atom()</span></li><li><span class="v">Args = list()</span></li><li><span class="v">Fun = fun()</span></li><li><span class="v">Required = Key | {Key,SubKeys} | {Key,SubKey} | {Key,SubKey,SubKeys}</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">SubKeys = SubKey | [SubKey]</span></li><li><span class="v">SubKey = atom()</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">UserData = term()</span></li><li><span class="v">Conns = [atom()]</span></li><li><span class="v">CSSFile = string()</span></li><li><span class="v">CTHs = [CTHModule |</span></li><li><span class="v">Â Â Â Â Â Â Â Â {CTHModule, CTHInitArgs} |</span></li><li><span class="v">Â Â Â Â Â Â Â Â {CTHModule, CTHInitArgs, CTHPriority}]</span></li><li><span class="v">CTHModule = atom()</span></li><li><span class="v">CTHInitArgs = term()</span></li></ul><p>OPTIONAL</p><p>The test suite information function.	Returns a list of tagged
tuples specifying various properties related to the execution of
this test suite (common for all test cases in the suite).</p><p>Tag <strong>timetrap</strong> sets the maximum time that each
test case is allowed to execute (including
<a href="#Module:init_per_testcase-2">Module:init_per_testcase-2</a>
and
<a href="#Module:end_per_testcase-2">Module:end_per_testcase-2</a>).
If the timetrap time is exceeded, the test case fails with reason
<strong>timetrap_timeout</strong>. A <strong>TimeFunc</strong> function can be used to
set a new timetrap by returning a <strong>TimeVal</strong>. It can also be
used to trigger a timetrap time-out by, at some point, returning a
value other than a <strong>TimeVal</strong>. For details, see section
<a href="./write_test_chapter#timetraps">Timetrap Time-Outs</a>
in the User's Guide.</p><p>Tag <strong>require</strong> specifies configuration variables
required by test cases (or configuration functions)
in the suite. If the required configuration variables are not found
in any of the configuration files, all test cases are skipped.
For details about the <strong>require</strong> functionality, see funtion
<a href="./ct#require-1">ct#require-1</a>.</p><p>With <strong>userdata</strong>, the user can
specify any test suite-related information, which can be
read by calling
<a href="./ct#userdata-2">ct#userdata-2</a>.</p><p>Tag <strong>ct_hooks</strong> specifies the
<a href="ct_hooks_chapter">Common Test Hooks</a>
to be run with this suite.</p><p>Other tuples than the ones defined are ignored.</p><p>For details about the test suite information function, see section
<a href="./write_test_chapter#suite">Test Suite Information Function</a> in the User's Guide.</p><h3>Module:init_per_suite(Config) -&gt; NewConfig | {skip,Reason} |
	  {skip_and_save,Reason,SaveConfig}</h3><p>Test suite initializations.</p><ul><li><span class="v">Config = NewConfig = SaveConfig = [{Key,Value}]</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>OPTIONAL; if this function is defined, then <a href="#Module:end_per_suite-1">Module:end_per_suite-1</a>
must also be defined.</p><p>This configuration function is called as the first function in the
suite. It typically contains initializations that are common for
all test cases in the suite, and that must only be done
once. Parameter <strong>Config</strong> is the configuration data
that can be modified. Whatever is returned from this
function is specified as <strong>Config</strong> to all configuration functions
and test cases in the suite.</p><p>If <strong>{skip,Reason}</strong>
is returned, all test cases in the suite are skipped
and <strong>Reason</strong> is printed in the overview log for the suite.</p><p>For information on <strong>save_config</strong> and <strong>skip_and_save</strong>,
see section
<a href="./dependencies_chapter#save_config">Saving Configuration Data</a> in the User's Guide.</p><h3>Module:end_per_suite(Config) -&gt; term() | 
	{save_config,SaveConfig}</h3><p>Test suite finalization.</p><ul><li><span class="v">Config = SaveConfig = [{Key,Value}]</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li></ul><p>OPTIONAL; if this function is defined, then <a href="#Module:init_per_suite-1">Module:init_per_suite-1</a>
must also be defined.</p><p>This function is called as the last test case in the
suite. It is meant to be used for cleaning up after
<a href="#Module:init_per_suite-1">Module:init_per_suite-1</a>.</p><p>For information on <strong>save_config</strong>, see section
<a href="./dependencies_chapter#save_config">Saving Configuration Data</a> in the User's Guide.</p><h3>Module:group(GroupName) -&gt; [Info]</h3><p>Test case group information function (providing default data for a test case group, that is, its test cases and subgroups).</p><ul><li><span class="v">Info = {timetrap,Time} | {require,Required} | {require,Name,Required} | {userdata,UserData} | {silent_connections,Conns} | {stylesheet,CSSFile} | {ct_hooks, CTHs}</span></li><li><span class="v">Time = TimeVal | TimeFunc</span></li><li><span class="v">TimeVal = MilliSec | {seconds,integer()} | {minutes,integer()} | {hours,integer()}</span></li><li><span class="v">TimeFunc = {Mod,Func,Args} | Fun</span></li><li><span class="v">MilliSec = integer()</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">Func = atom()</span></li><li><span class="v">Args = list()</span></li><li><span class="v">Fun = fun()</span></li><li><span class="v">Required = Key | {Key,SubKeys} | {Key,Subkey} | {Key,Subkey,SubKeys}</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">SubKeys = SubKey | [SubKey]</span></li><li><span class="v">SubKey = atom()</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">UserData = term()</span></li><li><span class="v">Conns = [atom()]</span></li><li><span class="v">CSSFile = string()</span></li><li><span class="v">CTHs = [CTHModule |</span></li><li><span class="v">Â Â Â Â Â Â Â Â {CTHModule, CTHInitArgs} |</span></li><li><span class="v">Â Â Â Â Â Â Â Â {CTHModule, CTHInitArgs, CTHPriority}]</span></li><li><span class="v">CTHModule = atom()</span></li><li><span class="v">CTHInitArgs = term()</span></li></ul><p>OPTIONAL</p><p>The test case group information function. It is supposed to
return a list of tagged tuples that specify various properties
related to the execution of a test case group (that is, its test
cases and subgroups). Properties set by
<a href="#Module:group-1">Module:group-1</a> override
properties with the same key that have been set previously by
<a href="#Module:suite-0">Module:suite-0</a>.</p><p>Tag <strong>timetrap</strong> sets the maximum time that each
test case is allowed to execute (including
<a href="#Module:init_per_testcase-2">Module:init_per_testcase-2</a>
and
<a href="#Module:end_per_testcase-2">Module:end_per_testcase-2</a>).
If the timetrap time is
exceeded, the test case fails with reason
<strong>timetrap_timeout</strong>. A <strong>TimeFunc</strong> function can be used to
set a new timetrap by returning a <strong>TimeVal</strong>. It can also be
used to trigger a timetrap time-out by, at some point, returning a
value other than a <strong>TimeVal</strong>. For details, see section
<a href="./write_test_chapter#timetraps">Timetrap Time-Outs</a> in the User's Guide.</p><p>Tag <strong>require</strong> specifies configuration variables
required by test cases (or configuration functions)
in the suite. If the required configuration variables are not found
in any of the configuration files, all test cases in this group are
skipped. For details about the <strong>require</strong> functionality, see
function
<a href="./ct#require-1">ct#require-1</a>.</p><p>With <strong>userdata</strong>, the user can
specify any test case group related information that can be 
read by calling
<a href="./ct#userdata-2">ct#userdata-2</a>.</p><p>Tag <strong>ct_hooks</strong> specifies the
<a href="ct_hooks_chapter">Common Test Hooks</a>
to be run with this suite.</p><p>Other tuples than the ones defined are ignored.</p><p>For details about the test case group information function,
see section <a href="./write_test_chapter#group_info">Group Information Function</a> in the User's Guide.</p><h3>Module:init_per_group(GroupName, Config) -&gt; NewConfig |
	  {skip,Reason}</h3><p>Test case group initializations.</p><ul><li><span class="v">GroupName = atom()</span></li><li><span class="v">Config = NewConfig = [{Key,Value}]</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>OPTIONAL; if this function is defined, then <a href="#Module:end_per_group-2">Module:end_per_group-2</a>
must also be defined.</p><p>This configuration function is called before execution of a
test case group. It typically contains initializations that are 
common for all test cases and subgroups in the group, and that
must only be performed once. <strong>GroupName</strong> is the name of the
group, as specified in the group definition (see
<a href="#Module:groups-0">Module:groups-0</a>).
Parameter <strong>Config</strong> is the configuration data that can be
modified.
The return value of this function is given as <strong>Config</strong>
to all test cases and subgroups in the group.</p><p>If <strong>{skip,Reason}</strong>
is returned, all test cases in the group are skipped and
<strong>Reason</strong> is printed in the overview log for the group.</p><p>For information about test case groups, see section 
<a href="./write_test_chapter#test_case_groups">Test Case  Groups</a> in the User's Guide.</p><h3>Module:end_per_group(GroupName, Config) -&gt; term() |
	  {return_group_result,Status}</h3><p>Test case group finalization.</p><ul><li><span class="v">GroupName = atom()</span></li><li><span class="v">Config = [{Key,Value}]</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Status = ok | skipped | failed</span></li></ul><p>OPTIONAL; if this function is defined, then <a href="#Module:init_per_group-2">Module:init_per_group-2</a>
must also be defined.</p><p>This function is called after the execution of a test case group
is finished. It is meant to be used for cleaning up after
<a href="#Module:init_per_group-2">Module:init_per_group-2</a>.
A status value for a nested subgroup can be returned with
<strong>{return_group_result,Status}</strong>. The status can be retrieved in
<a href="#Module:end_per_group-2">Module:end_per_group-2</a>
for the group on the level above. The status is also used by
<strong>Common Test</strong> for deciding if execution of a group is to
proceed if property <strong>sequence</strong> or <strong>repeat_until_*</strong>
is set.</p><p>For details about test case groups, see section 
<a href="./write_test_chapter#test_case_groups">Test Case Groups</a> in the User's Guide.</p><h3>Module:init_per_testcase(TestCase, Config) -&gt; NewConfig | {fail,Reason} | {skip,Reason}</h3><p>Test case initializations.</p><ul><li><span class="v"> TestCase = atom()</span></li><li><span class="v"> Config = NewConfig = [{Key,Value}]</span></li><li><span class="v"> Key = atom()</span></li><li><span class="v"> Value = term()</span></li><li><span class="v"> Reason = term()</span></li></ul><p>OPTIONAL; if this function is defined,
then <a href="#Module:end_per_testcase-2">Module:end_per_testcase-2</a> must also be
defined.</p><p>This function is called before each test case. Argument
<strong>TestCase</strong> is the test case name, and
<strong>Config</strong> (list of key-value tuples) is the configuration
data that can be modified. The <strong>NewConfig</strong> list returned
from this function is given as <strong>Config</strong> to the test case.
If <strong>{fail,Reason}</strong> is returned, the test case is
marked as failed without being executed.</p><p>If <strong>{skip,Reason}</strong> is returned, the test case is skipped
and <strong>Reason</strong> is printed in the overview log for the suite.</p><h3>Module:end_per_testcase(TestCase, Config) -&gt; term() | {fail,Reason} | {save_config,SaveConfig}</h3><p>Test case finalization.</p><ul><li><span class="v">TestCase = atom()</span></li><li><span class="v">Config = SaveConfig = [{Key,Value}]</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>OPTIONAL; if this function is defined,
then <a href="#Module:init_per_testcase-2">Module:init_per_testcase-2</a> must also be
defined.</p><p>This function is called after each test case, and can be used
to clean up after
<a href="#Module:init_per_testcase-2">Module:init_per_testcase-2</a>
and the test case. Any return value (besides <strong>{fail,Reason}</strong>
and <strong>{save_config,SaveConfig}</strong>) is ignored. By returning
<strong>{fail,Reason}</strong>, <strong>TestCase</strong> is marked as faulty (even
though it was successful in the sense that it returned
a value instead of terminating).</p><p>For information on <strong>save_config</strong>, see section
<a href="./dependencies_chapter#save_config">Saving Configuration Data</a> in the User's Guide.</p><h3>Module:Testcase() -&gt; [Info]</h3><p>Test case information function.</p><ul><li><span class="v">Info = {timetrap,Time} | {require,Required} | {require,Name,Required} | {userdata,UserData} | {silent_connections,Conns}</span></li><li><span class="v">Time = TimeVal | TimeFunc</span></li><li><span class="v">TimeVal = MilliSec | {seconds,integer()} | {minutes,integer()} | {hours,integer()}</span></li><li><span class="v">TimeFunc = {Mod,Func,Args} | Fun</span></li><li><span class="v">MilliSec = integer()</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">Func = atom()</span></li><li><span class="v">Args = list()</span></li><li><span class="v">Fun = fun()</span></li><li><span class="v">Required = Key | {Key,SubKeys} | {Key,Subkey} | {Key,Subkey,SubKeys}</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">SubKeys = SubKey | [SubKey]</span></li><li><span class="v">SubKey = atom()</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">UserData = term()</span></li><li><span class="v">Conns = [atom()]</span></li></ul><p>OPTIONAL</p><p>The test case information function. It is supposed to
return a list of tagged tuples that specify various properties
related to the execution of this particular test case.
Properties set by
<a href="#Module:Testcase-0">Module:Testcase-0</a>
override properties set previously for the test case by
<a href="#Module:group-1">Module:group-1</a> or
<a href="#Module:suite-0">Module:suite-0</a>.</p><p>Tag <strong>timetrap</strong> sets the maximum time that the
test case is allowed to execute. If the timetrap time is
exceeded, the test case fails with reason <strong>timetrap_timeout</strong>.
<a href="#Module:init_per_testcase-2">Module:init_per_testcase-2</a>
and
<a href="#Module:end_per_testcase-2">Module:end_per_testcase-2</a>
are included in the timetrap time.
A <strong>TimeFunc</strong> function can be used to
set a new timetrap by returning a <strong>TimeVal</strong>. It can also be
used to trigger a timetrap time-out by, at some point, returning a
value other than a <strong>TimeVal</strong>. For details, see section
<a href="./write_test_chapter#timetraps">Timetrap Time-Outs</a> in the User's Guide.</p><p>Tag <strong>require</strong> specifies configuration variables
that are required by the test case (or <strong>init_per_testcase/2</strong>
or <strong>end_per_testcase/2</strong>).
If the required configuration variables are not found in any of the
configuration files, the test case is skipped. For details about
the <strong>require</strong> functionality, see function
<a href="./ct#require-1">ct#require-1</a>.</p><p>If <strong>timetrap</strong> or <strong>require</strong> is not set, the
default values specified by
<a href="#Module:suite-0">Module:suite-0</a> (or
<a href="#Module:group-1">Module:group-1</a>) are used.</p><p>With <strong>userdata</strong>, the user can specify any test case-related
information that can be read by calling
<a href="./ct#userdata-3">ct#userdata-3</a>.</p><p>Other tuples than the ones defined are ignored.</p><p>For details about the test case information function, see section
<a href="./write_test_chapter#info_function">Test Case Information Function</a> in the User's Guide.</p><h3>Module:Testcase(Config) -&gt;  term() | {skip,Reason} | {comment,Comment} | {save_config,SaveConfig} | {skip_and_save,Reason,SaveConfig} | exit()</h3><p>A test case.</p><ul><li><span class="v">Config = SaveConfig = [{Key,Value}]</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Reason = term()</span></li><li><span class="v">Comment = string()</span></li></ul><p>MANDATORY</p><p>The implementation of a test case. Call the functions to test and
check the result. If something fails, ensure the
function causes a runtime error or call
<a href="./ct#fail-1">ct#fail-1</a>
(which also causes the test case process to terminate).</p><p>Elements from the <strong>Config</strong> list can, for example, be read
with <strong>proplists:get_value/2</strong> in STDLIB
(or the macro <strong>?config</strong> defined in <strong>ct.hrl</strong>).</p><p>If you decide not to run the test case after all, return
<strong>{skip,Reason}</strong>. <strong>Reason</strong> is then
printed in field <strong>Comment</strong> on the HTML result page.</p><p>To print some information in field <strong>Comment</strong> on the HTML
result page, return <strong>{comment,Comment}</strong>.</p><p>If the function returns anything else, the test case is
considered successful. The return value always gets printed
in the test case log file.</p><p>For details about test case implementation, see section
<a href="./write_test_chapter#test_cases">Test Cases</a>
in the User's Guide.</p><p>For information on <strong>save_config</strong> and <strong>skip_and_save</strong>,
see section
<a href="./dependencies_chapter#save_config">Saving Configuration Data</a> in the User's Guide.</p><h2>ct_run</h2><p>Program used for starting Common Test from the
    OS command line.</p><p>The <strong>ct_run</strong> program is automatically installed with Erlang/OTP
and the <strong>Common Test</strong> application (for more information, see
section <a href="install_chapter">Installation</a>
in the User's Guide). The program accepts different start flags.
Some flags trigger <strong>ct_run</strong> to start <strong>Common Test</strong> and
pass on data to it. Some flags start an Erlang node prepared for
running <strong>Common Test</strong> in a particular mode.The interface function
<a href="./ct#run_test-1">ct#run_test-1</a>,
corresponding to the <strong>ct_run</strong> program, is used for starting
<strong>Common Test</strong> from the Erlang shell (or an Erlang program).
For details, see the <a href="ct">ct</a>
manual page.<strong>ct_run</strong> also accepts Erlang emulator flags. These are used
when <strong>ct_run</strong> calls <strong>erl</strong> to start the Erlang node (this
makes it possible to add directories to the code server path,
change the cookie on the node, start more applications, and so on).With the optional flag <strong>-erl_args</strong>, options on the <strong>ct_run</strong>
command line can be divided into two groups:<ul><li>One group that <strong>Common Test</strong> is to process (those preceding <strong>-erl_args</strong>).</li><li>One group that <strong>Common Test</strong> is to ignore and pass on directly to the emulator (those following <strong>-erl_args</strong>).</li></ul>Options preceding <strong>-erl_args</strong> that <strong>Common Test</strong>
does not recognize are also passed on to the emulator untouched.
By <strong>-erl_args</strong> the user can specify flags with the same name, but
with different destinations, on the <strong>ct_run</strong> command line.If flags <strong>-pa</strong> or <strong>-pz</strong> are specified in the
<strong>Common Test</strong> group of options (preceding <strong>-erl_args</strong>),
relative directories are converted to absolute and reinserted into
the code path by <strong>Common Test</strong>. This is to avoid problems
loading user modules when <strong>Common Test</strong> changes working directory
during test runs. However, <strong>Common Test</strong> ignores flags <strong>-pa</strong>
and <strong>-pz</strong> following <strong>-erl_args</strong> on the command line. These
directories are added to the code path normally (that is, on specified
form).Exit status is set before the program ends. Value <strong>0</strong> indicates
a successful test result, <strong>1</strong> indicates one or more failed or
auto-skipped test cases, and <strong>2</strong> indicates test execution failure.If <strong>ct_run</strong> is called with option <strong>-help</strong>, it prints all
valid start flags to <strong>stdout</strong>.</p><a name="ct_run"></a><h3>Run Tests from Command Line</h3><pre>
 ct_run -dir TestDir1 TestDir2 .. TestDirN |
  [-dir TestDir] -suite Suite1 Suite2 .. SuiteN
  [-group Groups1 Groups2 .. GroupsN] [-case Case1 Case2 .. CaseN]
  [-step [config | keep_inactive]]
  [-config ConfigFile1 ConfigFile2 .. ConfigFileN]
  [-userconfig CallbackModule1 ConfigString1 and CallbackModule2
   ConfigString2 and .. CallbackModuleN ConfigStringN]
  [-decrypt_key Key] | [-decrypt_file KeyFile]
  [-label Label]
  [-logdir LogDir]
  [-logopts LogOpts]
  [-verbosity GenVLevel | [Category1 VLevel1 and
   Category2 VLevel2 and .. CategoryN VLevelN]]
  [-silent_connections [ConnType1 ConnType2 .. ConnTypeN]]
  [-stylesheet CSSFile]
  [-cover CoverCfgFile]
  [-cover_stop Bool]
  [-event_handler EvHandler1 EvHandler2 .. EvHandlerN] |
  [-event_handler_init EvHandler1 InitArg1 and
   EvHandler2 InitArg2 and .. EvHandlerN InitArgN]
  [-include InclDir1 InclDir2 .. InclDirN]
  [-no_auto_compile]
  [-abort_if_missing_suites]
  [-muliply_timetraps Multiplier]
  [-scale_timetraps]
  [-create_priv_dir auto_per_run | auto_per_tc | manual_per_tc]
  [-repeat N] |
  [-duration HHMMSS [-force_stop [skip_rest]]] |
  [-until [YYMoMoDD]HHMMSS [-force_stop [skip_rest]]]
  [-basic_html]
  [-no_esc_chars]
  [-keep_logs all | NLogs]
  [-ct_hooks CTHModule1 CTHOpts1 and CTHModule2 CTHOpts2 and ..
   CTHModuleN CTHOptsN]
  [-exit_status ignore_config]
  [-help]</pre><h3>Run Tests using Test Specification</h3><pre>
 ct_run -spec TestSpec1 TestSpec2 .. TestSpecN
  [-join_specs]
  [-config ConfigFile1 ConfigFile2 .. ConfigFileN]
  [-userconfig CallbackModule1 ConfigString1 and CallbackModule2
   ConfigString2 and .. and CallbackModuleN ConfigStringN]
  [-decrypt_key Key] | [-decrypt_file KeyFile]
  [-label Label]
  [-logdir LogDir]
  [-logopts LogOpts]
  [-verbosity GenVLevel | [Category1 VLevel1 and
   Category2 VLevel2 and .. CategoryN VLevelN]]
  [-allow_user_terms]
  [-silent_connections [ConnType1 ConnType2 .. ConnTypeN]]
  [-stylesheet CSSFile]
  [-cover CoverCfgFile]
  [-cover_stop Bool]
  [-event_handler EvHandler1 EvHandler2 .. EvHandlerN] |
  [-event_handler_init EvHandler1 InitArg1 and
   EvHandler2 InitArg2 and .. EvHandlerN InitArgN]
  [-include InclDir1 InclDir2 .. InclDirN]
  [-no_auto_compile]
  [-abort_if_missing_suites]
  [-muliply_timetraps Multiplier]
  [-scale_timetraps]
  [-create_priv_dir auto_per_run | auto_per_tc | manual_per_tc]
  [-repeat N] |
  [-duration HHMMSS [-force_stop [skip_rest]]] |
  [-until [YYMoMoDD]HHMMSS [-force_stop [skip_rest]]]
  [-basic_html]
  [-no_esc_chars]
  [-keep_logs all | NLogs]
  [-ct_hooks CTHModule1 CTHOpts1 and CTHModule2 CTHOpts2 and ..
   CTHModuleN CTHOptsN]
  [-exit_status ignore_config]</pre><h3>Run Tests in Web-Based GUI</h3><pre>
 ct_run -vts [-browser Browser]
  [-dir TestDir1 TestDir2 .. TestDirN] |
  [[dir TestDir] -suite Suite [[-group Group] [-case Case]]]
  [-config ConfigFile1 ConfigFile2 .. ConfigFileN]
  [-userconfig CallbackModule1 ConfigString1 and CallbackModule2
    ConfigString2 and .. and CallbackModuleN ConfigStringN]
  [-logopts LogOpts]
  [-verbosity GenVLevel | [Category1 VLevel1 and
   Category2 VLevel2 and .. CategoryN VLevelN]]
  [-decrypt_key Key] | [-decrypt_file KeyFile]
  [-include InclDir1 InclDir2 .. InclDirN]
  [-no_auto_compile]
  [-abort_if_missing_suites]
  [-muliply_timetraps Multiplier]
  [-scale_timetraps]
  [-create_priv_dir auto_per_run | auto_per_tc | manual_per_tc]
  [-basic_html]
  [-no_esc_chars]
  [-keep_logs all | NLogs]</pre><h3>Refresh HTML Index Files</h3><pre>
 ct_run -refresh_logs [-logdir LogDir] [-basic_html]
  [-keep_logs all | NLogs]</pre><h3>Run Common Test in Interactive Mode</h3><pre>
 ct_run -shell
  [-config ConfigFile1 ConfigFile2 ... ConfigFileN]
  [-userconfig CallbackModule1 ConfigString1 and CallbackModule2
   ConfigString2 and .. and CallbackModuleN ConfigStringN]
  [-decrypt_key Key] | [-decrypt_file KeyFile]</pre><h3>Start a Common Test Master Node</h3><pre>
 ct_run -ctmaster</pre><h3>See Also</h3><p>For information about the start flags, see section
<a href="run_test_chapter">Running Tests and Analyzing Results</a> in the User's Guide.</p><h2>ct</h2><p>Main user interface for the Common Test framework.</p><p>Main user interface for the <strong>Common Test</strong> framework.This module implements the command-line interface for running
tests and basic functions for <strong>Common Test</strong> case issues, such as
configuration and logging.<em>Test Suite Support Macros</em>The <strong>config</strong> macro is defined in <strong>ct.hrl</strong>. This macro is
to be used to retrieve information from the <strong>Config</strong> variable sent
to all test cases. It is used with two arguments; the first is the name
of the configuration variable to retrieve, the second is the
<strong>Config</strong> variable supplied to the test case.Possible configuration variables include:<ul><li><p><strong>data_dir</strong> - Data file directory</p></li><li><p><strong>priv_dir</strong> - Scratch file directory</p></li><li><p>Whatever added by
<a href="./common_test#Module:init_per_suite-1">common_test#Module:init_per_suite-1</a>
or
<a href="./common_test#Module:init_per_testcase-2">common_test#Module:init_per_testcase-2</a>
in the test suite.</p></li></ul></p><h3>Data Types</h3><a name="types"></a><dl><dt> <a name="type-handle"></a> <strong>handle() = pid()</strong> </dt><dd> <p>The identity (handle) of a connection.</p> </dd><dt> <a name="type-config_key"></a> <strong>config_key() = atom()</strong> </dt><dd> <p>A configuration key which exists in a configuration file</p> </dd><dt> <a name="type-target_name"></a><strong>target_name() = atom()</strong> </dt><dd> <p>A name and association to configuration data introduced
through a require statement, or a call to
<a href="#require-2">require-2</a>,
for example,
<strong>ct:require(mynodename,{node,[telnet]})</strong>.</p> </dd><dt> <a name="type-key_or_name"></a> <strong>key_or_name() = config_key() | target_name()</strong> </dt><dd></dd><dt> <a name="type-conn_log_options"></a> <strong>conn_log_options() = [conn_log_option()]</strong> </dt><dd> <p>Options that can be given to the <strong>cth_conn_log</strong> hook,
which is used for logging of NETCONF and Telnet
connections. See
<a href="./ct_netconfc#Logging">ct_netconfc</a>
or <a href="./ct_telnet#Logging">ct_telnet</a>
for description and examples of how to use this hook.</p> </dd><dt> <a name="type-conn_log_option"></a> <strong>conn_log_option() = {log_type,conn_log_type()} | {hosts,[key_or_name()]}</strong> </dt><dd></dd><dt> <a name="type-conn_log_type"></a> <strong>conn_log_type() = raw | pretty | html | silent</strong> </dt><dd></dd><dt> <a name="type-conn_log_mod"></a> <strong>conn_log_mod() = ct_netconfc | ct_telnet</strong> </dt><dd></dd></dl><h2>Functions</h2><h3>abort_current_testcase(Reason) -&gt; ok | {error, ErrorReason}</h3><p>Aborts the currently executing test case.</p><ul><li><span class="v">Reason = term()</span></li><li><span class="v">ErrorReason = no_testcase_running | parallel_group</span></li></ul><a name="abort_current_testcase-1"></a><p>Aborts the currently executing test case. The user must know with
certainty which test case is currently executing. The function is
therefore only safe to call from a function that has been called
(or synchronously invoked) by the test case.</p><p><strong>Reason</strong>, the reason for aborting the test case, is printed
in the test case log.</p><h3>add_config(Callback, Config) -&gt; ok | {error, Reason}</h3><p>Loads configuration variables using the specified callback module and configuration string.</p><ul><li><span class="v">Callback = atom()</span></li><li><span class="v">Config = string()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="add_config-2"></a><p>Loads configuration variables using the specified callback module and
configuration string. The callback module is to be either loaded or
present in the code part. Loaded configuration variables can later
be removed using function
<a href="#remove_config-2">remove_config-2</a>.
</p><h3>break(Comment) -&gt; ok | {error, Reason}</h3><p>Cancels any active timetrap and pause the execution of the current test case until the user calls function continue/0.</p><ul><li><span class="v">Comment = string()</span></li><li><span class="v">Reason = {multiple_cases_running, TestCases} | 'enable break with release_shell option'</span></li><li><span class="v">TestCases = [atom()]</span></li></ul><a name="break-1"></a><p>Cancels any active timetrap and pauses the execution of the
current test case until the user calls function <strong>continue/0</strong>.
The user can then interact with the Erlang node running the tests,
for example, for debugging purposes or for manually executing a
part of the test case. If a parallel group is executing,
<a href="#break-2">break-2</a> is to be
called instead.</p><p>A cancelled timetrap is not automatically reactivated after the
break, but must be started exlicitly with
<a href="#timetrap-1">timetrap-1</a>.</p><p>In order for the break/continue functionality to work, <strong>Common Test</strong> must release the shell process controlling <strong>stdin</strong>.
This is done by setting start option <strong>release_shell</strong>
to <strong>true</strong>. For details, see section
<a href="./run_test_chapter#erlang_shell_or_program">Running Tests from the Erlang Shell or from an Erlang Program</a>
in the User's Guide.</p><h3>break(TestCase, Comment) -&gt; ok | {error, Reason}</h3><p>Works the same way as break/1, only argument TestCase makes it possible to pause a test case executing in a parallel group.</p><ul><li><span class="v">TestCase = atom()</span></li><li><span class="v">Comment = string()</span></li><li><span class="v">Reason = 'test case not running' | 'enable break with release_shell option'</span></li></ul><a name="break-2"></a><p>Works the same way as
<a href="#break-1">break-1</a>, only
argument <strong>TestCase</strong> makes it possible to pause a test case
executing in a parallel group. Function
<a href="#continue-1">continue-1</a> is to
be used to resume execution of <strong>TestCase</strong>.</p><p>For details, see
<a href="#break/1">break/1</a>.</p><h3>capture_get() -&gt; ListOfStrings</h3><p>Equivalent to capture_get([default]).</p><ul><li><span class="v">ListOfStrings = [string()]</span></li></ul><a name="capture_get-0"></a><p>Equivalent to
<a href="#capture_get-1">ct:capture_get([default])</a>.</p><h3>capture_get(ExclCategories) -&gt; ListOfStrings</h3><p>Returns and purges the list of text strings buffered during the latest session of capturing printouts to stdout.</p><ul><li><span class="v">ExclCategories = [atom()]</span></li><li><span class="v">ListOfStrings = [string()]</span></li></ul><a name="capture_get-1"></a><p>Returns and purges the list of text strings buffered during the
latest session of capturing printouts to <strong>stdout</strong>. Log
categories that are to be ignored in <strong>ListOfStrings</strong> can be
specified with <strong>ExclCategories</strong>.
If <strong>ExclCategories = []</strong>, no filtering takes place.</p><p>See also
<a href="#capture_start-0">capture_start-0</a>,
<a href="#capture_stop-0">capture_stop-0</a>,
<a href="#log-3">log-3</a>.</p><h3>capture_start() -&gt; ok</h3><p>Starts capturing all text strings printed to stdout during execution of the test case.</p><a name="capture_start-0"></a><p>Starts capturing all text strings printed to <strong>stdout</strong>
during execution of the test case.</p><p>See also
<a href="#capture_get-1">capture_get-1</a>,
<a href="#capture_stop-0">capture_stop-0</a>.</p><h3>capture_stop() -&gt; ok</h3><p>Stops capturing text strings (a session started with capture_start/0).</p><a name="capture_stop-0"></a><p>Stops capturing text strings (a session started with
<strong>capture_start/0</strong>).</p><p>See also
<a href="#capture_get-1">capture_get-1</a>,
<a href="#capture_start-0">capture_start-0</a>.</p><h3>comment(Comment) -&gt; ok</h3><p>Prints the specified Comment in the comment field in the table on the test suite result page.</p><ul><li><span class="v">Comment = term()</span></li></ul><a name="comment-1"></a><p>Prints the specified <strong>Comment</strong> in the comment field in the
table on the test suite result page.</p><p>If called several times, only the last comment is printed. The
test case return value <strong>{comment,Comment}</strong> overwrites the
string set by this function.</p><h3>comment(Format, Args) -&gt; ok</h3><p>Prints the formatted string in the comment field in the table on the test suite result page.</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><a name="comment-2"></a><p>Prints the formatted string in the comment field in the table
on the test suite result page.</p><p>Arguments <strong>Format</strong> and <strong>Args</strong> are used in a call to
<strong>io_lib:format/2</strong> to create the comment string. The behavior
of <strong>comment/2</strong> is otherwise the same as function
<a href="#comment-1">comment-1</a>.</p><h3>continue() -&gt; ok</h3><p>This function must be called to continue after a test case (not executing in a parallel group) has called break/1.</p><a name="continue-0"></a><p>This function must be called to continue after a test case
(not executing in a parallel group) has called function
<a href="#break-1">break-1</a>.</p><h3>continue(TestCase) -&gt; ok</h3><p>This function must be called to continue after a test case has called break/2.</p><ul><li><span class="v">TestCase = atom()</span></li></ul><a name="continue-1"></a><p>This function must be called to continue after a test case has
called <a href="#break-2">break-2</a>.
If the paused test case, <strong>TestCase</strong>, executes in a parallel
group, this function, rather than <strong>continue/0</strong>, must be used
to let the test case proceed.</p><h3>decrypt_config_file(EncryptFileName, TargetFileName) -&gt; ok | {error, Reason}</h3><p>Decrypts EncryptFileName, previously generated with encrypt_config_file/2,3.</p><ul><li><span class="v">EncryptFileName = string()</span></li><li><span class="v">TargetFileName = string()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="decrypt_config_file-2"></a><p>Decrypts <strong>EncryptFileName</strong>, previously generated with
<a href="#encrypt_config_file-2">encrypt_config_file-2</a>.
The original file contents is saved in the target file. The
encryption key, a string, must be available in a text file named
<strong>.ct_config.crypt</strong>, either in the current directory, or the
home directory of the user (it is searched for in that order).</p><h3>decrypt_config_file(EncryptFileName, TargetFileName, KeyOrFile) -&gt; ok | {error, Reason}</h3><p>Decrypts EncryptFileName, previously generated with encrypt_config_file/2,3.</p><ul><li><span class="v">EncryptFileName = string()</span></li><li><span class="v">TargetFileName = string()</span></li><li><span class="v">KeyOrFile = {key, string()} | {file, string()}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="decrypt_config_file-3"></a><p>Decrypts <strong>EncryptFileName</strong>, previously generated with
<a href="#encrypt_config_file-2">encrypt_config_file-2</a>.
The original file contents is saved in the target file. The key
must have the same value as that used for encryption.</p><h3>encrypt_config_file(SrcFileName, EncryptFileName) -&gt; ok | {error, Reason}</h3><p>Encrypts the source configuration file with DES3 and saves the result in file EncryptFileName.</p><ul><li><span class="v">SrcFileName = string()</span></li><li><span class="v">EncryptFileName = string()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="encrypt_config_file-2"></a><p>Encrypts the source configuration file with DES3 and saves the result
in file <strong>EncryptFileName</strong>. The key, a string, must be
available in a text file named <strong>.ct_config.crypt</strong>, either
in the current directory, or the home directory of the user (it
is searched for in that order).</p><p>For information about using encrypted configuration files when
running tests, see section
<a href="./config_file_chapter#encrypted_config_files">Encrypted Configuration Files</a> in the User's Guide.</p><p>For details on DES3 encryption/decryption, see application
<a href="./index">crypto/index</a>.</p><h3>encrypt_config_file(SrcFileName, EncryptFileName, KeyOrFile) -&gt; ok | {error, Reason}</h3><p>Encrypts the source configuration file with DES3 and saves the result in the target file EncryptFileName.</p><ul><li><span class="v">SrcFileName = string()</span></li><li><span class="v">EncryptFileName = string()</span></li><li><span class="v">KeyOrFile = {key, string()} | {file, string()}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="encrypt_config_file-3"></a><p>Encrypts the source configuration file with DES3 and saves the result
in the target file <strong>EncryptFileName</strong>. The encryption key
to use is either the value in <strong>{key,Key}</strong> or the value
stored in the file specified by <strong>{file,File}</strong>.</p><p>For information about using encrypted configuration files when
running tests, see section
<a href="./config_file_chapter#encrypted_config_files">Encrypted Configuration Files</a> in the User's Guide.</p><p>For details on DES3 encryption/decryption, see application
<a href="./index">crypto/index</a>.</p><h3>fail(Reason) -&gt; ok</h3><p>Terminates a test case with the specified error Reason.</p><ul><li><span class="v">Reason = term()</span></li></ul><a name="fail-1"></a><p>Terminates a test case with the specified error <strong>Reason</strong>.</p><h3>fail(Format, Args) -&gt; ok</h3><p>Terminates a test case with an error message specified by a format string and a list of values (used as arguments to io_lib:format/2).</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><a name="fail-2"></a><p>Terminates a test case with an error message specified by a
format string and a list of values (used as arguments to
<strong>io_lib:format/2</strong>).</p><h3>get_config(Required) -&gt; Value</h3><p>Equivalent to get_config(Required, undefined, []).</p><a name="get_config-1"></a><p>Equivalent to <a href="#get_config-3">get_config-3</a>.</p><h3>get_config(Required, Default) -&gt; Value</h3><p>Equivalent to get_config(Required, Default, []).</p><a name="get_config-2"></a><p>Equivalent to <a href="#get_config-3">get_config-3</a>.</p><h3>get_config(Required, Default, Opts) -&gt; ValueOrElement</h3><p>Reads configuration data values.</p><ul><li><span class="v">Required = KeyOrName | {KeyOrName, SubKey} | {KeyOrName, SubKey, SubKey}</span></li><li><span class="v">KeyOrName = atom()</span></li><li><span class="v">SubKey = atom()</span></li><li><span class="v">Default = term()</span></li><li><span class="v">Opts = [Opt] | []</span></li><li><span class="v">Opt = element | all</span></li><li><span class="v">ValueOrElement = term() | Default</span></li></ul><a name="get_config-3"></a><p>Reads configuration data values.</p><p>Returns the matching values or configuration elements, given a
configuration variable key or its associated name (if one has been
specified with
<a href="#require-2">require-2</a>
or a <strong>require</strong> statement).</p><p><em>Example:</em></p><p>Given the following configuration file:</p><pre>
 {unix,[{telnet,IpAddr},
        {user,[{username,Username},
               {password,Password}]}]}.</pre><p>Then:</p><pre>
 ct:get_config(unix,Default) -&gt; [{telnet,IpAddr}, 
  {user, [{username,Username}, {password,Password}]}]
 ct:get_config({unix,telnet},Default) -&gt; IpAddr
 ct:get_config({unix,user,username},Default) -&gt; Username
 ct:get_config({unix,ftp},Default) -&gt; Default
 ct:get_config(unknownkey,Default) -&gt; Default</pre><p>If a configuration variable key has been associated with a name (by
<a href="#require-2">require-2</a>
or a <strong>require</strong> statement), the name can be used instead
of the key to read the value:</p><pre>
 ct:require(myuser,{unix,user}) -&gt; ok.
 ct:get_config(myuser,Default) -&gt; [{username,Username}, {password,Password}]</pre><p>If a configuration variable is defined in multiple files, use option
<strong>all</strong> to access all possible values. The values are returned
in a list. The order of the elements corresponds to the order
that the configuration files were specified at startup.</p><p>If configuration elements (key-value tuples) are to be returned as
result instead of values, use option <strong>element</strong>. The
returned elements are then on the form <strong>{Required,Value}</strong>.</p><p>See also
<a href="#get_config-1">get_config-1</a>,
<a href="#get_config-2">get_config-2</a>,
<a href="#require-1">require-1</a>,
<a href="#require-2">require-2</a>.</p><h3>get_event_mgr_ref() -&gt; EvMgrRef</h3><p>Gets a reference to the <strong>Common Test</strong> event manager.</p><ul><li><span class="v">EvMgrRef = atom()</span></li></ul><a name="get_event_mgr_ref-0"></a><p>Gets a reference to the <strong>Common Test</strong> event manager.
The reference can be used to, for example, add a user-specific
event handler while tests are running.</p><p><em>Example:</em></p><pre>
 gen_event:add_handler(ct:get_event_mgr_ref(), my_ev_h, [])</pre><h3>get_progname() -&gt; string()</h3><p>Returns the command used to start this Erlang instance.</p><a name="get_progname-0"></a><p>Returns the command used to start this Erlang instance.
If this information could not be found, the string
<strong>"no_prog_name"</strong> is returned.</p><h3>get_status() -&gt; TestStatus | {error, Reason} | no_tests_running</h3><p>Returns status of ongoing test.</p><ul><li><span class="v">TestStatus = [StatusElem]</span></li><li><span class="v">StatusElem = {current, TestCaseInfo} | {successful, Successful} | {failed, Failed} | {skipped, Skipped} | {total, Total}</span></li><li><span class="v">TestCaseInfo = {Suite, TestCase} | [{Suite, TestCase}]</span></li><li><span class="v">Suite = atom()</span></li><li><span class="v">TestCase = atom()</span></li><li><span class="v">Successful = integer()</span></li><li><span class="v">Failed = integer()</span></li><li><span class="v">Skipped = {UserSkipped, AutoSkipped}</span></li><li><span class="v">UserSkipped = integer()</span></li><li><span class="v">AutoSkipped = integer()</span></li><li><span class="v">Total = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="get_status-0"></a><p>Returns status of ongoing test. The returned list contains
information about which test case is executing (a list of cases
when a parallel test case group is executing), as well as
counters for successful, failed, skipped, and total test cases
so far.</p><h3>get_target_name(Handle) -&gt; {ok, TargetName} | {error, Reason}</h3><p>Returns the name of the target that the specified connection belongs to.</p><ul><li><span class="v">Handle = handle()</span></li><li><span class="v">TargetName = target_name()</span></li></ul><a name="get_target_name-1"></a><p>Returns the name of the target that the specified connection
belongs to.</p><h3>get_testspec_terms() -&gt; TestSpecTerms | undefined</h3><p>Gets a list of all test specification terms used to configure and run this test.</p><ul><li><span class="v">TestSpecTerms = [{Tag, Value}]</span></li><li><span class="v">Value = [term()]</span></li></ul><a name="get_testspec_terms-0"></a><p>Gets a list of all test specification terms used to configure
and run this test.</p><h3>get_testspec_terms(Tags) -&gt; TestSpecTerms | undefined</h3><p>Reads one or more terms from the test specification used to configure and run this test.</p><ul><li><span class="v">Tags = [Tag] | Tag</span></li><li><span class="v">Tag = atom()</span></li><li><span class="v">TestSpecTerms = [{Tag, Value}] | {Tag, Value}</span></li><li><span class="v">Value = [{Node, term()}] | [term()]</span></li><li><span class="v">Node = atom()</span></li></ul><a name="get_testspec_terms-1"></a><p>Reads one or more terms from the test specification used to
configure and run this test. <strong>Tag</strong> is any valid test
specification tag, for example, <strong>label</strong>, <strong>config</strong>, or
<strong>logdir</strong>. User-specific terms are also available to read if
option <strong>allow_user_terms</strong> is set.</p><p>All value tuples returned, except user terms, have the node
name as first element.</p><p>To read test terms, use <strong>Tag = tests</strong> (rather than
<strong>suites</strong>, <strong>groups</strong>, or <strong>cases</strong>). <strong>Value</strong> is
then the list of <em>all</em> tests on the form
<strong>[{Node,Dir,[{TestSpec,GroupsAndCases1},...]},...]</strong>, where
<strong>GroupsAndCases = [{Group,[Case]}] | [Case]</strong>.</p><h3>get_timetrap_info() -&gt; {Time, {Scaling,ScaleVal}}</h3><p>Reads information about the timetrap set for the current test case.</p><ul><li><span class="v">Time = integer() | infinity</span></li><li><span class="v">Scaling = true | false</span></li><li><span class="v">ScaleVal = integer()</span></li></ul><a name="get_timetrap_info-0"></a><p>Reads information about the timetrap set for the current test
case. <strong>Scaling</strong> indicates if <strong>Common Test</strong> will attempt
to compensate timetraps automatically for runtime delays
introduced by, for example, tools like cover. <strong>ScaleVal</strong> is
the value of the current scaling multipler (always 1 if scaling is
disabled). Note the <strong>Time</strong> is not the scaled result.</p><h3>get_verbosity(Category) -&gt; Level | undefined</h3><p>Read the verbosity level for a logging category.</p><ul><li><span class="v">Category = default | atom()</span></li><li><span class="v">Level = integer()</span></li></ul><a name="get_verbosity-1"></a><p>This function returns the verbosity level for the specified logging
category. See the <a href="./write_test_chapter#logging"> User's Guide</a> for details. Use the value <strong>default</strong> to read
the general verbosity level.</p><h3>install(Opts) -&gt; ok | {error, Reason}</h3><p>Installs configuration files and event handlers.</p><ul><li><span class="v">Opts = [Opt]</span></li><li><span class="v">Opt = {config, ConfigFiles} | {event_handler, Modules} | {decrypt, KeyOrFile}</span></li><li><span class="v">ConfigFiles = [ConfigFile]</span></li><li><span class="v">ConfigFile = string()</span></li><li><span class="v">Modules = [atom()]</span></li><li><span class="v">KeyOrFile = {key, Key} | {file, KeyFile}</span></li><li><span class="v">Key = string()</span></li><li><span class="v">KeyFile = string()</span></li></ul><a name="install-1"></a><p>Installs configuration files and event handlers.</p><p>Run this function once before the first test.</p><p><em>Example:</em></p><pre>
 install([{config,["config_node.ctc","config_user.ctc"]}])</pre><p>This function is automatically run by program <strong>ct_run</strong>.</p><h3>listenv(Telnet) -&gt; [Env]</h3><p>Performs command listenv on the specified Telnet connection and returns the result as a list of key-value pairs.</p><ul><li><span class="v">Telnet = term()</span></li><li><span class="v">Env = {Key, Value}</span></li><li><span class="v">Key = string()</span></li><li><span class="v">Value = string()</span></li></ul><a name="listenv-1"></a><p>Performs command <strong>listenv</strong> on the specified Telnet connection
and returns the result as a list of key-value pairs.</p><h3>log(Format) -&gt; ok</h3><p>Equivalent to log(default, 50, Format, [], []).</p><a name="log-1"></a><p>Equivalent to
<a href="#log-5">log-5</a>.</p><h3>log(X1, X2) -&gt; ok</h3><p>Equivalent to log(Category, Importance, Format, FormatArgs, []).</p><ul><li><span class="v">X1 = Category | Importance | Format</span></li><li><span class="v">X2 = Format | FormatArgs</span></li></ul><a name="log-2"></a><p>Equivalent to <a href="#log-5">log-5</a>.</p><h3>log(X1, X2, X3) -&gt; ok</h3><p>Equivalent to log(Category, Importance, Format, FormatArgs, Opts).</p><ul><li><span class="v">X1 = Category | Importance</span></li><li><span class="v">X2 = Importance | Format</span></li><li><span class="v">X3 = Format | FormatArgs | Opts</span></li></ul><a name="log-3"></a><p>Equivalent to <a href="#log-5">log-5</a>.</p><h3>log(X1, X2, X3, X4) -&gt; ok</h3><p>Equivalent to log(Category, Importance, Format, FormatArgs, Opts).</p><ul><li><span class="v">X1 = Category | Importance</span></li><li><span class="v">X2 = Importance | Format</span></li><li><span class="v">X3 = Format | FormatArgs</span></li><li><span class="v">X4 = FormatArgs | Opts</span></li></ul><a name="log-4"></a><p>Equivalent to <a href="#log-5">log-5</a>.</p><h3>log(Category, Importance, Format, FormatArgs, Opts) -&gt; ok</h3><p>Prints from a test case to the log file.</p><ul><li><span class="v">Category = atom()</span></li><li><span class="v">Importance = integer()</span></li><li><span class="v">Format = string()</span></li><li><span class="v">FormatArgs = list()</span></li><li><span class="v">Opts = [Opt]</span></li><li><span class="v">Opt = {heading,string()} | no_css | esc_chars</span></li></ul><a name="log-5"></a><p>Prints from a test case to the log file.</p><p>This function is meant for printing a string directly from a
test case to the test case log file.</p><p>Default <strong>Category</strong> is <strong>default</strong>,
default <strong>Importance</strong> is <strong>?STD_IMPORTANCE</strong>,
and default value for <strong>FormatArgs</strong> is <strong>[]</strong>.</p><p>For details on <strong>Category</strong>, <strong>Importance</strong> and the <strong>no_css</strong>
option, see section <a href="./write_test_chapter#logging"> Logging - Categories and Verbosity Levels</a> in the User's Guide.</p><p>Common Test will not escape special HTML characters (&lt;, &gt; and &amp;)
in the text printed with this function, unless the <strong>esc_chars</strong>
option is used.</p><h3>make_priv_dir() -&gt; ok | {error, Reason}</h3><p>If the test has been started with option create_priv_dir set to manual_per_tc, in order for the test case to use the private directory, it must first create it by calling this function.</p><ul><li><span class="v">Reason = term()</span></li></ul><a name="make_priv_dir-0"></a><p>If the test is started with option <strong>create_priv_dir</strong>
set to <strong>manual_per_tc</strong>, in order for the test case to use
the private directory, it must first create it by calling this
function.</p><h3>notify(Name, Data) -&gt; ok</h3><p>Sends an asynchronous notification of type Name with Data to the <strong>Common Test</strong> event manager.</p><ul><li><span class="v">Name = atom()</span></li><li><span class="v">Data = term()</span></li></ul><a name="notify-2"></a><p>Sends an asynchronous notification of type <strong>Name</strong> with
<strong>Data</strong>to the Common Test event manager. This can later be
caught by any installed event manager.</p><p>See also
<a href="./gen_event">stdlib/gen_event</a>.</p><h3>pal(Format) -&gt; ok</h3><p>Equivalent to pal(default, 50, Format, [], []).</p><a name="pal-1"></a><p>Equivalent to
<a href="#pal-5">pal-5</a>.</p><h3>pal(X1, X2) -&gt; ok</h3><p>Equivalent to pal(Category, Importance, Format, FormatArgs, []).</p><ul><li><span class="v">X1 = Category | Importance | Format</span></li><li><span class="v">X2 = Format | FormatArgs</span></li></ul><a name="pal-2"></a><p>Equivalent to <a href="#pal-5">pal-5</a>.</p><h3>pal(X1, X2, X3) -&gt; ok</h3><p>Equivalent to pal(Category, Importance, Format, FormatArgs, Opts).</p><ul><li><span class="v">X1 = Category | Importance</span></li><li><span class="v">X2 = Importance | Format</span></li><li><span class="v">X3 = Format | FormatArgs | Opts</span></li></ul><a name="pal-3"></a><p>Equivalent to <a href="#pal-5">pal-5</a>.</p><h3>pal(X1, X2, X3, X4) -&gt; ok</h3><p>Equivalent to pal(Category, Importance, Format, FormatArgs, Opts).</p><ul><li><span class="v">X1 = Category | Importance</span></li><li><span class="v">X2 = Importance | Format</span></li><li><span class="v">X3 = Format | FormatArgs</span></li><li><span class="v">X4 = FormatArgs | Opts</span></li></ul><a name="pal-4"></a><p>Equivalent to <a href="#pal-5">pal-5</a>.</p><h3>pal(Category, Importance, Format, FormatArgs, Opts) -&gt; ok</h3><p>Prints and logs from a test case.</p><ul><li><span class="v">Category = atom()</span></li><li><span class="v">Importance = integer()</span></li><li><span class="v">Format = string()</span></li><li><span class="v">FormatArgs = list()</span></li><li><span class="v">Opts = [Opt]</span></li><li><span class="v">Opt = {heading,string()} | no_css</span></li></ul><a name="pal-5"></a><p>Prints and logs from a test case.</p><p>This function is meant for printing a string from a test case,
both to the test case log file and to the console.</p><p>Default <strong>Category</strong> is <strong>default</strong>,
default <strong>Importance</strong> is <strong>?STD_IMPORTANCE</strong>,
and default value for <strong>FormatArgs</strong> is <strong>[]</strong>.</p><p>For details on <strong>Category</strong> and <strong>Importance</strong>, see section
<a href="./write_test_chapter#logging">Logging - Categories and Verbosity Levels</a> in the User's Guide.</p><p>Note that special characters in the text (&lt;, &gt; and &amp;) will
be escaped by Common Test before the text is printed to the log
file.</p><h3>parse_table(Data) -&gt; {Heading, Table}</h3><p>Parses the printout from an SQL table and returns a list of tuples.</p><ul><li><span class="v">Data = [string()]</span></li><li><span class="v">Heading = tuple()</span></li><li><span class="v">Table = [tuple()]</span></li></ul><a name="parse_table-1"></a><p>Parses the printout from an SQL table and returns a list of
tuples.</p><p>The printout to parse is typically the result of a <strong>select</strong>
command in SQL. The returned <strong>Table</strong> is a list of tuples,
where each tuple is a row in the table.</p><p><strong>Heading</strong> is a tuple of strings representing the headings
of each column in the table.</p><h3>print(Format) -&gt; ok</h3><p>Equivalent to print(default, 50, Format, [], []).</p><a name="print-1"></a><p>Equivalent to <a href="#print-5">print-5</a>.</p><h3>print(X1, X2) -&gt; ok</h3><p>Equivalent to print(Category, Importance, Format, FormatArgs, []).</p><ul><li><span class="v">X1 = Category | Importance | Format</span></li><li><span class="v">X2 = Format | FormatArgs</span></li></ul><a name="print-2"></a><p>Equivalent to <a href="#print-5">print-5</a>.</p><h3>print(X1, X2, X3) -&gt; ok</h3><p>Equivalent to print(Category, Importance, Format, FormatArgs, Opts).</p><ul><li><span class="v">X1 = Category | Importance</span></li><li><span class="v">X2 = Importance | Format</span></li><li><span class="v">X3 = Format | FormatArgs | Opts</span></li></ul><a name="print-3"></a><p>Equivalent to <a href="#print-5">print-5</a>.</p><h3>print(X1, X2, X3, X4) -&gt; ok</h3><p>Equivalent to print(Category, Importance, Format, FormatArgs, Opts).</p><ul><li><span class="v">X1 = Category | Importance</span></li><li><span class="v">X2 = Importance | Format</span></li><li><span class="v">X3 = Format | FormatArgs</span></li><li><span class="v">X4 = FormatArgs | Opts</span></li></ul><a name="print-4"></a><p>Equivalent to <a href="#print-5">print-5</a>.</p><h3>print(Category, Importance, Format, FormatArgs, Opts) -&gt; ok</h3><p>Prints from a test case to the console.</p><ul><li><span class="v">Category = atom()</span></li><li><span class="v">Importance = integer()</span></li><li><span class="v">Format = string()</span></li><li><span class="v">FormatArgs = list()</span></li><li><span class="v">Opts = [Opt]</span></li><li><span class="v">Opt = {heading,string()}</span></li></ul><a name="print-5"></a><p>Prints from a test case to the console.</p><p>This function is meant for printing a string from a test case to
the console.</p><p>Default <strong>Category</strong> is <strong>default</strong>,
default <strong>Importance</strong> is <strong>?STD_IMPORTANCE</strong>,
and default value for <strong>FormatArgs</strong> is <strong>[]</strong>.</p><p>For details on <strong>Category</strong> and <strong>Importance</strong>, see section
<a href="./write_test_chapter#logging">Logging - Categories and Verbosity Levels</a> in the User's Guide.</p><h3>reload_config(Required) -&gt; ValueOrElement | {error, Reason}</h3><p>Reloads configuration file containing specified configuration key.</p><ul><li><span class="v">Required = KeyOrName | {KeyOrName, SubKey} | {KeyOrName, SubKey, SubKey}</span></li><li><span class="v">KeyOrName = atom()</span></li><li><span class="v">SubKey = atom()</span></li><li><span class="v">ValueOrElement = term()</span></li></ul><a name="reload_config-1"></a><p>Reloads configuration file containing specified configuration key.</p><p>This function updates the configuration data from which the
specified configuration variable was read, and returns the (possibly)
new value of this variable.</p><p>If some variables were present in the configuration, but are
not loaded using this function, they are removed from the
configuration table together with their aliases.</p><h3>remaining_test_procs() -&gt; {TestProcs,SharedGL,OtherGLs}</h3><p>&gt;This function will return the identity of test- and group leader processes that are still running at the time of this call.</p><ul><li><span class="v">TestProcs = [{pid(),GL}]</span></li><li><span class="v">GL = pid()</span></li><li><span class="v">SharedGL = pid()</span></li><li><span class="v">OtherGLs = [pid()]</span></li></ul><a name="remaining_test_procs-0"></a><p>This function will return the identity of test- and group
leader processes that are still running at the time of this call.
<strong>TestProcs</strong> are processes in the system that have a Common Test IO
process as group leader. <strong>SharedGL</strong> is the central Common Test
IO process, responsible for printing to log files for configuration
functions and sequentially executing test cases. <strong>OtherGLs</strong> are
Common Test IO processes that print to log files for test cases
in parallel test case groups.</p><p>The process information returned by this function may be
used to locate and terminate remaining processes after tests have
finished executing. The function would typically by called from
Common Test Hook functions.</p><p>Note that processes that execute configuration functions or
test cases are never included in <strong>TestProcs</strong>. It is therefore safe
to use post configuration hook functions (such as post_end_per_suite,
post_end_per_group, post_end_per_testcase) to terminate all processes
in <strong>TestProcs</strong> that have the current group leader process as its group
leader.</p><p>Note also that the shared group leader (<strong>SharedGL</strong>) must never be
terminated by the user, only by Common Test. Group leader processes
for parallel test case groups (<strong>OtherGLs</strong>) may however be terminated
in post_end_per_group hook functions.</p><h3>remove_config(Callback, Config) -&gt; ok</h3><p>Removes configuration variables (together with their aliases) that were loaded with specified callback module and configuration string.</p><ul><li><span class="v">Callback = atom()</span></li><li><span class="v">Config = string()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="remove_config-2"></a><p>Removes configuration variables (together wih their aliases)
that were loaded with specified callback module and configuration
string.</p><h3>require(Required) -&gt; ok | {error, Reason}</h3><p>Checks if the required configuration is available.</p><ul><li><span class="v">Required = Key | {Key, SubKeys} | {Key, SubKey, SubKeys}</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">SubKeys = SubKey | [SubKey]</span></li><li><span class="v">SubKey = atom()</span></li></ul><a name="require-1"></a><p>Checks if the required configuration is available. Arbitrarily
deep tuples can be specified as <strong>Required</strong>. Only the last
element of the tuple can be a list of <strong>SubKey</strong>s.</p><p><em>Example 1.</em> Require the variable <strong>myvar</strong>:</p><pre>
 ok = ct:require(myvar).</pre><p>In this case the configuration file must at least contain:</p><pre>
 {myvar,Value}.</pre><p><em>Example 2.</em> Require key <strong>myvar</strong> with subkeys
<strong>sub1</strong> and <strong>sub2</strong>:</p><pre>
 ok = ct:require({myvar,[sub1,sub2]}).</pre><p>In this case the configuration file must at least contain:</p><pre>
 {myvar,[{sub1,Value},{sub2,Value}]}.</pre><p><em>Example 3.</em> Require key <strong>myvar</strong> with subkey
<strong>sub1</strong> with <strong>subsub1</strong>:</p><pre>
 ok = ct:require({myvar,sub1,sub2}).</pre><p>In this case the configuration file must at least contain:</p><pre>
 {myvar,[{sub1,[{sub2,Value}]}]}.</pre><p>See also
<a href="#get_config-1">get_config-1</a>,
<a href="#get_config-2">get_config-2</a>,
<a href="#get_config-3">get_config-3</a>,
<a href="#require-2">require-2</a>.</p><h3>require(Name, Required) -&gt; ok | {error, Reason}</h3><p>Checks if the required configuration is available and gives it a name.</p><ul><li><span class="v">Name = atom()</span></li><li><span class="v">Required = Key | {Key, SubKey} | {Key, SubKey, SubKey}</span></li><li><span class="v">SubKey = Key</span></li><li><span class="v">Key = atom()</span></li></ul><a name="require-2"></a><p>Checks if the required configuration is available and gives it a
name. The semantics for <strong>Required</strong> is the same as in
<a href="#require-1">require-1</a> except
that a list of <strong>SubKey</strong>s cannot be specified.</p><p>If the requested data is available, the subentry is associated
with <strong>Name</strong> so that the value of the element can be read with
<a href="#get_config-1">get_config-1</a>
provided <strong>Name</strong> is used instead of the whole <strong>Required</strong>
term.</p><p><em>Example:</em></p><p>Require one node with a Telnet connection and an FTP connection.
Name the node <strong>a</strong>:</p><pre>
 ok = ct:require(a,{machine,node}).</pre><p>All references to this node can then use the node name. For
example, a file over FTP is fetched like follows:</p><pre>
 ok = ct:ftp_get(a,RemoteFile,LocalFile).</pre><p>For this to work, the configuration file must at least contain:</p><pre>
 {machine,[{node,[{telnet,IpAddr},{ftp,IpAddr}]}]}.</pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The behavior of this function changed radically in
<strong>Common Test</strong> 1.6.2. To keep some backwards compatability,
it is still possible to do:<br/>
<strong>ct:require(a,{node,[telnet,ftp]}).</strong><br/>
This associates the name <strong>a</strong> with the top-level <strong>node</strong>
entry. For this to work, the configuration file must at least
contain:<br/>
<strong>{node,[{telnet,IpAddr},{ftp,IpAddr}]}.</strong></p></div><p>See also
<a href="#get_config-1">get_config-1</a>,
<a href="#get_config-2">get_config-2</a>,
<a href="#get_config-3">get_config-3</a>,
<a href="#require-1">require-1</a>.</p><h3>run(TestDirs) -&gt; Result</h3><p>Runs all test cases in all suites in the specified directories.</p><ul><li><span class="v">TestDirs = TestDir | [TestDir]</span></li></ul><a name="run-1"></a><p>Runs all test cases in all suites in the specified directories.</p><p>See also <a href="#run-3">run-3</a>.</p><h3>run(TestDir, Suite) -&gt; Result</h3><p>Runs all test cases in the specified suite.</p><a name="run-2"></a><p>Runs all test cases in the specified suite.</p><p>See also <a href="#run-3">run-3</a>.</p><h3>run(TestDir, Suite, Cases) -&gt; Result</h3><p>Runs the specified test cases.</p><ul><li><span class="v">TestDir = string()</span></li><li><span class="v">Suite = atom()</span></li><li><span class="v">Cases = atom() | [atom()]</span></li><li><span class="v">Result = [TestResult] | {error, Reason}</span></li></ul><a name="run-3"></a><p>Runs the specified test cases.</p><p>Requires that
<a href="#install-1">install-1</a> has been
run first.</p><p>Suites (<strong>*_SUITE.erl</strong>) files must be stored in <strong>TestDir</strong>
or <strong>TestDir/test</strong>. All suites are compiled when the test is
run.</p><h3>run_test(Opts) -&gt; Result</h3><p>Runs tests as specified by the combination of options in Opts.</p><ul><li><span class="v">Opts = [OptTuples]</span></li><li><span class="v">OptTuples = {dir, TestDirs} | {suite, Suites} | {group, Groups} | {testcase, Cases} | {spec, TestSpecs} | {join_specs, Bool} | {label, Label} | {config, CfgFiles} | {userconfig, UserConfig} | {allow_user_terms, Bool} | {logdir, LogDir} | {silent_connections, Conns} | {stylesheet, CSSFile} | {cover, CoverSpecFile} | {cover_stop, Bool} | {step, StepOpts} | {event_handler, EventHandlers} | {include, InclDirs} | {auto_compile, Bool} | {abort_if_missing_suites, Bool} | {create_priv_dir, CreatePrivDir} | {multiply_timetraps, M} | {scale_timetraps, Bool} | {repeat, N} | {duration, DurTime} | {until, StopTime} | {force_stop, ForceStop} | {decrypt, DecryptKeyOrFile} | {refresh_logs, LogDir} | {logopts, LogOpts} | {verbosity, VLevels} | {basic_html, Bool} | {esc_chars, Bool} | {keep_logs,KeepSpec} | {ct_hooks, CTHs} | {enable_builtin_hooks, Bool} | {release_shell, Bool}</span></li><li><span class="v">TestDirs = [string()] | string()</span></li><li><span class="v">Suites = [string()] | [atom()] | string() | atom()</span></li><li><span class="v">Cases = [atom()] | atom()</span></li><li><span class="v">Groups = GroupNameOrPath | [GroupNameOrPath]</span></li><li><span class="v">GroupNameOrPath = [atom()] | atom() | all</span></li><li><span class="v">TestSpecs = [string()] | string()</span></li><li><span class="v">Label = string() | atom()</span></li><li><span class="v">CfgFiles = [string()] | string()</span></li><li><span class="v">UserConfig = [{CallbackMod, CfgStrings}] | {CallbackMod, CfgStrings}</span></li><li><span class="v">CallbackMod = atom()</span></li><li><span class="v">CfgStrings = [string()] | string()</span></li><li><span class="v">LogDir = string()</span></li><li><span class="v">Conns = all | [atom()]</span></li><li><span class="v">CSSFile = string()</span></li><li><span class="v">CoverSpecFile = string()</span></li><li><span class="v">StepOpts = [StepOpt] | []</span></li><li><span class="v">StepOpt = config | keep_inactive</span></li><li><span class="v">EventHandlers = EH | [EH]</span></li><li><span class="v">EH = atom() | {atom(), InitArgs} | {[atom()], InitArgs}</span></li><li><span class="v">InitArgs = [term()]</span></li><li><span class="v">InclDirs = [string()] | string()</span></li><li><span class="v">CreatePrivDir = auto_per_run | auto_per_tc | manual_per_tc</span></li><li><span class="v">M = integer()</span></li><li><span class="v">N = integer()</span></li><li><span class="v">DurTime = string(HHMMSS)</span></li><li><span class="v">StopTime = string(YYMoMoDDHHMMSS) | string(HHMMSS)</span></li><li><span class="v">ForceStop = skip_rest | Bool</span></li><li><span class="v">DecryptKeyOrFile = {key, DecryptKey} | {file, DecryptFile}</span></li><li><span class="v">DecryptKey = string()</span></li><li><span class="v">DecryptFile = string()</span></li><li><span class="v">LogOpts = [LogOpt]</span></li><li><span class="v">LogOpt = no_nl | no_src</span></li><li><span class="v">VLevels = VLevel | [{Category, VLevel}]</span></li><li><span class="v">VLevel = integer()</span></li><li><span class="v">Category = atom()</span></li><li><span class="v">KeepSpec = all | pos_integer()</span></li><li><span class="v">CTHs = [CTHModule | {CTHModule, CTHInitArgs}]</span></li><li><span class="v">CTHModule = atom()</span></li><li><span class="v">CTHInitArgs = term()</span></li><li><span class="v">Result = {Ok, Failed, {UserSkipped, AutoSkipped}} | TestRunnerPid | {error, Reason}</span></li><li><span class="v">Ok = integer()</span></li><li><span class="v">Failed = integer()</span></li><li><span class="v">UserSkipped = integer()</span></li><li><span class="v">AutoSkipped = integer()</span></li><li><span class="v">TestRunnerPid = pid()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="run_test-1"></a><p>Runs tests as specified by the combination of options in
<strong>Opts</strong>. The options are the same as those used with program
<strong>ct_run</strong>, see <a href="./ct_run#ct_run">Run Tests from Command Line</a> in the <strong>ct_run</strong> manual page.</p><p>Here a <strong>TestDir</strong> can be used to point out the path to a
<strong>Suite</strong>. Option <strong>testcase</strong> corresponds to option
<strong>-case</strong> in program <strong>ct_run</strong>. Configuration files
specified in <strong>Opts</strong> are installed automatically at startup.</p><p><strong>TestRunnerPid</strong> is returned if <strong>release_shell == true</strong>.
For details, see
<a href="#break-1">break-1</a>.</p><p><strong>Reason</strong> indicates the type of error encountered.</p><h3>run_testspec(TestSpec) -&gt; Result</h3><p>Runs a test specified by TestSpec.</p><ul><li><span class="v">TestSpec = [term()]</span></li><li><span class="v">Result = {Ok, Failed, {UserSkipped, AutoSkipped}} | {error, Reason}</span></li><li><span class="v">Ok = integer()</span></li><li><span class="v">Failed = integer()</span></li><li><span class="v">UserSkipped = integer()</span></li><li><span class="v">AutoSkipped = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="run_testspec-1"></a><p>Runs a test specified by <strong>TestSpec</strong>. The same terms are used
as in test specification files.</p><p><strong>Reason</strong> indicates the type of error encountered.</p><h3>set_verbosity(Category, Level) -&gt; ok</h3><p>Set the verbosity level for a logging category.</p><ul><li><span class="v">Category = default | atom()</span></li><li><span class="v">Level = integer()</span></li></ul><a name="set_verbosity-2"></a><p>Use this function to set, or modify, the verbosity level for a logging
category. See the <a href="./write_test_chapter#logging"> User's Guide</a> for details. Use the value <strong>default</strong> to set the
general verbosity level.</p><h3>sleep(Time) -&gt; ok</h3><p>This function, similar to timer:sleep/1, suspends the test case for a specified time.</p><ul><li><span class="v">Time = {hours, Hours} | {minutes, Mins} | {seconds, Secs} | Millisecs | infinity</span></li><li><span class="v">Hours = integer()</span></li><li><span class="v">Mins = integer()</span></li><li><span class="v">Secs = integer()</span></li><li><span class="v">Millisecs = integer() | float()</span></li></ul><a name="sleep-1"></a><p>This function, similar to <strong>timer:sleep/1</strong> in STDLIB,
suspends the test case for a specified time.
However, this function also multiplies <strong>Time</strong> with the
<strong>multiply_timetraps</strong> value (if set) and under certain
circumstances also scales up the time automatically if
<strong>scale_timetraps</strong> is set to <strong>true</strong> (default is
<strong>false</strong>).</p><h3>start_interactive() -&gt; ok</h3><p>Starts <strong>Common Test</strong> in interactive mode.</p><a name="start_interactive-0"></a><p>Starts <strong>Common Test</strong> in interactive mode.</p><p>From this mode, all test case support functions can be executed
directly from the Erlang shell. The interactive mode can also be
started from the OS command line with <strong>ct_run -shell [-config File...]</strong>.</p><p>If any functions (for example, Telnet or FTP) using
"required configuration data" are to be called from the Erlang shell,
configuration data must first be required with
<a href="#require-2">require-2</a>.</p><p><em>Example:</em></p><pre>
 &gt; ct:require(unix_telnet, unix).
 ok
 &gt; ct_telnet:open(unix_telnet).
 {ok,&lt;0.105.0&gt;}
 &gt; ct_telnet:cmd(unix_telnet, "ls .").
 {ok,["ls","file1  ...",...]}</pre><h3>step(TestDir, Suite, Case) -&gt; Result</h3><p>Steps through a test case with the debugger.</p><ul><li><span class="v">Case = atom()</span></li></ul><a name="step-3"></a><p>Steps through a test case with the debugger.</p><p>See also <a href="#run-3">run-3</a>.</p><h3>step(TestDir, Suite, Case, Opts) -&gt; Result</h3><p>Steps through a test case with the debugger.</p><ul><li><span class="v">Case = atom()</span></li><li><span class="v">Opts = [Opt] | []</span></li><li><span class="v">Opt = config | keep_inactive</span></li></ul><a name="step-4"></a><p>Steps through a test case with the debugger. If option
<strong>config</strong> has been specifed, breakpoints are also set on
the configuration functions in <strong>Suite</strong>.</p><p>See also <a href="#run-3">run-3</a>.</p><h3>stop_interactive() -&gt; ok</h3><p>Exits the interactive mode.</p><a name="stop_interactive-0"></a><p>Exits the interactive mode.</p><p>See also
<a href="#start_interactive-0">start_interactive-0</a>.
</p><h3>sync_notify(Name, Data) -&gt; ok</h3><p>Sends a synchronous notification of type Name with Data to the <strong>Common Test</strong> event manager.</p><ul><li><span class="v">Name = atom()</span></li><li><span class="v">Data = term()</span></li></ul><a name="sync_notify-2"></a><p>Sends a synchronous notification of type <strong>Name</strong> with
<strong>Data</strong> to the <strong>Common Test</strong> event manager. This can later be
caught by any installed event manager.</p><p>See also
<a href="./gen_event">stdlib/gen_event</a>.
</p><h3>testcases(TestDir, Suite) -&gt; Testcases | {error, Reason}</h3><p>Returns all test cases in the specified suite.</p><ul><li><span class="v">TestDir = string()</span></li><li><span class="v">Suite = atom()</span></li><li><span class="v">Testcases = list()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="testcases-2"></a><p>Returns all test cases in the specified suite.</p><h3>timetrap(Time) -&gt; ok</h3><p>Sets a new timetrap for the running test case.</p><ul><li><span class="v">Time = {hours, Hours} | {minutes, Mins} | {seconds, Secs} | Millisecs | infinity | Func</span></li><li><span class="v">Hours = integer()</span></li><li><span class="v">Mins = integer()</span></li><li><span class="v">Secs = integer()</span></li><li><span class="v">Millisecs = integer()</span></li><li><span class="v">Func = {M, F, A} | function()</span></li><li><span class="v">M = atom()</span></li><li><span class="v">F = atom()</span></li><li><span class="v">A = list()</span></li></ul><a name="timetrap-1"></a><p>Sets a new timetrap for the running test case.</p><p>If the argument is <strong>Func</strong>, the timetrap is triggered when
this function returns. <strong>Func</strong> can also return a new
<strong>Time</strong> value, which in that case is the value for the new
timetrap.</p><h3>userdata(TestDir, Suite) -&gt; SuiteUserData | {error, Reason}</h3><p>Returns any data specified with tag userdata in the list of tuples returned from Suite:suite/0.</p><ul><li><span class="v">TestDir = string()</span></li><li><span class="v">Suite = atom()</span></li><li><span class="v">SuiteUserData = [term()]</span></li><li><span class="v">Reason = term()</span></li></ul><a name="userdata-2"></a><p>Returns any data specified with tag <strong>userdata</strong> in the list
of tuples returned from
<a href="./common_test#Module:suite-0">common_test#Module:suite-0</a>.</p><h3>userdata(TestDir, Suite, Case::GroupOrCase) -&gt; TCUserData | {error, Reason}</h3><p>Returns any data specified with tag userdata in the list of tuples returned from Suite:group(GroupName) or Suite:Case().</p><ul><li><span class="v">TestDir = string()</span></li><li><span class="v">Suite = atom()</span></li><li><span class="v">GroupOrCase = {group, GroupName} | atom()</span></li><li><span class="v">GroupName = atom()</span></li><li><span class="v">TCUserData = [term()]</span></li><li><span class="v">Reason = term()</span></li></ul><a name="userdata-3"></a><p>Returns any data specified with tag <strong>userdata</strong> in the list
of tuples returned from <strong>Suite:group(GroupName)</strong> or
<strong>Suite:Case()</strong>.</p><h2>ct_master</h2><p>Distributed test execution control for Common Test.</p><p>Distributed test execution control for <strong>Common Test</strong>.This module exports functions for running <strong>Common Test</strong> nodes on
multiple hosts in parallel.</p><h2>Functions</h2><h3>abort() -&gt; ok</h3><p>Stops all running tests.</p><a name="abort-0"></a><p>Stops all running tests.</p><h3>abort(Nodes) -&gt; ok</h3><p>Stops tests on specified nodes.</p><ul><li><span class="v">Nodes = atom() | [atom()]</span></li></ul><a name="abort-1"></a><p>Stops tests on specified nodes.</p><h3>basic_html(Bool) -&gt; ok</h3><p>If set to true, the ct_master logs are written on a primitive HTML format, not using the <strong>Common Test</strong> CSS style sheet.</p><ul><li><span class="v">Bool = true | false</span></li></ul><a name="basic_html-1"></a><p>If set to <strong>true</strong>, the <strong>ct_master logs</strong> are written on a
primitive HTML format, not using the <strong>Common Test</strong> CSS style
sheet.</p><h3>get_event_mgr_ref() -&gt; MasterEvMgrRef</h3><p>Gets a reference to the <strong>Common Test</strong> master event manager.</p><ul><li><span class="v">MasterEvMgrRef = atom()</span></li></ul><a name="get_event_mgr_ref-0"></a><p>Gets a reference to the <strong>Common Test</strong> master event manager.
The reference can be used to, for example, add a user-specific
event handler while tests are running.</p><p><em>Example:</em></p><pre>
 gen_event:add_handler(ct_master:get_event_mgr_ref(), my_ev_h, [])</pre><h3>progress() -&gt; [{Node, Status}]</h3><p>Returns test progress.</p><ul><li><span class="v">Node = atom()</span></li><li><span class="v">Status = finished_ok | ongoing | aborted | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="progress-0"></a><p>Returns test progress. If <strong>Status</strong> is <strong>ongoing</strong>, tests
are running on the node and are not yet finished.</p><h3>run(TestSpecs) -&gt; ok</h3><p>Equivalent to run(TestSpecs, false, [], []).</p><ul><li><span class="v">TestSpecs = string() | [SeparateOrMerged]</span></li></ul><a name="run-1"></a><p>Equivalent to <a href="#run-4">run-4</a>.</p><h3>run(TestSpecs, InclNodes, ExclNodes) -&gt; ok</h3><p>Equivalent to run(TestSpecs, false, InclNodes, ExclNodes). </p><ul><li><span class="v">TestSpecs = string() | [SeparateOrMerged]</span></li><li><span class="v">SeparateOrMerged = string() | [string()]</span></li><li><span class="v">InclNodes = [atom()]</span></li><li><span class="v">ExclNodes = [atom()]</span></li></ul><a name="run-3"></a><p>Equivalent to <a href="#run-4">run-4</a>.</p><h3>run(TestSpecs, AllowUserTerms, InclNodes, ExclNodes) -&gt; ok</h3><p>Tests are spawned on the nodes as specified in TestSpecs. </p><ul><li><span class="v">TestSpecs = string() | [SeparateOrMerged]</span></li><li><span class="v">SeparateOrMerged = string() | [string()]</span></li><li><span class="v">AllowUserTerms = bool()</span></li><li><span class="v">InclNodes = [atom()]</span></li><li><span class="v">ExclNodes = [atom()]</span></li></ul><a name="run-4"></a><p>Tests are spawned on the nodes as specified in <strong>TestSpecs</strong>.
Each specification in <strong>TestSpec</strong> is handled separately.
However, it is also possible to specify a list of specifications to
be merged into one specification before the tests are executed. Any
test without a particular node specification is also executed on
the nodes in <strong>InclNodes</strong>. Nodes in the <strong>ExclNodes</strong> list
are excluded from the test.</p><h3>run_on_node(TestSpecs, Node) -&gt; ok</h3><p>Equivalent to run_on_node(TestSpecs, false, Node).</p><ul><li><span class="v">TestSpecs = string() | [SeparateOrMerged]</span></li><li><span class="v">SeparateOrMerged = string() | [string()]</span></li><li><span class="v">Node = atom()</span></li></ul><a name="run_on_node-2"></a><p>Equivalent to
<a href="#run_on_node-3">run_on_node-3</a>.</p><h3>run_on_node(TestSpecs, AllowUserTerms, Node) -&gt; ok</h3><p>Tests are spawned on Node according to TestSpecs.</p><ul><li><span class="v">TestSpecs = string() | [SeparateOrMerged]</span></li><li><span class="v">SeparateOrMerged = string() | [string()]</span></li><li><span class="v">AllowUserTerms = bool()</span></li><li><span class="v">Node = atom()</span></li></ul><a name="run_on_node-3"></a><p>Tests are spawned on <strong>Node</strong> according to <strong>TestSpecs</strong>.</p><h3>run_test(Node, Opts) -&gt; ok</h3><p>Tests are spawned on Node using ct:run_test/1.</p><ul><li><span class="v">Node = atom()</span></li><li><span class="v">Opts = [OptTuples]</span></li><li><span class="v">OptTuples = {config, CfgFiles} | {dir, TestDirs} | {suite, Suites} | {testcase, Cases} | {spec, TestSpecs} | {allow_user_terms, Bool} | {logdir, LogDir} | {event_handler, EventHandlers} | {silent_connections, Conns} | {cover, CoverSpecFile} | {cover_stop, Bool} | {userconfig, UserCfgFiles}</span></li><li><span class="v">CfgFiles = string() | [string()]</span></li><li><span class="v">TestDirs = string() | [string()]</span></li><li><span class="v">Suites = atom() | [atom()]</span></li><li><span class="v">Cases = atom() | [atom()]</span></li><li><span class="v">TestSpecs = string() | [string()]</span></li><li><span class="v">LogDir = string()</span></li><li><span class="v">EventHandlers = EH | [EH]</span></li><li><span class="v">EH = atom() | {atom(), InitArgs} | {[atom()], InitArgs}</span></li><li><span class="v">InitArgs = [term()]</span></li><li><span class="v">Conns = all | [atom()]</span></li></ul><a name="run_test-2"></a><p>Tests are spawned on <strong>Node</strong> using
<a href="./ct#run_test-1">ct#run_test-1</a></p><h2>ct_cover</h2><p>Common Test framework code coverage support module.
</p><p><strong>Common Test</strong> framework code coverage support module.This module exports help functions for performing code coverage
analysis.</p><h2>Functions</h2><h3>add_nodes(Nodes) -&gt; {ok, StartedNodes} | {error, Reason}</h3><p>Adds nodes to current cover test (only works if cover support is active).</p><ul><li><span class="v">Nodes = [atom()]</span></li><li><span class="v">StartedNodes = [atom()]</span></li><li><span class="v">Reason = cover_not_running | not_main_node</span></li></ul><a name="add_nodes-1"></a><p>Adds nodes to current cover test. Notice that this only works if
cover support is active.</p><p>To have effect, this function is to be called from
<strong>init_per_suite/1</strong> (see
<a href="common_test">common_test</a>)
before any tests are performed.</p><h3>cross_cover_analyse(Level, Tests) -&gt; ok</h3><p>Accumulates cover results over multiple tests.</p><ul><li><span class="v">Level = overview | details</span></li><li><span class="v">Tests = [{Tag, Dir}]</span></li><li><span class="v">Tag = atom()</span></li><li><span class="v">Dir = string()</span></li></ul><a name="cross_cover_analyse-2"></a><p>Accumulates cover results over multiple tests. See section
<a href="./cover_chapter#cross_cover">Cross Cover Analysis</a> in the Users's Guide.</p><h3>remove_nodes(Nodes) -&gt; ok | {error, Reason}</h3><p>Removes nodes from the current cover test.</p><ul><li><span class="v">Nodes = [atom()]</span></li><li><span class="v">Reason = cover_not_running | not_main_node</span></li></ul><a name="remove_nodes-1"></a><p>Removes nodes from the current cover test.</p><p>Call this function to stop cover test on nodes previously
added with
<a href="#add_nodes-1">add_nodes-1</a>.
Results on the remote node are transferred to the <strong>Common Test</strong>
node.</p><h2>ct_ftp</h2><p>FTP client module (based on the FTP application).</p><p>FTP client module (based on the <strong>ftp</strong> application).</p><h3>Data Types</h3><a name="types"></a><dl><dt><strong>connection() = handle() | target_name()</strong></dt><dd><a name="type-connection"></a> <p>For <strong>target_name</strong>, see module
<a href="ct">ct</a>.</p></dd><dt><strong>handle() = handle()</strong></dt><dd><a name="type-handle"></a> <p>Handle for a specific FTP connection, see module
<a href="ct">ct</a>.</p></dd></dl><h2>Functions</h2><h3>cd(Connection, Dir) -&gt; ok | {error, Reason}</h3><p>Changes directory on remote host.</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">Dir = string()</span></li></ul><a name="cd-2"></a><p>Changes directory on remote host.</p><h3>close(Connection) -&gt; ok | {error, Reason}</h3><p>Closes the FTP connection.</p><ul><li><span class="v">Connection = connection()</span></li></ul><a name="close-1"></a><p>Closes the FTP connection.</p><h3>delete(Connection, File) -&gt; ok | {error, Reason}</h3><p>Deletes a file on remote host.</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">File = string()</span></li></ul><a name="delete-2"></a><p>Deletes a file on remote host.</p><h3>get(KeyOrName, RemoteFile, LocalFile) -&gt; ok | {error, Reason}</h3><p>Opens an FTP connection and fetches a file from the remote host.</p><ul><li><span class="v">KeyOrName = Key | Name</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Name = target_name()</span></li><li><span class="v">RemoteFile = string()</span></li><li><span class="v">LocalFile = string()</span></li></ul><a name="get-3"></a><p>Opens an FTP connection and fetches a file from the remote
host.</p><p><strong>RemoteFile</strong> and <strong>LocalFile</strong> must be absolute paths.</p><p>The configuration file must be as for
<a href="#put-3">put-3</a>.</p><p>For <strong>target_name</strong>, see module
<a href="ct">ct</a>.</p><p>See also
<a href="./ct#require-2">ct#require-2</a>.</p><h3>ls(Connection, Dir) -&gt; {ok, Listing} | {error, Reason}</h3><p>Lists directory Dir.</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">Dir = string()</span></li><li><span class="v">Listing = string()</span></li></ul><a name="ls-2"></a><p>Lists directory <strong>Dir</strong>.</p><h3>open(KeyOrName) -&gt; {ok, Handle} | {error, Reason}</h3><p>Opens an FTP connection to the specified node.</p><ul><li><span class="v">KeyOrName = Key | Name</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Name = target_name()</span></li><li><span class="v">Handle = handle()</span></li></ul><a name="open-1"></a><p>Opens an FTP connection to the specified node.</p><p>You can open a connection for a particular <strong>Name</strong> and use the
same name as reference for all following subsequent operations.
If you want
the connection to be associated with <strong>Handle</strong> instead (if you,
for example, need to open multiple connections to a host), use
<strong>Key</strong>, the configuration variable name, to specify the target.
A connection without an associated target name can only be closed
with the handle value.</p><p>For information on how to create a new <strong>Name</strong>, see
<a href="./ct#require-2">ct#require-2</a>.</p><p>For <strong>target_name</strong>, see module
<a href="ct">ct</a>.</p><h3>put(KeyOrName, LocalFile, RemoteFile) -&gt; ok | {error, Reason}</h3><p>Opens an FTP connection and sends a file to the remote host.</p><ul><li><span class="v">KeyOrName = Key | Name</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Name = target_name()</span></li><li><span class="v">LocalFile = string()</span></li><li><span class="v">RemoteFile = string()</span></li></ul><a name="put-3"></a><p>Opens an FTP connection and sends a file to the remote host.</p><p><strong>LocalFile</strong> and <strong>RemoteFile</strong> must be absolute paths.</p><p>For <strong>target_name</strong>, see module
<a href="ct">ct</a>.</p><p>If the target host is a "special" node, the FTP address must be
specified in the configuration file as follows:</p><pre>
 {node,[{ftp,IpAddr}]}.</pre><p>If the target host is something else, for example, a UNIX host,
the configuration file must also include the username and password
(both strings):</p><pre>
 {unix,[{ftp,IpAddr},
        {username,Username},
        {password,Password}]}.</pre><p>See also
<a href="./ct#require-2">ct#require-2</a>.</p><h3>recv(Connection, RemoteFile) -&gt; ok | {error, Reason}</h3><p>Fetches a file over FTP.</p><a name="recv-2"></a><p>Fetches a file over FTP.</p><p>The file gets the same name on the local host.</p><p>See also <a href="#recv-3">recv-3</a>.</p><h3>recv(Connection, RemoteFile, LocalFile) -&gt; ok | {error, Reason}</h3><p>Fetches a file over FTP.</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">RemoteFile = string()</span></li><li><span class="v">LocalFile = string()</span></li></ul><a name="recv-3"></a><p>Fetches a file over FTP.</p><p>The file is named <strong>LocalFile</strong> on the local host.</p><h3>send(Connection, LocalFile) -&gt; ok | {error, Reason}</h3><p>Sends a file over FTP.</p><a name="send-2"></a><p>Sends a file over FTP.</p><p>The file gets the same name on the remote host.</p><p>See also
<a href="#send-3">send-3</a>.</p><h3>send(Connection, LocalFile, RemoteFile) -&gt; ok | {error, Reason}</h3><p>Sends a file over FTP.</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">LocalFile = string()</span></li><li><span class="v">RemoteFile = string()</span></li></ul><a name="send-3"></a><p>Sends a file over FTP.</p><p>The file is named <strong>RemoteFile</strong> on the remote host.</p><h3>type(Connection, Type) -&gt; ok | {error, Reason}</h3><p>Changes the file transfer type.</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">Type = ascii | binary</span></li></ul><a name="type-2"></a><p>Changes the file transfer type.</p><h2>ct_ssh</h2><p>SSH/SFTP client module.</p><p>SSH/SFTP client module.This module uses application <strong>SSH</strong>, which provides detailed
information about, for example, functions, types, and options.Argument <strong>Server</strong> in the SFTP functions is only to be used for
SFTP sessions that have been started on existing SSH connections
(that is, when the original connection type is <strong>ssh</strong>). Whenever
the connection type is <strong>sftp</strong>, use the SSH connection reference
only.The following options are valid for specifying an SSH/SFTP
connection (that is, can be used as configuration elements):<pre>
 [{ConnType, Addr},
  {port, Port},
  {user, UserName}
  {password, Pwd}
  {user_dir, String}
  {public_key_alg, PubKeyAlg}
  {connect_timeout, Timeout}
  {key_cb, KeyCallbackMod}]</pre><strong>ConnType = ssh | sftp</strong>.For other types, see
<a href="./ssh">ssh/ssh</a>.All time-out parameters in <strong>ct_ssh</strong> functions are values in
milliseconds.</p><h3>Data Types</h3><a name="types"></a><dl><dt><strong>connection() = handle() | target_name()</strong></dt><dd><a name="type-connection"></a> <p>For <strong>target_name</strong>, see module
<a href="ct">ct</a>.</p></dd><dt><strong>handle() = handle()</strong></dt><dd><a name="type-handle"></a> <p>Handle for a specific SSH/SFTP connection, see module
<a href="ct">ct</a>.</p></dd><dt><strong>ssh_sftp_return() = term()</strong></dt><dd><a name="type-ssh_sftp_return"></a> <p>Return value from an
<a href="./ssh_sftp">ssh/ssh_sftp</a>
function.</p></dd></dl><h2>Functions</h2><h3>apread(SSH, Handle, Position, Length) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="apread-4"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>apread(SSH, Server, Handle, Position, Length) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="apread-5"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>apwrite(SSH, Handle, Position, Data) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="apwrite-4"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>apwrite(SSH, Server, Handle, Position, Data) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="apwrite-5"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>aread(SSH, Handle, Len) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="aread-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>aread(SSH, Server, Handle, Len) -&gt; Result</h3><p>For inforamtion and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="aread-4"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>awrite(SSH, Handle, Data) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="awrite-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>awrite(SSH, Server, Handle, Data) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="awrite-4"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>close(SSH, Handle) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="close-2"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>close(SSH, Server, Handle) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="close-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>connect(KeyOrName) -&gt; {ok, Handle} | {error, Reason}</h3><p>Equivalent to connect(KeyOrName, host, []).</p><a name="connect-1"></a><p>Equivalent to
<a href="#connect-3">connect-3</a>.</p><h3>connect(KeyOrName, ConnType) -&gt; {ok, Handle} | {error, Reason}</h3><p>Equivalent to connect(KeyOrName, ConnType, []).</p><a name="connect-2"></a><p>Equivalent to
<a href="#connect-3">connect-3</a>.</p><h3>connect(KeyOrName, ConnType, ExtraOpts) -&gt; {ok, Handle} | {error, Reason}</h3><p>Opens an SSH or SFTP connection using the information associated with KeyOrName.</p><ul><li><span class="v">KeyOrName = Key | Name</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Name = target_name()</span></li><li><span class="v">ConnType = ssh | sftp | host</span></li><li><span class="v">ExtraOpts = ssh_connect_options()</span></li><li><span class="v">Handle = handle()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="connect-3"></a><p>Opens an SSH or SFTP connection using the information associated
with <strong>KeyOrName</strong>.</p><p>If <strong>Name</strong> (an alias name for <strong>Key</strong>) is used to identify
the connection, this name can be used as connection reference for
subsequent calls. Only one open connection at a time associated
with <strong>Name</strong> is possible. If <strong>Key</strong> is used, the returned
handle must be used for subsequent calls (multiple connections can
be opened using the configuration data specified by <strong>Key</strong>).</p><p>For information on how to create a new <strong>Name</strong>, see
<a href="./ct#require-2">ct#require-2</a>.</p><p>For <strong>target_name</strong>, see module
<a href="ct">ct</a>.</p><p><strong>ConnType</strong> always overrides the type specified in the
address tuple in the configuration data (and in <strong>ExtraOpts</strong>).
So it is possible to, for example, open an SFTP connection
directly using data originally specifying an SSH connection. Value
<strong>host</strong> means that the connection type specified by the host
option (either in the configuration data or in <strong>ExtraOpts</strong>)
is used.</p><p><strong>ExtraOpts</strong> (optional) are extra SSH options to be added to
the configuration data for <strong>KeyOrName</strong>. The extra options
override any existing options with the same key in the
configuration data. For details on valid SSH options, see
application <a href="./index">ssh/index</a>.</p><h3>del_dir(SSH, Name) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="del_dir-2"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>del_dir(SSH, Server, Name) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="del_dir-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>delete(SSH, Name) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="delete-2"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>delete(SSH, Server, Name) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="delete-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>disconnect(SSH) -&gt; ok | {error, Reason}</h3><p>Closes an SSH/SFTP connection.</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="disconnect-1"></a><p>Closes an SSH/SFTP connection.</p><h3>exec(SSH, Command) -&gt; {ok, Data} | {error, Reason}</h3><p>Equivalent to exec(SSH, Command, DefaultTimeout).</p><a name="exec-2"></a><p>Equivalent to
<a href="#exec-3">exec-3</a>.</p><h3>exec(SSH, Command, Timeout) -&gt; {ok, Data} | {error, Reason}</h3><p>Requests server to perform Command.</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Command = string()</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">Data = list()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="exec-3"></a><p>Requests server to perform <strong>Command</strong>. A session channel is
opened automatically for the request. <strong>Data</strong> is received from
the server as a result of the command.</p><h3>exec(SSH, ChannelId, Command, Timeout) -&gt; {ok, Data} | {error, Reason}</h3><p>Requests server to perform Command.</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">ChannelId = integer()</span></li><li><span class="v">Command = string()</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">Data = list()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="exec-4"></a><p>Requests server to perform <strong>Command</strong>. A previously opened
session channel is used for the request. <strong>Data</strong> is received
from the server as a result of the command.</p><h3>get_file_info(SSH, Handle) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="get_file_info-2"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>get_file_info(SSH, Server, Handle) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="get_file_info-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>list_dir(SSH, Path) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="list_dir-2"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>list_dir(SSH, Server, Path) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="list_dir-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>make_dir(SSH, Name) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="make_dir-2"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>make_dir(SSH, Server, Name) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="make_dir-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>make_symlink(SSH, Name, Target) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="make_symlink-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>make_symlink(SSH, Server, Name, Target) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="make_symlink-4"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>open(SSH, File, Mode) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="open-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>open(SSH, Server, File, Mode) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="open-4"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>opendir(SSH, Path) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="opendir-2"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>opendir(SSH, Server, Path) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="opendir-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>position(SSH, Handle, Location) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="position-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>position(SSH, Server, Handle, Location) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="position-4"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>pread(SSH, Handle, Position, Length) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="pread-4"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>pread(SSH, Server, Handle, Position, Length) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="pread-5"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>pwrite(SSH, Handle, Position, Data) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="pwrite-4"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>pwrite(SSH, Server, Handle, Position, Data) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="pwrite-5"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>read(SSH, Handle, Len) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="read-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>read(SSH, Server, Handle, Len) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="read-4"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>read_file(SSH, File) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="read_file-2"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>read_file(SSH, Server, File) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="read_file-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>read_file_info(SSH, Name) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="read_file_info-2"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>read_file_info(SSH, Server, Name) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="read_file_info-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>read_link(SSH, Name) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="read_link-2"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>read_link(SSH, Server, Name) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="read_link-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>read_link_info(SSH, Name) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="read_link_info-2"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>read_link_info(SSH, Server, Name) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="read_link_info-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>receive_response(SSH, ChannelId) -&gt; {ok, Data} | {error, Reason}</h3><p>Equivalent to receive_response(SSH, ChannelId, close).</p><a name="receive_response-2"></a><p>Equivalent to
<a href="#receive_response-3">receive_response-3</a>.</p><h3>receive_response(SSH, ChannelId, End) -&gt; {ok, Data} | {error, Reason}</h3><p>Equivalent to receive_response(SSH, ChannelId, End, DefaultTimeout).</p><a name="receive_response-3"></a><p>Equivalent to
<a href="#receive_response-4">receive_response-4</a>.</p><h3>receive_response(SSH, ChannelId, End, Timeout) -&gt; {ok, Data} | {timeout, Data} | {error, Reason}</h3><p>Receives expected data from server on the specified session channel.</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">ChannelId = integer()</span></li><li><span class="v">End = Fun | close | timeout</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">Data = list()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="receive_response-4"></a><p>Receives expected data from server on the specified session
channel.</p><p>If <strong>End == close</strong>, data is returned to the caller when the
channel is closed by the server. If a time-out occurs before this
happens, the function returns <strong>{timeout,Data}</strong> (where
<strong>Data</strong> is the data received so far).</p><p>If <strong>End == timeout</strong>, a time-out is expected and
<strong>{ok,Data}</strong> is returned both in the case of a time-out and
when the channel is closed.</p><p>If <strong>End</strong> is a fun, this fun is called with one argument, the
data value in a received <strong>ssh_cm</strong> message (see
<a href="./ssh_connection">ssh/ssh_connection</a>.
The fun is to return either <strong>true</strong> to end the receiving
operation (and have the so far collected data returned) or
<strong>false</strong> to wait for more data from the server. Even if a fun
is supplied, the function returns immediately if the server closes
the channel).</p><h3>rename(SSH, OldName, NewName) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="rename-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>rename(SSH, Server, OldName, NewName) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="rename-4"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>send(SSH, ChannelId, Data) -&gt; ok | {error, Reason}</h3><p>Equivalent to send(SSH, ChannelId, 0, Data, DefaultTimeout).</p><a name="send-3"></a><p>Equivalent to <a href="#send-5">send-5</a>.</p><h3>send(SSH, ChannelId, Data, Timeout) -&gt; ok | {error, Reason}</h3><p>Equivalent to send(SSH, ChannelId, 0, Data, Timeout).</p><a name="send-4"></a><p>Equivalent to <a href="#send-5">send-5</a>.</p><h3>send(SSH, ChannelId, Type, Data, Timeout) -&gt; ok | {error, Reason}</h3><p>Sends data to server on specified session channel.</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">ChannelId = integer()</span></li><li><span class="v">Type = integer()</span></li><li><span class="v">Data = list()</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="send-5"></a><p>Sends data to server on specified session channel.</p><h3>send_and_receive(SSH, ChannelId, Data) -&gt; {ok, Data} | {error, Reason}</h3><p>Equivalent to send_and_receive(SSH, ChannelId, Data, close).</p><a name="send_and_receive-3"></a><p>Equivalent to
<a href="#send_and_receive-4">send_and_receive-4</a>.</p><h3>send_and_receive(SSH, ChannelId, Data, End) -&gt; {ok, Data} | {error, Reason}</h3><p>Equivalent to send_and_receive(SSH, ChannelId, 0, Data, End, DefaultTimeout).</p><a name="send_and_receive-4"></a><p>Equivalent to
<a href="#send_and_receive-6">send_and_receive-6</a>.</p><h3>send_and_receive(SSH, ChannelId, Data, End, Timeout) -&gt; {ok, Data} | {error, Reason}</h3><p>Equivalent to send_and_receive(SSH, ChannelId, 0, Data, End, Timeout).</p><a name="send_and_receive-5"></a><p>Equivalent to
<a href="#send_and_receive-6">send_and_receive-6</a>.</p><h3>send_and_receive(SSH, ChannelId, Type, Data, End, Timeout) -&gt; {ok, Data} | {error, Reason}</h3><p>Sends data to server on specified session channel and waits to receive the server response.</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">ChannelId = integer()</span></li><li><span class="v">Type = integer()</span></li><li><span class="v">Data = list()</span></li><li><span class="v">End = Fun | close | timeout</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="send_and_receive-6"></a><p>Sends data to server on specified session channel and waits to
receive the server response.</p><p>For details on argument <strong>End</strong>, see
<a href="#receive_response-4">receive_response-4</a>.</p><h3>session_close(SSH, ChannelId) -&gt; ok | {error, Reason}</h3><p>Closes an SSH session channel.</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">ChannelId = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="session_close-2"></a><p>Closes an SSH session channel.</p><h3>session_open(SSH) -&gt; {ok, ChannelId} | {error, Reason}</h3><p>Equivalent to session_open(SSH, DefaultTimeout).</p><a name="session_open-1"></a><p>Equivalent to
<a href="#session_open-2">session_open-2</a>.</p><h3>session_open(SSH, Timeout) -&gt; {ok, ChannelId} | {error, Reason}</h3><p>Opens a channel for an SSH session.</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">ChannelId = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="session_open-2"></a><p>Opens a channel for an SSH session.</p><h3>sftp_connect(SSH) -&gt; {ok, Server} | {error, Reason}</h3><p>Starts an SFTP session on an already existing SSH connection.</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Server = pid()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="sftp_connect-1"></a><p>Starts an SFTP session on an already existing SSH connection.
<strong>Server</strong> identifies the new session and must be specified
whenever SFTP requests are to be sent.</p><h3>shell(SSH, ChannelId) -&gt; ok | {error, Reason}</h3><p>Equivalent to shell(SSH, ChannelId, DefaultTimeout).</p><a name="shell-2"></a><p>Equivalent to
<a href="#shell-3">shell-3</a>.</p><h3>shell(SSH, ChannelId, Timeout) -&gt; ok | {error, Reason}</h3><p>Requests that the user default shell is executed at the server end.</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">ChannelId = integer()</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="shell-3"></a><p>Requests that the user default shell (typically defined in
<strong>/etc/passwd</strong> in Unix systems) is executed at the
server end.</p><h3>subsystem(SSH, ChannelId, Subsystem) -&gt; Status | {error, Reason}</h3><p>Equivalent to subsystem(SSH, ChannelId, Subsystem, DefaultTimeout).</p><a name="subsystem-3"></a><p>Equivalent to
<a href="#subsystem-4">subsystem-4</a>.</p><h3>subsystem(SSH, ChannelId, Subsystem, Timeout) -&gt; Status | {error, Reason}</h3><p>Sends a request to execute a predefined subsystem.</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">ChannelId = integer()</span></li><li><span class="v">Subsystem = string()</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">Status = success | failure</span></li><li><span class="v">Reason = term()</span></li></ul><a name="subsystem-4"></a><p>Sends a request to execute a predefined subsystem.</p><h3>write(SSH, Handle, Data) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="write-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>write(SSH, Server, Handle, Data) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="write-4"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>write_file(SSH, File, Iolist) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="write_file-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>write_file(SSH, Server, File, Iolist) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="write_file-4"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>write_file_info(SSH, Name, Info) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="write_file_info-3"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h3>write_file_info(SSH, Server, Name, Info) -&gt; Result</h3><p>For information and other types, see ssh_sftp(3).</p><ul><li><span class="v">SSH = connection()</span></li><li><span class="v">Result = ssh_sftp_return() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="write_file_info-4"></a><p>For information and other types, see
<a href="./ssh_sftp">ssh/ssh_sftp</a>.</p><h2>ct_netconfc</h2><p>NETCONF client module.</p><p>NETCONF client module.The NETCONF client is compliant with RFC 4741 NETCONF Configuration
Protocol and RFC 4742 Using the NETCONF Configuration Protocol over
Secure SHell (SSH).<a name="Connecting"></a><em>Connecting to a NETCONF server</em>NETCONF sessions can either be opened by a single call
to <a href="#open-1">open-1</a> or by a call
to <a href="#connect-1">connect-1</a> followed
by one or more calls to
<a href="#session-1">session-1</a>.The properties of the sessions will be exactly the same, except
that when
using <a href="#connect-1">connect-1</a>, you
may start multiple sessions over the same SSH connection. Each
session is implemented as an SSH channel.<a href="#open-1">open-1</a> will establish one
SSH connection with one SSH channel implementing one NETCONF
session. You may start mutiple sessions by
calling <a href="#open-1">open-1</a> multiple
times, but then a new SSH connection will be established for each
session.For each server to test against, the following entry can be added to a
configuration file:<pre>
 {server_id(),options()}.</pre>The <a href="#type-server_id">type-server_id</a>
or an associated
<a href="./ct#type-target_name">ct#type-target_name</a>
must then be used in calls to
<a href="#connect-2">connect-2</a>
or <a href="#open-2">open-2</a>.If no configuration exists for a server,
use <a href="#connect-1">connect-1</a>
or <a href="#open-1">open-1</a> instead,
and specify all necessary options in the <strong>Options</strong> parameter.<a name="Logging"></a><em>Logging</em>The NETCONF server uses <strong>error_logger</strong> for logging of NETCONF
traffic. A special purpose error handler is implemented in
<strong>ct_conn_log_h</strong>. To use this error handler, add the
<strong>cth_conn_log</strong> hook in the test suite, for example:<pre>
 suite() -&gt;
    [{ct_hooks, [{cth_conn_log, [{,}]}]}].</pre><strong>conn_log_mod()</strong> is the name of the <strong>Common Test</strong> module
implementing the connection protocol, for example, <strong>ct_netconfc</strong>.Hook option <strong>log_type</strong> specifies the type of logging:<dl><dt><strong>raw</strong></dt><dd><p>The sent and received NETCONF data is logged to a separate
text file "as is" without any formatting. A link to the file is
added to the test case HTML log.</p></dd><dt><strong>pretty</strong></dt><dd><p>The sent and received NETCONF data is logged to a separate
text file with XML data nicely indented. A link to the file is
added to the test case HTML log.</p></dd><dt><strong>html (default)</strong></dt><dd><p>The sent and received NETCONF traffic is pretty printed
directly in the test case HTML log.</p></dd><dt><strong>silent</strong></dt><dd><p>NETCONF traffic is not logged.</p></dd></dl>By default, all NETCONF traffic is logged in one single log file.
However, different connections can be logged in separate files.
To do this, use hook option <strong>hosts</strong> and list the names of the
servers/connections to be used in the suite. The connections
must be named for this to work, that is, they must be opened with
<a href="#open-2">open-2</a>.Option <strong>hosts</strong> has no effect if <strong>log_type</strong> is set to
<strong>html</strong> or <strong>silent</strong>.The hook options can also be specified in a configuration file with
configuration variable <strong>ct_conn_log</strong>:<pre>
 {ct_conn_log,[{,}]}.</pre>For example:<pre>
 {ct_conn_log,[{ct_netconfc,[{log_type,pretty},
                             {hosts,[]}]}]}</pre><em>Logging Example 1:</em><a name="Logging_example_1"></a>The following <strong>ct_hooks</strong> statement causes pretty printing of
NETCONF traffic to separate logs for the connections named
<strong>nc_server1</strong> and <strong>nc_server2</strong>. Any other connections are
logged to default NETCONF log.<pre>
 suite() -&gt;
    [{ct_hooks, [{cth_conn_log, [{ct_netconfc,[{log_type,pretty}},
                                               {hosts,[nc_server1,nc_server2]}]}
                                ]}]}].</pre>Connections must be opened as follows:<pre>
 open(nc_server1,[...]),
 open(nc_server2,[...]).</pre><em>Logging Example 2:</em><a name="Logging_example_2"></a>The following configuration file causes raw logging of all NETCONF 
traffic in to one single text file:<pre>
 {ct_conn_log,[{ct_netconfc,[{log_type,raw}]}]}.</pre>The <strong>ct_hooks</strong> statement must look as follows:<pre>
 suite() -&gt;
    [{ct_hooks, [{cth_conn_log, []}]}].</pre>The same <strong>ct_hooks</strong> statement without the configuration file
would cause HTML logging of all NETCONF connections in to the test
case HTML log.<a name="Notifications"></a><em>Notifications</em>The NETCONF client is also compliant with RFC 5277 NETCONF Event
Notifications, which defines a mechanism for an asynchronous message 
notification delivery service for the NETCONF protocol.Specific functions to support this are
<a href="#create_subscription-1">create_subscription-1</a>
and
<a href="#get_event_streams-1">get_event_streams-1</a>.<a name="Default_timeout"></a><em>Default Timeout</em>Most of the functions in this module have one variant with
a <strong>Timeout</strong> parameter, and one without. If nothing else is
specified, the default value <strong>infinity</strong> is used when
the <strong>Timeout</strong> parameter is not given.</p><h2>Data Types</h2><span class="name">client</span><span class="name">error_reason</span><span class="name">event_time</span><span class="name">handle</span><p>Opaque reference for a connection to a NETCONF server or a
NETCONF session.</p><span class="name">host</span><span class="name">netconf_db</span><span class="name">notification</span><span class="name">notification_content</span><span class="name">option</span><p><strong>SshConnectOption</strong> is any valid option to
<a href="../ssh/ssh#connect-3">ssh/ssh#connect-3</a>.
Common options used are <strong>user</strong>, <strong>password</strong>
and <strong>user_dir</strong>. The <strong>SshConnectOptions</strong> are
verfied by the SSH application.</p><span class="name">options</span><p>Options used for setting up an SSH connection to a NETCONF
server.</p><span class="name">server_id</span><p>The identity of a server, specified in a configuration
file.</p><span class="name">simple_xml</span><p>This type is further described in application
<a href="./index">xmerl/index</a>.</p><span class="name">stream_data</span><p>For details about the data format for the string values, see
"XML Schema for Event Notifications" in RFC 5277.</p><span class="name">stream_name</span><span class="name">streams</span><span class="name">xml_attribute_tag</span><span class="name">xml_attribute_value</span><span class="name">xml_attributes</span><span class="name">xml_content</span><span class="name">xml_tag</span><span class="name">xpath</span><span class="name">xs_datetime</span><p>This date and time identifier has the same format as the XML type
<strong>dateTime</strong> and is compliant with RFC 3339 Date and Time on
the Internet Timestamps. The format is as follows:</p><pre>
 [-]CCYY-MM-DDThh:mm:ss[.s][Z|(+|-)hh:mm]</pre><h2>Functions</h2><h3>action/2</h3><h3>action/3</h3><p>Executes an action.</p><p>Executes an action. If the return type is void, <strong>ok</strong> is
returned instead of <strong>{ok,[simple_xml()]}</strong>.</p><h3>close_session/1</h3><h3>close_session/2</h3><p>Requests graceful termination of the session associated with the client.</p><p>Requests graceful termination of the session associated with the
client.</p><p>When a NETCONF server receives a <strong>close-session</strong> request, it
gracefully closes the session.  The server releases any locks and
resources associated with the session and gracefully closes any
associated connections. Any NETCONF requests received after a
<strong>close-session</strong> request are ignored.</p><h3>connect/1</h3><p>Opens an SSH connection to a NETCONF server.</p><p>Opens an SSH connection to a NETCONF server.</p><p>If the server options are specified in a configuration file, use
<a href="#connect-2">connect-2</a>
instead.</p><p>The opaque <a href="#type-handle">type-handle</a>
reference returned from this
function is required as connection identifier when opening
sessions over this connection, see
<a href="#session-1">session-1</a>.</p><p>Option <strong>timeout</strong> (milliseconds) is used when setting up the
SSH connection. It is not used for any other purposes during the
lifetime of the connection.</p><h3>connect/2</h3><p>Opens an SSH connection to a named NETCONF server.</p><p>Open an SSH connection to a named NETCONF server.</p><p>If <strong><span class="anno">KeyOrName</span></strong> is a
configured <strong>server_id()</strong> or a
<strong>target_name()</strong> associated with such an Id, then the options
for this server are fetched from the configuration file.</p><p>Argument <strong><span class="anno">ExtraOptions</span></strong> is added to the
options found in the configuration file. If the same options
are specified, the values from the configuration file
overwrite <strong><span class="anno">ExtraOptions</span></strong>.</p><p>If the server is not specified in a configuration file, use
<a href="#connect-1">connect-1</a>
instead.</p><p>The opaque <a href="#type-handle">type-handle</a>
reference returned from this
function can be used as connection identifier when opening
sessions over this connection, see
<a href="#session-1">session-1</a>.
However, if <strong><span class="anno">KeyOrName</span></strong> is a
<strong>target_name()</strong>, that is, if the server is named through a
call to <a href="./ct#require-2">ct#require-2</a>
or a <strong>require</strong> statement in the test suite, then this name can
be used instead of
<a href="#type-handle">type-handle</a>.</p><p>Option <strong>timeout</strong> (milliseconds) is used when setting up the
SSH connection. It is not used for any other purposes during the
lifetime of the connection.</p><h3>copy_config/3</h3><h3>copy_config/4</h3><p>Copies configuration data.</p><p>Copies configuration data.</p><p>Which source and target options that can be issued depends on the
capabilities supported by the server. That is, <strong>:candidate</strong>
and/or <strong>:startup</strong> are required.</p><h3>create_subscription(Client) -&gt; Result</h3><h3>create_subscription(Client, Stream) -&gt; Result</h3><h3>create_subscription(Client, Stream, Filter) -&gt; Result</h3><h3>create_subscription(Client, Stream, Filter, Timeout) -&gt; Result</h3><h3>create_subscription/5</h3><h3>create_subscription/6</h3><p>Creates a subscription for event notifications.</p><p>Creates a subscription for event notifications.</p><p>This function sets up a subscription for NETCONF event
notifications of the specified stream type, matching the specified
filter. The calling process receives notifications as messages of
type <a href="#type-notification">type-notification</a>.</p><p>Only a subset of the function clauses are show above. The
full set of valid combinations of input parameters is as
follows:</p><pre>create_subscription(Client)

create_subscription(Client, Timeout)
create_subscription(Client, Stream)
create_subscription(Client, Filter)

create_subscription(Client, Stream, Timeout)
create_subscription(Client, Filter, Timeout)
create_subscription(Client, Stream, Filter)
create_subscription(Client, StartTime, StopTime)

create_subscription(Client, Stream, Filter, Timeout)
create_subscription(Client, StartTime, StopTime, Timeout)
create_subscription(Client, Stream, StartTime, StopTime)
create_subscription(Client, Filter, StartTime, StopTime)

create_subscription(Client, Stream, StartTime, StopTime, Timeout)
create_subscription(Client, Stream, Filter, StartTime, StopTime)
create_subscription(Client, Stream, Filter, StartTime, StopTime, Timeout)</pre><dl><dt><strong><span class="anno">Stream</span></strong></dt><dd><p>Optional parameter that indicates which stream of event
is of interest. If not present, events in the default NETCONF
stream are sent.</p></dd><dt><strong><span class="anno">Filter</span></strong></dt><dd><p>Optional parameter that indicates which subset of all
possible events is of interest. The parameter format is the
same as that of the filter parameter in the NETCONF protocol
operations. If not present, all events not precluded by other
parameters are sent.</p></dd><dt><strong><span class="anno">StartTime</span></strong></dt><dd><p>Optional parameter used to trigger the replay feature and
indicate that the replay is to start at the time specified.
If <strong><span class="anno">StartTime</span></strong> is not present, this is not a
replay subscription.</p> <p>It is not valid to specify start times that are later than
the current time. If <strong><span class="anno">StartTime</span></strong> is specified
earlier than the log can support, the replay begins with the
earliest available notification.</p> <p>This parameter is of type <strong>dateTime</strong> and compliant to
RFC 3339. Implementations must support time zones.</p></dd><dt><strong><span class="anno">StopTime</span></strong></dt><dd><p>Optional parameter used with the optional replay feature
to indicate the newest notifications of interest. If
<strong><span class="anno">StopTime</span></strong> is not present, the notifications
continues until the subscription is terminated.</p> <p>Must be used with and be later than <strong>StartTime</strong>. Values
of <strong><span class="anno">StopTime</span></strong> in the future are valid. This
parameter is of type <strong>dateTime</strong> and compliant to RFC 3339.
Implementations must support time zones.</p></dd></dl><p>For more details about the event notification mechanism, see
RFC 5277.</p><h3>delete_config/2</h3><h3>delete_config/3</h3><p>Deletes configuration data.</p><p>Deletes configuration data.</p><p>The running configuration cannot be deleted and <strong>:candidate</strong>
or <strong>:startup</strong> must be advertised by the server.</p><h3>disconnect/1</h3><p>Closes the given SSH connection.</p><p>Closes the given SSH connection.</p><p>If there are open NETCONF sessions on the connection, these
will be brutally aborted. To avoid this, close each session
with <a href="#close_session-1">close_session-1</a></p><h3>edit_config/3</h3><h3>edit_config/4</h3><h3>edit_config/4</h3><h3>edit_config/5</h3><p>Edits configuration data.</p><p>Edits configuration data.</p><p>By default only the running target is available, unless the server
includes <strong>:candidate</strong> or <strong>:startup</strong> in its list of
capabilities.</p><p><strong>OptParams</strong> can be used for specifying optional parameters
(<strong>default-operation</strong>, <strong>test-option</strong>, or
<strong>error-option</strong>) to be added to the <strong>edit-config</strong>
request. The value must be a list containing valid simple XML,
for example:</p><pre>
 [{'default-operation', ["none"]},
  {'error-option', ["rollback-on-error"]}]</pre><p>If <strong><span class="anno">OptParams</span></strong> is not given, the default
value <strong>[]</strong> is used.</p><h3>get/2</h3><h3>get/3</h3><p>Gets data.</p><p>Gets data.</p><p>This operation returns both configuration and state data from the
server.</p><p>Filter type <strong>xpath</strong> can be used only if the server supports
<strong>:xpath</strong>.</p><h3>get_capabilities/1</h3><h3>get_capabilities/2</h3><p>Returns the server side capabilities.</p><p>Returns the server side capabilities.</p><p>The following capability identifiers, defined in RFC 4741 NETCONF
Configuration Protocol, can be returned:</p><ul><li><p><strong>"urn:ietf:params:netconf:base:1.0"</strong></p></li><li><p><strong>"urn:ietf:params:netconf:capability:writable-running:1.0"</strong></p></li><li><p><strong>"urn:ietf:params:netconf:capability:candidate:1.0"</strong></p></li><li><p><strong>"urn:ietf:params:netconf:capability:confirmed-commit:1.0"</strong></p></li><li><p><strong>"urn:ietf:params:netconf:capability:rollback-on-error:1.0"</strong></p></li><li><p><strong>"urn:ietf:params:netconf:capability:startup:1.0"</strong></p></li><li><p><strong>"urn:ietf:params:netconf:capability:url:1.0"</strong></p></li><li><p><strong>"urn:ietf:params:netconf:capability:xpath:1.0"</strong></p></li></ul><p>More identifiers can exist, for example, server-side namespace.</p><h3>get_config/3</h3><h3>get_config/4</h3><p>Gets configuration data.</p><p>Gets configuration data.</p><p>To be able to access another source than <strong>running</strong>, the
server must advertise <strong>:candidate</strong> and/or <strong>:startup</strong>.</p><p>Filter type <strong>xpath</strong> can be used only if the server supports
<strong>:xpath</strong>.</p><h3>get_event_streams/1</h3><h3>get_event_streams/2</h3><h3>get_event_streams/2</h3><h3>get_event_streams/3</h3><p>Sends a request to get the specified event streams.</p><p>Sends a request to get the specified event streams.</p><p><strong>Streams</strong> is a list of stream names. The following filter is
sent to the NETCONF server in a <strong>get</strong> request:</p><pre>
 &lt;netconf xmlns="urn:ietf:params:xml:ns:netmod:notification"&gt;
   &lt;streams&gt;
     &lt;stream&gt;
       &lt;name&gt;StreamName1&lt;/name&gt;
     &lt;/stream&gt;
     &lt;stream&gt;
       &lt;name&gt;StreamName2&lt;/name&gt;
     &lt;/stream&gt;
     ...
   &lt;/streams&gt;
 &lt;/netconf&gt;</pre><p>If <strong>Streams</strong> is an empty list, <em>all</em> streams are
requested by sending the following filter:</p><pre>
 &lt;netconf xmlns="urn:ietf:params:xml:ns:netmod:notification"&gt;
   &lt;streams/&gt;
 &lt;/netconf&gt;</pre><p>If more complex filtering is needed, use
<a href="#get-2">get-2</a> and
specify the exact filter according to "XML Schema for Event
Notifications" in RFC 5277.</p><h3>get_session_id/1</h3><h3>get_session_id/2</h3><p>Returns the session Id associated with the specified client.</p><p>Returns the session Id associated with the specified client.</p><h3>hello/1</h3><h3>hello/2</h3><h3>hello/3</h3><p>Exchanges hello messages with the server.</p><p>Exchanges <strong>hello</strong> messages with the server.</p><p>Adds optional capabilities and sends a <strong>hello</strong> message to the
server and waits for the return.</p><h3>kill_session/2</h3><h3>kill_session/3</h3><p>Forces termination of the session associated with the supplied session Id.</p><p>Forces termination of the session associated with the supplied
session Id.</p><p>The server side must abort any ongoing operations, release any
locks and resources associated with the session, and close any
associated connections.</p><p>Only if the server is in the confirmed commit phase, the
configuration is restored to its state before entering the confirmed
commit phase. Otherwise, no configuration rollback is performed.</p><p>If the specified <strong>SessionId</strong> is equal to the current session
Id, an error is returned.</p><h3>lock/2</h3><h3>lock/3</h3><p>Locks the configuration target.</p><p>Locks the configuration target.</p><p>Which target parameters that can be used depends on if
<strong>:candidate</strong> and/or <strong>:startup</strong> are supported by the
server. If successfull, the configuration system of the device is
unavailable to other clients (NETCONF, CORBA, SNMP, and so on).
Locks are intended to be short-lived.</p><p>Operation
<a href="#kill_session-2">kill_session-2</a>
can be used to force the release of a lock owned by another NETCONF
session. How this is achieved by the server side is
implementation-specific.</p><h3>only_open/1</h3><p>Opens a NETCONF session, but does not send hello.</p><p>Opens a NETCONF session, but does not send <strong>hello</strong>.</p><p>As <a href="#open-1">open-1</a>, but
does not send a <strong>hello</strong> message.</p><h3>only_open/2</h3><p>Opens a named NETCONF session, but does not send hello.</p><p>Opens a named NETCONF session, but does not send <strong>hello</strong>.</p><p>As <a href="#open-2">open-2</a>, but
does not send a <strong>hello</strong> message.</p><h3>open/1</h3><p>Opens a NETCONF session and exchanges hello messages.</p><p>Opens a NETCONF session and exchanges <strong>hello</strong> messages.</p><p>If the server options are specified in a configuration file,
or if a named client is needed for logging purposes (see section
<a href="#Logging">Logging</a> in this module), use
<a href="#open-2">open-2</a>
instead.</p><p>The opaque <a href="#type-handle">type-handle</a>
reference returned from this
function is required as client identifier when calling any other
function in this module.</p><p>Option <strong>timeout</strong> (milliseconds) is used when setting up the
SSH connection and when waiting for the <strong>hello</strong> message from
the server. It is not used for any other purposes during the
lifetime of the connection.</p><h3>open/2</h3><p>Opens a named NETCONF session and exchanges hello messages.</p><p>Opens a named NETCONF session and exchanges <strong>hello</strong>
messages.</p><p>If <strong><span class="anno">KeyOrName</span></strong> is a
configured <strong>server_id()</strong> or a
<strong>target_name()</strong> associated with such an Id, then the options
for this server are fetched from the configuration file.</p><p>Argument <strong><span class="anno">ExtraOptions</span></strong> is added to the
options found in the configuration file. If the same
options are specified, the values from the configuration
file overwrite <strong><span class="anno">ExtraOptions</span></strong>.</p><p>If the server is not specified in a configuration file, use
<a href="#open-1">open-1</a>
instead.</p><p>The opaque <a href="#type-handle">type-handle</a>
reference returned from this
function can be used as client identifier when calling any other
function in this module. However, if <strong><span class="anno">KeyOrName</span></strong> is a
<strong>target_name()</strong>, that is, if the server is named through a
call to <a href="./ct#require-2">ct#require-2</a>
or a <strong>require</strong> statement in the test suite, then this name can
be used instead of
<a href="#type-handle">type-handle</a>.</p><p>Option <strong>timeout</strong> (milliseconds) is used when setting up the
SSH connection and when waiting for the <strong>hello</strong> message from
the server. It is not used for any other purposes during the
lifetime of the connection.</p><p>See also
<a href="./ct#require-2">ct#require-2</a>.</p><h3>send/2</h3><h3>send/3</h3><p>Sends an XML document to the server.</p><p>Sends an XML document to the server.</p><p>The specified XML document is sent "as is" to the server. This
function can be used for sending XML documents that cannot be
expressed by other interface functions in this module.</p><h3>send_rpc/2</h3><h3>send_rpc/3</h3><p>Sends a NETCONF rpc request to the server.</p><p>Sends a NETCONF <strong>rpc</strong> request to the server.</p><p>The specified XML document is wrapped in a valid NETCONF <strong>rpc</strong>
request and sent to the server. The <strong>message-id</strong> and namespace
attributes are added to element <strong>rpc</strong>.</p><p>This function can be used for sending <strong>rpc</strong> requests that
cannot be expressed by other interface functions in this module.</p><h3>session/1</h3><h3>session/2</h3><h3>session/2</h3><h3>session/3</h3><p>Opens a NETCONF session as a channel on the given SSH connection, and exchanges hello messages with the server.</p><ul><li>session_options</li></ul><ul><li>session_option</li></ul><p>Opens a NETCONF session as a channel on the given SSH
connection, and exchanges hello messages with the server.</p><p>The opaque <a href="#type-handle">type-handle</a>
reference returned from this
function can be used as client identifier when calling any
other function in this module. However, if <strong><span class="anno">KeyOrName</span></strong>
is used and it is a <strong>target_name()</strong>, that is, if the
server is named through a call
to <a href="./ct#require-2">ct#require-2</a>
or a <strong>require</strong> statement in the test suite, then this
name can be used instead of
<a href="#type-handle">type-handle</a>.</p><h3>unlock/2</h3><h3>unlock/3</h3><p>Unlocks the configuration target.</p><p>Unlocks the configuration target.</p><p>If the client earlier has acquired a lock through
<a href="#lock-2">lock-2</a>, this
operation releases the associated lock. To access another target
than <strong>running</strong>, the server must support <strong>:candidate</strong>
and/or <strong>:startup</strong>.</p><h2>ct_rpc</h2><p>Common Test specific layer on Erlang/OTP rpc.</p><p><strong>Common Test</strong> specific layer on Erlang/OTP <strong>rpc</strong>.</p><h2>Functions</h2><h3>app_node(App, Candidates) -&gt; NodeName</h3><p>From a set of candidate nodes determines which of them is running the application App.</p><ul><li><span class="v">App = atom()</span></li><li><span class="v">Candidates = [NodeName]</span></li><li><span class="v">NodeName = atom()</span></li></ul><a name="app_node-2"></a><p>From a set of candidate nodes determines which of them is running
the application <strong>App</strong>. If none of the candidate nodes is
running <strong>App</strong>, the function makes the test case calling
this function to fail. This function is the same as calling
<strong>app_node(App, Candidates, true)</strong>.</p><h3>app_node(App, Candidates, FailOnBadRPC) -&gt; NodeName</h3><p>Same as app_node/2, except that argument FailOnBadRPC determines if the search for a candidate node is to stop if badrpc is received at some point.</p><ul><li><span class="v">App = atom()</span></li><li><span class="v">Candidates = [NodeName]</span></li><li><span class="v">NodeName = atom()</span></li><li><span class="v">FailOnBadRPC = true | false</span></li></ul><a name="app_node-3"></a><p>Same as
<a href="#app_node-2">app_node-2</a>,
except that argument <strong>FailOnBadRPC</strong> determines if the search
for a candidate node is to stop if <strong>badrpc</strong> is received at
some point.</p><h3>app_node(App, Candidates, FailOnBadRPC, Cookie) -&gt; NodeName</h3><p>Same as app_node/2, except that argument FailOnBadRPC determines if the search for a candidate node is to stop if badrpc is received at some point.</p><ul><li><span class="v">App = atom()</span></li><li><span class="v">Candidates = [NodeName]</span></li><li><span class="v">NodeName = atom()</span></li><li><span class="v">FailOnBadRPC = true | false</span></li><li><span class="v">Cookie = atom()</span></li></ul><a name="app_node-4"></a><p>Same as
<a href="#app_node-2">app_node-2</a>,
except that argument <strong>FailOnBadRPC</strong> determines if the search
for a candidate node is to stop if <strong>badrpc</strong> is received at
some point.</p><p>The cookie on the client node is set to <strong>Cookie</strong> for this
<strong>rpc</strong> operation (used to match the server node cookie).</p><h3>call(Node, Module, Function, Args) -&gt; term() | {badrpc, Reason}</h3><p>Same as call(Node, Module, Function, Args, infinity).</p><a name="call-4"></a><p>Same as <strong>call(Node, Module, Function, Args, infinity)</strong>.</p><h3>call(Node, Module, Function, Args, TimeOut) -&gt; term() | {badrpc, Reason}</h3><p>Evaluates apply(Module, Function, Args) on the node Node.</p><ul><li><span class="v">Node = NodeName | {Fun, FunArgs}</span></li><li><span class="v">Fun = function()</span></li><li><span class="v">FunArgs = term()</span></li><li><span class="v">NodeName = atom()</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Function = atom()</span></li><li><span class="v">Args = [term()]</span></li><li><span class="v">Reason = timeout | term()</span></li></ul><a name="call-5"></a><p>Evaluates <strong>apply(Module, Function, Args)</strong> on the node
<strong>Node</strong>. Returns either whatever <strong>Function</strong> returns, or
<strong>{badrpc, Reason}</strong> if the remote procedure call fails. If
<strong>Node</strong> is <strong>{Fun, FunArgs}</strong>, applying <strong>Fun</strong> to
<strong>FunArgs</strong> is to return a node name.</p><h3>call(Node, Module, Function, Args, TimeOut, Cookie) -&gt; term() | {badrpc, Reason}</h3><p>Evaluates apply(Module, Function, Args) on the node Node.</p><ul><li><span class="v">Node = NodeName | {Fun, FunArgs}</span></li><li><span class="v">Fun = function()</span></li><li><span class="v">FunArgs = term()</span></li><li><span class="v">NodeName = atom()</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Function = atom()</span></li><li><span class="v">Args = [term()]</span></li><li><span class="v">Reason = timeout | term()</span></li><li><span class="v">Cookie = atom()</span></li></ul><a name="call-6"></a><p>Evaluates <strong>apply(Module, Function, Args)</strong> on the node
<strong>Node</strong>. Returns either whatever <strong>Function</strong> returns, or
<strong>{badrpc, Reason}</strong> if the remote procedure call fails. If
<strong>Node</strong> is <strong>{Fun, FunArgs}</strong>, applying <strong>Fun</strong> to
<strong>FunArgs</strong> is to return a node name.</p><p>The cookie on the client node is set to <strong>Cookie</strong> for this
<strong>rpc</strong> operation (used to match the server node cookie).</p><h3>cast(Node, Module, Function, Args) -&gt; ok</h3><p>Evaluates apply(Module, Function, Args) on the node Node.</p><ul><li><span class="v">Node = NodeName | {Fun, FunArgs}</span></li><li><span class="v">Fun = function()</span></li><li><span class="v">FunArgs = term()</span></li><li><span class="v">NodeName = atom()</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Function = atom()</span></li><li><span class="v">Args = [term()]</span></li><li><span class="v">Reason = timeout | term()</span></li></ul><a name="cast-4"></a><p>Evaluates <strong>apply(Module, Function, Args)</strong> on the node
<strong>Node</strong>. No response is delivered and the process that makes
the call is not suspended until the evaluation is completed as in
the case of <strong>call/3,4</strong>. If <strong>Node</strong> is
<strong>{Fun, FunArgs}</strong>, applying <strong>Fun</strong> to <strong>FunArgs</strong> is to
return a node name.</p><h3>cast(Node, Module, Function, Args, Cookie) -&gt; ok</h3><p>Evaluates apply(Module, Function, Args) on the node Node.</p><ul><li><span class="v">Node = NodeName | {Fun, FunArgs}</span></li><li><span class="v">Fun = function()</span></li><li><span class="v">FunArgs = term()</span></li><li><span class="v">NodeName = atom()</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Function = atom()</span></li><li><span class="v">Args = [term()]</span></li><li><span class="v">Reason = timeout | term()</span></li><li><span class="v">Cookie = atom()</span></li></ul><a name="cast-5"></a><p>Evaluates <strong>apply(Module, Function, Args)</strong> on the node
<strong>Node</strong>. No response is delivered and the process that makes
the call is not suspended until the evaluation is completed as in
the case of <strong>call/3,4</strong>. If <strong>Node</strong> is
<strong>{Fun, FunArgs}</strong>, applying <strong>Fun</strong> to <strong>FunArgs</strong> is to
return a node name.</p><p>The cookie on the client node is set to <strong>Cookie</strong> for this
<strong>rpc</strong> operation (used to match the server node cookie).</p><h2>ct_snmp</h2><p>Common Test user interface module for the SNMP application.</p><p><strong>Common Test</strong> user interface module for the <strong>SNMP</strong>
application.The purpose of this module is to simplify SNMP configuration for the
test case writer. Many test cases can use default values for common
operations and then no SNMP configuration files need to be supplied.
When it is necessary to change particular configuration parameters, a
subset of the relevant SNMP configuration files can be passed to
<strong>ct_snmp</strong> by <strong>Common Test</strong> configuration files. For more
specialized configuration parameters, a simple SNMP configuration file
can be placed in the test suite data directory. To simplify the test
suite, <strong>Common Test</strong> keeps track of some of the SNMP manager
information. This way the test suite does not have to handle as many
input parameters as if it had to interface wthe OTP SNMP manager
directly.<em>Configurable SNMP Manager and Agent Parameters:</em>Manager configuration:<dl><dt><strong>[{start_manager, boolean()}</strong></dt><dd><p>Optional. Default is <strong>true</strong>.</p></dd><dt><strong>{users, [{user_name(), [call_back_module(), user_data()]}]}</strong></dt><dd><p>Optional.</p></dd><dt><strong>{usm_users, [{usm_user_name(), [usm_config()]}]}</strong></dt><dd><p>Optional. SNMPv3 only.</p></dd><dt><strong>{managed_agents,[{agent_name(), [user_name(), agent_ip(), agent_port(), [agent_config()]]}]}</strong></dt><dd><p><strong>managed_agents</strong> is optional.</p></dd><dt><strong>{max_msg_size, integer()}</strong></dt><dd><p>Optional. Default is <strong>484</strong>.</p></dd><dt><strong>{mgr_port, integer()}</strong></dt><dd><p>Optional. Default is <strong>5000</strong>.</p></dd><dt><strong>{engine _id, string()}</strong></dt><dd><p>Optional. Default is <strong>"mgrEngine"</strong>.</p></dd></dl>Agent configuration:<dl><dt><strong>{start_agent, boolean()}</strong></dt><dd><p>Optional. Default is <strong>false</strong>.</p></dd><dt><strong>{agent_sysname, string()}</strong></dt><dd><p>Optional. Default is <strong>"ct_test"</strong>.</p></dd><dt><strong>{agent_manager_ip, manager_ip()}</strong></dt><dd><p>Optional. Default is <strong>localhost</strong>.</p></dd><dt><strong>{agent_vsns, list()}</strong></dt><dd><p>Optional. Default is <strong>[v2]</strong>.</p></dd><dt><strong>{agent_trap_udp, integer()}</strong></dt><dd><p>Optional. Default is <strong>5000</strong>.</p></dd><dt><strong>{agent_udp, integer()}</strong></dt><dd><p>Optional. Default is <strong>4000</strong>.</p></dd><dt><strong>{agent_notify_type, atom()}</strong></dt><dd><p>Optional. Default is <strong>trap</strong>.</p></dd><dt><strong>{agent_sec_type, sec_type()}</strong></dt><dd><p>Optional. Default is <strong>none</strong>.</p></dd><dt><strong>{agent_passwd, string()}</strong></dt><dd><p>Optional. Default is <strong>""</strong>.</p></dd><dt><strong>{agent_engine_id, string()}</strong></dt><dd><p>Optional. Default is <strong>"agentEngine"</strong>.</p></dd><dt><strong>{agent_max_msg_size, string()}</strong></dt><dd><p>Optional. Default is <strong>484</strong>.</p></dd></dl>The following parameters represents the SNMP configuration files
<strong>context.conf</strong>, <strong>standard.conf</strong>, <strong>community.conf</strong>,
<strong>vacm.conf</strong>, <strong>usm.conf</strong>, <strong>notify.conf</strong>,
<strong>target_addr.conf</strong>, and <strong>target_params.conf</strong>. Notice that
all values in <strong>agent.conf</strong> can be modified by the parameters
listed above. All these configuration files have default values set by
the <strong>SNMP</strong> application. These values can be overridden by suppling
a list of valid configuration values or a file located in the test
suites data directory, which can produce a list of valid configuration
values if you apply function <strong>file:consult/1</strong> to the file.<dl><dt><strong>{agent_contexts, [term()] | {data_dir_file, rel_path()}}</strong></dt><dd><p>Optional.</p></dd><dt><strong>{agent_community, [term()] | {data_dir_file, rel_path()}}</strong></dt><dd><p>Optional.</p></dd><dt><strong>{agent_sysinfo,  [term()] | {data_dir_file, rel_path()}}</strong></dt><dd><p>Optional.</p></dd><dt><strong>{agent_vacm, [term()] | {data_dir_file, rel_path()}}</strong></dt><dd><p>Optional.</p></dd><dt><strong>{agent_usm, [term()] | {data_dir_file, rel_path()}}</strong></dt><dd><p>Optional.</p></dd><dt><strong>{agent_notify_def, [term()] | {data_dir_file, rel_path()}}</strong></dt><dd><p>Optional.</p></dd><dt><strong>{agent_target_address_def, [term()] | {data_dir_file, rel_path()}}</strong></dt><dd><p>Optional.</p></dd><dt><strong>{agent_target_param_def, [term()] | {data_dir_file, rel_path()}}</strong></dt><dd><p>Optional.</p></dd></dl>Parameter <strong>MgrAgentConfName</strong> in the functions is to be a name
you allocate in your test suite using a <strong>require</strong> statement.
Example (where <strong>MgrAgentConfName = snmp_mgr_agent</strong>):<pre>
 suite() -&gt; [{require, snmp_mgr_agent, snmp}].</pre>or<pre>
 ct:require(snmp_mgr_agent, snmp).</pre>Notice that USM users are needed for SNMPv3 configuration and are
not to be confused with users.SNMP traps, inform, and report messages are handled by the user
callback module. For details, see the
<a href="./index">snmp/index</a> application.It is recommended to use the <strong>.hrl</strong> files created by the
Erlang/OTP MIB compiler to define the Object Identifiers (OIDs).
For example, to get the Erlang node name from <strong>erlNodeTable</strong>
in the OTP-MIB:<pre>
 Oid = ?erlNodeEntry ++ [?erlNodeName, 1]</pre>Furthermore, values can be set for <strong>SNMP</strong> application configuration
parameters, <strong>config</strong>, <strong>server</strong>, <strong>net_if</strong>, and so on (for
a list of valid parameters and types, see the  <a href="./users_guide">snmp/users_guide</a>). This is
done by defining a configuration data variable on the following form:<pre>
 {snmp_app, [{manager, [snmp_app_manager_params()]},
             {agent, [snmp_app_agent_params()]}]}.</pre>A name for the data must be allocated in the suite using
<strong>require</strong> (see the example above). Pass this name as argument
<strong>SnmpAppConfName</strong> to
<a href="#start-3">start-3</a>.
<strong>ct_snmp</strong> specifies default values for some <strong>SNMP</strong> application
configuration parameters (such as <strong>{verbosity,trace}</strong> for parameter
<strong>config</strong>). This set of defaults is merged with the parameters
specified by the user. The user values override <strong>ct_snmp</strong>
defaults.</p><h3>Data Types</h3><a name="types"></a><dl><dt><strong>agent_config() = {Item, Value}</strong></dt><dd><a name="type-agent_config"></a> </dd><dt><strong>agent_ip() = ip()</strong></dt><dd><a name="type-agent_ip"></a> </dd><dt><strong>agent_name() = atom()</strong></dt><dd><a name="type-agent_name"></a> </dd><dt><strong>agent_port() = integer()</strong></dt><dd><a name="type-agent_port"></a> </dd><dt><strong>call_back_module() = atom()</strong></dt><dd><a name="type-call_back_module"></a> </dd><dt><strong>error_index() = integer()</strong></dt><dd><a name="type-error_index"></a> </dd><dt><strong>error_status() = noError | atom()</strong></dt><dd><a name="type-error_status"></a> </dd><dt><strong>ip() = string() | {integer(), integer(), integer(), integer()}</strong></dt><dd><a name="type-ip"></a> </dd><dt><strong>manager_ip() = ip()</strong></dt><dd><a name="type-manager_ip"></a> </dd><dt><strong>oid() = [byte()]</strong></dt><dd><a name="type-oid"></a> </dd><dt><strong>oids() = [oid()]</strong></dt><dd><a name="type-oids"></a> </dd><dt><strong>rel_path() = string()</strong></dt><dd><a name="type-rel_path"></a> </dd><dt><strong>sec_type() = none | minimum | semi</strong></dt><dd><a name="type-sec_type"></a> </dd><dt><strong>snmp_app_agent_params() = term()</strong></dt><dd><a name="type-snmp_app_agent_params"></a> </dd><dt><strong>snmp_app_manager_params() = term()</strong></dt><dd><a name="type-snmp_app_manager_params"></a> </dd><dt><strong>snmpreply() = {error_status(), error_index(), varbinds()}</strong></dt><dd><a name="type-snmpreply"></a> </dd><dt><strong>user_data() = term()</strong></dt><dd><a name="type-user_data"></a> </dd><dt><strong>user_name() = atom()</strong></dt><dd><a name="type-user_name"></a> </dd><dt><strong>usm_config() = {Item, Value}</strong></dt><dd><a name="type-usm_config"></a> </dd><dt><strong>usm_user_name() = string()</strong></dt><dd><a name="type-usm_user_name"></a> </dd><dt><strong>value_type() = o('OBJECT IDENTIFIER') | i('INTEGER') | u('Unsigned32') | g('Unsigned32') | s('OCTET STRING')</strong></dt><dd><a name="type-value_type"></a> </dd><dt><strong>var_and_val() = {oid(), value_type(), value()}</strong></dt><dd><a name="type-var_and_val"></a> </dd><dt><strong>varbind() = term()</strong></dt><dd><a name="type-varbind"></a> </dd><dt><strong>varbinds() = [varbind()]</strong></dt><dd><a name="type-varbinds"></a> </dd><dt><strong>varsandvals() = [var_and_val()]</strong></dt><dd><a name="type-varsandvals"></a> </dd></dl><p>These data types are described in the documentation for
the <a href="./index">snmp/index</a> application.</p><h2>Functions</h2><h3>get_next_values(Agent, Oids, MgrAgentConfName) -&gt; SnmpReply</h3><p>Issues a synchronous SNMP get next request.</p><ul><li><span class="v">Agent = agent_name()</span></li><li><span class="v">Oids = oids()</span></li><li><span class="v">MgrAgentConfName = atom()</span></li><li><span class="v">SnmpReply = snmpreply()</span></li></ul><a name="get_next_values-3"></a><p>Issues a synchronous SNMP <strong>get next</strong> request.</p><h3>get_values(Agent, Oids, MgrAgentConfName) -&gt; SnmpReply</h3><p>Issues a synchronous SNMP get request.</p><ul><li><span class="v">Agent = agent_name()</span></li><li><span class="v">Oids = oids()</span></li><li><span class="v">MgrAgentConfName = atom()</span></li><li><span class="v">SnmpReply = snmpreply()</span></li></ul><a name="get_values-3"></a><p>Issues a synchronous SNMP <strong>get</strong> request.</p><h3>load_mibs(Mibs) -&gt; ok | {error, Reason}</h3><p>Loads the MIBs into agent snmp_master_agent.</p><ul><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="load_mibs-1"></a><p>Loads the MIBs into agent <strong>snmp_master_agent</strong>.</p><h3>register_agents(MgrAgentConfName, ManagedAgents) -&gt; ok | {error, Reason}</h3><p>Explicitly instructs the manager to handle this agent.</p><ul><li><span class="v">MgrAgentConfName = atom()</span></li><li><span class="v">ManagedAgents = [agent()]</span></li><li><span class="v">Reason = term()</span></li></ul><a name="register_agents-2"></a><p>Explicitly instructs the manager to handle this agent. Corresponds
to making an entry in <strong>agents.conf</strong>.</p><p>This function tries to register the specified managed agents, without
checking if any of them exist. To change a registered managed agent,
the agent must first be unregistered.</p><h3>register_users(MgrAgentConfName, Users) -&gt; ok | {error, Reason}</h3><p>Registers the manager entity (=user) responsible for specific agent(s).</p><ul><li><span class="v">MgrAgentConfName = atom()</span></li><li><span class="v">Users = [user()]</span></li><li><span class="v">Reason = term()</span></li></ul><a name="register_users-2"></a><p>Registers the manager entity (=user) responsible for specific
agent(s). Corresponds to making an entry in <strong>users.conf</strong>.</p><p>This function tries to register the specified users, without checking
if any of them exist. To change a registered user, the user must
first be unregistered.</p><h3>register_usm_users(MgrAgentConfName, UsmUsers) -&gt; ok | {error, Reason}</h3><p>Explicitly instructs the manager to handle this USM user.</p><ul><li><span class="v">MgrAgentConfName = atom()</span></li><li><span class="v">UsmUsers = [usm_user()]</span></li><li><span class="v">Reason = term()</span></li></ul><a name="register_usm_users-2"></a><p>Explicitly instructs the manager to handle this USM user.
Corresponds to making an entry in <strong>usm.conf</strong>.</p><p>This function tries to register the specified users, without checking
if any of them exist. To change a registered user, the user must
first be unregistered.</p><h3>set_info(Config) -&gt; [{Agent, OldVarsAndVals, NewVarsAndVals}]</h3><p>Returns a list of all successful set requests performed in the test case in reverse order.</p><ul><li><span class="v">Config = [{Key, Value}]</span></li><li><span class="v">Agent = agent_name()</span></li><li><span class="v">OldVarsAndVals = varsandvals()</span></li><li><span class="v">NewVarsAndVals = varsandvals()</span></li></ul><a name="set_info-1"></a><p>Returns a list of all successful <strong>set</strong> requests performed in
the test case in reverse order. The list contains the involved user
and agent, the value before <strong>set</strong>, and the new value. This is
intended to simplify the cleanup in function <strong>end_per_testcase</strong>,
that is, the undoing of the <strong>set</strong> requests and their possible
side-effects.</p><h3>set_values(Agent, VarsAndVals, MgrAgentConfName, Config) -&gt; SnmpReply</h3><p>Issues a synchronous SNMP set request.</p><ul><li><span class="v">Agent = agent_name()</span></li><li><span class="v">Oids = oids()</span></li><li><span class="v">MgrAgentConfName = atom()</span></li><li><span class="v">Config = [{Key, Value}]</span></li><li><span class="v">SnmpReply = snmpreply()</span></li></ul><a name="set_values-4"></a><p>Issues a synchronous SNMP <strong>set</strong> request.</p><h3>start(Config, MgrAgentConfName) -&gt; ok</h3><p>Equivalent to start(Config, MgrAgentConfName, undefined).</p><a name="start-2"></a><p>Equivalent to
<a href="#start-3">start-3</a>.</p><h3>start(Config, MgrAgentConfName, SnmpAppConfName) -&gt; ok</h3><p>Starts an SNMP manager and/or agent.</p><ul><li><span class="v">Config = [{Key, Value}]</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">MgrAgentConfName = atom()</span></li><li><span class="v">SnmpConfName = atom()</span></li></ul><a name="start-3"></a><p>Starts an SNMP manager and/or agent. In the manager case,
registrations of users and agents, as specified by the configuration
<strong>MgrAgentConfName</strong>, are performed. When using SNMPv3, called
USM users are also registered. Users, <strong>usm_users</strong>, and
managed agents can also be registered later using
<a href="#register_users-2">register_users-2</a>,
<a href="#register_agents-2">register_agents-2</a>,
and
<a href="#register_usm_users-2">register_usm_users-2</a>.</p><p>The agent started is called <strong>snmp_master_agent</strong>. Use
<a href="#load_mibs-1">load_mibs-1</a>
to load MIBs into the agent.</p><p>With <strong>SnmpAppConfName</strong> SNMP applications can be configured
with parameters <strong>config</strong>, <strong>mibs</strong>, <strong>net_if</strong>, and so on.
The values are merged with (and possibly override) default values
set by <strong>ct_snmp</strong>.</p><h3>stop(Config) -&gt; ok</h3><p>Stops the SNMP manager and/or agent, and removes all files created.</p><ul><li><span class="v">Config = [{Key, Value}]</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li></ul><a name="stop-1"></a><p>Stops the SNMP manager and/or agent, and removes all files
created.</p><h3>unload_mibs(Mibs) -&gt; ok | {error, Reason}</h3><p>Unloads the MIBs from agent snmp_master_agent.</p><ul><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="unload_mibs-1"></a><p>Unloads the MIBs from agent <strong>snmp_master_agent</strong>.</p><h3>unregister_agents(MgrAgentConfName) -&gt; ok</h3><p>Unregisters all managed agents.</p><ul><li><span class="v">MgrAgentConfName = atom()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="unregister_agents-1"></a><p>Unregisters all managed agents.</p><h3>unregister_agents(MgrAgentConfName, ManagedAgents) -&gt; ok</h3><p>Unregisters the specified managed agents.</p><ul><li><span class="v">MgrAgentConfName = atom()</span></li><li><span class="v">ManagedAgents = [agent_name()]</span></li><li><span class="v">Reason = term()</span></li></ul><a name="unregister_agents-2"></a><p>Unregisters the specified managed agents.</p><h3>unregister_users(MgrAgentConfName) -&gt; ok</h3><p>Unregisters all users.</p><ul><li><span class="v">MgrAgentConfName = atom()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="unregister_users-1"></a><p>Unregisters all users.</p><h3>unregister_users(MgrAgentConfName, Users) -&gt; ok</h3><p>Unregisters the specified users.</p><ul><li><span class="v">MgrAgentConfName = atom()</span></li><li><span class="v">Users = [user_name()]</span></li><li><span class="v">Reason = term()</span></li></ul><a name="unregister_users-2"></a><p>Unregisters the specified users.</p><h3>unregister_usm_users(MgrAgentConfName) -&gt; ok</h3><p>Unregisters all USM users.</p><ul><li><span class="v">MgrAgentConfName = atom()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="unregister_usm_users-1"></a><p>Unregisters all USM users.</p><h3>unregister_usm_users(MgrAgentConfName, UsmUsers) -&gt; ok</h3><p>Unregisters the specified USM users.</p><ul><li><span class="v">MgrAgentConfName = atom()</span></li><li><span class="v">UsmUsers = [usm_user_name()]</span></li><li><span class="v">Reason = term()</span></li></ul><a name="unregister_usm_users-2"></a><p>Unregisters the specified USM users.</p><h2>ct_telnet</h2><p>Common Test specific layer on top of Telnet client ct_telnet_client.erl</p><p><strong>Common Test</strong> specific layer on top of Telnet client
<strong>ct_telnet_client.erl</strong>.Use this module to set up Telnet connections, send commands, and
perform string matching on the result. For information about how to use
<strong>ct_telnet</strong> and configure connections, specifically for UNIX hosts,
see the
<a href="unix_telnet">unix_telnet</a> manual page.
Default values defined in <strong>ct_telnet</strong>:<a name="Default_values"></a><ul><li><p>Connection timeout (time to wait for connection) = 10
seconds</p></li><li><p>Command timeout (time to wait for a command to return) =
10 seconds</p></li><li><p>Max number of reconnection attempts = 3</p></li><li><p>Reconnection interval (time to wait in between
reconnection attempts) = 5 seconds</p></li><li><p>Keep alive (sends NOP to the server every 8 sec if
connection is idle) = <strong>true</strong></p></li><li><p>Polling limit (max number of times to poll to get a
remaining string terminated) = 0</p></li><li><p>Polling interval (sleep time between polls) = 1 second</p> </li><li><p>The TCP_NODELAY option for the telnet socket
is disabled (set to <strong>false</strong>) per default</p></li></ul>These parameters can be modified by the user with the following
configuration term:<pre>
 {telnet_settings, [{connect_timeout,Millisec},
                    {command_timeout,Millisec},
                    {reconnection_attempts,N},
                    {reconnection_interval,Millisec},
                    {keep_alive,Bool},
                    {poll_limit,N},
                    {poll_interval,Millisec},
                    {tcp_nodelay,Bool}]}.</pre><strong>Millisec = integer(), N = integer()</strong>Enter the <strong>telnet_settings</strong> term in a configuration file included
in the test and <strong>ct_telnet</strong> retrieves the information
automatically.<strong>keep_alive</strong> can be specified per connection, if necessary. For
details, see
<a href="unix_telnet">unix_telnet</a>.</p><h3>Logging</h3><a name="Logging"></a><p>The default logging behavior of <strong>ct_telnet</strong> is to print information
about performed operations, commands, and their corresponding results to
the test case HTML log. The following is not printed to the HTML
log: text strings sent from the Telnet server that are not explicitly
received by a <strong>ct_telnet</strong> function, such as <strong>expect/3</strong>.
However, <strong>ct_telnet</strong> can be configured to use a special purpose
event handler, implemented in <strong>ct_conn_log_h</strong>, for logging
<em>all</em> Telnet traffic. To use this handler, install a <strong>Common Test</strong> hook named <strong>cth_conn_log</strong>. Example (using the test suite
information function):</p><pre>
 suite() -&gt;
     [{ct_hooks, [{cth_conn_log, [{conn_mod(),hook_options()}]}]}].</pre><p><strong>conn_mod()</strong> is the name of the <strong>Common Test</strong> module
implementing the connection protocol, that is, <strong>ct_telnet</strong>.</p><p>The <strong>cth_conn_log</strong> hook performs unformatted logging of Telnet
data to a separate text file. All Telnet communication is captured and
printed, including any data sent from the server. The link to
this text file is located at the top of the test case HTML log.</p><p>By default, data for all Telnet connections is logged in one common
file (named <strong>default</strong>), which can get messy, for example, if
multiple Telnet sessions are running in parallel. Therefore a separate
log file can be created for each connection. To configure this, use hook
option <strong>hosts</strong> and list the names of the servers/connections
to be used in the suite. The connections must be named for this to
work (see
<a href="#open-1">open-1</a>).</p><p>Hook option <strong>log_type</strong> can be used to change the
<strong>cth_conn_log</strong> behavior. The default value of this option is
<strong>raw</strong>, which results in the behavior described above. If the value
is set to <strong>html</strong>, all Telnet communication is printed to the test
case HTML log instead.</p><p>All <strong>cth_conn_log</strong> hook options described can also be
specified in a configuration file with configuration variable
<strong>ct_conn_log</strong>.</p><p><em>Example:</em></p><pre>
 {ct_conn_log, [{ct_telnet,[{log_type,raw},
                            {hosts,[key_or_name()]}]}]}</pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Hook options specified in a configuration file overwrite any
hard-coded hook options in the test suite.</p></div><a name="Logging_example"></a><p><em>Logging Example:</em></p><p>The following <strong>ct_hooks</strong> statement causes printing of Telnet
traffic to separate logs for the connections <strong>server1</strong> and
<strong>server2</strong>. Traffic for any other connections is logged in the
default Telnet log.</p><pre>
 suite() -&gt;
     [{ct_hooks,
       [{cth_conn_log, [{ct_telnet,[{hosts,[server1,server2]}]}]}]}].</pre><p>As previously explained, this specification can also be provided by an
entry like the following in a configuration file:</p><pre>
 {ct_conn_log, [{ct_telnet,[{hosts,[server1,server2]}]}]}.</pre><p>In this case the <strong>ct_hooks</strong> statement in the test suite can look
as follows:</p><pre>
 suite() -&gt;
     [{ct_hooks, [{cth_conn_log, []}]}].</pre><h3>Data Types</h3><a name="types"></a><dl><dt><strong>connection() = handle() | {target_name(), connection_type()} | target_name()</strong></dt><dd><a name="type-connection"></a> <p>For <strong>target_name()</strong>, see module
<a href="ct">ct</a>.</p></dd><dt><strong>connection_type() = telnet | ts1 | ts2</strong></dt><dd><a name="type-connection_type"></a> </dd><dt><strong>handle() = handle()</strong></dt><dd><a name="type-handle"></a> <p>Handle for a specific Telnet connection, see module
<a href="ct">ct</a>.</p></dd><dt><strong>prompt_regexp() = string()</strong></dt><dd><a name="type-prompt_regexp"></a> <p>Regular expression matching all possible prompts for a specific
target type. <strong>regexp</strong> must not have any groups, that is, when
matching, <strong>re:run/3</strong> (in STDLIB) must return a list with
one single element.</p></dd></dl><h2>Functions</h2><h3>close(Connection) -&gt; ok | {error, Reason}</h3><p>Closes the Telnet connection and stops the process managing it.</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="close-1"></a><p>Closes the Telnet connection and stops the process managing it.</p><p>A connection can be associated with a target name and/or a handle.
If <strong>Connection</strong> has no associated target name, it can only
be closed with the handle value (see
<a href="#open-4">open-4</a>).</p><h3>cmd(Connection, Cmd) -&gt; {ok, Data} | {error, Reason}</h3><p>Equivalent to cmd(Connection, Cmd, []).</p><a name="cmd-2"></a><p>Equivalent to
<a href="#cmd-3">cmd-3</a>.</p><h3>cmd(Connection, Cmd, Opts) -&gt; {ok, Data} | {error, Reason}</h3><p>Sends a command through Telnet and waits for prompt.</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">Cmd = string()</span></li><li><span class="v">Opts = [Opt]</span></li><li><span class="v">Opt = {timeout, timeout()} | {newline, boolean() | string()}</span></li><li><span class="v">Data = [string()]</span></li><li><span class="v">Reason = term()</span></li></ul><a name="cmd-3"></a><p>Sends a command through Telnet and waits for prompt.</p><p>By default, this function adds "\n" to the end of the
specified command. If this is not desired, use option
<strong>{newline,false}</strong>. This is necessary, for example, when
sending Telnet command sequences prefixed with character
Interpret As Command (IAC). Option <strong>{newline,string()}</strong>
can also be used if a different line end than "\n" is
required, for instance <strong>{newline,"\r\n"}</strong>, to add both
carriage return and newline characters.</p><p>Option <strong>timeout</strong> specifies how long the client must wait
for prompt. If the time expires, the function returns
<strong>{error,timeout}</strong>. For information about the default value
for the command timeout, see the
<a href="#Default_values">list of default values</a>
in the beginning of this module.</p><h3>cmdf(Connection, CmdFormat, Args) -&gt; {ok, Data} | {error, Reason}</h3><p>Equivalent to cmdf(Connection, CmdFormat, Args, []).</p><a name="cmdf-3"></a><p>Equivalent to
<a href="#cmdf-4">cmdf-4</a>.</p><h3>cmdf(Connection, CmdFormat, Args, Opts) -&gt; {ok, Data} | {error, Reason}</h3><p>Sends a Telnet command and waits for prompt (uses a format string and a list of arguments to build the command).</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">CmdFormat = string()</span></li><li><span class="v">Args = list()</span></li><li><span class="v">Opts = [Opt]</span></li><li><span class="v">Opt = {timeout, timeout()} | {newline, boolean() | string()}</span></li><li><span class="v">Data = [string()]</span></li><li><span class="v">Reason = term()</span></li></ul><a name="cmdf-4"></a><p>Sends a Telnet command and waits for prompt (uses a format string
and a list of arguments to build the command).</p><p>For details, see
<a href="#cmd-3">cmd-3</a>.</p><h3>expect(Connection, Patterns) -&gt; term()</h3><p>Equivalent to expect(Connections, Patterns, []).</p><a name="expect-2"></a><p>Equivalent to
<a href="#expect-3">expect-3</a>.</p><h3>expect(Connection, Patterns, Opts) -&gt; {ok, Match} | {ok, MatchList, HaltReason} | {error, Reason}</h3><p>Gets data from Telnet and waits for the expected pattern.</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">Patterns = Pattern | [Pattern]</span></li><li><span class="v">Pattern = string() | {Tag, string()} | prompt | {prompt, Prompt}</span></li><li><span class="v">Prompt = string()</span></li><li><span class="v">Tag = term()</span></li><li><span class="v">Opts = [Opt]</span></li><li><span class="v">Opt = {idle_timeout, IdleTimeout} | {total_timeout, TotalTimeout} | repeat | {repeat, N} | sequence | {halt, HaltPatterns} | ignore_prompt | no_prompt_check | wait_for_prompt | {wait_for_prompt, Prompt}</span></li><li><span class="v">IdleTimeout = infinity | integer()</span></li><li><span class="v">TotalTimeout = infinity | integer()</span></li><li><span class="v">N = integer()</span></li><li><span class="v">HaltPatterns = Patterns</span></li><li><span class="v">MatchList = [Match]</span></li><li><span class="v">Match = RxMatch | {Tag, RxMatch} | {prompt, Prompt}</span></li><li><span class="v">RxMatch = [string()]</span></li><li><span class="v">HaltReason = done | Match</span></li><li><span class="v">Reason = timeout | {prompt, Prompt}</span></li></ul><a name="expect-3"></a><p>Gets data from Telnet and waits for the expected pattern.</p><p><strong>Pattern</strong> can be a POSIX regular expression. The function
returns when a pattern is successfully matched (at least one, in
the case of multiple patterns).</p><p><strong>RxMatch</strong> is a list of matched strings. It looks as
follows <strong>[FullMatch, SubMatch1, SubMatch2, ...]</strong>, where
<strong>FullMatch</strong> is the string matched by the whole regular
expression, and <strong>SubMatchN</strong> is the string that matched
subexpression number <strong>N</strong>. Subexpressions are denoted with
<strong>'(' ')'</strong> in the regular expression.</p><p>If a <strong>Tag</strong> is specified, the returned <strong>Match</strong> also
includes the matched <strong>Tag</strong>. Otherwise, only <strong>RxMatch</strong>
is returned.</p><p><em>Options:</em></p><dl><dt><strong>idle_timeout</strong></dt><dd><p>Indicates that the function must return if the Telnet
client is idle (that is, if no data is received) for more than
<strong>IdleTimeout</strong> milliseconds. Default time-out is 10
seconds.</p></dd><dt><strong>total_timeout</strong></dt><dd><p>Sets a time limit for the complete <strong>expect</strong> operation.
After <strong>TotalTimeout</strong> milliseconds, <strong>{error,timeout}</strong>
is returned. Default is <strong>infinity</strong> (that is, no time
limit).</p></dd><dt><strong>ignore_prompt | no_prompt_check</strong></dt><dd><p>&gt;The function returns when a prompt is received, even if
no pattern has yet been matched, and 
<strong>{error,{prompt,Prompt}}</strong> is returned. However, this
behavior can be modified with option <strong>ignore_prompt</strong> or
option <strong>no_prompt_check</strong>, which tells <strong>expect</strong> to
return only when a match is found or after a time-out.</p></dd><dt><strong>ignore_prompt</strong></dt><dd><p><strong>ct_telnet</strong> ignores any prompt found. This option is
useful if data sent by the server can include a pattern
matching prompt <strong>regexp</strong> (as returned by
<strong>TargedMod:get_prompt_regexp/0</strong>), but is not to not cause
the function to return.</p></dd><dt><strong>no_prompt_check</strong></dt><dd><p><strong>ct_telnet</strong> does not search for a prompt at all. This
is useful if, for example, <strong>Pattern</strong> itself matches the
prompt.</p></dd><dt><strong>wait_for_prompt</strong></dt><dd><p>Forces <strong>ct_telnet</strong> to wait until the prompt string
is received before returning (even if a pattern has already been
matched). This is equal to calling
<strong>expect(Conn, Patterns++[{prompt,Prompt}], [sequence|Opts])</strong>.
Notice that option <strong>idle_timeout</strong> and <strong>total_timeout</strong>
can abort the operation of waiting for prompt.</p></dd><dt><strong>repeat | repeat, N</strong></dt><dd><p>The pattern(s) must be matched multiple times. If <strong>N</strong>
is specified, the pattern(s) are matched <strong>N</strong> times, and
the function returns <strong>HaltReason = done</strong>. This option can be
interrupted by one or more <strong>HaltPatterns</strong>. <strong>MatchList</strong>
is always returned, that is, a list of <strong>Match</strong> instead of
only one <strong>Match</strong>. Also <strong>HaltReason</strong> is returned.</p> </dd><dt><strong>sequence</strong></dt><dd><p>All patterns must be matched in a sequence. A match is not
concluded until all patterns are matched. This option can be
interrupted by one or more <strong>HaltPatterns</strong>. <strong>MatchList</strong>
is always returned, that is, a list of <strong>Match</strong> instead of
only one <strong>Match</strong>. Also <strong>HaltReason</strong> is returned.</p>  </dd></dl><p><em>Example 1:</em></p><pre>
 expect(Connection,[{abc,"ABC"},{xyz,"XYZ"}],[sequence,{halt,[{nnn,"NNN"}]}])</pre><p>First this tries to match <strong>"ABC"</strong>, and then <strong>"XYZ"</strong>, but
if <strong>"NNN"</strong> appears,  the function returns
<strong>{error,{nnn,["NNN"]}}</strong>. If both <strong>"ABC"</strong> and <strong>"XYZ"</strong>
are matched, the function returns <strong>{ok,[AbcMatch,XyzMatch]}</strong>.</p><p><em>Example 2:</em></p><pre>
 expect(Connection,[{abc,"ABC"},{xyz,"XYZ"}],[{repeat,2},{halt,[{nnn,"NNN"}]}])</pre><p>This tries to match <strong>"ABC"</strong> or <strong>"XYZ"</strong> twice. If
<strong>"NNN"</strong> appears, the function returns
<strong>HaltReason = {nnn,["NNN"]}</strong>.</p><p>Options <strong>repeat</strong> and <strong>sequence</strong> can be combined to
match a sequence multiple times.</p><h3>get_data(Connection) -&gt; {ok, Data} | {error, Reason}</h3><p>Gets all data received by the Telnet client since the last command was sent.</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">Data = [string()]</span></li><li><span class="v">Reason = term()</span></li></ul><a name="get_data-1"></a><p>Gets all data received by the Telnet client since the last
command was sent. Only newline-terminated strings are returned.
If the last received string has not yet been terminated, the
connection can be polled automatically until the string is
complete.</p><p>The polling feature is controlled by the configuration values
<strong>poll_limit</strong> and <strong>poll_interval</strong> and is by default
disabled. This means that the function immediately returns all
complete strings received and saves a remaining non-terminated
string for a later <strong>get_data</strong> call.</p><h3>open(Name) -&gt; {ok, Handle} | {error, Reason}</h3><p>Equivalent to open(Name, telnet).</p><a name="open-1"></a><p>Equivalent to
<a href="#open-2">open-2</a>.</p><h3>open(Name, ConnType) -&gt; {ok, Handle} | {error, Reason}</h3><p>Opens a Telnet connection to the specified target host.</p><ul><li><span class="v">Name = target_name()</span></li><li><span class="v">ConnType = connection_type()</span></li><li><span class="v">Handle = handle()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="open-2"></a><p>Opens a Telnet connection to the specified target host.</p><h3>open(KeyOrName, ConnType, TargetMod) -&gt; {ok, Handle} | {error, Reason}</h3><p>Equivalent to open(KeyOrName, ConnType, TargetMod, []).</p><a name="open-3"></a><p>Equivalent to
<a href="#open-4">open-4</a>.</p><h3>open(KeyOrName, ConnType, TargetMod, Extra) -&gt; {ok, Handle} | {error, Reason}</h3><p>Opens a Telnet connection to the specified target host.</p><ul><li><span class="v">KeyOrName = Key | Name</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Name = target_name()</span></li><li><span class="v">ConnType = connection_type()</span></li><li><span class="v">TargetMod = atom()</span></li><li><span class="v">Extra = term()</span></li><li><span class="v">Handle = handle()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="open-4"></a><p>Opens a Telnet connection to the specified target host.</p><p>The target data must exist in a configuration file. The connection
can be associated with <strong>Name</strong> and/or the returned <strong>Handle</strong>.
To allocate a name for the target, use one of the following
alternatives:</p><ul><li><p><a href="./ct#require-2">ct#require-2</a>
in a test case</p></li><li><p>A <strong>require</strong> statement in the suite information
function (<strong>suite/0</strong>)</p></li><li><p>A <strong>require</strong> statement in a test case information
function</p></li></ul><p>If you want the connection to be associated with <strong>Handle</strong> only
(if you, for example, need to open multiple connections to a host),
use <strong>Key</strong>, the configuration variable name, to specify the
target. Notice that a connection without an associated target name
can only be closed with the <strong>Handle</strong> value.</p><p><strong>TargetMod</strong> is a module that exports the functions
<strong>connect(Ip, Port, KeepAlive, Extra)</strong> and
<strong>get_prompt_regexp()</strong> for the specified <strong>TargetType</strong>
(for example, <strong>unix_telnet</strong>).</p><p>For <strong>target_name()</strong>, see module
<a href="ct">ct</a>.</p><p>See also
<a href="./ct#require-2">ct#require-2</a>.</p><h3>send(Connection, Cmd) -&gt; ok | {error, Reason}</h3><p>Equivalent to send(Connection, Cmd, []).</p><a name="send-2"></a><p>Equivalent to
<a href="#send-3">send-3</a>.</p><h3>send(Connection, Cmd, Opts) -&gt; ok | {error, Reason}</h3><p>Sends a Telnet command and returns immediately.</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">Cmd = string()</span></li><li><span class="v">Opts = [Opt]</span></li><li><span class="v">Opt = {newline, boolean() | string()}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="send-3"></a><p>Sends a Telnet command and returns immediately.</p><p>By default, this function adds "\n" to the end of the
specified command. If this is not desired, option
<strong>{newline,false}</strong> can be used. This is necessary, for example,
when sending Telnet command sequences prefixed with character   
Interpret As Command (IAC). Option <strong>{newline,string()}</strong>
can also be used if a different line end than "\n" is
required, for instance <strong>{newline,"\r\n"}</strong>, to add both
carriage return and newline characters.</p><p>The resulting output from the command can be read with
<a href="#get_data-1">get_data-1</a> or
<a href="#expect-2">expect-2</a>.</p><h3>sendf(Connection, CmdFormat, Args) -&gt; ok | {error, Reason}</h3><p>Equivalent to sendf(Connection, CmdFormat, Args, []).</p><a name="sendf-3"></a><p>Equivalent to
<a href="#sendf-4">sendf-4</a>.</p><h3>sendf(Connection, CmdFormat, Args, Opts) -&gt; ok | {error, Reason}</h3><p>Sends a Telnet command and returns immediately (uses a format string and a list of arguments to build the command).</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">CmdFormat = string()</span></li><li><span class="v">Args = list()</span></li><li><span class="v">Opts = [Opt]</span></li><li><span class="v">Opt = {newline, boolean() | string()}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="sendf-4"></a><p>Sends a Telnet command and returns immediately (uses a format
string and a list of arguments to build the command).</p><p>For details, see
<a href="#send-3">send-3</a>.</p><h3>See Also</h3><p><a href="unix_telnet">unix_telnet</a></p><h2>unix_telnet</h2><p>Callback module for ct_telnet, for connecting to a Telnet
    server on a UNIX host.</p><p>Callback module for
<a href="ct_telnet">ct_telnet</a>,
for connecting to a Telnet server on a UNIX host.It requires the following entry in the configuration file:<pre>
 {unix,[{telnet,HostNameOrIpAddress},
        {port,PortNum},                 % optional
        {username,UserName},
        {password,Password},
        {keep_alive,Bool}]}.            % optional</pre>To communicate through Telnet to the host specified by
<strong>HostNameOrIpAddress</strong>, use the interface functions in
<a href="ct_telnet">ct_telnet</a>, for example,
<strong>open(Name)</strong> and <strong>cmd(Name,Cmd)</strong>.<strong>Name</strong> is the name you allocated to the Unix host in your
<strong>require</strong> statement, for example:<pre>
 suite() -&gt; [{require,Name,{unix,[telnet]}}].</pre>or<pre>
 ct:require(Name,{unix,[telnet]}).</pre>The "keep alive" activity (that is, that <strong>Common Test</strong> sends NOP
to the server every 10 seconds if the connection is idle) can be
enabled or disabled for one particular connection as described here.
It can be disabled for all connections using <strong>telnet_settings</strong>
(see <a href="ct_telnet">ct_telnet</a>).The <strong>{port,PortNum}</strong> tuple is optional and if omitted, default 
Telnet port 23 is used. Also the <strong>keep_alive</strong> tuple is optional,
and the value defauls to <strong>true</strong> (enabled).</p><h2>Functions</h2><h3>connect(ConnName, Ip, Port, Timeout, KeepAlive, TCPNoDelay, Extra) -&gt; {ok, Handle} | {error, Reason}</h3><p>Callback for ct_telnet.erl.</p><ul><li><span class="v">ConnName = target_name()</span></li><li><span class="v">Ip = string() | {integer(), integer(), integer(), integer()}</span></li><li><span class="v">Port = integer()</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">KeepAlive = bool()</span></li><li><span class="v">TCPNoDelay = bool()</span></li><li><span class="v">Extra = target_name() | {Username, Password}</span></li><li><span class="v">Username = string()</span></li><li><span class="v">Password = string()</span></li><li><span class="v">Handle = handle()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="connect-6"></a><p>Callback for <strong>ct_telnet.erl</strong>.</p><p>Setup Telnet connection to a Unix host.</p><p>For <strong>target_name()</strong>, see
<a href="ct">ct</a>. For <strong>handle()</strong>, see
<a href="ct_telnet">ct_telnet</a>.</p><h3>get_prompt_regexp() -&gt; PromptRegexp</h3><p>Callback for ct_telnet.erl.</p><ul><li><span class="v">PromptRegexp = prompt_regexp()</span></li></ul><a name="get_prompt_regexp-0"></a><p>Callback for <strong>ct_telnet.erl</strong>.</p><p>Returns a suitable <strong>regexp</strong> string matching common prompts
for users on Unix hosts.</p><p>For <strong>prompt_regexp()</strong>, see
<a href="ct_telnet">ct_telnet</a>.</p><h3>See Also</h3><p><a href="ct">ct</a>,
<a href="ct_telnet">ct_telnet</a></p><h2>ct_slave</h2><p>Common Test framework functions for starting and stopping
    nodes for Large-Scale Testing.</p><p><strong>Common Test</strong> framework functions for starting and stopping nodes
for Large-Scale Testing.This module exports functions used by the <strong>Common Test</strong>
Master to start and stop "slave" nodes. It is the default callback
module for the <strong>{init, node_start}</strong> term in the Test
Specification.</p><h2>Functions</h2><h3>start(Node) -&gt; Result</h3><p>Starts an Erlang node with name Node on the local host.</p><ul><li><span class="v">Node = atom()</span></li><li><span class="v">Result = {ok, NodeName} | {error, Reason, NodeName}</span></li><li><span class="v">Reason = already_started | started_not_connected | boot_timeout | init_timeout | startup_timeout | not_alive</span></li><li><span class="v">NodeName = atom()</span></li></ul><a name="start-1"></a><p>Starts an Erlang node with name <strong>Node</strong> on the local host.</p><p>See also
<a href="#start-3">start-3</a>.</p><h3>start(HostOrNode, NodeOrOpts) -&gt; Result</h3><p>Starts an Erlang node with default options on a specified host, or on the local host with specified options.</p><ul><li><span class="v">HostOrNode = atom()</span></li><li><span class="v">NodeOrOpts = atom() | list()</span></li><li><span class="v">Result = {ok, NodeName} | {error, Reason, NodeName}</span></li><li><span class="v">Reason = already_started | started_not_connected | boot_timeout | init_timeout | startup_timeout | not_alive</span></li><li><span class="v">NodeName = atom()</span></li></ul><a name="start-2"></a><p>Starts an Erlang node with default options on a specified host, or
on the local host with specified options. That is, the call is
interpreted as <strong>start(Host, Node)</strong> when the second argument is
atom-valued and <strong>start(Node, Opts)</strong> when it is list-valued.</p><p>See also
<a href="#start-3">start-3</a>.</p><h3>start(Host, Node, Opts) -&gt; Result</h3><p>Starts an Erlang node with name Node on host Host as specified by the combination of options in Opts.</p><ul><li><span class="v">Node = atom()</span></li><li><span class="v">Host = atom()</span></li><li><span class="v">Opts = [OptTuples]</span></li><li><span class="v">OptTuples = {username, Username} | {password, Password} | {boot_timeout, BootTimeout} | {init_timeout, InitTimeout} | {startup_timeout, StartupTimeout} | {startup_functions, StartupFunctions} | {monitor_master, Monitor} | {kill_if_fail, KillIfFail} | {erl_flags, ErlangFlags} | {env, [{EnvVar, Value}]}</span></li><li><span class="v">Username = string()</span></li><li><span class="v">Password = string()</span></li><li><span class="v">BootTimeout = integer()</span></li><li><span class="v">InitTimeout = integer()</span></li><li><span class="v">StartupTimeout = integer()</span></li><li><span class="v">StartupFunctions = [StartupFunctionSpec]</span></li><li><span class="v">StartupFunctionSpec = {Module, Function, Arguments}</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Function = atom()</span></li><li><span class="v">Arguments = [term]</span></li><li><span class="v">Monitor = bool()</span></li><li><span class="v">KillIfFail = bool()</span></li><li><span class="v">ErlangFlags = string()</span></li><li><span class="v">EnvVar = string()</span></li><li><span class="v">Value = string()</span></li><li><span class="v">Result = {ok, NodeName} | {error, Reason, NodeName}</span></li><li><span class="v">Reason = already_started | started_not_connected | boot_timeout | init_timeout | startup_timeout | not_alive</span></li><li><span class="v">NodeName = atom()</span></li></ul><a name="start-3"></a><p>Starts an Erlang node with name <strong>Node</strong> on host <strong>Host</strong> as
specified by the combination of options in <strong>Opts</strong>.</p><p>Options <strong>Username</strong> and <strong>Password</strong> are used to log on to the
remote host <strong>Host</strong>. <strong>Username</strong>, if omitted, defaults to
the current username. <strong>Password</strong> is empty by default.</p><p>A list of functions specified in option <strong>Startup</strong> are
executed after startup of the node. Notice that all used modules
are to be present in the code path on <strong>Host</strong>.</p><p>The time-outs are applied as follows:</p><dl><dt><strong>BootTimeout</strong></dt><dd><p>The time to start the Erlang node, in seconds. Defaults to
3 seconds. If the node is not pingable within this time, the result
<strong>{error, boot_timeout, NodeName}</strong> is returned.</p></dd><dt><strong>InitTimeout</strong></dt><dd><p>The time to wait for the node until it calls the internal
callback function informing master about a successful startup.
Defaults to 1 second. In case of a timed out message, the result
<strong>{error, init_timeout, NodeName}</strong> is returned.</p></dd><dt><strong>StartupTimeout</strong></dt><dd><p>The time to wait until the node stops to run
<strong>StartupFunctions</strong>. Defaults to 1 second. If this time-out
occurs, the result <strong>{error, startup_timeout, NodeName}</strong> is
returned.</p></dd></dl><p><em>Options:</em></p><dl><dt><strong>monitor_master</strong></dt><dd><p>Specifies if the slave node is to be stopped if the
master node stops. Defaults to <strong>false</strong>.</p></dd><dt><strong>kill_if_fail</strong></dt><dd><p>Specifies if the slave node is to be killed if a time-out
occurs during initialization or startup. Defaults to <strong>true</strong>.
Notice that the node can also be still alive it the boot time-out
occurred, but it is not killed in this case.</p></dd><dt><strong>erlang_flags</strong></dt><dd><p>Specifies which flags are added to the parameters of the
executable <strong>erl</strong>.</p></dd><dt><strong>env</strong></dt><dd><p>Specifies a list of environment variables that will extend
the environment.</p></dd></dl><p><em>Special return values:</em></p><ul><li><p><strong>{error, already_started, NodeName}</strong> if the node
with the specified name is already started on a specified
host.</p></li><li><p><strong>{error, started_not_connected, NodeName}</strong> if the
node is started, but not connected to the master node.</p></li><li><p><strong>{error, not_alive, NodeName}</strong> if the node on which
<a href="#start-3">start-3</a> is
called, is not alive. Notice that <strong>NodeName</strong> is the name of
the current node in this case.</p></li></ul><h3>stop(Node) -&gt; Result</h3><p>Stops the running Erlang node with name Node on the local host.</p><ul><li><span class="v">Node = atom()</span></li><li><span class="v">Result = {ok, NodeName} | {error, Reason, NodeName}</span></li><li><span class="v">Reason = not_started | not_connected | stop_timeout</span></li></ul><a name="stop-1"></a><p>Stops the running Erlang node with name <strong>Node</strong> on the local
host.</p><h3>stop(Host, Node) -&gt; Result</h3><p>Stops the running Erlang node with name Node on host Host.</p><ul><li><span class="v">Host = atom()</span></li><li><span class="v">Node = atom()</span></li><li><span class="v">Result = {ok, NodeName} | {error, Reason, NodeName}</span></li><li><span class="v">Reason = not_started | not_connected | stop_timeout</span></li><li><span class="v">NodeName = atom()</span></li></ul><a name="stop-2"></a><p>Stops the running Erlang node with name <strong>Node</strong> on host
<strong>Host</strong>.</p><h2>ct_hooks</h2><p>A callback interface on top of Common Test.</p><p>The <em>Common Test Hook (CTH)</em> framework allows extensions of the
default behavior of <strong>Common Test</strong> by callbacks before and after all
test suite calls. It is intended for advanced users of <strong>Common Test</strong>
who want to abstract out behavior that is common to multiple test suites.
In brief, CTH allows you to:<ul><li><p>Manipulate the runtime configuration before each suite
configuration call.</p></li><li><p>Manipulate the return of all suite configuration calls and by
extension the result of the test themselves.</p></li></ul>The following sections describe the mandatory and optional CTH
functions that <strong>Common Test</strong> calls during test execution.
For more details, see section
<a href="ct_hooks_chapter">Common Test Hooks</a> in the
User's Guide.For information about how to add a CTH to your suite, see section
<a href="./ct_hooks_chapter#installing">Installing a CTH</a>
in the User's Guide.</p><h3>Callback Functions</h3><p>The following functions define the callback interface for a CTH.</p><h2>Functions</h2><h3>Module:init(Id, Opts) -&gt; {ok, State} | {ok, State, Priority}</h3><p>Initiates the Common Test Hook.</p><ul><li><span class="v">Id = reference() | term()</span></li><li><span class="v">Opts = term()</span></li><li><span class="v">State = term()</span></li><li><span class="v">Priority = integer()</span></li></ul><p>MANDATORY</p><p>This function is always called before any other callback function.
Use it to initiate any common state. It is to return a state for
this CTH.</p><p><strong>Id</strong> is either the return value of
<a href="#Module:id-1">Module:id-1</a>,
or a <strong>reference</strong> (created using
<a href="../erts/erlang#make_ref-0">erlang:make_ref/0</a>
in ERTS) if
<a href="#Module:id-1">Module:id-1</a>
is not implemented.</p><p><strong>Priority</strong> is the relative priority of this hook. Hooks with a
lower priority are executed first. If no priority is specified, it 
is set to <strong>0</strong>.</p><p>For details about when <strong>init</strong> is called, see section
<a href="./ct_hooks_chapter#scope">CTH Scope</a>
in the User's Guide.</p><h3>Module:post_groups(SuiteName, GroupDefs) -&gt; NewGroupDefs</h3><p>Called after groups/0.</p><ul><li><span class="v">SuiteName = atom()</span></li><li><span class="v">GroupDefs = NewGroupDefs = [Group]</span></li><li><span class="v">Group = {GroupName,Properties,GroupsAndTestCases}</span></li><li><span class="v">GroupName = atom()</span></li><li><span class="v">Properties = [parallel | sequence | Shuffle | {GroupRepeatType,N}]</span></li><li><span class="v">GroupsAndTestCases = [Group | {group,GroupName} | TestCase | {testcase,TestCase,TCRepeatProps}]</span></li><li><span class="v">TestCase = atom()</span></li><li><span class="v">TCRepeatProps = [{repeat,N} | {repeat_until_ok,N} | {repeat_until_fail,N}]</span></li><li><span class="v">Shuffle = shuffle | {shuffle,Seed}</span></li><li><span class="v">Seed = {integer(),integer(),integer()}</span></li><li><span class="v">GroupRepeatType = repeat | repeat_until_all_ok | repeat_until_all_fail | repeat_until_any_ok | repeat_until_any_fail</span></li><li><span class="v">N = integer() | forever</span></li></ul><p>OPTIONAL</p><p>This function is called after
<a href="./common_test#Module:groups-0">common_test#Module:groups-0</a>.
It is used to modify the test group definitions, for
instance to add or remove groups or change group properties.</p><p><strong>GroupDefs</strong> is what
<a href="./common_test#Module:groups-0">common_test#Module:groups-0</a>
returned, that is, a list of group definitions.</p><p><strong>NewGroupDefs</strong> is the possibly modified version of this list.</p><p>This function is called only if the CTH is added before
<strong>init_per_suite</strong> is run. For details, see section
<a href="./ct_hooks_chapter#scope">CTH Scope</a>
in the User's Guide.</p><p>Notice that for CTHs that are installed by means of the
<a href="./common_test#Module:suite-0">common_test#Module:suite-0</a>
function, <strong>post_groups/2</strong> is called before
the <a href="#Module:init-2">Module:init-2</a>
hook function. However, for CTHs that are installed by means
of the CT start flag,
the <a href="#Module:init-2">Module:init-2</a>
function is called first.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Prior to each test execution, Common Test does a
simulated test run in order to count test suites, groups
and cases for logging purposes. This causes
the <strong>post_groups/2</strong> hook function to always be called
twice. For this reason, side effects are best avoided in
this callback.</p></div><h3>Module:post_all(SuiteName, Return, GroupDefs) -&gt; NewReturn</h3><p>Called after all/0.</p><ul><li><span class="v">SuiteName = atom()</span></li><li><span class="v">Return = NewReturn = Tests | {skip,Reason}</span></li><li><span class="v">Tests = [TestCase | {testcase,TestCase,TCRepeatProps} | {group,GroupName} | {group,GroupName,Properties} | {group,GroupName,Properties,SubGroups}]</span></li><li><span class="v">TestCase = atom()</span></li><li><span class="v">TCRepeatProps = [{repeat,N} | {repeat_until_ok,N} | {repeat_until_fail,N}]</span></li><li><span class="v">GroupName = atom()</span></li><li><span class="v">Properties = GroupProperties | default</span></li><li><span class="v">SubGroups = [{GroupName,Properties} | {GroupName,Properties,SubGroups}]</span></li><li><span class="v">Shuffle = shuffle | {shuffle,Seed}</span></li><li><span class="v">Seed = {integer(),integer(),integer()}</span></li><li><span class="v">GroupRepeatType = repeat | repeat_until_all_ok | repeat_until_all_fail | repeat_until_any_ok | repeat_until_any_fail</span></li><li><span class="v">N = integer() | forever</span></li><li><span class="v">GroupDefs = NewGroupDefs = [Group]</span></li><li><span class="v">Group = {GroupName,GroupProperties,GroupsAndTestCases}</span></li><li><span class="v">GroupProperties = [parallel | sequence | Shuffle | {GroupRepeatType,N}]</span></li><li><span class="v">GroupsAndTestCases = [Group | {group,GroupName} | TestCase]</span></li><li><span class="v">Reason = term()</span></li></ul><p>OPTIONAL</p><p>This function is called after
<a href="./common_test#Module:all-0">common_test#Module:all-0</a>.
It is used to modify the set of test cases and test group to
be executed, for instance to add or remove test cases and
groups, change group properties, or even skip all tests in
the suite.</p><p><strong>Return</strong> is what
<a href="./common_test#Module:all-0">common_test#Module:all-0</a>
returned, that is, a list of test cases and groups to be
executed, or a tuple <strong>{skip,Reason}</strong>.</p><p><strong>GroupDefs</strong> is what
<a href="./common_test#Module:groups-0">common_test#Module:groups-0</a>
or the <strong>post_groups/2</strong> hook returned, that is, a list
of group definitions.</p><p><strong>NewReturn</strong> is the possibly modified version of <strong>Return</strong>.</p><p>This function is called only if the CTH is added before
<strong>init_per_suite</strong> is run. For details, see section
<a href="./ct_hooks_chapter#scope">CTH Scope</a>
in the User's Guide.</p><p>Notice that for CTHs that are installed by means of the
<a href="./common_test#Module:suite-0">common_test#Module:suite-0</a>
function, <strong>post_all/2</strong> is called before
the <a href="#Module:init-2">Module:init-2</a>
hook function. However, for CTHs that are installed by means
of the CT start flag,
the <a href="#Module:init-2">Module:init-2</a>
function is called first.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Prior to each test execution, Common Test does a
simulated test run in order to count test suites, groups
and cases for logging purposes. This causes
the <strong>post_all/3</strong> hook function to always be called
twice. For this reason, side effects are best avoided in
this callback.</p></div><h3>Module:pre_init_per_suite(SuiteName, InitData, CTHState) -&gt; Result</h3><p>Called before init_per_suite.</p><ul><li><span class="v">SuiteName = atom()</span></li><li><span class="v">InitData = Config | SkipOrFail</span></li><li><span class="v">Config = NewConfig = [{Key,Value}]</span></li><li><span class="v">CTHState = NewCTHState = term()</span></li><li><span class="v">Result = {Return, NewCTHState}</span></li><li><span class="v">Return = NewConfig | SkipOrFail</span></li><li><span class="v">SkipOrFail = {fail, Reason} | {skip, Reason}</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>OPTIONAL</p><p>This function is called before
<a href="./common_test#Module:init_per_suite-1">common_test#Module:init_per_suite-1</a>
if it exists. It typically contains initialization/logging that must
be done before <strong>init_per_suite</strong> is called. If
<strong>{skip,Reason}</strong> or <strong>{fail,Reason}</strong> is returned,
<strong>init_per_suite</strong> and all test cases of the suite are skipped
and <strong>Reason</strong> printed in the overview log of the suite.</p><p><strong>SuiteName</strong> is the name of the suite to be run.</p><p><strong>InitData</strong> is the original configuration list of the test
suite, or a <strong>SkipOrFail</strong> tuple if a previous CTH has returned
this.</p><p><strong>CTHState</strong> is the current internal state of the CTH.</p><p><strong>Return</strong> is the result of the <strong>init_per_suite</strong> function.
If it is <strong>{skip,Reason}</strong> or <strong>{fail,Reason}</strong>, 
<a href="./common_test#Module:init_per_suite-1">common_test#Module:init_per_suite-1</a>
is never called, instead the initiation is considered to be
skipped or failed, respectively. If a <strong>NewConfig</strong> list is
returned,
<a href="./common_test#Module:init_per_suite-1">common_test#Module:init_per_suite-1</a>
is called with that <strong>NewConfig</strong> list. For more details, see
section <a href="./ct_hooks_chapter#pre">Pre Hooks</a>
in the User's Guide.</p><p>This function is called only if the CTH is added before
<strong>init_per_suite is run</strong>. For details, see section
<a href="./ct_hooks_chapter#scope">CTH Scope</a>
in the User's Guide.</p><h3>Module:post_init_per_suite(SuiteName, Config, Return, CTHState) -&gt; Result</h3><p>Called after init_per_suite.</p><ul><li><span class="v">SuiteName = atom()</span></li><li><span class="v">Config = [{Key,Value}]</span></li><li><span class="v">Return = NewReturn = Config | SkipOrFail | term()</span></li><li><span class="v">SkipOrFail = {fail, Reason} | {skip, Reason} | term()</span></li><li><span class="v">CTHState = NewCTHState = term()</span></li><li><span class="v">Result = {NewReturn, NewCTHState}</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>OPTIONAL</p><p>This function is called after
<a href="./common_test#Module:init_per_suite-1">common_test#Module:init_per_suite-1</a>
if it exists. It typically contains extra checks to ensure that all
the correct dependencies are started correctly.</p><p><strong>Return</strong> is what
<a href="./common_test#Module:init_per_suite-1">common_test#Module:init_per_suite-1</a>
returned, that is, <strong>{fail,Reason}</strong>, <strong>{skip,Reason}</strong>, a
<strong>Config</strong> list, or a term describing how
<a href="./common_test#Module:init_per_suite-1">common_test#Module:init_per_suite-1</a>
failed.</p><p><strong>NewReturn</strong> is the possibly modified return value of
<a href="./common_test#Module:init_per_suite-1">common_test#Module:init_per_suite-1</a>.
To recover from a failure in
<a href="./common_test#Module:init_per_suite-1">common_test#Module:init_per_suite-1</a>,
return <strong>ConfigList</strong> with the <strong>tc_status</strong> element removed.
For more details, see
<a href="./ct_hooks_chapter#post"> Post Hooks</a> in
section "Manipulating Tests" in the User's Guide.</p><p><strong>CTHState</strong> is the current internal state of the CTH.</p><p>This function is called only if the CTH is added before or in
<strong>init_per_suite</strong>. For details, see section
<a href="./ct_hooks_chapter#scope">CTH Scope</a>
in the User's Guide.</p><h3>Module:pre_init_per_group(SuiteName, GroupName, InitData, CTHState) -&gt; Result</h3><p>Called before init_per_group.</p><ul><li><span class="v">SuiteName = atom()</span></li><li><span class="v">GroupName = atom()</span></li><li><span class="v">InitData = Config | SkipOrFail</span></li><li><span class="v">Config = NewConfig = [{Key,Value}]</span></li><li><span class="v">CTHState = NewCTHState = term()</span></li><li><span class="v">Result = {NewConfig | SkipOrFail, NewCTHState}</span></li><li><span class="v">SkipOrFail = {fail,Reason} | {skip, Reason}</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>OPTIONAL</p><p>This function is called before
<a href="./common_test#Module:init_per_group-2">common_test#Module:init_per_group-2</a>
if it exists. It behaves the same way as
<a href="./ct_hooks#Module:pre_init_per_suite-3">ct_hooks#Module:pre_init_per_suite-3</a>,
but for function
<a href="./common_test#Module:init_per_group-2">common_test#Module:init_per_group-2</a>
instead.</p><p>If <strong>Module:pre_init_per_group/4</strong> is not exported, common_test
will attempt to call <strong>Module:pre_init_per_group(GroupName, InitData, CTHState)</strong> instead. This is for backwards
compatibility.</p><h3>Module:post_init_per_group(SuiteName, GroupName, Config, Return, CTHState) -&gt; Result</h3><p>Called after init_per_group.</p><ul><li><span class="v">SuiteName = atom()</span></li><li><span class="v">GroupName = atom()</span></li><li><span class="v">Config = [{Key,Value}]</span></li><li><span class="v">Return = NewReturn = Config | SkipOrFail | term()</span></li><li><span class="v">SkipOrFail = {fail,Reason} | {skip, Reason}</span></li><li><span class="v">CTHState = NewCTHState = term()</span></li><li><span class="v">Result = {NewReturn, NewCTHState}</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>OPTIONAL</p><p>This function is called after
<a href="./common_test#Module:init_per_group-2">common_test#Module:init_per_group-2</a>
if it exists. It behaves the same way as
<a href="./ct_hooks#Module:post_init_per_suite-4">ct_hooks#Module:post_init_per_suite-4</a>,
but for function
<a href="./common_test#Module:init_per_group-2">common_test#Module:init_per_group-2</a>
instead.</p><p>If <strong>Module:post_init_per_group/5</strong> is not exported, common_test
will attempt to call <strong>Module:post_init_per_group(GroupName, Config, Return, CTHState)</strong> instead. This is for backwards
compatibility.</p><h3>Module:pre_init_per_testcase(SuiteName, TestcaseName, InitData, CTHState) -&gt; Result</h3><p>Called before init_per_testcase.</p><ul><li><span class="v">SuiteName = atom()</span></li><li><span class="v">TestcaseName = atom()</span></li><li><span class="v">InitData = Config | SkipOrFail</span></li><li><span class="v">Config = NewConfig = [{Key,Value}]</span></li><li><span class="v">CTHState = NewCTHState = term()</span></li><li><span class="v">Result = {NewConfig | SkipOrFail, NewCTHState}</span></li><li><span class="v">SkipOrFail = {fail,Reason} | {skip, Reason}</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>OPTIONAL</p><p>This function is called before
<a href="./common_test#Module:init_per_testcase-2">common_test#Module:init_per_testcase-2</a>
if it exists. It behaves the same way as
<a href="./ct_hooks#Module:pre_init_per_suite-3">ct_hooks#Module:pre_init_per_suite-3</a>,
but for function
<a href="./common_test#Module:init_per_testcase-2">common_test#Module:init_per_testcase-2</a>
instead.</p><p>If <strong>Module:pre_init_per_testcase/4</strong> is not exported, common_test
will attempt to call <strong>Module:pre_init_per_testcase(TestcaseName, InitData, CTHState)</strong> instead. This is for backwards
compatibility.</p><p>CTHs cannot be added here right now. That feature may be added in
a later release, but it would right now break backwards
compatibility.</p><h3>Module:post_init_per_testcase(SuiteName, TestcaseName, Config, Return, CTHState) -&gt; Result</h3><p>Called after init_per_testcase.</p><ul><li><span class="v">SuiteName = atom()</span></li><li><span class="v">TestcaseName = atom()</span></li><li><span class="v">Config = [{Key,Value}]</span></li><li><span class="v">Return = NewReturn = Config | SkipOrFail | term()</span></li><li><span class="v">SkipOrFail = {fail,Reason} | {skip, Reason}</span></li><li><span class="v">CTHState = NewCTHState = term()</span></li><li><span class="v">Result = {NewReturn, NewCTHState}</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>OPTIONAL</p><p>This function is called after
<a href="./common_test#Module:init_per_testcase-2">common_test#Module:init_per_testcase-2</a>
if it exists. It behaves the same way as
<a href="./ct_hooks#Module:post_init_per_suite-4">ct_hooks#Module:post_init_per_suite-4</a>,
but for function
<a href="./common_test#Module:init_per_testcase-2">common_test#Module:init_per_testcase-2</a>
instead.</p><p>If <strong>Module:post_init_per_testcase/5</strong> is not exported, common_test
will attempt to call <strong>Module:post_init_per_testcase(TestcaseName, Config, Return, CTHState)</strong> instead. This is for backwards
compatibility.</p><h3>Module:pre_end_per_testcase(SuiteName, TestcaseName, EndData, CTHState) -&gt; Result</h3><p>Called before end_per_testcase.</p><ul><li><span class="v">SuiteName = atom()</span></li><li><span class="v">TestcaseName = atom()</span></li><li><span class="v">EndData = Config</span></li><li><span class="v">Config = NewConfig = [{Key,Value}]</span></li><li><span class="v">CTHState = NewCTHState = term()</span></li><li><span class="v">Result = {NewConfig, NewCTHState}</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>OPTIONAL</p><p>This function is called before
<a href="./common_test#Module:end_per_testcase-2">common_test#Module:end_per_testcase-2</a>
if it exists. It behaves the same way as
<a href="./ct_hooks#Module:pre_end_per_suite-3">ct_hooks#Module:pre_end_per_suite-3</a>,
but for function
<a href="./common_test#Module:end_per_testcase-2">common_test#Module:end_per_testcase-2</a>
instead.</p><p>This function cannot change the result of the test case by returning skip or fail
tuples, but it may insert items in <strong>Config</strong> that can be read in
<strong>end_per_testcase/2</strong> or in <strong>post_end_per_testcase/5</strong>.</p><p>If <strong>Module:pre_end_per_testcase/4</strong> is not exported, common_test
will attempt to call <strong>Module:pre_end_per_testcase(TestcaseName, EndData, CTHState)</strong> instead. This is for backwards
compatibility.</p><h3>Module:post_end_per_testcase(SuiteName, TestcaseName, Config, Return, CTHState) -&gt; Result</h3><p>Called after end_per_testcase.</p><ul><li><span class="v">SuiteName = atom()</span></li><li><span class="v">TestcaseName = atom()</span></li><li><span class="v">Config = [{Key,Value}]</span></li><li><span class="v">Return = NewReturn = Config | SkipOrFail | term()</span></li><li><span class="v">SkipOrFail = {fail,Reason} | {skip, Reason}</span></li><li><span class="v">CTHState = NewCTHState = term()</span></li><li><span class="v">Result = {NewReturn, NewCTHState}</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>OPTIONAL</p><p>This function is called after
<a href="./common_test#Module:end_per_testcase-2">common_test#Module:end_per_testcase-2</a>
if it exists. It behaves the same way as
<a href="./ct_hooks#Module:post_end_per_suite-4">ct_hooks#Module:post_end_per_suite-4</a>,
but for function
<a href="./common_test#Module:end_per_testcase-2">common_test#Module:end_per_testcase-2</a>
instead.</p><p>If <strong>Module:post_end_per_testcase/5</strong> is not exported, common_test
will attempt to call <strong>Module:post_end_per_testcase(TestcaseName, Config, Return, CTHState)</strong> instead. This is for backwards
compatibility.</p><h3>Module:pre_end_per_group(SuiteName, GroupName, EndData, CTHState) -&gt; Result</h3><p>Called before end_per_group.</p><ul><li><span class="v">SuiteName = atom()</span></li><li><span class="v">GroupName = atom()</span></li><li><span class="v">EndData = Config | SkipOrFail</span></li><li><span class="v">Config = NewConfig = [{Key,Value}]</span></li><li><span class="v">CTHState = NewCTHState = term()</span></li><li><span class="v">Result = {NewConfig | SkipOrFail, NewCTHState}</span></li><li><span class="v">SkipOrFail = {fail,Reason} | {skip, Reason}</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>OPTIONAL</p><p>This function is called before
<a href="./common_test#Module:end_per_group-2">common_test#Module:end_per_group-2</a>
if it exists. It behaves the same way as
<a href="./ct_hooks#Module:pre_init_per_suite-3">ct_hooks#Module:pre_init_per_suite-3</a>,
but for function
<a href="./common_test#Module:end_per_group-2">common_test#Module:end_per_group-2</a>
instead.</p><p>If <strong>Module:pre_end_per_group/4</strong> is not exported, common_test
will attempt to call <strong>Module:pre_end_per_group(GroupName, EndData, CTHState)</strong> instead. This is for backwards
compatibility.</p><h3>Module:post_end_per_group(SuiteName, GroupName, Config, Return, CTHState) -&gt; Result</h3><p>Called after end_per_group.</p><ul><li><span class="v">SuiteName = atom()</span></li><li><span class="v">GroupName = atom()</span></li><li><span class="v">Config = [{Key,Value}]</span></li><li><span class="v">Return = NewReturn = Config | SkipOrFail | term()</span></li><li><span class="v">SkipOrFail = {fail,Reason} | {skip, Reason}</span></li><li><span class="v">CTHState = NewCTHState = term()</span></li><li><span class="v">Result = {NewReturn, NewCTHState}</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>OPTIONAL</p><p>This function is called after
<a href="./common_test#Module:end_per_group-2">common_test#Module:end_per_group-2</a>
if it exists. It behaves the same way as
<a href="./ct_hooks#Module:post_init_per_suite-4">ct_hooks#Module:post_init_per_suite-4</a>,
but for function
<a href="./common_test#Module:end_per_group-2">end_per_group</a>
instead.</p><p>If <strong>Module:post_end_per_group/5</strong> is not exported, common_test
will attempt to call <strong>Module:post_end_per_group(GroupName, Config, Return, CTHState)</strong> instead. This is for backwards
compatibility.</p><h3>Module:pre_end_per_suite(SuiteName, EndData, CTHState) -&gt; Result</h3><p>Called before end_per_suite.</p><ul><li><span class="v">SuiteName = atom()</span></li><li><span class="v">EndData = Config | SkipOrFail</span></li><li><span class="v">Config = NewConfig = [{Key,Value}]</span></li><li><span class="v">CTHState = NewCTHState = term()</span></li><li><span class="v">Result = {NewConfig | SkipOrFail, NewCTHState}</span></li><li><span class="v">SkipOrFail = {fail,Reason} | {skip, Reason}</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>OPTIONAL</p><p>This function is called before
<a href="./common_test#Module:end_per_suite-1">common_test#Module:end_per_suite-1</a>
if it exists. It behaves the same way as
<a href="./ct_hooks#Module:pre_init_per_suite-3">ct_hooks#Module:pre_init_per_suite-3</a>,
but for function
<a href="./common_test#Module:end_per_suite-1">common_test#Module:end_per_suite-1</a>
instead.</p><h3>Module:post_end_per_suite(SuiteName, Config, Return, CTHState) -&gt; Result</h3><p>Called after end_per_suite.</p><ul><li><span class="v">SuiteName = atom()</span></li><li><span class="v">Config = [{Key,Value}]</span></li><li><span class="v">Return = NewReturn = Config | SkipOrFail | term()</span></li><li><span class="v">SkipOrFail = {fail,Reason} | {skip, Reason}</span></li><li><span class="v">CTHState = NewCTHState = term()</span></li><li><span class="v">Result = {NewReturn, NewCTHState}</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>OPTIONAL</p><p>This function is called after
<a href="./common_test#Module:end_per_suite-1">common_test#Module:end_per_suite-1</a>
if it exists. It behaves the same way as
<a href="./ct_hooks#Module:post_init_per_suite-4">ct_hooks#Module:post_init_per_suite-4</a>,
but for function
<a href="./common_test#Module:end_per_suite-1">common_test#Module:end_per_suite-1</a>
instead.</p><h3>Module:on_tc_fail(SuiteName, TestName, Reason, CTHState) -&gt; NewCTHState</h3><p>Called after the CTH scope ends.</p><ul><li><span class="v">SuiteName = atom()</span></li><li><span class="v">TestName = init_per_suite | end_per_suite | {init_per_group,GroupName} | {end_per_group,GroupName} | {FuncName,GroupName} | FuncName</span></li><li><span class="v">FuncName = atom()</span></li><li><span class="v">GroupName = atom()</span></li><li><span class="v">Reason = term()</span></li><li><span class="v">CTHState = NewCTHState = term()</span></li></ul><p>OPTIONAL</p><p>This function is called whenever a test case (or configuration
function) fails. It is called after the post function is called
for the failed test case, that is:</p><ul><li><p>If <strong>init_per_suite</strong> fails, this function is called after
<a href="#Module:post_init_per_suite-4">Module:post_init_per_suite-4</a>.</p></li><li><p>If a test case fails, this funcion is called after
<a href="#Module:post_end_per_testcase-5">Module:post_end_per_testcase-5</a>.</p></li></ul><p>If the failed test case belongs to a test case group, the first
argument is a tuple <strong>{FuncName,GroupName}</strong>, otherwise only
the function name.</p><p>The data that comes with <strong>Reason</strong> follows the same format as
<a href="./event_handler_chapter#failreason">event_handler_chapter#failreason</a>
in event
<a href="./event_handler_chapter#tc_done">event_handler_chapter#tc_done</a>.
For details, see section
<a href="./event_handler_chapter#events">Event Handling</a>
in the User's Guide.</p><p>If <strong>Module:on_tc_fail/4</strong> is not exported, common_test
will attempt to call <strong>Module:on_tc_fail(TestName, Reason, CTHState)</strong> instead. This is for backwards
compatibility.</p><h3>Module:on_tc_skip(SuiteName, TestName, Reason, CTHState) -&gt; NewCTHState</h3><p>Called after the CTH scope ends.</p><ul><li><span class="v">SuiteName = atom()</span></li><li><span class="v">TestName = init_per_suite | end_per_suite | {init_per_group,GroupName} | {end_per_group,GroupName} | {FuncName,GroupName} | FuncName</span></li><li><span class="v">FuncName = atom()</span></li><li><span class="v">GroupName = atom()</span></li><li><span class="v">Reason = {tc_auto_skip | tc_user_skip, term()}</span></li><li><span class="v">CTHState = NewCTHState = term()</span></li></ul><p>OPTIONAL</p><p>This function is called whenever a test case (or configuration
function) is skipped. It is called after the post function is called
for the skipped test case, that is:</p><ul><li><p>If <strong>init_per_group</strong> is skipped, this function is
called after 
<a href="#Module:post_init_per_group-5">Module:post_init_per_group-5</a>.</p></li><li><p>If a test case is skipped, this function is called after
<a href="#Module:post_end_per_testcase-5">Module:post_end_per_testcase-5</a>.</p></li></ul><p>If the skipped test case belongs to a test case group, the first
argument is a tuple <strong>{FuncName,GroupName}</strong>, otherwise only
the function name.</p><p>The data that comes with <strong>Reason</strong> follows the same format as
events
<a href="./event_handler_chapter#tc_auto_skip">event_handler_chapter#tc_auto_skip</a>
and
<a href="./event_handler_chapter#tc_user_skip">event_handler_chapter#tc_user_skip</a>
For details, see section
<a href="./event_handler_chapter#events">Event Handling</a>
in the User's Guide.</p><p>If <strong>Module:on_tc_skip/4</strong> is not exported, common_test
will attempt to call <strong>Module:on_tc_skip(TestName, Reason, CTHState)</strong> instead. This is for backwards
compatibility.</p><h3>Module:terminate(CTHState)</h3><p>Called after the CTH scope ends.</p><ul><li><span class="v">CTHState = term()</span></li></ul><p>OPTIONAL</p><p>This function is called at the end of a CTH
<a href="./ct_hooks_chapter#scope">scope</a>.</p><h3>Module:id(Opts) -&gt; Id</h3><p>Called before the init function of a CTH.</p><ul><li><span class="v">Opts = term()</span></li><li><span class="v">Id = term()</span></li></ul><p>OPTIONAL</p><p>The <strong>Id</strong> identifies a CTH instance uniquely. If two CTHs return
the same <strong>Id</strong>, the second CTH is ignored and subsequent calls to
the CTH are only made to the first instance. For details, see section
<a href="./ct_hooks_chapter#installing">Installing a CTH</a>
in the User's Guide.</p><p>This function is <em>not</em> to have any side effects, as it can 
be called multiple times by <strong>Common Test</strong>.</p><p>If not implemented, the CTH acts as if this function returned a call
to <strong>make_ref/0</strong>.</p><h2>ct_property_test</h2><p>EXPERIMENTAL support in Common Test for calling
    property-based tests.</p><p>EXPERIMENTAL support in <strong>Common Test</strong> for calling property-based
tests.This module is a first step to run property-based tests in the
<strong>Common Test</strong> framework. A property testing tool like QuickCheck
or PropEr is assumed to be installed.The idea is to have a <strong>Common Test</strong> test suite calling a property
testing tool with special property test suites as defined by that tool.
The usual Erlang application directory structure is assumed. The tests
are collected in the <strong>test</strong> directory of the application. The
<strong>test</strong> directory has a subdirectory <strong>property_test</strong>, where
everything needed for the property tests is collected.A typical <strong>Common Test</strong> test suite using <strong>ct_property_test</strong>
is organized as follows:<pre>
 -include_lib("common_test/include/ct.hrl").

 all() -&gt; [prop_ftp_case].

 init_per_suite(Config) -&gt;
     ct_property_test:init_per_suite(Config).

 %%%---- test case
 prop_ftp_case(Config) -&gt;
     ct_property_test:quickcheck(
       ftp_simple_client_server:prop_ftp(Config),
       Config
      ).</pre></p><h2>Functions</h2><h3>init_per_suite(Config) -&gt; Config | {skip, Reason}</h3><p>Initializes Config for property testing.</p><a name="init_per_suite-1"></a><p>Initializes <strong>Config</strong> for property testing.</p><p>This function investigates if support is available for either
Quickcheck, PropEr, or Triq. The options
<strong>{property_dir,AbsPath}</strong> and <strong>{property_test_tool,Tool}</strong>
are set in the <strong>Config</strong> returned.</p><p>The function is intended to be called in function
<strong>init_per_suite</strong> in the test suite.</p><p>The property tests are assumed to be in subdirectory
<strong>property_test</strong>.</p><h3>quickcheck(Property, Config) -&gt; true | {fail, Reason}</h3><p>Calls quickcheck and returns the result in a form suitable for Common Test.</p><a name="quickcheck-2"></a><p>Calls quickcheck and returns the result in a form suitable for
<strong>Common Test</strong>.</p><p>This function is intended to be called in the test cases in the
test suite.</p><h2>ct_testspec</h2><p>Parsing of test specifications for Common Test.
</p><p>Parsing of test specifications for <strong>Common Test</strong>.This module exports help functions for parsing of test specifications.</p><h2>Functions</h2><h3>get_tests(SpecsIn) -&gt; {ok, [{Specs,Tests}]} | {error, Reason}</h3><p>Parse the given test specification files and return the tests to run and skip.</p><ul><li><span class="v">SpecsIn = [string()] | [[string()]]</span></li><li><span class="v">Specs = [string()]</span></li><li><span class="v">Test = [{Node,Run,Skip}]</span></li><li><span class="v">Node = atom()</span></li><li><span class="v">Run = {Dir,Suites,Cases}</span></li><li><span class="v">Skip = {Dir,Suites,Comment} | {Dir,Suites,Cases,Comment}</span></li><li><span class="v">Dir = string()</span></li><li><span class="v">Suites = atom | [atom()] | all</span></li><li><span class="v">Cases = atom | [atom()] | all</span></li><li><span class="v">Comment = string()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="add_nodes-1"></a><p>Parse the given test specification files and return the
tests to run and skip.</p><p>If <strong>SpecsIn=[Spec1,Spec2,...]</strong>, separate tests will be
created per specification. If
<strong>SpecsIn=[[Spec1,Spec2,...]]</strong>, all specifications will be
merge into one test.</p><p>For each test, a <strong>{Specs,Tests}</strong> element is returned,
where <strong>Specs</strong> is a list of all included test
specifications, and <strong>Tests</strong> specifies actual tests to
run/skip per node.</p></body></html>