<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Common Test Basics</h1><a name="basics"></a><h2>General</h2><p>The <strong>Common Test</strong> framework is a tool that supports
implementation and automated execution of test cases to any
types of target systems. <strong>Common Test</strong> is the main tool being used 
in all testing- and verification activities that are part of Erlang/OTP 
system development and maintenance.
</p><p>Test cases can be executed individually or in batches. <strong>Common Test</strong>
also features a distributed testing mode with central control and logging.
With this feature, multiple systems can be tested independently in
one common session. This is useful, for example, when running automated 
large-scale regression tests.
</p><p>
The System Under Test (SUT) can consist of one or more target
nodes. <strong>Common Test</strong> contains a generic test server that, 
together with other test utilities, is used to perform test case execution. 
The tests can be started from a GUI, from the OS shell, or from an
Erlang shell. <em>Test suites</em> are files (Erlang
modules) that contain the <em>test cases</em> (Erlang functions)
to be executed. <em>Support modules</em> provide functions
that the test cases use to do the tests.
</p><p>In a black-box testing scenario, <strong>Common Test</strong>-based test programs connect to
the target system(s) through standard O&amp;M and CLI protocols. <strong>Common Test</strong>
provides implementations of, and wrapper interfaces to, some of these
protocols (most of which exist as standalone components and
applications in OTP). The wrappers simplify configuration and add
verbosity for logging purposes. <strong>Common Test</strong> is continously extended with
useful support modules. However, notice that it is
a straightforward task to use any Erlang/OTP component
for testing purposes with <strong>Common Test</strong>, without needing a <strong>Common Test</strong> 
wrapper for it. It is as simple as calling Erlang functions. A number of 
target-independent interfaces are supported in <strong>Common Test</strong>, such as
Generic Telnet and FTP. These can be specialized or used
directly for controlling instruments, traffic load generators, and so on.
</p><p><strong>Common Test</strong> is also a very useful tool for white-box testing Erlang
code (for example, module testing), as the test programs can call exported Erlang
functions directly. There is very little overhead required for
implementing basic test suites and executing simple tests. For black-box
testing Erlang software, Erlang RPC and standard O&amp;M interfaces
can be used for example.
</p><p>A test case can handle several connections to one or
more target systems, instruments, and traffic generators in
parallel to perform the necessary actions for a test. 
The handling of many connections in parallel is one of
the major strengths of <strong>Common Test</strong>, thanks to the efficient
support for concurrency in the Erlang runtime system, which <strong>Common Test</strong> 
users can take great advantage of.
</p><h2>Test Suite Organisation</h2><p>
Test suites are organized in test directories and each test suite
can have a separate data directory. Typically, these files and directories
are version-controlled similar to other forms of source code (possibly by
a version control system like GIT or Subversion). However, <strong>Common Test</strong> 
does not itself put any requirements on (or has any awareness of) 
possible file and directory versions.
</p><h2>Support Libraries</h2><p>
Support libraries contain functions that are useful for all test suites,
or for test suites in a specific functional area or subsystem.
In addition to the general support libraries provided by the
<strong>Common Test</strong> framework, and the various libraries and applications provided by
Erlang/OTP, there can also be a need for customized (user specific) 
support libraries. 
</p><h2>Suites and Test Cases</h2><p>
Testing is performed by running test suites (sets of test cases) or 
individual test cases. A test suite is implemented as an Erlang module named 
<strong>&lt;suite_name&gt;_SUITE.erl</strong> which contains a number of test cases.
A test case is an Erlang function that tests one or more things. 
The test case is the smallest unit that the <strong>Common Test</strong> test server deals with.
</p><p>
Sets of test cases, called test case groups, can also be defined. A test case
group can have execution properties associated with it. Execution properties 
specify if the test cases in the group are to be executed in
random order, in parallel, or in sequence, and if the execution of the group 
is to be repeated. Test case groups can also be nested (that is, a group can,
besides test cases, contain subgroups).
</p><p>
Besides test cases and groups, the test suite can also contain configuration 
functions. These functions are meant to be used for setting up (and verifying)
environment and state in the SUT (and/or the <strong>Common Test</strong> host node), 
required for the tests to execute correctly. Examples of operations are: 
Opening a connection to the SUT, initializing a database, running an installation 
script, and so on. Configuration can be performed per suite, per test case group,
and per individual test case.
</p><p>
The test suite module must conform to a
<a href="common_test">callback interface</a>
specified by the <strong>Common Test</strong> test server. For details, see section
<a href="./write_test_chapter#intro">Writing Test Suites</a>.
</p><p>
A test case is considered successful if it returns to the caller, no matter 
what the returned value is. However, a few return values have special meaning
as follows:</p><ul><li><strong>{skip,Reason}</strong> indicates that the test case is skipped.</li><li><strong>{comment,Comment}</strong> prints a comment in the log for the test case.</li><li><strong>{save_config,Config}</strong> makes the <strong>Common Test</strong> test server pass  <strong>Config</strong> to the next test case.</li></ul><p>
A test case failure is specified as a runtime error (a crash), no matter what 
the reason for termination is. If you use Erlang pattern matching effectively,
you can take advantage of this property. The result is concise and 
readable test case functions that look much more like scripts than actual programs. 
A simple example:
</p><pre>
 session(_Config) -&gt;
     {started,ServerId} = my_server:start(),
     {clients,[]} = my_server:get_clients(ServerId),
     MyId = self(),
     connected = my_server:connect(ServerId, MyId),
     {clients,[MyId]} = my_server:get_clients(ServerId),
     disconnected = my_server:disconnect(ServerId, MyId),
     {clients,[]} = my_server:get_clients(ServerId),
     stopped = my_server:stop(ServerId).</pre><p>
As a test suite runs, all information (including output to <strong>stdout</strong>) is 
recorded in many different log files. A minimum of information is displayed 
in the user console (only start and stop information, plus a note 
for each failed test case).
</p><p>
The result from each test case is recorded in a dedicated HTML log file, created 
for the particular test run. An overview page displays each test case represented 
by a table row showing total execution time, if the case was successful,
failed, or skipped, plus an optional user comment. For a failed test case, the 
reason for termination is also printed in the comment field. The overview page
has a link to each test case log file, providing simple navigation with any standard
HTML browser.
</p><a name="External_Interfaces"></a><h2>External Interfaces</h2><p>
The <strong>Common Test</strong> test server requires that the test suite defines and exports the 
following mandatory or optional callback functions:
</p><dl><dt><strong>all()</strong></dt><dd><p>Returns a list of all test cases and groups in the suite. (Mandatory)</p></dd><dt><strong>suite()</strong></dt><dd><p>Information function used to return properties for the suite. (Optional)</p></dd><dt><strong>groups()</strong></dt><dd><p>For declaring test case groups. (Optional)</p></dd><dt><strong>init_per_suite(Config)</strong></dt><dd><p>Suite level configuration function, executed before the first 
test case. (Optional)</p></dd><dt><strong>end_per_suite(Config)</strong></dt><dd><p>Suite level configuration function, executed after the last 
test case. (Optional)</p></dd><dt><strong>group(GroupName)</strong></dt><dd><p>Information function used to return properties for a test case group. (Optional)</p></dd><dt><strong>init_per_group(GroupName, Config)</strong></dt><dd><p>Configuration function for a group, executed before the first 
test case. (Optional)</p></dd><dt><strong>end_per_group(GroupName, Config)</strong></dt><dd><p>Configuration function for a group, executed after the last 
test case. (Optional)</p></dd><dt><strong>init_per_testcase(TestCase, Config)</strong></dt><dd><p>Configuration function for a testcase, executed before each 
test case. (Optional)</p></dd><dt><strong>end_per_testcase(TestCase, Config)</strong></dt><dd><p>Configuration function for a testcase, executed after each 
test case. (Optional)</p></dd></dl><p>
For each test case, the <strong>Common Test</strong> test server expects the
following functions:
</p><dl><dt>Testcasename()</dt><dd><p>Information function that returns a list of test case properties. (Optional)</p></dd><dt>Testcasename(Config)</dt><dd><p>The test case function.</p></dd></dl></body></html>