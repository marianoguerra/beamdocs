<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Code Coverage Analysis</h1><a name="cover"></a><h2>General</h2><p>Although <strong>Common Test</strong> was created primarily for
black-box testing, nothing prevents it from working perfectly as
a white-box testing tool as well. This is especially true when
the application to test is written in Erlang. Then the test
ports are easily realized with Erlang function calls.</p><p>When white-box testing an Erlang application, it is useful to
be able to measure the code coverage of the test. <strong>Common Test</strong>
provides simple access to the OTP Cover tool for this
purpose. <strong>Common Test</strong> handles all necessary communication with
the Cover tool (starting, compiling, analysing, and so on).
The <strong>Common Test</strong> user only needs to specify the extent of the
code coverage analysis.</p><h2>Use</h2><p>To specify the modules to be included in the code coverage test, 
provide a cover specification file. With this file you can point 
out specific modules or specify directories containing modules to be
included in the analysis. You can also specify modules to be excluded 
from the analysis.</p><p>If you are testing a distributed Erlang application, it is
likely that code you want included in the code coverage analysis
gets executed on another Erlang node than the one <strong>Common Test</strong>
is running on. If so, you must specify these other nodes in the 
cover specification file or add them dynamically to the code coverage 
set of nodes. For details on the latter, see module 
<a href="ct_cover">ct_cover</a>.</p><p>In the cover specification file you can also specify your
required level of the code coverage analysis; <strong>details</strong> or
<strong>overview</strong>. In detailed mode, you get a coverage overview
page, showing per module and total coverage percentages.
You also get an HTML file printed for each module included in the
analysis showing exactly what parts of the code have been
executed during the test. In overview mode, only the code
coverage overview page is printed.</p><p>You can choose to export and import code coverage data between
tests. If you specify the name of an export file in the cover
specification file, <strong>Common Test</strong> exports collected coverage
data to this file at the end of the test. You can similarly
specify previously exported data to be imported and
included in the analysis for a test (multiple import files can be specified). 
This way, the total code coverage can be analyzed without necessarily 
running all tests at once.</p><p>To activate the code coverage support, specify the name of the cover 
specification file as you start <strong>Common Test</strong>.
Do this by using flag <strong>-cover</strong> with 
<a href="ct_run">ct_run</a>, 
for example:</p><pre>
 $ ct_run -dir $TESTOBJS/db -cover $TESTOBJS/db/config/db.coverspec</pre><p>You can also pass the cover specification file name in a
call to <a href="./ct#run_test-1">ct#run_test-1</a>, 
by adding a <strong>{cover,CoverSpec}</strong> tuple to argument <strong>Opts</strong>.</p><p>You can also enable code coverage in your test specifications (see section 
<a href="./run_test_chapter#test_specifications">Test Specifications</a>
in section Running Tests and Analyzing Results).</p><a name="cover_stop"></a><h2>Stopping the Cover Tool When Tests Are Completed</h2><p>By default, the Cover tool is automatically stopped when the
tests are completed. This causes the original (non-cover
compiled) modules to be loaded back into the test node. If a
process at this point still runs old code of any of the
modules that are cover compiled, meaning that it has not done
any fully qualified function call after the cover compilation,
the process is killed. To avoid this, set the value of option 
<strong>cover_stop</strong> to <strong>false</strong>. This means that the 
modules stay cover compiled. Therefore, this is only recommended 
if the Erlang nodes under test are terminated after the test is 
completed, or if cover can be manually stopped.</p><p>The option can be set by using flag <strong>-cover_stop</strong> with
<strong>ct_run</strong>, by adding <strong>{cover_stop,true|false}</strong> to argument
<strong>Opts</strong> to 
<a href="./ct#run_test-1">ct#run_test-1</a>, 
or by adding a <strong>cover_stop</strong> term in the test specification (see section
<a href="./run_test_chapter#test_specifications">Test Specifications</a>
in section Running Tests and Analyzing Results).</p><h2>The Cover Specification File</h2><p>The following terms are allowed in a cover specification file:</p><pre>
 %% List of Nodes on which cover will be active during test.
 %% Nodes = [atom()]
 {nodes, Nodes}.       

 %% Files with previously exported cover data to include in analysis.
 %% CoverDataFiles = [string()]
 {import, CoverDataFiles}.

 %% Cover data file to export from this session.
 %% CoverDataFile = string()
 {export, CoverDataFile}.

 %% Cover analysis level.
 %% Level = details | overview
 {level, Level}.       

 %% Directories to include in cover.
 %% Dirs = [string()]
 {incl_dirs, Dirs}.

 %% Directories, including subdirectories, to include.
 {incl_dirs_r, Dirs}.

 %% Specific modules to include in cover.
 %% Mods = [atom()]
 {incl_mods, Mods}.

 %% Directories to exclude in cover.
 {excl_dirs, Dirs}.

 %% Directories, including subdirectories, to exclude.
 {excl_dirs_r, Dirs}.

 %% Specific modules to exclude in cover.
 {excl_mods, Mods}.

 %% Cross cover compilation
 %% Tag = atom(), an identifier for a test run
 %% Mod = [atom()], modules to compile for accumulated analysis
 {cross,[{Tag,Mods}]}.</pre><p>The terms <strong>incl_dirs_r</strong> and <strong>excl_dirs_r</strong> tell <strong>Common Test</strong> to search the specified directories recursively and include 
or exclude any module found during the search. The terms
<strong>incl_dirs</strong> and <strong>excl_dirs</strong> result in a
non-recursive search for modules (that is, only modules found in 
the specified directories are included or excluded).</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Directories containing Erlang modules to be included in a code 
coverage test must exist in the code server path. Otherwise, 
the Cover tool fails to recompile the modules. It is not sufficient to 
specify these directories in the cover specification file for 
<strong>Common Test</strong>.</p></div><a name="cross_cover"></a><h2>Cross Cover Analysis</h2><p>The cross cover mechanism allows cover analysis of modules
across multiple tests. It is useful if some code, for example, a 
library module, is used by many different tests and the accumulated 
cover result is desirable.</p><p>This can also be achieved in a more customized way by
using parameter <strong>export</strong> in the cover specification and
analysing the result off line. However, the cross cover mechanism is a
built-in solution that also provides logging.</p><p>The mechanism is easiest explained by an example:</p><p>Assume that there are two systems, <strong>s1</strong> and <strong>s2</strong>,
that are tested in separate test runs. System <strong>s1</strong> contains
a library module <strong>m1</strong> tested by test run <strong>s1</strong> and 
is included in the cover specification of <strong>s1</strong> as follows:</p><pre><code class="">
 s1.cover:
   {incl_mods,[m1]}.</code></pre><p>When analysing code coverage, the result for <strong>m1</strong> can be
seen in the cover log in the <strong>s1</strong> test result.</p><p>Now, imagine that as <strong>m1</strong> is a library module, it
is also often used by system <strong>s2</strong>. Test run <strong>s2</strong>
does not specifically test <strong>m1</strong>, but it can still be
interesting to see which parts of <strong>m1</strong> that are covered 
by the <strong>s2</strong> tests. To do this, <strong>m1</strong> can be included also
in the cover specification of <strong>s2</strong> as follows:</p><pre><code class="">
 s2.cover:
   {incl_mods,[m1]}.</code></pre><p>This gives an entry for <strong>m1</strong> also in the cover log
for test run <strong>s2</strong>. The problem is that this only
reflects the coverage by <strong>s2</strong> tests, not the accumulated
result over <strong>s1</strong> and <strong>s2</strong>. This is where the cross
cover mechanism comes in handy.</p><p>If instead the cover specification for <strong>s2</strong> is like
the following:</p><pre><code class="">
 s2.cover:
   {cross,[{s1,[m1]}]}.</code></pre><p>Then <strong>m1</strong> is cover compiled in test run <strong>s2</strong>,
but not shown in the coverage log. Instead, if
<a href="./ct_cover#cross_cover_analyse-2">ct_cover#cross_cover_analyse-2</a> 
is called after both <strong>s1</strong> and <strong>s2</strong> test runs are completed, 
the accumulated result for <strong>m1</strong> is available in the cross cover 
log for test run <strong>s1</strong>.</p><p>The call to the analyze function must be as follows:</p><pre><code class="">
 ct_cover:cross_cover_analyse(Level, [{s1,S1LogDir},{s2,S2LogDir}]).</code></pre><p>Here, <strong>S1LogDir</strong> and <strong>S2LogDir</strong> are the directories
named <strong>&lt;TestName&gt;.logs</strong> for each test respectively.</p><p>Notice the tags <strong>s1</strong> and <strong>s2</strong>, which are used in the
cover specification file and in the call to
<strong>ct_cover:cross_cover_analyse/2</strong>. The purpose of these is only
to map the modules specified in the cover specification to the log
directory specified in the call to the analyze function. The tag name
has no meaning beyond this.</p><h2>Logging</h2><p>To view the result of a code coverage test, click the button
labeled "COVER LOG" in the top-level index page for the test run.</p><p>Before Erlang/OTP 17.1, if your test run consisted of
multiple tests, cover would be started and stopped for each test
within the test run. Separate logs would be available through the
"Coverage log" link on the test suite result pages. These links
are still available, but now they all point to the same page as
the button on the top-level index page. The log contains the
accumulated results for the complete test run. For details about 
this change, see the release notes.</p><p>The button takes you to the code coverage overview page. If you
have successfully performed a detailed coverage analysis,
links to each individual module coverage page are found here.</p><p>If cross cover analysis is performed, and there are
accumulated coverage results for the current test, the link
"Coverdata collected over all tests" takes you to these
results.</p></body></html>