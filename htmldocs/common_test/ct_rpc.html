<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>ct_rpc</h1><h1>ct_rpc</h1><p>Common Test specific layer on Erlang/OTP rpc.</p><p><strong>Common Test</strong> specific layer on Erlang/OTP <strong>rpc</strong>.</p><h1>Functions</h1><h2>app_node(App, Candidates) -&gt; NodeName</h2><p>From a set of candidate nodes determines which of them is running the application App.</p><ul><li><span class="v">App = atom()</span></li><li><span class="v">Candidates = [NodeName]</span></li><li><span class="v">NodeName = atom()</span></li></ul><a name="app_node-2"></a><p>From a set of candidate nodes determines which of them is running
the application <strong>App</strong>. If none of the candidate nodes is
running <strong>App</strong>, the function makes the test case calling
this function to fail. This function is the same as calling
<strong>app_node(App, Candidates, true)</strong>.</p><h2>app_node(App, Candidates, FailOnBadRPC) -&gt; NodeName</h2><p>Same as app_node/2, except that argument FailOnBadRPC determines if the search for a candidate node is to stop if badrpc is received at some point.</p><ul><li><span class="v">App = atom()</span></li><li><span class="v">Candidates = [NodeName]</span></li><li><span class="v">NodeName = atom()</span></li><li><span class="v">FailOnBadRPC = true | false</span></li></ul><a name="app_node-3"></a><p>Same as
<a href="#app_node-2">app_node-2</a>,
except that argument <strong>FailOnBadRPC</strong> determines if the search
for a candidate node is to stop if <strong>badrpc</strong> is received at
some point.</p><h2>app_node(App, Candidates, FailOnBadRPC, Cookie) -&gt; NodeName</h2><p>Same as app_node/2, except that argument FailOnBadRPC determines if the search for a candidate node is to stop if badrpc is received at some point.</p><ul><li><span class="v">App = atom()</span></li><li><span class="v">Candidates = [NodeName]</span></li><li><span class="v">NodeName = atom()</span></li><li><span class="v">FailOnBadRPC = true | false</span></li><li><span class="v">Cookie = atom()</span></li></ul><a name="app_node-4"></a><p>Same as
<a href="#app_node-2">app_node-2</a>,
except that argument <strong>FailOnBadRPC</strong> determines if the search
for a candidate node is to stop if <strong>badrpc</strong> is received at
some point.</p><p>The cookie on the client node is set to <strong>Cookie</strong> for this
<strong>rpc</strong> operation (used to match the server node cookie).</p><h2>call(Node, Module, Function, Args) -&gt; term() | {badrpc, Reason}</h2><p>Same as call(Node, Module, Function, Args, infinity).</p><a name="call-4"></a><p>Same as <strong>call(Node, Module, Function, Args, infinity)</strong>.</p><h2>call(Node, Module, Function, Args, TimeOut) -&gt; term() | {badrpc, Reason}</h2><p>Evaluates apply(Module, Function, Args) on the node Node.</p><ul><li><span class="v">Node = NodeName | {Fun, FunArgs}</span></li><li><span class="v">Fun = function()</span></li><li><span class="v">FunArgs = term()</span></li><li><span class="v">NodeName = atom()</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Function = atom()</span></li><li><span class="v">Args = [term()]</span></li><li><span class="v">Reason = timeout | term()</span></li></ul><a name="call-5"></a><p>Evaluates <strong>apply(Module, Function, Args)</strong> on the node
<strong>Node</strong>. Returns either whatever <strong>Function</strong> returns, or
<strong>{badrpc, Reason}</strong> if the remote procedure call fails. If
<strong>Node</strong> is <strong>{Fun, FunArgs}</strong>, applying <strong>Fun</strong> to
<strong>FunArgs</strong> is to return a node name.</p><h2>call(Node, Module, Function, Args, TimeOut, Cookie) -&gt; term() | {badrpc, Reason}</h2><p>Evaluates apply(Module, Function, Args) on the node Node.</p><ul><li><span class="v">Node = NodeName | {Fun, FunArgs}</span></li><li><span class="v">Fun = function()</span></li><li><span class="v">FunArgs = term()</span></li><li><span class="v">NodeName = atom()</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Function = atom()</span></li><li><span class="v">Args = [term()]</span></li><li><span class="v">Reason = timeout | term()</span></li><li><span class="v">Cookie = atom()</span></li></ul><a name="call-6"></a><p>Evaluates <strong>apply(Module, Function, Args)</strong> on the node
<strong>Node</strong>. Returns either whatever <strong>Function</strong> returns, or
<strong>{badrpc, Reason}</strong> if the remote procedure call fails. If
<strong>Node</strong> is <strong>{Fun, FunArgs}</strong>, applying <strong>Fun</strong> to
<strong>FunArgs</strong> is to return a node name.</p><p>The cookie on the client node is set to <strong>Cookie</strong> for this
<strong>rpc</strong> operation (used to match the server node cookie).</p><h2>cast(Node, Module, Function, Args) -&gt; ok</h2><p>Evaluates apply(Module, Function, Args) on the node Node.</p><ul><li><span class="v">Node = NodeName | {Fun, FunArgs}</span></li><li><span class="v">Fun = function()</span></li><li><span class="v">FunArgs = term()</span></li><li><span class="v">NodeName = atom()</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Function = atom()</span></li><li><span class="v">Args = [term()]</span></li><li><span class="v">Reason = timeout | term()</span></li></ul><a name="cast-4"></a><p>Evaluates <strong>apply(Module, Function, Args)</strong> on the node
<strong>Node</strong>. No response is delivered and the process that makes
the call is not suspended until the evaluation is completed as in
the case of <strong>call/3,4</strong>. If <strong>Node</strong> is
<strong>{Fun, FunArgs}</strong>, applying <strong>Fun</strong> to <strong>FunArgs</strong> is to
return a node name.</p><h2>cast(Node, Module, Function, Args, Cookie) -&gt; ok</h2><p>Evaluates apply(Module, Function, Args) on the node Node.</p><ul><li><span class="v">Node = NodeName | {Fun, FunArgs}</span></li><li><span class="v">Fun = function()</span></li><li><span class="v">FunArgs = term()</span></li><li><span class="v">NodeName = atom()</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Function = atom()</span></li><li><span class="v">Args = [term()]</span></li><li><span class="v">Reason = timeout | term()</span></li><li><span class="v">Cookie = atom()</span></li></ul><a name="cast-5"></a><p>Evaluates <strong>apply(Module, Function, Args)</strong> on the node
<strong>Node</strong>. No response is delivered and the process that makes
the call is not suspended until the evaluation is completed as in
the case of <strong>call/3,4</strong>. If <strong>Node</strong> is
<strong>{Fun, FunArgs}</strong>, applying <strong>Fun</strong> to <strong>FunArgs</strong> is to
return a node name.</p><p>The cookie on the client node is set to <strong>Cookie</strong> for this
<strong>rpc</strong> operation (used to match the server node cookie).</p></body></html>