<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>ct_telnet</h1><h1>ct_telnet</h1><p>Common Test specific layer on top of Telnet client ct_telnet_client.erl</p><p><strong>Common Test</strong> specific layer on top of Telnet client
<strong>ct_telnet_client.erl</strong>.Use this module to set up Telnet connections, send commands, and
perform string matching on the result. For information about how to use
<strong>ct_telnet</strong> and configure connections, specifically for UNIX hosts,
see the
<a href="unix_telnet">unix_telnet</a> manual page.
Default values defined in <strong>ct_telnet</strong>:<a name="Default_values"></a><ul><li><p>Connection timeout (time to wait for connection) = 10
seconds</p></li><li><p>Command timeout (time to wait for a command to return) =
10 seconds</p></li><li><p>Max number of reconnection attempts = 3</p></li><li><p>Reconnection interval (time to wait in between
reconnection attempts) = 5 seconds</p></li><li><p>Keep alive (sends NOP to the server every 8 sec if
connection is idle) = <strong>true</strong></p></li><li><p>Polling limit (max number of times to poll to get a
remaining string terminated) = 0</p></li><li><p>Polling interval (sleep time between polls) = 1 second</p> </li><li><p>The TCP_NODELAY option for the telnet socket
is disabled (set to <strong>false</strong>) per default</p></li></ul>These parameters can be modified by the user with the following
configuration term:<pre>
 {telnet_settings, [{connect_timeout,Millisec},
                    {command_timeout,Millisec},
                    {reconnection_attempts,N},
                    {reconnection_interval,Millisec},
                    {keep_alive,Bool},
                    {poll_limit,N},
                    {poll_interval,Millisec},
                    {tcp_nodelay,Bool}]}.</pre><strong>Millisec = integer(), N = integer()</strong>Enter the <strong>telnet_settings</strong> term in a configuration file included
in the test and <strong>ct_telnet</strong> retrieves the information
automatically.<strong>keep_alive</strong> can be specified per connection, if necessary. For
details, see
<a href="unix_telnet">unix_telnet</a>.</p><h2>Logging</h2><a name="Logging"></a><p>The default logging behavior of <strong>ct_telnet</strong> is to print information
about performed operations, commands, and their corresponding results to
the test case HTML log. The following is not printed to the HTML
log: text strings sent from the Telnet server that are not explicitly
received by a <strong>ct_telnet</strong> function, such as <strong>expect/3</strong>.
However, <strong>ct_telnet</strong> can be configured to use a special purpose
event handler, implemented in <strong>ct_conn_log_h</strong>, for logging
<em>all</em> Telnet traffic. To use this handler, install a <strong>Common Test</strong> hook named <strong>cth_conn_log</strong>. Example (using the test suite
information function):</p><pre>
 suite() -&gt;
     [{ct_hooks, [{cth_conn_log, [{conn_mod(),hook_options()}]}]}].</pre><p><strong>conn_mod()</strong> is the name of the <strong>Common Test</strong> module
implementing the connection protocol, that is, <strong>ct_telnet</strong>.</p><p>The <strong>cth_conn_log</strong> hook performs unformatted logging of Telnet
data to a separate text file. All Telnet communication is captured and
printed, including any data sent from the server. The link to
this text file is located at the top of the test case HTML log.</p><p>By default, data for all Telnet connections is logged in one common
file (named <strong>default</strong>), which can get messy, for example, if
multiple Telnet sessions are running in parallel. Therefore a separate
log file can be created for each connection. To configure this, use hook
option <strong>hosts</strong> and list the names of the servers/connections
to be used in the suite. The connections must be named for this to
work (see
<a href="#open-1">open-1</a>).</p><p>Hook option <strong>log_type</strong> can be used to change the
<strong>cth_conn_log</strong> behavior. The default value of this option is
<strong>raw</strong>, which results in the behavior described above. If the value
is set to <strong>html</strong>, all Telnet communication is printed to the test
case HTML log instead.</p><p>All <strong>cth_conn_log</strong> hook options described can also be
specified in a configuration file with configuration variable
<strong>ct_conn_log</strong>.</p><p><em>Example:</em></p><pre>
 {ct_conn_log, [{ct_telnet,[{log_type,raw},
                            {hosts,[key_or_name()]}]}]}</pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Hook options specified in a configuration file overwrite any
hard-coded hook options in the test suite.</p></div><a name="Logging_example"></a><p><em>Logging Example:</em></p><p>The following <strong>ct_hooks</strong> statement causes printing of Telnet
traffic to separate logs for the connections <strong>server1</strong> and
<strong>server2</strong>. Traffic for any other connections is logged in the
default Telnet log.</p><pre>
 suite() -&gt;
     [{ct_hooks,
       [{cth_conn_log, [{ct_telnet,[{hosts,[server1,server2]}]}]}]}].</pre><p>As previously explained, this specification can also be provided by an
entry like the following in a configuration file:</p><pre>
 {ct_conn_log, [{ct_telnet,[{hosts,[server1,server2]}]}]}.</pre><p>In this case the <strong>ct_hooks</strong> statement in the test suite can look
as follows:</p><pre>
 suite() -&gt;
     [{ct_hooks, [{cth_conn_log, []}]}].</pre><h2>Data Types</h2><a name="types"></a><dl><dt><strong>connection() = handle() | {target_name(), connection_type()} | target_name()</strong></dt><dd><a name="type-connection"></a> <p>For <strong>target_name()</strong>, see module
<a href="ct">ct</a>.</p></dd><dt><strong>connection_type() = telnet | ts1 | ts2</strong></dt><dd><a name="type-connection_type"></a> </dd><dt><strong>handle() = handle()</strong></dt><dd><a name="type-handle"></a> <p>Handle for a specific Telnet connection, see module
<a href="ct">ct</a>.</p></dd><dt><strong>prompt_regexp() = string()</strong></dt><dd><a name="type-prompt_regexp"></a> <p>Regular expression matching all possible prompts for a specific
target type. <strong>regexp</strong> must not have any groups, that is, when
matching, <strong>re:run/3</strong> (in STDLIB) must return a list with
one single element.</p></dd></dl><h1>Functions</h1><h2>close(Connection) -&gt; ok | {error, Reason}</h2><p>Closes the Telnet connection and stops the process managing it.</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="close-1"></a><p>Closes the Telnet connection and stops the process managing it.</p><p>A connection can be associated with a target name and/or a handle.
If <strong>Connection</strong> has no associated target name, it can only
be closed with the handle value (see
<a href="#open-4">open-4</a>).</p><h2>cmd(Connection, Cmd) -&gt; {ok, Data} | {error, Reason}</h2><p>Equivalent to cmd(Connection, Cmd, []).</p><a name="cmd-2"></a><p>Equivalent to
<a href="#cmd-3">cmd-3</a>.</p><h2>cmd(Connection, Cmd, Opts) -&gt; {ok, Data} | {error, Reason}</h2><p>Sends a command through Telnet and waits for prompt.</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">Cmd = string()</span></li><li><span class="v">Opts = [Opt]</span></li><li><span class="v">Opt = {timeout, timeout()} | {newline, boolean() | string()}</span></li><li><span class="v">Data = [string()]</span></li><li><span class="v">Reason = term()</span></li></ul><a name="cmd-3"></a><p>Sends a command through Telnet and waits for prompt.</p><p>By default, this function adds "\n" to the end of the
specified command. If this is not desired, use option
<strong>{newline,false}</strong>. This is necessary, for example, when
sending Telnet command sequences prefixed with character
Interpret As Command (IAC). Option <strong>{newline,string()}</strong>
can also be used if a different line end than "\n" is
required, for instance <strong>{newline,"\r\n"}</strong>, to add both
carriage return and newline characters.</p><p>Option <strong>timeout</strong> specifies how long the client must wait
for prompt. If the time expires, the function returns
<strong>{error,timeout}</strong>. For information about the default value
for the command timeout, see the
<a href="#Default_values">list of default values</a>
in the beginning of this module.</p><h2>cmdf(Connection, CmdFormat, Args) -&gt; {ok, Data} | {error, Reason}</h2><p>Equivalent to cmdf(Connection, CmdFormat, Args, []).</p><a name="cmdf-3"></a><p>Equivalent to
<a href="#cmdf-4">cmdf-4</a>.</p><h2>cmdf(Connection, CmdFormat, Args, Opts) -&gt; {ok, Data} | {error, Reason}</h2><p>Sends a Telnet command and waits for prompt (uses a format string and a list of arguments to build the command).</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">CmdFormat = string()</span></li><li><span class="v">Args = list()</span></li><li><span class="v">Opts = [Opt]</span></li><li><span class="v">Opt = {timeout, timeout()} | {newline, boolean() | string()}</span></li><li><span class="v">Data = [string()]</span></li><li><span class="v">Reason = term()</span></li></ul><a name="cmdf-4"></a><p>Sends a Telnet command and waits for prompt (uses a format string
and a list of arguments to build the command).</p><p>For details, see
<a href="#cmd-3">cmd-3</a>.</p><h2>expect(Connection, Patterns) -&gt; term()</h2><p>Equivalent to expect(Connections, Patterns, []).</p><a name="expect-2"></a><p>Equivalent to
<a href="#expect-3">expect-3</a>.</p><h2>expect(Connection, Patterns, Opts) -&gt; {ok, Match} | {ok, MatchList, HaltReason} | {error, Reason}</h2><p>Gets data from Telnet and waits for the expected pattern.</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">Patterns = Pattern | [Pattern]</span></li><li><span class="v">Pattern = string() | {Tag, string()} | prompt | {prompt, Prompt}</span></li><li><span class="v">Prompt = string()</span></li><li><span class="v">Tag = term()</span></li><li><span class="v">Opts = [Opt]</span></li><li><span class="v">Opt = {idle_timeout, IdleTimeout} | {total_timeout, TotalTimeout} | repeat | {repeat, N} | sequence | {halt, HaltPatterns} | ignore_prompt | no_prompt_check | wait_for_prompt | {wait_for_prompt, Prompt}</span></li><li><span class="v">IdleTimeout = infinity | integer()</span></li><li><span class="v">TotalTimeout = infinity | integer()</span></li><li><span class="v">N = integer()</span></li><li><span class="v">HaltPatterns = Patterns</span></li><li><span class="v">MatchList = [Match]</span></li><li><span class="v">Match = RxMatch | {Tag, RxMatch} | {prompt, Prompt}</span></li><li><span class="v">RxMatch = [string()]</span></li><li><span class="v">HaltReason = done | Match</span></li><li><span class="v">Reason = timeout | {prompt, Prompt}</span></li></ul><a name="expect-3"></a><p>Gets data from Telnet and waits for the expected pattern.</p><p><strong>Pattern</strong> can be a POSIX regular expression. The function
returns when a pattern is successfully matched (at least one, in
the case of multiple patterns).</p><p><strong>RxMatch</strong> is a list of matched strings. It looks as
follows <strong>[FullMatch, SubMatch1, SubMatch2, ...]</strong>, where
<strong>FullMatch</strong> is the string matched by the whole regular
expression, and <strong>SubMatchN</strong> is the string that matched
subexpression number <strong>N</strong>. Subexpressions are denoted with
<strong>'(' ')'</strong> in the regular expression.</p><p>If a <strong>Tag</strong> is specified, the returned <strong>Match</strong> also
includes the matched <strong>Tag</strong>. Otherwise, only <strong>RxMatch</strong>
is returned.</p><p><em>Options:</em></p><dl><dt><strong>idle_timeout</strong></dt><dd><p>Indicates that the function must return if the Telnet
client is idle (that is, if no data is received) for more than
<strong>IdleTimeout</strong> milliseconds. Default time-out is 10
seconds.</p></dd><dt><strong>total_timeout</strong></dt><dd><p>Sets a time limit for the complete <strong>expect</strong> operation.
After <strong>TotalTimeout</strong> milliseconds, <strong>{error,timeout}</strong>
is returned. Default is <strong>infinity</strong> (that is, no time
limit).</p></dd><dt><strong>ignore_prompt | no_prompt_check</strong></dt><dd><p>&gt;The function returns when a prompt is received, even if
no pattern has yet been matched, and 
<strong>{error,{prompt,Prompt}}</strong> is returned. However, this
behavior can be modified with option <strong>ignore_prompt</strong> or
option <strong>no_prompt_check</strong>, which tells <strong>expect</strong> to
return only when a match is found or after a time-out.</p></dd><dt><strong>ignore_prompt</strong></dt><dd><p><strong>ct_telnet</strong> ignores any prompt found. This option is
useful if data sent by the server can include a pattern
matching prompt <strong>regexp</strong> (as returned by
<strong>TargedMod:get_prompt_regexp/0</strong>), but is not to not cause
the function to return.</p></dd><dt><strong>no_prompt_check</strong></dt><dd><p><strong>ct_telnet</strong> does not search for a prompt at all. This
is useful if, for example, <strong>Pattern</strong> itself matches the
prompt.</p></dd><dt><strong>wait_for_prompt</strong></dt><dd><p>Forces <strong>ct_telnet</strong> to wait until the prompt string
is received before returning (even if a pattern has already been
matched). This is equal to calling
<strong>expect(Conn, Patterns++[{prompt,Prompt}], [sequence|Opts])</strong>.
Notice that option <strong>idle_timeout</strong> and <strong>total_timeout</strong>
can abort the operation of waiting for prompt.</p></dd><dt><strong>repeat | repeat, N</strong></dt><dd><p>The pattern(s) must be matched multiple times. If <strong>N</strong>
is specified, the pattern(s) are matched <strong>N</strong> times, and
the function returns <strong>HaltReason = done</strong>. This option can be
interrupted by one or more <strong>HaltPatterns</strong>. <strong>MatchList</strong>
is always returned, that is, a list of <strong>Match</strong> instead of
only one <strong>Match</strong>. Also <strong>HaltReason</strong> is returned.</p> </dd><dt><strong>sequence</strong></dt><dd><p>All patterns must be matched in a sequence. A match is not
concluded until all patterns are matched. This option can be
interrupted by one or more <strong>HaltPatterns</strong>. <strong>MatchList</strong>
is always returned, that is, a list of <strong>Match</strong> instead of
only one <strong>Match</strong>. Also <strong>HaltReason</strong> is returned.</p>  </dd></dl><p><em>Example 1:</em></p><pre>
 expect(Connection,[{abc,"ABC"},{xyz,"XYZ"}],[sequence,{halt,[{nnn,"NNN"}]}])</pre><p>First this tries to match <strong>"ABC"</strong>, and then <strong>"XYZ"</strong>, but
if <strong>"NNN"</strong> appears,  the function returns
<strong>{error,{nnn,["NNN"]}}</strong>. If both <strong>"ABC"</strong> and <strong>"XYZ"</strong>
are matched, the function returns <strong>{ok,[AbcMatch,XyzMatch]}</strong>.</p><p><em>Example 2:</em></p><pre>
 expect(Connection,[{abc,"ABC"},{xyz,"XYZ"}],[{repeat,2},{halt,[{nnn,"NNN"}]}])</pre><p>This tries to match <strong>"ABC"</strong> or <strong>"XYZ"</strong> twice. If
<strong>"NNN"</strong> appears, the function returns
<strong>HaltReason = {nnn,["NNN"]}</strong>.</p><p>Options <strong>repeat</strong> and <strong>sequence</strong> can be combined to
match a sequence multiple times.</p><h2>get_data(Connection) -&gt; {ok, Data} | {error, Reason}</h2><p>Gets all data received by the Telnet client since the last command was sent.</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">Data = [string()]</span></li><li><span class="v">Reason = term()</span></li></ul><a name="get_data-1"></a><p>Gets all data received by the Telnet client since the last
command was sent. Only newline-terminated strings are returned.
If the last received string has not yet been terminated, the
connection can be polled automatically until the string is
complete.</p><p>The polling feature is controlled by the configuration values
<strong>poll_limit</strong> and <strong>poll_interval</strong> and is by default
disabled. This means that the function immediately returns all
complete strings received and saves a remaining non-terminated
string for a later <strong>get_data</strong> call.</p><h2>open(Name) -&gt; {ok, Handle} | {error, Reason}</h2><p>Equivalent to open(Name, telnet).</p><a name="open-1"></a><p>Equivalent to
<a href="#open-2">open-2</a>.</p><h2>open(Name, ConnType) -&gt; {ok, Handle} | {error, Reason}</h2><p>Opens a Telnet connection to the specified target host.</p><ul><li><span class="v">Name = target_name()</span></li><li><span class="v">ConnType = connection_type()</span></li><li><span class="v">Handle = handle()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="open-2"></a><p>Opens a Telnet connection to the specified target host.</p><h2>open(KeyOrName, ConnType, TargetMod) -&gt; {ok, Handle} | {error, Reason}</h2><p>Equivalent to open(KeyOrName, ConnType, TargetMod, []).</p><a name="open-3"></a><p>Equivalent to
<a href="#open-4">open-4</a>.</p><h2>open(KeyOrName, ConnType, TargetMod, Extra) -&gt; {ok, Handle} | {error, Reason}</h2><p>Opens a Telnet connection to the specified target host.</p><ul><li><span class="v">KeyOrName = Key | Name</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Name = target_name()</span></li><li><span class="v">ConnType = connection_type()</span></li><li><span class="v">TargetMod = atom()</span></li><li><span class="v">Extra = term()</span></li><li><span class="v">Handle = handle()</span></li><li><span class="v">Reason = term()</span></li></ul><a name="open-4"></a><p>Opens a Telnet connection to the specified target host.</p><p>The target data must exist in a configuration file. The connection
can be associated with <strong>Name</strong> and/or the returned <strong>Handle</strong>.
To allocate a name for the target, use one of the following
alternatives:</p><ul><li><p><a href="./ct#require-2">ct#require-2</a>
in a test case</p></li><li><p>A <strong>require</strong> statement in the suite information
function (<strong>suite/0</strong>)</p></li><li><p>A <strong>require</strong> statement in a test case information
function</p></li></ul><p>If you want the connection to be associated with <strong>Handle</strong> only
(if you, for example, need to open multiple connections to a host),
use <strong>Key</strong>, the configuration variable name, to specify the
target. Notice that a connection without an associated target name
can only be closed with the <strong>Handle</strong> value.</p><p><strong>TargetMod</strong> is a module that exports the functions
<strong>connect(Ip, Port, KeepAlive, Extra)</strong> and
<strong>get_prompt_regexp()</strong> for the specified <strong>TargetType</strong>
(for example, <strong>unix_telnet</strong>).</p><p>For <strong>target_name()</strong>, see module
<a href="ct">ct</a>.</p><p>See also
<a href="./ct#require-2">ct#require-2</a>.</p><h2>send(Connection, Cmd) -&gt; ok | {error, Reason}</h2><p>Equivalent to send(Connection, Cmd, []).</p><a name="send-2"></a><p>Equivalent to
<a href="#send-3">send-3</a>.</p><h2>send(Connection, Cmd, Opts) -&gt; ok | {error, Reason}</h2><p>Sends a Telnet command and returns immediately.</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">Cmd = string()</span></li><li><span class="v">Opts = [Opt]</span></li><li><span class="v">Opt = {newline, boolean() | string()}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="send-3"></a><p>Sends a Telnet command and returns immediately.</p><p>By default, this function adds "\n" to the end of the
specified command. If this is not desired, option
<strong>{newline,false}</strong> can be used. This is necessary, for example,
when sending Telnet command sequences prefixed with character   
Interpret As Command (IAC). Option <strong>{newline,string()}</strong>
can also be used if a different line end than "\n" is
required, for instance <strong>{newline,"\r\n"}</strong>, to add both
carriage return and newline characters.</p><p>The resulting output from the command can be read with
<a href="#get_data-1">get_data-1</a> or
<a href="#expect-2">expect-2</a>.</p><h2>sendf(Connection, CmdFormat, Args) -&gt; ok | {error, Reason}</h2><p>Equivalent to sendf(Connection, CmdFormat, Args, []).</p><a name="sendf-3"></a><p>Equivalent to
<a href="#sendf-4">sendf-4</a>.</p><h2>sendf(Connection, CmdFormat, Args, Opts) -&gt; ok | {error, Reason}</h2><p>Sends a Telnet command and returns immediately (uses a format string and a list of arguments to build the command).</p><ul><li><span class="v">Connection = connection()</span></li><li><span class="v">CmdFormat = string()</span></li><li><span class="v">Args = list()</span></li><li><span class="v">Opts = [Opt]</span></li><li><span class="v">Opt = {newline, boolean() | string()}</span></li><li><span class="v">Reason = term()</span></li></ul><a name="sendf-4"></a><p>Sends a Telnet command and returns immediately (uses a format
string and a list of arguments to build the command).</p><p>For details, see
<a href="#send-3">send-3</a>.</p><h2>See Also</h2><p><a href="unix_telnet">unix_telnet</a></p></body></html>