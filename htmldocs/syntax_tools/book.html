<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Syntax_Tools</h1><h1>Syntax_Tools</h1><p><em>Syntax_Tools</em> contains modules for handling abstract
Erlang syntax trees, in a way that is compatible with the "parse
trees" of the STDLIB module <strong>erl_parse</strong>, together with
utilities for reading source files in unusual ways and
pretty-printing syntax trees. Also included is an amazing module
merger and renamer called Igor, as well as an automatic
code-cleaner.</p><h4>Overview</h4><p>This package contains modules for handling abstract syntax trees (ASTs)
in Erlang, in a way that is compatible with the "abstract format" parse
trees of the stdlib module <strong>erl_parse</strong>, together with utilities for reading
source files, <a href="erl_prettypr">pretty-printing syntax trees</a>, <a href="igor">merging and renaming modules</a>, <a href="erl_tidy">cleaning up obsolete constructs</a>, and doing <a href="merl">metaprogramming</a> in Erlang.</p><p>The abstract layer (defined in <a href="erl_syntax">erl_syntax</a>) is nicely
structured and the node types are context-independent. The layer makes
it possible to transparently attach source-code comments and user
annotations to nodes of the tree. Using the abstract layer makes
applications less sensitive to changes in the <a href="./erl_parse">erl_parse(3)</a>
data structures, only requiring the <strong>erl_syntax</strong> module to be up-to-date.</p><p>The pretty printer <a href="erl_prettypr">erl_prettypr</a> is implemented on top of the
library module <a href="prettypr">prettypr</a>: this is a powerful and flexible generic
pretty printing library, which is also distributed separately.</p><p>For a short demonstration of parsing and pretty-printing, simply
compile the included module <a href="demo.erl">demo.erl</a>,
and execute <strong>demo:run()</strong> from the Erlang shell. It will compile the
remaining modules and give you further instructions.</p><p>Also try the <a href="erl_tidy">erl_tidy</a> module, as follows:
</p><pre>   erl_tidy:dir("any-erlang-source-dir", [test, old_guard_tests]).</pre><p>
(the <strong>test</strong> option assures that no files are modified).
</p><p><em>Syntax_Tools</em> contains modules for handling abstract
Erlang syntax trees, in a way that is compatible with the "external
format" parse trees of the STDLIB module <strong>erl_parse</strong>, together
with utilities for reading source files, pretty-printing syntax trees,
merging and renaming modules, cleaning up obsolete constructs, and
doing metaprogramming in Erlang.</p><h3>epp_dodger</h3><p>epp_dodger - bypasses the Erlang preprocessor.</p><p><strong>epp_dodger</strong> - bypasses the Erlang preprocessor.This module tokenises and parses most Erlang source code without
expanding preprocessor directives and macro applications, as long as
these are syntactically "well-behaved". Because the normal parse
trees of the <strong>erl_parse</strong> module cannot represent these things
(normally, they are expanded by the Erlang preprocessor <a href="./epp">epp(3)</a> before the parser sees them), an extended syntax tree
is created, using the <a href="erl_syntax">erl_syntax</a> module.</p><h4>DATA TYPES</h4><a name="types"></a><dl><dt><a name="type-errorinfo"></a>errorinfo() = {ErrorLine::integer(), Module::atom(), Descriptor::term()}</dt><dd> <p>This is a so-called Erlang I/O ErrorInfo structure; see the <a href="./io">io(3)</a> module for details.</p> </dd></dl><h3>Functions</h3><h4>parse(Dev::IODevice) -&gt; {ok, Forms} | {error,}</h4><p>Equivalent to parse(IODevice, 1). </p><a name="parse-1"></a><p>Equivalent to <a href="#parse-2">parse(IODevice, 1)</a>.</p><h4>parse(Dev::IODevice, L::StartLine) -&gt; {ok, Forms} | {error,}</h4><p>Equivalent to parse(IODevice, StartLine, []). </p><ul><li><span class="v">IODevice = pid()</span></li><li><span class="v">StartLine = integer()</span></li><li><span class="v">Forms = []</span></li></ul><a name="parse-2"></a><p>Equivalent to <a href="#parse-3">parse(IODevice, StartLine, [])</a>.</p><p><em>See also:</em> <a href="#parse-1">parse/1</a>.</p><h4>parse(Dev::IODevice, L0::StartLine, Options) -&gt; {ok, Forms} | {error,}</h4><p>Reads and parses program text from an I/O stream.</p><ul><li><span class="v">IODevice = pid()</span></li><li><span class="v">StartLine = integer()</span></li><li><span class="v">Options = [term()]</span></li><li><span class="v">Forms = []</span></li></ul><a name="parse-3"></a><p>Reads and parses program text from an I/O stream. Characters are
read from <strong>IODevice</strong> until end-of-file; apart from this, the
behaviour is the same as for <a href="#parse_file-2">parse_file/2</a>. <strong>StartLine</strong> is the
initial line number, which should be a positive integer.
</p><p><em>See also:</em> <a href="#parse-2">parse/2</a>, <a href="#parse_file-2">parse_file/2</a>, <a href="#parse_form-2">parse_form/2</a>, <a href="#quick_parse-3">quick_parse/3</a>.</p><h4>parse_file(File) -&gt; {ok, Forms} | {error,}</h4><p>Equivalent to parse_file(File, []). </p><ul><li><span class="v">File = </span></li><li><span class="v">Forms = []</span></li></ul><a name="parse_file-1"></a><p>Equivalent to <a href="#parse_file-2">parse_file(File, [])</a>.</p><h4>parse_file(File, Options) -&gt; {ok, Forms} | {error,}</h4><p>Reads and parses a file.</p><ul><li><span class="v">File = </span></li><li><span class="v">Options = [term()]</span></li><li><span class="v">Forms = []</span></li></ul><a name="parse_file-2"></a><p>Reads and parses a file. If successful, <strong>{ok, Forms}</strong>
is returned, where <strong>Forms</strong> is a list of abstract syntax
trees representing the "program forms" of the file (cf.
<strong>erl_syntax:is_form/1</strong>). Otherwise, <strong>{error, errorinfo()}</strong> is
returned, typically if the file could not be opened. Note that
parse errors show up as error markers in the returned list of
forms; they do not cause this function to fail or return
<strong>{error, errorinfo()}</strong>.</p><p>Options:
</p><dl><dt><strong>{no_fail, boolean()}</strong></dt><dd><p>If <strong>true</strong>, this makes <strong>epp_dodger</strong> replace any program forms
that could not be parsed with nodes of type <strong>text</strong> (see <a href="./erl_syntax#text-1">erl_syntax:text/1</a>), representing the raw token sequence of the
form, instead of reporting a parse error. The default value is
<strong>false</strong>.</p></dd><dt><strong>{clever, boolean()}</strong></dt><dd><p>If set to <strong>true</strong>, this makes <strong>epp_dodger</strong> try to repair the
source code as it seems fit, in certain cases where parsing would
otherwise fail. Currently, it inserts <strong>++</strong>-operators between string
literals and macros where it looks like concatenation was intended.
The default value is <strong>false</strong>.</p></dd></dl><p>
</p><p><em>See also:</em> <a href="#parse-2">parse/2</a>, <a href="#quick_parse_file-1">quick_parse_file/1</a>, <a href="./erl_syntax#is_form-1">erl_syntax:is_form/1</a>.</p><h4>parse_form(Dev::IODevice, L0::StartLine) -&gt; {ok, Form, LineNo} | {eof, LineNo} | {error,, LineNo}</h4><p>Equivalent to parse_form(IODevice, StartLine, []). </p><ul><li><span class="v">IODevice = pid()</span></li><li><span class="v">StartLine = integer()</span></li><li><span class="v">Form = </span></li><li><span class="v">LineNo = integer()</span></li></ul><a name="parse_form-2"></a><p>Equivalent to <a href="#parse_form-3">parse_form(IODevice, StartLine, [])</a>.</p><p><em>See also:</em> <a href="#quick_parse_form-2">quick_parse_form/2</a>.</p><h4>parse_form(Dev::IODevice, L0::StartLine, Options) -&gt; {ok, Form, LineNo} | {eof, LineNo} | {error,, LineNo}</h4><p>Reads and parses a single program form from an I/O stream.</p><ul><li><span class="v">IODevice = pid()</span></li><li><span class="v">StartLine = integer()</span></li><li><span class="v">Options = [term()]</span></li><li><span class="v">Form = </span></li><li><span class="v">LineNo = integer()</span></li></ul><a name="parse_form-3"></a><p>Reads and parses a single program form from an I/O stream.
Characters are read from <strong>IODevice</strong> until an end-of-form
marker is found (a period character followed by whitespace), or until
end-of-file; apart from this, the behaviour is similar to that of
<strong>parse/3</strong>, except that the return values also contain the
final line number given that <strong>StartLine</strong> is the initial
line number, and that <strong>{eof, LineNo}</strong> may be returned.
</p><p><em>See also:</em> <a href="#parse-3">parse/3</a>, <a href="#parse_form-2">parse_form/2</a>, <a href="#quick_parse_form-3">quick_parse_form/3</a>.</p><h4>quick_parse(Dev::IODevice) -&gt; {ok, Forms} | {error,}</h4><p>Equivalent to quick_parse(IODevice, 1). </p><a name="quick_parse-1"></a><p>Equivalent to <a href="#quick_parse-2">quick_parse(IODevice, 1)</a>.</p><h4>quick_parse(Dev::IODevice, L::StartLine) -&gt; {ok, Forms} | {error,}</h4><p>Equivalent to quick_parse(IODevice, StartLine, []). </p><ul><li><span class="v">IODevice = pid()</span></li><li><span class="v">StartLine = integer()</span></li><li><span class="v">Forms = []</span></li></ul><a name="quick_parse-2"></a><p>Equivalent to <a href="#quick_parse-3">quick_parse(IODevice, StartLine, [])</a>.</p><p><em>See also:</em> <a href="#quick_parse-1">quick_parse/1</a>.</p><h4>quick_parse(Dev::IODevice, L0::StartLine, Options) -&gt; {ok, Forms} | {error,}</h4><p>Similar to parse/3, but does a more quick-and-dirty processing of the code.</p><ul><li><span class="v">IODevice = pid()</span></li><li><span class="v">StartLine = integer()</span></li><li><span class="v">Options = [term()]</span></li><li><span class="v">Forms = []</span></li></ul><a name="quick_parse-3"></a><p>Similar to <a href="#parse-3">parse/3</a>, but does a more quick-and-dirty
processing of the code. See <a href="#quick_parse_file-2">quick_parse_file/2</a> for details.
</p><p><em>See also:</em> <a href="#parse-3">parse/3</a>, <a href="#quick_parse-2">quick_parse/2</a>, <a href="#quick_parse_file-2">quick_parse_file/2</a>, <a href="#quick_parse_form-2">quick_parse_form/2</a>.</p><h4>quick_parse_file(File) -&gt; {ok, Forms} | {error,}</h4><p>Equivalent to quick_parse_file(File, []). </p><ul><li><span class="v">File = </span></li><li><span class="v">Forms = []</span></li></ul><a name="quick_parse_file-1"></a><p>Equivalent to <a href="#quick_parse_file-2">quick_parse_file(File, [])</a>.</p><h4>quick_parse_file(File, Options) -&gt; {ok, Forms} | {error,}</h4><p>Similar to parse_file/2, but does a more quick-and-dirty   processing of the code.</p><ul><li><span class="v">File = </span></li><li><span class="v">Options = [term()]</span></li><li><span class="v">Forms = []</span></li></ul><a name="quick_parse_file-2"></a><p>Similar to <a href="#parse_file-2">parse_file/2</a>, but does a more quick-and-dirty  
processing of the code. Macro definitions and other preprocessor  
directives are discarded, and all macro calls are replaced with  
atoms. This is useful when only the main structure of the code is of  
interest, and not the details. Furthermore, the quick-parse method  
can usually handle more strange cases than the normal, more exact  
parsing.</p><p>Options: see <a href="#parse_file-2">parse_file/2</a>. Note however that for
<strong>quick_parse_file/2</strong>, the option <strong>no_fail</strong> is <strong>true</strong> by default.
</p><p><em>See also:</em> <a href="#parse_file-2">parse_file/2</a>, <a href="#quick_parse-2">quick_parse/2</a>.</p><h4>quick_parse_form(Dev::IODevice, L0::StartLine) -&gt; {ok, Form, LineNo} | {eof, LineNo} | {error,, LineNo}</h4><p>Equivalent to quick_parse_form(IODevice, StartLine, []). </p><ul><li><span class="v">IODevice = pid()</span></li><li><span class="v">StartLine = integer()</span></li><li><span class="v">Form =  | none</span></li><li><span class="v">LineNo = integer()</span></li></ul><a name="quick_parse_form-2"></a><p>Equivalent to <a href="#quick_parse_form-3">quick_parse_form(IODevice, StartLine, [])</a>.</p><p><em>See also:</em> <a href="#parse_form-2">parse_form/2</a>.</p><h4>quick_parse_form(Dev::IODevice, L0::StartLine, Options) -&gt; {ok, Form, LineNo} | {eof, LineNo} | {error,, LineNo}</h4><p>Similar to parse_form/3, but does a more quick-and-dirty processing of the code.</p><ul><li><span class="v">IODevice = pid()</span></li><li><span class="v">StartLine = integer()</span></li><li><span class="v">Options = [term()]</span></li><li><span class="v">Form = </span></li><li><span class="v">LineNo = integer()</span></li></ul><a name="quick_parse_form-3"></a><p>Similar to <a href="#parse_form-3">parse_form/3</a>, but does a more quick-and-dirty
processing of the code. See <a href="#quick_parse_file-2">quick_parse_file/2</a> for details.
</p><p><em>See also:</em> <a href="#parse-3">parse/3</a>, <a href="#parse_form-3">parse_form/3</a>, <a href="#quick_parse_form-2">quick_parse_form/2</a>.</p><h4>tokens_to_string(Tokens::[term()]) -&gt; string()</h4><p>Generates a string corresponding to the given token sequence.</p><a name="tokens_to_string-1"></a><p>Generates a string corresponding to the given token sequence.
The string can be re-tokenized to yield the same token list again.</p><h3>Authors</h3><span class="aname">Richard Carlsson</span><span class="email">carlsson.richard@gmail.com</span><h3>erl_comment_scan</h3><p>Functions for reading comment lines from Erlang source code.</p><p>Functions for reading comment lines from Erlang source code.</p><h4>DATA TYPES</h4><a name="types"></a><dl><dt><a name="type-comment"></a>comment() = {Line::integer(), Column::integer(), Indentation::integer(), Text::[string()]}</dt><dd> </dd></dl><h3>Functions</h3><h4>file(FileName::) -&gt; [Comment]</h4><p>Extracts comments from an Erlang source code file.</p><ul><li><span class="v">Comment = {Line, Column, Indentation, Text}</span></li><li><span class="v">Line = integer()</span></li><li><span class="v">Column = integer()</span></li><li><span class="v">Indentation = integer()</span></li><li><span class="v">Text = [string()]</span></li></ul><a name="file-1"></a><p>Extracts comments from an Erlang source code file. Returns a
list of entries representing <em>multi-line</em> comments, listed in
order of increasing line-numbers. For each entry, <strong>Text</strong>
is a list of strings representing the consecutive comment lines in
top-down order; the strings contain <em>all</em> characters following
(but not including) the first comment-introducing <strong>%</strong>  
character on the line, up to (but not including) the line-terminating  
newline.</p><p>Furthermore, <strong>Line</strong> is the line number and
<strong>Column</strong> the left column of the comment (i.e., the column
of the comment-introducing <strong>%</strong> character).
<strong>Indent</strong> is the indentation (or padding), measured in
character positions between the last non-whitespace character before
the comment (or the left margin), and the left column of the comment.
<strong>Line</strong> and <strong>Column</strong> are always positive
integers, and <strong>Indentation</strong> is a nonnegative integer.</p><p>Evaluation exits with reason <strong>{read, Reason}</strong> if a read
error occurred, where <strong>Reason</strong> is an atom corresponding to
a Posix error code; see the module <a href="./file">file(3)</a> for details.</p><h4>join_lines(Lines::[CommentLine]) -&gt; [Comment]</h4><p>Joins individual comment lines into multi-line comments.</p><ul><li><span class="v">CommentLine = {Line, Column, Indent, string()}</span></li><li><span class="v">Line = integer()</span></li><li><span class="v">Column = integer()</span></li><li><span class="v">Indent = integer()</span></li><li><span class="v">Comment = {Line, Column, Indent, Text}</span></li><li><span class="v">Text = [string()]</span></li></ul><a name="join_lines-1"></a><p>Joins individual comment lines into multi-line comments. The
input is a list of entries representing individual comment lines,
<em>in order of decreasing line-numbers</em>; see
<a href="#scan_lines-1">scan_lines/1</a> for details. The result is a list of
entries representing <em>multi-line</em> comments, <em>still listed in order of decreasing line-numbers</em>, but where for each entry,
<strong>Text</strong> is a list of consecutive comment lines in order of
<em>increasing</em> line-numbers (i.e., top-down).
</p><p><em>See also:</em> <a href="#scan_lines-1">scan_lines/1</a>.</p><h4>scan_lines(Text::string()) -&gt; [CommentLine]</h4><p>Extracts individual comment lines from a source code string.</p><ul><li><span class="v">CommentLine = {Line, Column, Indent, Text}</span></li><li><span class="v">Line = integer()</span></li><li><span class="v">Column = integer()</span></li><li><span class="v">Indent = integer()</span></li><li><span class="v">Text = string()</span></li></ul><a name="scan_lines-1"></a><p>Extracts individual comment lines from a source code string.
Returns a list of comment lines found in the text, listed in order of
<em>decreasing</em> line-numbers, i.e., the last comment line in the
input is first in the resulting list. <strong>Text</strong> is a single
string, containing all characters following (but not including) the
first comment-introducing <strong>%</strong> character on the line, up
to (but not including) the line-terminating newline. For details on
<strong>Line</strong>, <strong>Column</strong> and <strong>Indent</strong>, see <a href="#file-1">file/1</a>.</p><h4>string(Text::string()) -&gt; [Comment]</h4><p>Extracts comments from a string containing Erlang source code.</p><ul><li><span class="v">Comment = {Line, Column, Indentation, Text}</span></li><li><span class="v">Line = integer()</span></li><li><span class="v">Column = integer()</span></li><li><span class="v">Indentation = integer()</span></li><li><span class="v">Text = [string()]</span></li></ul><a name="string-1"></a><p>Extracts comments from a string containing Erlang source code.
Except for reading directly from a string, the behaviour is the same
as for <a href="#file-1">file/1</a>.
</p><p><em>See also:</em> <a href="#file-1">file/1</a>.</p><h3>Authors</h3><span class="aname">Richard Carlsson</span><span class="email">carlsson.richard@gmail.com</span><h3>erl_prettypr</h3><p>Pretty printing of abstract Erlang syntax trees.</p><p>Pretty printing of abstract Erlang syntax trees.This module is a front end to the pretty-printing library module
<strong>prettypr</strong>, for text formatting of abstract syntax trees defined by
the module <strong>erl_syntax</strong>.</p><h4>DATA TYPES</h4><a name="types"></a><dl><dt><a name="type-context"></a>context()</dt><dd> <p>A representation of the current context of the
pretty-printer. Can be accessed in hook functions.
</p> </dd><dt><a name="type-hook"></a>hook() = (<a href="#type-syntaxTree">syntaxTree()</a>, <a href="#type-context">context()</a>, Continuation) -&gt; <a href="./prettypr#type-document">prettypr:document()</a></dt><dd> <ul><li><p>Continuation = (<a href="#type-syntaxTree">syntaxTree()</a>, <a href="#type-context">context()</a>) -&gt; <a href="./prettypr#type-document">prettypr:document()</a></p></li></ul> <p>A call-back function for user-controlled formatting. See <a href="#format-2">format/2</a>.
</p> </dd><dt><a name="type-syntaxTree"></a>syntaxTree() = <a href="./erl_syntax#type-syntaxTree">erl_syntax:syntaxTree()</a></dt><dd> <p>An abstract syntax tree. See the <a href="erl_syntax">erl_syntax</a> module for
details.
</p> </dd></dl><h3>Functions</h3><h4>best(Tree::) -&gt; empty |</h4><p>Equivalent to best(Tree, []). </p><a name="best-1"></a><p>Equivalent to <a href="#best-2">best(Tree, [])</a>.</p><h4>best(Tree::, Options::[term()]) -&gt; empty |</h4><p>Creates a fixed "best" abstract layout for a syntax tree.</p><a name="best-2"></a><p>Creates a fixed "best" abstract layout for a syntax tree. This
is similar to the <strong>layout/2</strong> function, except that here, the final
layout has been selected with respect to the given options. The atom
<strong>empty</strong> is returned if no such layout could be produced. For
information on the options, see the <strong>format/2</strong> function.
</p><p><em>See also:</em> <a href="#best-1">best/1</a>, <a href="#format-2">format/2</a>, <a href="#layout-2">layout/2</a>, <a href="./prettypr#best-3">prettypr:best/3</a>.</p><h4>format(Tree::) -&gt; string()</h4><p>Equivalent to format(Tree, []). </p><a name="format-1"></a><p>Equivalent to <a href="#format-2">format(Tree, [])</a>.</p><h4>format(Tree::, Options::[term()]) -&gt; string()</h4><p>Prettyprint-formats an abstract Erlang syntax tree as text.</p><a name="format-2"></a><p>Prettyprint-formats an abstract Erlang syntax tree as text. For
example, if you have a <strong>.beam</strong> file that has been compiled with
<strong>debug_info</strong>, the following should print the source code for the
module (as it looks in the debug info representation):
</p><pre>     {ok,{_,[{abstract_code,{_,AC}}]}} =
             beam_lib:chunks("myfile.beam",[abstract_code]),
     io:put_chars(erl_prettypr:format(erl_syntax:form_list(AC)))</pre><p>
Available options:
</p><dl><dt>{hook, none | <a href="#type-hook">hook()</a>}</dt><dd><p>Unless the value is <strong>none</strong>, the given function is called
for each node whose list of annotations is not empty; see below
for details. The default value is <strong>none</strong>.</p></dd><dt>{paper, integer()}</dt><dd><p>Specifies the preferred maximum number of characters on any
line, including indentation. The default value is 80.</p></dd><dt>{ribbon, integer()}</dt><dd><p>Specifies the preferred maximum number of characters on any
line, not counting indentation. The default value is 65.</p></dd><dt>{user, term()}</dt><dd><p>User-specific data for use in hook functions. The default
value is <strong>undefined</strong>.</p></dd><dt>{encoding, epp:source_encoding()}</dt><dd><p>Specifies the encoding of the generated file.</p></dd></dl><p>
A hook function (cf. the <a href="#type-hook">hook()</a> type) is passed the current
syntax tree node, the context, and a continuation. The context can be
examined and manipulated by functions such as <strong>get_ctxt_user/1</strong> and
<strong>set_ctxt_user/2</strong>. The hook must return a "document" data structure
(see <a href="#layout-2">layout/2</a> and <a href="#best-2">best/2</a>); this may be constructed in
part or in whole by applying the continuation function. For example,
the following is a trivial hook:
</p><pre>      fun (Node, Ctxt, Cont) -&gt; Cont(Node, Ctxt) end</pre><p>
which yields the same result as if no hook was given.
The following, however:
</p><pre>      fun (Node, Ctxt, Cont) -&gt;
          Doc = Cont(Node, Ctxt),
          prettypr:beside(prettypr:text("&lt;b&gt;"),
                          prettypr:beside(Doc,
                                          prettypr:text("&lt;/b&gt;")))
      end</pre><p>
will place the text of any annotated node (regardless of the
annotation data) between HTML "boldface begin" and "boldface end"
tags.
</p><p><em>See also:</em> <a href="erl_syntax">erl_syntax</a>, <a href="#best-2">best/2</a>, <a href="#format-1">format/1</a>, <a href="#get_ctxt_user-1">get_ctxt_user/1</a>, <a href="#layout-2">layout/2</a>, <a href="#set_ctxt_user-2">set_ctxt_user/2</a>.</p><h4>get_ctxt_hook(Ctxt::) -&gt;</h4><p>Returns the hook function field of the prettyprinter context.</p><a name="get_ctxt_hook-1"></a><p>Returns the hook function field of the prettyprinter context.</p><p><em>See also:</em> <a href="#set_ctxt_hook-2">set_ctxt_hook/2</a>.</p><h4>get_ctxt_linewidth(Ctxt::) -&gt; integer()</h4><p>Returns the line widh field of the prettyprinter context.</p><a name="get_ctxt_linewidth-1"></a><p>Returns the line widh field of the prettyprinter context.</p><p><em>See also:</em> <a href="#set_ctxt_linewidth-2">set_ctxt_linewidth/2</a>.</p><h4>get_ctxt_paperwidth(Ctxt::) -&gt; integer()</h4><p>Returns the paper widh field of the prettyprinter context.</p><a name="get_ctxt_paperwidth-1"></a><p>Returns the paper widh field of the prettyprinter context.</p><p><em>See also:</em> <a href="#set_ctxt_paperwidth-2">set_ctxt_paperwidth/2</a>.</p><h4>get_ctxt_precedence(Ctxt::) -&gt; integer()</h4><p>Returns the operator precedence field of the prettyprinter context.</p><a name="get_ctxt_precedence-1"></a><p>Returns the operator precedence field of the prettyprinter
context.
</p><p><em>See also:</em> <a href="#set_ctxt_precedence-2">set_ctxt_precedence/2</a>.</p><h4>get_ctxt_user(Ctxt::) -&gt; term()</h4><p>Returns the user data field of the prettyprinter context.</p><a name="get_ctxt_user-1"></a><p>Returns the user data field of the prettyprinter context.</p><p><em>See also:</em> <a href="#set_ctxt_user-2">set_ctxt_user/2</a>.</p><h4>layout(Tree::) -&gt;</h4><p>Equivalent to layout(Tree, []). </p><a name="layout-1"></a><p>Equivalent to <a href="#layout-2">layout(Tree, [])</a>.</p><h4>layout(Tree::, Options::[term()]) -&gt;</h4><p>Creates an abstract document layout for a syntax tree.</p><a name="layout-2"></a><p>Creates an abstract document layout for a syntax tree. The
result represents a set of possible layouts (cf. module <strong>prettypr</strong>).
For information on the options, see <a href="#format-2">format/2</a>; note, however,
that the <strong>paper</strong> and <strong>ribbon</strong> options are ignored by this function.</p><p>This function provides a low-level interface to the pretty printer,
returning a flexible representation of possible layouts, independent
of the paper width eventually to be used for formatting. This can be
included as part of another document and/or further processed
directly by the functions in the <strong>prettypr</strong> module, or used in a hook
function (see <strong>format/2</strong> for details).
</p><p><em>See also:</em> <a href="prettypr">prettypr</a>, <a href="#format-2">format/2</a>, <a href="#layout-1">layout/1</a>.</p><h4>set_ctxt_hook(Ctxt::, Hook::) -&gt;</h4><p>Updates the hook function field of the prettyprinter context.</p><a name="set_ctxt_hook-2"></a><p>Updates the hook function field of the prettyprinter context.</p><p><em>See also:</em> <a href="#get_ctxt_hook-1">get_ctxt_hook/1</a>.</p><h4>set_ctxt_linewidth(Ctxt::, W::integer()) -&gt;</h4><p>Updates the line widh field of the prettyprinter context.</p><a name="set_ctxt_linewidth-2"></a><p>Updates the line widh field of the prettyprinter context.</p><p>Note: changing this value (and passing the resulting context to a
continuation function) does not affect the normal formatting, but may
affect user-defined behaviour in hook functions.
</p><p><em>See also:</em> <a href="#get_ctxt_linewidth-1">get_ctxt_linewidth/1</a>.</p><h4>set_ctxt_paperwidth(Ctxt::, W::integer()) -&gt;</h4><p>Updates the paper widh field of the prettyprinter context.</p><a name="set_ctxt_paperwidth-2"></a><p>Updates the paper widh field of the prettyprinter context.</p><p>Note: changing this value (and passing the resulting context to a
continuation function) does not affect the normal formatting, but may
affect user-defined behaviour in hook functions.
</p><p><em>See also:</em> <a href="#get_ctxt_paperwidth-1">get_ctxt_paperwidth/1</a>.</p><h4>set_ctxt_precedence(Ctxt::, Prec::integer()) -&gt;</h4><p>Updates the operator precedence field of the prettyprinter context.</p><a name="set_ctxt_precedence-2"></a><p>Updates the operator precedence field of the prettyprinter
context. See the <a href="./erl_parse">erl_parse(3)</a> module for operator precedences.
</p><p><em>See also:</em> <a href="./erl_parse">erl_parse(3)</a>, <a href="#get_ctxt_precedence-1">get_ctxt_precedence/1</a>.</p><h4>set_ctxt_user(Ctxt::, X::term()) -&gt;</h4><p>Updates the user data field of the prettyprinter context.</p><a name="set_ctxt_user-2"></a><p>Updates the user data field of the prettyprinter context.</p><p><em>See also:</em> <a href="#get_ctxt_user-1">get_ctxt_user/1</a>.</p><h3>Authors</h3><span class="aname">Richard Carlsson</span><span class="email">carlsson.richard@gmail.com</span><h3>erl_recomment</h3><p>Inserting comments into abstract Erlang syntax trees.</p><p>Inserting comments into abstract Erlang syntax treesThis module contains functions for inserting comments, described
by position, indentation and text, as attachments on an abstract
syntax tree, at the correct places.</p><h4>DATA TYPES</h4><a name="types"></a><dl><dt><a name="type-syntaxTree"></a>syntaxTree() = <a href="./erl_syntax#type-syntaxTree">erl_syntax:syntaxTree()</a></dt><dd> <p>An abstract syntax
tree. See the <a href="erl_syntax">erl_syntax</a> module for details.</p> </dd></dl><h3>Functions</h3><h4>quick_recomment_forms(Tree::Forms, Comments::[Comment]) -&gt;</h4><p>Like recomment_forms/2, but only inserts top-level comments.</p><ul><li><span class="v">Forms =  | []</span></li><li><span class="v">Comment = {Line, Column, Indentation, Text}</span></li><li><span class="v">Line = integer()</span></li><li><span class="v">Column = integer()</span></li><li><span class="v">Indentation = integer()</span></li><li><span class="v">Text = [string()]</span></li></ul><a name="quick_recomment_forms-2"></a><p>Like <a href="#recomment_forms-2">recomment_forms/2</a>, but only inserts top-level
comments. Comments within function definitions or declarations
("forms") are simply ignored.</p><h4>recomment_forms(Tree::Forms, Comments::[Comment]) -&gt;</h4><p>Attaches comments to the syntax tree/trees representing a program.</p><ul><li><span class="v">Forms =  | []</span></li><li><span class="v">Comment = {Line, Column, Indentation, Text}</span></li><li><span class="v">Line = integer()</span></li><li><span class="v">Column = integer()</span></li><li><span class="v">Indentation = integer()</span></li><li><span class="v">Text = [string()]</span></li></ul><a name="recomment_forms-2"></a><p>Attaches comments to the syntax tree/trees representing a
program. The given <strong>Forms</strong> should be a single syntax tree
of type <strong>form_list</strong>, or a list of syntax trees
representing "program forms". The syntax trees must contain valid
position information (for details, see
<strong>recomment_tree/2</strong>). The result is a corresponding syntax
tree of type <strong>form_list</strong> in which all comments in the list
<strong>Comments</strong> have been attached at the proper places.</p><p>Assuming <strong>Forms</strong> represents a program (or any sequence
of "program forms"), any comments whose first lines are not directly
associated with a specific program form will become standalone
comments inserted between the neighbouring program forms.
Furthermore, comments whose column position is less than or equal to
one will not be attached to a program form that begins at a
conflicting line number (this can happen with preprocessor-generated
<strong>line</strong>-attributes).</p><p>If <strong>Forms</strong> is a syntax tree of some other type than
<strong>form_list</strong>, the comments will be inserted directly using
<strong>recomment_tree/2</strong>, and any comments left over from that
process are added as postcomments on the result.</p><p>Entries in <strong>Comments</strong> represent multi-line comments.
For each entry, <strong>Line</strong> is the line number and
<strong>Column</strong> the left column of the comment (the column of the
first comment-introducing "<strong>%</strong>" character).
<strong>Indentation</strong> is the number of character positions between
the last non-whitespace character before the comment (or the left
margin) and the left column of the comment. <strong>Text</strong> is a
list of strings representing the consecutive comment lines in
top-down order, where each string contains all characters following
(but not including) the comment-introducing "<strong>%</strong>" and up
to (but not including) the terminating newline. (Cf. module
<strong>erl_comment_scan</strong>.)</p><p>Evaluation exits with reason <strong>{bad_position, Pos}</strong> if
the associated position information <strong>Pos</strong> of some subtree
in the input does not have a recognizable format, or with reason
<strong>{bad_tree, L, C}</strong> if insertion of a comment at line
<strong>L</strong>, column <strong>C</strong>, fails because the tree
structure is ill-formed.</p><p><em>See also:</em> <a href="erl_comment_scan">erl_comment_scan</a>, <a href="#quick_recomment_forms-2">quick_recomment_forms/2</a>, <a href="#recomment_tree-2">recomment_tree/2</a>.</p><h4>recomment_tree(Tree::, Comments::[Comment]) -&gt; {, [Comment]}</h4><p>Attaches comments to a syntax tree.</p><ul><li><span class="v">Comment = {Line, Column, Indentation, Text}</span></li><li><span class="v">Line = integer()</span></li><li><span class="v">Column = integer()</span></li><li><span class="v">Indentation = integer()</span></li><li><span class="v">Text = [string()]</span></li></ul><a name="recomment_tree-2"></a><p>Attaches comments to a syntax tree. The result is a pair
<strong>{NewTree, Remainder}</strong> where <strong>NewTree</strong> is the
given <strong>Tree</strong> where comments from the list
<strong>Comments</strong> have been attached at the proper places.
<strong>Remainder</strong> is the list of entries in
<strong>Comments</strong> which have not been inserted, because their
line numbers are greater than those of any node in the tree. The
entries in <strong>Comments</strong> are inserted in order; if two  
comments become attached to the same node, they will appear in the  
same order in the program text.</p><p>The nodes of the syntax tree must contain valid position
information. This can be single integers, assumed to represent a line
number, or 2- or 3-tuples where the first or second element is an
integer, in which case the leftmost integer element is assumed to
represent the line number. Line numbers less than one are ignored
(usually, the default line number for newly created nodes is
zero).</p><p>For details on the <strong>Line</strong>, <strong>Column</strong> and
<strong>Indentation</strong> fields, and the behaviour in case of errors,
see <strong>recomment_forms/2</strong>.</p><p><em>See also:</em> <a href="#recomment_forms-2">recomment_forms/2</a>.</p><h3>Authors</h3><span class="aname">Richard Carlsson</span><span class="email">carlsson.richard@gmail.com</span><h3>erl_syntax</h3><p>Abstract Erlang syntax trees.</p><p>Abstract Erlang syntax trees.This module defines an abstract data type for representing Erlang
source code as syntax trees, in a way that is backwards compatible
with the data structures created by the Erlang standard library
parser module <strong>erl_parse</strong> (often referred to as "parse
trees", which is a bit of a misnomer). This means that all
<strong>erl_parse</strong> trees are valid abstract syntax trees, but the
reverse is not true: abstract syntax trees can in general not be used
as input to functions expecting an <strong>erl_parse</strong> tree.
However, as long as an abstract syntax tree represents a correct
Erlang program, the function <a href="#revert-1">revert/1</a> should be able to
transform it to the corresponding <strong>erl_parse</strong>  
representation.A recommended starting point for the first-time user is the documentation
of the <a href="#type-syntaxTree">syntaxTree()</a> data type, and the function <a href="#type-1">type/1</a>.<a name="NOTES:"></a><em>NOTES:</em>This module deals with the composition and decomposition of
<em>syntactic</em> entities (as opposed to semantic ones); its  
purpose is to hide all direct references to the data structures used  
to represent these entities. With few exceptions, the functions in  
this module perform no semantic interpretation of their inputs, and  
in general, the user is assumed to pass type-correct arguments - if  
this is not done, the effects are not defined.With the exception of the <a href="#type-erl_parse">erl_parse()</a> data structures,
the internal representations of abstract syntax trees are subject to
change without notice, and should not be documented outside this
module. Furthermore, we do not give any guarantees on how an abstract
syntax tree may or may not be represented, <em>with the following exceptions</em>: no syntax tree is represented by a single atom, such
as <strong>none</strong>, by a list constructor <strong>[X | Y]</strong>, or
by the empty list <strong>[]</strong>. This can be relied on when writing
functions that operate on syntax trees.</p><h4>DATA TYPES</h4><a name="types"></a><dl><dt><a name="type-encoding"></a>encoding() = utf8 | unicode | latin1</dt><dd> </dd><dt><a name="type-erl_parse"></a>erl_parse() = <a href="./erl_parse#type-abstract_clause">erl_parse:abstract_clause()</a> | <a href="./erl_parse#type-abstract_expr">erl_parse:abstract_expr()</a> | <a href="./erl_parse#type-abstract_form">erl_parse:abstract_form()</a> | <a href="./erl_parse#type-abstract_type">erl_parse:abstract_type()</a> | <a href="./erl_parse#type-form_info">erl_parse:form_info()</a> | {bin_element, term(), term(), term(), term()}</dt><dd> </dd><dt><a name="type-forms"></a>forms() = <a href="#type-syntaxTree">syntaxTree()</a> | [<a href="#type-syntaxTree">syntaxTree()</a>]</dt><dd> </dd><dt><a name="type-guard"></a>guard() = none | <a href="#type-syntaxTree">syntaxTree()</a> | [<a href="#type-syntaxTree">syntaxTree()</a>] | [[<a href="#type-syntaxTree">syntaxTree()</a>]]</dt><dd> </dd><dt><a name="type-padding"></a>padding() = none | integer()</dt><dd> </dd><dt><a name="type-syntaxTree"></a>syntaxTree()</dt><dd> <p>An abstract syntax tree. The <a href="#type-erl_parse">erl_parse()</a>
"parse tree" representation is a proper subset of the <strong>syntaxTree()</strong>  
representation.</p> <p>Every abstract syntax tree node has a <em>type</em>, given by the
function <a href="#type-1">type/1</a>. Each node also has associated
<em>attributes</em>; see <a href="#get_attrs-1">get_attrs/1</a> for details. The functions
<a href="#make_tree-2">make_tree/2</a> and <a href="#subtrees-1">subtrees/1</a> are generic
constructor/decomposition functions for abstract syntax trees. The
functions <a href="#abstract-1">abstract/1</a> and <a href="#concrete-1">concrete/1</a> convert between
constant Erlang terms and their syntactic representations. The set of
syntax tree nodes is extensible through the <a href="#tree-2">tree/2</a> function.</p> <p>A syntax tree can be transformed to the <a href="#type-erl_parse">erl_parse()</a>
representation with the <a href="#revert-1">revert/1</a> function.</p> </dd><dt><a name="type-syntaxTreeAttributes"></a>syntaxTreeAttributes()</dt><dd> <p>This is an abstract representation of
syntax tree node attributes; see the function <a href="#get_attrs-1">get_attrs/1</a>.
</p> </dd></dl><h3>Functions</h3><h4>abstract(T::term()) -&gt;</h4><p>Returns the syntax tree corresponding to an Erlang term.</p><a name="abstract-1"></a><p>Returns the syntax tree corresponding to an Erlang term.
<strong>Term</strong> must be a literal term, i.e., one that can be
represented as a source code literal. Thus, it may not contain a
process identifier, port, reference or function value as a
subterm. The function recognises printable strings, in order to get a
compact and readable representation. Evaluation fails with reason
<strong>badarg</strong> if <strong>Term</strong> is not a literal term.
</p><p><em>See also:</em> <a href="#concrete-1">concrete/1</a>, <a href="#is_literal-1">is_literal/1</a>.</p><h4>add_ann(A::term(), Node::) -&gt;</h4><p>Appends the term Annotation to the list of user annotations of Node.</p><a name="add_ann-2"></a><p>Appends the term <strong>Annotation</strong> to the list of user
annotations of <strong>Node</strong>.</p><p>Note: this is equivalent to <strong>set_ann(Node, [Annotation | get_ann(Node)])</strong>, but potentially more efficient.
</p><p><em>See also:</em> <a href="#get_ann-1">get_ann/1</a>, <a href="#set_ann-2">set_ann/2</a>.</p><h4>add_postcomments(Cs::[], Node::) -&gt;</h4><p>Appends Comments to the post-comments of Node.</p><a name="add_postcomments-2"></a><p>Appends <strong>Comments</strong> to the post-comments of <strong>Node</strong>.</p><p>Note: This is equivalent to <strong>set_postcomments(Node, get_postcomments(Node) ++ Comments)</strong>, but potentially more
efficient.
</p><p><em>See also:</em> <a href="#add_precomments-2">add_precomments/2</a>, <a href="#comment-2">comment/2</a>, <a href="#get_postcomments-1">get_postcomments/1</a>, <a href="#join_comments-2">join_comments/2</a>, <a href="#set_postcomments-2">set_postcomments/2</a>.</p><h4>add_precomments(Cs::[], Node::) -&gt;</h4><p>Appends Comments to the pre-comments of Node.</p><a name="add_precomments-2"></a><p>Appends <strong>Comments</strong> to the pre-comments of <strong>Node</strong>.</p><p>Note: This is equivalent to <strong>set_precomments(Node, get_precomments(Node) ++ Comments)</strong>, but potentially more
efficient.
</p><p><em>See also:</em> <a href="#add_postcomments-2">add_postcomments/2</a>, <a href="#comment-2">comment/2</a>, <a href="#get_precomments-1">get_precomments/1</a>, <a href="#join_comments-2">join_comments/2</a>, <a href="#set_precomments-2">set_precomments/2</a>.</p><h4>annotated_type(Name::, Type::) -&gt;</h4><p>Creates an abstract annotated type expression.</p><a name="annotated_type-2"></a><p>Creates an abstract annotated type expression. The result
represents "<strong>Name :: Type</strong>".
</p><p><em>See also:</em> <a href="#annotated_type_body-1">annotated_type_body/1</a>, <a href="#annotated_type_name-1">annotated_type_name/1</a>.</p><h4>annotated_type_body(Node::) -&gt;</h4><p>Returns the type subtrees of an annotated_type node.</p><a name="annotated_type_body-1"></a><p>Returns the type subtrees of an <strong>annotated_type</strong> node.
</p><p><em>See also:</em> <a href="#annotated_type-2">annotated_type/2</a>.</p><h4>annotated_type_name(Node::) -&gt;</h4><p>Returns the name subtree of an annotated_type node.</p><a name="annotated_type_name-1"></a><p>Returns the name subtree of an <strong>annotated_type</strong> node.
</p><p><em>See also:</em> <a href="#annotated_type-2">annotated_type/2</a>.</p><h4>application(Operator::, Arguments::[]) -&gt;</h4><p>Creates an abstract function application expression.</p><a name="application-2"></a><p>Creates an abstract function application expression. If
<strong>Arguments</strong> is <strong>[A1, ..., An]</strong>, the result
represents "<strong>Operator(A1, ..., An)</strong>".
</p><p><em>See also:</em> <a href="#application-3">application/3</a>, <a href="#application_arguments-1">application_arguments/1</a>, <a href="#application_operator-1">application_operator/1</a>.</p><h4>application(Module::none |, Name::, Arguments::[]) -&gt;</h4><p>Creates an abstract function application expression.</p><a name="application-3"></a><p>Creates an abstract function application expression. If
<strong>Module</strong> is <strong>none</strong>, this is call is equivalent
to <strong>application(Function, Arguments)</strong>, otherwise it is
equivalent to <strong>application(module_qualifier(Module, Function), Arguments)</strong>.</p><p>(This is a utility function.)
</p><p><em>See also:</em> <a href="#application-2">application/2</a>, <a href="#module_qualifier-2">module_qualifier/2</a>.</p><h4>application_arguments(Node::) -&gt; []</h4><p>Returns the list of argument subtrees of an application node.</p><a name="application_arguments-1"></a><p>Returns the list of argument subtrees of an
<strong>application</strong> node.
</p><p><em>See also:</em> <a href="#application-2">application/2</a>.</p><h4>application_operator(Node::) -&gt;</h4><p>Returns the operator subtree of an application node.</p><a name="application_operator-1"></a><p>Returns the operator subtree of an <strong>application</strong> node.</p><p>Note: if <strong>Node</strong> represents
"<strong>M:F(...)</strong>", then the result is the
subtree representing "<strong>M:F</strong>".
</p><p><em>See also:</em> <a href="#application-2">application/2</a>, <a href="#module_qualifier-2">module_qualifier/2</a>.</p><h4>arity_qualifier(Body::, Arity::) -&gt;</h4><p>Creates an abstract arity qualifier.</p><a name="arity_qualifier-2"></a><p>Creates an abstract arity qualifier. The result represents
"<strong>Body/Arity</strong>".
</p><p><em>See also:</em> <a href="#arity_qualifier_argument-1">arity_qualifier_argument/1</a>, <a href="#arity_qualifier_body-1">arity_qualifier_body/1</a>.</p><h4>arity_qualifier_argument(Node::) -&gt;</h4><p>Returns the argument (the arity) subtree of an arity_qualifier node.</p><a name="arity_qualifier_argument-1"></a><p>Returns the argument (the arity) subtree of an
<strong>arity_qualifier</strong> node.
</p><p><em>See also:</em> <a href="#arity_qualifier-2">arity_qualifier/2</a>.</p><h4>arity_qualifier_body(Node::) -&gt;</h4><p>Returns the body subtree of an arity_qualifier node.</p><a name="arity_qualifier_body-1"></a><p>Returns the body subtree of an <strong>arity_qualifier</strong> node.
</p><p><em>See also:</em> <a href="#arity_qualifier-2">arity_qualifier/2</a>.</p><h4>atom(Name::atom() | string()) -&gt;</h4><p>Creates an abstract atom literal.</p><a name="atom-1"></a><p>Creates an abstract atom literal. The print name of the atom is
the character sequence represented by <strong>Name</strong>.
</p><p><em>See also:</em> <a href="#atom_literal-1">atom_literal/1</a>, <a href="#atom_literal-2">atom_literal/2</a>, <a href="#atom_name-1">atom_name/1</a>, <a href="#atom_value-1">atom_value/1</a>, <a href="#is_atom-2">is_atom/2</a>.</p><h4>atom_literal(Node::) -&gt; string()</h4><p>Returns the literal string represented by an atom   node.</p><a name="atom_literal-1"></a><p>Returns the literal string represented by an <strong>atom</strong>  
node. This includes surrounding single-quote characters if necessary.  
Characters beyond 255 will be escaped.</p><p>Note that e.g. the result of <strong>atom("x\ny")</strong> represents
any and all of `x\ny'', `x\12y'',
`x\012y'' and `x\^Jy\''; see <a href="#string-1">string/1</a>.
</p><p><em>See also:</em> <a href="#atom-1">atom/1</a>, <a href="#string-1">string/1</a>.</p><h4>atom_literal(Node, X2) -&gt; term()
</h4><p>Returns the literal string represented by an atom node.</p><a name="atom_literal-2"></a><p>Returns the literal string represented by an <strong>atom</strong>
node. This includes surrounding single-quote characters if necessary.
Depending on the encoding a character beyond 255 will be escaped
(<strong>latin1</strong>) or copied as is (<strong>utf8</strong>).
</p><p><em>See also:</em> <a href="#atom-1">atom/1</a>, <a href="#atom_literal-1">atom_literal/1</a>, <a href="#string-1">string/1</a>.</p><h4>atom_name(Node::) -&gt; string()</h4><p>Returns the printname of an atom node.</p><a name="atom_name-1"></a><p>Returns the printname of an <strong>atom</strong> node.
</p><p><em>See also:</em> <a href="#atom-1">atom/1</a>.</p><h4>atom_value(Node::) -&gt; atom()</h4><p>Returns the value represented by an atom node.</p><a name="atom_value-1"></a><p>Returns the value represented by an <strong>atom</strong> node.
</p><p><em>See also:</em> <a href="#atom-1">atom/1</a>.</p><h4>attribute(Name::) -&gt;</h4><p>Equivalent to attribute(Name, none). </p><a name="attribute-1"></a><p>Equivalent to <a href="#attribute-2">attribute(Name, none)</a>.</p><h4>attribute(Name::, Args::none | []) -&gt;</h4><p>Creates an abstract program attribute.</p><a name="attribute-2"></a><p>Creates an abstract program attribute. If
<strong>Arguments</strong> is <strong>[A1, ..., An]</strong>, the result
represents "<strong>-Name(A1, ..., An).</strong>". Otherwise, if <strong>Arguments</strong> is
<strong>none</strong>, the result represents
"<strong>-Name.</strong>". The latter form makes it possible
to represent preprocessor directives such as
"<strong>-endif.</strong>". Attributes are source code forms.</p><p>Note: The preprocessor macro definition directive
"<strong>-define(Name, Body).</strong>" has relatively
few requirements on the syntactical form of <strong>Body</strong> (viewed
as a sequence of tokens). The <strong>text</strong> node type can be used
for a <strong>Body</strong> that is not a normal Erlang construct.
</p><p><em>See also:</em> <a href="#attribute-1">attribute/1</a>, <a href="#attribute_arguments-1">attribute_arguments/1</a>, <a href="#attribute_name-1">attribute_name/1</a>, <a href="#is_form-1">is_form/1</a>, <a href="#text-1">text/1</a>.</p><h4>attribute_arguments(Node::) -&gt; none | []</h4><p>Returns the list of argument subtrees of an attribute node, if any.</p><a name="attribute_arguments-1"></a><p>Returns the list of argument subtrees of an
<strong>attribute</strong> node, if any. If <strong>Node</strong>
represents "<strong>-Name.</strong>", the result is
<strong>none</strong>. Otherwise, if <strong>Node</strong> represents
"<strong>-Name(E1, ..., En).</strong>",
<strong>[E1, ..., E1]</strong> is returned.
</p><p><em>See also:</em> <a href="#attribute-1">attribute/1</a>.</p><h4>attribute_name(Node::) -&gt;</h4><p>Returns the name subtree of an attribute node.</p><a name="attribute_name-1"></a><p>Returns the name subtree of an <strong>attribute</strong> node.
</p><p><em>See also:</em> <a href="#attribute-1">attribute/1</a>.</p><h4>binary(List::[]) -&gt;</h4><p>Creates an abstract binary-object template.</p><a name="binary-1"></a><p>Creates an abstract binary-object template. If
<strong>Fields</strong> is <strong>[F1, ..., Fn]</strong>, the result
represents "<strong>&lt;&lt;F1, ..., Fn&gt;&gt;</strong>".
</p><p><em>See also:</em> <a href="#binary_field-2">binary_field/2</a>, <a href="#binary_fields-1">binary_fields/1</a>.</p><h4>binary_comp(Template::, Body::[]) -&gt;</h4><p>Creates an abstract binary comprehension.</p><a name="binary_comp-2"></a><p>Creates an abstract binary comprehension. If <strong>Body</strong> is
<strong>[E1, ..., En]</strong>, the result represents
"<strong>&lt;&lt;Template || E1, ..., En&gt;&gt;</strong>".
</p><p><em>See also:</em> <a href="#binary_comp_body-1">binary_comp_body/1</a>, <a href="#binary_comp_template-1">binary_comp_template/1</a>, <a href="#generator-2">generator/2</a>.</p><h4>binary_comp_body(Node::) -&gt; []</h4><p>Returns the list of body subtrees of a binary_comp node.</p><a name="binary_comp_body-1"></a><p>Returns the list of body subtrees of a <strong>binary_comp</strong> node.
</p><p><em>See also:</em> <a href="#binary_comp-2">binary_comp/2</a>.</p><h4>binary_comp_template(Node::) -&gt;</h4><p>Returns the template subtree of a binary_comp node.</p><a name="binary_comp_template-1"></a><p>Returns the template subtree of a <strong>binary_comp</strong> node.
</p><p><em>See also:</em> <a href="#binary_comp-2">binary_comp/2</a>.</p><h4>binary_field(Body::) -&gt;</h4><p>Equivalent to binary_field(Body, []). </p><a name="binary_field-1"></a><p>Equivalent to <a href="#binary_field-2">binary_field(Body, [])</a>.</p><h4>binary_field(Body::, Types::[]) -&gt;</h4><p>Creates an abstract binary template field.</p><a name="binary_field-2"></a><p>Creates an abstract binary template field. If
<strong>Types</strong> is the empty list, the result simply represents
"<strong>Body</strong>", otherwise, if <strong>Types</strong> is
<strong>[T1, ..., Tn]</strong>, the result represents
"<strong>Body/T1-...-Tn</strong>".
</p><p><em>See also:</em> <a href="#binary-1">binary/1</a>, <a href="#binary_field-1">binary_field/1</a>, <a href="#binary_field-3">binary_field/3</a>, <a href="#binary_field_body-1">binary_field_body/1</a>, <a href="#binary_field_size-1">binary_field_size/1</a>, <a href="#binary_field_types-1">binary_field_types/1</a>.</p><h4>binary_field(Body::, Size::none |, Types::[]) -&gt;</h4><p>Creates an abstract binary template field.</p><a name="binary_field-3"></a><p>Creates an abstract binary template field.
If <strong>Size</strong> is <strong>none</strong>, this is equivalent to
"<strong>binary_field(Body, Types)</strong>", otherwise it is
equivalent to "<strong>binary_field(size_qualifier(Body, Size), Types)</strong>".</p><p>(This is a utility function.)
</p><p><em>See also:</em> <a href="#binary-1">binary/1</a>, <a href="#binary_field-2">binary_field/2</a>, <a href="#size_qualifier-2">size_qualifier/2</a>.</p><h4>binary_field_body(Node::) -&gt;</h4><p>Returns the body subtree of a binary_field.</p><a name="binary_field_body-1"></a><p>Returns the body subtree of a <strong>binary_field</strong>.
</p><p><em>See also:</em> <a href="#binary_field-2">binary_field/2</a>.</p><h4>binary_field_size(Node::) -&gt; none |</h4><p>Returns the size specifier subtree of a binary_field node, if any.</p><a name="binary_field_size-1"></a><p>Returns the size specifier subtree of a
<strong>binary_field</strong> node, if any. If <strong>Node</strong>
represents "<strong>Body:Size</strong>" or
"<strong>Body:Size/T1, ..., Tn</strong>", the result is <strong>Size</strong>, otherwise
<strong>none</strong> is returned.</p><p>(This is a utility function.)
</p><p><em>See also:</em> <a href="#binary_field-2">binary_field/2</a>, <a href="#binary_field-3">binary_field/3</a>.</p><h4>binary_field_types(Node::) -&gt; []</h4><p>Returns the list of type-specifier subtrees of a binary_field node.</p><a name="binary_field_types-1"></a><p>Returns the list of type-specifier subtrees of a
<strong>binary_field</strong> node. If <strong>Node</strong> represents
"<strong>.../T1, ..., Tn</strong>", the result is
<strong>[T1, ..., Tn]</strong>, otherwise the result is the empty list.
</p><p><em>See also:</em> <a href="#binary_field-2">binary_field/2</a>.</p><h4>binary_fields(Node::) -&gt; []</h4><p>Returns the list of field subtrees of a binary node.</p><a name="binary_fields-1"></a><p>Returns the list of field subtrees of a <strong>binary</strong> node.
</p><p><em>See also:</em> <a href="#binary-1">binary/1</a>, <a href="#binary_field-2">binary_field/2</a>.</p><h4>binary_generator(Pattern::, Body::) -&gt;</h4><p>Creates an abstract binary_generator.</p><a name="binary_generator-2"></a><p>Creates an abstract binary_generator. The result represents
"<strong>Pattern &lt;- Body</strong>".
</p><p><em>See also:</em> <a href="#binary_comp-2">binary_comp/2</a>, <a href="#binary_generator_body-1">binary_generator_body/1</a>, <a href="#binary_generator_pattern-1">binary_generator_pattern/1</a>, <a href="#list_comp-2">list_comp/2</a>.</p><h4>binary_generator_body(Node::) -&gt;</h4><p>Returns the body subtree of a generator node.</p><a name="binary_generator_body-1"></a><p>Returns the body subtree of a <strong>generator</strong> node.
</p><p><em>See also:</em> <a href="#binary_generator-2">binary_generator/2</a>.</p><h4>binary_generator_pattern(Node::) -&gt;</h4><p>Returns the pattern subtree of a generator node.</p><a name="binary_generator_pattern-1"></a><p>Returns the pattern subtree of a <strong>generator</strong> node.
</p><p><em>See also:</em> <a href="#binary_generator-2">binary_generator/2</a>.</p><h4>bitstring_type(M::, N::) -&gt;</h4><p>Creates an abstract bitstring type.</p><a name="bitstring_type-2"></a><p>Creates an abstract bitstring type. The result represents
"<strong>&lt;&lt;_:M, _:_*N&gt;&gt;</strong>".
</p><p><em>See also:</em> <a href="#bitstring_type_m-1">bitstring_type_m/1</a>, <a href="#bitstring_type_n-1">bitstring_type_n/1</a>.</p><h4>bitstring_type_m(Node::) -&gt;</h4><p>Returns the number of start bits, M,  of a bitstring_type node.</p><a name="bitstring_type_m-1"></a><p>Returns the number of start bits, <strong>M</strong>,  of a <strong>bitstring_type</strong> node.
</p><p><em>See also:</em> <a href="#bitstring_type-2">bitstring_type/2</a>.</p><h4>bitstring_type_n(Node::) -&gt;</h4><p>Returns the segment size, N, of a bitstring_type node.</p><a name="bitstring_type_n-1"></a><p>Returns the segment size, <strong>N</strong>, of a <strong>bitstring_type</strong> node.
</p><p><em>See also:</em> <a href="#bitstring_type-2">bitstring_type/2</a>.</p><h4>block_expr(Body::[]) -&gt;</h4><p>Creates an abstract block expression.</p><a name="block_expr-1"></a><p>Creates an abstract block expression. If <strong>Body</strong> is
<strong>[B1, ..., Bn]</strong>, the result represents "<strong>begin B1, ..., Bn end</strong>".
</p><p><em>See also:</em> <a href="#block_expr_body-1">block_expr_body/1</a>.</p><h4>block_expr_body(Node::) -&gt; []</h4><p>Returns the list of body subtrees of a block_expr node.</p><a name="block_expr_body-1"></a><p>Returns the list of body subtrees of a <strong>block_expr</strong> node.
</p><p><em>See also:</em> <a href="#block_expr-1">block_expr/1</a>.</p><h4>case_expr(Argument::, Clauses::[]) -&gt;</h4><p>Creates an abstract case-expression.</p><a name="case_expr-2"></a><p>Creates an abstract case-expression. If <strong>Clauses</strong> is
<strong>[C1, ..., Cn]</strong>, the result represents "<strong>case Argument of C1; ...; Cn end</strong>". More
exactly, if each <strong>Ci</strong> represents "<strong>(Pi) Gi -&gt; Bi</strong>", then the result represents
"<strong>case Argument of P1 G1 -&gt; B1; ...; Pn Gn -&gt; Bn end</strong>".
</p><p><em>See also:</em> <a href="#case_expr_argument-1">case_expr_argument/1</a>, <a href="#case_expr_clauses-1">case_expr_clauses/1</a>, <a href="#clause-3">clause/3</a>, <a href="#cond_expr-1">cond_expr/1</a>, <a href="#if_expr-1">if_expr/1</a>.</p><h4>case_expr_argument(Node::) -&gt;</h4><p>Returns the argument subtree of a case_expr node.</p><a name="case_expr_argument-1"></a><p>Returns the argument subtree of a <strong>case_expr</strong> node.
</p><p><em>See also:</em> <a href="#case_expr-2">case_expr/2</a>.</p><h4>case_expr_clauses(Node::) -&gt; []</h4><p>Returns the list of clause subtrees of a case_expr node.</p><a name="case_expr_clauses-1"></a><p>Returns the list of clause subtrees of a <strong>case_expr</strong> node.
</p><p><em>See also:</em> <a href="#case_expr-2">case_expr/2</a>.</p><h4>catch_expr(Expr::) -&gt;</h4><p>Creates an abstract catch-expression.</p><a name="catch_expr-1"></a><p>Creates an abstract catch-expression. The result represents
"<strong>catch Expr</strong>".
</p><p><em>See also:</em> <a href="#catch_expr_body-1">catch_expr_body/1</a>.</p><h4>catch_expr_body(Node::) -&gt;</h4><p>Returns the body subtree of a catch_expr node.</p><a name="catch_expr_body-1"></a><p>Returns the body subtree of a <strong>catch_expr</strong> node.
</p><p><em>See also:</em> <a href="#catch_expr-1">catch_expr/1</a>.</p><h4>char(Char::char()) -&gt;</h4><p>Creates an abstract character literal.</p><a name="char-1"></a><p>Creates an abstract character literal. The result represents
"<strong>$Name</strong>", where <strong>Name</strong> corresponds to
<strong>Value</strong>.</p><p>Note: the literal corresponding to a particular character value is
not uniquely defined. E.g., the character "<strong>a</strong>" can be
written both as "<strong>$a</strong>" and "<strong>$\141</strong>", and a Tab
character can be written as "<strong>$\11</strong>", "<strong>$\011</strong>"
or "<strong>$\t</strong>".
</p><p><em>See also:</em> <a href="#char_literal-1">char_literal/1</a>, <a href="#char_literal-2">char_literal/2</a>, <a href="#char_value-1">char_value/1</a>, <a href="#is_char-2">is_char/2</a>.</p><h4>char_literal(Node::) -&gt; nonempty_string()</h4><p>Returns the literal string represented by a char node.</p><a name="char_literal-1"></a><p>Returns the literal string represented by a <strong>char</strong>
node. This includes the leading "<strong>$</strong>" character.
Characters beyond 255 will be escaped.
</p><p><em>See also:</em> <a href="#char-1">char/1</a>.</p><h4>char_literal(Node::, X2::) -&gt; nonempty_string()</h4><p>Returns the literal string represented by a char node.</p><a name="char_literal-2"></a><p>Returns the literal string represented by a <strong>char</strong>
node. This includes the leading "<strong>$</strong>" character.
Depending on the encoding a character beyond 255 will be escaped
(<strong>latin1</strong>) or copied as is (<strong>utf8</strong>).
</p><p><em>See also:</em> <a href="#char-1">char/1</a>.</p><h4>char_value(Node::) -&gt; char()</h4><p>Returns the value represented by a char node.</p><a name="char_value-1"></a><p>Returns the value represented by a <strong>char</strong> node.
</p><p><em>See also:</em> <a href="#char-1">char/1</a>.</p><h4>class_qualifier(Class::, Body::) -&gt;</h4><p>Creates an abstract class qualifier.</p><a name="class_qualifier-2"></a><p>Creates an abstract class qualifier. The result represents
"<strong>Class:Body</strong>".
</p><p><em>See also:</em> <a href="#class_qualifier_argument-1">class_qualifier_argument/1</a>, <a href="#class_qualifier_body-1">class_qualifier_body/1</a>, <a href="#class_qualifier_stacktrace-1">class_qualifier_stacktrace/1</a>, <a href="#try_expr-4">try_expr/4</a>.</p><h4>class_qualifier(Class::, Body::, Stacktrace::) -&gt;</h4><p>Creates an abstract class qualifier.</p><a name="class_qualifier-3"></a><p>Creates an abstract class qualifier. The result represents
"<strong>Class:Body:Stacktrace</strong>".
</p><p><em>See also:</em> <a href="#class_qualifier_argument-1">class_qualifier_argument/1</a>, <a href="#class_qualifier_body-1">class_qualifier_body/1</a>, <a href="#try_expr-4">try_expr/4</a>.</p><h4>class_qualifier_argument(Node::) -&gt;</h4><p>Returns the argument (the class) subtree of a class_qualifier node.</p><a name="class_qualifier_argument-1"></a><p>Returns the argument (the class) subtree of a
<strong>class_qualifier</strong> node.
</p><p><em>See also:</em> <a href="#class_qualifier-2">class_qualifier/2</a>.</p><h4>class_qualifier_body(Node::) -&gt;</h4><p>Returns the body subtree of a class_qualifier node.</p><a name="class_qualifier_body-1"></a><p>Returns the body subtree of a <strong>class_qualifier</strong> node.
</p><p><em>See also:</em> <a href="#class_qualifier-2">class_qualifier/2</a>.</p><h4>class_qualifier_stacktrace(Node::) -&gt;</h4><p>Returns the stacktrace subtree of a class_qualifier node.</p><a name="class_qualifier_stacktrace-1"></a><p>Returns the stacktrace subtree of a <strong>class_qualifier</strong> node.
</p><p><em>See also:</em> <a href="#class_qualifier-2">class_qualifier/2</a>.</p><h4>clause(Guard::, Body::[]) -&gt;</h4><p>Equivalent to clause([], Guard, Body). </p><a name="clause-2"></a><p>Equivalent to <a href="#clause-3">clause([], Guard, Body)</a>.</p><h4>clause(Patterns::[], Guard::, Body::[]) -&gt;</h4><p>Creates an abstract clause.</p><a name="clause-3"></a><p>Creates an abstract clause. If <strong>Patterns</strong> is
<strong>[P1, ..., Pn]</strong> and <strong>Body</strong> is <strong>[B1, ..., Bm]</strong>, then if <strong>Guard</strong> is <strong>none</strong>, the
result represents "<strong>(P1, ..., Pn) -&gt; B1, ..., Bm</strong>", otherwise, unless
<strong>Guard</strong> is a list, the result represents
"<strong>(P1, ..., Pn) when Guard -&gt; B1, ..., Bm</strong>".</p><p>For simplicity, the <strong>Guard</strong> argument may also be any
of the following:
</p><ul><li><p>An empty list <strong>[]</strong>. This is equivalent to passing
<strong>none</strong>.</p></li><li><p>A nonempty list <strong>[E1, ..., Ej]</strong> of syntax trees.
This is equivalent to passing <strong>conjunction([E1, ..., Ej])</strong>.</p></li><li><p>A nonempty list of lists of syntax trees <strong>[[E1_1, ..., E1_k1], ..., [Ej_1, ..., Ej_kj]]</strong>, which is equivalent
to passing <strong>disjunction([conjunction([E1_1, ..., E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])</strong>.</p></li></ul><p>
</p><p><em>See also:</em> <a href="#clause-2">clause/2</a>, <a href="#clause_body-1">clause_body/1</a>, <a href="#clause_guard-1">clause_guard/1</a>, <a href="#clause_patterns-1">clause_patterns/1</a>.</p><h4>clause_body(Node::) -&gt; []</h4><p>Return the list of body subtrees of a clause node.</p><a name="clause_body-1"></a><p>Return the list of body subtrees of a <strong>clause</strong> node.
</p><p><em>See also:</em> <a href="#clause-3">clause/3</a>.</p><h4>clause_guard(Node::) -&gt; none |</h4><p>Returns the guard subtree of a clause node, if any.</p><a name="clause_guard-1"></a><p>Returns the guard subtree of a <strong>clause</strong> node, if
any. If <strong>Node</strong> represents "<strong>(P1, ..., Pn) when Guard -&gt; B1, ..., Bm</strong>", <strong>Guard</strong> is returned. Otherwise, the
result is <strong>none</strong>.
</p><p><em>See also:</em> <a href="#clause-3">clause/3</a>.</p><h4>clause_patterns(Node::) -&gt; []</h4><p>Returns the list of pattern subtrees of a clause node.</p><a name="clause_patterns-1"></a><p>Returns the list of pattern subtrees of a <strong>clause</strong> node.
</p><p><em>See also:</em> <a href="#clause-3">clause/3</a>.</p><h4>comment(Strings::[string()]) -&gt;</h4><p>Equivalent to comment(none, Strings). </p><a name="comment-1"></a><p>Equivalent to <a href="#comment-2">comment(none, Strings)</a>.</p><h4>comment(Pad::, Strings::[string()]) -&gt;</h4><p>Creates an abstract comment with the given padding and text.</p><a name="comment-2"></a><p>Creates an abstract comment with the given padding and text. If
<strong>Strings</strong> is a (possibly empty) list
<strong>["Txt1", ..., "TxtN"]</strong>, the result
represents the source code text
</p><pre>
     %Txt1
     ...
     %TxtN</pre><p>
<strong>Padding</strong> states the number of empty character positions
to the left of the comment separating it horizontally from
source code on the same line (if any). If <strong>Padding</strong> is
<strong>none</strong>, a default positive number is used. If
<strong>Padding</strong> is an integer less than 1, there should be no
separating space. Comments are in themselves regarded as source
program forms.
</p><p><em>See also:</em> <a href="#comment-1">comment/1</a>, <a href="#is_form-1">is_form/1</a>.</p><h4>comment_padding(Node::) -&gt;</h4><p>Returns the amount of padding before the comment, or none.</p><a name="comment_padding-1"></a><p>Returns the amount of padding before the comment, or
<strong>none</strong>. The latter means that a default padding may be used.
</p><p><em>See also:</em> <a href="#comment-2">comment/2</a>.</p><h4>comment_text(Node::) -&gt; [string()]</h4><p>Returns the lines of text of the abstract comment.</p><a name="comment_text-1"></a><p>Returns the lines of text of the abstract comment.
</p><p><em>See also:</em> <a href="#comment-2">comment/2</a>.</p><h4>compact_list(Node::) -&gt;</h4><p>Yields the most compact form for an abstract list skeleton.</p><a name="compact_list-1"></a><p>Yields the most compact form for an abstract list skeleton. The
result either represents "<strong>[E1, ..., En | Tail]</strong>", where <strong>Tail</strong> is not a list
skeleton, or otherwise simply "<strong>[E1, ..., En]</strong>". Annotations on subtrees of <strong>Node</strong>
that represent list skeletons may be lost, but comments will be
propagated to the result. Returns <strong>Node</strong> itself if
<strong>Node</strong> does not represent a list skeleton.
</p><p><em>See also:</em> <a href="#list-2">list/2</a>, <a href="#normalize_list-1">normalize_list/1</a>.</p><h4>concrete(Node::) -&gt; term()</h4><p>Returns the Erlang term represented by a syntax tree.</p><a name="concrete-1"></a><p>Returns the Erlang term represented by a syntax tree. Evaluation
fails with reason <strong>badarg</strong> if <strong>Node</strong> does not  
represent a literal term.</p><p>Note: Currently, the set of syntax trees which have a concrete
representation is larger than the set of trees which can be built
using the function <a href="#abstract-1">abstract/1</a>. An abstract character
will be concretised as an integer, while <a href="#abstract-1">abstract/1</a> does
not at present yield an abstract character for any input. (Use the
<a href="#char-1">char/1</a> function to explicitly create an abstract  
character.)</p><p>Note: <strong>arity_qualifier</strong> nodes are recognized. This is to follow The
Erlang Parser when it comes to wild attributes: both {F, A} and F/A
are recognized, which makes it possible to turn wild attributes
into recognized attributes without at the same time making it
impossible to compile files using the new syntax with the old
version of the Erlang Compiler.
</p><p><em>See also:</em> <a href="#abstract-1">abstract/1</a>, <a href="#char-1">char/1</a>, <a href="#is_literal-1">is_literal/1</a>.</p><h4>cond_expr(Clauses::[]) -&gt;</h4><p>Creates an abstract cond-expression.</p><a name="cond_expr-1"></a><p>Creates an abstract cond-expression. If <strong>Clauses</strong> is
<strong>[C1, ..., Cn]</strong>, the result represents "<strong>cond C1; ...; Cn end</strong>". More exactly, if each
<strong>Ci</strong> represents "<strong>() Ei -&gt; Bi</strong>", then the result represents "<strong>cond E1 -&gt; B1; ...; En -&gt; Bn end</strong>".
</p><p><em>See also:</em> <a href="#case_expr-2">case_expr/2</a>, <a href="#clause-3">clause/3</a>, <a href="#cond_expr_clauses-1">cond_expr_clauses/1</a>.</p><h4>cond_expr_clauses(Node::) -&gt; []</h4><p>Returns the list of clause subtrees of a cond_expr node.</p><a name="cond_expr_clauses-1"></a><p>Returns the list of clause subtrees of a <strong>cond_expr</strong> node.
</p><p><em>See also:</em> <a href="#cond_expr-1">cond_expr/1</a>.</p><h4>conjunction(Tests::[]) -&gt;</h4><p>Creates an abstract conjunction.</p><a name="conjunction-1"></a><p>Creates an abstract conjunction. If <strong>List</strong> is
<strong>[E1, ..., En]</strong>, the result represents
"<strong>E1, ..., En</strong>".
</p><p><em>See also:</em> <a href="#conjunction_body-1">conjunction_body/1</a>, <a href="#disjunction-1">disjunction/1</a>.</p><h4>conjunction_body(Node::) -&gt; []</h4><p>Returns the list of body subtrees of a conjunction node.</p><a name="conjunction_body-1"></a><p>Returns the list of body subtrees of a
<strong>conjunction</strong> node.
</p><p><em>See also:</em> <a href="#conjunction-1">conjunction/1</a>.</p><h4>cons(Head::, Tail::) -&gt;</h4><p>"Optimising" list skeleton cons operation.</p><a name="cons-2"></a><p>"Optimising" list skeleton cons operation. Creates an abstract
list skeleton whose first element is <strong>Head</strong> and whose tail
corresponds to <strong>Tail</strong>. This is similar to
<strong>list([Head], Tail)</strong>, except that <strong>Tail</strong> may
not be <strong>none</strong>, and that the result does not necessarily
represent exactly "<strong>[Head | Tail]</strong>", but
may depend on the <strong>Tail</strong> subtree. E.g., if
<strong>Tail</strong> represents <strong>[X, Y]</strong>, the result may
represent "<strong>[Head, X, Y]</strong>", rather than
"<strong>[Head | [X, Y]]</strong>". Annotations on
<strong>Tail</strong> itself may be lost if <strong>Tail</strong> represents
a list skeleton, but comments on <strong>Tail</strong> are propagated to
the result.
</p><p><em>See also:</em> <a href="#list-2">list/2</a>, <a href="#list_head-1">list_head/1</a>, <a href="#list_tail-1">list_tail/1</a>.</p><h4>constrained_function_type(FunctionType::, FunctionConstraint::[]) -&gt;</h4><p>Creates an abstract constrained function type.</p><a name="constrained_function_type-2"></a><p>Creates an abstract constrained function type.
If <strong>FunctionConstraint</strong> is <strong>[C1, ..., Cn]</strong>, the result represents
"<strong>FunctionType when C1, ...Cn</strong>".
</p><p><em>See also:</em> <a href="#constrained_function_type_argument-1">constrained_function_type_argument/1</a>, <a href="#constrained_function_type_body-1">constrained_function_type_body/1</a>.</p><h4>constrained_function_type_argument(Node::) -&gt;</h4><p>Returns the function constraint subtree of a constrained_function_type node.</p><a name="constrained_function_type_argument-1"></a><p>Returns the function constraint subtree of a
<strong>constrained_function_type</strong> node.
</p><p><em>See also:</em> <a href="#constrained_function_type-2">constrained_function_type/2</a>.</p><h4>constrained_function_type_body(Node::) -&gt;</h4><p>Returns the function type subtree of a constrained_function_type node.</p><a name="constrained_function_type_body-1"></a><p>Returns the function type subtree of a
<strong>constrained_function_type</strong> node.
</p><p><em>See also:</em> <a href="#constrained_function_type-2">constrained_function_type/2</a>.</p><h4>constraint(Name::, Types::[]) -&gt;</h4><p>Creates an abstract (subtype) constraint.</p><a name="constraint-2"></a><p>Creates an abstract (subtype) constraint. The result represents
"<strong>Name :: Type</strong>".
</p><p><em>See also:</em> <a href="#constraint_argument-1">constraint_argument/1</a>, <a href="#constraint_body-1">constraint_body/1</a>.</p><h4>constraint_argument(Node::) -&gt;</h4><p>Returns the name subtree of a constraint node.</p><a name="constraint_argument-1"></a><p>Returns the name subtree of a <strong>constraint</strong> node.
</p><p><em>See also:</em> <a href="#constraint-2">constraint/2</a>.</p><h4>constraint_body(Node::) -&gt; []</h4><p>Returns the type subtree of a constraint node.</p><a name="constraint_body-1"></a><p>Returns the type subtree of a <strong>constraint</strong> node.
</p><p><em>See also:</em> <a href="#constraint-2">constraint/2</a>.</p><h4>copy_ann(Source::, Target::) -&gt;</h4><p>Copies the list of user annotations from Source to Target.</p><a name="copy_ann-2"></a><p>Copies the list of user annotations from <strong>Source</strong> to <strong>Target</strong>.</p><p>Note: this is equivalent to <strong>set_ann(Target, get_ann(Source))</strong>, but potentially more efficient.
</p><p><em>See also:</em> <a href="#get_ann-1">get_ann/1</a>, <a href="#set_ann-2">set_ann/2</a>.</p><h4>copy_attrs(S::, T::) -&gt;</h4><p>Copies the attributes from Source to Target.</p><a name="copy_attrs-2"></a><p>Copies the attributes from <strong>Source</strong> to <strong>Target</strong>.</p><p>Note: this is equivalent to <strong>set_attrs(Target, get_attrs(Source))</strong>, but potentially more efficient.
</p><p><em>See also:</em> <a href="#get_attrs-1">get_attrs/1</a>, <a href="#set_attrs-2">set_attrs/2</a>.</p><h4>copy_comments(Source::, Target::) -&gt;</h4><p>Copies the pre- and postcomments from Source to Target.</p><a name="copy_comments-2"></a><p>Copies the pre- and postcomments from <strong>Source</strong> to <strong>Target</strong>.</p><p>Note: This is equivalent to
<strong>set_postcomments(set_precomments(Target, get_precomments(Source)), get_postcomments(Source))</strong>, but
potentially more efficient.
</p><p><em>See also:</em> <a href="#comment-2">comment/2</a>, <a href="#get_postcomments-1">get_postcomments/1</a>, <a href="#get_precomments-1">get_precomments/1</a>, <a href="#set_postcomments-2">set_postcomments/2</a>, <a href="#set_precomments-2">set_precomments/2</a>.</p><h4>copy_pos(Source::, Target::) -&gt;</h4><p>Copies the position information from Source to Target.</p><a name="copy_pos-2"></a><p>Copies the position information from <strong>Source</strong> to <strong>Target</strong>.</p><p>This is equivalent to <strong>set_pos(Target, get_pos(Source))</strong>, but potentially more efficient.
</p><p><em>See also:</em> <a href="#get_pos-1">get_pos/1</a>, <a href="#set_pos-2">set_pos/2</a>.</p><h4>data(Tree::) -&gt; term()</h4><p>For special purposes only.</p><a name="data-1"></a><p><em>For special purposes only</em>. Returns the associated data
of a syntax tree node. Evaluation fails with reason
<strong>badarg</strong> if <strong>is_tree(Node)</strong> does not yield
<strong>true</strong>.
</p><p><em>See also:</em> <a href="#tree-2">tree/2</a>.</p><h4>disjunction(Tests::[]) -&gt;</h4><p>Creates an abstract disjunction.</p><a name="disjunction-1"></a><p>Creates an abstract disjunction. If <strong>List</strong> is
<strong>[E1, ..., En]</strong>, the result represents
"<strong>E1; ...; En</strong>".
</p><p><em>See also:</em> <a href="#conjunction-1">conjunction/1</a>, <a href="#disjunction_body-1">disjunction_body/1</a>.</p><h4>disjunction_body(Node::) -&gt; []</h4><p>Returns the list of body subtrees of a disjunction node.</p><a name="disjunction_body-1"></a><p>Returns the list of body subtrees of a
<strong>disjunction</strong> node.
</p><p><em>See also:</em> <a href="#disjunction-1">disjunction/1</a>.</p><h4>eof_marker() -&gt;</h4><p>Creates an abstract end-of-file marker.</p><a name="eof_marker-0"></a><p>Creates an abstract end-of-file marker. This represents the  
end of input when reading a sequence of source code forms. An  
end-of-file marker is itself regarded as a source code form  
(namely, the last in any sequence in which it occurs). It has no  
defined lexical form.</p><p>Note: this is retained only for backwards compatibility with
existing parsers and tools.
</p><p><em>See also:</em> <a href="#error_marker-1">error_marker/1</a>, <a href="#is_form-1">is_form/1</a>, <a href="#warning_marker-1">warning_marker/1</a>.</p><h4>error_marker(Error::term()) -&gt;</h4><p>Creates an abstract error marker.</p><a name="error_marker-1"></a><p>Creates an abstract error marker. The result represents an
occurrence of an error in the source code, with an associated Erlang
I/O ErrorInfo structure given by <strong>Error</strong> (see module
<a href="./io">io(3)</a> for details). Error markers are regarded as source  
code forms, but have no defined lexical form.</p><p>Note: this is supported only for backwards compatibility with
existing parsers and tools.
</p><p><em>See also:</em> <a href="#eof_marker-0">eof_marker/0</a>, <a href="#error_marker_info-1">error_marker_info/1</a>, <a href="#is_form-1">is_form/1</a>, <a href="#warning_marker-1">warning_marker/1</a>.</p><h4>error_marker_info(Node::) -&gt; term()</h4><p>Returns the ErrorInfo structure of an error_marker node.</p><a name="error_marker_info-1"></a><p>Returns the ErrorInfo structure of an <strong>error_marker</strong> node.
</p><p><em>See also:</em> <a href="#error_marker-1">error_marker/1</a>.</p><h4>flatten_form_list(Node::) -&gt;</h4><p>Flattens sublists of a form_list node.</p><a name="flatten_form_list-1"></a><p>Flattens sublists of a <strong>form_list</strong> node. Returns
<strong>Node</strong> with all subtrees of type <strong>form_list</strong>
recursively expanded, yielding a single "flat" abstract form
sequence.
</p><p><em>See also:</em> <a href="#form_list-1">form_list/1</a>.</p><h4>float(Value::float()) -&gt;</h4><p>Creates an abstract floating-point literal.</p><a name="float-1"></a><p>Creates an abstract floating-point literal. The lexical
representation is the decimal floating-point numeral of <strong>Value</strong>.
</p><p><em>See also:</em> <a href="#float_literal-1">float_literal/1</a>, <a href="#float_value-1">float_value/1</a>.</p><h4>float_literal(Node::) -&gt; string()</h4><p>Returns the numeral string represented by a float node.</p><a name="float_literal-1"></a><p>Returns the numeral string represented by a <strong>float</strong> node.
</p><p><em>See also:</em> <a href="#float-1">float/1</a>.</p><h4>float_value(Node::) -&gt; float()</h4><p>Returns the value represented by a float node.</p><a name="float_value-1"></a><p>Returns the value represented by a <strong>float</strong> node. Note
that floating-point values should usually not be compared for
equality.
</p><p><em>See also:</em> <a href="#float-1">float/1</a>.</p><h4>form_list(Forms::[]) -&gt;</h4><p>Creates an abstract sequence of "source code forms".</p><a name="form_list-1"></a><p>Creates an abstract sequence of "source code forms". If
<strong>Forms</strong> is <strong>[F1, ..., Fn]</strong>, where each
<strong>Fi</strong> is a form (see <a href="#is_form-1">is_form/1</a>, the result
represents
</p><pre>
     F1
     ...
     Fn</pre><p>
where the <strong>Fi</strong> are separated by one or more line breaks. A
node of type <strong>form_list</strong> is itself regarded as a source
code form; see <a href="#flatten_form_list-1">flatten_form_list/1</a>.</p><p>Note: this is simply a way of grouping source code forms as a
single syntax tree, usually in order to form an Erlang module
definition.
</p><p><em>See also:</em> <a href="#flatten_form_list-1">flatten_form_list/1</a>, <a href="#form_list_elements-1">form_list_elements/1</a>, <a href="#is_form-1">is_form/1</a>.</p><h4>form_list_elements(Node::) -&gt; []</h4><p>Returns the list of subnodes of a form_list node.</p><a name="form_list_elements-1"></a><p>Returns the list of subnodes of a <strong>form_list</strong> node.
</p><p><em>See also:</em> <a href="#form_list-1">form_list/1</a>.</p><h4>fun_expr(Clauses::[]) -&gt;</h4><p>Creates an abstract fun-expression.</p><a name="fun_expr-1"></a><p>Creates an abstract fun-expression. If <strong>Clauses</strong> is
<strong>[C1, ..., Cn]</strong>, the result represents "<strong>fun C1; ...; Cn end</strong>". More exactly, if each
<strong>Ci</strong> represents "<strong>(Pi1, ..., Pim) Gi -&gt; Bi</strong>", then the result represents
"<strong>fun (P11, ..., P1m) G1 -&gt; B1; ...; (Pn1, ..., Pnm) Gn -&gt; Bn end</strong>".
</p><p><em>See also:</em> <a href="#fun_expr_arity-1">fun_expr_arity/1</a>, <a href="#fun_expr_clauses-1">fun_expr_clauses/1</a>.</p><h4>fun_expr_arity(Node::) -&gt; arity()</h4><p>Returns the arity of a fun_expr node.</p><a name="fun_expr_arity-1"></a><p>Returns the arity of a <strong>fun_expr</strong> node. The result is  
the number of parameter patterns in the first clause of the  
fun-expression; subsequent clauses are ignored.</p><p>An exception is thrown if <strong>fun_expr_clauses(Node)</strong>
returns an empty list, or if the first element of that list is not a
syntax tree <strong>C</strong> of type <strong>clause</strong> such that
<strong>clause_patterns(C)</strong> is a nonempty list.
</p><p><em>See also:</em> <a href="#clause-3">clause/3</a>, <a href="#clause_patterns-1">clause_patterns/1</a>, <a href="#fun_expr-1">fun_expr/1</a>, <a href="#fun_expr_clauses-1">fun_expr_clauses/1</a>.</p><h4>fun_expr_clauses(Node::) -&gt; []</h4><p>Returns the list of clause subtrees of a fun_expr node.</p><a name="fun_expr_clauses-1"></a><p>Returns the list of clause subtrees of a <strong>fun_expr</strong> node.
</p><p><em>See also:</em> <a href="#fun_expr-1">fun_expr/1</a>.</p><h4>fun_type() -&gt;</h4><p>Creates an abstract fun of any type.</p><a name="fun_type-0"></a><p>Creates an abstract fun of any type. The result represents
"<strong>fun()</strong>".</p><h4>function(Name::, Clauses::[]) -&gt;</h4><p>Creates an abstract function definition.</p><a name="function-2"></a><p>Creates an abstract function definition. If <strong>Clauses</strong>
is <strong>[C1, ..., Cn]</strong>, the result represents
"<strong>Name C1; ...; Name Cn.</strong>". More exactly, if each <strong>Ci</strong>
represents "<strong>(Pi1, ..., Pim) Gi -&gt; Bi</strong>", then the result represents
"<strong>Name(P11, ..., P1m) G1 -&gt; B1; ...; Name(Pn1, ..., Pnm) Gn -&gt; Bn.</strong>". Function definitions are source
code forms.
</p><p><em>See also:</em> <a href="#function_arity-1">function_arity/1</a>, <a href="#function_clauses-1">function_clauses/1</a>, <a href="#function_name-1">function_name/1</a>, <a href="#is_form-1">is_form/1</a>.</p><h4>function_arity(Node::) -&gt; arity()</h4><p>Returns the arity of a function node.</p><a name="function_arity-1"></a><p>Returns the arity of a <strong>function</strong> node. The result  
is the number of parameter patterns in the first clause of the  
function; subsequent clauses are ignored.</p><p>An exception is thrown if <strong>function_clauses(Node)</strong>
returns an empty list, or if the first element of that list is not
a syntax tree <strong>C</strong> of type <strong>clause</strong> such that
<strong>clause_patterns(C)</strong> is a nonempty list.
</p><p><em>See also:</em> <a href="#clause-3">clause/3</a>, <a href="#clause_patterns-1">clause_patterns/1</a>, <a href="#function-2">function/2</a>, <a href="#function_clauses-1">function_clauses/1</a>.</p><h4>function_clauses(Node::) -&gt; []</h4><p>Returns the list of clause subtrees of a function node.</p><a name="function_clauses-1"></a><p>Returns the list of clause subtrees of a <strong>function</strong> node.
</p><p><em>See also:</em> <a href="#function-2">function/2</a>.</p><h4>function_name(Node::) -&gt;</h4><p>Returns the name subtree of a function node.</p><a name="function_name-1"></a><p>Returns the name subtree of a <strong>function</strong> node.
</p><p><em>See also:</em> <a href="#function-2">function/2</a>.</p><h4>function_type(Type) -&gt; term()
</h4><p>Equivalent to function_type(any_arity, Type). </p><a name="function_type-1"></a><p>Equivalent to <a href="#function_type-2">function_type(any_arity, Type)</a>.</p><h4>function_type(Arguments::any_arity |, Return::) -&gt;</h4><p>Creates an abstract function type.</p><a name="function_type-2"></a><p>Creates an abstract function type. If <strong>Arguments</strong> is
<strong>[T1, ..., Tn]</strong>, then if it occurs within a function
specification, the result represents
"<strong>(T1, ...Tn) -&gt; Return</strong>"; otherwise
it represents
"<strong>fun((T1, ...Tn) -&gt; Return)</strong>".
If <strong>Arguments</strong> is <strong>any_arity</strong>, it represents
"<strong>fun((...) -&gt; Return)</strong>".</p><p>Note that the <strong>erl_parse</strong> representation is identical for
"<strong>FunctionType</strong>" and
"<strong>fun(FunctionType)</strong>".
</p><p><em>See also:</em> <a href="#function_type_arguments-1">function_type_arguments/1</a>, <a href="#function_type_return-1">function_type_return/1</a>.</p><h4>function_type_arguments(Node::) -&gt; any_arity | []</h4><p>Returns the argument types subtrees of a function_type node.</p><a name="function_type_arguments-1"></a><p>Returns the argument types subtrees of a <strong>function_type</strong> node.
If <strong>Node</strong> represents "<strong>fun((...) -&gt; Return)</strong>",
<strong>any_arity</strong> is returned; otherwise, if <strong>Node</strong> represents
"<strong>(T1, ...Tn) -&gt; Return</strong>" or
"<strong>fun((T1, ...Tn) -&gt; Return)</strong>",
<strong>[T1, ..., Tn]</strong> is returned.</p><p><em>See also:</em> <a href="#function_type-1">function_type/1</a>, <a href="#function_type-2">function_type/2</a>.</p><h4>function_type_return(Node::) -&gt;</h4><p>Returns the return type subtrees of a function_type node.</p><a name="function_type_return-1"></a><p>Returns the return type subtrees of a <strong>function_type</strong> node.
</p><p><em>See also:</em> <a href="#function_type-1">function_type/1</a>, <a href="#function_type-2">function_type/2</a>.</p><h4>generator(Pattern::, Body::) -&gt;</h4><p>Creates an abstract generator.</p><a name="generator-2"></a><p>Creates an abstract generator. The result represents
"<strong>Pattern &lt;- Body</strong>".
</p><p><em>See also:</em> <a href="#binary_comp-2">binary_comp/2</a>, <a href="#generator_body-1">generator_body/1</a>, <a href="#generator_pattern-1">generator_pattern/1</a>, <a href="#list_comp-2">list_comp/2</a>.</p><h4>generator_body(Node::) -&gt;</h4><p>Returns the body subtree of a generator node.</p><a name="generator_body-1"></a><p>Returns the body subtree of a <strong>generator</strong> node.
</p><p><em>See also:</em> <a href="#generator-2">generator/2</a>.</p><h4>generator_pattern(Node::) -&gt;</h4><p>Returns the pattern subtree of a generator node.</p><a name="generator_pattern-1"></a><p>Returns the pattern subtree of a <strong>generator</strong> node.
</p><p><em>See also:</em> <a href="#generator-2">generator/2</a>.</p><h4>get_ann(Tree::) -&gt; [term()]</h4><p>Returns the list of user annotations associated with a syntax tree node.</p><a name="get_ann-1"></a><p>Returns the list of user annotations associated with a syntax
tree node. For a newly created node, this is the empty list. The
annotations may be any terms.
</p><p><em>See also:</em> <a href="#get_attrs-1">get_attrs/1</a>, <a href="#set_ann-2">set_ann/2</a>.</p><h4>get_attrs(Tree::) -&gt;</h4><p>Returns a representation of the attributes associated with a syntax tree node.</p><a name="get_attrs-1"></a><p>Returns a representation of the attributes associated with a
syntax tree node. The attributes are all the extra information that
can be attached to a node. Currently, this includes position
information, source code comments, and user annotations. The result
of this function cannot be inspected directly; only attached to
another node (see <a href="#set_attrs-2">set_attrs/2</a>).</p><p>For accessing individual attributes, see <a href="#get_pos-1">get_pos/1</a>,
<a href="#get_ann-1">get_ann/1</a>, <a href="#get_precomments-1">get_precomments/1</a> and
<a href="#get_postcomments-1">get_postcomments/1</a>.
</p><p><em>See also:</em> <a href="#get_ann-1">get_ann/1</a>, <a href="#get_pos-1">get_pos/1</a>, <a href="#get_postcomments-1">get_postcomments/1</a>, <a href="#get_precomments-1">get_precomments/1</a>, <a href="#set_attrs-2">set_attrs/2</a>.</p><h4>get_pos(Tree::) -&gt; term()</h4><p>Returns the position information associated with Node.</p><a name="get_pos-1"></a><p>Returns the position information associated with
<strong>Node</strong>. This is usually a nonnegative integer (indicating
the source code line number), but may be any term. By default, all
new tree nodes have their associated position information set to the
integer zero.
</p><p><em>See also:</em> <a href="#get_attrs-1">get_attrs/1</a>, <a href="#set_pos-2">set_pos/2</a>.</p><h4>get_postcomments(Tree::) -&gt; []</h4><p>Returns the associated post-comments of a node.</p><a name="get_postcomments-1"></a><p>Returns the associated post-comments of a node. This is a
possibly empty list of abstract comments, in top-down textual order.
When the code is formatted, post-comments are typically displayed to
the right of and/or below the node. For example:
</p><pre>     {foo, X, Y}     % Post-comment of tuple</pre><p>
If possible, the comment should be moved past any following
separator characters on the same line, rather than placing the
separators on the following line. E.g.:
</p><pre>     foo([X | Xs], Y) -&gt;
         foo(Xs, bar(X));     % Post-comment of 'bar(X)' node
      ...</pre><p>
(where the comment is moved past the rightmost "<strong>)</strong>" and
the "<strong>;</strong>").
</p><p><em>See also:</em> <a href="#comment-2">comment/2</a>, <a href="#get_attrs-1">get_attrs/1</a>, <a href="#get_precomments-1">get_precomments/1</a>, <a href="#set_postcomments-2">set_postcomments/2</a>.</p><h4>get_precomments(Tree::) -&gt; []</h4><p>Returns the associated pre-comments of a node.</p><a name="get_precomments-1"></a><p>Returns the associated pre-comments of a node. This is a
possibly empty list of abstract comments, in top-down textual order.
When the code is formatted, pre-comments are typically displayed
directly above the node. For example:
</p><pre>     % Pre-comment of function
     foo(X) -&gt; {bar, X}.</pre><p>
If possible, the comment should be moved before any preceding
separator characters on the same line. E.g.:
</p><pre>     foo([X | Xs]) -&gt;
         % Pre-comment of 'bar(X)' node
         [bar(X) | foo(Xs)];
     ...</pre><p>
(where the comment is moved before the "<strong>[</strong>").
</p><p><em>See also:</em> <a href="#comment-2">comment/2</a>, <a href="#get_attrs-1">get_attrs/1</a>, <a href="#get_postcomments-1">get_postcomments/1</a>, <a href="#set_precomments-2">set_precomments/2</a>.</p><h4>has_comments(Tree::) -&gt; boolean()</h4><p>Yields false if the node has no associated comments, and true otherwise.</p><a name="has_comments-1"></a><p>Yields <strong>false</strong> if the node has no associated
comments, and <strong>true</strong> otherwise.</p><p>Note: This is equivalent to <strong>(get_precomments(Node) == []) and (get_postcomments(Node) == [])</strong>, but potentially more
efficient.
</p><p><em>See also:</em> <a href="#get_postcomments-1">get_postcomments/1</a>, <a href="#get_precomments-1">get_precomments/1</a>, <a href="#remove_comments-1">remove_comments/1</a>.</p><h4>if_expr(Clauses::[]) -&gt;</h4><p>Creates an abstract if-expression.</p><a name="if_expr-1"></a><p>Creates an abstract if-expression. If <strong>Clauses</strong> is
<strong>[C1, ..., Cn]</strong>, the result represents "<strong>if C1; ...; Cn end</strong>". More exactly, if each
<strong>Ci</strong> represents "<strong>() Gi -&gt; Bi</strong>", then the result represents "<strong>if G1 -&gt; B1; ...; Gn -&gt; Bn end</strong>".
</p><p><em>See also:</em> <a href="#case_expr-2">case_expr/2</a>, <a href="#clause-3">clause/3</a>, <a href="#if_expr_clauses-1">if_expr_clauses/1</a>.</p><h4>if_expr_clauses(Node::) -&gt; []</h4><p>Returns the list of clause subtrees of an if_expr node.</p><a name="if_expr_clauses-1"></a><p>Returns the list of clause subtrees of an <strong>if_expr</strong> node.
</p><p><em>See also:</em> <a href="#if_expr-1">if_expr/1</a>.</p><h4>implicit_fun(Name::) -&gt;</h4><p>Creates an abstract "implicit fun" expression.</p><a name="implicit_fun-1"></a><p>Creates an abstract "implicit fun" expression. The result
represents "<strong>fun Name</strong>". <strong>Name</strong> should
represent either <strong>F/A</strong> or
<strong>M:F/A</strong>
</p><p><em>See also:</em> <a href="#arity_qualifier-2">arity_qualifier/2</a>, <a href="#implicit_fun-2">implicit_fun/2</a>, <a href="#implicit_fun-3">implicit_fun/3</a>, <a href="#implicit_fun_name-1">implicit_fun_name/1</a>, <a href="#module_qualifier-2">module_qualifier/2</a>.</p><h4>implicit_fun(Name::, Arity::none |) -&gt;</h4><p>Creates an abstract "implicit fun" expression.</p><a name="implicit_fun-2"></a><p>Creates an abstract "implicit fun" expression. If
<strong>Arity</strong> is <strong>none</strong>, this is equivalent to
<strong>implicit_fun(Name)</strong>, otherwise it is equivalent to
<strong>implicit_fun(arity_qualifier(Name, Arity))</strong>.</p><p>(This is a utility function.)
</p><p><em>See also:</em> <a href="#implicit_fun-1">implicit_fun/1</a>, <a href="#implicit_fun-3">implicit_fun/3</a>.</p><h4>implicit_fun(Module::none |, Name::, Arity::) -&gt;</h4><p>Creates an abstract module-qualified "implicit fun" expression.</p><a name="implicit_fun-3"></a><p>Creates an abstract module-qualified "implicit fun" expression.
If <strong>Module</strong> is <strong>none</strong>, this is equivalent to
<strong>implicit_fun(Name, Arity)</strong>, otherwise it is equivalent to
<strong>implicit_fun(module_qualifier(Module, arity_qualifier(Name, Arity))</strong>.</p><p>(This is a utility function.)
</p><p><em>See also:</em> <a href="#implicit_fun-1">implicit_fun/1</a>, <a href="#implicit_fun-2">implicit_fun/2</a>.</p><h4>implicit_fun_name(Node::) -&gt;</h4><p>Returns the name subtree of an implicit_fun node.</p><a name="implicit_fun_name-1"></a><p>Returns the name subtree of an <strong>implicit_fun</strong> node.</p><p>Note: if <strong>Node</strong> represents "<strong>fun N/A</strong>" or "<strong>fun M:N/A</strong>", then the result is the
subtree representing "<strong>N/A</strong>" or
"<strong>M:N/A</strong>", respectively.
</p><p><em>See also:</em> <a href="#arity_qualifier-2">arity_qualifier/2</a>, <a href="#implicit_fun-1">implicit_fun/1</a>, <a href="#module_qualifier-2">module_qualifier/2</a>.</p><h4>infix_expr(Left::, Operator::, Right::) -&gt;</h4><p>Creates an abstract infix operator expression.</p><a name="infix_expr-3"></a><p>Creates an abstract infix operator expression. The result
represents "<strong>Left Operator Right</strong>".
</p><p><em>See also:</em> <a href="#infix_expr_left-1">infix_expr_left/1</a>, <a href="#infix_expr_operator-1">infix_expr_operator/1</a>, <a href="#infix_expr_right-1">infix_expr_right/1</a>, <a href="#prefix_expr-2">prefix_expr/2</a>.</p><h4>infix_expr_left(Node::) -&gt;</h4><p>Returns the left argument subtree of an infix_expr node.</p><a name="infix_expr_left-1"></a><p>Returns the left argument subtree of an
<strong>infix_expr</strong> node.
</p><p><em>See also:</em> <a href="#infix_expr-3">infix_expr/3</a>.</p><h4>infix_expr_operator(Node::) -&gt;</h4><p>Returns the operator subtree of an infix_expr node.</p><a name="infix_expr_operator-1"></a><p>Returns the operator subtree of an <strong>infix_expr</strong> node.
</p><p><em>See also:</em> <a href="#infix_expr-3">infix_expr/3</a>.</p><h4>infix_expr_right(Node::) -&gt;</h4><p>Returns the right argument subtree of an infix_expr node.</p><a name="infix_expr_right-1"></a><p>Returns the right argument subtree of an
<strong>infix_expr</strong> node.
</p><p><em>See also:</em> <a href="#infix_expr-3">infix_expr/3</a>.</p><h4>integer(Value::integer()) -&gt;</h4><p>Creates an abstract integer literal.</p><a name="integer-1"></a><p>Creates an abstract integer literal. The lexical representation
is the canonical decimal numeral of <strong>Value</strong>.
</p><p><em>See also:</em> <a href="#integer_literal-1">integer_literal/1</a>, <a href="#integer_value-1">integer_value/1</a>, <a href="#is_integer-2">is_integer/2</a>.</p><h4>integer_literal(Node::) -&gt; string()</h4><p>Returns the numeral string represented by an integer node.</p><a name="integer_literal-1"></a><p>Returns the numeral string represented by an <strong>integer</strong> node.
</p><p><em>See also:</em> <a href="#integer-1">integer/1</a>.</p><h4>integer_range_type(Low::, High::) -&gt;</h4><p>Creates an abstract range type.</p><a name="integer_range_type-2"></a><p>Creates an abstract range type. The result represents
"<strong>Low .. High</strong>".
</p><p><em>See also:</em> <a href="#integer_range_type_high-1">integer_range_type_high/1</a>, <a href="#integer_range_type_low-1">integer_range_type_low/1</a>.</p><h4>integer_range_type_high(Node::) -&gt;</h4><p>Returns the high limit of an integer_range_type node.</p><a name="integer_range_type_high-1"></a><p>Returns the high limit of an <strong>integer_range_type</strong> node.
</p><p><em>See also:</em> <a href="#integer_range_type-2">integer_range_type/2</a>.</p><h4>integer_range_type_low(Node::) -&gt;</h4><p>Returns the low limit of an integer_range_type node.</p><a name="integer_range_type_low-1"></a><p>Returns the low limit of an <strong>integer_range_type</strong> node.
</p><p><em>See also:</em> <a href="#integer_range_type-2">integer_range_type/2</a>.</p><h4>integer_value(Node::) -&gt; integer()</h4><p>Returns the value represented by an integer node.</p><a name="integer_value-1"></a><p>Returns the value represented by an <strong>integer</strong> node.
</p><p><em>See also:</em> <a href="#integer-1">integer/1</a>.</p><h4>is_atom(Node::, Value::atom()) -&gt; boolean()</h4><p>Returns true if Node has type atom and represents Value, otherwise false.</p><a name="is_atom-2"></a><p>Returns <strong>true</strong> if <strong>Node</strong> has type
<strong>atom</strong> and represents <strong>Value</strong>, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#atom-1">atom/1</a>.</p><h4>is_char(Node::, Value::char()) -&gt; boolean()</h4><p>Returns true if Node has type char and represents Value, otherwise false.</p><a name="is_char-2"></a><p>Returns <strong>true</strong> if <strong>Node</strong> has type
<strong>char</strong> and represents <strong>Value</strong>, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#char-1">char/1</a>.</p><h4>is_form(Node::) -&gt; boolean()</h4><p>Returns true if Node is a syntax tree representing a so-called "source code form", otherwise false.</p><a name="is_form-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is a syntax tree
representing a so-called "source code form", otherwise
<strong>false</strong>. Forms are the Erlang source code units which,  
placed in sequence, constitute an Erlang program. Current form types  
are:</p><p>
<strong>attribute</strong>
<strong>comment</strong>
<strong>error_marker</strong>
<strong>eof_marker</strong>
<br/>
<strong>form_list</strong>
<strong>function</strong>
<strong>warning_marker</strong>
<strong>text</strong>
<br/>
</p><p><em>See also:</em> <a href="#attribute-2">attribute/2</a>, <a href="#comment-2">comment/2</a>, <a href="#eof_marker-0">eof_marker/0</a>, <a href="#error_marker-1">error_marker/1</a>, <a href="#form_list-1">form_list/1</a>, <a href="#function-2">function/2</a>, <a href="#type-1">type/1</a>, <a href="#warning_marker-1">warning_marker/1</a>.</p><h4>is_integer(Node::, Value::integer()) -&gt; boolean()</h4><p>Returns true if Node has type integer and represents Value, otherwise false.</p><a name="is_integer-2"></a><p>Returns <strong>true</strong> if <strong>Node</strong> has type
<strong>integer</strong> and represents <strong>Value</strong>, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#integer-1">integer/1</a>.</p><h4>is_leaf(Node::) -&gt; boolean()</h4><p>Returns true if Node is a leaf node, otherwise false.</p><a name="is_leaf-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> is a leaf node,
otherwise <strong>false</strong>. The currently recognised leaf node  
types are:</p><p>
<strong>atom</strong>
<strong>char</strong>
<strong>comment</strong>
<strong>eof_marker</strong>
<strong>error_marker</strong>
<br/>
<strong>float</strong>
<strong>fun_type</strong>
<strong>integer</strong>
<strong>nil</strong>
<strong>operator</strong>
<strong>string</strong>
<br/>
<strong>text</strong>
<strong>underscore</strong>
<strong>variable</strong>
<strong>warning_marker</strong>
<br/>
</p><p>A node of type <strong>map_expr</strong> is a leaf node if and only if it has no
argument and no fields.
A node of type <strong>map_type</strong> is a leaf node if and only if it has no
fields (<strong>any_size</strong>).
A node of type <strong>tuple</strong> is a leaf node if and only if its arity is zero.
A node of type <strong>tuple_type</strong> is a leaf node if and only if it has no
elements (<strong>any_size</strong>).</p><p>Note: not all literals are leaf nodes, and vice versa. E.g.,
tuples with nonzero arity and nonempty lists may be literals, but are
not leaf nodes. Variables, on the other hand, are leaf nodes but not
literals.
</p><p><em>See also:</em> <a href="#is_literal-1">is_literal/1</a>, <a href="#type-1">type/1</a>.</p><h4>is_list_skeleton(Node::) -&gt; boolean()</h4><p>Returns true if Node has type list or nil, otherwise false.</p><a name="is_list_skeleton-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> has type
<strong>list</strong> or <strong>nil</strong>, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#list-2">list/2</a>, <a href="#nil-0">nil/0</a>.</p><h4>is_literal(T::) -&gt; boolean()</h4><p>Returns true if Node represents a literal term, otherwise false.</p><a name="is_literal-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> represents a
literal term, otherwise <strong>false</strong>. This function returns
<strong>true</strong> if and only if the value of
<strong>concrete(Node)</strong> is defined.
</p><p><em>See also:</em> <a href="#abstract-1">abstract/1</a>, <a href="#concrete-1">concrete/1</a>.</p><h4>is_proper_list(Node::) -&gt; boolean()</h4><p>Returns true if Node represents a proper list, and false otherwise.</p><a name="is_proper_list-1"></a><p>Returns <strong>true</strong> if <strong>Node</strong> represents a
proper list, and <strong>false</strong> otherwise. A proper list is a
list skeleton either on the form "<strong>[]</strong>" or
"<strong>[E1, ..., En]</strong>", or "<strong>[... | Tail]</strong>" where recursively <strong>Tail</strong> also  
represents a proper list.</p><p>Note: Since <strong>Node</strong> is a syntax tree, the actual
run-time values corresponding to its subtrees may often be partially
or completely unknown. Thus, if <strong>Node</strong> represents e.g.
"<strong>[... | Ns]</strong>" (where <strong>Ns</strong> is a variable), then
the function will return <strong>false</strong>, because it is not known
whether <strong>Ns</strong> will be bound to a list at run-time. If
<strong>Node</strong> instead represents e.g. "<strong>[1, 2, 3]</strong>" or
"<strong>[A | []]</strong>", then the function will return
<strong>true</strong>.
</p><p><em>See also:</em> <a href="#list-2">list/2</a>.</p><h4>is_string(Node::, Value::string()) -&gt; boolean()</h4><p>Returns true if Node has type string and represents Value, otherwise false.</p><a name="is_string-2"></a><p>Returns <strong>true</strong> if <strong>Node</strong> has type
<strong>string</strong> and represents <strong>Value</strong>, otherwise <strong>false</strong>.
</p><p><em>See also:</em> <a href="#string-1">string/1</a>.</p><h4>is_tree(Tree::) -&gt; boolean()</h4><p>For special purposes only.</p><a name="is_tree-1"></a><p><em>For special purposes only</em>. Returns <strong>true</strong> if
<strong>Tree</strong> is an abstract syntax tree and <strong>false</strong>  
otherwise.</p><p><em>Note</em>: this function yields <strong>false</strong> for all
"old-style" <strong>erl_parse</strong>-compatible "parse trees".
</p><p><em>See also:</em> <a href="#tree-2">tree/2</a>.</p><h4>join_comments(Source::, Target::) -&gt;</h4><p>Appends the comments of Source to the current comments of Target.</p><a name="join_comments-2"></a><p>Appends the comments of <strong>Source</strong> to the current
comments of <strong>Target</strong>.</p><p>Note: This is equivalent to
<strong>add_postcomments(get_postcomments(Source), add_precomments(get_precomments(Source), Target))</strong>, but
potentially more efficient.
</p><p><em>See also:</em> <a href="#add_postcomments-2">add_postcomments/2</a>, <a href="#add_precomments-2">add_precomments/2</a>, <a href="#comment-2">comment/2</a>, <a href="#get_postcomments-1">get_postcomments/1</a>, <a href="#get_precomments-1">get_precomments/1</a>.</p><h4>list(List::[]) -&gt;</h4><p>Equivalent to list(List, none). </p><a name="list-1"></a><p>Equivalent to <a href="#list-2">list(List, none)</a>.</p><h4>list(Elements::[], Tail::none |) -&gt;</h4><p>Constructs an abstract list skeleton.</p><a name="list-2"></a><p>Constructs an abstract list skeleton. The result has type
<strong>list</strong> or <strong>nil</strong>. If <strong>List</strong> is a
nonempty list <strong>[E1, ..., En]</strong>, the result has type
<strong>list</strong> and represents either "<strong>[E1, ..., En]</strong>", if <strong>Tail</strong> is <strong>none</strong>, or
otherwise "<strong>[E1, ..., En | Tail]</strong>". If <strong>List</strong> is the empty list,
<strong>Tail</strong> <em>must</em> be <strong>none</strong>, and in that
case the result has type <strong>nil</strong> and represents
"<strong>[]</strong>" (see <a href="#nil-0">nil/0</a>).</p><p>The difference between lists as semantic objects (built up of  
individual "cons" and "nil" terms) and the various syntactic forms  
for denoting lists may be bewildering at first. This module provides  
functions both for exact control of the syntactic representation as  
well as for the simple composition and deconstruction in terms of  
cons and head/tail operations.</p><p>Note: in <strong>list(Elements, none)</strong>, the "nil" list
terminator is implicit and has no associated information (see
<a href="#get_attrs-1">get_attrs/1</a>), while in the seemingly equivalent
<strong>list(Elements, Tail)</strong> when <strong>Tail</strong> has type
<strong>nil</strong>, the list terminator subtree <strong>Tail</strong> may
have attached attributes such as position, comments, and annotations,
which will be preserved in the result.
</p><p><em>See also:</em> <a href="#compact_list-1">compact_list/1</a>, <a href="#cons-2">cons/2</a>, <a href="#get_attrs-1">get_attrs/1</a>, <a href="#is_list_skeleton-1">is_list_skeleton/1</a>, <a href="#is_proper_list-1">is_proper_list/1</a>, <a href="#list-1">list/1</a>, <a href="#list_elements-1">list_elements/1</a>, <a href="#list_head-1">list_head/1</a>, <a href="#list_length-1">list_length/1</a>, <a href="#list_prefix-1">list_prefix/1</a>, <a href="#list_suffix-1">list_suffix/1</a>, <a href="#list_tail-1">list_tail/1</a>, <a href="#nil-0">nil/0</a>, <a href="#normalize_list-1">normalize_list/1</a>.</p><h4>list_comp(Template::, Body::[]) -&gt;</h4><p>Creates an abstract list comprehension.</p><a name="list_comp-2"></a><p>Creates an abstract list comprehension. If <strong>Body</strong> is
<strong>[E1, ..., En]</strong>, the result represents
"<strong>[Template || E1, ..., En]</strong>".
</p><p><em>See also:</em> <a href="#generator-2">generator/2</a>, <a href="#list_comp_body-1">list_comp_body/1</a>, <a href="#list_comp_template-1">list_comp_template/1</a>.</p><h4>list_comp_body(Node::) -&gt; []</h4><p>Returns the list of body subtrees of a list_comp node.</p><a name="list_comp_body-1"></a><p>Returns the list of body subtrees of a <strong>list_comp</strong> node.
</p><p><em>See also:</em> <a href="#list_comp-2">list_comp/2</a>.</p><h4>list_comp_template(Node::) -&gt;</h4><p>Returns the template subtree of a list_comp node.</p><a name="list_comp_template-1"></a><p>Returns the template subtree of a <strong>list_comp</strong> node.
</p><p><em>See also:</em> <a href="#list_comp-2">list_comp/2</a>.</p><h4>list_elements(Node::) -&gt; []</h4><p>Returns the list of element subtrees of a list skeleton.</p><a name="list_elements-1"></a><p>Returns the list of element subtrees of a list skeleton.
<strong>Node</strong> must represent a proper list. E.g., if
<strong>Node</strong> represents "<strong>[X1, X2 | [X3, X4 | []]</strong>", then
<strong>list_elements(Node)</strong> yields the list <strong>[X1, X2, X3, X4]</strong>.
</p><p><em>See also:</em> <a href="#is_proper_list-1">is_proper_list/1</a>, <a href="#list-2">list/2</a>.</p><h4>list_head(Node::) -&gt;</h4><p>Returns the head element subtree of a list node.</p><a name="list_head-1"></a><p>Returns the head element subtree of a <strong>list</strong> node. If
<strong>Node</strong> represents "<strong>[Head ...]</strong>", the
result will represent "<strong>Head</strong>".
</p><p><em>See also:</em> <a href="#cons-2">cons/2</a>, <a href="#list-2">list/2</a>, <a href="#list_tail-1">list_tail/1</a>.</p><h4>list_length(Node::) -&gt; non_neg_integer()</h4><p>Returns the number of element subtrees of a list skeleton.</p><a name="list_length-1"></a><p>Returns the number of element subtrees of a list skeleton.
<strong>Node</strong> must represent a proper list. E.g., if
<strong>Node</strong> represents "<strong>[X1 | [X2, X3 | [X4, X5, X6]]]</strong>", then <strong>list_length(Node)</strong> returns the  
integer 6.</p><p>Note: this is equivalent to
<strong>length(list_elements(Node))</strong>, but potentially more
efficient.
</p><p><em>See also:</em> <a href="#is_proper_list-1">is_proper_list/1</a>, <a href="#list-2">list/2</a>, <a href="#list_elements-1">list_elements/1</a>.</p><h4>list_prefix(Node::) -&gt; []</h4><p>Returns the prefix element subtrees of a list node.</p><a name="list_prefix-1"></a><p>Returns the prefix element subtrees of a <strong>list</strong> node.
If <strong>Node</strong> represents "<strong>[E1, ..., En]</strong>" or "<strong>[E1, ..., En | Tail]</strong>", the returned value is <strong>[E1, ..., En]</strong>.
</p><p><em>See also:</em> <a href="#list-2">list/2</a>.</p><h4>list_suffix(Node::) -&gt; none |</h4><p>Returns the suffix subtree of a list node, if one exists.</p><a name="list_suffix-1"></a><p>Returns the suffix subtree of a <strong>list</strong> node, if one
exists. If <strong>Node</strong> represents "<strong>[E1, ..., En | Tail]</strong>", the returned value is
<strong>Tail</strong>, otherwise, i.e., if <strong>Node</strong> represents
"<strong>[E1, ..., En]</strong>", <strong>none</strong> is  
returned.</p><p>Note that even if this function returns some <strong>Tail</strong>
that is not <strong>none</strong>, the type of <strong>Tail</strong> can be
<strong>nil</strong>, if the tail has been given explicitly, and the list
skeleton has not been compacted (see <a href="#compact_list-1">compact_list/1</a>).
</p><p><em>See also:</em> <a href="#compact_list-1">compact_list/1</a>, <a href="#list-2">list/2</a>, <a href="#nil-0">nil/0</a>.</p><h4>list_tail(Node::) -&gt;</h4><p>Returns the tail of a list node.</p><a name="list_tail-1"></a><p>Returns the tail of a <strong>list</strong> node. If
<strong>Node</strong> represents a single-element list
"<strong>[E]</strong>", then the result has type
<strong>nil</strong>, representing "<strong>[]</strong>". If
<strong>Node</strong> represents "<strong>[E1, E2 ...]</strong>", the result will represent "<strong>[E2 ...]</strong>", and if <strong>Node</strong> represents
"<strong>[Head | Tail]</strong>", the result will
represent "<strong>Tail</strong>".
</p><p><em>See also:</em> <a href="#cons-2">cons/2</a>, <a href="#list-2">list/2</a>, <a href="#list_head-1">list_head/1</a>.</p><h4>macro(Name::) -&gt;</h4><p>Equivalent to macro(Name, none). </p><a name="macro-1"></a><p>Equivalent to <a href="#macro-2">macro(Name, none)</a>.</p><h4>macro(Name::, Arguments::none | []) -&gt;</h4><p>Creates an abstract macro application.</p><a name="macro-2"></a><p>Creates an abstract macro application. If <strong>Arguments</strong>
is <strong>none</strong>, the result represents
"<strong>?Name</strong>", otherwise, if <strong>Arguments</strong>
is <strong>[A1, ..., An]</strong>, the result represents
"<strong>?Name(A1, ..., An)</strong>".</p><p>Notes: if <strong>Arguments</strong> is the empty list, the result
will thus represent "<strong>?Name()</strong>", including a pair  
of matching parentheses.</p><p>The only syntactical limitation imposed by the preprocessor on the
arguments to a macro application (viewed as sequences of tokens) is
that they must be balanced with respect to parentheses, brackets,
<strong>begin ... end</strong>, <strong>case ... end</strong>, etc. The
<strong>text</strong> node type can be used to represent arguments which
are not regular Erlang constructs.
</p><p><em>See also:</em> <a href="#macro-1">macro/1</a>, <a href="#macro_arguments-1">macro_arguments/1</a>, <a href="#macro_name-1">macro_name/1</a>, <a href="#text-1">text/1</a>.</p><h4>macro_arguments(Node::) -&gt; none | []</h4><p>Returns the list of argument subtrees of a macro node, if any.</p><a name="macro_arguments-1"></a><p>Returns the list of argument subtrees of a <strong>macro</strong>
node, if any. If <strong>Node</strong> represents
"<strong>?Name</strong>", <strong>none</strong> is returned.
Otherwise, if <strong>Node</strong> represents
"<strong>?Name(A1, ..., An)</strong>",
<strong>[A1, ..., An]</strong> is returned.
</p><p><em>See also:</em> <a href="#macro-2">macro/2</a>.</p><h4>macro_name(Node::) -&gt;</h4><p>Returns the name subtree of a macro node.</p><a name="macro_name-1"></a><p>Returns the name subtree of a <strong>macro</strong> node.
</p><p><em>See also:</em> <a href="#macro-2">macro/2</a>.</p><h4>make_tree(X1::atom(), X2::[[]]) -&gt;</h4><p>Creates a syntax tree with the given type and subtrees.</p><a name="make_tree-2"></a><p>Creates a syntax tree with the given type and subtrees.
<strong>Type</strong> must be a node type name (see <a href="#type-1">type/1</a>)
that does not denote a leaf node type (see <a href="#is_leaf-1">is_leaf/1</a>).
<strong>Groups</strong> must be a <em>nonempty</em> list of groups of
syntax trees, representing the subtrees of a node of the given type,
in left-to-right order as they would occur in the printed program
text, grouped by category as done by <a href="#subtrees-1">subtrees/1</a>.</p><p>The result of <strong>copy_attrs(Node, make_tree(type(Node), subtrees(Node)))</strong> (see <a href="#update_tree-2">update_tree/2</a>) represents
the same source code text as the original <strong>Node</strong>, assuming
that <strong>subtrees(Node)</strong> yields a nonempty list. However, it
does not necessarily have the same data representation as
<strong>Node</strong>.
</p><p><em>See also:</em> <a href="#copy_attrs-2">copy_attrs/2</a>, <a href="#is_leaf-1">is_leaf/1</a>, <a href="#subtrees-1">subtrees/1</a>, <a href="#type-1">type/1</a>, <a href="#update_tree-2">update_tree/2</a>.</p><h4>map_expr(Fields::[]) -&gt;</h4><p>Equivalent to map_expr(none, Fields). </p><a name="map_expr-1"></a><p>Equivalent to <a href="#map_expr-2">map_expr(none, Fields)</a>.</p><h4>map_expr(Argument::none |, Fields::[]) -&gt;</h4><p>Creates an abstract map expression.</p><a name="map_expr-2"></a><p>Creates an abstract map expression. If <strong>Fields</strong> is
<strong>[F1, ..., Fn]</strong>, then if <strong>Argument</strong> is <strong>none</strong>, the result represents
"<strong>#{F1, ..., Fn}</strong>",
otherwise it represents
"<strong>Argument#{F1, ..., Fn}</strong>".
</p><p><em>See also:</em> <a href="#map_expr-1">map_expr/1</a>, <a href="#map_expr_argument-1">map_expr_argument/1</a>, <a href="#map_expr_fields-1">map_expr_fields/1</a>, <a href="#map_field_assoc-2">map_field_assoc/2</a>, <a href="#map_field_exact-2">map_field_exact/2</a>.</p><h4>map_expr_argument(Node::) -&gt; none |</h4><p>Returns the argument subtree of a map_expr node, if any.</p><a name="map_expr_argument-1"></a><p>Returns the argument subtree of a <strong>map_expr</strong> node, if any. If <strong>Node</strong>
represents "<strong>#{...}</strong>", <strong>none</strong> is returned.
Otherwise, if <strong>Node</strong> represents "<strong>Argument#{...}</strong>",
<strong>Argument</strong> is returned.
</p><p><em>See also:</em> <a href="#map_expr-2">map_expr/2</a>.</p><h4>map_expr_fields(Node::) -&gt; []</h4><p>Returns the list of field subtrees of a map_expr node.</p><a name="map_expr_fields-1"></a><p>Returns the list of field subtrees of a <strong>map_expr</strong> node.
</p><p><em>See also:</em> <a href="#map_expr-2">map_expr/2</a>.</p><h4>map_field_assoc(Name::, Value::) -&gt;</h4><p>Creates an abstract map assoc field.</p><a name="map_field_assoc-2"></a><p>Creates an abstract map assoc field. The result represents
"<strong>Name =&gt; Value</strong>".
</p><p><em>See also:</em> <a href="#map_expr-2">map_expr/2</a>, <a href="#map_field_assoc_name-1">map_field_assoc_name/1</a>, <a href="#map_field_assoc_value-1">map_field_assoc_value/1</a>.</p><h4>map_field_assoc_name(Node::) -&gt;</h4><p>Returns the name subtree of a map_field_assoc node.</p><a name="map_field_assoc_name-1"></a><p>Returns the name subtree of a <strong>map_field_assoc</strong> node.
</p><p><em>See also:</em> <a href="#map_field_assoc-2">map_field_assoc/2</a>.</p><h4>map_field_assoc_value(Node::) -&gt;</h4><p>Returns the value subtree of a map_field_assoc node.</p><a name="map_field_assoc_value-1"></a><p>Returns the value subtree of a <strong>map_field_assoc</strong> node.
</p><p><em>See also:</em> <a href="#map_field_assoc-2">map_field_assoc/2</a>.</p><h4>map_field_exact(Name::, Value::) -&gt;</h4><p>Creates an abstract map exact field.</p><a name="map_field_exact-2"></a><p>Creates an abstract map exact field. The result represents
"<strong>Name := Value</strong>".
</p><p><em>See also:</em> <a href="#map_expr-2">map_expr/2</a>, <a href="#map_field_exact_name-1">map_field_exact_name/1</a>, <a href="#map_field_exact_value-1">map_field_exact_value/1</a>.</p><h4>map_field_exact_name(Node::) -&gt;</h4><p>Returns the name subtree of a map_field_exact node.</p><a name="map_field_exact_name-1"></a><p>Returns the name subtree of a <strong>map_field_exact</strong> node.
</p><p><em>See also:</em> <a href="#map_field_exact-2">map_field_exact/2</a>.</p><h4>map_field_exact_value(Node::) -&gt;</h4><p>Returns the value subtree of a map_field_exact node.</p><a name="map_field_exact_value-1"></a><p>Returns the value subtree of a <strong>map_field_exact</strong> node.
</p><p><em>See also:</em> <a href="#map_field_exact-2">map_field_exact/2</a>.</p><h4>map_type() -&gt; term()
</h4><p>Equivalent to map_type(any_size). </p><a name="map_type-0"></a><p>Equivalent to <a href="#map_type-1">map_type(any_size)</a>.</p><h4>map_type(Fields::any_size | []) -&gt;</h4><p>Creates an abstract type map.</p><a name="map_type-1"></a><p>Creates an abstract type map. If <strong>Fields</strong> is
<strong>[F1, ..., Fn]</strong>, the result represents
"<strong>#{F1, ..., Fn}</strong>";
otherwise, if <strong>Fields</strong> is <strong>any_size</strong>, it represents
"<strong>map()</strong>".
</p><p><em>See also:</em> <a href="#map_type_fields-1">map_type_fields/1</a>.</p><h4>map_type_assoc(Name::, Value::) -&gt;</h4><p>Creates an abstract map type assoc field.</p><a name="map_type_assoc-2"></a><p>Creates an abstract map type assoc field. The result represents
"<strong>Name =&gt; Value</strong>".
</p><p><em>See also:</em> <a href="#map_type-1">map_type/1</a>, <a href="#map_type_assoc_name-1">map_type_assoc_name/1</a>, <a href="#map_type_assoc_value-1">map_type_assoc_value/1</a>.</p><h4>map_type_assoc_name(Node::) -&gt;</h4><p>Returns the name subtree of a map_type_assoc node.</p><a name="map_type_assoc_name-1"></a><p>Returns the name subtree of a <strong>map_type_assoc</strong> node.
</p><p><em>See also:</em> <a href="#map_type_assoc-2">map_type_assoc/2</a>.</p><h4>map_type_assoc_value(Node::) -&gt;</h4><p>Returns the value subtree of a map_type_assoc node.</p><a name="map_type_assoc_value-1"></a><p>Returns the value subtree of a <strong>map_type_assoc</strong> node.
</p><p><em>See also:</em> <a href="#map_type_assoc-2">map_type_assoc/2</a>.</p><h4>map_type_exact(Name::, Value::) -&gt;</h4><p>Creates an abstract map type exact field.</p><a name="map_type_exact-2"></a><p>Creates an abstract map type exact field. The result represents
"<strong>Name := Value</strong>".
</p><p><em>See also:</em> <a href="#map_type-1">map_type/1</a>, <a href="#map_type_exact_name-1">map_type_exact_name/1</a>, <a href="#map_type_exact_value-1">map_type_exact_value/1</a>.</p><h4>map_type_exact_name(Node::) -&gt;</h4><p>Returns the name subtree of a map_type_exact node.</p><a name="map_type_exact_name-1"></a><p>Returns the name subtree of a <strong>map_type_exact</strong> node.
</p><p><em>See also:</em> <a href="#map_type_exact-2">map_type_exact/2</a>.</p><h4>map_type_exact_value(Node::) -&gt;</h4><p>Returns the value subtree of a map_type_exact node.</p><a name="map_type_exact_value-1"></a><p>Returns the value subtree of a <strong>map_type_exact</strong> node.
</p><p><em>See also:</em> <a href="#map_type_exact-2">map_type_exact/2</a>.</p><h4>map_type_fields(Node::) -&gt; any_size | []</h4><p>Returns the list of field subtrees of a map_type node.</p><a name="map_type_fields-1"></a><p>Returns the list of field subtrees of a <strong>map_type</strong> node.
If <strong>Node</strong> represents "<strong>map()</strong>", <strong>any_size</strong> is returned;
otherwise, if <strong>Node</strong> represents
"<strong>#{F1, ..., Fn}</strong>",
<strong>[F1, ..., Fn]</strong> is returned.
</p><p><em>See also:</em> <a href="#map_type-0">map_type/0</a>, <a href="#map_type-1">map_type/1</a>.</p><h4>match_expr(Pattern::, Body::) -&gt;</h4><p>Creates an abstract match-expression.</p><a name="match_expr-2"></a><p>Creates an abstract match-expression. The result represents
"<strong>Pattern = Body</strong>".
</p><p><em>See also:</em> <a href="#match_expr_body-1">match_expr_body/1</a>, <a href="#match_expr_pattern-1">match_expr_pattern/1</a>.</p><h4>match_expr_body(Node::) -&gt;</h4><p>Returns the body subtree of a match_expr node.</p><a name="match_expr_body-1"></a><p>Returns the body subtree of a <strong>match_expr</strong> node.
</p><p><em>See also:</em> <a href="#match_expr-2">match_expr/2</a>.</p><h4>match_expr_pattern(Node::) -&gt;</h4><p>Returns the pattern subtree of a match_expr node.</p><a name="match_expr_pattern-1"></a><p>Returns the pattern subtree of a <strong>match_expr</strong> node.
</p><p><em>See also:</em> <a href="#match_expr-2">match_expr/2</a>.</p><h4>meta(T::) -&gt;</h4><p>Creates a meta-representation of a syntax tree.</p><a name="meta-1"></a><p>Creates a meta-representation of a syntax tree. The result
represents an Erlang expression "<strong>MetaTree</strong>"
which, if evaluated, will yield a new syntax tree representing the
same source code text as <strong>Tree</strong> (although the actual data
representation may be different). The expression represented by
<strong>MetaTree</strong> is <em>implementation independent</em> with
regard to the data structures used by the abstract syntax tree
implementation. Comments attached to nodes of <strong>Tree</strong> will  
be preserved, but other attributes are lost.</p><p>Any node in <strong>Tree</strong> whose node type is
<strong>variable</strong> (see <a href="#type-1">type/1</a>), and whose list of
annotations (see <a href="#get_ann-1">get_ann/1</a>) contains the atom
<strong>meta_var</strong>, will remain unchanged in the resulting tree,
except that exactly one occurrence of <strong>meta_var</strong> is  
removed from its annotation list.</p><p>The main use of the function <strong>meta/1</strong> is to transform a
data structure <strong>Tree</strong>, which represents a piece of program
code, into a form that is <em>representation independent when printed</em>. E.g., suppose <strong>Tree</strong> represents a variable
named "V". Then (assuming a function <strong>print/1</strong> for
printing syntax trees), evaluating <strong>print(abstract(Tree))</strong>
- simply using <a href="#abstract-1">abstract/1</a> to map the actual data
structure onto a syntax tree representation - would output a string
that might look something like "<strong>{tree, variable, ..., "V", ...}</strong>", which is obviously dependent on the implementation of
the abstract syntax trees. This could e.g. be useful for caching a
syntax tree in a file. However, in some situations like in a program
generator generator (with two "generator"), it may be unacceptable.
Using <strong>print(meta(Tree))</strong> instead would output a
<em>representation independent</em> syntax tree generating
expression; in the above case, something like
"<strong>erl_syntax:variable("V")</strong>".
</p><p><em>See also:</em> <a href="#abstract-1">abstract/1</a>, <a href="#get_ann-1">get_ann/1</a>, <a href="#type-1">type/1</a>.</p><h4>module_qualifier(Module::, Body::) -&gt;</h4><p>Creates an abstract module qualifier.</p><a name="module_qualifier-2"></a><p>Creates an abstract module qualifier. The result represents
"<strong>Module:Body</strong>".
</p><p><em>See also:</em> <a href="#module_qualifier_argument-1">module_qualifier_argument/1</a>, <a href="#module_qualifier_body-1">module_qualifier_body/1</a>.</p><h4>module_qualifier_argument(Node::) -&gt;</h4><p>Returns the argument (the module) subtree of a module_qualifier node.</p><a name="module_qualifier_argument-1"></a><p>Returns the argument (the module) subtree of a
<strong>module_qualifier</strong> node.
</p><p><em>See also:</em> <a href="#module_qualifier-2">module_qualifier/2</a>.</p><h4>module_qualifier_body(Node::) -&gt;</h4><p>Returns the body subtree of a module_qualifier node.</p><a name="module_qualifier_body-1"></a><p>Returns the body subtree of a <strong>module_qualifier</strong> node.
</p><p><em>See also:</em> <a href="#module_qualifier-2">module_qualifier/2</a>.</p><h4>named_fun_expr(Name::, Clauses::[]) -&gt;</h4><p>Creates an abstract named fun-expression.</p><a name="named_fun_expr-2"></a><p>Creates an abstract named fun-expression. If <strong>Clauses</strong> is
<strong>[C1, ..., Cn]</strong>, the result represents "<strong>fun Name C1; ...; Name Cn end</strong>".
More exactly, if each <strong>Ci</strong> represents
"<strong>(Pi1, ..., Pim) Gi -&gt; Bi</strong>",
then the result represents
"<strong>fun Name(P11, ..., P1m) G1 -&gt; B1; ...; Name(Pn1, ..., Pnm) Gn -&gt; Bn end</strong>".
</p><p><em>See also:</em> <a href="#named_fun_expr_arity-1">named_fun_expr_arity/1</a>, <a href="#named_fun_expr_clauses-1">named_fun_expr_clauses/1</a>, <a href="#named_fun_expr_name-1">named_fun_expr_name/1</a>.</p><h4>named_fun_expr_arity(Node::) -&gt; arity()</h4><p>Returns the arity of a named_fun_expr node.</p><a name="named_fun_expr_arity-1"></a><p>Returns the arity of a <strong>named_fun_expr</strong> node. The result is  
the number of parameter patterns in the first clause of the  
named fun-expression; subsequent clauses are ignored.</p><p>An exception is thrown if <strong>named_fun_expr_clauses(Node)</strong>
returns an empty list, or if the first element of that list is not a
syntax tree <strong>C</strong> of type <strong>clause</strong> such that
<strong>clause_patterns(C)</strong> is a nonempty list.
</p><p><em>See also:</em> <a href="#clause-3">clause/3</a>, <a href="#clause_patterns-1">clause_patterns/1</a>, <a href="#named_fun_expr-2">named_fun_expr/2</a>, <a href="#named_fun_expr_clauses-1">named_fun_expr_clauses/1</a>.</p><h4>named_fun_expr_clauses(Node::) -&gt; []</h4><p>Returns the list of clause subtrees of a named_fun_expr node.</p><a name="named_fun_expr_clauses-1"></a><p>Returns the list of clause subtrees of a <strong>named_fun_expr</strong> node.
</p><p><em>See also:</em> <a href="#named_fun_expr-2">named_fun_expr/2</a>.</p><h4>named_fun_expr_name(Node::) -&gt;</h4><p>Returns the name subtree of a named_fun_expr node.</p><a name="named_fun_expr_name-1"></a><p>Returns the name subtree of a <strong>named_fun_expr</strong> node.
</p><p><em>See also:</em> <a href="#named_fun_expr-2">named_fun_expr/2</a>.</p><h4>nil() -&gt;</h4><p>Creates an abstract empty list.</p><a name="nil-0"></a><p>Creates an abstract empty list. The result represents
"<strong>[]</strong>". The empty list is traditionally called "nil".
</p><p><em>See also:</em> <a href="#is_list_skeleton-1">is_list_skeleton/1</a>, <a href="#list-2">list/2</a>.</p><h4>normalize_list(Node::) -&gt;</h4><p>Expands an abstract list skeleton to its most explicit form.</p><a name="normalize_list-1"></a><p>Expands an abstract list skeleton to its most explicit form. If
<strong>Node</strong> represents "<strong>[E1, ..., En | Tail]</strong>", the result represents "<strong>[E1 | ... [En | Tail1] ... ]</strong>", where
<strong>Tail1</strong> is the result of
<strong>normalize_list(Tail)</strong>. If <strong>Node</strong> represents
"<strong>[E1, ..., En]</strong>", the result simply
represents "<strong>[E1 | ... [En | []] ... ]</strong>". If <strong>Node</strong> does not represent a list skeleton,
<strong>Node</strong> itself is returned.
</p><p><em>See also:</em> <a href="#compact_list-1">compact_list/1</a>, <a href="#list-2">list/2</a>.</p><h4>operator(Name::atom() | string()) -&gt;</h4><p>Creates an abstract operator.</p><a name="operator-1"></a><p>Creates an abstract operator. The name of the operator is the
character sequence represented by <strong>Name</strong>. This is
analogous to the print name of an atom, but an operator is never
written within single-quotes; e.g., the result of
<strong>operator(</strong>++')' represents "<strong>++</strong>" rather
than "`++''".
</p><p><em>See also:</em> <a href="#atom-1">atom/1</a>, <a href="#operator_literal-1">operator_literal/1</a>, <a href="#operator_name-1">operator_name/1</a>.</p><h4>operator_literal(Node::) -&gt; string()</h4><p>Returns the literal string represented by an operator node.</p><a name="operator_literal-1"></a><p>Returns the literal string represented by an
<strong>operator</strong> node. This is simply the operator name as a string.
</p><p><em>See also:</em> <a href="#operator-1">operator/1</a>.</p><h4>operator_name(Node::) -&gt; atom()</h4><p>Returns the name of an operator node.</p><a name="operator_name-1"></a><p>Returns the name of an <strong>operator</strong> node. Note that
the name is returned as an atom.
</p><p><em>See also:</em> <a href="#operator-1">operator/1</a>.</p><h4>parentheses(Expr::) -&gt;</h4><p>Creates an abstract parenthesised expression.</p><a name="parentheses-1"></a><p>Creates an abstract parenthesised expression. The result
represents "<strong>(Body)</strong>", independently of the
context.
</p><p><em>See also:</em> <a href="#parentheses_body-1">parentheses_body/1</a>.</p><h4>parentheses_body(Node::) -&gt;</h4><p>Returns the body subtree of a parentheses node.</p><a name="parentheses_body-1"></a><p>Returns the body subtree of a <strong>parentheses</strong> node.
</p><p><em>See also:</em> <a href="#parentheses-1">parentheses/1</a>.</p><h4>prefix_expr(Operator::, Argument::) -&gt;</h4><p>Creates an abstract prefix operator expression.</p><a name="prefix_expr-2"></a><p>Creates an abstract prefix operator expression. The result
represents "<strong>Operator Argument</strong>".
</p><p><em>See also:</em> <a href="#infix_expr-3">infix_expr/3</a>, <a href="#prefix_expr_argument-1">prefix_expr_argument/1</a>, <a href="#prefix_expr_operator-1">prefix_expr_operator/1</a>.</p><h4>prefix_expr_argument(Node::) -&gt;</h4><p>Returns the argument subtree of a prefix_expr node.</p><a name="prefix_expr_argument-1"></a><p>Returns the argument subtree of a <strong>prefix_expr</strong> node.
</p><p><em>See also:</em> <a href="#prefix_expr-2">prefix_expr/2</a>.</p><h4>prefix_expr_operator(Node::) -&gt;</h4><p>Returns the operator subtree of a prefix_expr node.</p><a name="prefix_expr_operator-1"></a><p>Returns the operator subtree of a <strong>prefix_expr</strong> node.
</p><p><em>See also:</em> <a href="#prefix_expr-2">prefix_expr/2</a>.</p><h4>receive_expr(Clauses::[]) -&gt;</h4><p>Equivalent to receive_expr(Clauses, none, []). </p><a name="receive_expr-1"></a><p>Equivalent to <a href="#receive_expr-3">receive_expr(Clauses, none, [])</a>.</p><h4>receive_expr(Clauses::[], Timeout::none |, Action::[]) -&gt;</h4><p>Creates an abstract receive-expression.</p><a name="receive_expr-3"></a><p>Creates an abstract receive-expression. If <strong>Timeout</strong>
is <strong>none</strong>, the result represents "<strong>receive C1; ...; Cn end</strong>" (the <strong>Action</strong>
argument is ignored). Otherwise, if <strong>Clauses</strong> is
<strong>[C1, ..., Cn]</strong> and <strong>Action</strong> is <strong>[A1, ..., Am]</strong>, the result represents "<strong>receive C1; ...; Cn after Timeout -&gt; A1, ..., Am end</strong>". More exactly, if each <strong>Ci</strong> represents
"<strong>(Pi) Gi -&gt; Bi</strong>", then the
result represents "<strong>receive P1 G1 -&gt; B1; ...; Pn Gn -&gt; Bn ... end</strong>".</p><p>Note that in Erlang, a receive-expression must have at least one
clause if no timeout part is specified.
</p><p><em>See also:</em> <a href="#case_expr-2">case_expr/2</a>, <a href="#clause-3">clause/3</a>, <a href="#receive_expr-1">receive_expr/1</a>, <a href="#receive_expr_action-1">receive_expr_action/1</a>, <a href="#receive_expr_clauses-1">receive_expr_clauses/1</a>, <a href="#receive_expr_timeout-1">receive_expr_timeout/1</a>.</p><h4>receive_expr_action(Node::) -&gt; []</h4><p>Returns the list of action body subtrees of a receive_expr node.</p><a name="receive_expr_action-1"></a><p>Returns the list of action body subtrees of a
<strong>receive_expr</strong> node. If <strong>Node</strong> represents
"<strong>receive C1; ...; Cn end</strong>", this is the
empty list.
</p><p><em>See also:</em> <a href="#receive_expr-3">receive_expr/3</a>.</p><h4>receive_expr_clauses(Node::) -&gt; []</h4><p>Returns the list of clause subtrees of a receive_expr node.</p><a name="receive_expr_clauses-1"></a><p>Returns the list of clause subtrees of a
<strong>receive_expr</strong> node.
</p><p><em>See also:</em> <a href="#receive_expr-3">receive_expr/3</a>.</p><h4>receive_expr_timeout(Node::) -&gt; none |</h4><p>Returns the timeout subtree of a receive_expr node, if any.</p><a name="receive_expr_timeout-1"></a><p>Returns the timeout subtree of a <strong>receive_expr</strong> node,
if any. If <strong>Node</strong> represents "<strong>receive C1; ...; Cn end</strong>", <strong>none</strong> is returned.
Otherwise, if <strong>Node</strong> represents "<strong>receive C1; ...; Cn after Timeout -&gt; ... end</strong>",
<strong>Timeout</strong> is returned.
</p><p><em>See also:</em> <a href="#receive_expr-3">receive_expr/3</a>.</p><h4>record_access(Argument::, Type::, Field::) -&gt;</h4><p>Creates an abstract record field access expression.</p><a name="record_access-3"></a><p>Creates an abstract record field access expression. The result
represents "<strong>Argument#Type.Field</strong>".
</p><p><em>See also:</em> <a href="#record_access_argument-1">record_access_argument/1</a>, <a href="#record_access_field-1">record_access_field/1</a>, <a href="#record_access_type-1">record_access_type/1</a>, <a href="#record_expr-3">record_expr/3</a>.</p><h4>record_access_argument(Node::) -&gt;</h4><p>Returns the argument subtree of a record_access node.</p><a name="record_access_argument-1"></a><p>Returns the argument subtree of a <strong>record_access</strong> node.
</p><p><em>See also:</em> <a href="#record_access-3">record_access/3</a>.</p><h4>record_access_field(Node::) -&gt;</h4><p>Returns the field subtree of a record_access node.</p><a name="record_access_field-1"></a><p>Returns the field subtree of a <strong>record_access</strong> node.
</p><p><em>See also:</em> <a href="#record_access-3">record_access/3</a>.</p><h4>record_access_type(Node::) -&gt;</h4><p>Returns the type subtree of a record_access node.</p><a name="record_access_type-1"></a><p>Returns the type subtree of a <strong>record_access</strong> node.
</p><p><em>See also:</em> <a href="#record_access-3">record_access/3</a>.</p><h4>record_expr(Type::, Fields::[]) -&gt;</h4><p>Equivalent to record_expr(none, Type, Fields). </p><a name="record_expr-2"></a><p>Equivalent to <a href="#record_expr-3">record_expr(none, Type, Fields)</a>.</p><h4>record_expr(Argument::none |, Type::, Fields::[]) -&gt;</h4><p>Creates an abstract record expression.</p><a name="record_expr-3"></a><p>Creates an abstract record expression. If <strong>Fields</strong> is
<strong>[F1, ..., Fn]</strong>, then if <strong>Argument</strong> is
<strong>none</strong>, the result represents
"<strong>#Type{F1, ..., Fn}</strong>",
otherwise it represents
"<strong>Argument#Type{F1, ..., Fn}</strong>".
</p><p><em>See also:</em> <a href="#record_access-3">record_access/3</a>, <a href="#record_expr-2">record_expr/2</a>, <a href="#record_expr_argument-1">record_expr_argument/1</a>, <a href="#record_expr_fields-1">record_expr_fields/1</a>, <a href="#record_expr_type-1">record_expr_type/1</a>, <a href="#record_field-2">record_field/2</a>, <a href="#record_index_expr-2">record_index_expr/2</a>.</p><h4>record_expr_argument(Node::) -&gt; none |</h4><p>Returns the argument subtree of a record_expr node, if any.</p><a name="record_expr_argument-1"></a><p>Returns the argument subtree of a <strong>record_expr</strong> node,
if any. If <strong>Node</strong> represents
"<strong>#Type{...}</strong>", <strong>none</strong> is returned.
Otherwise, if <strong>Node</strong> represents
"<strong>Argument#Type{...}</strong>",
<strong>Argument</strong> is returned.
</p><p><em>See also:</em> <a href="#record_expr-3">record_expr/3</a>.</p><h4>record_expr_fields(Node::) -&gt; []</h4><p>Returns the list of field subtrees of a record_expr node.</p><a name="record_expr_fields-1"></a><p>Returns the list of field subtrees of a
<strong>record_expr</strong> node.
</p><p><em>See also:</em> <a href="#record_expr-3">record_expr/3</a>.</p><h4>record_expr_type(Node::) -&gt;</h4><p>Returns the type subtree of a record_expr node.</p><a name="record_expr_type-1"></a><p>Returns the type subtree of a <strong>record_expr</strong> node.
</p><p><em>See also:</em> <a href="#record_expr-3">record_expr/3</a>.</p><h4>record_field(Name::) -&gt;</h4><p>Equivalent to record_field(Name, none). </p><a name="record_field-1"></a><p>Equivalent to <a href="#record_field-2">record_field(Name, none)</a>.</p><h4>record_field(Name::, Value::none |) -&gt;</h4><p>Creates an abstract record field specification.</p><a name="record_field-2"></a><p>Creates an abstract record field specification. If
<strong>Value</strong> is <strong>none</strong>, the result represents
simply "<strong>Name</strong>", otherwise it represents
"<strong>Name = Value</strong>".
</p><p><em>See also:</em> <a href="#record_expr-3">record_expr/3</a>, <a href="#record_field_name-1">record_field_name/1</a>, <a href="#record_field_value-1">record_field_value/1</a>.</p><h4>record_field_name(Node::) -&gt;</h4><p>Returns the name subtree of a record_field node.</p><a name="record_field_name-1"></a><p>Returns the name subtree of a <strong>record_field</strong> node.
</p><p><em>See also:</em> <a href="#record_field-2">record_field/2</a>.</p><h4>record_field_value(Node::) -&gt; none |</h4><p>Returns the value subtree of a record_field node, if any.</p><a name="record_field_value-1"></a><p>Returns the value subtree of a <strong>record_field</strong> node,
if any. If <strong>Node</strong> represents
"<strong>Name</strong>", <strong>none</strong> is
returned. Otherwise, if <strong>Node</strong> represents
"<strong>Name = Value</strong>", <strong>Value</strong>
is returned.
</p><p><em>See also:</em> <a href="#record_field-2">record_field/2</a>.</p><h4>record_index_expr(Type::, Field::) -&gt;</h4><p>Creates an abstract record field index expression.</p><a name="record_index_expr-2"></a><p>Creates an abstract record field index expression. The result
represents "<strong>#Type.Field</strong>".</p><p>(Note: the function name <strong>record_index/2</strong> is reserved
by the Erlang compiler, which is why that name could not be used
for this constructor.)
</p><p><em>See also:</em> <a href="#record_expr-3">record_expr/3</a>, <a href="#record_index_expr_field-1">record_index_expr_field/1</a>, <a href="#record_index_expr_type-1">record_index_expr_type/1</a>.</p><h4>record_index_expr_field(Node::) -&gt;</h4><p>Returns the field subtree of a record_index_expr node.</p><a name="record_index_expr_field-1"></a><p>Returns the field subtree of a <strong>record_index_expr</strong> node.
</p><p><em>See also:</em> <a href="#record_index_expr-2">record_index_expr/2</a>.</p><h4>record_index_expr_type(Node::) -&gt;</h4><p>Returns the type subtree of a record_index_expr node.</p><a name="record_index_expr_type-1"></a><p>Returns the type subtree of a <strong>record_index_expr</strong> node.
</p><p><em>See also:</em> <a href="#record_index_expr-2">record_index_expr/2</a>.</p><h4>record_type(Name::, Fields::[]) -&gt;</h4><p>Creates an abstract record type.</p><a name="record_type-2"></a><p>Creates an abstract record type. If <strong>Fields</strong> is
<strong>[F1, ..., Fn]</strong>, the result represents
"<strong>#Name{F1, ..., Fn}</strong>".
</p><p><em>See also:</em> <a href="#record_type_fields-1">record_type_fields/1</a>, <a href="#record_type_name-1">record_type_name/1</a>.</p><h4>record_type_field(Name::, Type::) -&gt;</h4><p>Creates an abstract record type field.</p><a name="record_type_field-2"></a><p>Creates an abstract record type field. The result represents
"<strong>Name :: Type</strong>".
</p><p><em>See also:</em> <a href="#record_type_field_name-1">record_type_field_name/1</a>, <a href="#record_type_field_type-1">record_type_field_type/1</a>.</p><h4>record_type_field_name(Node::) -&gt;</h4><p>Returns the name subtree of a record_type_field node.</p><a name="record_type_field_name-1"></a><p>Returns the name subtree of a <strong>record_type_field</strong> node.
</p><p><em>See also:</em> <a href="#record_type_field-2">record_type_field/2</a>.</p><h4>record_type_field_type(Node::) -&gt;</h4><p>Returns the type subtree of a record_type_field node.</p><a name="record_type_field_type-1"></a><p>Returns the type subtree of a <strong>record_type_field</strong> node.
</p><p><em>See also:</em> <a href="#record_type_field-2">record_type_field/2</a>.</p><h4>record_type_fields(Node::) -&gt; []</h4><p>Returns the fields subtree of a record_type node.</p><a name="record_type_fields-1"></a><p>Returns the fields subtree of a <strong>record_type</strong> node.
</p><p><em>See also:</em> <a href="#record_type-2">record_type/2</a>.</p><h4>record_type_name(Node::) -&gt;</h4><p>Returns the name subtree of a record_type node.</p><a name="record_type_name-1"></a><p>Returns the name subtree of a <strong>record_type</strong> node.
</p><p><em>See also:</em> <a href="#record_type-2">record_type/2</a>.</p><h4>remove_comments(Node::) -&gt;</h4><p>Clears the associated comments of Node.</p><a name="remove_comments-1"></a><p>Clears the associated comments of <strong>Node</strong>.</p><p>Note: This is equivalent to
<strong>set_precomments(set_postcomments(Node, []), [])</strong>, but
potentially more efficient.
</p><p><em>See also:</em> <a href="#set_postcomments-2">set_postcomments/2</a>, <a href="#set_precomments-2">set_precomments/2</a>.</p><h4>revert(Node::) -&gt;</h4><p>Returns an erl_parse-compatible representation of a syntax tree, if possible.</p><a name="revert-1"></a><p>Returns an <strong>erl_parse</strong>-compatible representation of a
syntax tree, if possible. If <strong>Tree</strong> represents a
well-formed Erlang program or expression, the conversion should work
without problems. Typically, <a href="#is_tree-1">is_tree/1</a> yields
<strong>true</strong> if conversion failed (i.e., the result is still an
abstract syntax tree), and <strong>false</strong> otherwise.</p><p>The <a href="#is_tree-1">is_tree/1</a> test is not completely foolproof. For a
few special node types (e.g. <strong>arity_qualifier</strong>), if such a
node occurs in a context where it is not expected, it will be left
unchanged as a non-reverted subtree of the result. This can only
happen if <strong>Tree</strong> does not actually represent legal Erlang
code.
</p><p><em>See also:</em> <a href="./erl_parse">erl_parse(3)</a>, <a href="#revert_forms-1">revert_forms/1</a>.</p><h4>revert_forms(Forms::) -&gt; []</h4><p>Reverts a sequence of Erlang source code forms.</p><a name="revert_forms-1"></a><p>Reverts a sequence of Erlang source code forms. The sequence can
be given either as a <strong>form_list</strong> syntax tree (possibly
nested), or as a list of "program form" syntax trees. If successful,
the corresponding flat list of <strong>erl_parse</strong>-compatible
syntax trees is returned (see <a href="#revert-1">revert/1</a>). If some program
form could not be reverted, <strong>{error, Form}</strong> is thrown.
Standalone comments in the form sequence are discarded.
</p><p><em>See also:</em> <a href="#form_list-1">form_list/1</a>, <a href="#is_form-1">is_form/1</a>, <a href="#revert-1">revert/1</a>.</p><h4>set_ann(Node::, As::[term()]) -&gt;</h4><p>Sets the list of user annotations of Node to Annotations.</p><a name="set_ann-2"></a><p>Sets the list of user annotations of <strong>Node</strong> to <strong>Annotations</strong>.
</p><p><em>See also:</em> <a href="#add_ann-2">add_ann/2</a>, <a href="#copy_ann-2">copy_ann/2</a>, <a href="#get_ann-1">get_ann/1</a>.</p><h4>set_attrs(Node::, Attr::) -&gt;</h4><p>Sets the attributes of Node to Attributes.</p><a name="set_attrs-2"></a><p>Sets the attributes of <strong>Node</strong> to <strong>Attributes</strong>.
</p><p><em>See also:</em> <a href="#copy_attrs-2">copy_attrs/2</a>, <a href="#get_attrs-1">get_attrs/1</a>.</p><h4>set_pos(Node::, Pos::term()) -&gt;</h4><p>Sets the position information of Node to Pos.</p><a name="set_pos-2"></a><p>Sets the position information of <strong>Node</strong> to <strong>Pos</strong>.
</p><p><em>See also:</em> <a href="#copy_pos-2">copy_pos/2</a>, <a href="#get_pos-1">get_pos/1</a>.</p><h4>set_postcomments(Node::, Cs::[]) -&gt;</h4><p>Sets the post-comments of Node to Comments.</p><a name="set_postcomments-2"></a><p>Sets the post-comments of <strong>Node</strong> to
<strong>Comments</strong>. <strong>Comments</strong> should be a possibly
empty list of abstract comments, in top-down textual order
</p><p><em>See also:</em> <a href="#add_postcomments-2">add_postcomments/2</a>, <a href="#comment-2">comment/2</a>, <a href="#copy_comments-2">copy_comments/2</a>, <a href="#get_postcomments-1">get_postcomments/1</a>, <a href="#join_comments-2">join_comments/2</a>, <a href="#remove_comments-1">remove_comments/1</a>, <a href="#set_precomments-2">set_precomments/2</a>.</p><h4>set_precomments(Node::, Cs::[]) -&gt;</h4><p>Sets the pre-comments of Node to Comments.</p><a name="set_precomments-2"></a><p>Sets the pre-comments of <strong>Node</strong> to
<strong>Comments</strong>. <strong>Comments</strong> should be a possibly
empty list of abstract comments, in top-down textual order.
</p><p><em>See also:</em> <a href="#add_precomments-2">add_precomments/2</a>, <a href="#comment-2">comment/2</a>, <a href="#copy_comments-2">copy_comments/2</a>, <a href="#get_precomments-1">get_precomments/1</a>, <a href="#join_comments-2">join_comments/2</a>, <a href="#remove_comments-1">remove_comments/1</a>, <a href="#set_postcomments-2">set_postcomments/2</a>.</p><h4>size_qualifier(Body::, Size::) -&gt;</h4><p>Creates an abstract size qualifier.</p><a name="size_qualifier-2"></a><p>Creates an abstract size qualifier. The result represents
"<strong>Body:Size</strong>".
</p><p><em>See also:</em> <a href="#size_qualifier_argument-1">size_qualifier_argument/1</a>, <a href="#size_qualifier_body-1">size_qualifier_body/1</a>.</p><h4>size_qualifier_argument(Node::) -&gt;</h4><p>Returns the argument subtree (the size) of a size_qualifier node.</p><a name="size_qualifier_argument-1"></a><p>Returns the argument subtree (the size) of a
<strong>size_qualifier</strong> node.
</p><p><em>See also:</em> <a href="#size_qualifier-2">size_qualifier/2</a>.</p><h4>size_qualifier_body(Node::) -&gt;</h4><p>Returns the body subtree of a size_qualifier node.</p><a name="size_qualifier_body-1"></a><p>Returns the body subtree of a <strong>size_qualifier</strong> node.
</p><p><em>See also:</em> <a href="#size_qualifier-2">size_qualifier/2</a>.</p><h4>string(String::string()) -&gt;</h4><p>Creates an abstract string literal.</p><a name="string-1"></a><p>Creates an abstract string literal. The result represents
<strong>"Text"</strong> (including the surrounding
double-quotes), where <strong>Text</strong> corresponds to the sequence
of characters in <strong>Value</strong>, but not representing a
<em>specific</em> string literal.</p><p>For example, the result of <strong>string("x\ny")</strong> represents any and all of
<strong>"x\ny"</strong>, <strong>"x\12y"</strong>, <strong>"x\012y"</strong> and <strong>"x\^Jy"</strong>; see <a href="#char-1">char/1</a>.
</p><p><em>See also:</em> <a href="#char-1">char/1</a>, <a href="#is_string-2">is_string/2</a>, <a href="#string_literal-1">string_literal/1</a>, <a href="#string_literal-2">string_literal/2</a>, <a href="#string_value-1">string_value/1</a>.</p><h4>string_literal(Node::) -&gt; nonempty_string()</h4><p>Returns the literal string represented by a string node.</p><a name="string_literal-1"></a><p>Returns the literal string represented by a <strong>string</strong>
node. This includes surrounding double-quote characters.
Characters beyond 255 will be escaped.
</p><p><em>See also:</em> <a href="#string-1">string/1</a>.</p><h4>string_literal(Node::, X2::) -&gt; nonempty_string()</h4><p>Returns the literal string represented by a string node.</p><a name="string_literal-2"></a><p>Returns the literal string represented by a <strong>string</strong>
node. This includes surrounding double-quote characters.
Depending on the encoding characters beyond 255 will be escaped
(<strong>latin1</strong>) or copied as is (<strong>utf8</strong>).
</p><p><em>See also:</em> <a href="#string-1">string/1</a>.</p><h4>string_value(Node::) -&gt; string()</h4><p>Returns the value represented by a string node.</p><a name="string_value-1"></a><p>Returns the value represented by a <strong>string</strong> node.
</p><p><em>See also:</em> <a href="#string-1">string/1</a>.</p><h4>subtrees(T::) -&gt; [[]]</h4><p>Returns the grouped list of all subtrees of a syntax tree.</p><a name="subtrees-1"></a><p>Returns the grouped list of all subtrees of a syntax tree. If
<strong>Node</strong> is a leaf node (see <a href="#is_leaf-1">is_leaf/1</a>), this
is the empty list, otherwise the result is always a nonempty list,
containing the lists of subtrees of <strong>Node</strong>, in  
left-to-right order as they occur in the printed program text, and  
grouped by category. Often, each group contains only a single  
subtree.</p><p>Depending on the type of <strong>Node</strong>, the size of some  
groups may be variable (e.g., the group consisting of all the  
elements of a tuple), while others always contain the same number of  
elements - usually exactly one (e.g., the group containing the  
argument expression of a case-expression). Note, however, that the  
exact structure of the returned list (for a given node type) should  
in general not be depended upon, since it might be subject to change  
without notice.</p><p>The function <a href="#subtrees-1">subtrees/1</a> and the constructor functions
<a href="#make_tree-2">make_tree/2</a> and <a href="#update_tree-2">update_tree/2</a> can be a  
great help if one wants to traverse a syntax tree, visiting all its  
subtrees, but treat nodes of the tree in a uniform way in most or all  
cases. Using these functions makes this simple, and also assures that  
your code is not overly sensitive to extensions of the syntax tree  
data type, because any node types not explicitly handled by your code  
can be left to a default case.</p><p>For example:
</p><pre>     postorder(F, Tree) -&gt;
        F(case subtrees(Tree) of
            [] -&gt; Tree;
            List -&gt; update_tree(Tree,
                                [[postorder(F, Subtree)
                                  || Subtree &amp;lt;- Group]
                                 || Group &amp;lt;- List])
          end).</pre><p>
maps the function <strong>F</strong> on <strong>Tree</strong> and all its
subtrees, doing a post-order traversal of the syntax tree. (Note the
use of <a href="#update_tree-2">update_tree/2</a> to preserve node attributes.) For a
simple function like:
</p><pre>     f(Node) -&gt;
        case type(Node) of
            atom -&gt; atom("a_" ++ atom_name(Node));
            _ -&gt; Node
        end.</pre><p>
the call <strong>postorder(fun f/1, Tree)</strong> will yield a new
representation of <strong>Tree</strong> in which all atom names have been
extended with the prefix "a_", but nothing else (including comments,
annotations and line numbers) has been changed.
</p><p><em>See also:</em> <a href="#copy_attrs-2">copy_attrs/2</a>, <a href="#is_leaf-1">is_leaf/1</a>, <a href="#make_tree-2">make_tree/2</a>, <a href="#type-1">type/1</a>.</p><h4>text(String::string()) -&gt;</h4><p>Creates an abstract piece of source code text.</p><a name="text-1"></a><p>Creates an abstract piece of source code text. The result
represents exactly the sequence of characters in <strong>String</strong>.
This is useful in cases when one wants full control of the resulting
output, e.g., for the appearance of floating-point numbers or macro
definitions.
</p><p><em>See also:</em> <a href="#text_string-1">text_string/1</a>.</p><h4>text_string(Node::) -&gt; string()</h4><p>Returns the character sequence represented by a text node.</p><a name="text_string-1"></a><p>Returns the character sequence represented by a <strong>text</strong> node.
</p><p><em>See also:</em> <a href="#text-1">text/1</a>.</p><h4>tree(Type::atom()) -&gt; #tree{type=atom(), attr=#attr{pos=term(), ann=[term()], com=none | #com{pre=[], post=[]}}, data=term()}</h4><p>Equivalent to tree(Type, []). </p><a name="tree-1"></a><p>Equivalent to <a href="#tree-2">tree(Type, [])</a>.</p><h4>tree(Type::atom(), Data::term()) -&gt; #tree{type=atom(), attr=#attr{pos=term(), ann=[term()], com=none | #com{pre=[], post=[]}}, data=term()}</h4><p>For special purposes only.</p><a name="tree-2"></a><p><em>For special purposes only</em>. Creates an abstract syntax
tree node with type tag <strong>Type</strong> and associated data
<strong>Data</strong>.</p><p>This function and the related <a href="#is_tree-1">is_tree/1</a> and
<a href="#data-1">data/1</a> provide a uniform way to extend the set of
<strong>erl_parse</strong> node types. The associated data is any term,  
whose format may depend on the type tag.</p><p><a name="Notes:"></a><em>Notes:</em>
</p><ul><li><p>Any nodes created outside of this module must have type tags
distinct from those currently defined by this module; see
<a href="#type-1">type/1</a> for a complete list.</p></li><li><p>The type tag of a syntax tree node may also be used
as a primary tag by the <strong>erl_parse</strong> representation;
in that case, the selector functions for that node type
<em>must</em> handle both the abstract syntax tree and the
<strong>erl_parse</strong> form. The function <strong>type(T)</strong>
should return the correct type tag regardless of the
representation of <strong>T</strong>, so that the user sees no
difference between <strong>erl_syntax</strong> and
<strong>erl_parse</strong> nodes.</p></li></ul><p>
</p><p><em>See also:</em> <a href="#data-1">data/1</a>, <a href="#is_tree-1">is_tree/1</a>, <a href="#type-1">type/1</a>.</p><h4>try_after_expr(Body::[], After::[]) -&gt;</h4><p>Equivalent to try_expr(Body, [], [], After). </p><a name="try_after_expr-2"></a><p>Equivalent to <a href="#try_expr-4">try_expr(Body, [], [], After)</a>.</p><h4>try_expr(Body::[], Handlers::[]) -&gt;</h4><p>Equivalent to try_expr(Body, [], Handlers). </p><a name="try_expr-2"></a><p>Equivalent to <a href="#try_expr-3">try_expr(Body, [], Handlers)</a>.</p><h4>try_expr(Body::[], Clauses::[], Handlers::[]) -&gt;</h4><p>Equivalent to try_expr(Body, Clauses, Handlers, []). </p><a name="try_expr-3"></a><p>Equivalent to <a href="#try_expr-4">try_expr(Body, Clauses, Handlers, [])</a>.</p><h4>try_expr(Body::[], Clauses::[], Handlers::[], After::[]) -&gt;</h4><p>Creates an abstract try-expression.</p><a name="try_expr-4"></a><p>Creates an abstract try-expression. If <strong>Body</strong> is
<strong>[B1, ..., Bn]</strong>, <strong>Clauses</strong> is <strong>[C1, ..., Cj]</strong>, <strong>Handlers</strong> is <strong>[H1, ..., Hk]</strong>, and
<strong>After</strong> is <strong>[A1, ..., Am]</strong>, the result
represents "<strong>try B1, ..., Bn of C1; ...; Cj catch H1; ...; Hk after A1, ..., Am end</strong>". More exactly, if each
<strong>Ci</strong> represents "<strong>(CPi) CGi -&gt; CBi</strong>", and each <strong>Hi</strong> represents
"<strong>(HPi) HGi -&gt; HBi</strong>", then the
result represents "<strong>try B1, ..., Bn of CP1 CG1 -&gt; CB1; ...; CPj CGj -&gt; CBj catch HP1 HG1 -&gt; HB1; ...; HPk HGk -&gt; HBk after A1, ..., Am end</strong>"; see
<a href="#case_expr-2">case_expr/2</a>. If <strong>Clauses</strong> is the empty list,
the <strong>of ...</strong> section is left out. If <strong>After</strong> is
the empty list, the <strong>after ...</strong> section is left out. If
<strong>Handlers</strong> is the empty list, and <strong>After</strong> is
nonempty, the <strong>catch ...</strong> section is left out.
</p><p><em>See also:</em> <a href="#case_expr-2">case_expr/2</a>, <a href="#class_qualifier-2">class_qualifier/2</a>, <a href="#clause-3">clause/3</a>, <a href="#try_after_expr-2">try_after_expr/2</a>, <a href="#try_expr-2">try_expr/2</a>, <a href="#try_expr-3">try_expr/3</a>, <a href="#try_expr_after-1">try_expr_after/1</a>, <a href="#try_expr_body-1">try_expr_body/1</a>, <a href="#try_expr_clauses-1">try_expr_clauses/1</a>, <a href="#try_expr_handlers-1">try_expr_handlers/1</a>.</p><h4>try_expr_after(Node::) -&gt; []</h4><p>Returns the list of "after" subtrees of a try_expr node.</p><a name="try_expr_after-1"></a><p>Returns the list of "after" subtrees of a <strong>try_expr</strong> node.
</p><p><em>See also:</em> <a href="#try_expr-4">try_expr/4</a>.</p><h4>try_expr_body(Node::) -&gt; []</h4><p>Returns the list of body subtrees of a try_expr node.</p><a name="try_expr_body-1"></a><p>Returns the list of body subtrees of a <strong>try_expr</strong> node.
</p><p><em>See also:</em> <a href="#try_expr-4">try_expr/4</a>.</p><h4>try_expr_clauses(Node::) -&gt; []</h4><p>Returns the list of case-clause subtrees of a try_expr node.</p><a name="try_expr_clauses-1"></a><p>Returns the list of case-clause subtrees of a
<strong>try_expr</strong> node. If <strong>Node</strong> represents
"<strong>try Body catch H1; ...; Hn end</strong>", the result is the empty list.
</p><p><em>See also:</em> <a href="#try_expr-4">try_expr/4</a>.</p><h4>try_expr_handlers(Node::) -&gt; []</h4><p>Returns the list of handler-clause subtrees of a try_expr node.</p><a name="try_expr_handlers-1"></a><p>Returns the list of handler-clause subtrees of a
<strong>try_expr</strong> node.
</p><p><em>See also:</em> <a href="#try_expr-4">try_expr/4</a>.</p><h4>tuple(List::[]) -&gt;</h4><p>Creates an abstract tuple.</p><a name="tuple-1"></a><p>Creates an abstract tuple. If <strong>Elements</strong> is
<strong>[X1, ..., Xn]</strong>, the result represents
"<strong>{X1, ..., Xn}</strong>".</p><p>Note: The Erlang language has distinct 1-tuples, i.e.,
<strong>{X}</strong> is always distinct from <strong>X</strong> itself.
</p><p><em>See also:</em> <a href="#tuple_elements-1">tuple_elements/1</a>, <a href="#tuple_size-1">tuple_size/1</a>.</p><h4>tuple_elements(Node::) -&gt; []</h4><p>Returns the list of element subtrees of a tuple node.</p><a name="tuple_elements-1"></a><p>Returns the list of element subtrees of a <strong>tuple</strong> node.
</p><p><em>See also:</em> <a href="#tuple-1">tuple/1</a>.</p><h4>tuple_size(Node::) -&gt; non_neg_integer()</h4><p>Returns the number of elements of a tuple node.</p><a name="tuple_size-1"></a><p>Returns the number of elements of a <strong>tuple</strong> node.</p><p>Note: this is equivalent to
<strong>length(tuple_elements(Node))</strong>, but potentially more
efficient.
</p><p><em>See also:</em> <a href="#tuple-1">tuple/1</a>, <a href="#tuple_elements-1">tuple_elements/1</a>.</p><h4>tuple_type() -&gt; term()
</h4><p>Equivalent to tuple_type(any_size). </p><a name="tuple_type-0"></a><p>Equivalent to <a href="#tuple_type-1">tuple_type(any_size)</a>.</p><h4>tuple_type(Elements::any_size | []) -&gt;</h4><p>Creates an abstract type tuple.</p><a name="tuple_type-1"></a><p>Creates an abstract type tuple. If <strong>Elements</strong> is
<strong>[T1, ..., Tn]</strong>, the result represents
"<strong>{T1, ..., Tn}</strong>";
otherwise, if <strong>Elements</strong> is <strong>any_size</strong>, it represents
"<strong>tuple()</strong>".
</p><p><em>See also:</em> <a href="#tuple_type_elements-1">tuple_type_elements/1</a>.</p><h4>tuple_type_elements(Node::) -&gt; any_size | []</h4><p>Returns the list of type element subtrees of a tuple_type node.</p><a name="tuple_type_elements-1"></a><p>Returns the list of type element subtrees of a <strong>tuple_type</strong> node.
If <strong>Node</strong> represents "<strong>tuple()</strong>", <strong>any_size</strong> is returned;
otherwise, if <strong>Node</strong> represents
"<strong>{T1, ..., Tn}</strong>",
<strong>[T1, ..., Tn]</strong> is returned.
</p><p><em>See also:</em> <a href="#tuple_type-0">tuple_type/0</a>, <a href="#tuple_type-1">tuple_type/1</a>.</p><h4>type(Tree::) -&gt; atom()</h4><p>Returns the type tag of Node.</p><a name="type-1"></a><p>Returns the type tag of <strong>Node</strong>. If <strong>Node</strong>
does not represent a syntax tree, evaluation fails with reason
<strong>badarg</strong>. Node types currently defined by this module are:</p><p>
application
annotated_type
arity_qualifier
atom
<br/>
attribute
binary
binary_field
bitstring_type
<br/>
block_expr
case_expr
catch_expr
char
<br/>
class_qualifier
clause
comment
cond_expr
<br/>
conjunction
constrained_function_type
constraint
disjunction
<br/>
eof_marker
error_marker
float
form_list
<br/>
fun_expr
fun_type
function
function_type
<br/>
generator
if_expr
implicit_fun
infix_expr
<br/>
integer
integer_range_type
list
list_comp
<br/>
macro
map_expr
map_field_assoc
map_field_exact
<br/>
map_type
map_type_assoc
map_type_exact
match_expr
module_qualifier
<br/>
named_fun_expr
nil
operator
parentheses
<br/>
prefix_expr
receive_expr
record_access
record_expr
<br/>
record_field
record_index_expr
record_type
record_type_field
<br/>
size_qualifier
string
text
try_expr
<br/>
tuple
tuple_type
typed_record_field
type_application
type_union
underscore
user_type_application
variable
<br/>
warning_marker
<br/>
</p><p>The user may (for special purposes) create additional nodes
with other type tags, using the <a href="#tree-2">tree/2</a> function.</p><p>Note: The primary constructor functions for a node type should
always have the same name as the node type itself.
</p><p><em>See also:</em> <a href="#annotated_type-2">annotated_type/2</a>, <a href="#application-3">application/3</a>, <a href="#arity_qualifier-2">arity_qualifier/2</a>, <a href="#atom-1">atom/1</a>, <a href="#attribute-2">attribute/2</a>, <a href="#binary-1">binary/1</a>, <a href="#binary_field-2">binary_field/2</a>, <a href="#bitstring_type-2">bitstring_type/2</a>, <a href="#block_expr-1">block_expr/1</a>, <a href="#case_expr-2">case_expr/2</a>, <a href="#catch_expr-1">catch_expr/1</a>, <a href="#char-1">char/1</a>, <a href="#class_qualifier-2">class_qualifier/2</a>, <a href="#clause-3">clause/3</a>, <a href="#comment-2">comment/2</a>, <a href="#cond_expr-1">cond_expr/1</a>, <a href="#conjunction-1">conjunction/1</a>, <a href="#constrained_function_type-2">constrained_function_type/2</a>, <a href="#constraint-2">constraint/2</a>, <a href="#disjunction-1">disjunction/1</a>, <a href="#eof_marker-0">eof_marker/0</a>, <a href="#error_marker-1">error_marker/1</a>, <a href="#float-1">float/1</a>, <a href="#form_list-1">form_list/1</a>, <a href="#fun_expr-1">fun_expr/1</a>, <a href="#fun_type-0">fun_type/0</a>, <a href="#function-2">function/2</a>, <a href="#function_type-1">function_type/1</a>, <a href="#function_type-2">function_type/2</a>, <a href="#generator-2">generator/2</a>, <a href="#if_expr-1">if_expr/1</a>, <a href="#implicit_fun-2">implicit_fun/2</a>, <a href="#infix_expr-3">infix_expr/3</a>, <a href="#integer-1">integer/1</a>, <a href="#integer_range_type-2">integer_range_type/2</a>, <a href="#list-2">list/2</a>, <a href="#list_comp-2">list_comp/2</a>, <a href="#macro-2">macro/2</a>, <a href="#map_expr-2">map_expr/2</a>, <a href="#map_field_assoc-2">map_field_assoc/2</a>, <a href="#map_field_exact-2">map_field_exact/2</a>, <a href="#map_type-0">map_type/0</a>, <a href="#map_type-1">map_type/1</a>, <a href="#map_type_assoc-2">map_type_assoc/2</a>, <a href="#map_type_exact-2">map_type_exact/2</a>, <a href="#match_expr-2">match_expr/2</a>, <a href="#module_qualifier-2">module_qualifier/2</a>, <a href="#named_fun_expr-2">named_fun_expr/2</a>, <a href="#nil-0">nil/0</a>, <a href="#operator-1">operator/1</a>, <a href="#parentheses-1">parentheses/1</a>, <a href="#prefix_expr-2">prefix_expr/2</a>, <a href="#receive_expr-3">receive_expr/3</a>, <a href="#record_access-3">record_access/3</a>, <a href="#record_expr-2">record_expr/2</a>, <a href="#record_field-2">record_field/2</a>, <a href="#record_index_expr-2">record_index_expr/2</a>, <a href="#record_type-2">record_type/2</a>, <a href="#record_type_field-2">record_type_field/2</a>, <a href="#size_qualifier-2">size_qualifier/2</a>, <a href="#string-1">string/1</a>, <a href="#text-1">text/1</a>, <a href="#tree-2">tree/2</a>, <a href="#try_expr-3">try_expr/3</a>, <a href="#tuple-1">tuple/1</a>, <a href="#tuple_type-0">tuple_type/0</a>, <a href="#tuple_type-1">tuple_type/1</a>, <a href="#type_application-2">type_application/2</a>, <a href="#type_union-1">type_union/1</a>, <a href="#typed_record_field-2">typed_record_field/2</a>, <a href="#underscore-0">underscore/0</a>, <a href="#user_type_application-2">user_type_application/2</a>, <a href="#variable-1">variable/1</a>, <a href="#warning_marker-1">warning_marker/1</a>.</p><h4>type_application(TypeName::, Arguments::[]) -&gt;</h4><p>Creates an abstract type application expression.</p><a name="type_application-2"></a><p>Creates an abstract type application expression. If <strong>Arguments</strong> is
<strong>[T1, ..., Tn]</strong>, the result represents
"<strong>TypeName(T1, ...Tn)</strong>".
</p><p><em>See also:</em> <a href="#type_application-3">type_application/3</a>, <a href="#type_application_arguments-1">type_application_arguments/1</a>, <a href="#type_application_name-1">type_application_name/1</a>, <a href="#user_type_application-2">user_type_application/2</a>.</p><h4>type_application(Module::none |, TypeName::, Arguments::[]) -&gt;</h4><p>Creates an abstract type application expression.</p><a name="type_application-3"></a><p>Creates an abstract type application expression. If
<strong>Module</strong> is <strong>none</strong>, this is call is equivalent
to <strong>type_application(TypeName, Arguments)</strong>, otherwise it is
equivalent to <strong>type_application(module_qualifier(Module, TypeName), Arguments)</strong>.</p><p>(This is a utility function.)
</p><p><em>See also:</em> <a href="#module_qualifier-2">module_qualifier/2</a>, <a href="#type_application-2">type_application/2</a>.</p><h4>type_application_arguments(Node::) -&gt; []</h4><p>Returns the arguments subtrees of a type_application node.</p><a name="type_application_arguments-1"></a><p>Returns the arguments subtrees of a <strong>type_application</strong> node.
</p><p><em>See also:</em> <a href="#type_application-2">type_application/2</a>.</p><h4>type_application_name(Node::) -&gt;</h4><p>Returns the type name subtree of a type_application node.</p><a name="type_application_name-1"></a><p>Returns the type name subtree of a <strong>type_application</strong> node.
</p><p><em>See also:</em> <a href="#type_application-2">type_application/2</a>.</p><h4>type_union(Types::[]) -&gt;</h4><p>Creates an abstract type union.</p><a name="type_union-1"></a><p>Creates an abstract type union. If <strong>Types</strong> is
<strong>[T1, ..., Tn]</strong>, the result represents
"<strong>T1 | ... | Tn</strong>".
</p><p><em>See also:</em> <a href="#type_union_types-1">type_union_types/1</a>.</p><h4>type_union_types(Node::) -&gt; []</h4><p>Returns the list of type subtrees of a type_union node.</p><a name="type_union_types-1"></a><p>Returns the list of type subtrees of a <strong>type_union</strong> node.
</p><p><em>See also:</em> <a href="#type_union-1">type_union/1</a>.</p><h4>typed_record_field(Field::, Type::) -&gt;</h4><p>Creates an abstract typed record field specification.</p><a name="typed_record_field-2"></a><p>Creates an abstract typed record field specification. The
result represents "<strong>Field :: Type</strong>".
</p><p><em>See also:</em> <a href="#typed_record_field_body-1">typed_record_field_body/1</a>, <a href="#typed_record_field_type-1">typed_record_field_type/1</a>.</p><h4>typed_record_field_body(Node::) -&gt;</h4><p>Returns the field subtree of a typed_record_field node.</p><a name="typed_record_field_body-1"></a><p>Returns the field subtree of a <strong>typed_record_field</strong> node.
</p><p><em>See also:</em> <a href="#typed_record_field-2">typed_record_field/2</a>.</p><h4>typed_record_field_type(Node::) -&gt;</h4><p>Returns the type subtree of a typed_record_field node.</p><a name="typed_record_field_type-1"></a><p>Returns the type subtree of a <strong>typed_record_field</strong> node.
</p><p><em>See also:</em> <a href="#typed_record_field-2">typed_record_field/2</a>.</p><h4>underscore() -&gt;</h4><p>Creates an abstract universal pattern ("_").</p><a name="underscore-0"></a><p>Creates an abstract universal pattern ("<strong>_</strong>"). The
lexical representation is a single underscore character. Note that
this is <em>not</em> a variable, lexically speaking.
</p><p><em>See also:</em> <a href="#variable-1">variable/1</a>.</p><h4>update_tree(Node::, Groups::[[]]) -&gt;</h4><p>Creates a syntax tree with the same type and attributes as the given tree.</p><a name="update_tree-2"></a><p>Creates a syntax tree with the same type and attributes as the
given tree. This is equivalent to <strong>copy_attrs(Node, make_tree(type(Node), Groups))</strong>.
</p><p><em>See also:</em> <a href="#copy_attrs-2">copy_attrs/2</a>, <a href="#make_tree-2">make_tree/2</a>, <a href="#type-1">type/1</a>.</p><h4>user_type_application(TypeName::, Arguments::[]) -&gt;</h4><p>Creates an abstract user type.</p><a name="user_type_application-2"></a><p>Creates an abstract user type. If <strong>Arguments</strong> is
<strong>[T1, ..., Tn]</strong>, the result represents
"<strong>TypeName(T1, ...Tn)</strong>".
</p><p><em>See also:</em> <a href="#type_application-2">type_application/2</a>, <a href="#user_type_application_arguments-1">user_type_application_arguments/1</a>, <a href="#user_type_application_name-1">user_type_application_name/1</a>.</p><h4>user_type_application_arguments(Node::) -&gt; []</h4><p>Returns the arguments subtrees of a user_type_application node.</p><a name="user_type_application_arguments-1"></a><p>Returns the arguments subtrees of a <strong>user_type_application</strong> node.
</p><p><em>See also:</em> <a href="#user_type_application-2">user_type_application/2</a>.</p><h4>user_type_application_name(Node::) -&gt;</h4><p>Returns the type name subtree of a user_type_application node.</p><a name="user_type_application_name-1"></a><p>Returns the type name subtree of a <strong>user_type_application</strong> node.
</p><p><em>See also:</em> <a href="#user_type_application-2">user_type_application/2</a>.</p><h4>variable(Name::atom() | string()) -&gt;</h4><p>Creates an abstract variable with the given name.</p><a name="variable-1"></a><p>Creates an abstract variable with the given name.
<strong>Name</strong> may be any atom or string that represents a
lexically valid variable name, but <em>not</em> a single underscore
character; see <a href="#underscore-0">underscore/0</a>.</p><p>Note: no checking is done whether the character sequence
represents a proper variable name, i.e., whether or not its first
character is an uppercase Erlang character, or whether it does not
contain control characters, whitespace, etc.
</p><p><em>See also:</em> <a href="#underscore-0">underscore/0</a>, <a href="#variable_literal-1">variable_literal/1</a>, <a href="#variable_name-1">variable_name/1</a>.</p><h4>variable_literal(Node::) -&gt; string()</h4><p>Returns the name of a variable node as a string.</p><a name="variable_literal-1"></a><p>Returns the name of a <strong>variable</strong> node as a string.
</p><p><em>See also:</em> <a href="#variable-1">variable/1</a>.</p><h4>variable_name(Node::) -&gt; atom()</h4><p>Returns the name of a variable node as an atom.</p><a name="variable_name-1"></a><p>Returns the name of a <strong>variable</strong> node as an atom.
</p><p><em>See also:</em> <a href="#variable-1">variable/1</a>.</p><h4>warning_marker(Warning::term()) -&gt;</h4><p>Creates an abstract warning marker.</p><a name="warning_marker-1"></a><p>Creates an abstract warning marker. The result represents an
occurrence of a possible problem in the source code, with an
associated Erlang I/O ErrorInfo structure given by <strong>Error</strong>
(see module <a href="./io">io(3)</a> for details). Warning markers are  
regarded as source code forms, but have no defined lexical form.</p><p>Note: this is supported only for backwards compatibility with
existing parsers and tools.
</p><p><em>See also:</em> <a href="#eof_marker-0">eof_marker/0</a>, <a href="#error_marker-1">error_marker/1</a>, <a href="#is_form-1">is_form/1</a>, <a href="#warning_marker_info-1">warning_marker_info/1</a>.</p><h4>warning_marker_info(Node::) -&gt; term()</h4><p>Returns the ErrorInfo structure of a warning_marker node.</p><a name="warning_marker_info-1"></a><p>Returns the ErrorInfo structure of a <strong>warning_marker</strong> node.
</p><p><em>See also:</em> <a href="#warning_marker-1">warning_marker/1</a>.</p><h3>Authors</h3><span class="aname">Richard Carlsson</span><span class="email">carlsson.richard@gmail.com</span><h3>erl_syntax_lib</h3><p>Support library for abstract Erlang syntax trees.</p><p>Support library for abstract Erlang syntax trees.This module contains utility functions for working with the
abstract data type defined in the module <a href="erl_syntax">erl_syntax</a>.
</p><h4>DATA TYPES</h4><a name="types"></a><dl><dt><a name="type-info_pair"></a>info_pair() = {<a href="#type-key">key()</a>, term()}</dt><dd> </dd><dt><a name="type-key"></a>key() = attributes | errors | exports | functions | imports | module | records | warnings</dt><dd> </dd><dt><a name="type-ordset"></a>ordset(T) = <a href="../stdlib/ordsets#type-ordset">ordsets:ordset(T)</a></dt><dd> </dd><dt><a name="type-set"></a>set(T) = <a href="../stdlib/sets#type-set">sets:set(T)</a></dt><dd> </dd><dt><a name="type-syntaxTree"></a>syntaxTree() = <a href="./erl_syntax#type-syntaxTree">erl_syntax:syntaxTree()</a></dt><dd> <p>An abstract syntax
tree. See the <a href="erl_syntax">erl_syntax</a> module for details.</p> </dd></dl><h3>Functions</h3><h4>analyze_application(Node::) -&gt; FunctionName | Arity</h4><p>Returns the name of a called function.</p><ul><li><span class="v">FunctionName = {atom(), Arity} | {ModuleName, FunctionName}</span></li><li><span class="v">Arity = integer()</span></li><li><span class="v">ModuleName = atom()</span></li></ul><a name="analyze_application-1"></a><p>Returns the name of a called function. The result is a
representation of the name of the applied function <strong>F/A</strong>,
if <strong>Node</strong> represents a function application
"<strong>&lt;em&gt;F&lt;/em&gt;(&lt;em&gt;X_1&lt;/em&gt;, ..., &lt;em&gt;X_A&lt;/em&gt;)</strong>". If the
function is not explicitly named (i.e., <strong>F</strong> is given by
some expression), only the arity <strong>A</strong> is returned.</p><p>The evaluation throws <strong>syntax_error</strong> if <strong>Node</strong> does not represent a
well-formed application expression.
</p><p><em>See also:</em> <a href="#analyze_function_name-1">analyze_function_name/1</a>.</p><h4>analyze_attribute(Node::) -&gt; preprocessor | {atom(), atom()}</h4><p>Analyzes an attribute node.</p><a name="analyze_attribute-1"></a><p>Analyzes an attribute node. If <strong>Node</strong> represents a
preprocessor directive, the atom <strong>preprocessor</strong> is
returned. Otherwise, if <strong>Node</strong> represents a module
attribute "<strong>-&lt;em&gt;Name&lt;/em&gt;...</strong>", a tuple <strong>{Name, Info}</strong> is returned, where <strong>Info</strong> depends on
<strong>Name</strong>, as follows:
</p><dl><dt><strong>{module, Info}</strong></dt><dd><p>where <strong>Info = analyze_module_attribute(Node)</strong>.</p></dd><dt><strong>{export, Info}</strong></dt><dd><p>where <strong>Info = analyze_export_attribute(Node)</strong>.</p></dd><dt><strong>{import, Info}</strong></dt><dd><p>where <strong>Info = analyze_import_attribute(Node)</strong>.</p></dd><dt><strong>{file, Info}</strong></dt><dd><p>where <strong>Info = analyze_file_attribute(Node)</strong>.</p></dd><dt><strong>{record, Info}</strong></dt><dd><p>where <strong>Info = analyze_record_attribute(Node)</strong>.</p></dd><dt><strong>{Name, Info}</strong></dt><dd><p>where <strong>{Name, Info} = analyze_wild_attribute(Node)</strong>.</p></dd></dl><p>
The evaluation throws <strong>syntax_error</strong> if <strong>Node</strong>
does not represent a well-formed module attribute.
</p><p><em>See also:</em> <a href="#analyze_export_attribute-1">analyze_export_attribute/1</a>, <a href="#analyze_file_attribute-1">analyze_file_attribute/1</a>, <a href="#analyze_import_attribute-1">analyze_import_attribute/1</a>, <a href="#analyze_module_attribute-1">analyze_module_attribute/1</a>, <a href="#analyze_record_attribute-1">analyze_record_attribute/1</a>, <a href="#analyze_wild_attribute-1">analyze_wild_attribute/1</a>.</p><h4>analyze_export_attribute(Node::) -&gt; [FunctionName]</h4><p>Returns the list of function names declared by an export   attribute.</p><ul><li><span class="v">FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</span></li><li><span class="v">ModuleName = atom()</span></li></ul><a name="analyze_export_attribute-1"></a><p>Returns the list of function names declared by an export  
attribute. We do not guarantee that each name occurs at most once in  
the list. The order of listing is not defined.</p><p>The evaluation throws <strong>syntax_error</strong> if <strong>Node</strong> does not represent a
well-formed export attribute.
</p><p><em>See also:</em> <a href="#analyze_attribute-1">analyze_attribute/1</a>.</p><h4>analyze_file_attribute(Node::) -&gt; {string(), integer()}</h4><p>Returns the file name and line number of a file attribute.</p><a name="analyze_file_attribute-1"></a><p>Returns the file name and line number of a <strong>file</strong>
attribute. The result is the pair <strong>{File, Line}</strong> if
<strong>Node</strong> represents "<strong>-file(File, Line).</strong>".</p><p>The evaluation throws <strong>syntax_error</strong> if
<strong>Node</strong> does not represent a well-formed <strong>file</strong>
attribute.
</p><p><em>See also:</em> <a href="#analyze_attribute-1">analyze_attribute/1</a>.</p><h4>analyze_form(Node::) -&gt; {atom(), term()} | atom()</h4><p>Analyzes a "source code form" node.</p><a name="analyze_form-1"></a><p>Analyzes a "source code form" node. If <strong>Node</strong> is a
"form" type (cf. <strong>erl_syntax:is_form/1</strong>), the returned
value is a tuple <strong>{Type, Info}</strong> where <strong>Type</strong> is
the node type and <strong>Info</strong> depends on <strong>Type</strong>, as
follows:
</p><dl><dt><strong>{attribute, Info}</strong></dt><dd><p>where <strong>Info = analyze_attribute(Node)</strong>.</p></dd><dt><strong>{error_marker, Info}</strong></dt><dd><p>where <strong>Info = erl_syntax:error_marker_info(Node)</strong>.</p></dd><dt><strong>{function, Info}</strong></dt><dd><p>where <strong>Info = analyze_function(Node)</strong>.</p></dd><dt><strong>{warning_marker, Info}</strong></dt><dd><p>where <strong>Info = erl_syntax:warning_marker_info(Node)</strong>.</p></dd></dl><p>  
For other types of forms, only the node type is returned.</p><p>The evaluation throws <strong>syntax_error</strong> if
<strong>Node</strong> is not well-formed.
</p><p><em>See also:</em> <a href="#analyze_attribute-1">analyze_attribute/1</a>, <a href="#analyze_function-1">analyze_function/1</a>, <a href="./erl_syntax#error_marker_info-1">erl_syntax:error_marker_info/1</a>, <a href="./erl_syntax#is_form-1">erl_syntax:is_form/1</a>, <a href="./erl_syntax#warning_marker_info-1">erl_syntax:warning_marker_info/1</a>.</p><h4>analyze_forms(Forms) -&gt; [{Key, term()}]</h4><p>Analyzes a sequence of "program forms".</p><ul><li><span class="v">Forms =  | []</span></li><li><span class="v">Key = attributes | errors | exports | functions | imports | module | records | warnings</span></li></ul><a name="analyze_forms-1"></a><p>Analyzes a sequence of "program forms". The given
<strong>Forms</strong> may be a single syntax tree of type
<strong>form_list</strong>, or a list of "program form" syntax trees. The
returned value is a list of pairs <strong>{Key, Info}</strong>, where
each value of <strong>Key</strong> occurs at most once in the list; the  
absence of a particular key indicates that there is no well-defined  
value for that key.</p><p>Each entry in the resulting list contains the following
corresponding information about the program forms:
</p><dl><dt><strong>{attributes, Attributes}</strong></dt><dd><ul><li><p><strong>Attributes = [{atom(), term()}]</strong></p></li></ul><p>
<strong>Attributes</strong> is a list of pairs representing the
names and corresponding values of all so-called "wild"
attributes (as e.g. "<strong>-compile(...)</strong>") occurring in
<strong>Forms</strong> (cf. <strong>analyze_wild_attribute/1</strong>).
We do not guarantee that each name occurs at most once in the
list. The order of listing is not defined.</p></dd><dt><strong>{errors, Errors}</strong></dt><dd><ul><li><p><strong>Errors = [term()]</strong></p></li></ul><p>
<strong>Errors</strong> is the list of error descriptors of all
<strong>error_marker</strong> nodes that occur in
<strong>Forms</strong>. The order of listing is not defined.</p></dd><dt><strong>{exports, Exports}</strong></dt><dd><ul><li><p><strong>Exports = [FunctionName]</strong></p></li><li><p><strong>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</strong></p></li><li><p><strong>ModuleName = atom()</strong></p></li></ul><p>
<strong>Exports</strong> is a list of representations of those
function names that are listed by export declaration attributes
in <strong>Forms</strong> (cf.
<strong>analyze_export_attribute/1</strong>). We do not guarantee
that each name occurs at most once in the list. The order of
listing is not defined.</p></dd><dt><strong>{functions, Functions}</strong></dt><dd><ul><li><p><strong>Functions = [{atom(), integer()}]</strong></p></li></ul><p>
<strong>Functions</strong> is a list of the names of the functions
that are defined in <strong>Forms</strong> (cf.
<strong>analyze_function/1</strong>). We do not guarantee that each
name occurs at most once in the list. The order of listing is
not defined.</p></dd><dt><strong>{imports, Imports}</strong></dt><dd><ul><li><p><strong>Imports = [{Module, Names}]</strong></p></li><li><p><strong>Module = atom()</strong></p></li><li><p><strong>Names = [FunctionName]</strong></p></li><li><p><strong>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</strong></p></li><li><p><strong>ModuleName = atom()</strong></p></li></ul><p>
<strong>Imports</strong> is a list of pairs representing those
module names and corresponding function names that are listed
by import declaration attributes in <strong>Forms</strong> (cf.
<strong>analyze_import_attribute/1</strong>), where each
<strong>Module</strong> occurs at most once in
<strong>Imports</strong>. We do not guarantee that each name occurs
at most once in the lists of function names. The order of
listing is not defined.</p></dd><dt><strong>{module, ModuleName}</strong></dt><dd><ul><li><p><strong>ModuleName = atom()</strong></p></li></ul><p>
<strong>ModuleName</strong> is the name declared by a module
attribute in <strong>Forms</strong>. If no module name is defined
in <strong>Forms</strong>, the result will contain no entry for the
<strong>module</strong> key. If multiple module name declarations
should occur, all but the first will be ignored.</p></dd><dt><strong>{records, Records}</strong></dt><dd><ul><li><p><strong>Records = [{atom(), Fields}]</strong></p></li><li><p><strong>Fields = [{atom(), {Default, Type}}]</strong></p></li><li><p><strong>Default = none | syntaxTree()</strong></p></li><li><p><strong>Type = none | syntaxTree()</strong></p></li></ul><p>
<strong>Records</strong> is a list of pairs representing the names
and corresponding field declarations of all record declaration
attributes occurring in <strong>Forms</strong>. For fields declared
without a default value, the corresponding value for
<strong>Default</strong> is the atom <strong>none</strong>. Similarly, for fields declared
without a type, the corresponding value for <strong>Type</strong> is the
atom <strong>none</strong> (cf.
<strong>analyze_record_attribute/1</strong>). We do not guarantee
that each record name occurs at most once in the list. The
order of listing is not defined.</p></dd><dt><strong>{warnings, Warnings}</strong></dt><dd><ul><li><p><strong>Warnings = [term()]</strong></p></li></ul><p>
<strong>Warnings</strong> is the list of error descriptors of all
<strong>warning_marker</strong> nodes that occur in
<strong>Forms</strong>. The order of listing is not defined.</p></dd></dl><p>The evaluation throws <strong>syntax_error</strong> if an ill-formed
Erlang construct is encountered.
</p><p><em>See also:</em> <a href="#analyze_export_attribute-1">analyze_export_attribute/1</a>, <a href="#analyze_function-1">analyze_function/1</a>, <a href="#analyze_import_attribute-1">analyze_import_attribute/1</a>, <a href="#analyze_record_attribute-1">analyze_record_attribute/1</a>, <a href="#analyze_wild_attribute-1">analyze_wild_attribute/1</a>, <a href="./erl_syntax#error_marker_info-1">erl_syntax:error_marker_info/1</a>, <a href="./erl_syntax#warning_marker_info-1">erl_syntax:warning_marker_info/1</a>.</p><h4>analyze_function(Node::) -&gt; {atom(), integer()}</h4><p>Returns the name and arity of a function definition.</p><a name="analyze_function-1"></a><p>Returns the name and arity of a function definition. The result
is a pair <strong>{Name, A}</strong> if <strong>Node</strong> represents a
function definition "<strong>Name(&lt;em&gt;P_1&lt;/em&gt;, ..., &lt;em&gt;P_A&lt;/em&gt;) -&gt; ...</strong>".</p><p>The evaluation throws <strong>syntax_error</strong> if
<strong>Node</strong> does not represent a well-formed function
definition.</p><h4>analyze_function_name(Node::) -&gt; FunctionName</h4><p>Returns the function name represented by a syntax tree.</p><ul><li><span class="v">FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</span></li><li><span class="v">ModuleName = atom()</span></li></ul><a name="analyze_function_name-1"></a><p>Returns the function name represented by a syntax tree. If
<strong>Node</strong> represents a function name, such as
"<strong>foo/1</strong>" or "<strong>bloggs:fred/2</strong>", a uniform  
representation of that name is returned. Different nestings of arity  
and module name qualifiers in the syntax tree does not affect the  
result.</p><p>The evaluation throws <strong>syntax_error</strong> if
<strong>Node</strong> does not represent a well-formed function name.</p><h4>analyze_implicit_fun(Node::) -&gt; FunctionName</h4><p>Returns the name of an implicit fun expression "fun &lt;em&gt;F&lt;/em&gt;".</p><ul><li><span class="v">FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</span></li><li><span class="v">ModuleName = atom()</span></li></ul><a name="analyze_implicit_fun-1"></a><p>Returns the name of an implicit fun expression "<strong>fun &lt;em&gt;F&lt;/em&gt;</strong>". The result is a representation of the function
name <strong>F</strong>. (Cf. <strong>analyze_function_name/1</strong>.)</p><p>The evaluation throws <strong>syntax_error</strong> if
<strong>Node</strong> does not represent a well-formed implicit fun.
</p><p><em>See also:</em> <a href="#analyze_function_name-1">analyze_function_name/1</a>.</p><h4>analyze_import_attribute(Node::) -&gt; {atom(), [FunctionName]} | atom()</h4><p>Returns the module name and (if present) list of function names declared by an import attribute.</p><ul><li><span class="v">FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</span></li><li><span class="v">ModuleName = atom()</span></li></ul><a name="analyze_import_attribute-1"></a><p>Returns the module name and (if present) list of function names
declared by an import attribute. The returned value is an atom
<strong>Module</strong> or a pair <strong>{Module, Names}</strong>, where
<strong>Names</strong> is a list of function names declared as imported
from the module named by <strong>Module</strong>. We do not guarantee
that each name occurs at most once in <strong>Names</strong>. The order  
of listing is not defined.</p><p>The evaluation throws <strong>syntax_error</strong> if <strong>Node</strong> does not represent a
well-formed import attribute.
</p><p><em>See also:</em> <a href="#analyze_attribute-1">analyze_attribute/1</a>.</p><h4>analyze_module_attribute(Node::) -&gt; Name::atom() | {Name::atom(), Variables::[atom()]}</h4><p>Returns the module name and possible parameters declared by a module attribute.</p><a name="analyze_module_attribute-1"></a><p>Returns the module name and possible parameters declared by a
module attribute. If the attribute is a plain module declaration such
as <strong>-module(name)</strong>, the result is the module name. If the attribute  
is a parameterized module declaration, the result is a tuple  
containing the module name and a list of the parameter variable  
names.</p><p>The evaluation throws <strong>syntax_error</strong> if <strong>Node</strong> does not represent a
well-formed module attribute.
</p><p><em>See also:</em> <a href="#analyze_attribute-1">analyze_attribute/1</a>.</p><h4>analyze_record_attribute(Node::) -&gt; {atom(), Fields}</h4><p>Returns the name and the list of fields of a record declaration attribute.</p><ul><li><span class="v">Fields = [{atom(), {Default, Type}}]</span></li><li><span class="v">Default = none | </span></li><li><span class="v">Type = none | </span></li></ul><a name="analyze_record_attribute-1"></a><p>Returns the name and the list of fields of a record declaration
attribute. The result is a pair <strong>{Name, Fields}</strong>, if
<strong>Node</strong> represents "<strong>-record(Name, {...}).</strong>",
where <strong>Fields</strong> is a list of pairs <strong>{Label, {Default, Type}}</strong> for each field "<strong>Label</strong>", "<strong>Label = &lt;em&gt;Default&lt;/em&gt;</strong>", "<strong>Label :: &lt;em&gt;Type&lt;/em&gt;</strong>", or
"<strong>Label = &lt;em&gt;Default&lt;/em&gt; :: &lt;em&gt;Type&lt;/em&gt;</strong>" in the declaration,
listed in left-to-right
order. If the field has no default-value declaration, the value for
<strong>Default</strong> will be the atom <strong>none</strong>. If the field has no type declaration,
the value for <strong>Type</strong> will be the atom <strong>none</strong>. We do not  
guarantee that each label occurs at most once in the list.</p><p>The evaluation throws <strong>syntax_error</strong> if
<strong>Node</strong> does not represent a well-formed record declaration
attribute.
</p><p><em>See also:</em> <a href="#analyze_attribute-1">analyze_attribute/1</a>, <a href="#analyze_record_field-1">analyze_record_field/1</a>.</p><h4>analyze_record_expr(Node::) -&gt; {atom(), Info} | atom()</h4><p>Returns the record name and field name/names of a record expression.</p><ul><li><span class="v">Info = {atom(), [{atom(), Value}]} | {atom(), atom()} | atom()</span></li><li><span class="v">Value = </span></li></ul><a name="analyze_record_expr-1"></a><p>Returns the record name and field name/names of a record
expression. If <strong>Node</strong> has type <strong>record_expr</strong>,
<strong>record_index_expr</strong> or <strong>record_access</strong>, a pair
<strong>{Type, Info}</strong> is returned, otherwise an atom
<strong>Type</strong> is returned. <strong>Type</strong> is the node type of
<strong>Node</strong>, and <strong>Info</strong> depends on
<strong>Type</strong>, as follows:
</p><dl><dt><strong>record_expr</strong>:</dt><dd><p><strong>{atom(), [{atom(), Value}]}</strong></p></dd><dt><strong>record_access</strong>:</dt><dd><p><strong>{atom(), atom()}</strong></p></dd><dt><strong>record_index_expr</strong>:</dt><dd><p><strong>{atom(), atom()}</strong></p></dd></dl><p>
</p><p>For a <strong>record_expr</strong> node, <strong>Info</strong> represents
the record name and the list of descriptors for the involved fields,
listed in the order they appear. A field descriptor is a pair
<strong>{Label, Value}</strong>, if <strong>Node</strong> represents "<strong>Label = &lt;em&gt;Value&lt;/em&gt;</strong>".
For a <strong>record_access</strong> node,
<strong>Info</strong> represents the record name and the field name. For a
<strong>record_index_expr</strong> node, <strong>Info</strong> represents the  
record name and the name field name.</p><p>The evaluation throws <strong>syntax_error</strong> if
<strong>Node</strong> represents a record expression that is not
well-formed.
</p><p><em>See also:</em> <a href="#analyze_record_attribute-1">analyze_record_attribute/1</a>, <a href="#analyze_record_field-1">analyze_record_field/1</a>.</p><h4>analyze_record_field(Node::) -&gt; {atom(), {Default, Type}}</h4><p>Returns the label, value-expression, and type of a record field specifier.</p><ul><li><span class="v">Default = none | </span></li><li><span class="v">Type = none | </span></li></ul><a name="analyze_record_field-1"></a><p>Returns the label, value-expression, and type of a record field
specifier. The result is a pair <strong>{Label, {Default, Type}}</strong>, if
<strong>Node</strong> represents "<strong>Label</strong>", "<strong>Label = &lt;em&gt;Default&lt;/em&gt;</strong>",
"<strong>Label :: &lt;em&gt;Type&lt;/em&gt;</strong>", or
"<strong>Label = &lt;em&gt;Default&lt;/em&gt; :: &lt;em&gt;Type&lt;/em&gt;</strong>".
If the field has no value-expression, the value for
<strong>Default</strong> will be the atom <strong>none</strong>. If the field has no type,
the value for <strong>Type</strong> will be the atom <strong>none</strong>.</p><p>The evaluation throws <strong>syntax_error</strong> if
<strong>Node</strong> does not represent a well-formed record field
specifier.
</p><p><em>See also:</em> <a href="#analyze_record_attribute-1">analyze_record_attribute/1</a>, <a href="#analyze_record_expr-1">analyze_record_expr/1</a>.</p><h4>analyze_type_application(Node::) -&gt; TypeName</h4><p>Returns the name of a used type.</p><ul><li><span class="v">TypeName = {atom(), integer()} | {ModuleName, {atom(), integer()}}</span></li><li><span class="v">ModuleName = atom()</span></li></ul><a name="analyze_type_application-1"></a><p>Returns the name of a used type. The result is a
representation of the name of the used pre-defined or local type <strong>N/A</strong>,
if <strong>Node</strong> represents a local (user) type application
"<strong>&lt;em&gt;N&lt;/em&gt;(&lt;em&gt;T_1&lt;/em&gt;, ..., &lt;em&gt;T_A&lt;/em&gt;)</strong>", or
a representation of the name of the used remote type <strong>M:N/A</strong>
if <strong>Node</strong> represents a remote user type application
"<strong>&lt;em&gt;M&lt;/em&gt;:&lt;em&gt;N&lt;/em&gt;(&lt;em&gt;T_1&lt;/em&gt;, ..., &lt;em&gt;T_A&lt;/em&gt;)</strong>".</p><p>The evaluation throws <strong>syntax_error</strong> if <strong>Node</strong> does not represent a
well-formed (user) type application expression.
</p><p><em>See also:</em> <a href="#analyze_type_name-1">analyze_type_name/1</a>.</p><h4>analyze_type_name(Node::) -&gt; TypeName</h4><p>Returns the type name represented by a syntax tree.</p><ul><li><span class="v">TypeName = atom() | {atom(), integer()} | {ModuleName, {atom(), integer()}}</span></li><li><span class="v">ModuleName = atom()</span></li></ul><a name="analyze_type_name-1"></a><p>Returns the type name represented by a syntax tree. If
<strong>Node</strong> represents a type name, such as
"<strong>foo/1</strong>" or "<strong>bloggs:fred/2</strong>", a uniform  
representation of that name is returned.</p><p>The evaluation throws <strong>syntax_error</strong> if
<strong>Node</strong> does not represent a well-formed type name.</p><h4>analyze_wild_attribute(Node::) -&gt; {atom(), term()}</h4><p>Returns the name and value of a "wild" attribute.</p><a name="analyze_wild_attribute-1"></a><p>Returns the name and value of a "wild" attribute. The result is
the pair <strong>{Name, Value}</strong>, if <strong>Node</strong> represents "<strong>-Name(Value)</strong>".</p><p>Note that no checking is done whether <strong>Name</strong> is a
reserved attribute name such as <strong>module</strong> or
<strong>export</strong>: it is assumed that the attribute is "wild".</p><p>The evaluation throws <strong>syntax_error</strong> if <strong>Node</strong> does not represent a
well-formed wild attribute.
</p><p><em>See also:</em> <a href="#analyze_attribute-1">analyze_attribute/1</a>.</p><h4>annotate_bindings(Tree::) -&gt;</h4><p>Adds or updates annotations on nodes in a syntax tree.</p><a name="annotate_bindings-1"></a><p>Adds or updates annotations on nodes in a syntax tree.
Equivalent to <strong>annotate_bindings(Tree, Bindings)</strong> where
the top-level environment <strong>Bindings</strong> is taken from the
annotation <strong>{env, Bindings}</strong> on the root node of
<strong>Tree</strong>. An exception is thrown if no such annotation
should exist.
</p><p><em>See also:</em> <a href="#annotate_bindings-2">annotate_bindings/2</a>.</p><h4>annotate_bindings(Tree::, Bindings::) -&gt;</h4><p>Adds or updates annotations on nodes in a syntax tree.</p><a name="annotate_bindings-2"></a><p>Adds or updates annotations on nodes in a syntax tree.
<strong>Bindings</strong> specifies the set of bound variables in the
environment of the top level node. The following annotations are
affected:
</p><ul><li><p><strong>{env, Vars}</strong>, representing the input environment
of the subtree.</p></li><li><p><strong>{bound, Vars}</strong>, representing the variables that
are bound in the subtree.</p></li><li><p><strong>{free, Vars}</strong>, representing the free variables in
the subtree.</p></li></ul><p>
<strong>Bindings</strong> and <strong>Vars</strong> are ordered-set lists
(cf. module <strong>ordsets</strong>) of atoms representing variable
names.
</p><p><em>See also:</em> <a href="./ordsets">ordsets(3)</a>, <a href="#annotate_bindings-1">annotate_bindings/1</a>.</p><h4>fold(F::Function, Start::term(), Tree::) -&gt; term()</h4><p>Folds a function over all nodes of a syntax tree.</p><ul><li><span class="v">Function = (, term()) -&gt; term()</span></li></ul><a name="fold-3"></a><p>Folds a function over all nodes of a syntax tree. The result is
the value of <strong>Function(X1, Function(X2, ... Function(Xn, Start) ... ))</strong>, where <strong>[X1, X2, ..., Xn]</strong> are the nodes of
<strong>Tree</strong> in a post-order traversal.
</p><p><em>See also:</em> <a href="#fold_subtrees-3">fold_subtrees/3</a>, <a href="#foldl_listlist-3">foldl_listlist/3</a>.</p><h4>fold_subtrees(F::Function, Start::term(), Tree::) -&gt; term()</h4><p>Folds a function over the immediate subtrees of a syntax tree.</p><ul><li><span class="v">Function = (, term()) -&gt; term()</span></li></ul><a name="fold_subtrees-3"></a><p>Folds a function over the immediate subtrees of a syntax tree.
This is similar to <strong>fold/3</strong>, but only on the immediate
subtrees of <strong>Tree</strong>, in left-to-right order; it does not
include the root node of <strong>Tree</strong>.
</p><p><em>See also:</em> <a href="#fold-3">fold/3</a>.</p><h4>foldl_listlist(F::Function, Start::term(), Ls::[[term()]]) -&gt; term()</h4><p>Like lists:foldl/3, but over a list of lists.</p><ul><li><span class="v">Function = (term(), term()) -&gt; term()</span></li></ul><a name="foldl_listlist-3"></a><p>Like <strong>lists:foldl/3</strong>, but over a list of lists.
</p><p><em>See also:</em> <a href="../stdlib/lists#foldl/3">lists:foldl/3</a>, <a href="#fold-3">fold/3</a>.</p><h4>function_name_expansions(Names::[Name]) -&gt; [{ShortName, Name}]</h4><p>Creates a mapping from corresponding short names to full function names.</p><ul><li><span class="v">Name = ShortName | {atom(), Name}</span></li><li><span class="v">ShortName = atom() | {atom(), integer()}</span></li></ul><a name="function_name_expansions-1"></a><p>Creates a mapping from corresponding short names to full
function names. Names are represented by nested tuples of atoms and
integers (cf. <strong>analyze_function_name/1</strong>). The result is a
list containing a pair <strong>{ShortName, Name}</strong> for each
element <strong>Name</strong> in the given list, where the corresponding
<strong>ShortName</strong> is the rightmost-innermost part of
<strong>Name</strong>. The list thus represents a finite mapping from  
unqualified names to the corresponding qualified names.</p><p>Note: the resulting list can contain more than one tuple
<strong>{ShortName, Name}</strong> for the same <strong>ShortName</strong>,
possibly with different values for <strong>Name</strong>, depending on
the given list.
</p><p><em>See also:</em> <a href="#analyze_function_name-1">analyze_function_name/1</a>.</p><h4>is_fail_expr(Tree::) -&gt; boolean()</h4><p>Returns true if Tree represents an expression which never terminates normally.</p><a name="is_fail_expr-1"></a><p>Returns <strong>true</strong> if <strong>Tree</strong> represents an
expression which never terminates normally. Note that the reverse
does not apply. Currently, the detected cases are calls to
<strong>exit/1</strong>, <strong>throw/1</strong>,
<strong>erlang:error/1</strong> and <strong>erlang:error/2</strong>.
</p><p><em>See also:</em> <a href="../erts/erlang#error/1">erlang:error/1</a>, <a href="../erts/erlang#error/2">erlang:error/2</a>, <a href="../erts/erlang#exit/1">erlang:exit/1</a>, <a href="../erts/erlang#throw/1">erlang:throw/1</a>.</p><h4>limit(Tree, Depth) -&gt;</h4><p>Equivalent to limit(Tree, Depth, Text) using the text "..." as default replacement.</p><a name="limit-2"></a><p>Equivalent to <strong>limit(Tree, Depth, Text)</strong> using the
text <strong>"..."</strong> as default replacement.
</p><p><em>See also:</em> <a href="#limit-3">limit/3</a>, <a href="./erl_syntax#text-1">erl_syntax:text/1</a>.</p><h4>limit(Tree::, Depth::integer(), Node::) -&gt;</h4><p>Limits a syntax tree to a specified depth.</p><a name="limit-3"></a><p>Limits a syntax tree to a specified depth. Replaces all non-leaf
subtrees in <strong>Tree</strong> at the given <strong>Depth</strong> by
<strong>Node</strong>. If <strong>Depth</strong> is negative, the result is
always <strong>Node</strong>, even if <strong>Tree</strong> has no subtrees.</p><p>When a group of subtrees (as e.g., the argument list of an
<strong>application</strong> node) is at the specified depth, and there
are two or more subtrees in the group, these will be collectively
replaced by <strong>Node</strong> even if they are leaf nodes. Groups of
subtrees that are above the specified depth will be limited in size,
as if each subsequent tree in the group were one level deeper than
the previous. E.g., if <strong>Tree</strong> represents a list of
integers "<strong>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</strong>", the result
of <strong>limit(Tree, 5)</strong> will represent <strong>[1, 2, 3, 4, ...]</strong>.</p><p>The resulting syntax tree is typically only useful for
pretty-printing or similar visual formatting.
</p><p><em>See also:</em> <a href="#limit-2">limit/2</a>.</p><h4>map(F::Function, Tree::) -&gt;</h4><p>Applies a function to each node of a syntax tree.</p><ul><li><span class="v">Function = () -&gt; </span></li></ul><a name="map-2"></a><p>Applies a function to each node of a syntax tree. The result of
each application replaces the corresponding original node. The order
of traversal is bottom-up.
</p><p><em>See also:</em> <a href="#map_subtrees-2">map_subtrees/2</a>.</p><h4>map_subtrees(F::Function, Tree::) -&gt;</h4><p>Applies a function to each immediate subtree of a syntax tree.</p><ul><li><span class="v">Function = (Tree) -&gt; Tree1</span></li></ul><a name="map_subtrees-2"></a><p>Applies a function to each immediate subtree of a syntax tree.
The result of each application replaces the corresponding original
node.
</p><p><em>See also:</em> <a href="#map-2">map/2</a>.</p><h4>mapfold(F::Function, Start::term(), Tree::) -&gt; {, term()}</h4><p>Combines map and fold in a single operation.</p><ul><li><span class="v">Function = (, term()) -&gt; {, term()}</span></li></ul><a name="mapfold-3"></a><p>Combines map and fold in a single operation. This is similar to
<strong>map/2</strong>, but also propagates an extra value from each
application of the <strong>Function</strong> to the next, while doing a
post-order traversal of the tree like <strong>fold/3</strong>. The value
<strong>Start</strong> is passed to the first function application, and
the final result is the result of the last application.
</p><p><em>See also:</em> <a href="#fold-3">fold/3</a>, <a href="#map-2">map/2</a>.</p><h4>mapfold_subtrees(F::Function, Start::term(), Tree::) -&gt; {, term()}</h4><p>Does a mapfold operation over the immediate subtrees of a syntax tree.</p><ul><li><span class="v">Function = (, term()) -&gt; {, term()}</span></li></ul><a name="mapfold_subtrees-3"></a><p>Does a mapfold operation over the immediate subtrees of a syntax
tree. This is similar to <strong>mapfold/3</strong>, but only on the
immediate subtrees of <strong>Tree</strong>, in left-to-right order; it
does not include the root node of <strong>Tree</strong>.
</p><p><em>See also:</em> <a href="#mapfold-3">mapfold/3</a>.</p><h4>mapfoldl_listlist(F::Function, S::State, Ls::[[term()]]) -&gt; {[[term()]], term()}</h4><p>Like lists:mapfoldl/3, but over a list of lists.</p><ul><li><span class="v">Function = (term(), term()) -&gt; {term(), term()}</span></li></ul><a name="mapfoldl_listlist-3"></a><p>Like <strong>lists:mapfoldl/3</strong>, but over a list of lists.
The list of lists in the result has the same structure as the given
list of lists.</p><h4>new_variable_name(Used::) -&gt; atom()</h4><p>Returns an atom which is not already in the set Used.</p><a name="new_variable_name-1"></a><p>Returns an atom which is not already in the set <strong>Used</strong>. This is
equivalent to <strong>new_variable_name(Function, Used)</strong>, where <strong>Function</strong>
maps a given integer <strong>N</strong> to the atom whose name consists of "<strong>V</strong>"
followed by the numeral for <strong>N</strong>.
</p><p><em>See also:</em> <a href="#new_variable_name-2">new_variable_name/2</a>.</p><h4>new_variable_name(F::Function, Used::) -&gt; atom()</h4><p>Returns a user-named atom which is not already in the set Used.</p><ul><li><span class="v">Function = (integer()) -&gt; atom()</span></li></ul><a name="new_variable_name-2"></a><p>Returns a user-named atom which is not already in the set
<strong>Used</strong>. The atom is generated by applying the given
<strong>Function</strong> to a generated integer. Integers are generated  
using an algorithm which tries to keep the names randomly distributed  
within a reasonably small range relative to the number of elements in  
the set.</p><p>This function uses the module <strong>rand</strong> to generate new
keys. The seed it uses may be initialized by calling
<strong>rand:seed/1</strong> or <strong>rand:seed/2</strong> before this
function is first called.
</p><p><em>See also:</em> <a href="./random">random(3)</a>, <a href="./sets">sets(3)</a>, <a href="#new_variable_name-1">new_variable_name/1</a>.</p><h4>new_variable_names(N::integer(), Used::) -&gt; [atom()]</h4><p>Like new_variable_name/1, but generates a list of N new names.</p><a name="new_variable_names-2"></a><p>Like <strong>new_variable_name/1</strong>, but generates a list of
<strong>N</strong> new names.
</p><p><em>See also:</em> <a href="#new_variable_name-1">new_variable_name/1</a>.</p><h4>new_variable_names(N::integer(), F::Function, Used::) -&gt; [atom()]</h4><p>Like new_variable_name/2, but generates a list of N new names.</p><ul><li><span class="v">Function = (integer()) -&gt; atom()</span></li></ul><a name="new_variable_names-3"></a><p>Like <strong>new_variable_name/2</strong>, but generates a list of
<strong>N</strong> new names.
</p><p><em>See also:</em> <a href="#new_variable_name-2">new_variable_name/2</a>.</p><h4>strip_comments(Tree::) -&gt;</h4><p>Removes all comments from all nodes of a syntax tree.</p><a name="strip_comments-1"></a><p>Removes all comments from all nodes of a syntax tree. All other
attributes (such as position information) remain unchanged.
Standalone comments in form lists are removed; any other standalone
comments are changed into null-comments (no text, no indentation).</p><h4>to_comment(Tree) -&gt;</h4><p>Equivalent to to_comment(Tree, "% "). </p><a name="to_comment-1"></a><p>Equivalent to <a href="#to_comment-2">to_comment(Tree, "% ")</a>.</p><h4>to_comment(Tree::, Prefix::string()) -&gt;</h4><p>Equivalent to to_comment(Tree, Prefix, F) for a default formatting function F.</p><a name="to_comment-2"></a><p>Equivalent to <strong>to_comment(Tree, Prefix, F)</strong> for a
default formatting function <strong>F</strong>. The default
<strong>F</strong> simply calls <strong>erl_prettypr:format/1</strong>.
</p><p><em>See also:</em> <a href="#to_comment-3">to_comment/3</a>, <a href="./erl_prettypr#format-1">erl_prettypr:format/1</a>.</p><h4>to_comment(Tree::, Prefix::string(), F::Printer) -&gt;</h4><p>Transforms a syntax tree into an abstract comment.</p><ul><li><span class="v">Printer = () -&gt; string()</span></li></ul><a name="to_comment-3"></a><p>Transforms a syntax tree into an abstract comment. The lines of
the comment contain the text for <strong>Node</strong>, as produced by
the given <strong>Printer</strong> function. Each line of the comment is
prefixed by the string <strong>Prefix</strong> (this does not include the
initial "<strong>%</strong>" character of the comment line).</p><p>For example, the result of
<strong>to_comment(erl_syntax:abstract([a,b,c]))</strong> represents
</p><pre>
          %% [a,b,c]</pre><p>
(cf. <strong>to_comment/1</strong>).</p><p>Note: the text returned by the formatting function will be split
automatically into separate comment lines at each line break. No
extra work is needed.
</p><p><em>See also:</em> <a href="#to_comment-1">to_comment/1</a>, <a href="#to_comment-2">to_comment/2</a>.</p><h4>variables(Tree::) -&gt;</h4><p>Returns the names of variables occurring in a syntax tree, The result is a set of variable names represented by atoms.</p><a name="variables-1"></a><p>Returns the names of variables occurring in a syntax tree, The
result is a set of variable names represented by atoms. Macro names
are not included.
</p><p><em>See also:</em> <a href="./sets">sets(3)</a>.</p><h3>Authors</h3><span class="aname">Richard Carlsson</span><span class="email">carlsson.richard@gmail.com</span><h3>erl_tidy</h3><p>Tidies and pretty-prints Erlang source code, removing unused  
functions, updating obsolete constructs and function calls, etc.</p><p>Tidies and pretty-prints Erlang source code, removing unused  
functions, updating obsolete constructs and function calls, etc.Caveats: It is possible that in some intricate uses of macros,  
the automatic addition or removal of parentheses around uses or  
arguments could cause the resulting program to be rejected by the  
compiler; however, we have found no such case in existing  
code. Programs defining strange macros can usually not be read by  
this program, and in those cases, no changes will be made.If you really, really want to, you may call it "Inga".Disclaimer: The author accepts no responsibility for errors
introduced in code that has been processed by the program. It has
been reasonably well tested, but the possibility of errors remains.
Keep backups of your original code safely stored, until you feel
confident that the new, modified code can be trusted.
</p><h4>DATA TYPES</h4><a name="types"></a><dl><dt><a name="type-filename"></a>filename() = <a href="./file#type-filename">file:filename()</a></dt><dd> </dd><dt><a name="type-syntaxTree"></a>syntaxTree() = <a href="./erl_syntax#type-syntaxTree">erl_syntax:syntaxTree()</a></dt><dd> <p>An abstract syntax
tree. See the <a href="erl_syntax">erl_syntax</a> module for details.
</p> </dd></dl><h3>Functions</h3><h4>dir() -&gt; ok</h4><p>Equivalent to dir(""). </p><a name="dir-0"></a><p>Equivalent to <a href="#dir-1">dir("")</a>.</p><h4>dir(Dir) -&gt; ok</h4><p>Equivalent to dir(Dir, []). </p><a name="dir-1"></a><p>Equivalent to <a href="#dir-2">dir(Dir, [])</a>.</p><h4>dir(Directory::, Options::[term()]) -&gt; ok</h4><p>Tidies Erlang source files in a directory and its   subdirectories.</p><a name="dir-2"></a><p>Tidies Erlang source files in a directory and its  
subdirectories.</p><p>Available options:
</p><dl><dt>{follow_links, boolean()}</dt><dd><p>If the value is <strong>true</strong>, symbolic directory
links will be followed.  The default value is
<strong>false</strong>.</p></dd><dt>{recursive, boolean()}</dt><dd><p>If the value is <strong>true</strong>, subdirectories will be
visited recursively.  The default value is
<strong>true</strong>.</p></dd><dt>{regexp, string()}</dt><dd><p>The value denotes a regular expression (see module
<strong>re</strong>).  Tidying will only be applied to those
regular files whose names match this pattern. The default
value is <strong>".*\\.erl$"</strong>, which matches normal
Erlang source file names.</p></dd><dt>{test, boolean()}</dt><dd><p>If the value is <strong>true</strong>, no files will be
modified. The default value is <strong>false</strong>.</p></dd><dt>{verbose, boolean()}</dt><dd><p>If the value is <strong>true</strong>, progress messages will
be output while the program is running, unless the
<strong>quiet</strong> option is <strong>true</strong>. The default
value when calling <a href="#dir-2">dir/2</a> is <strong>true</strong>.</p></dd></dl><p>See the function <a href="#file-2">file/2</a> for further options.
</p><p><em>See also:</em> <a href="./re">re(3)</a>, <a href="#file-2">file/2</a>.</p><h4>file(Name) -&gt; ok</h4><p>Equivalent to file(Name, []). </p><a name="file-1"></a><p>Equivalent to <a href="#file-2">file(Name, [])</a>.</p><h4>file(Name::, Options::[term()]) -&gt; ok</h4><p>Tidies an Erlang source code file.</p><a name="file-2"></a><p>Tidies an Erlang source code file.</p><p>Available options are:
</p><dl><dt>{backup_suffix, string()}</dt><dd><p>Specifies the file name suffix to be used when a backup
file is created; the default value is <strong>".bak"</strong>
(cf. the <strong>backups</strong> option).</p></dd><dt>{backups, boolean()}</dt><dd><p>If the value is <strong>true</strong>, existing files will be
renamed before new files are opened for writing. The new
names are formed by appending the string given by the
<strong>backup_suffix</strong> option to the original name. The
default value is <strong>true</strong>.</p></dd><dt>{dir, filename()}</dt><dd><p>Specifies the name of the directory in which the output
file is to be written. By default, the current directory is
used. If the value is an empty string, the current directory
is used. </p></dd><dt>{outfile, filename()}</dt><dd><p>Specifies the name of the file (without suffix) to which
the resulting source code is to be written. If this option is
not specified, the <strong>Name</strong> argument is used.</p></dd><dt>{printer, Function}</dt><dd><ul><li><p><strong>Function = (syntaxTree(), [term()]) -&gt; string()</strong></p></li></ul><p>
Specifies a function for prettyprinting Erlang syntax trees.
This is used for outputting the resulting module definition.
The function is assumed to return formatted text for the given
syntax tree, and should raise an exception if an error occurs.
The default formatting function calls
<strong>erl_prettypr:format/2</strong>.</p></dd><dt>{test, boolean()}</dt><dd><p>If the value is <strong>true</strong>, no files will be modified; this
is typically most useful if the <strong>verbose</strong> flag is enabled, to
generate reports about the program files without affecting
them. The default value is <strong>false</strong>.</p></dd><dt>{stdout, boolean()}</dt><dd><p>If the value is <strong>true</strong>, instead of the file being written
to disk it will be printed to stdout. The default value is
<strong>false</strong>.</p></dd></dl><p>See the function <strong>module/2</strong> for further options.
</p><p><em>See also:</em> <a href="#module-2">module/2</a>, <a href="./erl_prettypr#format-2">erl_prettypr:format/2</a>.</p><h4>module(Forms) -&gt;</h4><p>Equivalent to module(Forms, []). </p><a name="module-1"></a><p>Equivalent to <a href="#module-2">module(Forms, [])</a>.</p><h4>module(Forms, Options::[term()]) -&gt;</h4><p>Tidies a syntax tree representation of a module definition.</p><ul><li><span class="v">Forms =  | []</span></li></ul><a name="module-2"></a><p>Tidies a syntax tree representation of a module
definition. The given <strong>Forms</strong> may be either a single
syntax tree of type <strong>form_list</strong>, or a list of syntax
trees representing "program forms". In either case,
<strong>Forms</strong> must represent a single complete module
definition. The returned syntax tree has type
<strong>form_list</strong> and represents a tidied-up version of the  
same source code.</p><p>Available options are:
</p><dl><dt>{auto_export_vars, boolean()}</dt><dd><p>If the value is <strong>true</strong>, all matches
"<strong>{V1, ..., Vn} = E</strong>" where <strong>E</strong> is a
case-, if- or receive-expression whose branches all return
n-tuples (or explicitly throw exceptions) will be rewritten
to bind and export the variables <strong>V1</strong>, ...,
<strong>Vn</strong> directly. The default value is <strong>false</strong>.</p> <p>For example:
</p><pre>
                 {X, Y} = case ... of
                              ... -&gt; {17, foo()};
                              ... -&gt; {42, bar()}
                          end
        </pre><p>
will be rewritten to:
</p><pre>
                 case ... of
                     ... -&gt; X = 17, Y = foo(), {X, Y};
                     ... -&gt; X = 42, Y = bar(), {X, Y}
                 end
        </pre></dd><dt>{auto_list_comp, boolean()}</dt><dd><p>If the value is <strong>true</strong>, calls to <strong>lists:map/2</strong> and
<strong>lists:filter/2</strong> will be rewritten using list comprehensions.
The default value is <strong>true</strong>.</p></dd><dt>{file, string()}</dt><dd><p>Specifies the name of the file from which the source code
was taken. This is only used for generation of error
reports. The default value is the empty string.</p></dd><dt>{idem, boolean()}</dt><dd><p>If the value is <strong>true</strong>, all options that affect how the
code is modified are set to "no changes". For example, to
only update guard tests, and nothing else, use the options
<strong>[new_guard_tests, idem]</strong>. (Recall that options closer to the
beginning of the list have higher precedence.)</p></dd><dt>{keep_unused, boolean()}</dt><dd><p>If the value is <strong>true</strong>, unused functions will
not be removed from the code. The default value is
<strong>false</strong>.</p></dd><dt>{new_guard_tests, boolean()}</dt><dd><p>If the value is <strong>true</strong>, guard tests will be updated to
use the new names, e.g. "<strong>is_integer(X)</strong>" instead of
"<strong>integer(X)</strong>". The default value is <strong>true</strong>. See also
<strong>old_guard_tests</strong>.</p></dd><dt>{no_imports, boolean()}</dt><dd><p>If the value is <strong>true</strong>, all import statements will be
removed and calls to imported functions will be expanded to
explicit remote calls. The default value is <strong>false</strong>.</p></dd><dt>{old_guard_tests, boolean()}</dt><dd><p>If the value is <strong>true</strong>, guard tests will be changed to
use the old names instead of the new ones, e.g.
"<strong>integer(X)</strong>" instead of "<strong>is_integer(X)</strong>". The default
value is <strong>false</strong>. This option overrides the <strong>new_guard_tests</strong>
option.</p></dd><dt>{quiet, boolean()}</dt><dd><p>If the value is <strong>true</strong>, all information
messages and warning messages will be suppressed. The default
value is <strong>false</strong>.</p></dd><dt>{rename, [{{atom(), atom(), integer()}, {atom(), atom()}}]}</dt><dd><p>The value is a list of pairs, associating tuples
<strong>{Module, Name, Arity}</strong> with tuples <strong>{NewModule, NewName}</strong>,        
specifying renamings of calls to remote functions. By        
default, the value is the empty list.</p> <p>The renaming affects only remote calls (also when
disguised by import declarations); local calls within a
module are not affected, and no function definitions are
renamed. Since the arity cannot change, the new name is
represented by <strong>{NewModule, NewName}</strong> only. Only        
calls matching the specified arity will match; multiple        
entries are necessary for renaming calls to functions that        
have the same module and function name, but different        
arities.</p> <p>This option can also be used to override the default
renaming of calls which use obsolete function names.</p></dd><dt>{verbose, boolean()}</dt><dd><p>If the value is <strong>true</strong>, progress messages will be output
while the program is running, unless the <strong>quiet</strong> option is
<strong>true</strong>. The default value is <strong>false</strong>.</p></dd></dl><h3>Authors</h3><span class="aname">Richard Carlsson</span><span class="email">carlsson.richard@gmail.com</span><h3>igor</h3><p>Igor: the Module Merger and Renamer.</p><p>Igor: the Module Merger and Renamer.The program Igor merges the source code of one or more Erlang  
modules into a single module, which can then replace the original set  
of modules. Igor is also able to rename a set of (possibly  
interdependent) modules, without joining them into a single  
module.The main user interface consists of the functions <a href="#merge-3">merge/3</a> and
<a href="#rename-3">rename/3</a>. See also the function <a href="#parse_transform-2">parse_transform/2</a>.A note of warning: Igor cannot do anything about the case when the
name of a remote function is passed to the built-in functions
<strong>apply</strong> and <strong>spawn</strong> <em>unless</em> the module
and function names are explicitly stated in the call, as in e.g.
<strong>apply(lists, reverse, [Xs])</strong>. In all other cases, Igor  
leaves such calls unchanged, and warns the user that manual editing  
might be necessary.Also note that Erlang records will be renamed as necessary to
avoid non-equivalent definitions using the same record name. This
does not work if the source code accesses the name field of such
record tuples by <strong>element/2</strong> or similar methods. Always  
use the record syntax to handle record tuples, if possible.Disclaimer: the author of this program takes no responsibility for  
the correctness of the produced output, or for any effects of its  
execution. In particular, the author may not be held responsible  
should Igor include the code of a deceased madman in the result.For further information on Igors in general, see e.g. "Young
Frankenstein", Mel Brooks, 1974, and "The Fifth Elephant", Terry
Pratchett, 1999.</p><h4>DATA TYPES</h4><a name="types"></a><dl><dt><a name="type-filename"></a>filename() = <a href="./file#type-filename">file:filename()</a></dt><dd> </dd><dt><a name="type-stubDescriptor"></a>stubDescriptor() = {ModuleName, Functions, [Attribute]}</dt><dd> <ul><li><p>ModuleName = atom()</p></li><li><p>Functions = [{FunctionName, {ModuleName, FunctionName}}]</p></li><li><p>FunctionName = {atom(), integer()}</p></li><li><p>Attribute = {atom(), term()}</p></li></ul> <p>A stub module descriptor contains the module name, a list of
exported functions, and a list of module attributes. Each
function is described by its name (which includes its arity),
and the corresponding module and function that it calls. (The
arities should always match.) The attributes are simply
described by key-value pairs.
</p> </dd><dt><a name="type-syntaxTree"></a>syntaxTree() = <a href="./erl_syntax#type-syntaxTree">erl_syntax:syntaxTree()</a></dt><dd> <p>An abstract syntax
tree. See the <a href="erl_syntax">erl_syntax</a> module for details.
</p> </dd></dl><h3>Functions</h3><h4>create_stubs(Stubs::[], Options::[term()]) -&gt; [string()]</h4><p>Creates stub module source files corresponding to the given stub descriptors.</p><a name="create_stubs-2"></a><p>Creates stub module source files corresponding to the given stub
descriptors. The returned value is the list of names of the created
files. See <strong>merge_sources/3</strong> for more information about  
stub descriptors.</p><p>Options:
</p><dl><dt><strong>{backup_suffix, string()}</strong></dt><dd></dd><dt><strong>{backups, boolean()}</strong></dt><dd></dd><dt><strong>{printer, Function}</strong></dt><dd></dd><dt><strong>{stub_dir, filename()}</strong></dt><dd></dd><dt><strong>{suffix, string()}</strong></dt><dd></dd><dt><strong>{verbose, boolean()}</strong></dt><dd></dd></dl><p>See <strong>merge/3</strong> for details on these options.
</p><p><em>See also:</em> <a href="#merge-3">merge/3</a>, <a href="#merge_sources-3">merge_sources/3</a>.</p><h4>merge(Name::atom(), Files::[]) -&gt; []</h4><p>Equivalent to merge(Name, Files, []). </p><a name="merge-2"></a><p>Equivalent to <a href="#merge-3">merge(Name, Files, [])</a>.</p><h4>merge(Name::atom(), Files::[], Options::[term()]) -&gt; []</h4><p>Merges source code files to a single file.</p><a name="merge-3"></a><p>Merges source code files to a single file. <strong>Name</strong>
specifies the name of the resulting module - not the name of the
output file. <strong>Files</strong> is a list of file names and/or module
names of source modules to be read and merged (see
<strong>merge_files/4</strong> for details). All the input modules must  
be distinctly named.</p><p>The resulting source code is written to a file named
"<strong>&lt;em&gt;Name&lt;/em&gt;.erl</strong>" in the current directory, unless
otherwise specified by the options <strong>dir</strong> and
<strong>outfile</strong> described below.</p><p>Examples:
</p><ul><li><p>given a module <strong>m</strong> in file "<strong>m.erl</strong>"
which uses the standard library module <strong>lists</strong>, calling
<strong>igor:merge(m, [m, lists])</strong> will create a new file
"<strong>m.erl</strong> which contains the code from <strong>m</strong> and
exports the same functions, and which includes the referenced code
from the <strong>lists</strong> module. The original file will be
renamed to "<strong>m.erl.bak</strong>".</p></li><li><p>given modules <strong>m1</strong> and <strong>m2</strong>, in
corresponding files, calling <strong>igor:merge(m, [m1, m2])</strong>
will create a file "<strong>m.erl</strong>" which contains the code
from <strong>m1</strong> and <strong>m2</strong> and exports the functions
of <strong>m1</strong>.</p></li></ul><p>Stub module files are created for those modules that are to be
exported by the target module (see options <strong>export</strong>,
<strong>stubs</strong> and <strong>stub_dir</strong>).</p><p>The function returns the list of file names of all created  
modules, including any automatically created stub modules. The file  
name of the target module is always first in the list.</p><p>Note: If you get a "syntax error" message when trying to merge
files (and you know those files to be correct), then try the
<strong>preprocess</strong> option. It typically means that your code  
contains too strange macros to be handled without actually performing  
the preprocessor expansions.</p><p>Options:
</p><dl><dt><strong>{backup_suffix, string()}</strong></dt><dd><p>Specifies the file name suffix to be used when a backup file
is created; the default value is <strong>".bak"</strong>.</p></dd><dt><strong>{backups, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, existing files will be
renamed before new files are opened for writing. The new names
are formed by appending the string given by the
<strong>backup_suffix</strong> option to the original name. The
default value is <strong>true</strong>.</p></dd><dt><strong>{dir, filename()}</strong></dt><dd><p>Specifies the name of the directory in which the output file
is to be written. An empty string is interpreted as the current
directory. By default, the current directory is used.</p></dd><dt><strong>{outfile, filename()}</strong></dt><dd><p>Specifies the name of the file (without suffix) to which the
resulting source code is to be written. By default, this is the
same as the <strong>Name</strong> argument.</p></dd><dt><strong>{preprocess, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, preprocessing will be done
when reading the source code. See <strong>merge_files/4</strong> for
details.</p></dd><dt><strong>{printer, Function}</strong></dt><dd><ul><li><p><strong>Function = (syntaxTree()) -&gt; string()</strong></p></li></ul><p>
Specifies a function for prettyprinting Erlang syntax trees.
This is used for outputting the resulting module definition, as
well as for creating stub files. The function is assumed to
return formatted text for the given syntax tree, and should raise
an exception if an error occurs. The default formatting function
calls <strong>erl_prettypr:format/2</strong>.</p></dd><dt><strong>{stub_dir, filename()}</strong></dt><dd><p>Specifies the name of the directory to which any generated
stub module files are written. The default value is
<strong>"stubs"</strong>.</p></dd><dt><strong>{stubs, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, stub module files will be
automatically generated for all exported modules that do not have
the same name as the target module. The default value is
<strong>true</strong>.</p></dd><dt><strong>{suffix, string()}</strong></dt><dd><p>Specifies the suffix to be used for the output file names;
the default value is <strong>".erl"</strong>.</p></dd></dl><p>See <strong>merge_files/4</strong> for further options.
</p><p><em>See also:</em> <a href="#merge-2">merge/2</a>, <a href="#merge_files-4">merge_files/4</a>.</p><h4>merge_files(Name::atom(), Files::[], Options::[term()]) -&gt; {, []}</h4><p>Equivalent to merge_files(Name, [], Files, Options). </p><a name="merge_files-3"></a><p>Equivalent to <a href="#merge_files-4">merge_files(Name, [], Files, Options)</a>.</p><h4>merge_files(Name::atom(), Sources::[Forms], Files::[], Options::[term()]) -&gt; {, []}</h4><p>Merges source code files and syntax trees to a single syntax tree.</p><ul><li><span class="v">Forms =  | []</span></li></ul><a name="merge_files-4"></a><p>Merges source code files and syntax trees to a single syntax
tree. This is a file-reading front end to
<strong>merge_sources/3</strong>. <strong>Name</strong> specifies the name of
the resulting module - not the name of the output file.
<strong>Sources</strong> is a list of syntax trees and/or lists of
"source code form" syntax trees, each entry representing a module
definition. <strong>Files</strong> is a list of file names and/or module  
names of source modules to be read and included. All the input  
modules must be distinctly named.</p><p>If a name in <strong>Files</strong> is not the name of an existing
file, Igor assumes it represents a module name, and tries to locate
and read the corresponding source file. The parsed files are appended
to <strong>Sources</strong> and passed on to
<strong>merge_sources/3</strong>, i.e., entries in <strong>Sources</strong>  
are listed before entries read from files.</p><p>If no exports are listed by an <strong>export</strong> option (see
<strong>merge_sources/3</strong> for details), then if <strong>Name</strong>
is also the name of one of the input modules, that module will be
exported; otherwise, the first listed module will be exported. Cf.
the examples under <strong>merge/3</strong>.</p><p>The result is a pair <strong>{Tree, Stubs}</strong>, where
<strong>Tree</strong> represents the source code that is the result of
merging all the code in <strong>Sources</strong> and <strong>Files</strong>,
and <strong>Stubs</strong> is a list of stub module descriptors (see
<strong>merge_sources/3</strong> for details).</p><p>Options:
</p><dl><dt><strong>{comments, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, source code comments in
the original files will be preserved in the output. The default
value is <strong>true</strong>.</p></dd><dt><strong>{find_src_rules, [{string(), string()}]}</strong></dt><dd><p>Specifies a list of rules for associating object files with
source files, to be passed to the function
<strong>filelib:find_source/2</strong>. This can be used to change the
way Igor looks for source files. If this option is not specified,
the default system rules are used. The first occurrence of this
option completely overrides any later in the option list.</p></dd><dt><strong>{includes, [filename()]}</strong></dt><dd><p>Specifies a list of directory names for the Erlang
preprocessor, if used, to search for include files (cf. the
<strong>preprocess</strong> option). The default value is the empty
list. The directory of the source file and the current directory
are automatically appended to the list.</p></dd><dt><strong>{macros, [{atom(), term()}]}</strong></dt><dd><p>Specifies a list of "pre-defined" macro definitions for the
Erlang preprocessor, if used (cf. the <strong>preprocess</strong>
option). The default value is the empty list.</p></dd><dt><strong>{preprocess, boolean()}</strong></dt><dd><p>If the value is <strong>false</strong>, Igor will read source
files without passing them through the Erlang preprocessor
(<strong>epp</strong>), in order to avoid expansion of preprocessor
directives such as <strong>-include(...).</strong>,
<strong>-define(...).</strong> and <strong>-ifdef(...)</strong>, and
macro calls such as <strong>?LINE</strong> and <strong>?MY_MACRO(x, y)</strong>. The default value is <strong>false</strong>, i.e.,
preprocessing is not done. (See the module
<strong>epp_dodger</strong> for details.)</p> <p>Notes: If a file contains too exotic definitions or uses of
macros, it will not be possible to read it without preprocessing.
Furthermore, Igor does not currently try to sort out multiple
inclusions of the same file, or redefinitions of the same macro
name. Therefore, when preprocessing is turned off, it may become
necessary to edit the resulting source code, removing such
re-inclusions and redefinitions.</p></dd></dl><p>See <strong>merge_sources/3</strong> for further options.
</p><p><em>See also:</em> <a href="epp_dodger">epp_dodger</a>, <a href="../stdlib/filelib#find_source/2">filelib:find_source/2</a>, <a href="#merge-3">merge/3</a>, <a href="#merge_files-3">merge_files/3</a>, <a href="#merge_sources-3">merge_sources/3</a>.</p><h4>merge_sources(Name::atom(), Sources::[Forms], Options::[term()]) -&gt; {, []}</h4><p>Merges syntax trees to a single syntax tree.</p><ul><li><span class="v">Forms =  | []</span></li></ul><a name="merge_sources-3"></a><p>Merges syntax trees to a single syntax tree. This is the main
code merging "engine". <strong>Name</strong> specifies the name of the
resulting module. <strong>Sources</strong> is a list of syntax trees of
type <strong>form_list</strong> and/or lists of "source code form" syntax  
trees, each entry representing a module definition. All the input  
modules must be distinctly named.</p><p>Unless otherwise specified by the options, all modules are assumed
to be at least "static", and all except the target module are assumed
to be "safe". See the <strong>static</strong> and <strong>safe</strong>  
options for details.</p><p>If <strong>Name</strong> is also the name of one of the input modules,  
the code from that module will occur at the top of the resulting  
code, and no extra "header" comments will be added. In other words,  
the look of that module will be preserved.</p><p>The result is a pair <strong>{Tree, Stubs}</strong>, where
<strong>Tree</strong> represents the source code that is the result of
merging all the code in <strong>Sources</strong>, and <strong>Stubs</strong>  
is a list of stub module descriptors (see below).</p><p><strong>Stubs</strong> contains one entry for each exported input
module (cf. the <strong>export</strong> option), each entry describing a
stub module that redirects calls of functions in the original module
to the corresponding (possibly renamed) functions in the new module.
The stub descriptors can be used to automatically generate stub
modules; see <strong>create_stubs/2</strong>.</p><p>Options:
</p><dl><dt><strong>{export, [atom()]}</strong></dt><dd><p>Specifies a list of names of input modules whose interfaces
should be exported by the output module. A stub descriptor is
generated for each specified module, unless its name is
<strong>Name</strong>. If no modules are specified, then if
<strong>Name</strong> is also the name of an input module, that
module will be exported; otherwise the first listed module in
<strong>Sources</strong> will be exported. The default value is the
empty list.</p></dd><dt><strong>{export_all, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, this is equivalent to
listing all of the input modules in the <strong>export</strong>
option. The default value is <strong>false</strong>.</p></dd><dt><strong>{file_attributes, Preserve}</strong></dt><dd><ul><li><p><strong>Preserve = yes | comment | no</strong></p></li></ul><p>
If the value is <strong>yes</strong>, all file attributes
<strong>-file(...)</strong> in the input sources will be preserved in
the resulting code. If the value is <strong>comment</strong>, they
will be turned into comments, but remain in their original
positions in the code relative to the other source code forms. If
the value is <strong>no</strong>, all file attributes will be removed
from the code, unless they have attached comments, in which case
they will be handled as in the <strong>comment</strong> case. The
default value is <strong>no</strong>.</p></dd><dt><strong>{no_banner, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, no banner comment will be
added at the top of the resulting module, even if the target
module does not have the same name as any of the input modules.
Instead, Igor will try to preserve the look of the module whose
code is at the top of the output. The default value is
<strong>false</strong>.</p></dd><dt><strong>{no_headers, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, no header comments will be
added to the resulting module at the beginning of each section of
code that originates from a particular input module. The default
value is <strong>false</strong>, which means that section headers are
normally added whenever more than two or more modules are
merged.</p></dd><dt><strong>{no_imports, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, all
<strong>-import(...)</strong> declarations in the original code will
be expanded in the result; otherwise, as much as possible of the
original import declarations will be preserved. The default value
is <strong>false</strong>.</p></dd><dt><strong>{notes, Notes}</strong></dt><dd><ul><li><p><strong>Notes = always | yes | no</strong></p></li></ul><p>
If the value is <strong>yes</strong>, comments will be inserted where
important changes have been made in the code. If the value is
<strong>always</strong>, <em>all</em> changes to the code will be
commented. If the value is <strong>no</strong>, changes will be made
without comments. The default value is <strong>yes</strong>.</p></dd><dt><strong>{redirect, [{atom(), atom()}]}</strong></dt><dd><p>Specifies a list of pairs of module names, representing a
mapping from old names to new. <em>The set of old names may not include any of the names of the input modules.</em> All calls to
the listed old modules will be rewritten to refer to the
corresponding new modules. <em>The redirected calls will not be further processed, even if the new destination is in one of the input modules.</em> This option mainly exists to support module
renaming; cf. <strong>rename/3</strong>. The default value is the
empty list.</p></dd><dt><strong>{safe, [atom()]}</strong></dt><dd><p>Specifies a list of names of input modules such that calls to
these "safe" modules may be turned into direct local calls, that
do not test for code replacement. Typically, this can be done for
e.g. standard library modules. If a module is "safe", it is per
definition also "static" (cf. below). The list may be empty. By
default, all involved modules <em>except the target module</em>
are considered "safe".</p></dd><dt><strong>{static, [atom()]}</strong></dt><dd><p>Specifies a list of names of input modules which will be
assumed never to be replaced (reloaded) unless the target module
is also first replaced. The list may be empty. The target module
itself (which may also be one of the input modules) is always
regarded as "static", regardless of the value of this option. By
default, all involved modules are assumed to be static.</p></dd><dt><strong>{tidy, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, the resulting code will be
processed using the <strong>erl_tidy</strong> module, which removes
unused functions and does general code cleanup. (See
<strong>erl_tidy:module/2</strong> for additional options.) The
default value is <strong>true</strong>.</p></dd><dt><strong>{verbose, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, progress messages will be
output while the program is running; the default value is
<strong>false</strong>.</p></dd></dl><p>Note: The distinction between "static" and "safe" modules is
necessary in order not to break the semantics of dynamic code
replacement. A "static" source module will not be replaced unless the
target module also is. Now imagine a state machine implemented by
placing the code for each state in a separate module, and suppose
that we want to merge this into a single target module, marking all
source modules as static. At each point in the original code where a
call is made from one of the modules to another (i.e., the state
transitions), code replacement is expected to be detected. Then, if
we in the merged code do not check at these points if the
<em>target</em> module (the result of the merge) has been replaced,  
we cannot be sure in general that we will be able to do code  
replacement of the merged state machine - it could run forever  
without detecting the code change. Therefore, all such calls must  
remain remote-calls (detecting code changes), but may call the target  
module directly.</p><p>If we are sure that this kind of situation cannot ensue, we may
specify the involved modules as "safe", and all calls between them
will become local. Note that if the target module itself is specified
as safe, "remote" calls to itself will be turned into local calls.
This would destroy the code replacement properties of e.g. a typical
server loop.
</p><p><em>See also:</em> <a href="#create_stubs-2">create_stubs/2</a>, <a href="#rename-3">rename/3</a>, <a href="./erl_tidy#module-2">erl_tidy:module/2</a>.</p><h4>parse_transform(Forms::[], Options::[term()]) -&gt; []</h4><p>Allows Igor to work as a component of the Erlang compiler.</p><a name="parse_transform-2"></a><p>Allows Igor to work as a component of the Erlang compiler.
Including the term <strong>{parse_transform, igor}</strong> in the
compile options when compiling an Erlang module (cf.
<strong>compile:file/2</strong>), will call upon Igor to process the  
source code, allowing automatic inclusion of other source files. No  
files are created or overwritten when this function is used.</p><p>Igor will look for terms <strong>{igor, List}</strong> in the compile
options, where <strong>List</strong> is a list of Igor-specific options,
as follows:
</p><dl><dt><strong>{files, [filename()]}</strong></dt><dd><p>The value specifies a list of source files to be merged with
the file being compiled; cf. <strong>merge_files/4</strong>.</p></dd></dl><p>See <strong>merge_files/4</strong> for further options. Note, however,
that some options are preset by this function and cannot be
overridden by the user; in particular, all cosmetic features are
turned off, for efficiency. Preprocessing is turned on.
</p><p><em>See also:</em> <a href="../compiler/compile#file/2">compile:file/2</a>, <a href="#merge_files-4">merge_files/4</a>.</p><h4>rename(Files::[], Renamings) -&gt; [string()]</h4><p>Equivalent to rename(Files, Renamings, []). </p><a name="rename-2"></a><p>Equivalent to <a href="#rename-3">rename(Files, Renamings, [])</a>.</p><h4>rename(Files::[], Renamings, Options::[term()]) -&gt; [string()]</h4><p>Renames a set of possibly interdependent source code modules.</p><ul><li><span class="v">Renamings = [{atom(), atom()}]</span></li></ul><a name="rename-3"></a><p>Renames a set of possibly interdependent source code modules.
<strong>Files</strong> is a list of file names of source modules to be
processed. <strong>Renamings</strong> is a list of pairs of <em>module names</em>, representing a mapping from old names to new. The  
returned value is the list of output file names.</p><p>Each file in the list will be read and processed separately. For
every file, each reference to some module M, such that there is an
entry <strong>{&lt;em&gt;M&lt;/em&gt;, &lt;em&gt;M1&lt;/em&gt;}</strong> in
<strong>Renamings</strong>, will be changed to the corresponding M1.
Furthermore, if a file F defines module M, and there is an entry
<strong>{&lt;em&gt;M&lt;/em&gt;, &lt;em&gt;M1&lt;/em&gt;}</strong> in <strong>Renamings</strong>, a
new file named <strong>&lt;em&gt;M1&lt;/em&gt;.erl</strong> will be created in the
same directory as F, containing the source code for module M, renamed
to M1. If M does not have an entry in <strong>Renamings</strong>, the
module is not renamed, only updated, and the resulting source code is
written to <strong>&lt;em&gt;M&lt;/em&gt;.erl</strong> (typically, this overwrites
the original file). The <strong>suffix</strong> option (see below) can be
used to change the default "<strong>.erl</strong>" suffix for the  
generated files.</p><p>Stub modules will automatically be created (see the
<strong>stubs</strong> and <strong>stub_dir</strong> options below) for each  
module that is renamed. These can be used to redirect any calls still  
using the old module names. The stub files are created in the same  
directory as the source file (typically overwriting the original  
file).</p><p>Options:
</p><dl><dt><strong>{backup_suffix, string()}</strong></dt><dd></dd><dt><strong>{backups, boolean()}</strong></dt><dd></dd><dt><strong>{printer, Function}</strong></dt><dd></dd><dt><strong>{stubs, boolean()}</strong></dt><dd></dd><dt><strong>{suffix, string()}</strong></dt><dd></dd></dl><p>
See <strong>merge/3</strong> for details on these options.</p><dl><dt><strong>{comments, boolean()}</strong></dt><dd></dd><dt><strong>{preprocess, boolean()}</strong></dt><dd></dd></dl><p>
See <strong>merge_files/4</strong> for details on these options.</p><dl><dt><strong>{no_banner, boolean()}</strong></dt><dd></dd></dl><p>
For the <strong>rename</strong> function, this option is
<strong>true</strong> by default. See <strong>merge_sources/3</strong> for  
details.</p><dl><dt><strong>{tidy, boolean()}</strong></dt><dd></dd></dl><p>
For the <strong>rename</strong> function, this option is
<strong>false</strong> by default. See <strong>merge_sources/3</strong> for  
details.</p><dl><dt><strong>{no_headers, boolean()}</strong></dt><dd></dd><dt><strong>{stub_dir, filename()}</strong></dt><dd></dd></dl><p>
These options are preset by the <strong>rename</strong> function and  
cannot be overridden by the user.</p><p>See <strong>merge_sources/3</strong> for further options.
</p><p><em>See also:</em> <a href="#merge-3">merge/3</a>, <a href="#merge_files-4">merge_files/4</a>, <a href="#merge_sources-3">merge_sources/3</a>.</p><h3>Authors</h3><span class="aname">Richard Carlsson</span><span class="email">carlsson.richard@gmail.com</span><h3>merl</h3><p>Metaprogramming in Erlang.</p><p>Metaprogramming in Erlang.
Merl is a more user friendly interface to the <strong>erl_syntax</strong> module, making
it easy both to build new ASTs from scratch and to
match and decompose existing ASTs. For details that are outside the scope
of Merl itself, please see the documentation of <a href="erl_syntax">erl_syntax</a>.<a name="Quick_start"></a><em>Quick start</em>To enable the full power of Merl, your module needs to include the Merl
header file:
<pre>     -include_lib("syntax_tools/include/merl.hrl").</pre>Then, you can use the <strong>?Q(Text)</strong> macros in your code to create ASTs or match
on existing ASTs. For example:
<pre>     Tuple = ?Q("{foo, 42}"),
     ?Q("{foo, _@Number}") = Tuple,
     Call = ?Q("foo:bar(_@Number)")</pre>Calling <strong>merl:print(Call)</strong> will then print the following code:
<pre>     foo:bar(42)</pre>The <strong>?Q</strong> macros turn the quoted code fragments into ASTs, and lifts
metavariables such as <strong>_@Tuple</strong> and <strong>_@Number</strong> to the level of your Erlang
code, so you can use the corresponding Erlang variables <strong>Tuple</strong> and <strong>Number</strong>  
directly. This is the most straightforward way to use Merl, and in many  
cases it's all you need.You can even write case switches using <strong>?Q</strong> macros as patterns. For example:
<pre>     case AST of
         ?Q("{foo, _@Foo}") -&gt; handle(Foo);
         ?Q("{bar, _@Bar}") when erl_syntax:is_integer(Bar) -&gt; handle(Bar);
         _ -&gt; handle_default()
     end</pre>These case switches only allow <strong>?Q(...)</strong> or <strong>_</strong> as clause patterns, and the  
guards may contain any expressions, not just Erlang guard expressions.If the macro <strong>MERL_NO_TRANSFORM</strong> is defined before the <strong>merl.hrl</strong> header
file is included, the parse transform used by Merl will be disabled, and in
that case, the match expressions <strong>?Q(...) = ...</strong>, case switches using
<strong>?Q(...)</strong> patterns, and automatic metavariables like <strong>_@Tuple</strong> cannot be
used in your code, but the Merl macros and functions still work. To do
metavariable substitution, you need to use the <strong>?Q(Text, Map)</strong> macro, e.g.:
<pre>     Tuple = ?Q("{foo, _@bar, _@baz}", [{bar, Bar}, {baz,Baz}])</pre>The text given to a <strong>?Q(Text)</strong> macro can be either a single string, or a
list of strings. The latter is useful when you need to split a long
expression over multiple lines, e.g.:
<pre>     ?Q(["case _@Expr of",
         "  {foo, X} -&gt; f(X);",
         "  {bar, X} -&gt; g(X)",
         "  _ -&gt; h(X)"
         "end"])</pre>  
If there is a syntax error somewhere in the text (like the missing semicolon  
in the second clause above) this allows Merl to generate an error message  
pointing to the exact line in your source code. (Just remember to  
comma-separate the strings in the list, otherwise Erlang will concatenate  
the string fragments as if they were a single string.)<a name="Metavariable_syntax"></a><em>Metavariable syntax</em>There are several ways to write a metavariable in your quoted code:
<ul><li><p>Atoms starting with <strong>@</strong>, for example <strong>'@foo'</strong> or <strong>'@Foo'</strong></p></li><li><p>Variables starting with <strong>_@</strong>, for example <strong>_@bar</strong> or <strong>_@Bar</strong></p></li><li><p>Strings starting with <strong>"'@</strong>, for example <strong>"'@File"</strong></p></li><li><p>Integers starting with 909, for example <strong>9091</strong> or <strong>909123</strong></p></li></ul>
Following the prefix, one or more <strong>_</strong> or <strong>0</strong> characters may be used to
indicate "lifting" of the variable one or more levels, and after that, a <strong>@</strong>
or <strong>9</strong> character indicates a glob metavariable (matching zero or more
elements in a sequence) rather than a normal metavariable. For example:
<ul><li><p><strong>'@_foo'</strong> is lifted one level, and <strong>_@__foo</strong> is lifted two
levels</p></li><li><p><strong>_@@bar</strong> is a glob variable, and <strong>_@_@bar</strong> is a lifted glob
variable</p></li><li><p><strong>90901</strong> is a lifted variable,<strong>90991</strong> is a glob variable, and <strong>9090091</strong>
is a glob variable lifted two levels</p></li></ul>
(Note that the last character in the name is never considered to be a lift
or glob marker, hence, <strong>_@__</strong> and <strong>90900</strong> are only lifted one level, not  
two. Also note that globs only matter for matching; when doing  
substitutions, a non-glob variable can be used to inject a sequence of  
elements, and vice versa.)If the name after the prefix and any lift and glob markers is <strong>_</strong> or <strong>0</strong>,
the variable is treated as an anonymous catch-all pattern in matches. For
example, <strong>_@_</strong>, <strong>_@@_</strong>, <strong>_@__</strong>, or even <strong>_@__@_</strong>.Finally, if the name without any prefixes or lift/glob markers begins with
an uppercase character, as in <strong>_@Foo</strong> or <strong>_@_@Foo</strong>, it will become a
variable on the Erlang level, and can be used to easily deconstruct and
construct syntax trees:
<pre>     case Input of
         ?Q("{foo, _@Number}") -&gt; ?Q("foo:bar(_@Number)");
         ...</pre>
We refer to these as "automatic metavariables". If in addition the name ends
with <strong>@</strong>, as in <strong>_@Foo@</strong>, the value of the variable as an Erlang term will
be automatically converted to the corresponding abstract syntax tree when
used to construct a larger tree. For example, in:
<pre>     Bar = {bar, 42},
     Foo = ?Q("{foo, _@Bar@}")</pre>
(where Bar is just some term, not a syntax tree) the result <strong>Foo</strong> will be a
syntax tree representing <strong>{foo, {bar, 42}}</strong>. This avoids the need for
temporary variables in order to inject data, as in
<pre>     TmpBar = erl_syntax:abstract(Bar),
     Foo = ?Q("{foo, _@TmpBar}")</pre>If the context requires an integer rather than a variable, an atom, or a
string, you cannot use the uppercase convention to mark an automatic
metavariable. Instead, if the integer (without the <strong>909</strong>-prefix and
lift/glob markers) ends in a <strong>9</strong>, the integer will become an Erlang-level
variable prefixed with <strong>Q</strong>, and if it ends with <strong>99</strong> it will also be
automatically abstracted. For example, the following will increment the
arity of the exported function f:
<pre>     case Form of
         ?Q("-export([f/90919]).") -&gt;
             Q2 = erl_syntax:concrete(Q1) + 1,
             ?Q("-export([f/909299]).");
         ...</pre><a name="When_to_use_the_various_forms_of_metavariables"></a><em>When to use the various forms of metavariables</em>Merl can only parse a fragment of text if it follows the basic syntactical
rules of Erlang. In most places, a normal Erlang variable can be used as
metavariable, for example:
<pre>     ?Q("f(_@Arg)") = Expr</pre>
but if you want to match on something like the name of a function, you have
to use an atom as metavariable:
<pre>     ?Q("'@Name'() -&gt; _@@_." = Function</pre>
(note the anonymous glob variable <strong>_@@_</strong> to ignore the function body).In some contexts, only a string or an integer is allowed. For example, the
directive <strong>-file(Name, Line)</strong> requires that <strong>Name</strong> is a string literal and
<strong>Line</strong> an integer literal:<pre>     ?Q("-file(\"'@File\", 9090).") = ?Q("-file(\"foo.erl\", 42).")).</pre>
This will extract the string literal <strong>"foo.erl"</strong> into the variable <strong>Foo</strong>.
Note the use of the anonymous variable <strong>9090</strong> to ignore the line number. To  
match and also bind a metavariable that must be an integer literal, we can  
use the convention of ending the integer with a 9, turning it into a  
Q-prefixed variable on the Erlang level (see the previous section).<a name="Globs"></a><em>Globs</em>Whenever you want to match out a number of elements in a sequence (zero or
more) rather than a fixed set of elements, you need to use a glob. For
example:
<pre>     ?Q("{_@@Elements}") = ?Q({a, b, c})</pre>
will bind Elements to the list of individual syntax trees representing the
atoms <strong>a</strong>, <strong>b</strong>, and <strong>c</strong>. This can also be used with static prefix and suffix
elements in the sequence. For example:
<pre>     ?Q("{a, b, _@@Elements}") = ?Q({a, b, c, d})</pre>
will bind Elements to the list of the <strong>c</strong> and <strong>d</strong> subtrees, and
<pre>     ?Q("{_@@Elements, c, d}") = ?Q({a, b, c, d})</pre>
will bind Elements to the list of the <strong>a</strong> and <strong>b</strong> subtrees. You can even use
plain metavariables in the prefix or suffix:
<pre>     ?Q("{_@First, _@@Rest}") = ?Q({a, b, c})</pre>
or
<pre>     ?Q("{_@@_, _@Last}") = ?Q({a, b, c})</pre>  
(ignoring all but the last element). You cannot however have two globs as  
part of the same sequence.<a name="Lifted_metavariables"></a><em>Lifted metavariables</em>In some cases, the Erlang syntax rules make it impossible to place a
metavariable directly where you would like it. For example, you cannot
write:
<pre>     ?Q("-export([_@@Name]).")</pre>
to match out all name/arity pairs in the export list, or to insert a list of
exports in a declaration, because the Erlang parser only allows elements on
the form <strong>A/I</strong> (where <strong>A</strong> is an atom and <strong>I</strong> an integer) in the export list.
A variable like the above is not allowed, but neither is a single atom or
integer, so <strong>'@@Name'</strong> or <strong>909919</strong> wouldn't work either.What you have to do in such cases is to write your metavariable in a
syntactically valid position, and use lifting markers to denote where it
should really apply, as in:
<pre>     ?Q("-export(['@_@Name'/0]).")</pre>
This causes the variable to be lifted (after parsing) to the next higher
level in the syntax tree, replacing that entire subtree. In this case, the
<strong>'@_@Name'/0</strong> will be replaced with <strong>'@@Name'</strong>, and the <strong>/0</strong>  
part was just used as dummy notation and will be discarded.You may even need to apply lifting more than once. To match the entire
export list as a single syntax tree, you can write:
<pre>     ?Q("-export(['@__Name'/0]).")</pre>
using two underscores, but with no glob marker this time. This will make the
entire <strong>['@__Name'/0]</strong> part be replaced with <strong>'@Name'</strong>.Sometimes, the tree structure of a code fragment isn't very obvious, and
parts of the structure may be invisible when printed as source code. For
instance, a simple function definition like the following:
<pre>     zero() -&gt; 0.</pre>
consists of the name (the atom <strong>zero</strong>), and a list of clauses containing the
single clause <strong>() -&gt; 0</strong>. The clause consists of an argument list (empty), a
guard (empty), and a body (which is always a list of expressions) containing
the single expression <strong>0</strong>. This means that to match out the name and the
list of clauses of any function, you'll need to use a pattern like
<strong>?Q("'@Name'() -&gt; _@_@Body.")</strong>, using a dummy clause whose body is a glob  
lifted one level.To visualize the structure of a syntax tree, you can use the function
<strong>merl:show(T)</strong>, which prints a summary. For example, entering
<pre>     merl:show(merl:quote("inc(X, Y) when Y &gt; 0 -&gt; X + Y."))</pre>
in the Erlang shell will print the following (where the <strong>+</strong> signs separate
groups of subtrees on the same level):
<pre>     function: inc(X, Y) when ... -&gt; X + Y.
       atom: inc
       +
       clause: (X, Y) when ... -&gt; X + Y
         variable: X
         variable: Y
         +
         disjunction: Y &gt; 0
           conjunction: Y &gt; 0
             infix_expr: Y &gt; 0
               variable: Y
               +
               operator: &gt;
               +
               integer: 0
         +
         infix_expr: X + Y
           variable: X
           +
           operator: +
           +
           variable: Y</pre>This shows another important non-obvious case: a clause guard, even if it's
as simple as <strong>Y &gt; 0</strong>, always consists of a single disjunction of one or more
conjunctions of tests, much like a tuple of tuples. Thus:
<ul><li><p><strong>"when _@Guard -&gt;"</strong> will only match a guard with exactly one
test</p></li><li><p><strong>"when _@@Guard -&gt;"</strong> will match a guard with one or more
comma-separated tests (but no semicolons), binding <strong>Guard</strong> to the list
of tests</p></li><li><p><strong>"when _@_Guard -&gt;"</strong> will match just like the previous pattern, but
binds <strong>Guard</strong> to the conjunction subtree</p></li><li><p><strong>"when _@_@Guard -&gt;"</strong> will match an arbitrary nonempty guard,
binding <strong>Guard</strong> to the list of conjunction subtrees</p></li><li><p><strong>"when _@__Guard -&gt;"</strong> will match like the previous pattern, but
binds <strong>Guard</strong> to the whole disjunction subtree</p></li><li><p>and finally, <strong>"when _@__@Guard -&gt;"</strong> will match any clause,
binding <strong>Guard</strong> to <strong>[]</strong> if the guard is empty and to <strong>[Disjunction]</strong>
otherwise</p></li></ul>Thus, the following pattern matches all possible clauses:
<pre>     "(_@Args) when _@__@Guard -&gt; _@Body"</pre></p><h4>DATA TYPES</h4><a name="types"></a><dl><dt><a name="type-default_action"></a>default_action() = () -&gt; any()</dt><dd> </dd><dt><a name="type-env"></a>env() = [{Key::<a href="#type-id">id()</a>, <a href="#type-pattern_or_patterns">pattern_or_patterns()</a>}]</dt><dd> </dd><dt><a name="type-guard_test"></a>guard_test() = (<a href="#type-env">env()</a>) -&gt; boolean()</dt><dd> </dd><dt><a name="type-guarded_action"></a>guarded_action() = <a href="#type-switch_action">switch_action()</a> | {<a href="#type-guard_test">guard_test()</a>, <a href="#type-switch_action">switch_action()</a>}</dt><dd> </dd><dt><a name="type-guarded_actions"></a>guarded_actions() = <a href="#type-guarded_action">guarded_action()</a> | [<a href="#type-guarded_action">guarded_action()</a>]</dt><dd> </dd><dt><a name="type-id"></a>id() = atom() | integer()</dt><dd> </dd><dt><a name="type-location"></a>location() = <a href="./erl_anno#type-location">erl_anno:location()</a></dt><dd> </dd><dt><a name="type-pattern"></a>pattern() = <a href="#type-tree">tree()</a> | <a href="#type-template">template()</a></dt><dd> </dd><dt><a name="type-pattern_or_patterns"></a>pattern_or_patterns() = <a href="#type-pattern">pattern()</a> | [<a href="#type-pattern">pattern()</a>]</dt><dd> </dd><dt><a name="type-switch_action"></a>switch_action() = (<a href="#type-env">env()</a>) -&gt; any()</dt><dd> </dd><dt><a name="type-switch_clause"></a>switch_clause() = {<a href="#type-pattern_or_patterns">pattern_or_patterns()</a>, <a href="#type-guarded_actions">guarded_actions()</a>} | {<a href="#type-pattern_or_patterns">pattern_or_patterns()</a>, <a href="#type-guard_test">guard_test()</a>, <a href="#type-switch_action">switch_action()</a>} | <a href="#type-default_action">default_action()</a></dt><dd> </dd><dt><a name="type-template"></a>template() = <a href="#type-tree">tree()</a> | {<a href="#type-id">id()</a>} | {*, <a href="#type-id">id()</a>} | {template, atom(), term(), [[<a href="#type-template">template()</a>]]}</dt><dd> </dd><dt><a name="type-template_or_templates"></a>template_or_templates() = <a href="#type-template">template()</a> | [<a href="#type-template">template()</a>]</dt><dd> </dd><dt><a name="type-text"></a>text() = string() | binary() | [string()] | [binary()]</dt><dd> </dd><dt><a name="type-tree"></a>tree() = <a href="./erl_syntax#type-syntaxTree">erl_syntax:syntaxTree()</a></dt><dd> </dd><dt><a name="type-tree_or_trees"></a>tree_or_trees() = <a href="#type-tree">tree()</a> | [<a href="#type-tree">tree()</a>]</dt><dd> </dd></dl><h3>Functions</h3><h4>alpha(Trees::, Env::[{,}]) -&gt;</h4><p>Alpha converts a pattern (renames variables).</p><a name="alpha-2"></a><p>Alpha converts a pattern (renames variables). Similar to tsubst/1,
but only renames variables (including globs).</p><p><em>See also:</em> <a href="#tsubst-2">tsubst/2</a>.</p><h4>compile(Code) -&gt; term()
</h4><p>Equivalent to compile(Code, []). </p><a name="compile-1"></a><p>Equivalent to <a href="#compile-2">compile(Code, [])</a>.</p><h4>compile(Code, Options) -&gt; term()
</h4><p>Compile a syntax tree or list of syntax trees representing a module into a binary BEAM object.</p><a name="compile-2"></a><p>Compile a syntax tree or list of syntax trees representing a module
into a binary BEAM object.</p><p><em>See also:</em> <a href="#compile-1">compile/1</a>, <a href="#compile_and_load-2">compile_and_load/2</a>.</p><h4>compile_and_load(Code) -&gt; term()
</h4><p>Equivalent to compile_and_load(Code, []). </p><a name="compile_and_load-1"></a><p>Equivalent to <a href="#compile_and_load-2">compile_and_load(Code, [])</a>.</p><h4>compile_and_load(Code, Options) -&gt; term()
</h4><p>Compile a syntax tree or list of syntax trees representing a module and load the resulting module into memory.</p><a name="compile_and_load-2"></a><p>Compile a syntax tree or list of syntax trees representing a module
and load the resulting module into memory.</p><p><em>See also:</em> <a href="#compile-2">compile/2</a>, <a href="#compile_and_load-1">compile_and_load/1</a>.</p><h4>match(Patterns::, Trees::) -&gt; {ok,} | error</h4><p>Match a pattern against a syntax tree (or patterns against syntax trees) returning an environment mapping variable names to subtrees; the environment is always sorted on keys.</p><a name="match-2"></a><p>Match a pattern against a syntax tree (or patterns against syntax
trees) returning an environment mapping variable names to subtrees; the
environment is always sorted on keys. Note that multiple occurrences of
metavariables in the pattern is not allowed, but is not checked.
</p><p><em>See also:</em> <a href="#switch-2">switch/2</a>, <a href="#template-1">template/1</a>.</p><h4>meta_template(Templates::) -&gt;</h4><p>Turn a template into a syntax tree representing the template.</p><a name="meta_template-1"></a><p>Turn a template into a syntax tree representing the template.
Meta-variables in the template are turned into normal Erlang variables if
their names (after the metavariable prefix characters) begin with an
uppercase character. E.g., <strong>_@Foo</strong> in the template becomes the variable
<strong>Foo</strong> in the meta-template. Furthermore, variables ending with <strong>@</strong> are
automatically wrapped in a call to merl:term/1, so e.g. <strong>_@Foo@ in the template becomes `merl:term(Foo)</strong> in the meta-template.</p><h4>print(Ts) -&gt; term()
</h4><p>Pretty-print a syntax tree or template to the standard output.</p><a name="print-1"></a><p>Pretty-print a syntax tree or template to the standard output. This
is a utility function for development and debugging.</p><h4>qquote(Text::, Env::) -&gt;</h4><p>Parse text and substitute meta-variables.</p><a name="qquote-2"></a><p>Parse text and substitute meta-variables.
</p><h4>qquote(StartPos::, Text::, Env::) -&gt;</h4><p>Parse text and substitute meta-variables.</p><a name="qquote-3"></a><p>Parse text and substitute meta-variables. Takes an initial scanner  
starting position as first argument.</p><p>The macro <strong>?Q(Text, Env)</strong> expands to <strong>merl:qquote(?LINE, Text, Env)</strong>.
</p><p><em>See also:</em> <a href="#quote-2">quote/2</a>.</p><h4>quote(Text::) -&gt;</h4><p>Parse text.</p><a name="quote-1"></a><p>Parse text.
</p><h4>quote(StartPos::, Text::) -&gt;</h4><p>Parse text.</p><a name="quote-2"></a><p>Parse text. Takes an initial scanner starting position as first  
argument.</p><p>The macro <strong>?Q(Text)</strong> expands to <strong>merl:quote(?LINE, Text, Env)</strong>.
</p><p><em>See also:</em> <a href="#quote-1">quote/1</a>.</p><h4>show(Ts) -&gt; term()
</h4><p>Print the structure of a syntax tree or template to the standard output.</p><a name="show-1"></a><p>Print the structure of a syntax tree or template to the standard
output. This is a utility function for development and debugging.</p><h4>subst(Trees::, Env::) -&gt;</h4><p>Substitute metavariables in a pattern or list of patterns, yielding a syntax tree or list of trees as result.</p><a name="subst-2"></a><p>Substitute metavariables in a pattern or list of patterns, yielding
a syntax tree or list of trees as result. Both for normal metavariables
and glob metavariables, the substituted value may be a single element or
a list of elements. For example, if a list representing <strong>1, 2, 3</strong> is
substituted for <strong>var</strong> in either of <strong>[foo, _@var, bar]</strong> or <strong>[foo, _@var, bar]</strong>, the result represents <strong>[foo, 1, 2, 3, bar]</strong>.</p><h4>switch(Trees::, Cs::[]) -&gt; any()</h4><p>Match against one or more clauses with patterns and optional guards.</p><a name="switch-2"></a><p>Match against one or more clauses with patterns and optional guards.</p><p>Note that clauses following a default action will be ignored.
</p><p><em>See also:</em> <a href="#match-2">match/2</a>.</p><h4>template(Trees::) -&gt;</h4><p>Turn a syntax tree or list of trees into a template or templates.</p><a name="template-1"></a><p>Turn a syntax tree or list of trees into a template or templates.
Templates can be instantiated or matched against, and reverted back to
normal syntax trees using <a href="#tree-1">tree/1</a>. If the input is already a
template, it is not modified further.
</p><p><em>See also:</em> <a href="#match-2">match/2</a>, <a href="#subst-2">subst/2</a>, <a href="#tree-1">tree/1</a>.</p><h4>template_vars(Template::) -&gt; []</h4><p>Return an ordered list of the metavariables in the template.</p><a name="template_vars-1"></a><p>Return an ordered list of the metavariables in the template.</p><h4>term(Term::term()) -&gt;</h4><p>Create a syntax tree for a constant term.</p><a name="term-1"></a><p>Create a syntax tree for a constant term.</p><h4>tree(Templates::) -&gt;</h4><p>Revert a template to a normal syntax tree.</p><a name="tree-1"></a><p>Revert a template to a normal syntax tree. Any remaining
metavariables are turned into <strong>@</strong>-prefixed atoms or <strong>909</strong>-prefixed
integers.</p><p><em>See also:</em> <a href="#template-1">template/1</a>.</p><h4>tsubst(Trees::, Env::) -&gt;</h4><p>Like subst/2, but does not convert the result from a template back to a tree.</p><a name="tsubst-2"></a><p>Like subst/2, but does not convert the result from a template back
to a tree. Useful if you want to do multiple separate substitutions.</p><p><em>See also:</em> <a href="#subst-2">subst/2</a>, <a href="#tree-1">tree/1</a>.</p><h4>var(Name::atom()) -&gt;</h4><p>Create a variable.</p><a name="var-1"></a><p>Create a variable.</p><h3>Authors</h3><span class="aname">Richard Carlsson</span><span class="email">carlsson.richard@gmail.com</span><h3>merl_transform</h3><p>Parse transform for merl.</p><p>Parse transform for merl. Enables the use of automatic metavariables
and using quasi-quotes in matches and case switches. Also optimizes calls
to functions in <strong>merl</strong> by partially evaluating them, turning strings to  
templates, etc., at compile-time.Using <strong>-include_lib("syntax_tools/include/merl.hrl").</strong> enables this
transform, unless the macro <strong>MERL_NO_TRANSFORM</strong> is defined first.</p><h3>Functions</h3><h4>parse_transform(Forms, Options) -&gt; term()
</h4><p> </p><a name="parse_transform-2"></a><h3>Authors</h3><span class="aname">Richard Carlsson</span><span class="email">carlsson.richard@gmail.com</span><h3>prettypr</h3><p>A generic pretty printer library.</p><p>A generic pretty printer library. This module uses a  
strict-style context passing implementation of John Hughes algorithm,  
described in "The design of a Pretty-printing Library". The  
paragraph-style formatting, empty documents, floating documents, and  
null strings are my own additions to the algorithm.To get started, you should read about the <a href="#type-document">document()</a> data
type; the main constructor functions: <a href="#text-1">text/1</a>, <a href="#above-2">above/2</a>, <a href="#beside-2">beside/2</a>, <a href="#nest-2">nest/2</a>, <a href="#sep-1">sep/1</a>, and <a href="#par-2">par/2</a>; and the main layout function <a href="#format-3">format/3</a>.If you simply want to format a paragraph of plain text, you probably
want to use the <a href="#text_par-2">text_par/2</a> function, as in the following
example:
<pre>  prettypr:format(prettypr:text_par("Lorem ipsum dolor sit amet"), 20)</pre></p><h4>DATA TYPES</h4><a name="types"></a><dl><dt><a name="type-document"></a>document()</dt><dd> <p>An abstract character-based "document" representing  
a number of possible layouts, which can be processed to produce a  
single concrete layout. A concrete layout can then be rendered as a  
sequence of characters containing linebreaks, which can be passed to  
a printer or terminal that uses a fixed-width font.</p> <p>For example, a document <strong>sep([text("foo"), text("bar")])</strong>
represents the two layouts
</p><pre>     foo bar</pre><p>
and
</p><pre>     foo
     bar</pre> <p>Which layout is chosen depends on the available horizontal space.
When processing a document, the main parameters are the <em>paper width</em> and the <em>line width</em> (also known as the "ribbon  
width"). In the resulting layout, no text should be printed beyond  
the paper width (which by default is 80 characters) as long as it can  
be avoided, and each single line of text (its indentation not  
counted, hence "ribbon") should preferably be no wider than the  
specified line width (which by default is 65).</p> <p>Documents can be joined into a single new document using the
constructor functions of this module. Note that the new document
often represents a larger number of possible layouts than just the
sum of the components.</p> </dd></dl><h3>Functions</h3><h4>above(D1::, D2::) -&gt;</h4><p>Concatenates documents vertically.</p><a name="above-2"></a><p>Concatenates documents vertically. Returns a document
representing the concatenation of the documents <strong>D1</strong> and <strong>D2</strong> such
that the first line of <strong>D2</strong> follows directly below the last line of
<strong>D1</strong>, and the first character of <strong>D2</strong> is in the same horizontal
column as the first character of <strong>D1</strong>, in all possible layouts.</p><p>Examples:
</p><pre>     ab  cd  =&gt;  ab
                 cd
 
                    abc
     abc   fgh  =&gt;   de
      de    ij      fgh
                     ij</pre><h4>beside(D1::, D2::) -&gt;</h4><p>Concatenates documents horizontally.</p><a name="beside-2"></a><p>Concatenates documents horizontally. Returns a document
representing the concatenation of the documents <strong>D1</strong> and <strong>D2</strong> such
that the last character of <strong>D1</strong> is horizontally adjacent to the first
character of <strong>D2</strong>, in all possible layouts. (Note: any indentation of
<strong>D2</strong> is lost.)</p><p>Examples:
</p><pre>     ab  cd  =&gt;  abcd
 
     ab  ef      ab
     cd  gh  =&gt;  cdef
                   gh</pre><h4>best(D::, PaperWidth::integer(), LineWidth::integer()) -&gt; empty |</h4><p>Selects a "best" layout for a document, creating a corresponding fixed-layout document.</p><a name="best-3"></a><p>Selects a "best" layout for a document, creating a corresponding
fixed-layout document. If no layout could be produced, the atom
<strong>empty</strong> is returned instead. For details about <strong>PaperWidth</strong> and
<strong>LineWidth</strong>, see <a href="#format-3">format/3</a>. The function is idempotent.</p><p>One possible use of this function is to compute a fixed layout for a
document, which can then be included as part of a larger document.
For example:
</p><pre>     above(text("Example:"), nest(8, best(D, W - 12, L - 6)))</pre><p>
will format <strong>D</strong> as a displayed-text example indented by 8, whose
right margin is indented by 4 relative to the paper width <strong>W</strong> of the
surrounding document, and whose maximum individual line length is
shorter by 6 than the line length <strong>L</strong> of the surrounding document.</p><p>This function is used by the <a href="#format-3">format/3</a> function to prepare a
document before being laid out as text.</p><h4>break(D::) -&gt;</h4><p>Forces a line break at the end of the given document.</p><a name="break-1"></a><p>Forces a line break at the end of the given document. This is a
utility function; see <a href="#empty-0">empty/0</a> for details.</p><h4>empty() -&gt;</h4><p>Yields the empty document, which has neither height nor width.</p><a name="empty-0"></a><p>Yields the empty document, which has neither height nor width.
(<strong>empty</strong> is thus different from an empty <a href="#text-1">text</a>  
string, which has zero width but height 1.)</p><p>Empty documents are occasionally useful; in particular, they have the
property that <strong>above(X, empty())</strong> will force a new line after <strong>X</strong>
without leaving an empty line below it; since this is a common idiom,
the utility function <a href="#break-1">break/1</a> will place a given document in
such a context.
</p><p><em>See also:</em> <a href="#text-1">text/1</a>.</p><h4>floating(D::) -&gt;</h4><p>Equivalent to floating(D, 0, 0). </p><a name="floating-1"></a><p>Equivalent to <a href="#floating-3">floating(D, 0, 0)</a>.</p><h4>floating(D::, Hp::integer(), Vp::integer()) -&gt;</h4><p>Creates a "floating" document.</p><a name="floating-3"></a><p>Creates a "floating" document. The result represents the same
set of layouts as <strong>D</strong>; however, a floating document may be moved
relative to other floating documents immediately beside or above it,
according to their relative horizontal and vertical priorities. These
priorities are set with the <strong>Hp</strong> and <strong>Vp</strong> parameters; if omitted,  
both default to zero.</p><p>Notes: Floating documents appear to work well, but are currently less
general than you might wish, losing effect when embedded in certain
contexts. It is possible to nest floating-operators (even with
different priorities), but the effects may be difficult to predict.
In any case, note that the way the algorithm reorders floating
documents amounts to a "bubblesort", so don't expect it to be able to
sort large sequences of floating documents quickly.</p><h4>follow(D1::, D2::) -&gt;</h4><p>Equivalent to follow(D1, D2, 0). </p><a name="follow-2"></a><p>Equivalent to <a href="#follow-3">follow(D1, D2, 0)</a>.</p><h4>follow(D1::, D2::, Offset::integer()) -&gt;</h4><p>Separates two documents by either a single space, or a line break and intentation.</p><a name="follow-3"></a><p>Separates two documents by either a single space, or a line
break and intentation. In other words, one of the layouts
</p><pre>     abc def</pre><p>
or
</p><pre>     abc
      def</pre><p>  
will be generated, using the optional offset in the latter case. This  
is often useful for typesetting programming language constructs.</p><p>This is a utility function; see <a href="#par-2">par/2</a> for further details.
</p><p><em>See also:</em> <a href="#follow-2">follow/2</a>.</p><h4>format(D::) -&gt; string()</h4><p>Equivalent to format(D, 80). </p><a name="format-1"></a><p>Equivalent to <a href="#format-2">format(D, 80)</a>.</p><h4>format(D::, PaperWidth::integer()) -&gt; string()</h4><p>Equivalent to format(D, PaperWidth, 65). </p><a name="format-2"></a><p>Equivalent to <a href="#format-3">format(D, PaperWidth, 65)</a>.</p><h4>format(D::, PaperWidth::integer(), LineWidth::integer()) -&gt; string()</h4><p>Computes a layout for a document and returns the corresponding text.</p><a name="format-3"></a><p>Computes a layout for a document and returns the corresponding
text. See <a href="#type-document">document()</a> for further information. Throws
<strong>no_layout</strong> if no layout could be selected.</p><p><strong>PaperWidth</strong> specifies the total width (in character positions) of
the field for which the text is to be laid out. <strong>LineWidth</strong> specifies
the desired maximum width (in number of characters) of the text
printed on any single line, disregarding leading and trailing white
space. These parameters need to be properly balanced in order to
produce good layouts. By default, <strong>PaperWidth</strong> is 80 and <strong>LineWidth</strong>
is 65.
</p><p><em>See also:</em> <a href="#best-3">best/3</a>.</p><h4>nest(N::integer(), D::) -&gt;</h4><p>Indents a document a number of character positions to the right.</p><a name="nest-2"></a><p>Indents a document a number of character positions to the right.
Note that <strong>N</strong> may be negative, shifting the text to the left, or
zero, in which case <strong>D</strong> is returned unchanged.</p><h4>null_text(Characters::string()) -&gt;</h4><p>Similar to text/1, but the result is treated as having   zero width.</p><a name="null_text-1"></a><p>Similar to <a href="#text-1">text/1</a>, but the result is treated as having  
zero width. This is regardless of the actual length of the string.  
Null text is typically used for markup, which is supposed to have no  
effect on the actual layout.</p><p>The standard example is when formatting source code as HTML to be
placed within <strong>&lt;pre&gt;...&lt;/pre&gt;</strong> markup, and using e.g. <strong>&lt;i&gt;</strong> and <strong>&lt;b&gt;</strong>
to make parts of the source code stand out. In this case, the markup
does not add to the width of the text when viewed in an HTML browser,
so the layout engine should simply pretend that the markup has zero
width.
</p><p><em>See also:</em> <a href="#empty-0">empty/0</a>, <a href="#text-1">text/1</a>.</p><h4>par(Docs::[]) -&gt;</h4><p>Equivalent to par(Ds, 0). </p><a name="par-1"></a><p>Equivalent to <a href="#par-2">par(Ds, 0)</a>.</p><h4>par(Docs::[], Offset::integer()) -&gt;</h4><p>Arranges documents in a paragraph-like layout.</p><a name="par-2"></a><p>Arranges documents in a paragraph-like layout. Returns a
document representing all possible left-aligned paragraph-like
layouts of the (nonempty) sequence <strong>Docs</strong> of documents. Elements in
<strong>Docs</strong> are separated horizontally by a single space character and
vertically with a single line break. All lines following the first
(if any) are indented to the same left column, whose indentation is
specified by the optional <strong>Offset</strong> parameter relative to the position
of the first element in <strong>Docs</strong>. For example, with an offset of -4,  
the following layout can be produced, for a list of documents  
representing the numbers 0 to 15:</p><pre>         0 1 2 3
     4 5 6 7 8 9
     10 11 12 13
     14 15</pre><p>
or with an offset of +2:
</p><pre>     0 1 2 3 4 5 6
       7 8 9 10 11
       12 13 14 15</pre><p>The utility function <a href="#text_par-2">text_par/2</a> can be used to easily
transform a string of text into a <strong>par</strong> representation by splitting  
it into words.</p><p>Note that whenever a document in <strong>Docs</strong> contains a line break, it
will be placed on a separate line. Thus, neither a layout such as
</p><pre>     ab cd
        ef</pre><p>
nor
</p><pre>     ab
     cd ef</pre><p>
will be generated. However, a useful idiom for making the former
variant possible (when wanted) is <strong>beside(par([D1, text("")], N), D2)</strong> for two documents <strong>D1</strong> and <strong>D2</strong>. This will break the line
between <strong>D1</strong> and <strong>D2</strong> if <strong>D1</strong> contains a line break (or if otherwise
necessary), and optionally further indent <strong>D2</strong> by <strong>N</strong> character
positions. The utility function <a href="#follow-3">follow/3</a> creates this context
for two documents <strong>D1</strong> and <strong>D2</strong>, and an optional integer <strong>N</strong>.
</p><p><em>See also:</em> <a href="#par-1">par/1</a>, <a href="#text_par-2">text_par/2</a>.</p><h4>sep(Docs::[]) -&gt;</h4><p>Arranges documents horizontally or vertically, separated by whitespace.</p><a name="sep-1"></a><p>Arranges documents horizontally or vertically, separated by
whitespace. Returns a document representing two alternative layouts
of the (nonempty) sequence <strong>Docs</strong> of documents, such that either all
elements in <strong>Docs</strong> are concatenated horizontally, and separated by a  
space character, or all elements are concatenated vertically (without  
extra separation).</p><p>Note: If some document in <strong>Docs</strong> contains a line break, the vertical  
layout will always be selected.</p><p>Examples:
</p><pre>                                  ab
     ab  cd  ef  =&gt;  ab cd ef  |  cd
                                  ef
 
     ab           ab
     cd  ef  =&gt;   cd
                  ef</pre><p>
</p><p><em>See also:</em> <a href="#par-2">par/2</a>.</p><h4>text(Characters::string()) -&gt;</h4><p>Yields a document representing a fixed, unbreakable sequence of characters.</p><a name="text-1"></a><p>Yields a document representing a fixed, unbreakable sequence of
characters. The string should contain only <em>printable</em>
characters (tabs allowed but not recommended), and <em>not</em>
newline, line feed, vertical tab, etc. A tab character (<strong>\t</strong>) is
interpreted as padding of 1-8 space characters to the next column of
8 characters <em>within the string</em>.
</p><p><em>See also:</em> <a href="#empty-0">empty/0</a>, <a href="#null_text-1">null_text/1</a>, <a href="#text_par-2">text_par/2</a>.</p><h4>text_par(Text::string()) -&gt;</h4><p>Equivalent to text_par(Text, 0). </p><a name="text_par-1"></a><p>Equivalent to <a href="#text_par-2">text_par(Text, 0)</a>.</p><h4>text_par(Text::string(), Indentation::integer()) -&gt;</h4><p>Yields a document representing paragraph-formatted plain text.</p><a name="text_par-2"></a><p>Yields a document representing paragraph-formatted plain text.
The optional <strong>Indentation</strong> parameter specifies the extra indentation
of the first line of the paragraph. For example, <strong>text_par("Lorem ipsum dolor sit amet", N)</strong> could represent
</p><pre>     Lorem ipsum dolor
     sit amet</pre><p>
if <strong>N</strong> = 0, or
</p><pre>       Lorem ipsum
     dolor sit amet</pre><p>
if <strong>N</strong> = 2, or
</p><pre>     Lorem ipsum dolor
       sit amet</pre><p>
if <strong>N</strong> = -2.</p><p>(The sign of the indentation is thus reversed compared to the <a href="#par-2">par/2</a> function, and the behaviour varies slightly depending on the  
sign in order to match the expected layout of a paragraph of text.)</p><p>Note that this is just a utility function, which does all the work of
splitting the given string into words separated by whitespace and
setting up a <a href="#par-2">par</a> with the proper indentation,
containing a list of <a href="#text-1">text</a> elements.
</p><p><em>See also:</em> <a href="#par-2">par/2</a>, <a href="#text-1">text/1</a>, <a href="#text_par-1">text_par/1</a>.</p><h3>Authors</h3><span class="aname">Richard Carlsson</span><span class="email">carlsson.richard@gmail.com</span></body></html>