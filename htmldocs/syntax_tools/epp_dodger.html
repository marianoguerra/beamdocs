<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>epp_dodger</h1><h1>epp_dodger</h1><p>epp_dodger - bypasses the Erlang preprocessor.</p><p><strong>epp_dodger</strong> - bypasses the Erlang preprocessor.This module tokenises and parses most Erlang source code without
expanding preprocessor directives and macro applications, as long as
these are syntactically "well-behaved". Because the normal parse
trees of the <strong>erl_parse</strong> module cannot represent these things
(normally, they are expanded by the Erlang preprocessor <a href="./epp">epp(3)</a> before the parser sees them), an extended syntax tree
is created, using the <a href="erl_syntax">erl_syntax</a> module.</p><h2>DATA TYPES</h2><a name="types"></a><dl><dt><a name="type-errorinfo"></a>errorinfo() = {ErrorLine::integer(), Module::atom(), Descriptor::term()}</dt><dd> <p>This is a so-called Erlang I/O ErrorInfo structure; see the <a href="./io">io(3)</a> module for details.</p> </dd></dl><h1>Functions</h1><h2>parse(Dev::IODevice) -&gt; {ok, Forms} | {error,}</h2><p>Equivalent to parse(IODevice, 1). </p><a name="parse-1"></a><p>Equivalent to <a href="#parse-2">parse(IODevice, 1)</a>.</p><h2>parse(Dev::IODevice, L::StartLine) -&gt; {ok, Forms} | {error,}</h2><p>Equivalent to parse(IODevice, StartLine, []). </p><ul><li><span class="v">IODevice = pid()</span></li><li><span class="v">StartLine = integer()</span></li><li><span class="v">Forms = []</span></li></ul><a name="parse-2"></a><p>Equivalent to <a href="#parse-3">parse(IODevice, StartLine, [])</a>.</p><p><em>See also:</em> <a href="#parse-1">parse/1</a>.</p><h2>parse(Dev::IODevice, L0::StartLine, Options) -&gt; {ok, Forms} | {error,}</h2><p>Reads and parses program text from an I/O stream.</p><ul><li><span class="v">IODevice = pid()</span></li><li><span class="v">StartLine = integer()</span></li><li><span class="v">Options = [term()]</span></li><li><span class="v">Forms = []</span></li></ul><a name="parse-3"></a><p>Reads and parses program text from an I/O stream. Characters are
read from <strong>IODevice</strong> until end-of-file; apart from this, the
behaviour is the same as for <a href="#parse_file-2">parse_file/2</a>. <strong>StartLine</strong> is the
initial line number, which should be a positive integer.
</p><p><em>See also:</em> <a href="#parse-2">parse/2</a>, <a href="#parse_file-2">parse_file/2</a>, <a href="#parse_form-2">parse_form/2</a>, <a href="#quick_parse-3">quick_parse/3</a>.</p><h2>parse_file(File) -&gt; {ok, Forms} | {error,}</h2><p>Equivalent to parse_file(File, []). </p><ul><li><span class="v">File = </span></li><li><span class="v">Forms = []</span></li></ul><a name="parse_file-1"></a><p>Equivalent to <a href="#parse_file-2">parse_file(File, [])</a>.</p><h2>parse_file(File, Options) -&gt; {ok, Forms} | {error,}</h2><p>Reads and parses a file.</p><ul><li><span class="v">File = </span></li><li><span class="v">Options = [term()]</span></li><li><span class="v">Forms = []</span></li></ul><a name="parse_file-2"></a><p>Reads and parses a file. If successful, <strong>{ok, Forms}</strong>
is returned, where <strong>Forms</strong> is a list of abstract syntax
trees representing the "program forms" of the file (cf.
<strong>erl_syntax:is_form/1</strong>). Otherwise, <strong>{error, errorinfo()}</strong> is
returned, typically if the file could not be opened. Note that
parse errors show up as error markers in the returned list of
forms; they do not cause this function to fail or return
<strong>{error, errorinfo()}</strong>.</p><p>Options:
</p><dl><dt><strong>{no_fail, boolean()}</strong></dt><dd><p>If <strong>true</strong>, this makes <strong>epp_dodger</strong> replace any program forms
that could not be parsed with nodes of type <strong>text</strong> (see <a href="./erl_syntax#text-1">erl_syntax:text/1</a>), representing the raw token sequence of the
form, instead of reporting a parse error. The default value is
<strong>false</strong>.</p></dd><dt><strong>{clever, boolean()}</strong></dt><dd><p>If set to <strong>true</strong>, this makes <strong>epp_dodger</strong> try to repair the
source code as it seems fit, in certain cases where parsing would
otherwise fail. Currently, it inserts <strong>++</strong>-operators between string
literals and macros where it looks like concatenation was intended.
The default value is <strong>false</strong>.</p></dd></dl><p>
</p><p><em>See also:</em> <a href="#parse-2">parse/2</a>, <a href="#quick_parse_file-1">quick_parse_file/1</a>, <a href="./erl_syntax#is_form-1">erl_syntax:is_form/1</a>.</p><h2>parse_form(Dev::IODevice, L0::StartLine) -&gt; {ok, Form, LineNo} | {eof, LineNo} | {error,, LineNo}</h2><p>Equivalent to parse_form(IODevice, StartLine, []). </p><ul><li><span class="v">IODevice = pid()</span></li><li><span class="v">StartLine = integer()</span></li><li><span class="v">Form = </span></li><li><span class="v">LineNo = integer()</span></li></ul><a name="parse_form-2"></a><p>Equivalent to <a href="#parse_form-3">parse_form(IODevice, StartLine, [])</a>.</p><p><em>See also:</em> <a href="#quick_parse_form-2">quick_parse_form/2</a>.</p><h2>parse_form(Dev::IODevice, L0::StartLine, Options) -&gt; {ok, Form, LineNo} | {eof, LineNo} | {error,, LineNo}</h2><p>Reads and parses a single program form from an I/O stream.</p><ul><li><span class="v">IODevice = pid()</span></li><li><span class="v">StartLine = integer()</span></li><li><span class="v">Options = [term()]</span></li><li><span class="v">Form = </span></li><li><span class="v">LineNo = integer()</span></li></ul><a name="parse_form-3"></a><p>Reads and parses a single program form from an I/O stream.
Characters are read from <strong>IODevice</strong> until an end-of-form
marker is found (a period character followed by whitespace), or until
end-of-file; apart from this, the behaviour is similar to that of
<strong>parse/3</strong>, except that the return values also contain the
final line number given that <strong>StartLine</strong> is the initial
line number, and that <strong>{eof, LineNo}</strong> may be returned.
</p><p><em>See also:</em> <a href="#parse-3">parse/3</a>, <a href="#parse_form-2">parse_form/2</a>, <a href="#quick_parse_form-3">quick_parse_form/3</a>.</p><h2>quick_parse(Dev::IODevice) -&gt; {ok, Forms} | {error,}</h2><p>Equivalent to quick_parse(IODevice, 1). </p><a name="quick_parse-1"></a><p>Equivalent to <a href="#quick_parse-2">quick_parse(IODevice, 1)</a>.</p><h2>quick_parse(Dev::IODevice, L::StartLine) -&gt; {ok, Forms} | {error,}</h2><p>Equivalent to quick_parse(IODevice, StartLine, []). </p><ul><li><span class="v">IODevice = pid()</span></li><li><span class="v">StartLine = integer()</span></li><li><span class="v">Forms = []</span></li></ul><a name="quick_parse-2"></a><p>Equivalent to <a href="#quick_parse-3">quick_parse(IODevice, StartLine, [])</a>.</p><p><em>See also:</em> <a href="#quick_parse-1">quick_parse/1</a>.</p><h2>quick_parse(Dev::IODevice, L0::StartLine, Options) -&gt; {ok, Forms} | {error,}</h2><p>Similar to parse/3, but does a more quick-and-dirty processing of the code.</p><ul><li><span class="v">IODevice = pid()</span></li><li><span class="v">StartLine = integer()</span></li><li><span class="v">Options = [term()]</span></li><li><span class="v">Forms = []</span></li></ul><a name="quick_parse-3"></a><p>Similar to <a href="#parse-3">parse/3</a>, but does a more quick-and-dirty
processing of the code. See <a href="#quick_parse_file-2">quick_parse_file/2</a> for details.
</p><p><em>See also:</em> <a href="#parse-3">parse/3</a>, <a href="#quick_parse-2">quick_parse/2</a>, <a href="#quick_parse_file-2">quick_parse_file/2</a>, <a href="#quick_parse_form-2">quick_parse_form/2</a>.</p><h2>quick_parse_file(File) -&gt; {ok, Forms} | {error,}</h2><p>Equivalent to quick_parse_file(File, []). </p><ul><li><span class="v">File = </span></li><li><span class="v">Forms = []</span></li></ul><a name="quick_parse_file-1"></a><p>Equivalent to <a href="#quick_parse_file-2">quick_parse_file(File, [])</a>.</p><h2>quick_parse_file(File, Options) -&gt; {ok, Forms} | {error,}</h2><p>Similar to parse_file/2, but does a more quick-and-dirty   processing of the code.</p><ul><li><span class="v">File = </span></li><li><span class="v">Options = [term()]</span></li><li><span class="v">Forms = []</span></li></ul><a name="quick_parse_file-2"></a><p>Similar to <a href="#parse_file-2">parse_file/2</a>, but does a more quick-and-dirty  
processing of the code. Macro definitions and other preprocessor  
directives are discarded, and all macro calls are replaced with  
atoms. This is useful when only the main structure of the code is of  
interest, and not the details. Furthermore, the quick-parse method  
can usually handle more strange cases than the normal, more exact  
parsing.</p><p>Options: see <a href="#parse_file-2">parse_file/2</a>. Note however that for
<strong>quick_parse_file/2</strong>, the option <strong>no_fail</strong> is <strong>true</strong> by default.
</p><p><em>See also:</em> <a href="#parse_file-2">parse_file/2</a>, <a href="#quick_parse-2">quick_parse/2</a>.</p><h2>quick_parse_form(Dev::IODevice, L0::StartLine) -&gt; {ok, Form, LineNo} | {eof, LineNo} | {error,, LineNo}</h2><p>Equivalent to quick_parse_form(IODevice, StartLine, []). </p><ul><li><span class="v">IODevice = pid()</span></li><li><span class="v">StartLine = integer()</span></li><li><span class="v">Form =  | none</span></li><li><span class="v">LineNo = integer()</span></li></ul><a name="quick_parse_form-2"></a><p>Equivalent to <a href="#quick_parse_form-3">quick_parse_form(IODevice, StartLine, [])</a>.</p><p><em>See also:</em> <a href="#parse_form-2">parse_form/2</a>.</p><h2>quick_parse_form(Dev::IODevice, L0::StartLine, Options) -&gt; {ok, Form, LineNo} | {eof, LineNo} | {error,, LineNo}</h2><p>Similar to parse_form/3, but does a more quick-and-dirty processing of the code.</p><ul><li><span class="v">IODevice = pid()</span></li><li><span class="v">StartLine = integer()</span></li><li><span class="v">Options = [term()]</span></li><li><span class="v">Form = </span></li><li><span class="v">LineNo = integer()</span></li></ul><a name="quick_parse_form-3"></a><p>Similar to <a href="#parse_form-3">parse_form/3</a>, but does a more quick-and-dirty
processing of the code. See <a href="#quick_parse_file-2">quick_parse_file/2</a> for details.
</p><p><em>See also:</em> <a href="#parse-3">parse/3</a>, <a href="#parse_form-3">parse_form/3</a>, <a href="#quick_parse_form-2">quick_parse_form/2</a>.</p><h2>tokens_to_string(Tokens::[term()]) -&gt; string()</h2><p>Generates a string corresponding to the given token sequence.</p><a name="tokens_to_string-1"></a><p>Generates a string corresponding to the given token sequence.
The string can be re-tokenized to yield the same token list again.</p><h1>Authors</h1><span class="aname">Richard Carlsson</span><span class="email">carlsson.richard@gmail.com</span></body></html>