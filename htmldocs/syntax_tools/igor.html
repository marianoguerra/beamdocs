<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>igor</h1><h1>igor</h1><p>Igor: the Module Merger and Renamer.</p><p>Igor: the Module Merger and Renamer.The program Igor merges the source code of one or more Erlang  
modules into a single module, which can then replace the original set  
of modules. Igor is also able to rename a set of (possibly  
interdependent) modules, without joining them into a single  
module.The main user interface consists of the functions <a href="#merge-3">merge/3</a> and
<a href="#rename-3">rename/3</a>. See also the function <a href="#parse_transform-2">parse_transform/2</a>.A note of warning: Igor cannot do anything about the case when the
name of a remote function is passed to the built-in functions
<strong>apply</strong> and <strong>spawn</strong> <em>unless</em> the module
and function names are explicitly stated in the call, as in e.g.
<strong>apply(lists, reverse, [Xs])</strong>. In all other cases, Igor  
leaves such calls unchanged, and warns the user that manual editing  
might be necessary.Also note that Erlang records will be renamed as necessary to
avoid non-equivalent definitions using the same record name. This
does not work if the source code accesses the name field of such
record tuples by <strong>element/2</strong> or similar methods. Always  
use the record syntax to handle record tuples, if possible.Disclaimer: the author of this program takes no responsibility for  
the correctness of the produced output, or for any effects of its  
execution. In particular, the author may not be held responsible  
should Igor include the code of a deceased madman in the result.For further information on Igors in general, see e.g. "Young
Frankenstein", Mel Brooks, 1974, and "The Fifth Elephant", Terry
Pratchett, 1999.</p><h2>DATA TYPES</h2><a name="types"></a><dl><dt><a name="type-filename"></a>filename() = <a href="./file#type-filename">file:filename()</a></dt><dd> </dd><dt><a name="type-stubDescriptor"></a>stubDescriptor() = {ModuleName, Functions, [Attribute]}</dt><dd> <ul><li><p>ModuleName = atom()</p></li><li><p>Functions = [{FunctionName, {ModuleName, FunctionName}}]</p></li><li><p>FunctionName = {atom(), integer()}</p></li><li><p>Attribute = {atom(), term()}</p></li></ul> <p>A stub module descriptor contains the module name, a list of
exported functions, and a list of module attributes. Each
function is described by its name (which includes its arity),
and the corresponding module and function that it calls. (The
arities should always match.) The attributes are simply
described by key-value pairs.
</p> </dd><dt><a name="type-syntaxTree"></a>syntaxTree() = <a href="./erl_syntax#type-syntaxTree">erl_syntax:syntaxTree()</a></dt><dd> <p>An abstract syntax
tree. See the <a href="erl_syntax">erl_syntax</a> module for details.
</p> </dd></dl><h1>Functions</h1><h2>create_stubs(Stubs::[], Options::[term()]) -&gt; [string()]</h2><p>Creates stub module source files corresponding to the given stub descriptors.</p><a name="create_stubs-2"></a><p>Creates stub module source files corresponding to the given stub
descriptors. The returned value is the list of names of the created
files. See <strong>merge_sources/3</strong> for more information about  
stub descriptors.</p><p>Options:
</p><dl><dt><strong>{backup_suffix, string()}</strong></dt><dd></dd><dt><strong>{backups, boolean()}</strong></dt><dd></dd><dt><strong>{printer, Function}</strong></dt><dd></dd><dt><strong>{stub_dir, filename()}</strong></dt><dd></dd><dt><strong>{suffix, string()}</strong></dt><dd></dd><dt><strong>{verbose, boolean()}</strong></dt><dd></dd></dl><p>See <strong>merge/3</strong> for details on these options.
</p><p><em>See also:</em> <a href="#merge-3">merge/3</a>, <a href="#merge_sources-3">merge_sources/3</a>.</p><h2>merge(Name::atom(), Files::[]) -&gt; []</h2><p>Equivalent to merge(Name, Files, []). </p><a name="merge-2"></a><p>Equivalent to <a href="#merge-3">merge(Name, Files, [])</a>.</p><h2>merge(Name::atom(), Files::[], Options::[term()]) -&gt; []</h2><p>Merges source code files to a single file.</p><a name="merge-3"></a><p>Merges source code files to a single file. <strong>Name</strong>
specifies the name of the resulting module - not the name of the
output file. <strong>Files</strong> is a list of file names and/or module
names of source modules to be read and merged (see
<strong>merge_files/4</strong> for details). All the input modules must  
be distinctly named.</p><p>The resulting source code is written to a file named
"<strong>&lt;em&gt;Name&lt;/em&gt;.erl</strong>" in the current directory, unless
otherwise specified by the options <strong>dir</strong> and
<strong>outfile</strong> described below.</p><p>Examples:
</p><ul><li><p>given a module <strong>m</strong> in file "<strong>m.erl</strong>"
which uses the standard library module <strong>lists</strong>, calling
<strong>igor:merge(m, [m, lists])</strong> will create a new file
"<strong>m.erl</strong> which contains the code from <strong>m</strong> and
exports the same functions, and which includes the referenced code
from the <strong>lists</strong> module. The original file will be
renamed to "<strong>m.erl.bak</strong>".</p></li><li><p>given modules <strong>m1</strong> and <strong>m2</strong>, in
corresponding files, calling <strong>igor:merge(m, [m1, m2])</strong>
will create a file "<strong>m.erl</strong>" which contains the code
from <strong>m1</strong> and <strong>m2</strong> and exports the functions
of <strong>m1</strong>.</p></li></ul><p>Stub module files are created for those modules that are to be
exported by the target module (see options <strong>export</strong>,
<strong>stubs</strong> and <strong>stub_dir</strong>).</p><p>The function returns the list of file names of all created  
modules, including any automatically created stub modules. The file  
name of the target module is always first in the list.</p><p>Note: If you get a "syntax error" message when trying to merge
files (and you know those files to be correct), then try the
<strong>preprocess</strong> option. It typically means that your code  
contains too strange macros to be handled without actually performing  
the preprocessor expansions.</p><p>Options:
</p><dl><dt><strong>{backup_suffix, string()}</strong></dt><dd><p>Specifies the file name suffix to be used when a backup file
is created; the default value is <strong>".bak"</strong>.</p></dd><dt><strong>{backups, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, existing files will be
renamed before new files are opened for writing. The new names
are formed by appending the string given by the
<strong>backup_suffix</strong> option to the original name. The
default value is <strong>true</strong>.</p></dd><dt><strong>{dir, filename()}</strong></dt><dd><p>Specifies the name of the directory in which the output file
is to be written. An empty string is interpreted as the current
directory. By default, the current directory is used.</p></dd><dt><strong>{outfile, filename()}</strong></dt><dd><p>Specifies the name of the file (without suffix) to which the
resulting source code is to be written. By default, this is the
same as the <strong>Name</strong> argument.</p></dd><dt><strong>{preprocess, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, preprocessing will be done
when reading the source code. See <strong>merge_files/4</strong> for
details.</p></dd><dt><strong>{printer, Function}</strong></dt><dd><ul><li><p><strong>Function = (syntaxTree()) -&gt; string()</strong></p></li></ul><p>
Specifies a function for prettyprinting Erlang syntax trees.
This is used for outputting the resulting module definition, as
well as for creating stub files. The function is assumed to
return formatted text for the given syntax tree, and should raise
an exception if an error occurs. The default formatting function
calls <strong>erl_prettypr:format/2</strong>.</p></dd><dt><strong>{stub_dir, filename()}</strong></dt><dd><p>Specifies the name of the directory to which any generated
stub module files are written. The default value is
<strong>"stubs"</strong>.</p></dd><dt><strong>{stubs, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, stub module files will be
automatically generated for all exported modules that do not have
the same name as the target module. The default value is
<strong>true</strong>.</p></dd><dt><strong>{suffix, string()}</strong></dt><dd><p>Specifies the suffix to be used for the output file names;
the default value is <strong>".erl"</strong>.</p></dd></dl><p>See <strong>merge_files/4</strong> for further options.
</p><p><em>See also:</em> <a href="#merge-2">merge/2</a>, <a href="#merge_files-4">merge_files/4</a>.</p><h2>merge_files(Name::atom(), Files::[], Options::[term()]) -&gt; {, []}</h2><p>Equivalent to merge_files(Name, [], Files, Options). </p><a name="merge_files-3"></a><p>Equivalent to <a href="#merge_files-4">merge_files(Name, [], Files, Options)</a>.</p><h2>merge_files(Name::atom(), Sources::[Forms], Files::[], Options::[term()]) -&gt; {, []}</h2><p>Merges source code files and syntax trees to a single syntax tree.</p><ul><li><span class="v">Forms =  | []</span></li></ul><a name="merge_files-4"></a><p>Merges source code files and syntax trees to a single syntax
tree. This is a file-reading front end to
<strong>merge_sources/3</strong>. <strong>Name</strong> specifies the name of
the resulting module - not the name of the output file.
<strong>Sources</strong> is a list of syntax trees and/or lists of
"source code form" syntax trees, each entry representing a module
definition. <strong>Files</strong> is a list of file names and/or module  
names of source modules to be read and included. All the input  
modules must be distinctly named.</p><p>If a name in <strong>Files</strong> is not the name of an existing
file, Igor assumes it represents a module name, and tries to locate
and read the corresponding source file. The parsed files are appended
to <strong>Sources</strong> and passed on to
<strong>merge_sources/3</strong>, i.e., entries in <strong>Sources</strong>  
are listed before entries read from files.</p><p>If no exports are listed by an <strong>export</strong> option (see
<strong>merge_sources/3</strong> for details), then if <strong>Name</strong>
is also the name of one of the input modules, that module will be
exported; otherwise, the first listed module will be exported. Cf.
the examples under <strong>merge/3</strong>.</p><p>The result is a pair <strong>{Tree, Stubs}</strong>, where
<strong>Tree</strong> represents the source code that is the result of
merging all the code in <strong>Sources</strong> and <strong>Files</strong>,
and <strong>Stubs</strong> is a list of stub module descriptors (see
<strong>merge_sources/3</strong> for details).</p><p>Options:
</p><dl><dt><strong>{comments, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, source code comments in
the original files will be preserved in the output. The default
value is <strong>true</strong>.</p></dd><dt><strong>{find_src_rules, [{string(), string()}]}</strong></dt><dd><p>Specifies a list of rules for associating object files with
source files, to be passed to the function
<strong>filelib:find_source/2</strong>. This can be used to change the
way Igor looks for source files. If this option is not specified,
the default system rules are used. The first occurrence of this
option completely overrides any later in the option list.</p></dd><dt><strong>{includes, [filename()]}</strong></dt><dd><p>Specifies a list of directory names for the Erlang
preprocessor, if used, to search for include files (cf. the
<strong>preprocess</strong> option). The default value is the empty
list. The directory of the source file and the current directory
are automatically appended to the list.</p></dd><dt><strong>{macros, [{atom(), term()}]}</strong></dt><dd><p>Specifies a list of "pre-defined" macro definitions for the
Erlang preprocessor, if used (cf. the <strong>preprocess</strong>
option). The default value is the empty list.</p></dd><dt><strong>{preprocess, boolean()}</strong></dt><dd><p>If the value is <strong>false</strong>, Igor will read source
files without passing them through the Erlang preprocessor
(<strong>epp</strong>), in order to avoid expansion of preprocessor
directives such as <strong>-include(...).</strong>,
<strong>-define(...).</strong> and <strong>-ifdef(...)</strong>, and
macro calls such as <strong>?LINE</strong> and <strong>?MY_MACRO(x, y)</strong>. The default value is <strong>false</strong>, i.e.,
preprocessing is not done. (See the module
<strong>epp_dodger</strong> for details.)</p> <p>Notes: If a file contains too exotic definitions or uses of
macros, it will not be possible to read it without preprocessing.
Furthermore, Igor does not currently try to sort out multiple
inclusions of the same file, or redefinitions of the same macro
name. Therefore, when preprocessing is turned off, it may become
necessary to edit the resulting source code, removing such
re-inclusions and redefinitions.</p></dd></dl><p>See <strong>merge_sources/3</strong> for further options.
</p><p><em>See also:</em> <a href="epp_dodger">epp_dodger</a>, <a href="../stdlib/filelib#find_source/2">filelib:find_source/2</a>, <a href="#merge-3">merge/3</a>, <a href="#merge_files-3">merge_files/3</a>, <a href="#merge_sources-3">merge_sources/3</a>.</p><h2>merge_sources(Name::atom(), Sources::[Forms], Options::[term()]) -&gt; {, []}</h2><p>Merges syntax trees to a single syntax tree.</p><ul><li><span class="v">Forms =  | []</span></li></ul><a name="merge_sources-3"></a><p>Merges syntax trees to a single syntax tree. This is the main
code merging "engine". <strong>Name</strong> specifies the name of the
resulting module. <strong>Sources</strong> is a list of syntax trees of
type <strong>form_list</strong> and/or lists of "source code form" syntax  
trees, each entry representing a module definition. All the input  
modules must be distinctly named.</p><p>Unless otherwise specified by the options, all modules are assumed
to be at least "static", and all except the target module are assumed
to be "safe". See the <strong>static</strong> and <strong>safe</strong>  
options for details.</p><p>If <strong>Name</strong> is also the name of one of the input modules,  
the code from that module will occur at the top of the resulting  
code, and no extra "header" comments will be added. In other words,  
the look of that module will be preserved.</p><p>The result is a pair <strong>{Tree, Stubs}</strong>, where
<strong>Tree</strong> represents the source code that is the result of
merging all the code in <strong>Sources</strong>, and <strong>Stubs</strong>  
is a list of stub module descriptors (see below).</p><p><strong>Stubs</strong> contains one entry for each exported input
module (cf. the <strong>export</strong> option), each entry describing a
stub module that redirects calls of functions in the original module
to the corresponding (possibly renamed) functions in the new module.
The stub descriptors can be used to automatically generate stub
modules; see <strong>create_stubs/2</strong>.</p><p>Options:
</p><dl><dt><strong>{export, [atom()]}</strong></dt><dd><p>Specifies a list of names of input modules whose interfaces
should be exported by the output module. A stub descriptor is
generated for each specified module, unless its name is
<strong>Name</strong>. If no modules are specified, then if
<strong>Name</strong> is also the name of an input module, that
module will be exported; otherwise the first listed module in
<strong>Sources</strong> will be exported. The default value is the
empty list.</p></dd><dt><strong>{export_all, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, this is equivalent to
listing all of the input modules in the <strong>export</strong>
option. The default value is <strong>false</strong>.</p></dd><dt><strong>{file_attributes, Preserve}</strong></dt><dd><ul><li><p><strong>Preserve = yes | comment | no</strong></p></li></ul><p>
If the value is <strong>yes</strong>, all file attributes
<strong>-file(...)</strong> in the input sources will be preserved in
the resulting code. If the value is <strong>comment</strong>, they
will be turned into comments, but remain in their original
positions in the code relative to the other source code forms. If
the value is <strong>no</strong>, all file attributes will be removed
from the code, unless they have attached comments, in which case
they will be handled as in the <strong>comment</strong> case. The
default value is <strong>no</strong>.</p></dd><dt><strong>{no_banner, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, no banner comment will be
added at the top of the resulting module, even if the target
module does not have the same name as any of the input modules.
Instead, Igor will try to preserve the look of the module whose
code is at the top of the output. The default value is
<strong>false</strong>.</p></dd><dt><strong>{no_headers, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, no header comments will be
added to the resulting module at the beginning of each section of
code that originates from a particular input module. The default
value is <strong>false</strong>, which means that section headers are
normally added whenever more than two or more modules are
merged.</p></dd><dt><strong>{no_imports, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, all
<strong>-import(...)</strong> declarations in the original code will
be expanded in the result; otherwise, as much as possible of the
original import declarations will be preserved. The default value
is <strong>false</strong>.</p></dd><dt><strong>{notes, Notes}</strong></dt><dd><ul><li><p><strong>Notes = always | yes | no</strong></p></li></ul><p>
If the value is <strong>yes</strong>, comments will be inserted where
important changes have been made in the code. If the value is
<strong>always</strong>, <em>all</em> changes to the code will be
commented. If the value is <strong>no</strong>, changes will be made
without comments. The default value is <strong>yes</strong>.</p></dd><dt><strong>{redirect, [{atom(), atom()}]}</strong></dt><dd><p>Specifies a list of pairs of module names, representing a
mapping from old names to new. <em>The set of old names may not include any of the names of the input modules.</em> All calls to
the listed old modules will be rewritten to refer to the
corresponding new modules. <em>The redirected calls will not be further processed, even if the new destination is in one of the input modules.</em> This option mainly exists to support module
renaming; cf. <strong>rename/3</strong>. The default value is the
empty list.</p></dd><dt><strong>{safe, [atom()]}</strong></dt><dd><p>Specifies a list of names of input modules such that calls to
these "safe" modules may be turned into direct local calls, that
do not test for code replacement. Typically, this can be done for
e.g. standard library modules. If a module is "safe", it is per
definition also "static" (cf. below). The list may be empty. By
default, all involved modules <em>except the target module</em>
are considered "safe".</p></dd><dt><strong>{static, [atom()]}</strong></dt><dd><p>Specifies a list of names of input modules which will be
assumed never to be replaced (reloaded) unless the target module
is also first replaced. The list may be empty. The target module
itself (which may also be one of the input modules) is always
regarded as "static", regardless of the value of this option. By
default, all involved modules are assumed to be static.</p></dd><dt><strong>{tidy, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, the resulting code will be
processed using the <strong>erl_tidy</strong> module, which removes
unused functions and does general code cleanup. (See
<strong>erl_tidy:module/2</strong> for additional options.) The
default value is <strong>true</strong>.</p></dd><dt><strong>{verbose, boolean()}</strong></dt><dd><p>If the value is <strong>true</strong>, progress messages will be
output while the program is running; the default value is
<strong>false</strong>.</p></dd></dl><p>Note: The distinction between "static" and "safe" modules is
necessary in order not to break the semantics of dynamic code
replacement. A "static" source module will not be replaced unless the
target module also is. Now imagine a state machine implemented by
placing the code for each state in a separate module, and suppose
that we want to merge this into a single target module, marking all
source modules as static. At each point in the original code where a
call is made from one of the modules to another (i.e., the state
transitions), code replacement is expected to be detected. Then, if
we in the merged code do not check at these points if the
<em>target</em> module (the result of the merge) has been replaced,  
we cannot be sure in general that we will be able to do code  
replacement of the merged state machine - it could run forever  
without detecting the code change. Therefore, all such calls must  
remain remote-calls (detecting code changes), but may call the target  
module directly.</p><p>If we are sure that this kind of situation cannot ensue, we may
specify the involved modules as "safe", and all calls between them
will become local. Note that if the target module itself is specified
as safe, "remote" calls to itself will be turned into local calls.
This would destroy the code replacement properties of e.g. a typical
server loop.
</p><p><em>See also:</em> <a href="#create_stubs-2">create_stubs/2</a>, <a href="#rename-3">rename/3</a>, <a href="./erl_tidy#module-2">erl_tidy:module/2</a>.</p><h2>parse_transform(Forms::[], Options::[term()]) -&gt; []</h2><p>Allows Igor to work as a component of the Erlang compiler.</p><a name="parse_transform-2"></a><p>Allows Igor to work as a component of the Erlang compiler.
Including the term <strong>{parse_transform, igor}</strong> in the
compile options when compiling an Erlang module (cf.
<strong>compile:file/2</strong>), will call upon Igor to process the  
source code, allowing automatic inclusion of other source files. No  
files are created or overwritten when this function is used.</p><p>Igor will look for terms <strong>{igor, List}</strong> in the compile
options, where <strong>List</strong> is a list of Igor-specific options,
as follows:
</p><dl><dt><strong>{files, [filename()]}</strong></dt><dd><p>The value specifies a list of source files to be merged with
the file being compiled; cf. <strong>merge_files/4</strong>.</p></dd></dl><p>See <strong>merge_files/4</strong> for further options. Note, however,
that some options are preset by this function and cannot be
overridden by the user; in particular, all cosmetic features are
turned off, for efficiency. Preprocessing is turned on.
</p><p><em>See also:</em> <a href="../compiler/compile#file/2">compile:file/2</a>, <a href="#merge_files-4">merge_files/4</a>.</p><h2>rename(Files::[], Renamings) -&gt; [string()]</h2><p>Equivalent to rename(Files, Renamings, []). </p><a name="rename-2"></a><p>Equivalent to <a href="#rename-3">rename(Files, Renamings, [])</a>.</p><h2>rename(Files::[], Renamings, Options::[term()]) -&gt; [string()]</h2><p>Renames a set of possibly interdependent source code modules.</p><ul><li><span class="v">Renamings = [{atom(), atom()}]</span></li></ul><a name="rename-3"></a><p>Renames a set of possibly interdependent source code modules.
<strong>Files</strong> is a list of file names of source modules to be
processed. <strong>Renamings</strong> is a list of pairs of <em>module names</em>, representing a mapping from old names to new. The  
returned value is the list of output file names.</p><p>Each file in the list will be read and processed separately. For
every file, each reference to some module M, such that there is an
entry <strong>{&lt;em&gt;M&lt;/em&gt;, &lt;em&gt;M1&lt;/em&gt;}</strong> in
<strong>Renamings</strong>, will be changed to the corresponding M1.
Furthermore, if a file F defines module M, and there is an entry
<strong>{&lt;em&gt;M&lt;/em&gt;, &lt;em&gt;M1&lt;/em&gt;}</strong> in <strong>Renamings</strong>, a
new file named <strong>&lt;em&gt;M1&lt;/em&gt;.erl</strong> will be created in the
same directory as F, containing the source code for module M, renamed
to M1. If M does not have an entry in <strong>Renamings</strong>, the
module is not renamed, only updated, and the resulting source code is
written to <strong>&lt;em&gt;M&lt;/em&gt;.erl</strong> (typically, this overwrites
the original file). The <strong>suffix</strong> option (see below) can be
used to change the default "<strong>.erl</strong>" suffix for the  
generated files.</p><p>Stub modules will automatically be created (see the
<strong>stubs</strong> and <strong>stub_dir</strong> options below) for each  
module that is renamed. These can be used to redirect any calls still  
using the old module names. The stub files are created in the same  
directory as the source file (typically overwriting the original  
file).</p><p>Options:
</p><dl><dt><strong>{backup_suffix, string()}</strong></dt><dd></dd><dt><strong>{backups, boolean()}</strong></dt><dd></dd><dt><strong>{printer, Function}</strong></dt><dd></dd><dt><strong>{stubs, boolean()}</strong></dt><dd></dd><dt><strong>{suffix, string()}</strong></dt><dd></dd></dl><p>
See <strong>merge/3</strong> for details on these options.</p><dl><dt><strong>{comments, boolean()}</strong></dt><dd></dd><dt><strong>{preprocess, boolean()}</strong></dt><dd></dd></dl><p>
See <strong>merge_files/4</strong> for details on these options.</p><dl><dt><strong>{no_banner, boolean()}</strong></dt><dd></dd></dl><p>
For the <strong>rename</strong> function, this option is
<strong>true</strong> by default. See <strong>merge_sources/3</strong> for  
details.</p><dl><dt><strong>{tidy, boolean()}</strong></dt><dd></dd></dl><p>
For the <strong>rename</strong> function, this option is
<strong>false</strong> by default. See <strong>merge_sources/3</strong> for  
details.</p><dl><dt><strong>{no_headers, boolean()}</strong></dt><dd></dd><dt><strong>{stub_dir, filename()}</strong></dt><dd></dd></dl><p>
These options are preset by the <strong>rename</strong> function and  
cannot be overridden by the user.</p><p>See <strong>merge_sources/3</strong> for further options.
</p><p><em>See also:</em> <a href="#merge-3">merge/3</a>, <a href="#merge_files-4">merge_files/4</a>, <a href="#merge_sources-3">merge_sources/3</a>.</p><h1>Authors</h1><span class="aname">Richard Carlsson</span><span class="email">carlsson.richard@gmail.com</span></body></html>