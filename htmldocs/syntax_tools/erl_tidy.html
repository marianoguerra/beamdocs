<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>erl_tidy</h1><h1>erl_tidy</h1><p>Tidies and pretty-prints Erlang source code, removing unused  
functions, updating obsolete constructs and function calls, etc.</p><p>Tidies and pretty-prints Erlang source code, removing unused  
functions, updating obsolete constructs and function calls, etc.Caveats: It is possible that in some intricate uses of macros,  
the automatic addition or removal of parentheses around uses or  
arguments could cause the resulting program to be rejected by the  
compiler; however, we have found no such case in existing  
code. Programs defining strange macros can usually not be read by  
this program, and in those cases, no changes will be made.If you really, really want to, you may call it "Inga".Disclaimer: The author accepts no responsibility for errors
introduced in code that has been processed by the program. It has
been reasonably well tested, but the possibility of errors remains.
Keep backups of your original code safely stored, until you feel
confident that the new, modified code can be trusted.
</p><h2>DATA TYPES</h2><a name="types"></a><dl><dt><a name="type-filename"></a>filename() = <a href="./file#type-filename">file:filename()</a></dt><dd> </dd><dt><a name="type-syntaxTree"></a>syntaxTree() = <a href="./erl_syntax#type-syntaxTree">erl_syntax:syntaxTree()</a></dt><dd> <p>An abstract syntax
tree. See the <a href="erl_syntax">erl_syntax</a> module for details.
</p> </dd></dl><h1>Functions</h1><h2>dir() -&gt; ok</h2><p>Equivalent to dir(""). </p><a name="dir-0"></a><p>Equivalent to <a href="#dir-1">dir("")</a>.</p><h2>dir(Dir) -&gt; ok</h2><p>Equivalent to dir(Dir, []). </p><a name="dir-1"></a><p>Equivalent to <a href="#dir-2">dir(Dir, [])</a>.</p><h2>dir(Directory::, Options::[term()]) -&gt; ok</h2><p>Tidies Erlang source files in a directory and its   subdirectories.</p><a name="dir-2"></a><p>Tidies Erlang source files in a directory and its  
subdirectories.</p><p>Available options:
</p><dl><dt>{follow_links, boolean()}</dt><dd><p>If the value is <strong>true</strong>, symbolic directory
links will be followed.  The default value is
<strong>false</strong>.</p></dd><dt>{recursive, boolean()}</dt><dd><p>If the value is <strong>true</strong>, subdirectories will be
visited recursively.  The default value is
<strong>true</strong>.</p></dd><dt>{regexp, string()}</dt><dd><p>The value denotes a regular expression (see module
<strong>re</strong>).  Tidying will only be applied to those
regular files whose names match this pattern. The default
value is <strong>".*\\.erl$"</strong>, which matches normal
Erlang source file names.</p></dd><dt>{test, boolean()}</dt><dd><p>If the value is <strong>true</strong>, no files will be
modified. The default value is <strong>false</strong>.</p></dd><dt>{verbose, boolean()}</dt><dd><p>If the value is <strong>true</strong>, progress messages will
be output while the program is running, unless the
<strong>quiet</strong> option is <strong>true</strong>. The default
value when calling <a href="#dir-2">dir/2</a> is <strong>true</strong>.</p></dd></dl><p>See the function <a href="#file-2">file/2</a> for further options.
</p><p><em>See also:</em> <a href="./re">re(3)</a>, <a href="#file-2">file/2</a>.</p><h2>file(Name) -&gt; ok</h2><p>Equivalent to file(Name, []). </p><a name="file-1"></a><p>Equivalent to <a href="#file-2">file(Name, [])</a>.</p><h2>file(Name::, Options::[term()]) -&gt; ok</h2><p>Tidies an Erlang source code file.</p><a name="file-2"></a><p>Tidies an Erlang source code file.</p><p>Available options are:
</p><dl><dt>{backup_suffix, string()}</dt><dd><p>Specifies the file name suffix to be used when a backup
file is created; the default value is <strong>".bak"</strong>
(cf. the <strong>backups</strong> option).</p></dd><dt>{backups, boolean()}</dt><dd><p>If the value is <strong>true</strong>, existing files will be
renamed before new files are opened for writing. The new
names are formed by appending the string given by the
<strong>backup_suffix</strong> option to the original name. The
default value is <strong>true</strong>.</p></dd><dt>{dir, filename()}</dt><dd><p>Specifies the name of the directory in which the output
file is to be written. By default, the current directory is
used. If the value is an empty string, the current directory
is used. </p></dd><dt>{outfile, filename()}</dt><dd><p>Specifies the name of the file (without suffix) to which
the resulting source code is to be written. If this option is
not specified, the <strong>Name</strong> argument is used.</p></dd><dt>{printer, Function}</dt><dd><ul><li><p><strong>Function = (syntaxTree(), [term()]) -&gt; string()</strong></p></li></ul><p>
Specifies a function for prettyprinting Erlang syntax trees.
This is used for outputting the resulting module definition.
The function is assumed to return formatted text for the given
syntax tree, and should raise an exception if an error occurs.
The default formatting function calls
<strong>erl_prettypr:format/2</strong>.</p></dd><dt>{test, boolean()}</dt><dd><p>If the value is <strong>true</strong>, no files will be modified; this
is typically most useful if the <strong>verbose</strong> flag is enabled, to
generate reports about the program files without affecting
them. The default value is <strong>false</strong>.</p></dd><dt>{stdout, boolean()}</dt><dd><p>If the value is <strong>true</strong>, instead of the file being written
to disk it will be printed to stdout. The default value is
<strong>false</strong>.</p></dd></dl><p>See the function <strong>module/2</strong> for further options.
</p><p><em>See also:</em> <a href="#module-2">module/2</a>, <a href="./erl_prettypr#format-2">erl_prettypr:format/2</a>.</p><h2>module(Forms) -&gt;</h2><p>Equivalent to module(Forms, []). </p><a name="module-1"></a><p>Equivalent to <a href="#module-2">module(Forms, [])</a>.</p><h2>module(Forms, Options::[term()]) -&gt;</h2><p>Tidies a syntax tree representation of a module definition.</p><ul><li><span class="v">Forms =  | []</span></li></ul><a name="module-2"></a><p>Tidies a syntax tree representation of a module
definition. The given <strong>Forms</strong> may be either a single
syntax tree of type <strong>form_list</strong>, or a list of syntax
trees representing "program forms". In either case,
<strong>Forms</strong> must represent a single complete module
definition. The returned syntax tree has type
<strong>form_list</strong> and represents a tidied-up version of the  
same source code.</p><p>Available options are:
</p><dl><dt>{auto_export_vars, boolean()}</dt><dd><p>If the value is <strong>true</strong>, all matches
"<strong>{V1, ..., Vn} = E</strong>" where <strong>E</strong> is a
case-, if- or receive-expression whose branches all return
n-tuples (or explicitly throw exceptions) will be rewritten
to bind and export the variables <strong>V1</strong>, ...,
<strong>Vn</strong> directly. The default value is <strong>false</strong>.</p> <p>For example:
</p><pre>
                 {X, Y} = case ... of
                              ... -&gt; {17, foo()};
                              ... -&gt; {42, bar()}
                          end
        </pre><p>
will be rewritten to:
</p><pre>
                 case ... of
                     ... -&gt; X = 17, Y = foo(), {X, Y};
                     ... -&gt; X = 42, Y = bar(), {X, Y}
                 end
        </pre></dd><dt>{auto_list_comp, boolean()}</dt><dd><p>If the value is <strong>true</strong>, calls to <strong>lists:map/2</strong> and
<strong>lists:filter/2</strong> will be rewritten using list comprehensions.
The default value is <strong>true</strong>.</p></dd><dt>{file, string()}</dt><dd><p>Specifies the name of the file from which the source code
was taken. This is only used for generation of error
reports. The default value is the empty string.</p></dd><dt>{idem, boolean()}</dt><dd><p>If the value is <strong>true</strong>, all options that affect how the
code is modified are set to "no changes". For example, to
only update guard tests, and nothing else, use the options
<strong>[new_guard_tests, idem]</strong>. (Recall that options closer to the
beginning of the list have higher precedence.)</p></dd><dt>{keep_unused, boolean()}</dt><dd><p>If the value is <strong>true</strong>, unused functions will
not be removed from the code. The default value is
<strong>false</strong>.</p></dd><dt>{new_guard_tests, boolean()}</dt><dd><p>If the value is <strong>true</strong>, guard tests will be updated to
use the new names, e.g. "<strong>is_integer(X)</strong>" instead of
"<strong>integer(X)</strong>". The default value is <strong>true</strong>. See also
<strong>old_guard_tests</strong>.</p></dd><dt>{no_imports, boolean()}</dt><dd><p>If the value is <strong>true</strong>, all import statements will be
removed and calls to imported functions will be expanded to
explicit remote calls. The default value is <strong>false</strong>.</p></dd><dt>{old_guard_tests, boolean()}</dt><dd><p>If the value is <strong>true</strong>, guard tests will be changed to
use the old names instead of the new ones, e.g.
"<strong>integer(X)</strong>" instead of "<strong>is_integer(X)</strong>". The default
value is <strong>false</strong>. This option overrides the <strong>new_guard_tests</strong>
option.</p></dd><dt>{quiet, boolean()}</dt><dd><p>If the value is <strong>true</strong>, all information
messages and warning messages will be suppressed. The default
value is <strong>false</strong>.</p></dd><dt>{rename, [{{atom(), atom(), integer()}, {atom(), atom()}}]}</dt><dd><p>The value is a list of pairs, associating tuples
<strong>{Module, Name, Arity}</strong> with tuples <strong>{NewModule, NewName}</strong>,        
specifying renamings of calls to remote functions. By        
default, the value is the empty list.</p> <p>The renaming affects only remote calls (also when
disguised by import declarations); local calls within a
module are not affected, and no function definitions are
renamed. Since the arity cannot change, the new name is
represented by <strong>{NewModule, NewName}</strong> only. Only        
calls matching the specified arity will match; multiple        
entries are necessary for renaming calls to functions that        
have the same module and function name, but different        
arities.</p> <p>This option can also be used to override the default
renaming of calls which use obsolete function names.</p></dd><dt>{verbose, boolean()}</dt><dd><p>If the value is <strong>true</strong>, progress messages will be output
while the program is running, unless the <strong>quiet</strong> option is
<strong>true</strong>. The default value is <strong>false</strong>.</p></dd></dl><h1>Authors</h1><span class="aname">Richard Carlsson</span><span class="email">carlsson.richard@gmail.com</span></body></html>