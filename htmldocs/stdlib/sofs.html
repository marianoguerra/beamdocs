<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>sofs</h1><h1>sofs</h1><p>Functions for manipulating sets of sets.</p><p>This module provides operations on finite sets and
relations represented as sets. Intuitively, a set is a
collection of elements; every element belongs to the set, and
the set contains every element.Given a set A and a sentence S(x), where x is a free variable,
a new set B whose elements are exactly those elements of A for
which S(x) holds can be formed, this is denoted BÂ =
{xÂ inÂ AÂ : S(x)}. Sentences are expressed using
the logical operators "for some" (or "there exists"), "for all",
"and", "or", "not". If the existence of a set containing all the
specified elements is known (as is always the case in this
module), this is denoted BÂ = {xÂ : S(x)}.<ul><li> <p>The <em>unordered set</em> containing the elements a, b, and c is
denoted {a,Â b,Â c}. This notation is not to be confused with
tuples.</p> <p>The <em>ordered pair</em> of a and b, with first <em>coordinate</em>
a and second coordinate b, is denoted (a,Â b). An ordered pair
is an <em>ordered set</em> of two elements. In this module, ordered
sets can contain one, two, or more elements, and parentheses are
used to enclose the elements.</p> <p>Unordered sets and ordered sets are orthogonal, again in this
module; there is no unordered set equal to any ordered set.</p> </li><li> <p>The <em>empty set</em> contains no elements.</p> <p>Set A is <a name="equal"></a><em>equal</em> to set B if they
contain the same elements, which is denoted AÂ =Â B. Two
ordered sets are equal if they contain the same number of elements
and have equal elements at each coordinate.</p> <p>Set B is a <a name="subset"></a><em>subset</em> of set A
if A contains all elements that B contains.</p> <p>The <a name="union"></a><em>union</em> of two sets A and B
is the smallest set that contains all elements of A and all elements
of B.</p> <p>The <a name="intersection"></a><em>intersection</em> of two
sets A and B is the set that contains all elements of A that belong
to B.</p> <p>Two sets are <a name="disjoint"></a><em>disjoint</em> if
their intersection is the empty set.</p> <p>The <a name="difference"></a><em>difference</em> of two sets
A and B is the set that contains all elements of A that do not belong
to B.</p> <p>The <a name="symmetric_difference"></a><em>symmetric  difference</em> of two sets is the set that contains those element
that belong to either of the two sets, but not both.</p> <p>The <a name="union_n"></a><em>union</em> of a collection
of sets is the smallest set that contains all the elements that
belong to at least one set of the collection.</p> <p>The <a name="intersection_n"></a><em>intersection</em> of
a non-empty collection of sets is the set that contains all elements
that belong to every set of the collection.</p> </li><li> <p>The <a name="Cartesian_product"></a><em>Cartesian product</em> of two sets X and Y, denoted XÂ ÃÂ Y, is
the set {aÂ : aÂ = (x,Â y) for some xÂ inÂ X and
for some yÂ inÂ Y}.</p> <p>A <a name="relation"></a><em>relation</em> is a subset of
XÂ ÃÂ Y. Let R be a relation. The fact that (x,Â y)
belongs to R is written as xÂ RÂ y. As relations are sets,
the definitions of the last item (subset, union, and so on) apply to
relations as well.</p> <p>The <a name="domain"></a><em>domain</em> of R is the set
{xÂ : xÂ RÂ y for some yÂ inÂ Y}.</p> <p>The <a name="range"></a><em>range</em> of R is the set
{yÂ : xÂ RÂ y for some xÂ inÂ X}.</p> <p>The <a name="converse"></a><em>converse</em> of R is the
set {aÂ : aÂ = (y,Â x) for some
(x,Â y)Â inÂ R}.</p> <p>If A is a subset of X, the <a name="image"></a><em>image</em>
of A under R is the set {yÂ : xÂ RÂ y for some
xÂ inÂ A}. If B is a subset of Y, the
<a name="inverse_image"></a><em>inverse image</em> of B is the
set {xÂ : xÂ RÂ y for some yÂ inÂ B}.</p> <p>If R is a relation from X to Y, and S is a relation from Y to Z, the 
<a name="relative_product"></a><em>relative product</em> of R
and S is the relation T from X to Z defined so that xÂ TÂ z
if and only if there exists an element y in Y such that
xÂ RÂ y and yÂ SÂ z.</p> <p>The <a name="restriction"></a><em>restriction</em> of R to A
is the set S defined so that xÂ SÂ y if and only if there
exists an element x in A such that xÂ RÂ y.</p> <p>If S is a restriction of R to A, then R is an
<a name="extension"></a><em>extension</em> of S to X.</p> <p>If XÂ =Â Y, then R is called a relation <em>in</em> X.</p> <p>The <a name="field"></a><em>field</em> of a relation R in X
is the union of the domain of R and the range of R.</p> <p>If R is a relation in X, and if S is defined so that xÂ SÂ y
if xÂ RÂ y and not xÂ =Â y, then S is the
<a name="strict_relation"></a><em>strict</em> relation
corresponding to R. Conversely, if S is a relation in X, and if R is
defined so that xÂ RÂ y if xÂ SÂ y or xÂ =Â y,
then R is the <a name="weak_relation"></a><em>weak</em>
relation corresponding to S.</p> <p>A relation R in X is <em>reflexive</em> if xÂ RÂ x for every
element x of X, it is <em>symmetric</em> if xÂ RÂ y implies
that yÂ RÂ x, and it is <em>transitive</em> if
xÂ RÂ y and yÂ RÂ z imply that xÂ RÂ z.</p> </li><li> <p>A <a name="function"></a><em>function</em> F is a relation,
a subset of XÂ ÃÂ Y, such that the domain of F is equal
to X and such that for every x in X there is a unique element y in Y
with (x,Â y) in F. The latter condition can be formulated as
follows: if xÂ FÂ y and xÂ FÂ z, then yÂ =Â z.
In this module, it is not required that the domain of F is equal to X
for a relation to be considered a function.</p> <p>Instead of writing (x,Â y)Â inÂ F or xÂ FÂ y, we
write F(x)Â =Â y when F is a function, and say that F maps x
onto y, or that the value of F at x is y.</p> <p>As functions are relations, the definitions of the last item (domain,
range, and so on) apply to functions as well.</p> <p>If the converse of a function F is a function F', then F' is called 
the <a name="inverse"></a><em>inverse</em> of F.</p> <p>The relative product of two functions F1 and F2 is called
the <a name="composite"></a><em>composite</em> of F1 and F2
if the range of F1 is a subset of the domain of F2.</p> </li><li> <p>Sometimes, when the range of a function is more important than the
function itself, the function is called a <em>family</em>.</p> <p>The domain of a family is called the <em>index set</em>, and the
range is called the <em>indexed set</em>.</p> <p>If x is a family from I to X, then x[i] denotes the value of the
function at index i. The notation "a family in X" is used for such a
family.</p> <p>When the indexed set is a set of subsets of a set X, we call x a 
<a name="family"></a><em>family of subsets</em> of X.</p> <p>If x is a family of subsets of X, the union of the range of x is
called the <em>union of the family</em> x.</p> <p>If x is non-empty (the index set is non-empty), the <em>intersection of the family</em> x is the intersection of the range of x.</p> <p>In this module, the only families that are considered are families
of subsets of some set X; in the following, the word "family" is
used for such families of subsets.</p> </li><li> <p>A <a name="partition"></a><em>partition</em> of a set X is a
collection S of non-empty subsets of X whose union is X and whose
elements are pairwise disjoint.</p> <p>A relation in a set is an <em>equivalence relation</em> if it is
reflexive, symmetric, and transitive.</p> <p>If R is an equivalence relation in X, and x is an element of X, the 
<a name="equivalence_class"></a><em>equivalence class</em> of
x with respect to R is the set of all those elements y of X for which
xÂ RÂ y holds. The equivalence classes constitute a
partitioning of X. Conversely, if C is a partition of X, the relation
that holds for any two elements of X if they belong to the same
equivalence class, is an equivalence relation induced by the
partition C.</p> <p>If R is an equivalence relation in X, the
<a name="canonical_map"></a><em>canonical map</em> is the
function that maps every element of X onto its equivalence class.</p> </li><li> <p><a name="binary_relation"></a>Relations as defined above
(as sets of ordered pairs) are from now on referred to as <em>binary relations</em>.</p> <p>We call a set of ordered sets (x[1],Â ...,Â x[n]) an
<a name="n_ary_relation"></a><em>(n-ary) relation</em>, and
say that the relation is a subset of the
<a name="Cartesian_product_tuple"></a>Cartesian product
X[1]Â ÃÂ ...Â ÃÂ X[n], where x[i] is
an element of X[i], 1Â &lt;=Â iÂ &lt;=Â n.</p> <p>The <a name="projection"></a><em>projection</em> of an n-ary
relation R onto coordinate i is the set {x[i]Â :
(x[1],Â ...,Â x[i],Â ...,Â x[n]) in R for some
x[j]Â inÂ X[j], 1Â &lt;=Â jÂ &lt;=Â n and
not iÂ =Â j}. The projections of a binary relation R onto the
first and second coordinates are the domain and the range of R,
respectively.</p> <p>The relative product of binary relations can be generalized to n-ary
relations as follows. Let TR be an ordered set
(R[1],Â ...,Â R[n]) of binary relations from X to Y[i]
and S a binary relation from
(Y[1]Â ÃÂ ...Â ÃÂ Y[n]) to Z. The
<a name="tuple_relative_product"></a><em>relative product</em>
of TR and S is the binary relation T from X to Z defined so that
xÂ TÂ z if and only if there exists an element y[i] in Y[i]
for each 1Â &lt;=Â iÂ &lt;=Â n such that
xÂ R[i]Â y[i] and
(y[1],Â ...,Â y[n])Â SÂ z. Now let TR be a an
ordered set (R[1],Â ...,Â R[n]) of binary relations from
X[i] to Y[i] and S a subset of
X[1]Â ÃÂ ...Â ÃÂ X[n].
The <a name="multiple_relative_product"></a><em>multiple relative product</em> of TR and S is defined to be the set
{zÂ : zÂ = ((x[1],Â ...,Â x[n]), (y[1],...,y[n]))
for some (x[1],Â ...,Â x[n])Â inÂ S and for some
(x[i],Â y[i]) in R[i], 1Â &lt;=Â iÂ &lt;=Â n}.</p> <p>The <a name="natural_join"></a><em>natural join</em> of an
n-ary relation R and an m-ary relation S on coordinate i and j is
defined to be the set
{zÂ : zÂ = (x[1],Â ...,Â x[n],Â 
y[1],Â ...,Â y[j-1],Â y[j+1],Â ...,Â y[m])
for some (x[1],Â ...,Â x[n])Â inÂ R and for some
(y[1],Â ...,Â y[m])Â inÂ S such that
x[i]Â =Â y[j]}.</p> </li><li> <p><a name="sets_definition"></a>The sets recognized by this
module are represented by elements of the relation Sets, which is
defined as the smallest set such that:</p> <ul><li> <p>For every atom T, except '_', and for every term X,
(T,Â X) belongs to Sets (<em>atomic sets</em>).</p> </li><li> <p>(['_'],Â []) belongs to Sets (the <em>untyped empty set</em>).</p> </li><li> <p>For every tuple TÂ = {T[1],Â ...,Â T[n]} and
for every tuple XÂ = {X[1],Â ...,Â X[n]}, if
(T[i],Â X[i]) belongs to Sets for every
1Â &lt;=Â iÂ &lt;=Â n, then (T,Â X) belongs
to Sets (<em>ordered sets</em>).</p> </li><li> <p>For every term T, if X is the empty list or a non-empty
sorted list [X[1],Â ...,Â X[n]] without duplicates
such that (T,Â X[i]) belongs to Sets for every
1Â &lt;=Â iÂ &lt;=Â n, then ([T],Â X)
belongs to Sets (<em>typed unordered sets</em>).</p> </li></ul> <p>An <a name="external_set"></a><em>external set</em> is an
element of the range of Sets.</p> <p>A <a name="type"></a><em>type</em> is an element of the
domain of Sets.</p> <p>If S is an element (T,Â X) of Sets, then T is a
<a name="valid_type"></a><em>valid type</em> of X, T is the
type of S, and X is the external set of S.
<a href="#from_term/2">from_term/2</a> creates a
set from a type and an Erlang term turned into an external set.</p> <p>The sets represented by Sets are the elements of the range of
function Set from Sets to Erlang terms and sets of Erlang terms:</p> <ul><li>Set(T,Term)Â = Term, where T is an atom</li><li>Set({T[1],Â ...,Â T[n]},Â {X[1],Â ..., Â X[n]})Â = (Set(T[1],Â X[1]),Â ...,Â  Set(T[n],Â X[n]))</li><li>Set([T],Â [X[1],Â ...,Â X[n]])Â = {Set(T,Â X[1]),Â ...,Â Set(T,Â X[n])}</li><li>Set([T],Â [])Â = {}</li></ul> <p>When there is no risk of confusion, elements of Sets are identified
with the sets they represent. For example, if U is the result of
calling <a href="#union/2">union/2</a> with S1
and S2 as arguments, then U is said to be the union of S1 and S2.
A more precise formulation is that Set(U) is the union of Set(S1)
and Set(S2).</p> </li></ul>The types are used to implement the various conditions that
sets must fulfill. As an example, consider the relative
product of two sets R and S, and recall that the relative
product of R and S is defined if R is a binary relation to Y and
S is a binary relation from Y. The function that implements the
relative product, <a href="#relative_product/2">relative_product/2</a>, checks
that the arguments represent binary relations by matching [{A,B}]
against the type of the first argument (Arg1 say), and [{C,D}]
against the type of the second argument (Arg2 say). The fact
that [{A,B}] matches the type of Arg1 is to be interpreted as
Arg1 representing a binary relation from X to Y, where X is
defined as all sets Set(x) for some element x in Sets the type
of which is A, and similarly for Y. In the same way Arg2 is
interpreted as representing a binary relation from W to Z.
Finally it is checked that B matches C, which is sufficient to
ensure that W is equal to Y. The untyped empty set is handled
separately: its type, ['_'], matches the type of any unordered
set.A few functions of this module
(<a href="#drestriction/3">drestriction/3</a>,
<a href="#family_projection/2">family_projection/2</a>,
<a href="#partition/2">partition/2</a>,
<a href="#partition_family/2">partition_family/2</a>,
<a href="#projection/2">projection/2</a>,
<a href="#restriction/3">restriction/3</a>,
<a href="#substitution/2">substitution/2</a>)
accept an Erlang
function as a means to modify each element of a given unordered
set. <a name="set_fun"></a>Such a function, called
SetFun in the following, can be specified as a functional object (fun),
a tuple <strong>{external,Â Fun}</strong>, or an integer:<ul><li> <p>If SetFun is specified as a fun, the fun is applied to each element
of the given set and the return value is assumed to be a set.</p> </li><li> <p>If SetFun is specified as a tuple <strong>{external, Fun}</strong>, Fun is
applied to the external set of each element of the given set and the
return value is assumed to be an external set. Selecting the
elements of an unordered set as external sets and assembling a
new unordered set from a list of external sets is in the present
implementation more efficient than modifying each element as a
set. However, this optimization can only be used when the
elements of the unordered set are atomic or ordered sets. It
must also be the case that the type of the elements matches some
clause of Fun (the type of the created set is the result of
applying Fun to the type of the given set), and that Fun does
nothing but selecting, duplicating, or rearranging parts of the
elements.</p> </li><li> <p>Specifying a SetFun as an integer I is equivalent to
specifying <strong>{external, fun(X)Â -&gt; element(I,Â X)Â end}</strong>, but is to be preferred, as it
makes it possible to handle this case even more efficiently.</p> </li></ul>Examples of SetFuns:<pre>
fun sofs:union/1
fun(S) -&gt; sofs:partition(1, S) end
{external, fun(A) -&gt; A end}
{external, fun({A,_,C}) -&gt; {C,A} end}
{external, fun({_,{_,C}}) -&gt; C end}
{external, fun({_,{_,{_,E}=C}}) -&gt; {E,{E,C}} end}
2</pre>The order in which a SetFun is applied to the elements of an
unordered set is not specified, and can change in future
versions of this module.The execution time of the functions of this module is dominated
by the time it takes to sort lists. When no sorting is needed,
the execution time is in the worst case proportional to the sum
of the sizes of the input arguments and the returned value. A
few functions execute in constant time:
<a href="#from_external/2">from_external/2</a>,
<a href="#is_empty_set/1">is_empty_set/1</a>,
<a href="#is_set/1">is_set/1</a>,
<a href="#is_sofs_set/1">is_sofs_set/1</a>,
<a href="#to_external/1">to_external/1</a>
<a href="#type/1">type/1</a>.The functions of this module exit the process with a
<strong>badarg</strong>, <strong>bad_function</strong>, or <strong>type_mismatch</strong>
message when given badly formed arguments or sets the types of
which are not compatible.When comparing external sets, operator <strong>==/2</strong> is used.</p><h1>Data Types</h1><span class="name">anyset</span><p>Any kind of set (also included are the atomic sets).</p><span class="name">binary_relation</span><p>A <a href="#binary_relation">binary relation</a>.</p><span class="name">external_set</span><p>An <a href="#external_set">external set</a>.</p><span class="name">family</span><p>A <a href="#family">family</a> (of subsets).</p><span class="name">a_function</span><p>A <a href="#function">function</a>.</p><span class="name">ordset</span><p>An <a href="#sets_definition">ordered set</a>.</p><span class="name">relation</span><p>An <a href="#n_ary_relation">n-ary relation</a>.
</p><span class="name">a_set</span><p>An <a href="#sets_definition">unordered set</a>.</p><span class="name">set_of_sets</span><p>An <a href="#sets_definition">unordered set</a> of unordered sets.</p><span class="name">set_fun</span><p>A <a href="#set_fun">SetFun</a>.</p><span class="name">spec_fun</span><span class="name">type</span><p>A <a href="#type">type</a>.</p><span class="name">tuple_of(T)</span><p>A tuple where the elements are of type <strong>T</strong>.</p><h1>Functions</h1><h2>a_function/1</h2><h2>a_function/2</h2><p>Create a function.</p><p>Creates a <a href="#function">function</a>.
<strong>a_function(F,Â T)</strong> is equivalent to
<strong>from_term(F,Â T)</strong> if the result is a function. If
no <a href="#type">type</a> is explicitly
specified, <strong>[{atom,Â atom}]</strong> is used as the
function type.</p><h2>canonical_relation/1</h2><p>Return the canonical map.</p><p>Returns the binary relation containing the elements
(E,Â Set) such that Set belongs to <strong><span class="anno">SetOfSets</span></strong>
and E belongs to Set. If <strong>SetOfSets</strong> is
a <a href="#partition">partition</a> of a set X and
R is the equivalence relation in X induced by <strong>SetOfSets</strong>,
then the returned relation is
the <a href="#canonical_map">canonical map</a> from
X onto the equivalence classes with respect to R.</p><pre>
1&gt; <span class="input">Ss = sofs:from_term([[a,b],[b,c]]),</span>
<span class="input">CR = sofs:canonical_relation(Ss),</span>
<span class="input">sofs:to_external(CR).</span>
[{a,[a,b]},{b,[a,b]},{b,[b,c]},{c,[b,c]}]</pre><h2>composite/2</h2><p>Return the composite of two functions.</p><p>Returns the <a href="#composite">composite</a> of 
the functions <strong><span class="anno">Function1</span></strong> and
<strong><span class="anno">Function2</span></strong>.</p><pre>
1&gt; <span class="input">F1 = sofs:a_function([{a,1},{b,2},{c,2}]),</span>
<span class="input">F2 = sofs:a_function([{1,x},{2,y},{3,z}]),</span>
<span class="input">F = sofs:composite(F1, F2),</span>
<span class="input">sofs:to_external(F).</span>
[{a,x},{b,y},{c,y}]</pre><h2>constant_function/2</h2><p>Create the function that maps each element of a set onto another set.</p><p>Creates the <a href="#function">function</a>
that maps each element of set <strong>Set</strong> onto <strong>AnySet</strong>.</p><pre>
1&gt; <span class="input">S = sofs:set([a,b]),</span>
<span class="input">E = sofs:from_term(1),</span>
<span class="input">R = sofs:constant_function(S, E),</span>
<span class="input">sofs:to_external(R).</span>
[{a,1},{b,1}]</pre><h2>converse/1</h2><p>Return the converse of a binary relation.</p><p>Returns the <a href="#converse">converse</a>
of the binary relation <strong><span class="anno">BinRel1</span></strong>.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{1,a},{2,b},{3,a}]),</span>
<span class="input">R2 = sofs:converse(R1),</span>
<span class="input">sofs:to_external(R2).</span>
[{a,1},{a,3},{b,2}]</pre><h2>difference/2</h2><p>Return the difference of two sets.</p><p>Returns the <a href="#difference">difference</a> of
the sets <strong><span class="anno">Set1</span></strong> and <strong><span class="anno">Set2</span></strong>.</p><h2>digraph_to_family/1</h2><h2>digraph_to_family/2</h2><p>Create a family from a directed graph.</p><p>Creates a <a href="#family">family</a> from
the directed graph <strong><span class="anno">Graph</span></strong>. Each vertex a of
<strong><span class="anno">Graph</span></strong> is
represented by a pair (a,Â {b[1],Â ...,Â b[n]}),
where the b[i]:s are the out-neighbors of a. If no type is
explicitly specified, [{atom,Â [atom]}] is used as type of
the family. It is assumed that <strong><span class="anno">Type</span></strong> is
a <a href="#valid_type">valid type</a> of the 
external set of the family.</p><p>If G is a directed graph, it holds that the vertices and
edges of G are the same as the vertices and edges of
<strong>family_to_digraph(digraph_to_family(G))</strong>.</p><h2>domain/1</h2><p>Return the domain of a binary relation.</p><p>Returns the <a href="#domain">domain</a> of
the binary relation <strong><span class="anno">BinRel</span></strong>.</p><pre>
1&gt; <span class="input">R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]),</span>
<span class="input">S = sofs:domain(R),</span>
<span class="input">sofs:to_external(S).</span>
[1,2]</pre><h2>drestriction/2</h2><p>Return a restriction of a binary relation.</p><p>Returns the difference between the binary relation
<strong><span class="anno">BinRel1</span></strong>
and the <a href="#restriction">restriction</a>
of <strong><span class="anno">BinRel1</span></strong> to <strong><span class="anno">Set</span></strong>.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{1,a},{2,b},{3,c}]),</span>
<span class="input">S = sofs:set([2,4,6]),</span>
<span class="input">R2 = sofs:drestriction(R1, S),</span>
<span class="input">sofs:to_external(R2).</span>
[{1,a},{3,c}]</pre><p><strong>drestriction(R,Â S)</strong> is equivalent to
<strong>difference(R,Â restriction(R,Â S))</strong>.</p><h2>drestriction/3</h2><p>Return a restriction of a relation.</p><p>Returns a subset of <strong><span class="anno">Set1</span></strong> containing those
elements that do not give
an element in <strong><span class="anno">Set2</span></strong> as the result of applying
<strong><span class="anno">SetFun</span></strong>.</p><pre>
1&gt; <span class="input">SetFun = {external, fun({_A,B,C}) -&gt; {B,C} end},</span>
<span class="input">R1 = sofs:relation([{a,aa,1},{b,bb,2},{c,cc,3}]),</span>
<span class="input">R2 = sofs:relation([{bb,2},{cc,3},{dd,4}]),</span>
<span class="input">R3 = sofs:drestriction(SetFun, R1, R2),</span>
<span class="input">sofs:to_external(R3).</span>
[{a,aa,1}]</pre><p><strong>drestriction(F,Â S1,Â S2)</strong> is equivalent to
<strong>difference(S1,Â restriction(F,Â S1,Â S2))</strong>.</p><h2>empty_set/0</h2><p>Return the untyped empty set.</p><p>Returns the <a href="#sets_definition">untyped empty set</a>. <strong>empty_set()</strong> is equivalent to
<strong>from_term([],Â ['_'])</strong>.</p><h2>extension/3</h2><p>Extend the domain of a binary relation.</p><p>Returns the <a href="#extension">extension</a> of
<strong><span class="anno">BinRel1</span></strong> such that for
each element E in <strong><span class="anno">Set</span></strong> that does not belong to the
<a href="#domain">domain</a> of
<strong><span class="anno">BinRel1</span></strong>, <strong><span class="anno">BinRel2</span></strong> contains the
pair (E,Â <strong>AnySet</strong>).</p><pre>
1&gt; <span class="input">S = sofs:set([b,c]),</span>
<span class="input">A = sofs:empty_set(),</span>
<span class="input">R = sofs:family([{a,[1,2]},{b,[3]}]),</span>
<span class="input">X = sofs:extension(R, S, A),</span>
<span class="input">sofs:to_external(X).</span>
[{a,[1,2]},{b,[3]},{c,[]}]</pre><h2>family/1</h2><h2>family/2</h2><p>Create a family of subsets.</p><p>Creates a <a href="#family">family of subsets</a>.
<strong>family(F,Â T)</strong> is equivalent to
<strong>from_term(F,Â T)</strong> if the result is a family. If
no <a href="#type">type</a> is explicitly
specified, <strong>[{atom,Â [atom]}]</strong> is used as the
family type.</p><h2>family_difference/2</h2><p>Return the difference of two families.</p><p>If <strong><span class="anno">Family1</span></strong> and <strong><span class="anno">Family2</span></strong>
are <a href="#family">families</a>, then
<strong><span class="anno">Family3</span></strong> is the family
such that the index set is equal to the index set of
<strong><span class="anno">Family1</span></strong>, and <strong><span class="anno">Family3</span></strong>[i] is
the difference between <strong><span class="anno">Family1</span></strong>[i]
and <strong><span class="anno">Family2</span></strong>[i] if <strong><span class="anno">Family2</span></strong>
maps i, otherwise <strong><span class="anno">Family1</span>[i]</strong>.</p><pre>
1&gt; <span class="input">F1 = sofs:family([{a,[1,2]},{b,[3,4]}]),</span>
<span class="input">F2 = sofs:family([{b,[4,5]},{c,[6,7]}]),</span>
<span class="input">F3 = sofs:family_difference(F1, F2),</span>
<span class="input">sofs:to_external(F3).</span>
[{a,[1,2]},{b,[3]}]</pre><h2>family_domain/1</h2><p>Return a family of domains.</p><p>If <strong><span class="anno">Family1</span></strong> is
a <a href="#family">family</a>
and <strong><span class="anno">Family1</span></strong>[i] is a binary relation for every i
in the index set of <strong><span class="anno">Family1</span></strong>,
then <strong><span class="anno">Family2</span></strong> is the family with the same index
set as <strong><span class="anno">Family1</span></strong> such
that <strong><span class="anno">Family2</span></strong>[i] is
the <a href="#domain">domain</a> of
<strong><span class="anno">Family1</span>[i]</strong>.</p><pre>
1&gt; <span class="input">FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]),</span>
<span class="input">F = sofs:family_domain(FR),</span>
<span class="input">sofs:to_external(F).</span>
[{a,[1,2,3]},{b,[]},{c,[4,5]}]</pre><h2>family_field/1</h2><p>Return a family of fields.</p><p>If <strong><span class="anno">Family1</span></strong> is
a <a href="#family">family</a>
and <strong><span class="anno">Family1</span></strong>[i] is a binary relation for every i
in the index set of <strong><span class="anno">Family1</span></strong>,
then <strong><span class="anno">Family2</span></strong> is the family with the same index
set as <strong><span class="anno">Family1</span></strong> such
that <strong><span class="anno">Family2</span></strong>[i] is
the <a href="#field">field</a> of
<strong><span class="anno">Family1</span></strong>[i].</p><pre>
1&gt; <span class="input">FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]),</span>
<span class="input">F = sofs:family_field(FR),</span>
<span class="input">sofs:to_external(F).</span>
[{a,[1,2,3,a,b,c]},{b,[]},{c,[4,5,d,e]}]</pre><p><strong>family_field(Family1)</strong> is equivalent to
<strong>family_union(family_domain(Family1), family_range(Family1))</strong>.</p><h2>family_intersection/1</h2><p>Return the intersection of a family of sets of sets.</p><p>If <strong><span class="anno">Family1</span></strong> is
a <a href="#family">family</a>
and <strong><span class="anno">Family1</span></strong>[i] is a set of sets for every i in
the index set of <strong><span class="anno">Family1</span></strong>,
then <strong><span class="anno">Family2</span></strong> is the family with the same index
set as <strong><span class="anno">Family1</span></strong> such
that <strong><span class="anno">Family2</span></strong>[i] is
the <a href="#intersection_n">intersection</a>
of <strong><span class="anno">Family1</span></strong>[i].</p><p>If <strong><span class="anno">Family1</span></strong>[i] is an empty set for some i,
the process exits with a <strong>badarg</strong> message.</p><pre>
1&gt; <span class="input">F1 = sofs:from_term([{a,[[1,2,3],[2,3,4]]},{b,[[x,y,z],[x,y]]}]),</span>
<span class="input">F2 = sofs:family_intersection(F1),</span>
<span class="input">sofs:to_external(F2).</span>
[{a,[2,3]},{b,[x,y]}]</pre><h2>family_intersection/2</h2><p>Return the intersection of two families.</p><p>If <strong><span class="anno">Family1</span></strong> and <strong><span class="anno">Family2</span></strong>
are <a href="#family">families</a>,
then <strong><span class="anno">Family3</span></strong> is the family such that the index
set is the intersection of <strong><span class="anno">Family1</span></strong>:s and
<strong><span class="anno">Family2</span></strong>:s index sets,
and <strong><span class="anno">Family3</span></strong>[i] is the intersection of
<strong><span class="anno">Family1</span></strong>[i] and <strong><span class="anno">Family2</span></strong>[i].</p><pre>
1&gt; <span class="input">F1 = sofs:family([{a,[1,2]},{b,[3,4]},{c,[5,6]}]),</span>
<span class="input">F2 = sofs:family([{b,[4,5]},{c,[7,8]},{d,[9,10]}]),</span>
<span class="input">F3 = sofs:family_intersection(F1, F2),</span>
<span class="input">sofs:to_external(F3).</span>
[{b,[4]},{c,[]}]</pre><h2>family_projection/2</h2><p>Return a family of modified subsets.</p><p>If <strong><span class="anno">Family1</span></strong> is
a <a href="#family">family</a>,
then <strong><span class="anno">Family2</span></strong> is the family with the same index
set as <strong><span class="anno">Family1</span></strong> such
that <strong><span class="anno">Family2</span></strong>[i] is the result of
calling <strong><span class="anno">SetFun</span></strong> with <strong><span class="anno">Family1</span></strong>[i]
as argument.</p><pre>
1&gt; <span class="input">F1 = sofs:from_term([{a,[[1,2],[2,3]]},{b,[[]]}]),</span>
<span class="input">F2 = sofs:family_projection(fun sofs:union/1, F1),</span>
<span class="input">sofs:to_external(F2).</span>
[{a,[1,2,3]},{b,[]}]</pre><h2>family_range/1</h2><p>Return a family of ranges.</p><p>If <strong><span class="anno">Family1</span></strong> is
a <a href="#family">family</a>
and <strong><span class="anno">Family1</span></strong>[i] is a binary relation for every i
in the index set of <strong><span class="anno">Family1</span></strong>,
then <strong><span class="anno">Family2</span></strong> is the family with the same index
set as <strong><span class="anno">Family1</span></strong> such
that <strong><span class="anno">Family2</span></strong>[i] is
the <a href="#range">range</a> of
<strong><span class="anno">Family1</span></strong>[i].</p><pre>
1&gt; <span class="input">FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]),</span>
<span class="input">F = sofs:family_range(FR),</span>
<span class="input">sofs:to_external(F).</span>
[{a,[a,b,c]},{b,[]},{c,[d,e]}]</pre><h2>family_specification/2</h2><p>Select a subset of a family using a predicate.</p><p>If <strong><span class="anno">Family1</span></strong> is
a <a href="#family">family</a>,
then <strong><span class="anno">Family2</span></strong> is
the <a href="#restriction">restriction</a> of
<strong><span class="anno">Family1</span></strong> to those elements i of the index set
for which <strong><span class="anno">Fun</span></strong> applied
to <strong><span class="anno">Family1</span></strong>[i] returns
<strong>true</strong>. If <strong><span class="anno">Fun</span></strong> is a
tuple <strong>{external,Â Fun2}</strong>, then <strong>Fun2</strong> is applied to
the <a href="#external_set">external set</a>
of <strong><span class="anno">Family1</span></strong>[i], otherwise <strong><span class="anno">Fun</span></strong>
is applied to <strong><span class="anno">Family1</span></strong>[i].</p><pre>
1&gt; <span class="input">F1 = sofs:family([{a,[1,2,3]},{b,[1,2]},{c,[1]}]),</span>
<span class="input">SpecFun = fun(S) -&gt; sofs:no_elements(S) =:= 2 end,</span>
<span class="input">F2 = sofs:family_specification(SpecFun, F1),</span>
<span class="input">sofs:to_external(F2).</span>
[{b,[1,2]}]</pre><h2>family_to_digraph/1</h2><h2>family_to_digraph/2</h2><p>Create a directed graph from a family.</p><p>Creates a directed graph from
<a href="#family">family</a> <strong><span class="anno">Family</span></strong>.
For each pair (a,Â {b[1],Â ...,Â b[n]})
of <strong><span class="anno">Family</span></strong>, vertex
a and the edges (a,Â b[i]) for
1Â &lt;=Â iÂ &lt;=Â n are added to a newly
created directed graph.</p><p>If no graph type is specified, <a href="./digraph#new/0">digraph#new/0</a> is used for
creating the directed graph, otherwise argument
<strong><span class="anno">GraphType</span></strong> is passed on as second argument to
<a href="./digraph#new/1">digraph#new/1</a>.</p><p>It F is a family, it holds that F is a subset of
<strong>digraph_to_family(family_to_digraph(F),Â type(F))</strong>.
Equality holds if <strong>union_of_family(F)</strong> is a subset of
<strong>domain(F)</strong>.</p><p>Creating a cycle in an acyclic graph exits the process with
a <strong>cyclic</strong> message.</p><h2>family_to_relation/1</h2><p>Create a binary relation from a family.</p><p>If <strong><span class="anno">Family</span></strong> is
a <a href="#family">family</a>,
then <strong><span class="anno">BinRel</span></strong> is the binary relation containing
all pairs (i,Â x) such that i belongs to the index set
of <strong><span class="anno">Family</span></strong> and x belongs
to <strong><span class="anno">Family</span></strong>[i].</p><pre>
1&gt; <span class="input">F = sofs:family([{a,[]}, {b,[1]}, {c,[2,3]}]),</span>
<span class="input">R = sofs:family_to_relation(F),</span>
<span class="input">sofs:to_external(R).</span>
[{b,1},{c,2},{c,3}]</pre><h2>family_union/1</h2><p>Return the union of a family of sets of sets.</p><p>If <strong><span class="anno">Family1</span></strong> is
a <a href="#family">family</a>
and <strong><span class="anno">Family1</span></strong>[i] is a set of sets for each i in
the index set of <strong><span class="anno">Family1</span></strong>,
then <strong><span class="anno">Family2</span></strong> is the family with the same index
set as <strong><span class="anno">Family1</span></strong> such
that <strong><span class="anno">Family2</span></strong>[i] is
the <a href="#union_n">union</a> of
<strong><span class="anno">Family1</span></strong>[i].</p><pre>
1&gt; <span class="input">F1 = sofs:from_term([{a,[[1,2],[2,3]]},{b,[[]]}]),</span>
<span class="input">F2 = sofs:family_union(F1),</span>
<span class="input">sofs:to_external(F2).</span>
[{a,[1,2,3]},{b,[]}]</pre><p><strong>family_union(F)</strong> is equivalent to
<strong>family_projection(fun sofs:union/1,Â F)</strong>.</p><h2>family_union/2</h2><p>Return the union of two families.</p><p>If <strong><span class="anno">Family1</span></strong> and <strong><span class="anno">Family2</span></strong>
are <a href="#family">families</a>,
then <strong><span class="anno">Family3</span></strong> is the family such that the index
set is the union of <strong><span class="anno">Family1</span></strong>:s
and <strong><span class="anno">Family2</span></strong>:s index sets,
and <strong><span class="anno">Family3</span></strong>[i] is the union
of <strong><span class="anno">Family1</span></strong>[i] and <strong><span class="anno">Family2</span></strong>[i]
if both map i, otherwise <strong><span class="anno">Family1</span></strong>[i]
or <strong><span class="anno">Family2</span></strong>[i].</p><pre>
1&gt; <span class="input">F1 = sofs:family([{a,[1,2]},{b,[3,4]},{c,[5,6]}]),</span>
<span class="input">F2 = sofs:family([{b,[4,5]},{c,[7,8]},{d,[9,10]}]),</span>
<span class="input">F3 = sofs:family_union(F1, F2),</span>
<span class="input">sofs:to_external(F3).</span>
[{a,[1,2]},{b,[3,4,5]},{c,[5,6,7,8]},{d,[9,10]}]</pre><h2>field/1</h2><p>Return the field of a binary relation.</p><p>Returns the <a href="#field">field</a> of the
binary relation <strong><span class="anno">BinRel</span></strong>.</p><pre>
1&gt; <span class="input">R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]),</span>
<span class="input">S = sofs:field(R),</span>
<span class="input">sofs:to_external(S).</span>
[1,2,a,b,c]</pre><p><strong>field(R)</strong> is equivalent
to <strong>union(domain(R), range(R))</strong>.</p><h2>from_external/2</h2><p>Create a set.</p><p>Creates a set from the <a href="#external_set">external  set</a> <strong><span class="anno">ExternalSet</span></strong> and
the <a href="#type">type</a> <strong><span class="anno">Type</span></strong>.
It is assumed that <strong><span class="anno">Type</span></strong> is
a <a href="#valid_type">valid type</a> of <strong><span class="anno">ExternalSet</span></strong>.</p><h2>from_sets/1</h2><p>Create a set out of a list of sets.</p><p>Returns the <a href="#sets_definition">unordered set</a> containing the sets of list
<strong><span class="anno">ListOfSets</span></strong>.</p><pre>
1&gt; <span class="input">S1 = sofs:relation([{a,1},{b,2}]),</span>
<span class="input">S2 = sofs:relation([{x,3},{y,4}]),</span>
<span class="input">S = sofs:from_sets([S1,S2]),</span>
<span class="input">sofs:to_external(S).</span>
[[{a,1},{b,2}],[{x,3},{y,4}]]</pre><h2>from_sets/1</h2><p>Create an ordered set out of a tuple of sets.</p><p>Returns the <a href="#sets_definition">ordered set</a> containing the sets of the non-empty tuple
<strong><span class="anno">TupleOfSets</span></strong>.</p><h2>from_term/1</h2><h2>from_term/2</h2><p>Create a set.</p><p><a name="from_term"></a>Creates an element
of <a href="#sets_definition">Sets</a> by
traversing term <strong><span class="anno">Term</span></strong>, sorting lists,
removing duplicates, and
deriving or verifying a <a href="#valid_type">valid type</a> for the so obtained external set. An
explicitly specified <a href="#type">type</a>
<strong><span class="anno">Type</span></strong>
can be used to limit the depth of the traversal; an atomic
type stops the traversal, as shown by the following example
where <strong>"foo"</strong> and <strong>{"foo"}</strong> are left unmodified:</p><pre>
1&gt; <span class="input">S = sofs:from_term([{{"foo"},[1,1]},{"foo",[2,2]}], [{atom,[atom]}]),</span>
<span class="input">sofs:to_external(S).</span>
[{{"foo"},[1]},{"foo",[2]}]</pre><p><strong>from_term</strong> can be used for creating atomic or ordered
sets. The only purpose of such a set is that of later
building unordered sets, as all functions in this module
that <em>do</em> anything operate on unordered sets.
Creating unordered sets from a collection of ordered sets
can be the way to go if the ordered sets are big and one
does not want to waste heap by rebuilding the elements of
the unordered set. The following example shows that a set can be
built "layer by layer":</p><pre>
1&gt; <span class="input">A = sofs:from_term(a),</span>
<span class="input">S = sofs:set([1,2,3]),</span>
<span class="input">P1 = sofs:from_sets({A,S}),</span>
<span class="input">P2 = sofs:from_term({b,[6,5,4]}),</span>
<span class="input">Ss = sofs:from_sets([P1,P2]),</span>
<span class="input">sofs:to_external(Ss).</span>
[{a,[1,2,3]},{b,[4,5,6]}]</pre><p>Other functions that create sets are
<a href="#from_external/2">from_external/2</a>
and <a href="#from_sets/1">from_sets/1</a>.
Special cases of <strong>from_term/2</strong> are
<a href="#a_function/1">a_function/1</a>,
<a href="#empty_set/0">empty_set/0</a>,
<a href="#family/1">family/1</a>,
<a href="#relation/1">relation/1</a>, and
<a href="#set/1">set/1</a>.</p><h2>image/2</h2><p>Return the image of a set under a binary relation.</p><p>Returns the <a href="#image">image</a> of
set <strong><span class="anno">Set1</span></strong> under the binary
relation <strong><span class="anno">BinRel</span></strong>.</p><pre>
1&gt; <span class="input">R = sofs:relation([{1,a},{2,b},{2,c},{3,d}]),</span>
<span class="input">S1 = sofs:set([1,2]),</span>
<span class="input">S2 = sofs:image(R, S1),</span>
<span class="input">sofs:to_external(S2).</span>
[a,b,c]</pre><h2>intersection/1</h2><p>Return the intersection of a set of sets.</p><p>Returns
the <a href="#intersection_n">intersection</a> of
the set of sets <strong><span class="anno">SetOfSets</span></strong>.</p><p>Intersecting an empty set of sets exits the process with a
<strong>badarg</strong> message.</p><h2>intersection/2</h2><p>Return the intersection of two sets.</p><p>Returns
the <a href="#intersection">intersection</a> of
<strong><span class="anno">Set1</span></strong> and <strong><span class="anno">Set2</span></strong>.</p><h2>intersection_of_family/1</h2><p>Return the intersection of a family.</p><p>Returns the intersection of
<a href="#family">family</a> <strong><span class="anno">Family</span></strong>.
</p><p>Intersecting an empty family exits the process with a
<strong>badarg</strong> message.</p><pre>
1&gt; <span class="input">F = sofs:family([{a,[0,2,4]},{b,[0,1,2]},{c,[2,3]}]),</span>
<span class="input">S = sofs:intersection_of_family(F),</span>
<span class="input">sofs:to_external(S).</span>
[2]</pre><h2>inverse/1</h2><p>Return the inverse of a function.</p><p>Returns the <a href="#inverse">inverse</a>
of function <strong><span class="anno">Function1</span></strong>.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{1,a},{2,b},{3,c}]),</span>
<span class="input">R2 = sofs:inverse(R1),</span>
<span class="input">sofs:to_external(R2).</span>
[{a,1},{b,2},{c,3}]</pre><h2>inverse_image/2</h2><p>Return the inverse image of a set under a binary relation.</p><p>Returns the <a href="#inverse_image">inverse image</a> of <strong><span class="anno">Set1</span></strong> under the binary
relation <strong><span class="anno">BinRel</span></strong>.</p><pre>
1&gt; <span class="input">R = sofs:relation([{1,a},{2,b},{2,c},{3,d}]),</span>
<span class="input">S1 = sofs:set([c,d,e]),</span>
<span class="input">S2 = sofs:inverse_image(R, S1),</span>
<span class="input">sofs:to_external(S2).</span>
[2,3]</pre><h2>is_a_function/1</h2><p>Test for a function.</p><p>Returns <strong>true</strong> if the binary relation <strong><span class="anno">BinRel</span></strong>
is a <a href="#function">function</a> or the
untyped empty set, otherwise <strong>false</strong>.</p><h2>is_disjoint/2</h2><p>Test for disjoint sets.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Set1</span></strong>
and <strong><span class="anno">Set2</span></strong>
are <a href="#disjoint">disjoint</a>, otherwise
<strong>false</strong>.</p><h2>is_empty_set/1</h2><p>Test for an empty set.</p><p>Returns <strong>true</strong> if <strong><span class="anno">AnySet</span></strong> is an empty
unordered set, otherwise <strong>false</strong>.</p><h2>is_equal/2</h2><p>Test two sets for equality.</p><p>Returns <strong>true</strong> if <strong><span class="anno">AnySet1</span></strong>
and <strong><span class="anno">AnySet2</span></strong>
are <a href="#equal">equal</a>, otherwise
<strong>false</strong>. The following  example shows that <strong>==/2</strong> is
used when comparing sets for equality:</p><pre>
1&gt; <span class="input">S1 = sofs:set([1.0]),</span>
<span class="input">S2 = sofs:set([1]),</span>
<span class="input">sofs:is_equal(S1, S2).</span>
true</pre><h2>is_set/1</h2><p>Test for an unordered set.</p><p>Returns <strong>true</strong> if <strong><span class="anno">AnySet</span></strong> is
an <a href="#sets_definition">unordered set</a>, and
<strong>false</strong> if <strong><span class="anno">AnySet</span></strong> is an ordered set or an
atomic set.</p><h2>is_sofs_set/1</h2><p>Test for an unordered set.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is
an <a href="#sets_definition">unordered set</a>, an
ordered set, or an atomic set, otherwise <strong>false</strong>.</p><h2>is_subset/2</h2><p>Test two sets for subset.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Set1</span></strong> is
a <a href="#subset">subset</a>
of <strong><span class="anno">Set2</span></strong>, otherwise <strong>false</strong>.</p><h2>is_type/1</h2><p>Test for a type.</p><p>Returns <strong>true</strong> if term <strong><span class="anno">Term</span></strong> is
a <a href="#type">type</a>.</p><h2>join/4</h2><p>Return the join of two relations.</p><p>Returns the <a href="#natural_join">natural join</a> of the relations <strong><span class="anno">Relation1</span></strong>
and <strong><span class="anno">Relation2</span></strong> on coordinates <strong><span class="anno">I</span></strong>
and <strong><span class="anno">J</span></strong>.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{a,x,1},{b,y,2}]),</span>
<span class="input">R2 = sofs:relation([{1,f,g},{1,h,i},{2,3,4}]),</span>
<span class="input">J = sofs:join(R1, 3, R2, 1),</span>
<span class="input">sofs:to_external(J).</span>
[{a,x,1,f,g},{a,x,1,h,i},{b,y,2,3,4}]</pre><h2>multiple_relative_product/2</h2><p>Return the multiple relative product of a tuple of binary relations and a relation.</p><p>If <strong><span class="anno">TupleOfBinRels</span></strong> is a non-empty tuple
{R[1],Â ...,Â R[n]} of binary relations
and <strong><span class="anno">BinRel1</span></strong> is a binary relation,
then <strong><span class="anno">BinRel2</span></strong> is
the <a href="#multiple_relative_product">multiple relative product</a> of the ordered set
(R[i],Â ...,Â R[n]) and <strong><span class="anno">BinRel1</span></strong>.</p><pre>
1&gt; <span class="input">Ri = sofs:relation([{a,1},{b,2},{c,3}]),</span>
<span class="input">R = sofs:relation([{a,b},{b,c},{c,a}]),</span>
<span class="input">MP = sofs:multiple_relative_product({Ri, Ri}, R),</span>
<span class="input">sofs:to_external(sofs:range(MP)).</span>
[{1,2},{2,3},{3,1}]</pre><h2>no_elements/1</h2><p>Return the number of elements of a set.</p><p>Returns the number of elements of the ordered or unordered
set <strong><span class="anno">ASet</span></strong>.</p><h2>partition/1</h2><p>Return the coarsest partition given a set of sets.</p><p>Returns the <a href="#partition">partition</a> of
the union of the set of sets <strong><span class="anno">SetOfSets</span></strong> such that
two elements are considered equal if they belong to the same
elements of <strong><span class="anno">SetOfSets</span></strong>.</p><pre>
1&gt; <span class="input">Sets1 = sofs:from_term([[a,b,c],[d,e,f],[g,h,i]]),</span>
<span class="input">Sets2 = sofs:from_term([[b,c,d],[e,f,g],[h,i,j]]),</span>
<span class="input">P = sofs:partition(sofs:union(Sets1, Sets2)),</span>
<span class="input">sofs:to_external(P).</span>
[[a],[b,c],[d],[e,f],[g],[h,i],[j]]</pre><h2>partition/2</h2><p>Return a partition of a set.</p><p>Returns the <a href="#partition">partition</a> of
<strong><span class="anno">Set</span></strong> such that two elements are considered equal
if the results of applying <strong><span class="anno">SetFun</span></strong> are equal.</p><pre>
1&gt; <span class="input">Ss = sofs:from_term([[a],[b],[c,d],[e,f]]),</span>
<span class="input">SetFun = fun(S) -&gt; sofs:from_term(sofs:no_elements(S)) end,</span>
<span class="input">P = sofs:partition(SetFun, Ss),</span>
<span class="input">sofs:to_external(P).</span>
[[[a],[b]],[[c,d],[e,f]]]</pre><h2>partition/3</h2><p>Return a partition of a set.</p><p>Returns a pair of sets that, regarded as constituting a
set, forms a <a href="#partition">partition</a> of
<strong><span class="anno">Set1</span></strong>. If the
result of applying <strong><span class="anno">SetFun</span></strong> to an element of
<strong><span class="anno">Set1</span></strong> gives an element in <strong><span class="anno">Set2</span></strong>,
the element belongs to <strong><span class="anno">Set3</span></strong>, otherwise the
element belongs to <strong><span class="anno">Set4</span></strong>.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{1,a},{2,b},{3,c}]),</span>
<span class="input">S = sofs:set([2,4,6]),</span>
<span class="input">{R2,R3} = sofs:partition(1, R1, S),</span>
<span class="input">{sofs:to_external(R2),sofs:to_external(R3)}.</span>
{[{2,b}],[{1,a},{3,c}]}</pre><p><strong>partition(F,Â S1,Â S2)</strong> is equivalent to
<strong>{restriction(F,Â S1,Â S2), drestriction(F,Â S1,Â S2)}</strong>.</p><h2>partition_family/2</h2><p>Return a family indexing a partition.</p><p>Returns <a href="#family">family</a>
<strong><span class="anno">Family</span></strong> where the indexed set is
a <a href="#partition">partition</a>
of <strong><span class="anno">Set</span></strong> such that two elements are considered
equal if the results of applying <strong><span class="anno">SetFun</span></strong> are the
same value i. This i is the index that <strong><span class="anno">Family</span></strong>
maps onto the <a href="#equivalence_class">equivalence class</a>.</p><pre>
1&gt; <span class="input">S = sofs:relation([{a,a,a,a},{a,a,b,b},{a,b,b,b}]),</span>
<span class="input">SetFun = {external, fun({A,_,C,_}) -&gt; {A,C} end},</span>
<span class="input">F = sofs:partition_family(SetFun, S),</span>
<span class="input">sofs:to_external(F).</span>
[{{a,a},[{a,a,a,a}]},{{a,b},[{a,a,b,b},{a,b,b,b}]}]</pre><h2>product/1</h2><p>Return the Cartesian product of a tuple of sets.</p><p>Returns the <a href="#Cartesian_product_tuple">Cartesian product</a> of the non-empty tuple of sets
<strong><span class="anno">TupleOfSets</span></strong>. If (x[1],Â ...,Â x[n]) is
an element of the n-ary relation <strong><span class="anno">Relation</span></strong>, then
x[i] is drawn from element i of <strong><span class="anno">TupleOfSets</span></strong>.</p><pre>
1&gt; <span class="input">S1 = sofs:set([a,b]),</span>
<span class="input">S2 = sofs:set([1,2]),</span>
<span class="input">S3 = sofs:set([x,y]),</span>
<span class="input">P3 = sofs:product({S1,S2,S3}),</span>
<span class="input">sofs:to_external(P3).</span>
[{a,1,x},{a,1,y},{a,2,x},{a,2,y},{b,1,x},{b,1,y},{b,2,x},{b,2,y}]</pre><h2>product/2</h2><p>Return the Cartesian product of two sets.</p><p>Returns the <a href="#Cartesian_product">Cartesian product</a> of <strong><span class="anno">Set1</span></strong>
and <strong><span class="anno">Set2</span></strong>.</p><pre>
1&gt; <span class="input">S1 = sofs:set([1,2]),</span>
<span class="input">S2 = sofs:set([a,b]),</span>
<span class="input">R = sofs:product(S1, S2),</span>
<span class="input">sofs:to_external(R).</span>
[{1,a},{1,b},{2,a},{2,b}]</pre><p><strong>product(S1,Â S2)</strong> is equivalent to
<strong>product({S1,Â S2})</strong>.</p><h2>projection/2</h2><p>Return a set of substituted elements.</p><p>Returns the set created by substituting each element of
<strong><span class="anno">Set1</span></strong> by the result of
applying <strong><span class="anno">SetFun</span></strong> to the element.</p><p>If <strong><span class="anno">SetFun</span></strong> is a number iÂ &gt;=Â 1 and
<strong><span class="anno">Set1</span></strong> is a relation, then the returned set is
the <a href="#projection">projection</a> of
<strong><span class="anno">Set1</span></strong> onto coordinate i.</p><pre>
1&gt; <span class="input">S1 = sofs:from_term([{1,a},{2,b},{3,a}]),</span>
<span class="input">S2 = sofs:projection(2, S1),</span>
<span class="input">sofs:to_external(S2).</span>
[a,b]</pre><h2>range/1</h2><p>Return the range of a binary relation.</p><p>Returns the <a href="#range">range</a> of the
binary relation <strong><span class="anno">BinRel</span></strong>.</p><pre>
1&gt; <span class="input">R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]),</span>
<span class="input">S = sofs:range(R),</span>
<span class="input">sofs:to_external(S).</span>
[a,b,c]</pre><h2>relation/1</h2><h2>relation/2</h2><p>Create a relation.</p><p>Creates a <a href="#relation">relation</a>.
<strong>relation(R,Â T)</strong> is equivalent to
<strong>from_term(R,Â T)</strong>, if T is
a <a href="#type">type</a> and the result is a
relation. If <strong><span class="anno">Type</span></strong> is an integer N, then
<strong>[{atom,Â ...,Â atom}])</strong>, where the tuple size
is N, is used as type of the relation. If no type is
explicitly specified, the size of the first tuple of
<strong><span class="anno">Tuples</span></strong> is
used if there is such a tuple. <strong>relation([])</strong> is
equivalent to <strong>relation([],Â 2)</strong>.</p><h2>relation_to_family/1</h2><p>Create a family from a binary relation.</p><p>Returns <a href="#family">family</a>
<strong><span class="anno">Family</span></strong> such that the index set is equal to
the <a href="#domain">domain</a> of the binary
relation <strong><span class="anno">BinRel</span></strong>, and <strong><span class="anno">Family</span></strong>[i]
is the <a href="#image">image</a> of the set of i
under <strong><span class="anno">BinRel</span></strong>.</p><pre>
1&gt; <span class="input">R = sofs:relation([{b,1},{c,2},{c,3}]),</span>
<span class="input">F = sofs:relation_to_family(R),</span>
<span class="input">sofs:to_external(F).</span>
[{b,[1]},{c,[2,3]}]</pre><h2>relative_product/1</h2><h2>relative_product/2</h2><p>Return the relative product of a list of binary relations and a binary relation.</p><p>If <strong><span class="anno">ListOfBinRels</span></strong> is a non-empty list
[R[1],Â ...,Â R[n]] of binary relations and
<strong><span class="anno">BinRel1</span></strong>
is a binary relation, then <strong><span class="anno">BinRel2</span></strong> is the
<a href="#tuple_relative_product">relative product</a>
of the ordered set (R[i],Â ...,Â R[n]) and
<strong><span class="anno">BinRel1</span></strong>.</p><p>If <strong><span class="anno">BinRel1</span></strong> is omitted, the relation of equality
between the elements of
the <a href="#Cartesian_product_tuple">Cartesian product</a> of the ranges of R[i],
rangeÂ R[1]Â ÃÂ ...Â ÃÂ rangeÂ R[n],
is used instead (intuitively, nothing is "lost").</p><pre>
1&gt; <span class="input">TR = sofs:relation([{1,a},{1,aa},{2,b}]),</span>
<span class="input">R1 = sofs:relation([{1,u},{2,v},{3,c}]),</span>
<span class="input">R2 = sofs:relative_product([TR, R1]),</span>
<span class="input">sofs:to_external(R2).</span>
[{1,{a,u}},{1,{aa,u}},{2,{b,v}}]</pre><p>Notice that <strong>relative_product([R1],Â R2)</strong> is
different from <strong>relative_product(R1,Â R2)</strong>; the
list of one element is not identified with the element itself.</p><h2>relative_product/2</h2><p>Return the relative product of two binary relations.</p><p>Returns the <a href="#relative_product">relative product</a> of the binary relations <strong><span class="anno">BinRel1</span></strong>
and <strong><span class="anno">BinRel2</span></strong>.</p><h2>relative_product1/2</h2><p>Return the relative_product of two binary relations.</p><p>Returns the <a href="#relative_product">relative product</a> of
the <a href="#converse">converse</a> of the
binary relation <strong><span class="anno">BinRel1</span></strong> and the binary
relation <strong><span class="anno">BinRel2</span></strong>.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{1,a},{1,aa},{2,b}]),</span>
<span class="input">R2 = sofs:relation([{1,u},{2,v},{3,c}]),</span>
<span class="input">R3 = sofs:relative_product1(R1, R2),</span>
<span class="input">sofs:to_external(R3).</span>
[{a,u},{aa,u},{b,v}]</pre><p><strong>relative_product1(R1,Â R2)</strong> is equivalent to
<strong>relative_product(converse(R1),Â R2)</strong>.</p><h2>restriction/2</h2><p>Return a restriction of a binary relation.</p><p>Returns the <a href="#restriction">restriction</a> of
the binary relation <strong><span class="anno">BinRel1</span></strong>
to <strong><span class="anno">Set</span></strong>.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{1,a},{2,b},{3,c}]),</span>
<span class="input">S = sofs:set([1,2,4]),</span>
<span class="input">R2 = sofs:restriction(R1, S),</span>
<span class="input">sofs:to_external(R2).</span>
[{1,a},{2,b}]</pre><h2>restriction/3</h2><p>Return a restriction of a set.</p><p>Returns a subset of <strong><span class="anno">Set1</span></strong> containing those
elements that gives an element in <strong><span class="anno">Set2</span></strong> as the
result of applying <strong><span class="anno">SetFun</span></strong>.</p><pre>
1&gt; <span class="input">S1 = sofs:relation([{1,a},{2,b},{3,c}]),</span>
<span class="input">S2 = sofs:set([b,c,d]),</span>
<span class="input">S3 = sofs:restriction(2, S1, S2),</span>
<span class="input">sofs:to_external(S3).</span>
[{2,b},{3,c}]</pre><h2>set/1</h2><h2>set/2</h2><p>Create a set of atoms or any type of sets.</p><p>Creates an <a href="#sets_definition">unordered set</a>. <strong>set(L,Â T)</strong> is equivalent to
<strong>from_term(L,Â T)</strong>, if the result is an unordered
set. If no <a href="#type">type</a> is
explicitly specified, <strong>[atom]</strong> is used as the set type.</p><h2>specification/2</h2><p>Select a subset using a predicate.</p><p>Returns the set containing every element
of <strong><span class="anno">Set1</span></strong> for which <strong><span class="anno">Fun</span></strong>
returns <strong>true</strong>. If <strong><span class="anno">Fun</span></strong> is a tuple
<strong>{external,Â Fun2}</strong>, <strong>Fun2</strong> is applied to the
<a href="#external_set">external set</a> of
each element, otherwise <strong><span class="anno">Fun</span></strong> is applied to each
element.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{a,1},{b,2}]),</span>
<span class="input">R2 = sofs:relation([{x,1},{x,2},{y,3}]),</span>
<span class="input">S1 = sofs:from_sets([R1,R2]),</span>
<span class="input">S2 = sofs:specification(fun sofs:is_a_function/1, S1),</span>
<span class="input">sofs:to_external(S2).</span>
[[{a,1},{b,2}]]</pre><h2>strict_relation/1</h2><p>Return the strict relation corresponding to a given relation.</p><p>Returns the <a href="#strict_relation">strict relation</a> corresponding to the binary
relation <strong><span class="anno">BinRel1</span></strong>.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{1,1},{1,2},{2,1},{2,2}]),</span>
<span class="input">R2 = sofs:strict_relation(R1),</span>
<span class="input">sofs:to_external(R2).</span>
[{1,2},{2,1}]</pre><h2>substitution/2</h2><p>Return a function with a given set as domain.</p><p>Returns a function, the domain of which
is <strong><span class="anno">Set1</span></strong>. The value of an element of the domain
is the result of applying <strong><span class="anno">SetFun</span></strong> to the
element.</p><pre>
1&gt; <span class="input">L = [{a,1},{b,2}].</span>
[{a,1},{b,2}]
2&gt; <span class="input">sofs:to_external(sofs:projection(1,sofs:relation(L))).</span>
[a,b]
3&gt; <span class="input">sofs:to_external(sofs:substitution(1,sofs:relation(L))).</span>
[{{a,1},a},{{b,2},b}]
4&gt; <span class="input">SetFun = {external, fun({A,_}=E) -&gt; {E,A} end},</span>
<span class="input">sofs:to_external(sofs:projection(SetFun,sofs:relation(L))).</span>
[{{a,1},a},{{b,2},b}]</pre><p>The relation of equality between the elements of {a,b,c}:</p><pre>
1&gt; <span class="input">I = sofs:substitution(fun(A) -&gt; A end, sofs:set([a,b,c])),</span>
<span class="input">sofs:to_external(I).</span>
[{a,a},{b,b},{c,c}]</pre><p>Let <strong>SetOfSets</strong> be a set of sets and <strong>BinRel</strong> a binary
relation. The function that maps each element <strong>Set</strong> of
<strong>SetOfSets</strong> onto the <a href="#image">image</a>
of <strong>Set</strong> under <strong>BinRel</strong> is returned by the following
function:</p><pre>
images(SetOfSets, BinRel) -&gt;
   Fun = fun(Set) -&gt; sofs:image(BinRel, Set) end,
   sofs:substitution(Fun, SetOfSets).</pre><p>External unordered sets are represented as sorted lists. So,
creating the image of a set under a relation R can traverse all
elements of R (to that comes the sorting of results, the
image). In <a href="#image/2">image/2</a>,
<strong>BinRel</strong> is traversed once
for each element of <strong>SetOfSets</strong>, which can take too long. The
following efficient function can be used instead under the
assumption that the image of each element of <strong>SetOfSets</strong> under
<strong>BinRel</strong> is non-empty:</p><pre>
images2(SetOfSets, BinRel) -&gt;
   CR = sofs:canonical_relation(SetOfSets),
   R = sofs:relative_product1(CR, BinRel),
   sofs:relation_to_family(R).</pre><h2>symdiff/2</h2><p>Return the symmetric difference of two sets.</p><p>Returns the <a href="#symmetric_difference">symmetric difference</a> (or the Boolean sum)
of <strong><span class="anno">Set1</span></strong> and <strong><span class="anno">Set2</span></strong>.</p><pre>
1&gt; <span class="input">S1 = sofs:set([1,2,3]),</span>
<span class="input">S2 = sofs:set([2,3,4]),</span>
<span class="input">P = sofs:symdiff(S1, S2),</span>
<span class="input">sofs:to_external(P).</span>
[1,4]</pre><h2>symmetric_partition/2</h2><p>Return a partition of two sets.</p><p>Returns a triple of sets:</p><ul><li><strong><span class="anno">Set3</span></strong> contains the elements of <strong><span class="anno">Set1</span></strong> that do not belong to <strong><span class="anno">Set2</span></strong>. </li><li><strong><span class="anno">Set4</span></strong> contains the elements of <strong><span class="anno">Set1</span></strong> that belong to <strong><span class="anno">Set2</span></strong>. </li><li><strong><span class="anno">Set5</span></strong> contains the elements of <strong><span class="anno">Set2</span></strong> that do not belong to <strong><span class="anno">Set1</span></strong>. </li></ul><h2>to_external/1</h2><p>Return the elements of a set.</p><p>Returns the <a href="#external_set">external set</a> of an atomic, ordered, or unordered set.</p><h2>to_sets/1</h2><p>Return a list or a tuple of the elements of a set.</p><p>Returns the elements of the ordered set <strong><span class="anno">ASet</span></strong>
as a tuple of sets, and the elements of the unordered set
<strong><span class="anno">ASet</span></strong> as a sorted list of sets without
duplicates.</p><h2>type/1</h2><p>Return the type of a set.</p><p>Returns the <a href="#type">type</a> of an
atomic, ordered, or unordered set.</p><h2>union/1</h2><p>Return the union of a set of sets.</p><p>Returns the <a href="#union_n">union</a> of the
set of sets <strong><span class="anno">SetOfSets</span></strong>.</p><h2>union/2</h2><p>Return the union of two sets.</p><p>Returns the <a href="#union">union</a> of
<strong><span class="anno">Set1</span></strong> and <strong><span class="anno">Set2</span></strong>.</p><h2>union_of_family/1</h2><p>Return the union of a family.</p><p>Returns the union of <a href="#family">family</a>
<strong><span class="anno">Family</span></strong>.</p><pre>
1&gt; <span class="input">F = sofs:family([{a,[0,2,4]},{b,[0,1,2]},{c,[2,3]}]),</span>
<span class="input">S = sofs:union_of_family(F),</span>
<span class="input">sofs:to_external(S).</span>
[0,1,2,3,4]</pre><h2>weak_relation/1</h2><p>Return the weak relation corresponding to a given relation.</p><p>Returns a subset S of the <a href="#weak_relation">weak relation</a> W
corresponding to the binary relation <strong><span class="anno">BinRel1</span></strong>.
Let F be the <a href="#field">field</a> of
<strong><span class="anno">BinRel1</span></strong>. The
subset S is defined so that x S y if x W y for some x in F
and for some y in F.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{1,1},{1,2},{3,1}]),</span>
<span class="input">R2 = sofs:weak_relation(R1),</span>
<span class="input">sofs:to_external(R2).</span>
[{1,1},{1,2},{2,2},{3,1},{3,3}]</pre><h2>See Also</h2><p><a href="dict">dict</a>,
<a href="digraph">digraph</a>,
<a href="orddict">orddict</a>,
<a href="ordsets">ordsets</a>,
<a href="sets">sets</a></p></body></html>