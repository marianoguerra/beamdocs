<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>timer</h1><h1>timer</h1><p>Timer functions.</p><p>This module provides useful functions related to time. Unless otherwise
stated, time is always measured in <em>milliseconds</em>. All
timer functions return immediately, regardless of work done by another
process.Successful evaluations of the timer functions give return values
containing a timer reference, denoted <strong>TRef</strong>. By using
<a href="#cancel/1">cancel/1</a>,
the returned reference can be used to cancel any
requested action. A <strong>TRef</strong> is an Erlang term, which contents
must not be changed.The time-outs are not exact, but are <em>at least</em> as long
as requested.</p><h1>Data Types</h1><span class="name">time</span><p>Time in milliseconds.</p><span class="name">tref</span><p>A timer reference.</p><h1>Functions</h1><h2>apply_after/4</h2><p>Apply <strong>Module:Function(Arguments)</strong> after a specified <strong>Time</strong>.</p><p>Evaluates <strong>apply(<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Arguments</span>)</strong> after <strong><span class="anno">Time</span></strong>
milliseconds.</p><p>Returns <strong>{ok, <span class="anno">TRef</span>}</strong> or
<strong>{error, <span class="anno">Reason</span>}</strong>.</p><h2>apply_interval/4</h2><p>Evaluate <strong>Module:Function(Arguments)</strong> repeatedly at intervals of <strong>Time</strong>.</p><p>Evaluates <strong>apply(<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Arguments</span>)</strong> repeatedly at intervals of
<strong><span class="anno">Time</span></strong>.</p><p>Returns <strong>{ok, <span class="anno">TRef</span>}</strong> or
<strong>{error, <span class="anno">Reason</span>}</strong>.</p><h2>cancel/1</h2><p>Cancel a previously requested time-out identified by <strong>TRef</strong>.</p><p>Cancels a previously requested time-out. <strong><span class="anno">TRef</span></strong> is
a unique
timer reference returned by the related timer function.</p><p>Returns <strong>{ok, cancel}</strong>, or <strong>{error, <span class="anno">Reason</span>}</strong>
when <strong><span class="anno">TRef</span></strong> is not a timer reference.</p><h2>exit_after/2</h2><h2>exit_after/3</h2><p>Send an exit signal with <strong>Reason</strong> after a specified <strong>Time</strong>.</p><p><strong>exit_after/2</strong> is the same as
<strong>exit_after(<span class="anno">Time</span>, self(), <span class="anno">Reason1</span>)</strong>.</p><p><strong>exit_after/3</strong> sends an exit signal with reason
<strong><span class="anno">Reason1</span></strong> to
pid <strong><span class="anno">Pid</span></strong>. Returns <strong>{ok, <span class="anno">TRef</span>}</strong>
or <strong>{error, <span class="anno">Reason2</span>}</strong>.</p><h2>hms/3</h2><p>Convert <strong>Hours</strong>+<strong>Minutes</strong>+<strong>Seconds</strong> to <strong>Milliseconds</strong>.</p><p>Returns the number of milliseconds in <strong><span class="anno">Hours</span> + <span class="anno">Minutes</span> + <span class="anno">Seconds</span></strong>.</p><h2>hours/1</h2><p>Convert <strong>Hours</strong> to <strong>Milliseconds</strong>.</p><p>Returns the number of milliseconds in <strong><span class="anno">Hours</span></strong>.</p><h2>kill_after/1</h2><h2>kill_after/2</h2><p>Send an exit signal with <strong>Reason</strong> after a specified <strong>Time</strong>.</p><p><strong>kill_after/1</strong> is the same as
<strong>exit_after(<span class="anno">Time</span>, self(), kill)</strong>.</p><p><strong>kill_after/2</strong> is the same as
<strong>exit_after(<span class="anno">Time</span>, <span class="anno">Pid</span>, kill)</strong>.</p><h2>minutes/1</h2><p>Converts <strong>Minutes</strong> to <strong>Milliseconds</strong>.</p><p>Returns the number of milliseconds in
<strong><span class="anno">Minutes</span></strong>.</p><h2>now_diff/2</h2><p>Calculate time difference between time stamps.</p><dl><dt>Tdiff</dt><dd>In microseconds</dd></dl><p>Calculates the time difference <strong><span class="anno">Tdiff</span> = <span class="anno">T2</span> - <span class="anno">T1</span></strong> in <em>microseconds</em>,
where <strong><span class="anno">T1</span></strong> and <strong><span class="anno">T2</span></strong>
are time-stamp tuples on the same format as returned from
<a href="../erts/erlang#timestamp/0">erts/erlang#timestamp/0</a> or
<a href="../kernel/os#timestamp/0">kernel/os#timestamp/0</a>.</p><h2>seconds/1</h2><p>Convert <strong>Seconds</strong> to <strong>Milliseconds</strong>.</p><p>Returns the number of milliseconds in
<strong><span class="anno">Seconds</span></strong>.</p><h2>send_after/2</h2><h2>send_after/3</h2><p>Send <strong>Message</strong> to <strong>Pid</strong> after a specified <strong>Time</strong>.</p><dl><dt><strong>send_after/3</strong></dt><dd> <p>Evaluates <strong><span class="anno">Pid</span> ! <span class="anno">Message</span></strong> after
<strong><span class="anno">Time</span></strong> milliseconds. (<strong><span class="anno">Pid</span></strong>
can also be an atom of a registered name.)</p> <p>Returns <strong>{ok, <span class="anno">TRef</span>}</strong> or
<strong>{error, <span class="anno">Reason</span>}</strong>.</p> </dd><dt><strong>send_after/2</strong></dt><dd> <p>Same as <strong>send_after(<span class="anno">Time</span>, self(), <span class="anno">Message</span>)</strong>.</p> </dd></dl><h2>send_interval/2</h2><h2>send_interval/3</h2><p>Send <strong>Message</strong> repeatedly at intervals of <strong>Time</strong>. </p><dl><dt><strong>send_interval/3</strong></dt><dd> <p>Evaluates <strong><span class="anno">Pid</span> ! <span class="anno">Message</span></strong>
repeatedly after <strong><span class="anno">Time</span></strong> milliseconds.
(<strong><span class="anno">Pid</span></strong> can also be
an atom of a registered name.)</p> <p>Returns <strong>{ok, <span class="anno">TRef</span>}</strong> or
<strong>{error, <span class="anno">Reason</span>}</strong>.</p> </dd><dt><strong>send_interval/2</strong></dt><dd> <p>Same as <strong>send_interval(<span class="anno">Time</span>, self(), <span class="anno">Message</span>)</strong>.</p> </dd></dl><h2>sleep/1</h2><p>Suspend the calling process for <strong>Time</strong> milliseconds. </p><p>Suspends the process calling this function for
<strong><span class="anno">Time</span></strong> milliseconds and then returns <strong>ok</strong>,
or suspends the process forever if <strong><span class="anno">Time</span></strong> is the
atom <strong>infinity</strong>. Naturally, this
function does <em>not</em> return immediately.</p><h2>start/0</h2><p>Start a global timer server (named <strong>timer_server</strong>). </p><p>Starts the timer server. Normally, the server does not need
to be started explicitly. It is started dynamically if it
is needed. This is useful during development, but in a
target system the server is to be started explicitly. Use
configuration parameters for
<a href="./index">Kernel</a> for this.</p><h2>tc/1</h2><h2>tc/2</h2><h2>tc/3</h2><p>Measure the real time it takes to evaluate <strong>apply(Module, Function, Arguments)</strong> or <strong>apply(Fun, Arguments)</strong>.</p><dl><dt>Time</dt><dd>In microseconds</dd></dl><dl><dt><strong>tc/3</strong></dt><dd> <p>Evaluates <strong>apply(<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Arguments</span>)</strong> and measures the elapsed real time as 
reported by <a href="../erts/erlang#monotonic_time/0">erts/erlang#monotonic_time/0</a>.</p> <p>Returns <strong>{<span class="anno">Time</span>, <span class="anno">Value</span>}</strong>, where
<strong><span class="anno">Time</span></strong> is the elapsed real time in
<em>microseconds</em>, and <strong><span class="anno">Value</span></strong> is what is
returned from the apply.</p> </dd><dt><strong>tc/2</strong></dt><dd> <p>Evaluates <strong>apply(<span class="anno">Fun</span>, <span class="anno">Arguments</span>)</strong>.
Otherwise the same as <strong>tc/3</strong>.</p> </dd><dt><strong>tc/1</strong></dt><dd> <p>Evaluates <strong><span class="anno">Fun</span>()</strong>. Otherwise the same as
<strong>tc/2</strong>.</p> </dd></dl><h2>Examples</h2><p><em>Example 1</em></p><p>The following example shows how to print "Hello World!" in 5 seconds:</p><pre>
1&gt; <span class="input">timer:apply_after(5000, io, format, ["~nHello World!~n", []]).</span>
{ok,TRef}
Hello World!</pre><p><em>Example 2</em></p><p>The following example shows a process performing a 
certain action, and if this action is not completed within a certain 
limit, the process is killed:</p><pre><code class="">
Pid = spawn(mod, fun, [foo, bar]),
%% If pid is not finished in 10 seconds, kill him
{ok, R} = timer:kill_after(timer:seconds(10), Pid),
...
%% We change our mind...
timer:cancel(R),
...</code></pre><h2>Notes</h2><p>A timer can always be removed by calling
<a href="#cancel/1">cancel/1</a>.</p><p>An interval timer, that is, a timer created by evaluating any of the
functions
<a href="#apply_interval/4">apply_interval/4</a>,
<a href="#send_interval/3">send_interval/3</a>, and
<a href="#send_interval/2">send_interval/2</a>
is linked to the process to which the timer performs its task.</p><p>A one-shot timer, that is, a timer created by evaluating any of the
functions
<a href="#apply_after/4">apply_after/4</a>,
<a href="#send_after/3">send_after/3</a>,
<a href="#send_after/2">send_after/2</a>,
<a href="#exit_after/3">exit_after/3</a>,
<a href="#exit_after/2">exit_after/2</a>,
<a href="#kill_after/2">kill_after/2</a>, and
<a href="#kill_after/1">kill_after/1</a>
is not linked to any process. Hence, such a timer is removed only
when it reaches its time-out, or if it is explicitly removed by a call to
<a href="#cancel/1">cancel/1</a>.</p></body></html>