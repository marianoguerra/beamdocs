<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>The Erlang I/O Protocol</h1><p>The I/O protocol in Erlang enables bi-directional communication between
clients and servers.</p><ul><li> <p>The I/O server is a process that handles the requests and performs
the requested task on, for example, an I/O device.</p> </li><li> <p>The client is any Erlang process wishing to read or write data from/to
the I/O device.</p> </li></ul><p>The common I/O protocol has been present in OTP since the beginning, but
has been undocumented and has also evolved over the years. In an
addendum to Robert Virding's rationale, the original I/O protocol is
described. This section describes the current I/O protocol.</p><p>The original I/O protocol was simple and flexible. Demands for memory
efficiency and execution time efficiency have triggered extensions
to the protocol over the years, making the protocol larger and somewhat
less easy to implement than the original. It can certainly be argued that
the current protocol is too complex, but this section describes how it
looks today, not how it should have looked.</p><p>The basic ideas from the original protocol still hold. The I/O server
and client communicate with one single, rather simplistic protocol and no
server state is ever present in the client. Any I/O server can be used
together with any client code, and the client code does not need to be
aware of the I/O device that the I/O server communicates with.</p><h2>Protocol Basics</h2><p>As described in Robert's paper, I/O servers and clients communicate
using <strong>io_request</strong>/<strong>io_reply</strong> tuples as follows:</p><pre>
{io_request, From, ReplyAs, Request}
{io_reply, ReplyAs, Reply}</pre><p>The client sends an <strong>io_request</strong> tuple to the I/O server and the
server eventually sends a corresponding <strong>io_reply</strong> tuple.</p><ul><li> <p><strong>From</strong> is the <strong>pid()</strong> of the client, the process which
the I/O server sends the I/O reply to.</p> </li><li> <p><strong>ReplyAs</strong> can be any datum and is returned in the
corresponding <strong>io_reply</strong>. The
<a href="./io">stdlib/io</a> module monitors the
the I/O server and uses the monitor reference as the <strong>ReplyAs</strong>
datum. A more complicated client can have many outstanding I/O
requests to the same I/O server and can use different references (or
something else) to differentiate among the incoming I/O replies.
Element <strong>ReplyAs</strong> is to be considered opaque by the I/O
server.</p> <p>Notice that the <strong>pid()</strong> of the I/O server is not explicitly
present in tuple <strong>io_reply</strong>. The reply can be sent from any
process, not necessarily the actual I/O server.</p> </li><li> <p><strong>Request</strong> and <strong>Reply</strong> are described below.</p> </li></ul><p>When an I/O server receives an <strong>io_request</strong> tuple, it acts upon the
<strong>Request</strong> part and eventually sends an <strong>io_reply</strong> tuple with
the corresponding <strong>Reply</strong> part.</p><h2>Output Requests</h2><p>To output characters on an I/O device, the following <strong>Request</strong>s
exist:</p><pre>
{put_chars, Encoding, Characters}
{put_chars, Encoding, Module, Function, Args}</pre><ul><li> <p><strong>Encoding</strong> is <strong>unicode</strong> or <strong>latin1</strong>, meaning that the
characters are (in case of binaries) encoded as UTF-8 or ISO Latin-1
(pure bytes). A well-behaved I/O server is also to return an error
indication if list elements contain integers &gt; 255
when <strong>Encoding</strong> is set to <strong>latin1</strong>.</p> <p>Notice that this does not in any way tell how characters are to be
put on the I/O device or handled by the I/O server. Different I/O
servers can handle the characters however they want, this only tells
the I/O server which format the data is expected to have. In the
<strong>Module</strong>/<strong>Function</strong>/<strong>Args</strong> case, <strong>Encoding</strong> tells
which format the designated function produces.</p> <p>Notice also that byte-oriented data is simplest sent using the ISO
Latin-1 encoding.</p> </li><li> <p><strong>Characters</strong> are the data to be put on the I/O device. If
<strong>Encoding</strong> is <strong>latin1</strong>, this is an <strong>iolist()</strong>. If
<strong>Encoding</strong> is <strong>unicode</strong>, this is an Erlang standard mixed
Unicode list (one integer in a list per character, characters in
binaries represented as UTF-8).</p> </li><li> <p><strong>Module</strong>, <strong>Function</strong>, and <strong>Args</strong> denote a function
that is called to produce the data (like
<a href="../stdlib/io_lib#format/2">stdlib/io_lib#format/2</a>).
</p> <p><strong>Args</strong> is a list of arguments to the function. The function is
to produce data in the specified <strong>Encoding</strong>. The I/O server is
to call the function as <strong>apply(Mod, Func, Args)</strong> and put the
returned data on the I/O device as if it was sent in a
<strong>{put_chars, Encoding, Characters}</strong> request. If the function
returns anything else than a binary or list, or throws an exception,
an error is to be sent back to the client.</p> </li></ul><p>The I/O server replies to the client with an <strong>io_reply</strong> tuple, where
element <strong>Reply</strong> is one of:</p><pre>
ok
{error, Error}</pre><ul><li><strong>Error</strong> describes the error to the client, which can do whatever it wants with it. The <a href="./io">stdlib/io</a> module typically returns it "as is".</li></ul><p>For backward compatibility, the following <strong>Request</strong>s are also to be
handled by an I/O server (they are not to be present after
Erlang/OTP R15B):</p><pre>
{put_chars, Characters}
{put_chars, Module, Function, Args}</pre><p>These are to behave as <strong>{put_chars, latin1, Characters}</strong> and
<strong>{put_chars, latin1, Module, Function, Args}</strong>, respectively.</p><h2>Input Requests</h2><p>To read characters from an I/O device, the following <strong>Request</strong>s
exist:</p><pre>
{get_until, Encoding, Prompt, Module, Function, ExtraArgs}</pre><ul><li> <p><strong>Encoding</strong> denotes how data is to be sent back to the client
and what data is sent to the function denoted by
<strong>Module</strong>/<strong>Function</strong>/<strong>ExtraArgs</strong>. If the function
supplied returns data as a list, the data is converted to this
encoding. If the function supplied returns data in some other format,
no conversion can be done, and it is up to the client-supplied
function to return data in a proper way.</p> <p>If <strong>Encoding</strong> is <strong>latin1</strong>, lists of integers <strong>0..255</strong>
or binaries containing plain bytes are sent back to the client when
possible. If <strong>Encoding</strong> is <strong>unicode</strong>, lists with integers
in the whole Unicode range or binaries encoded in UTF-8 are sent to
the client. The user-supplied function always sees lists of
integers, never binaries, but the list can contain numbers &gt; 255
if <strong>Encoding</strong> is <strong>unicode</strong>.</p> </li><li> <p><strong>Prompt</strong> is a list of characters (not mixed, no binaries) or an
atom to be output as a prompt for input on the I/O device.
<strong>Prompt</strong> is often ignored by the I/O server; if set to <strong>''</strong>,
it is always to be ignored (and results in nothing being written to
the I/O device).</p> </li><li> <p><strong>Module</strong>, <strong>Function</strong>, and <strong>ExtraArgs</strong> denote a
function and arguments to determine when enough data is written. The
function is to take two more arguments, the last state, and a list of
characters. The function is to return one of:</p> <pre>
{done, Result, RestChars}
{more, Continuation}</pre> <p><strong>Result</strong> can be any Erlang term, but if it is a <strong>list()</strong>,
the I/O server can convert it to a <strong>binary()</strong> of appropriate
format before returning it to the client, if the I/O server is set in
binary mode (see below).</p> <p>The function is called with the data the I/O server finds on its I/O
device, returning one of:</p> <ul><li> <p><strong>{done, Result, RestChars}</strong> when enough data is read. In
this case <strong>Result</strong> is sent to the client and <strong>RestChars</strong>
is kept in the I/O server as a buffer for later input.</p> </li><li> <p><strong>{more, Continuation}</strong>, which indicates that more
characters are needed to complete the request.</p> </li></ul> <p><strong>Continuation</strong> is sent as the state in later calls to the
function when more characters are available. When no more characters
are available, the function must return <strong>{done, eof, Rest}</strong>. The
initial state is the empty list. The data when an end of file is
reached on the IO device is the atom <strong>eof</strong>.</p> <p>An emulation of the <strong>get_line</strong> request can be (inefficiently)
implemented using the following functions:</p> <pre><code class="">
-module(demo).
-export([until_newline/3, get_line/1]).

until_newline(_ThisFar,eof,_MyStopCharacter) -&gt;
    {done,eof,[]};
until_newline(ThisFar,CharList,MyStopCharacter) -&gt;
    case
        lists:splitwith(fun(X) -&gt; X =/= MyStopCharacter end,  CharList)
    of
	{L,[]} -&gt;
            {more,ThisFar++L};
	{L2,[MyStopCharacter|Rest]} -&gt;
	    {done,ThisFar++L2++[MyStopCharacter],Rest}
    end.

get_line(IoServer) -&gt;
    IoServer ! {io_request,
                self(),
                IoServer,
                {get_until, unicode, '', ?MODULE, until_newline, [$\n]}},
    receive
        {io_reply, IoServer, Data} -&gt;
	    Data
    end.</code></pre> <p>Notice that the last element in the <strong>Request</strong> tuple
(<strong>[$\n]</strong>) is appended to the argument list when the function is
called. The function is to be called like
<strong>apply(Module, Function, [ State, Data | ExtraArgs ])</strong> by the
I/O server.</p> </li></ul><p>A fixed number of characters is requested using the following
<strong>Request</strong>:</p><pre>
{get_chars, Encoding, Prompt, N}</pre><ul><li> <p><strong>Encoding</strong> and <strong>Prompt</strong> as for <strong>get_until</strong>.</p> </li><li> <p><strong>N</strong> is the number of characters to be read from the I/O
device.</p> </li></ul><p>A single line (as in former example) is requested with the
following <strong>Request</strong>:</p><pre>
{get_line, Encoding, Prompt}</pre><ul><li><strong>Encoding</strong> and <strong>Prompt</strong> as for <strong>get_until</strong>.</li></ul><p>Clearly, <strong>get_chars</strong> and <strong>get_line</strong> could be implemented with
the <strong>get_until</strong> request (and indeed they were originally), but
demands for efficiency have made these additions necessary.</p><p>The I/O server replies to the client with an <strong>io_reply</strong> tuple, where
element <strong>Reply</strong> is one of:</p><pre>
Data
eof
{error, Error}</pre><ul><li> <p><strong>Data</strong> is the characters read, in list or binary form
(depending on the I/O server mode, see the next section).</p> </li><li> <p><strong>eof</strong> is returned when input end is reached and no more data is
available to the client process.</p> </li><li> <p><strong>Error</strong> describes the error to the client, which can do
whatever it wants with it. The
<a href="./io">stdlib/io</a> module typically
returns it as is.</p> </li></ul><p>For backward compatibility, the following <strong>Request</strong>s are also to be
handled by an I/O server (they are not to be present after
Erlang/OTP R15B):</p><pre>
{get_until, Prompt, Module, Function, ExtraArgs}
{get_chars, Prompt, N}
{get_line, Prompt}</pre><p>These are to behave as
<strong>{get_until, latin1, Prompt, Module, Function, ExtraArgs}</strong>,
<strong>{get_chars, latin1, Prompt, N}</strong>, and
<strong>{get_line, latin1, Prompt}</strong>, respectively.</p><h2>I/O Server Modes</h2><p>Demands for efficiency when reading data from an I/O server has not only
lead to the addition of the <strong>get_line</strong> and <strong>get_chars</strong> requests,
but has also added the concept of I/O server options. No options are
mandatory to implement, but all I/O servers in the Erlang standard
libraries honor the <strong>binary</strong> option, which allows element
<strong>Data</strong> of the <strong>io_reply</strong> tuple to be a binary instead of a list
<em>when possible</em>. If the data is sent as a binary, Unicode data is
sent in the standard Erlang Unicode format, that is, UTF-8 (notice that
the function of the <strong>get_until</strong> request still gets list data
regardless of the I/O server mode).</p><p>Notice that the <strong>get_until</strong> request allows for a function with the
data specified as always being a list. Also, the return value data from
such a function can be of any type (as is indeed the case when an
<a href="../stdlib/io#fread/2">stdlib/io#fread/2</a>
request is sent to an I/O server).
The client must be prepared for data received as
answers to those requests to be in various forms. However, the I/O
server is to convert the results to binaries whenever possible (that is,
when the function supplied to <strong>get_until</strong> returns a list). This is
done in the example in section
<a href="#example_io_server">An Annotated and Working Example I/O Server</a>.
</p><p>An I/O server in binary mode affects the data sent to the client, so that
it must be able to handle binary data. For convenience, the modes of an
I/O server can be set and retrieved using the following I/O requests:</p><pre>
{setopts, Opts}</pre><ul><li><strong>Opts</strong> is a list of options in the format recognized by the <a href="./proplists">stdlib/proplists</a> module (and by the I/O server).</li></ul><p>As an example, the I/O server for the interactive shell (in
<strong>group.erl</strong>) understands the following options:</p><pre>
{binary, boolean()} (or binary/list)
{echo, boolean()}
{expand_fun, fun()}
{encoding, unicode/latin1} (or unicode/latin1)</pre><p>Options <strong>binary</strong> and <strong>encoding</strong> are common for all I/O servers
in OTP, while <strong>echo</strong> and <strong>expand</strong> are valid only for this I/O
server. Option <strong>unicode</strong> notifies how characters are put on the
physical I/O device, that is, if the terminal itself is Unicode-aware.
It does not affect how characters are sent in the I/O protocol, where
each request contains encoding information for the provided or returned
data.</p><p>The I/O server is to send one of the following as <strong>Reply</strong>:</p><pre>
ok
{error, Error}</pre><p>An error (preferably <strong>enotsup</strong>) is to be expected if the option is
not supported by the I/O server (like if an <strong>echo</strong> option is sent in
a <strong>setopts</strong> request to a plain file).</p><p>To retrieve options, the following request is used:</p><pre>
getopts</pre><p>This request asks for a complete list of all options supported by the
I/O server as well as their current values.</p><p>The I/O server replies:</p><pre>
OptList
{error, Error}</pre><ul><li><strong>OptList</strong> is a list of tuples <strong>{Option, Value}</strong>, where <strong>Option</strong> always is an atom.</li></ul><h2>Multiple I/O Requests</h2><p>The <strong>Request</strong> element can in itself contain many <strong>Request</strong>s
by using the following format:</p><pre>
{requests, Requests}</pre><ul><li><strong>Requests</strong> is a list of valid <strong>io_request</strong> tuples for the protocol. They must be executed in the order that they appear in the list. The execution is to continue until one of the requests results in an error or the list is consumed. The result of the last request is sent back to the client.</li></ul><p>The I/O server can, for a list of requests, send any of the following
valid results in the reply, depending on the requests in the list:</p><pre>
ok
{ok, Data}
{ok, Options}
{error, Error}</pre><h2>Optional I/O Request</h2><p>The following I/O request is optional to implement and a client is to
be prepared for an error return:</p><pre>
{get_geometry, Geometry}</pre><ul><li><strong>Geometry</strong> is the atom <strong>rows</strong> or the atom <strong>columns</strong>.</li></ul><p>The I/O server is to send the <strong>Reply</strong> as:</p><pre>
{ok, N}
{error, Error}</pre><ul><li><strong>N</strong> is the number of character rows or columns that the I/O device has, if applicable to the I/O device handled by the I/O server, otherwise <strong>{error, enotsup}</strong> is a good answer.</li></ul><h2>Unimplemented Request Types</h2><p>If an I/O server encounters a request that it does not recognize (that
is, the <strong>io_request</strong> tuple has the expected format, but the
<strong>Request</strong> is unknown), the I/O server is to send a valid reply with
the error tuple:</p><pre>
{error, request}</pre><p>This makes it possible to extend the protocol with optional requests
and for the clients to be somewhat backward compatible.</p><h2>An Annotated and Working Example I/O Server</h2><a name="example_io_server"></a><p>An I/O server is any process capable of handling the I/O protocol. There
is no generic I/O server behavior, but could well be. The framework is
simple, a process handling incoming requests, usually both I/O-requests
and other I/O device-specific requests (positioning, closing, and so on).
</p><p>The example I/O server stores characters in an ETS table, making
up a fairly crude RAM file.</p><p>The module begins with the usual directives, a function to start the
I/O server and a main loop handling the requests:</p><pre><code class="">
-module(ets_io_server).

-export([start_link/0, init/0, loop/1, until_newline/3, until_enough/3]).

-define(CHARS_PER_REC, 10).

-record(state, {
	  table,
	  position, % absolute
	  mode % binary | list
	 }).

start_link() -&gt;
    spawn_link(?MODULE,init,[]).

init() -&gt;
    Table = ets:new(noname,[ordered_set]),
    ?MODULE:loop(#state{table = Table, position = 0, mode=list}).

loop(State) -&gt;
    receive
	{io_request, From, ReplyAs, Request} -&gt;
	    case request(Request,State) of
		{Tag, Reply, NewState} when Tag =:= ok; Tag =:= error -&gt;
		    reply(From, ReplyAs, Reply),
		    ?MODULE:loop(NewState);
		{stop, Reply, _NewState} -&gt;
		    reply(From, ReplyAs, Reply),
		    exit(Reply)
	    end;
	%% Private message
	{From, rewind} -&gt;
	    From ! {self(), ok},
	    ?MODULE:loop(State#state{position = 0});
	_Unknown -&gt;
	    ?MODULE:loop(State)
    end.</code></pre><p>The main loop receives messages from the client (which can use the
the <a href="./io">stdlib/io</a> module to send
requests). For each request, the function <strong>request/2</strong> is called and a
reply is eventually sent using function <strong>reply/3</strong>.</p><p>The "private" message <strong>{From, rewind}</strong> results in the
current position in the pseudo-file to be reset to <strong>0</strong> (the beginning
of the "file"). This is a typical example of I/O device-specific
messages not being part of the I/O protocol. It is usually a bad idea to
embed such private messages in <strong>io_request</strong> tuples, as that can
confuse the reader.</p><p>First, we examine the reply function:</p><pre><code class="">
reply(From, ReplyAs, Reply) -&gt;
    From ! {io_reply, ReplyAs, Reply}.</code></pre><p>It sends the <strong>io_reply</strong> tuple back to the client, providing element
<strong>ReplyAs</strong> received in the request along with the result of the
request, as described earlier.</p><p>We need to handle some requests. First the requests for writing
characters:</p><pre><code class="">
request({put_chars, Encoding, Chars}, State) -&gt;
    put_chars(unicode:characters_to_list(Chars,Encoding),State);
request({put_chars, Encoding, Module, Function, Args}, State) -&gt;
    try
	request({put_chars, Encoding, apply(Module, Function, Args)}, State)
    catch
	_:_ -&gt;
	    {error, {error,Function}, State}
    end;</code></pre><p>The <strong>Encoding</strong> says how the characters in the request are
represented. We want to store the characters as lists in the ETS
table, so we convert them to lists using function
<a href="../stdlib/unicode#characters_to_list/2">stdlib/unicode#characters_to_list/2</a>.
The conversion function conveniently accepts the encoding types
<strong>unicode</strong> and <strong>latin1</strong>, so we can use <strong>Encoding</strong> directly.</p><p>When <strong>Module</strong>, <strong>Function</strong>, and <strong>Arguments</strong> are provided,
we apply it and do the same with the result as if the data was provided
directly.</p><p>We handle the requests for retrieving data:</p><pre><code class="">
request({get_until, Encoding, _Prompt, M, F, As}, State) -&gt;
    get_until(Encoding, M, F, As, State);
request({get_chars, Encoding, _Prompt, N}, State) -&gt;
    %% To simplify the code, get_chars is implemented using get_until
    get_until(Encoding, ?MODULE, until_enough, [N], State);
request({get_line, Encoding, _Prompt}, State) -&gt;
    %% To simplify the code, get_line is implemented using get_until
    get_until(Encoding, ?MODULE, until_newline, [$\n], State);</code></pre><p>Here we have cheated a little by more or less only implementing
<strong>get_until</strong> and using internal helpers to implement <strong>get_chars</strong>
and <strong>get_line</strong>. In production code, this can be inefficient, but
that depends on the frequency of the different requests. Before we start
implementing functions <strong>put_chars/2</strong> and <strong>get_until/5</strong>, we
examine the few remaining requests:</p><pre><code class="">
request({get_geometry,_}, State) -&gt;
    {error, {error,enotsup}, State};
request({setopts, Opts}, State) -&gt;
    setopts(Opts, State);
request(getopts, State) -&gt;
    getopts(State);
request({requests, Reqs}, State) -&gt;
     multi_request(Reqs, {ok, ok, State});</code></pre><p>Request <strong>get_geometry</strong> has no meaning for this I/O server, so the
reply is <strong>{error, enotsup}</strong>. The only option we handle is
<strong>binary</strong>/<strong>list</strong>, which is done in separate functions.</p><p>The multi-request tag (<strong>requests</strong>) is handled in a separate loop
function applying the requests in the list one after another, returning
the last result.</p><p>We need to handle backward compatibility and the
<a href="./file">kernel/file</a> module (which
uses the old requests until backward compatibility with pre-R13 nodes is
no longer needed). Notice that the I/O server does not work with a simple
<strong>file:write/2</strong> if these are not added:</p><pre><code class="">
request({put_chars,Chars}, State) -&gt;
    request({put_chars,latin1,Chars}, State);
request({put_chars,M,F,As}, State) -&gt;
    request({put_chars,latin1,M,F,As}, State);
request({get_chars,Prompt,N}, State) -&gt;
    request({get_chars,latin1,Prompt,N}, State);
request({get_line,Prompt}, State) -&gt;
    request({get_line,latin1,Prompt}, State);
request({get_until, Prompt,M,F,As}, State) -&gt;
    request({get_until,latin1,Prompt,M,F,As}, State);</code></pre><p><strong>{error, request}</strong> must be returned if the request is not
recognized:</p><pre><code class="">
request(_Other, State) -&gt;
    {error, {error, request}, State}.</code></pre><p>Next we handle the different requests, first the fairly generic
multi-request type:</p><pre><code class="">
multi_request([R|Rs], {ok, _Res, State}) -&gt;
    multi_request(Rs, request(R, State));
multi_request([_|_], Error) -&gt;
    Error;
multi_request([], Result) -&gt;
    Result.</code></pre><p>We loop through the requests one at the time, stopping when we either
encounter an error or the list is exhausted. The last return value is
sent back to the client (it is first returned to the main loop and then
sent back by function <strong>io_reply</strong>).</p><p>Requests <strong>getopts</strong> and <strong>setopts</strong> are also simple to handle.
We only change or read the state record:</p><pre><code class="">
setopts(Opts0,State) -&gt;
    Opts = proplists:unfold(
	     proplists:substitute_negations(
	       [{list,binary}], 
	       Opts0)),
    case check_valid_opts(Opts) of
	true -&gt;
	        case proplists:get_value(binary, Opts) of
		    true -&gt;
			{ok,ok,State#state{mode=binary}};
		    false -&gt;
			{ok,ok,State#state{mode=binary}};
		    _ -&gt;
			{ok,ok,State}
		end;
	false -&gt;
	    {error,{error,enotsup},State}
    end.
check_valid_opts([]) -&gt;
    true;
check_valid_opts([{binary,Bool}|T]) when is_boolean(Bool) -&gt;
    check_valid_opts(T);
check_valid_opts(_) -&gt;
    false.

getopts(#state{mode=M} = S) -&gt;
    {ok,[{binary, case M of
		      binary -&gt;
			  true;
		      _ -&gt;
			  false
		  end}],S}.</code></pre><p>As a convention, all I/O servers handle both <strong>{setopts, [binary]}</strong>,
<strong>{setopts, [list]}</strong>, and <strong>{setopts,[{binary, boolean()}]}</strong>,
hence the trick with <strong>proplists:substitute_negations/2</strong> and
<strong>proplists:unfold/1</strong>. If invalid options are sent to us, we send
<strong>{error, enotsup}</strong> back to the client.</p><p>Request <strong>getopts</strong> is to return a list of <strong>{Option, Value}</strong>
tuples. This has the twofold function of providing both the current values
and the available options of this I/O server. We have only one option, and
hence return that.</p><p>So far this I/O server is fairly generic (except for request
<strong>rewind</strong> handled in the main loop and the creation of an ETS
table). Most I/O servers contain code similar to this one.</p><p>To make the example runnable, we start implementing the reading and
writing of the data to/from the ETS table. First function
<strong>put_chars/3</strong>:</p><pre><code class="">
put_chars(Chars, #state{table = T, position = P} = State) -&gt;
    R = P div ?CHARS_PER_REC,
    C = P rem ?CHARS_PER_REC,
    [ apply_update(T,U) || U &lt;- split_data(Chars, R, C) ],
    {ok, ok, State#state{position = (P + length(Chars))}}.</code></pre><p>We already have the data as (Unicode) lists and therefore only split
the list in runs of a predefined size and put each run in the table at
the current position (and forward). Functions <strong>split_data/3</strong> and
<strong>apply_update/2</strong> are implemented below.</p><p>Now we want to read data from the table. Function <strong>get_until/5</strong>
reads data and applies the function until it says that it is done. The
result is sent back to the client:</p><pre><code class="">
get_until(Encoding, Mod, Func, As, 
	  #state{position = P, mode = M, table = T} = State) -&gt;
    case get_loop(Mod,Func,As,T,P,[]) of
	{done,Data,_,NewP} when is_binary(Data); is_list(Data) -&gt;
	    if
		M =:= binary -&gt; 
		    {ok, 
		     unicode:characters_to_binary(Data, unicode, Encoding),
		     State#state{position = NewP}};
		true -&gt;
		    case check(Encoding, 
		               unicode:characters_to_list(Data, unicode))
                    of
			{error, _} = E -&gt;
			    {error, E, State};
			List -&gt;
			    {ok, List,
			     State#state{position = NewP}}
		    end
	    end;
	{done,Data,_,NewP} -&gt;
	    {ok, Data, State#state{position = NewP}};
	Error -&gt;
	    {error, Error, State}
    end.

get_loop(M,F,A,T,P,C) -&gt;
    {NewP,L} = get(P,T),
    case catch apply(M,F,[C,L|A]) of
	{done, List, Rest} -&gt;
	    {done, List, [], NewP - length(Rest)};
	{more, NewC} -&gt;
	    get_loop(M,F,A,T,NewP,NewC);
	_ -&gt;
	    {error,F}
    end.</code></pre><p>Here we also handle the mode (<strong>binary</strong> or <strong>list</strong>) that can be
set by request <strong>setopts</strong>. By default, all OTP I/O servers send data
back to the client as lists, but switching mode to <strong>binary</strong> can
increase efficiency if the I/O server handles it in an appropriate way.
The implementation of <strong>get_until</strong> is difficult to get efficient, as
the supplied function is defined to take lists as arguments, but
<strong>get_chars</strong> and <strong>get_line</strong> can be optimized for binary mode.
However, this example does not optimize anything.</p><p>It is important though that the returned data is of the correct type
depending on the options set. We therefore convert the lists to binaries
in the correct encoding <em>if possible</em> before returning. The
function supplied in the <strong>get_until</strong> request tuple can, as its final
result return anything, so only functions returning lists can get them
converted to binaries. If the request contains encoding tag
<strong>unicode</strong>, the lists can contain all Unicode code points and the
binaries are to be in UTF-8. If the encoding tag is <strong>latin1</strong>, the
client is only to get characters in the range <strong>0..255</strong>. Function
<strong>check/2</strong> takes care of not returning arbitrary Unicode code points
in lists if the encoding was specified as <strong>latin1</strong>. If the function
does not return a list, the check cannot be performed and the result is
that of the supplied function untouched.</p><p>To manipulate the table we implement the following utility functions:</p><pre><code class="">
check(unicode, List) -&gt;
    List;
check(latin1, List) -&gt;
    try 
	[ throw(not_unicode) || X &lt;- List,
				X &gt; 255 ],
	List
    catch
	throw:_ -&gt;
	    {error,{cannot_convert, unicode, latin1}}
    end.</code></pre><p>The function check provides an error tuple if Unicode code points &gt;
255 are to be returned if the client requested <strong>latin1</strong>.</p><p>The two functions <strong>until_newline/3</strong> and <strong>until_enough/3</strong> are
helpers used together with function <strong>get_until/5</strong> to implement
<strong>get_chars</strong> and <strong>get_line</strong> (inefficiently):</p><pre><code class="">
until_newline([],eof,_MyStopCharacter) -&gt;
    {done,eof,[]};
until_newline(ThisFar,eof,_MyStopCharacter) -&gt;
    {done,ThisFar,[]};
until_newline(ThisFar,CharList,MyStopCharacter) -&gt;
    case
        lists:splitwith(fun(X) -&gt; X =/= MyStopCharacter end,  CharList)
    of
	{L,[]} -&gt;
            {more,ThisFar++L};
	{L2,[MyStopCharacter|Rest]} -&gt;
	    {done,ThisFar++L2++[MyStopCharacter],Rest}
    end.

until_enough([],eof,_N) -&gt;
    {done,eof,[]};
until_enough(ThisFar,eof,_N) -&gt;
    {done,ThisFar,[]};
until_enough(ThisFar,CharList,N) 
  when length(ThisFar) + length(CharList) &gt;= N -&gt;
    {Res,Rest} = my_split(N,ThisFar ++ CharList, []),
    {done,Res,Rest};
until_enough(ThisFar,CharList,_N) -&gt;
    {more,ThisFar++CharList}.</code></pre><p>As can be seen, the functions above are just the type of functions that
are to be provided in <strong>get_until</strong> requests.</p><p>To complete the I/O server, we only need to read and write the table in
an appropriate way:</p><pre><code class="">
get(P,Tab) -&gt;
    R = P div ?CHARS_PER_REC,
    C = P rem ?CHARS_PER_REC,
    case ets:lookup(Tab,R) of
	[] -&gt;
	    {P,eof};
	[{R,List}] -&gt;
	    case my_split(C,List,[]) of
		{_,[]} -&gt;
		    {P+length(List),eof};
		{_,Data} -&gt;
		    {P+length(Data),Data}
	    end
    end.

my_split(0,Left,Acc) -&gt;
    {lists:reverse(Acc),Left};
my_split(_,[],Acc) -&gt;
    {lists:reverse(Acc),[]};
my_split(N,[H|T],Acc) -&gt;
    my_split(N-1,T,[H|Acc]).

split_data([],_,_) -&gt;
    [];
split_data(Chars, Row, Col) -&gt;
    {This,Left} = my_split(?CHARS_PER_REC - Col, Chars, []),
    [ {Row, Col, This} | split_data(Left, Row + 1, 0) ].

apply_update(Table, {Row, Col, List}) -&gt;     
    case ets:lookup(Table,Row) of
	[] -&gt;
	    ets:insert(Table,{Row, lists:duplicate(Col,0) ++ List});
	[{Row, OldData}] -&gt;
	    {Part1,_} = my_split(Col,OldData,[]),
	    {_,Part2} = my_split(Col+length(List),OldData,[]),
	    ets:insert(Table,{Row, Part1 ++ List ++ Part2})
    end.</code></pre><p>The table is read or written in chunks of <strong>?CHARS_PER_REC</strong>,
overwriting when necessary. The implementation is clearly not efficient,
it is just working.</p><p>This concludes the example. It is fully runnable and you can read or
write to the I/O server by using, for example, the
<a href="./io">stdlib/io</a> module or even the
<a href="./file">kernel/file</a> module. It is
as simple as that to implement a fully fledged I/O server in Erlang.</p></body></html>