<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>gb_trees</h1><h1>gb_trees</h1><p>General balanced trees.</p><p>This module provides Prof. Arne Andersson's General
Balanced Trees. These have no storage overhead compared to
unbalanced binary trees, and their performance is
better than AVL trees.This module considers two keys as different if and only if
they do not compare equal (<strong>==</strong>).</p><h2>Data Structure</h2><p>Trees and iterators are built using opaque data structures that should
not be pattern-matched from outside this module.</p><p>There is no attempt to balance trees after deletions. As
deletions do not increase the height of a tree, this should be OK.</p><p>The original balance condition <em>h(T) &lt;= ceil(c * log(|T|))</em>
has been changed to the similar (but not quite equivalent)
condition <em>2 ^ h(T) &lt;= |T| ^ c</em>. This should also be OK.</p><h1>Data Types</h1><span class="name">tree</span><p>A general balanced tree.</p><span class="name">tree</span><span class="name">iter</span><p>A general balanced tree iterator.</p><span class="name">iter</span><h1>Functions</h1><h2>balance/1</h2><p>Rebalance a tree.</p><p>Rebalances <strong><span class="anno">Tree1</span></strong>. Notice that this is
rarely necessary,
but can be motivated when many nodes have been
deleted from the tree without further insertions. Rebalancing
can then be forced to minimize lookup times, as
deletion does not rebalance the tree.</p><h2>delete/2</h2><p>Remove a node from a tree.</p><p>Removes the node with key <strong><span class="anno">Key</span></strong> from
<strong><span class="anno">Tree1</span></strong> and returns the new tree. Assumes that the
key is present in the tree, crashes otherwise.</p><h2>delete_any/2</h2><p>Remove a (possibly non-existing) node from a tree.</p><p>Removes the node with key <strong><span class="anno">Key</span></strong> from
<strong><span class="anno">Tree1</span></strong> if
the key is present in the tree, otherwise does nothing.
Returns the new tree.</p><h2>take/2</h2><p>Returns a value and new tree without node with key <strong>Key</strong>.</p><p>Returns a value <strong><span class="anno">Value</span></strong> from node with key <strong><span class="anno">Key</span></strong>
and new <strong><span class="anno">Tree2</span></strong> without the node with this value.
Assumes that the node with key is present in the tree,
crashes otherwise.</p><h2>take_any/2</h2><p>Returns a value and new tree without node with key <strong>Key</strong>.</p><p>Returns a value <strong><span class="anno">Value</span></strong> from node with key <strong><span class="anno">Key</span></strong>
and new <strong><span class="anno">Tree2</span></strong> without the node with this value.
Returns <strong>error</strong> if the node with the key is not present in
the tree.</p><h2>empty/0</h2><p>Return an empty tree.</p><p>Returns a new empty tree.</p><h2>enter/3</h2><p>Insert or update key with value in a tree.</p><p>Inserts <strong><span class="anno">Key</span></strong> with value <strong><span class="anno">Value</span></strong>
into <strong><span class="anno">Tree1</span></strong> if the key is not present in the tree,
otherwise updates <strong><span class="anno">Key</span></strong> to value
<strong><span class="anno">Value</span></strong> in <strong><span class="anno">Tree1</span></strong>. Returns the
new tree.</p><h2>from_orddict/1</h2><p>Make a tree from an orddict.</p><p>Turns an ordered list <strong><span class="anno">List</span></strong> of key-value tuples
into a tree. The list must not contain duplicate keys.</p><h2>get/2</h2><p>Look up a key in a tree, if present.</p><p>Retrieves the value stored with <strong><span class="anno">Key</span></strong> in
<strong><span class="anno">Tree</span></strong>.
Assumes that the key is present in the tree, crashes
otherwise.</p><h2>insert/3</h2><p>Insert a new key and value in a tree.</p><p>Inserts <strong><span class="anno">Key</span></strong> with value <strong><span class="anno">Value</span></strong>
into <strong><span class="anno">Tree1</span></strong> and
returns the new tree. Assumes that the key is not present in
the tree, crashes otherwise.</p><h2>is_defined/2</h2><p>Test for membership of a tree.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Key</span></strong> is present in
<strong><span class="anno">Tree</span></strong>, otherwise <strong>false</strong>.</p><h2>is_empty/1</h2><p>Test for empty tree.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Tree</span></strong> is an empty tree,
othwewise  <strong>false</strong>.</p><h2>iterator/1</h2><p>Return an iterator for a tree.</p><p>Returns an iterator that can be used for traversing the
entries of <strong><span class="anno">Tree</span></strong>; see
<a href="#next/1">next/1</a>. The implementation
of this is very efficient; traversing the whole tree using
<strong>next/1</strong> is only slightly slower than getting the list
of all elements using
<a href="#to_list/1">to_list/1</a>
and traversing that.
The main advantage of the iterator approach is that it does
not require the complete list of all elements to be built in
memory at one time.</p><h2>iterator_from/2</h2><p>Return an iterator for a tree starting from a specified key. </p><p>Returns an iterator that can be used for traversing the
entries of <strong><span class="anno">Tree</span></strong>; see
<a href="#next/1">next/1</a>.
The difference as compared to the iterator returned by
<a href="#iterator/1">iterator/1</a>
is that the first key greater than
or equal to <strong><span class="anno">Key</span></strong> is returned.</p><h2>keys/1</h2><p>Return a list of the keys in a tree.</p><p>Returns the keys in <strong><span class="anno">Tree</span></strong> as an ordered list.</p><h2>largest/1</h2><p>Return largest key and value.</p><p>Returns <strong>{<span class="anno">Key</span>, <span class="anno">Value</span>}</strong>, where
<strong><span class="anno">Key</span></strong> is the largest
key in <strong><span class="anno">Tree</span></strong>, and <strong><span class="anno">Value</span></strong> is
the value associated
with this key. Assumes that the tree is not empty.</p><h2>lookup/2</h2><p>Look up a key in a tree.</p><p>Looks up <strong><span class="anno">Key</span></strong> in <strong><span class="anno">Tree</span></strong>.
Returns <strong>{value, <span class="anno">Value</span>}</strong>, or <strong>none</strong> if
<strong><span class="anno">Key</span></strong> is not present.</p><h2>map/2</h2><p>Return largest key and value.</p><p>Maps function F(<span class="anno">K</span>, <span class="anno">V1</span>) -&gt; <span class="anno">V2</span>
to all key-value pairs of tree <strong><span class="anno">Tree1</span></strong>. Returns a
new tree <strong><span class="anno">Tree2</span></strong> with the same set of keys as
<strong><span class="anno">Tree1</span></strong> and the new set of values
<strong><span class="anno">V2</span></strong>.</p><h2>next/1</h2><p>Traverse a tree with an iterator.</p><p>Returns <strong>{<span class="anno">Key</span>, <span class="anno">Value</span>, <span class="anno">Iter2</span>}</strong>, where <strong><span class="anno">Key</span></strong> is the
smallest key referred to by iterator <strong><span class="anno">Iter1</span></strong>, and
<strong><span class="anno">Iter2</span></strong> is the new iterator to be used for
traversing the remaining nodes, or the atom <strong>none</strong> if no
nodes remain.</p><h2>size/1</h2><p>Return the number of nodes in a tree.</p><p>Returns the number of nodes in <strong><span class="anno">Tree</span></strong>.</p><h2>smallest/1</h2><p>Return smallest key and value.</p><p>Returns <strong>{<span class="anno">Key</span>, <span class="anno">Value</span>}</strong>, where
<strong><span class="anno">Key</span></strong> is the smallest
key in <strong><span class="anno">Tree</span></strong>, and <strong><span class="anno">Value</span></strong> is
the value associated
with this key. Assumes that the tree is not empty.</p><h2>take_largest/1</h2><p>Extract largest key and value.</p><p>Returns <strong>{<span class="anno">Key</span>, <span class="anno">Value</span>, <span class="anno">Tree2</span>}</strong>, where <strong><span class="anno">Key</span></strong> is the
largest key in <strong><span class="anno">Tree1</span></strong>, <strong><span class="anno">Value</span></strong>
is the value associated with this key, and <strong><span class="anno">Tree2</span></strong>
is this tree with the corresponding node deleted. Assumes that the
tree is not empty.</p><h2>take_smallest/1</h2><p>Extract smallest key and value.</p><p>Returns <strong>{<span class="anno">Key</span>, <span class="anno">Value</span>, <span class="anno">Tree2</span>}</strong>, where <strong><span class="anno">Key</span></strong> is the
smallest key in <strong><span class="anno">Tree1</span></strong>, <strong><span class="anno">Value</span></strong>
is the value associated with this key, and <strong><span class="anno">Tree2</span></strong>
is this tree with the corresponding node deleted. Assumes that the
tree is not empty.</p><h2>to_list/1</h2><p>Convert a tree into a list.</p><p>Converts a tree into an ordered list of key-value tuples.</p><h2>update/3</h2><p>Update a key to new value in a tree.</p><p>Updates <strong><span class="anno">Key</span></strong> to value <strong><span class="anno">Value</span></strong>
in <strong><span class="anno">Tree1</span></strong> and
returns the new tree. Assumes that the key is present in the tree.</p><h2>values/1</h2><p>Return a list of the values in a tree.</p><p>Returns the values in <strong><span class="anno">Tree</span></strong> as an ordered list,
sorted by their corresponding keys. Duplicates are not removed.</p><h2>See Also</h2><p><a href="dict">dict</a>,
<a href="gb_sets">gb_sets</a></p></body></html>