<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>lists</h1><h1>lists</h1><p>List processing functions.</p><p>This module contains functions for list processing.Unless otherwise stated, all functions assume that position
numbering starts at 1. That is, the first element of a list is at
position 1.Two terms <strong>T1</strong> and <strong>T2</strong> compare equal if
<strong>T1Â ==Â T2</strong> evaluates to <strong>true</strong>. They match
if <strong>T1Â =:=Â T2</strong> evaluates to <strong>true</strong>.Whenever an <a name="ordering_function"></a><em>ordering function</em>
<strong>F</strong> is expected as argument, it is assumed that the
following properties hold of <strong>F</strong> for all x, y, and z:<ul><li><p>If x <strong>F</strong> y and y <strong>F</strong> x, then x = y (<strong>F</strong>
is antisymmetric).</p> </li><li><p>If x <strong>F</strong> y and y <strong>F</strong> z, then x <strong>F</strong> z
(<strong>F</strong> is transitive).</p> </li><li><p>x <strong>F</strong> y or y <strong>F</strong> x (<strong>F</strong> is total).</p> </li></ul>An example of a typical ordering function is less than or equal
to: <strong>=&lt;/2</strong>.</p><h1>Functions</h1><h2>all/2</h2><p>Return <strong>true</strong> if all elements in a list satisfy <strong>Pred</strong>.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Pred</span>(<span class="anno">Elem</span>)</strong>
returns <strong>true</strong> for all elements <strong><span class="anno">Elem</span></strong> in
<strong><span class="anno">List</span></strong>, otherwise <strong>false</strong>.</p><h2>any/2</h2><p>Return <strong>true</strong> if any of the elements in a list satisfies <strong>Pred</strong>.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Pred</span>(<span class="anno">Elem</span>)</strong>
returns <strong>true</strong> for at least one element <strong><span class="anno">Elem</span></strong>
in <strong><span class="anno">List</span></strong>.</p><h2>append/1</h2><p>Append a list of lists.</p><p>Returns a list in which all the sublists of
<strong><span class="anno">ListOfLists</span></strong> have been appended.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:append([[1, 2, 3], [a, b], [4, 5, 6]]).</span>
[1,2,3,a,b,4,5,6]</pre><h2>append/2</h2><p>Append two lists.</p><p>Returns a new list <strong><span class="anno">List3</span></strong>, which is made from
the elements of <strong><span class="anno">List1</span></strong> followed by the elements of
<strong><span class="anno">List2</span></strong>.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:append("abc", "def").</span>
"abcdef"</pre><p><strong>lists:append(A, B)</strong> is equivalent to <strong>A ++ B</strong>.</p><h2>concat/1</h2><p>Concatenate a list of atoms.</p><p>Concatenates the text representation of the elements of
<strong><span class="anno">Things</span></strong>. The elements of <strong><span class="anno">Things</span></strong>
can be atoms, integers, floats, or strings.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:concat([doc, '/', file, '.', 3]).</span>
"doc/file.3"</pre><h2>delete/2</h2><p>Delete an element from a list.</p><p>Returns a copy of <strong><span class="anno">List1</span></strong> where the first element
matching <strong><span class="anno">Elem</span></strong> is deleted, if there is such an
element.</p><h2>droplast/1</h2><p>Drop the last element of a list.</p><p>Drops the last element of a <strong><span class="anno">List</span></strong>. The list is to
be non-empty, otherwise the function crashes with a
<strong>function_clause</strong>.</p><h2>dropwhile/2</h2><p>Drop elements from a list while a predicate is <strong>true</strong>. </p><p>Drops elements <strong><span class="anno">Elem</span></strong> from
<strong><span class="anno">List1</span></strong> while
<strong><span class="anno">Pred</span>(<span class="anno">Elem</span>)</strong> returns <strong>true</strong> and
returns the remaining list.</p><h2>duplicate/2</h2><p>Make <strong>N</strong> copies of element.</p><p>Returns a list containing <strong><span class="anno">N</span></strong> copies of term
<strong><span class="anno">Elem</span></strong>.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:duplicate(5, xx).</span>
[xx,xx,xx,xx,xx]</pre><h2>filter/2</h2><p>Select elements that satisfy a predicate.</p><p><strong><span class="anno">List2</span></strong> is a list of all elements
<strong><span class="anno">Elem</span></strong> in <strong><span class="anno">List1</span></strong> for which
<strong><span class="anno">Pred</span>(<span class="anno">Elem</span>)</strong> returns <strong>true</strong>.</p><h2>filtermap/2</h2><p>Filter and map elements that satisfy a function.</p><p>Calls <strong><span class="anno">Fun</span>(<span class="anno">Elem</span>)</strong> on successive
elements <strong>Elem</strong> of <strong><span class="anno">List1</span></strong>.
<strong><span class="anno">Fun</span>/1</strong> must return either a Boolean or a tuple
<strong>{true, <span class="anno">Value</span>}</strong>. The function returns the list of
elements for which <strong><span class="anno">Fun</span></strong> returns a new value, where
a value of <strong>true</strong> is synonymous with
<strong>{true, <span class="anno">Elem</span>}</strong>.</p><p>That is, <strong>filtermap</strong> behaves as if it had been defined as
follows:</p><pre><code class="">
filtermap(Fun, List1) -&gt;
    lists:foldr(fun(Elem, Acc) -&gt;
                       case Fun(Elem) of
                           false -&gt; Acc;
                           true -&gt; [Elem|Acc];
                           {true,Value} -&gt; [Value|Acc]
                       end
                end, [], List1).</code></pre><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:filtermap(fun(X) -&gt; case X rem 2 of 0 -&gt; {true, X div 2}; _ -&gt; false end end, [1,2,3,4,5]).</span>
[1,2]</pre><h2>flatlength/1</h2><p>Length of flattened deep list.</p><p>Equivalent to <strong>length(flatten(<span class="anno">DeepList</span>))</strong>, but
more efficient.</p><h2>flatmap/2</h2><p>Map and flatten in one pass.</p><p>Takes a function from <strong><span class="anno">A</span></strong>s to lists of
<strong><span class="anno">B</span></strong>s, and a list of <strong><span class="anno">A</span></strong>s
(<strong><span class="anno">List1</span></strong>) and produces a list of
<strong><span class="anno">B</span></strong>s by applying the function to every element in
<strong><span class="anno">List1</span></strong> and appending the resulting lists.</p><p>That is, <strong>flatmap</strong> behaves as if it had been defined as
follows:</p><pre><code class="">
flatmap(Fun, List1) -&gt;
    append(map(Fun, List1)).</code></pre><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:flatmap(fun(X)-&gt;[X,X] end, [a,b,c]).</span>
[a,a,b,b,c,c]</pre><h2>flatten/1</h2><p>Flatten a deep list.</p><p>Returns a flattened version of <strong><span class="anno">DeepList</span></strong>.</p><h2>flatten/2</h2><p>Flatten a deep list.</p><p>Returns a flattened version of <strong><span class="anno">DeepList</span></strong> with tail
<strong><span class="anno">Tail</span></strong> appended.</p><h2>foldl/3</h2><p>Fold a function over a list.</p><p>Calls <strong><span class="anno">Fun</span>(<span class="anno">Elem</span>, <span class="anno">AccIn</span>)</strong>
on successive elements <strong>A</strong> of <strong><span class="anno">List</span></strong>, starting
with <strong><span class="anno">AccIn</span> == <span class="anno">Acc0</span></strong>.
<strong><span class="anno">Fun</span>/2</strong> must return a new accumulator, which is
passed to the next call. The function returns the final value of
the accumulator. <strong><span class="anno">Acc0</span></strong> is returned if the list is
empty.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:foldl(fun(X, Sum) -&gt; X + Sum end, 0, [1,2,3,4,5]).</span>
15
&gt; <span class="input">lists:foldl(fun(X, Prod) -&gt; X * Prod end, 1, [1,2,3,4,5]).</span>
120</pre><h2>foldr/3</h2><p>Fold a function over a list.</p><p>Like <a href="#foldl/3">foldl/3</a>, but the
list is traversed from right to left.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">P = fun(A, AccIn) -&gt; io:format("~p ", [A]), AccIn end.</span>
#Fun&lt;erl_eval.12.2225172&gt;
&gt; <span class="input">lists:foldl(P, void, [1,2,3]).</span>
1 2 3 void
&gt; <span class="input">lists:foldr(P, void, [1,2,3]).</span>
3 2 1 void</pre><p><strong>foldl/3</strong> is tail recursive and is usually preferred to
<strong>foldr/3</strong>.</p><h2>join/2</h2><p>Insert an element between elements in a list</p><p>Inserts <strong><span class="anno">Sep</span></strong> between each element in <strong><span class="anno">List1</span></strong>. Has no
effect on the empty list and on a singleton list. For example:</p><pre>
&gt; <span class="input">lists:join(x, [a,b,c]).</span>
[a,x,b,x,c]
&gt; <span class="input">lists:join(x, [a]).</span>
[a]
&gt; <span class="input">lists:join(x, []).</span>
[]</pre><h2>foreach/2</h2><p>Apply a function to each element of a list.</p><p>Calls <strong><span class="anno">Fun</span>(<span class="anno">Elem</span>)</strong> for each element
<strong><span class="anno">Elem</span></strong> in <strong><span class="anno">List</span></strong>. This function
is used for its side effects and
the evaluation order is defined to be the same as the order
of the elements in the list.</p><h2>keydelete/3</h2><p>Delete an element from a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns a copy of <strong><span class="anno">TupleList1</span></strong> where the first
occurrence of a tuple whose <strong><span class="anno">N</span></strong>th element compares
equal to
<strong><span class="anno">Key</span></strong> is deleted, if there is such a tuple.</p><h2>keyfind/3</h2><p>Search for an element in a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Searches the list of tuples <strong><span class="anno">TupleList</span></strong> for a
tuple whose <strong><span class="anno">N</span></strong>th element compares equal to
<strong><span class="anno">Key</span></strong>.
Returns <strong><span class="anno">Tuple</span></strong> if such a tuple is found,
otherwise <strong>false</strong>.</p><h2>keymap/3</h2><p>Map a function over a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns a list of tuples where, for each tuple in
<strong><span class="anno">TupleList1</span></strong>, the <strong><span class="anno">N</span></strong>th element
<strong><span class="anno">Term1</span></strong> of the tuple
has been replaced with the result of calling
<strong><span class="anno">Fun</span>(<span class="anno">Term1</span>)</strong>.</p><p><em>Examples:</em></p><pre>
&gt; <span class="input">Fun = fun(Atom) -&gt; atom_to_list(Atom) end.</span>
#Fun&lt;erl_eval.6.10732646&gt;
2&gt; <span class="input">lists:keymap(Fun, 2, [{name,jane,22},{name,lizzie,20},{name,lydia,15}]).</span>
[{name,"jane",22},{name,"lizzie",20},{name,"lydia",15}]</pre><h2>keymember/3</h2><p>Test for membership of a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns <strong>true</strong> if there is a tuple in
<strong><span class="anno">TupleList</span></strong> whose <strong><span class="anno">N</span></strong>th element
compares equal to <strong><span class="anno">Key</span></strong>, otherwise <strong>false</strong>.</p><h2>keymerge/3</h2><p>Merge two key-sorted lists of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns the sorted list formed by merging
<strong><span class="anno">TupleList1</span></strong> and <strong><span class="anno">TupleList2</span></strong>.
The merge is performed on the <strong><span class="anno">N</span></strong>th element of each
tuple. Both <strong><span class="anno">TupleList1</span></strong> and
<strong><span class="anno">TupleList2</span></strong> must be key-sorted before evaluating
this function. When two tuples compare equal, the tuple from
<strong><span class="anno">TupleList1</span></strong> is picked before the tuple from
<strong><span class="anno">TupleList2</span></strong>.</p><h2>keyreplace/4</h2><p>Replace an element in a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns a copy of <strong><span class="anno">TupleList1</span></strong> where the first
occurrence of a <strong>T</strong> tuple whose <strong><span class="anno">N</span></strong>th element
compares equal to <strong><span class="anno">Key</span></strong> is replaced with
<strong><span class="anno">NewTuple</span></strong>, if there is such a tuple <strong>T</strong>.</p><h2>keysearch/3</h2><p>Search for an element in a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Searches the list of tuples <strong><span class="anno">TupleList</span></strong> for a
tuple whose <strong><span class="anno">N</span></strong>th element compares equal to
<strong><span class="anno">Key</span></strong>.
Returns <strong>{value, <span class="anno">Tuple</span>}</strong> if such a tuple is found,
otherwise <strong>false</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is retained for backward compatibility. Function
<a href="#keyfind/3">keyfind/3</a>
is usually more convenient.</p></div><h2>keysort/2</h2><p>Sort a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns a list containing the sorted elements of list
<strong><span class="anno">TupleList1</span></strong>. Sorting is performed on the
<strong><span class="anno">N</span></strong>th element of the tuples. The sort is stable.</p><h2>keystore/4</h2><p>Store an element in a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns a copy of <strong><span class="anno">TupleList1</span></strong> where the first
occurrence of a tuple <strong>T</strong> whose <strong><span class="anno">N</span></strong>th element
compares equal to <strong><span class="anno">Key</span></strong> is replaced with
<strong><span class="anno">NewTuple</span></strong>, if there is such a tuple <strong>T</strong>.
If there is no such tuple <strong>T</strong>, a copy of
<strong><span class="anno">TupleList1</span></strong> where
[<strong><span class="anno">NewTuple</span></strong>] has been appended to the end is
returned.</p><h2>keytake/3</h2><p>Extract an element from a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Searches the list of tuples <strong><span class="anno">TupleList1</span></strong> for a
tuple whose <strong><span class="anno">N</span></strong>th element compares equal to
<strong><span class="anno">Key</span></strong>. Returns <strong>{value, <span class="anno">Tuple</span>, <span class="anno">TupleList2</span>}</strong> if such a tuple is found, otherwise
<strong>false</strong>. <strong><span class="anno">TupleList2</span></strong> is a copy
of <strong><span class="anno">TupleList1</span></strong> where the first occurrence of
<strong><span class="anno">Tuple</span></strong> has been removed.</p><h2>last/1</h2><p>Return last element in a list.</p><p>Returns the last element in <strong><span class="anno">List</span></strong>.</p><h2>map/2</h2><p>Map a function over a list.</p><p>Takes a function from <strong><span class="anno">A</span></strong>s to
<strong><span class="anno">B</span></strong>s, and a list of <strong><span class="anno">A</span></strong>s and
produces a list of <strong><span class="anno">B</span></strong>s by applying
the function to every element in the list. This function is
used to obtain the return values. The evaluation order depends on
the implementation.</p><h2>mapfoldl/3</h2><p>Map and fold in one pass.</p><p>Combines the operations of
<a href="#map/2">map/2</a> and 
<a href="#foldl/3">foldl/3</a> into one pass.</p><p><em>Example:</em></p><p>Summing the elements in a list and double them at the same time:</p><pre>
&gt; <span class="input">lists:mapfoldl(fun(X, Sum) -&gt; {2*X, X+Sum} end,</span>
<span class="input">0, [1,2,3,4,5]).</span>
{[2,4,6,8,10],15}</pre><h2>mapfoldr/3</h2><p>Map and fold in one pass.</p><p>Combines the operations of
<a href="#map/2">map/2</a> and 
<a href="#foldr/3">foldr/3</a> into one pass.</p><h2>max/1</h2><p>Return maximum element of a list.</p><p>Returns the first element of <strong><span class="anno">List</span></strong> that compares
greater than or equal to all other elements of
<strong><span class="anno">List</span></strong>.</p><h2>member/2</h2><p>Test for membership of a list.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Elem</span></strong> matches some element
of <strong><span class="anno">List</span></strong>, otherwise <strong>false</strong>.</p><h2>merge/1</h2><p>Merge a list of sorted lists.</p><p>Returns the sorted list formed by merging all the sublists of
<strong><span class="anno">ListOfLists</span></strong>. All sublists must be sorted before
evaluating this function. When two elements compare equal,
the element from the sublist with the lowest position in
<strong><span class="anno">ListOfLists</span></strong> is picked before the other
element.</p><h2>merge/2</h2><p>Merge two sorted lists.</p><p>Returns the sorted list formed by merging <strong><span class="anno">List1</span></strong>
and <strong><span class="anno">List2</span></strong>. Both <strong><span class="anno">List1</span></strong> and
<strong><span class="anno">List2</span></strong> must be
sorted before evaluating this function. When two elements
compare equal, the element from <strong><span class="anno">List1</span></strong> is picked
before the element from <strong><span class="anno">List2</span></strong>.</p><h2>merge/3</h2><p>Merge two sorted list.</p><p>Returns the sorted list formed by merging <strong><span class="anno">List1</span></strong>
and <strong><span class="anno">List2</span></strong>. Both <strong><span class="anno">List1</span></strong> and
<strong><span class="anno">List2</span></strong> must be sorted according to the <a href="#ordering_function">ordering function</a>
<strong><span class="anno">Fun</span></strong> before evaluating this function.
<strong><span class="anno">Fun</span>(<span class="anno">A</span>, <span class="anno">B</span>)</strong> is to return
<strong>true</strong> if <strong><span class="anno">A</span></strong> compares less
than or equal to <strong><span class="anno">B</span></strong> in the ordering, otherwise
<strong>false</strong>. When two elements compare equal, the element from
<strong><span class="anno">List1</span></strong> is picked before the element from
<strong><span class="anno">List2</span></strong>.</p><h2>merge3/3</h2><p>Merge three sorted lists.</p><p>Returns the sorted list formed by merging <strong><span class="anno">List1</span></strong>,
<strong><span class="anno">List2</span></strong>, and <strong><span class="anno">List3</span></strong>. All of
<strong><span class="anno">List1</span></strong>, <strong><span class="anno">List2</span></strong>, and
<strong><span class="anno">List3</span></strong> must be sorted before evaluating this
function. When two elements compare equal, the element from
<strong><span class="anno">List1</span></strong>, if there is such an element,
is picked before the other element, otherwise the element
from <strong><span class="anno">List2</span></strong> is picked before the element from
<strong><span class="anno">List3</span></strong>.</p><h2>min/1</h2><p>Return minimum element of a list.</p><p>Returns the first element of <strong><span class="anno">List</span></strong> that compares
less than or equal to all other elements of
<strong><span class="anno">List</span></strong>.</p><h2>nth/2</h2><p>Return the <strong>N</strong>th element of a list.</p><dl><dt>N</dt><dd>1..length(<span class="anno">List</span>)</dd></dl><p>Returns the <strong><span class="anno">N</span></strong>th element of
<strong><span class="anno">List</span></strong>.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:nth(3, [a, b, c, d, e]).</span>
c</pre><h2>nthtail/2</h2><p>Return the <strong>N</strong>th tail of a list.</p><dl><dt>N</dt><dd>0..length(<span class="anno">List</span>)</dd></dl><p>Returns the <strong><span class="anno">N</span></strong>th tail of <strong><span class="anno">List</span></strong>,
that is, the sublist of <strong><span class="anno">List</span></strong> starting at
<strong><span class="anno">N</span>+1</strong> and continuing up to the end of the list.</p><p><em>Example</em></p><pre>
&gt; <span class="input">lists:nthtail(3, [a, b, c, d, e]).</span>
[d,e]
&gt; <span class="input">tl(tl(tl([a, b, c, d, e]))).</span>
[d,e]
&gt; <span class="input">lists:nthtail(0, [a, b, c, d, e]).</span>
[a,b,c,d,e]
&gt; <span class="input">lists:nthtail(5, [a, b, c, d, e]).</span>
[]</pre><h2>partition/2</h2><p>Partition a list into two lists based on a predicate.</p><p>Partitions <strong><span class="anno">List</span></strong> into two lists, where the first
list contains all elements for which
<strong><span class="anno">Pred</span>(<span class="anno">Elem</span>)</strong> returns <strong>true</strong>,
and the second list contains all elements for which
<strong><span class="anno">Pred</span>(<span class="anno">Elem</span>)</strong> returns <strong>false</strong>.</p><p><em>Examples:</em></p><pre>
&gt; <span class="input">lists:partition(fun(A) -&gt; A rem 2 == 1 end, [1,2,3,4,5,6,7]).</span>
{[1,3,5,7],[2,4,6]}
&gt; <span class="input">lists:partition(fun(A) -&gt; is_atom(A) end, [a,b,1,c,d,2,3,4,e]).</span>
{[a,b,c,d,e],[1,2,3,4]}</pre><p>For a different way to partition a list, see
<a href="#splitwith/2">splitwith/2</a>.</p><h2>prefix/2</h2><p>Test for list prefix.</p><p>Returns <strong>true</strong> if <strong><span class="anno">List1</span></strong> is a prefix of
<strong><span class="anno">List2</span></strong>, otherwise <strong>false</strong>.</p><h2>reverse/1</h2><p>Reverse a list.</p><p>Returns a list with the elements in <strong><span class="anno">List1</span></strong>
in reverse order.</p><h2>reverse/2</h2><p>Reverse a list appending a tail.</p><p>Returns a list with the elements in <strong><span class="anno">List1</span></strong>
in reverse order, with tail <strong><span class="anno">Tail</span></strong> appended.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:reverse([1, 2, 3, 4], [a, b, c]).</span>
[4,3,2,1,a,b,c]</pre><h2>search/2</h2><p>Find the first element that satisfies a predicate.</p><p>If there is a <strong><span class="anno">Value</span></strong> in <strong><span class="anno">List</span></strong>
such that <strong><span class="anno">Pred</span>(<span class="anno">Value</span>)</strong> returns
<strong>true</strong>, returns <strong>{value, <span class="anno">Value</span>}</strong>
for the first such <strong><span class="anno">Value</span></strong>,
otherwise returns <strong>false</strong>.</p><h2>seq/2</h2><h2>seq/3</h2><p>Generate a sequence of integers.</p><p>Returns a sequence of integers that starts with
<strong><span class="anno">From</span></strong> and contains the successive results of
adding <strong><span class="anno">Incr</span></strong> to the previous element, until
<strong><span class="anno">To</span></strong> is reached or passed (in the latter case,
<strong><span class="anno">To</span></strong> is not an element of
the sequence). <strong><span class="anno">Incr</span></strong> defaults to 1.</p><p>Failures:</p><ul><li> <p>If <strong><span class="anno">To</span> &lt; <span class="anno">From</span> - <span class="anno">Incr</span></strong>
and <strong><span class="anno">Incr</span> &gt; 0</strong>.</p> </li><li> <p>If <strong><span class="anno">To</span> &gt; <span class="anno">From</span> - <span class="anno">Incr</span></strong> and
<strong><span class="anno">Incr</span> &lt; 0</strong>.</p> </li><li> <p>If <strong><span class="anno">Incr</span> =:= 0</strong> and
<strong><span class="anno">From</span> =/= <span class="anno">To</span></strong>.</p> </li></ul><p>The following equalities hold for all sequences:</p><pre><code class="">
length(lists:seq(From, To)) =:= To - From + 1
length(lists:seq(From, To, Incr)) =:= (To - From + Incr) div Incr</code></pre><p><em>Examples:</em></p><pre>
&gt; <span class="input">lists:seq(1, 10).</span>
[1,2,3,4,5,6,7,8,9,10]
&gt; <span class="input">lists:seq(1, 20, 3).</span>
[1,4,7,10,13,16,19]
&gt; <span class="input">lists:seq(1, 0, 1).</span>
[]
&gt; <span class="input">lists:seq(10, 6, 4).</span>
[]
&gt; <span class="input">lists:seq(1, 1, 0).</span>
[1]</pre><h2>sort/1</h2><p>Sort a list.</p><p>Returns a list containing the sorted elements of
<strong><span class="anno">List1</span></strong>.</p><h2>sort/2</h2><p>Sort a list.</p><p>Returns a list containing the sorted elements of
<strong><span class="anno">List1</span></strong>, according to the <a href="#ordering_function">ordering function</a>
<strong><span class="anno">Fun</span></strong>. <strong><span class="anno">Fun</span>(<span class="anno">A</span>, <span class="anno">B</span>)</strong> is to return <strong>true</strong> if <strong><span class="anno">A</span></strong>
compares less than or equal to <strong><span class="anno">B</span></strong> in the
ordering, otherwise <strong>false</strong>.</p><h2>split/2</h2><p>Split a list into two lists.</p><dl><dt>N</dt><dd>0..length(<span class="anno">List1</span>)</dd></dl><p>Splits <strong><span class="anno">List1</span></strong> into <strong><span class="anno">List2</span></strong> and
<strong><span class="anno">List3</span></strong>. <strong><span class="anno">List2</span></strong> contains the
first <strong><span class="anno">N</span></strong> elements and <strong><span class="anno">List3</span></strong>
the remaining elements (the <strong><span class="anno">N</span></strong>th tail).</p><h2>splitwith/2</h2><p>Split a list into two lists based on a predicate.</p><p>Partitions <strong><span class="anno">List</span></strong> into two lists according to
<strong><span class="anno">Pred</span></strong>. <strong>splitwith/2</strong> behaves as if it is
defined as follows:</p><pre><code class="">
splitwith(Pred, List) -&gt;
    {takewhile(Pred, List), dropwhile(Pred, List)}.</code></pre><p><em>Examples:</em></p><pre>
&gt; <span class="input">lists:splitwith(fun(A) -&gt; A rem 2 == 1 end, [1,2,3,4,5,6,7]).</span>
{[1],[2,3,4,5,6,7]}
&gt; <span class="input">lists:splitwith(fun(A) -&gt; is_atom(A) end, [a,b,1,c,d,2,3,4,e]).</span>
{[a,b],[1,c,d,2,3,4,e]}</pre><p>For a different way to partition a list, see 
<a href="#partition/2">partition/2</a>.</p><h2>sublist/2</h2><p>Return a sublist of a certain length, starting at the first position.</p><p>Returns the sublist of <strong><span class="anno">List1</span></strong> starting at
position 1 and with (maximum) <strong><span class="anno">Len</span></strong> elements. It is
not an error for <strong><span class="anno">Len</span></strong> to exceed the length of the
list, in that case the whole list is returned.</p><h2>sublist/3</h2><p>Return a sublist starting at a specified position and with a specified number of elements.</p><dl><dt>Start</dt><dd>1..(length(<span class="anno">List1</span>)+1)</dd></dl><p>Returns the sublist of <strong><span class="anno">List1</span></strong> starting at
<strong><span class="anno">Start</span></strong> and with (maximum) <strong><span class="anno">Len</span></strong>
elements. It is not an error for
<strong><span class="anno">Start</span>+<span class="anno">Len</span></strong> to exceed the length of
the list.</p><p><em>Examples:</em></p><pre>
&gt; <span class="input">lists:sublist([1,2,3,4], 2, 2).</span>
[2,3]
&gt; <span class="input">lists:sublist([1,2,3,4], 2, 5).</span>
[2,3,4]
&gt; <span class="input">lists:sublist([1,2,3,4], 5, 2).</span>
[]</pre><h2>subtract/2</h2><p>Subtract the element in one list from another list.</p><p>Returns a new list <strong><span class="anno">List3</span></strong> that is a copy of
<strong><span class="anno">List1</span></strong>, subjected to the following procedure:
for each element in <strong><span class="anno">List2</span></strong>, its first occurrence
in <strong><span class="anno">List1</span></strong> is deleted.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:subtract("123212", "212").</span>
"312".</pre><p><strong>lists:subtract(A, B)</strong> is equivalent to <strong>A -- B</strong>.</p><h2>suffix/2</h2><p>Test for list suffix.</p><p>Returns <strong>true</strong> if <strong><span class="anno">List1</span></strong> is a suffix of
<strong><span class="anno">List2</span></strong>, otherwise <strong>false</strong>.</p><h2>sum/1</h2><p>Return the sum of elements in a list.</p><p>Returns the sum of the elements in <strong><span class="anno">List</span></strong>.</p><h2>takewhile/2</h2><p>Take elements from a list while a predicate is <strong>true</strong>. </p><p>Takes elements <strong><span class="anno">Elem</span></strong> from
<strong><span class="anno">List1</span></strong> while
<strong><span class="anno">Pred</span>(<span class="anno">Elem</span>)</strong> returns <strong>true</strong>, that
is, the function returns the longest prefix of the list for which
all elements satisfy the predicate.</p><h2>ukeymerge/3</h2><p>Merge two key-sorted lists of tuples, removing duplicates. </p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns the sorted list formed by merging
<strong><span class="anno">TupleList1</span></strong> and
<strong><span class="anno">TupleList2</span></strong>. The merge is performed on the
<strong><span class="anno">N</span></strong>th element of each tuple. Both
<strong><span class="anno">TupleList1</span></strong> and <strong><span class="anno">TupleList2</span></strong>
must be key-sorted without duplicates before evaluating this function.
When two tuples compare equal, the tuple from
<strong><span class="anno">TupleList1</span></strong> is picked and the
one from <strong><span class="anno">TupleList2</span></strong> is deleted.</p><h2>ukeysort/2</h2><p>Sort a list of tuples, removing duplicates.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns a list containing the sorted elements of list
<strong><span class="anno">TupleList1</span></strong> where all except the first tuple of
the tuples comparing equal have been deleted. Sorting is
performed on the <strong><span class="anno">N</span></strong>th element of the tuples.</p><h2>umerge/1</h2><p>Merge a list of sorted lists, removing duplicates.</p><p>Returns the sorted list formed by merging all the sublists
of <strong><span class="anno">ListOfLists</span></strong>. All sublists must be sorted and
contain no duplicates before evaluating this function.
When two elements compare equal, the element from the sublist
with the lowest position in <strong><span class="anno">ListOfLists</span></strong> is
picked and the other is deleted.</p><h2>umerge/2</h2><p>Merge two sorted lists, removing duplicates.</p><p>Returns the sorted list formed by merging <strong><span class="anno">List1</span></strong>
and <strong><span class="anno">List2</span></strong>. Both <strong><span class="anno">List1</span></strong> and
<strong><span class="anno">List2</span></strong> must be
sorted and contain no duplicates before evaluating this
function. When two elements compare equal, the element from
<strong><span class="anno">List1</span></strong> is picked and the one from
<strong><span class="anno">List2</span></strong> is deleted.</p><h2>umerge/3</h2><p>Merge two sorted lists, removing duplicates.</p><p>Returns the sorted list formed by merging <strong><span class="anno">List1</span></strong>
and <strong><span class="anno">List2</span></strong>. Both <strong><span class="anno">List1</span></strong> and
<strong><span class="anno">List2</span></strong> must be sorted according to the <a href="#ordering_function">ordering function</a>
<strong>Fun</strong> and contain no duplicates before evaluating this function.
<strong><span class="anno">Fun</span>(<span class="anno">A</span>, <span class="anno">B</span>)</strong> is to return
<strong>true</strong> if <strong><span class="anno">A</span></strong> compares less than or equal to
<strong><span class="anno">B</span></strong> in the ordering, otherwise <strong>false</strong>. When
two elements compare equal, the element from <strong><span class="anno">List1</span></strong>
is picked and the one from <strong><span class="anno">List2</span></strong> is deleted.</p><h2>umerge3/3</h2><p>Merge three sorted lists, removing duplicates.</p><p>Returns the sorted list formed by merging <strong><span class="anno">List1</span></strong>,
<strong><span class="anno">List2</span></strong>, and <strong><span class="anno">List3</span></strong>. All of
<strong><span class="anno">List1</span></strong>, <strong><span class="anno">List2</span></strong>, and
<strong><span class="anno">List3</span></strong> must be sorted and contain no
duplicates before evaluating this function. When two
elements compare equal, the element from <strong><span class="anno">List1</span></strong> is
picked if there is such an element, otherwise the element from
<strong><span class="anno">List2</span></strong> is picked, and the other is deleted.</p><h2>unzip/1</h2><p>Unzip a list of two-tuples into two lists.</p><p>"Unzips" a list of two-tuples into two lists, where the first
list contains the first element of each tuple, and the second
list contains the second element of each tuple.</p><h2>unzip3/1</h2><p>Unzip a list of three-tuples into three lists.</p><p>"Unzips" a list of three-tuples into three lists, where
the first list contains the first element of each tuple,
the second list contains the second element of each tuple, and
the third list contains the third element of each tuple.</p><h2>usort/1</h2><p>Sort a list, removing duplicates.</p><p>Returns a list containing the sorted elements of
<strong><span class="anno">List1</span></strong> where all except the first element of the
elements comparing equal have been deleted.</p><h2>usort/2</h2><p>Sort a list, removing duplicates.</p><p>Returns a list containing the sorted elements of
<strong><span class="anno">List1</span></strong> where all except the first element of the
elements comparing equal according to the <a href="#ordering_function">ordering function</a>
<strong><span class="anno">Fun</span></strong> have been deleted.
<strong><span class="anno">Fun</span>(A, B)</strong> is to return
<strong>true</strong> if <strong>A</strong> compares less than or equal to
<strong>B</strong> in the ordering, otherwise <strong>false</strong>.</p><h2>zip/2</h2><p>Zip two lists into a list of two-tuples.</p><p>"Zips" two lists of equal length into one list of two-tuples,
where the first element of each tuple is taken from the first
list and the second element is taken from the corresponding
element in the second list.</p><h2>zip3/3</h2><p>Zip three lists into a list of three-tuples.</p><p>"Zips" three lists of equal length into one list of
three-tuples, where the first element of each tuple is taken
from the first list, the second element is taken from
the corresponding element in the second list, and the third
element is taken from the corresponding element in the third list.</p><h2>zipwith/3</h2><p>Zip two lists into one list according to a fun.</p><p>Combines the elements of two lists of equal length into one list.
For each pair <strong><span class="anno">X</span>, <span class="anno">Y</span></strong> of list elements
from the two lists, the element in the result list is
<strong><span class="anno">Combine</span>(<span class="anno">X</span>, <span class="anno">Y</span>)</strong>.</p><p><strong>zipwith(fun(X, Y) -&gt; {X,Y} end, List1, List2)</strong> is
equivalent to <strong>zip(List1, List2)</strong>.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:zipwith(fun(X, Y) -&gt; X+Y end, [1,2,3], [4,5,6]).</span>
[5,7,9]</pre><h2>zipwith3/4</h2><p>Zip three lists into one list according to a fun.</p><p>Combines the elements of three lists of equal length into one
list. For each triple <strong><span class="anno">X</span>, <span class="anno">Y</span>, <span class="anno">Z</span></strong> of list elements from the three lists, the element
in the result list is <strong><span class="anno">Combine</span>(<span class="anno">X</span>, <span class="anno">Y</span>, <span class="anno">Z</span>)</strong>.</p><p><strong>zipwith3(fun(X, Y, Z) -&gt; {X,Y,Z} end, List1, List2, List3)</strong> is
equivalent to <strong>zip3(List1, List2, List3)</strong>.</p><p><em>Examples:</em></p><pre>
&gt; <span class="input">lists:zipwith3(fun(X, Y, Z) -&gt; X+Y+Z end, [1,2,3], [4,5,6], [7,8,9]).</span>
[12,15,18]
&gt; <span class="input">lists:zipwith3(fun(X, Y, Z) -&gt; [X,Y,Z] end, [a,b,c], [x,y,z], [1,2,3]).</span>
[[a,x,1],[b,y,2],[c,z,3]]</pre></body></html>