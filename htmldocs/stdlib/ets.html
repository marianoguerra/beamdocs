<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>ets</h1><h1>ets</h1><p>Built-in term storage.</p><p>This module is an interface to the Erlang built-in term storage
BIFs. These provide the ability to store very large quantities of
data in an Erlang runtime system, and to have constant access
time to the data. (In the case of <strong>ordered_set</strong>, see below,
access time is proportional to the logarithm of the number of
stored objects.)Data is organized as a set of dynamic tables, which can store
tuples. Each table is created by a process. When the process
terminates, the table is automatically destroyed. Every table has
access rights set at creation.Tables are divided into four different types, <strong>set</strong>,
<strong>ordered_set</strong>, <strong>bag</strong>, and <strong>duplicate_bag</strong>.
A <strong>set</strong> or <strong>ordered_set</strong> table can only have one object
associated with each key. A <strong>bag</strong> or <strong>duplicate_bag</strong> table can
have many objects associated with each key.<a name="max_ets_tables"></a>Notice that there is no automatic garbage collection for tables.
Even if there are no references to a table from any process, it
is not automatically destroyed unless the owner process
terminates. To destroy a table explicitly, use function
<a href="#delete/1">delete/1</a>.
The default owner is the process that created the
table. To transfer table ownership at process termination, use
option <a href="#heir">heir</a> or call
<a href="#give_away/3">give_away/3</a>.Some implementation details:<ul><li><p>In the current implementation, every object insert and
look-up operation results in a copy of the object.</p></li><li><p><strong>'$end_of_table'</strong> is not to be used as a key, as
this atom is used to mark the end of the table when using functions
<a href="#first/1">first/1</a> and
<a href="#next/2">next/2</a>.</p></li></ul>Notice the subtle difference between
<em>matching</em> and <em>comparing equal</em>, which is
demonstrated by table types <strong>set</strong> and <strong>ordered_set</strong>:<ul><li> <p>Two Erlang terms <strong>match</strong> if they are of
the same type and have the same value, so that <strong>1</strong> matches
<strong>1</strong>, but not <strong>1.0</strong> (as <strong>1.0</strong> is a <strong>float()</strong>
and not an <strong>integer()</strong>).</p> </li><li> <p>Two Erlang terms <em>compare equal</em>
if they either are of the same type and value, or if
both are numeric types and extend to the same value, so that
<strong>1</strong> compares equal to both <strong>1</strong> and <strong>1.0</strong>.</p> </li><li> <p>The <strong>ordered_set</strong> works on the <em>Erlang term order</em> and
no defined order exists between an <strong>integer()</strong> and a
<strong>float()</strong> that extends to the same value. Hence the key
<strong>1</strong> and the key <strong>1.0</strong> are regarded as equal in an
<strong>ordered_set</strong> table.</p> </li></ul></p><h2>Failure</h2><p>The functions in this module exits with reason
<strong>badarg</strong> if any argument has the wrong format, if the
table identifier is invalid, or if the operation is denied because of
table access rights (<a href="#protected">protected</a>
or <a href="#private">private</a>).</p><a name="concurrency"></a><h2>Concurrency</h2><p>This module provides some limited support for concurrent access.
All updates to single objects are guaranteed to be both <em>atomic</em>
and <em>isolated</em>. This means that an updating operation to
a single object either succeeds or fails completely without any
effect (atomicity) and that
no intermediate results of the update can be seen by other
processes (isolation). Some functions that update many objects
state that they even guarantee atomicity and isolation for the entire
operation. In database terms the isolation level can be seen as
"serializable", as if all isolated operations are carried out serially,
one after the other in a strict order.</p><a name="traversal"></a><h2>Table traversal</h2><p>There are different ways to traverse through the objects of a table.</p><ul><li><p><em>Single-step</em> traversal one key at at time, using
<a href="#first/1">first/1</a>,
<a href="#next/2">next/2</a>,
<a href="#last/1">last/1</a> and
<a href="#prev/2">prev/2</a>.</p> </li><li><p>Search with simple <em>match patterns</em>, using
<a href="#match/1">match/1</a>,
<a href="#match_delete/2">match_delete/2</a> and
<a href="#match_object/1">match_object/1</a>.</p> </li><li><p>Search with more powerful <em>match specifications</em>, using
<a href="#select/1">select/1</a>,
<a href="#select_count/2">select_count/2</a>,
<a href="#select_delete/2">select_delete/2</a>,
<a href="#select_replace/2">select_replace/2</a> and
<a href="#select_reverse/1">select_reverse/1</a>.</p> </li><li><p><em>Table conversions</em>, using
<a href="#tab2file/2">tab2file/2</a> and
<a href="#tab2list/1">tab2list/1</a>.</p> </li></ul><p>None of these ways of table traversal will guarantee a consistent table snapshot
if the table is also updated during the traversal. Moreover, traversals not
done in a <em>safe</em> way, on tables where keys are inserted or deleted
during the traversal, may yield the following undesired effects:</p><ul><li><p>Any key may be missed.</p></li><li><p>Any key may be found more than once.</p></li><li><p>The traversal may fail with <strong>badarg</strong> exception if keys are deleted.</p> </li></ul><p>A table traversal is <em>safe</em> if either</p><ul><li><p>the table is of type <strong>ordered_set</strong>.</p> </li><li><p>the entire table traversal is done within one ETS function
call.</p> </li><li><p>function <a href="#safe_fixtable/2">safe_fixtable/2</a>
is used to keep the table fixated during the entire traversal.</p> </li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Even though the access of a single object is always guaranteed to be
<a href="#concurrency">atomic and isolated</a>, each traversal
through a table to find the next key is not done with such guarantees. This is often
not a problem, but may cause rare subtle "unexpected" effects if a concurrent
process inserts objects during a traversal. For example, consider one
process doing</p><pre>
ets:new(t, [ordered_set, named_table]),
ets:insert(t, {1}),
ets:insert(t, {2}),
ets:insert(t, {3}),
</pre><p>A concurrent call to <strong>ets:first(t)</strong>, done by another
process, may then in rare cases return <strong>2</strong> even though
<strong>2</strong> has never existed in the table ordered as the first key. In
the same way, a concurrent call to <strong>ets:next(t, 1)</strong> may return
<strong>3</strong> even though <strong>3</strong> never existed in the table
ordered directly after <strong>1</strong>.</p><p>Effects like this are improbable but possible. The probability will
further be reduced (if not vanish) if table option
<a href="#new_2_write_concurrency">new_2_write_concurrency</a>
is not enabled. This can also only be a potential concern for
<strong>ordered_set</strong> where the traversal order is defined.</p></div><p>Traversals using <strong>match</strong> and <strong>select</strong> functions may not need to
scan the entire table depending on how the key is specified. A match
pattern with a <em>fully bound key</em> (without any match variables) will
optimize the operation to a single key lookup without any table traversal
at all. For <strong>ordered_set</strong> a <em>partially bound key</em> will limit the
traversal to only scan a subset of the table based on term order. A
partially bound key is either a list or a tuple with a prefix that is fully
bound. Example:</p><pre>
1&gt; <span class="input">T = ets:new(t,[ordered_set]), ets:insert(T, {"555-1234", "John Smith"}).</span>
true
2&gt; <span class="input">%% Efficient search of all with area code 555</span>
2&gt; <span class="input">ets:match(T,{[$5,$5,$5,$- |'$1'],'$2'}).</span>
[["1234","John Smith"]]
</pre><a name="match_spec"></a><h2>Match Specifications</h2><p>Some of the functions use a <em>match specification</em>,
<strong>match_spec</strong>. For a brief explanation, see
<a href="#select/2">select/2</a>. For a detailed
description, see section <a href="./match_spec"> Match Specifications in Erlang</a> in ERTS User's Guide.</p><h1>Data Types</h1><span class="name">access</span><span class="name">continuation()</span><p>Opaque continuation used by <a href="#select/1">select/1</a>, <a href="#select_reverse/1">select_reverse/1</a>, <a href="#match/1">match/1</a>, and <a href="#match_object/1">match_object/1</a>.</p><span class="name">match_spec</span><p>A match specification, see above.</p><span class="name">comp_match_spec</span><p>A compiled match specification.</p><span class="name">match_pattern</span><span class="name">tab</span><span class="name">tid</span><p>A table identifier, as returned by
<a href="#new/2">new/2</a>.</p><span class="name">type</span><h1>Functions</h1><h2>all/0</h2><p>Return a list of all ETS tables.</p><p>Returns a list of all tables at the node. Named tables are
specified by their names, unnamed tables are specified by their
table identifiers.</p><p>There is no guarantee of consistency in the returned list. Tables
created or deleted by other processes "during" the <strong>ets:all()</strong>
call either are or are not included in the list. Only tables
created/deleted <em>before</em> <strong>ets:all()</strong> is called are
guaranteed to be included/excluded.</p><h2>delete/1</h2><p>Delete an entire ETS table.</p><p>Deletes the entire table <strong><span class="anno">Tab</span></strong>.</p><h2>delete/2</h2><p>Delete all objects with a specified key from an ETS table.</p><p>Deletes all objects with key <strong><span class="anno">Key</span></strong> from table
<strong><span class="anno">Tab</span></strong>.</p><h2>delete_all_objects/1</h2><p>Delete all objects in an ETS table.</p><p>Delete all objects in the ETS table <strong><span class="anno">Tab</span></strong>.
The operation is guaranteed to be
<a href="#concurrency">atomic and isolated</a>.</p><h2>delete_object/2</h2><p>Deletes a specific from an ETS table.</p><p>Delete the exact object <strong><span class="anno">Object</span></strong> from the
ETS table,
leaving objects with the same key but other differences
(useful for type <strong>bag</strong>). In a <strong>duplicate_bag</strong> table, all
instances of the object are deleted.</p><h2>file2tab/1</h2><p>Read an ETS table from a file.</p><p>Reads a file produced by <a href="#tab2file/2">tab2file/2</a> or 
<a href="#tab2file/3">tab2file/3</a> and
creates the corresponding table <strong><span class="anno">Tab</span></strong>.</p><p>Equivalent to <strong>file2tab(<span class="anno">Filename</span>, [])</strong>.</p><h2>file2tab/2</h2><p>Read an ETS table from a file.</p><p>Reads a file produced by <a href="#tab2file/2">tab2file/2</a> or <a href="#tab2file/3">tab2file/3</a> and creates the
corresponding table <strong><span class="anno">Tab</span></strong>.</p><p>The only supported option is <strong>{verify,boolean()}</strong>.
If verification is turned on (by specifying <strong>{verify,true}</strong>),
the function uses whatever information is present in the file to
assert that the information is not damaged. How this is done depends
on which <strong>extended_info</strong> was written using 
<a href="#tab2file/3">tab2file/3</a>.</p><p>If no <strong>extended_info</strong> is present in the file and
<strong>{verify,true}</strong> is specified, the number of objects
written is compared to the size of the original table when the
dump was started. This can make verification fail if the table was
<strong>public</strong> and objects were added or removed while the
table was dumped to file. To avoid this problem,
either do not verify files dumped while updated simultaneously
or use option <strong>{extended_info, [object_count]}</strong> to
<a href="#tab2file/3">tab2file/3</a>, which
extends the information in the file with the number of objects
written.</p><p>If verification is turned on and the file was written with
option <strong>{extended_info, [md5sum]}</strong>, reading the file
is slower and consumes radically more CPU time than otherwise.</p><p><strong>{verify,false}</strong> is the default.</p><h2>first/1</h2><p>Return the first key in an ETS table.</p><p>Returns the first key <strong><span class="anno">Key</span></strong> in table
<strong><span class="anno">Tab</span></strong>. For an <strong>ordered_set</strong> table, the first
key in Erlang term order is returned. For other
table types, the first key according to the internal
order of the table is returned. If the table is empty,
<strong>'$end_of_table'</strong> is returned.</p><p>To find subsequent keys in the table, use
<a href="#next/2">next/2</a>.</p><h2>foldl/3</h2><p>Fold a function over an ETS table.</p><p><strong><span class="anno">Acc0</span></strong> is returned if the table is empty.
This function is similar to
<a href="./lists#foldl/3">lists#foldl/3</a>.
The table elements are traversed in an unspecified order, except for
<strong>ordered_set</strong> tables, where they are traversed first to last.</p><p>If <strong><span class="anno">Function</span></strong> inserts objects into the table,
or another
process inserts objects into the table, those objects <em>can</em>
(depending on key ordering) be included in the traversal.</p><h2>foldr/3</h2><p>Fold a function over an ETS table.</p><p><strong><span class="anno">Acc0</span></strong> is returned if the table is empty.
This function is similar to
<a href="./lists#foldr/3">lists#foldr/3</a>.
The table elements are traversed in an unspecified order, except for
<strong>ordered_set</strong> tables, where they are traversed last to first.</p><p>If <strong><span class="anno">Function</span></strong> inserts objects into the table,
or another
process inserts objects into the table, those objects <em>can</em>
(depending on key ordering) be included in the traversal.</p><h2>from_dets/2</h2><p>Fill an ETS table with objects from a Dets table.</p><p>Fills an already created ETS table with the objects in the
already opened Dets table <strong><span class="anno">DetsTab</span></strong>.
Existing objects in the ETS table are kept unless
overwritten.</p><p>If any of the tables does not exist or the Dets table is
not open, a <strong>badarg</strong> exception is raised.</p><h2>fun2ms/1</h2><p>Pseudo function that transforms fun syntax to a match specification.</p><p>Pseudo function that by a <strong>parse_transform</strong> translates
<strong><span class="anno">LiteralFun</span></strong> typed as parameter in the function
call to a
<a href="#match_spec">match specification</a>.
With "literal" is meant that the fun must textually be written
as the parameter of the function, it cannot be held in a
variable that in turn is passed to the function.</p><p>The parse transform is provided in the <strong>ms_transform</strong>
module and the source <em>must</em> include
file <strong>ms_transform.hrl</strong> in STDLIB for this
pseudo function to work. Failing to include the hrl file in
the source results in a runtime error, not a compile
time error. The include file is easiest included by adding line
<strong>-include_lib("stdlib/include/ms_transform.hrl").</strong> to
the source file.</p><p>The fun is very restricted, it can take only a single
parameter (the object to match): a sole variable or a
tuple. It must use the <strong>is_</strong> guard tests.
Language constructs that have no representation in a match
specification (<strong>if</strong>, <strong>case</strong>, <strong>receive</strong>,
and so on) are not allowed.</p><p>The return value is the resulting match specification.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">ets:fun2ms(fun({M,N}) when N &gt; 3 -&gt; M end).</span>
[{{'$1','$2'},[{'&gt;','$2',3}],['$1']}]</pre><p>Variables from the environment can be imported, so that the
following works:</p><pre>
2&gt; <span class="input">X=3.</span>
3
3&gt; <span class="input">ets:fun2ms(fun({M,N}) when N &gt; X -&gt; M end).</span>
[{{'$1','$2'},[{'&gt;','$2',{const,3}}],['$1']}]</pre><p>The imported variables are replaced by match specification
<strong>const</strong> expressions, which is consistent with the
static scoping for Erlang funs. However, local or global function
calls cannot be in the guard or body of the fun. Calls to built-in
match specification functions is of course allowed:</p><pre>
4&gt; <span class="input">ets:fun2ms(fun({M,N}) when N &gt; X, my_fun(M) -&gt; M end).</span>
Error: fun containing local Erlang function calls
('my_fun' called in guard) cannot be translated into match_spec
{error,transform_error}
5&gt; <span class="input">ets:fun2ms(fun({M,N}) when N &gt; X, is_atom(M) -&gt; M end).</span>
[{{'$1','$2'},[{'&gt;','$2',{const,3}},{is_atom,'$1'}],['$1']}]</pre><p>As shown by the example, the function can be called
from the shell also. The fun must be literally in the call
when used from the shell as well.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If the <strong>parse_transform</strong> is not applied to a module that
calls this pseudo function, the call fails in runtime
(with a <strong>badarg</strong>). The <strong>ets</strong> module
exports a function with this name, but it is never to
be called except when using the function in the
shell. If the <strong>parse_transform</strong> is properly applied by
including header file <strong>ms_transform.hrl</strong>, compiled
code never calls the function, but the function call is
replaced by a literal match specification.</p></div><p>For more information, see <a href="./ms_transform#top">ms_transform#top</a>.</p><h2>give_away/3</h2><p>Change owner of a table.</p><p>Make process <strong><span class="anno">Pid</span></strong> the new owner of table
<strong><span class="anno">Tab</span></strong>. If successful, message
<strong>{'ETS-TRANSFER',<span class="anno">Tab</span>,FromPid,<span class="anno">GiftData</span>}</strong>
is sent to the new owner.</p><p>The process <strong><span class="anno">Pid</span></strong> must be alive, local, and not
already the owner of the table.
The calling process must be the table owner.</p><p>Notice that this function does not affect option
<a href="#heir">heir</a> of the table. A table
owner can, for example, set <strong>heir</strong> to itself, give the table
away, and then get it back if the receiver terminates.</p><h2>i/0</h2><p>Display information about all ETS tables on a terminal. </p><p>Displays information about all ETS tables on a terminal.</p><h2>i/1</h2><p>Browse an ETS table on a terminal.</p><p>Browses table <strong><span class="anno">Tab</span></strong> on a terminal.</p><h2>info/1</h2><p>Return information about an <strong>table</strong>.</p><p>Returns information about table <strong><span class="anno">Tab</span></strong> as a list of
tuples. If <strong><span class="anno">Tab</span></strong> has the correct type
for a table identifier, but does not refer to an existing ETS
table, <strong>undefined</strong> is returned. If <strong><span class="anno">Tab</span></strong> is
not of the correct type, a <strong>badarg</strong> exception is raised.</p><dl><dt><strong>{compressed, boolean()}</strong></dt><dd> <p>Indicates if the table is compressed.</p> </dd><dt><strong>{heir, pid() | none}</strong></dt><dd> <p>The pid of the heir of the table, or <strong>none</strong> if no heir
is set.</p> </dd><dt><strong>{id,</strong><a href="#type-tid">type-tid</a><strong>}</strong></dt><dd> <p>The table identifier.</p> </dd><dt><strong>{keypos, integer() &gt;= 1}</strong></dt><dd> <p>The key position.</p> </dd><dt><strong>{memory, integer() &gt;= 0</strong></dt><dd> <p>The number of words allocated to the table.</p> </dd><dt><strong>{name, atom()}</strong></dt><dd> <p>The table name.</p> </dd><dt><strong>{named_table, boolean()}</strong></dt><dd> <p>Indicates if the table is named.</p> </dd><dt><strong>{node, node()}</strong></dt><dd> <p>The node where the table is stored. This field is no longer
meaningful, as tables cannot be accessed from other nodes.</p> </dd><dt><strong>{owner, pid()}</strong></dt><dd> <p>The pid of the owner of the table.</p> </dd><dt><strong>{protection,</strong> <a href="#type-access">type-access</a><strong>}</strong></dt><dd> <p>The table access rights.</p> </dd><dt><strong>{size, integer() &gt;= 0</strong></dt><dd> <p>The number of objects inserted in the table.</p> </dd><dt><strong>{type,</strong> <a href="#type-type">type-type</a><strong>}</strong></dt><dd> <p>The table type.</p> </dd><dt><strong>{read_concurrency, boolean()}</strong></dt><dd> <p>Indicates whether the table uses <strong>read_concurrency</strong> or
not.</p> </dd><dt><strong>{write_concurrency, boolean()}</strong></dt><dd> <p>Indicates whether the table uses <strong>write_concurrency</strong>.</p> </dd></dl><h2>info/2</h2><p>Return the information associated with the specified item for an ETS table.</p><p>Returns the information associated with <strong>Item</strong> for table
<strong><span class="anno">Tab</span></strong>, or returns <strong>undefined</strong> if <strong>Tab</strong>
does not refer an existing ETS table. If
<strong><span class="anno">Tab</span></strong> is
not of the correct type, or if <strong><span class="anno">Item</span></strong> is not
one of the allowed values, a <strong>badarg</strong> exception is raised.</p><p>In addition to the <strong>{<span class="anno">Item</span>,<span class="anno">Value</span>}</strong>
pairs defined for <a href="#info/1">info/1</a>,
the following items are allowed:</p><ul><li> <p><strong>Item=fixed, Value=boolean()</strong></p> <p>Indicates if the table is fixed by any process.</p> </li><li> <p><a name="info_2_safe_fixed_monotonic_time"></a></p> <p><strong>Item=safe_fixed|safe_fixed_monotonic_time, Value={FixationTime,Info}|false</strong></p> <p>If the table is fixed using
<a href="#safe_fixtable/2">safe_fixtable/2</a>,
the call returns a tuple where <strong>FixationTime</strong> is the
last time when the table changed from unfixed to fixed.</p> <p>The format and value of <strong>FixationTime</strong> depends on
<strong>Item</strong>:</p> <dl><dt><strong>safe_fixed</strong></dt><dd> <p><strong>FixationTime</strong> corresponds to the result returned by
<a href="../erts/erlang#timestamp/0">erts/erlang#timestamp/0</a> at the time of fixation.
Notice that when the system uses single or multi
<a href="../erts/time_correction#Time_Warp_Modes">time warp modes</a> this can produce strange results, as
the use of <strong>safe_fixed</strong> is not
<a href="../erts/time_correction#Time_Warp_Safe_Code"> time warp safe</a>. Time warp safe code must use
<strong>safe_fixed_monotonic_time</strong> instead.</p> </dd><dt><strong>safe_fixed_monotonic_time</strong></dt><dd> <p><strong>FixationTime</strong> corresponds to the result returned by
<a href="../erts/erlang#monotonic_time/0">erts/erlang#monotonic_time/0</a> at the time of
fixation. The use of <strong>safe_fixed_monotonic_time</strong> is
<a href="../erts/time_correction#Time_Warp_Safe_Code"> time warp safe</a>.</p> </dd></dl> <p><strong>Info</strong> is a possibly empty lists of tuples
<strong>{Pid,RefCount}</strong>, one tuple for every process the
table is fixed by now. <strong>RefCount</strong> is the value
of the reference counter and it keeps track of how many times
the table has been fixed by the process.</p> <p>Table fixations are not limited to <a href="#safe_fixtable/2">safe_fixtable/2</a>. Temporary fixations may also
be done by for example <a href="#traversal">traversing functions</a> like <strong>select</strong> and <strong>match</strong>. Such
table fixations are automatically released before the
corresponding functions returns, but they may be seen by a
concurrent call to
<strong>ets:info(T,safe_fixed|safe_fixed_monotonic_time)</strong>.</p> <p>If the table is not fixed at all, the call returns <strong>false</strong>.</p> </li><li> <p><strong>Item=stats, Value=tuple()</strong></p> <p>Returns internal statistics about tables on an internal format
used by OTP test suites. Not for production use.</p></li></ul><h2>init_table/2</h2><p>Replace all objects of an ETS table.</p><p>Replaces the existing objects of table <strong><span class="anno">Tab</span></strong> with
objects created by calling the input function
<strong><span class="anno">InitFun</span></strong>,
see below. This function is provided for compatibility with
the <strong>dets</strong> module, it is not more efficient than filling
a table by using
<a href="#insert/2">insert/2</a>.</p><p>When called with argument <strong>read</strong>, the function
<strong><span class="anno">InitFun</span></strong> is assumed to return
<strong>end_of_input</strong> when
there is no more input, or <strong>{<span class="anno">Objects</span>, Fun}</strong>, where
<strong><span class="anno">Objects</span></strong> is a list of objects and <strong>Fun</strong> is a
new input function. Any other value <strong>Value</strong> is returned as an
error <strong>{error, {init_fun, Value}}</strong>. Each input function is
called exactly once, and if an error occur, the last
function is called with argument <strong>close</strong>, the reply
of which is ignored.</p><p>If the table type is <strong>set</strong> and more than one object
exists with a given key, one of the objects is
chosen. This is not necessarily the last object with the given
key in the sequence of objects returned by the input
functions. This holds also for duplicated
objects stored in tables of type <strong>bag</strong>.</p><h2>insert/2</h2><p>Insert an object into an ETS table.</p><p>Inserts the object or all of the objects in list
<strong><span class="anno">ObjectOrObjects</span></strong> into table
<strong><span class="anno">Tab</span></strong>.</p><ul><li> <p>If the table type is <strong>set</strong> and the key of the inserted
objects <em>matches</em> the key of any object in the table,
the old object is replaced.</p> </li><li> <p>If the table type is <strong>ordered_set</strong> and the key of the
inserted object <em>compares equal</em> to the key of any object
in the table, the old object is replaced.</p> </li><li> <p>If the list contains more than one object with
<em>matching</em> keys and the table type is <strong>set</strong>, one is
inserted, which one is not defined.
The same holds for table type <strong>ordered_set</strong>
if the keys <em>compare equal</em>.</p> </li></ul><p>The entire operation is guaranteed to be
<a href="#concurrency">atomic and isolated</a>,
even when a list of objects is inserted.</p><h2>insert_new/2</h2><p>Insert an object into an ETS table if the key is not already present.</p><p>Same as <a href="#insert/2">insert/2</a>
except that instead of overwriting objects with the same key
(for <strong>set</strong> or <strong>ordered_set</strong>) or adding more objects with
keys already existing in the table (for <strong>bag</strong> and
<strong>duplicate_bag</strong>), <strong>false</strong> is returned.</p><p>If <strong><span class="anno">ObjectOrObjects</span></strong> is a
list, the function checks <em>every</em> key before
inserting anything. Nothing is inserted unless
<em>all</em> keys present in the list are absent from the
table. Like <strong>insert/2</strong>, the entire operation is guaranteed to be
<a href="#concurrency">atomic and isolated</a>.</p><h2>is_compiled_ms/1</h2><p>Check if an Erlang term is the result of <strong>match_spec_compile</strong>.</p><p>Checks if a term is a valid
compiled <a href="#match_spec">match specification</a>.
The compiled match specification is an opaque datatype that
<em>cannot</em> be sent between Erlang nodes or be stored on
disk. Any attempt to create an external representation of a
compiled match specification results in an empty binary
(<strong>&lt;&lt;&gt;&gt;</strong>).</p><p><em>Examples:</em></p><p>The following expression yields <strong>true</strong>::</p><pre><code class="">
ets:is_compiled_ms(ets:match_spec_compile([{'_',[],[true]}])).</code></pre><p>The following expressions yield <strong>false</strong>, as variable
<strong>Broken</strong> contains a compiled match specification that has
passed through external representation:</p><pre><code class="">
MS = ets:match_spec_compile([{'_',[],[true]}]),
Broken = binary_to_term(term_to_binary(MS)),
ets:is_compiled_ms(Broken).</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The reason for not having an external representation of
compiled match specifications is performance. It can be
subject to change in future releases, while this interface
remains for backward compatibility.</p></div><h2>last/1</h2><p>Return the last key in an ETS table of type <strong>ordered_set</strong>.</p><p>Returns the last key <strong><span class="anno">Key</span></strong> according to Erlang
term order in table <strong>Tab</strong> of type <strong>ordered_set</strong>. For
other table types, the function is synonymous to
<a href="#first/1">first/1</a>.
If the table is empty, <strong>'$end_of_table'</strong> is returned.</p><p>To find preceding keys in the table, use
<a href="#prev/2">prev/2</a>.</p><h2>lookup/2</h2><p>Return all objects with a specified key in an ETS table. </p><p>Returns a list of all objects with key <strong><span class="anno">Key</span></strong> in
table <strong><span class="anno">Tab</span></strong>.</p><ul><li> <p>For tables of type <strong>set</strong>, <strong>bag</strong>, or
<strong>duplicate_bag</strong>, an object is returned only if the specified
key <em>matches</em> the key of the object in the table.</p> </li><li> <p>For tables of type <strong>ordered_set</strong>, an object is returned if
the specified key <em>compares equal</em> to the key of an object
in the table.</p> </li></ul><p>The difference is the same as between <strong>=:=</strong> and <strong>==</strong>.</p><p>As an example, one can insert an object with
<strong>integer()</strong> <strong>1</strong> as a key in an <strong>ordered_set</strong>
and get the object returned as a result of doing a <strong>lookup/2</strong>
with <strong>float()</strong> <strong>1.0</strong> as the key to search for.</p><p>For tables of type <strong>set</strong> or <strong>ordered_set</strong>,
the function returns either the empty list or a list with one
element, as there cannot be more than one object with the same
key. For tables of type <strong>bag</strong> or <strong>duplicate_bag</strong>, the
function returns a list of arbitrary length.</p><p>Notice that the time order of object insertions is preserved;
the first object inserted with the specified key is the first
in the resulting list, and so on.</p><p>Insert and lookup times in tables of type <strong>set</strong>,
<strong>bag</strong>, and <strong>duplicate_bag</strong> are constant, regardless
of the table size. For the <strong>ordered_set</strong>
datatype, time is proportional to the (binary) logarithm of
the number of objects.</p><h2>lookup_element/3</h2><p>Return the <strong>Pos</strong>:th element of all objects with a specified key in an ETS table.</p><p>For a table <strong><span class="anno">Tab</span></strong> of type <strong>set</strong> or
<strong>ordered_set</strong>, the function returns the
<strong><span class="anno">Pos</span></strong>:th
element of the object with key <strong><span class="anno">Key</span></strong>.</p><p>For tables of type <strong>bag</strong> or <strong>duplicate_bag</strong>,
the functions returns a list with the <strong><span class="anno">Pos</span></strong>:th
element of every object with key <strong><span class="anno">Key</span></strong>.</p><p>If no object with key <strong><span class="anno">Key</span></strong> exists, the
function exits with reason <strong>badarg</strong>.</p><p>The difference between <strong>set</strong>, <strong>bag</strong>, and
<strong>duplicate_bag</strong> on one hand, and <strong>ordered_set</strong> on
the other, regarding the fact that <strong>ordered_set</strong>
view keys as equal when they <em>compare equal</em>
whereas the other table types regard them equal only when
they <em>match</em>, holds for <strong>lookup_element/3</strong>.</p><h2>match/1</h2><p>Continues matching objects in an ETS table.</p><p>Continues a match started with
<a href="#match/3">match/3</a>. The next
chunk of the size specified in the initial <strong>match/3</strong>
call is returned together with a new <strong><span class="anno">Continuation</span></strong>,
which can be used in subsequent calls to this function.</p><p>When there are no more objects in the table, <strong>'$end_of_table'</strong>
is returned.</p><h2>match/2</h2><p>Match the objects in an ETS table against a pattern. </p><p>Matches the objects in table <strong><span class="anno">Tab</span></strong> against
pattern <strong><span class="anno">Pattern</span></strong>.</p><p>A pattern is a term that can contain:</p><ul><li>Bound parts (Erlang terms)</li><li><strong>'_'</strong> that matches any Erlang term</li><li>Pattern variables <strong>'$N'</strong>, where <strong>N</strong>=0,1,...</li></ul><p>The function returns a list with one element for each
matching object, where each element is an ordered list of
pattern variable bindings, for example:</p><pre>
6&gt; <span class="input">ets:match(T, '$1').</span> % Matches every object in table
[[{rufsen,dog,7}],[{brunte,horse,5}],[{ludde,dog,5}]]
7&gt; <span class="input">ets:match(T, {'_',dog,'$1'}).</span>
[[7],[5]]
8&gt; <span class="input">ets:match(T, {'_',cow,'$1'}).</span>
[]</pre><p>If the key is specified in the pattern, the match is very
efficient. If the key is not specified, that is, if it is a
variable or an underscore, the entire table must be searched.
The search time can be substantial if the table is very large.</p><p>For tables of type <strong>ordered_set</strong>, the result is in
the same order as in a <strong>first</strong>/<strong>next</strong> traversal.</p><h2>match/3</h2><p>Match the objects in an ETS table against a pattern and return part of the answers.</p><p>Works like <a href="#match/2">match/2</a>, 
but returns only a limited (<strong><span class="anno">Limit</span></strong>) number of
matching objects. Term <strong><span class="anno">Continuation</span></strong> can then
be used in subsequent calls to <a href="#match/1">match/1</a> to get the next chunk of matching
objects. This is a space-efficient way to work on objects in a
table, which is faster than traversing the table object
by object using
<a href="#first/1">first/1</a> and
<a href="#next/2">next/2</a>.</p><p>If the table is empty, <strong>'$end_of_table'</strong> is returned.</p><p>Use <a href="#safe_fixtable/2">safe_fixtable/2</a>
to guarantee <a href="#traversal">safe traversal</a>
for subsequent calls to <a href="#match/1">match/1</a>.</p><h2>match_delete/2</h2><p>Delete all objects that match a specified pattern from an ETS table.</p><p>Deletes all objects that match pattern <strong><span class="anno">Pattern</span></strong>
from table <strong><span class="anno">Tab</span></strong>. For a description of patterns,
see <a href="#match/2">match/2</a>.</p><h2>match_object/1</h2><p>Continues matching objects in an ETS table.</p><p>Continues a match started with
<a href="#match_object/3">match_object/3</a>.
The next chunk of the size specified in the initial
<strong>match_object/3</strong> call is returned together with a new
<strong><span class="anno">Continuation</span></strong>, which can be used in subsequent
calls to this function.</p><p>When there are no more objects in the table, <strong>'$end_of_table'</strong>
is returned.</p><h2>match_object/2</h2><p>Match the objects in an ETS table against a pattern. </p><p>Matches the objects in table <strong><span class="anno">Tab</span></strong> against
pattern <strong><span class="anno">Pattern</span></strong>. For a description of patterns,
see <a href="#match/2">match/2</a>.
The function returns a list of all objects that
match the pattern.</p><p>If the key is specified in the pattern, the match is very
efficient. If the key is not specified, that is, if it is a
variable or an underscore, the entire table must be searched.
The search time can be substantial if the table is very large.</p><p>For tables of type <strong>ordered_set</strong>, the result is in
the same order as in a <strong>first</strong>/<strong>next</strong> traversal.</p><h2>match_object/3</h2><p>Match the objects in an ETS table against a pattern and return part of the answers.</p><p>Works like <a href="#match_object/2">match_object/2</a>, but only returns a
limited (<strong><span class="anno">Limit</span></strong>) number of matching objects. Term
<strong><span class="anno">Continuation</span></strong> can then be used in subsequent
calls to <a href="#match_object/1">match_object/1</a> to get the next chunk of matching
objects. This is a space-efficient way to work on objects in a
table, which is faster than traversing the table object
by object using
<a href="#first/1">first/1</a> and
<a href="#next/2">next/2</a>.</p><p>If the table is empty, <strong>'$end_of_table'</strong> is returned.</p><p>Use <a href="#safe_fixtable/2">safe_fixtable/2</a>
to guarantee <a href="#traversal">safe traversal</a>
for subsequent calls to <a href="#match_object/1">match_object/1</a>.</p><h2>match_spec_compile/1</h2><p>Compile a match specification into its internal representation. </p><p>Transforms a
<a href="#match_spec">match specification</a> into an
internal representation that can be used in subsequent calls to
<a href="#match_spec_run/2">match_spec_run/2</a>.
The internal representation is
opaque and cannot be converted to external term format and
then back again without losing its properties (that is, it cannot
be sent to a process on another node and still remain a
valid compiled match specification, nor can it be stored on disk).
To check the validity of a compiled match specification, use
<a href="#is_compiled_ms/1">is_compiled_ms/1</a>.
</p><p>If term <strong><span class="anno">MatchSpec</span></strong> cannot be compiled (does not
represent a valid match specification), a <strong>badarg</strong> exception is
raised.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function has limited use in normal code. It is used by the
<a href="dets">dets</a> module
to perform the <strong>dets:select()</strong> operations.</p></div><h2>match_spec_run/2</h2><p>Perform matching, using a compiled match specification on a list of terms.</p><p>Executes the matching specified in a compiled
<a href="#match_spec">match specification</a> on a list
of terms. Term <strong><span class="anno">CompiledMatchSpec</span></strong> is to be
the result of a call to <a href="#match_spec_compile/1">match_spec_compile/1</a> and is hence the internal
representation of the match specification one wants to use.</p><p>The matching is executed on each element in <strong><span class="anno">List</span></strong>
and the function returns a list containing all results. If an element
in <strong><span class="anno">List</span></strong> does not match, nothing is returned
for that element. The length of the result list is therefore
equal or less than the length of parameter <strong><span class="anno">List</span></strong>.
</p><p><em>Example:</em></p><p>The following two calls give the same result (but certainly not the
same execution time):</p><pre><code class="">
Table = ets:new...
MatchSpec = ...
% The following call...
ets:match_spec_run(ets:tab2list(Table),
                   ets:match_spec_compile(MatchSpec)),
% ...gives the same result as the more common (and more efficient)
ets:select(Table, MatchSpec),</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function has limited use in normal code. It is used by the
<a href="dets">dets</a> module
to perform the <strong>dets:select()</strong> operations and by
Mnesia during transactions.</p></div><h2>member/2</h2><p>Tests for occurrence of a key in an ETS table.</p><p>Works like <a href="#lookup/2">lookup/2</a>,
but does not return the objects. Returns <strong>true</strong> if one or more
elements in the table has key <strong><span class="anno">Key</span></strong>, otherwise
<strong>false</strong>.</p><h2>new/2</h2><p>Create a new ETS table.</p><p>Creates a new table and returns a table identifier that can
be used in subsequent operations. The table identifier can be
sent to other processes so that a table can be shared between
different processes within a node.</p><p>Parameter <strong><span class="anno">Options</span></strong> is a list of options that
specifies table type, access rights, key position, and whether the
table is named. Default values are used for omitted options.
This means that not specifying any options (<strong>[]</strong>) is the same
as specifying <strong>[set, protected, {keypos,1}, {heir,none}, {write_concurrency,false}, {read_concurrency,false}]</strong>.</p><dl><dt><strong>set</strong></dt><dd> <p>The table is a <strong>set</strong> table: one key, one object,
no order among objects. This is the default table type.</p> </dd><dt><strong>ordered_set</strong></dt><dd> <p>The table is a <strong>ordered_set</strong> table: one key, one
object, ordered in Erlang term order, which is the order
implied by the &lt; and &gt; operators. Tables of this type
have a somewhat different behavior in some situations
than tables of other types. Most notably, the
<strong>ordered_set</strong> tables regard keys as equal when they
<em>compare equal</em>, not only when they match. This
means that to an <strong>ordered_set</strong> table, <strong>integer()</strong>
<strong>1</strong> and <strong>float()</strong> <strong>1.0</strong> are regarded as equal.
This also means that the
key used to lookup an element not necessarily
<em>matches</em> the key in the returned elements, if
<strong>float()</strong>'s and <strong>integer()</strong>'s are mixed in
keys of a table.</p> </dd><dt><strong>bag</strong></dt><dd> <p>The table is a <strong>bag</strong> table, which can have many
objects, but only one instance of each object, per key.</p> </dd><dt><strong>duplicate_bag</strong></dt><dd> <p>The table is a <strong>duplicate_bag</strong> table, which can have
many objects, including multiple copies of the same
object, per key.</p> </dd><dt><strong>public</strong></dt><dd> <p>Any process can read or write to the table.</p> <a name="protected"></a> </dd><dt><strong>protected</strong></dt><dd> <p>The owner process can read and write to the table. Other
processes can only read the table. This is the default
setting for the access rights.</p> <a name="private"></a> </dd><dt><strong>private</strong></dt><dd> <p>Only the owner process can read or write to the table.</p> </dd><dt><strong>named_table</strong></dt><dd> <p>If this option is present, the table is registered under its
<strong><span class="anno">Name</span></strong> which can then be used instead of the
table identifier in subsequent operations.</p> <p>The function will also return the <strong><span class="anno">Name</span></strong>
instead of the table identifier. To get the table identifier of a
named table, use
<a href="#whereis/1">whereis/1</a>.</p> </dd><dt><strong>{keypos,<span class="anno">Pos</span>}</strong></dt><dd> <p>Specifies which element in the stored tuples to use
as key. By default, it is the first element, that is,
<strong><span class="anno">Pos</span>=1</strong>. However, this is not always
appropriate. In
particular, we do not want the first element to be the
key if we want to store Erlang records in a table.</p> <p>Notice that any tuple stored in the table must have at
least <strong><span class="anno">Pos</span></strong> number of elements.</p> <a name="heir"></a> </dd><dt><strong>{heir,<span class="anno">Pid</span>,<span class="anno">HeirData</span>} | {heir,none}</strong></dt><dd> <p>Set a process as heir. The heir inherits the table if
the owner terminates. Message
<strong>{'ETS-TRANSFER',tid(),FromPid,<span class="anno">HeirData</span>}</strong> is
sent to the heir when that occurs. The heir must be a local
process. Default heir is <strong>none</strong>, which destroys the table
when the owner terminates.</p> <a name="new_2_write_concurrency"></a> </dd><dt><strong>{write_concurrency,boolean()}</strong></dt><dd> <p>Performance tuning. Defaults to <strong>false</strong>, in which case an
operation that
mutates (writes to) the table obtains exclusive access,
blocking any concurrent access of the same table until finished.
If set to <strong>true</strong>, the table is optimized to concurrent
write access. Different objects of the same table can be mutated
(and read) by concurrent processes. This is achieved to some
degree at the expense of memory consumption and the performance
of sequential access and concurrent reading.</p> <p>Option <strong>write_concurrency</strong> can be combined with option
<a href="#new_2_read_concurrency">new_2_read_concurrency</a>. You typically want to combine
these when large concurrent read bursts and large concurrent
write bursts are common; for more information, see option
<a href="#new_2_read_concurrency">new_2_read_concurrency</a>.</p> <p>Notice that this option does not change any guarantees about
<a href="#concurrency">atomicity and isolation</a>.
Functions that makes such promises over many objects (like
<a href="#insert/2">insert/2</a>)
gain less (or nothing) from this option.</p> <p>The memory consumption inflicted by both <strong>write_concurrency</strong>
and <strong>read_concurrency</strong> is a constant overhead per table for
<strong>set</strong>, <strong>bag</strong> and <strong>duplicate_bag</strong>. For
<strong>ordered_set</strong> the memory overhead depends on the number
of inserted objects and the amount of actual detected
concurrency in runtime. The memory overhead can be especially
large when both options are combined.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Prior to stdlib-3.7 (OTP-22.0) <strong>write_concurrency</strong> had no
effect on <strong>ordered_set</strong>.</p></div> <a name="new_2_read_concurrency"></a> </dd><dt><strong>{read_concurrency,boolean()}</strong></dt><dd> <p>Performance tuning. Defaults to <strong>false</strong>. When set to
<strong>true</strong>, the table is optimized for concurrent read
operations. When this option is enabled on a runtime system with
SMP support, read operations become much cheaper; especially on
systems with multiple physical processors. However, switching
between read and write operations becomes more expensive.</p> <p>You typically want to enable this option when concurrent read
operations are much more frequent than write operations, or when
concurrent reads and writes comes in large read and write bursts
(that is, many reads not interrupted by writes, and many
writes not interrupted by reads).</p> <p>You typically do
<em>not</em> want to enable this option when the common access
pattern is a few read operations interleaved with a few write
operations repeatedly. In this case, you would get a performance
degradation by enabling this option.</p> <p>Option <strong>read_concurrency</strong> can be combined with option
<a href="#new_2_write_concurrency">new_2_write_concurrency</a>.
You typically want to combine these when large concurrent
read bursts and large concurrent write bursts are common.</p> <a name="new_2_compressed"></a> </dd><dt><strong>compressed</strong></dt><dd> <p>If this option is present, the table data is stored in a more
compact format to consume less memory. However, it will make
table operations slower. Especially operations that need to
inspect entire objects, such as <strong>match</strong> and <strong>select</strong>,
get much slower. The key element is not compressed.</p> </dd></dl><h2>next/2</h2><p>Return the next key in an ETS table.</p><p>Returns the next key <strong><span class="anno">Key2</span></strong>, following key
<strong><span class="anno">Key1</span></strong> in table <strong><span class="anno">Tab</span></strong>. For table
type <strong>ordered_set</strong>, the next key in Erlang term order is
returned. For other table types, the next key
according to the internal order of the table is returned. If no
next key exists, <strong>'$end_of_table'</strong> is returned.</p><p>To find the first key in the table, use
<a href="#first/1">first/1</a>.</p><p>Unless a table of type <strong>set</strong>, <strong>bag</strong>, or
<strong>duplicate_bag</strong> is fixated using
<a href="#safe_fixtable/2">safe_fixtable/2</a>,
a call to <strong>next/2</strong> will fail if <strong><span class="anno">Key1</span></strong> no longer
exists in the table. For table type <strong>ordered_set</strong>, the function
always returns the next key after <strong><span class="anno">Key1</span></strong> in term
order, regardless whether <strong><span class="anno">Key1</span></strong> ever existed in the
table.</p><h2>prev/2</h2><p>Return the previous key in an ETS table of type <strong>ordered_set</strong>.</p><p>Returns the previous key <strong><span class="anno">Key2</span></strong>, preceding key
<strong><span class="anno">Key1</span></strong> according to Erlang term order in table
<strong><span class="anno">Tab</span></strong> of type <strong>ordered_set</strong>. For other
table types, the function is synonymous to
<a href="#next/2">next/2</a>.
If no previous key exists, <strong>'$end_of_table'</strong> is returned.</p><p>To find the last key in an <strong>ordered_set</strong> table, use
<a href="#last/1">last/1</a>.</p><h2>rename/2</h2><p>Rename a named ETS table.</p><p>Renames the named table <strong><span class="anno">Tab</span></strong> to the new name
<strong><span class="anno">Name</span></strong>. Afterwards, the old name cannot be used to
access the table. Renaming an unnamed table has no effect.</p><h2>repair_continuation/2</h2><p>Repair a continuation from <strong>ets:select/1 or ets:select/3</strong> that has passed through external representation.</p><p>Restores an opaque continuation returned by
<a href="#select/3">select/3</a> or
<a href="#select/1">select/1</a> if the
continuation has passed through external term format (been
sent between nodes or stored on disk).</p><p>The reason for this function is that continuation terms
contain compiled match specifications and therefore are
invalidated if converted to external term format. Given that the
original match specification is kept intact, the continuation can
be restored, meaning it can once again be used in subsequent
<strong>select/1</strong> calls even though it has been stored on
disk or on another node.</p><p><em>Examples:</em></p><p>The following sequence of calls fails:</p><pre><code class="">
T=ets:new(x,[]),
...
{_,C} = ets:select(T,ets:fun2ms(fun({N,_}=A)
when (N rem 10) =:= 0 -&gt;
A
end),10),
Broken = binary_to_term(term_to_binary(C)),
ets:select(Broken).</code></pre><p>The following sequence works, as the call to
<strong>repair_continuation/2</strong> reestablishes the (deliberately)
invalidated continuation <strong>Broken</strong>.</p><pre><code class="">
T=ets:new(x,[]),
...
MS = ets:fun2ms(fun({N,_}=A)
when (N rem 10) =:= 0 -&gt;
A
end),
{_,C} = ets:select(T,MS,10),
Broken = binary_to_term(term_to_binary(C)),
ets:select(ets:repair_continuation(Broken,MS)).</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is rarely needed in application code. It is used
by Mnesia to provide distributed <strong>select/3</strong>
and <strong>select/1</strong> sequences. A normal application would
either use Mnesia or keep the continuation from being
converted to external format.</p><p>The reason for not having an external representation of a
compiled match specification is performance. It can be subject to
change in future releases, while this interface remains
for backward compatibility.</p></div><h2>safe_fixtable/2</h2><p>Fix an ETS table for safe traversal.</p><p>Fixes a table of type <strong>set</strong>, <strong>bag</strong>, or
<strong>duplicate_bag</strong> for <a href="#traversal"> safe traversal</a> using
<a href="#first/1">first/1</a> &amp;
<a href="#next/2">next/2</a>,
<a href="#match/3">match/3</a> &amp;
<a href="#match/1">match/1</a>,
<a href="#match_object/3">match_object/3</a> &amp;
<a href="#match_object/1">match_object/1</a>, or
<a href="#select/3">select/3</a> &amp;
<a href="#select/1">select/1</a>.</p><p>A process fixes a table by calling
<strong>safe_fixtable(<span class="anno">Tab</span>, true)</strong>. The table remains
fixed until the process releases it by calling
<strong>safe_fixtable(<span class="anno">Tab</span>, false)</strong>, or until the process
terminates.</p><p>If many processes fix a table, the table remains fixed
until all processes have released it (or terminated).
A reference counter is kept on a per process basis, and N
consecutive fixes requires N releases to release the table.</p><p>When a table is fixed, a sequence of
<a href="#first/1">first/1</a> and
<a href="#next/2">next/2</a> calls are
guaranteed to succeed even if keys are removed during the
traversal. The keys for objects inserted or deleted during a
traversal may or may not be returned by <strong>next/2</strong> depending on
the ordering of keys within the table and if the key exists at the time
<strong>next/2</strong> is called.</p><p><em>Example:</em></p><pre><code class="">
clean_all_with_value(Tab,X) -&gt;
    safe_fixtable(Tab,true),
    clean_all_with_value(Tab,X,ets:first(Tab)),
    safe_fixtable(Tab,false).

clean_all_with_value(Tab,X,'$end_of_table') -&gt;
    true;
clean_all_with_value(Tab,X,Key) -&gt;
    case ets:lookup(Tab,Key) of
        [{Key,X}] -&gt;
            ets:delete(Tab,Key);
        _ -&gt;
            true
    end,
    clean_all_with_value(Tab,X,ets:next(Tab,Key)).</code></pre><p>Notice that deleted objects are not freed from a
fixed table until it has been released. If a process fixes a
table but never releases it, the memory used by the deleted
objects is never freed. The performance of operations on
the table also degrades significantly.</p><p>To retrieve information about which processes have fixed which
tables, use <a href="#info_2_safe_fixed_monotonic_time">info_2_safe_fixed_monotonic_time</a>. A system with
many processes fixing tables can need a monitor that sends alarms
when tables have been fixed for too long.</p><p>Notice that <strong>safe_fixtable/2</strong> is not necessary for table type
<strong>ordered_set</strong> and for traversals done by a single ETS function call,
like <a href="#select/2">select/2</a>.</p><h2>select/1</h2><p>Continue matching objects in an ETS table.</p><p>Continues a match started with
<a href="#select/3">select/3</a>. The next
chunk of the size specified in the initial <strong>select/3</strong>
call is returned together with a new <strong><span class="anno">Continuation</span></strong>,
which can be used in subsequent calls to this function.</p><p>When there are no more objects in the table, <strong>'$end_of_table'</strong>
is returned.</p><h2>select/2</h2><p>Match the objects in an ETS table against a match specification.</p><p>Matches the objects in table <strong><span class="anno">Tab</span></strong> using a
<a href="#match_spec">match specification</a>.
This is a more general call than
<a href="#match/2">match/2</a> and
<a href="#match_object/2">match_object/2</a>
calls. In its simplest form, the match specification is as
follows:</p><pre><code class="">
MatchSpec = [MatchFunction]
MatchFunction = {MatchHead, [Guard], [Result]}
MatchHead = "Pattern as in ets:match"
Guard = {"Guardtest name", ...}
Result = "Term construct"</code></pre><p>This means that the match specification is always a list of one or
more tuples (of arity 3). The first element of the tuple is to be
a pattern as described in
<a href="#match/2">match/2</a>.
The second element of the tuple is to
be a list of 0 or more guard tests (described below). The
third element of the tuple is to be a list containing a
description of the value to return. In almost all
normal cases, the list contains exactly one term that fully
describes the value to return for each object.</p><p>The return value is constructed using the "match variables"
bound in <strong>MatchHead</strong> or using the special match variables
<strong>'$_'</strong> (the whole matching object) and <strong>'$$'</strong> (all
match variables in a list), so that the following
<strong>match/2</strong> expression:</p><pre><code class="">
ets:match(Tab,{'$1','$2','$3'})</code></pre><p>is exactly equivalent to:</p><pre><code class="">
ets:select(Tab,[{{'$1','$2','$3'},[],['$$']}])</code></pre><p>And that the following <strong>match_object/2</strong> call:</p><pre><code class="">
ets:match_object(Tab,{'$1','$2','$1'})</code></pre><p>is exactly equivalent to</p><pre><code class="">
ets:select(Tab,[{{'$1','$2','$1'},[],['$_']}])</code></pre><p>Composite terms can be constructed in the <strong>Result</strong> part
either by simply writing a list, so that the following code:</p><pre><code class="">
ets:select(Tab,[{{'$1','$2','$3'},[],['$$']}])</code></pre><p>gives the same output as:</p><pre><code class="">
ets:select(Tab,[{{'$1','$2','$3'},[],[['$1','$2','$3']]}])</code></pre><p>That is, all the bound variables in the match head as a list. If
tuples are to be constructed, one has to write a tuple of
arity 1 where the single element in the tuple is the tuple
one wants to construct (as an ordinary tuple can be mistaken
for a <strong>Guard</strong>).</p><p>Therefore the following call:</p><pre><code class="">
ets:select(Tab,[{{'$1','$2','$1'},[],['$_']}])</code></pre><p>gives the same output as:</p><pre><code class="">
ets:select(Tab,[{{'$1','$2','$1'},[],[{{'$1','$2','$3'}}]}])</code></pre><p>This syntax is equivalent to the syntax used in the trace
patterns (see the
<a href="./dbg">runtime_tools/dbg</a>) module in Runtime_Tools.</p><p>The <strong>Guard</strong>s are constructed as tuples, where the first
element is the test name and the remaining elements
are the test parameters. To check for a specific type
(say a list) of the element bound to the match variable
<strong>'$1'</strong>, one would write the test as
<strong>{is_list, '$1'}</strong>. If the test fails, the object in the
table does not match and the next <strong>MatchFunction</strong> (if
any) is tried. Most guard tests present in Erlang can be
used, but only the new versions prefixed <strong>is_</strong> are
allowed (<strong>is_float</strong>, <strong>is_atom</strong>, and so on).</p><p>The <strong>Guard</strong> section can also contain logic and
arithmetic operations, which are written with the same syntax
as the guard tests (prefix notation), so that the following
guard test written in Erlang:</p><pre><code class="">
is_integer(X), is_integer(Y), X + Y &lt; 4711</code></pre><p>is expressed as follows (<strong>X</strong> replaced with <strong>'$1'</strong> and
<strong>Y</strong> with <strong>'$2'</strong>):</p><pre><code class="">
[{is_integer, '$1'}, {is_integer, '$2'}, {'&lt;', {'+', '$1', '$2'}, 4711}]</code></pre><p>For tables of type <strong>ordered_set</strong>, objects are visited
in the same order as in a <strong>first</strong>/<strong>next</strong>
traversal. This means that the match specification is
executed against objects with keys in the <strong>first</strong>/<strong>next</strong>
order and the corresponding result list is in the order of that
execution.</p><h2>select/3</h2><p>Match the objects in an ETS table against a match specification and return part of the answers.</p><p>Works like <a href="#select/2">select/2</a>,
but only returns a limited
(<strong><span class="anno">Limit</span></strong>) number of matching objects. Term
<strong><span class="anno">Continuation</span></strong> can then be used in subsequent
calls to <a href="#select/1">select/1</a>
to get the next chunk of matching
objects. This is a space-efficient way to work on objects in a
table, which is still faster than traversing the table object by
object using <a href="#first/1">first/1</a>
and <a href="#next/2">next/2</a>.</p><p>If the table is empty, <strong>'$end_of_table'</strong> is returned.</p><p>Use <a href="#safe_fixtable/2">safe_fixtable/2</a>
to guarantee <a href="#traversal">safe traversal</a>
for subsequent calls to <a href="#select/1">select/1</a>.</p><h2>select_count/2</h2><p>Match the objects in an ETS table against a match specification and return the number of objects for which the match specification returned <strong>true</strong>.</p><p>Matches the objects in table <strong><span class="anno">Tab</span></strong> using a
<a href="#match_spec">match specification</a>. If the
match specification returns <strong>true</strong> for an object, that object
considered a match and is counted. For any other result from
the match specification the object is not considered a match and is
therefore not counted.</p><p>This function can be described as a
<a href="#match_delete/2">match_delete/2</a>
function that does not delete any elements, but only counts them.</p><p>The function returns the number of objects matched.</p><h2>select_delete/2</h2><p>Match the objects in an ETS table against a match specification and delete objects where the match specification returns <strong>true</strong>.</p><p>Matches the objects in table <strong><span class="anno">Tab</span></strong> using a
<a href="#match_spec">match specification</a>. If the
match specification returns <strong>true</strong> for an object, that object is
removed from the table. For any other result from the match
specification the object is retained. This is a more general
call than the <a href="#match_delete/2">match_delete/2</a> call.</p><p>The function returns the number of objects
deleted from the table.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The match specification has to return the atom <strong>true</strong> if
the object is to be deleted. No other return value gets the
object deleted. So one cannot use the same match specification for
looking up elements as for deleting them.</p></div><h2>select_replace/2</h2><p>Match and replace objects atomically in an ETS table</p><p>Matches the objects in the table <strong><span class="anno">Tab</span></strong> using a
<a href="#match_spec">match specification</a>. For each
matched object, the existing object is replaced with
the match specification result.</p><p>The match-and-replace operation for each individual object is guaranteed to be
<a href="#concurrency">atomic and isolated</a>. The
<strong>select_replace</strong> table traversal as a whole, like all other select functions,
does not give such guarantees.</p><p>The match specifiction must be guaranteed to <em>retain the key</em>
of any matched object. If not, <strong>select_replace</strong> will fail with <strong>badarg</strong>
without updating any objects.</p><p>For the moment, due to performance and semantic constraints,
tables of type <strong>bag</strong> are not yet supported.</p><p>The function returns the total number of replaced objects.</p><p><em>Example</em></p><p>For all 2-tuples with a list in second position, add atom <strong>'marker'</strong> first in the list:</p><pre>
1&gt; <span class="input">T = ets:new(x,[]), ets:insert(T, {key, [1, 2, 3]}).</span>
true
2&gt; <span class="input">MS = ets:fun2ms(fun({K, L}) when is_list(L) -&gt; {K, [marker | L]} end).</span>
[{{'$1','$2'},[{is_list,'$2'}],[{{'$1',[marker|'$2']}}]}]
3&gt; <span class="input">ets:select_replace(T, MS).</span>
1
4&gt; <span class="input">ets:tab2list(T).</span>
[{key,[marker,1,2,3]}]
	</pre><p>A generic single object compare-and-swap operation:</p><pre>
[Old] = ets:lookup(T, Key),
New = update_object(Old),
Success = (1 =:= ets:select_replace(T, [{Old, [], [{const, New}]}])),
	</pre><h2>select_reverse/1</h2><p>Continue matching objects in an ETS table.</p><p>Continues a match started with <a href="#select_reverse/3">select_reverse/3</a>. For tables of type
<strong>ordered_set</strong>, the traversal of the table continues
to objects with keys earlier in the Erlang term order. The
returned list also contains objects with keys in reverse order.
For all other table types, the behavior is exactly that of
<a href="#select/1">select/1</a>.</p><p><em>Example:</em></p><pre><code class="">
1&gt; T = ets:new(x,[ordered_set]).
2&gt; [ ets:insert(T,{N}) || N &lt;- lists:seq(1,10) ].
...
3&gt; {R0,C0} = ets:select_reverse(T,[{'_',[],['$_']}],4).
...
4&gt; R0.
[{10},{9},{8},{7}]
5&gt; {R1,C1} = ets:select_reverse(C0).
...
6&gt; R1.
[{6},{5},{4},{3}]
7&gt; {R2,C2} = ets:select_reverse(C1).
...
8&gt; R2.
[{2},{1}]
9&gt; '$end_of_table' = ets:select_reverse(C2).
...</code></pre><h2>select_reverse/2</h2><p>Match the objects in an ETS table against a match specification.</p><p>Works like <a href="#select/2">select/2</a>,
but returns the list in reverse order for table type <strong>ordered_set</strong>.
For all other table types, the return value is identical to that of
<strong>select/2</strong>.</p><h2>select_reverse/3</h2><p>Match the objects in an ETS table against a match specification and return part of the answers.</p><p>Works like <a href="#select/3">select/3</a>,
but for table type <strong>ordered_set</strong>
traversing is done starting at the last object in
Erlang term order and moves to the first. For all other table
types, the return value is identical to that of <strong>select/3</strong>.</p><p>Notice that this is <em>not</em> equivalent to
reversing the result list of a <strong>select/3</strong> call, as the result list
is not only reversed, but also contains the last
<strong><span class="anno">Limit</span></strong>
matching objects in the table, not the first.</p><h2>setopts/2</h2><p>Set table options.</p><p>Sets table options. The only allowed option to be set after the
table has been created is
<a href="#heir">heir</a>.
The calling process must be the table owner.</p><h2>slot/2</h2><p>Return all objects in a specified slot of an ETS table. </p><p>This function is mostly for debugging purposes, Normally
<strong>first</strong>/<strong>next</strong> or <strong>last</strong>/<strong>prev</strong> are to be used
instead.</p><p>Returns all objects in slot <strong><span class="anno">I</span></strong> of table
<strong><span class="anno">Tab</span></strong>. A table can be traversed by repeatedly
calling the function,
starting with the first slot <strong><span class="anno">I</span>=0</strong> and
ending when <strong>'$end_of_table'</strong> is returned.
If argument <strong><span class="anno">I</span></strong> is out of range,
the function fails with reason <strong>badarg</strong>.</p><p>Unless a table of type <strong>set</strong>, <strong>bag</strong>, or
<strong>duplicate_bag</strong> is protected using
<a href="#safe_fixtable/2">safe_fixtable/2</a>,
a traversal can fail if
concurrent updates are made to the table. For table type
<strong>ordered_set</strong>, the function returns a list containing
object <strong><span class="anno">I</span></strong> in Erlang term order.</p><h2>tab2file/2</h2><p>Dump an ETS table to a file.</p><p>Dumps table <strong><span class="anno">Tab</span></strong> to file
<strong><span class="anno">Filename</span></strong>.</p><p>Equivalent to
<strong>tab2file(<span class="anno">Tab</span>, <span class="anno">Filename</span>,[])</strong></p><h2>tab2file/3</h2><p>Dump an ETS table to a file.</p><p>Dumps table <strong><span class="anno">Tab</span></strong> to file
<strong><span class="anno">Filename</span></strong>.</p><p>When dumping the table, some information about the table
is dumped to a header at the beginning of the dump. This
information contains data about the table type,
name, protection, size, version, and if it is a named table. It
also contains notes about what extended information is added
to the file, which can be a count of the objects in the file
or a MD5 sum of the header and records in the file.</p><p>The size field in the header might not correspond to the
number of records in the file if the table is public
and records are added or removed from the table during
dumping. Public tables updated during dump, and that one wants
to verify when reading, needs at least one field of extended
information for the read verification process to be reliable
later.</p><p>Option <strong>extended_info</strong> specifies what extra
information is written to the table dump:</p><dl><dt><strong>object_count</strong></dt><dd> <p>The number of objects written to the file is
noted in the file footer, so file truncation can be
verified even if the file was updated during dump.</p> </dd><dt><strong>md5sum</strong></dt><dd> <p>The header and objects in the file are checksummed using
the built-in MD5 functions. The MD5 sum of all objects is
written in the file footer, so that verification while reading
detects the slightest bitflip in the file data. Using this
costs a fair amount of CPU time.</p> </dd></dl><p>Whenever option <strong>extended_info</strong> is used, it
results in a file not readable by versions of ETS before
that in STDLIB 1.15.1</p><p>If option <strong>sync</strong> is set to <strong>true</strong>, it ensures that
the content of the file is written to the disk before
<strong>tab2file</strong> returns. Defaults to <strong>{sync, false}</strong>.</p><h2>tab2list/1</h2><p>Return a list of all objects in an ETS table.</p><p>Returns a list of all objects in table <strong><span class="anno">Tab</span></strong>.</p><h2>tabfile_info/1</h2><p>Return a list of all objects in an ETS table.</p><p>Returns information about the table dumped to file by
<a href="#tab2file/2">tab2file/2</a> or 
<a href="#tab2file/3">tab2file/3</a>.</p><p>The following items are returned:</p><dl><dt><strong>name</strong></dt><dd> <p>The name of the dumped table. If the table was a
named table, a table with the same name cannot exist when the
table is loaded from file with 
<a href="#file2tab/2">file2tab/2</a>.
If the table is
not saved as a named table, this field has no significance
when loading the table from file.</p> </dd><dt><strong>type</strong></dt><dd> <p>The ETS type of the dumped table (that is, <strong>set</strong>,
<strong>bag</strong>, <strong>duplicate_bag</strong>, or <strong>ordered_set</strong>). This
type is used when loading the table again.</p> </dd><dt><strong>protection</strong></dt><dd> <p>The protection of the dumped table (that is, <strong>private</strong>,
<strong>protected</strong>, or <strong>public</strong>). A table loaded from the
file gets the same protection.</p> </dd><dt><strong>named_table</strong></dt><dd> <p><strong>true</strong> if the table was a named table when dumped
to file, otherwise <strong>false</strong>. Notice that when a named table
is loaded from a file, there cannot exist a table in the
system with the same name.</p> </dd><dt><strong>keypos</strong></dt><dd> <p>The <strong>keypos</strong> of the table dumped to file, which
is used when loading the table again.</p> </dd><dt><strong>size</strong></dt><dd> <p>The number of objects in the table when the table dump
to file started. For a <strong>public</strong> table, this number
does not need to correspond to the number of objects saved to
the file, as objects can have been added or deleted by another
process during table dump.</p> </dd><dt><strong>extended_info</strong></dt><dd> <p>The extended information written in the file footer to
allow stronger verification during table loading from file, as
specified to <a href="#tab2file/3">tab2file/3</a>. Notice that this
function only tells <em>which</em> information is present, not
the values in the file footer. The value is a list containing one
or more of the atoms <strong>object_count</strong> and <strong>md5sum</strong>.</p> </dd><dt><strong>version</strong></dt><dd> <p>A tuple <strong>{<span class="anno">Major</span>,<span class="anno">Minor</span>}</strong>
containing the major and
minor version of the file format for ETS table dumps. This
version field was added beginning with STDLIB 1.5.1.
Files dumped with older versions return <strong>{0,0}</strong> in this
field.</p> </dd></dl><p>An error is returned if the file is inaccessible,
badly damaged, or not produced with
<a href="#tab2file/2">tab2file/2</a> or
<a href="#tab2file/3">tab2file/3</a>.</p><h2>table/1</h2><h2>table/2</h2><p>Return a QLC query handle.</p><p>Returns a Query List
Comprehension (QLC) query handle. The
<a href="qlc">qlc</a> module provides
a query language aimed mainly at Mnesia, but ETS
tables, Dets tables,
and lists are also recognized by QLC as sources of
data. Calling <strong>table/1,2</strong> is the means to make the
ETS table <strong>Tab</strong> usable to QLC.</p><p>When there are only simple restrictions on the key position,
QLC uses <a href="#lookup/2">lookup/2</a>
to look up the keys. When
that is not possible, the whole table is traversed.
Option <strong>traverse</strong> determines how this is done:</p><dl><dt><strong>first_next</strong></dt><dd> <p>The table is traversed one key at a time by calling
<a href="#first/1">first/1</a> and
<a href="#next/2">next/2</a>.</p> </dd><dt><strong>last_prev</strong></dt><dd> <p>The table is traversed one key at a time by calling
<a href="#last/1">last/1</a> and
<a href="#prev/2">prev/2</a>.</p> </dd><dt><strong>select</strong></dt><dd> <p>The table is traversed by calling
<a href="#select/3">select/3</a> and
<a href="#select/1">select/1</a>.
Option <strong>n_objects</strong> determines the number of objects
returned (the third argument of <strong>select/3</strong>); the
default is to return <strong>100</strong> objects at a time. The
<a href="#match_spec">match specification</a> (the
second argument of <strong>select/3</strong>) is assembled by QLC: simple
filters are translated into equivalent match specifications
while more complicated filters must be applied to all
objects returned by <strong>select/3</strong> given a match specification
that matches all objects.</p> </dd><dt><strong>{select, <span class="anno">MatchSpec</span>}</strong></dt><dd> <p>As for <strong>select</strong>, the table is traversed by calling
<a href="#select/3">select/3</a> and
<a href="#select/1">select/1</a>.
The difference is that the match specification is explicitly
specified. This is how to state match specifications that cannot
easily be expressed within the syntax provided by QLC.</p> </dd></dl><p><em>Examples:</em></p><p>An explicit match specification is here used to traverse the
table:</p><pre>
9&gt; <span class="input">true = ets:insert(Tab = ets:new(t, []), [{1,a},{2,b},{3,c},{4,d}]),</span>
<span class="input">MS = ets:fun2ms(fun({X,Y}) when (X &gt; 1) or (X &lt; 5) -&gt; {Y} end),</span>
<span class="input">QH1 = ets:table(Tab, [{traverse, {select, MS}}]).</span></pre><p>An example with an implicit match specification:</p><pre>
10&gt; <span class="input">QH2 = qlc:q([{Y} || {X,Y} &lt;- ets:table(Tab), (X &gt; 1) or (X &lt; 5)]).</span></pre><p>The latter example is equivalent to the former, which
can be verified using function <strong>qlc:info/1</strong>:</p><pre>
11&gt; <span class="input">qlc:info(QH1) =:= qlc:info(QH2).</span>
true</pre><p><strong>qlc:info/1</strong> returns information about a query handle,
and in this case identical information is returned for the
two query handles.</p><h2>take/2</h2><p>Return and remove all objects with a specified key from an ETS table.</p><p>Returns and removes a list of all objects with key
<strong><span class="anno">Key</span></strong> in table <strong><span class="anno">Tab</span></strong>.</p><p>The specified <strong><span class="anno">Key</span></strong> is used to identify the object
by either <em>comparing equal</em> the key of an object in an
<strong>ordered_set</strong> table, or <em>matching</em> in other types of
tables (for details on the difference, see
<a href="#lookup/2">lookup/2</a> and
<a href="#new/2">new/2</a>).</p><h2>test_ms/2</h2><p>Test a match specification for use in <strong>select/2</strong>. </p><p>This function is a utility to test a
<a href="#match_spec">match specification</a> used in
calls to <a href="#select/2">select/2</a>.
The function both tests <strong><span class="anno">MatchSpec</span></strong> for "syntactic"
correctness and runs the match specification against object
<strong><span class="anno">Tuple</span></strong>.</p><p>If the match specification is syntactically correct, the function
either returns <strong>{ok,<span class="anno">Result</span>}</strong>, where
<strong><span class="anno">Result</span></strong> is what would have been the result in a
real <strong>select/2</strong> call, or <strong>false</strong> if the match specification
does not match object <strong><span class="anno">Tuple</span></strong>.</p><p>If the match specification contains errors, tuple
<strong>{error, <span class="anno">Errors</span>}</strong> is returned,
where <strong><span class="anno">Errors</span></strong> is a list of natural language
descriptions of what was wrong with the match specification.</p><p>This is a useful debugging and test tool, especially when
writing complicated <strong>select/2</strong> calls.</p><p>See also: <a href="../erts/erlang#match_spec_test/3"> erlang:match_spec_test/3</a>.</p><h2>to_dets/2</h2><p>Fill a Dets table with objects from an ETS table. </p><p>Fills an already created/opened Dets table with the objects
in the already opened ETS table named <strong><span class="anno">Tab</span></strong>.
The Dets table is emptied before the objects are inserted.</p><h2>update_counter/3</h2><h2>update_counter/4</h2><h2>update_counter/3</h2><h2>update_counter/4</h2><h2>update_counter/3</h2><h2>update_counter/4</h2><p>Update a counter object in an ETS table.</p><ul><li>Tab</li></ul><ul><li>Key</li></ul><ul><li>UpdateOp</li></ul><ul><li>Pos</li></ul><ul><li>Threshold</li></ul><ul><li>SetValue</li></ul><ul><li>Default</li></ul><p>This function provides an efficient way to update one or more 
counters, without the trouble of having to look up an object, update 
the object by incrementing an element, and insert the resulting
object into the table again. The operation is guaranteed to be
<a href="#concurrency">atomic and isolated</a>.</p><p>This function destructively update the object with key
<strong><span class="anno">Key</span></strong> in table <strong><span class="anno">Tab</span></strong> by adding
<strong><span class="anno">Incr</span></strong> to the element at position
<strong><span class="anno">Pos</span></strong>. The new counter value is
returned. If no position is specified, the element directly
following key (<strong>&lt;keypos&gt;+1</strong>) is updated.</p><p>If a <strong><span class="anno">Threshold</span></strong> is specified, the counter is
reset to value <strong><span class="anno">SetValue</span></strong> if the following
conditions occur:</p><ul><li><p><strong><span class="anno">Incr</span></strong> is not negative (<strong>&gt;= 0</strong>) and
the result would be greater than (<strong>&gt;</strong>)
<strong><span class="anno">Threshold</span></strong>.</p> </li><li><p><strong><span class="anno">Incr</span></strong> is negative
(<strong>&lt; 0</strong>) and the result would be less than
(<strong>&lt;</strong>) <strong><span class="anno">Threshold</span></strong>.</p> </li></ul><p>A list of <strong><span class="anno">UpdateOp</span></strong> can be supplied to do many
update operations within the object.
The operations are carried out in the
order specified in the list. If the same counter position occurs 
more than once in the list, the corresponding counter is thus 
updated many times, each time based on the previous result.
The return value is a list of the new counter values from each 
update operation in the same order as in the operation list. If an 
empty list is specified, nothing is updated and an empty list is 
returned. If the function fails, no updates are done.</p><p>The specified <strong><span class="anno">Key</span></strong> is used to identify the object
by either <em>matching</em> the key of an object in a <strong>set</strong>
table, or <em>compare equal</em> to the key of an object in an
<strong>ordered_set</strong> table (for details on the difference, see 
<a href="#lookup/2">lookup/2</a> and 
<a href="#new/2">new/2</a>).</p><p>If a default object <strong><span class="anno">Default</span></strong> is specified,
it is used
as the object to be updated if the key is missing from the table. The
value in place of the key is ignored and replaced by the proper key
value. The return value is as if the default object had not been used,
that is, a single updated element or a list of them.</p><p>The function fails with reason <strong>badarg</strong> in the following
situations:</p><ul><li>The table type is not <strong>set</strong> or <strong>ordered_set</strong>.</li><li>No object with the correct key exists and no default object was supplied.</li><li>The object has the wrong arity.</li><li>The default object arity is smaller than <strong>&lt;keypos&gt;</strong>.</li><li>Any field from the default object that is updated is not an integer.</li><li>The element to update is not an integer.</li><li>The element to update is also the key.</li><li>Any of <strong><span class="anno">Pos</span></strong>, <strong><span class="anno">Incr</span></strong>, <strong><span class="anno">Threshold</span></strong>, or <strong><span class="anno">SetValue</span></strong> is not an integer.</li></ul><h2>update_element/3</h2><h2>update_element/3</h2><p>Update the <strong>Pos</strong>:th element of the object with a specified key in an ETS table.</p><ul><li>Tab</li></ul><ul><li>Key</li></ul><ul><li>Value</li></ul><ul><li>Pos</li></ul><p>This function provides an efficient way to update one or more 
elements within an object, without the trouble of having to look up, 
update, and write back the entire object.</p><p>This function destructively updates the object with key
<strong><span class="anno">Key</span></strong> in table <strong><span class="anno">Tab</span></strong>.
The element at position <strong><span class="anno">Pos</span></strong> is given
the value <strong><span class="anno">Value</span></strong>.</p><p>A list of <strong>{<span class="anno">Pos</span>,<span class="anno">Value</span>}</strong> can be
supplied to update many
elements within the same object. If the same position occurs more 
than once in the list, the last value in the list is written. If
the list is empty or the function fails, no updates are done.
The function is also atomic in the sense that other processes 
can never see any intermediate results.</p><p>Returns <strong>true</strong> if an object with key <strong><span class="anno">Key</span></strong>
is found, otherwise <strong>false</strong>.</p><p>The specified <strong><span class="anno">Key</span></strong> is used to identify the object
by either <em>matching</em> the key of an object in a <strong>set</strong>
table, or <em>compare equal</em> to the key of an object in an
<strong>ordered_set</strong> table (for details on the difference, see
<a href="#lookup/2">lookup/2</a> and 
<a href="#new/2">new/2</a>).</p><p>The function fails with reason <strong>badarg</strong> in the following
situations:</p><ul><li>The table type is not <strong>set</strong> or <strong>ordered_set</strong>.</li><li><strong><span class="anno">Pos</span></strong> &lt; 1.</li><li><strong><span class="anno">Pos</span></strong> &gt; object arity.</li><li>The element to update is also the key.</li></ul><h2>whereis/1</h2><p>Retrieves the tid() of a named table.</p><p>This function returns the
<a href="#type-tid">type-tid</a> of the named table
identified by <strong><span class="anno">TableName</span></strong>, or <strong>undefined</strong> if
no such table exists. The <strong>tid()</strong> can be used in place of the
table name in all operations, which is slightly faster since the name
does not have to be resolved on each call.</p><p>If the table is deleted, the <strong>tid()</strong> will be invalid even if
another named table is created with the same name.</p></body></html>