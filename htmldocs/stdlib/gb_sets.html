<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>gb_sets</h1><h1>gb_sets</h1><p>General balanced trees.</p><p>This module provides ordered sets using Prof. Arne Andersson's
General Balanced Trees. Ordered sets can be much more efficient than
using ordered lists, for larger sets, but depends on the
application.This module considers two elements as different if and only if
they do not compare equal (<strong>==</strong>).</p><h2>Complexity Note</h2><p>The complexity on set operations is bounded by either <em>O(|S|)</em> or
<em>O(|T| * log(|S|))</em>, where S is the largest given set, depending
on which is fastest for any particular function call. For
operating on sets of almost equal size, this implementation is
about 3 times slower than using ordered-list sets directly. For
sets of very different sizes, however, this solution can be
arbitrarily much faster; in practical cases, often
10-100 times. This implementation is particularly suited for
accumulating elements a few at a time, building up a large set
(&gt; 100-200 elements), and repeatedly testing for
membership in the current set.</p><p>As with normal tree structures, lookup (membership testing),
insertion, and deletion have logarithmic complexity.</p><h2>Compatibility</h2><p>The following functions in this module also exist and provides
the same functionality in the
<a href="sets">sets</a> and
<a href="ordsets">ordsets</a>
modules. That is, by only changing the module name for each call,
you can try out different set representations.</p><ul><li><a href="#add_element/2">add_element/2</a> </li><li><a href="#del_element/2">del_element/2</a> </li><li><a href="#filter/2">filter/2</a> </li><li><a href="#fold/3">fold/3</a> </li><li><a href="#from_list/1">from_list/1</a> </li><li><a href="#intersection/1">intersection/1</a> </li><li><a href="#intersection/2">intersection/2</a> </li><li><a href="#is_element/2">is_element/2</a> </li><li><a href="#is_empty/1">is_empty/1</a> </li><li><a href="#is_set/1">is_set/1</a> </li><li><a href="#is_subset/2">is_subset/2</a> </li><li><a href="#new/0">new/0</a> </li><li><a href="#size/1">size/1</a> </li><li><a href="#subtract/2">subtract/2</a> </li><li><a href="#to_list/1">to_list/1</a> </li><li><a href="#union/1">union/1</a> </li><li><a href="#union/2">union/2</a> </li></ul><h1>Data Types</h1><span class="name">set</span><p>A general balanced set.</p><span class="name">set</span><span class="name">iter</span><p>A general balanced set iterator.</p><span class="name">iter</span><h1>Functions</h1><h2>add/2</h2><h2>add_element/2</h2><p>Add a (possibly existing) element to a set.</p><p>Returns a new set formed from <strong><span class="anno">Set1</span></strong> with
<strong><span class="anno">Element</span></strong> inserted. If <strong><span class="anno">Element</span></strong>
is already an
element in <strong><span class="anno">Set1</span></strong>, nothing is changed.</p><h2>balance/1</h2><p>Rebalance tree representation of a set.</p><p>Rebalances the tree representation of <strong><span class="anno">Set1</span></strong>.
Notice that
this is rarely necessary, but can be motivated when a large
number of elements have been deleted from the tree without
further insertions. Rebalancing can then be forced
to minimise lookup times, as deletion does not
rebalance the tree.</p><h2>del_element/2</h2><p>Remove a (possibly non-existing) element from a set.</p><p>Returns a new set formed from <strong><span class="anno">Set1</span></strong> with
<strong><span class="anno">Element</span></strong> removed. If <strong><span class="anno">Element</span></strong>
is not an element
in <strong><span class="anno">Set1</span></strong>, nothing is changed.</p><h2>delete/2</h2><p>Remove an element from a set.</p><p>Returns a new set formed from <strong><span class="anno">Set1</span></strong> with
<strong><span class="anno">Element</span></strong> removed. Assumes that
<strong><span class="anno">Element</span></strong> is present
in <strong><span class="anno">Set1</span></strong>.</p><h2>delete_any/2</h2><p>Remove a (possibly non-existing) element from a set.</p><p>Returns a new set formed from <strong><span class="anno">Set1</span></strong> with
<strong><span class="anno">Element</span></strong> removed. If <strong><span class="anno">Element</span></strong>
is not an element
in <strong><span class="anno">Set1</span></strong>, nothing is changed.</p><h2>difference/2</h2><p>Return the difference of two sets.</p><p>Returns only the elements of <strong><span class="anno">Set1</span></strong> that are not
also elements of <strong><span class="anno">Set2</span></strong>.</p><h2>empty/0</h2><p>Return an empty set.</p><p>Returns a new empty set.</p><h2>filter/2</h2><p>Filter set elements.</p><p>Filters elements in <strong><span class="anno">Set1</span></strong> using predicate function
<strong><span class="anno">Pred</span></strong>.</p><h2>fold/3</h2><p>Fold over set elements.</p><p>Folds <strong><span class="anno">Function</span></strong> over every element in
<strong><span class="anno">Set</span></strong>
returning the final value of the accumulator.</p><h2>from_list/1</h2><p>Convert a list into a set.</p><p>Returns a set of the elements in <strong><span class="anno">List</span></strong>, where
<strong><span class="anno">List</span></strong> can be unordered and contain duplicates.</p><h2>from_ordset/1</h2><p>Make a set from an ordset list.</p><p>Turns an ordered-set list <strong><span class="anno">List</span></strong> into a set.
The list must not contain duplicates.</p><h2>insert/2</h2><p>Add a new element to a set.</p><p>Returns a new set formed from <strong><span class="anno">Set1</span></strong> with
<strong><span class="anno">Element</span></strong> inserted. Assumes that
<strong><span class="anno">Element</span></strong> is not
present in <strong><span class="anno">Set1</span></strong>.</p><h2>intersection/1</h2><p>Return the intersection of a list of sets.</p><p>Returns the intersection of the non-empty list of sets.</p><h2>intersection/2</h2><p>Return the intersection of two sets.</p><p>Returns the intersection of <strong><span class="anno">Set1</span></strong> and
<strong><span class="anno">Set2</span></strong>.</p><h2>is_disjoint/2</h2><p>Check whether two sets are disjoint.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Set1</span></strong> and
<strong><span class="anno">Set2</span></strong> are disjoint (have no elements in common),
otherwise <strong>false</strong>.</p><h2>is_element/2</h2><p>Test for membership of a set.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Element</span></strong> is an element of
<strong><span class="anno">Set</span></strong>, otherwise <strong>false</strong>.</p><h2>is_empty/1</h2><p>Test for empty set.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Set</span></strong> is an empty set,
otherwise <strong>false</strong>.</p><h2>is_member/2</h2><p>Test for membership of a set.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Element</span></strong> is an element of
<strong><span class="anno">Set</span></strong>, otherwise <strong>false</strong>.</p><h2>is_set/1</h2><p>Test for a set.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> appears to be a set,
otherwise <strong>false</strong>.</p><h2>is_subset/2</h2><p>Test for subset.</p><p>Returns <strong>true</strong> when every element of <strong><span class="anno">Set1</span></strong> is
also a member of <strong><span class="anno">Set2</span></strong>, otherwise <strong>false</strong>.</p><h2>iterator/1</h2><p>Return an iterator for a set.</p><p>Returns an iterator that can be used for traversing the entries of
<strong><span class="anno">Set</span></strong>; see
<a href="#next/1">next/1</a>. The implementation
of this is very efficient; traversing the whole set using
<strong>next/1</strong> is only slightly slower than getting the list of all
elements using <a href="#to_list/1">to_list/1</a>
and traversing that.
The main advantage of the iterator approach is that it does
not require the complete list of all elements to be built in
memory at one time.</p><h2>iterator_from/2</h2><p>Return an iterator for a set starting from a specified element. </p><p>Returns an iterator that can be used for traversing the
entries of <strong><span class="anno">Set</span></strong>; see
<a href="#next/1">next/1</a>.
The difference as compared to the iterator returned by
<a href="#iterator/1">iterator/1</a>
is that the first element greater than
or equal to <strong><span class="anno">Element</span></strong> is returned.</p><h2>largest/1</h2><p>Return largest element.</p><p>Returns the largest element in <strong><span class="anno">Set</span></strong>. Assumes that
<strong><span class="anno">Set</span></strong> is not empty.</p><h2>new/0</h2><p>Return an empty set.</p><p>Returns a new empty set.</p><h2>next/1</h2><p>Traverse a set with an iterator.</p><p>Returns <strong>{<span class="anno">Element</span>, <span class="anno">Iter2</span>}</strong>, where
<strong><span class="anno">Element</span></strong> is the smallest element referred to by
iterator <strong><span class="anno">Iter1</span></strong>,
and <strong><span class="anno">Iter2</span></strong> is the new iterator to be used for
traversing the remaining elements, or the atom <strong>none</strong> if
no elements remain.</p><h2>singleton/1</h2><p>Return a set with one element.</p><p>Returns a set containing only element <strong><span class="anno">Element</span></strong>.
</p><h2>size/1</h2><p>Return the number of elements in a set.</p><p>Returns the number of elements in <strong><span class="anno">Set</span></strong>.</p><h2>smallest/1</h2><p>Return smallest element.</p><p>Returns the smallest element in <strong><span class="anno">Set</span></strong>. Assumes that
<strong><span class="anno">Set</span></strong> is not empty.</p><h2>subtract/2</h2><p>Return the difference of two sets.</p><p>Returns only the elements of <strong><span class="anno">Set1</span></strong> that are not
also elements of <strong><span class="anno">Set2</span></strong>.</p><h2>take_largest/1</h2><p>Extract largest element.</p><p>Returns <strong>{<span class="anno">Element</span>, <span class="anno">Set2</span>}</strong>, where
<strong><span class="anno">Element</span></strong> is the largest element in
<strong><span class="anno">Set1</span></strong>, and <strong><span class="anno">Set2</span></strong> is this set
with <strong><span class="anno">Element</span></strong> deleted. Assumes that
<strong><span class="anno">Set1</span></strong> is not empty.</p><h2>take_smallest/1</h2><p>Extract smallest element.</p><p>Returns <strong>{<span class="anno">Element</span>, <span class="anno">Set2</span>}</strong>, where
<strong><span class="anno">Element</span></strong> is the smallest element in
<strong><span class="anno">Set1</span></strong>, and <strong><span class="anno">Set2</span></strong> is this set
with <strong><span class="anno">Element</span></strong> deleted. Assumes that
<strong><span class="anno">Set1</span></strong> is not empty.</p><h2>to_list/1</h2><p>Convert a set into a list.</p><p>Returns the elements of <strong><span class="anno">Set</span></strong> as a list.</p><h2>union/1</h2><p>Return the union of a list of sets.</p><p>Returns the merged (union) set of the list of sets.</p><h2>union/2</h2><p>Return the union of two sets.</p><p>Returns the merged (union) set of <strong><span class="anno">Set1</span></strong> and
<strong><span class="anno">Set2</span></strong>.</p><h2>See Also</h2><p><a href="gb_trees">gb_trees</a>,
<a href="ordsets">ordsets</a>,
<a href="sets">sets</a></p></body></html>