<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>dets</h1><h1>dets</h1><p>A disk-based term storage.</p><p>This module provides a term storage on file. The
stored terms, in this module called <em>objects</em>, are tuples
such that one element is defined to be the key. A Dets
<em>table</em> is a collection of objects with the key at the same
position stored on a file.This module is used by the Mnesia application, and is provided
"as is" for users who are interested in efficient storage of Erlang
terms on disk only. Many applications only need to store some
terms in a file. Mnesia adds transactions, queries, and
distribution. The size of Dets files cannot exceed 2 GB. If larger
tables are needed, table fragmentation in Mnesia can be used.Three types of Dets tables exist:<ul><li><p><strong>set</strong>. A table of this type has at most one object with a
given key. If an object with a key already present in the
table is inserted, the existing object is overwritten by the new
object.</p> </li><li><p><strong>bag</strong>. A table of this type has zero or more different
objects with a given key.</p> </li><li><p><strong>duplicate_bag</strong>. A table of this type has zero or more
possibly matching objects with a given key.</p> </li></ul>Dets tables must be opened before they can be updated or read,
and when finished they must be properly closed. If a table is not
properly closed, Dets automatically repairs the table.
This can take a substantial time if the table is large. A Dets
table is closed when the process which opened the table
terminates. If many Erlang processes (users) open the same Dets
table, they share the table. The table is properly closed
when all users have either terminated or closed the table. Dets
tables are not properly closed if the Erlang runtime system
terminates abnormally.As all operations performed by Dets are disk operations, it
is important to realize that a single look-up operation involves a
series of disk seek and read operations. The Dets functions
are therefore much slower than the corresponding
<a href="ets">ets</a> functions,
although Dets exports a similar interface.Dets organizes data as a linear hash list and the hash list
grows gracefully as more data is inserted into the table. Space
management on the file is performed by what is called a buddy
system. The current implementation keeps the entire buddy system
in RAM, which implies that if the table gets heavily fragmented,
quite some memory can be used up. The only way to defragment a
table is to close it and then open it again with option <strong>repair</strong>
set to <strong>force</strong>.Notice that type <strong>ordered_set</strong> in Ets is not yet
provided by Dets, neither is the limited support for
concurrent updates that makes a sequence of <strong>first</strong> and
<strong>next</strong> calls safe to use on fixed ETS tables. Both these
features may be provided by Dets in a future release of
Erlang/OTP. Until then, the Mnesia application (or some
user-implemented method for locking) must be used to implement safe
concurrency. Currently, no Erlang/OTP library has support for
ordered disk-based term storage.All Dets functions return <strong>{error, Reason}</strong> if an error
occurs (<a href="#first/1">first/1</a> and
<a href="#next/2">next/2</a> are exceptions, they
exit the process with the error tuple). If badly formed arguments are
specified, all functions exit the process with a <strong>badarg</strong>
message.</p><h1>Data Types</h1><span class="name">access</span><span class="name">auto_save</span><span class="name">bindings_cont</span><p>Opaque continuation used by <a href="#match/1">match/1</a> and <a href="#match/3">match/3</a>.</p><span class="name">cont</span><p>Opaque continuation used by <a href="#bchunk/2">bchunk/2</a>.</p><span class="name">keypos</span><span class="name">match_spec</span><p>Match specifications, see section
<a href="./match_spec"> Match Specification in Erlang</a> in ERTS User's Guide and the
<a href="ms_transform">ms_transform</a>
module.</p><span class="name">no_slots</span><span class="name">object</span><span class="name">object_cont</span><p>Opaque continuation used by <a href="#match_object/1">match_object/1</a> and
<a href="#match_object/3">match_object/3</a>.</p><span class="name">pattern</span><p>For a description of patterns, see
<a href="./ets#match/2">ets#match/2</a>.</p><span class="name">select_cont</span><p>Opaque continuation used by <a href="#select/1">select/1</a> and <a href="#select/3">select/3</a>.</p><span class="name">tab_name</span><span class="name">type</span><h1>Functions</h1><h2>all/0</h2><p>Return a list of the names of all open Dets tables on this node.</p><p>Returns a list of the names of all open tables on this node.</p><h2>bchunk/2</h2><p>Return a chunk of objects stored in a Dets table. </p><p>Returns a list of objects stored in a table. The exact
representation of the returned objects is not public. The
lists of data can be used for initializing a table by specifying
value <strong>bchunk</strong> to option <strong>format</strong> of function
<a href="#init_table/3">init_table/3</a>
The Mnesia application uses this
function for copying open tables.</p><p>Unless the table is protected using <strong>safe_fixtable/2</strong>,
calls to <strong>bchunk/2</strong> do possibly not work as expected if
concurrent updates are made to the table.</p><p>The first time <strong>bchunk/2</strong> is called, an initial
continuation, the atom <strong>start</strong>, must be provided.</p><p><strong>bchunk/2</strong> returns a tuple
<strong>{<span class="anno">Continuation2</span>, <span class="anno">Data</span>}</strong>,
where <strong><span class="anno">Data</span></strong> is a list of
objects. <strong><span class="anno">Continuation2</span></strong> is another continuation
that is to be passed on to a subsequent call to <strong>bchunk/2</strong>. With
a series of calls to <strong>bchunk/2</strong>, all table objects can be
extracted.</p><p><strong>bchunk/2</strong> returns <strong>'$end_of_table'</strong> when all
objects are returned, or <strong>{error, <span class="anno">Reason</span>}</strong>
if an error occurs.</p><h2>close/1</h2><p>Close a Dets table.</p><p>Closes a table. Only processes that have opened a table are
allowed to close it.</p><p>All open tables must be closed before the system is
stopped. If an attempt is made to open a table that is not
properly closed, Dets automatically tries to repair it.</p><h2>delete/2</h2><p>Delete all objects with a specified key from a Dets table.</p><p>Deletes all objects with key <strong><span class="anno">Key</span></strong> from
table <strong><span class="anno">Name</span></strong>.</p><h2>delete_all_objects/1</h2><p>Delete all objects from a Dets table.</p><p>Deletes all objects from a table in almost constant time.
However, if the table if fixed, <strong>delete_all_objects(T)</strong>
is equivalent to <strong>match_delete(T, '_')</strong>.</p><h2>delete_object/2</h2><p>Delete a specified object from a Dets table.</p><p>Deletes all instances of a specified object from a table. If a
table is of type <strong>bag</strong> or <strong>duplicate_bag</strong>, this
function can be used to delete only some of
the objects with a specified key.</p><h2>first/1</h2><p>Return the first key stored in a Dets table.</p><p>Returns the first key stored in table <strong><span class="anno">Name</span></strong>
according to the internal order of the table, or
<strong>'$end_of_table'</strong> if the table is empty.</p><p>Unless the table is protected using <strong>safe_fixtable/2</strong>,
subsequent calls to <a href="#next/2">next/2</a>
do possibly not work as expected if
concurrent updates are made to the table.</p><p>If an error occurs, the process is exited with an error
tuple <strong>{error, Reason}</strong>. The error tuple is not returned,
as it cannot be distinguished from a key.</p><p>There are two reasons why <strong>first/1</strong> and <strong>next/2</strong>
are not to be used: they are not efficient, and they
prevent the use of key <strong>'$end_of_table'</strong>, as this atom
is used to indicate the end of the table. If possible, use functions
<a href="#match/1">match/1</a>,
<a href="#match_object/1">match_object/1</a>, and
<a href="#select/1">select/1</a>
for traversing tables.</p><h2>foldl/3</h2><h2>foldr/3</h2><p>Fold a function over a Dets table.</p><p>Calls <strong><span class="anno">Function</span></strong> on successive elements of
table <strong><span class="anno">Name</span></strong> together with an extra argument
<strong>AccIn</strong>. The table elements are traversed in unspecified
order. <strong><span class="anno">Function</span></strong> must return a new
accumulator that is passed to the next call.
<strong><span class="anno">Acc0</span></strong> is returned if the table is empty.</p><h2>from_ets/2</h2><p>Replace the objects of a Dets table with the objects of an ETS table.</p><p>Deletes all objects of table <strong><span class="anno">Name</span></strong> and then
inserts all the objects of the ETS table
<strong><span class="anno">EtsTab</span></strong>. The objects are inserted in unspecified
order. As <strong>ets:safe_fixtable/2</strong> is called, the ETS table
must be public or owned by the calling process.</p><h2>info/1</h2><p>Return information about a Dets table.</p><p>Returns information about table <strong><span class="anno">Name</span></strong>
as a list of tuples:</p><ul><li> <p><strong>{file_size, integer() &gt;= 0}}</strong> - The file size, in
bytes.</p> </li><li> <p><strong>{filename, </strong><a href="./file#type-name">file#type-name</a><strong>}</strong> - The name of the file
where objects are stored.</p> </li><li> <p><strong>{keypos, </strong><a href="#type-keypos">type-keypos</a><strong>}</strong> - The key position.</p> </li><li> <p><strong>{size, integer() &gt;= 0}</strong> - The number of objects
stored in the table.</p> </li><li> <p><strong>{type, </strong><a href="#type-type">type-type</a><strong>}</strong> - The table type.</p> </li></ul><h2>info/2</h2><p>Return the information associated with a specified item for a Dets table.</p><p>Returns the information associated with <strong><span class="anno">Item</span></strong>
for table <strong><span class="anno">Name</span></strong>.
In addition to the <strong>{<span class="anno">Item</span>, <span class="anno">Value</span>}</strong>
pairs defined for <a href="#info/1">info/1</a>,
the following items are allowed:</p><ul><li> <p><strong>{access, </strong><a href="#type-access">type-access</a><strong>}</strong> - The access mode.</p> </li><li> <p><strong>{auto_save, </strong><a href="#type-auto_save">type-auto_save</a><strong>}</strong> - The autosave interval.</p> </li><li> <p><strong>{bchunk_format, binary()}</strong> - An opaque binary
describing the format of the objects returned by
<strong>bchunk/2</strong>. The binary can be used as argument to
<strong>is_compatible_chunk_format/2</strong>.</p> </li><li> <p><strong>{hash, Hash}</strong> - Describes which BIF is
used to calculate the hash values of the objects stored in the
Dets table. Possible values of <strong>Hash</strong>:</p> <ul><li> <p><strong>phash</strong> - Implies that the <strong>erlang:phash/2</strong> BIF
is used.</p> </li><li> <p><strong>phash2</strong> - Implies that the <strong>erlang:phash2/1</strong> BIF
is used.</p> </li></ul> </li><li> <p><strong>{memory, integer() &gt;= 0}</strong> - The file size, in bytes.
The same value is associated with item <strong>file_size</strong>.</p> </li><li> <p><strong>{no_keys, integer &gt;= 0()}</strong> - The number of different
keys stored in the table.</p> </li><li> <p><strong>{no_objects, integer &gt;= 0()}</strong> - The number of objects
stored in the table.</p> </li><li> <p><strong>{no_slots, {Min, Used, Max}}</strong> - The
number of slots of the table. <strong>Min</strong> is the minimum number of
slots, <strong>Used</strong> is the number of currently used slots,
and <strong>Max</strong> is the maximum number of slots.</p> </li><li> <p><strong>{owner, pid()}</strong> - The pid of the process that
handles requests to the Dets table.</p> </li><li> <p><strong>{ram_file, boolean()}</strong> - Whether the table is
kept in RAM.</p> </li><li> <p><strong>{safe_fixed_monotonic_time, SafeFixed}</strong> - If the table
is fixed, <strong>SafeFixed</strong> is a tuple
<strong>{FixedAtTime, [{Pid,RefCount}]}</strong>.
<strong>FixedAtTime</strong> is the time when
the table was first fixed, and <strong>Pid</strong> is the pid of
the process that fixes the table <strong>RefCount</strong> times.
There can be any number of processes in the list. If the table
is not fixed, <strong>SafeFixed</strong> is the atom <strong>false</strong>.</p> <p><strong>FixedAtTime</strong> corresponds to the result returned by
<a href="../erts/erlang#monotonic_time/0">erts/erlang#monotonic_time/0</a> at the time of fixation.
The use of <strong>safe_fixed_monotonic_time</strong> is
<a href="../erts/time_correction#Time_Warp_Safe_Code"> time warp safe</a>.</p> </li><li> <p><strong>{safe_fixed, SafeFixed}</strong> - The same as
<strong>{safe_fixed_monotonic_time, SafeFixed}</strong> except
the format and value of <strong>FixedAtTime</strong>.</p> <p><strong>FixedAtTime</strong> corresponds to the result returned by
<a href="../erts/erlang#timestamp/0">erts/erlang#timestamp/0</a> at the time of fixation.
Notice that when the system uses single or multi
<a href="../erts/time_correction#Time_Warp_Modes">time warp modes</a>, this can produce strange results. This is
because the use of <strong>safe_fixed</strong> is not
<a href="../erts/time_correction#Time_Warp_Safe_Code"> time warp safe</a>. Time warp safe code must use
<strong>safe_fixed_monotonic_time</strong> instead.</p> </li></ul><h2>init_table/2</h2><h2>init_table/3</h2><p>Replace all objects of a Dets table.</p><p>Replaces the existing objects of table <strong><span class="anno">Name</span></strong>
with objects created by calling the input function
<strong><span class="anno">InitFun</span></strong>,
see below. The reason for using this function rather than
calling <strong>insert/2</strong> is that of efficiency. Notice
that the input functions are called by the process that
handles requests to the Dets table, not by the calling
process.</p><p>When called with argument <strong>read</strong>, function
<strong><span class="anno">InitFun</span></strong> is assumed to return <strong>end_of_input</strong>
when there is no more input, or <strong>{Objects, Fun}</strong>, where
<strong>Objects</strong> is a list of objects and <strong>Fun</strong> is a new
input function. Any other value <strong>Value</strong> is returned as an error
<strong>{error, {init_fun, Value}}</strong>. Each input function is
called exactly once, and if an error occurs, the last
function is called with argument <strong>close</strong>, the reply
of which is ignored.</p><p>If the table type is <strong>set</strong> and more
than one object exists with a given key, one of the objects is
chosen. This is not necessarily the last object with the given
key in the sequence of objects returned by the input
functions. Avoid duplicate keys, otherwise the file becomes 
unnecessarily fragmented. This holds also for duplicated
objects stored in tables of type <strong>bag</strong>.</p><p>It is important that the table has a sufficient number of
slots for the objects. If not, the hash list starts to
grow when <strong>init_table/2</strong> returns, which significantly
slows down access to the table for a period of time. The
minimum number of slots is set by the <strong>open_file/2</strong> option
<strong>min_no_slots</strong> and returned by the <strong>info/2</strong>
item <strong>no_slots</strong>. See also option <strong>min_no_slots</strong> below.</p><p>Argument <strong><span class="anno">Options</span></strong> is a list of <strong>{Key, Val}</strong>
tuples, where the following values are allowed:</p><ul><li> <p><strong>{min_no_slots, no_slots()}</strong> - Specifies the
estimated number of different keys to be stored
in the table. The <strong>open_file/2</strong> option with the same
name is ignored, unless the table is created, in which
case performance can be enhanced by supplying an
estimate when initializing the table.</p> </li><li> <p><strong>{format, Format}</strong> - Specifies the format of the
objects returned by function <strong><span class="anno">InitFun</span></strong>. If
<strong>Format</strong> is <strong>term</strong> (the default),
<strong><span class="anno">InitFun</span></strong> is assumed to return a list of tuples.
If <strong>Format</strong> is <strong>bchunk</strong>, <strong><span class="anno">InitFun</span></strong> is
assumed to return <strong><span class="anno">Data</span></strong> as returned by
<a href="#bchunk/2">bchunk/2</a>.
This option overrides option <strong>min_no_slots</strong>.</p> </li></ul><h2>insert/2</h2><p>Insert one or more objects into a Dets table.</p><p>Inserts one or more objects into the table <strong><span class="anno">Name</span></strong>.
If there already exists an object with a key matching the key of
some of the given objects and the table type is <strong>set</strong>,
the old object will be replaced.</p><h2>insert_new/2</h2><p>Insert one or more objects into a Dets table.</p><p>Inserts one or more objects into table <strong><span class="anno">Name</span></strong>.
If there already exists some object with a key matching the key
of any of the specified objects, the table is not updated and
<strong>false</strong> is returned. Otherwise the objects are inserted
and <strong>true</strong> returned.</p><h2>is_compatible_bchunk_format/2</h2><p>Test compatibility of chunk data of a table.</p><p>Returns <strong>true</strong> if it would be possible to initialize
table <strong><span class="anno">Name</span></strong>, using
<a href="#init_table/3">init_table/3</a> with
option <strong>{format,Â bchunk}</strong>,  with objects read with
<a href="#bchunk/2">bchunk/2</a> from some
table <strong>T</strong>, such that calling
<strong>info(T,Â bchunk_format)</strong> returns
<strong>BchunkFormat</strong>.</p><h2>is_dets_file/1</h2><p>Test for a Dets table.</p><p>Returns <strong>true</strong> if file <strong><span class="anno">Filename</span></strong>
is a Dets table, otherwise <strong>false</strong>.</p><h2>lookup/2</h2><p>Return all objects with a specified key stored in a Dets table.</p><p>Returns a list of all objects with key <strong><span class="anno">Key</span></strong>
stored in table <strong><span class="anno">Name</span></strong>, for example:</p><pre>
2&gt; <span class="input">dets:open_file(abc, [{type, bag}]).</span>
{ok,abc}
3&gt; <span class="input">dets:insert(abc, {1,2,3}).</span>
ok
4&gt; <span class="input">dets:insert(abc, {1,3,4}).</span>
ok
5&gt; <span class="input">dets:lookup(abc, 1).</span>
[{1,2,3},{1,3,4}]</pre><p>If the table type is <strong>set</strong>, the function returns
either the empty list or a list with one object, as there
cannot be more than one object with a given key. If the table
type is <strong>bag</strong> or <strong>duplicate_bag</strong>, the function
returns a list of arbitrary length.</p><p>Notice that the order of objects returned is unspecified. In
particular, the order in which objects were inserted is not
reflected.</p><h2>match/1</h2><p>Match a chunk of objects stored in a Dets table and return a list of variable bindings.</p><p>Matches some objects stored in a table and returns a
non-empty list of the bindings matching a specified pattern in
some unspecified order. The table, the pattern, and the number
of objects that are matched are all defined by
<strong><span class="anno">Continuation</span></strong>, which has been returned by a
previous call to <strong>match/1</strong> or <strong>match/3</strong>.</p><p>When all table objects are matched,
<strong>'$end_of_table'</strong> is returned.</p><h2>match/2</h2><p>Match the objects stored in a Dets table and return a list of variable bindings.</p><p>Returns for each object of table <strong><span class="anno">Name</span></strong> that
matches <strong><span class="anno">Pattern</span></strong> a list of bindings in some
unspecified order. For a description of patterns, see
<a href="./ets#match/2">ets#match/2</a>.
If the keypos'th element of
<strong><span class="anno">Pattern</span></strong> is unbound, all table objects are
matched. If the keypos'th element is bound, only the
objects with the correct key are matched.</p><h2>match/3</h2><p>Match the first chunk of objects stored in a Dets table and return a list of variable bindings.</p><p>Matches some or all objects of table <strong><span class="anno">Name</span></strong> and
returns a non-empty list of the bindings that match
<strong><span class="anno">Pattern</span></strong> in some unspecified order.
For a description of patterns, see
<a href="./ets#match/2">ets#match/2</a>.</p><p>A tuple of the bindings and a continuation is returned,
unless the table is empty, in which case
<strong>'$end_of_table'</strong> is returned. The continuation is to be
used when matching further objects by calling
<a href="#match/1">match/1</a>.</p><p>If the keypos'th element of <strong><span class="anno">Pattern</span></strong> is bound,
all table objects are matched. If the keypos'th element is
unbound, all table objects are matched, <strong><span class="anno">N</span></strong>
objects at a time, until at least one object matches or the
end of the table is reached. The default, indicated by
giving <strong><span class="anno">N</span></strong> the value <strong>default</strong>, is to let
the number of objects vary depending on the sizes of the objects.
All objects with the
same key are always matched at the same time, which implies that
more than <span class="anno">N</span> objects can sometimes be matched.</p><p>The table is always to be protected using
<a href="#safe_fixtable/2">safe_fixtable/2</a>
before calling <strong>match/3</strong>, otherwise
errors can occur when calling <strong>match/1</strong>.</p><h2>match_delete/2</h2><p>Delete all objects that match a given pattern from a Dets table.</p><p>Deletes all objects that match <strong><span class="anno">Pattern</span></strong> from
table <strong><span class="anno">Name</span></strong>. For a description of patterns,
see <a href="./ets#match/2">ets#match/2</a>.</p><p>If the keypos'th element of <strong>Pattern</strong> is bound,
only the objects with the correct key are matched.</p><h2>match_object/1</h2><p>Match a chunk of objects stored in a Dets table and return a list of objects.</p><p>Returns a non-empty list of some objects stored in a table
that match a given pattern in some unspecified order. The
table, the pattern, and the number of objects that are matched
are all defined by <strong><span class="anno">Continuation</span></strong>, which has been
returned by a previous call to <strong>match_object/1</strong> or
<strong>match_object/3</strong>.</p><p>When all table objects are matched,
<strong>'$end_of_table'</strong> is returned.</p><h2>match_object/2</h2><p>Match the objects stored in a Dets table and return a list of objects.</p><p>Returns a list of all objects of table <strong><span class="anno">Name</span></strong> that
match <strong><span class="anno">Pattern</span></strong> in some unspecified order.
For a description of patterns, see
<a href="./ets#match/2">ets#match/2</a>.</p><p>If the keypos'th element of <strong><span class="anno">Pattern</span></strong> is
unbound, all table objects are matched. If the
keypos'th element of <strong><span class="anno">Pattern</span></strong> is bound, only the
objects with the correct key are matched.</p><p>Using the <strong>match_object</strong> functions for traversing all
table objects is more efficient than calling
<strong>first/1</strong> and <strong>next/2</strong> or <strong>slot/2</strong>.</p><h2>match_object/3</h2><p>Match the first chunk of objects stored in a Dets table and return a list of objects.</p><p>Matches some or all objects stored in table <strong><span class="anno">Name</span></strong>
and returns a non-empty list of the objects that match
<strong><span class="anno">Pattern</span></strong> in some unspecified order.
For a description of patterns, see
<a href="./ets#match/2">ets#match/2</a>.</p><p>A list of objects and a continuation is returned, unless
the table is empty, in which case <strong>'$end_of_table'</strong>
is returned. The continuation is to be used when matching
further objects by calling
<a href="#match_object/1">match_object/1</a>.</p><p>If the keypos'th element of <strong><span class="anno">Pattern</span></strong> is bound,
all table objects are matched. If the keypos'th element is
unbound, all table objects are matched, <strong><span class="anno">N</span></strong>
objects at a time, until at least one object matches or the
end of the table is reached. The default, indicated by
giving <strong><span class="anno">N</span></strong> the value <strong>default</strong>,
is to let the number
of objects vary depending on the sizes of the objects. All
matching objects with the same key are always returned
in the same reply, which implies
that more than <span class="anno">N</span> objects can sometimes be returned.</p><p>The table is always to be protected using
<a href="#safe_fixtable/2">safe_fixtable/2</a>
before calling <strong>match_object/3</strong>, otherwise
errors can occur when calling <strong>match_object/1</strong>.</p><h2>member/2</h2><p>Test for occurrence of a key in a Dets table.</p><p>Works like <a href="#lookup/2">lookup/2</a>,
but does not return the objects. Returns <strong>true</strong> if one or more
table elements has key <strong><span class="anno">Key</span></strong>, otherwise
<strong>false</strong>.</p><h2>next/2</h2><p>Return the next key in a Dets table.</p><p>Returns either the key following <strong><span class="anno">Key1</span></strong> in table
<strong><span class="anno">Name</span></strong> according to the internal order of the
table, or <strong>'$end_of_table'</strong> if there is no next key.</p><p>If an error occurs, the process is exited with an error
tuple <strong>{error, Reason}</strong>.</p><p>To find the first key in the table, use
<a href="#first/1">first/1</a>.</p><h2>open_file/1</h2><p>Open an existing Dets table.</p><p>Opens an existing table. If the table is not properly closed,
it is repaired. The returned reference is to be used as the table
name. This function is most useful for debugging purposes.</p><h2>open_file/2</h2><p>Open a Dets table.</p><p>Opens a table. An empty Dets table is created if no file
exists.</p><p>The atom <strong><span class="anno">Name</span></strong> is the table name. The table
name must be provided in all subsequent operations on the
table. The name can be used by other processes as well, and
many processes can share one table.</p><p>If two processes open the same table by giving the same
name and arguments, the table has two users. If one
user closes the table, it remains open until the second
user closes it.</p><p>Argument <strong><span class="anno">Args</span></strong> is a list of <strong>{Key, Val}</strong>
tuples, where the following values are allowed:</p><ul><li> <p><strong>{access, </strong><a href="#type-access">type-access</a><strong>}</strong> - Existing tables can be
opened in read-only mode. A table that is opened
in read-only mode is not subjected to the automatic file
reparation algorithm if it is later opened after a crash.
Defaults to <strong>read_write</strong>.</p> </li><li> <p><strong>{auto_save, </strong><a href="#type-auto_save">type-auto_save</a><strong>}</strong> - The autosave
interval. If the interval is an integer <strong>Time</strong>, the
table is flushed to disk whenever it is not accessed for
<strong>Time</strong> milliseconds. A table that has been flushed
requires no reparation when reopened after an
uncontrolled emulator halt. If the interval is the atom
<strong>infinity</strong>, autosave is disabled. Defaults to
180000 (3 minutes).</p> </li><li> <p><strong>{estimated_no_objects, </strong><a href="#type-no_slots">type-no_slots</a><strong>}</strong> - Equivalent to option
<strong>min_no_slots</strong>.</p> </li><li> <p><strong>{file, </strong><a href="./file#type-name">file#type-name</a><strong>}</strong> - The name of the file to be
opened. Defaults to the table name.</p> </li><li> <p><strong>{max_no_slots, </strong><a href="#type-no_slots">type-no_slots</a><strong>}</strong> - The maximum number
of slots to be used. Defaults to 32 M, which is the
maximal value. Notice that a higher value can
increase the table fragmentation, and
a smaller value can decrease the fragmentation, at
the expense of execution time.</p> </li><li> <p><strong>{min_no_slots, </strong><a href="#type-no_slots">type-no_slots</a><strong>}</strong> - Application
performance can be enhanced with this flag by specifying,
when the table is created, the estimated number of
different keys to be stored in the table. Defaults to 256,
which is the minimum value.</p> </li><li> <p><strong>{keypos, </strong><a href="#type-keypos">type-keypos</a><strong>}</strong> - The position of the
element of each object to be used as key. Defaults to 1.
The ability to explicitly state the key
position is most convenient when we want to store Erlang
records in which the first position of the record is the
name of the record type.</p> </li><li> <p><strong>{ram_file, boolean()}</strong> - Whether the table is to
be kept in RAM. Keeping the table in RAM can sound like an
anomaly, but can enhance the performance of applications
that open a table, insert a set of objects, and then
close the table. When the table is closed, its contents
are written to the disk file. Defaults to <strong>false</strong>.</p> </li><li> <p><strong>{repair, Value}</strong> - <strong>Value</strong> can be either
a <strong>boolean()</strong> or the atom <strong>force</strong>. The flag
specifies if the Dets server is to invoke the
automatic file reparation algorithm. Defaults to
<strong>true</strong>. If <strong>false</strong> is specified, no attempt is
made to repair the file, and <strong>{error, {needs_repair, FileName}}</strong> is returned if the table must be repaired.</p> <p>Value <strong>force</strong> means that a reparation
is made even if the table is properly closed.
This is a seldom needed option.</p> <p>Option <strong>repair</strong> is ignored if the table is already open.</p> </li><li> <p><strong>{type, </strong><a href="#type-type">type-type</a><strong>}</strong> - The table type. Defaults to
<strong>set</strong>.</p> </li></ul><h2>pid2name/1</h2><p>Return the name of the Dets table handled by a pid.</p><p>Returns the table name given the pid of a process
that handles requests to a table, or <strong>undefined</strong> if
there is no such table.</p><p>This function is meant to be used for debugging only.</p><h2>repair_continuation/2</h2><p>Repair a continuation from <strong>select/1</strong> or <strong>select/3</strong>. </p><p>This function can be used to restore an opaque continuation
returned by
<a href="#select/3">select/3</a> or
<a href="#select/1">select/1</a> if the
continuation has passed through external term format (been
sent between nodes or stored on disk).</p><p>The reason for this function is that continuation terms
contain compiled match specifications and therefore are
invalidated if converted to external term format. Given that
the original match specification is kept intact, the
continuation can be restored, meaning it can once again be
used in subsequent <strong>select/1</strong> calls even though it has
been stored on disk or on another node.</p><p>For more information and examples, see the
<a href="ets">ets</a> module.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is rarely needed in application code. It is used by
application Mnesia to provide distributed <strong>select/3</strong>
and <strong>select/1</strong> sequences. A normal application would
either use Mnesia or keep the continuation from being
converted to external format.</p><p>The reason for not having an external representation of
compiled match specifications is performance. It can be
subject to change in future releases, while this interface
remains for backward compatibility.</p></div><h2>safe_fixtable/2</h2><p>Fix a Dets table for safe traversal.</p><p>If <strong><span class="anno">Fix</span></strong> is <strong>true</strong>, table
<strong><span class="anno">Name</span></strong> is
fixed (once more) by the calling process, otherwise the table
is released. The table is also released when a fixing process
terminates.</p><p>If many processes fix a table, the table remains
fixed until all processes have released it or terminated. A
reference counter is kept on a per process basis, and N
consecutive fixes require N releases to release the table.</p><p>It is not guaranteed that calls to <strong>first/1</strong>,
<strong>next/2</strong>, or select and match functions work as expected
even if the table is fixed; the limited support for
concurrency provided by the
<a href="ets">ets</a> module is not yet
provided by Dets.
Fixing a table currently only disables resizing of
the hash list of the table.</p><p>If objects have been added while the table was fixed, the
hash list starts to grow when the table is released, which
significantly slows down access to the table for a period
of time.</p><h2>select/1</h2><p>Apply a match specification to some objects stored in a Dets table.</p><p>Applies a match specification to some objects stored in a
table and returns a non-empty list of the results. The
table, the match specification, and the number of objects
that are matched are all defined by <strong><span class="anno">Continuation</span></strong>,
which is returned by a previous call to
<a href="#select/1">select/1</a> or
<a href="#select/3">select/3</a>.</p><p>When all objects of the table have been matched,
<strong>'$end_of_table'</strong> is returned.</p><h2>select/2</h2><p>Apply a match specification to all objects stored in a Dets table.</p><p>Returns the results of applying match specification
<strong><span class="anno">MatchSpec</span></strong> to all or some objects stored in table
<strong><span class="anno">Name</span></strong>. The order of the objects is not specified.
For a description of match specifications, see the
<a href="./match_spec">ERTS User's Guide</a>.</p><p>If the keypos'th element of <strong><span class="anno">MatchSpec</span></strong> is
unbound, the match specification is applied to all objects of
the table. If the keypos'th element is bound, the match
specification is applied to the objects with the correct key(s)
only.</p><p>Using the <strong>select</strong> functions for traversing all
objects of a table is more efficient than calling
<strong>first/1</strong> and <strong>next/2</strong> or <strong>slot/2</strong>.
</p><h2>select/3</h2><p>Apply a match specification to the first chunk of objects stored in a Dets table.</p><p>Returns the results of applying match specification
<strong><span class="anno">MatchSpec</span></strong> to some or all objects stored in table
<strong><span class="anno">Name</span></strong>. The order of the objects is not specified.
For a description of match specifications, see the
<a href="./match_spec">ERTS User's Guide</a>.</p><p>A tuple of the results of applying the match specification
and a continuation is returned, unless the table is empty,
in which case <strong>'$end_of_table'</strong> is returned. The
continuation is to be used when matching more objects by calling
<a href="#select/1">select/1</a>.</p><p>If the keypos'th element of <strong><span class="anno">MatchSpec</span></strong> is bound,
the  match specification is applied to all objects of the table
with the correct key(s). If the keypos'th element of
<strong><span class="anno">MatchSpec</span></strong> is unbound, the match specification is
applied to all objects of the table, <strong><span class="anno">N</span></strong> objects at
a time, until at least one object matches or the end of the
table is reached. The default, indicated by giving
<strong><span class="anno">N</span></strong> the value <strong>default</strong>, is to let the number
of objects vary depending on the sizes of the objects. All
objects with the
same key are always handled at the same time, which implies that the
match specification can be applied to more than <span class="anno">N</span>
objects.</p><p>The table is always to be protected using
<a href="#safe_fixtable/2">safe_fixtable/2</a>
before calling <strong>select/3</strong>, otherwise
errors can occur when calling <strong>select/1</strong>.</p><h2>select_delete/2</h2><p>Delete all objects that match a given pattern from a Dets table.</p><p>Deletes each object from table <strong><span class="anno">Name</span></strong> such that
applying match specification <strong><span class="anno">MatchSpec</span></strong> to the
object returns value <strong>true</strong>.
For a description of match specifications, see the
<a href="./match_spec">ERTS User's Guide</a>.
Returns the number of deleted objects.</p><p>If the keypos'th element of <strong><span class="anno">MatchSpec</span></strong> is
bound, the match specification is applied to the objects
with the correct key(s) only.</p><h2>slot/2</h2><p>Return the list of objects associated with a slot of a Dets table.</p><p>The objects of a table are distributed among slots,
starting with slot <strong>0</strong> and ending with slot <strong>n</strong>.
Returns the list of objects associated with slot
<strong><span class="anno">I</span></strong>. If <strong><span class="anno">I</span></strong> &gt; <strong>n</strong>,
<strong>'$end_of_table'</strong> is returned.</p><h2>sync/1</h2><p>Ensure that all updates made to a Dets table are written to disk.</p><p>Ensures that all updates made to table <strong><span class="anno">Name</span></strong> are
written to disk. This also applies to tables that have been
opened with flag <strong>ram_file</strong> set to <strong>true</strong>. In
this case, the contents of the RAM file are flushed to disk.</p><p>Notice that the space management data structures kept in RAM,
the buddy system, is also written to the disk. This can take
some time if the table is fragmented.</p><h2>table/1</h2><h2>table/2</h2><p>Return a QLC query handle.</p><p>Returns a Query List
Comprehension (QLC) query handle. The
<a href="qlc">qlc</a> module
provides a query language aimed mainly for Mnesia, but
ETS tables, Dets tables, and lists are also recognized
by <strong>qlc</strong> as sources of data. Calling
<a href="./dets#table/1">dets#table/1</a> is the
means to make Dets table <strong><span class="anno">Name</span></strong> usable to
<strong>qlc</strong>.</p><p>When there are only simple restrictions on the key position,
<strong>qlc</strong> uses
<a href="./dets#lookup/2">dets#lookup/2</a>
to look up the keys. When
that is not possible, the whole table is traversed.
Option <strong>traverse</strong> determines how this is done:</p><ul><li> <p><strong>first_next</strong> - The table is traversed one key at
a time by calling <strong>dets:first/1</strong> and <strong>dets:next/2</strong>.</p> </li><li> <p><strong>select</strong> - The table is traversed by calling
<a href="./dets#select/3">dets#select/3</a> and
<a href="./dets#select/1">dets#select/1</a>.
Option <strong>n_objects</strong> determines the number of objects
returned (the third argument of <strong>select/3</strong>). The
match specification (the second argument of
<strong>select/3</strong>) is assembled by <strong>qlc</strong>:</p> <ul><li> <p>Simple filters are translated into equivalent match
specifications.</p> </li><li> <p>More complicated filters must be applied to all
objects returned by <strong>select/3</strong> given a match
specification that matches all objects.</p> </li></ul> </li><li> <p><strong>{select, </strong><a href="#type-match_spec"> match_spec()</a><strong>}</strong> - As for <strong>select</strong>,
the table is traversed by calling <strong>dets:select/3</strong>
and <strong>dets:select/1</strong>. The difference is that the
match specification is specified explicitly. This is how to
state match specifications that cannot easily be
expressed within the syntax provided by <strong>qlc</strong>.</p> </li></ul><p>The following example uses an explicit match specification
to traverse the table:</p><pre>
1&gt; <span class="input">dets:open_file(t, []),</span>
<span class="input">ok = dets:insert(t, [{1,a},{2,b},{3,c},{4,d}]),</span>
<span class="input">MS = ets:fun2ms(fun({X,Y}) when (X &gt; 1) or (X &lt; 5) -&gt; {Y} end),</span>
<span class="input">QH1 = dets:table(t, [{traverse, {select, MS}}]).</span></pre><p>An example with implicit match specification:</p><pre>
2&gt; <span class="input">QH2 = qlc:q([{Y} || {X,Y} &lt;- dets:table(t), (X &gt; 1) or (X &lt; 5)]).</span></pre><p>The latter example is equivalent to the former, which 
can be verified using function <strong>qlc:info/1</strong>:</p><pre>
3&gt; <span class="input">qlc:info(QH1) =:= qlc:info(QH2).</span>
true</pre><p><strong>qlc:info/1</strong> returns information about a query handle.
In this case identical information is returned for the
two query handles.</p><h2>to_ets/2</h2><p>Insert all objects of a Dets table into an ETS table.</p><p>Inserts the objects of the Dets table <strong><span class="anno">Name</span></strong>
into the ETS table <strong><span class="anno">EtsTab</span></strong>. The order in
which the objects are
inserted is not specified. The existing objects of the ETS
table are kept unless overwritten.</p><h2>traverse/2</h2><p>Apply a function to all or some objects stored in a Dets table.</p><p>Applies <strong><span class="anno">Fun</span></strong> to each object stored in table
<strong><span class="anno">Name</span></strong> in some unspecified order. Different
actions are
taken depending on the return value of <strong><span class="anno">Fun</span></strong>. The
following <strong><span class="anno">Fun</span></strong> return values are allowed:</p><dl><dt><strong>continue</strong></dt><dd> <p>Continue to perform the traversal. For example, the
following function can be used to print the contents
of a table:</p> <pre>
fun(X) -&gt; io:format("~p~n", [X]), continue end.</pre> </dd><dt><strong>{continue, Val}</strong></dt><dd> <p>Continue the traversal and accumulate <strong><span class="anno">Val</span></strong>.
The following function is supplied to collect all
objects of a table in a list:</p> <pre>
fun(X) -&gt; {continue, X} end.</pre> </dd><dt><strong>{done, <span class="anno">Value</span>}</strong></dt><dd> <p>Terminate the traversal and return
<strong>[<span class="anno">Value</span> | Acc]</strong>.</p> </dd></dl><p>Any other value <strong><span class="anno">OtherValue</span></strong> returned by
<strong><span class="anno">Fun</span></strong> terminates the
traversal and is returned immediately.</p><h2>update_counter/3</h2><p>Update a counter object stored in a Dets table. </p><p>Updates the object with key <strong><span class="anno">Key</span></strong> stored in
table <strong><span class="anno">Name</span></strong> of type <strong>set</strong> by adding
<strong><span class="anno">Incr</span></strong> to the
element at the <strong><span class="anno">Pos</span></strong>:th position.
The new counter value
is returned. If no position is specified, the element directly
following the key is updated.</p><p>This functions provides a way of updating a counter,
without having to look up an object, update the object by
incrementing an element, and insert the resulting object into
the table again.</p><h2>See Also</h2><p><a href="ets">ets</a>,
<a href="./mnesia">mnesia/mnesia</a>,
<a href="qlc">qlc</a></p></body></html>