<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>STDLIB Reference Manual</h1><h2>STDLIB</h2><p>The STDLIB application.</p><p>The STDLIB application is mandatory in the sense that the minimal
system based on Erlang/OTP consists of Kernel and STDLIB.
The STDLIB application contains no services.</p><h3>Configuration</h3><p>The following configuration parameters are defined for the STDLIB
application. For more information about configuration parameters, see the
<a href="./app">kernel/app</a> module in Kernel.</p><dl><dt><strong>shell_esc = icl | abort</strong></dt><dd> <p>Can be used to change the behavior of the Erlang shell when
<em>^G</em> is pressed.</p> </dd><dt><strong>restricted_shell = module()</strong></dt><dd> <p>Can be used to run the Erlang shell in restricted mode.</p> </dd><dt><strong>shell_catch_exception = boolean()</strong></dt><dd> <p>Can be used to set the exception handling of the evaluator process of
Erlang shell.</p> </dd><dt><strong>shell_history_length = integer() &gt;= 0</strong></dt><dd> <p>Can be used to determine how many commands are saved by the Erlang
shell.</p> </dd><dt><strong>shell_prompt_func = {Mod, Func} | default</strong></dt><dd> <p>where</p> <ul><li><strong>Mod = atom()</strong></li><li><strong>Func = atom()</strong></li></ul> <p>Can be used to set a customized Erlang shell prompt function.</p> </dd><dt><strong>shell_saved_results = integer() &gt;= 0</strong></dt><dd> <p>Can be used to determine how many results are saved by the Erlang
shell.</p> </dd><dt><strong>shell_strings = boolean()</strong></dt><dd> <p>Can be used to determine how the Erlang shell outputs lists of
integers.</p> </dd></dl><h3>See Also</h3><p><a href="./app">kernel/app</a>,
<a href="./application">kernel/application</a>,
<a href="shell">shell(3)</a></p><h2>array</h2><p>Functional, extendible arrays.</p><p>Functional, extendible arrays. Arrays can have fixed size, or can grow
automatically as needed. A default value is used for entries that have not
been explicitly set.Arrays uses <em>zero</em>-based indexing. This is a deliberate design
choice and differs from other Erlang data structures, for example,
tuples.Unless specified by the user when the array is created, the default
value is the atom <strong>undefined</strong>. There is no difference between an
unset entry and an entry that has been explicitly set to the same value
as the default one (compare
<a href="#reset-2">reset-2</a>). If you need to
differentiate between unset and set entries, ensure that the default value
cannot be confused with the values of set entries.The array never shrinks automatically. If an index <strong>I</strong> has been used
to set an entry successfully, all indices in the range [0,<strong>I</strong>] stay
accessible unless the array size is explicitly changed by calling
<a href="#resize-2">resize-2</a>.<em>Examples:</em>Create a fixed-size array with entries 0-9 set to <strong>undefined</strong>:<pre>
A0 = array:new(10).
10 = array:size(A0).</pre>Create an extendible array and set entry 17 to <strong>true</strong>, causing the
array to grow automatically:<pre>
A1 = array:set(17, true, array:new()).
18 = array:size(A1).</pre>Read back a stored value:<pre>
true = array:get(17, A1).</pre>Accessing an unset entry returns default value:<pre>
undefined = array:get(3, A1)</pre>Accessing an entry beyond the last set entry also returns the default
value, if the array does not have fixed size:<pre>
undefined = array:get(18, A1).</pre>"Sparse" functions ignore default-valued entries:<pre>
A2 = array:set(4, false, A1).
[{4, false}, {17, true}] = array:sparse_to_orddict(A2).</pre>An extendible array can be made fixed-size later:<pre>
A3 = array:fix(A2).</pre>A fixed-size array does not grow automatically and does not allow
accesses beyond the last set entry:<pre>
{'EXIT',{badarg,_}} = (catch array:set(18, true, A3)).
{'EXIT',{badarg,_}} = (catch array:get(18, A3)).</pre></p><h2>Data Types</h2><span class="name">array</span><p>A functional, extendible array. The representation is not documented
and is subject to change without notice. Notice that arrays cannot be
directly compared for equality.</p><span class="name">array</span><span class="name">array_indx</span><span class="name">array_opts</span><span class="name">array_opt</span><span class="name">indx_pairs</span><span class="name">indx_pair</span><h2>Functions</h2><h3>default/1</h3><p>Get the value used for uninitialized entries.</p><a name="default-1"></a><p>Gets the value used for uninitialized entries.</p><p>See also <a href="#new-2">new-2</a>.</p><h3>fix/1</h3><p>Fix the array size.</p><a name="fix-1"></a><p>Fixes the array size. This prevents it from growing automatically
upon insertion.</p><p>See also <a href="#set-3">set-3</a> and
<a href="#relax-1">relax-1</a>.</p><h3>foldl/3</h3><p>Fold the array elements using the specified function and initial accumulator value.</p><a name="foldl-3"></a><p>Folds the array elements using the specified function and initial
accumulator value. The elements are visited in order from the lowest
index to the highest. If <strong><span class="anno">Function</span></strong> is not a
function, the call fails with reason <strong>badarg</strong>.</p><p>See also <a href="#foldr-3">foldr-3</a>,
<a href="#map-2">map-2</a>,
<a href="#sparse_foldl-3">sparse_foldl-3</a>.</p><h3>foldr/3</h3><p>Fold the array elements right-to-left using the specified function and initial accumulator value.</p><a name="foldr-3"></a><p>Folds the array elements right-to-left using the specified function
and initial accumulator value. The elements are visited in order from
the highest index to the lowest. If <strong><span class="anno">Function</span></strong> is
not a function, the call fails with reason <strong>badarg</strong>.</p><p>See also <a href="#foldl-3">foldl-3</a>,
<a href="#map-2">map-2</a>.</p><h3>from_list/1</h3><p>Equivalent to <strong>from_list(List, undefined)</strong>.</p><a name="from_list-1"></a><p>Equivalent to
<a href="#from_list-2">from_list-2</a>.</p><h3>from_list/2</h3><p>Convert a list to an extendible array.</p><a name="from_list-2"></a><p>Converts a list to an extendible array. <strong><span class="anno">Default</span></strong>
is used as the value for uninitialized entries of the array. If
<strong><span class="anno">List</span></strong> is not a proper list, the call fails with
reason <strong>badarg</strong>.</p><p>See also <a href="#new-2">new-2</a>,
<a href="#to_list-1">to_list-1</a>.</p><h3>from_orddict/1</h3><p>Equivalent to <strong>from_orddict(Orddict, undefined)</strong>. </p><a name="from_orddict-1"></a><p>Equivalent to
<a href="#from_orddict-2">from_orddict-2</a>.</p><h3>from_orddict/2</h3><p>Convert an ordered list of pairs <strong>{Index, Value}</strong> to a corresponding extendible array.</p><a name="from_orddict-2"></a><p>Converts an ordered list of pairs <strong>{Index, <span class="anno">Value</span>}</strong>
to a corresponding extendible array. <strong><span class="anno">Default</span></strong> is
used as the value for uninitialized entries of the array. If
<strong><span class="anno">Orddict</span></strong> is not a proper, ordered list of pairs
whose first elements are non-negative integers, the call fails with
reason <strong>badarg</strong>.</p><p>See also <a href="#new-2">new-2</a>,
<a href="#to_orddict-1">to_orddict-1</a>.</p><h3>get/2</h3><p>Get the value of entry <strong>I</strong>.</p><a name="get-2"></a><p>Gets the value of entry <strong><span class="anno">I</span></strong>. If
<strong><span class="anno">I</span></strong> is not a non-negative integer, or if the array
has fixed size and <strong><span class="anno">I</span></strong> is larger than the maximum
index, the call fails with reason <strong>badarg</strong>.</p><p>If the array does not have fixed size, the default value for any
index <strong><span class="anno">I</span></strong> greater than
<strong>size(<span class="anno">Array</span>)-1</strong> is returned.</p><p>See also <a href="#set-3">set-3</a>.</p><h3>is_array/1</h3><p>Returns <strong>true</strong> if <strong>X</strong> is an array, otherwise <strong>false</strong>.</p><a name="is_array-1"></a><p>Returns <strong>true</strong> if <strong><span class="anno">X</span></strong> is an array, otherwise
<strong>false</strong>. Notice that the check is only shallow, as there is no
guarantee that <strong><span class="anno">X</span></strong> is a well-formed array
representation even if this function returns <strong>true</strong>.</p><h3>is_fix/1</h3><p>Check if the array has fixed size.</p><a name="is_fix-1"></a><p>Checks if the array has fixed size. Returns <strong>true</strong> if the array
is fixed, otherwise <strong>false</strong>.</p><p>See also <a href="#fix-1">fix-1</a>.</p><h3>map/2</h3><p>Map the specified function onto each array element.</p><a name="map-2"></a><p>Maps the specified function onto each array element. The elements are
visited in order from the lowest index to the highest. If
<strong><span class="anno">Function</span></strong> is not a function, the call fails with
reason <strong>badarg</strong>.</p><p>See also <a href="#foldl-3">foldl-3</a>,
<a href="#foldr-3">foldr-3</a>,
<a href="#sparse_map-2">sparse_map-2</a>.</p><h3>new/0</h3><p>Create a new, extendible array with initial size zero. </p><a name="new-0"></a><p>Creates a new, extendible array with initial size zero.</p><p>See also <a href="#new-1">new-1</a>,
<a href="#new-2">new-2</a>.</p><h3>new/1</h3><p>Create a new array according to the specified options. </p><a name="new-1"></a><p>Creates a new array according to the specified otions. By default,
the array is extendible and has initial size zero. Array indices
start at <strong>0</strong>.</p><p><strong><span class="anno">Options</span></strong> is a single term or a list of terms,
selected from the following:</p><dl><dt><strong>N::integer() &gt;= 0</strong> or <strong>{size, N::integer() &gt;= 0}</strong> </dt><dd><p>Specifies the initial array size; this also implies
<strong>{fixed, true}</strong>. If <strong>N</strong> is not a non-negative integer, the
call fails with reason <strong>badarg</strong>.</p></dd><dt><strong>fixed</strong> or <strong>{fixed, true}</strong></dt><dd><p>Creates a fixed-size array. See also
<a href="#fix-1">fix-1</a>.</p></dd><dt><strong>{fixed, false}</strong></dt><dd><p>Creates an extendible (non-fixed-size) array.</p></dd><dt><strong>{default, Value}</strong></dt><dd><p>Sets the default value for the array to <strong>Value</strong>.</p> </dd></dl><p>Options are processed in the order they occur in the list, that is,
later options have higher precedence.</p><p>The default value is used as the value of uninitialized entries, and
cannot be changed once the array has been created.</p><p><em>Examples:</em></p><pre>
array:new(100)</pre><p>creates a fixed-size array of size 100.</p><pre>
array:new({default,0})</pre><p>creates an empty, extendible array whose default value is <strong>0</strong>.
</p><pre>
array:new([{size,10},{fixed,false},{default,-1}])</pre><p>creates an extendible array with initial size 10 whose default value
is <strong>-1</strong>.</p><p>See also <a href="#fix-1">fix-1</a>,
<a href="#from_list-2">from_list-2</a>,
<a href="#get-2">get-2</a>,
<a href="#new-0">new-0</a>,
<a href="#new-2">new-2</a>,
<a href="#set-3">set-3</a>.</p><h3>new/2</h3><p>Create a new array according to the specified size and options. </p><a name="new-2"></a><p>Creates a new array according to the specified size and options. If
<strong><span class="anno">Size</span></strong> is not a non-negative integer, the call fails
with reason <strong>badarg</strong>. By default, the array has fixed size.
Notice that any size specifications in <strong><span class="anno">Options</span></strong>
override parameter <strong><span class="anno">Size</span></strong>.</p><p>If <strong><span class="anno">Options</span></strong> is a list, this is equivalent to
<strong>new([{size, <span class="anno">Size</span>} | <span class="anno">Options</span>]</strong>,
otherwise it is equivalent to <strong>new([{size, <span class="anno">Size</span>} | [<span class="anno">Options</span>]]</strong>. However, using this function directly is
more efficient.</p><p><em>Example:</em></p><pre>
array:new(100, {default,0})</pre><p>creates a fixed-size array of size 100, whose default value is
<strong>0</strong>.</p><p>See also <a href="#new-1">new-1</a>.</p><h3>relax/1</h3><p>Make the array resizable.</p><a name="relax-1"></a><p>Makes the array resizable. (Reverses the effects of
<a href="#fix-1">fix-1</a>.)</p><p>See also <a href="#fix-1">fix-1</a>.</p><h3>reset/2</h3><p>Reset entry <strong>I</strong> to the default value for the array. </p><a name="reset-2"></a><p>Resets entry <strong><span class="anno">I</span></strong> to the default value for the
array. If the value of entry <strong><span class="anno">I</span></strong> is the default
value, the array is returned unchanged. Reset never changes the array
size. Shrinking can be done explicitly by calling
<a href="#resize-2">resize-2</a>.</p><p>If <strong><span class="anno">I</span></strong> is not a non-negative integer, or if the
array has fixed size and <strong><span class="anno">I</span></strong> is larger than the
maximum index, the call fails with reason <strong>badarg</strong>; compare
<a href="#set-3">set-3</a></p><p>See also <a href="#new-2">new-2</a>,
<a href="#set-3">set-3</a>.</p><h3>resize/1</h3><p>Change the array size to that reported by <strong>sparse_size/1</strong>. </p><a name="resize-1"></a><p>Changes the array size to that reported by
<a href="#sparse_size-1">sparse_size-1</a>. If
the specified array has fixed size, also the resulting array has fixed
size.</p><p>See also <a href="#resize-2">resize-2</a>,
<a href="#sparse_size-1">sparse_size-1</a>.</p><h3>resize/2</h3><p>Change the array size.</p><a name="resize-2"></a><p>Change the array size. If <strong><span class="anno">Size</span></strong> is not a
non-negative integer, the call fails with reason <strong>badarg</strong>. If
the specified array has fixed size, also the resulting array has fixed
size.</p><h3>set/3</h3><p>Set entry <strong>I</strong> of the array to <strong>Value</strong>.</p><a name="set-3"></a><p>Sets entry <strong><span class="anno">I</span></strong> of the array to
<strong><span class="anno">Value</span></strong>. If <strong><span class="anno">I</span></strong> is not a
non-negative integer, or if the array has fixed size and
<strong><span class="anno">I</span></strong> is larger than the maximum index, the call
fails with reason <strong>badarg</strong>.</p><p>If the array does not have fixed size, and <strong><span class="anno">I</span></strong> is
greater than <strong>size(<span class="anno">Array</span>)-1</strong>, the array grows to
size <strong><span class="anno">I</span>+1</strong>.</p><p>See also <a href="#get-2">get-2</a>,
<a href="#reset-2">reset-2</a>.</p><h3>size/1</h3><p>Get the number of entries in the array.</p><a name="size-1"></a><p>Gets the number of entries in the array. Entries are numbered from
<strong>0</strong> to <strong>size(<span class="anno">Array</span>)-1</strong>. Hence, this is also the
index of the first entry that is guaranteed to not have been
previously set.</p><p>See also <a href="#set-3">set-3</a>,
<a href="#sparse_size-1">sparse_size-1</a>.</p><h3>sparse_foldl/3</h3><p>Fold the array elements using the specified function and initial accumulator value, skipping default-valued entries.</p><a name="sparse_foldl-3"></a><p>Folds the array elements using the specified function and initial
accumulator value, skipping default-valued entries. The elements are
visited in order from the lowest index to the highest. If
<strong><span class="anno">Function</span></strong> is not a function, the call fails with
reason <strong>badarg</strong>.</p><p>See also <a href="#foldl-3">foldl-3</a>,
<a href="#sparse_foldr-3">sparse_foldr-3</a>.</p><h3>sparse_foldr/3</h3><p>Fold the array elements right-to-left using the specified function and initial accumulator value, skipping default-valued entries.</p><a name="sparse_foldr-3"></a><p>Folds the array elements right-to-left using the specified
function and initial accumulator value, skipping default-valued
entries. The elements are visited in order from the highest index to
the lowest. If <strong><span class="anno">Function</span></strong> is not a function, the
call fails with reason <strong>badarg</strong>.</p><p>See also <a href="#foldr-3">foldr-3</a>,
<a href="#sparse_foldl-3">sparse_foldl-3</a>.</p><h3>sparse_map/2</h3><p>Map the specified function onto each array element, skipping default-valued entries.</p><a name="sparse_map-2"></a><p>Maps the specified function onto each array element, skipping
default-valued entries. The elements are visited in order from the
lowest index to the highest. If <strong><span class="anno">Function</span></strong> is not a
function, the call fails with reason <strong>badarg</strong>.</p><p>See also <a href="#map-2">map-2</a>.</p><h3>sparse_size/1</h3><p>Get the number of entries in the array up until the last non-default-valued entry.</p><a name="sparse_size-1"></a><p>Gets the number of entries in the array up until the last
non-default-valued entry. That is, returns <strong>I+1</strong> if <strong>I</strong> is
the last non-default-valued entry in the array, or zero if no such
entry exists.</p><p>See also <a href="#resize-1">resize-1</a>,
<a href="#size-1">size-1</a>.</p><h3>sparse_to_list/1</h3><p>Convert the array to a list, skipping default-valued entries. </p><a name="sparse_to_list-1"></a><p>Converts the array to a list, skipping default-valued entries.</p><p>See also <a href="#to_list-1">to_list-1</a>.</p><h3>sparse_to_orddict/1</h3><p>Convert the array to an ordered list of pairs <strong>{Index, Value}</strong>, skipping default-valued entries.</p><a name="sparse_to_orddict-1"></a><p>Converts the array to an ordered list of pairs <strong>{Index, <span class="anno">Value</span>}</strong>, skipping default-valued entries.</p><p>See also
<a href="#to_orddict-1">to_orddict-1</a>.</p><h3>to_list/1</h3><p>Convert the array to a list.</p><a name="to_list-1"></a><p>Converts the array to a list.</p><p>See also <a href="#from_list-2">from_list-2</a>,
<a href="#sparse_to_list-1">sparse_to_list-1</a>.
</p><h3>to_orddict/1</h3><p>Convert the array to an ordered list of pairs <strong>{Index, Value}</strong>.</p><a name="to_orddict-1"></a><p>Converts the array to an ordered list of pairs <strong>{Index, <span class="anno">Value</span>}</strong>.</p><p>See also
<a href="#from_orddict-2">from_orddict-2</a>,
<a href="#sparse_to_orddict-1">sparse_to_orddict-1</a>.
</p><h2>assert.hrl</h2><p>Assert macros.</p><p>The include file <strong>assert.hrl</strong> provides macros for inserting
assertions in your program code.Include the following directive in the module from which the function is
called:<pre><code class="">
-include_lib("stdlib/include/assert.hrl").</code></pre>When an assertion succeeds, the assert macro yields the atom <strong>ok</strong>.
When an assertion fails, an exception of type <strong>error</strong> is generated.
The associated error term has the form <strong>{Macro, Info}</strong>. <strong>Macro</strong>
is the macro name, for example, <strong>assertEqual</strong>. <strong>Info</strong> is a list
of tagged values, such as <strong>[{module, M}, {line, L}, ...]</strong>, which
gives more information about the location and cause of the exception. All
entries in the <strong>Info</strong> list are optional; do not rely programmatically
on any of them being present.Each assert macro has a corresponding version with an extra argument,
for adding comments to assertions. These can for example be printed as
part of error reports, to clarify the meaning of the check that
failed. For example, <strong>?assertEqual(0, fib(0), "Fibonacci is defined for zero")</strong>. The comment text can be any character data (string,
UTF8-binary, or deep list of such data), and will be included in the
error term as <strong>{comment, Text}</strong>.If the macro <strong>NOASSERT</strong> is defined when <strong>assert.hrl</strong> is read
by the compiler, the macros are defined as equivalent to the atom
<strong>ok</strong>. The test will not be performed and there is no cost at runtime.For example, using <strong>erlc</strong> to compile your modules, the following
disables all assertions:<pre><code class="">
erlc -DNOASSERT=true *.erl</code></pre>(The value of <strong>NOASSERT</strong> does not matter, only the fact that it is
defined.)A few other macros also have effect on the enabling or disabling of
assertions:<ul><li><p>If <strong>NODEBUG</strong> is defined, it implies <strong>NOASSERT</strong> (unless
<strong>DEBUG</strong> is also defined, which overrides <strong>NODEBUG</strong>).</p> </li><li><p>If <strong>ASSERT</strong> is defined, it overrides <strong>NOASSERT</strong>, that
is, the assertions remain enabled.</p></li></ul>If you prefer, you can thus use only <strong>DEBUG</strong>/<strong>NODEBUG</strong> as the
main flags to control the behavior of the assertions (which is useful if
you have other compiler conditionals or debugging macros controlled by
those flags), or you can use <strong>ASSERT</strong>/<strong>NOASSERT</strong> to control only
the assert macros.</p><h3>Macros</h3><dl><dt><strong>assert(BoolExpr)</strong></dt><dd></dd><dt><strong>assert(BoolExpr, Comment)</strong></dt><dd> <p>Tests that <strong>BoolExpr</strong> completes normally returning
<strong>true</strong>.</p> </dd><dt><strong>assertNot(BoolExpr)</strong></dt><dd></dd><dt><strong>assertNot(BoolExpr, Comment)</strong></dt><dd> <p>Tests that <strong>BoolExpr</strong> completes normally returning
<strong>false</strong>.</p> </dd><dt><strong>assertMatch(GuardedPattern, Expr)</strong></dt><dd></dd><dt><strong>assertMatch(GuardedPattern, Expr, Comment)</strong></dt><dd> <p>Tests that <strong>Expr</strong> completes normally yielding a value that
matches <strong>GuardedPattern</strong>, for example:</p> <pre><code class="">
?assertMatch({bork, _}, f())</code></pre> <p>Notice that a guard <strong>when ...</strong> can be included:</p> <pre><code class="">
?assertMatch({bork, X} when X &gt; 0, f())</code></pre> </dd><dt><strong>assertNotMatch(GuardedPattern, Expr)</strong></dt><dd></dd><dt><strong>assertNotMatch(GuardedPattern, Expr, Comment)</strong></dt><dd> <p>Tests that <strong>Expr</strong> completes normally yielding a value that does
not match <strong>GuardedPattern</strong>.</p> <p>As in <strong>assertMatch</strong>, <strong>GuardedPattern</strong> can have a
<strong>when</strong> part.</p> </dd><dt><strong>assertEqual(ExpectedValue, Expr)</strong></dt><dd></dd><dt><strong>assertEqual(ExpectedValue, Expr, Comment)</strong></dt><dd> <p>Tests that <strong>Expr</strong> completes normally yielding a value that is
exactly equal to <strong>ExpectedValue</strong>.</p> </dd><dt><strong>assertNotEqual(ExpectedValue, Expr)</strong></dt><dd></dd><dt><strong>assertNotEqual(ExpectedValue, Expr, Comment)</strong></dt><dd> <p>Tests that <strong>Expr</strong> completes normally yielding a value that is
not exactly equal to <strong>ExpectedValue</strong>.</p> </dd><dt><strong>assertException(Class, Term, Expr)</strong></dt><dd></dd><dt><strong>assertException(Class, Term, Expr, Comment)</strong></dt><dd> <p>Tests that <strong>Expr</strong> completes abnormally with an exception of type
<strong>Class</strong> and with the associated <strong>Term</strong>. The assertion fails
if <strong>Expr</strong> raises a different exception or if it completes
normally returning any value.</p> <p>Notice that both <strong>Class</strong> and <strong>Term</strong> can be guarded
patterns, as in <strong>assertMatch</strong>.</p> </dd><dt><strong>assertNotException(Class, Term, Expr)</strong></dt><dd></dd><dt><strong>assertNotException(Class, Term, Expr, Comment)</strong></dt><dd> <p>Tests that <strong>Expr</strong> does not evaluate abnormally with an
exception of type <strong>Class</strong> and with the associated <strong>Term</strong>.
The assertion succeeds if <strong>Expr</strong> raises a different exception or
if it completes normally returning any value.</p> <p>As in <strong>assertException</strong>, both <strong>Class</strong> and <strong>Term</strong> can
be guarded patterns.</p> </dd><dt><strong>assertError(Term, Expr)</strong></dt><dd></dd><dt><strong>assertError(Term, Expr, Comment)</strong></dt><dd> <p>Equivalent to <strong>assertException(error, Term, Expr)</strong></p> </dd><dt><strong>assertExit(Term, Expr)</strong></dt><dd></dd><dt><strong>assertExit(Term, Expr, Comment)</strong></dt><dd> <p>Equivalent to <strong>assertException(exit, Term, Expr)</strong></p> </dd><dt><strong>assertThrow(Term, Expr)</strong></dt><dd></dd><dt><strong>assertThrow(Term, Expr, Comment)</strong></dt><dd> <p>Equivalent to <strong>assertException(throw, Term, Expr)</strong></p> </dd></dl><h3>See Also</h3><p><a href="./compile">compiler/compile</a>,
<a href="./erlc">erts/erlc</a></p><h2>base64</h2><p>Provides base64 encode and decode, see
    RFC 2045.</p><p>Provides base64 encode and decode, see
<a href="https://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>.</p><h2>Data Types</h2><span class="name">ascii_string</span><span class="name">ascii_binary</span><p>A <strong>binary()</strong> with ASCII characters in the range 1 to
255.</p><h2>Functions</h2><h3>decode/1</h3><h3>decode_to_string/1</h3><h3>mime_decode/1</h3><h3>mime_decode_to_string/1</h3><p>Decode a base64 encoded string to data.</p><ul><li>Base64</li></ul><ul><li>Data</li></ul><ul><li>DataString</li></ul><p>Decodes a base64-encoded string to plain ASCII. See
<a href="https://www.ietf.org/html/rfc4648">RFC 4648</a>.</p><p><strong>mime_decode/1</strong> and <strong>mime_decode_to_string/1</strong> strip away
illegal characters, while <strong>decode/1</strong> and
<strong>decode_to_string/1</strong> only strip away whitespace characters.</p><h3>encode/1</h3><h3>encode_to_string/1</h3><p>Encode data into base64.</p><ul><li>Data</li></ul><ul><li>Base64</li></ul><ul><li>Base64String</li></ul><p>Encodes a plain ASCII string into base64. The result is 33% larger
than the data.</p><h2>beam_lib</h2><p>An interface to the BEAM file format.</p><p>This module provides an interface to files created by
the BEAM Compiler ("BEAM files"). The format used, a variant of
"EA IFF 1985" Standard for Interchange Format Files, divides data
into chunks.Chunk data can be returned as binaries or as compound terms.
Compound terms are returned when chunks are referenced by names
(atoms) rather than identifiers (strings). The recognized names
and the corresponding identifiers are as follows:<ul><li><strong>atoms ("Atom")</strong></li><li><strong>attributes ("Attr")</strong></li><li><strong>compile_info ("CInf")</strong></li><li><strong>debug_info ("Dbgi")</strong></li><li><strong>exports ("ExpT")</strong></li><li><strong>imports ("ImpT")</strong></li><li><strong>indexed_imports ("ImpT")</strong></li><li><strong>labeled_exports ("ExpT")</strong></li><li><strong>labeled_locals ("LocT")</strong></li><li><strong>locals ("LocT")</strong></li></ul></p><a name="debug_info"></a><h3>Debug Information/Abstract Code</h3><p>Option <strong>debug_info</strong> can be specified to the Compiler (see
<a href="../compiler/compile#debug_info">compiler/compile#debug_info</a>)
to have debug information, such as <a href="./absform">Erlang Abstract Format</a>, stored in the <strong>debug_info</strong> chunk.
Tools such as Debugger and Xref require the debug information to
be included.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Source code can be reconstructed from the debug information.
To prevent this, use encrypted debug information (see below).</p></div><p>The debug information can also be removed from BEAM files
using <a href="#strip/1">strip/1</a>,
<a href="#strip_files/1">strip_files/1</a>, and/or
<a href="#strip_release/1">strip_release/1</a>.</p><h3>Reconstruct Source Code</h3><p>The following example shows how to reconstruct Erlang source code from
the debug information in a BEAM file <strong>Beam</strong>:</p><pre><code class="">
{ok,{_,[{abstract_code,{_,AC}}]}} = beam_lib:chunks(Beam,[abstract_code]).
io:fwrite("~s~n", [erl_prettypr:format(erl_syntax:form_list(AC))]).</code></pre><h3>Encrypted Debug Information</h3><p>The debug information can be encrypted to keep
the source code secret, but still be able to use tools such as
Debugger or Xref.</p><p>To use encrypted debug information, a key must be provided to
the compiler and <strong>beam_lib</strong>. The key is specified as a string.
It is recommended that the string contains at least 32 characters and
that both upper and lower case letters as well as digits and
special characters are used.</p><p>The default type (and currently the only type) of crypto
algorithm is <strong>des3_cbc</strong>, three rounds of DES. The key string
is scrambled using
<a href="../erts/erlang#md5/1">erts/erlang#md5/1</a>
to generate the keys used for <strong>des3_cbc</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As far as we know by the time of writing, it is
infeasible to break <strong>des3_cbc</strong> encryption without any
knowledge of the key. Therefore, as long as the key is kept
safe and is unguessable, the encrypted debug information
<em>should</em> be safe from intruders.</p></div><p>The key can be provided in the following two ways:</p><ul><li> <p>Use Compiler option <strong>{debug_info_key,Key}</strong>, see
<a href="../compiler/compile#debug_info_key">compiler/compile#debug_info_key</a>
and function
<a href="#crypto_key_fun/1">crypto_key_fun/1</a>
to register a fun that returns the key whenever
<strong>beam_lib</strong> must decrypt the debug information.</p> <p>If no such fun is registered, <strong>beam_lib</strong> instead
searches for an <strong>.erlang.crypt</strong> file, see the next section.</p> </li><li> <p>Store the key in a text file named <strong>.erlang.crypt</strong>.</p> <p>In this case, Compiler option <strong>encrypt_debug_info</strong>
can be used, see
<a href="../compiler/compile#encrypt_debug_info">compiler/compile#encrypt_debug_info</a>.
</p> </li></ul><h3>.erlang.crypt</h3><p><strong>beam_lib</strong> searches for <strong>.erlang.crypt</strong> in the current
directory and then the home directory for the current user. If
the file is found and contains a key, <strong>beam_lib</strong>
implicitly creates a crypto key fun and registers it.</p><p>File <strong>.erlang.crypt</strong> is to contain a single list of tuples:</p><pre><code class="">
{debug_info, Mode, Module, Key}</code></pre><p><strong>Mode</strong> is the type of crypto algorithm; currently, the only
allowed value is <strong>des3_cbc</strong>. <strong>Module</strong> is either an
atom, in which case <strong>Key</strong> is only used for the module
<strong>Module</strong>, or <strong>[]</strong>, in which case <strong>Key</strong> is
used for all modules. <strong>Key</strong> is the non-empty key string.</p><p><strong>Key</strong> in the first tuple where both <strong>Mode</strong> and
<strong>Module</strong> match is used.</p><p>The following is an example of an <strong>.erlang.crypt</strong> file that returns
the same key for all modules:</p><pre><code class="">
[{debug_info, des3_cbc, [], "%&gt;7}|pc/DM6Cga*68$Mw]L#&amp;_Gejr]G^"}].</code></pre><p>The following is a slightly more complicated example of an
<strong>.erlang.crypt</strong> providing one key for module
<strong>t</strong> and another key for all other modules:</p><pre><code class="">
[{debug_info, des3_cbc, t, "My KEY"},
 {debug_info, des3_cbc, [], "%&gt;7}|pc/DM6Cga*68$Mw]L#&amp;_Gejr]G^"}].</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Do not use any of the keys in these examples. Use your own keys.</p></div><h2>Data Types</h2><span class="name">beam</span><p>Each of the functions described below accept either the
filename (as a string) or a binary containing the BEAM
module.</p><span class="name">chunkdata</span><p>The list of attributes is sorted on <strong>Attribute</strong>
(in <strong>attrib_entry()</strong>) and each
attribute name occurs once in the list. The attribute values
occur in the same order as in the file. The lists of functions
are also sorted.</p><span class="name">chunkid</span><p>"Attr" | "CInf" | "Dbgi" | "ExpT" | "ImpT" | "LocT" | "AtU8"</p><span class="name">dataB</span><span class="name">debug_info</span><p>The format stored in the <strong>debug_info</strong> chunk.
To retrieve particular code representation from the backend,
<strong>Backend:debug_info(Format, Module, Data, Opts)</strong> must be
invoked. <strong>Format</strong> is an atom, such as <strong>erlang_v1</strong> for
the Erlang Abstract Format or <strong>core_v1</strong> for Core Erlang.
<strong>Module</strong> is the module represented by the beam file and
<strong>Data</strong> is the value stored in the debug info chunk.
<strong>Opts</strong> is any list of values supported by the <strong>Backend</strong>.
<strong>Backend:debug_info/4</strong> must return <strong>{ok, Code}</strong> or
<strong>{error, Term}</strong>.</p><p>Developers must always invoke the <strong>debug_info/4</strong> function
and never rely on the <strong>Data</strong> stored in the <strong>debug_info</strong>
chunk, as it is opaque and may change at any moment. <strong>no_debug_info</strong>
means that chunk <strong>"Dbgi"</strong> is present, but empty.</p><span class="name">abst_code</span><p>It is not checked that the forms conform to the abstract format
indicated by <strong><span class="anno">AbstVersion</span></strong>. <strong>no_abstract_code</strong>
means that chunk <strong>"Abst"</strong> is present, but empty.</p><p>For modules compiled with OTP 20 onwards, the <strong>abst_code</strong> chunk
is automatically computed from the <strong>debug_info</strong> chunk.</p><span class="name">forms</span><span class="name">compinfo_entry</span><span class="name">attrib_entry</span><span class="name">labeled_entry</span><span class="name">index</span><span class="name">label</span><span class="name">chunkref</span><span class="name">chunkname</span><span class="name">chnk_rsn</span><span class="name">info_rsn</span><h2>Functions</h2><h3>all_chunks/1</h3><p>Read all chunks from a BEAM file or binary</p><p>Reads chunk data for all chunks.</p><h3>build_module/1</h3><p>Create a BEAM module from a list of chunks.</p><p>Builds a BEAM module (as a binary) from a list of chunks.</p><h3>chunks/2</h3><p>Read selected chunks from a BEAM file or binary.</p><p>Reads chunk data for selected chunks references. The order of
the returned list of chunk data is determined by the order
of the list of chunks references.</p><h3>chunks/3</h3><p>Read selected chunks from a BEAM file or binary.</p><p>Reads chunk data for selected chunks references. The order of
the returned list of chunk data is determined by the order
of the list of chunks references.</p><p>By default, if any requested chunk is missing in
<strong><span class="anno">Beam</span></strong>, an <strong>error</strong> tuple is returned.
However, if option <strong>allow_missing_chunks</strong> is specified,
a result is returned even if chunks are missing.
In the result list, any missing chunks are represented as
<strong>{<span class="anno">ChunkRef</span>,missing_chunk}</strong>.
Notice however that if chunk <strong>"Atom"</strong> is missing, that is
considered a fatal error and the return value is an <strong>error</strong>
tuple.</p><h3>clear_crypto_key_fun/0</h3><p>Unregister the current crypto key fun.</p><p>Unregisters the crypto key fun and terminates the process
holding it, started by
<a href="#crypto_key_fun/1">crypto_key_fun/1</a>.
</p><p>Returns either <strong>{ok, undefined}</strong> if no crypto key fun is
registered, or <strong>{ok, Term}</strong>, where <strong>Term</strong> is
the return value from <strong>CryptoKeyFun(clear)</strong>, see
<strong>crypto_key_fun/1</strong>.</p><h3>cmp/2</h3><p>Compare two BEAM files.</p><ul><li>cmp_rsn</li></ul><p>Compares the contents of two BEAM files. If the module names
are the same, and all chunks except for chunk <strong>"CInf"</strong>
(the chunk containing the compilation information that is
returned by <strong>Module:module_info(compile)</strong>)
have the same contents in both files,
<strong>ok</strong> is returned. Otherwise an error message is returned.</p><h3>cmp_dirs/2</h3><p>Compare the BEAM files in two directories.</p><p>Compares the BEAM files in
two directories. Only files with extension <strong>".beam"</strong> are
compared. BEAM files that exist only in directory
<strong><span class="anno">Dir1</span></strong> (<strong><span class="anno">Dir2</span></strong>) are returned in
<strong><span class="anno">Only1</span></strong> (<strong><span class="anno">Only2</span></strong>).
BEAM files that exist in both directories but
are considered different by <strong>cmp/2</strong> are returned as
pairs {<strong><span class="anno">Filename1</span></strong>, <strong><span class="anno">Filename2</span></strong>},
where <strong><span class="anno">Filename1</span></strong> (<strong><span class="anno">Filename2</span></strong>)
exists in directory <strong><span class="anno">Dir1</span></strong>
(<strong><span class="anno">Dir2</span></strong>).</p><h3>crypto_key_fun/1</h3><p>Register a fun that provides a crypto key.</p><ul><li>crypto_fun</li></ul><ul><li>crypto_fun_arg</li></ul><ul><li>mode</li></ul><p>Registers an unary fun
that is called if <strong>beam_lib</strong> must read an
<strong>debug_info</strong> chunk that has been encrypted. The fun
is held in a process that is started by the function.</p><p>If a fun is already registered when attempting to
register a fun, <strong>{error, exists}</strong> is returned.</p><p>The fun must handle the following arguments:</p><pre><code class="">
CryptoKeyFun(init) -&gt; ok | {ok, NewCryptoKeyFun} | {error, Term}</code></pre><p>Called when the fun is registered, in the process that holds
the fun. Here the crypto key fun can do any necessary
initializations. If <strong>{ok, NewCryptoKeyFun}</strong> is returned,
<strong>NewCryptoKeyFun</strong> is registered instead of
<strong>CryptoKeyFun</strong>. If <strong>{error, Term}</strong> is returned,
the registration is aborted and <strong>crypto_key_fun/1</strong>
also returns <strong>{error, Term}</strong>.</p><pre><code class="">
CryptoKeyFun({debug_info, Mode, Module, Filename}) -&gt; Key</code></pre><p>Called when the key is needed for module <strong>Module</strong>
in the file named <strong>Filename</strong>. <strong>Mode</strong> is the type of
crypto algorithm; currently, the only possible value is
<strong>des3_cbc</strong>. The call is to fail (raise an exception) if
no key is available.</p><pre><code class="">
CryptoKeyFun(clear) -&gt; term()</code></pre><p>Called before the fun is unregistered. Here any cleaning up
can be done. The return value is not important, but is passed
back to the caller of <strong>clear_crypto_key_fun/0</strong> as part
of its return value.</p><h3>diff_dirs/2</h3><p>Compare the BEAM files in two directories.</p><p>Compares the BEAM files in two directories as
<a href="#cmp_dirs/2">cmp_dirs/2</a>, but the
names of files that exist in only one directory or are different are
presented on standard output.</p><h3>format_error/1</h3><p>Return an English description of a BEAM read error reply. </p><p>For a specified error returned by any function in this module,
this function returns a descriptive string
of the error in English. For file errors, function
<a href="../kernel/file#format_error/1">kernel/file#format_error/1</a>
is to be called.</p><h3>info/1</h3><p>Information about a BEAM file.</p><p>Returns a list containing some information about a BEAM file
as tuples <strong>{Item, Info}</strong>:</p><dl><dt><strong>{file, <span class="anno">Filename</span>} | {binary, <span class="anno">Binary</span>}</strong></dt><dd> <p>The name (string) of the BEAM file, or the binary from
which the information was extracted.</p> </dd><dt><strong>{module, <span class="anno">Module</span>}</strong></dt><dd> <p>The name (atom) of the module.</p> </dd><dt><strong>{chunks, [{<span class="anno">ChunkId</span>, <span class="anno">Pos</span>, <span class="anno">Size</span>}]}</strong></dt><dd> <p>For each chunk, the identifier (string) and the position
and size of the chunk data, in bytes.</p> </dd></dl><h3>md5/1</h3><p>Read the module version of the BEAM file.</p><p>Calculates an MD5 redundancy check for the code of the module
(compilation date and other attributes are not included).</p><h3>strip/1</h3><p>Remove chunks not needed by the loader from a BEAM file. </p><p>Removes all chunks from a BEAM
file except those needed by the loader. In particular,
the debug information (chunk <strong>debug_info</strong> and <strong>abstract_code</strong>)
is removed.</p><h3>strip/2</h3><p>Remove chunks not needed by the loader from a BEAM file. </p><p>Removes all chunks from a BEAM
file except those needed by the loader or passed in. In particular,
the debug information (chunk <strong>debug_info</strong> and <strong>abstract_code</strong>)
is removed.</p><h3>strip_files/1</h3><p>Removes chunks not needed by the loader from BEAM files. </p><p>Removes all chunks except
those needed by the loader from BEAM files. In particular,
the debug information (chunk <strong>debug_info</strong> and <strong>abstract_code</strong>)
is removed. The returned list contains one element for each
specified filename, in the same order as in <strong>Files</strong>.</p><h3>strip_files/2</h3><p>Removes chunks not needed by the loader from BEAM files. </p><p>Removes all chunks except
those needed by the loader or passed in from BEAM files. In particular,
the debug information (chunk <strong>debug_info</strong> and <strong>abstract_code</strong>)
is removed. The returned list contains one element for each
specified filename, in the same order as in <strong>Files</strong>.</p><h3>strip_release/1</h3><p>Remove chunks not needed by the loader from all BEAM files of a release.</p><p>Removes all chunks
except those needed by the loader from the BEAM files of a
release. <strong><span class="anno">Dir</span></strong> is to be the installation root
directory. For example, the current OTP release can be
stripped with the call
<strong>beam_lib:strip_release(code:root_dir())</strong>.</p><h3>strip_release/2</h3><p>Remove chunks not needed by the loader from all BEAM files of a release.</p><p>Removes all chunks
except those needed by the loader or passed in from the BEAM files of a
release. <strong><span class="anno">Dir</span></strong> is to be the installation root
directory. For example, the current OTP release can be
stripped with the call
<strong>beam_lib:strip_release(code:root_dir())</strong>.</p><h3>version/1</h3><p>Read the module version of the BEAM file.</p><p>Returns the module version or versions. A version is defined by
module attribute <strong>-vsn(Vsn)</strong>. If this attribute is
not specified, the version defaults to the checksum of
the module. Notice that if version <strong>Vsn</strong> is not a list,
it is made into one, that is <strong>{ok,{Module,[Vsn]}}</strong> is
returned. If there are many <strong>-vsn</strong> module attributes,
the result is the concatenated list of versions.</p><p><em>Examples:</em></p><pre>
1&gt; <span class="input">beam_lib:version(a).</span> % -vsn(1).
{ok,{a,[1]}}
2&gt; <span class="input">beam_lib:version(b).</span> % -vsn([1]).
{ok,{b,[1]}}
3&gt; <span class="input">beam_lib:version(c).</span> % -vsn([1]). -vsn(2).
{ok,{c,[1,2]}}
4&gt; <span class="input">beam_lib:version(d).</span> % no -vsn attribute
{ok,{d,[275613208176997377698094100858909383631]}}</pre><h2>binary</h2><p>Library for handling binary data.</p><p>This module contains functions for manipulating byte-oriented
binaries. Although the majority of functions could be provided
using bit-syntax, the functions in this library are highly
optimized and are expected to either execute faster or consume
less memory, or both, than a counterpart written in pure Erlang.The module is provided according to Erlang Enhancement Proposal
(EEP) 31.</p><h2>Data Types</h2><span class="name">cp</span><p>Opaque data type representing a compiled
search pattern. Guaranteed to be a <strong>tuple()</strong> to allow programs to
distinguish it from non-precompiled search patterns.</p><span class="name">part</span><p>A representaion of a part (or range) in a binary. <strong>Start</strong> is
a zero-based offset into a <strong>binary()</strong> and <strong>Length</strong> is the
length of that part. As input to functions in this module, a reverse
part specification is allowed, constructed with a negative
<strong>Length</strong>, so that the part of the binary begins at <strong>Start</strong> +
<strong>Length</strong> and is -<strong>Length</strong> long. This is useful for referencing
the last <strong>N</strong> bytes of a binary as <strong>{size(Binary), -N}</strong>. The
functions in this module always return <strong>part()</strong>s with positive
<strong>Length</strong>.</p><h2>Functions</h2><h3>at/2</h3><p>Return the byte at a specific position in a binary.</p><p>Returns the byte at position <strong><span class="anno">Pos</span></strong> (zero-based) in
binary <strong><span class="anno">Subject</span></strong> as an integer. If
<strong><span class="anno">Pos</span></strong> &gt;= <strong>byte_size(<span class="anno">Subject</span>)</strong>,
a <strong>badarg</strong> exception is raised.</p><h3>bin_to_list/1</h3><p>Convert a binary to a list of integers.</p><p>Same as <strong>bin_to_list(<span class="anno">Subject</span>, {0,byte_size(<span class="anno">Subject</span>)})</strong>.</p><h3>bin_to_list/2</h3><p>Convert a binary to a list of integers.</p><p>Converts <strong><span class="anno">Subject</span></strong> to a list of <strong>byte()</strong>s, each
representing the value of one byte. <strong>part()</strong> denotes which part of
the <strong>binary()</strong> to convert.</p><p><em>Example:</em></p><pre><code class="">
1&gt; binary:bin_to_list(&lt;&lt;"erlang"&gt;&gt;, {1,3}).
"rla"
%% or [114,108,97] in list notation.</code></pre><p>If <strong><span class="anno">PosLen</span></strong> in any way references outside the binary,
a <strong>badarg</strong> exception is raised.</p><h3>bin_to_list/3</h3><p>Convert a binary to a list of integers.</p><p>Same as<strong> bin_to_list(<span class="anno">Subject</span>, {<span class="anno">Pos</span>, <span class="anno">Len</span>})</strong>.</p><h3>compile_pattern/1</h3><p>Precompile a binary search pattern.</p><p>Builds an internal structure representing a compilation of a
search pattern, later to be used in functions
<a href="#match-3">match-3</a>,
<a href="#matches-3">matches-3</a>,
<a href="#split-3">split-3</a>, or
<a href="#replace-4">replace-4</a>.
The <strong>cp()</strong> returned is guaranteed to be a
<strong>tuple()</strong> to allow programs to distinguish it from
non-precompiled search patterns.</p><p>When a list of binaries is specified, it denotes a set of
alternative binaries to search for. For example, if
<strong>[&lt;&lt;"functional"&gt;&gt;,&lt;&lt;"programming"&gt;&gt;]</strong>
is specified as <strong><span class="anno">Pattern</span></strong>, this
means either <strong>&lt;&lt;"functional"&gt;&gt;</strong> or
<strong>&lt;&lt;"programming"&gt;&gt;</strong>". The pattern is a set of
alternatives; when only a single binary is specified, the set has
only one element. The order of alternatives in a pattern is
not significant.</p><p>The list of binaries used for search alternatives must be flat and
proper.</p><p>If <strong><span class="anno">Pattern</span></strong> is not a binary or a flat proper list of
binaries with length &gt; 0, a <strong>badarg</strong> exception is raised.</p><h3>copy/1</h3><p>Create a duplicate of a binary.</p><p>Same as <strong>copy(<span class="anno">Subject</span>, 1)</strong>.</p><h3>copy/2</h3><p>Duplicate a binary <strong>N</strong> times and create a new.</p><p>Creates a binary with the content of <strong><span class="anno">Subject</span></strong>
duplicated <strong><span class="anno">N</span></strong> times.</p><p>This function always creates a new binary, even if <strong><span class="anno">N</span> = 1</strong>. By using <a href="#copy/1">copy/1</a>
on a binary referencing a larger binary, one
can free up the larger binary for garbage collection.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>By deliberately copying a single binary to avoid referencing
a larger binary, one can, instead of freeing up the larger
binary for later garbage collection, create much more binary
data than needed. Sharing binary data is usually good. Only in
special cases, when small parts reference large binaries and the
large binaries are no longer used in any process, deliberate
copying can be a good idea.</p></div><p>If <strong><span class="anno">N</span></strong> &lt; <strong>0</strong>, a <strong>badarg</strong> exception is
raised.</p><h3>decode_unsigned/1</h3><p>Decode a whole binary into an integer of arbitrary size. </p><p>Same as <strong>decode_unsigned(<span class="anno">Subject</span>, big)</strong>.</p><h3>decode_unsigned/2</h3><p>Decode a whole binary into an integer of arbitrary size. </p><p>Converts the binary digit representation, in big endian or little
endian, of a positive integer in <strong><span class="anno">Subject</span></strong> to an Erlang
<strong>integer()</strong>.</p><p><em>Example:</em></p><pre><code class="">
1&gt; binary:decode_unsigned(&lt;&lt;169,138,199&gt;&gt;,big).
11111111</code></pre><h3>encode_unsigned/1</h3><p>Encode an unsigned integer into the minimal binary.</p><p>Same as <strong>encode_unsigned(<span class="anno">Unsigned</span>, big)</strong>.</p><h3>encode_unsigned/2</h3><p>Encode an unsigned integer into the minimal binary.</p><p>Converts a positive integer to the smallest possible
representation in a binary digit representation, either big endian
or little endian.</p><p><em>Example:</em></p><pre><code class="">
1&gt; binary:encode_unsigned(11111111, big).
&lt;&lt;169,138,199&gt;&gt;</code></pre><h3>first/1</h3><p>Return the first byte of a binary.</p><p>Returns the first byte of binary <strong><span class="anno">Subject</span></strong> as an
integer. If the size of <strong><span class="anno">Subject</span></strong> is zero, a
<strong>badarg</strong> exception is raised.</p><h3>last/1</h3><p>Return the last byte of a binary.</p><p>Returns the last byte of binary <strong><span class="anno">Subject</span></strong> as an
integer. If the size of <strong><span class="anno">Subject</span></strong> is zero, a
<strong>badarg</strong> exception is raised.</p><h3>list_to_bin/1</h3><p>Convert a list of integers and binaries to a binary.</p><p>Works exactly as
<a href="../erts/erlang#list_to_binary/1">erts/erlang#list_to_binary/1</a>,
added for completeness.</p><h3>longest_common_prefix/1</h3><p>Return length of longest common prefix for a set of binaries. </p><p>Returns the length of the longest common prefix of the
binaries in list <strong><span class="anno">Binaries</span></strong>.</p><p><em>Example:</em></p><pre><code class="">
1&gt; binary:longest_common_prefix([&lt;&lt;"erlang"&gt;&gt;, &lt;&lt;"ergonomy"&gt;&gt;]).
2
2&gt; binary:longest_common_prefix([&lt;&lt;"erlang"&gt;&gt;, &lt;&lt;"perl"&gt;&gt;]).
0</code></pre><p>If <strong><span class="anno">Binaries</span></strong> is not a flat list of binaries, a
<strong>badarg</strong> exception is raised.</p><h3>longest_common_suffix/1</h3><p>Return length of longest common suffix for a set of binaries. </p><p>Returns the length of the longest common suffix of the
binaries in list <strong><span class="anno">Binaries</span></strong>.</p><p><em>Example:</em></p><pre><code class="">
1&gt; binary:longest_common_suffix([&lt;&lt;"erlang"&gt;&gt;, &lt;&lt;"fang"&gt;&gt;]).
3
2&gt; binary:longest_common_suffix([&lt;&lt;"erlang"&gt;&gt;, &lt;&lt;"perl"&gt;&gt;]).
0</code></pre><p>If <strong>Binaries</strong> is not a flat list of binaries, a <strong>badarg</strong>
exception is raised.</p><h3>match/2</h3><p>Search for the first match of a pattern in a binary.</p><p>Same as <strong>match(<span class="anno">Subject</span>, <span class="anno">Pattern</span>, [])</strong>.
</p><h3>match/3</h3><p>Search for the first match of a pattern in a binary.</p><ul><li>part</li></ul><p>Searches for the first occurrence of <strong><span class="anno">Pattern</span></strong> in
<strong><span class="anno">Subject</span></strong> and returns the position and length.</p><p>The function returns <strong>{Pos, Length}</strong> for the binary
in <strong><span class="anno">Pattern</span></strong>, starting at the lowest position in
<strong><span class="anno">Subject</span></strong>.</p><p><em>Example:</em></p><pre><code class="">
1&gt; binary:match(&lt;&lt;"abcde"&gt;&gt;, [&lt;&lt;"bcde"&gt;&gt;, &lt;&lt;"cd"&gt;&gt;],[]).
{1,4}</code></pre><p>Even though <strong>&lt;&lt;"cd"&gt;&gt;</strong> ends before
<strong>&lt;&lt;"bcde"&gt;&gt;</strong>, <strong>&lt;&lt;"bcde"&gt;&gt;</strong>
begins first and is therefore the first match. If two
overlapping matches begin at the same position, the longest is
returned.</p><p>Summary of the options:</p><dl><dt>{scope, {<span class="anno">Start</span>, <span class="anno">Length</span>}}</dt><dd><p>Only the specified part is searched. Return values still have
offsets from the beginning of <strong><span class="anno">Subject</span></strong>. A negative
<strong>Length</strong> is allowed as described in section Data Types in this
manual.</p></dd></dl><p>If none of the strings in <strong><span class="anno">Pattern</span></strong> is found, the
atom <strong>nomatch</strong> is returned.</p><p>For a description of <strong><span class="anno">Pattern</span></strong>, see function
<a href="#compile_pattern-1">compile_pattern-1</a>.
</p><p>If <strong>{scope, {Start,Length}}</strong> is specified in the options such
that <strong>Start</strong> &gt; size of <strong>Subject</strong>, <strong>Start</strong> +
<strong>Length</strong> &lt; 0 or <strong>Start</strong> + <strong>Length</strong> &gt; size of
<strong>Subject</strong>, a <strong>badarg</strong> exception is raised.</p><h3>matches/2</h3><p>Search for all matches of a pattern in a binary.</p><p>Same as <strong>matches(<span class="anno">Subject</span>, <span class="anno">Pattern</span>, [])</strong>.
</p><h3>matches/3</h3><p>Search for all matches of a pattern in a binary.</p><ul><li>part</li></ul><p>As <a href="#match-2">match-2</a>,
but <strong><span class="anno">Subject</span></strong> is searched until
exhausted and a list of all non-overlapping parts matching
<strong><span class="anno">Pattern</span></strong> is returned (in order).</p><p>The first and longest match is preferred to a shorter,
which is illustrated by the following example:</p><pre><code class="">
1&gt; binary:matches(&lt;&lt;"abcde"&gt;&gt;,
                  [&lt;&lt;"bcde"&gt;&gt;,&lt;&lt;"bc"&gt;&gt;,&lt;&lt;"de"&gt;&gt;],[]).
[{1,4}]</code></pre><p>The result shows that &lt;&lt;"bcde"&gt;&gt; is selected instead of
the shorter match &lt;&lt;"bc"&gt;&gt; (which would have given raise to
one more match, &lt;&lt;"de"&gt;&gt;).
This corresponds to the behavior of
POSIX regular expressions (and programs like awk), but is not
consistent with alternative matches in <strong>re</strong> (and Perl), where
instead lexical ordering in the search pattern selects which
string matches.</p><p>If none of the strings in a pattern is found, an empty list is
returned.</p><p>For a description of <strong><span class="anno">Pattern</span></strong>, see
<a href="#compile_pattern-1">compile_pattern-1</a>.
For a description of available options, see
<a href="#match-3">match-3</a>.</p><p>If <strong>{scope, {<span class="anno">Start</span>,<span class="anno">Length</span>}}</strong> is
specified in the options such that <strong><span class="anno">Start</span></strong> &gt; size
of <strong><span class="anno">Subject</span></strong>, <strong><span class="anno">Start</span> + <span class="anno">Length</span></strong> &lt; 0 or <strong><span class="anno">Start</span> + <span class="anno">Length</span></strong> is &gt; size of <strong><span class="anno">Subject</span></strong>,
a <strong>badarg</strong> exception is raised.</p><h3>part/2</h3><p>Extract a part of a binary.</p><p>Extracts the part of binary <strong><span class="anno">Subject</span></strong> described by
<strong><span class="anno">PosLen</span></strong>.</p><p>A negative length can be used to extract bytes at the end of a
binary:</p><pre><code class="">
1&gt; Bin = &lt;&lt;1,2,3,4,5,6,7,8,9,10&gt;&gt;.
2&gt; binary:part(Bin, {byte_size(Bin), -5}).
&lt;&lt;6,7,8,9,10&gt;&gt;</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><a href="#part-2">part/2</a> and
<a href="#part-3">part/3</a> are also available in the
<a href="./erlang">erts/erlang</a>
module under the names <strong>binary_part/2</strong> and
<strong>binary_part/3</strong>. Those BIFs are allowed in guard tests.</p></div><p>If <strong><span class="anno">PosLen</span></strong> in any way references outside the binary,
a <strong>badarg</strong> exception is raised.</p><h3>part/3</h3><p>Extract a part of a binary.</p><p>Same as <strong>part(<span class="anno">Subject</span>, {<span class="anno">Pos</span>, <span class="anno">Len</span>})</strong>.</p><h3>referenced_byte_size/1</h3><p>Determine the size of the binary pointed out by a subbinary. </p><p>If a binary references a larger binary (often described as
being a subbinary), it can be useful to get the size of the
referenced binary. This function can be used in a program to trigger the
use of <a href="#copy/1">copy/1</a>. By copying a
binary, one can dereference the original, possibly large, binary that a
smaller binary is a reference to.</p><p><em>Example:</em></p><pre><code class="">
store(Binary, GBSet) -&gt;
  NewBin =
      case binary:referenced_byte_size(Binary) of
          Large when Large &gt; 2 * byte_size(Binary) -&gt;
             binary:copy(Binary);
          _ -&gt;
             Binary
      end,
  gb_sets:insert(NewBin,GBSet).</code></pre><p>In this example, we chose to copy the binary content before
inserting it in <strong>gb_sets:set()</strong> if it references a binary more than
twice the data size we want to keep. Of course,
different rules apply when copying to different programs.</p><p>Binary sharing occurs whenever binaries are taken apart.
This is the fundamental reason why binaries are fast,
decomposition can always be done with O(1) complexity. In rare
circumstances this data sharing is however undesirable, why this
function together with <strong>copy/1</strong> can be useful when optimizing
for memory use.</p><p>Example of binary sharing:</p><pre><code class="">
1&gt; A = binary:copy(&lt;&lt;1&gt;&gt;, 100).
&lt;&lt;1,1,1,1,1 ...
2&gt; byte_size(A).
100
3&gt; binary:referenced_byte_size(A)
100
4&gt; &lt;&lt;_:10/binary,B:10/binary,_/binary&gt;&gt; = A.
&lt;&lt;1,1,1,1,1 ...
5&gt; byte_size(B).
10
6&gt; binary:referenced_byte_size(B)
100</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Binary data is shared among processes. If another process
still references the larger binary, copying the part this
process uses only consumes more memory and does not free up the
larger binary for garbage collection. Use this kind of intrusive
functions with extreme care and only if a real problem is detected.</p></div><h3>replace/3</h3><p>Replace bytes in a binary according to a pattern.</p><p>Same as <strong>replace(<span class="anno">Subject</span>, <span class="anno">Pattern</span>, <span class="anno">Replacement</span>,[])</strong>.</p><h3>replace/4</h3><p>Replace bytes in a binary according to a pattern.</p><dl><dt>OnePos</dt><dd>An integer() =&lt; byte_size(<span class="anno">Replacement</span>) </dd></dl><p>Constructs a new binary by replacing the parts in
<strong><span class="anno">Subject</span></strong> matching <strong><span class="anno">Pattern</span></strong> with
the content of <strong><span class="anno">Replacement</span></strong>.</p><p>If the matching subpart of <strong><span class="anno">Subject</span></strong> giving raise
to the replacement is to be inserted in the result, option
<strong>{insert_replaced, <span class="anno">InsPos</span>}</strong> inserts the matching part
into <strong><span class="anno">Replacement</span></strong> at the specified position (or
positions) before inserting <strong><span class="anno">Replacement</span></strong> into
<strong><span class="anno">Subject</span></strong>.</p><p><em>Example:</em></p><pre><code class="">
1&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,&lt;&lt;"b"&gt;&gt;,&lt;&lt;"[]"&gt;&gt;, [{insert_replaced,1}]).
&lt;&lt;"a[b]cde"&gt;&gt;
2&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,[&lt;&lt;"b"&gt;&gt;,&lt;&lt;"d"&gt;&gt;],&lt;&lt;"[]"&gt;&gt;,[global,{insert_replaced,1}]).
&lt;&lt;"a[b]c[d]e"&gt;&gt;
3&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,[&lt;&lt;"b"&gt;&gt;,&lt;&lt;"d"&gt;&gt;],&lt;&lt;"[]"&gt;&gt;,[global,{insert_replaced,[1,1]}]).
&lt;&lt;"a[bb]c[dd]e"&gt;&gt;
4&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,[&lt;&lt;"b"&gt;&gt;,&lt;&lt;"d"&gt;&gt;],&lt;&lt;"[-]"&gt;&gt;,[global,{insert_replaced,[1,2]}]).
&lt;&lt;"a[b-b]c[d-d]e"&gt;&gt;</code></pre><p>If any position specified in <strong><span class="anno">InsPos</span></strong> &gt; size
of the replacement binary, a <strong>badarg</strong> exception is raised.</p><p>Options <strong>global</strong> and <strong>{scope, part()}</strong> work as for
<a href="#split-3">split-3</a>.
The return type is always a <strong>binary()</strong>.</p><p>For a description of <strong><span class="anno">Pattern</span></strong>, see
<a href="#compile_pattern-1">compile_pattern-1</a>.
</p><h3>split/2</h3><p>Split a binary according to a pattern.</p><p>Same as <strong>split(<span class="anno">Subject</span>, <span class="anno">Pattern</span>, [])</strong>.</p><h3>split/3</h3><p>Split a binary according to a pattern.</p><p>Splits <strong><span class="anno">Subject</span></strong> into a list of binaries based on
<strong><span class="anno">Pattern</span></strong>. If option <strong>global</strong> is not specified,
only the first occurrence of <strong><span class="anno">Pattern</span></strong> in
<strong><span class="anno">Subject</span></strong> gives rise to a split.</p><p>The parts of <strong><span class="anno">Pattern</span></strong> found in
<strong><span class="anno">Subject</span></strong> are not included in the result.</p><p><em>Example:</em></p><pre><code class="">
1&gt; binary:split(&lt;&lt;1,255,4,0,0,0,2,3&gt;&gt;, [&lt;&lt;0,0,0&gt;&gt;,&lt;&lt;2&gt;&gt;],[]).
[&lt;&lt;1,255,4&gt;&gt;, &lt;&lt;2,3&gt;&gt;]
2&gt; binary:split(&lt;&lt;0,1,0,0,4,255,255,9&gt;&gt;, [&lt;&lt;0,0&gt;&gt;, &lt;&lt;255,255&gt;&gt;],[global]).
[&lt;&lt;0,1&gt;&gt;,&lt;&lt;4&gt;&gt;,&lt;&lt;9&gt;&gt;]</code></pre><p>Summary of options:</p><dl><dt>{scope, part()}</dt><dd><p>Works as in <a href="#match-3">match-3</a>
and <a href="#matches-3">matches-3</a>. Notice that
this only defines the scope of the search for matching strings,
it does not cut the binary before splitting. The bytes before and after
the scope are kept in the result. See the example below.</p></dd><dt>trim</dt><dd><p>Removes trailing empty parts of the result (as does <strong>trim</strong>
in <a href="./re#split/3">re#split/3</a>.</p></dd><dt>trim_all</dt><dd><p>Removes all empty parts of the result.</p></dd><dt>global</dt><dd><p>Repeats the split until <strong><span class="anno">Subject</span></strong> is
exhausted. Conceptually option <strong>global</strong> makes split work
on the positions returned by
<a href="#matches-3">matches-3</a>, while it
normally works on the position returned by
<a href="#match-3">match-3</a>.</p></dd></dl><p>Example of the difference between a scope and taking the
binary apart before splitting:</p><pre><code class="">
1&gt; binary:split(&lt;&lt;"banana"&gt;&gt;, [&lt;&lt;"a"&gt;&gt;],[{scope,{2,3}}]).
[&lt;&lt;"ban"&gt;&gt;,&lt;&lt;"na"&gt;&gt;]
2&gt; binary:split(binary:part(&lt;&lt;"banana"&gt;&gt;,{2,3}), [&lt;&lt;"a"&gt;&gt;],[]).
[&lt;&lt;"n"&gt;&gt;,&lt;&lt;"n"&gt;&gt;]</code></pre><p>The return type is always a list of binaries that are all
referencing <strong><span class="anno">Subject</span></strong>. This means that the data in
<strong><span class="anno">Subject</span></strong> is not copied to new binaries, and that
<strong><span class="anno">Subject</span></strong> cannot be garbage collected until the results
of the split are no longer referenced.</p><p>For a description of <strong><span class="anno">Pattern</span></strong>, see
<a href="#compile_pattern-1">compile_pattern-1</a>.
</p><h2>c</h2><p>Command interface module.</p><p>This module enables users to enter the short form of
some commonly used commands.</p><h2>Functions</h2><h3>bt/1</h3><p>Stack backtrace for a process.</p><p>Stack backtrace for a process. Equivalent to
<strong>erlang:process_display(<span class="anno">Pid</span>, backtrace)</strong>.</p><h3>c/1</h3><h3>c/2</h3><h3>c/3</h3><p>Compile and load a file or module.</p><p>Compiles and then purges and loads the code for a module.
<strong><span class="anno">Module</span></strong> can be either a module name or a source
file path, with or without <strong>.erl</strong> extension.
<strong><span class="anno">Options</span></strong> defaults to <strong>[]</strong>.</p><p>If <strong><span class="anno">Module</span></strong> is an atom and is not the path of a
source file, then the code path is searched to locate the object
file for the module and extract its original compiler options and
source path. If the source file is not found in the original
location, <a href="./filelib#find_source/1">filelib#find_source/1</a>
is used to search for it relative to the directory of the object
file.</p><p>The source file is compiled with the the original
options appended to the given <strong><span class="anno">Options</span></strong>, the
output replacing the old object file if and only if compilation
succeeds. A function <strong><span class="anno">Filter</span></strong> can be specified
for removing elements from from the original compiler options
before the new options are added.</p><p>Notice that purging the code means that any processes
lingering in old code for the module are killed without
warning. For more information, see <strong>code/3</strong>.</p><h3>cd/1</h3><p>Change working directory.</p><p>Changes working directory to <strong><span class="anno">Dir</span></strong>, which can be a
relative name, and then prints the name of the new working
directory.</p><p><em>Example:</em></p><pre>
2&gt; <span class="input">cd("../erlang").</span>
/home/ron/erlang</pre><h3>erlangrc/1</h3><p>Load an erlang resource file.</p><p>Search <strong>PathList</strong> and load <strong>.erlang</strong> resource file if
found.</p><h3>flush/0</h3><p>Flush any messages sent to the shell.</p><p>Flushes any messages sent to the shell.</p><h3>help/0</h3><p>Help information.</p><p>Displays help information: all valid shell internal commands,
and commands in this module.</p><h3>i/0</h3><h3>ni/0</h3><p>System information.</p><p><strong>i/0</strong> displays system information, listing
information about all processes. <strong>ni/0</strong> does the same,
but for all nodes the network.</p><h3>i/3</h3><p>Information about pid &lt;X.Y.Z&gt;.</p><p>Displays information about a process, Equivalent to
<strong>process_info(pid(<span class="anno">X</span>, <span class="anno">Y</span>, <span class="anno">Z</span>))</strong>, but location transparent.</p><h3>l/1</h3><p>Load or reload a module.</p><p>Purges and loads, or reloads, a module by calling
<strong>code:purge(<span class="anno">Module</span>)</strong> followed by
<strong>code:load_file(<span class="anno">Module</span>)</strong>.</p><p>Notice that purging the code means that any processes
lingering in old code for the module are killed without
warning. For more information, see <strong>code/3</strong>.</p><h3>lc(Files) -&gt; ok</h3><p>Compile a list of files.</p><ul><li><span class="v">Files = [File]</span></li><li><span class="v">File</span></li></ul><p>Compiles a list of files by calling
<strong>compile:file(File, [report_errors, report_warnings])</strong> for each
<strong>File</strong> in <strong>Files</strong>.</p><p>For information about <strong>File</strong>, see
<a href="./file#type-filename">file#type-filename</a>.
</p><h3>lm/0</h3><p>Loads all modified modules.</p><p>Reloads all currently loaded modules that have changed on disk (see <strong>mm()</strong>).
Returns the list of results from calling <strong>l(M)</strong> for each such <strong>M</strong>.</p><h3>ls/0</h3><p>List files in the current directory.</p><p>Lists files in the current directory.</p><h3>ls/1</h3><p>List files in a directory or a single file.</p><p>Lists files in directory <strong><span class="anno">Dir</span></strong> or, if <strong>Dir</strong>
is a file, only lists it.</p><h3>m/0</h3><p>Which modules are loaded.</p><p>Displays information about the loaded modules, including
the files from which they have been loaded.</p><h3>m/1</h3><p>Information about a module.</p><p>Displays information about <strong><span class="anno">Module</span></strong>.</p><h3>mm/0</h3><p>Lists all modified modules.</p><p>Lists all modified modules. Shorthand for
<a href="../kernel/code#modified_modules/0">kernel/code#modified_modules/0</a>.</p><h3>memory/0</h3><p>Memory allocation information.</p><p>Memory allocation information. Equivalent to
<a href="../erts/erlang#memory/0">erts/erlang#memory/0</a>.</p><h3>memory/1</h3><h3>memory/1</h3><p>Memory allocation information.</p><p>Memory allocation information. Equivalent to
<a href="../erts/erlang#memory/1">erts/erlang#memory/1</a>.</p><h3>nc/1</h3><h3>nc/2</h3><p>Compile and load code in a file on all nodes.</p><p>Compiles and then loads the code for a file on all nodes.
<strong><span class="anno">Options</span></strong> defaults to <strong>[]</strong>.
Compilation is equivalent to:</p><pre><code class="">
compile:file(<span class="anno">File</span>, <span class="anno">Options</span> ++ [report_errors, report_warnings])</code></pre><h3>nl/1</h3><p>Load module on all nodes.</p><p>Loads <strong><span class="anno">Module</span></strong> on all nodes.</p><h3>pid/3</h3><p>Convert <strong>X,Y,Z</strong> to a pid.</p><p>Converts <strong><span class="anno">X</span></strong>, <strong><span class="anno">Y</span></strong>,
<strong><span class="anno">Z</span></strong> to pid <strong>&lt;X.Y.Z&gt;</strong>.
This function is only to be used when debugging.</p><h3>pwd/0</h3><p>Print working directory.</p><p>Prints the name of the working directory.</p><h3>q/0</h3><p>Quit - shorthand for <strong>init:stop()</strong>.</p><p>This function is shorthand for <strong>init:stop()</strong>, that is,
it causes the node to stop in a controlled fashion.</p><h3>regs/0</h3><h3>nregs/0</h3><p>Information about registered processes.</p><p><strong>regs/0</strong> displays information about all registered
processes. <strong>nregs/0</strong> does the same, but for all nodes
in the network.</p><h3>uptime/0</h3><p>Print node uptime.</p><p>Prints the node uptime (as specified by
<strong>erlang:statistics(wall_clock)</strong>) in human-readable form.</p><h3>xm(ModSpec) -&gt; void()</h3><p>Cross-reference check a module.</p><ul><li><span class="v">ModSpec = Module | Filename</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Filename = string()</span></li></ul><p>Finds undefined functions, unused functions,
and calls to deprecated functions in a module by calling
<strong>xref:m/1</strong>.</p><h3>y(File) -&gt; YeccRet</h3><p>Generate an LALR-1 parser.</p><ul><li><span class="v">File = name()</span></li><li><span class="v">YeccRet</span></li></ul><p>Generates an LALR-1 parser. Equivalent to:</p><pre><code class="">
yecc:file(File)</code></pre><p>For information about <strong>File = name()</strong>, see
<a href="filename">filename</a>.
For information about <strong>YeccRet</strong>, see
<a href="../parsetools/yecc#file/1">parsetools/yecc#file/1</a>.
</p><h3>y(File, Options) -&gt; YeccRet</h3><p>Generate an LALR-1 parser.</p><ul><li><span class="v">File = name()</span></li><li><span class="v">Options, YeccRet</span></li></ul><p>Generates an LALR-1 parser. Equivalent to:</p><pre><code class="">
yecc:file(File, Options)</code></pre><p>For information about <strong>File = name()</strong>, see
<a href="filename">filename</a>.
For information about <strong>Options</strong> and <strong>YeccRet</strong>, see
<a href="../parsetools/yecc#file/1">parsetools/yecc#file/1</a>.
</p><h3>See Also</h3><p><a href="filename">filename</a>,
<a href="./compile">compiler/compile</a>,
<a href="./erlang">erts/erlang</a>,
<a href="./yecc">parsetools/yecc</a>,
<a href="./xref">tools/xref</a></p><h2>calendar</h2><p>Local and universal time, day of the week, date and time
    conversions.</p><p>This module provides computation of local and universal time,
day of the week, and many time conversion functions.Time is local when it is adjusted in accordance with the current
time zone and daylight saving. Time is universal when it reflects
the time at longitude zero, without any adjustment for daylight
saving. Universal Coordinated Time (UTC) time is also called
Greenwich Mean Time (GMT).The time functions <strong>local_time/0</strong> and
<strong>universal_time/0</strong> in this module both return date
and time. The is because separate functions for date
and time can result in a date/time combination that is displaced
by 24 hours. This occurs if one of the functions is called
before midnight, and the other after midnight. This problem also
applies to the Erlang BIFs <strong>date/0</strong> and <strong>time/0</strong>, and
their use is strongly discouraged if a reliable date/time stamp
is required.All dates conform to the Gregorian calendar. This calendar was
introduced by Pope Gregory XIII in 1582 and was used in all
Catholic countries from this year. Protestant parts of Germany
and the Netherlands adopted it in 1698, England followed in 1752,
and Russia in 1918 (the October revolution of 1917 took place in
November according to the Gregorian calendar).The Gregorian calendar in this module is extended back to year 0.
For a given date, the <em>gregorian days</em> is the number of
days up to and including the date specified. Similarly,
the <em>gregorian seconds</em> for a specified date and time is
the number of seconds up to and including the specified date
and time.For computing differences between epochs in time, use
the functions counting gregorian days or seconds. If epochs are
specified as local time, they must be converted to universal time
to get the correct value of the elapsed time between epochs.
Use of function <strong>time_difference/2</strong> is discouraged.Different definitions exist for the week of the year.
This module contains a week of the year implementation
conforming to the ISO 8601 standard. As the week number for a
specified date can fall on the previous, the current, or on the next
year, it is important to specify both the year and the week number.
Functions <strong>iso_week_number/0</strong> and <strong>iso_week_number/1</strong>
return a tuple of the year and the week number.</p><h2>Data Types</h2><span class="name">datetime</span><span class="name">datetime1970</span><span class="name">date</span><span class="name">year</span><p>Year cannot be abbreviated. For example, 93 denotes year
93, not 1993. The valid range depends on the underlying operating
system. The date tuple must denote a valid date.</p><span class="name">year1970</span><span class="name">month</span><span class="name">day</span><span class="name">time</span><span class="name">hour</span><span class="name">minute</span><span class="name">second</span><span class="name">daynum</span><span class="name">ldom</span><span class="name">yearweeknum</span><span class="name">weeknum</span><h2>Functions</h2><h3>date_to_gregorian_days/1</h3><h3>date_to_gregorian_days/3</h3><p>Compute the number of days from year 0 up to the specified date.</p><ul><li>Date</li></ul><ul><li>Year</li></ul><ul><li>Month</li></ul><ul><li>Day</li></ul><p>Computes the number of gregorian days starting
with year 0 and ending at the specified date.</p><h3>datetime_to_gregorian_seconds/1</h3><p>Compute the number of seconds from year 0 up to the specified date and time.</p><p>Computes the number of gregorian seconds starting
with year 0 and ending at the specified date and time.</p><h3>day_of_the_week/1</h3><h3>day_of_the_week/3</h3><p>Compute the day of the week.</p><ul><li>Date</li></ul><ul><li>Year</li></ul><ul><li>Month</li></ul><ul><li>Day</li></ul><p>Computes the day of the week from the specified
<strong><span class="anno">Year</span></strong>, <strong><span class="anno">Month</span></strong>, and
<strong><span class="anno">Day</span></strong>. Returns the day of the week as
<strong>1</strong>: Monday, <strong>2</strong>: Tuesday, and so on.</p><h3>gregorian_days_to_date/1</h3><p>Compute the date from the number of gregorian days.</p><p>Computes the date from the specified number of gregorian days.</p><h3>gregorian_seconds_to_datetime/1</h3><p>Compute the date and time from the number of gregorian seconds. </p><p>Computes the date and time from the specified
number of gregorian seconds.</p><h3>is_leap_year/1</h3><p>Check if the year is a leap year.</p><p>Checks if the specified year is a leap year.</p><h3>iso_week_number/0</h3><p>Compute the ISO week number for the actual date.</p><p>Returns tuple <strong>{Year, WeekNum}</strong> representing
the ISO week number for the actual date. To determine the
actual date, use function
<a href="#local_time/0">local_time/0</a>.</p><h3>iso_week_number/1</h3><p>Compute the ISO week number for the specified date.</p><p>Returns tuple <strong>{Year, WeekNum}</strong> representing
the ISO week number for the specified date.</p><h3>last_day_of_the_month/2</h3><p>Compute the number of days in a month.</p><p>Computes the number of days in a month.</p><h3>local_time/0</h3><p>Compute local time.</p><p>Returns the local time reported by
the underlying operating system.</p><h3>local_time_to_universal_time/1</h3><p>Convert from local time to universal time (deprecated). </p><p>Converts from local time to Universal Coordinated Time (UTC).
<strong><span class="anno">DateTime1</span></strong> must refer to a local
date after Jan 1, 1970.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated. Use
<a href="#local_time_to_universal_time_dst/1">local_time_to_universal_time_dst/1</a>
instead, as it gives a more correct and complete result.
Especially for
the period that does not exist, as it is skipped during
the switch <em>to</em> daylight saving time, this function
still returns a result.</p></div><h3>local_time_to_universal_time_dst/1</h3><p>Convert from local time to universal time(s).</p><p>Converts from local time to Universal Coordinated Time (UTC).
<strong><span class="anno">DateTime1</span></strong> must refer to a local
date after Jan 1, 1970.</p><p>The return value is a list of 0, 1, or 2 possible UTC times:</p><dl><dt><strong>[]</strong></dt><dd> <p>For a local <strong>{Date1, Time1}</strong> during the period that
is skipped when switching <em>to</em> daylight saving
time, there is no corresponding UTC, as the local time
is illegal (it has never occured).</p> </dd><dt><strong>[DstDateTimeUTC, DateTimeUTC]</strong></dt><dd> <p>For a local <strong>{Date1, Time1}</strong> during the period that
is repeated when switching <em>from</em> daylight saving
time, two corresponding UTCs exist; one for the first
instance of the period when daylight saving time is still
active, and one for the second instance.</p> </dd><dt><strong>[DateTimeUTC]</strong></dt><dd> <p>For all other local times only one corresponding UTC exists.</p> </dd></dl><h3>now_to_datetime/1</h3><p>Convert now to date and time.</p><p>Returns Universal Coordinated Time (UTC)
converted from the return value from
<a href="../erts/erlang#timestamp/0">erts/erlang#timestamp/0</a>.
</p><h3>now_to_local_time/1</h3><p>Convert now to local date and time.</p><p>Returns local date and time converted from the return value from
<a href="../erts/erlang#timestamp/0">erts/erlang#timestamp/0</a>.
</p><h3>now_to_universal_time/1</h3><p>Convert now to date and time.</p><p>Returns Universal Coordinated Time (UTC)
converted from the return value from
<a href="../erts/erlang#timestamp/0">erts/erlang#timestamp/0</a>.
</p><h3>rfc3339_to_system_time/1</h3><h3>rfc3339_to_system_time/2</h3><p>Convert from RFC 3339 timestamp to system time.</p><ul><li>rfc3339_string</li></ul><ul><li>rfc3339_time_unit</li></ul><p>Converts an RFC 3339 timestamp into system time. The data format
of RFC 3339 timestamps is described by
<a href="https://www.ietf.org/rfc/rfc3339.txt">RFC 3339</a>.</p><p>Valid option:</p><dl><dt><strong>{unit, Unit}</strong></dt><dd><p>The time unit of the return value.
The default is <strong>second</strong>.</p> </dd></dl><pre>
1&gt; <span class="input">calendar:rfc3339_to_system_time("2018-02-01T16:17:58+01:00").</span>
1517498278
2&gt; <span class="input">calendar:rfc3339_to_system_time("2018-02-01 15:18:02.088Z", [{unit, nanosecond}]).</span>
1517498282088000000</pre><h3>seconds_to_daystime/1</h3><p>Compute days and time from seconds.</p><p>Converts a specified number of seconds into days, hours, minutes,
and seconds. <strong><span class="anno">Time</span></strong> is always non-negative, but
<strong><span class="anno">Days</span></strong> is negative if argument
<strong><span class="anno">Seconds</span></strong> is.</p><h3>seconds_to_time/1</h3><p>Compute time from seconds.</p><ul><li>secs_per_day</li></ul><p>Computes the time from the specified number of seconds.
<strong><span class="anno">Seconds</span></strong> must be less than the number of
seconds per day (86400).</p><h3>system_time_to_local_time/2</h3><p>Convert system time to local date and time.</p><p>Converts a specified system time into local date and time.</p><h3>system_time_to_rfc3339/1</h3><h3>system_time_to_rfc3339/2</h3><p>Convert from system to RFC 3339 timestamp.</p><ul><li>offset</li></ul><ul><li>rfc3339_string</li></ul><ul><li>rfc3339_time_unit</li></ul><p>Converts a system time into an RFC 3339 timestamp. The data format
of RFC 3339 timestamps is described by
<a href="https://www.ietf.org/rfc/rfc3339.txt">RFC 3339</a>.
The data format of offsets is also described by RFC 3339.</p><p>Valid options:</p><dl><dt><strong>{offset, Offset}</strong></dt><dd><p>The offset, either a string or an integer, to be
included in the formatted string.
An empty string, which is the default, is interpreted
as local time. A non-empty string is included as is.
The time unit of the integer is the same as the one
of <strong><span class="anno">Time</span></strong>.</p> </dd><dt><strong>{time_designator, Character}</strong></dt><dd><p>The character used as time designator, that is,
the date and time separator. The default is <strong>$T</strong>.</p> </dd><dt><strong>{unit, Unit}</strong></dt><dd><p>The time unit of <strong><span class="anno">Time</span></strong>. The
default is <strong>second</strong>. If some other unit is given
(<strong>millisecond</strong>, <strong>microsecond</strong>, or
<strong>nanosecond</strong>), the formatted string includes a
fraction of a second. The number of fractional second
digits is three, six, or nine depending on what time unit
is chosen. Notice that trailing zeros are not removed from
the fraction.
</p> </dd></dl><pre>
1&gt; <span class="input">calendar:system_time_to_rfc3339(erlang:system_time(second)).</span>
"2018-04-23T14:56:28+02:00"
2&gt; <span class="input">calendar:system_time_to_rfc3339(erlang:system_time(second), [{offset, "-02:00"}]).</span>
"2018-04-23T10:56:52-02:00"
3&gt; <span class="input">calendar:system_time_to_rfc3339(erlang:system_time(second), [{offset, -7200}]).</span>
"2018-04-23T10:57:05-02:00"
4&gt; <span class="input">calendar:system_time_to_rfc3339(erlang:system_time(millisecond), [{unit, millisecond}, {time_designator, $\s}, {offset, "Z"}]).</span>
"2018-04-23 12:57:20.482Z"</pre><h3>system_time_to_universal_time/2</h3><p>Convert system time to universal date and time.</p><p>Converts a specified system time into universal date and time.</p><h3>time_difference/2</h3><p>Compute the difference between two times (deprecated). </p><p>Returns the difference between two <strong>{Date, Time}</strong> tuples.
<strong><span class="anno">T2</span></strong> is to refer to an epoch later
than <strong><span class="anno">T1</span></strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is obsolete. Use the conversion functions for
gregorian days and seconds instead.</p></div><h3>time_to_seconds/1</h3><p>Compute the number of seconds since midnight up to the specified time.</p><ul><li>secs_per_day</li></ul><p>Returns the number of seconds since midnight
up to the specified time.</p><h3>universal_time/0</h3><p>Compute universal time.</p><p>Returns the Universal Coordinated Time (UTC)
reported by the underlying operating system. Returns local time if
universal time is unavailable.</p><h3>universal_time_to_local_time/1</h3><p>Convert from universal time to local time.</p><p>Converts from Universal Coordinated Time (UTC) to local time.
<strong><span class="anno">DateTime</span></strong> must refer to a date after Jan 1, 1970.
</p><h3>valid_date/1</h3><h3>valid_date/3</h3><p>Check if a date is valid</p><ul><li>Date</li></ul><ul><li>Year</li></ul><ul><li>Month</li></ul><ul><li>Day</li></ul><p>This function checks if a date is a valid.</p><h3>Leap Years</h3><p>The notion that every fourth year is a leap year is not
completely true. By the Gregorian rule, a year Y is a leap year if
one of the following rules is valid:</p><ul><li> <p>Y is divisible by 4, but not by 100.</p> </li><li> <p>Y is divisible by 400.</p> </li></ul><p>Hence, 1996 is a leap year, 1900 is not, but 2000 is.</p><h3>Date and Time Source</h3><p>Local time is obtained from the Erlang BIF <strong>localtime/0</strong>.
Universal time is computed from the BIF <strong>universaltime/0</strong>.</p><p>The following apply:</p><ul><li>There are 86400 seconds in a day.</li><li>There are 365 days in an ordinary year.</li><li>There are 366 days in a leap year.</li><li>There are 1461 days in a 4 year period.</li><li>There are 36524 days in a 100 year period.</li><li>There are 146097 days in a 400 year period.</li><li>There are 719528 days between Jan 1, 0 and Jan 1, 1970.</li></ul><h2>dets</h2><p>A disk-based term storage.</p><p>This module provides a term storage on file. The
stored terms, in this module called <em>objects</em>, are tuples
such that one element is defined to be the key. A Dets
<em>table</em> is a collection of objects with the key at the same
position stored on a file.This module is used by the Mnesia application, and is provided
"as is" for users who are interested in efficient storage of Erlang
terms on disk only. Many applications only need to store some
terms in a file. Mnesia adds transactions, queries, and
distribution. The size of Dets files cannot exceed 2 GB. If larger
tables are needed, table fragmentation in Mnesia can be used.Three types of Dets tables exist:<ul><li><p><strong>set</strong>. A table of this type has at most one object with a
given key. If an object with a key already present in the
table is inserted, the existing object is overwritten by the new
object.</p> </li><li><p><strong>bag</strong>. A table of this type has zero or more different
objects with a given key.</p> </li><li><p><strong>duplicate_bag</strong>. A table of this type has zero or more
possibly matching objects with a given key.</p> </li></ul>Dets tables must be opened before they can be updated or read,
and when finished they must be properly closed. If a table is not
properly closed, Dets automatically repairs the table.
This can take a substantial time if the table is large. A Dets
table is closed when the process which opened the table
terminates. If many Erlang processes (users) open the same Dets
table, they share the table. The table is properly closed
when all users have either terminated or closed the table. Dets
tables are not properly closed if the Erlang runtime system
terminates abnormally.As all operations performed by Dets are disk operations, it
is important to realize that a single look-up operation involves a
series of disk seek and read operations. The Dets functions
are therefore much slower than the corresponding
<a href="ets">ets</a> functions,
although Dets exports a similar interface.Dets organizes data as a linear hash list and the hash list
grows gracefully as more data is inserted into the table. Space
management on the file is performed by what is called a buddy
system. The current implementation keeps the entire buddy system
in RAM, which implies that if the table gets heavily fragmented,
quite some memory can be used up. The only way to defragment a
table is to close it and then open it again with option <strong>repair</strong>
set to <strong>force</strong>.Notice that type <strong>ordered_set</strong> in Ets is not yet
provided by Dets, neither is the limited support for
concurrent updates that makes a sequence of <strong>first</strong> and
<strong>next</strong> calls safe to use on fixed ETS tables. Both these
features may be provided by Dets in a future release of
Erlang/OTP. Until then, the Mnesia application (or some
user-implemented method for locking) must be used to implement safe
concurrency. Currently, no Erlang/OTP library has support for
ordered disk-based term storage.All Dets functions return <strong>{error, Reason}</strong> if an error
occurs (<a href="#first/1">first/1</a> and
<a href="#next/2">next/2</a> are exceptions, they
exit the process with the error tuple). If badly formed arguments are
specified, all functions exit the process with a <strong>badarg</strong>
message.</p><h2>Data Types</h2><span class="name">access</span><span class="name">auto_save</span><span class="name">bindings_cont</span><p>Opaque continuation used by <a href="#match/1">match/1</a> and <a href="#match/3">match/3</a>.</p><span class="name">cont</span><p>Opaque continuation used by <a href="#bchunk/2">bchunk/2</a>.</p><span class="name">keypos</span><span class="name">match_spec</span><p>Match specifications, see section
<a href="./match_spec"> Match Specification in Erlang</a> in ERTS User's Guide and the
<a href="ms_transform">ms_transform</a>
module.</p><span class="name">no_slots</span><span class="name">object</span><span class="name">object_cont</span><p>Opaque continuation used by <a href="#match_object/1">match_object/1</a> and
<a href="#match_object/3">match_object/3</a>.</p><span class="name">pattern</span><p>For a description of patterns, see
<a href="./ets#match/2">ets#match/2</a>.</p><span class="name">select_cont</span><p>Opaque continuation used by <a href="#select/1">select/1</a> and <a href="#select/3">select/3</a>.</p><span class="name">tab_name</span><span class="name">type</span><h2>Functions</h2><h3>all/0</h3><p>Return a list of the names of all open Dets tables on this node.</p><p>Returns a list of the names of all open tables on this node.</p><h3>bchunk/2</h3><p>Return a chunk of objects stored in a Dets table. </p><p>Returns a list of objects stored in a table. The exact
representation of the returned objects is not public. The
lists of data can be used for initializing a table by specifying
value <strong>bchunk</strong> to option <strong>format</strong> of function
<a href="#init_table/3">init_table/3</a>
The Mnesia application uses this
function for copying open tables.</p><p>Unless the table is protected using <strong>safe_fixtable/2</strong>,
calls to <strong>bchunk/2</strong> do possibly not work as expected if
concurrent updates are made to the table.</p><p>The first time <strong>bchunk/2</strong> is called, an initial
continuation, the atom <strong>start</strong>, must be provided.</p><p><strong>bchunk/2</strong> returns a tuple
<strong>{<span class="anno">Continuation2</span>, <span class="anno">Data</span>}</strong>,
where <strong><span class="anno">Data</span></strong> is a list of
objects. <strong><span class="anno">Continuation2</span></strong> is another continuation
that is to be passed on to a subsequent call to <strong>bchunk/2</strong>. With
a series of calls to <strong>bchunk/2</strong>, all table objects can be
extracted.</p><p><strong>bchunk/2</strong> returns <strong>'$end_of_table'</strong> when all
objects are returned, or <strong>{error, <span class="anno">Reason</span>}</strong>
if an error occurs.</p><h3>close/1</h3><p>Close a Dets table.</p><p>Closes a table. Only processes that have opened a table are
allowed to close it.</p><p>All open tables must be closed before the system is
stopped. If an attempt is made to open a table that is not
properly closed, Dets automatically tries to repair it.</p><h3>delete/2</h3><p>Delete all objects with a specified key from a Dets table.</p><p>Deletes all objects with key <strong><span class="anno">Key</span></strong> from
table <strong><span class="anno">Name</span></strong>.</p><h3>delete_all_objects/1</h3><p>Delete all objects from a Dets table.</p><p>Deletes all objects from a table in almost constant time.
However, if the table if fixed, <strong>delete_all_objects(T)</strong>
is equivalent to <strong>match_delete(T, '_')</strong>.</p><h3>delete_object/2</h3><p>Delete a specified object from a Dets table.</p><p>Deletes all instances of a specified object from a table. If a
table is of type <strong>bag</strong> or <strong>duplicate_bag</strong>, this
function can be used to delete only some of
the objects with a specified key.</p><h3>first/1</h3><p>Return the first key stored in a Dets table.</p><p>Returns the first key stored in table <strong><span class="anno">Name</span></strong>
according to the internal order of the table, or
<strong>'$end_of_table'</strong> if the table is empty.</p><p>Unless the table is protected using <strong>safe_fixtable/2</strong>,
subsequent calls to <a href="#next/2">next/2</a>
do possibly not work as expected if
concurrent updates are made to the table.</p><p>If an error occurs, the process is exited with an error
tuple <strong>{error, Reason}</strong>. The error tuple is not returned,
as it cannot be distinguished from a key.</p><p>There are two reasons why <strong>first/1</strong> and <strong>next/2</strong>
are not to be used: they are not efficient, and they
prevent the use of key <strong>'$end_of_table'</strong>, as this atom
is used to indicate the end of the table. If possible, use functions
<a href="#match/1">match/1</a>,
<a href="#match_object/1">match_object/1</a>, and
<a href="#select/1">select/1</a>
for traversing tables.</p><h3>foldl/3</h3><h3>foldr/3</h3><p>Fold a function over a Dets table.</p><p>Calls <strong><span class="anno">Function</span></strong> on successive elements of
table <strong><span class="anno">Name</span></strong> together with an extra argument
<strong>AccIn</strong>. The table elements are traversed in unspecified
order. <strong><span class="anno">Function</span></strong> must return a new
accumulator that is passed to the next call.
<strong><span class="anno">Acc0</span></strong> is returned if the table is empty.</p><h3>from_ets/2</h3><p>Replace the objects of a Dets table with the objects of an ETS table.</p><p>Deletes all objects of table <strong><span class="anno">Name</span></strong> and then
inserts all the objects of the ETS table
<strong><span class="anno">EtsTab</span></strong>. The objects are inserted in unspecified
order. As <strong>ets:safe_fixtable/2</strong> is called, the ETS table
must be public or owned by the calling process.</p><h3>info/1</h3><p>Return information about a Dets table.</p><p>Returns information about table <strong><span class="anno">Name</span></strong>
as a list of tuples:</p><ul><li> <p><strong>{file_size, integer() &gt;= 0}}</strong> - The file size, in
bytes.</p> </li><li> <p><strong>{filename, </strong><a href="./file#type-name">file#type-name</a><strong>}</strong> - The name of the file
where objects are stored.</p> </li><li> <p><strong>{keypos, </strong><a href="#type-keypos">type-keypos</a><strong>}</strong> - The key position.</p> </li><li> <p><strong>{size, integer() &gt;= 0}</strong> - The number of objects
stored in the table.</p> </li><li> <p><strong>{type, </strong><a href="#type-type">type-type</a><strong>}</strong> - The table type.</p> </li></ul><h3>info/2</h3><p>Return the information associated with a specified item for a Dets table.</p><p>Returns the information associated with <strong><span class="anno">Item</span></strong>
for table <strong><span class="anno">Name</span></strong>.
In addition to the <strong>{<span class="anno">Item</span>, <span class="anno">Value</span>}</strong>
pairs defined for <a href="#info/1">info/1</a>,
the following items are allowed:</p><ul><li> <p><strong>{access, </strong><a href="#type-access">type-access</a><strong>}</strong> - The access mode.</p> </li><li> <p><strong>{auto_save, </strong><a href="#type-auto_save">type-auto_save</a><strong>}</strong> - The autosave interval.</p> </li><li> <p><strong>{bchunk_format, binary()}</strong> - An opaque binary
describing the format of the objects returned by
<strong>bchunk/2</strong>. The binary can be used as argument to
<strong>is_compatible_chunk_format/2</strong>.</p> </li><li> <p><strong>{hash, Hash}</strong> - Describes which BIF is
used to calculate the hash values of the objects stored in the
Dets table. Possible values of <strong>Hash</strong>:</p> <ul><li> <p><strong>phash</strong> - Implies that the <strong>erlang:phash/2</strong> BIF
is used.</p> </li><li> <p><strong>phash2</strong> - Implies that the <strong>erlang:phash2/1</strong> BIF
is used.</p> </li></ul> </li><li> <p><strong>{memory, integer() &gt;= 0}</strong> - The file size, in bytes.
The same value is associated with item <strong>file_size</strong>.</p> </li><li> <p><strong>{no_keys, integer &gt;= 0()}</strong> - The number of different
keys stored in the table.</p> </li><li> <p><strong>{no_objects, integer &gt;= 0()}</strong> - The number of objects
stored in the table.</p> </li><li> <p><strong>{no_slots, {Min, Used, Max}}</strong> - The
number of slots of the table. <strong>Min</strong> is the minimum number of
slots, <strong>Used</strong> is the number of currently used slots,
and <strong>Max</strong> is the maximum number of slots.</p> </li><li> <p><strong>{owner, pid()}</strong> - The pid of the process that
handles requests to the Dets table.</p> </li><li> <p><strong>{ram_file, boolean()}</strong> - Whether the table is
kept in RAM.</p> </li><li> <p><strong>{safe_fixed_monotonic_time, SafeFixed}</strong> - If the table
is fixed, <strong>SafeFixed</strong> is a tuple
<strong>{FixedAtTime, [{Pid,RefCount}]}</strong>.
<strong>FixedAtTime</strong> is the time when
the table was first fixed, and <strong>Pid</strong> is the pid of
the process that fixes the table <strong>RefCount</strong> times.
There can be any number of processes in the list. If the table
is not fixed, <strong>SafeFixed</strong> is the atom <strong>false</strong>.</p> <p><strong>FixedAtTime</strong> corresponds to the result returned by
<a href="../erts/erlang#monotonic_time/0">erts/erlang#monotonic_time/0</a> at the time of fixation.
The use of <strong>safe_fixed_monotonic_time</strong> is
<a href="../erts/time_correction#Time_Warp_Safe_Code"> time warp safe</a>.</p> </li><li> <p><strong>{safe_fixed, SafeFixed}</strong> - The same as
<strong>{safe_fixed_monotonic_time, SafeFixed}</strong> except
the format and value of <strong>FixedAtTime</strong>.</p> <p><strong>FixedAtTime</strong> corresponds to the result returned by
<a href="../erts/erlang#timestamp/0">erts/erlang#timestamp/0</a> at the time of fixation.
Notice that when the system uses single or multi
<a href="../erts/time_correction#Time_Warp_Modes">time warp modes</a>, this can produce strange results. This is
because the use of <strong>safe_fixed</strong> is not
<a href="../erts/time_correction#Time_Warp_Safe_Code"> time warp safe</a>. Time warp safe code must use
<strong>safe_fixed_monotonic_time</strong> instead.</p> </li></ul><h3>init_table/2</h3><h3>init_table/3</h3><p>Replace all objects of a Dets table.</p><p>Replaces the existing objects of table <strong><span class="anno">Name</span></strong>
with objects created by calling the input function
<strong><span class="anno">InitFun</span></strong>,
see below. The reason for using this function rather than
calling <strong>insert/2</strong> is that of efficiency. Notice
that the input functions are called by the process that
handles requests to the Dets table, not by the calling
process.</p><p>When called with argument <strong>read</strong>, function
<strong><span class="anno">InitFun</span></strong> is assumed to return <strong>end_of_input</strong>
when there is no more input, or <strong>{Objects, Fun}</strong>, where
<strong>Objects</strong> is a list of objects and <strong>Fun</strong> is a new
input function. Any other value <strong>Value</strong> is returned as an error
<strong>{error, {init_fun, Value}}</strong>. Each input function is
called exactly once, and if an error occurs, the last
function is called with argument <strong>close</strong>, the reply
of which is ignored.</p><p>If the table type is <strong>set</strong> and more
than one object exists with a given key, one of the objects is
chosen. This is not necessarily the last object with the given
key in the sequence of objects returned by the input
functions. Avoid duplicate keys, otherwise the file becomes 
unnecessarily fragmented. This holds also for duplicated
objects stored in tables of type <strong>bag</strong>.</p><p>It is important that the table has a sufficient number of
slots for the objects. If not, the hash list starts to
grow when <strong>init_table/2</strong> returns, which significantly
slows down access to the table for a period of time. The
minimum number of slots is set by the <strong>open_file/2</strong> option
<strong>min_no_slots</strong> and returned by the <strong>info/2</strong>
item <strong>no_slots</strong>. See also option <strong>min_no_slots</strong> below.</p><p>Argument <strong><span class="anno">Options</span></strong> is a list of <strong>{Key, Val}</strong>
tuples, where the following values are allowed:</p><ul><li> <p><strong>{min_no_slots, no_slots()}</strong> - Specifies the
estimated number of different keys to be stored
in the table. The <strong>open_file/2</strong> option with the same
name is ignored, unless the table is created, in which
case performance can be enhanced by supplying an
estimate when initializing the table.</p> </li><li> <p><strong>{format, Format}</strong> - Specifies the format of the
objects returned by function <strong><span class="anno">InitFun</span></strong>. If
<strong>Format</strong> is <strong>term</strong> (the default),
<strong><span class="anno">InitFun</span></strong> is assumed to return a list of tuples.
If <strong>Format</strong> is <strong>bchunk</strong>, <strong><span class="anno">InitFun</span></strong> is
assumed to return <strong><span class="anno">Data</span></strong> as returned by
<a href="#bchunk/2">bchunk/2</a>.
This option overrides option <strong>min_no_slots</strong>.</p> </li></ul><h3>insert/2</h3><p>Insert one or more objects into a Dets table.</p><p>Inserts one or more objects into the table <strong><span class="anno">Name</span></strong>.
If there already exists an object with a key matching the key of
some of the given objects and the table type is <strong>set</strong>,
the old object will be replaced.</p><h3>insert_new/2</h3><p>Insert one or more objects into a Dets table.</p><p>Inserts one or more objects into table <strong><span class="anno">Name</span></strong>.
If there already exists some object with a key matching the key
of any of the specified objects, the table is not updated and
<strong>false</strong> is returned. Otherwise the objects are inserted
and <strong>true</strong> returned.</p><h3>is_compatible_bchunk_format/2</h3><p>Test compatibility of chunk data of a table.</p><p>Returns <strong>true</strong> if it would be possible to initialize
table <strong><span class="anno">Name</span></strong>, using
<a href="#init_table/3">init_table/3</a> with
option <strong>{format,bchunk}</strong>,  with objects read with
<a href="#bchunk/2">bchunk/2</a> from some
table <strong>T</strong>, such that calling
<strong>info(T,bchunk_format)</strong> returns
<strong>BchunkFormat</strong>.</p><h3>is_dets_file/1</h3><p>Test for a Dets table.</p><p>Returns <strong>true</strong> if file <strong><span class="anno">Filename</span></strong>
is a Dets table, otherwise <strong>false</strong>.</p><h3>lookup/2</h3><p>Return all objects with a specified key stored in a Dets table.</p><p>Returns a list of all objects with key <strong><span class="anno">Key</span></strong>
stored in table <strong><span class="anno">Name</span></strong>, for example:</p><pre>
2&gt; <span class="input">dets:open_file(abc, [{type, bag}]).</span>
{ok,abc}
3&gt; <span class="input">dets:insert(abc, {1,2,3}).</span>
ok
4&gt; <span class="input">dets:insert(abc, {1,3,4}).</span>
ok
5&gt; <span class="input">dets:lookup(abc, 1).</span>
[{1,2,3},{1,3,4}]</pre><p>If the table type is <strong>set</strong>, the function returns
either the empty list or a list with one object, as there
cannot be more than one object with a given key. If the table
type is <strong>bag</strong> or <strong>duplicate_bag</strong>, the function
returns a list of arbitrary length.</p><p>Notice that the order of objects returned is unspecified. In
particular, the order in which objects were inserted is not
reflected.</p><h3>match/1</h3><p>Match a chunk of objects stored in a Dets table and return a list of variable bindings.</p><p>Matches some objects stored in a table and returns a
non-empty list of the bindings matching a specified pattern in
some unspecified order. The table, the pattern, and the number
of objects that are matched are all defined by
<strong><span class="anno">Continuation</span></strong>, which has been returned by a
previous call to <strong>match/1</strong> or <strong>match/3</strong>.</p><p>When all table objects are matched,
<strong>'$end_of_table'</strong> is returned.</p><h3>match/2</h3><p>Match the objects stored in a Dets table and return a list of variable bindings.</p><p>Returns for each object of table <strong><span class="anno">Name</span></strong> that
matches <strong><span class="anno">Pattern</span></strong> a list of bindings in some
unspecified order. For a description of patterns, see
<a href="./ets#match/2">ets#match/2</a>.
If the keypos'th element of
<strong><span class="anno">Pattern</span></strong> is unbound, all table objects are
matched. If the keypos'th element is bound, only the
objects with the correct key are matched.</p><h3>match/3</h3><p>Match the first chunk of objects stored in a Dets table and return a list of variable bindings.</p><p>Matches some or all objects of table <strong><span class="anno">Name</span></strong> and
returns a non-empty list of the bindings that match
<strong><span class="anno">Pattern</span></strong> in some unspecified order.
For a description of patterns, see
<a href="./ets#match/2">ets#match/2</a>.</p><p>A tuple of the bindings and a continuation is returned,
unless the table is empty, in which case
<strong>'$end_of_table'</strong> is returned. The continuation is to be
used when matching further objects by calling
<a href="#match/1">match/1</a>.</p><p>If the keypos'th element of <strong><span class="anno">Pattern</span></strong> is bound,
all table objects are matched. If the keypos'th element is
unbound, all table objects are matched, <strong><span class="anno">N</span></strong>
objects at a time, until at least one object matches or the
end of the table is reached. The default, indicated by
giving <strong><span class="anno">N</span></strong> the value <strong>default</strong>, is to let
the number of objects vary depending on the sizes of the objects.
All objects with the
same key are always matched at the same time, which implies that
more than <span class="anno">N</span> objects can sometimes be matched.</p><p>The table is always to be protected using
<a href="#safe_fixtable/2">safe_fixtable/2</a>
before calling <strong>match/3</strong>, otherwise
errors can occur when calling <strong>match/1</strong>.</p><h3>match_delete/2</h3><p>Delete all objects that match a given pattern from a Dets table.</p><p>Deletes all objects that match <strong><span class="anno">Pattern</span></strong> from
table <strong><span class="anno">Name</span></strong>. For a description of patterns,
see <a href="./ets#match/2">ets#match/2</a>.</p><p>If the keypos'th element of <strong>Pattern</strong> is bound,
only the objects with the correct key are matched.</p><h3>match_object/1</h3><p>Match a chunk of objects stored in a Dets table and return a list of objects.</p><p>Returns a non-empty list of some objects stored in a table
that match a given pattern in some unspecified order. The
table, the pattern, and the number of objects that are matched
are all defined by <strong><span class="anno">Continuation</span></strong>, which has been
returned by a previous call to <strong>match_object/1</strong> or
<strong>match_object/3</strong>.</p><p>When all table objects are matched,
<strong>'$end_of_table'</strong> is returned.</p><h3>match_object/2</h3><p>Match the objects stored in a Dets table and return a list of objects.</p><p>Returns a list of all objects of table <strong><span class="anno">Name</span></strong> that
match <strong><span class="anno">Pattern</span></strong> in some unspecified order.
For a description of patterns, see
<a href="./ets#match/2">ets#match/2</a>.</p><p>If the keypos'th element of <strong><span class="anno">Pattern</span></strong> is
unbound, all table objects are matched. If the
keypos'th element of <strong><span class="anno">Pattern</span></strong> is bound, only the
objects with the correct key are matched.</p><p>Using the <strong>match_object</strong> functions for traversing all
table objects is more efficient than calling
<strong>first/1</strong> and <strong>next/2</strong> or <strong>slot/2</strong>.</p><h3>match_object/3</h3><p>Match the first chunk of objects stored in a Dets table and return a list of objects.</p><p>Matches some or all objects stored in table <strong><span class="anno">Name</span></strong>
and returns a non-empty list of the objects that match
<strong><span class="anno">Pattern</span></strong> in some unspecified order.
For a description of patterns, see
<a href="./ets#match/2">ets#match/2</a>.</p><p>A list of objects and a continuation is returned, unless
the table is empty, in which case <strong>'$end_of_table'</strong>
is returned. The continuation is to be used when matching
further objects by calling
<a href="#match_object/1">match_object/1</a>.</p><p>If the keypos'th element of <strong><span class="anno">Pattern</span></strong> is bound,
all table objects are matched. If the keypos'th element is
unbound, all table objects are matched, <strong><span class="anno">N</span></strong>
objects at a time, until at least one object matches or the
end of the table is reached. The default, indicated by
giving <strong><span class="anno">N</span></strong> the value <strong>default</strong>,
is to let the number
of objects vary depending on the sizes of the objects. All
matching objects with the same key are always returned
in the same reply, which implies
that more than <span class="anno">N</span> objects can sometimes be returned.</p><p>The table is always to be protected using
<a href="#safe_fixtable/2">safe_fixtable/2</a>
before calling <strong>match_object/3</strong>, otherwise
errors can occur when calling <strong>match_object/1</strong>.</p><h3>member/2</h3><p>Test for occurrence of a key in a Dets table.</p><p>Works like <a href="#lookup/2">lookup/2</a>,
but does not return the objects. Returns <strong>true</strong> if one or more
table elements has key <strong><span class="anno">Key</span></strong>, otherwise
<strong>false</strong>.</p><h3>next/2</h3><p>Return the next key in a Dets table.</p><p>Returns either the key following <strong><span class="anno">Key1</span></strong> in table
<strong><span class="anno">Name</span></strong> according to the internal order of the
table, or <strong>'$end_of_table'</strong> if there is no next key.</p><p>If an error occurs, the process is exited with an error
tuple <strong>{error, Reason}</strong>.</p><p>To find the first key in the table, use
<a href="#first/1">first/1</a>.</p><h3>open_file/1</h3><p>Open an existing Dets table.</p><p>Opens an existing table. If the table is not properly closed,
it is repaired. The returned reference is to be used as the table
name. This function is most useful for debugging purposes.</p><h3>open_file/2</h3><p>Open a Dets table.</p><p>Opens a table. An empty Dets table is created if no file
exists.</p><p>The atom <strong><span class="anno">Name</span></strong> is the table name. The table
name must be provided in all subsequent operations on the
table. The name can be used by other processes as well, and
many processes can share one table.</p><p>If two processes open the same table by giving the same
name and arguments, the table has two users. If one
user closes the table, it remains open until the second
user closes it.</p><p>Argument <strong><span class="anno">Args</span></strong> is a list of <strong>{Key, Val}</strong>
tuples, where the following values are allowed:</p><ul><li> <p><strong>{access, </strong><a href="#type-access">type-access</a><strong>}</strong> - Existing tables can be
opened in read-only mode. A table that is opened
in read-only mode is not subjected to the automatic file
reparation algorithm if it is later opened after a crash.
Defaults to <strong>read_write</strong>.</p> </li><li> <p><strong>{auto_save, </strong><a href="#type-auto_save">type-auto_save</a><strong>}</strong> - The autosave
interval. If the interval is an integer <strong>Time</strong>, the
table is flushed to disk whenever it is not accessed for
<strong>Time</strong> milliseconds. A table that has been flushed
requires no reparation when reopened after an
uncontrolled emulator halt. If the interval is the atom
<strong>infinity</strong>, autosave is disabled. Defaults to
180000 (3 minutes).</p> </li><li> <p><strong>{estimated_no_objects, </strong><a href="#type-no_slots">type-no_slots</a><strong>}</strong> - Equivalent to option
<strong>min_no_slots</strong>.</p> </li><li> <p><strong>{file, </strong><a href="./file#type-name">file#type-name</a><strong>}</strong> - The name of the file to be
opened. Defaults to the table name.</p> </li><li> <p><strong>{max_no_slots, </strong><a href="#type-no_slots">type-no_slots</a><strong>}</strong> - The maximum number
of slots to be used. Defaults to 32 M, which is the
maximal value. Notice that a higher value can
increase the table fragmentation, and
a smaller value can decrease the fragmentation, at
the expense of execution time.</p> </li><li> <p><strong>{min_no_slots, </strong><a href="#type-no_slots">type-no_slots</a><strong>}</strong> - Application
performance can be enhanced with this flag by specifying,
when the table is created, the estimated number of
different keys to be stored in the table. Defaults to 256,
which is the minimum value.</p> </li><li> <p><strong>{keypos, </strong><a href="#type-keypos">type-keypos</a><strong>}</strong> - The position of the
element of each object to be used as key. Defaults to 1.
The ability to explicitly state the key
position is most convenient when we want to store Erlang
records in which the first position of the record is the
name of the record type.</p> </li><li> <p><strong>{ram_file, boolean()}</strong> - Whether the table is to
be kept in RAM. Keeping the table in RAM can sound like an
anomaly, but can enhance the performance of applications
that open a table, insert a set of objects, and then
close the table. When the table is closed, its contents
are written to the disk file. Defaults to <strong>false</strong>.</p> </li><li> <p><strong>{repair, Value}</strong> - <strong>Value</strong> can be either
a <strong>boolean()</strong> or the atom <strong>force</strong>. The flag
specifies if the Dets server is to invoke the
automatic file reparation algorithm. Defaults to
<strong>true</strong>. If <strong>false</strong> is specified, no attempt is
made to repair the file, and <strong>{error, {needs_repair, FileName}}</strong> is returned if the table must be repaired.</p> <p>Value <strong>force</strong> means that a reparation
is made even if the table is properly closed.
This is a seldom needed option.</p> <p>Option <strong>repair</strong> is ignored if the table is already open.</p> </li><li> <p><strong>{type, </strong><a href="#type-type">type-type</a><strong>}</strong> - The table type. Defaults to
<strong>set</strong>.</p> </li></ul><h3>pid2name/1</h3><p>Return the name of the Dets table handled by a pid.</p><p>Returns the table name given the pid of a process
that handles requests to a table, or <strong>undefined</strong> if
there is no such table.</p><p>This function is meant to be used for debugging only.</p><h3>repair_continuation/2</h3><p>Repair a continuation from <strong>select/1</strong> or <strong>select/3</strong>. </p><p>This function can be used to restore an opaque continuation
returned by
<a href="#select/3">select/3</a> or
<a href="#select/1">select/1</a> if the
continuation has passed through external term format (been
sent between nodes or stored on disk).</p><p>The reason for this function is that continuation terms
contain compiled match specifications and therefore are
invalidated if converted to external term format. Given that
the original match specification is kept intact, the
continuation can be restored, meaning it can once again be
used in subsequent <strong>select/1</strong> calls even though it has
been stored on disk or on another node.</p><p>For more information and examples, see the
<a href="ets">ets</a> module.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is rarely needed in application code. It is used by
application Mnesia to provide distributed <strong>select/3</strong>
and <strong>select/1</strong> sequences. A normal application would
either use Mnesia or keep the continuation from being
converted to external format.</p><p>The reason for not having an external representation of
compiled match specifications is performance. It can be
subject to change in future releases, while this interface
remains for backward compatibility.</p></div><h3>safe_fixtable/2</h3><p>Fix a Dets table for safe traversal.</p><p>If <strong><span class="anno">Fix</span></strong> is <strong>true</strong>, table
<strong><span class="anno">Name</span></strong> is
fixed (once more) by the calling process, otherwise the table
is released. The table is also released when a fixing process
terminates.</p><p>If many processes fix a table, the table remains
fixed until all processes have released it or terminated. A
reference counter is kept on a per process basis, and N
consecutive fixes require N releases to release the table.</p><p>It is not guaranteed that calls to <strong>first/1</strong>,
<strong>next/2</strong>, or select and match functions work as expected
even if the table is fixed; the limited support for
concurrency provided by the
<a href="ets">ets</a> module is not yet
provided by Dets.
Fixing a table currently only disables resizing of
the hash list of the table.</p><p>If objects have been added while the table was fixed, the
hash list starts to grow when the table is released, which
significantly slows down access to the table for a period
of time.</p><h3>select/1</h3><p>Apply a match specification to some objects stored in a Dets table.</p><p>Applies a match specification to some objects stored in a
table and returns a non-empty list of the results. The
table, the match specification, and the number of objects
that are matched are all defined by <strong><span class="anno">Continuation</span></strong>,
which is returned by a previous call to
<a href="#select/1">select/1</a> or
<a href="#select/3">select/3</a>.</p><p>When all objects of the table have been matched,
<strong>'$end_of_table'</strong> is returned.</p><h3>select/2</h3><p>Apply a match specification to all objects stored in a Dets table.</p><p>Returns the results of applying match specification
<strong><span class="anno">MatchSpec</span></strong> to all or some objects stored in table
<strong><span class="anno">Name</span></strong>. The order of the objects is not specified.
For a description of match specifications, see the
<a href="./match_spec">ERTS User's Guide</a>.</p><p>If the keypos'th element of <strong><span class="anno">MatchSpec</span></strong> is
unbound, the match specification is applied to all objects of
the table. If the keypos'th element is bound, the match
specification is applied to the objects with the correct key(s)
only.</p><p>Using the <strong>select</strong> functions for traversing all
objects of a table is more efficient than calling
<strong>first/1</strong> and <strong>next/2</strong> or <strong>slot/2</strong>.
</p><h3>select/3</h3><p>Apply a match specification to the first chunk of objects stored in a Dets table.</p><p>Returns the results of applying match specification
<strong><span class="anno">MatchSpec</span></strong> to some or all objects stored in table
<strong><span class="anno">Name</span></strong>. The order of the objects is not specified.
For a description of match specifications, see the
<a href="./match_spec">ERTS User's Guide</a>.</p><p>A tuple of the results of applying the match specification
and a continuation is returned, unless the table is empty,
in which case <strong>'$end_of_table'</strong> is returned. The
continuation is to be used when matching more objects by calling
<a href="#select/1">select/1</a>.</p><p>If the keypos'th element of <strong><span class="anno">MatchSpec</span></strong> is bound,
the  match specification is applied to all objects of the table
with the correct key(s). If the keypos'th element of
<strong><span class="anno">MatchSpec</span></strong> is unbound, the match specification is
applied to all objects of the table, <strong><span class="anno">N</span></strong> objects at
a time, until at least one object matches or the end of the
table is reached. The default, indicated by giving
<strong><span class="anno">N</span></strong> the value <strong>default</strong>, is to let the number
of objects vary depending on the sizes of the objects. All
objects with the
same key are always handled at the same time, which implies that the
match specification can be applied to more than <span class="anno">N</span>
objects.</p><p>The table is always to be protected using
<a href="#safe_fixtable/2">safe_fixtable/2</a>
before calling <strong>select/3</strong>, otherwise
errors can occur when calling <strong>select/1</strong>.</p><h3>select_delete/2</h3><p>Delete all objects that match a given pattern from a Dets table.</p><p>Deletes each object from table <strong><span class="anno">Name</span></strong> such that
applying match specification <strong><span class="anno">MatchSpec</span></strong> to the
object returns value <strong>true</strong>.
For a description of match specifications, see the
<a href="./match_spec">ERTS User's Guide</a>.
Returns the number of deleted objects.</p><p>If the keypos'th element of <strong><span class="anno">MatchSpec</span></strong> is
bound, the match specification is applied to the objects
with the correct key(s) only.</p><h3>slot/2</h3><p>Return the list of objects associated with a slot of a Dets table.</p><p>The objects of a table are distributed among slots,
starting with slot <strong>0</strong> and ending with slot <strong>n</strong>.
Returns the list of objects associated with slot
<strong><span class="anno">I</span></strong>. If <strong><span class="anno">I</span></strong> &gt; <strong>n</strong>,
<strong>'$end_of_table'</strong> is returned.</p><h3>sync/1</h3><p>Ensure that all updates made to a Dets table are written to disk.</p><p>Ensures that all updates made to table <strong><span class="anno">Name</span></strong> are
written to disk. This also applies to tables that have been
opened with flag <strong>ram_file</strong> set to <strong>true</strong>. In
this case, the contents of the RAM file are flushed to disk.</p><p>Notice that the space management data structures kept in RAM,
the buddy system, is also written to the disk. This can take
some time if the table is fragmented.</p><h3>table/1</h3><h3>table/2</h3><p>Return a QLC query handle.</p><p>Returns a Query List
Comprehension (QLC) query handle. The
<a href="qlc">qlc</a> module
provides a query language aimed mainly for Mnesia, but
ETS tables, Dets tables, and lists are also recognized
by <strong>qlc</strong> as sources of data. Calling
<a href="./dets#table/1">dets#table/1</a> is the
means to make Dets table <strong><span class="anno">Name</span></strong> usable to
<strong>qlc</strong>.</p><p>When there are only simple restrictions on the key position,
<strong>qlc</strong> uses
<a href="./dets#lookup/2">dets#lookup/2</a>
to look up the keys. When
that is not possible, the whole table is traversed.
Option <strong>traverse</strong> determines how this is done:</p><ul><li> <p><strong>first_next</strong> - The table is traversed one key at
a time by calling <strong>dets:first/1</strong> and <strong>dets:next/2</strong>.</p> </li><li> <p><strong>select</strong> - The table is traversed by calling
<a href="./dets#select/3">dets#select/3</a> and
<a href="./dets#select/1">dets#select/1</a>.
Option <strong>n_objects</strong> determines the number of objects
returned (the third argument of <strong>select/3</strong>). The
match specification (the second argument of
<strong>select/3</strong>) is assembled by <strong>qlc</strong>:</p> <ul><li> <p>Simple filters are translated into equivalent match
specifications.</p> </li><li> <p>More complicated filters must be applied to all
objects returned by <strong>select/3</strong> given a match
specification that matches all objects.</p> </li></ul> </li><li> <p><strong>{select, </strong><a href="#type-match_spec"> match_spec()</a><strong>}</strong> - As for <strong>select</strong>,
the table is traversed by calling <strong>dets:select/3</strong>
and <strong>dets:select/1</strong>. The difference is that the
match specification is specified explicitly. This is how to
state match specifications that cannot easily be
expressed within the syntax provided by <strong>qlc</strong>.</p> </li></ul><p>The following example uses an explicit match specification
to traverse the table:</p><pre>
1&gt; <span class="input">dets:open_file(t, []),</span>
<span class="input">ok = dets:insert(t, [{1,a},{2,b},{3,c},{4,d}]),</span>
<span class="input">MS = ets:fun2ms(fun({X,Y}) when (X &gt; 1) or (X &lt; 5) -&gt; {Y} end),</span>
<span class="input">QH1 = dets:table(t, [{traverse, {select, MS}}]).</span></pre><p>An example with implicit match specification:</p><pre>
2&gt; <span class="input">QH2 = qlc:q([{Y} || {X,Y} &lt;- dets:table(t), (X &gt; 1) or (X &lt; 5)]).</span></pre><p>The latter example is equivalent to the former, which 
can be verified using function <strong>qlc:info/1</strong>:</p><pre>
3&gt; <span class="input">qlc:info(QH1) =:= qlc:info(QH2).</span>
true</pre><p><strong>qlc:info/1</strong> returns information about a query handle.
In this case identical information is returned for the
two query handles.</p><h3>to_ets/2</h3><p>Insert all objects of a Dets table into an ETS table.</p><p>Inserts the objects of the Dets table <strong><span class="anno">Name</span></strong>
into the ETS table <strong><span class="anno">EtsTab</span></strong>. The order in
which the objects are
inserted is not specified. The existing objects of the ETS
table are kept unless overwritten.</p><h3>traverse/2</h3><p>Apply a function to all or some objects stored in a Dets table.</p><p>Applies <strong><span class="anno">Fun</span></strong> to each object stored in table
<strong><span class="anno">Name</span></strong> in some unspecified order. Different
actions are
taken depending on the return value of <strong><span class="anno">Fun</span></strong>. The
following <strong><span class="anno">Fun</span></strong> return values are allowed:</p><dl><dt><strong>continue</strong></dt><dd> <p>Continue to perform the traversal. For example, the
following function can be used to print the contents
of a table:</p> <pre>
fun(X) -&gt; io:format("~p~n", [X]), continue end.</pre> </dd><dt><strong>{continue, Val}</strong></dt><dd> <p>Continue the traversal and accumulate <strong><span class="anno">Val</span></strong>.
The following function is supplied to collect all
objects of a table in a list:</p> <pre>
fun(X) -&gt; {continue, X} end.</pre> </dd><dt><strong>{done, <span class="anno">Value</span>}</strong></dt><dd> <p>Terminate the traversal and return
<strong>[<span class="anno">Value</span> | Acc]</strong>.</p> </dd></dl><p>Any other value <strong><span class="anno">OtherValue</span></strong> returned by
<strong><span class="anno">Fun</span></strong> terminates the
traversal and is returned immediately.</p><h3>update_counter/3</h3><p>Update a counter object stored in a Dets table. </p><p>Updates the object with key <strong><span class="anno">Key</span></strong> stored in
table <strong><span class="anno">Name</span></strong> of type <strong>set</strong> by adding
<strong><span class="anno">Incr</span></strong> to the
element at the <strong><span class="anno">Pos</span></strong>:th position.
The new counter value
is returned. If no position is specified, the element directly
following the key is updated.</p><p>This functions provides a way of updating a counter,
without having to look up an object, update the object by
incrementing an element, and insert the resulting object into
the table again.</p><h3>See Also</h3><p><a href="ets">ets</a>,
<a href="./mnesia">mnesia/mnesia</a>,
<a href="qlc">qlc</a></p><h2>dict</h2><p>Key-value dictionary.</p><p>This module provides a <strong>Key</strong>-<strong>Value</strong> dictionary.
The representation of a dictionary is not defined.This module provides the same interface as the
<a href="orddict">orddict</a> module.
One difference is that while this module
considers two keys as different if they do not match (<strong>=:=</strong>),
<strong>orddict</strong> considers two keys as different if and only if
they do not compare equal (<strong>==</strong>).</p><h2>Data Types</h2><span class="name">dict</span><p>Dictionary as returned by
<a href="#new/0">new/0</a>.</p><span class="name">dict</span><h2>Functions</h2><h3>append/3</h3><p>Append a value to keys in a dictionary.</p><p>Appends a new <strong><span class="anno">Value</span></strong> to the current list
of values associated with <strong><span class="anno">Key</span></strong>.</p><p>See also section <a href="#notes">Notes</a>.</p><h3>append_list/3</h3><p>Append new values to keys in a dictionary.</p><p>Appends a list of values <strong><span class="anno">ValList</span></strong> to
the current list of values associated with <strong><span class="anno">Key</span></strong>. An
exception is generated if the initial value associated with
<strong><span class="anno">Key</span></strong> is not a list of values.</p><p>See also section <a href="#notes">Notes</a>.</p><h3>erase/2</h3><p>Erase a key from a dictionary.</p><p>Erases all items with a given key from a dictionary.</p><h3>fetch/2</h3><p>Look up values in a dictionary.</p><p>Returns the value associated with <strong><span class="anno">Key</span></strong>
in dictionary <strong><span class="anno">Dict</span></strong>. This function assumes that
<strong><span class="anno">Key</span></strong> is present in dictionary <strong>Dict</strong>,
and an exception
is generated if <strong><span class="anno">Key</span></strong> is not in the dictionary.</p><p>See also section <a href="#notes">Notes</a>.</p><h3>fetch_keys/1</h3><p>Return all keys in a dictionary.</p><p>Returns a list of all keys in dictionary <strong>Dict</strong>.</p><h3>take/2</h3><p>Return value and new dictionary without element with this value.</p><p>This function returns value from dictionary and a
new dictionary without this value.
Returns <strong>error</strong> if the key is not present in the dictionary.</p><h3>filter/2</h3><p>Select elements that satisfy a predicate.</p><p><strong><span class="anno">Dict2</span></strong> is a dictionary of all keys and values in
<strong><span class="anno">Dict1</span></strong> for which
<strong><span class="anno">Pred</span>(<span class="anno">Key</span>, <span class="anno">Value</span>)</strong> is
<strong>true</strong>.</p><h3>find/2</h3><p>Search for a key in a dictionary.</p><p>Searches for a key in dictionary <strong>Dict</strong>. Returns
<strong>{ok, <span class="anno">Value</span>}</strong>, where <strong><span class="anno">Value</span></strong> is
the value associated with <strong><span class="anno">Key</span></strong>, or <strong>error</strong>
if the key is not present in the dictionary.</p><p>See also section <a href="#notes">Notes</a>.</p><h3>fold/3</h3><p>Fold a function over a dictionary.</p><p>Calls <strong><span class="anno">Fun</span></strong> on successive keys and values of
dictionary <strong><span class="anno">Dict</span></strong> together with an extra argument
<strong>Acc</strong>
(short for accumulator). <strong><span class="anno">Fun</span></strong> must return a new
accumulator that is passed to the next call. <strong><span class="anno">Acc0</span></strong>
is returned if the dictionary is empty. The evaluation order is
undefined.</p><h3>from_list/1</h3><p>Convert a list of pairs to a dictionary.</p><p>Converts the <strong><span class="anno">Key</span></strong>-<strong><span class="anno">Value</span></strong> list
<strong><span class="anno">List</span></strong> to dictionary <strong>Dict</strong>.</p><h3>is_empty/1</h3><p>Return <strong>true</strong> if the dictionary is empty.</p><p>Returns <strong>true</strong> if dictionary <strong><span class="anno">Dict</span></strong> has no
elements, otherwise <strong>false</strong>.</p><h3>is_key/2</h3><p>Test if a key is in a dictionary.</p><p>Tests if <strong><span class="anno">Key</span></strong> is contained in
dictionary <strong><span class="anno">Dict</span></strong>.</p><h3>map/2</h3><p>Map a function over a dictionary.</p><p>Calls <strong><span class="anno">Fun</span></strong> on successive keys and values
of dictionary <strong><span class="anno">Dict1</span></strong> to return a new value for
each key. The evaluation order is undefined.</p><h3>merge/3</h3><p>Merge two dictionaries.</p><p>Merges two dictionaries, <strong><span class="anno">Dict1</span></strong> and
<strong><span class="anno">Dict2</span></strong>, to create a new dictionary.  All the
<strong><span class="anno">Key</span></strong>-<strong><span class="anno">Value</span></strong> pairs from both
dictionaries are included in the new dictionary. If a key occurs
in both dictionaries, <strong><span class="anno">Fun</span></strong> is called with the
key and both values to return a new value.
<strong>merge</strong> can be defined as follows, but is faster:</p><pre><code class="">
merge(Fun, D1, D2) -&gt;
    fold(fun (K, V1, D) -&gt;
                 update(K, fun (V2) -&gt; Fun(K, V1, V2) end, V1, D)
         end, D2, D1).</code></pre><h3>new/0</h3><p>Create a dictionary.</p><p>Creates a new dictionary.</p><h3>size/1</h3><p>Return the number of elements in a dictionary.</p><p>Returns the number of elements in dictionary
<strong><span class="anno">Dict</span></strong>.</p><h3>store/3</h3><p>Store a value in a dictionary.</p><p>Stores a <strong><span class="anno">Key</span></strong>-<strong><span class="anno">Value</span></strong> pair in
dictionary <strong>Dict2</strong>. If <strong><span class="anno">Key</span></strong> already exists in
<strong><span class="anno">Dict1</span></strong>,
the associated value is replaced by <strong><span class="anno">Value</span></strong>.</p><h3>to_list/1</h3><p>Convert a dictionary to a list of pairs.</p><p>Converts dictionary <strong>Dict</strong> to a list representation.</p><h3>update/3</h3><p>Update a value in a dictionary.</p><p>Updates a value in a dictionary by calling <strong><span class="anno">Fun</span></strong> on
the value to get a new value. An exception is generated if
<strong><span class="anno">Key</span></strong> is not present in the dictionary.</p><h3>update/4</h3><p>Update a value in a dictionary.</p><p>Updates a value in a dictionary by calling <strong><span class="anno">Fun</span></strong> on
the value to get a new value. If <strong><span class="anno">Key</span></strong> is not
present in the dictionary, <strong><span class="anno">Initial</span></strong> is stored as
the first value. For example, <strong>append/3</strong> can be defined as:</p><pre><code class="">
append(Key, Val, D) -&gt;
    update(Key, fun (Old) -&gt; Old ++ [Val] end, [Val], D).</code></pre><h3>update_counter/3</h3><p>Increment a value in a dictionary.</p><p>Adds <strong><span class="anno">Increment</span></strong> to the value associated with
<strong><span class="anno">Key</span></strong> and stores this value.
If <strong><span class="anno">Key</span></strong> is not present in the dictionary,
<strong><span class="anno">Increment</span></strong> is stored as the first value.</p><p>This can be defined as follows, but is faster:</p><pre><code class="">
update_counter(Key, Incr, D) -&gt;
    update(Key, fun (Old) -&gt; Old + Incr end, Incr, D).</code></pre><h3>Notes</h3><a name="notes"></a><p>Functions <strong>append</strong> and <strong>append_list</strong> are included
so that keyed values can be stored in a list <em>accumulator</em>, for
example:</p><pre>
&gt; D0 = dict:new(),
  D1 = dict:store(files, [], D0),
  D2 = dict:append(files, f1, D1),
  D3 = dict:append(files, f2, D2),
  D4 = dict:append(files, f3, D3),
  dict:fetch(files, D4).
[f1,f2,f3]</pre><p>This saves the trouble of first fetching a keyed value,
appending a new value to the list of stored values, and storing
the result.</p><p>Function <strong>fetch</strong> is to be used if the key is known to
be in the dictionary, otherwise function <strong>find</strong>.</p><h3>See Also</h3><p><a href="gb_trees">gb_trees</a>, 
<a href="orddict">orddict</a></p><h2>digraph</h2><p>Directed graphs.</p><p>This module provides a version of labeled
directed graphs. What makes the graphs provided here
non-proper directed graphs is that multiple edges between
vertices are allowed. However, the customary definition of
directed graphs is used here.<ul><li> <p>A <a name="digraph"></a><em>directed graph</em> (or just
"digraph") is a pair (V,E) of a finite set V of
<a name="vertex"></a><em>vertices</em> and a finite set E of
<a name="edge"></a><em>directed edges</em> (or just "edges").
The set of edges E is a subset of VV (the
Cartesian product of V with itself).</p> <p>In this module, V is allowed to be empty. The so obtained unique
digraph is called the
<a name="empty_digraph"></a><em>empty digraph</em>. Both
vertices and edges are represented by unique Erlang terms.</p> </li><li> <p>Digraphs can be annotated with more information. Such information
can be attached to the vertices and to the edges of the digraph. An
annotated digraph is called a <em>labeled digraph</em>, and the
information attached to a vertex or an edge is called a
<a name="label"></a><em>label</em>. Labels are Erlang
terms.</p> </li><li> <p>An edge e=(v,w) is said to
<a name="emanate"></a><em>emanate</em> from vertex v and to
be <a name="incident"></a><em>incident</em> on vertex w.</p> </li><li> <p>The <a name="out_degree"></a><em>out-degree</em> of a vertex
is the number of edges emanating from that vertex.</p> </li><li> <p>The <a name="in_degree"></a><em>in-degree</em> of a vertex 
is the number of edges incident on that vertex.</p> </li><li> <p>If an edge is emanating from v and incident on w, then w is
said to be an <a name="out_neighbour"></a>
<em>out-neighbor</em> of v, and v is said to be an
<a name="in_neighbour"></a><em>in-neighbor</em> of w.</p> </li><li> <p>A <a name="path"></a><em>path</em> P from v[1] to v[k]
in a digraph (V,E) is a non-empty sequence
v[1],v[2],...,v[k] of vertices in V such that
there is an edge (v[i],v[i+1]) in E for
1&lt;=i&lt;k.</p> </li><li> <p>The <a name="length"></a><em>length</em> of path P is
k-1.</p> </li><li> <p>Path P is <a name="simple_path"></a><em>simple</em> if all
vertices are distinct, except that the first and the last vertices
can be the same.</p> </li><li> <p>Path P is a <a name="cycle"></a><em>cycle</em> if the
length of P is not zero and v[1] = v[k].</p> </li><li> <p>A <a name="loop"></a><em>loop</em> is a cycle of length
one.</p> </li><li> <p>A <a name="simple_cycle"></a><em>simple cycle</em> is a path
that is both a cycle and simple.</p> </li><li> <p>An <a name="acyclic_digraph"></a><em>acyclic digraph</em>
is a digraph without cycles.</p> </li></ul></p><h2>Data Types</h2><span class="name">d_type</span><span class="name">d_cyclicity</span><span class="name">d_protection</span><span class="name">graph</span><p>A digraph as returned by
<a href="#new/0">new/0</a>.</p><span class="name">edge()</span><span class="name">label</span><span class="name">vertex()</span><h2>Functions</h2><h3>add_edge/3</h3><h3>add_edge/4</h3><h3>add_edge/5</h3><p>Add an edge to a digraph.</p><ul><li>add_edge_err_rsn</li></ul><p><strong>add_edge/5</strong> creates (or modifies) edge <strong><span class="anno">E</span></strong>
of digraph <strong><span class="anno">G</span></strong>, using <strong><span class="anno">Label</span></strong> as
the (new) <a href="#label">label</a> of the edge. The
edge is <a href="#emanate">emanating</a> from
<strong><span class="anno">V1</span></strong> and
<a href="#incident">incident</a>
on <strong><span class="anno">V2</span></strong>. Returns <strong><span class="anno">E</span></strong>.</p><p><strong>add_edge(<span class="anno">G</span>,<span class="anno">V1</span>,<span class="anno">V2</span>,<span class="anno">Label</span>)</strong>
is equivalent to
<strong>add_edge(<span class="anno">G</span>,<span class="anno">E</span>,<span class="anno">V1</span>,<span class="anno">V2</span>,<span class="anno">Label</span>)</strong>,
where <strong><span class="anno">E</span></strong> is a created edge. The created edge is
represented by term <strong>['$e'|N]</strong>, where <strong>N</strong>
is an integer&gt;=0.</p><p><strong>add_edge(<span class="anno">G</span>,<span class="anno">V1</span>,<span class="anno">V2</span>)</strong>
is equivalent to
<strong>add_edge(<span class="anno">G</span>,<span class="anno">V1</span>,<span class="anno">V2</span>,[])</strong>.
</p><p>If the edge would create a cycle in
an <a href="#acyclic_digraph">acyclic digraph</a>,
<strong>{error,{bad_edge,<span class="anno">Path</span>}}</strong> is returned.
If <strong><span class="anno">G</span></strong> already has an edge with value
<strong><span class="anno">E</span></strong> connecting a different pair of vertices,
<strong>{error,{bad_edge,[<span class="anno">V1</span>,<span class="anno">V2</span>]}}</strong>
is returned.
If either of <strong><span class="anno">V1</span></strong> or <strong><span class="anno">V2</span></strong> is not
a vertex of digraph <strong><span class="anno">G</span></strong>,
<strong>{error,{bad_vertex,</strong><span class="anno">V</span><strong>}}</strong> is
returned, <span class="anno">V</span>=<strong><span class="anno">V1</span></strong> or
<span class="anno">V</span>=<strong><span class="anno">V2</span></strong>.</p><h3>add_vertex/1</h3><h3>add_vertex/2</h3><h3>add_vertex/3</h3><p>Add or modify a vertex of a digraph.</p><p><strong>add_vertex/3</strong> creates (or modifies) vertex
<strong><span class="anno">V</span></strong> of digraph <strong><span class="anno">G</span></strong>, using
<strong><span class="anno">Label</span></strong> as the (new)
<a href="#label">label</a> of the
vertex. Returns <strong><span class="anno">V</span></strong>.</p><p><strong>add_vertex(<span class="anno">G</span>,<span class="anno">V</span>)</strong> is equivalent
to <strong>add_vertex(<span class="anno">G</span>,<span class="anno">V</span>,[])</strong>.
</p><p><strong>add_vertex/1</strong> creates a vertex using the empty list
as label, and returns the created vertex. The created vertex
is represented by term <strong>['$v'|N]</strong>,
where <strong>N</strong> is an integer&gt;=0.</p><h3>del_edge/2</h3><p>Delete an edge from a digraph.</p><p>Deletes edge <strong><span class="anno">E</span></strong> from digraph
<strong><span class="anno">G</span></strong>.</p><h3>del_edges/2</h3><p>Delete edges from a digraph.</p><p>Deletes the edges in list <strong><span class="anno">Edges</span></strong> from digraph
<strong><span class="anno">G</span></strong>.</p><h3>del_path/3</h3><p>Delete paths from a digraph.</p><p>Deletes edges from digraph <strong><span class="anno">G</span></strong> until there are no
<a href="#path">paths</a> from vertex
<strong><span class="anno">V1</span></strong> to vertex <strong><span class="anno">V2</span></strong>.</p><p>A sketch of the procedure employed:</p><ul><li> <p>Find an arbitrary
<a href="#simple_path">simple path</a>
v[1],v[2],...,v[k] from <strong><span class="anno">V1</span></strong>
to <strong><span class="anno">V2</span></strong> in <strong><span class="anno">G</span></strong>.</p> </li><li> <p>Remove all edges of <strong><span class="anno">G</span></strong>
<a href="#emanate">emanating</a> from v[i] and
<a href="#incident">incident</a> to v[i+1] for
1&lt;=i&lt;k (including multiple
edges).</p> </li><li> <p>Repeat until there is no path between <strong><span class="anno">V1</span></strong>
and <strong><span class="anno">V2</span></strong>.</p> </li></ul><h3>del_vertex/2</h3><p>Delete a vertex from a digraph.</p><p>Deletes vertex <strong><span class="anno">V</span></strong> from digraph
<strong><span class="anno">G</span></strong>. Any edges
<a href="#emanate">emanating</a> from
<strong><span class="anno">V</span></strong> or
<a href="#incident">incident</a>
on <strong><span class="anno">V</span></strong> are also deleted.</p><h3>del_vertices/2</h3><p>Delete vertices from a digraph.</p><p>Deletes the vertices in list <strong><span class="anno">Vertices</span></strong> from
digraph <strong><span class="anno">G</span></strong>.</p><h3>delete/1</h3><p>Delete a digraph.</p><p>Deletes digraph <strong><span class="anno">G</span></strong>. This call is important
as digraphs are implemented with ETS. There is
no garbage collection of ETS tables. However, the digraph
is deleted if the process that created the digraph terminates.</p><h3>edge/2</h3><p>Return the vertices and the label of an edge of a digraph. </p><p>Returns
<strong>{<span class="anno">E</span>,<span class="anno">V1</span>,<span class="anno">V2</span>,<span class="anno">Label</span>}</strong>,
where <strong><span class="anno">Label</span></strong> is the
<a href="#label">label</a> of edge
<strong><span class="anno">E</span></strong> <a href="#emanate">emanating</a>
from <strong><span class="anno">V1</span></strong> and
<a href="#incident">incident</a> on
<strong><span class="anno">V2</span></strong> of digraph <strong><span class="anno">G</span></strong>.
If no edge <strong><span class="anno">E</span></strong> of
digraph <strong><span class="anno">G</span></strong> exists, <strong>false</strong> is returned.</p><h3>edges/1</h3><p>Return all edges of a digraph.</p><p>Returns a list of all edges of digraph <strong><span class="anno">G</span></strong>, in
some unspecified order.</p><h3>edges/2</h3><p>Return the edges emanating from or incident on a vertex of a digraph.</p><p>Returns a list of all
edges <a href="#emanate">emanating</a> from or 
<a href="#incident">incident</a> on<strong><span class="anno">V</span></strong>
of digraph <strong><span class="anno">G</span></strong>, in some unspecified order.</p><h3>get_cycle/2</h3><p>Find one cycle in a digraph.</p><p>If a <a href="#simple_cycle">simple cycle</a> of
length two or more exists through vertex <strong><span class="anno">V</span></strong>, the
cycle is returned as a list
<strong>[<span class="anno">V</span>,...,<span class="anno">V</span>]</strong> of vertices.
If a <a href="#loop">loop</a> through
<strong><span class="anno">V</span></strong> exists, the loop is returned as a list
<strong>[<span class="anno">V</span>]</strong>. If no cycles through
<strong><span class="anno">V</span></strong> exist, <strong>false</strong> is returned.</p><p><a href="#get_path/3">get_path/3</a> is used
for finding a simple cycle through <strong><span class="anno">V</span></strong>.</p><h3>get_path/3</h3><p>Find one path in a digraph.</p><p>Tries to find
a <a href="#simple_path">simple path</a> from vertex 
<strong><span class="anno">V1</span></strong> to vertex <strong><span class="anno">V2</span></strong> of digraph
<strong><span class="anno">G</span></strong>. Returns the path as a list
<strong>[<span class="anno">V1</span>,...,<span class="anno">V2</span>]</strong> of vertices,
or <strong>false</strong> if no simple path from <strong><span class="anno">V1</span></strong> to
<strong><span class="anno">V2</span></strong> of length one or more exists.</p><p>Digraph <strong><span class="anno">G</span></strong> is traversed in a depth-first manner,
and the first found path is returned.</p><h3>get_short_cycle/2</h3><p>Find one short cycle in a digraph.</p><p>Tries to find an as short as possible
<a href="#simple_cycle">simple cycle</a> through
vertex <strong><span class="anno">V</span></strong> of digraph <strong>G</strong>. Returns the cycle
as a list <strong>[<span class="anno">V</span>,...,<span class="anno">V</span>]</strong>
of vertices, or
<strong>false</strong> if no simple cycle through <strong><span class="anno">V</span></strong> exists.
Notice that a <a href="#loop">loop</a> through
<strong><span class="anno">V</span></strong> is returned as list
<strong>[<span class="anno">V</span>,<span class="anno">V</span>]</strong>.</p><p><a href="#get_short_path/3">get_short_path/3</a>
is used for finding a simple cycle through <strong><span class="anno">V</span></strong>.</p><h3>get_short_path/3</h3><p>Find one short path in a digraph.</p><p>Tries to find an as short as possible
<a href="#simple_path">simple path</a> from vertex
<strong><span class="anno">V1</span></strong> to vertex <strong><span class="anno">V2</span></strong> of digraph
<strong><span class="anno">G</span></strong>. Returns the path as a list
<strong>[<span class="anno">V1</span>,...,<span class="anno">V2</span>]</strong> of
vertices, or <strong>false</strong> if no simple path from
<strong><span class="anno">V1</span></strong>
to <strong><span class="anno">V2</span></strong> of length one or more exists.</p><p>Digraph <strong><span class="anno">G</span></strong> is traversed in a breadth-first
manner, and the first found path is returned.</p><h3>in_degree/2</h3><p>Return the in-degree of a vertex of a digraph.</p><p>Returns the <a href="#in_degree">in-degree</a> of
vertex <strong><span class="anno">V</span></strong> of digraph <strong><span class="anno">G</span></strong>.</p><h3>in_edges/2</h3><p>Return all edges incident on a vertex of a digraph.</p><p>Returns a list of all
edges <a href="#incident">incident</a> on
<strong><span class="anno">V</span></strong> of digraph <strong><span class="anno">G</span></strong>,
in some unspecified order.</p><h3>in_neighbours/2</h3><p>Return all in-neighbors of a vertex of  a digraph.</p><p>Returns a list of
all <a href="#in_neighbour">in-neighbors</a> of 
<strong><span class="anno">V</span></strong> of digraph <strong><span class="anno">G</span></strong>,
in some unspecified order.</p><h3>info/1</h3><p>Return information about a digraph.</p><ul><li>d_cyclicity</li></ul><ul><li>d_protection</li></ul><p>Returns a list of <strong>{Tag, Value}</strong> pairs describing
digraph <strong><span class="anno">G</span></strong>. The following pairs are returned:</p><ul><li> <p><strong>{cyclicity, <span class="anno">Cyclicity</span>}</strong>, where
<strong><span class="anno">Cyclicity</span></strong>
is <strong>cyclic</strong> or <strong>acyclic</strong>, according to the
options given to <strong>new</strong>.</p> </li><li> <p><strong>{memory, <span class="anno">NoWords</span>}</strong>, where
<strong><span class="anno">NoWords</span></strong> is
the number of words allocated to the ETS tables.</p> </li><li> <p><strong>{protection, <span class="anno">Protection</span>}</strong>, where
<strong><span class="anno">Protection</span></strong>
is <strong>protected</strong> or <strong>private</strong>, according
to the options given to <strong>new</strong>.</p> </li></ul><h3>new/0</h3><p>Return a protected empty digraph, where cycles are allowed. </p><p>Equivalent to <strong>new([])</strong>.</p><h3>new/1</h3><p>Create a new empty digraph.</p><ul><li>Type</li></ul><ul><li>d_type</li></ul><ul><li>d_cyclicity</li></ul><ul><li>d_protection</li></ul><p>Returns
an <a href="#empty_digraph">empty digraph</a> with 
properties according to the options in <strong><span class="anno">Type</span></strong>:</p><dl><dt><strong>cyclic</strong></dt><dd><p>Allows <a href="#cycle">cycles</a> in the
digraph (default).</p></dd><dt><strong>acyclic</strong></dt><dd><p>The digraph is to be kept
<a href="#acyclic_digraph">acyclic</a>.</p></dd><dt><strong>protected</strong></dt><dd><p>Other processes can read the digraph (default).</p></dd><dt><strong>private</strong></dt><dd><p>The digraph can be read and modified by the creating
process only.</p></dd></dl><p>If an unrecognized type option <strong>T</strong> is specified or
<strong><span class="anno">Type</span></strong>
is not a proper list, a <strong>badarg</strong> exception is raised.</p><h3>no_edges/1</h3><p>Return the number of edges of a digraph.</p><p>Returns the number of edges of digraph <strong><span class="anno">G</span></strong>.</p><h3>no_vertices/1</h3><p>Return the number of vertices of a digraph.</p><p>Returns the number of vertices of digraph <strong><span class="anno">G</span></strong>.</p><h3>out_degree/2</h3><p>Return the out-degree of a vertex of a digraph.</p><p>Returns the <a href="#out_degree">out-degree</a> of
vertex <strong><span class="anno">V</span></strong> of digraph <strong><span class="anno">G</span></strong>.</p><h3>out_edges/2</h3><p>Return all edges emanating from a vertex of a digraph. </p><p>Returns a list of all
edges <a href="#emanate">emanating</a> from
<strong><span class="anno">V</span></strong> of digraph <strong><span class="anno">G</span></strong>,
in some unspecified order.</p><h3>out_neighbours/2</h3><p>Return all out-neighbors of a vertex of a digraph.</p><p>Returns a list of 
all <a href="#out_neighbour">out-neighbors</a> of 
<strong><span class="anno">V</span></strong> of digraph <strong><span class="anno">G</span></strong>,
in some unspecified order.</p><h3>vertex/2</h3><p>Return the label of a vertex of a digraph.</p><p>Returns <strong>{<span class="anno">V</span>,<span class="anno">Label</span>}</strong>,
where <strong><span class="anno">Label</span></strong> is the
<a href="#label">label</a> of the vertex
<strong><span class="anno">V</span></strong> of digraph <strong><span class="anno">G</span></strong>,
or <strong>false</strong> if no vertex <strong><span class="anno">V</span></strong>
of digraph <strong><span class="anno">G</span></strong> exists.</p><h3>vertices/1</h3><p>Return all vertices of a digraph.</p><p>Returns a list of all vertices of digraph <strong><span class="anno">G</span></strong>, in
some unspecified order.</p><h3>See Also</h3><p><a href="digraph_utils">digraph_utils</a>,
<a href="ets">ets</a></p><h2>digraph_utils</h2><p>Algorithms for directed graphs.</p><p>This module provides algorithms based on depth-first traversal of
directed graphs. For basic functions on directed graphs, see the
<a href="digraph">digraph</a> module.<ul><li> <p>A <a name="digraph"></a><em>directed graph</em> (or just
"digraph") is a pair (V,E) of a finite set V of
<a name="vertex"></a><em>vertices</em> and a finite set E of
<a name="edge"></a><em>directed edges</em> (or just "edges").
The set of edges E is a subset of VV (the
Cartesian product of V with itself).</p> </li><li> <p>Digraphs can be annotated with more information. Such information
can be attached to the vertices and to the edges of the digraph. An
annotated digraph is called a <em>labeled digraph</em>, and the
information attached to a vertex or an edge is called a
<a name="label"></a><em>label</em>.</p> </li><li> <p>An edge e=(v,w) is said to
<a name="emanate"></a><em>emanate</em> from vertex v and to
be <a name="incident"></a><em>incident</em> on vertex w.</p> </li><li> <p>If an edge is emanating from v and incident on w, then w is
said to be an <a name="out_neighbour"></a>
<em>out-neighbor</em> of v, and v is said to be an
<a name="in_neighbour"></a><em>in-neighbor</em> of w.</p> </li><li> <p>A <a name="path"></a><em>path</em> P from v[1] to v[k]
in a digraph (V,E) is a non-empty sequence
v[1],v[2],...,v[k] of vertices in V such that
there is an edge (v[i],v[i+1]) in E for
1&lt;=i&lt;k.</p> </li><li> <p>The <a name="length"></a><em>length</em> of path P is
k-1.</p> </li><li> <p>Path P is a <a name="cycle"></a><em>cycle</em> if the
length of P is not zero and v[1] = v[k].</p> </li><li> <p>A <a name="loop"></a><em>loop</em> is a cycle of length
one.</p> </li><li> <p>An <a name="acyclic_digraph"></a><em>acyclic digraph</em>
is a digraph without cycles.</p> </li><li> <p>A <a name="depth_first_traversal"></a><em>depth-first traversal</em> of a directed digraph can be viewed as a process
that visits all vertices of the digraph. Initially, all vertices
are marked as unvisited. The traversal starts with an
arbitrarily chosen vertex, which is marked as visited, and
follows an edge to an unmarked vertex, marking that vertex. The
search then proceeds from that vertex in the same fashion, until
there is no edge leading to an unvisited vertex. At that point
the process backtracks, and the traversal continues as long as
there are unexamined edges. If unvisited vertices remain
when all edges from the first vertex have been examined, some
so far unvisited vertex is chosen, and the process is repeated.</p> </li><li> <p>A <a name="partial_ordering"></a><em>partial ordering</em>
of a set S is a transitive, antisymmetric, and reflexive relation
between the objects of S.</p> </li><li> <p>The problem of
<a name="topsort"></a><em>topological sorting</em> is to find
a total ordering of S that is a superset of the partial ordering. A
digraph G=(V,E) is equivalent to a relation E
on V (we neglect that the version of directed graphs
provided by the <strong>digraph</strong> module allows multiple edges
between vertices). If the digraph has no cycles of length two or
more, the reflexive and transitive closure of E is a
partial ordering.</p> </li><li> <p>A <a name="subgraph"></a><em>subgraph</em> G' of G is a
digraph whose vertices and edges form subsets of the vertices
and edges of G.</p> </li><li> <p>G' is <em>maximal</em> with respect to a property P if all other
subgraphs that include the vertices of G' do not have property P.</p> </li><li> <p>A <a name="strong_components"></a><em>strongly connected component</em> is a maximal subgraph such that there is a path
between each pair of vertices.</p> </li><li> <p>A <a name="components"></a><em>connected component</em>
is a maximal subgraph such that there is a path between each pair of
vertices, considering all edges undirected.</p> </li><li> <p>An <a name="arborescence"></a><em>arborescence</em> is an
acyclic digraph with a vertex V, the
<a name="root"></a><em>root</em>, such that there is a unique
path from V to every other vertex of G.</p> </li><li> <p>A <a name="tree"></a><em>tree</em> is an acyclic non-empty
digraph such that there is a unique path between every pair of
vertices, considering all edges undirected.</p> </li></ul></p><h2>Functions</h2><h3>arborescence_root/1</h3><p>Check if a digraph is an arborescence.</p><p>Returns <strong>{yes, <span class="anno">Root</span>}</strong> if <strong><span class="anno">Root</span></strong>
is the <a href="#root">root</a> of the arborescence
<strong><span class="anno">Digraph</span></strong>, otherwise <strong>no</strong>.</p><h3>components/1</h3><p>Return the components of a digraph.</p><p>Returns a list
of <a href="#components">connected components.</a>.
Each component is represented by its
vertices. The order of the vertices and the order of the
components are arbitrary. Each vertex of digraph
<strong><span class="anno">Digraph</span></strong> occurs in exactly one component.</p><h3>condensation/1</h3><p>Return a condensed graph of a digraph.</p><p>Creates a digraph where the vertices are
the <a href="#strong_components">strongly connected components</a> of <strong><span class="anno">Digraph</span></strong> as returned by
<a href="#strong_components/1">strong_components/1</a>.
If X and Y are two different strongly
connected components, and vertices x and y exist in X
and Y, respectively, such that there is an
edge <a href="#emanate">emanating</a> from x
and <a href="#incident">incident</a> on y, then 
an edge emanating from X and incident on Y is created.</p><p>The created digraph has the same type as <strong><span class="anno">Digraph</span></strong>.
All vertices and edges have the
default <a href="#label">label</a> <strong>[]</strong>.</p><p>Each <a href="#cycle">cycle</a> is
included in some strongly connected component, which implies that
a <a href="#topsort">topological ordering</a> of the
created digraph always exists.</p><h3>cyclic_strong_components/1</h3><p>Return the cyclic strong components of a digraph.</p><p>Returns a list of <a href="#strong_components">strongly connected components</a>. Each strongly component is represented
by its vertices. The order of the vertices and the order of
the components are arbitrary. Only vertices that are
included in some <a href="#cycle">cycle</a> in
<strong><span class="anno">Digraph</span></strong> are returned, otherwise the returned
list is equal to that returned by
<a href="#strong_components/1">strong_components/1</a>.</p><h3>is_acyclic/1</h3><p>Check if a digraph is acyclic.</p><p>Returns <strong>true</strong> if and only if digraph
<strong><span class="anno">Digraph</span></strong> is
<a href="#acyclic_digraph">acyclic</a>.</p><h3>is_arborescence/1</h3><p>Check if a digraph is an arborescence.</p><p>Returns <strong>true</strong> if and only if digraph
<strong><span class="anno">Digraph</span></strong> is
an <a href="#arborescence">arborescence</a>.</p><h3>is_tree/1</h3><p>Check if a digraph is a tree.</p><p>Returns <strong>true</strong> if and only if digraph
<strong><span class="anno">Digraph</span></strong> is
a <a href="#tree">tree</a>.</p><h3>loop_vertices/1</h3><p>Return the vertices of a digraph included in some loop. </p><p>Returns a list of all vertices of <strong><span class="anno">Digraph</span></strong> that
are included in some <a href="#loop">loop</a>.</p><h3>postorder/1</h3><p>Return the vertices of a digraph in postorder.</p><p>Returns all vertices of digraph <strong><span class="anno">Digraph</span></strong>.
The order is given by
a <a href="#depth_first_traversal">depth-first traversal</a> of the digraph, collecting visited
vertices in postorder. More precisely, the vertices visited
while searching from an arbitrarily chosen vertex are
collected in postorder, and all those collected vertices are
placed before the subsequently visited vertices.</p><h3>preorder/1</h3><p>Return the vertices of a digraph in preorder.</p><p>Returns all vertices of digraph <strong><span class="anno">Digraph</span></strong>.
The order is given by
a <a href="#depth_first_traversal">depth-first traversal</a> of the digraph, collecting visited
vertices in preorder.</p><h3>reachable/2</h3><p>Return the vertices reachable from some vertices of a digraph. </p><p>Returns an unsorted list of digraph vertices such that for
each vertex in the list, there is a
<a href="#path">path</a> in <strong><span class="anno">Digraph</span></strong>
from some
vertex of <strong><span class="anno">Vertices</span></strong> to the vertex. In particular,
as paths can have length zero, the vertices of
<strong><span class="anno">Vertices</span></strong> are included in the returned list.</p><h3>reachable_neighbours/2</h3><p>Return the neighbors reachable from some vertices of a digraph.</p><p>Returns an unsorted list of digraph vertices such that for
each vertex in the list, there is a
<a href="#path">path</a> in <strong><span class="anno">Digraph</span></strong>
of length
one or more from some vertex of <strong><span class="anno">Vertices</span></strong> to the
vertex. As a consequence, only those vertices
of <strong><span class="anno">Vertices</span></strong> that are included in
some <a href="#cycle">cycle</a> are returned.</p><h3>reaching/2</h3><p>Return the vertices that reach some vertices of a digraph. </p><p>Returns an unsorted list of digraph vertices such that for
each vertex in the list, there is
a <a href="#path">path</a> from the vertex to some
vertex of <strong><span class="anno">Vertices</span></strong>. In particular, as paths
can have length zero, the vertices of <strong><span class="anno">Vertices</span></strong>
are included in the returned list.</p><h3>reaching_neighbours/2</h3><p>Return the neighbors that reach some vertices of a digraph. </p><p>Returns an unsorted list of digraph vertices such that for
each vertex in the list, there is
a <a href="#path">path</a> of length one or more
from the vertex to some vertex of <strong><span class="anno">Vertices</span></strong>.
Therefore only those vertices of <strong><span class="anno">Vertices</span></strong>
that are included
in some <a href="#cycle">cycle</a> are returned.</p><h3>strong_components/1</h3><p>Return the strong components of a digraph.</p><p>Returns a list of <a href="#strong_components">strongly connected components</a>.
Each strongly component is represented
by its vertices. The order of the vertices and the order of
the components are arbitrary. Each vertex of digraph
<strong><span class="anno">Digraph</span></strong> occurs in exactly one strong component.
</p><h3>subgraph/2</h3><h3>subgraph/3</h3><p>Return a subgraph of a digraph.</p><p>Creates a maximal <a href="#subgraph">subgraph</a>
of <strong>Digraph</strong> having
as vertices those vertices of <strong><span class="anno">Digraph</span></strong> that are
mentioned in <strong><span class="anno">Vertices</span></strong>.</p><p>If the value of option <strong>type</strong> is <strong>inherit</strong>, which is
the default, the type of <strong><span class="anno">Digraph</span></strong> is used
for the subgraph as well. Otherwise the option value of <strong>type</strong>
is used as argument to
<a href="./digraph#new/1">digraph#new/1</a>.</p><p>If the value of option <strong>keep_labels</strong> is <strong>true</strong>,
which is the default,
the <a href="#label">labels</a> of vertices and edges
of <strong><span class="anno">Digraph</span></strong> are used for the subgraph as well. If
the value is <strong>false</strong>, default label <strong>[]</strong> is used
for the vertices and edges of the subgroup.</p><p><strong>subgraph(<span class="anno">Digraph</span>, <span class="anno">Vertices</span>)</strong> is
equivalent to
<strong>subgraph(<span class="anno">Digraph</span>, <span class="anno">Vertices</span>, [])</strong>.</p><p>If any of the arguments are invalid, a <strong>badarg</strong> exception is
raised.</p><h3>topsort/1</h3><p>Return a topological sorting of the vertices of a digraph. </p><p>Returns a <a href="#topsort">topological ordering</a> of the vertices of digraph
<strong><span class="anno">Digraph</span></strong> if such an ordering exists, otherwise
<strong>false</strong>. For each vertex in the returned list,
no <a href="#out_neighbour">out-neighbors</a>
occur earlier in the list.</p><h3>See Also</h3><p><a href="digraph">digraph</a></p><h2>epp</h2><p>An Erlang code preprocessor.</p><p>The Erlang code preprocessor includes functions that are used by the
<a href="./compile">compiler/compile</a>
module to preprocess macros and include files before
the parsing takes place.The Erlang source file <a name="encoding"></a><em>encoding</em> is selected by a
comment in one of the first two lines of the source file. The
first string matching the regular expression
<strong>coding\s*[:=]\s*([-a-zA-Z0-9])+</strong> selects the encoding. If
the matching string is not a valid encoding, it is ignored. The
valid encodings are <strong>Latin-1</strong> and <strong>UTF-8</strong>, where the
case of the characters can be chosen freely.<em>Examples:</em><pre>
%% coding: utf-8</pre><pre>
%% For this file we have chosen encoding = Latin-1</pre><pre>
%% -*- coding: latin-1 -*-</pre></p><h2>Data Types</h2><span class="name">macros</span><span class="name">epp_handle</span><p>Handle to the <strong>epp</strong> server.</p><span class="name">source_encoding</span><h2>Functions</h2><h3>close/1</h3><p>Close the preprocessing of the file associated with <strong>Epp</strong>. </p><p>Closes the preprocessing of a file.</p><h3>default_encoding/0</h3><p>Return the default encoding of Erlang source files.</p><p>Returns the default encoding of Erlang source files.</p><h3>encoding_to_string/1</h3><p>Return a string representation of an encoding.</p><p>Returns a string representation of an encoding. The string
is recognized by
<a href="#read_encoding/1">read_encoding/1</a>,
<a href="#read_encoding_from_binary/1">read_encoding_from_binary/1</a>, and
<a href="#set_encoding/1">set_encoding/1</a>
as a valid encoding.</p><h3>format_error/1</h3><p>Format an error descriptor.</p><p>Takes an <strong><span class="anno">ErrorDescriptor</span></strong> and returns
a string that
describes the error or warning. This function is usually
called implicitly when processing an <strong>ErrorInfo</strong>
structure (see section
<a href="#errorinfo">Error Information</a>).</p><h3>open/1</h3><p>Open a file for preprocessing.</p><p>Opens a file for preprocessing.</p><p>If you want to change the file name of the implicit -file()
attributes inserted during preprocessing, you can do with
<strong>{source_name, <span class="anno">SourceName</span>}</strong>. If unset it will
default to the name of the opened file.</p><p>If <strong>extra</strong> is specified in
<strong><span class="anno">Options</span></strong>, the return value is
<strong>{ok, <span class="anno">Epp</span>, <span class="anno">Extra</span>}</strong> instead
of <strong>{ok, <span class="anno">Epp</span>}</strong>.</p><h3>open/2</h3><p>Open a file for preprocessing.</p><p>Equivalent to
<strong>epp:open([{name, FileName}, {includes, IncludePath}])</strong>.</p><h3>open/3</h3><p>Open a file for preprocessing.</p><p>Equivalent to <strong>epp:open([{name, FileName}, {includes, IncludePath}, {macros, PredefMacros}])</strong>.</p><h3>parse_erl_form/1</h3><p>Return the next Erlang form from the opened Erlang source file. </p><ul><li>warning_info</li></ul><p>Returns the next Erlang form from the opened Erlang source file.
Tuple <strong>{eof, <span class="anno">Line</span>}</strong> is returned at the end of the
file. The first form corresponds to an implicit attribute
<strong>-file(File,1).</strong>, where <strong>File</strong> is the file name.</p><h3>parse_file/2</h3><p>Preprocess and parse an Erlang source file.</p><p>Preprocesses and parses an Erlang source file.
Notice that tuple <strong>{eof, <span class="anno">Line</span>}</strong> returned at the
end of the file is included as a "form".</p><p>If you want to change the file name of the implicit -file()
attributes inserted during preprocessing, you can do with
<strong>{source_name, <span class="anno">SourceName</span>}</strong>. If unset it will
default to the name of the opened file.</p><p>If <strong>extra</strong> is specified in
<strong><span class="anno">Options</span></strong>, the return value is
<strong>{ok, [<span class="anno">Form</span>], <span class="anno">Extra</span>}</strong> instead
of <strong>{ok, [<span class="anno">Form</span>]}</strong>.</p><h3>parse_file/3</h3><p>Preprocess and parse an Erlang source file.</p><p>Equivalent to <strong>epp:parse_file(FileName, [{includes, IncludePath}, {macros, PredefMacros}])</strong>.</p><h3>read_encoding/1</h3><h3>read_encoding/2</h3><p>Read the encoding from a file.</p><p>Read the <a href="#encoding">encoding</a> from
a file. Returns the read encoding, or <strong>none</strong> if no
valid encoding is found.</p><p>Option <strong>in_comment_only</strong> is <strong>true</strong> by
default, which is correct for Erlang source files. If set to
<strong>false</strong>, the encoding string does not necessarily have to
occur in a comment.</p><h3>read_encoding_from_binary/1</h3><h3>read_encoding_from_binary/2</h3><p>Read the encoding from a binary.</p><p>Read the <a href="#encoding">encoding</a> from
a binary. Returns the read encoding, or <strong>none</strong> if no
valid encoding is found.</p><p>Option <strong>in_comment_only</strong> is <strong>true</strong> by
default, which is correct for Erlang source files. If set to
<strong>false</strong>, the encoding string does not necessarily have to
occur in a comment.</p><h3>set_encoding/1</h3><p>Read and set the encoding of an I/O device.</p><p>Reads the <a href="#encoding">encoding</a> from
an I/O device and sets the encoding of the device
accordingly. The position of the I/O device referenced by
<strong><span class="anno">File</span></strong> is not affected. If no valid
encoding can be read from the I/O device, the encoding of the
I/O device is set to the default encoding.</p><p>Returns the read encoding, or <strong>none</strong> if no valid
encoding is found.</p><h3>set_encoding/2</h3><p>Read and set the encoding of an I/O device.</p><p>Reads the <a href="#encoding">encoding</a> from
an I/O device and sets the encoding of the device
accordingly. The position of the I/O device referenced by
<strong><span class="anno">File</span></strong> is not affected. If no valid
encoding can be read from the I/O device, the encoding of the
I/O device is set to the
<a href="#encoding">encoding</a> specified by
<strong><span class="anno">Default</span></strong>.</p><p>Returns the read encoding, or <strong>none</strong> if no valid
encoding is found.</p><h3>Error Information</h3><a name="errorinfo"></a><p><strong>ErrorInfo</strong> is the standard <strong>ErrorInfo</strong> structure that is
returned from all I/O modules. The format is as follows:</p><pre><code class="">
{ErrorLine, Module, ErrorDescriptor}</code></pre><p>A string describing the error is obtained with the following call:</p><pre><code class="">
Module:format_error(ErrorDescriptor)</code></pre><h3>See Also</h3><p><a href="erl_parse">erl_parse</a></p><h2>erl_anno</h2><p>Abstract datatype for the annotations of the Erlang Compiler.
</p><p>This module provides an abstract type that is used by the
Erlang Compiler and its helper modules for holding data such as
column, line number, and text. The data type is a collection of
<a name="annotations"></a><em>annotations</em> as
described in the following.The Erlang Token Scanner returns tokens with a subset of
the following annotations, depending on the options:<dl><dt><strong>column</strong></dt><dd><p>The column where the token begins.</p></dd><dt><strong>location</strong></dt><dd><p>The line and column where the token begins, or
just the line if the column is unknown.</p></dd><dt><strong>text</strong></dt><dd><p>The token's text.</p></dd></dl>From this, the following annotation is derived:<dl><dt><strong>line</strong></dt><dd><p>The line where the token begins.</p></dd></dl>This module also supports the following annotations,
which are used by various modules:<dl><dt><strong>file</strong></dt><dd><p>A filename.</p></dd><dt><strong>generated</strong></dt><dd><p>A Boolean indicating if the abstract code is
compiler-generated. The Erlang Compiler does not emit warnings
for such code.</p></dd><dt><strong>record</strong></dt><dd><p>A Boolean indicating if the origin of the abstract
code is a record. Used by
<a href="./dialyzer">Dialyzer</a>
to assign types to tuple elements.</p> </dd></dl>The functions
<a href="./erl_scan#column/1">erl_scan#column/1</a>,
<a href="./erl_scan#end_location/1">erl_scan#end_location/1</a>,
<a href="./erl_scan#line/1">erl_scan#line/1</a>,
<a href="./erl_scan#location/1">erl_scan#location/1</a>, and
<a href="./erl_scan#text/1">erl_scan#text/1</a>
in the <strong>erl_scan</strong> module can be used for inspecting
annotations in tokens.The functions
<a href="./erl_parse#anno_from_term/1">erl_parse#anno_from_term/1</a>,
<a href="./erl_parse#anno_to_term/1">erl_parse#anno_to_term/1</a>,
<a href="./erl_parse#fold_anno/3">erl_parse#fold_anno/3</a>,
<a href="./erl_parse#map_anno/2">erl_parse#map_anno/2</a>,
<a href="./erl_parse#mapfold_anno/3">erl_parse#mapfold_anno/3</a>,
and <a href="./erl_parse#new_anno/1">erl_parse#new_anno/1</a>,
in the <strong>erl_parse</strong> module can be
used for manipulating annotations in abstract code.</p><h2>Data Types</h2><span class="name">anno()</span><p>A collection of annotations.</p><span class="name">anno_term</span><p>The term representing a collection of annotations. It is
either a <strong>location()</strong> or a list of key-value pairs.</p><span class="name">column</span><span class="name">line</span><span class="name">location</span><span class="name">text</span><h2>Functions</h2><h3>column/1</h3><p>Return the column.</p><ul><li>column</li></ul><p>Returns the column of the annotations <span class="anno">Anno</span>.</p><h3>end_location/1</h3><p>Return the end location of the text.</p><ul><li>location</li></ul><p>Returns the end location of the text of the
annotations <span class="anno">Anno</span>. If there is no text,
<strong>undefined</strong> is returned.</p><h3>file/1</h3><p>Return the filename.</p><ul><li>filename</li></ul><p>Returns the filename of the annotations <span class="anno">Anno</span>.
If there is no filename, <strong>undefined</strong> is returned.</p><h3>from_term/1</h3><p>Return annotations given a term.</p><p>Returns annotations with representation <span class="anno">Term</span>.</p><p>See also <a href="#to_term/1">to_term()</a>.</p><h3>generated/1</h3><p>Return the generated Boolean.</p><ul><li>generated</li></ul><p>Returns <strong>true</strong> if annotations <span class="anno">Anno</span>
is marked as generated. The default is to return
<strong>false</strong>.</p><h3>is_anno/1</h3><p>Test for a collection of annotations.</p><p>Returns <strong>true</strong> if <span class="anno">Term</span> is a collection of
annotations, otherwise <strong>false</strong>.</p><h3>line/1</h3><p>Return the line.</p><ul><li>line</li></ul><p>Returns the line of the annotations <span class="anno">Anno</span>.</p><h3>location/1</h3><p>Return the location.</p><ul><li>location</li></ul><p>Returns the location of the annotations <span class="anno">Anno</span>.</p><h3>new/1</h3><p>Create a new collection of annotations.</p><ul><li>location</li></ul><p>Creates a new collection of annotations given a location.</p><h3>set_file/2</h3><p>Modify the filename.</p><ul><li>filename</li></ul><p>Modifies the filename of the annotations <span class="anno">Anno</span>.</p><h3>set_generated/2</h3><p>Modify the generated marker.</p><ul><li>generated</li></ul><p>Modifies the generated marker of the annotations <span class="anno">Anno</span>.
</p><h3>set_line/2</h3><p>Modify the line.</p><ul><li>line</li></ul><p>Modifies the line of the annotations <span class="anno">Anno</span>.</p><h3>set_location/2</h3><p>Modify the location.</p><ul><li>location</li></ul><p>Modifies the location of the annotations <span class="anno">Anno</span>.</p><h3>set_record/2</h3><p>Modify the record marker.</p><ul><li>record</li></ul><p>Modifies the record marker of the annotations <span class="anno">Anno</span>.</p><h3>set_text/2</h3><p>Modify the text.</p><ul><li>text</li></ul><p>Modifies the text of the annotations <span class="anno">Anno</span>.</p><h3>text/1</h3><p>Return the text.</p><ul><li>text</li></ul><p>Returns the text of the annotations <span class="anno">Anno</span>.
If there is no text, <strong>undefined</strong> is returned.</p><h3>to_term/1</h3><p>Return the term representing a collection of annotations. </p><p>Returns the term representing the annotations <span class="anno">Anno</span>.</p><p>See also <a href="#from_term/1">from_term()</a>.</p><h3>See Also</h3><p><a href="erl_parse">erl_parse</a>,
<a href="erl_scan">erl_scan</a></p><h2>erl_eval</h2><p>The Erlang meta interpreter.</p><p>This module provides an interpreter for Erlang expressions. The
expressions are in the abstract syntax as returned by
<a href="erl_parse">erl_parse</a>,
the Erlang parser, or <a href="io">io</a>.</p><h2>Data Types</h2><span class="name">bindings</span><span class="name">binding_struct</span><p>A binding structure.</p><span class="name">expression</span><span class="name">expressions</span><p>As returned by <a href="./erl_parse#parse_exprs/1">erl_parse#parse_exprs/1</a> or
<a href="./io#parse_erl_exprs/2">io#parse_erl_exprs/2</a>.</p><span class="name">expression_list</span><span class="name">func_spec</span><span class="name">lfun_eval_handler</span><span class="name">lfun_value_handler</span><span class="name">local_function_handler</span><p>Further described in section
<a href="#local_function_handler"> Local Function Handler</a> in this module</p><span class="name">name</span><span class="name">nlfun_handler</span><span class="name">non_local_function_handler</span><p>Further described in section
<a href="#non_local_function_handler"> Non-Local Function Handler</a> in this module.</p><span class="name">value</span><h2>Functions</h2><h3>add_binding/3</h3><p>Add a binding.</p><p>Adds binding <strong><span class="anno">Name</span>=<span class="anno">Value</span></strong>
to <strong><span class="anno">BindingStruct</span></strong>.
Returns an updated binding structure.</p><h3>binding/2</h3><p>Return bindings.</p><p>Returns the binding of <strong><span class="anno">Name</span></strong>
in <strong><span class="anno">BindingStruct</span></strong>.</p><h3>bindings/1</h3><p>Return bindings.</p><p>Returns the list of bindings contained in the binding
structure.</p><h3>del_binding/2</h3><p>Delete a binding.</p><p>Removes the binding of <strong><span class="anno">Name</span></strong>
in <strong><span class="anno">BindingStruct</span></strong>.
Returns an updated binding structure.</p><h3>expr/2</h3><h3>expr/3</h3><h3>expr/4</h3><h3>expr/5</h3><p>Evaluate expression.</p><p>Evaluates <strong><span class="anno">Expression</span></strong> with the set of bindings
<strong><span class="anno">Bindings</span></strong>. <strong><span class="anno">Expression</span></strong> is an
expression in abstract syntax.
For an explanation of when and how to use arguments
<strong><span class="anno">LocalFunctionHandler</span></strong> and
<strong><span class="anno">NonLocalFunctionHandler</span></strong>, see sections
<a href="#local_function_handler"> Local Function Handler</a> and
<a href="#non_local_function_handler"> Non-Local Function Handler</a> in this module.</p><p>Returns <strong>{value, <span class="anno">Value</span>, <span class="anno">NewBindings</span>}</strong>
by default. If <strong><span class="anno">ReturnFormat</span></strong> is <strong>value</strong>,
only <strong><span class="anno">Value</span></strong> is returned.</p><h3>expr_list/2</h3><h3>expr_list/3</h3><h3>expr_list/4</h3><p>Evaluate a list of expressions.</p><p>Evaluates a list of expressions in parallel, using the same
initial bindings for each expression. Attempts are made to
merge the bindings returned from each evaluation. This
function is useful in <strong>LocalFunctionHandler</strong>, see section
<a href="#local_function_handler"> Local Function Handler</a> in this module.</p><p>Returns <strong>{<span class="anno">ValueList</span>, <span class="anno">NewBindings</span>}</strong>.
</p><h3>exprs/2</h3><h3>exprs/3</h3><h3>exprs/4</h3><p>Evaluate expressions.</p><p>Evaluates <strong><span class="anno">Expressions</span></strong> with the set of bindings
<strong><span class="anno">Bindings</span></strong>, where <strong><span class="anno">Expressions</span></strong>
is a sequence of expressions (in abstract syntax) of a type that can
be returned by <a href="./io#parse_erl_exprs/2">io#parse_erl_exprs/2</a>.
For an explanation of when and how to use arguments
<strong><span class="anno">LocalFunctionHandler</span></strong> and
<strong><span class="anno">NonLocalFunctionHandler</span></strong>, see sections
<a href="#local_function_handler"> Local Function Handler</a> and
<a href="#non_local_function_handler"> Non-Local Function Handler</a> in this module.</p><p>Returns <strong>{value, <span class="anno">Value</span>, <span class="anno">NewBindings</span>}</strong>
</p><h3>new_bindings/0</h3><p>Return a bindings structure.</p><p>Returns an empty binding structure.</p><a name="local_function_handler"></a><h3>Local Function Handler</h3><p>During evaluation of a function, no calls can be made to local
functions. An undefined function error would be
generated. However, the optional argument
<strong>LocalFunctionHandler</strong> can be used to define a function
that is called when there is a call to a local function. The
argument can have the following formats:</p><dl><dt><strong>{value,Func}</strong></dt><dd> <p>This defines a local function handler that is called with:</p> <pre><code class="">
Func(Name, Arguments)</code></pre> <p><strong>Name</strong> is the name of the local function (an atom) and
<strong>Arguments</strong> is a list of the <em>evaluated</em>
arguments. The function handler returns the value of the
local function. In this case, the current bindings cannot be
accessed. To signal an error, the function
handler calls <strong>exit/1</strong> with a suitable exit value.</p> </dd><dt><strong>{eval,Func}</strong></dt><dd> <p>This defines a local function handler that is called with:</p> <pre><code class="">
Func(Name, Arguments, Bindings)</code></pre> <p><strong>Name</strong> is the name of the local function (an atom),
<strong>Arguments</strong> is a list of the <em>unevaluated</em>
arguments, and <strong>Bindings</strong> are the current variable
bindings. The function handler returns:</p> <pre><code class="">
{value,Value,NewBindings}</code></pre> <p><strong>Value</strong> is the value of the local function and
<strong>NewBindings</strong> are the updated variable bindings. In
this case, the function handler must itself evaluate all the
function arguments and manage the bindings. To signal an
error, the function handler calls <strong>exit/1</strong> with a
suitable exit value.</p> </dd><dt><strong>none</strong></dt><dd> <p>There is no local function handler.</p> </dd></dl><a name="non_local_function_handler"></a><h3>Non-Local Function Handler</h3><p>The optional argument <strong>NonLocalFunctionHandler</strong> can be
used to define a function that is called in the following
cases:</p><ul><li><p>A functional object (fun) is called.</p></li><li><p>A built-in function is called.</p></li><li><p>A function is called using the <strong>M:F</strong> syntax, where <strong>M</strong>
and <strong>F</strong> are atoms or expressions.</p></li><li><p>An operator <strong>Op/A</strong> is called (this is handled as a call to
function <strong>erlang:Op/A</strong>).</p></li></ul><p>Exceptions are calls to <strong>erlang:apply/2,3</strong>; neither of the
function handlers are called for such calls.
The argument can have the following formats:</p><dl><dt><strong>{value,Func}</strong></dt><dd> <p>This defines a non-local function handler that is called with:</p> <pre><code class="">
Func(FuncSpec, Arguments)</code></pre> <p><strong>FuncSpec</strong> is the name of the function on the form
<strong>{Module,Function}</strong> or a fun, and <strong>Arguments</strong> is a
list of the <em>evaluated</em> arguments. The function
handler returns the value of the function. To
signal an error, the function handler calls
<strong>exit/1</strong> with a suitable exit value.</p> </dd><dt><strong>none</strong></dt><dd> <p>There is no non-local function handler.</p> </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>For calls such as <strong>erlang:apply(Fun, Args)</strong> or
<strong>erlang:apply(Module, Function, Args)</strong>, the call of the
non-local function handler corresponding to the call to
<strong>erlang:apply/2,3</strong> itself
(<strong>Func({erlang, apply}, [Fun, Args])</strong> or
<strong>Func({erlang, apply}, [Module, Function, Args])</strong>)
never takes place.</p><p>The non-local function handler <em>is</em> however called with the
evaluated arguments of the call to
<strong>erlang:apply/2,3</strong>: <strong>Func(Fun, Args)</strong> or
<strong>Func({Module, Function}, Args)</strong> (assuming
that <strong>{Module, Function}</strong> is not <strong>{erlang, apply}</strong>).</p><p>Calls to functions defined by evaluating fun expressions
<strong>"fun ... end"</strong> are also hidden from non-local function
handlers.</p></div><p>The non-local function handler argument is probably not used as
frequently as the local function handler argument. A possible
use is to call <strong>exit/1</strong> on calls to functions that for some
reason are not allowed to be called.</p><h3>Known Limitation</h3><p>Undocumented functions in this module are not to be used.</p><h2>erl_expand_records</h2><p>Expands records in a module.</p><p>This module expands records in a module.</p><h2>Functions</h2><h3>module/2</h3><p>Expand all records in a module.</p><p>Expands all records in a module to use explicit tuple
operations and adds explicit module names to calls to BIFs and
imported functions.  The returned module has no references to
records, attributes, or code.</p><h3>See Also</h3><p>Section <a href="./absform">The Abstract Format</a>
in ERTS User's Guide.</p><h2>erl_id_trans</h2><p>An identity parse transform.</p><p>This module performs an identity parse transformation of Erlang code.
It is included as an example for users who wants to write their own
parse transformers. If option <strong>{parse_transform,Module}</strong> is passed
to the compiler, a user-written function <strong>parse_transform/2</strong>
is called by the compiler before the code is checked for errors.</p><h2>Functions</h2><h3>parse_transform(Forms, Options) -&gt; Forms</h3><p>Transform Erlang forms.</p><ul><li><span class="v">Forms = [ | ]</span></li><li><span class="v">Options = []</span></li></ul><p>Performs an identity transformation on Erlang forms, as an example.
</p><h3>Parse Transformations</h3><p>Parse transformations are used if a programmer wants to use
Erlang syntax, but with different semantics. The original Erlang
code is then transformed into other Erlang code.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Programmers are strongly advised not to engage in parse
transformations. No support is offered for problems encountered.</p></div><h3>See Also</h3><p><a href="erl_parse">erl_parse</a>,
<a href="./compile">compiler/compile</a></p><h2>erl_internal</h2><p>Internal Erlang definitions.</p><p>This module defines Erlang BIFs, guard tests, and operators.
This module is only of interest to programmers who
manipulate Erlang code.</p><h2>Functions</h2><h3>add_predefined_functions/1</h3><p>Add code for pre-defined functions.</p><p>Adds to <strong><span class="anno">Forms</span></strong> the code for the standard
pre-defined functions (such as <strong>module_info/0</strong>) that are
to be included in every module.</p><h3>arith_op/2</h3><p>Test for an arithmetic operator.</p><p>Returns <strong>true</strong> if <strong><span class="anno">OpName</span>/<span class="anno">Arity</span></strong>
is an arithmetic operator, otherwise <strong>false</strong>.</p><h3>bif/2</h3><p>Test for an Erlang BIF.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Name</span>/<span class="anno">Arity</span></strong>
is an Erlang BIF that is automatically recognized by the compiler,
otherwise <strong>false</strong>.</p><h3>bool_op/2</h3><p>Test for a Boolean operator.</p><p>Returns <strong>true</strong> if <strong><span class="anno">OpName</span>/<span class="anno">Arity</span></strong>
is a Boolean operator, otherwise <strong>false</strong>.</p><h3>comp_op/2</h3><p>Test for a comparison operator.</p><p>Returns <strong>true</strong> if <strong><span class="anno">OpName</span>/<span class="anno">Arity</span></strong>
is a comparison operator, otherwise <strong>false</strong>.</p><h3>guard_bif/2</h3><p>Test for an Erlang BIF allowed in guards.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Name</span>/<span class="anno">Arity</span></strong> is
an Erlang BIF that is allowed in guards, otherwise <strong>false</strong>.</p><h3>list_op/2</h3><p>Test for a list operator.</p><p>Returns <strong>true</strong> if <strong><span class="anno">OpName</span>/<span class="anno">Arity</span></strong>
is a list operator, otherwise <strong>false</strong>.</p><h3>op_type/2</h3><p>Return operator type.</p><p>Returns the <strong><span class="anno">Type</span></strong> of operator that
<strong><span class="anno">OpName</span>/<span class="anno">Arity</span></strong> belongs to,
or generates a <strong>function_clause</strong> error if it is not an
operator.</p><h3>send_op/2</h3><p>Test for a send operator.</p><p>Returns <strong>true</strong> if <strong><span class="anno">OpName</span>/<span class="anno">Arity</span></strong>
is a send operator, otherwise <strong>false</strong>.</p><h3>type_test/2</h3><p>Test for a valid type test.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Name</span>/<span class="anno">Arity</span></strong> is
a valid Erlang type test, otherwise <strong>false</strong>.</p><h2>erl_lint</h2><p>The Erlang code linter.</p><p>This module is used to check Erlang code for illegal syntax and
other bugs. It also warns against coding practices that are
not recommended.The errors detected include:<ul><li>Redefined and undefined functions</li><li>Unbound and unsafe variables</li><li>Illegal record use</li></ul>The warnings detected include:<ul><li>Unused functions and imports</li><li>Unused variables</li><li>Variables imported into matches</li><li>Variables exported from <strong>if</strong>/<strong>case</strong>/<strong>receive</strong></li><li>Variables shadowed in funs and list comprehensions</li></ul>Some of the warnings are optional, and can be turned on by
specifying the appropriate option, described below.The functions in this module are invoked automatically by the
Erlang compiler. There is no reason to invoke these
functions separately unless you have written your own Erlang
compiler.</p><h2>Data Types</h2><span class="name">error_info</span><span class="name">error_description</span><h2>Functions</h2><h3>format_error/1</h3><p>Format an error descriptor.</p><p>Takes an <strong><span class="anno">ErrorDescriptor</span></strong> and returns a string
that describes the error or warning. This function is usually
called implicitly when processing an <strong>ErrorInfo</strong> structure
(see section
<a href="#errorinfo">Error Information</a>).</p><h3>is_guard_test/1</h3><p>Test for a guard test.</p><p>Tests if <strong><span class="anno">Expr</span></strong> is a legal guard test.
<strong><span class="anno">Expr</span></strong> is an Erlang term representing the abstract
form for the expression. <a href="./erl_parse#parse_exprs/1">erl_parse#parse_exprs/1</a>
can be used to generate a list of <strong><span class="anno">Expr</span></strong>.</p><h3>module/1</h3><h3>module/2</h3><h3>module/3</h3><p>Check a module for errors.</p><p>Checks all the forms in a module for errors. It returns:</p><dl><dt><strong>{ok,<span class="anno">Warnings</span>}</strong></dt><dd> <p>There are no errors in the module.</p> </dd><dt><strong>{error,<span class="anno">Errors</span>,<span class="anno">Warnings</span>}</strong></dt><dd> <p>There are errors in the module.</p> </dd></dl><p>As this module is of interest only to the maintainers of the
compiler, and to avoid the same description in two places, the
elements of <strong>Options</strong> that control the warnings are
only described in the
<a href="../compiler/compile#erl_lint_options">compiler/compile#erl_lint_options</a> module.</p><p><strong><span class="anno">AbsForms</span></strong> of a module, which comes from a file
that is read through <strong>epp</strong>, the Erlang preprocessor, can come
from many files. This means that any references to errors must
include the filename, see the <a href="epp">epp</a> module or parser (see the
<a href="erl_parse">erl_parse</a> module).
The returned errors and warnings have the following format:</p><pre><code class="">
[{<span class="anno">FileName2</span>,[<span class="anno">ErrorInfo</span>]}]</code></pre><p>The errors and warnings are listed in the order in which they are
encountered in the forms. The errors from one file can therefore be
split into different entries in the list of errors.</p><a name="errorinfo"></a><h3>Error Information</h3><p><strong>ErrorInfo</strong> is the standard <strong>ErrorInfo</strong> structure that is
returned from all I/O modules. The format is as follows:</p><pre><code class="">
{ErrorLine, Module, ErrorDescriptor}</code></pre><p>A string describing the error is obtained with the following call:</p><pre><code class="">
Module:format_error(ErrorDescriptor)</code></pre><h3>See Also</h3><p><a href="epp">epp</a>,
<a href="erl_parse">erl_parse</a></p><h2>erl_parse</h2><p>The Erlang parser.</p><p>This module is the basic Erlang parser that converts tokens into
the abstract form of either forms (that is, top-level constructs),
expressions, or terms. The Abstract Format is described in the
<a href="./absform">ERTS User's Guide</a>.
Notice that a token list must end with the <em>dot</em> token to be
acceptable to the parse functions (see the <a href="erl_scan">erl_scan</a>) module.</p><h2>Data Types</h2><span class="name">abstract_clause()</span><p>Abstract form of an Erlang clause.</p><span class="name">abstract_expr()</span><p>Abstract form of an Erlang expression.</p><span class="name">abstract_form()</span><p>Abstract form of an Erlang form.</p><span class="name">abstract_type()</span><p>Abstract form of an Erlang type.</p><span class="name">erl_parse_tree</span><span class="name">error_description</span><span class="name">error_info</span><span class="name">form_info</span><p>Tuples <strong>{error, error_info()}</strong> and <strong>{warning, error_info()}</strong>, denoting syntactically incorrect forms and
warnings, and <strong>{eof, line()}</strong>, denoting an end-of-stream
encountered before a complete form had been parsed.</p><span class="name">token</span><h2>Functions</h2><h3>abstract/1</h3><p>Convert an Erlang term into an abstract form.</p><p>Converts the Erlang data structure <strong><span class="anno">Data</span></strong> into an
abstract form of type <strong><span class="anno">AbsTerm</span></strong>.
This function is the inverse of
<a href="#normalise/1">normalise/1</a>.</p><p><strong>erl_parse:abstract(T)</strong> is equivalent to
<strong>erl_parse:abstract(T, 0)</strong>.</p><h3>abstract/2</h3><p>Convert an Erlang term into an abstract form.</p><ul><li>encoding_func</li></ul><p>Converts the Erlang data structure <strong><span class="anno">Data</span></strong> into an
abstract form of type <strong><span class="anno">AbsTerm</span></strong>.</p><p>Option <strong><span class="anno">Line</span></strong> is the line to be
assigned to each node of <strong><span class="anno">AbsTerm</span></strong>.</p><p>Option <strong><span class="anno">Encoding</span></strong> is used for
selecting which integer lists to be considered
as strings. The default is to use the encoding returned by
function <a href="./epp#default_encoding/0">epp#default_encoding/0</a>.
Value <strong>none</strong> means that no integer lists are
considered as strings. <strong>encoding_func()</strong> is
called with one integer of a list at a time; if it
returns <strong>true</strong> for every integer, the list is
considered a string.</p><h3>anno_from_term/1</h3><p>Return annotations as terms.</p><p>Assumes that <strong><span class="anno">Term</span></strong> is a term with the same
structure as a <strong>erl_parse</strong> tree, but with terms,
say <strong>T</strong>, where a <strong>erl_parse</strong> tree has collections
of annotations. Returns a <strong>erl_parse</strong> tree where each
term <strong>T</strong> is replaced by the value returned by
<a href="./erl_anno#from_term/1">erl_anno#from_term/1</a>. The term
<strong><span class="anno">Term</span></strong> is traversed in a depth-first,
left-to-right fashion.</p><h3>anno_to_term/1</h3><p>Return the representation of annotations.</p><p>Returns a term where each collection of annotations
<strong>Anno</strong> of the nodes of the <strong>erl_parse</strong> tree
<strong><span class="anno">Abstr</span></strong> is replaced by the term
returned by <a href="./erl_anno#to_term/1">erl_anno#to_term/1</a>. The
<strong>erl_parse</strong> tree is traversed in a depth-first,
left-to-right fashion.</p><h3>fold_anno/3</h3><p>Fold a function over the annotations of an <strong>erl_parse</strong> tree. </p><p>Updates an accumulator by applying <strong><span class="anno">Fun</span></strong> on
each collection of annotations of the <strong>erl_parse</strong> tree
<strong><span class="anno">Abstr</span></strong>. The first call to
<strong><span class="anno">Fun</span></strong> has <strong><span class="anno">AccIn</span></strong> as
argument, the returned accumulator
<strong><span class="anno">AccOut</span></strong> is passed to the next call, and
so on. The final value of the accumulator is returned. The
<strong>erl_parse</strong> tree is traversed in a depth-first, left-to-right
fashion.</p><h3>format_error(ErrorDescriptor) -&gt; Chars</h3><p>Format an error descriptor.</p><ul><li><span class="v">ErrorDescriptor = </span></li><li><span class="v">Chars = [char() | Chars]</span></li></ul><p>Uses an <strong>ErrorDescriptor</strong> and returns a string
that describes the error. This function is usually called
implicitly when an <strong>ErrorInfo</strong> structure is processed
(see section <a href="#errorinfo"> Error Information</a>).</p><h3>map_anno/2</h3><p>Map a function over the annotations of an <strong>erl_parse</strong> tree. </p><p>Modifies the <strong>erl_parse</strong> tree <strong><span class="anno">Abstr</span></strong>
by applying <strong><span class="anno">Fun</span></strong> on each collection of
annotations of the nodes of the <strong>erl_parse</strong> tree. The
<strong>erl_parse</strong> tree is traversed in a depth-first,
left-to-right fashion.</p><h3>mapfold_anno/3</h3><p>Map and fold a function over the annotations of an <strong>erl_parse</strong> tree.</p><p>Modifies the <strong>erl_parse</strong> tree <strong><span class="anno">Abstr</span></strong>
by applying <strong><span class="anno">Fun</span></strong> on each collection of
annotations of the nodes of the <strong>erl_parse</strong> tree, while
at the same time updating an accumulator. The first call to
<strong><span class="anno">Fun</span></strong> has <strong><span class="anno">AccIn</span></strong> as
second argument, the returned accumulator
<strong><span class="anno">AccOut</span></strong> is passed to the next call, and
so on. The modified <strong>erl_parse</strong> tree and the
final value of the accumulator are returned. The
<strong>erl_parse</strong> tree is traversed in a depth-first,
left-to-right fashion.</p><h3>new_anno/1</h3><p>Create new annotations.</p><p>Assumes that <strong><span class="anno">Term</span></strong> is a term with the same
structure as a <strong>erl_parse</strong> tree, but with <a href="./erl_anno#type-location">locations</a> where a
<strong>erl_parse</strong> tree has collections of annotations.
Returns a <strong>erl_parse</strong> tree where each location <strong>L</strong>
is replaced by the value returned by <a href="./erl_anno#new/1">erl_anno#new/1</a>.
The term <strong><span class="anno">Term</span></strong> is traversed in a
depth-first, left-to-right fashion.</p><h3>normalise/1</h3><p>Convert abstract form to an Erlang term.</p><p>Converts the abstract form <strong><span class="anno">AbsTerm</span></strong> of a
term into a conventional Erlang data structure (that is, the
term itself). This function is the inverse of
<a href="#abstract/1">abstract/1</a>.</p><h3>parse_exprs/1</h3><p>Parse Erlang expressions.</p><p>Parses <strong><span class="anno">Tokens</span></strong> as if it was a list of expressions.
Returns one of the following:</p><dl><dt><strong>{ok, <span class="anno">ExprList</span>}</strong></dt><dd> <p>The parsing was successful. <strong><span class="anno">ExprList</span></strong> is a
list of the abstract forms of the parsed expressions.</p> </dd><dt><strong>{error, <span class="anno">ErrorInfo</span>}</strong></dt><dd> <p>An error occurred.</p> </dd></dl><h3>parse_form/1</h3><p>Parse an Erlang form.</p><p>Parses <strong><span class="anno">Tokens</span></strong> as if it was a form. Returns one
of the following:</p><dl><dt><strong>{ok, <span class="anno">AbsForm</span>}</strong></dt><dd> <p>The parsing was successful. <strong><span class="anno">AbsForm</span></strong> is the
abstract form of the parsed form.</p> </dd><dt><strong>{error, <span class="anno">ErrorInfo</span>}</strong></dt><dd> <p>An error occurred.</p> </dd></dl><h3>parse_term/1</h3><p>Parse an Erlang term.</p><p>Parses <strong><span class="anno">Tokens</span></strong> as if it was a term. Returns
one of the following:</p><dl><dt><strong>{ok, <span class="anno">Term</span>}</strong></dt><dd> <p>The parsing was successful. <strong><span class="anno">Term</span></strong> is
the Erlang term corresponding to the token list.</p> </dd><dt><strong>{error, <span class="anno">ErrorInfo</span>}</strong></dt><dd> <p>An error occurred.</p> </dd></dl><h3>tokens/1</h3><h3>tokens/2</h3><p>Generate a list of tokens for an expression.</p><p>Generates a list of tokens representing the abstract
form <strong><span class="anno">AbsTerm</span></strong> of an expression. Optionally,
<strong><span class="anno">MoreTokens</span></strong> is appended.</p><a name="errorinfo"></a><h3>Error Information</h3><p><strong>ErrorInfo</strong> is the standard <strong>ErrorInfo</strong> structure that is
returned from all I/O modules. The format is as follows:</p><pre><code class="">
{ErrorLine, Module, ErrorDescriptor}</code></pre><p>A string describing the error is obtained with the following call:</p><pre><code class="">
Module:format_error(ErrorDescriptor)</code></pre><h3>See Also</h3><p><a href="erl_anno">erl_anno</a>,
<a href="erl_scan">erl_scan</a>,
<a href="io">io</a>,
section <a href="./absform">The Abstract Format</a>
in the ERTS User's Guide</p><h2>erl_pp</h2><p>The Erlang pretty printer.</p><p>The functions in this module are used to generate
aesthetically attractive representations of abstract
forms, which are suitable for printing.
All functions return (possibly deep)
lists of characters and generate an error if the form is wrong.All functions can have an optional argument, which specifies a hook
that is called if an attempt is made to print an unknown form.</p><h2>Data Types</h2><span class="name">hook_function</span><p>Optional argument <a name="hook_function"></a><strong>HookFunction</strong>,
shown in the functions described in this module, defines a function
that is called when an unknown form occurs where there
is to be a valid expression. If <strong>HookFunction</strong> is equal to
<strong>none</strong>, there is no hook function.</p><p>The called hook function is to return a (possibly deep) list of
characters. Function <a href="#expr/4">expr/4</a>
is useful in a hook.</p><p>If <strong><span class="anno">CurrentIndentation</span></strong> is negative, there are no
line breaks and only a space is used as a separator.</p><span class="name">option</span><p>The option <strong>quote_singleton_atom_types</strong>
is used to add quotes to all singleton atom types.</p><span class="name">options</span><h2>Functions</h2><h3>attribute/1</h3><h3>attribute/2</h3><p>Pretty print an attribute.</p><p>Same as <a href="#form/1">form/1</a>,
but only for attribute <strong><span class="anno">Attribute</span></strong>.</p><h3>expr/1</h3><h3>expr/2</h3><h3>expr/3</h3><h3>expr/4</h3><p>Pretty print one <strong>Expression</strong>.</p><p>Prints one expression. It is useful for implementing hooks (see
section
<a href="#knownlimitations">Known Limitations</a>).</p><h3>exprs/1</h3><h3>exprs/2</h3><h3>exprs/3</h3><p>Pretty print <strong>Expressions</strong>.</p><p>Same as <a href="#form/1">form/1</a>,
but only for the sequence of
expressions in <strong><span class="anno">Expressions</span></strong>.</p><h3>form/1</h3><h3>form/2</h3><p>Pretty print a form.</p><p>Pretty prints a
<strong><span class="anno">Form</span></strong>, which is an abstract form of a type that is
returned by <a href="./erl_parse#parse_form/1">erl_parse#parse_form/1</a>.</p><h3>function/1</h3><h3>function/2</h3><p>Pretty print a function.</p><p>Same as <a href="#form/1">form/1</a>,
but only for function <strong><span class="anno">Function</span></strong>.</p><h3>guard/1</h3><h3>guard/2</h3><p>Pretty print a guard.</p><p>Same as <a href="#form/1">form/1</a>,
but only for the guard test <strong><span class="anno">Guard</span></strong>.</p><a name="knownlimitations"></a><h3>Known Limitations</h3><p>It is not possible to have hook functions for unknown forms
at other places than expressions.</p><h3>See Also</h3><p><a href="erl_eval">erl_eval</a>,
<a href="erl_parse">erl_parse</a>,
<a href="io">io</a></p><h2>erl_scan</h2><p>The Erlang token scanner.</p><p>This module contains functions for tokenizing (scanning) characters into
Erlang tokens.</p><h2>Data Types</h2><span class="name">category</span><span class="name">error_description</span><span class="name">error_info</span><span class="name">option</span><span class="name">options</span><span class="name">symbol</span><span class="name">resword_fun</span><span class="name">token</span><span class="name">tokens</span><span class="name">tokens_result</span><h2>Functions</h2><h3>category/1</h3><p>Return the category.</p><p>Returns the category of <strong><span class="anno">Token</span></strong>.</p><h3>column/1</h3><p>Return the column.</p><p>Returns the column of <strong><span class="anno">Token</span></strong>'s
collection of annotations.</p><h3>end_location/1</h3><p>Return the end location of the text.</p><p>Returns the end location of the text of
<strong><span class="anno">Token</span></strong>'s collection of annotations. If
there is no text, <strong>undefined</strong> is returned.</p><h3>format_error/1</h3><p>Format an error descriptor.</p><p>Uses an <strong><span class="anno">ErrorDescriptor</span></strong> and returns a string 
that describes the error or warning. This function is usually
called implicitly when an <strong>ErrorInfo</strong> structure is
processed (see section
<a href="#errorinfo">Error Information</a>).</p><h3>line/1</h3><p>Return the line.</p><p>Returns the line of <strong><span class="anno">Token</span></strong>'s collection
of annotations.</p><h3>location/1</h3><p>Return the location.</p><p>Returns the location of <strong><span class="anno">Token</span></strong>'s
collection of annotations.</p><h3>reserved_word/1</h3><p>Test for a reserved word.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Atom</span></strong> is an
Erlang reserved word, otherwise <strong>false</strong>.</p><h3>string/1</h3><h3>string/2</h3><h3>string/3</h3><p>Scan a string and return the Erlang tokens.</p><p>Takes the list of characters <strong><span class="anno">String</span></strong> and tries to
scan (tokenize) them. Returns one of the following:</p><dl><dt><strong>{ok, <span class="anno">Tokens</span>, <span class="anno">EndLocation</span>}</strong></dt><dd> <p><strong><span class="anno">Tokens</span></strong> are the Erlang tokens from
<strong><span class="anno">String</span></strong>. <strong><span class="anno">EndLocation</span></strong>
is the first location after the last token.</p> </dd><dt><strong>{error, <span class="anno">ErrorInfo</span>, <span class="anno">ErrorLocation</span>}</strong></dt><dd> <p>An error occurred. <strong><span class="anno">ErrorLocation</span></strong> is the
first location after the erroneous token.</p> </dd></dl><p><strong>string(<span class="anno">String</span>)</strong> is equivalent to
<strong>string(<span class="anno">String</span>, 1)</strong>, and
<strong>string(<span class="anno">String</span>, <span class="anno">StartLocation</span>)</strong> is equivalent to
<strong>string(<span class="anno">String</span>, <span class="anno">StartLocation</span>, [])</strong>.</p><p><strong><span class="anno">StartLocation</span></strong> indicates the initial location
when scanning starts. If <strong><span class="anno">StartLocation</span></strong> is a line,
<strong>Anno</strong>, <strong><span class="anno">EndLocation</span></strong>, and
<strong><span class="anno">ErrorLocation</span></strong> are lines. If
<strong><span class="anno">StartLocation</span></strong> is a pair of a line and a column,
<strong>Anno</strong> takes the form of an opaque compound
data type, and <strong><span class="anno">EndLocation</span></strong> and
<strong><span class="anno">ErrorLocation</span></strong>
are pairs of a line and a column. The <em>token annotations</em> contain information about the column and the
line where the token begins, as well as the text of the
token (if option <strong>text</strong> is specified), all of which can
be accessed by calling
<a href="#column/1">column/1</a>,
<a href="#line/1">line/1</a>,
<a href="#location/1">location/1</a>, and
<a href="#text/1">text/1</a>.</p><p>A <em>token</em> is a tuple containing information about
syntactic category, the token annotations, and the
terminal symbol. For punctuation characters (such as <strong>;</strong> and 
<strong>|</strong>) and reserved words, the category and the symbol
coincide, and the token is represented by a two-tuple.
Three-tuples have one of the following forms:</p><ul><li><strong>{atom, Anno, atom()}</strong></li><li><strong>{char, Anno, char()}</strong></li><li><strong>{comment, Anno, string()}</strong></li><li><strong>{float, Anno, float()}</strong></li><li><strong>{integer, Anno, integer()}</strong></li><li><strong>{var, Anno, atom()}</strong></li><li><strong>{white_space, Anno, string()}</strong></li></ul><p>Valid options:</p><dl><dt><strong>{reserved_word_fun, reserved_word_fun()}</strong></dt><dd><p>A callback function that is called when the scanner
has found an unquoted atom. If the function returns
<strong>true</strong>, the unquoted atom itself becomes the category
of the token. If the function returns <strong>false</strong>,
<strong>atom</strong> becomes the category of the unquoted atom.</p> </dd><dt><strong>return_comments</strong></dt><dd><p>Return comment tokens.</p> </dd><dt><strong>return_white_spaces</strong></dt><dd><p>Return white space tokens. By convention, a newline
character, if present, is always the first character of the
text (there cannot be more than one newline in a white space
token).</p> </dd><dt><strong>return</strong></dt><dd><p>Short for <strong>[return_comments, return_white_spaces]</strong>.</p> </dd><dt><strong>text</strong></dt><dd><p>Include the token text in the token annotation. The
text is the part of the input corresponding to the token.</p> </dd></dl><h3>symbol/1</h3><p>Return the symbol.</p><p>Returns the symbol of <strong><span class="anno">Token</span></strong>.</p><h3>text/1</h3><p>Return the text.</p><p>Returns the text of <strong><span class="anno">Token</span></strong>'s collection
of annotations. If there is no text, <strong>undefined</strong> is
returned.</p><h3>tokens/3</h3><h3>tokens/4</h3><p>Re-entrant scanner.</p><ul><li>char_spec</li></ul><ul><li>return_cont</li></ul>An opaque continuation.<p>This is the re-entrant scanner, which scans characters until
either a <em>dot</em> ('.' followed by a white space) or
<strong>eof</strong> is reached. It returns:</p><dl><dt><strong>{done, <span class="anno">Result</span>, <span class="anno">LeftOverChars</span>}</strong> </dt><dd> <p>Indicates that there is sufficient input
data to get a result. <strong><span class="anno">Result</span></strong> is:</p> <dl><dt><strong>{ok, Tokens, EndLocation}</strong></dt><dd> <p>The scanning was successful. <strong>Tokens</strong>
is the list of tokens including <em>dot</em>.</p> </dd><dt><strong>{eof, EndLocation}</strong></dt><dd> <p>End of file was encountered before any more tokens.</p> </dd><dt><strong>{error, ErrorInfo, EndLocation}</strong></dt><dd> <p>An error occurred. <strong><span class="anno">LeftOverChars</span></strong>
is the remaining characters of the input data,
starting from <strong>EndLocation</strong>.</p> </dd></dl> </dd><dt><strong>{more, <span class="anno">Continuation1</span>}</strong></dt><dd> <p>More data is required for building a term.
<strong><span class="anno">Continuation1</span></strong> must be passed in a new call to
<strong>tokens/3,4</strong> when more data is available.</p> </dd></dl><p>The <strong><span class="anno">CharSpec</span></strong> <strong>eof</strong> signals end of file.
<strong><span class="anno">LeftOverChars</span></strong> then takes the value <strong>eof</strong>
as well.</p><p><strong>tokens(<span class="anno">Continuation</span>, <span class="anno">CharSpec</span>, <span class="anno">StartLocation</span>)</strong> is equivalent to
<strong>tokens(<span class="anno">Continuation</span>, <span class="anno">CharSpec</span>, <span class="anno">StartLocation</span>, [])</strong>.</p><p>For a description of the options, see
<a href="#string/3">string/3</a>.</p><a name="errorinfo"></a><h3>Error Information</h3><p><strong>ErrorInfo</strong> is the standard <strong>ErrorInfo</strong> structure that is
returned from all I/O modules. The format is as follows:</p><pre><code class="">
{ErrorLocation, Module, ErrorDescriptor}</code></pre><p>A string describing the error is obtained with the following call:</p><pre><code class="">
Module:format_error(ErrorDescriptor)</code></pre><h3>Notes</h3><p>The continuation of the first call to the re-entrant input
functions must be <strong>[]</strong>. For a complete description of how the
re-entrant input scheme works, see Armstrong, Virding and
Williams: 'Concurrent Programming in Erlang', Chapter 13.</p><h3>See Also</h3><p><a href="erl_anno">erl_anno</a>,
<a href="erl_parse">erl_parse</a>,
<a href="io">io</a></p><h2>erl_tar</h2><p>Unix 'tar' utility for reading and writing tar archives.
</p><p>This module archives and extract files to and from
a tar file. This module supports reading most common tar formats,
namely v7, STAR, USTAR, and PAX, as well as some of GNU tar's extensions
to the USTAR format (sparse files most notably). It produces tar archives
in USTAR format, unless the files being archived require PAX format due to
restrictions in USTAR (such as unicode metadata, filename length, and more).
As such, <strong>erl_tar</strong> supports tar archives produced by most all modern
tar utilities, and produces tarballs which should be similarly portable.By convention, the name of a tar file is to end in "<strong>.tar</strong>".
To abide to the convention, add "<strong>.tar</strong>" to the name.Tar files can be created in one operation using function
<a href="#create/2">create/2</a> or
<a href="#create/3">create/3</a>.Alternatively, for more control, use functions
<a href="#open/2">open/2</a>,
<a href="#add/3">add/3</a>, and
<a href="#close/1">close/1</a>.To extract all files from a tar file, use function
<a href="#extract/1">extract/1</a>.
To extract only some files or to be able to specify some more options,
use function <a href="#extract/2">extract/2</a>.To return a list of the files in a tar file,
use function <a href="#table/1">table/1</a> or
<a href="#table/2">table/2</a>.
To print a list of files to the Erlang shell,
use function <a href="#t/1">t/1</a> or
<a href="#tt/1">tt/1</a>.To convert an error term returned from one of the functions
above to a readable message, use function
<a href="#format_error/1">format_error/1</a>.</p><h3>Unicode Support</h3><p>If <a href="../kernel/file#native_name_encoding/0">kernel/file#native_name_encoding/0</a>
returns <strong>utf8</strong>, path names are encoded in UTF-8 when
creating tar files, and path names are assumed to be encoded in
UTF-8 when extracting tar files.</p><p>If <a href="../kernel/file#native_name_encoding/0">kernel/file#native_name_encoding/0</a>
returns <strong>latin1</strong>, no translation of path names is done.</p><p>Unicode metadata stored in PAX headers is preserved</p><h3>Other Storage Media</h3><p>The <a href="./ftp">ftp/ftp</a>
module normally accesses the tar file on disk using
the <a href="./file">kernel/file</a> module.
When other needs arise, you can define your own low-level Erlang
functions to perform the writing and reading on the storage media;
use function <a href="#init/3">init/3</a>.</p><p>An example of this is the SFTP support in
<a href="../ssh/ssh_sftp#open_tar/3">ssh/ssh_sftp#open_tar/3</a>. This function opens a tar file
on a remote machine using an SFTP channel.</p><h3>Limitations</h3><ul><li> <p>If you must remain compatible with the USTAR tar format, you must ensure file paths being
stored are less than 255 bytes in total, with a maximum filename component
length of 100 bytes. USTAR uses a header field (prefix) in addition to the name field, and
splits file paths longer than 100 bytes into two parts. This split is done on a directory boundary,
and is done in such a way to make the best use of the space available in those two fields, but in practice
this will often mean that you have less than 255 bytes for a path. <strong>erl_tar</strong> will
automatically upgrade the format to PAX to handle longer filenames, so this is only an issue if you
need to extract the archive with an older implementation of <strong>erl_tar</strong> or <strong>tar</strong> which does
not support PAX. In this case, the PAX headers will be extracted as regular files, and you will need to
apply them manually.</p> </li><li> <p>Like the above, if you must remain USTAR compatible, you must also ensure than paths for
symbolic/hard links are no more than 100 bytes, otherwise PAX headers will be used.</p> </li></ul><h2>Functions</h2><h3>add(TarDescriptor, Filename, Options) -&gt; RetValue</h3><p>Add a file to an open tar file.</p><ul><li><span class="v">TarDescriptor = term()</span></li><li><span class="v">FilenameOrBin = filename()|binary()</span></li><li><span class="v">NameInArchive = filename()</span></li><li><span class="v">Filename = filename()|{NameInArchive,FilenameOrBin}</span></li><li><span class="v">Options = [Option]</span></li><li><span class="v">Option = dereference|verbose|{chunks,ChunkSize}</span></li><li><span class="v">|{atime,non_neg_integer()}|{mtime,non_neg_integer()}</span></li><li><span class="v">|{ctime,non_neg_integer()}|{uid,non_neg_integer()}</span></li><li><span class="v">|{gid,non_neg_integer()}</span></li><li><span class="v">ChunkSize = positive_integer()</span></li><li><span class="v">RetValue = ok|{error,{Filename,Reason}}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a file to a tar file that has been opened for writing by
<a href="#open/2">open/2</a>.</p><p><strong>NameInArchive</strong> is the name under which the file becomes
stored in the tar file. The file gets this name when it is
extracted from the tar file.</p><p>Options:</p><dl><dt><strong>dereference</strong></dt><dd> <p>By default, symbolic links are stored as symbolic links
in the tar file. To override the default and store the file
that the symbolic link points to into the tar file, use
option <strong>dereference</strong>.</p> </dd><dt><strong>verbose</strong></dt><dd> <p>Prints an informational message about the added file.</p> </dd><dt><strong>{chunks,ChunkSize}</strong></dt><dd> <p>Reads data in parts from the file. This is intended for
memory-limited machines that, for example, builds a tar file
on a remote machine over SFTP, see
<a href="../ssh/ssh_sftp#open_tar/3">ssh/ssh_sftp#open_tar/3</a>.</p> </dd><dt><strong>{atime,non_neg_integer()}</strong></dt><dd> <p>Sets the last time, as
<a href="../erts/time_correction#POSIX_Time"> POSIX time</a>, when the file was read. See also
<a href="../kernel/file#read_file_info/1">kernel/file#read_file_info/1</a>.</p> </dd><dt><strong>{mtime,non_neg_integer()}</strong></dt><dd> <p>Sets the last time, as
<a href="../erts/time_correction#POSIX_Time"> POSIX time</a>, when the file was written. See also
<a href="../kernel/file#read_file_info/1">kernel/file#read_file_info/1</a>.</p> </dd><dt><strong>{ctime,non_neg_integer()}</strong></dt><dd> <p>Sets the time, as
<a href="../erts/time_correction#POSIX_Time"> POSIX time</a>, when the file was created. See also
<a href="../kernel/file#read_file_info/1">kernel/file#read_file_info/1</a>.</p> </dd><dt><strong>{uid,non_neg_integer()}</strong></dt><dd> <p>Sets the file owner.
<a href="../kernel/file#read_file_info/1">kernel/file#read_file_info/1</a>.</p> </dd><dt><strong>{gid,non_neg_integer()}</strong></dt><dd> <p>Sets the group that the file owner belongs to.
<a href="../kernel/file#read_file_info/1">kernel/file#read_file_info/1</a>.</p> </dd></dl><h3>add(TarDescriptor, FilenameOrBin, NameInArchive, Options) -&gt;
        RetValue</h3><p>Add a file to an open tar file.</p><ul><li><span class="v">TarDescriptor = term()</span></li><li><span class="v">FilenameOrBin = filename()|binary()</span></li><li><span class="v">Filename = filename()</span></li><li><span class="v">NameInArchive = filename()</span></li><li><span class="v">Options = [Option]</span></li><li><span class="v">Option = dereference|verbose</span></li><li><span class="v">RetValue = ok|{error,{Filename,Reason}}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a file to a tar file that has been opened for writing by
<a href="#open/2">open/2</a>. This function
accepts the same options as
<a href="#add/3">add/3</a>.</p><h3>close(TarDescriptor)</h3><p>Close an open tar file.</p><ul><li><span class="v">TarDescriptor = term()</span></li></ul><p>Closes a tar file
opened by <a href="#open/2">open/2</a>.</p><h3>create(Name, FileList) -&gt;RetValue</h3><p>Create a tar archive.</p><ul><li><span class="v">Name = filename()</span></li><li><span class="v">FileList = [Filename|{NameInArchive, FilenameOrBin}]</span></li><li><span class="v">FilenameOrBin = filename()|binary()</span></li><li><span class="v">Filename = filename()</span></li><li><span class="v">NameInArchive = filename()</span></li><li><span class="v">RetValue = ok|{error,{Name,Reason}}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Creates a tar file and archives the files whose names are specified
in <strong>FileList</strong> into it. The files can either be read from disk
or be specified as binaries.</p><h3>create(Name, FileList, OptionList)</h3><p>Create a tar archive with options.</p><ul><li><span class="v">Name = filename()</span></li><li><span class="v">FileList = [Filename|{NameInArchive, FilenameOrBin}]</span></li><li><span class="v">FilenameOrBin = filename()|binary()</span></li><li><span class="v">Filename = filename()</span></li><li><span class="v">NameInArchive = filename()</span></li><li><span class="v">OptionList = [Option]</span></li><li><span class="v">Option = compressed|cooked|dereference|verbose</span></li><li><span class="v">RetValue = ok|{error,{Name,Reason}}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Creates a tar file and archives the files whose names are specified
in <strong>FileList</strong> into it. The files can either be read from disk
or be specified as binaries.</p><p>The options in <strong>OptionList</strong> modify the defaults as follows:</p><dl><dt><strong>compressed</strong></dt><dd> <p>The entire tar file is compressed, as if it has
been run through the <strong>gzip</strong> program. To abide to the
convention that a compressed tar file is to end in
"<strong>.tar.gz</strong>" or "<strong>.tgz</strong>", add the appropriate
extension.</p> </dd><dt><strong>cooked</strong></dt><dd> <p>By default, function <strong>open/2</strong> opens the tar file in
<strong>raw</strong> mode, which is faster but does not allow a remote
(Erlang) file server to be used. Adding <strong>cooked</strong> to the
mode list overrides the default and opens the tar file without
option <strong>raw</strong>.</p> </dd><dt><strong>dereference</strong></dt><dd> <p>By default, symbolic links are stored as symbolic links in
the tar file. To override the default and store the file that
the symbolic link points to into the tar file, use
option <strong>dereference</strong>.</p> </dd><dt><strong>verbose</strong></dt><dd> <p>Prints an informational message about each added file.</p> </dd></dl><h3>extract(Name) -&gt; RetValue</h3><p>Extract all files from a tar file.</p><ul><li><span class="v">Name = filename() | {binary,binary()} | {file,Fd}</span></li><li><span class="v">Fd = file_descriptor()</span></li><li><span class="v">RetValue = ok|{error,{Name,Reason}}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Extracts all files from a tar archive.</p><p>If argument <strong>Name</strong> is specified as <strong>{binary,Binary}</strong>,
the contents of the binary is assumed to be a tar archive.</p><p>If argument <strong>Name</strong> is specified as <strong>{file,Fd}</strong>,
<strong>Fd</strong> is assumed to be a file descriptor returned from function
<strong>file:open/2</strong>.</p><p>Otherwise, <strong>Name</strong> is to be a filename.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Leading slashes in tar member names will be removed before
writing the file. That is, absolute paths will be turned into
relative paths. There will be an info message written to the error
logger when paths are changed in this way.</p></div><h3>extract(Name, OptionList)</h3><p>Extract files from a tar file.</p><ul><li><span class="v">Name = filename() | {binary,binary()} | {file,Fd}</span></li><li><span class="v">Fd = file_descriptor()</span></li><li><span class="v">OptionList = [Option]</span></li><li><span class="v">Option = {cwd,Cwd}|{files,FileList}|keep_old_files|verbose|memory</span></li><li><span class="v">Cwd = [dirname()]</span></li><li><span class="v">FileList = [filename()]</span></li><li><span class="v">RetValue = ok|MemoryRetValue|{error,{Name,Reason}}</span></li><li><span class="v">MemoryRetValue = {ok, [{NameInArchive,binary()}]}</span></li><li><span class="v">NameInArchive = filename()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Extracts files from a tar archive.</p><p>If argument <strong>Name</strong> is specified as <strong>{binary,Binary}</strong>,
the contents of the binary is assumed to be a tar archive.</p><p>If argument <strong>Name</strong> is specified as <strong>{file,Fd}</strong>,
<strong>Fd</strong> is assumed to be a file descriptor returned from function
<strong>file:open/2</strong>.</p><p>Otherwise, <strong>Name</strong> is to be a filename.</p><p>The following options modify the defaults for the extraction as
follows:</p><dl><dt><strong>{cwd,Cwd}</strong></dt><dd> <p>Files with relative filenames are by default extracted
to the current working directory. With this option, files are
instead extracted into directory <strong>Cwd</strong>.</p> </dd><dt><strong>{files,FileList}</strong></dt><dd> <p>By default, all files are extracted from the tar file. With
this option, only those files are extracted whose names are
included in <strong>FileList</strong>.</p> </dd><dt><strong>compressed</strong></dt><dd> <p>With this option, the file is uncompressed while extracting.
If the tar file is not compressed, this option is ignored.</p> </dd><dt><strong>cooked</strong></dt><dd> <p>By default, function <strong>open/2</strong> function opens the tar file
in <strong>raw</strong> mode, which is faster but does not allow a remote
(Erlang) file server to be used. Adding <strong>cooked</strong> to the mode
list overrides the default and opens the tar file without option
<strong>raw</strong>.</p> </dd><dt><strong>memory</strong></dt><dd> <p>Instead of extracting to a directory, this option gives the
result as a list of tuples <strong>{Filename, Binary}</strong>, where
<strong>Binary</strong> is a binary containing the extracted data of the
file named <strong>Filename</strong> in the tar file.</p> </dd><dt><strong>keep_old_files</strong></dt><dd> <p>By default, all existing files with the same name as files in
the tar file are overwritten. With this option, existing
files are not overwriten.</p> </dd><dt><strong>verbose</strong></dt><dd> <p>Prints an informational message for each extracted file.</p> </dd></dl><h3>format_error(Reason) -&gt; string()</h3><p>Convert error term to a readable string.</p><ul><li><span class="v">Reason = term()</span></li></ul><p>Converts an error reason term to a human-readable error message
string.</p><h3>init(UserPrivate, AccessMode, Fun) -&gt;
        {ok,TarDescriptor} | {error,Reason}</h3><p>Create a <strong>TarDescriptor</strong> used in subsequent tar operations when defining own low-level storage access functions.</p><ul><li><span class="v">UserPrivate = term()</span></li><li><span class="v">AccessMode = [write] | [read]</span></li><li><span class="v">Fun when AccessMode is [write] = fun(write, {UserPrivate,DataToWrite})-&gt;...; (position,{UserPrivate,Position})-&gt;...; (close, UserPrivate)-&gt;... end</span></li><li><span class="v">Fun when AccessMode is [read] = fun(read2, {UserPrivate,Size})-&gt;...; (position,{UserPrivate,Position})-&gt;...; (close,   UserPrivate)-&gt;... end</span></li><li><span class="v">TarDescriptor = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>The <strong>Fun</strong> is the definition of what to do when the different
storage operations functions are to be called from the higher tar
handling functions (such as <strong>add/3</strong>, <strong>add/4</strong>, and
<strong>close/1</strong>).</p><p>The <strong>Fun</strong> is called when the tar function wants to do a
low-level operation, like writing a block to a file. The <strong>Fun</strong>
is called as <strong>Fun(Op, {UserPrivate,Parameters...})</strong>, where
<strong>Op</strong> is the operation name, <strong>UserPrivate</strong> is the term
passed as the first argument to <strong>init/1</strong> and
<strong>Parameters...</strong> are the data added by the tar function to be
passed down to the storage handling function.</p><p>Parameter <strong>UserPrivate</strong> is typically the result of opening a
low-level structure like a file descriptor or an SFTP channel id.
The different <strong>Fun</strong> clauses operate on that very term.</p><p>The following are the fun clauses parameter lists:</p><dl><dt><strong>(write, {UserPrivate,DataToWrite})</strong></dt><dd> <p>Writes term <strong>DataToWrite</strong> using <strong>UserPrivate</strong>.</p> </dd><dt><strong>(close, UserPrivate)</strong></dt><dd> <p>Closes the access.</p> </dd><dt><strong>(read2, {UserPrivate,Size})</strong></dt><dd> <p>Reads using <strong>UserPrivate</strong> but only <strong>Size</strong> bytes.
Notice that there is only an arity-2 read function, not an arity-1
function.</p> </dd><dt><strong>(position,{UserPrivate,Position})</strong></dt><dd> <p>Sets the position of <strong>UserPrivate</strong> as defined for files in
<a href="../kernel/file#position-2">kernel/file#position-2</a></p> </dd></dl><p><em>Example:</em></p><p>The following is a complete <strong>Fun</strong> parameter for reading and
writing on files using the
<a href="./file">kernel/file</a> module:</p><pre><code class="">
ExampleFun = 
   fun(write, {Fd,Data}) -&gt;  file:write(Fd, Data);
      (position, {Fd,Pos}) -&gt; file:position(Fd, Pos);
      (read2, {Fd,Size}) -&gt; file:read(Fd, Size);
      (close, Fd) -&gt; file:close(Fd)
   end</code></pre><p>Here <strong>Fd</strong> was specified to function <strong>init/3</strong> as:</p><pre><code class="">
{ok,Fd} = file:open(Name, ...).
{ok,TarDesc} = erl_tar:init(Fd, [write], ExampleFun),</code></pre><p><strong>TarDesc</strong> is then used:</p><pre><code class="">
erl_tar:add(TarDesc, SomeValueIwantToAdd, FileNameInTarFile),
...,
erl_tar:close(TarDesc)</code></pre><p>When the <strong>erl_tar</strong> core wants to, for example, write a piece
of <strong>Data</strong>, it would call
<strong>ExampleFun(write, {UserPrivate,Data})</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This example with the <strong>file</strong> module operations is
not necessary to use directly, as that is what function
<a href="#open/2">open/2</a> in principle
does.</p></div><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>The <strong>TarDescriptor</strong> term is not a file descriptor. You are
advised not to rely on the specific contents of this term, as it
can change in future Erlang/OTP releases when more features are
added to this module.</p></div><h3>open(Name, OpenModeList) -&gt; RetValue</h3><p>Open a tar file for writing.</p><ul><li><span class="v">Name = filename()</span></li><li><span class="v">OpenModeList = [OpenMode]</span></li><li><span class="v">Mode = write|compressed|cooked</span></li><li><span class="v">RetValue = {ok,TarDescriptor}|{error,{Name,Reason}}</span></li><li><span class="v">TarDescriptor = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Creates a tar file for writing (any existing file with the same
name is truncated).</p><p>By convention, the name of a tar file is to end in "<strong>.tar</strong>".
To abide to the convention, add "<strong>.tar</strong>" to the name.</p><p>Except for the <strong>write</strong> atom, the following atoms
can be added to <strong>OpenModeList</strong>:</p><dl><dt><strong>compressed</strong></dt><dd> <p>The entire tar file is compressed, as if it has been run
through the <strong>gzip</strong> program. To abide to the convention
that a compressed tar file is to end in "<strong>.tar.gz</strong>" or
"<strong>.tgz</strong>", add the appropriate extension.</p> </dd><dt><strong>cooked</strong></dt><dd> <p>By default, the tar file is opened in <strong>raw</strong> mode, which is
faster but does not allow a remote (Erlang) file server to be
used. Adding <strong>cooked</strong> to the mode list overrides the
default and opens the tar file without option <strong>raw</strong>.</p> </dd></dl><p>To add one file at the time into an opened tar file, use function
<a href="#add/3">add/3</a>. When you are
finished adding files, use function <a href="#close/1">close/1</a> to close the tar file.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>The <strong>TarDescriptor</strong> term is not a file descriptor. You are
advised not to rely on the specific contents of this term, as it
can change in future Erlang/OTP releases when more features are
added to this module..</p></div><h3>table(Name) -&gt; RetValue</h3><p>Retrieve the name of all files in a tar file.</p><ul><li><span class="v">Name = filename()|{binary,binary()}|{file,file_descriptor()}</span></li><li><span class="v">RetValue = {ok,[string()]}|{error,{Name,Reason}}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retrieves the names of all files in the tar file <strong>Name</strong>.</p><h3>table(Name, Options)</h3><p>Retrieve name and information of all files in a tar file. </p><ul><li><span class="v">Name = filename()|{binary,binary()}|{file,file_descriptor()}</span></li></ul><p>Retrieves the names of all files in the tar file <strong>Name</strong>.</p><h3>t(Name)</h3><p>Print the name of each file in a tar file.</p><ul><li><span class="v">Name = filename()|{binary,binary()}|{file,file_descriptor()}</span></li></ul><p>Prints the names of all files in the tar file <strong>Name</strong> to the
Erlang shell (similar to "<strong>tart</strong>").</p><h3>tt(Name)</h3><p>Print name and information for each file in a tar file. </p><ul><li><span class="v">Name = filename()|{binary,binary()}|{file,file_descriptor()}</span></li></ul><p>Prints names and information about all files in the tar file
<strong>Name</strong> to the Erlang shell (similar to "<strong>tartv</strong>").</p><h2>ets</h2><p>Built-in term storage.</p><p>This module is an interface to the Erlang built-in term storage
BIFs. These provide the ability to store very large quantities of
data in an Erlang runtime system, and to have constant access
time to the data. (In the case of <strong>ordered_set</strong>, see below,
access time is proportional to the logarithm of the number of
stored objects.)Data is organized as a set of dynamic tables, which can store
tuples. Each table is created by a process. When the process
terminates, the table is automatically destroyed. Every table has
access rights set at creation.Tables are divided into four different types, <strong>set</strong>,
<strong>ordered_set</strong>, <strong>bag</strong>, and <strong>duplicate_bag</strong>.
A <strong>set</strong> or <strong>ordered_set</strong> table can only have one object
associated with each key. A <strong>bag</strong> or <strong>duplicate_bag</strong> table can
have many objects associated with each key.<a name="max_ets_tables"></a>Notice that there is no automatic garbage collection for tables.
Even if there are no references to a table from any process, it
is not automatically destroyed unless the owner process
terminates. To destroy a table explicitly, use function
<a href="#delete/1">delete/1</a>.
The default owner is the process that created the
table. To transfer table ownership at process termination, use
option <a href="#heir">heir</a> or call
<a href="#give_away/3">give_away/3</a>.Some implementation details:<ul><li><p>In the current implementation, every object insert and
look-up operation results in a copy of the object.</p></li><li><p><strong>'$end_of_table'</strong> is not to be used as a key, as
this atom is used to mark the end of the table when using functions
<a href="#first/1">first/1</a> and
<a href="#next/2">next/2</a>.</p></li></ul>Notice the subtle difference between
<em>matching</em> and <em>comparing equal</em>, which is
demonstrated by table types <strong>set</strong> and <strong>ordered_set</strong>:<ul><li> <p>Two Erlang terms <strong>match</strong> if they are of
the same type and have the same value, so that <strong>1</strong> matches
<strong>1</strong>, but not <strong>1.0</strong> (as <strong>1.0</strong> is a <strong>float()</strong>
and not an <strong>integer()</strong>).</p> </li><li> <p>Two Erlang terms <em>compare equal</em>
if they either are of the same type and value, or if
both are numeric types and extend to the same value, so that
<strong>1</strong> compares equal to both <strong>1</strong> and <strong>1.0</strong>.</p> </li><li> <p>The <strong>ordered_set</strong> works on the <em>Erlang term order</em> and
no defined order exists between an <strong>integer()</strong> and a
<strong>float()</strong> that extends to the same value. Hence the key
<strong>1</strong> and the key <strong>1.0</strong> are regarded as equal in an
<strong>ordered_set</strong> table.</p> </li></ul></p><h3>Failure</h3><p>The functions in this module exits with reason
<strong>badarg</strong> if any argument has the wrong format, if the
table identifier is invalid, or if the operation is denied because of
table access rights (<a href="#protected">protected</a>
or <a href="#private">private</a>).</p><a name="concurrency"></a><h3>Concurrency</h3><p>This module provides some limited support for concurrent access.
All updates to single objects are guaranteed to be both <em>atomic</em>
and <em>isolated</em>. This means that an updating operation to
a single object either succeeds or fails completely without any
effect (atomicity) and that
no intermediate results of the update can be seen by other
processes (isolation). Some functions that update many objects
state that they even guarantee atomicity and isolation for the entire
operation. In database terms the isolation level can be seen as
"serializable", as if all isolated operations are carried out serially,
one after the other in a strict order.</p><a name="traversal"></a><h3>Table traversal</h3><p>There are different ways to traverse through the objects of a table.</p><ul><li><p><em>Single-step</em> traversal one key at at time, using
<a href="#first/1">first/1</a>,
<a href="#next/2">next/2</a>,
<a href="#last/1">last/1</a> and
<a href="#prev/2">prev/2</a>.</p> </li><li><p>Search with simple <em>match patterns</em>, using
<a href="#match/1">match/1</a>,
<a href="#match_delete/2">match_delete/2</a> and
<a href="#match_object/1">match_object/1</a>.</p> </li><li><p>Search with more powerful <em>match specifications</em>, using
<a href="#select/1">select/1</a>,
<a href="#select_count/2">select_count/2</a>,
<a href="#select_delete/2">select_delete/2</a>,
<a href="#select_replace/2">select_replace/2</a> and
<a href="#select_reverse/1">select_reverse/1</a>.</p> </li><li><p><em>Table conversions</em>, using
<a href="#tab2file/2">tab2file/2</a> and
<a href="#tab2list/1">tab2list/1</a>.</p> </li></ul><p>None of these ways of table traversal will guarantee a consistent table snapshot
if the table is also updated during the traversal. Moreover, traversals not
done in a <em>safe</em> way, on tables where keys are inserted or deleted
during the traversal, may yield the following undesired effects:</p><ul><li><p>Any key may be missed.</p></li><li><p>Any key may be found more than once.</p></li><li><p>The traversal may fail with <strong>badarg</strong> exception if keys are deleted.</p> </li></ul><p>A table traversal is <em>safe</em> if either</p><ul><li><p>the table is of type <strong>ordered_set</strong>.</p> </li><li><p>the entire table traversal is done within one ETS function
call.</p> </li><li><p>function <a href="#safe_fixtable/2">safe_fixtable/2</a>
is used to keep the table fixated during the entire traversal.</p> </li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Even though the access of a single object is always guaranteed to be
<a href="#concurrency">atomic and isolated</a>, each traversal
through a table to find the next key is not done with such guarantees. This is often
not a problem, but may cause rare subtle "unexpected" effects if a concurrent
process inserts objects during a traversal. For example, consider one
process doing</p><pre>
ets:new(t, [ordered_set, named_table]),
ets:insert(t, {1}),
ets:insert(t, {2}),
ets:insert(t, {3}),
</pre><p>A concurrent call to <strong>ets:first(t)</strong>, done by another
process, may then in rare cases return <strong>2</strong> even though
<strong>2</strong> has never existed in the table ordered as the first key. In
the same way, a concurrent call to <strong>ets:next(t, 1)</strong> may return
<strong>3</strong> even though <strong>3</strong> never existed in the table
ordered directly after <strong>1</strong>.</p><p>Effects like this are improbable but possible. The probability will
further be reduced (if not vanish) if table option
<a href="#new_2_write_concurrency">new_2_write_concurrency</a>
is not enabled. This can also only be a potential concern for
<strong>ordered_set</strong> where the traversal order is defined.</p></div><p>Traversals using <strong>match</strong> and <strong>select</strong> functions may not need to
scan the entire table depending on how the key is specified. A match
pattern with a <em>fully bound key</em> (without any match variables) will
optimize the operation to a single key lookup without any table traversal
at all. For <strong>ordered_set</strong> a <em>partially bound key</em> will limit the
traversal to only scan a subset of the table based on term order. A
partially bound key is either a list or a tuple with a prefix that is fully
bound. Example:</p><pre>
1&gt; <span class="input">T = ets:new(t,[ordered_set]), ets:insert(T, {"555-1234", "John Smith"}).</span>
true
2&gt; <span class="input">%% Efficient search of all with area code 555</span>
2&gt; <span class="input">ets:match(T,{[$5,$5,$5,$- |'$1'],'$2'}).</span>
[["1234","John Smith"]]
</pre><a name="match_spec"></a><h3>Match Specifications</h3><p>Some of the functions use a <em>match specification</em>,
<strong>match_spec</strong>. For a brief explanation, see
<a href="#select/2">select/2</a>. For a detailed
description, see section <a href="./match_spec"> Match Specifications in Erlang</a> in ERTS User's Guide.</p><h2>Data Types</h2><span class="name">access</span><span class="name">continuation()</span><p>Opaque continuation used by <a href="#select/1">select/1</a>, <a href="#select_reverse/1">select_reverse/1</a>, <a href="#match/1">match/1</a>, and <a href="#match_object/1">match_object/1</a>.</p><span class="name">match_spec</span><p>A match specification, see above.</p><span class="name">comp_match_spec</span><p>A compiled match specification.</p><span class="name">match_pattern</span><span class="name">tab</span><span class="name">tid</span><p>A table identifier, as returned by
<a href="#new/2">new/2</a>.</p><span class="name">type</span><h2>Functions</h2><h3>all/0</h3><p>Return a list of all ETS tables.</p><p>Returns a list of all tables at the node. Named tables are
specified by their names, unnamed tables are specified by their
table identifiers.</p><p>There is no guarantee of consistency in the returned list. Tables
created or deleted by other processes "during" the <strong>ets:all()</strong>
call either are or are not included in the list. Only tables
created/deleted <em>before</em> <strong>ets:all()</strong> is called are
guaranteed to be included/excluded.</p><h3>delete/1</h3><p>Delete an entire ETS table.</p><p>Deletes the entire table <strong><span class="anno">Tab</span></strong>.</p><h3>delete/2</h3><p>Delete all objects with a specified key from an ETS table.</p><p>Deletes all objects with key <strong><span class="anno">Key</span></strong> from table
<strong><span class="anno">Tab</span></strong>.</p><h3>delete_all_objects/1</h3><p>Delete all objects in an ETS table.</p><p>Delete all objects in the ETS table <strong><span class="anno">Tab</span></strong>.
The operation is guaranteed to be
<a href="#concurrency">atomic and isolated</a>.</p><h3>delete_object/2</h3><p>Deletes a specific from an ETS table.</p><p>Delete the exact object <strong><span class="anno">Object</span></strong> from the
ETS table,
leaving objects with the same key but other differences
(useful for type <strong>bag</strong>). In a <strong>duplicate_bag</strong> table, all
instances of the object are deleted.</p><h3>file2tab/1</h3><p>Read an ETS table from a file.</p><p>Reads a file produced by <a href="#tab2file/2">tab2file/2</a> or 
<a href="#tab2file/3">tab2file/3</a> and
creates the corresponding table <strong><span class="anno">Tab</span></strong>.</p><p>Equivalent to <strong>file2tab(<span class="anno">Filename</span>, [])</strong>.</p><h3>file2tab/2</h3><p>Read an ETS table from a file.</p><p>Reads a file produced by <a href="#tab2file/2">tab2file/2</a> or <a href="#tab2file/3">tab2file/3</a> and creates the
corresponding table <strong><span class="anno">Tab</span></strong>.</p><p>The only supported option is <strong>{verify,boolean()}</strong>.
If verification is turned on (by specifying <strong>{verify,true}</strong>),
the function uses whatever information is present in the file to
assert that the information is not damaged. How this is done depends
on which <strong>extended_info</strong> was written using 
<a href="#tab2file/3">tab2file/3</a>.</p><p>If no <strong>extended_info</strong> is present in the file and
<strong>{verify,true}</strong> is specified, the number of objects
written is compared to the size of the original table when the
dump was started. This can make verification fail if the table was
<strong>public</strong> and objects were added or removed while the
table was dumped to file. To avoid this problem,
either do not verify files dumped while updated simultaneously
or use option <strong>{extended_info, [object_count]}</strong> to
<a href="#tab2file/3">tab2file/3</a>, which
extends the information in the file with the number of objects
written.</p><p>If verification is turned on and the file was written with
option <strong>{extended_info, [md5sum]}</strong>, reading the file
is slower and consumes radically more CPU time than otherwise.</p><p><strong>{verify,false}</strong> is the default.</p><h3>first/1</h3><p>Return the first key in an ETS table.</p><p>Returns the first key <strong><span class="anno">Key</span></strong> in table
<strong><span class="anno">Tab</span></strong>. For an <strong>ordered_set</strong> table, the first
key in Erlang term order is returned. For other
table types, the first key according to the internal
order of the table is returned. If the table is empty,
<strong>'$end_of_table'</strong> is returned.</p><p>To find subsequent keys in the table, use
<a href="#next/2">next/2</a>.</p><h3>foldl/3</h3><p>Fold a function over an ETS table.</p><p><strong><span class="anno">Acc0</span></strong> is returned if the table is empty.
This function is similar to
<a href="./lists#foldl/3">lists#foldl/3</a>.
The table elements are traversed in an unspecified order, except for
<strong>ordered_set</strong> tables, where they are traversed first to last.</p><p>If <strong><span class="anno">Function</span></strong> inserts objects into the table,
or another
process inserts objects into the table, those objects <em>can</em>
(depending on key ordering) be included in the traversal.</p><h3>foldr/3</h3><p>Fold a function over an ETS table.</p><p><strong><span class="anno">Acc0</span></strong> is returned if the table is empty.
This function is similar to
<a href="./lists#foldr/3">lists#foldr/3</a>.
The table elements are traversed in an unspecified order, except for
<strong>ordered_set</strong> tables, where they are traversed last to first.</p><p>If <strong><span class="anno">Function</span></strong> inserts objects into the table,
or another
process inserts objects into the table, those objects <em>can</em>
(depending on key ordering) be included in the traversal.</p><h3>from_dets/2</h3><p>Fill an ETS table with objects from a Dets table.</p><p>Fills an already created ETS table with the objects in the
already opened Dets table <strong><span class="anno">DetsTab</span></strong>.
Existing objects in the ETS table are kept unless
overwritten.</p><p>If any of the tables does not exist or the Dets table is
not open, a <strong>badarg</strong> exception is raised.</p><h3>fun2ms/1</h3><p>Pseudo function that transforms fun syntax to a match specification.</p><p>Pseudo function that by a <strong>parse_transform</strong> translates
<strong><span class="anno">LiteralFun</span></strong> typed as parameter in the function
call to a
<a href="#match_spec">match specification</a>.
With "literal" is meant that the fun must textually be written
as the parameter of the function, it cannot be held in a
variable that in turn is passed to the function.</p><p>The parse transform is provided in the <strong>ms_transform</strong>
module and the source <em>must</em> include
file <strong>ms_transform.hrl</strong> in STDLIB for this
pseudo function to work. Failing to include the hrl file in
the source results in a runtime error, not a compile
time error. The include file is easiest included by adding line
<strong>-include_lib("stdlib/include/ms_transform.hrl").</strong> to
the source file.</p><p>The fun is very restricted, it can take only a single
parameter (the object to match): a sole variable or a
tuple. It must use the <strong>is_</strong> guard tests.
Language constructs that have no representation in a match
specification (<strong>if</strong>, <strong>case</strong>, <strong>receive</strong>,
and so on) are not allowed.</p><p>The return value is the resulting match specification.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">ets:fun2ms(fun({M,N}) when N &gt; 3 -&gt; M end).</span>
[{{'$1','$2'},[{'&gt;','$2',3}],['$1']}]</pre><p>Variables from the environment can be imported, so that the
following works:</p><pre>
2&gt; <span class="input">X=3.</span>
3
3&gt; <span class="input">ets:fun2ms(fun({M,N}) when N &gt; X -&gt; M end).</span>
[{{'$1','$2'},[{'&gt;','$2',{const,3}}],['$1']}]</pre><p>The imported variables are replaced by match specification
<strong>const</strong> expressions, which is consistent with the
static scoping for Erlang funs. However, local or global function
calls cannot be in the guard or body of the fun. Calls to built-in
match specification functions is of course allowed:</p><pre>
4&gt; <span class="input">ets:fun2ms(fun({M,N}) when N &gt; X, my_fun(M) -&gt; M end).</span>
Error: fun containing local Erlang function calls
('my_fun' called in guard) cannot be translated into match_spec
{error,transform_error}
5&gt; <span class="input">ets:fun2ms(fun({M,N}) when N &gt; X, is_atom(M) -&gt; M end).</span>
[{{'$1','$2'},[{'&gt;','$2',{const,3}},{is_atom,'$1'}],['$1']}]</pre><p>As shown by the example, the function can be called
from the shell also. The fun must be literally in the call
when used from the shell as well.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If the <strong>parse_transform</strong> is not applied to a module that
calls this pseudo function, the call fails in runtime
(with a <strong>badarg</strong>). The <strong>ets</strong> module
exports a function with this name, but it is never to
be called except when using the function in the
shell. If the <strong>parse_transform</strong> is properly applied by
including header file <strong>ms_transform.hrl</strong>, compiled
code never calls the function, but the function call is
replaced by a literal match specification.</p></div><p>For more information, see <a href="./ms_transform#top">ms_transform#top</a>.</p><h3>give_away/3</h3><p>Change owner of a table.</p><p>Make process <strong><span class="anno">Pid</span></strong> the new owner of table
<strong><span class="anno">Tab</span></strong>. If successful, message
<strong>{'ETS-TRANSFER',<span class="anno">Tab</span>,FromPid,<span class="anno">GiftData</span>}</strong>
is sent to the new owner.</p><p>The process <strong><span class="anno">Pid</span></strong> must be alive, local, and not
already the owner of the table.
The calling process must be the table owner.</p><p>Notice that this function does not affect option
<a href="#heir">heir</a> of the table. A table
owner can, for example, set <strong>heir</strong> to itself, give the table
away, and then get it back if the receiver terminates.</p><h3>i/0</h3><p>Display information about all ETS tables on a terminal. </p><p>Displays information about all ETS tables on a terminal.</p><h3>i/1</h3><p>Browse an ETS table on a terminal.</p><p>Browses table <strong><span class="anno">Tab</span></strong> on a terminal.</p><h3>info/1</h3><p>Return information about an <strong>table</strong>.</p><p>Returns information about table <strong><span class="anno">Tab</span></strong> as a list of
tuples. If <strong><span class="anno">Tab</span></strong> has the correct type
for a table identifier, but does not refer to an existing ETS
table, <strong>undefined</strong> is returned. If <strong><span class="anno">Tab</span></strong> is
not of the correct type, a <strong>badarg</strong> exception is raised.</p><dl><dt><strong>{compressed, boolean()}</strong></dt><dd> <p>Indicates if the table is compressed.</p> </dd><dt><strong>{heir, pid() | none}</strong></dt><dd> <p>The pid of the heir of the table, or <strong>none</strong> if no heir
is set.</p> </dd><dt><strong>{id,</strong><a href="#type-tid">type-tid</a><strong>}</strong></dt><dd> <p>The table identifier.</p> </dd><dt><strong>{keypos, integer() &gt;= 1}</strong></dt><dd> <p>The key position.</p> </dd><dt><strong>{memory, integer() &gt;= 0</strong></dt><dd> <p>The number of words allocated to the table.</p> </dd><dt><strong>{name, atom()}</strong></dt><dd> <p>The table name.</p> </dd><dt><strong>{named_table, boolean()}</strong></dt><dd> <p>Indicates if the table is named.</p> </dd><dt><strong>{node, node()}</strong></dt><dd> <p>The node where the table is stored. This field is no longer
meaningful, as tables cannot be accessed from other nodes.</p> </dd><dt><strong>{owner, pid()}</strong></dt><dd> <p>The pid of the owner of the table.</p> </dd><dt><strong>{protection,</strong> <a href="#type-access">type-access</a><strong>}</strong></dt><dd> <p>The table access rights.</p> </dd><dt><strong>{size, integer() &gt;= 0</strong></dt><dd> <p>The number of objects inserted in the table.</p> </dd><dt><strong>{type,</strong> <a href="#type-type">type-type</a><strong>}</strong></dt><dd> <p>The table type.</p> </dd><dt><strong>{read_concurrency, boolean()}</strong></dt><dd> <p>Indicates whether the table uses <strong>read_concurrency</strong> or
not.</p> </dd><dt><strong>{write_concurrency, boolean()}</strong></dt><dd> <p>Indicates whether the table uses <strong>write_concurrency</strong>.</p> </dd></dl><h3>info/2</h3><p>Return the information associated with the specified item for an ETS table.</p><p>Returns the information associated with <strong>Item</strong> for table
<strong><span class="anno">Tab</span></strong>, or returns <strong>undefined</strong> if <strong>Tab</strong>
does not refer an existing ETS table. If
<strong><span class="anno">Tab</span></strong> is
not of the correct type, or if <strong><span class="anno">Item</span></strong> is not
one of the allowed values, a <strong>badarg</strong> exception is raised.</p><p>In addition to the <strong>{<span class="anno">Item</span>,<span class="anno">Value</span>}</strong>
pairs defined for <a href="#info/1">info/1</a>,
the following items are allowed:</p><ul><li> <p><strong>Item=fixed, Value=boolean()</strong></p> <p>Indicates if the table is fixed by any process.</p> </li><li> <p><a name="info_2_safe_fixed_monotonic_time"></a></p> <p><strong>Item=safe_fixed|safe_fixed_monotonic_time, Value={FixationTime,Info}|false</strong></p> <p>If the table is fixed using
<a href="#safe_fixtable/2">safe_fixtable/2</a>,
the call returns a tuple where <strong>FixationTime</strong> is the
last time when the table changed from unfixed to fixed.</p> <p>The format and value of <strong>FixationTime</strong> depends on
<strong>Item</strong>:</p> <dl><dt><strong>safe_fixed</strong></dt><dd> <p><strong>FixationTime</strong> corresponds to the result returned by
<a href="../erts/erlang#timestamp/0">erts/erlang#timestamp/0</a> at the time of fixation.
Notice that when the system uses single or multi
<a href="../erts/time_correction#Time_Warp_Modes">time warp modes</a> this can produce strange results, as
the use of <strong>safe_fixed</strong> is not
<a href="../erts/time_correction#Time_Warp_Safe_Code"> time warp safe</a>. Time warp safe code must use
<strong>safe_fixed_monotonic_time</strong> instead.</p> </dd><dt><strong>safe_fixed_monotonic_time</strong></dt><dd> <p><strong>FixationTime</strong> corresponds to the result returned by
<a href="../erts/erlang#monotonic_time/0">erts/erlang#monotonic_time/0</a> at the time of
fixation. The use of <strong>safe_fixed_monotonic_time</strong> is
<a href="../erts/time_correction#Time_Warp_Safe_Code"> time warp safe</a>.</p> </dd></dl> <p><strong>Info</strong> is a possibly empty lists of tuples
<strong>{Pid,RefCount}</strong>, one tuple for every process the
table is fixed by now. <strong>RefCount</strong> is the value
of the reference counter and it keeps track of how many times
the table has been fixed by the process.</p> <p>Table fixations are not limited to <a href="#safe_fixtable/2">safe_fixtable/2</a>. Temporary fixations may also
be done by for example <a href="#traversal">traversing functions</a> like <strong>select</strong> and <strong>match</strong>. Such
table fixations are automatically released before the
corresponding functions returns, but they may be seen by a
concurrent call to
<strong>ets:info(T,safe_fixed|safe_fixed_monotonic_time)</strong>.</p> <p>If the table is not fixed at all, the call returns <strong>false</strong>.</p> </li><li> <p><strong>Item=stats, Value=tuple()</strong></p> <p>Returns internal statistics about tables on an internal format
used by OTP test suites. Not for production use.</p></li></ul><h3>init_table/2</h3><p>Replace all objects of an ETS table.</p><p>Replaces the existing objects of table <strong><span class="anno">Tab</span></strong> with
objects created by calling the input function
<strong><span class="anno">InitFun</span></strong>,
see below. This function is provided for compatibility with
the <strong>dets</strong> module, it is not more efficient than filling
a table by using
<a href="#insert/2">insert/2</a>.</p><p>When called with argument <strong>read</strong>, the function
<strong><span class="anno">InitFun</span></strong> is assumed to return
<strong>end_of_input</strong> when
there is no more input, or <strong>{<span class="anno">Objects</span>, Fun}</strong>, where
<strong><span class="anno">Objects</span></strong> is a list of objects and <strong>Fun</strong> is a
new input function. Any other value <strong>Value</strong> is returned as an
error <strong>{error, {init_fun, Value}}</strong>. Each input function is
called exactly once, and if an error occur, the last
function is called with argument <strong>close</strong>, the reply
of which is ignored.</p><p>If the table type is <strong>set</strong> and more than one object
exists with a given key, one of the objects is
chosen. This is not necessarily the last object with the given
key in the sequence of objects returned by the input
functions. This holds also for duplicated
objects stored in tables of type <strong>bag</strong>.</p><h3>insert/2</h3><p>Insert an object into an ETS table.</p><p>Inserts the object or all of the objects in list
<strong><span class="anno">ObjectOrObjects</span></strong> into table
<strong><span class="anno">Tab</span></strong>.</p><ul><li> <p>If the table type is <strong>set</strong> and the key of the inserted
objects <em>matches</em> the key of any object in the table,
the old object is replaced.</p> </li><li> <p>If the table type is <strong>ordered_set</strong> and the key of the
inserted object <em>compares equal</em> to the key of any object
in the table, the old object is replaced.</p> </li><li> <p>If the list contains more than one object with
<em>matching</em> keys and the table type is <strong>set</strong>, one is
inserted, which one is not defined.
The same holds for table type <strong>ordered_set</strong>
if the keys <em>compare equal</em>.</p> </li></ul><p>The entire operation is guaranteed to be
<a href="#concurrency">atomic and isolated</a>,
even when a list of objects is inserted.</p><h3>insert_new/2</h3><p>Insert an object into an ETS table if the key is not already present.</p><p>Same as <a href="#insert/2">insert/2</a>
except that instead of overwriting objects with the same key
(for <strong>set</strong> or <strong>ordered_set</strong>) or adding more objects with
keys already existing in the table (for <strong>bag</strong> and
<strong>duplicate_bag</strong>), <strong>false</strong> is returned.</p><p>If <strong><span class="anno">ObjectOrObjects</span></strong> is a
list, the function checks <em>every</em> key before
inserting anything. Nothing is inserted unless
<em>all</em> keys present in the list are absent from the
table. Like <strong>insert/2</strong>, the entire operation is guaranteed to be
<a href="#concurrency">atomic and isolated</a>.</p><h3>is_compiled_ms/1</h3><p>Check if an Erlang term is the result of <strong>match_spec_compile</strong>.</p><p>Checks if a term is a valid
compiled <a href="#match_spec">match specification</a>.
The compiled match specification is an opaque datatype that
<em>cannot</em> be sent between Erlang nodes or be stored on
disk. Any attempt to create an external representation of a
compiled match specification results in an empty binary
(<strong>&lt;&lt;&gt;&gt;</strong>).</p><p><em>Examples:</em></p><p>The following expression yields <strong>true</strong>::</p><pre><code class="">
ets:is_compiled_ms(ets:match_spec_compile([{'_',[],[true]}])).</code></pre><p>The following expressions yield <strong>false</strong>, as variable
<strong>Broken</strong> contains a compiled match specification that has
passed through external representation:</p><pre><code class="">
MS = ets:match_spec_compile([{'_',[],[true]}]),
Broken = binary_to_term(term_to_binary(MS)),
ets:is_compiled_ms(Broken).</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The reason for not having an external representation of
compiled match specifications is performance. It can be
subject to change in future releases, while this interface
remains for backward compatibility.</p></div><h3>last/1</h3><p>Return the last key in an ETS table of type <strong>ordered_set</strong>.</p><p>Returns the last key <strong><span class="anno">Key</span></strong> according to Erlang
term order in table <strong>Tab</strong> of type <strong>ordered_set</strong>. For
other table types, the function is synonymous to
<a href="#first/1">first/1</a>.
If the table is empty, <strong>'$end_of_table'</strong> is returned.</p><p>To find preceding keys in the table, use
<a href="#prev/2">prev/2</a>.</p><h3>lookup/2</h3><p>Return all objects with a specified key in an ETS table. </p><p>Returns a list of all objects with key <strong><span class="anno">Key</span></strong> in
table <strong><span class="anno">Tab</span></strong>.</p><ul><li> <p>For tables of type <strong>set</strong>, <strong>bag</strong>, or
<strong>duplicate_bag</strong>, an object is returned only if the specified
key <em>matches</em> the key of the object in the table.</p> </li><li> <p>For tables of type <strong>ordered_set</strong>, an object is returned if
the specified key <em>compares equal</em> to the key of an object
in the table.</p> </li></ul><p>The difference is the same as between <strong>=:=</strong> and <strong>==</strong>.</p><p>As an example, one can insert an object with
<strong>integer()</strong> <strong>1</strong> as a key in an <strong>ordered_set</strong>
and get the object returned as a result of doing a <strong>lookup/2</strong>
with <strong>float()</strong> <strong>1.0</strong> as the key to search for.</p><p>For tables of type <strong>set</strong> or <strong>ordered_set</strong>,
the function returns either the empty list or a list with one
element, as there cannot be more than one object with the same
key. For tables of type <strong>bag</strong> or <strong>duplicate_bag</strong>, the
function returns a list of arbitrary length.</p><p>Notice that the time order of object insertions is preserved;
the first object inserted with the specified key is the first
in the resulting list, and so on.</p><p>Insert and lookup times in tables of type <strong>set</strong>,
<strong>bag</strong>, and <strong>duplicate_bag</strong> are constant, regardless
of the table size. For the <strong>ordered_set</strong>
datatype, time is proportional to the (binary) logarithm of
the number of objects.</p><h3>lookup_element/3</h3><p>Return the <strong>Pos</strong>:th element of all objects with a specified key in an ETS table.</p><p>For a table <strong><span class="anno">Tab</span></strong> of type <strong>set</strong> or
<strong>ordered_set</strong>, the function returns the
<strong><span class="anno">Pos</span></strong>:th
element of the object with key <strong><span class="anno">Key</span></strong>.</p><p>For tables of type <strong>bag</strong> or <strong>duplicate_bag</strong>,
the functions returns a list with the <strong><span class="anno">Pos</span></strong>:th
element of every object with key <strong><span class="anno">Key</span></strong>.</p><p>If no object with key <strong><span class="anno">Key</span></strong> exists, the
function exits with reason <strong>badarg</strong>.</p><p>The difference between <strong>set</strong>, <strong>bag</strong>, and
<strong>duplicate_bag</strong> on one hand, and <strong>ordered_set</strong> on
the other, regarding the fact that <strong>ordered_set</strong>
view keys as equal when they <em>compare equal</em>
whereas the other table types regard them equal only when
they <em>match</em>, holds for <strong>lookup_element/3</strong>.</p><h3>match/1</h3><p>Continues matching objects in an ETS table.</p><p>Continues a match started with
<a href="#match/3">match/3</a>. The next
chunk of the size specified in the initial <strong>match/3</strong>
call is returned together with a new <strong><span class="anno">Continuation</span></strong>,
which can be used in subsequent calls to this function.</p><p>When there are no more objects in the table, <strong>'$end_of_table'</strong>
is returned.</p><h3>match/2</h3><p>Match the objects in an ETS table against a pattern. </p><p>Matches the objects in table <strong><span class="anno">Tab</span></strong> against
pattern <strong><span class="anno">Pattern</span></strong>.</p><p>A pattern is a term that can contain:</p><ul><li>Bound parts (Erlang terms)</li><li><strong>'_'</strong> that matches any Erlang term</li><li>Pattern variables <strong>'$N'</strong>, where <strong>N</strong>=0,1,...</li></ul><p>The function returns a list with one element for each
matching object, where each element is an ordered list of
pattern variable bindings, for example:</p><pre>
6&gt; <span class="input">ets:match(T, '$1').</span> % Matches every object in table
[[{rufsen,dog,7}],[{brunte,horse,5}],[{ludde,dog,5}]]
7&gt; <span class="input">ets:match(T, {'_',dog,'$1'}).</span>
[[7],[5]]
8&gt; <span class="input">ets:match(T, {'_',cow,'$1'}).</span>
[]</pre><p>If the key is specified in the pattern, the match is very
efficient. If the key is not specified, that is, if it is a
variable or an underscore, the entire table must be searched.
The search time can be substantial if the table is very large.</p><p>For tables of type <strong>ordered_set</strong>, the result is in
the same order as in a <strong>first</strong>/<strong>next</strong> traversal.</p><h3>match/3</h3><p>Match the objects in an ETS table against a pattern and return part of the answers.</p><p>Works like <a href="#match/2">match/2</a>, 
but returns only a limited (<strong><span class="anno">Limit</span></strong>) number of
matching objects. Term <strong><span class="anno">Continuation</span></strong> can then
be used in subsequent calls to <a href="#match/1">match/1</a> to get the next chunk of matching
objects. This is a space-efficient way to work on objects in a
table, which is faster than traversing the table object
by object using
<a href="#first/1">first/1</a> and
<a href="#next/2">next/2</a>.</p><p>If the table is empty, <strong>'$end_of_table'</strong> is returned.</p><p>Use <a href="#safe_fixtable/2">safe_fixtable/2</a>
to guarantee <a href="#traversal">safe traversal</a>
for subsequent calls to <a href="#match/1">match/1</a>.</p><h3>match_delete/2</h3><p>Delete all objects that match a specified pattern from an ETS table.</p><p>Deletes all objects that match pattern <strong><span class="anno">Pattern</span></strong>
from table <strong><span class="anno">Tab</span></strong>. For a description of patterns,
see <a href="#match/2">match/2</a>.</p><h3>match_object/1</h3><p>Continues matching objects in an ETS table.</p><p>Continues a match started with
<a href="#match_object/3">match_object/3</a>.
The next chunk of the size specified in the initial
<strong>match_object/3</strong> call is returned together with a new
<strong><span class="anno">Continuation</span></strong>, which can be used in subsequent
calls to this function.</p><p>When there are no more objects in the table, <strong>'$end_of_table'</strong>
is returned.</p><h3>match_object/2</h3><p>Match the objects in an ETS table against a pattern. </p><p>Matches the objects in table <strong><span class="anno">Tab</span></strong> against
pattern <strong><span class="anno">Pattern</span></strong>. For a description of patterns,
see <a href="#match/2">match/2</a>.
The function returns a list of all objects that
match the pattern.</p><p>If the key is specified in the pattern, the match is very
efficient. If the key is not specified, that is, if it is a
variable or an underscore, the entire table must be searched.
The search time can be substantial if the table is very large.</p><p>For tables of type <strong>ordered_set</strong>, the result is in
the same order as in a <strong>first</strong>/<strong>next</strong> traversal.</p><h3>match_object/3</h3><p>Match the objects in an ETS table against a pattern and return part of the answers.</p><p>Works like <a href="#match_object/2">match_object/2</a>, but only returns a
limited (<strong><span class="anno">Limit</span></strong>) number of matching objects. Term
<strong><span class="anno">Continuation</span></strong> can then be used in subsequent
calls to <a href="#match_object/1">match_object/1</a> to get the next chunk of matching
objects. This is a space-efficient way to work on objects in a
table, which is faster than traversing the table object
by object using
<a href="#first/1">first/1</a> and
<a href="#next/2">next/2</a>.</p><p>If the table is empty, <strong>'$end_of_table'</strong> is returned.</p><p>Use <a href="#safe_fixtable/2">safe_fixtable/2</a>
to guarantee <a href="#traversal">safe traversal</a>
for subsequent calls to <a href="#match_object/1">match_object/1</a>.</p><h3>match_spec_compile/1</h3><p>Compile a match specification into its internal representation. </p><p>Transforms a
<a href="#match_spec">match specification</a> into an
internal representation that can be used in subsequent calls to
<a href="#match_spec_run/2">match_spec_run/2</a>.
The internal representation is
opaque and cannot be converted to external term format and
then back again without losing its properties (that is, it cannot
be sent to a process on another node and still remain a
valid compiled match specification, nor can it be stored on disk).
To check the validity of a compiled match specification, use
<a href="#is_compiled_ms/1">is_compiled_ms/1</a>.
</p><p>If term <strong><span class="anno">MatchSpec</span></strong> cannot be compiled (does not
represent a valid match specification), a <strong>badarg</strong> exception is
raised.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function has limited use in normal code. It is used by the
<a href="dets">dets</a> module
to perform the <strong>dets:select()</strong> operations.</p></div><h3>match_spec_run/2</h3><p>Perform matching, using a compiled match specification on a list of terms.</p><p>Executes the matching specified in a compiled
<a href="#match_spec">match specification</a> on a list
of terms. Term <strong><span class="anno">CompiledMatchSpec</span></strong> is to be
the result of a call to <a href="#match_spec_compile/1">match_spec_compile/1</a> and is hence the internal
representation of the match specification one wants to use.</p><p>The matching is executed on each element in <strong><span class="anno">List</span></strong>
and the function returns a list containing all results. If an element
in <strong><span class="anno">List</span></strong> does not match, nothing is returned
for that element. The length of the result list is therefore
equal or less than the length of parameter <strong><span class="anno">List</span></strong>.
</p><p><em>Example:</em></p><p>The following two calls give the same result (but certainly not the
same execution time):</p><pre><code class="">
Table = ets:new...
MatchSpec = ...
% The following call...
ets:match_spec_run(ets:tab2list(Table),
                   ets:match_spec_compile(MatchSpec)),
% ...gives the same result as the more common (and more efficient)
ets:select(Table, MatchSpec),</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function has limited use in normal code. It is used by the
<a href="dets">dets</a> module
to perform the <strong>dets:select()</strong> operations and by
Mnesia during transactions.</p></div><h3>member/2</h3><p>Tests for occurrence of a key in an ETS table.</p><p>Works like <a href="#lookup/2">lookup/2</a>,
but does not return the objects. Returns <strong>true</strong> if one or more
elements in the table has key <strong><span class="anno">Key</span></strong>, otherwise
<strong>false</strong>.</p><h3>new/2</h3><p>Create a new ETS table.</p><p>Creates a new table and returns a table identifier that can
be used in subsequent operations. The table identifier can be
sent to other processes so that a table can be shared between
different processes within a node.</p><p>Parameter <strong><span class="anno">Options</span></strong> is a list of options that
specifies table type, access rights, key position, and whether the
table is named. Default values are used for omitted options.
This means that not specifying any options (<strong>[]</strong>) is the same
as specifying <strong>[set, protected, {keypos,1}, {heir,none}, {write_concurrency,false}, {read_concurrency,false}]</strong>.</p><dl><dt><strong>set</strong></dt><dd> <p>The table is a <strong>set</strong> table: one key, one object,
no order among objects. This is the default table type.</p> </dd><dt><strong>ordered_set</strong></dt><dd> <p>The table is a <strong>ordered_set</strong> table: one key, one
object, ordered in Erlang term order, which is the order
implied by the &lt; and &gt; operators. Tables of this type
have a somewhat different behavior in some situations
than tables of other types. Most notably, the
<strong>ordered_set</strong> tables regard keys as equal when they
<em>compare equal</em>, not only when they match. This
means that to an <strong>ordered_set</strong> table, <strong>integer()</strong>
<strong>1</strong> and <strong>float()</strong> <strong>1.0</strong> are regarded as equal.
This also means that the
key used to lookup an element not necessarily
<em>matches</em> the key in the returned elements, if
<strong>float()</strong>'s and <strong>integer()</strong>'s are mixed in
keys of a table.</p> </dd><dt><strong>bag</strong></dt><dd> <p>The table is a <strong>bag</strong> table, which can have many
objects, but only one instance of each object, per key.</p> </dd><dt><strong>duplicate_bag</strong></dt><dd> <p>The table is a <strong>duplicate_bag</strong> table, which can have
many objects, including multiple copies of the same
object, per key.</p> </dd><dt><strong>public</strong></dt><dd> <p>Any process can read or write to the table.</p> <a name="protected"></a> </dd><dt><strong>protected</strong></dt><dd> <p>The owner process can read and write to the table. Other
processes can only read the table. This is the default
setting for the access rights.</p> <a name="private"></a> </dd><dt><strong>private</strong></dt><dd> <p>Only the owner process can read or write to the table.</p> </dd><dt><strong>named_table</strong></dt><dd> <p>If this option is present, the table is registered under its
<strong><span class="anno">Name</span></strong> which can then be used instead of the
table identifier in subsequent operations.</p> <p>The function will also return the <strong><span class="anno">Name</span></strong>
instead of the table identifier. To get the table identifier of a
named table, use
<a href="#whereis/1">whereis/1</a>.</p> </dd><dt><strong>{keypos,<span class="anno">Pos</span>}</strong></dt><dd> <p>Specifies which element in the stored tuples to use
as key. By default, it is the first element, that is,
<strong><span class="anno">Pos</span>=1</strong>. However, this is not always
appropriate. In
particular, we do not want the first element to be the
key if we want to store Erlang records in a table.</p> <p>Notice that any tuple stored in the table must have at
least <strong><span class="anno">Pos</span></strong> number of elements.</p> <a name="heir"></a> </dd><dt><strong>{heir,<span class="anno">Pid</span>,<span class="anno">HeirData</span>} | {heir,none}</strong></dt><dd> <p>Set a process as heir. The heir inherits the table if
the owner terminates. Message
<strong>{'ETS-TRANSFER',tid(),FromPid,<span class="anno">HeirData</span>}</strong> is
sent to the heir when that occurs. The heir must be a local
process. Default heir is <strong>none</strong>, which destroys the table
when the owner terminates.</p> <a name="new_2_write_concurrency"></a> </dd><dt><strong>{write_concurrency,boolean()}</strong></dt><dd> <p>Performance tuning. Defaults to <strong>false</strong>, in which case an
operation that
mutates (writes to) the table obtains exclusive access,
blocking any concurrent access of the same table until finished.
If set to <strong>true</strong>, the table is optimized to concurrent
write access. Different objects of the same table can be mutated
(and read) by concurrent processes. This is achieved to some
degree at the expense of memory consumption and the performance
of sequential access and concurrent reading.</p> <p>Option <strong>write_concurrency</strong> can be combined with option
<a href="#new_2_read_concurrency">new_2_read_concurrency</a>. You typically want to combine
these when large concurrent read bursts and large concurrent
write bursts are common; for more information, see option
<a href="#new_2_read_concurrency">new_2_read_concurrency</a>.</p> <p>Notice that this option does not change any guarantees about
<a href="#concurrency">atomicity and isolation</a>.
Functions that makes such promises over many objects (like
<a href="#insert/2">insert/2</a>)
gain less (or nothing) from this option.</p> <p>The memory consumption inflicted by both <strong>write_concurrency</strong>
and <strong>read_concurrency</strong> is a constant overhead per table for
<strong>set</strong>, <strong>bag</strong> and <strong>duplicate_bag</strong>. For
<strong>ordered_set</strong> the memory overhead depends on the number
of inserted objects and the amount of actual detected
concurrency in runtime. The memory overhead can be especially
large when both options are combined.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Prior to stdlib-3.7 (OTP-22.0) <strong>write_concurrency</strong> had no
effect on <strong>ordered_set</strong>.</p></div> <a name="new_2_read_concurrency"></a> </dd><dt><strong>{read_concurrency,boolean()}</strong></dt><dd> <p>Performance tuning. Defaults to <strong>false</strong>. When set to
<strong>true</strong>, the table is optimized for concurrent read
operations. When this option is enabled on a runtime system with
SMP support, read operations become much cheaper; especially on
systems with multiple physical processors. However, switching
between read and write operations becomes more expensive.</p> <p>You typically want to enable this option when concurrent read
operations are much more frequent than write operations, or when
concurrent reads and writes comes in large read and write bursts
(that is, many reads not interrupted by writes, and many
writes not interrupted by reads).</p> <p>You typically do
<em>not</em> want to enable this option when the common access
pattern is a few read operations interleaved with a few write
operations repeatedly. In this case, you would get a performance
degradation by enabling this option.</p> <p>Option <strong>read_concurrency</strong> can be combined with option
<a href="#new_2_write_concurrency">new_2_write_concurrency</a>.
You typically want to combine these when large concurrent
read bursts and large concurrent write bursts are common.</p> <a name="new_2_compressed"></a> </dd><dt><strong>compressed</strong></dt><dd> <p>If this option is present, the table data is stored in a more
compact format to consume less memory. However, it will make
table operations slower. Especially operations that need to
inspect entire objects, such as <strong>match</strong> and <strong>select</strong>,
get much slower. The key element is not compressed.</p> </dd></dl><h3>next/2</h3><p>Return the next key in an ETS table.</p><p>Returns the next key <strong><span class="anno">Key2</span></strong>, following key
<strong><span class="anno">Key1</span></strong> in table <strong><span class="anno">Tab</span></strong>. For table
type <strong>ordered_set</strong>, the next key in Erlang term order is
returned. For other table types, the next key
according to the internal order of the table is returned. If no
next key exists, <strong>'$end_of_table'</strong> is returned.</p><p>To find the first key in the table, use
<a href="#first/1">first/1</a>.</p><p>Unless a table of type <strong>set</strong>, <strong>bag</strong>, or
<strong>duplicate_bag</strong> is fixated using
<a href="#safe_fixtable/2">safe_fixtable/2</a>,
a call to <strong>next/2</strong> will fail if <strong><span class="anno">Key1</span></strong> no longer
exists in the table. For table type <strong>ordered_set</strong>, the function
always returns the next key after <strong><span class="anno">Key1</span></strong> in term
order, regardless whether <strong><span class="anno">Key1</span></strong> ever existed in the
table.</p><h3>prev/2</h3><p>Return the previous key in an ETS table of type <strong>ordered_set</strong>.</p><p>Returns the previous key <strong><span class="anno">Key2</span></strong>, preceding key
<strong><span class="anno">Key1</span></strong> according to Erlang term order in table
<strong><span class="anno">Tab</span></strong> of type <strong>ordered_set</strong>. For other
table types, the function is synonymous to
<a href="#next/2">next/2</a>.
If no previous key exists, <strong>'$end_of_table'</strong> is returned.</p><p>To find the last key in an <strong>ordered_set</strong> table, use
<a href="#last/1">last/1</a>.</p><h3>rename/2</h3><p>Rename a named ETS table.</p><p>Renames the named table <strong><span class="anno">Tab</span></strong> to the new name
<strong><span class="anno">Name</span></strong>. Afterwards, the old name cannot be used to
access the table. Renaming an unnamed table has no effect.</p><h3>repair_continuation/2</h3><p>Repair a continuation from <strong>ets:select/1 or ets:select/3</strong> that has passed through external representation.</p><p>Restores an opaque continuation returned by
<a href="#select/3">select/3</a> or
<a href="#select/1">select/1</a> if the
continuation has passed through external term format (been
sent between nodes or stored on disk).</p><p>The reason for this function is that continuation terms
contain compiled match specifications and therefore are
invalidated if converted to external term format. Given that the
original match specification is kept intact, the continuation can
be restored, meaning it can once again be used in subsequent
<strong>select/1</strong> calls even though it has been stored on
disk or on another node.</p><p><em>Examples:</em></p><p>The following sequence of calls fails:</p><pre><code class="">
T=ets:new(x,[]),
...
{_,C} = ets:select(T,ets:fun2ms(fun({N,_}=A)
when (N rem 10) =:= 0 -&gt;
A
end),10),
Broken = binary_to_term(term_to_binary(C)),
ets:select(Broken).</code></pre><p>The following sequence works, as the call to
<strong>repair_continuation/2</strong> reestablishes the (deliberately)
invalidated continuation <strong>Broken</strong>.</p><pre><code class="">
T=ets:new(x,[]),
...
MS = ets:fun2ms(fun({N,_}=A)
when (N rem 10) =:= 0 -&gt;
A
end),
{_,C} = ets:select(T,MS,10),
Broken = binary_to_term(term_to_binary(C)),
ets:select(ets:repair_continuation(Broken,MS)).</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is rarely needed in application code. It is used
by Mnesia to provide distributed <strong>select/3</strong>
and <strong>select/1</strong> sequences. A normal application would
either use Mnesia or keep the continuation from being
converted to external format.</p><p>The reason for not having an external representation of a
compiled match specification is performance. It can be subject to
change in future releases, while this interface remains
for backward compatibility.</p></div><h3>safe_fixtable/2</h3><p>Fix an ETS table for safe traversal.</p><p>Fixes a table of type <strong>set</strong>, <strong>bag</strong>, or
<strong>duplicate_bag</strong> for <a href="#traversal"> safe traversal</a> using
<a href="#first/1">first/1</a> &amp;
<a href="#next/2">next/2</a>,
<a href="#match/3">match/3</a> &amp;
<a href="#match/1">match/1</a>,
<a href="#match_object/3">match_object/3</a> &amp;
<a href="#match_object/1">match_object/1</a>, or
<a href="#select/3">select/3</a> &amp;
<a href="#select/1">select/1</a>.</p><p>A process fixes a table by calling
<strong>safe_fixtable(<span class="anno">Tab</span>, true)</strong>. The table remains
fixed until the process releases it by calling
<strong>safe_fixtable(<span class="anno">Tab</span>, false)</strong>, or until the process
terminates.</p><p>If many processes fix a table, the table remains fixed
until all processes have released it (or terminated).
A reference counter is kept on a per process basis, and N
consecutive fixes requires N releases to release the table.</p><p>When a table is fixed, a sequence of
<a href="#first/1">first/1</a> and
<a href="#next/2">next/2</a> calls are
guaranteed to succeed even if keys are removed during the
traversal. The keys for objects inserted or deleted during a
traversal may or may not be returned by <strong>next/2</strong> depending on
the ordering of keys within the table and if the key exists at the time
<strong>next/2</strong> is called.</p><p><em>Example:</em></p><pre><code class="">
clean_all_with_value(Tab,X) -&gt;
    safe_fixtable(Tab,true),
    clean_all_with_value(Tab,X,ets:first(Tab)),
    safe_fixtable(Tab,false).

clean_all_with_value(Tab,X,'$end_of_table') -&gt;
    true;
clean_all_with_value(Tab,X,Key) -&gt;
    case ets:lookup(Tab,Key) of
        [{Key,X}] -&gt;
            ets:delete(Tab,Key);
        _ -&gt;
            true
    end,
    clean_all_with_value(Tab,X,ets:next(Tab,Key)).</code></pre><p>Notice that deleted objects are not freed from a
fixed table until it has been released. If a process fixes a
table but never releases it, the memory used by the deleted
objects is never freed. The performance of operations on
the table also degrades significantly.</p><p>To retrieve information about which processes have fixed which
tables, use <a href="#info_2_safe_fixed_monotonic_time">info_2_safe_fixed_monotonic_time</a>. A system with
many processes fixing tables can need a monitor that sends alarms
when tables have been fixed for too long.</p><p>Notice that <strong>safe_fixtable/2</strong> is not necessary for table type
<strong>ordered_set</strong> and for traversals done by a single ETS function call,
like <a href="#select/2">select/2</a>.</p><h3>select/1</h3><p>Continue matching objects in an ETS table.</p><p>Continues a match started with
<a href="#select/3">select/3</a>. The next
chunk of the size specified in the initial <strong>select/3</strong>
call is returned together with a new <strong><span class="anno">Continuation</span></strong>,
which can be used in subsequent calls to this function.</p><p>When there are no more objects in the table, <strong>'$end_of_table'</strong>
is returned.</p><h3>select/2</h3><p>Match the objects in an ETS table against a match specification.</p><p>Matches the objects in table <strong><span class="anno">Tab</span></strong> using a
<a href="#match_spec">match specification</a>.
This is a more general call than
<a href="#match/2">match/2</a> and
<a href="#match_object/2">match_object/2</a>
calls. In its simplest form, the match specification is as
follows:</p><pre><code class="">
MatchSpec = [MatchFunction]
MatchFunction = {MatchHead, [Guard], [Result]}
MatchHead = "Pattern as in ets:match"
Guard = {"Guardtest name", ...}
Result = "Term construct"</code></pre><p>This means that the match specification is always a list of one or
more tuples (of arity 3). The first element of the tuple is to be
a pattern as described in
<a href="#match/2">match/2</a>.
The second element of the tuple is to
be a list of 0 or more guard tests (described below). The
third element of the tuple is to be a list containing a
description of the value to return. In almost all
normal cases, the list contains exactly one term that fully
describes the value to return for each object.</p><p>The return value is constructed using the "match variables"
bound in <strong>MatchHead</strong> or using the special match variables
<strong>'$_'</strong> (the whole matching object) and <strong>'$$'</strong> (all
match variables in a list), so that the following
<strong>match/2</strong> expression:</p><pre><code class="">
ets:match(Tab,{'$1','$2','$3'})</code></pre><p>is exactly equivalent to:</p><pre><code class="">
ets:select(Tab,[{{'$1','$2','$3'},[],['$$']}])</code></pre><p>And that the following <strong>match_object/2</strong> call:</p><pre><code class="">
ets:match_object(Tab,{'$1','$2','$1'})</code></pre><p>is exactly equivalent to</p><pre><code class="">
ets:select(Tab,[{{'$1','$2','$1'},[],['$_']}])</code></pre><p>Composite terms can be constructed in the <strong>Result</strong> part
either by simply writing a list, so that the following code:</p><pre><code class="">
ets:select(Tab,[{{'$1','$2','$3'},[],['$$']}])</code></pre><p>gives the same output as:</p><pre><code class="">
ets:select(Tab,[{{'$1','$2','$3'},[],[['$1','$2','$3']]}])</code></pre><p>That is, all the bound variables in the match head as a list. If
tuples are to be constructed, one has to write a tuple of
arity 1 where the single element in the tuple is the tuple
one wants to construct (as an ordinary tuple can be mistaken
for a <strong>Guard</strong>).</p><p>Therefore the following call:</p><pre><code class="">
ets:select(Tab,[{{'$1','$2','$1'},[],['$_']}])</code></pre><p>gives the same output as:</p><pre><code class="">
ets:select(Tab,[{{'$1','$2','$1'},[],[{{'$1','$2','$3'}}]}])</code></pre><p>This syntax is equivalent to the syntax used in the trace
patterns (see the
<a href="./dbg">runtime_tools/dbg</a>) module in Runtime_Tools.</p><p>The <strong>Guard</strong>s are constructed as tuples, where the first
element is the test name and the remaining elements
are the test parameters. To check for a specific type
(say a list) of the element bound to the match variable
<strong>'$1'</strong>, one would write the test as
<strong>{is_list, '$1'}</strong>. If the test fails, the object in the
table does not match and the next <strong>MatchFunction</strong> (if
any) is tried. Most guard tests present in Erlang can be
used, but only the new versions prefixed <strong>is_</strong> are
allowed (<strong>is_float</strong>, <strong>is_atom</strong>, and so on).</p><p>The <strong>Guard</strong> section can also contain logic and
arithmetic operations, which are written with the same syntax
as the guard tests (prefix notation), so that the following
guard test written in Erlang:</p><pre><code class="">
is_integer(X), is_integer(Y), X + Y &lt; 4711</code></pre><p>is expressed as follows (<strong>X</strong> replaced with <strong>'$1'</strong> and
<strong>Y</strong> with <strong>'$2'</strong>):</p><pre><code class="">
[{is_integer, '$1'}, {is_integer, '$2'}, {'&lt;', {'+', '$1', '$2'}, 4711}]</code></pre><p>For tables of type <strong>ordered_set</strong>, objects are visited
in the same order as in a <strong>first</strong>/<strong>next</strong>
traversal. This means that the match specification is
executed against objects with keys in the <strong>first</strong>/<strong>next</strong>
order and the corresponding result list is in the order of that
execution.</p><h3>select/3</h3><p>Match the objects in an ETS table against a match specification and return part of the answers.</p><p>Works like <a href="#select/2">select/2</a>,
but only returns a limited
(<strong><span class="anno">Limit</span></strong>) number of matching objects. Term
<strong><span class="anno">Continuation</span></strong> can then be used in subsequent
calls to <a href="#select/1">select/1</a>
to get the next chunk of matching
objects. This is a space-efficient way to work on objects in a
table, which is still faster than traversing the table object by
object using <a href="#first/1">first/1</a>
and <a href="#next/2">next/2</a>.</p><p>If the table is empty, <strong>'$end_of_table'</strong> is returned.</p><p>Use <a href="#safe_fixtable/2">safe_fixtable/2</a>
to guarantee <a href="#traversal">safe traversal</a>
for subsequent calls to <a href="#select/1">select/1</a>.</p><h3>select_count/2</h3><p>Match the objects in an ETS table against a match specification and return the number of objects for which the match specification returned <strong>true</strong>.</p><p>Matches the objects in table <strong><span class="anno">Tab</span></strong> using a
<a href="#match_spec">match specification</a>. If the
match specification returns <strong>true</strong> for an object, that object
considered a match and is counted. For any other result from
the match specification the object is not considered a match and is
therefore not counted.</p><p>This function can be described as a
<a href="#match_delete/2">match_delete/2</a>
function that does not delete any elements, but only counts them.</p><p>The function returns the number of objects matched.</p><h3>select_delete/2</h3><p>Match the objects in an ETS table against a match specification and delete objects where the match specification returns <strong>true</strong>.</p><p>Matches the objects in table <strong><span class="anno">Tab</span></strong> using a
<a href="#match_spec">match specification</a>. If the
match specification returns <strong>true</strong> for an object, that object is
removed from the table. For any other result from the match
specification the object is retained. This is a more general
call than the <a href="#match_delete/2">match_delete/2</a> call.</p><p>The function returns the number of objects
deleted from the table.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The match specification has to return the atom <strong>true</strong> if
the object is to be deleted. No other return value gets the
object deleted. So one cannot use the same match specification for
looking up elements as for deleting them.</p></div><h3>select_replace/2</h3><p>Match and replace objects atomically in an ETS table</p><p>Matches the objects in the table <strong><span class="anno">Tab</span></strong> using a
<a href="#match_spec">match specification</a>. For each
matched object, the existing object is replaced with
the match specification result.</p><p>The match-and-replace operation for each individual object is guaranteed to be
<a href="#concurrency">atomic and isolated</a>. The
<strong>select_replace</strong> table traversal as a whole, like all other select functions,
does not give such guarantees.</p><p>The match specifiction must be guaranteed to <em>retain the key</em>
of any matched object. If not, <strong>select_replace</strong> will fail with <strong>badarg</strong>
without updating any objects.</p><p>For the moment, due to performance and semantic constraints,
tables of type <strong>bag</strong> are not yet supported.</p><p>The function returns the total number of replaced objects.</p><p><em>Example</em></p><p>For all 2-tuples with a list in second position, add atom <strong>'marker'</strong> first in the list:</p><pre>
1&gt; <span class="input">T = ets:new(x,[]), ets:insert(T, {key, [1, 2, 3]}).</span>
true
2&gt; <span class="input">MS = ets:fun2ms(fun({K, L}) when is_list(L) -&gt; {K, [marker | L]} end).</span>
[{{'$1','$2'},[{is_list,'$2'}],[{{'$1',[marker|'$2']}}]}]
3&gt; <span class="input">ets:select_replace(T, MS).</span>
1
4&gt; <span class="input">ets:tab2list(T).</span>
[{key,[marker,1,2,3]}]
	</pre><p>A generic single object compare-and-swap operation:</p><pre>
[Old] = ets:lookup(T, Key),
New = update_object(Old),
Success = (1 =:= ets:select_replace(T, [{Old, [], [{const, New}]}])),
	</pre><h3>select_reverse/1</h3><p>Continue matching objects in an ETS table.</p><p>Continues a match started with <a href="#select_reverse/3">select_reverse/3</a>. For tables of type
<strong>ordered_set</strong>, the traversal of the table continues
to objects with keys earlier in the Erlang term order. The
returned list also contains objects with keys in reverse order.
For all other table types, the behavior is exactly that of
<a href="#select/1">select/1</a>.</p><p><em>Example:</em></p><pre><code class="">
1&gt; T = ets:new(x,[ordered_set]).
2&gt; [ ets:insert(T,{N}) || N &lt;- lists:seq(1,10) ].
...
3&gt; {R0,C0} = ets:select_reverse(T,[{'_',[],['$_']}],4).
...
4&gt; R0.
[{10},{9},{8},{7}]
5&gt; {R1,C1} = ets:select_reverse(C0).
...
6&gt; R1.
[{6},{5},{4},{3}]
7&gt; {R2,C2} = ets:select_reverse(C1).
...
8&gt; R2.
[{2},{1}]
9&gt; '$end_of_table' = ets:select_reverse(C2).
...</code></pre><h3>select_reverse/2</h3><p>Match the objects in an ETS table against a match specification.</p><p>Works like <a href="#select/2">select/2</a>,
but returns the list in reverse order for table type <strong>ordered_set</strong>.
For all other table types, the return value is identical to that of
<strong>select/2</strong>.</p><h3>select_reverse/3</h3><p>Match the objects in an ETS table against a match specification and return part of the answers.</p><p>Works like <a href="#select/3">select/3</a>,
but for table type <strong>ordered_set</strong>
traversing is done starting at the last object in
Erlang term order and moves to the first. For all other table
types, the return value is identical to that of <strong>select/3</strong>.</p><p>Notice that this is <em>not</em> equivalent to
reversing the result list of a <strong>select/3</strong> call, as the result list
is not only reversed, but also contains the last
<strong><span class="anno">Limit</span></strong>
matching objects in the table, not the first.</p><h3>setopts/2</h3><p>Set table options.</p><p>Sets table options. The only allowed option to be set after the
table has been created is
<a href="#heir">heir</a>.
The calling process must be the table owner.</p><h3>slot/2</h3><p>Return all objects in a specified slot of an ETS table. </p><p>This function is mostly for debugging purposes, Normally
<strong>first</strong>/<strong>next</strong> or <strong>last</strong>/<strong>prev</strong> are to be used
instead.</p><p>Returns all objects in slot <strong><span class="anno">I</span></strong> of table
<strong><span class="anno">Tab</span></strong>. A table can be traversed by repeatedly
calling the function,
starting with the first slot <strong><span class="anno">I</span>=0</strong> and
ending when <strong>'$end_of_table'</strong> is returned.
If argument <strong><span class="anno">I</span></strong> is out of range,
the function fails with reason <strong>badarg</strong>.</p><p>Unless a table of type <strong>set</strong>, <strong>bag</strong>, or
<strong>duplicate_bag</strong> is protected using
<a href="#safe_fixtable/2">safe_fixtable/2</a>,
a traversal can fail if
concurrent updates are made to the table. For table type
<strong>ordered_set</strong>, the function returns a list containing
object <strong><span class="anno">I</span></strong> in Erlang term order.</p><h3>tab2file/2</h3><p>Dump an ETS table to a file.</p><p>Dumps table <strong><span class="anno">Tab</span></strong> to file
<strong><span class="anno">Filename</span></strong>.</p><p>Equivalent to
<strong>tab2file(<span class="anno">Tab</span>, <span class="anno">Filename</span>,[])</strong></p><h3>tab2file/3</h3><p>Dump an ETS table to a file.</p><p>Dumps table <strong><span class="anno">Tab</span></strong> to file
<strong><span class="anno">Filename</span></strong>.</p><p>When dumping the table, some information about the table
is dumped to a header at the beginning of the dump. This
information contains data about the table type,
name, protection, size, version, and if it is a named table. It
also contains notes about what extended information is added
to the file, which can be a count of the objects in the file
or a MD5 sum of the header and records in the file.</p><p>The size field in the header might not correspond to the
number of records in the file if the table is public
and records are added or removed from the table during
dumping. Public tables updated during dump, and that one wants
to verify when reading, needs at least one field of extended
information for the read verification process to be reliable
later.</p><p>Option <strong>extended_info</strong> specifies what extra
information is written to the table dump:</p><dl><dt><strong>object_count</strong></dt><dd> <p>The number of objects written to the file is
noted in the file footer, so file truncation can be
verified even if the file was updated during dump.</p> </dd><dt><strong>md5sum</strong></dt><dd> <p>The header and objects in the file are checksummed using
the built-in MD5 functions. The MD5 sum of all objects is
written in the file footer, so that verification while reading
detects the slightest bitflip in the file data. Using this
costs a fair amount of CPU time.</p> </dd></dl><p>Whenever option <strong>extended_info</strong> is used, it
results in a file not readable by versions of ETS before
that in STDLIB 1.15.1</p><p>If option <strong>sync</strong> is set to <strong>true</strong>, it ensures that
the content of the file is written to the disk before
<strong>tab2file</strong> returns. Defaults to <strong>{sync, false}</strong>.</p><h3>tab2list/1</h3><p>Return a list of all objects in an ETS table.</p><p>Returns a list of all objects in table <strong><span class="anno">Tab</span></strong>.</p><h3>tabfile_info/1</h3><p>Return a list of all objects in an ETS table.</p><p>Returns information about the table dumped to file by
<a href="#tab2file/2">tab2file/2</a> or 
<a href="#tab2file/3">tab2file/3</a>.</p><p>The following items are returned:</p><dl><dt><strong>name</strong></dt><dd> <p>The name of the dumped table. If the table was a
named table, a table with the same name cannot exist when the
table is loaded from file with 
<a href="#file2tab/2">file2tab/2</a>.
If the table is
not saved as a named table, this field has no significance
when loading the table from file.</p> </dd><dt><strong>type</strong></dt><dd> <p>The ETS type of the dumped table (that is, <strong>set</strong>,
<strong>bag</strong>, <strong>duplicate_bag</strong>, or <strong>ordered_set</strong>). This
type is used when loading the table again.</p> </dd><dt><strong>protection</strong></dt><dd> <p>The protection of the dumped table (that is, <strong>private</strong>,
<strong>protected</strong>, or <strong>public</strong>). A table loaded from the
file gets the same protection.</p> </dd><dt><strong>named_table</strong></dt><dd> <p><strong>true</strong> if the table was a named table when dumped
to file, otherwise <strong>false</strong>. Notice that when a named table
is loaded from a file, there cannot exist a table in the
system with the same name.</p> </dd><dt><strong>keypos</strong></dt><dd> <p>The <strong>keypos</strong> of the table dumped to file, which
is used when loading the table again.</p> </dd><dt><strong>size</strong></dt><dd> <p>The number of objects in the table when the table dump
to file started. For a <strong>public</strong> table, this number
does not need to correspond to the number of objects saved to
the file, as objects can have been added or deleted by another
process during table dump.</p> </dd><dt><strong>extended_info</strong></dt><dd> <p>The extended information written in the file footer to
allow stronger verification during table loading from file, as
specified to <a href="#tab2file/3">tab2file/3</a>. Notice that this
function only tells <em>which</em> information is present, not
the values in the file footer. The value is a list containing one
or more of the atoms <strong>object_count</strong> and <strong>md5sum</strong>.</p> </dd><dt><strong>version</strong></dt><dd> <p>A tuple <strong>{<span class="anno">Major</span>,<span class="anno">Minor</span>}</strong>
containing the major and
minor version of the file format for ETS table dumps. This
version field was added beginning with STDLIB 1.5.1.
Files dumped with older versions return <strong>{0,0}</strong> in this
field.</p> </dd></dl><p>An error is returned if the file is inaccessible,
badly damaged, or not produced with
<a href="#tab2file/2">tab2file/2</a> or
<a href="#tab2file/3">tab2file/3</a>.</p><h3>table/1</h3><h3>table/2</h3><p>Return a QLC query handle.</p><p>Returns a Query List
Comprehension (QLC) query handle. The
<a href="qlc">qlc</a> module provides
a query language aimed mainly at Mnesia, but ETS
tables, Dets tables,
and lists are also recognized by QLC as sources of
data. Calling <strong>table/1,2</strong> is the means to make the
ETS table <strong>Tab</strong> usable to QLC.</p><p>When there are only simple restrictions on the key position,
QLC uses <a href="#lookup/2">lookup/2</a>
to look up the keys. When
that is not possible, the whole table is traversed.
Option <strong>traverse</strong> determines how this is done:</p><dl><dt><strong>first_next</strong></dt><dd> <p>The table is traversed one key at a time by calling
<a href="#first/1">first/1</a> and
<a href="#next/2">next/2</a>.</p> </dd><dt><strong>last_prev</strong></dt><dd> <p>The table is traversed one key at a time by calling
<a href="#last/1">last/1</a> and
<a href="#prev/2">prev/2</a>.</p> </dd><dt><strong>select</strong></dt><dd> <p>The table is traversed by calling
<a href="#select/3">select/3</a> and
<a href="#select/1">select/1</a>.
Option <strong>n_objects</strong> determines the number of objects
returned (the third argument of <strong>select/3</strong>); the
default is to return <strong>100</strong> objects at a time. The
<a href="#match_spec">match specification</a> (the
second argument of <strong>select/3</strong>) is assembled by QLC: simple
filters are translated into equivalent match specifications
while more complicated filters must be applied to all
objects returned by <strong>select/3</strong> given a match specification
that matches all objects.</p> </dd><dt><strong>{select, <span class="anno">MatchSpec</span>}</strong></dt><dd> <p>As for <strong>select</strong>, the table is traversed by calling
<a href="#select/3">select/3</a> and
<a href="#select/1">select/1</a>.
The difference is that the match specification is explicitly
specified. This is how to state match specifications that cannot
easily be expressed within the syntax provided by QLC.</p> </dd></dl><p><em>Examples:</em></p><p>An explicit match specification is here used to traverse the
table:</p><pre>
9&gt; <span class="input">true = ets:insert(Tab = ets:new(t, []), [{1,a},{2,b},{3,c},{4,d}]),</span>
<span class="input">MS = ets:fun2ms(fun({X,Y}) when (X &gt; 1) or (X &lt; 5) -&gt; {Y} end),</span>
<span class="input">QH1 = ets:table(Tab, [{traverse, {select, MS}}]).</span></pre><p>An example with an implicit match specification:</p><pre>
10&gt; <span class="input">QH2 = qlc:q([{Y} || {X,Y} &lt;- ets:table(Tab), (X &gt; 1) or (X &lt; 5)]).</span></pre><p>The latter example is equivalent to the former, which
can be verified using function <strong>qlc:info/1</strong>:</p><pre>
11&gt; <span class="input">qlc:info(QH1) =:= qlc:info(QH2).</span>
true</pre><p><strong>qlc:info/1</strong> returns information about a query handle,
and in this case identical information is returned for the
two query handles.</p><h3>take/2</h3><p>Return and remove all objects with a specified key from an ETS table.</p><p>Returns and removes a list of all objects with key
<strong><span class="anno">Key</span></strong> in table <strong><span class="anno">Tab</span></strong>.</p><p>The specified <strong><span class="anno">Key</span></strong> is used to identify the object
by either <em>comparing equal</em> the key of an object in an
<strong>ordered_set</strong> table, or <em>matching</em> in other types of
tables (for details on the difference, see
<a href="#lookup/2">lookup/2</a> and
<a href="#new/2">new/2</a>).</p><h3>test_ms/2</h3><p>Test a match specification for use in <strong>select/2</strong>. </p><p>This function is a utility to test a
<a href="#match_spec">match specification</a> used in
calls to <a href="#select/2">select/2</a>.
The function both tests <strong><span class="anno">MatchSpec</span></strong> for "syntactic"
correctness and runs the match specification against object
<strong><span class="anno">Tuple</span></strong>.</p><p>If the match specification is syntactically correct, the function
either returns <strong>{ok,<span class="anno">Result</span>}</strong>, where
<strong><span class="anno">Result</span></strong> is what would have been the result in a
real <strong>select/2</strong> call, or <strong>false</strong> if the match specification
does not match object <strong><span class="anno">Tuple</span></strong>.</p><p>If the match specification contains errors, tuple
<strong>{error, <span class="anno">Errors</span>}</strong> is returned,
where <strong><span class="anno">Errors</span></strong> is a list of natural language
descriptions of what was wrong with the match specification.</p><p>This is a useful debugging and test tool, especially when
writing complicated <strong>select/2</strong> calls.</p><p>See also: <a href="../erts/erlang#match_spec_test/3"> erlang:match_spec_test/3</a>.</p><h3>to_dets/2</h3><p>Fill a Dets table with objects from an ETS table. </p><p>Fills an already created/opened Dets table with the objects
in the already opened ETS table named <strong><span class="anno">Tab</span></strong>.
The Dets table is emptied before the objects are inserted.</p><h3>update_counter/3</h3><h3>update_counter/4</h3><h3>update_counter/3</h3><h3>update_counter/4</h3><h3>update_counter/3</h3><h3>update_counter/4</h3><p>Update a counter object in an ETS table.</p><ul><li>Tab</li></ul><ul><li>Key</li></ul><ul><li>UpdateOp</li></ul><ul><li>Pos</li></ul><ul><li>Threshold</li></ul><ul><li>SetValue</li></ul><ul><li>Default</li></ul><p>This function provides an efficient way to update one or more 
counters, without the trouble of having to look up an object, update 
the object by incrementing an element, and insert the resulting
object into the table again. The operation is guaranteed to be
<a href="#concurrency">atomic and isolated</a>.</p><p>This function destructively update the object with key
<strong><span class="anno">Key</span></strong> in table <strong><span class="anno">Tab</span></strong> by adding
<strong><span class="anno">Incr</span></strong> to the element at position
<strong><span class="anno">Pos</span></strong>. The new counter value is
returned. If no position is specified, the element directly
following key (<strong>&lt;keypos&gt;+1</strong>) is updated.</p><p>If a <strong><span class="anno">Threshold</span></strong> is specified, the counter is
reset to value <strong><span class="anno">SetValue</span></strong> if the following
conditions occur:</p><ul><li><p><strong><span class="anno">Incr</span></strong> is not negative (<strong>&gt;= 0</strong>) and
the result would be greater than (<strong>&gt;</strong>)
<strong><span class="anno">Threshold</span></strong>.</p> </li><li><p><strong><span class="anno">Incr</span></strong> is negative
(<strong>&lt; 0</strong>) and the result would be less than
(<strong>&lt;</strong>) <strong><span class="anno">Threshold</span></strong>.</p> </li></ul><p>A list of <strong><span class="anno">UpdateOp</span></strong> can be supplied to do many
update operations within the object.
The operations are carried out in the
order specified in the list. If the same counter position occurs 
more than once in the list, the corresponding counter is thus 
updated many times, each time based on the previous result.
The return value is a list of the new counter values from each 
update operation in the same order as in the operation list. If an 
empty list is specified, nothing is updated and an empty list is 
returned. If the function fails, no updates are done.</p><p>The specified <strong><span class="anno">Key</span></strong> is used to identify the object
by either <em>matching</em> the key of an object in a <strong>set</strong>
table, or <em>compare equal</em> to the key of an object in an
<strong>ordered_set</strong> table (for details on the difference, see 
<a href="#lookup/2">lookup/2</a> and 
<a href="#new/2">new/2</a>).</p><p>If a default object <strong><span class="anno">Default</span></strong> is specified,
it is used
as the object to be updated if the key is missing from the table. The
value in place of the key is ignored and replaced by the proper key
value. The return value is as if the default object had not been used,
that is, a single updated element or a list of them.</p><p>The function fails with reason <strong>badarg</strong> in the following
situations:</p><ul><li>The table type is not <strong>set</strong> or <strong>ordered_set</strong>.</li><li>No object with the correct key exists and no default object was supplied.</li><li>The object has the wrong arity.</li><li>The default object arity is smaller than <strong>&lt;keypos&gt;</strong>.</li><li>Any field from the default object that is updated is not an integer.</li><li>The element to update is not an integer.</li><li>The element to update is also the key.</li><li>Any of <strong><span class="anno">Pos</span></strong>, <strong><span class="anno">Incr</span></strong>, <strong><span class="anno">Threshold</span></strong>, or <strong><span class="anno">SetValue</span></strong> is not an integer.</li></ul><h3>update_element/3</h3><h3>update_element/3</h3><p>Update the <strong>Pos</strong>:th element of the object with a specified key in an ETS table.</p><ul><li>Tab</li></ul><ul><li>Key</li></ul><ul><li>Value</li></ul><ul><li>Pos</li></ul><p>This function provides an efficient way to update one or more 
elements within an object, without the trouble of having to look up, 
update, and write back the entire object.</p><p>This function destructively updates the object with key
<strong><span class="anno">Key</span></strong> in table <strong><span class="anno">Tab</span></strong>.
The element at position <strong><span class="anno">Pos</span></strong> is given
the value <strong><span class="anno">Value</span></strong>.</p><p>A list of <strong>{<span class="anno">Pos</span>,<span class="anno">Value</span>}</strong> can be
supplied to update many
elements within the same object. If the same position occurs more 
than once in the list, the last value in the list is written. If
the list is empty or the function fails, no updates are done.
The function is also atomic in the sense that other processes 
can never see any intermediate results.</p><p>Returns <strong>true</strong> if an object with key <strong><span class="anno">Key</span></strong>
is found, otherwise <strong>false</strong>.</p><p>The specified <strong><span class="anno">Key</span></strong> is used to identify the object
by either <em>matching</em> the key of an object in a <strong>set</strong>
table, or <em>compare equal</em> to the key of an object in an
<strong>ordered_set</strong> table (for details on the difference, see
<a href="#lookup/2">lookup/2</a> and 
<a href="#new/2">new/2</a>).</p><p>The function fails with reason <strong>badarg</strong> in the following
situations:</p><ul><li>The table type is not <strong>set</strong> or <strong>ordered_set</strong>.</li><li><strong><span class="anno">Pos</span></strong> &lt; 1.</li><li><strong><span class="anno">Pos</span></strong> &gt; object arity.</li><li>The element to update is also the key.</li></ul><h3>whereis/1</h3><p>Retrieves the tid() of a named table.</p><p>This function returns the
<a href="#type-tid">type-tid</a> of the named table
identified by <strong><span class="anno">TableName</span></strong>, or <strong>undefined</strong> if
no such table exists. The <strong>tid()</strong> can be used in place of the
table name in all operations, which is slightly faster since the name
does not have to be resolved on each call.</p><p>If the table is deleted, the <strong>tid()</strong> will be invalid even if
another named table is created with the same name.</p><h2>file_sorter</h2><p>File sorter.</p><p>This module contains functions for sorting terms on files, merging
already sorted files, and checking files for sortedness. Chunks
containing binary terms are read from a sequence of files, sorted
internally in memory and written on temporary files, which are
merged producing one sorted file as output. Merging is provided
as an optimization; it is faster when the files are already
sorted, but it always works to sort instead of merge.On a file, a term is represented by a header and a binary. Two
options define the format of terms on files:<dl><dt><strong>{header, HeaderLength}</strong></dt><dd> <p><strong>HeaderLength</strong> determines the
number of bytes preceding each binary and containing the
length of the binary in bytes. Defaults to 4. The order of the
header bytes is defined as follows: if <strong>B</strong> is a binary
containing a header only, size <strong>Size</strong> of the binary
is calculated as
<strong>&lt;&lt;Size:HeaderLength/unit:8&gt;&gt; = B</strong>.</p> </dd><dt><strong>{format, Format}</strong></dt><dd> <p>Option <strong>Format</strong> determines the
function that is applied to binaries to create the
terms to be sorted. Defaults to
<strong>binary_term</strong>, which is equivalent to
<strong>funbinary_to_term/1</strong>. Value <strong>binary</strong> is
equivalent to <strong>fun(X) -&gt; X end</strong>, which means that the
binaries are sorted as they are. This is the fastest
format. If <strong>Format</strong> is <strong>term</strong>, <strong>io:read/2</strong> is
called to read terms. In that case, only the default value of
option <strong>header</strong> is allowed.</p> <p>Option <strong>format</strong> also determines what is written to the
sorted output file: if
<strong>Format</strong> is <strong>term</strong>, then <strong>io:format/3</strong> is called
to write each term, otherwise the binary prefixed by a header
is written. Notice that the binary written is the same binary
that was read; the results of applying function <strong>Format</strong>
are thrown away when the terms have been sorted.
Reading and writing terms using the <strong>io</strong> module
is much slower than reading and writing binaries.</p> </dd></dl>Other options are:<dl><dt><strong>{order, Order}</strong></dt><dd> <p>The default is to sort terms in
ascending order, but that can be changed by value
<strong>descending</strong> or by specifying an ordering function <strong>Fun</strong>.
An ordering function is antisymmetric, transitive, and total.
<strong>Fun(A,B)</strong> is to return <strong>true</strong> if <strong>A</strong>
comes before <strong>B</strong> in the ordering, otherwise <strong>false</strong>.
An example of a typical ordering function is less than or equal
to, <strong>=&lt;/2</strong>. Using an ordering function slows down the sort
considerably. Functions <strong>keysort</strong>, <strong>keymerge</strong> and
<strong>keycheck</strong> do not accept ordering functions.</p> </dd><dt><strong>{unique, boolean()}</strong></dt><dd> <p>When sorting or merging files,
only the first of a sequence of terms that compare equal (<strong>==</strong>)
is output if this option is set to <strong>true</strong>. Defaults
to <strong>false</strong>, which implies that all terms that
compare equal are output. When checking files for
sortedness, a check that no pair of consecutive terms
compares equal is done if this option is set to <strong>true</strong>.</p> </dd><dt><strong>{tmpdir, TempDirectory}</strong></dt><dd> <p>The directory where
temporary files are put can be chosen explicitly. The
default, implied by value <strong>""</strong>, is to put temporary
files on the same directory as the sorted output file. If
output is a function (see below), the directory returned by
<strong>file:get_cwd()</strong> is used instead. The names of
temporary files are derived from the Erlang nodename
(<strong>node()</strong>), the process identifier of the current Erlang
emulator (<strong>os:getpid()</strong>), and a unique integer
(<strong>erlang:unique_integer([positive])</strong>). A typical name is
<strong>fs_mynode@myhost_1763_4711.17</strong>, where
<strong>17</strong> is a sequence number. Existing files are
overwritten. Temporary files are deleted unless some
uncaught <strong>EXIT</strong> signal occurs.</p> </dd><dt><strong>{compressed, boolean()}</strong></dt><dd> <p>Temporary files and the output file can be compressed. Defaults
<strong>false</strong>, which implies that written files are not
compressed. Regardless of the value of option <strong>compressed</strong>,
compressed files can always be read. Notice that
reading and writing compressed files are significantly slower
than reading and writing uncompressed files.</p> </dd><dt><strong>{size, Size}</strong></dt><dd> <p>By default about 512*1024 bytes read from files are sorted
internally. This option is rarely needed.</p> </dd><dt><strong>{no_files, NoFiles}</strong></dt><dd> <p>By default 16 files are merged at a time. This option is rarely
needed.</p> </dd></dl>As an alternative to sorting files, a function of one argument
can be specified as input. When called with argument <strong>read</strong>,
the function is assumed to return either of the following:<ul><li> <p><strong>end_of_input</strong> or <strong>{end_of_input, Value}}</strong> when there
is no more input (<strong>Value</strong> is explained below).</p> </li><li> <p><strong>{Objects, Fun}</strong>, where <strong>Objects</strong> is a list of binaries
or terms depending on the format, and <strong>Fun</strong> is a new input
function.</p> </li></ul>Any other value is immediately returned as value of the current call
to <strong>sort</strong> or <strong>keysort</strong>. Each input function is
called exactly once. If an error occurs, the last
function is called with argument <strong>close</strong>, the reply of
which is ignored.A function of one argument can be specified as output. The results
of sorting or merging the input is collected in a non-empty
sequence of variable length lists of binaries or terms depending
on the format. The output function is called with one list at a
time, and is assumed to return a new output function. Any other
return value is immediately returned as value of the current
call to the sort or merge function. Each output function is
called exactly once. When some output function has been applied
to all of the results or an error occurs, the last function is
called with argument <strong>close</strong>, and the reply is returned
as value of the current call to the sort or merge function.If a function is specified as input and the last input function
returns <strong>{end_of_input, Value}</strong>, the function specified as output
is called with argument <strong>{value, Value}</strong>. This makes it
easy to initiate the sequence of output functions with a value
calculated by the input functions.As an example, consider sorting the terms on a disk log file.
A function that reads chunks from the disk log and returns a
list of binaries is used as input. The results are collected in
a list of terms.<pre>
sort(Log) -&gt;
    {ok, _} = disk_log:open([{name,Log}, {mode,read_only}]),
    Input = input(Log, start),
    Output = output([]),
    Reply = file_sorter:sort(Input, Output, {format,term}),
    ok = disk_log:close(Log),
    Reply.

input(Log, Cont) -&gt;
    fun(close) -&gt;
            ok;
       (read) -&gt;
            case disk_log:chunk(Log, Cont) of
                {error, Reason} -&gt;
                    {error, Reason};
                {Cont2, Terms} -&gt;
                    {Terms, input(Log, Cont2)};
                {Cont2, Terms, _Badbytes} -&gt;
                    {Terms, input(Log, Cont2)};
                eof -&gt;
                    end_of_input
            end
    end.

output(L) -&gt;
    fun(close) -&gt;
            lists:append(lists:reverse(L));
       (Terms) -&gt;
            output([Terms | L])
    end.</pre>For more examples of functions as input and output, see
the end of the <strong>file_sorter</strong> module; the <strong>term</strong>
format is implemented with functions.The possible values of <strong>Reason</strong> returned when an error
occurs are:<ul><li> <p><strong>bad_object</strong>, <strong>{bad_object, FileName}</strong> -
Applying the format function failed for some binary,
or the key(s) could not be extracted from some term.</p> </li><li> <p><strong>{bad_term, FileName}</strong> - <strong>io:read/2</strong> failed
to read some term.</p> </li><li> <p><strong>{file_error, FileName, file:posix()}</strong> - For an
explanation of <strong>file:posix()</strong>, see
<a href="./file">kernel/file</a>.</p> </li><li> <p><strong>{premature_eof, FileName}</strong> - End-of-file was
encountered inside some binary term.</p> </li></ul></p><h2>Data Types</h2><span class="name">file_name</span><span class="name">file_names</span><span class="name">i_command</span><span class="name">i_reply</span><span class="name">infun</span><span class="name">input</span><span class="name">input_reply</span><span class="name">o_command</span><span class="name">o_reply</span><span class="name">object</span><span class="name">outfun</span><span class="name">output</span><span class="name">output_reply</span><span class="name">value</span><span class="name">options</span><span class="name">option</span><span class="name">format</span><span class="name">format_fun</span><span class="name">header_length</span><span class="name">key_pos</span><span class="name">no_files</span><span class="name">order</span><span class="name">order_fun</span><span class="name">size</span><span class="name">tmp_directory</span><span class="name">reason</span><h2>Functions</h2><h3>check/1</h3><h3>check/2</h3><p>Check whether terms on files are sorted.</p><p>Checks files for sortedness. If a file is not sorted, the
first out-of-order element is returned. The first term on a
file has position 1.</p><p><strong>check(FileName)</strong> is equivalent to
<strong>check([FileName], [])</strong>.</p><h3>keycheck/2</h3><h3>keycheck/3</h3><p>Check whether terms on files are sorted by key.</p><p>Checks files for sortedness. If a file is not sorted, the
first out-of-order element is returned. The first term on a
file has position 1.</p><p><strong>keycheck(KeyPos, FileName)</strong> is equivalent
to <strong>keycheck(KeyPos, [FileName], [])</strong>.</p><h3>keymerge/3</h3><h3>keymerge/4</h3><p>Merge terms on files by key.</p><p>Merges tuples on files. Each input file is assumed to be
sorted on key(s).</p><p><strong>keymerge(KeyPos, FileNames, Output)</strong> is equivalent
to <strong>keymerge(KeyPos, FileNames, Output, [])</strong>.</p><h3>keysort/2</h3><p>Sort terms on files by key.</p><p>Sorts tuples on files.</p><p><strong>keysort(N, FileName)</strong> is
equivalent to <strong>keysort(N, [FileName], FileName)</strong>.</p><h3>keysort/3</h3><h3>keysort/4</h3><p>Sort terms on files by key.</p><p>Sorts tuples on files. The sort is performed on the
element(s) mentioned in <strong><span class="anno">KeyPos</span></strong>. If two
tuples compare equal (<strong>==</strong>) on one element, the next
element according to <strong><span class="anno">KeyPos</span></strong>
is compared. The sort is stable.</p><p><strong>keysort(N, Input, Output)</strong> is equivalent to
<strong>keysort(N, Input, Output, [])</strong>.</p><h3>merge/2</h3><h3>merge/3</h3><p>Merge terms on files.</p><p>Merges terms on files. Each input file is assumed to be
sorted.</p><p><strong>merge(FileNames, Output)</strong> is equivalent to
<strong>merge(FileNames, Output, [])</strong>.</p><h3>sort/1</h3><p>Sort terms on files.</p><p>Sorts terms on files.</p><p><strong>sort(FileName)</strong> is equivalent
to <strong>sort([FileName], FileName)</strong>.</p><h3>sort/2</h3><h3>sort/3</h3><p>Sort terms on files.</p><p>Sorts terms on files.</p><p><strong>sort(Input, Output)</strong> is
equivalent to <strong>sort(Input, Output, [])</strong>.</p><h2>filelib</h2><p>File utilities, such as wildcard matching of filenames.
</p><p>This module contains utilities on a higher level than the
<a href="./file">kernel/file</a> module.This module does not support "raw" filenames (that is, files whose
names do not comply with the expected encoding). Such files are ignored
by the functions in this module.For more information about raw filenames, see the
<a href="./file">kernel/file</a> module.</p><h2>Data Types</h2><span class="name">filename</span><span class="name">dirname</span><span class="name">dirname_all</span><span class="name">filename_all</span><span class="name">find_file_rule</span><span class="name">find_source_rule</span><h2>Functions</h2><h3>ensure_dir/1</h3><p>Ensure that all parent directories for a file or directory exist.</p><p>Ensures that all parent directories for the specified file or
directory name <strong><span class="anno">Name</span></strong>
exist, trying to create them if necessary.</p><p>Returns <strong>ok</strong> if all parent directories already exist
or can be created. Returns <strong>{error, <span class="anno">Reason</span>}</strong> if
some parent directory does not exist and cannot be created.</p><h3>file_size/1</h3><p>Return the size in bytes of a file.</p><p>Returns the size of the specified file.</p><h3>fold_files/5</h3><p>Fold over all files matching a regular expression.</p><p>Folds function <strong><span class="anno">Fun</span></strong> over all (regular) files
<strong><span class="anno">F</span></strong> in directory <strong><span class="anno">Dir</span></strong> that match
the regular expression <strong><span class="anno">RegExp</span></strong> (for a description
of the allowed regular expressions,
see the <a href="re">re</a> module).
If <strong><span class="anno">Recursive</span></strong> is <strong>true</strong>, all subdirectories
to <strong>Dir</strong>
are processed. The regular expression matching is only done on
the filename without the directory part.</p><p>If Unicode filename translation is in effect and the file
system is transparent, filenames that cannot be
interpreted as Unicode can be encountered, in which case the
<strong>fun()</strong> must be prepared to handle raw filenames
(that is, binaries). If the regular expression contains
codepoints &gt; 255, it does not match filenames that do
not conform to the expected character encoding (that is, are not
encoded in valid UTF-8).</p><p>For more information about raw filenames, see the
<a href="./file">kernel/file</a> module.</p><h3>is_dir/1</h3><p>Test whether <strong>Name</strong> refers to a directory.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Name</span></strong>
refers to a directory, otherwise <strong>false</strong>.</p><h3>is_file/1</h3><p>Test whether <strong>Name</strong> refers to a file or directory. </p><p>Returns <strong>true</strong> if <strong><span class="anno">Name</span></strong>
refers to a file or a directory, otherwise <strong>false</strong>.</p><h3>is_regular/1</h3><p>Test whether <strong>Name</strong> refers to a (regular) file.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Name</span></strong>
refers to a (regular) file, otherwise <strong>false</strong>.</p><h3>last_modified/1</h3><p>Return the local date and time when a file was last modified. </p><p>Returns the date and time the specified file or directory was last
modified, or <strong>0</strong> if the file does not exist.</p><h3>wildcard/1</h3><p>Match filenames using Unix-style wildcards.</p><p>Returns a list of all files that match Unix-style wildcard string
<strong><span class="anno">Wildcard</span></strong>.</p><p>The wildcard string looks like an ordinary filename, except
that the following "wildcard characters" are interpreted in a special
way:</p><dl><dt>?</dt><dd> <p>Matches one character.</p> </dd><dt>*</dt><dd> <p>Matches any number of characters up to the end of
the filename, the next dot, or the next slash.</p> </dd><dt>**</dt><dd> <p>Two adjacent <strong>*</strong> used as a single pattern match
all files and zero or more directories and subdirectories.</p> </dd><dt>[Character1,Character2,...]</dt><dd> <p>Matches any of the characters listed. Two characters
separated by a hyphen match a range of characters.
Example: <strong>[A-Z]</strong> matches any uppercase letter.</p> </dd><dt>{Item,...}</dt><dd> <p>Alternation. Matches one of the alternatives.</p> </dd></dl><p>Other characters represent themselves. Only filenames that
have exactly the same character in the same position match.
Matching is case-sensitive, for example, "a" does not match "A".</p><p>Directory separators must always be written as <strong>/</strong>, even on
Windows.</p><p>A character preceded by <strong>\</strong> loses its special meaning. Note
that <strong>\</strong> must be written as <strong>\\</strong> in a string literal.
For example, "\\?*" will match any filename starting with <strong>?</strong>.</p><p>Notice that multiple "*" characters are allowed
(as in Unix wildcards, but opposed to Windows/DOS wildcards).</p><p><em>Examples:</em></p><p>The following examples assume that the current directory is the
top of an Erlang/OTP installation.</p><p>To find all <strong>.beam</strong> files in all applications, use the
following line:</p><pre><code class="">
filelib:wildcard("lib/*/ebin/*.beam").</code></pre><p>To find <strong>.erl</strong> or <strong>.hrl</strong> in all applications <strong>src</strong>
directories, use either of the following lines:</p><pre><code class="">
filelib:wildcard("lib/*/src/*.?rl")</code></pre><pre><code class="">
filelib:wildcard("lib/*/src/*.{erl,hrl}")</code></pre><p>To find all <strong>.hrl</strong> files in <strong>src</strong> or <strong>include</strong>
directories:</p><pre><code class="">
filelib:wildcard("lib/*/{src,include}/*.hrl").</code></pre><p>To find all <strong>.erl</strong> or <strong>.hrl</strong> files in either
<strong>src</strong> or <strong>include</strong> directories:</p><pre><code class="">
filelib:wildcard("lib/*/{src,include}/*.{erl,hrl}")</code></pre><p>To find all <strong>.erl</strong> or <strong>.hrl</strong> files in any subdirectory:</p><pre><code class="">
filelib:wildcard("lib/**/*.{erl,hrl}")</code></pre><h3>wildcard/2</h3><p>Match filenames using Unix-style wildcards starting at a specified directory.</p><p>Same as <a href="#wildcard/1">wildcard/1</a>,
except that <strong><span class="anno">Cwd</span></strong> is used instead of the working
directory.</p><h3>find_file/2</h3><h3>find_file/3</h3><p>Find a file relative to a given directory.</p><p>Looks for a file of the given name by applying suffix rules to
the given directory path. For example, a rule <strong>{"ebin", "src"}</strong>
means that if the directory path ends with <strong>"ebin"</strong>, the
corresponding path ending in <strong>"src"</strong> should be searched.</p><p>If <strong><span class="anno">Rules</span></strong> is left out or is an empty list, the
default system rules are used. See also the Kernel application
parameter <a href="../kernel/kernel_app#source_search_rules">kernel/kernel_app#source_search_rules</a>.</p><h3>find_source/1</h3><p>Find the source file for a given object file.</p><p>Equivalent to <strong>find_source(Base, Dir)</strong>, where <strong>Dir</strong> is
<strong>filename:dirname(<span class="anno">FilePath</span>)</strong> and <strong>Base</strong> is
<strong>filename:basename(<span class="anno">FilePath</span>)</strong>.</p><h3>find_source/2</h3><h3>find_source/3</h3><p>Find a source file relative to a given directory.</p><p>Applies file extension specific rules to find the source file for
a given object file relative to the object directory. For example,
for a file with the extension <strong>.beam</strong>, the default rule is to
look for a file with a corresponding extension <strong>.erl</strong> by
replacing the suffix <strong>"ebin"</strong> of the object directory path with
<strong>"src"</strong> or <strong>"src/*"</strong>.
The file search is done through <a href="#find_file/3">find_file/3</a>. The directory of
the object file is always tried before any other directory specified
by the rules.</p><p>If <strong><span class="anno">Rules</span></strong> is left out or is an empty list, the
default system rules are used. See also the Kernel application
parameter <a href="../kernel/kernel_app#source_search_rules">kernel/kernel_app#source_search_rules</a>.</p><h2>filename</h2><p>Filename manipulation functions.</p><p>This module provides functions
for analyzing and manipulating filenames. These functions are
designed so that the Erlang code can work on many different
platforms with different filename formats. With filename
is meant all strings that can be used to denote a file. The filename
can be a short relative name like <strong>foo.erl</strong>, a long absolute
name including a drive designator, a directory name like
<strong>D:\usr/local\bin\erl/lib\tools\foo.erl</strong>, or any variations
in between.In Windows, all functions return filenames with forward slashes
only, even if the arguments contain backslashes. To normalize a
filename by removing redundant directory separators, use
<a href="#join/1">join/1</a>.
The module supports
<a href="./unicode_usage#notes-about-raw-filenames">raw filenames</a> in the way that if a binary is
present, or the filename cannot be interpreted according to the return
value of <a href="../kernel/file#native_name_encoding/0">kernel/file#native_name_encoding/0</a>, a raw filename is also
returned. For example, <strong>join/1</strong> provided with a path component
that is a binary (and cannot be interpreted under the current
native filename encoding) results in a raw filename that is returned
(the join operation is performed of course). For more information
about raw filenames, see the
<a href="./file">kernel/file</a> module.</p><h2>Functions</h2><h3>absname/1</h3><p>Convert a filename to an absolute name, relative the working directory.</p><p>Converts a relative <strong><span class="anno">Filename</span></strong> and returns an
absolute name. No attempt is made to create the shortest absolute
name, as this can give incorrect results on file systems that
allow links.</p><p><em>Unix examples:</em></p><pre>
1&gt; <span class="input">pwd().</span>
"/usr/local"
2&gt; <span class="input">filename:absname("foo").</span>
"/usr/local/foo"
3&gt; <span class="input">filename:absname("../x").</span>
"/usr/local/../x"
4&gt; <span class="input">filename:absname("/").</span>
"/"</pre><p><em>Windows examples:</em></p><pre>
1&gt; <span class="input">pwd().</span>
"D:/usr/local"
2&gt; <span class="input">filename:absname("foo").</span>
"D:/usr/local/foo"
3&gt; <span class="input">filename:absname("../x").</span>
"D:/usr/local/../x"
4&gt; <span class="input">filename:absname("/").</span>
"D:/"</pre><h3>absname/2</h3><p>Convert a filename to an absolute name, relative a specified directory.</p><p>Same as <a href="#absname/1">absname/1</a>,
except that the directory to which the filename is to be made
relative is specified in argument <strong><span class="anno">Dir</span></strong>.</p><h3>absname_join/2</h3><p>Join an absolute directory with a relative filename.</p><p>Joins an absolute directory with a relative filename. Similar to
<a href="#join/2">join/2</a>, but on platforms
with tight restrictions on raw filename length and no support for
symbolic links (read: VxWorks), leading parent directory components
in <strong><span class="anno">Filename</span></strong> are matched against trailing
directory components in <strong><span class="anno">Dir</span></strong> so they can be
removed from the result - minimizing its length.</p><h3>basedir/2</h3><h3>basedir/2</h3><p>Equivalent to <strong>basedir(<span class="anno">PathType</span>, <span class="anno">Application</span>,#{})</strong> or <strong>basedir(<span class="anno">PathsType</span>, <span class="anno">Application</span>,#{})</strong>. </p><ul><li>PathType</li></ul><ul><li>basedir_path_type</li></ul><ul><li>PathsType</li></ul><ul><li>basedir_paths_type</li></ul><ul><li>Application</li></ul><p>
Equivalent to <a href="#basedir_3_1"> basedir(, , #{})</a>
or <a href="#basedir_3_2"> basedir(, , #{})</a>.
</p><h3>basedir/3</h3><h3>basedir/3</h3><ul><li>PathType</li></ul><ul><li>basedir_path_type</li></ul><ul><li>PathsType</li></ul><ul><li>basedir_paths_type</li></ul><ul><li>Application</li></ul><ul><li>Opts</li></ul><ul><li>basedir_opts</li></ul><a name="basedir-3"></a><p>
Returns a suitable path, or paths, for a given type.  If
<strong>os</strong> is not set in <strong><span class="anno">Opts</span></strong> the
function will default to the native option, that is
<strong>'linux'</strong>, <strong>'darwin'</strong> or <strong>'windows'</strong>, as
understood by <strong>os:type/0</strong>. Anything not recognized
as <strong>'darwin'</strong> or <strong>'windows'</strong> is interpreted as
<strong>'linux'</strong>.</p><p>
The options <strong>'author'</strong> and <strong>'version'</strong> are only used with <strong>'windows'</strong> option mode.
</p><ul><li><strong>user_cache</strong> <p>The path location is intended for transient data files on a local machine.</p> <p>
On Linux:
Respects the os environment variable <strong>XDG_CACHE_HOME</strong>.
</p> <pre>
1&gt; <span class="input">filename:basedir(user_cache, "my_application", #{os=&gt;linux}).</span>
"/home/otptest/.cache/my_application"</pre> On Darwin: <pre>
1&gt; <span class="input">filename:basedir(user_cache, "my_application", #{os=&gt;darwin}).</span>
"/home/otptest/Library/Caches/my_application"</pre> On Windows: <pre>
1&gt; <span class="input">filename:basedir(user_cache, "My App").</span>
"c:/Users/otptest/AppData/Local/My App/Cache"
2&gt; <span class="input">filename:basedir(user_cache, "My App").</span>
"c:/Users/otptest/AppData/Local/My App/Cache"
3&gt; <span class="input">filename:basedir(user_cache, "My App", #{author=&gt;"Erlang"}).</span>
"c:/Users/otptest/AppData/Local/Erlang/My App/Cache"
4&gt; <span class="input">filename:basedir(user_cache, "My App", #{version=&gt;"1.2"}).</span>
"c:/Users/otptest/AppData/Local/My App/1.2/Cache"
5&gt; <span class="input">filename:basedir(user_cache, "My App", #{author=&gt;"Erlang",version=&gt;"1.2"}).</span>
"c:/Users/otptest/AppData/Local/Erlang/My App/1.2/Cache"</pre> </li><li><strong>user_config</strong> <p>
The path location is intended for persistent configuration files.
</p> <p>
On Linux:
Respects the os environment variable <strong>XDG_CONFIG_HOME</strong>.
</p> <pre>
2&gt; <span class="input">filename:basedir(user_config, "my_application", #{os=&gt;linux}).</span>
"/home/otptest/.config/my_application"</pre> On Darwin:<pre>
2&gt; <span class="input">filename:basedir(user_config, "my_application", #{os=&gt;darwin}).</span>
"/home/otptest/Library/Application Support/my_application"</pre> On Windows:<pre>
1&gt; <span class="input">filename:basedir(user_config, "My App").</span>
"c:/Users/otptest/AppData/Roaming/My App"
2&gt; <span class="input">filename:basedir(user_config, "My App", #{author=&gt;"Erlang", version=&gt;"1.2"}).</span>
"c:/Users/otptest/AppData/Roaming/Erlang/My App/1.2"</pre> </li><li><strong>user_data</strong> <p>
The path location is intended for persistent data files.
</p> <p>
On Linux:
Respects the os environment variable <strong>XDG_DATA_HOME</strong>.
</p> <pre>
3&gt; <span class="input">filename:basedir(user_data, "my_application", #{os=&gt;linux}).</span>
"/home/otptest/.local/my_application"</pre> On Darwin:<pre>
3&gt; <span class="input">filename:basedir(user_data, "my_application", #{os=&gt;darwin}).</span>
"/home/otptest/Library/Application Support/my_application"</pre> On Windows:<pre>
8&gt; <span class="input">filename:basedir(user_data, "My App").</span>
"c:/Users/otptest/AppData/Local/My App"
9&gt; <span class="input">filename:basedir(user_data, "My App",#{author=&gt;"Erlang",version=&gt;"1.2"}).</span>
"c:/Users/otptest/AppData/Local/Erlang/My App/1.2"</pre> </li><li><strong>user_log</strong> <p>The path location is intended for transient log files on a local machine.</p> <p>
On Linux:
Respects the os environment variable <strong>XDG_CACHE_HOME</strong>.</p> <pre>
4&gt; <span class="input">filename:basedir(user_log, "my_application", #{os=&gt;linux}).</span>
"/home/otptest/.cache/my_application/log"</pre> On Darwin:<pre>
4&gt; <span class="input">filename:basedir(user_log, "my_application", #{os=&gt;darwin}).</span>
"/home/otptest/Library/Caches/my_application"</pre> On Windows:<pre>
12&gt; <span class="input">filename:basedir(user_log, "My App").</span>
"c:/Users/otptest/AppData/Local/My App/Logs"
13&gt; <span class="input">filename:basedir(user_log, "My App",#{author=&gt;"Erlang",version=&gt;"1.2"}).</span>
"c:/Users/otptest/AppData/Local/Erlang/My App/1.2/Logs"</pre> </li><li><strong>site_config</strong><p>
On Linux:
Respects the os environment variable <strong>XDG_CONFIG_DIRS</strong>.</p> <pre>
5&gt; <span class="input">filename:basedir(site_data, "my_application", #{os=&gt;linux}).</span>
["/usr/local/share/my_application",
 "/usr/share/my_application"]
6&gt; <span class="input">os:getenv("XDG_CONFIG_DIRS").</span>
"/etc/xdg/xdg-ubuntu:/usr/share/upstart/xdg:/etc/xdg"
7&gt; <span class="input">filename:basedir(site_config, "my_application", #{os=&gt;linux}).</span>
["/etc/xdg/xdg-ubuntu/my_application",
 "/usr/share/upstart/xdg/my_application",
 "/etc/xdg/my_application"]
8&gt; <span class="input">os:unsetenv("XDG_CONFIG_DIRS").</span>
true
9&gt; <span class="input">filename:basedir(site_config, "my_application", #{os=&gt;linux}).</span>
["/etc/xdg/my_application"]</pre> On Darwin:<pre>
5&gt; <span class="input">filename:basedir(site_config, "my_application", #{os=&gt;darwin}).</span>
["/Library/Application Support/my_application"]</pre> </li><li><strong>site_data</strong><p>
On Linux:
Respects the os environment variable <strong>XDG_DATA_DIRS</strong>.</p> <pre>
10&gt; <span class="input">os:getenv("XDG_DATA_DIRS").</span>
"/usr/share/ubuntu:/usr/share/gnome:/usr/local/share/:/usr/share/"
11&gt; <span class="input">filename:basedir(site_data, "my_application", #{os=&gt;linux}).</span>
["/usr/share/ubuntu/my_application",
 "/usr/share/gnome/my_application",
 "/usr/local/share/my_application",
 "/usr/share/my_application"]
12&gt; <span class="input">os:unsetenv("XDG_DATA_DIRS").</span>
true
13&gt; <span class="input">filename:basedir(site_data, "my_application", #{os=&gt;linux}).</span>
["/usr/local/share/my_application",
 "/usr/share/my_application"]</pre> On Darwin:<pre>
5&gt; <span class="input">filename:basedir(site_data, "my_application", #{os=&gt;darwin}).</span>
["/Library/Application Support/my_application"]</pre> </li></ul><h3>basename/1</h3><p>Return the last component of a filename.</p><p>Returns the last component of <strong><span class="anno">Filename</span></strong>, or
<strong><span class="anno">Filename</span></strong> itself if it does not contain any
directory separators.</p><p><em>Examples:</em></p><pre>
5&gt; <span class="input">filename:basename("foo").</span>
"foo"
6&gt; <span class="input">filename:basename("/usr/foo").</span>
"foo"
7&gt; <span class="input">filename:basename("/").</span>
[]</pre><h3>basename/2</h3><p>Return the last component of a filename, stripped of the specified extension.</p><p>Returns the last component of <strong><span class="anno">Filename</span></strong> with
extension <strong><span class="anno">Ext</span></strong> stripped. This function is to be
used to remove a (possible) specific extension. To remove an
existing extension when you are unsure which one it is, use
<strong>rootname(basename(Filename))</strong>.</p><p><em>Examples:</em></p><pre>
8&gt; <span class="input">filename:basename("~/src/kalle.erl", ".erl").</span>
"kalle"
9&gt; <span class="input">filename:basename("~/src/kalle.beam", ".erl").</span>
"kalle.beam"
10&gt; <span class="input">filename:basename("~/src/kalle.old.erl", ".erl").</span>
"kalle.old"
11&gt; <span class="input">filename:rootname(filename:basename("~/src/kalle.erl")).</span>
"kalle"
12&gt; <span class="input">filename:rootname(filename:basename("~/src/kalle.beam")).</span>
"kalle"</pre><h3>dirname/1</h3><p>Return the directory part of a path name.</p><p>Returns the directory part of <strong><span class="anno">Filename</span></strong>.</p><p><em>Examples:</em></p><pre>
13&gt; <span class="input">filename:dirname("/usr/src/kalle.erl").</span>
"/usr/src"
14&gt; <span class="input">filename:dirname("kalle.erl").</span>
"."</pre><pre>
5&gt; <span class="input">filename:dirname("\\usr\\src/kalle.erl").</span> % Windows
"/usr/src"</pre><h3>extension/1</h3><p>Return the file extension.</p><p>Returns the file extension of <strong><span class="anno">Filename</span></strong>,
including the period. Returns an empty string if no extension
exists.</p><p><em>Examples:</em></p><pre>
15&gt; <span class="input">filename:extension("foo.erl").</span>
".erl"
16&gt; <span class="input">filename:extension("beam.src/kalle").</span>
[]</pre><h3>find_src/1</h3><h3>find_src/2</h3><p>Find the filename and compiler options for a module.</p><p>Finds the source filename and compiler options for a module.
The result can be fed to <a href="../compiler/compile#file/2">compiler/compile#file/2</a> to compile the file again.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated. Use <a href="./filelib#find_source/1">filelib#find_source/1</a> instead for finding source files.</p><p>If possible, use the <a href="beam_lib">beam_lib</a>
module to extract the compiler options and the abstract code
format from the Beam file and compile that instead.</p></div><p>Argument <strong><span class="anno">Beam</span></strong>, which can be a string or an atom,
specifies either the module name or the path to the source
code, with or without extension <strong>".erl"</strong>. In either
case, the module must be known by the code server, that is,
<strong>code:which(<span class="anno">Module</span>)</strong> must succeed.</p><p><strong><span class="anno">Rules</span></strong> describes how the source directory can be
found when the object code directory is known. It is a list of
tuples <strong>{<span class="anno">BinSuffix</span>, <span class="anno">SourceSuffix</span>}</strong> and
is interpreted as follows: if the end of the directory name where the
object is located matches <strong><span class="anno">BinSuffix</span></strong>, then the
name created by replacing <strong><span class="anno">BinSuffix</span></strong> with
<strong><span class="anno">SourceSuffix</span></strong> is expanded by calling
<a href="./filelib#wildcard/1">filelib#wildcard/1</a>.
If a regular file is found among the matches, the function
returns that location together with <strong><span class="anno">Options</span></strong>.
Otherwise the next rule is tried, and so on.</p><p><strong><span class="anno">Rules</span></strong> defaults
to:</p><pre><code class="">
[{"", ""}, {"ebin", "src"}, {"ebin", "esrc"},
 {"ebin", "src/*"}, {"ebin", "esrc/*"}]</code></pre><p>The function returns <strong>{<span class="anno">SourceFile</span>, <span class="anno">Options</span>}</strong> if it succeeds.
<strong><span class="anno">SourceFile</span></strong> is the absolute path to the source
file without extension <strong>".erl"</strong>. <strong><span class="anno">Options</span></strong>
includes the options that are necessary to recompile the file with
<strong>compile:file/2</strong>, but excludes options such as <strong>report</strong>
and <strong>verbose</strong>, which do not change the way code is generated.
The paths in options <strong>{outdir, <span class="anno">Path</span>}</strong> and
<strong>{i, Path}</strong> are guaranteed to be absolute.</p><h3>flatten/1</h3><p>Convert a filename to a flat string.</p><p>Converts a possibly deep list filename consisting of
characters and atoms into the corresponding flat string
filename.</p><h3>join/1</h3><p>Join a list of filename components with directory separators. </p><p>Joins a list of filename <strong><span class="anno">Components</span></strong> with
directory separators.
If one of the elements of <strong><span class="anno">Components</span></strong>
includes an absolute path, such as <strong>"/xxx"</strong>,
the preceding elements, if any, are removed from the result.</p><p>The result is "normalized":</p><ul><li>Redundant directory separators are removed.</li><li>In Windows, all directory separators are forward slashes and the drive letter is in lower case.</li></ul><p><em>Examples:</em></p><pre>
17&gt; <span class="input">filename:join(["/usr", "local", "bin"]).</span>
"/usr/local/bin"
18&gt; <span class="input">filename:join(["a/b///c/"]).</span>
"a/b/c"</pre><pre>
6&gt; <span class="input">filename:join(["B:a\\b///c/"]).</span> % Windows
"b:a/b/c"</pre><h3>join/2</h3><p>Join two filename components with directory separators. </p><p>Joins two filename components with directory separators.
Equivalent to <strong>join([<span class="anno">Name1</span>, <span class="anno">Name2</span>])</strong>.
</p><h3>nativename/1</h3><p>Return the native form of a file path.</p><p>Converts <strong><span class="anno">Path</span></strong> to a form accepted by the command
shell and native applications on the current platform. On Windows,
forward slashes are converted to backward slashes. On all
platforms, the name is normalized as done by
<a href="#join/1">join/1</a>.</p><p><em>Examples:</em></p><pre>
19&gt; <span class="input">filename:nativename("/usr/local/bin/").</span> % Unix
"/usr/local/bin"</pre><pre>
7&gt; <span class="input">filename:nativename("/usr/local/bin/").</span> % Windows
"\\usr\\local\\bin"</pre><h3>pathtype/1</h3><p>Return the path type.</p><p>Returns the path type, which is one of the following:</p><dl><dt><strong>absolute</strong></dt><dd> <p>The path name refers to a specific file on a specific
volume.</p> <p>Unix example: <strong>/usr/local/bin</strong></p> <p>Windows example: <strong>D:/usr/local/bin</strong></p> </dd><dt><strong>relative</strong></dt><dd> <p>The path name is relative to the current working
directory on the current volume.</p> <p>Example: <strong>foo/bar, ../src</strong></p> </dd><dt><strong>volumerelative</strong></dt><dd> <p>The path name is relative to the current working
directory on a specified volume, or it is a specific file
on the current working volume.</p> <p>Windows example: <strong>D:bar.erl, /bar/foo.erl</strong></p> </dd></dl><h3>rootname/1</h3><h3>rootname/2</h3><p>Remove a filename extension.</p><p>Removes a filename extension. <strong>rootname/2</strong> works as
<strong>rootname/1</strong>, except that the extension is removed only
if it is <strong><span class="anno">Ext</span></strong>.</p><p><em>Examples:</em></p><pre>
20&gt; <span class="input">filename:rootname("/beam.src/kalle").</span>
"/beam.src/kalle"
21&gt; <span class="input">filename:rootname("/beam.src/foo.erl").</span>
"/beam.src/foo"
22&gt; <span class="input">filename:rootname("/beam.src/foo.erl", ".erl").</span>
"/beam.src/foo"
23&gt; <span class="input">filename:rootname("/beam.src/foo.beam", ".erl").</span>
"/beam.src/foo.beam"</pre><h3>safe_relative_path/1</h3><p>Sanitize a relative path to avoid directory traversal attacks.</p><p>Sanitizes the relative path by eliminating ".." and "."
components to protect against directory traversal attacks.
Either returns the sanitized path name, or the atom
<strong>unsafe</strong> if the path is unsafe.
The path is considered unsafe in the following circumstances:</p><ul><li><p>The path is not relative.</p></li><li><p>A ".." component would climb up above the root of
the relative path.</p></li></ul><p><em>Examples:</em></p><pre>
1&gt; <span class="input">filename:safe_relative_path("dir/sub_dir/..").</span>
"dir"
2&gt; <span class="input">filename:safe_relative_path("dir/..").</span>
[]
3&gt; <span class="input">filename:safe_relative_path("dir/../..").</span>
unsafe
4&gt; <span class="input">filename:safe_relative_path("/abs/path").</span>
unsafe</pre><h3>split/1</h3><p>Split a filename into its path components.</p><p>Returns a list whose elements are the path components of
<strong><span class="anno">Filename</span></strong>.</p><p><em>Examples:</em></p><pre>
24&gt; <span class="input">filename:split("/usr/local/bin").</span>
["/","usr","local","bin"]
25&gt; <span class="input">filename:split("foo/bar").</span>
["foo","bar"]
26&gt; <span class="input">filename:split("a:\\msdev\\include").</span>
["a:/","msdev","include"]</pre><h2>gb_sets</h2><p>General balanced trees.</p><p>This module provides ordered sets using Prof. Arne Andersson's
General Balanced Trees. Ordered sets can be much more efficient than
using ordered lists, for larger sets, but depends on the
application.This module considers two elements as different if and only if
they do not compare equal (<strong>==</strong>).</p><h3>Complexity Note</h3><p>The complexity on set operations is bounded by either <em>O(|S|)</em> or
<em>O(|T| * log(|S|))</em>, where S is the largest given set, depending
on which is fastest for any particular function call. For
operating on sets of almost equal size, this implementation is
about 3 times slower than using ordered-list sets directly. For
sets of very different sizes, however, this solution can be
arbitrarily much faster; in practical cases, often
10-100 times. This implementation is particularly suited for
accumulating elements a few at a time, building up a large set
(&gt; 100-200 elements), and repeatedly testing for
membership in the current set.</p><p>As with normal tree structures, lookup (membership testing),
insertion, and deletion have logarithmic complexity.</p><h3>Compatibility</h3><p>The following functions in this module also exist and provides
the same functionality in the
<a href="sets">sets</a> and
<a href="ordsets">ordsets</a>
modules. That is, by only changing the module name for each call,
you can try out different set representations.</p><ul><li><a href="#add_element/2">add_element/2</a> </li><li><a href="#del_element/2">del_element/2</a> </li><li><a href="#filter/2">filter/2</a> </li><li><a href="#fold/3">fold/3</a> </li><li><a href="#from_list/1">from_list/1</a> </li><li><a href="#intersection/1">intersection/1</a> </li><li><a href="#intersection/2">intersection/2</a> </li><li><a href="#is_element/2">is_element/2</a> </li><li><a href="#is_empty/1">is_empty/1</a> </li><li><a href="#is_set/1">is_set/1</a> </li><li><a href="#is_subset/2">is_subset/2</a> </li><li><a href="#new/0">new/0</a> </li><li><a href="#size/1">size/1</a> </li><li><a href="#subtract/2">subtract/2</a> </li><li><a href="#to_list/1">to_list/1</a> </li><li><a href="#union/1">union/1</a> </li><li><a href="#union/2">union/2</a> </li></ul><h2>Data Types</h2><span class="name">set</span><p>A general balanced set.</p><span class="name">set</span><span class="name">iter</span><p>A general balanced set iterator.</p><span class="name">iter</span><h2>Functions</h2><h3>add/2</h3><h3>add_element/2</h3><p>Add a (possibly existing) element to a set.</p><p>Returns a new set formed from <strong><span class="anno">Set1</span></strong> with
<strong><span class="anno">Element</span></strong> inserted. If <strong><span class="anno">Element</span></strong>
is already an
element in <strong><span class="anno">Set1</span></strong>, nothing is changed.</p><h3>balance/1</h3><p>Rebalance tree representation of a set.</p><p>Rebalances the tree representation of <strong><span class="anno">Set1</span></strong>.
Notice that
this is rarely necessary, but can be motivated when a large
number of elements have been deleted from the tree without
further insertions. Rebalancing can then be forced
to minimise lookup times, as deletion does not
rebalance the tree.</p><h3>del_element/2</h3><p>Remove a (possibly non-existing) element from a set.</p><p>Returns a new set formed from <strong><span class="anno">Set1</span></strong> with
<strong><span class="anno">Element</span></strong> removed. If <strong><span class="anno">Element</span></strong>
is not an element
in <strong><span class="anno">Set1</span></strong>, nothing is changed.</p><h3>delete/2</h3><p>Remove an element from a set.</p><p>Returns a new set formed from <strong><span class="anno">Set1</span></strong> with
<strong><span class="anno">Element</span></strong> removed. Assumes that
<strong><span class="anno">Element</span></strong> is present
in <strong><span class="anno">Set1</span></strong>.</p><h3>delete_any/2</h3><p>Remove a (possibly non-existing) element from a set.</p><p>Returns a new set formed from <strong><span class="anno">Set1</span></strong> with
<strong><span class="anno">Element</span></strong> removed. If <strong><span class="anno">Element</span></strong>
is not an element
in <strong><span class="anno">Set1</span></strong>, nothing is changed.</p><h3>difference/2</h3><p>Return the difference of two sets.</p><p>Returns only the elements of <strong><span class="anno">Set1</span></strong> that are not
also elements of <strong><span class="anno">Set2</span></strong>.</p><h3>empty/0</h3><p>Return an empty set.</p><p>Returns a new empty set.</p><h3>filter/2</h3><p>Filter set elements.</p><p>Filters elements in <strong><span class="anno">Set1</span></strong> using predicate function
<strong><span class="anno">Pred</span></strong>.</p><h3>fold/3</h3><p>Fold over set elements.</p><p>Folds <strong><span class="anno">Function</span></strong> over every element in
<strong><span class="anno">Set</span></strong>
returning the final value of the accumulator.</p><h3>from_list/1</h3><p>Convert a list into a set.</p><p>Returns a set of the elements in <strong><span class="anno">List</span></strong>, where
<strong><span class="anno">List</span></strong> can be unordered and contain duplicates.</p><h3>from_ordset/1</h3><p>Make a set from an ordset list.</p><p>Turns an ordered-set list <strong><span class="anno">List</span></strong> into a set.
The list must not contain duplicates.</p><h3>insert/2</h3><p>Add a new element to a set.</p><p>Returns a new set formed from <strong><span class="anno">Set1</span></strong> with
<strong><span class="anno">Element</span></strong> inserted. Assumes that
<strong><span class="anno">Element</span></strong> is not
present in <strong><span class="anno">Set1</span></strong>.</p><h3>intersection/1</h3><p>Return the intersection of a list of sets.</p><p>Returns the intersection of the non-empty list of sets.</p><h3>intersection/2</h3><p>Return the intersection of two sets.</p><p>Returns the intersection of <strong><span class="anno">Set1</span></strong> and
<strong><span class="anno">Set2</span></strong>.</p><h3>is_disjoint/2</h3><p>Check whether two sets are disjoint.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Set1</span></strong> and
<strong><span class="anno">Set2</span></strong> are disjoint (have no elements in common),
otherwise <strong>false</strong>.</p><h3>is_element/2</h3><p>Test for membership of a set.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Element</span></strong> is an element of
<strong><span class="anno">Set</span></strong>, otherwise <strong>false</strong>.</p><h3>is_empty/1</h3><p>Test for empty set.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Set</span></strong> is an empty set,
otherwise <strong>false</strong>.</p><h3>is_member/2</h3><p>Test for membership of a set.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Element</span></strong> is an element of
<strong><span class="anno">Set</span></strong>, otherwise <strong>false</strong>.</p><h3>is_set/1</h3><p>Test for a set.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> appears to be a set,
otherwise <strong>false</strong>.</p><h3>is_subset/2</h3><p>Test for subset.</p><p>Returns <strong>true</strong> when every element of <strong><span class="anno">Set1</span></strong> is
also a member of <strong><span class="anno">Set2</span></strong>, otherwise <strong>false</strong>.</p><h3>iterator/1</h3><p>Return an iterator for a set.</p><p>Returns an iterator that can be used for traversing the entries of
<strong><span class="anno">Set</span></strong>; see
<a href="#next/1">next/1</a>. The implementation
of this is very efficient; traversing the whole set using
<strong>next/1</strong> is only slightly slower than getting the list of all
elements using <a href="#to_list/1">to_list/1</a>
and traversing that.
The main advantage of the iterator approach is that it does
not require the complete list of all elements to be built in
memory at one time.</p><h3>iterator_from/2</h3><p>Return an iterator for a set starting from a specified element. </p><p>Returns an iterator that can be used for traversing the
entries of <strong><span class="anno">Set</span></strong>; see
<a href="#next/1">next/1</a>.
The difference as compared to the iterator returned by
<a href="#iterator/1">iterator/1</a>
is that the first element greater than
or equal to <strong><span class="anno">Element</span></strong> is returned.</p><h3>largest/1</h3><p>Return largest element.</p><p>Returns the largest element in <strong><span class="anno">Set</span></strong>. Assumes that
<strong><span class="anno">Set</span></strong> is not empty.</p><h3>new/0</h3><p>Return an empty set.</p><p>Returns a new empty set.</p><h3>next/1</h3><p>Traverse a set with an iterator.</p><p>Returns <strong>{<span class="anno">Element</span>, <span class="anno">Iter2</span>}</strong>, where
<strong><span class="anno">Element</span></strong> is the smallest element referred to by
iterator <strong><span class="anno">Iter1</span></strong>,
and <strong><span class="anno">Iter2</span></strong> is the new iterator to be used for
traversing the remaining elements, or the atom <strong>none</strong> if
no elements remain.</p><h3>singleton/1</h3><p>Return a set with one element.</p><p>Returns a set containing only element <strong><span class="anno">Element</span></strong>.
</p><h3>size/1</h3><p>Return the number of elements in a set.</p><p>Returns the number of elements in <strong><span class="anno">Set</span></strong>.</p><h3>smallest/1</h3><p>Return smallest element.</p><p>Returns the smallest element in <strong><span class="anno">Set</span></strong>. Assumes that
<strong><span class="anno">Set</span></strong> is not empty.</p><h3>subtract/2</h3><p>Return the difference of two sets.</p><p>Returns only the elements of <strong><span class="anno">Set1</span></strong> that are not
also elements of <strong><span class="anno">Set2</span></strong>.</p><h3>take_largest/1</h3><p>Extract largest element.</p><p>Returns <strong>{<span class="anno">Element</span>, <span class="anno">Set2</span>}</strong>, where
<strong><span class="anno">Element</span></strong> is the largest element in
<strong><span class="anno">Set1</span></strong>, and <strong><span class="anno">Set2</span></strong> is this set
with <strong><span class="anno">Element</span></strong> deleted. Assumes that
<strong><span class="anno">Set1</span></strong> is not empty.</p><h3>take_smallest/1</h3><p>Extract smallest element.</p><p>Returns <strong>{<span class="anno">Element</span>, <span class="anno">Set2</span>}</strong>, where
<strong><span class="anno">Element</span></strong> is the smallest element in
<strong><span class="anno">Set1</span></strong>, and <strong><span class="anno">Set2</span></strong> is this set
with <strong><span class="anno">Element</span></strong> deleted. Assumes that
<strong><span class="anno">Set1</span></strong> is not empty.</p><h3>to_list/1</h3><p>Convert a set into a list.</p><p>Returns the elements of <strong><span class="anno">Set</span></strong> as a list.</p><h3>union/1</h3><p>Return the union of a list of sets.</p><p>Returns the merged (union) set of the list of sets.</p><h3>union/2</h3><p>Return the union of two sets.</p><p>Returns the merged (union) set of <strong><span class="anno">Set1</span></strong> and
<strong><span class="anno">Set2</span></strong>.</p><h3>See Also</h3><p><a href="gb_trees">gb_trees</a>,
<a href="ordsets">ordsets</a>,
<a href="sets">sets</a></p><h2>gb_trees</h2><p>General balanced trees.</p><p>This module provides Prof. Arne Andersson's General
Balanced Trees. These have no storage overhead compared to
unbalanced binary trees, and their performance is
better than AVL trees.This module considers two keys as different if and only if
they do not compare equal (<strong>==</strong>).</p><h3>Data Structure</h3><p>Trees and iterators are built using opaque data structures that should
not be pattern-matched from outside this module.</p><p>There is no attempt to balance trees after deletions. As
deletions do not increase the height of a tree, this should be OK.</p><p>The original balance condition <em>h(T) &lt;= ceil(c * log(|T|))</em>
has been changed to the similar (but not quite equivalent)
condition <em>2 ^ h(T) &lt;= |T| ^ c</em>. This should also be OK.</p><h2>Data Types</h2><span class="name">tree</span><p>A general balanced tree.</p><span class="name">tree</span><span class="name">iter</span><p>A general balanced tree iterator.</p><span class="name">iter</span><h2>Functions</h2><h3>balance/1</h3><p>Rebalance a tree.</p><p>Rebalances <strong><span class="anno">Tree1</span></strong>. Notice that this is
rarely necessary,
but can be motivated when many nodes have been
deleted from the tree without further insertions. Rebalancing
can then be forced to minimize lookup times, as
deletion does not rebalance the tree.</p><h3>delete/2</h3><p>Remove a node from a tree.</p><p>Removes the node with key <strong><span class="anno">Key</span></strong> from
<strong><span class="anno">Tree1</span></strong> and returns the new tree. Assumes that the
key is present in the tree, crashes otherwise.</p><h3>delete_any/2</h3><p>Remove a (possibly non-existing) node from a tree.</p><p>Removes the node with key <strong><span class="anno">Key</span></strong> from
<strong><span class="anno">Tree1</span></strong> if
the key is present in the tree, otherwise does nothing.
Returns the new tree.</p><h3>take/2</h3><p>Returns a value and new tree without node with key <strong>Key</strong>.</p><p>Returns a value <strong><span class="anno">Value</span></strong> from node with key <strong><span class="anno">Key</span></strong>
and new <strong><span class="anno">Tree2</span></strong> without the node with this value.
Assumes that the node with key is present in the tree,
crashes otherwise.</p><h3>take_any/2</h3><p>Returns a value and new tree without node with key <strong>Key</strong>.</p><p>Returns a value <strong><span class="anno">Value</span></strong> from node with key <strong><span class="anno">Key</span></strong>
and new <strong><span class="anno">Tree2</span></strong> without the node with this value.
Returns <strong>error</strong> if the node with the key is not present in
the tree.</p><h3>empty/0</h3><p>Return an empty tree.</p><p>Returns a new empty tree.</p><h3>enter/3</h3><p>Insert or update key with value in a tree.</p><p>Inserts <strong><span class="anno">Key</span></strong> with value <strong><span class="anno">Value</span></strong>
into <strong><span class="anno">Tree1</span></strong> if the key is not present in the tree,
otherwise updates <strong><span class="anno">Key</span></strong> to value
<strong><span class="anno">Value</span></strong> in <strong><span class="anno">Tree1</span></strong>. Returns the
new tree.</p><h3>from_orddict/1</h3><p>Make a tree from an orddict.</p><p>Turns an ordered list <strong><span class="anno">List</span></strong> of key-value tuples
into a tree. The list must not contain duplicate keys.</p><h3>get/2</h3><p>Look up a key in a tree, if present.</p><p>Retrieves the value stored with <strong><span class="anno">Key</span></strong> in
<strong><span class="anno">Tree</span></strong>.
Assumes that the key is present in the tree, crashes
otherwise.</p><h3>insert/3</h3><p>Insert a new key and value in a tree.</p><p>Inserts <strong><span class="anno">Key</span></strong> with value <strong><span class="anno">Value</span></strong>
into <strong><span class="anno">Tree1</span></strong> and
returns the new tree. Assumes that the key is not present in
the tree, crashes otherwise.</p><h3>is_defined/2</h3><p>Test for membership of a tree.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Key</span></strong> is present in
<strong><span class="anno">Tree</span></strong>, otherwise <strong>false</strong>.</p><h3>is_empty/1</h3><p>Test for empty tree.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Tree</span></strong> is an empty tree,
othwewise  <strong>false</strong>.</p><h3>iterator/1</h3><p>Return an iterator for a tree.</p><p>Returns an iterator that can be used for traversing the
entries of <strong><span class="anno">Tree</span></strong>; see
<a href="#next/1">next/1</a>. The implementation
of this is very efficient; traversing the whole tree using
<strong>next/1</strong> is only slightly slower than getting the list
of all elements using
<a href="#to_list/1">to_list/1</a>
and traversing that.
The main advantage of the iterator approach is that it does
not require the complete list of all elements to be built in
memory at one time.</p><h3>iterator_from/2</h3><p>Return an iterator for a tree starting from a specified key. </p><p>Returns an iterator that can be used for traversing the
entries of <strong><span class="anno">Tree</span></strong>; see
<a href="#next/1">next/1</a>.
The difference as compared to the iterator returned by
<a href="#iterator/1">iterator/1</a>
is that the first key greater than
or equal to <strong><span class="anno">Key</span></strong> is returned.</p><h3>keys/1</h3><p>Return a list of the keys in a tree.</p><p>Returns the keys in <strong><span class="anno">Tree</span></strong> as an ordered list.</p><h3>largest/1</h3><p>Return largest key and value.</p><p>Returns <strong>{<span class="anno">Key</span>, <span class="anno">Value</span>}</strong>, where
<strong><span class="anno">Key</span></strong> is the largest
key in <strong><span class="anno">Tree</span></strong>, and <strong><span class="anno">Value</span></strong> is
the value associated
with this key. Assumes that the tree is not empty.</p><h3>lookup/2</h3><p>Look up a key in a tree.</p><p>Looks up <strong><span class="anno">Key</span></strong> in <strong><span class="anno">Tree</span></strong>.
Returns <strong>{value, <span class="anno">Value</span>}</strong>, or <strong>none</strong> if
<strong><span class="anno">Key</span></strong> is not present.</p><h3>map/2</h3><p>Return largest key and value.</p><p>Maps function F(<span class="anno">K</span>, <span class="anno">V1</span>) -&gt; <span class="anno">V2</span>
to all key-value pairs of tree <strong><span class="anno">Tree1</span></strong>. Returns a
new tree <strong><span class="anno">Tree2</span></strong> with the same set of keys as
<strong><span class="anno">Tree1</span></strong> and the new set of values
<strong><span class="anno">V2</span></strong>.</p><h3>next/1</h3><p>Traverse a tree with an iterator.</p><p>Returns <strong>{<span class="anno">Key</span>, <span class="anno">Value</span>, <span class="anno">Iter2</span>}</strong>, where <strong><span class="anno">Key</span></strong> is the
smallest key referred to by iterator <strong><span class="anno">Iter1</span></strong>, and
<strong><span class="anno">Iter2</span></strong> is the new iterator to be used for
traversing the remaining nodes, or the atom <strong>none</strong> if no
nodes remain.</p><h3>size/1</h3><p>Return the number of nodes in a tree.</p><p>Returns the number of nodes in <strong><span class="anno">Tree</span></strong>.</p><h3>smallest/1</h3><p>Return smallest key and value.</p><p>Returns <strong>{<span class="anno">Key</span>, <span class="anno">Value</span>}</strong>, where
<strong><span class="anno">Key</span></strong> is the smallest
key in <strong><span class="anno">Tree</span></strong>, and <strong><span class="anno">Value</span></strong> is
the value associated
with this key. Assumes that the tree is not empty.</p><h3>take_largest/1</h3><p>Extract largest key and value.</p><p>Returns <strong>{<span class="anno">Key</span>, <span class="anno">Value</span>, <span class="anno">Tree2</span>}</strong>, where <strong><span class="anno">Key</span></strong> is the
largest key in <strong><span class="anno">Tree1</span></strong>, <strong><span class="anno">Value</span></strong>
is the value associated with this key, and <strong><span class="anno">Tree2</span></strong>
is this tree with the corresponding node deleted. Assumes that the
tree is not empty.</p><h3>take_smallest/1</h3><p>Extract smallest key and value.</p><p>Returns <strong>{<span class="anno">Key</span>, <span class="anno">Value</span>, <span class="anno">Tree2</span>}</strong>, where <strong><span class="anno">Key</span></strong> is the
smallest key in <strong><span class="anno">Tree1</span></strong>, <strong><span class="anno">Value</span></strong>
is the value associated with this key, and <strong><span class="anno">Tree2</span></strong>
is this tree with the corresponding node deleted. Assumes that the
tree is not empty.</p><h3>to_list/1</h3><p>Convert a tree into a list.</p><p>Converts a tree into an ordered list of key-value tuples.</p><h3>update/3</h3><p>Update a key to new value in a tree.</p><p>Updates <strong><span class="anno">Key</span></strong> to value <strong><span class="anno">Value</span></strong>
in <strong><span class="anno">Tree1</span></strong> and
returns the new tree. Assumes that the key is present in the tree.</p><h3>values/1</h3><p>Return a list of the values in a tree.</p><p>Returns the values in <strong><span class="anno">Tree</span></strong> as an ordered list,
sorted by their corresponding keys. Duplicates are not removed.</p><h3>See Also</h3><p><a href="dict">dict</a>,
<a href="gb_sets">gb_sets</a></p><h2>gen_event</h2><p>Generic event handling behavior.</p><p>This behavior module provides event handling functionality. It
consists of a generic event manager process with any number of
event handlers that are added and deleted dynamically.An event manager implemented using this module has a standard
set of interface functions and includes functionality for tracing and
error reporting. It also fits into an OTP supervision tree. For more
information, see
<a href="./events">OTP Design Principles</a>.
Each event handler is implemented as a callback module exporting
a predefined set of functions. The relationship between the behavior
functions and the callback functions is as follows:<pre>
gen_event module                   Callback module
----------------                   ---------------
gen_event:start
gen_event:start_link       -----&gt;  -

gen_event:add_handler
gen_event:add_sup_handler  -----&gt;  Module:init/1

gen_event:notify
gen_event:sync_notify      -----&gt;  Module:handle_event/2

gen_event:call             -----&gt;  Module:handle_call/2

-                          -----&gt;  Module:handle_info/2

gen_event:delete_handler   -----&gt;  Module:terminate/2

gen_event:swap_handler
gen_event:swap_sup_handler -----&gt;  Module1:terminate/2
                                   Module2:init/1

gen_event:which_handlers   -----&gt;  -

gen_event:stop             -----&gt;  Module:terminate/2

-                          -----&gt;  Module:code_change/3</pre>As each event handler is one callback module, an event manager
has many callback modules that are added and deleted
dynamically. <strong>gen_event</strong> is therefore more tolerant of callback
module errors than the other behaviors. If a callback function for
an installed event handler fails with <strong>Reason</strong>, or returns a
bad value <strong>Term</strong>, the event manager does not fail. It deletes
the event handler by calling callback function
<a href="#Module:terminate/2">Module:terminate/2</a>,
giving as argument
<strong>{error,{'EXIT',Reason}}</strong> or <strong>{error,Term}</strong>, respectively.
No other event handler is affected.A <strong>gen_event</strong> process handles system messages as described in
<a href="sys">sys</a>. The <strong>sys</strong> module
can be used for debugging an event manager.Notice that an event manager <em>does</em> trap exit signals
automatically.The <strong>gen_event</strong> process can go into hibernation 
(see <a href="../erts/erlang#hibernate/3">erts/erlang#hibernate/3</a>) if a callback function in
a handler module specifies <strong>hibernate</strong> in its return value.
This can be useful if the server is expected to be idle for a long
time. However, use this feature with care, as hibernation
implies at least two garbage collections (when hibernating and
shortly after waking up) and is not something you want to do
between each event handled by a busy event manager.Notice that when multiple event handlers are
invoked, it is sufficient that one single event handler returns a
<strong>hibernate</strong> request for the whole event manager to go into
hibernation.Unless otherwise stated, all functions in this module fail if
the specified event manager does not exist or if bad arguments are
specified.</p><h2>Data Types</h2><span class="name">handler</span><span class="name">handler_args</span><span class="name">add_handler_ret</span><span class="name">del_handler_ret</span><h2>Functions</h2><h3>add_handler(EventMgrRef, Handler, Args) -&gt; Result</h3><p>Add an event handler to a generic event manager.</p><ul><li><span class="v">EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</span></li><li><span class="v">Name = Node = atom()</span></li><li><span class="v">GlobalName = ViaName = term()</span></li><li><span class="v">Handler = Module | {Module,Id}</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Id = term()</span></li><li><span class="v">Args = term()</span></li><li><span class="v">Result = ok | {'EXIT',Reason} | term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a new event handler to event manager <strong>EventMgrRef</strong>.
The event manager calls
<a href="#Module:init/1">Module:init/1</a>
to initiate the event handler and its internal state.</p><p><strong>EventMgrRef</strong> can be any of the following:</p><ul><li>The pid</li><li><strong>Name</strong>, if the event manager is locally registered</li><li><strong>{Name,Node}</strong>, if the event manager is locally registered at another node</li><li><strong>{global,GlobalName}</strong>, if the event manager is globally registered</li><li><strong>{via,Module,ViaName}</strong>, if the event manager is registered through an alternative process registry</li></ul><p><strong>Handler</strong> is the name of the callback module <strong>Module</strong> or
a tuple <strong>{Module,Id}</strong>, where <strong>Id</strong> is any term.
The <strong>{Module,Id}</strong> representation makes it possible to
identify a specific event handler when many event handlers
use the same callback module.</p><p><strong>Args</strong> is any term that is passed as the argument
to <strong>Module:init/1</strong>.</p><p>If <strong>Module:init/1</strong> returns a correct value indicating
successful completion, the event manager adds the event
handler and this function returns
<strong>ok</strong>. If <strong>Module:init/1</strong> fails with <strong>Reason</strong> or
returns <strong>{error,Reason}</strong>, the event handler is
ignored and this function returns <strong>{'EXIT',Reason}</strong> or
<strong>{error,Reason}</strong>, respectively.</p><h3>add_sup_handler(EventMgrRef, Handler, Args) -&gt; Result</h3><p>Add a supervised event handler to a generic event manager. </p><ul><li><span class="v">EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</span></li><li><span class="v">Name = Node = atom()</span></li><li><span class="v">GlobalName = ViaName = term()</span></li><li><span class="v">Handler = Module | {Module,Id}</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Id = term()</span></li><li><span class="v">Args = term()</span></li><li><span class="v">Result = ok | {'EXIT',Reason} | term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a new event handler in the same way as
<a href="#add_handler/3">add_handler/3</a>,
but also supervises the connection between the event handler
and the calling process.</p><ul><li>If the calling process later terminates with <strong>Reason</strong>, the event manager deletes the event handler by calling <a href="#Module:terminate/2">Module:terminate/2</a> with <strong>{stop,Reason}</strong> as argument. </li><li> <p>If the event handler is deleted later, the event manager
sends a message <strong>{gen_event_EXIT,Handler,Reason}</strong> to
the calling process. <strong>Reason</strong> is one of the following:</p> <ul><li> <p><strong>normal</strong>, if the event handler has been removed
because of a
call to <strong>delete_handler/3</strong>, or <strong>remove_handler</strong>
has been returned by a callback function (see below).</p> </li><li> <p><strong>shutdown</strong>, if the event handler has been removed
because the event manager is terminating.</p> </li><li> <p><strong>{swapped,NewHandler,Pid}</strong>, if the process <strong>Pid</strong>
has replaced the event handler with another event handler
<strong>NewHandler</strong> using a call to
<a href="#swap_handler/3">swap_handler/3</a> or
<a href="#swap_sup_handler/3">swap_sup_handler/3</a>.</p> </li><li> <p>A term, if the event handler is removed because of an error.
Which term depends on the error.</p></li></ul> </li></ul><p>For a description of the arguments and return values, see
<a href="#add_handler/3">add_handler/3</a>.</p><h3>call(EventMgrRef, Handler, Request) -&gt; Result</h3><h3>call(EventMgrRef, Handler, Request, Timeout) -&gt; Result</h3><p>Make a synchronous call to a generic event manager.</p><ul><li><span class="v">EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</span></li><li><span class="v">Name = Node = atom()</span></li><li><span class="v">GlobalName = ViaName = term()</span></li><li><span class="v">Handler = Module | {Module,Id}</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Id = term()</span></li><li><span class="v">Request = term()</span></li><li><span class="v">Timeout = int()&gt;0 | infinity</span></li><li><span class="v">Result = Reply | {error,Error}</span></li><li><span class="v">Reply = term()</span></li><li><span class="v">Error = bad_module | {'EXIT',Reason} | term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Makes a synchronous call to event handler <strong>Handler</strong>
installed in event manager <strong>EventMgrRef</strong> by sending a
request and waiting until a reply arrives or a time-out occurs.
The event manager calls <a href="#Module:handle_call/2">Module:handle_call/2</a> to handle the request.</p><p>For a description of <strong>EventMgrRef</strong> and <strong>Handler</strong>, see
<a href="#add_handler/3">add_handler/3</a>.</p><p><strong>Request</strong> is any term that is passed as one of
the arguments to <strong>Module:handle_call/2</strong>.</p><p><strong>Timeout</strong> is an integer greater than zero that specifies
how many milliseconds to wait for a reply, or the atom
<strong>infinity</strong> to wait indefinitely. Defaults to 5000.
If no reply is received within the specified time, the function
call fails.</p><p>The return value <strong>Reply</strong> is defined in the return value of
<strong>Module:handle_call/2</strong>. If the specified event handler is not
installed, the function returns <strong>{error,bad_module}</strong>. If
the callback function fails with <strong>Reason</strong> or returns an
unexpected value <strong>Term</strong>, this function returns
<strong>{error,{'EXIT',Reason}}</strong> or <strong>{error,Term}</strong>,
respectively.</p><h3>delete_handler(EventMgrRef, Handler, Args) -&gt; Result</h3><p>Delete an event handler from a generic event manager.</p><ul><li><span class="v">EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</span></li><li><span class="v">Name = Node = atom()</span></li><li><span class="v">GlobalName = ViaName = term()</span></li><li><span class="v">Handler = Module | {Module,Id}</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Id = term()</span></li><li><span class="v">Args = term()</span></li><li><span class="v">Result = term() | {error,module_not_found} | {'EXIT',Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Deletes an event handler from event manager
<strong>EventMgrRef</strong>. The event manager calls
<a href="#Module:terminate/2">Module:terminate/2</a> to terminate the event
handler.</p><p>For a description of <strong>EventMgrRef</strong> and <strong>Handler</strong>, see
<a href="#add_handler/3">add_handler/3</a>.</p><p><strong>Args</strong> is any term that is passed as one of
the arguments to <strong>Module:terminate/2</strong>.</p><p>The return value is the return value of <strong>Module:terminate/2</strong>.
If the specified event handler is not installed, the function
returns <strong>{error,module_not_found}</strong>. If the callback function
fails with <strong>Reason</strong>, the function returns
<strong>{'EXIT',Reason}</strong>.</p><h3>notify(EventMgrRef, Event) -&gt; ok</h3><h3>sync_notify(EventMgrRef, Event) -&gt; ok</h3><p>Notify an event manager about an event.</p><ul><li><span class="v">EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</span></li><li><span class="v">Name = Node = atom()</span></li><li><span class="v">GlobalName = ViaName = term()</span></li><li><span class="v">Event = term()</span></li></ul><p>Sends an event notification to event manager
<strong>EventMgrRef</strong>. The event manager calls
<a href="#Module:handle_event/2">Module:handle_event/2</a>
for each installed event handler to handle the event.</p><p><strong>notify/2</strong> is asynchronous and returns immediately after
the event notification has been sent. <strong>sync_notify/2</strong> is
synchronous in the sense that it returns <strong>ok</strong> after
the event has been handled by all event handlers.</p><p>For a description of <strong>EventMgrRef</strong>, see
<a href="#add_handler/3">add_handler/3</a>.</p><p><strong>Event</strong> is any term that is passed as one of
the arguments to <a href="#Module:handle_event/2">Module:handle_event/2</a>.</p><p><strong>notify/1</strong> does not fail even if the specified event manager
does not exist, unless it is specified as <strong>Name</strong>.</p><h3>start() -&gt; Result</h3><h3>start(EventMgrName | Options) -&gt; Result</h3><h3>start(EventMgrName, Options) -&gt; Result</h3><p>Create a stand-alone event manager process.</p><ul><li><span class="v">EventMgrName = {local,Name} | {global,GlobalName} | {via,Module,ViaName}</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">GlobalName = ViaName = term()</span></li><li><span class="v">Options = [Option]</span></li><li><span class="v">Option = {debug,Dbgs} | {timeout,Time} | {hibernate_after,HibernateAfterTimeout} | {spawn_opt,SOpts}</span></li><li><span class="v">Dbgs = [Dbg]</span></li><li><span class="v">Dbg = trace | log | statistics | {log_to_file,FileName} | {install,{Func,FuncState}}</span></li><li><span class="v">SOpts = [term()]</span></li><li><span class="v">Result = {ok,Pid} | {error,{already_started,Pid}}</span></li><li><span class="v">Pid = pid()</span></li></ul><p>Creates a stand-alone event manager process, that is, an event
manager that is not part of a supervision tree and thus has
no supervisor.</p><p>For a description of the arguments and return values, see
<a href="#start_link/0">start_link/0</a>.</p><h3>start_link() -&gt; Result</h3><h3>start_link(EventMgrName | Options) -&gt; Result</h3><h3>start_link(EventMgrName, Options) -&gt; Result</h3><p>Create a generic event manager process in a supervision tree. </p><ul><li><span class="v">EventMgrName = {local,Name} | {global,GlobalName} | {via,Module,ViaName}</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">GlobalName = ViaName = term()</span></li><li><span class="v">Options = [Option]</span></li><li><span class="v">Option = {debug,Dbgs} | {timeout,Time} | {hibernate_after,HibernateAfterTimeout} | {spawn_opt,SOpts}</span></li><li><span class="v">Dbgs = [Dbg]</span></li><li><span class="v">Dbg = trace | log | statistics | {log_to_file,FileName} | {install,{Func,FuncState}}</span></li><li><span class="v">SOpts = [term()]</span></li><li><span class="v">Result = {ok,Pid} | {error,{already_started,Pid}}</span></li><li><span class="v">Pid = pid()</span></li></ul><p>Creates an event manager process as part of a supervision
tree. The function is to be called, directly or indirectly,
by the supervisor. For example, it ensures that
the event manager is linked to the supervisor.</p><ul><li> <p>If <strong>EventMgrName={local,Name}</strong>, the event manager is
registered locally as <strong>Name</strong> using <strong>register/2</strong>.</p> </li><li> <p>If <strong>EventMgrName={global,GlobalName}</strong>, the event manager is
registered globally as <strong>GlobalName</strong> using
<a href="../kernel/global#register_name/2">kernel/global#register_name/2</a>.
If no name is provided, the event manager is not registered.</p> </li><li> <p>If <strong>EventMgrName={via,Module,ViaName}</strong>, the event manager
registers with the registry represented by <strong>Module</strong>.
The <strong>Module</strong> callback is to export the functions
<strong>register_name/2</strong>, <strong>unregister_name/1</strong>,
<strong>whereis_name/1</strong>, and <strong>send/2</strong>, which are to behave
as the corresponding functions in
<a href="./global">kernel/global</a>.
Thus, <strong>{via,global,GlobalName}</strong> is a valid reference.</p> </li><li> <p>If option <strong>{hibernate_after,HibernateAfterTimeout}</strong> is present, the <strong>gen_event</strong>
process awaits any message for <strong>HibernateAfterTimeout</strong> milliseconds and
if no message is received, the process goes into hibernation automatically
(by calling <a href="./proc_lib#hibernate/3">proc_lib#hibernate/3</a>).</p> </li></ul><p>If the event manager is successfully created, the function
returns <strong>{ok,Pid}</strong>, where <strong>Pid</strong> is the pid of
the event manager. If a process with the specified
<strong>EventMgrName</strong> exists already, the function returns
<strong>{error,{already_started,Pid}}</strong>, where <strong>Pid</strong> is
the pid of that process.</p><h3>stop(EventMgrRef) -&gt; ok</h3><h3>stop(EventMgrRef, Reason, Timeout) -&gt; ok</h3><p>Terminate a generic event manager.</p><ul><li><span class="v">EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</span></li><li><span class="v">Name = Node = atom()</span></li><li><span class="v">GlobalName = ViaName = term()</span></li><li><span class="v">Reason = term()</span></li><li><span class="v">Timeout = int()&gt;0 | infinity</span></li></ul><p>Orders event manager <strong>EventMgrRef</strong> to exit with
the specifies <strong>Reason</strong> and waits for it to
terminate. Before terminating, <strong>gen_event</strong> calls
<a href="#Module:terminate/2">Module:terminate/2</a>
for each installed event handler.</p><p>The function returns <strong>ok</strong> if the event manager terminates
with the expected reason. Any other reason than <strong>normal</strong>,
<strong>shutdown</strong>, or <strong>{shutdown,Term}</strong> causes an
error report to be issued using
<a href="./logger">kernel/logger</a>.
The default <strong>Reason</strong> is <strong>normal</strong>.</p><p><strong>Timeout</strong> is an integer greater than zero that
specifies how many milliseconds to wait for the event manager to
terminate, or the atom <strong>infinity</strong> to wait
indefinitely. Defaults to <strong>infinity</strong>. If the
event manager has not terminated within the specified time, a
<strong>timeout</strong> exception is raised.</p><p>If the process does not exist, a <strong>noproc</strong> exception
is raised.</p><p>For a description of <strong>EventMgrRef</strong>, see
<a href="#add_handler/3">add_handler/3</a>.</p><h3>swap_handler(EventMgrRef, {Handler1,Args1}, {Handler2,Args2}) -&gt; Result</h3><p>Replace an event handler in a generic event manager.</p><ul><li><span class="v">EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</span></li><li><span class="v">Name = Node = atom()</span></li><li><span class="v">GlobalName = ViaName = term()</span></li><li><span class="v">Handler1 = Handler2 = Module | {Module,Id}</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Id = term()</span></li><li><span class="v">Args1 = Args2 = term()</span></li><li><span class="v">Result = ok | {error,Error}</span></li><li><span class="v">Error = {'EXIT',Reason} | term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Replaces an old event handler with a new event handler in
event manager <strong>EventMgrRef</strong>.</p><p>For a description of the arguments, see
<a href="#add_handler/3">add_handler/3</a>.</p><p>First the old event handler <strong>Handler1</strong> is deleted.
The event manager calls <strong>Module1:terminate(Args1, ...)</strong>,
where <strong>Module1</strong> is the callback module of <strong>Handler1</strong>,
and collects the return value.</p><p>Then the new event handler <strong>Handler2</strong> is added and initiated
by calling <strong>Module2:init({Args2,Term})</strong>, where <strong>Module2</strong>
is the callback module of <strong>Handler2</strong> and <strong>Term</strong> is
the return value of <strong>Module1:terminate/2</strong>. This makes it
possible to transfer information from <strong>Handler1</strong> to
<strong>Handler2</strong>.</p><p>The new handler is added even if the the specified old event
handler is not installed, in which case <strong>Term=error</strong>, or if
<strong>Module1:terminate/2</strong> fails with <strong>Reason</strong>,
in which case <strong>Term={'EXIT',Reason}</strong>.
The old handler is deleted even if <strong>Module2:init/1</strong> fails.</p><p>If there was a supervised connection between <strong>Handler1</strong> and
a process <strong>Pid</strong>, there is a supervised connection
between <strong>Handler2</strong> and <strong>Pid</strong> instead.</p><p>If <strong>Module2:init/1</strong> returns a correct value, this function
returns <strong>ok</strong>. If <strong>Module2:init/1</strong> fails with
<strong>Reason</strong> or returns an unexpected value <strong>Term</strong>,
this function returns <strong>{error,{'EXIT',Reason}}</strong> or
<strong>{error,Term}</strong>, respectively.</p><h3>swap_sup_handler(EventMgrRef, {Handler1,Args1}, {Handler2,Args2}) -&gt; Result</h3><p>Replace an event handler in a generic event manager.</p><ul><li><span class="v">EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</span></li><li><span class="v">Name = Node = atom()</span></li><li><span class="v">GlobalName = ViaName = term()</span></li><li><span class="v">Handler1 = Handler 2 = Module | {Module,Id}</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Id = term()</span></li><li><span class="v">Args1 = Args2 = term()</span></li><li><span class="v">Result = ok | {error,Error}</span></li><li><span class="v">Error = {'EXIT',Reason} | term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Replaces an event handler in event manager <strong>EventMgrRef</strong>
in the same way as <strong>swap_handler/3</strong>, but also supervises
the connection between <strong>Handler2</strong> and the calling process.</p><p>For a description of the arguments and return values, see 
<a href="#swap_handler/3">swap_handler/3</a>.</p><h3>which_handlers(EventMgrRef) -&gt; [Handler]</h3><p>Return all event handlers installed in a generic event manager. </p><ul><li><span class="v">EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</span></li><li><span class="v">Name = Node = atom()</span></li><li><span class="v">GlobalName = ViaName = term()</span></li><li><span class="v">Handler = Module | {Module,Id}</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Id = term()</span></li></ul><p>Returns a list of all event handlers installed in event
manager <strong>EventMgrRef</strong>.</p><p>For a description of <strong>EventMgrRef</strong> and <strong>Handler</strong>, see
<a href="#add_handler/3">add_handler/3</a>.</p><h3>Callback Functions</h3><p>The following functions are to be exported from a <strong>gen_event</strong>
callback module.</p><h2>Functions</h2><h3>Module:code_change(OldVsn, State, Extra) -&gt; {ok, NewState}</h3><p>Update the internal state during upgrade/downgrade.</p><ul><li><span class="v">OldVsn = Vsn | {down, Vsn}</span></li><li><span class="v">Vsn = term()</span></li><li><span class="v">State = NewState = term()</span></li><li><span class="v">Extra = term()</span></li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This callback is optional, so callback modules need not export it.
If a release upgrade/downgrade with <strong>Change={advanced,Extra}</strong>
specified in the <strong>.appup</strong> file is made when <strong>code_change/3</strong>
isn't implemented the event handler will crash with an <strong>undef</strong> error
reason.</p></div><p>This function is called for an installed event handler that
is to update its internal state during a release
upgrade/downgrade, that is, when the instruction
<strong>{update,Module,Change,...}</strong>, where
<strong>Change={advanced,Extra}</strong>, is specified in the <strong>.appup</strong>
file. For more information, see <a href="./users_guide">OTP Design Principles</a>.</p><p>For an upgrade, <strong>OldVsn</strong> is <strong>Vsn</strong>, and for a downgrade,
<strong>OldVsn</strong> is <strong>{down,Vsn}</strong>. <strong>Vsn</strong> is defined by the
<strong>vsn</strong> attribute(s) of the old version of the callback module
<strong>Module</strong>. If no such attribute is defined, the version
is the checksum of the Beam file.</p><p><strong>State</strong> is the internal state of the event handler.</p><p><strong>Extra</strong> is passed "as is" from the <strong>{advanced,Extra}</strong>
part of the update instruction.</p><p>The function is to return the updated internal state.</p><h3>Module:format_status(Opt, [PDict, State]) -&gt; Status</h3><p>Optional function for providing a term describing the current event handler state.</p><ul><li><span class="v">Opt = normal | terminate</span></li><li><span class="v">PDict = [{Key, Value}]</span></li><li><span class="v">State = term()</span></li><li><span class="v">Status = term()</span></li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This callback is optional, so event handler modules need
not export it. If a handler does not export this function,
the <strong>gen_event</strong> module uses the handler state directly for
the purposes described below.</p></div><p>This function is called by a <strong>gen_event</strong> process in the
following situations:</p><ul><li>One of <a href="./sys#get_status/1">sys#get_status/1</a> is invoked to get the <strong>gen_event</strong> status. <strong>Opt</strong> is set to the atom <strong>normal</strong> for this case.</li><li>The event handler terminates abnormally and <strong>gen_event</strong> logs an error. <strong>Opt</strong> is set to the atom <strong>terminate</strong> for this case.</li></ul><p>This function is useful for changing the form and
appearance of the event handler state for these cases. An
event handler callback module wishing to change the
the <strong>sys:get_status/1,2</strong> return value as well as how
its state appears in termination error logs, exports an
instance of <strong>format_status/2</strong> that returns a term
describing the current state of the event handler.</p><p><strong>PDict</strong> is the current value of the
process dictionary of <strong>gen_event</strong>.</p><p><strong>State</strong> is the internal state of the event handler.</p><p>The function is to return <strong>Status</strong>, a term that
change the details of the current state of the event
handler. Any term is allowed for <strong>Status</strong>. The
<strong>gen_event</strong> module uses <strong>Status</strong> as follows:</p><ul><li><p>When <strong>sys:get_status/1,2</strong> is called, <strong>gen_event</strong>
ensures that its return value contains <strong>Status</strong> in
place of the state term of the event handler.</p></li><li><p>When an event handler terminates abnormally, <strong>gen_event</strong>
logs <strong>Status</strong> in place of the state term of the
event handler.</p></li></ul><p>One use for this function is to return compact alternative
state representations to avoid that large state terms
are printed in log files.</p><h3>Module:handle_call(Request, State) -&gt; Result</h3><p>Handle a synchronous request.</p><ul><li><span class="v">Request = term()</span></li><li><span class="v">State = term()</span></li><li><span class="v">Result = {ok,Reply,NewState} | {ok,Reply,NewState,hibernate}</span></li><li><span class="v">| {swap_handler,Reply,Args1,NewState,Handler2,Args2}</span></li><li><span class="v">| {remove_handler, Reply}</span></li><li><span class="v">Reply = term()</span></li><li><span class="v">NewState = term()</span></li><li><span class="v">Args1 = Args2 = term()</span></li><li><span class="v">Handler2 = Module2 | {Module2,Id}</span></li><li><span class="v">Module2 = atom()</span></li><li><span class="v">Id = term()</span></li></ul><p>Whenever an event manager receives a request sent using
<a href="#call/3">call/3</a>,
this function is called for
the specified event handler to handle the request.</p><p><strong>Request</strong> is the <strong>Request</strong> argument of <strong>call/3,4</strong>.</p><p><strong>State</strong> is the internal state of the event handler.</p><p>The return values are the same as for
<a href="#Module:handle_event/2">Module:handle_event/2</a>
except that they also contain a term <strong>Reply</strong>, which is the reply
to the client as the return value of <strong>call/3,4</strong>.</p><h3>Module:handle_event(Event, State) -&gt; Result</h3><p>Handle an event.</p><ul><li><span class="v">Event = term()</span></li><li><span class="v">State = term()</span></li><li><span class="v">Result = {ok,NewState} | {ok,NewState,hibernate} </span></li><li><span class="v">| {swap_handler,Args1,NewState,Handler2,Args2} | remove_handler</span></li><li><span class="v">NewState = term()</span></li><li><span class="v">Args1 = Args2 = term()</span></li><li><span class="v">Handler2 = Module2 | {Module2,Id}</span></li><li><span class="v">Module2 = atom()</span></li><li><span class="v">Id = term()</span></li></ul><p>Whenever an event manager receives an event sent using
<a href="#notify/2">notify/2</a> or
<a href="#sync_notify/2">sync_notify/2</a>,
this function is called for each installed event handler to handle
the event.</p><p><strong>Event</strong> is the <strong>Event</strong> argument of
<strong>notify/2</strong>/<strong>sync_notify/2</strong>.</p><p><strong>State</strong> is the internal state of the event handler.</p><ul><li> <p>If <strong>{ok,NewState}</strong> or <strong>{ok,NewState,hibernate}</strong>
is returned, the event handler
remains in the event manager with the possible updated
internal state <strong>NewState</strong>.</p> </li><li> <p>If <strong>{ok,NewState,hibernate}</strong> is returned, the event
manager also goes into hibernation (by calling
<a href="./proc_lib#hibernate/3">proc_lib#hibernate/3</a>), waiting for the next
event to occur. It is sufficient that one of the
event handlers return <strong>{ok,NewState,hibernate}</strong> for the
whole event manager process to hibernate.</p> </li><li> <p>If <strong>{swap_handler,Args1,NewState,Handler2,Args2}</strong> is
returned, the event handler is replaced by <strong>Handler2</strong> by
first calling <strong>Module:terminate(Args1,NewState)</strong> and then
<strong>Module2:init({Args2,Term})</strong>, where <strong>Term</strong> is the return
value of <strong>Module:terminate/2</strong>. For more information, see
<a href="#swap_handler/3">swap_handler/3</a>.
</p> </li><li> <p>If <strong>remove_handler</strong> is returned, the event handler is
deleted by calling
<strong>Module:terminate(remove_handler,State)</strong>.</p> </li></ul><h3>Module:handle_info(Info, State) -&gt; Result</h3><p>Handle an incoming message.</p><ul><li><span class="v">Info = term()</span></li><li><span class="v">State = term()</span></li><li><span class="v">Result = {ok,NewState} | {ok,NewState,hibernate}</span></li><li><span class="v">| {swap_handler,Args1,NewState,Handler2,Args2} | remove_handler</span></li><li><span class="v">NewState = term()</span></li><li><span class="v">Args1 = Args2 = term()</span></li><li><span class="v">Handler2 = Module2 | {Module2,Id}</span></li><li><span class="v">Module2 = atom()</span></li><li><span class="v">Id = term()</span></li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This callback is optional, so callback modules need not
export it. The <strong>gen_event</strong> module provides a default
implementation of this function that logs about the unexpected
<strong>Info</strong> message, drops it and returns <strong>{ok, State}</strong>.</p></div><p>This function is called for each installed event handler when
an event manager receives any other message than an event or
a synchronous request (or a system message).</p><p><strong>Info</strong> is the received message.</p><p>For a description of <strong>State</strong> and possible return values, see
<a href="#Module:handle_event/2">Module:handle_event/2</a>.</p><h3>Module:init(InitArgs) -&gt; {ok,State} | {ok,State,hibernate} | {error,Reason}</h3><p>Initialize an event handler.</p><ul><li><span class="v">InitArgs = Args | {Args,Term}</span></li><li><span class="v">Args = Term = term()</span></li><li><span class="v">State = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Whenever a new event handler is added to an event manager,
this function is called to initialize the event handler.</p><p>If the event handler is added because of a call to
<a href="#add_handler/3">add_handler/3</a> or
<a href="#add_sup_handler/3">add_sup_handler/3</a>, <strong>InitArgs</strong> is
the <strong>Args</strong> argument of these functions.</p><p>If the event handler replaces another event handler because of
a call to
<a href="#swap_handler/3">swap_handler/3</a> or
<a href="#swap_sup_handler/3">swap_sup_handler/3</a>, or because of a <strong>swap</strong>
return tuple from one of the other callback functions,
<strong>InitArgs</strong> is a tuple <strong>{Args,Term}</strong>, where <strong>Args</strong> is
the argument provided in the function call/return tuple and
<strong>Term</strong> is the result of terminating the old event handler, see
<a href="#swap_handler/3">swap_handler/3</a>.</p><p>If successful, the function returns <strong>{ok,State}</strong>
or <strong>{ok,State,hibernate}</strong>, where <strong>State</strong> is the
initial internal state of the event handler.</p><p>If <strong>{ok,State,hibernate}</strong> is returned, the event
manager goes into hibernation (by calling <a href="./proc_lib#hibernate/3">proc_lib#hibernate/3</a>),
waiting for the next event to occur.</p><h3>Module:terminate(Arg, State) -&gt; term()</h3><p>Clean up before deletion.</p><ul><li><span class="v">Arg = Args | {stop,Reason} | stop | remove_handler</span></li><li><span class="v">| {error,{'EXIT',Reason}} | {error,Term}</span></li><li><span class="v">Args = Reason = Term = term()</span></li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This callback is optional, so callback modules need not
export it. The <strong>gen_event</strong> module provides a default
implementation without cleanup.</p></div><p>Whenever an event handler is deleted from an event manager,
this function is called. It is to be the opposite of
<a href="#Module:init/1">Module:init/1</a>
and do any necessary cleaning up.</p><p>If the event handler is deleted because of a call to
<a href="#delete_handler/3">delete_handler/3</a>,
<a href="#swap_handler/3">swap_handler/3</a>, or
<a href="#swap_sup_handler/3">swap_sup_handler/3</a>, <strong>Arg</strong> is
the <strong>Args</strong> argument of this function call.</p><p><strong>Arg={stop,Reason}</strong> if the event handler has a supervised
connection to a process that has terminated with reason
<strong>Reason</strong>.</p><p><strong>Arg=stop</strong> if the event handler is deleted because
the event manager is terminating.</p><p>The event manager terminates if it is part of a supervision
tree and it is ordered by its supervisor to terminate.
Even if it is <em>not</em> part of a supervision tree, it
terminates if it receives an <strong>'EXIT'</strong> message from
its parent.</p><p><strong>Arg=remove_handler</strong> if the event handler is deleted because
another callback function has returned <strong>remove_handler</strong> or
<strong>{remove_handler,Reply}</strong>.</p><p><strong>Arg={error,Term}</strong> if the event handler is deleted because
a callback function returned an unexpected value <strong>Term</strong>,
or <strong>Arg={error,{'EXIT',Reason}}</strong> if a callback function
failed.</p><p><strong>State</strong> is the internal state of the event handler.</p><p>The function can return any term. If the event handler is
deleted because of a call to <strong>gen_event:delete_handler/3</strong>,
the return value of that function becomes the return value of this
function. If the event handler is to be replaced with another event
handler because of a swap, the return value is passed to
the <strong>init</strong> function of the new event handler. Otherwise
the return value is ignored.</p><h3>See Also</h3><p><a href="supervisor">supervisor</a>,
<a href="sys">sys</a></p><h2>gen_fsm</h2><p>Deprecated and replaced by gen_statem</p><p> Deprecated and replaced by  <a href="gen_statem">gen_statem</a> </p><a name="Migration to gen_statem"></a><h3>Migration to gen_statem</h3><p>Here follows a simple example of turning a gen_fsm into
a <a href="gen_statem">gen_statem</a>. The example comes
from the previous Users Guide for <strong>gen_fsm</strong> </p><pre><code class="erl">
-module(code_lock).
-define(NAME, code_lock).
%-define(BEFORE_REWRITE, true).

-ifdef(BEFORE_REWRITE).
-behaviour(gen_fsm).
-else.
-behaviour(gen_statem).
-endif.

-export([start_link/1, button/1, stop/0]).

-ifdef(BEFORE_REWRITE).
-export([init/1, locked/2, open/2, handle_sync_event/4, handle_event/3,
	 handle_info/3, terminate/3, code_change/4]).
-else.
-export([init/1, callback_mode/0, locked/3, open/3, terminate/3, code_change/4]).
%% Add callback__mode/0
%% Change arity of the state functions
%% Remove handle_info/3
-endif.

-ifdef(BEFORE_REWRITE).
start_link(Code) -&gt;
    gen_fsm:start_link({local, ?NAME}, ?MODULE, Code, []).
-else.
start_link(Code) -&gt;
    gen_statem:start_link({local,?NAME}, ?MODULE, Code, []).
-endif.

-ifdef(BEFORE_REWRITE).
button(Digit) -&gt;
    gen_fsm:send_event(?NAME, {button, Digit}).
-else.
button(Digit) -&gt;
    gen_statem:cast(?NAME, {button,Digit}).
    %% send_event is asynchronous and becomes a cast
-endif.

-ifdef(BEFORE_REWRITE).
stop() -&gt;
    gen_fsm:sync_send_all_state_event(?NAME, stop).
-else.
stop() -&gt;
    gen_statem:call(?NAME, stop).
    %% sync_send is synchronous and becomes call
    %% all_state is handled by callback code in gen_statem
-endif.

init(Code) -&gt;
    do_lock(),
    Data = #{code =&gt; Code, remaining =&gt; Code},
    {ok, locked, Data}.

-ifdef(BEFORE_REWRITE).
-else.
callback_mode() -&gt;
    state_functions.
%% state_functions mode is the mode most similar to
%% gen_fsm. There is also handle_event mode which is
%% a fairly different concept. 
-endif.

-ifdef(BEFORE_REWRITE).
locked({button, Digit}, Data0) -&gt;
    case analyze_lock(Digit, Data0) of
	{open = StateName, Data} -&gt;
	    {next_state, StateName, Data, 10000};
	{StateName, Data} -&gt;
	    {next_state, StateName, Data}
    end.
-else.
locked(cast, {button,Digit}, Data0) -&gt;
    case analyze_lock(Digit, Data0) of
	{open = StateName, Data} -&gt;
	    {next_state, StateName, Data, 10000};
	{StateName, Data} -&gt;
	    {next_state, StateName, Data}
    end;
locked({call, From}, Msg, Data) -&gt;    
    handle_call(From, Msg, Data);
locked({info, Msg}, StateName, Data) -&gt;    
    handle_info(Msg, StateName, Data).
%% Arity differs
%% All state events are dispatched to handle_call and handle_info help
%% functions. If you want to handle a call or cast event specifically
%% for this state you would add a special clause for it above. 
-endif.										

-ifdef(BEFORE_REWRITE).
open(timeout, State) -&gt;
     do_lock(),
    {next_state, locked, State};
open({button,_}, Data) -&gt;
    {next_state, locked, Data}.
-else.
open(timeout, _, Data) -&gt;
    do_lock(),
    {next_state, locked, Data};
open(cast, {button,_}, Data) -&gt;
    {next_state, locked, Data};
open({call, From}, Msg, Data) -&gt;    
    handle_call(From, Msg, Data);
open(info, Msg, Data) -&gt;    
    handle_info(Msg, open, Data).
%% Arity differs
%% All state events are dispatched to handle_call and handle_info help
%% functions. If you want to handle a call or cast event specifically
%% for this state you would add a special clause for it above.   
-endif.	  

-ifdef(BEFORE_REWRITE).
handle_sync_event(stop, _From, _StateName, Data) -&gt;
    {stop, normal, ok, Data}.

handle_event(Event, StateName, Data) -&gt;
    {stop, {shutdown, {unexpected, Event, StateName}}, Data}.

handle_info(Info, StateName, Data) -&gt;
    {stop, {shutdown, {unexpected, Info, StateName}}, StateName, Data}. 
-else.   
-endif.	
  
terminate(_Reason, State, _Data) -&gt;
    State =/= locked andalso do_lock(),
    ok.
code_change(_Vsn, State, Data, _Extra) -&gt;
    {ok, State, Data}.

%% Internal functions
-ifdef(BEFORE_REWRITE).
-else.   
handle_call(From, stop, Data) -&gt;
     {stop_and_reply, normal,  {reply, From, ok}, Data}.

handle_info(Info, StateName, Data) -&gt;
    {stop, {shutdown, {unexpected, Info, StateName}}, StateName, Data}.
%% These are internal functions for handling all state events
%% and not behaviour callbacks as in gen_fsm
-endif.	

analyze_lock(Digit, #{code := Code, remaining := Remaining} = Data) -&gt;
     case Remaining of
         [Digit] -&gt;
	     do_unlock(),
	     {open,  Data#{remaining := Code}};
         [Digit|Rest] -&gt; % Incomplete   
             {locked, Data#{remaining := Rest}};
         _Wrong -&gt;
             {locked, Data#{remaining := Code}}
     end.

do_lock() -&gt;
    io:format("Lock~n", []).
do_unlock() -&gt;
    io:format("Unlock~n", []).
    </code></pre><h2>gen_server</h2><p>Generic server behavior.</p><p>This behavior module provides the server of a client-server
relation. A generic server process (<strong>gen_server</strong>) implemented using
this module has a standard set of interface functions and
includes functionality for tracing and error reporting. It also
fits into an OTP supervision tree. For more information, see section
<a href="./gen_server_concepts"> gen_server Behaviour</a> in OTP Design Principles.A <strong>gen_server</strong> process assumes all specific parts to be located in
a callback module exporting a predefined set of functions.
The relationship between the behavior functions and the callback
functions is as follows:<pre>
gen_server module            Callback module
-----------------            ---------------
gen_server:start
gen_server:start_link -----&gt; Module:init/1

gen_server:stop       -----&gt; Module:terminate/2

gen_server:call
gen_server:multi_call -----&gt; Module:handle_call/3

gen_server:cast
gen_server:abcast     -----&gt; Module:handle_cast/2

-                     -----&gt; Module:handle_info/2

-                     -----&gt; Module:handle_continue/2

-                     -----&gt; Module:terminate/2

-                     -----&gt; Module:code_change/3</pre>If a callback function fails or returns a bad value, the
<strong>gen_server</strong> process terminates.A <strong>gen_server</strong> process handles system messages as described in
<a href="sys">sys</a>. The <strong>sys</strong> module
can be used for debugging a <strong>gen_server</strong> process.Notice that a <strong>gen_server</strong> process does not trap exit signals
automatically, this must be explicitly initiated in the callback
module.Unless otherwise stated, all functions in this module fail if
the specified <strong>gen_server</strong> process does not exist or if bad
arguments are specified.The <strong>gen_server</strong> process can go into hibernation
(see <a href="../erts/erlang#hibernate/3">erts/erlang#hibernate/3</a>) if a callback
function specifies <strong>'hibernate'</strong> instead of a time-out value. This
can be useful if the server is expected to be idle for a long
time. However, use this feature with care, as hibernation
implies at least two garbage collections (when hibernating and
shortly after waking up) and is not something you want to do
between each call to a busy server.If the <strong>gen_server</strong> process needs to perform an action
immediately after initialization or to break the execution of a
callback into multiple steps, it can return <strong>{continue,Continue}</strong>
in place of the time-out or hibernation value, which will immediately
invoke the <strong>handle_continue/2</strong> callback.</p><h2>Functions</h2><h3>abcast(Name, Request) -&gt; abcast</h3><h3>abcast(Nodes, Name, Request) -&gt; abcast</h3><p>Send an asynchronous request to many generic servers.</p><ul><li><span class="v">Nodes = [Node]</span></li><li><span class="v">Node = atom()</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">Request = term()</span></li></ul><p>Sends an asynchronous request to the <strong>gen_server</strong> processes
locally registered as <strong>Name</strong> at the specified nodes. The function
returns immediately and ignores nodes that do not exist, or
where the <strong>gen_server</strong> <strong>Name</strong> does not exist.
The <strong>gen_server</strong> processes call
<a href="#Module:handle_cast/2">Module:handle_cast/2</a> to handle the request.</p><p>For a description of the arguments, see
<a href="#multi_call/2">multi_call/2</a>.</p><h3>call(ServerRef, Request) -&gt; Reply</h3><h3>call(ServerRef, Request, Timeout) -&gt; Reply</h3><p>Make a synchronous call to a generic server.</p><ul><li><span class="v">ServerRef = Name | {Name,Node} | {global,GlobalName}</span></li><li><span class="v">| {via,Module,ViaName} | pid()</span></li><li><span class="v">Node = atom()</span></li><li><span class="v">GlobalName = ViaName = term()</span></li><li><span class="v">Request = term()</span></li><li><span class="v">Timeout = int()&gt;0 | infinity</span></li><li><span class="v">Reply = term()</span></li></ul><p>Makes a synchronous call to the <strong>ServerRef</strong> of the
<strong>gen_server</strong> process
by sending a request and waiting until a reply arrives or a
time-out occurs. The <strong>gen_server</strong> process calls
<a href="#Module:handle_call/3">Module:handle_call/3</a> to handle the request.</p><p><strong>ServerRef</strong> can be any of the following:</p><ul><li>The pid</li><li><strong>Name</strong>, if the <strong>gen_server</strong> process is locally registered</li><li><strong>{Name,Node}</strong>, if the <strong>gen_server</strong> process is locally registered at another node</li><li><strong>{global,GlobalName}</strong>, if the <strong>gen_server</strong> process is globally registered</li><li><strong>{via,Module,ViaName}</strong>, if the <strong>gen_server</strong> process is registered through an alternative process registry</li></ul><p><strong>Request</strong> is any term that is passed as one of
the arguments to <strong>Module:handle_call/3</strong>.</p><p><strong>Timeout</strong> is an integer greater than zero that
specifies how many milliseconds to wait for a reply, or
the atom <strong>infinity</strong> to wait indefinitely. Defaults to
5000. If no reply is received within the specified time,
the function call fails. If the caller catches the failure
and continues running, and the server is just late with the reply,
it can arrive at any time later into the message queue of the caller.
The caller must in this case be prepared for this
and discard any such garbage messages that are two element
tuples with a reference as the first element.</p><p>The return value <strong>Reply</strong> is defined in the return value
of <strong>Module:handle_call/3</strong>.</p><p>The call can fail for many reasons, including time-out and the
called <strong>gen_server</strong> process dying before or during the call.</p><h3>cast(ServerRef, Request) -&gt; ok</h3><p>Send an asynchronous request to a generic server.</p><ul><li><span class="v">ServerRef = Name | {Name,Node} | {global,GlobalName}</span></li><li><span class="v">| {via,Module,ViaName} | pid()</span></li><li><span class="v">Node = atom()</span></li><li><span class="v">GlobalName = ViaName = term()</span></li><li><span class="v">Request = term()</span></li></ul><p>Sends an asynchronous request to the <strong>ServerRef</strong> of the
<strong>gen_server</strong> process
and returns <strong>ok</strong> immediately, ignoring
if the destination node or <strong>gen_server</strong> process does not exist.
The <strong>gen_server</strong> process calls
<a href="#Module:handle_cast/2">Module:handle_cast/2</a> to handle the request.</p><p>For a description of <strong>ServerRef</strong>, see
<a href="#call/2">call/2</a>.</p><p><strong>Request</strong> is any term that is passed as one
of the arguments to <strong>Module:handle_cast/2</strong>.</p><h3>enter_loop(Module, Options, State)</h3><h3>enter_loop(Module, Options, State, ServerName)</h3><h3>enter_loop(Module, Options, State, Timeout)</h3><h3>enter_loop(Module, Options, State, ServerName, Timeout)</h3><p>Enter the <strong>gen_server</strong> receive loop.</p><ul><li><span class="v">Module = atom()</span></li><li><span class="v">Options = [Option]</span></li><li><span class="v">Option = {debug,Dbgs} | {hibernate_after,HibernateAfterTimeout}</span></li><li><span class="v">Dbgs = [Dbg]</span></li><li><span class="v">Dbg = trace | log | statistics</span></li><li><span class="v">| {log_to_file,FileName} | {install,{Func,FuncState}}</span></li><li><span class="v">State = term()</span></li><li><span class="v">ServerName = {local,Name} | {global,GlobalName}</span></li><li><span class="v">| {via,Module,ViaName}</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">GlobalName = ViaName = term()</span></li><li><span class="v">Timeout = int() | infinity</span></li></ul><p>Makes an existing process into a <strong>gen_server</strong> process. Does not
return, instead the calling process enters the <strong>gen_server</strong>
process receive
loop and becomes a <strong>gen_server</strong> process. The process
<em>must</em> have been started using one of the start functions in
<a href="proc_lib">proc_lib</a>. The user is
responsible for any initialization of the process, including
registering a name for it.</p><p>This function is useful when a more complex initialization procedure
is needed than the <strong>gen_server</strong> process behavior provides.</p><p><strong>Module</strong>, <strong>Options</strong>, and <strong>ServerName</strong> have
the same meanings as when calling
<a href="#start_link/3">start_link/3</a>.
However, if <strong>ServerName</strong> is specified, the process must
have been registered accordingly <em>before</em> this function
is called.</p><p><strong>State</strong> and <strong>Timeout</strong> have the same meanings as in
the return value of
<a href="#Module:init/1">Module:init/1</a>.
The callback module <strong>Module</strong> does not need to
export an <strong>init/1</strong> function.</p><p>The function fails if the calling process was not started by a
<strong>proc_lib</strong> start function, or if it is not registered
according to <strong>ServerName</strong>.</p><h3>multi_call(Name, Request) -&gt; Result</h3><h3>multi_call(Nodes, Name, Request) -&gt; Result</h3><h3>multi_call(Nodes, Name, Request, Timeout) -&gt; Result</h3><p>Make a synchronous call to many generic servers.</p><ul><li><span class="v">Nodes = [Node]</span></li><li><span class="v">Node = atom()</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">Request = term()</span></li><li><span class="v">Timeout = int()&gt;=0 | infinity</span></li><li><span class="v">Result = {Replies,BadNodes}</span></li><li><span class="v">Replies = [{Node,Reply}]</span></li><li><span class="v">Reply = term()</span></li><li><span class="v">BadNodes = [Node]</span></li></ul><p>Makes a synchronous call to all <strong>gen_server</strong> processes locally
registered as <strong>Name</strong> at the specified nodes by first
sending a request to every node and then waits for
the replies. The <strong>gen_server</strong> process calls
<a href="#Module:handle_call/3">Module:handle_call/3</a> to handle the request.</p><p>The function returns a tuple <strong>{Replies,BadNodes}</strong>, where
<strong>Replies</strong> is a list of <strong>{Node,Reply}</strong> and
<strong>BadNodes</strong> is a list of node that either did not exist,
or where the <strong>gen_server</strong> <strong>Name</strong> did not exist or did not
reply.</p><p><strong>Nodes</strong> is a list of node names to which the request
is to be sent. Default value is the list of all known nodes
<strong>[node()|nodes()]</strong>.</p><p><strong>Name</strong> is the locally registered name of each
<strong>gen_server</strong> process.</p><p><strong>Request</strong> is any term that is passed as one of
the arguments to <strong>Module:handle_call/3</strong>.</p><p><strong>Timeout</strong> is an integer greater than zero that
specifies how many milliseconds to wait for each reply, or
the atom <strong>infinity</strong> to wait indefinitely. Defaults
to <strong>infinity</strong>. If no reply is received from a node within
the specified time, the node is added to <strong>BadNodes</strong>.</p><p>When a reply <strong>Reply</strong> is received from the <strong>gen_server</strong>
process at a node <strong>Node</strong>, <strong>{Node,Reply}</strong> is added to
<strong>Replies</strong>. <strong>Reply</strong> is defined in the return value of
<strong>Module:handle_call/3</strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If one of the nodes cannot process monitors, for example,
C or Java nodes, and the <strong>gen_server</strong> process is not started
when the requests are sent, but starts within 2 seconds,
this function waits the whole <strong>Timeout</strong>,
which may be infinity.</p><p>This problem does not exist if all nodes are Erlang nodes.</p></div><p>To prevent late answers (after the time-out) from polluting
the message queue of the caller, a middleman process is used to
do the calls. Late answers are then discarded
when they arrive to a terminated process.</p><h3>reply(Client, Reply) -&gt; Result</h3><p>Send a reply to a client.</p><ul><li><span class="v">Client - see below</span></li><li><span class="v">Reply = term()</span></li><li><span class="v">Result = term()</span></li></ul><p>This function can be used by a <strong>gen_server</strong> process to
explicitly send a reply to a client that called
<a href="#call/2">call/2</a> or
<a href="#multi_call/2">multi_call/2</a>,
when the reply cannot be defined in the return value of
<a href="#Module:handle_call/3">Module:handle_call/3</a>.</p><p><strong>Client</strong> must be the <strong>From</strong> argument provided to
the callback function. <strong>Reply</strong> is any term
given back to the client as the return value of
<strong>call/2,3</strong> or <strong>multi_call/2,3,4</strong>.</p><p>The return value <strong>Result</strong> is not further defined, and
is always to be ignored.</p><h3>start(Module, Args, Options) -&gt; Result</h3><h3>start(ServerName, Module, Args, Options) -&gt; Result</h3><p>Create a standalone <strong>gen_server</strong> process.</p><ul><li><span class="v">ServerName = {local,Name} | {global,GlobalName}</span></li><li><span class="v">| {via,Module,ViaName}</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">GlobalName = ViaName = term()</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Args = term()</span></li><li><span class="v">Options = [Option]</span></li><li><span class="v">Option = {debug,Dbgs} | {timeout,Time} | {hibernate_after,HibernateAfterTimeout} | {spawn_opt,SOpts}</span></li><li><span class="v">Dbgs = [Dbg]</span></li><li><span class="v">Dbg = trace | log | statistics | {log_to_file,FileName} | {install,{Func,FuncState}}</span></li><li><span class="v">SOpts = [term()]</span></li><li><span class="v">Result = {ok,Pid} | ignore | {error,Error}</span></li><li><span class="v">Pid = pid()</span></li><li><span class="v">Error = {already_started,Pid} | term()</span></li></ul><p>Creates a standalone <strong>gen_server</strong> process, that is, a
<strong>gen_server</strong> process that is not part of a supervision tree
and thus has no supervisor.</p><p>For a description of arguments and return values, see
<a href="#start_link/3">start_link/3</a>.</p><h3>start_link(Module, Args, Options) -&gt; Result</h3><h3>start_link(ServerName, Module, Args, Options) -&gt; Result</h3><p>Create a <strong>gen_server</strong> process in a supervision tree. </p><ul><li><span class="v">ServerName = {local,Name} | {global,GlobalName}</span></li><li><span class="v">| {via,Module,ViaName}</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">GlobalName = ViaName = term()</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Args = term()</span></li><li><span class="v">Options = [Option]</span></li><li><span class="v">Option = {debug,Dbgs} | {timeout,Time} | {hibernate_after,HibernateAfterTimeout} | {spawn_opt,SOpts}</span></li><li><span class="v">Dbgs = [Dbg]</span></li><li><span class="v">Dbg = trace | log | statistics | {log_to_file,FileName} | {install,{Func,FuncState}}</span></li><li><span class="v">SOpts = [term()]</span></li><li><span class="v">Result = {ok,Pid} | ignore | {error,Error}</span></li><li><span class="v">Pid = pid()</span></li><li><span class="v">Error = {already_started,Pid} | term()</span></li></ul><p>Creates a <strong>gen_server</strong> process as part of a supervision tree.
This function is to be called, directly or indirectly, by
the supervisor. For example, it ensures that
the <strong>gen_server</strong> process is linked to the supervisor.</p><p>The <strong>gen_server</strong> process calls
<a href="#Module:init/1">Module:init/1</a> to
initialize. To ensure a synchronized startup procedure,
<strong>start_link/3,4</strong> does not return until
<strong>Module:init/1</strong> has returned.</p><ul><li> <p>If <strong>ServerName={local,Name}</strong>, the <strong>gen_server</strong> process
is registered locally as <strong>Name</strong> using <strong>register/2</strong>.</p> </li><li> <p>If <strong>ServerName={global,GlobalName}</strong>, the <strong>gen_server</strong>
process id registered globally as <strong>GlobalName</strong> using
<a href="../kernel/global#register_name/2">kernel/global#register_name/2</a> If no name is
provided, the <strong>gen_server</strong> process is not registered.</p> </li><li> <p>If <strong>ServerName={via,Module,ViaName}</strong>, the <strong>gen_server</strong>
process registers with the registry represented by <strong>Module</strong>.
The <strong>Module</strong> callback is to export the functions
<strong>register_name/2</strong>, <strong>unregister_name/1</strong>,
<strong>whereis_name/1</strong>, and <strong>send/2</strong>, which are to behave
like the corresponding functions in
<a href="./global">kernel/global</a>.
Thus, <strong>{via,global,GlobalName}</strong> is a valid reference.</p> </li></ul><p><strong>Module</strong> is the name of the callback module.</p><p><strong>Args</strong> is any term that is passed as
the argument to
<a href="#Module:init/1">Module:init/1</a>.</p><ul><li> <p>If option <strong>{timeout,Time}</strong> is present, the <strong>gen_server</strong>
process is allowed to spend <strong>Time</strong> milliseconds
initializing or it is terminated and the start function
returns <strong>{error,timeout}</strong>.</p> </li><li> <p>If option <strong>{hibernate_after,HibernateAfterTimeout}</strong> is present, the <strong>gen_server</strong>
process awaits any message for <strong>HibernateAfterTimeout</strong> milliseconds and
if no message is received, the process goes into hibernation automatically
(by calling <a href="./proc_lib#hibernate/3">proc_lib#hibernate/3</a>).</p> </li><li> <p>If option <strong>{debug,Dbgs}</strong> is present,
the corresponding <strong>sys</strong> function is called for each
item in <strong>Dbgs</strong>; see
<a href="sys">sys</a>.</p> </li><li> <p>If option <strong>{spawn_opt,SOpts}</strong> is present,
<strong>SOpts</strong> is passed as option list to
the <strong>spawn_opt</strong> BIF, which is used to spawn
the <strong>gen_server</strong> process; see
<a href="../erts/erlang#spawn_opt/2">erts/erlang#spawn_opt/2</a>.</p> </li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Using spawn option <strong>monitor</strong> is not
allowed, it causes the function to fail with reason
<strong>badarg</strong>.</p></div><p>If the <strong>gen_server</strong> process is successfully created and
initialized, the function returns <strong>{ok,Pid}</strong>, where <strong>Pid</strong>
is the pid of the <strong>gen_server</strong> process. If a process with the
specified <strong>ServerName</strong> exists already, the function returns
<strong>{error,{already_started,Pid}}</strong>, where <strong>Pid</strong> is
the pid of that process.</p><p>If <strong>Module:init/1</strong> fails with <strong>Reason</strong>,
the function returns <strong>{error,Reason}</strong>. If
<strong>Module:init/1</strong> returns <strong>{stop,Reason}</strong> or
<strong>ignore</strong>, the process is terminated and the function
returns <strong>{error,Reason}</strong> or <strong>ignore</strong>, respectively.</p><h3>stop(ServerRef) -&gt; ok</h3><h3>stop(ServerRef, Reason, Timeout) -&gt; ok</h3><p>Synchronously stop a generic server.</p><ul><li><span class="v">ServerRef = Name | {Name,Node} | {global,GlobalName}</span></li><li><span class="v">| {via,Module,ViaName} | pid()</span></li><li><span class="v">Node = atom()</span></li><li><span class="v">GlobalName = ViaName = term()</span></li><li><span class="v">Reason = term()</span></li><li><span class="v">Timeout = int()&gt;0 | infinity</span></li></ul><p>Orders a generic server to exit with the specified <strong>Reason</strong>
and waits for it to terminate. The <strong>gen_server</strong> process calls
<a href="#Module:terminate/2">Module:terminate/2</a> before exiting.</p><p>The function returns <strong>ok</strong> if the server terminates
with the expected reason. Any other reason than <strong>normal</strong>,
<strong>shutdown</strong>, or <strong>{shutdown,Term}</strong> causes an
error report to be issued using
<a href="./logger">kernel/logger</a>.
The default <strong>Reason</strong> is <strong>normal</strong>.</p><p><strong>Timeout</strong> is an integer greater than zero that
specifies how many milliseconds to wait for the server to
terminate, or the atom <strong>infinity</strong> to wait
indefinitely. Defaults to <strong>infinity</strong>. If the
server has not terminated within the specified time, a
<strong>timeout</strong> exception is raised.</p><p>If the process does not exist, a <strong>noproc</strong> exception
is raised.</p><h3>Callback Functions</h3><p>The following functions
are to be exported from a <strong>gen_server</strong> callback module.</p><h2>Functions</h2><h3>Module:code_change(OldVsn, State, Extra) -&gt; {ok, NewState} | {error, Reason}</h3><p>Update the internal state during upgrade/downgrade.</p><ul><li><span class="v">OldVsn = Vsn | {down, Vsn}</span></li><li><span class="v">Vsn = term()</span></li><li><span class="v">State = NewState = term()</span></li><li><span class="v">Extra = term()</span></li><li><span class="v">Reason = term()</span></li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This callback is optional, so callback modules need not export it.
If a release upgrade/downgrade with <strong>Change={advanced,Extra}</strong>
specified in the <strong>appup</strong> file is made when <strong>code_change/3</strong>
isn't implemented the process will crash with an <strong>undef</strong> exit
reason.</p></div><p>This function is called by a <strong>gen_server</strong> process when it is
to update its internal state during a release upgrade/downgrade,
that is, when the instruction <strong>{update,Module,Change,...}</strong>,
where <strong>Change={advanced,Extra}</strong>, is specifed in
the <strong>appup</strong> file. For more information, see section
<a href="../doc/design_principles/release_handling#instr"> Release Handling Instructions</a> in OTP Design Principles.</p><p>For an upgrade, <strong>OldVsn</strong> is <strong>Vsn</strong>, and
for a downgrade, <strong>OldVsn</strong> is
<strong>{down,Vsn}</strong>. <strong>Vsn</strong> is defined by the <strong>vsn</strong>
attribute(s) of the old version of the callback module
<strong>Module</strong>. If no such attribute is defined, the version
is the checksum of the Beam file.</p><p><strong>State</strong> is the internal state of the <strong>gen_server</strong>
process.</p><p><strong>Extra</strong> is passed "as is" from the <strong>{advanced,Extra}</strong>
part of the update instruction.</p><p>If successful, the function must return the updated
internal state.</p><p>If the function returns <strong>{error,Reason}</strong>, the ongoing
upgrade fails and rolls back to the old release.</p><h3>Module:format_status(Opt, [PDict, State]) -&gt; Status</h3><p>Optional function for providing a term describing the current <strong>gen_server</strong> status.</p><ul><li><span class="v">Opt = normal | terminate</span></li><li><span class="v">PDict = [{Key, Value}]</span></li><li><span class="v">State = term()</span></li><li><span class="v">Status = term()</span></li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This callback is optional, so callback modules need not
export it. The <strong>gen_server</strong> module provides a default
implementation of this function that returns the callback
module state.</p></div><p>This function is called by a <strong>gen_server</strong> process in the
following situations:</p><ul><li> <p>One of <a href="./sys#get_status/1">sys#get_status/1</a>
is invoked to get the <strong>gen_server</strong> status. <strong>Opt</strong> is set
to the atom <strong>normal</strong>.</p> </li><li> <p>The <strong>gen_server</strong> process terminates abnormally and logs an
error. <strong>Opt</strong> is set to the atom <strong>terminate</strong>.</p> </li></ul><p>This function is useful for changing the form and
appearance of the <strong>gen_server</strong> status for these cases. A
callback module wishing to change
the <strong>sys:get_status/1,2</strong> return value, as well as how
its status appears in termination error logs, exports an
instance of <strong>format_status/2</strong> that returns a term
describing the current status of the <strong>gen_server</strong> process.</p><p><strong>PDict</strong> is the current value of the process dictionary of
the <strong>gen_server</strong> process..</p><p><strong>State</strong> is the internal state of the <strong>gen_server</strong>
process.</p><p>The function is to return <strong>Status</strong>, a term that
changes the details of the current state and status of
the <strong>gen_server</strong> process. There are no restrictions on the
form <strong>Status</strong> can take, but for
the <strong>sys:get_status/1,2</strong> case (when <strong>Opt</strong>
is <strong>normal</strong>), the recommended form for
the <strong>Status</strong> value is <strong>[{data, [{"State", Term}]}]</strong>, where <strong>Term</strong> provides relevant details of
the <strong>gen_server</strong> state. Following this recommendation is not
required, but it makes the callback module status
consistent with the rest of the <strong>sys:get_status/1,2</strong>
return value.</p><p>One use for this function is to return compact alternative
state representations to avoid that large state terms are
printed in log files.</p><h3>Module:handle_call(Request, From, State) -&gt; Result</h3><p>Handle a synchronous request.</p><ul><li><span class="v">Request = term()</span></li><li><span class="v">From = {pid(),Tag}</span></li><li><span class="v">State = term()</span></li><li><span class="v">Result = {reply,Reply,NewState} | {reply,Reply,NewState,Timeout}</span></li><li><span class="v">| {reply,Reply,NewState,hibernate}</span></li><li><span class="v">| {reply,Reply,NewState,{continue,Continue}}</span></li><li><span class="v">| {noreply,NewState} | {noreply,NewState,Timeout}</span></li><li><span class="v">| {noreply,NewState,hibernate}</span></li><li><span class="v">| {noreply,NewState,{continue,Continue}}</span></li><li><span class="v">| {stop,Reason,Reply,NewState} | {stop,Reason,NewState}</span></li><li><span class="v">Reply = term()</span></li><li><span class="v">NewState = term()</span></li><li><span class="v">Timeout = int()&gt;=0 | infinity</span></li><li><span class="v">Continue = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Whenever a <strong>gen_server</strong> process receives a request sent using
<a href="#call/2">call/2</a> or
<a href="#multi_call/2">multi_call/2</a>,
this function is called to handle the request.</p><p><strong>Request</strong> is the <strong>Request</strong> argument provided
to <strong>call</strong> or <strong>multi_call</strong>.</p><p><strong>From</strong> is a tuple <strong>{Pid,Tag}</strong>, where <strong>Pid</strong> is
the pid of the client and <strong>Tag</strong> is a unique tag.</p><p><strong>State</strong> is the internal state of the <strong>gen_server</strong>
process.</p><ul><li> <p>If <strong>{reply,Reply,NewState}</strong> is returned, 
<strong>{reply,Reply,NewState,Timeout}</strong> or 
<strong>{reply,Reply,NewState,hibernate}</strong>, <strong>Reply</strong> is
given back to <strong>From</strong> as the return value of
<strong>call/2,3</strong> or included in the return value of
<strong>multi_call/2,3,4</strong>. The <strong>gen_server</strong> process then
continues executing with the possibly updated internal state
<strong>NewState</strong>.</p> <p>For a description of <strong>Timeout</strong> and <strong>hibernate</strong>, see
<a href="#Module:init/1">Module:init/1</a>.</p> </li><li> <p>If <strong>{noreply,NewState}</strong> is returned,
<strong>{noreply,NewState,Timeout}</strong>, or
<strong>{noreply,NewState,hibernate}</strong>, the <strong>gen_server</strong>
process continues executing with <strong>NewState</strong>. Any reply to
<strong>From</strong> must be specified explicitly using
<a href="#reply/2">reply/2</a>.</p> </li><li> <p>If <strong>{stop,Reason,Reply,NewState}</strong> is returned,
<strong>Reply</strong> is given back to <strong>From</strong>.</p> </li><li> <p>If <strong>{stop,Reason,NewState}</strong> is returned, any reply
to <strong>From</strong> must be specified explicitly using
<a href="#reply/2">reply/2</a>.
The <strong>gen_server</strong> process then calls
<strong>Module:terminate(Reason,NewState)</strong> and terminates.</p> </li></ul><h3>Module:handle_cast(Request, State) -&gt; Result</h3><p>Handle an asynchronous request.</p><ul><li><span class="v">Request = term()</span></li><li><span class="v">State = term()</span></li><li><span class="v">Result = {noreply,NewState} | {noreply,NewState,Timeout}</span></li><li><span class="v">| {noreply,NewState,hibernate}</span></li><li><span class="v">| {noreply,NewState,{continue,Continue}}</span></li><li><span class="v">| {stop,Reason,NewState}</span></li><li><span class="v">NewState = term()</span></li><li><span class="v">Timeout = int()&gt;=0 | infinity</span></li><li><span class="v">Continue = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Whenever a <strong>gen_server</strong> process receives a request sent using
<a href="#cast/2">cast/2</a> or
<a href="#abcast/2">abcast/2</a>,
this function is called to handle the request.</p><p>For a description of the arguments and possible return values, see
<a href="#Module:handle_call/3">Module:handle_call/3</a>.</p><h3>Module:handle_continue(Continue, State) -&gt; Result</h3><p>Handle a continue instruction.</p><ul><li><span class="v">Continue = term()</span></li><li><span class="v">State = term()</span></li><li><span class="v">Result = {noreply,NewState} | {noreply,NewState,Timeout}</span></li><li><span class="v">| {noreply,NewState,hibernate}</span></li><li><span class="v">| {noreply,NewState,{continue,Continue}}</span></li><li><span class="v">| {stop,Reason,NewState}</span></li><li><span class="v">NewState = term()</span></li><li><span class="v">Timeout = int()&gt;=0 | infinity</span></li><li><span class="v">Continue = term()</span></li><li><span class="v">Reason = normal | term()</span></li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This callback is optional, so callback modules need to
export it only if they return <strong>{continue,Continue}</strong>
from another callback. If continue is used and the callback
is not implemented, the process will exit with <strong>undef</strong>
error.</p></div><p>This function is called by a <strong>gen_server</strong> process whenever
a previous callback returns <strong>{continue, Continue}</strong>.
<strong>handle_continue/2</strong> is invoked immediately after the previous
callback, which makes it useful for performing work after
initialization or for splitting the work in a callback in
multiple steps, updating the process state along the way.</p><p>For a description of the other arguments and possible return values,
see <a href="#Module:handle_call/3">Module:handle_call/3</a>.</p><h3>Module:handle_info(Info, State) -&gt; Result</h3><p>Handle an incoming message.</p><ul><li><span class="v">Info = timeout | term()</span></li><li><span class="v">State = term()</span></li><li><span class="v">Result = {noreply,NewState} | {noreply,NewState,Timeout}</span></li><li><span class="v">| {noreply,NewState,hibernate}</span></li><li><span class="v">| {noreply,NewState,{continue,Continue}}</span></li><li><span class="v">| {stop,Reason,NewState}</span></li><li><span class="v">NewState = term()</span></li><li><span class="v">Timeout = int()&gt;=0 | infinity</span></li><li><span class="v">Reason = normal | term()</span></li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This callback is optional, so callback modules need not
export it. The <strong>gen_server</strong> module provides a default
implementation of this function that logs about the unexpected
<strong>Info</strong> message, drops it and returns <strong>{noreply, State}</strong>.</p></div><p>This function is called by a <strong>gen_server</strong> process when a
time-out occurs or when it receives any other message than a
synchronous or asynchronous request (or a system message).</p><p><strong>Info</strong> is either the atom <strong>timeout</strong>, if a time-out
has occurred, or the received message.</p><p>For a description of the other arguments and possible return values,
see <a href="#Module:handle_call/3">Module:handle_call/3</a>.</p><h3>Module:init(Args) -&gt; Result</h3><p>Initialize process and internal state.</p><ul><li><span class="v">Args = term()</span></li><li><span class="v">Result =  {ok,State} | {ok,State,Timeout} | {ok,State,hibernate}</span></li><li><span class="v">| {ok,State,{continue,Continue}} | {stop,Reason} | ignore</span></li><li><span class="v">State = term()</span></li><li><span class="v">Timeout = int()&gt;=0 | infinity</span></li><li><span class="v">Reason = term()</span></li></ul><p>Whenever a <strong>gen_server</strong> process is started using
<a href="#start/3">start/3</a> or
<a href="#start_link/3">start_link/3</a>,
this function is called by the new process to initialize.</p><p><strong>Args</strong> is the <strong>Args</strong> argument provided to the start
function.</p><p>If the initialization is successful, the function is to
return <strong>{ok,State}</strong>, <strong>{ok,State,Timeout}</strong>, or
<strong>{ok,State,hibernate}</strong>, where <strong>State</strong> is the internal
state of the <strong>gen_server</strong> process.</p><p>If an integer time-out value is provided, a time-out occurs
unless a request or a message is received within
<strong>Timeout</strong> milliseconds. A time-out is represented by
the atom <strong>timeout</strong>, which is to be handled by the
<a href="#Module:handle_info/2">Module:handle_info/2</a> callback function. The atom
<strong>infinity</strong> can be used to wait indefinitely, this is
the default value.</p><p>If <strong>hibernate</strong> is specified instead of a time-out value,
the process goes into
hibernation when waiting for the next message to arrive (by calling 
<a href="./proc_lib#hibernate/3">proc_lib#hibernate/3</a>).</p><p>If the initialization fails, the function is to return
<strong>{stop,Reason}</strong>, where <strong>Reason</strong> is any term, or
<strong>ignore</strong>.</p><h3>Module:terminate(Reason, State)</h3><p>Clean up before termination.</p><ul><li><span class="v">Reason = normal | shutdown | {shutdown,term()} | term()</span></li><li><span class="v">State = term()</span></li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This callback is optional, so callback modules need not
export it. The <strong>gen_server</strong> module provides a default
implementation without cleanup.</p></div><p>This function is called by a <strong>gen_server</strong> process when it is
about to terminate. It is to be the opposite of
<a href="#Module:init/1">Module:init/1</a>
and do any necessary cleaning up. When it returns,
the <strong>gen_server</strong> process terminates with <strong>Reason</strong>.
The return value is ignored.</p><p><strong>Reason</strong> is a term denoting the stop reason and <strong>State</strong>
is the internal state of the <strong>gen_server</strong> process.</p><p><strong>Reason</strong> depends on why the <strong>gen_server</strong> process is
terminating. If it is because another callback function has returned
a stop tuple <strong>{stop,..}</strong>, <strong>Reason</strong> has
the value specified in that tuple. If it is because of a failure,
<strong>Reason</strong> is the error reason.</p><p>If the <strong>gen_server</strong> process is part of a supervision tree and
is ordered by its supervisor to terminate, this function is
called with <strong>Reason=shutdown</strong> if the following
conditions apply:</p><ul><li> <p>The <strong>gen_server</strong> process has been set to trap exit
signals.</p> </li><li> <p>The shutdown strategy as defined in the child specification
of the supervisor is an integer time-out value, not
<strong>brutal_kill</strong>.</p> </li></ul><p>Even if the <strong>gen_server</strong> process is <em>not</em> part of a
supervision tree, this function is called if it receives an
<strong>'EXIT'</strong> message from its parent. <strong>Reason</strong> is the same
as in the <strong>'EXIT'</strong> message.</p><p>Otherwise, the <strong>gen_server</strong> process terminates immediately.</p><p>Notice that for any other reason than <strong>normal</strong>,
<strong>shutdown</strong>, or <strong>{shutdown,Term}</strong>, the <strong>gen_server</strong>
process is assumed to terminate because of an error and
an error report is issued using
<a href="./logger">kernel/logger</a>.</p><h3>See Also</h3><p><a href="gen_event">gen_event</a>,
<a href="gen_statem">gen_statem</a>,
<a href="proc_lib">proc_lib</a>,
<a href="supervisor">supervisor</a>,
<a href="sys">sys</a></p><h2>gen_statem</h2><p>Generic state machine behavior.</p><p>
<strong>gen_statem</strong> provides a generic state machine behaviour
and replaces its predecessor
<a href="gen_fsm">gen_fsm</a>
since Erlang/OTP 20.0.

This reference manual describes types generated from the types
in the <strong>gen_statem</strong> source code, so they are correct.
However, the generated descriptions also reflect the type hiearchy,
which makes them kind of hard to read.

To get an overview of the concepts and operation of <strong>gen_statem</strong>,
do read the
<a href="./statem"> Behaviour </a>
in
<a href="./users_guide"> OTP Design Principles </a>
which frequently links back to this reference manual to avoid
containing detailed facts that may rot by age.

<strong>gen_statem</strong> has got the same features that
<a href="gen_fsm">gen_fsm</a>
had and adds some really useful:
<ul><li>Co-located state code</li><li>Arbitrary term state</li><li>Event postponing</li><li>Self-generated events</li><li>State time-out</li><li>Multiple generic named time-outs</li><li>Absolute time-out time</li><li>Automatic state enter calls</li><li> Reply from other state than the request, <strong>sys</strong> traceable </li><li>Multiple <strong>sys</strong> traceable replies</li></ul>
Two
<a href="#type-callback_mode">type-callback_mode</a>
are supported:
<ul><li> <p>One for finite-state machines
(<a href="gen_fsm">gen_fsm</a> like),
which requires the state to be an atom and uses that state as
the name of the current callback function
</p> </li><li> <p>One without restriction on the state data type
that uses one callback function for all states
</p> </li></ul>
The callback model(s) for <strong>gen_statem</strong> differs from
the one for <a href="gen_fsm">gen_fsm</a>,
but it is still fairly easy to
<a href="./gen_fsm#Migration to gen_statem"> rewrite from </a> <strong>gen_fsm</strong> to <strong>gen_statem</strong>.

A generic state machine process (<strong>gen_statem</strong>) implemented
using this module has a standard set of interface functions
and includes functionality for tracing and error reporting.
It also fits into an OTP supervision tree. For more information, see
<a href="./statem">OTP Design Principles</a>.

A <strong>gen_statem</strong> assumes all specific parts to be located in a
callback module exporting a predefined set of functions.
The relationship between the behavior functions and the callback
functions is as follows:<pre>
gen_statem module            Callback module
-----------------            ---------------
gen_statem:start
gen_statem:start_link -----&gt; Module:init/1

Server start or code change
                      -----&gt; Module:callback_mode/0

gen_statem:stop       -----&gt; Module:terminate/3

gen_statem:call
gen_statem:cast
erlang:send
erlang:'!'            -----&gt; Module:StateName/3
                             Module:handle_event/4

-                     -----&gt; Module:terminate/3

-                     -----&gt; Module:code_change/4</pre>
Events are of different
<a href="#type-event_type">types</a>,
so the callback functions can know the origin of an event
and how to respond.

If a callback function fails or returns a bad value,
the <strong>gen_statem</strong> terminates, unless otherwise stated.
However, an exception of class
<a href="../erts/erlang#throw/1">erts/erlang#throw/1</a>
is not regarded as an error but as a valid return
from all callback functions.
<a name="state callback"></a>
The <em>state callback</em> for a specific
<a href="#type-state">state</a>
in a <strong>gen_statem</strong> is the callback function that is called
for all events in this state. It is selected depending on which
<a href="#type-callback_mode">type-callback_mode</a>
that the callback module defines with the callback function
<a href="#Module:callback_mode/0">Module:callback_mode/0</a>.

When the
<a href="#type-callback_mode">type-callback_mode</a>
is <strong>state_functions</strong>, the state must be an atom and
is used as the <em>state callback</em> name; see
<a href="#Module:StateName/3">Module:StateName/3</a>.
This co-locates all code for a specific state
in one function as the <strong>gen_statem</strong> engine
branches depending on state name.
Note the fact that the callback function
<a href="#Module:terminate/3">Module:terminate/3</a>
makes the state name <strong>terminate</strong> unusable in this mode.

When the
<a href="#type-callback_mode">type-callback_mode</a>
is <strong>handle_event_function</strong>, the state can be any term
and the <em>state callback</em> name is
<a href="#Module:handle_event/4">Module:handle_event/4</a>.
This makes it easy to branch depending on state or event as you desire.
Be careful about which events you handle in which
states so that you do not accidentally postpone an event
forever creating an infinite busy loop.

When <strong>gen_statem</strong> receives a process message it is
converted into an event and the
<a href="#state callback">state callback</a>
is called with the event as two arguments: type and content.
When the
<a href="#state callback">state callback</a>
has processed the event it returns to <strong>gen_statem</strong>
which does a <em>state transition</em>.
If this <em>state transition</em> is to a different state,
that is: <strong>NextState =/= State</strong>, it is a <em>state change</em>.

The
<a href="#state callback">state callback</a>
may return
<a href="#type-action">type-action</a>
for <strong>gen_statem</strong>
to execute during the <em>state transition</em>,
for example to reply to a
<a href="#call/2">call/2</a>.

One of the possible <em>transition actions</em>
is to postpone the current event.
Then it is not retried in the current state.
The <strong>gen_statem</strong> engine keeps a queue of events
divided into the postponed events
and the events still to process.
After a <em>state change</em> the queue restarts
with the postponed events.

The <strong>gen_statem</strong> event queue model is sufficient
to emulate the normal process message queue with selective receive.
Postponing an event corresponds to not matching it
in a receive statement, and changing states corresponds
to entering a new receive statement.

The
<a href="#state callback">state callback</a>
can insert events using the
<a href="#type-action">type-action</a>
<strong>next_event</strong>
and such an event is inserted in the event queue
as the next to call the
<a href="#state callback">state callback</a>
with.
That is, as if it is the oldest incoming event.
A dedicated
<a href="#type-event_type">type-event_type</a>
<strong>internal</strong> can be used for such events making them impossible
to mistake for external events.

Inserting an event replaces the trick of calling your own
state handling functions that you often would have to
resort to in, for example,
<a href="gen_fsm">gen_fsm</a>
to force processing an inserted event before others.

The <strong>gen_statem</strong> engine can automatically
make a specialized call to the
<a href="#state callback">state callback</a>
whenever a new state is entered; see 
<a href="#type-state_enter">type-state_enter</a>.
This is for writing code common to all state entries.
Another way to do it is to explicitly insert an event
at the <em>state transition</em>,
and/or to use a dedicated <em>state transition</em> function,
but that is something you will have to remember
at every <em>state transition</em> to the state(s) that need it.

For the details of a <em>state transition</em>, see type
<a href="#type-transition_option">type-transition_option</a>.

A <strong>gen_statem</strong> handles system messages as described in
<a href="sys">sys</a>.
The <strong>sys</strong> module can be used for debugging a <strong>gen_statem</strong>.

Notice that a <strong>gen_statem</strong> does not trap exit signals
automatically, this must be explicitly initiated in
the callback module (by calling
<a href="../erts/erlang#process_flag/2">erts/erlang#process_flag/2</a>.

Unless otherwise stated, all functions in this module fail if
the specified <strong>gen_statem</strong> does not exist or
if bad arguments are specified.

The <strong>gen_statem</strong> process can go into hibernation; see
<a href="./proc_lib#hibernate/3">proc_lib#hibernate/3</a>.
It is done when a
<a href="#state callback">state callback</a>
or
<a href="#Module:init/1">Module:init/1</a>
specifies <strong>hibernate</strong> in the returned
<a href="#type-action">type-action</a>
list. This feature can be useful to reclaim process heap memory
while the server is expected to be idle for a long time.
However, use this feature with care,
as hibernation can be too costly
to use after every event; see
<a href="../erts/erlang#hibernate/3">erts/erlang#hibernate/3</a>.

There is also a server start option
<a href="#type-enter_loop_opt">type-enter_loop_opt</a>
for
<a href="#start/3">start/3</a>,
<a href="#start_link/3">start_link/3</a> or
<a href="#enter_loop/4">enter_loop/4</a>,
that may be used to automatically hibernate the server.
</p><h3>Example</h3><p>
The following example shows a simple pushbutton model
for a toggling pushbutton implemented with
<a href="#type-callback_mode">type-callback_mode</a>
<strong>state_functions</strong>.
You can push the button and it replies if it went on or off,
and you can ask for a count of how many times it has been
pushed to switch on.
</p><p>The following is the complete callback module file
<strong>pushbutton.erl</strong>:</p><pre><code class="erl">
-module(pushbutton).
-behaviour(gen_statem).

-export([start/0,push/0,get_count/0,stop/0]).
-export([terminate/3,code_change/4,init/1,callback_mode/0]).
-export([on/3,off/3]).

name() -&gt; pushbutton_statem. % The registered server name

%% API.  This example uses a registered name name()
%% and does not link to the caller.
start() -&gt;
    gen_statem:start({local,name()}, ?MODULE, [], []).
push() -&gt;
    gen_statem:call(name(), push).
get_count() -&gt;
    gen_statem:call(name(), get_count).
stop() -&gt;
    gen_statem:stop(name()).

%% Mandatory callback functions
terminate(_Reason, _State, _Data) -&gt;
    void.
code_change(_Vsn, State, Data, _Extra) -&gt;
    {ok,State,Data}.
init([]) -&gt;
    %% Set the initial state + data.  Data is used only as a counter.
    State = off, Data = 0,
    {ok,State,Data}.
callback_mode() -&gt; state_functions.

%%% state callback(s)

off({call,From}, push, Data) -&gt;
    %% Go to 'on', increment count and reply
    %% that the resulting status is 'on'
    {next_state,on,Data+1,[{reply,From,on}]};
off(EventType, EventContent, Data) -&gt;
    handle_event(EventType, EventContent, Data).

on({call,From}, push, Data) -&gt;
    %% Go to 'off' and reply that the resulting status is 'off'
    {next_state,off,Data,[{reply,From,off}]};
on(EventType, EventContent, Data) -&gt;
    handle_event(EventType, EventContent, Data).

%% Handle events common to all states
handle_event({call,From}, get_count, Data) -&gt;
    %% Reply with the current count
    {keep_state,Data,[{reply,From,Data}]};
handle_event(_, _, Data) -&gt;
    %% Ignore all other events
    {keep_state,Data}.
    </code></pre><p>The following is a shell session when running it:</p><pre>
1&gt; pushbutton:start().
{ok,&lt;0.36.0&gt;}
2&gt; pushbutton:get_count().
0
3&gt; pushbutton:push().
on
4&gt; pushbutton:get_count().
1
5&gt; pushbutton:push().
off
6&gt; pushbutton:get_count().
1
7&gt; pushbutton:stop().
ok
8&gt; pushbutton:push().
** exception exit: {noproc,{gen_statem,call,[pushbutton_statem,push,infinity]}}
     in function  gen:do_for_proc/2 (gen.erl, line 261)
     in call from gen_statem:call/3 (gen_statem.erl, line 386)
    </pre><p>
To compare styles, here follows the same example using
<a href="#type-callback_mode">type-callback_mode</a>
<strong>handle_event_function</strong>, or rather the code to replace
after function <strong>init/1</strong> of the <strong>pushbutton.erl</strong>
example file above:
</p><pre><code class="erl">
callback_mode() -&gt; handle_event_function.

%%% state callback(s)

handle_event({call,From}, push, off, Data) -&gt;
    %% Go to 'on', increment count and reply
    %% that the resulting status is 'on'
    {next_state,on,Data+1,[{reply,From,on}]};
handle_event({call,From}, push, on, Data) -&gt;
    %% Go to 'off' and reply that the resulting status is 'off'
    {next_state,off,Data,[{reply,From,off}]};
%%
%% Event handling common to all states
handle_event({call,From}, get_count, State, Data) -&gt;
    %% Reply with the current count
    {next_state,State,Data,[{reply,From,Data}]};
handle_event(_, _, State, Data) -&gt;
    %% Ignore all other events
    {next_state,State,Data}.
    </code></pre><h2>Data Types</h2><span class="name">server_name</span><p>
Name specification to use when starting
a <strong>gen_statem</strong> server. See
<a href="#start_link/3">start_link/3</a>
and
<a href="#type-server_ref">type-server_ref</a>
below.
</p><span class="name">server_ref</span><p>
Server specification to use when addressing
a <strong>gen_statem</strong> server.
See <a href="#call/2">call/2</a> and
<a href="#type-server_name">type-server_name</a>
above.
</p><p>It can be:</p><dl><dt><strong>pid() | LocalName</strong></dt><dd> <p>
The <strong>gen_statem</strong> is locally registered.
</p> </dd><dt><strong>{Name,Node}</strong></dt><dd> <p>
The <strong>gen_statem</strong> is locally registered
on another node.
</p> </dd><dt><strong>{global,GlobalName}</strong></dt><dd> <p>
The <strong>gen_statem</strong> is globally registered in
<a href="./global">kernel/global</a>.
</p> </dd><dt><strong>{via,RegMod,ViaName}</strong></dt><dd> <p>
The <strong>gen_statem</strong> is registered in
an alternative process registry.
The registry callback module <strong>RegMod</strong>
is to export functions
<strong>register_name/2</strong>, <strong>unregister_name/1</strong>,
<strong>whereis_name/1</strong>, and <strong>send/2</strong>,
which are to behave like the corresponding functions in
<a href="./global">kernel/global</a>.
Thus, <strong>{via,global,GlobalName}</strong> is the same as
<strong>{global,GlobalName}</strong>.
</p> </dd></dl><span class="name">start_opt</span><p>
Options that can be used when starting
a <strong>gen_statem</strong> server through, for example,
<a href="#start_link/3">start_link/3</a>.
</p><span class="name">start_ret</span><p>
Return value from the start functions, for example,
<a href="#start_link/3">start_link/3</a>.
</p><span class="name">enter_loop_opt</span><p>
Options that can be used when starting
a <strong>gen_statem</strong> server through,
<a href="#enter_loop/4">enter_loop/4</a>.
</p><dl><dt><strong>hibernate_after</strong></dt><dd> <p>
<strong>HibernateAfterTimeout</strong>
specifies that the <strong>gen_statem</strong> process awaits
any message for <strong>HibernateAfterTimeout</strong> milliseconds and
if no message is received, the process goes into hibernation
automatically (by calling
<a href="./proc_lib#hibernate/3">proc_lib#hibernate/3</a>).
</p> </dd><dt><strong>debug</strong></dt><dd> <p>
For every entry in <strong><span class="anno">Dbgs</span></strong>,
the corresponding function in
<a href="sys">sys</a> is called.
</p> </dd></dl><span class="name">from</span><p>
Destination to use when replying through, for example, the
<a href="#type-action">type-action</a>
<strong>{reply,From,Reply}</strong>
to a process that has called the <strong>gen_statem</strong> server using
<a href="#call/2">call/2</a>.
</p><span class="name">state</span><p>
If the
<a href="#type-callback_mode">type-callback_mode</a>
is <strong>handle_event_function</strong>,
the state can be any term.
After a <em>state change</em> (<strong>NextState =/= State</strong>),
all postponed events are retried.
</p><span class="name">state_name</span><p>
If the
<a href="#type-callback_mode">type-callback_mode</a>
is <strong>state_functions</strong>,
the state must be of this type.
After a <em>state change</em> (<strong>NextState =/= State</strong>),
all postponed events are retried.
</p><span class="name">data</span><p>
A term in which the state machine implementation
is to store any server data it needs. The difference between
this and the <a href="#type-state">type-state</a>
itself is that a change in this data does not cause
postponed events to be retried. Hence, if a change
in this data would change the set of events that
are handled, then that data item is to be made
a part of the state.
</p><span class="name">event_type</span><p>
There are 3 categories of events:
<a href="#type-external_event_type">external</a>,
<a href="#type-timeout_event_type">timeout</a>,
and <strong>internal</strong>.
</p><p>
<strong>internal</strong> events can only be generated by the
state machine itself through the <em>transition action</em>
<a href="#type-action">type-action</a>.
</p><span class="name">external_event_type</span><p>
External events are of 3 types:
<strong>{call,<span class="anno">From</span>}</strong>, <strong>cast</strong>, or <strong>info</strong>.
<a href="#call/2">Calls</a>
(synchronous) and
<a href="#cast/2">casts</a>
originate from the corresponding API functions.
For calls, the event contains whom to reply to.
Type <strong>info</strong> originates from regular process messages sent
to the <strong>gen_statem</strong>.
</p><span class="name">timeout_event_type</span><p>
There are 3 types of timeout events that the state machine
can generate for itself with the corresponding
<a href="#type-timeout_action">timeout_action()</a>s.
</p><span class="name">callback_mode_result</span><p>
This is the return type from
<a href="#Module:callback_mode/0">Module:callback_mode/0</a>
and selects 
<a href="#type-callback_mode">type-callback_mode</a>
and whether to do
<a href="#type-state_enter">type-state_enter</a>,
or not.
</p><span class="name">callback_mode</span><p>
The <em>callback mode</em> is selected when starting the
<strong>gen_statem</strong> and after code change
using the return value from
<a href="#Module:callback_mode/0">Module:callback_mode/0</a>.
</p><dl><dt><strong>state_functions</strong></dt><dd> <p>
The state must be of type
<a href="#type-state_name">type-state_name</a>
and one callback function per state, that is,
<a href="#Module:StateName/3">Module:StateName/3</a>,
is used.
</p> </dd><dt><strong>handle_event_function</strong></dt><dd> <p>
The state can be any term and the callback function
<a href="#Module:handle_event/4">Module:handle_event/4</a>
is used for all states.
</p> </dd></dl><span class="name">state_enter</span><p>
Whether the state machine should use <em>state enter calls</em>
or not is selected when starting the  <strong>gen_statem</strong>
and after code change using the return value from
<a href="#Module:callback_mode/0">Module:callback_mode/0</a>.
</p><p>
If 
<a href="#Module:callback_mode/0">Module:callback_mode/0</a>
returns a list containing <strong>state_enter</strong>,
the <strong>gen_statem</strong> engine will, at every <em>state change</em>,
call the
<a href="#state callback">state callback</a>
with arguments <strong>(enter, OldState, Data)</strong>.
This may look like an event but is really a call
performed after the previous
<a href="#state callback">state callback</a>
returned and before any event is delivered to the new
<a href="#state callback">state callback</a>.
See
<a href="#Module:StateName/3">Module:StateName/3</a>
and
<a href="#Module:handle_event/4">Module:handle_event/4</a>.
Such a call can be repeated by returning a
<a href="#type-state_callback_result">type-state_callback_result</a>
or
<a href="#type-state_callback_result">type-state_callback_result</a>
tuple from the <em>state callback</em>.
</p><p>
If 
<a href="#Module:callback_mode/0">Module:callback_mode/0</a>
does not return such a list, no <em>state enter calls</em> are done.
</p><p>
If 
<a href="#Module:code_change/4">Module:code_change/4</a>
should transform the state,
it is regarded as a state rename and not a <em>state change</em>,
which will not cause a <em>state enter call</em>.
</p><p>
Note that a <em>state enter call</em> <em>will</em> be done
right before entering the initial state even though this
actually is not a <em>state change</em>.
In this case <strong>OldState =:= State</strong>,
which cannot happen for a subsequent state change,
but will happen when repeating the <em>state enter call</em>.
</p><span class="name">transition_option</span><p>
Transition options can be set by
<a href="#type-action">actions</a>
and modify the <em>state transition</em>.
The <em>state transition</em> takes place when the
<a href="#state callback">state callback</a>
has processed an event and returns.
Here are the sequence of steps for a <em>state transition</em>:
</p><ul><li> <p>
If
<a href="#type-state_enter">type-state_enter</a>
are used, and either:
the state changes, it is the initial state,
or one of the callback results
<a href="#type-state_callback_result">type-state_callback_result</a>
or
<a href="#type-state_callback_result">type-state_callback_result</a>
is used; the <strong>gen_statem</strong> calls
the new state callback with arguments
<a href="#type-state_enter">type-state_enter</a>.
</p> <p>
Any 
<a href="#type-enter_action">actions</a>
returned from this call are handled as if they were
appended to the actions
returned by the state callback that caused the state entry.
</p> <p>
Should this <em>state enter call</em> return any of
the mentioned <strong>repeat_*</strong> callback results
it is repeated again, with the updated <strong>Data</strong>.
</p> </li><li> <p>
All
<a href="#type-action">actions</a>
are processed in order of appearance.
</p> </li><li> <p>
If
<a href="#type-postpone">type-postpone</a>
is <strong>true</strong>,
the current event is postponed.
</p> </li><li> <p>
If this is a <em>state change</em>,
the queue of incoming events
is reset to start with the oldest postponed.
</p> </li><li> <p>
All events stored with
<a href="#type-action">type-action</a>
<strong>next_event</strong>
are inserted to be processed before previously queued events.
</p> </li><li> <p>
Time-out timers
<a href="#type-event_timeout">type-event_timeout</a>,
<a href="#type-generic_timeout">type-generic_timeout</a>
and 
<a href="#type-state_timeout">type-state_timeout</a>
are handled.  Time-outs with zero time are guaranteed to be
delivered to the state machine before any external
not yet received event so if there is such a time-out requested,
the corresponding time-out zero event is enqueued as
the newest received event;
that is after already queued events
such as inserted and postponed events.
</p> <p>
Any event cancels an
<a href="#type-event_timeout">type-event_timeout</a>
so a zero time event time-out is only generated
if the event queue is empty.
</p> <p>
A <em>state change</em> cancels a
<a href="#type-state_timeout">type-state_timeout</a>
and any new transition option of this type
belongs to the new state.
</p> </li><li> <p>
If there are enqueued events the
<a href="#state callback">state callback</a>
for the possibly new state
is called with the oldest enqueued event,
and we start again from the top of this list.
</p> </li><li> <p>
Otherwise the <strong>gen_statem</strong> goes into <strong>receive</strong>
or hibernation
(if
<a href="#type-hibernate">type-hibernate</a>
is <strong>true</strong>)
to wait for the next message. In hibernation the next
non-system event awakens the <strong>gen_statem</strong>, or rather
the next incoming message awakens the <strong>gen_statem</strong>,
but if it is a system event it goes right back into hibernation.
When a new message arrives the 
<a href="#state callback">state callback</a>
is called with the corresponding event,
and we start again from the top of this sequence.
</p> </li></ul><span class="name">postpone</span><p>
If <strong>true</strong>, postpones the current event and retries
it after a <em>state change</em>
(<strong>NextState =/= State</strong>).
</p><span class="name">hibernate</span><p>
If <strong>true</strong>, hibernates the <strong>gen_statem</strong>
by calling
<a href="./proc_lib#hibernate/3">proc_lib#hibernate/3</a>
before going into <strong>receive</strong>
to wait for a new external event.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
If there are enqueued events to process
when hibrnation is requested,
this is optimized by not hibernating but instead calling
<a href="../erts/erlang#garbage_collect/0">erts/erlang#garbage_collect/0</a>
to simulate that the <strong>gen_statem</strong> entered hibernation
and immediately got awakened by an enqueued event.
</p></div><span class="name">event_timeout</span><p>
Starts a timer set by
<a href="#type-enter_action">type-enter_action</a>
<strong>timeout</strong>.
When the timer expires an event of
<a href="#type-event_type">type-event_type</a>
<strong>timeout</strong> will be generated.
See
<a href="../erts/erlang#start_timer/4">erts/erlang#start_timer/4</a>
for how <strong>Time</strong> and
<a href="#type-timeout_option">type-timeout_option</a>
are interpreted.  Future <strong>erlang:start_timer/4</strong> <strong>Options</strong>
will not necessarily be supported.
</p><p>
Any event that arrives cancels this time-out.
Note that a retried or inserted event counts as arrived.
So does a state time-out zero event, if it was generated
before this time-out is requested.
</p><p>
If <strong>Time</strong> is <strong>infinity</strong>,
no timer is started, as it never would expire anyway.
</p><p>
If <strong>Time</strong> is relative and <strong>0</strong>
no timer is actually started,
instead the the time-out event is enqueued to ensure
that it gets processed before any not yet
received external event, but after already queued events.
</p><p>
Note that it is not possible nor needed to cancel this time-out,
as it is cancelled automatically by any other event.
</p><span class="name">generic_timeout</span><p>
Starts a timer set by
<a href="#type-enter_action">type-enter_action</a>
<strong>{timeout,Name}</strong>.
When the timer expires an event of
<a href="#type-event_type">type-event_type</a>
<strong>{timeout,Name}</strong> will be generated.
See
<a href="../erts/erlang#start_timer/4">erts/erlang#start_timer/4</a>
for how <strong>Time</strong> and
<a href="#type-timeout_option">type-timeout_option</a>
are interpreted.  Future <strong>erlang:start_timer/4</strong> <strong>Options</strong>
will not necessarily be supported.
</p><p>
If <strong>Time</strong> is <strong>infinity</strong>,
no timer is started, as it never would expire anyway.
</p><p>
If <strong>Time</strong> is relative and <strong>0</strong>
no timer is actually started,
instead the the time-out event is enqueued to ensure
that it gets processed before any not yet
received external event.
</p><p>
Setting a timer with the same <strong>Name</strong> while it is running
will restart it with the new time-out value.
Therefore it is possible to cancel
a specific time-out by setting it to <strong>infinity</strong>.
</p><span class="name">state_timeout</span><p>
Starts a timer set by
<a href="#type-enter_action">type-enter_action</a>
<strong>state_timeout</strong>.
When the timer expires an event of
<a href="#type-event_type">type-event_type</a>
<strong>state_timeout</strong> will be generated.
See
<a href="../erts/erlang#start_timer/4">erts/erlang#start_timer/4</a>
for how <strong>Time</strong> and
<a href="#type-timeout_option">type-timeout_option</a>
are interpreted.  Future <strong>erlang:start_timer/4</strong> <strong>Options</strong>
will not necessarily be supported.
</p><p>
If <strong>Time</strong> is <strong>infinity</strong>,
no timer is started, as it never would expire anyway.
</p><p>
If <strong>Time</strong> is relative and <strong>0</strong>
no timer is actually started,
instead the the time-out event is enqueued to ensure
that it gets processed before any not yet
received external event.
</p><p>
Setting this timer while it is running will restart it with
the new time-out value.  Therefore it is possible to cancel
this time-out by setting it to <strong>infinity</strong>.
</p><span class="name">timeout_option</span><p>
If <strong>Abs</strong> is <strong>true</strong> an absolute timer is started,
and if it is <strong>false</strong> a relative, which is the default.
See
<a href="../erts/erlang#start_timer/4">erts/erlang#start_timer/4</a>
for details.
</p><p>
</p><span class="name">action</span><p>
These <em>transition actions</em> can be invoked by
returning them from the
<a href="#state callback">state callback</a>
when it is called with an
<a href="#type-event_type">event</a>,
from
<a href="#Module:init/1">Module:init/1</a>
or by giving them to
<a href="#enter_loop/5">enter_loop/5</a>.
</p><p>
Actions are executed in the containing list order.
</p><p>
Actions that set
<a href="#type-transition_option"> transition options </a>
override any previous of the same type,
so the last in the containing list wins.
For example, the last
<a href="#type-postpone">type-postpone</a>
overrides any previous <strong>postpone()</strong> in the list.
</p><dl><dt><strong>postpone</strong></dt><dd> <p>
Sets the
<a href="#type-transition_option">type-transition_option</a>
<a href="#type-postpone">type-postpone</a>
for this <em>state transition</em>.
This action is ignored when returned from
<a href="#Module:init/1">Module:init/1</a>
or given to
<a href="#enter_loop/5">enter_loop/5</a>,
as there is no event to postpone in those cases.
</p> </dd><dt><strong>next_event</strong></dt><dd> <p>
This action does not set any
<a href="#type-transition_option">type-transition_option</a>
but instead stores the specified <strong><span class="anno">EventType</span></strong>
and <strong><span class="anno">EventContent</span></strong> for insertion after all
actions have been executed.
</p> <p>
The stored events are inserted in the queue as the next to process
before any already queued events. The order of these stored events
is preserved, so the first <strong>next_event</strong> in the containing
list becomes the first to process.
</p> <p>
An event of type
<a href="#type-event_type">type-event_type</a>
is to be used when you want to reliably distinguish
an event inserted this way from any external event.
</p> </dd></dl><span class="name">enter_action</span><p>
These <em>transition actions</em> can be invoked by
returning them from the
<a href="#state callback">state callback</a>, from
<a href="#Module:init/1">Module:init/1</a>
or by giving them to
<a href="#enter_loop/5">enter_loop/5</a>.
</p><p>
Actions are executed in the containing list order.
</p><p>
Actions that set
<a href="#type-transition_option">transition options</a>
override any previous of the same type,
so the last in the containing list wins.
For example, the last
<a href="#type-event_timeout">type-event_timeout</a>
overrides any previous <strong>event_timeout()</strong> in the list.
</p><dl><dt><strong>hibernate</strong></dt><dd> <p>
Sets the
<a href="#type-transition_option">type-transition_option</a>
<a href="#type-hibernate">type-hibernate</a>
for this <em>state transition</em>.
</p> </dd></dl><span class="name">timeout_action</span><p>
These <em>transition actions</em> can be invoked by
returning them from the
<a href="#state callback">state callback</a>, from
<a href="#Module:init/1">Module:init/1</a>
or by giving them to
<a href="#enter_loop/5">enter_loop/5</a>.
</p><p>
These timeout actions sets timeout
<a href="#type-transition_option">transition options</a>.
</p><dl><dt><strong>Time</strong></dt><dd> <p>
Short for <strong>{timeout,Time,Time}</strong>, that is,
the time-out message is the time-out time.
This form exists to make the
<a href="#state callback">state callback</a>
return value <strong>{next_state,NextState,NewData,Time}</strong>
allowed like for <strong>gen_fsm</strong>.
</p> </dd><dt><strong>timeout</strong></dt><dd> <p>
Sets the
<a href="#type-transition_option">type-transition_option</a>
<a href="#type-event_timeout">type-event_timeout</a>
to <strong><span class="anno">Time</span></strong> with <strong><span class="anno">EventContent</span></strong>
and time-out options
<a href="#type-timeout_option">type-timeout_option</a>.
</p> </dd><dt><strong>{timeout,<span class="anno">Name</span>}</strong></dt><dd> <p>
Sets the
<a href="#type-transition_option">type-transition_option</a>
<a href="#type-generic_timeout">type-generic_timeout</a>
to <strong><span class="anno">Time</span></strong> for <strong><span class="anno">Name</span></strong>
with <strong><span class="anno">EventContent</span></strong>
and time-out options
<a href="#type-timeout_option">type-timeout_option</a>.
</p> </dd><dt><strong>state_timeout</strong></dt><dd> <p>
Sets the
<a href="#type-transition_option">type-transition_option</a>
<a href="#type-state_timeout">type-state_timeout</a>
to <strong><span class="anno">Time</span></strong> with <strong><span class="anno">EventContent</span></strong>
and time-out options
<a href="#type-timeout_option">type-timeout_option</a>.
</p> </dd></dl><span class="name">reply_action</span><p>
This <em>transition action</em> can be invoked by
returning it from the
<a href="#state callback">state callback</a>, from
<a href="#Module:init/1">Module:init/1</a>
or by giving it to
<a href="#enter_loop/5">enter_loop/5</a>.
</p><p>
It does not set any
<a href="#type-transition_option">type-transition_option</a>
but instead replies to a caller waiting for a reply in
<a href="#call/2">call/2</a>.
<strong><span class="anno">From</span></strong> must be the term from argument
<a href="#type-event_type">type-event_type</a>
in a call to a
<a href="#state callback">state callback</a>.
</p><p>
Note that using this action from 
<a href="#Module:init/1">Module:init/1</a>
or
<a href="#enter_loop/5">enter_loop/5</a>
would be weird on the border of witchcraft
since there has been no earlier call to a
<a href="#state callback">state callback</a>
in this server.
</p><span class="name">init_result</span><p>
For a succesful initialization,
<strong><span class="anno">State</span></strong> is the initial
<a href="#type-state">type-state</a>
and <strong><span class="anno">Data</span></strong> the initial server
<a href="#type-data">type-data</a>
of the <strong>gen_statem</strong>.
</p><p>
The <a href="#type-action">type-action</a>
are executed when entering the first
<a href="#type-state">state</a> just as for a
<a href="#state callback">state callback</a>,
except that the action <strong>postpone</strong> is forced to
<strong>false</strong> since there is no event to postpone.
</p><p>
For an unsuccesful initialization,
<strong>{stop,<span class="anno">Reason</span>}</strong>
or <strong>ignore</strong> should be used; see
<a href="#start_link/3">start_link/3</a>.
</p><span class="name">state_enter_result</span><p>
<strong><span class="anno">State</span></strong> is the current state
and it cannot be changed since the state callback
was called with a
<a href="#type-state_enter">type-state_enter</a>.
</p><dl><dt><strong>next_state</strong></dt><dd> <p>
The <strong>gen_statem</strong> does a state transition to
<strong><span class="anno">State</span></strong>, which has to be
the current state,
sets <strong><span class="anno">NewData</span></strong>,
and executes all <strong><span class="anno">Actions</span></strong>.
</p> </dd></dl><span class="name">event_handler_result</span><p>
<strong><span class="anno">StateType</span></strong> is
<a href="#type-state_name">type-state_name</a>
if
<a href="#type-callback_mode">type-callback_mode</a>
is <strong>state_functions</strong>, or
<a href="#type-state">type-state</a>
if
<a href="#type-callback_mode">type-callback_mode</a>
is <strong>handle_event_function</strong>.
</p><dl><dt><strong>next_state</strong></dt><dd> <p>
The <strong>gen_statem</strong> does a <em>state transition</em> to
<strong><span class="anno">NextState</span></strong>
(which can be the same as the current state),
sets <strong><span class="anno">NewData</span></strong>,
and executes all <strong><span class="anno">Actions</span></strong>.
If <strong><span class="anno">NextState</span> =/= CurrentState</strong>
the <em>state transition</em> is a <em>state change</em>.
</p> </dd></dl><span class="name">state_callback_result</span><p>
<strong><span class="anno">ActionType</span></strong> is
<a href="#type-enter_action">type-enter_action</a>
if the state callback was called with a
<a href="#type-state_enter">type-state_enter</a>
and
<a href="#type-action">type-action</a>
if the state callback was called with an event.
</p><dl><dt><strong>keep_state</strong></dt><dd> <p>
The same as
<strong>{next_state,CurrentState,<span class="anno">NewData</span>,<span class="anno">Actions</span>}</strong>.
</p> </dd><dt><strong>keep_state_and_data</strong></dt><dd> <p>
The same as
<strong>{keep_state,CurrentData,<span class="anno">Actions</span>}</strong>.
</p> </dd><dt><strong>repeat_state</strong></dt><dd> <p>
If the <strong>gen_statem</strong> runs with
<a href="#type-state_enter">type-state_enter</a>,
the <em>state enter call</em> is repeated, see type
<a href="#type-transition_option">type-transition_option</a>,
other than that <strong>repeat_state</strong> is the same as
<strong>keep_state</strong>.
</p> </dd><dt><strong>repeat_state_and_data</strong></dt><dd> <p>
The same as
<strong>{repeat_state,CurrentData,<span class="anno">Actions</span>}</strong>.
</p> </dd><dt><strong>stop</strong></dt><dd> <p>
Terminates the <strong>gen_statem</strong> by calling
<a href="#Module:terminate/3">Module:terminate/3</a>
with <strong>Reason</strong> and
<strong><span class="anno">NewData</span></strong>, if specified.
</p> </dd><dt><strong>stop_and_reply</strong></dt><dd> <p>
Sends all <strong><span class="anno">Replies</span></strong>,
then terminates the <strong>gen_statem</strong> by calling
<a href="#Module:terminate/3">Module:terminate/3</a>
with <strong>Reason</strong> and
<strong><span class="anno">NewData</span></strong>, if specified.
</p> </dd></dl><p>
All these terms are tuples or atoms and this property
will hold in any future version of <strong>gen_statem</strong>.
</p><h2>Functions</h2><h3>call/2</h3><h3>call/3</h3><p>Make a synchronous call to a <strong>gen_statem</strong>.</p><p>
Makes a synchronous call to the <strong>gen_statem</strong>
<a href="#type-server_ref">type-server_ref</a>
by sending a request
and waiting until its reply arrives.
The <strong>gen_statem</strong> calls the
<a href="#state callback">state callback</a>
with
<a href="#type-event_type">type-event_type</a>
<strong>{call,From}</strong> and event content
<strong><span class="anno">Request</span></strong>.
</p><p>
A <strong><span class="anno">Reply</span></strong> is generated when a
<a href="#state callback">state callback</a>
returns with
<strong>{reply,From,<span class="anno">Reply</span>}</strong> as one
<a href="#type-action">type-action</a>,
and that <strong><span class="anno">Reply</span></strong> becomes the return value
of this function.
</p><p>
<strong><span class="anno">Timeout</span></strong> is an integer &gt; 0,
which specifies how many milliseconds to wait for a reply,
or the atom <strong>infinity</strong> to wait indefinitely,
which is the default. If no reply is received within
the specified time, the function call fails.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
For <strong><span class="anno">Timeout</span> &lt; infinity</strong>,
to avoid getting a late reply in the caller's
inbox if the caller should catch exceptions,
this function spawns a proxy process that
does the call. A late reply gets delivered to the
dead proxy process, hence gets discarded. This is
less efficient than using
<strong><span class="anno">Timeout</span> == infinity</strong>.
</p></div><p>
<strong><span class="anno">Timeout</span></strong> can also be a tuple
<strong>{clean_timeout,<span class="anno">T</span>}</strong> or
<strong>{dirty_timeout,<span class="anno">T</span>}</strong>, where
<strong><span class="anno">T</span></strong> is the time-out time.
<strong>{clean_timeout,<span class="anno">T</span>}</strong> works like
just <strong>T</strong> described in the note above
and uses a proxy process
while <strong>{dirty_timeout,<span class="anno">T</span>}</strong>
bypasses the proxy process which is more lightweight.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
If you combine catching exceptions from this function
with <strong>{dirty_timeout,<span class="anno">T</span>}</strong>
to avoid that the calling process dies when the call
times out, you will have to be prepared to handle
a late reply.  Note that there is an odd chance
to get a late reply even with
<strong>{dirty_timeout,infinity}</strong> or <strong>infinity</strong>
for example in the event of network problems.
So why not just let the calling process die
by not catching the exception?
</p></div><p>
The call can also fail, for example, if the <strong>gen_statem</strong>
dies before or during this function call.
</p><h3>cast/2</h3><p>Send an asynchronous event to a <strong>gen_statem</strong>.</p><p>
Sends an asynchronous event to the <strong>gen_statem</strong>
<a href="#type-server_ref">type-server_ref</a>
and returns <strong>ok</strong> immediately,
ignoring if the destination node or <strong>gen_statem</strong>
does not exist.
The <strong>gen_statem</strong> calls the
<a href="#state callback">state callback</a>
with
<a href="#type-event_type">type-event_type</a>
<strong>cast</strong> and event content
<strong><span class="anno">Msg</span></strong>.
</p><h3>enter_loop/4</h3><p>Enter the <strong>gen_statem</strong> receive loop.</p><p>
The same as
<a href="#enter_loop/6">enter_loop/6</a>
with <strong>Actions = []</strong> except that no
<a href="#type-server_name">type-server_name</a>
must have been registered.  This creates an anonymous server.
</p><h3>enter_loop/5</h3><p>Enter the <strong>gen_statem</strong> receive loop.</p><p>
If <strong><span class="anno">Server_or_Actions</span></strong> is a <strong>list()</strong>,
the same as
<a href="#enter_loop/6">enter_loop/6</a>
except that no
<a href="#type-server_name">type-server_name</a>
must have been registered and
<strong>Actions = <span class="anno">Server_or_Actions</span></strong>.
This creates an anonymous server.
</p><p>
Otherwise the same as
<a href="#enter_loop/6">enter_loop/6</a>
with
<strong>Server = <span class="anno">Server_or_Actions</span></strong> and
<strong>Actions = []</strong>.
</p><h3>enter_loop/6</h3><p>Enter the <strong>gen_statem</strong> receive loop.</p><p>
Makes the calling process become a <strong>gen_statem</strong>.
Does not return, instead the calling process enters
the <strong>gen_statem</strong> receive loop and becomes
a <strong>gen_statem</strong> server.
The process <em>must</em> have been started
using one of the start functions in
<a href="proc_lib">proc_lib</a>.
The user is responsible for any initialization of the process,
including registering a name for it.
</p><p>
This function is useful when a more complex initialization
procedure is needed than
the <strong>gen_statem</strong> behavior provides.
</p><p>
<strong><span class="anno">Module</span></strong>, <strong><span class="anno">Opts</span></strong>
have the same meaning as when calling
<a href="#start_link/3">start_link/3</a>.
</p><p>
If <strong><span class="anno">Server</span></strong> is <strong>self()</strong> an anonymous
server is created just as when using 
<a href="#start_link/3">start_link/3</a>.
If <strong><span class="anno">Server</span></strong> is a
<a href="#type-server_name">type-server_name</a>
a named server is created just as when using
<a href="#start_link/4">start_link/4</a>.
However, the
<a href="#type-server_name">type-server_name</a>
name must have been registered accordingly
<em>before</em> this function is called.
</p><p>
<strong><span class="anno">State</span></strong>, <strong><span class="anno">Data</span></strong>,
and <strong><span class="anno">Actions</span></strong>
have the same meanings as in the return value of
<a href="#Module:init/1">Module:init/1</a>.
Also, the callback module does not need to export a
<a href="#Module:init/1">Module:init/1</a>
function.
</p><p>
The function fails if the calling process was not started by a
<a href="proc_lib">proc_lib</a>
start function, or if it is not registered
according to
<a href="#type-server_name">type-server_name</a>.
</p><h3>reply/1</h3><h3>reply/2</h3><p>Reply to a caller.</p><p>
This function can be used by a <strong>gen_statem</strong>
to explicitly send a reply to a process that waits in
<a href="#call/2">call/2</a>
when the reply cannot be defined in
the return value of a
<a href="#state callback">state callback</a>.
</p><p>
<strong><span class="anno">From</span></strong> must be the term from argument
<a href="#type-event_type">type-event_type</a>
to the
<a href="#state callback">state callback</a>.
A reply or multiple replies canalso be sent
using one or several
<a href="#type-reply_action">type-reply_action</a>s
from a
<a href="#state callback">state callback</a>.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
A reply sent with this function is not visible
in <a href="sys">sys</a> debug output.
</p></div><h3>start/3</h3><h3>start/4</h3><p>Create a standalone <strong>gen_statem</strong> process.</p><p>
Creates a standalone <strong>gen_statem</strong> process according to
OTP design principles (using
<a href="proc_lib">proc_lib</a>
primitives).
As it does not get linked to the calling process,
this start function cannot be used by a supervisor
to start a child.
</p><p>
For a description of arguments and return values, see
<a href="#start_link/3">start_link/3</a>.
</p><h3>start_link/3</h3><h3>start_link/4</h3><p>Create a linked <strong>gen_statem</strong> process.</p><p>
Creates a <strong>gen_statem</strong> process according
to OTP design principles
(using
<a href="proc_lib">proc_lib</a>
primitives)
that is linked to the calling process.
This is essential when the <strong>gen_statem</strong> must be part of
a supervision tree so it gets linked to its supervisor.
</p><p>
The <strong>gen_statem</strong> process calls
<a href="#Module:init/1">Module:init/1</a>
to initialize the server. To ensure a synchronized startup
procedure, <strong>start_link/3,4</strong> does not return until
<a href="#Module:init/1">Module:init/1</a>
has returned.
</p><p>
<strong><span class="anno">ServerName</span></strong> specifies the
<a href="#type-server_name">type-server_name</a>
to register for the <strong>gen_statem</strong>.
If the <strong>gen_statem</strong> is started with <strong>start_link/3</strong>,
no <strong><span class="anno">ServerName</span></strong> is provided and
the <strong>gen_statem</strong> is not registered.
</p><p><strong><span class="anno">Module</span></strong> is the name of the callback module.</p><p>
<strong><span class="anno">Args</span></strong> is an arbitrary term that is passed as
the argument to
<a href="#Module:init/1">Module:init/1</a>.
</p><ul><li> <p>
If option
<a href="#type-start_opt">type-start_opt</a>
is present in
<strong><span class="anno">Opts</span></strong>, the <strong>gen_statem</strong>
is allowed to spend <strong>Time</strong> milliseconds initializing
or it terminates and the start function returns
<a href="#type-start_ret">type-start_ret</a>.
</p> </li><li> <p>If option
<a href="#type-enter_loop_opt">type-enter_loop_opt</a>
is present, the <strong>gen_statem</strong>
process awaits any message for <strong>HibernateAfterTimeout</strong> milliseconds and
if no message is received, the process goes into hibernation automatically
(by calling <a href="./proc_lib#hibernate/3">proc_lib#hibernate/3</a>).
</p> </li><li> <p>
If option
<a href="#type-enter_loop_opt">type-enter_loop_opt</a>
is present in <strong><span class="anno">Opts</span></strong>, debugging through
<a href="sys">sys</a> is activated.
</p> </li><li> <p>
If option
<a href="#type-start_opt">type-start_opt</a>
is present in
<strong><span class="anno">Opts</span></strong>, <strong>SpawnOpts</strong> is passed
as option list to
<a href="../erts/erlang#spawn_opt/2">erts/erlang#spawn_opt/2</a>,
which is used to spawn the <strong>gen_statem</strong> process.
</p> </li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Using spawn option <strong>monitor</strong> is not
allowed, it causes this function to fail with reason
<strong>badarg</strong>.
</p></div><p>
If the <strong>gen_statem</strong> is successfully created
and initialized, this function returns
<a href="#type-start_ret">type-start_ret</a>,
where <strong>Pid</strong> is the <strong>pid()</strong>
of the <strong>gen_statem</strong>.
If a process with the specified <strong><span class="anno">ServerName</span></strong>
exists already, this function returns
<a href="#type-start_ret">type-start_ret</a>,
where <strong>Pid</strong> is the <strong>pid()</strong> of that process.
</p><p>
If <strong>Module:init/1</strong> fails with <strong>Reason</strong>,
this function returns
<a href="#type-start_ret">type-start_ret</a>.
If <strong>Module:init/1</strong> returns
<a href="#type-start_ret">type-start_ret</a>
or
<a href="#type-start_ret">type-start_ret</a>,
the process is terminated and this function
returns
<a href="#type-start_ret">type-start_ret</a>
or
<a href="#type-start_ret">type-start_ret</a>,
respectively.
</p><h3>stop/1</h3><p>Synchronously stop a generic server.</p><p>
The same as
<a href="#stop/3">stop/3</a>.
</p><h3>stop/3</h3><p>Synchronously stop a generic server.</p><p>
Orders the <strong>gen_statem</strong>
<a href="#type-server_ref">type-server_ref</a>
to exit with the specified <strong><span class="anno">Reason</span></strong>
and waits for it to terminate.
The <strong>gen_statem</strong> calls
<a href="#Module:terminate/3">Module:terminate/3</a>
before exiting.
</p><p>
This function returns <strong>ok</strong> if the server terminates
with the expected reason. Any other reason than <strong>normal</strong>,
<strong>shutdown</strong>, or <strong>{shutdown,Term}</strong> causes an
error report to be issued through
<a href="./logger">kernel/logger</a>.
The default <strong><span class="anno">Reason</span></strong> is <strong>normal</strong>.
</p><p>
<strong><span class="anno">Timeout</span></strong> is an integer &gt; 0,
which specifies how many milliseconds to wait for the server to
terminate, or the atom <strong>infinity</strong> to wait indefinitely.
Defaults to <strong>infinity</strong>.
If the server does not terminate within the specified time,
a <strong>timeout</strong> exception is raised.
</p><p>
If the process does not exist, a <strong>noproc</strong> exception
is raised.
</p><h3>Callback Functions</h3><p>
The following functions are to be exported from a
<strong>gen_statem</strong> callback module.
</p><h2>Functions</h2><h3>Module:callback_mode() -&gt; CallbackMode</h3><p>Update the internal state during upgrade/downgrade.</p><ul><li><span class="v"> CallbackMode =  | [  |  ] </span></li></ul><p>
This function is called by a <strong>gen_statem</strong>
when it needs to find out the
<a href="#type-callback_mode">type-callback_mode</a>
of the callback module.  The value is cached by <strong>gen_statem</strong>
for efficiency reasons, so this function is only called
once after server start and after code change,
but before the first
<a href="#state callback">state callback</a>
in the current code version is called.
More occasions may be added in future versions
of <strong>gen_statem</strong>.
</p><p>
Server start happens either when
<a href="#Module:init/1">Module:init/1</a>
returns or when
<a href="#enter_loop/4">enter_loop/4</a>
is called.  Code change happens when
<a href="#Module:code_change/4">Module:code_change/4</a>
returns.
</p><p>
The <strong>CallbackMode</strong> is either just
<a href="#type-callback_mode">type-callback_mode</a>
or a list containing
<a href="#type-callback_mode">type-callback_mode</a>
and possibly the atom
<a href="#type-state_enter">type-state_enter</a>.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
If this function's body does not return an inline constant
value the callback module is doing something strange.
</p></div><h3>Module:code_change(OldVsn, OldState, OldData, Extra) -&gt;
        Result
</h3><p>Update the internal state during upgrade/downgrade.</p><ul><li><span class="v">OldVsn = Vsn | {down,Vsn}</span></li><li><span class="v">Vsn = term()</span></li><li><span class="v">OldState = NewState = term()</span></li><li><span class="v">Extra = term()</span></li><li><span class="v">Result = {ok,NewState,NewData} | Reason</span></li><li><span class="v"> OldState = NewState =  </span></li><li><span class="v"> OldData = NewData =  </span></li><li><span class="v">Reason = term()</span></li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
This callback is optional, so callback modules need not export it.
If a release upgrade/downgrade with
<strong>Change = {advanced,Extra}</strong>
specified in the <strong>.appup</strong> file is made
when <strong>code_change/4</strong> is not implemented
the process will crash with exit reason <strong>undef</strong>.
</p></div><p>
This function is called by a <strong>gen_statem</strong> when it is to
update its internal state during a release upgrade/downgrade,
that is, when the instruction <strong>{update,Module,Change,...}</strong>,
where <strong>Change = {advanced,Extra}</strong>, is specified in the
<a href="./appup">sasl/appup</a>
file. For more information, see
<a href="../doc/design_principles/release_handling#instr">OTP Design Principles</a>.
</p><p>
For an upgrade, <strong>OldVsn</strong> is <strong>Vsn</strong>, and
for a downgrade, <strong>OldVsn</strong> is
<strong>{down,Vsn}</strong>. <strong>Vsn</strong> is defined by the <strong>vsn</strong>
attribute(s) of the old version of the callback module
<strong>Module</strong>. If no such attribute is defined, the version
is the checksum of the Beam file.
</p><p>
<strong>OldState</strong> and <strong>OldData</strong> is the internal state
of the <strong>gen_statem</strong>.
</p><p>
<strong>Extra</strong> is passed "as is" from the <strong>{advanced,Extra}</strong>
part of the update instruction.
</p><p>
If successful, the function must return the updated
internal state in an
<strong>{ok,NewState,NewData}</strong> tuple.
</p><p>
If the function returns a failure <strong>Reason</strong>, the ongoing
upgrade fails and rolls back to the old release.
Note that <strong>Reason</strong> cannot be an <strong>{ok,_,_}</strong> tuple
since that will be regarded as a
<strong>{ok,NewState,NewData}</strong> tuple,
and that a tuple matching <strong>{ok,_}</strong>
is an also invalid failure <strong>Reason</strong>.
It is recommended to use an atom as <strong>Reason</strong> since
it will be wrapped in an <strong>{error,Reason}</strong> tuple.
</p><p>
Also note when upgrading a <strong>gen_statem</strong>,
this function and hence
the <strong>Change = {advanced,Extra}</strong> parameter in the
<a href="./appup">sasl/appup</a> file
is not only needed to update the internal state
or to act on the <strong>Extra</strong> argument.
It is also needed if an upgrade or downgrade should change 
<a href="#type-callback_mode">type-callback_mode</a>,
or else the <em>callback mode</em> after the code change
will not be honoured,
most probably causing a server crash.
</p><h3>Module:init(Args) -&gt; Result(StateType)</h3><p> Initializing process and internal state. </p><ul><li><span class="v">Args = term()</span></li><li><span class="v"> Result(StateType) =  </span></li></ul><a name="Module:init-1"></a><p>
Whenever a <strong>gen_statem</strong> is started using
<a href="#start_link/3">start_link/3</a>
or
<a href="#start/3">start/3</a>,
this function is called by the new process to initialize
the implementation state and server data.
</p><p>
<strong>Args</strong> is the <strong>Args</strong> argument provided to that start
function.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Note that if the <strong>gen_statem</strong> is started through
<a href="proc_lib">proc_lib</a>
and
<a href="#enter_loop/4">enter_loop/4</a>,
this callback will never be called.
Since this callback is not optional it can
in that case be implemented as:
</p><pre>
init(Args) -&gt; erlang:error(not_implemented, [Args]).</pre></div><h3>Module:format_status(Opt, [PDict,State,Data]) -&gt;
        Status
</h3><p>Optional function for providing a term describing the current <strong>gen_statem</strong> status.</p><ul><li><span class="v">Opt = normal | terminate</span></li><li><span class="v">PDict = [{Key, Value}]</span></li><li><span class="v"> State =  </span></li><li><span class="v"> Data =  </span></li><li><span class="v">Key = term()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">Status = term()</span></li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
This callback is optional, so a callback module does not need
to export it. The <strong>gen_statem</strong> module provides a default
implementation of this function that returns
<strong>{State,Data}</strong>.
</p><p>
If this callback is exported but fails,
to hide possibly sensitive data,
the default function will instead return <strong>{State,Info}</strong>,
where <strong>Info</strong> says nothing but the fact that
<strong>format_status/2</strong> has crashed.
</p></div><p>This function is called by a <strong>gen_statem</strong> process when
any of the following apply:</p><ul><li> One of <a href="./sys#get_status/1">sys#get_status/1</a> is invoked to get the <strong>gen_statem</strong> status. <strong>Opt</strong> is set to the atom <strong>normal</strong> for this case. </li><li> The <strong>gen_statem</strong> terminates abnormally and logs an error. <strong>Opt</strong> is set to the atom <strong>terminate</strong> for this case. </li></ul><p>
This function is useful for changing the form and
appearance of the <strong>gen_statem</strong> status for these cases. A
callback module wishing to change the
<a href="./sys#get_status/1">sys#get_status/1</a>
return value and how
its status appears in termination error logs exports an
instance of <strong>format_status/2</strong>, which returns a term
describing the current status of the <strong>gen_statem</strong>.
</p><p>
<strong>PDict</strong> is the current value of the process dictionary
of the <strong>gen_statem</strong>.
</p><p>
<a href="#type-state">type-state</a>
is the internal state of the <strong>gen_statem</strong>.
</p><p>
<a href="#type-data">type-data</a>
is the internal server data of the <strong>gen_statem</strong>.
</p><p>
The function is to return <strong>Status</strong>, a term that
contains the appropriate details
of the current state and status of
the <strong>gen_statem</strong>. There are no restrictions on the
form <strong>Status</strong> can take, but for the
<a href="./sys#get_status/1">sys#get_status/1</a>
case (when <strong>Opt</strong>
is <strong>normal</strong>), the recommended form for
the <strong>Status</strong> value is <strong>[{data, [{"State", Term}]}]</strong>, where <strong>Term</strong> provides relevant details of
the <strong>gen_statem</strong> state. Following this recommendation is not
required, but it makes the callback module status
consistent with the rest of the
<a href="./sys#get_status/1">sys#get_status/1</a>
return value.
</p><p>
One use for this function is to return compact alternative
state representations to avoid having large state terms
printed in log files. Another use is to hide sensitive data from
being written to the error log.
</p><h3>Module:StateName(enter, OldState, Data) -&gt;
        StateEnterResult(StateName)
</h3><h3>Module:StateName(EventType, EventContent, Data) -&gt;
        StateFunctionResult
</h3><h3>Module:handle_event(enter, OldState, State, Data) -&gt;
	StateEnterResult(State)
</h3><h3>Module:handle_event(EventType, EventContent, State, Data) -&gt;
	HandleEventResult
</h3><p>Handle an event.</p><ul><li><span class="v"> EventType =  </span></li><li><span class="v">EventContent = term()</span></li><li><span class="v"> State =  </span></li><li><span class="v"> Data = NewData =  </span></li><li><span class="v"> StateEnterResult(StateName) =  </span></li><li><span class="v"> StateFunctionResult = () </span></li><li><span class="v"> StateEnterResult(State) =  </span></li><li><span class="v"> HandleEventResult = () </span></li></ul><p>
Whenever a <strong>gen_statem</strong> receives an event from
<a href="#call/2">call/2</a>,
<a href="#cast/2">cast/2</a>, or
as a normal process message, one of these functions is called. If
<a href="#type-callback_mode">type-callback_mode</a>
is <strong>state_functions</strong>, <strong>Module:StateName/3</strong> is called,
and if it is <strong>handle_event_function</strong>,
<strong>Module:handle_event/4</strong> is called.
</p><p>
If <strong>EventType</strong> is
<a href="#type-event_type">type-event_type</a>,
the caller waits for a reply. The reply can be sent
from this or from any other
<a href="#state callback">state callback</a>
by returning with <strong>{reply,From,Reply}</strong> in
<a href="#type-action">type-action</a>, in
<a href="#type-reply_action">type-reply_action</a>,
or by calling
<a href="#reply/2">reply/2</a>.
</p><p>
If this function returns with a next state that
does not match equal (<strong>=/=</strong>) to the current state,
all postponed events are retried in the next state.
</p><p>
The only difference between <strong>StateFunctionResult</strong> and
<strong>HandleEventResult</strong> is that for <strong>StateFunctionResult</strong>
the next state must be an atom, but for <strong>HandleEventResult</strong>
there is no restriction on the next state.
</p><p>
For options that can be set and actions that can be done
by <strong>gen_statem</strong> after returning from this function,
see <a href="#type-action">type-action</a>.
</p><p>
When the <strong>gen_statem</strong> runs with
<a href="#type-state_enter">type-state_enter</a>,
these functions are also called with arguments
<strong>(enter, OldState, ...)</strong> during every <em>state change</em>.
In this case there are some restrictions on the
<a href="#type-enter_action">actions</a>
that may be returned:
<a href="#type-postpone">type-postpone</a>
is not allowed since a <em>state enter call</em> is not
an event so there is no event to postpone, and 
<a href="#type-action">type-action</a>
is not allowed since using <em>state enter calls</em>
should not affect how events are consumed and produced.
You may also not change states from this call.
Should you return <strong>{next_state,NextState, ...}</strong>
with <strong>NextState =/= State</strong> the <strong>gen_statem</strong> crashes.
Note that it is actually allowed to use
<strong>{repeat_state, NewData, ...}</strong> although it makes little
sense since you immediately will be called again with a new
<em>state enter call</em> making this just a weird way
of looping, and there are better ways to loop in Erlang.
If you do not update <strong>NewData</strong> and have some
loop termination condition, or if you use
<strong>{repeat_state_and_data, _}</strong> or
<strong>repeat_state_and_data</strong> you have an infinite loop!
You are advised to use <strong>{keep_state,...}</strong>,
<strong>{keep_state_and_data,_}</strong> or
<strong>keep_state_and_data</strong>
since changing states from a <em>state enter call</em>
is not possible anyway.
</p><p>
Note the fact that you can use
<a href="../erts/erlang#throw/1">erts/erlang#throw/1</a>
to return the result, which can be useful.
For example to bail out with <strong>throw(keep_state_and_data)</strong>
from deep within complex code that cannot
return <strong>{next_state,State,Data}</strong> because
<strong>State</strong> or <strong>Data</strong> is no longer in scope.
</p><h3>Module:terminate(Reason, State, Data) -&gt; Ignored</h3><p>Clean up before termination.</p><ul><li><span class="v">Reason = normal | shutdown | {shutdown,term()} | term()</span></li><li><span class="v">State = </span></li><li><span class="v">Data = </span></li><li><span class="v">Ignored = term()</span></li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This callback is optional, so callback modules need not
export it. The <strong>gen_statem</strong> module provides a default
implementation without cleanup.</p></div><p>
This function is called by a <strong>gen_statem</strong>
when it is about to terminate. It is to be the opposite of
<a href="#Module:init/1">Module:init/1</a>
and do any necessary cleaning up. When it returns,
the <strong>gen_statem</strong> terminates with <strong>Reason</strong>. The return
value is ignored.</p><p>
<strong>Reason</strong> is a term denoting the stop reason and
<a href="#type-state">type-state</a>
is the internal state of the <strong>gen_statem</strong>.
</p><p>
<strong>Reason</strong> depends on why the <strong>gen_statem</strong>
is terminating.
If it is because another callback function has returned, a
stop tuple <strong>{stop,Reason}</strong> in
<a href="#type-action">type-action</a>,
<strong>Reason</strong> has the value specified in that tuple.
If it is because of a failure, <strong>Reason</strong> is the error reason.
</p><p>
If the <strong>gen_statem</strong> is part of a supervision tree and is
ordered by its supervisor to terminate, this function is
called with <strong>Reason = shutdown</strong> if both the following
conditions apply:</p><ul><li> <p>
The <strong>gen_statem</strong> has been set
to trap exit signals.
</p> </li><li> <p>
The shutdown strategy as defined in the supervisor's
child specification is an integer time-out value, not
<strong>brutal_kill</strong>.
</p> </li></ul><p>
Even if the <strong>gen_statem</strong> is <em>not</em>
part of a supervision tree, this function is called
if it receives an <strong>'EXIT'</strong> message from its parent.
<strong>Reason</strong> is the same as
in the <strong>'EXIT'</strong> message.
</p><p>
Otherwise, the <strong>gen_statem</strong> is immediately terminated.
</p><p>
Notice that for any other reason than <strong>normal</strong>,
<strong>shutdown</strong>, or <strong>{shutdown,Term}</strong>,
the <strong>gen_statem</strong> is assumed to terminate because of an error
and an error report is issued using
<a href="./logger">kernel/logger</a>.
</p><h3>See Also</h3><p>
<a href="gen_event">gen_event</a>,
<a href="gen_fsm">gen_fsm</a>,
<a href="gen_server">gen_server</a>,
<a href="proc_lib">proc_lib</a>,
<a href="supervisor">supervisor</a>,
<a href="sys">sys</a>.
</p><h2>io</h2><p>Standard I/O server interface functions.</p><p>This module provides an interface to standard Erlang I/O servers.
The output functions all return <strong>ok</strong> if they are successful,
or exit if they are not.All functions in this module have an optional
parameter <strong>IoDevice</strong>. If included, it must be the pid of a
process that handles the I/O protocols. Normally, it is the
<strong>IoDevice</strong> returned by
<a href="../kernel/file#open/2">kernel/file#open/2</a>.For a description of the I/O protocols, see section
<a href="io_protocol">The Erlang I/O Protocol</a>
in the User's Guide.</p><h2>Data Types</h2><span class="name">device</span><p>An I/O device, either <strong>standard_io</strong>, <strong>standard_error</strong>, a
registered name, or a pid handling I/O protocols (returned from
<a href="../kernel/file#open/2">kernel/file#open/2</a>).
</p><span class="name">opt_pair</span><span class="name">expand_fun</span><span class="name">encoding</span><span class="name">setopt</span><span class="name">format</span><span class="name">location</span><span class="name">prompt</span><span class="name">server_no_data</span><p>What the I/O server sends when there is no data.</p><h2>Functions</h2><h3>columns/0</h3><h3>columns/1</h3><p>Get the number of columns of an I/O device.</p><p>Retrieves the number of columns of the
<strong><span class="anno">IoDevice</span></strong> (that is, the width of a terminal).
The function succeeds for terminal devices and returns
<strong>{error, enotsup}</strong> for all other I/O devices.</p><h3>format/1</h3><h3>format/2</h3><h3>format/3</h3><h3>fwrite/1</h3><h3>fwrite/2</h3><h3>fwrite/3</h3><p>Write formatted output.</p><p>Writes the items in <strong><span class="anno">Data</span></strong> (<strong>[]</strong>) on the
standard output (<strong><span class="anno">IoDevice</span></strong>) in accordance with
<strong><span class="anno">Format</span></strong>. <strong><span class="anno">Format</span></strong> contains
plain characters that are copied to
the output device, and control sequences for formatting, see
below. If <strong><span class="anno">Format</span></strong> is an atom or a binary, it is
first converted to a list with the aid of <strong>atom_to_list/1</strong> or
<strong>binary_to_list/1</strong>. Example:</p><pre>
1&gt; <span class="input">io:fwrite("Hello world!~n", []).</span>
Hello world!
ok</pre><p>The general format of a control sequence is <strong>~F.P.PadModC</strong>.</p><p>The character <strong>C</strong> determines the type of control sequence
to be used. It is the only required field. All of <strong>F</strong>,
<strong>P</strong>, <strong>Pad</strong>, and <strong>Mod</strong> are optional. For example,
to use a <strong>#</strong> for <strong>Pad</strong> but use the default values for
<strong>F</strong> and <strong>P</strong>, you can write <strong>~..#C</strong>.</p><ul><li> <p><strong>F</strong> is the <strong>field width</strong> of the printed argument. A
negative value means that the argument is left-justified
within the field, otherwise right-justified. If no
field width is specified, the required print width is
used. If the field width specified is too small, the
whole field is filled with <strong>*</strong> characters.</p> </li><li> <p><strong>P</strong> is the <strong>precision</strong> of the printed argument. A
default value is used if no precision is specified. The
interpretation of precision depends on the control sequences.
Unless otherwise specified, argument <strong>within</strong> is used
to determine print width.</p> </li><li> <p><strong>Pad</strong> is the padding character. This is the character
used to pad the printed representation of the argument so that
it conforms to the specified field width and precision. Only
one padding character can be specified and, whenever
applicable, it is used for both the field width and precision.
The default padding character is <strong>' '</strong> (space).</p> </li><li> <p><strong>Mod</strong> is the control sequence modifier. This is
one or more characters that change the interpretation of
<strong>Data</strong>. The current modifiers are <strong>t</strong>, for Unicode
translation, and <strong>l</strong>, for stopping <strong>p</strong> and <strong>P</strong>
from detecting printable characters.</p> </li></ul><p>If <strong>F</strong>, <strong>P</strong>, or <strong>Pad</strong> is a <strong>*</strong> character,
the next argument in <strong>Data</strong> is used as the value.
For example:</p><pre>
1&gt; <span class="input">io:fwrite("~*.*.0f~n",[9, 5, 3.14159265]).</span>
003.14159
ok</pre><p>To use a literal <strong>*</strong> character as <strong>Pad</strong>, it must be
passed as an argument:</p><pre>
2&gt; <span class="input">io:fwrite("~*.*.*f~n",[9, 5, $*, 3.14159265]).</span>
**3.14159
ok</pre><p><em>Available control sequences:</em></p><dl><dt><strong>~</strong></dt><dd> <p>Character <strong>~</strong> is written.</p> </dd><dt><strong>c</strong></dt><dd> <p>The argument is a number that is interpreted as an
ASCII code. The precision is the number of times the
character is printed and defaults to the field width,
which in turn defaults to 1. Example:</p> <pre>
1&gt; <span class="input">io:fwrite("|~10.5c|~-10.5c|~5c|~n", [$a, $b, $c]).</span>
|     aaaaa|bbbbb     |ccccc|
ok</pre> <p>If the Unicode translation modifier (<strong>t</strong>) is in effect,
the integer argument can be any number representing a
valid Unicode codepoint, otherwise it is to be an integer
less than or equal to 255, otherwise it is masked with 16#FF:</p> <pre>
2&gt; <span class="input">io:fwrite("~tc~n",[1024]).</span>
\x{400}
ok
3&gt; <span class="input">io:fwrite("~c~n",[1024]).</span>
^@
ok</pre> </dd><dt><strong>f</strong></dt><dd> <p>The argument is a float that is written as
<strong>[-]ddd.ddd</strong>, where the precision is the number of
digits after the decimal point. The default precision is 6
and it cannot be &lt; 1.</p> </dd><dt><strong>e</strong></dt><dd> <p>The argument is a float that is written as
<strong>[-]d.ddde+-ddd</strong>, where the precision is the number
of digits written. The default precision is 6 and it
cannot be &lt; 2.</p> </dd><dt><strong>g</strong></dt><dd> <p>The argument is a float that is written as <strong>f</strong>, if
it is &gt;= 0.1 and &lt; 10000.0. Otherwise, it is written
in the <strong>e</strong> format. The precision is the number of
significant digits. It defaults to 6 and is not to be
&lt; 2. If the absolute value of the float does not
allow it to be written in the <strong>f</strong> format with the
desired number of significant digits, it is also written
in the <strong>e</strong> format.</p> </dd><dt><strong>s</strong></dt><dd> <p>Prints the argument with the string syntax. The
argument is, if no Unicode translation modifier is present, an 
<strong>iolist()</strong>, a <strong>binary()</strong>, or an <strong>atom()</strong>.
If the Unicode translation modifier (<strong>t</strong>) is in effect,
the argument is <strong>unicode:chardata()</strong>, meaning that
binaries are in UTF-8. The characters
are printed without quotes. The string is first truncated
by the specified precision and then padded and justified to the
specified field width. The default precision is the field width.
</p> <p>This format can be used for printing any object and
truncating the output so it fits a specified field:</p> <pre>
1&gt; <span class="input">io:fwrite("|~10w|~n", [{hey, hey, hey}]).</span>
|**********|
ok
2&gt; <span class="input">io:fwrite("|~10s|~n", [io_lib:write({hey, hey, hey})]).</span>
|{hey,hey,h|
3&gt; <span class="input">io:fwrite("|~-10.8s|~n", [io_lib:write({hey, hey, hey})]).</span>
|{hey,hey  |
ok</pre> <p>A list with integers &gt; 255 is considered an error if the
Unicode translation modifier is not specified:</p> <pre>
4&gt; <span class="input">io:fwrite("~ts~n",[[1024]]).</span>
\x{400}
ok
5&gt; <span class="input">io:fwrite("~s~n",[[1024]]).</span>
** exception error: bad argument
     in function  io:format/3
        called as io:format(&lt;0.53.0&gt;,"~s~n",[[1024]])</pre> </dd><dt><strong>w</strong></dt><dd> <p>Writes data with the standard syntax. This is used to
output Erlang terms. Atoms are printed within quotes if
they contain embedded non-printable characters.
Atom characters &gt; 255 are escaped unless the
Unicode translation modifier (<strong>t</strong>) is used.
Floats are printed accurately as the shortest, correctly
rounded string.</p> </dd><dt><strong>p</strong></dt><dd> <p>Writes the data with standard syntax in the same way as
<strong>~w</strong>, but breaks terms whose printed representation
is longer than one line into many lines and indents each
line sensibly. Left-justification is not supported.
It also tries to detect flat lists of
printable characters and output these as strings.
For example:</p> <pre>
1&gt; <span class="input">T = [{attributes,[[{id,age,1.50000},{mode,explicit},</span>
<span class="input">{typename,"INTEGER"}], [{id,cho},{mode,explicit},{typename,'Cho'}]]},</span>
<span class="input">{typename,'Person'},{tag,{'PRIVATE',3}},{mode,implicit}].</span>
...
2&gt; <span class="input">io:fwrite("~w~n", [T]).</span>
[{attributes,[[{id,age,1.5},{mode,explicit},{typename,
[73,78,84,69,71,69,82]}],[{id,cho},{mode,explicit},{typena
me,'Cho'}]]},{typename,'Person'},{tag,{'PRIVATE',3}},{mode
,implicit}]
ok
3&gt; <span class="input">io:fwrite("~62p~n", [T]).</span>
[{attributes,[[{id,age,1.5},
               {mode,explicit},
               {typename,"INTEGER"}],
              [{id,cho},{mode,explicit},{typename,'Cho'}]]},
 {typename,'Person'},
 {tag,{'PRIVATE',3}},
 {mode,implicit}]
ok</pre> <p>The field width specifies the maximum line length.
It defaults to 80. The precision specifies the initial
indentation of the term. It defaults to the number of
characters printed on this line in the <em>same</em> call to
<a href="#write/1">write/1</a> or
<a href="#format/1">format/1</a>.
For example, using <strong>T</strong> above:</p> <pre>
4&gt; <span class="input">io:fwrite("Here T = ~62p~n", [T]).</span>
Here T = [{attributes,[[{id,age,1.5},
                        {mode,explicit},
                        {typename,"INTEGER"}],
                       [{id,cho},
                        {mode,explicit},
                        {typename,'Cho'}]]},
          {typename,'Person'},
          {tag,{'PRIVATE',3}},
          {mode,implicit}]
ok</pre> <p>As from Erlang/OTP 21.0, a field width of value
<strong>0</strong> can be used for specifying that a line is
infinitely long, which means that no line breaks
are inserted. For example:</p> <pre>
5&gt; <span class="input">io:fwrite("~0p~n", [lists:seq(1, 30)]).</span>
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]
ok</pre> <p>When the modifier <strong>l</strong> is specified, no detection of
printable character lists takes place, for example:</p> <pre>
6&gt; <span class="input">S = [{a,"a"}, {b, "b"}], io:fwrite("~15p~n", [S]).</span>
[{a,"a"},
 {b,"b"}]
ok
7&gt; <span class="input">io:fwrite("~15lp~n", [S]).</span>
[{a,[97]},
 {b,[98]}]
ok</pre> <p>The Unicode translation modifier <strong>t</strong> specifies how to treat
characters outside the Latin-1 range of codepoints, in
atoms, strings, and binaries. For example, printing an atom
containing a character &gt; 255:</p> <pre>
8&gt; <span class="input">io:fwrite("~p~n",[list_to_atom([1024])]).</span>
'\x{400}'
ok
9&gt; <span class="input">io:fwrite("~tp~n",[list_to_atom([1024])]).</span>
''
ok</pre> <p>By default, Erlang only detects lists of characters
in the Latin-1 range as strings, but the <strong>+pc unicode</strong>
flag can be used to change this (see <a href="#printable_range/0">printable_range/0</a> for details). For example:</p> <pre>
10&gt; <span class="input">io:fwrite("~p~n",[[214]]).</span>
""
ok
11&gt; <span class="input">io:fwrite("~p~n",[[1024]]).</span>
[1024]
ok
12&gt; <span class="input">io:fwrite("~tp~n",[[1024]]).</span>
[1024]
ok
</pre> <p>but if Erlang was started with <strong>+pc unicode</strong>:</p> <pre>
13&gt; <span class="input">io:fwrite("~p~n",[[1024]]).</span>
[1024]
ok
14&gt; <span class="input">io:fwrite("~tp~n",[[1024]]).</span>
""
ok</pre> <p>Similarly, binaries that look like UTF-8 encoded strings
are output with the binary string syntax if the <strong>t</strong>
modifier is specified:</p> <pre>
15&gt; <span class="input">io:fwrite("~p~n", [&lt;&lt;208,128&gt;&gt;]).</span>
&lt;&lt;208,128&gt;&gt;
ok
16&gt; <span class="input">io:fwrite("~tp~n", [&lt;&lt;208,128&gt;&gt;]).</span>
&lt;&lt;""/utf8&gt;&gt;
ok
17&gt; <span class="input">io:fwrite("~tp~n", [&lt;&lt;128,128&gt;&gt;]).</span>
&lt;&lt;128,128&gt;&gt;
ok</pre> </dd><dt><strong>W</strong></dt><dd> <p>Writes data in the same way as <strong>~w</strong>, but takes an
extra argument that is the maximum depth to which terms
are printed. Anything below this depth is replaced with
<strong>...</strong>. For example, using <strong>T</strong> above:</p> <pre>
8&gt; <span class="input">io:fwrite("~W~n", [T,9]).</span>
[{attributes,[[{id,age,1.5},{mode,explicit},{typename,...}],
[{id,cho},{mode,...},{...}]]},{typename,'Person'},
{tag,{'PRIVATE',3}},{mode,implicit}]
ok</pre> <p>If the maximum depth is reached, it cannot
be read in the resultant output. Also, the
<strong>,...</strong> form in a tuple denotes that there are more
elements in the tuple but these are below the print depth.</p> </dd><dt><strong>P</strong></dt><dd> <p>Writes data in the same way as <strong>~p</strong>, but takes an
extra argument that is the maximum depth to which terms
are printed. Anything below this depth is replaced with
<strong>...</strong>, for example:</p> <pre>
9&gt; <span class="input">io:fwrite("~62P~n", [T,9]).</span>
[{attributes,[[{id,age,1.5},{mode,explicit},{typename,...}],
              [{id,cho},{mode,...},{...}]]},
 {typename,'Person'},
 {tag,{'PRIVATE',3}},
 {mode,implicit}]
ok</pre> </dd><dt><strong>B</strong></dt><dd> <p>Writes an integer in base 2-36, the default base is
10. A leading dash is printed for negative integers.</p> <p>The precision field selects base, for example:</p> <pre>
1&gt; <span class="input">io:fwrite("~.16B~n", [31]).</span>
1F
ok
2&gt; <span class="input">io:fwrite("~.2B~n", [-19]).</span>
-10011
ok
3&gt; <span class="input">io:fwrite("~.36B~n", [5*36+35]).</span>
5Z
ok</pre> </dd><dt><strong>X</strong></dt><dd> <p>Like <strong>B</strong>, but takes an extra argument that is a
prefix to insert before the number, but after the leading
dash, if any.</p> <p>The prefix can be a possibly deep list of characters or
an atom. Example:</p> <pre>
1&gt; <span class="input">io:fwrite("~X~n", [31,"10#"]).</span>
10#31
ok
2&gt; <span class="input">io:fwrite("~.16X~n", [-31,"0x"]).</span>
-0x1F
ok</pre> </dd><dt><strong>#</strong></dt><dd> <p>Like <strong>B</strong>, but prints the number with an Erlang style
<strong>#</strong>-separated base prefix. Example:</p> <pre>
1&gt; <span class="input">io:fwrite("~.10#~n", [31]).</span>
10#31
ok
2&gt; <span class="input">io:fwrite("~.16#~n", [-31]).</span>
-16#1F
ok</pre> </dd><dt><strong>b</strong></dt><dd> <p>Like <strong>B</strong>, but prints lowercase letters.</p> </dd><dt><strong>x</strong></dt><dd> <p>Like <strong>X</strong>, but prints lowercase letters.</p> </dd><dt><strong>+</strong></dt><dd> <p>Like <strong>#</strong>, but prints lowercase letters.</p> </dd><dt><strong>n</strong></dt><dd> <p>Writes a new line.</p> </dd><dt><strong>i</strong></dt><dd> <p>Ignores the next term.</p> </dd></dl><p>The function returns:</p><dl><dt><strong>ok</strong></dt><dd> <p>The formatting succeeded.</p> </dd></dl><p>If an error occurs, there is no output. Example:</p><pre>
1&gt; <span class="input">io:fwrite("~s ~w ~i ~w ~c ~n",['abc def', 'abc def', {foo, 1},{foo, 1}, 65]).</span>
abc def 'abc def'  {foo,1} A
ok
2&gt; <span class="input">io:fwrite("~s", [65]).</span>
** exception error: bad argument
     in function  io:format/3
        called as io:format(&lt;0.53.0&gt;,"~s","A")</pre><p>In this example, an attempt was made to output the single
character 65 with the aid of the string formatting directive
<strong>"~s"</strong>.</p><h3>fread/2</h3><h3>fread/3</h3><p>Read formatted input.</p><ul><li>server_no_data</li></ul><p>Reads characters from the standard input
(<strong><span class="anno">IoDevice</span></strong>), prompting it with
<strong><span class="anno">Prompt</span></strong>. Interprets the characters in accordance
with <strong><span class="anno">Format</span></strong>. <strong><span class="anno">Format</span></strong> contains
control sequences that directs the interpretation of the input.</p><p><strong><span class="anno">Format</span></strong> can contain the following:</p><ul><li> <p>Whitespace characters (<em>Space</em>, <em>Tab</em>, and
<em>Newline</em>) that cause input to be read to the next
non-whitespace character.</p> </li><li> <p>Ordinary characters that must match the next input
character.</p> </li><li> <p>Control sequences, which have the general format
<strong>~*FMC</strong>, where:</p> <ul><li> <p>Character <strong>*</strong> is an optional return suppression
character. It provides a method to specify a field that
is to be omitted.</p> </li><li> <p><strong>F</strong> is the <strong>field width</strong> of the input field.</p> </li><li> <p><strong>M</strong> is an optional translation modifier (of which
<strong>t</strong> is the only supported, meaning Unicode
translation).</p> </li><li> <p><strong>C</strong> determines the type of control sequence.</p> </li></ul> <p>Unless otherwise specified, leading whitespace is
ignored for all control sequences. An input field cannot
be more than one line wide.</p> <p><em>Available control sequences:</em></p> <dl><dt><strong>~</strong></dt><dd> <p>A single <strong>~</strong> is expected in the input.</p> </dd><dt><strong>d</strong></dt><dd> <p>A decimal integer is expected.</p> </dd><dt><strong>u</strong></dt><dd> <p>An unsigned integer in base 2-36 is expected. The
field width parameter is used to specify base. Leading
whitespace characters are not skipped.</p> </dd><dt><strong>-</strong></dt><dd> <p>An optional sign character is expected. A sign
character <strong>-</strong> gives return value <strong>-1</strong>. Sign
character <strong>+</strong> or none gives <strong>1</strong>. The field width
parameter is ignored. Leading whitespace characters
are not skipped.</p> </dd><dt><strong>#</strong></dt><dd> <p>An integer in base 2-36 with Erlang-style base
prefix (for example, <strong>"16#ffff"</strong>) is expected.</p> </dd><dt><strong>f</strong></dt><dd> <p>A floating point number is expected. It must follow
the Erlang floating point number syntax.</p> </dd><dt><strong>s</strong></dt><dd> <p>A string of non-whitespace characters is read. If a
field width has been specified, this number of
characters are read and all trailing whitespace
characters are stripped. An Erlang string (list of
characters) is returned.</p> <p>If Unicode translation is in effect (<strong>~ts</strong>),
characters &gt; 255 are accepted, otherwise
not. With the translation modifier, the returned
list can as a consequence also contain integers &gt; 255:</p> <pre>
1&gt; <span class="input">io:fread("Prompt&gt; ","~s").</span>
Prompt&gt; <span class="input">&lt;Characters beyond latin1 range not printable in this medium&gt;</span>
{error,{fread,string}}
2&gt; <span class="input">io:fread("Prompt&gt; ","~ts").</span>
Prompt&gt; <span class="input">&lt;Characters beyond latin1 range not printable in this medium&gt;</span>
{ok,[[1091,1085,1080,1094,1086,1076,1077]]}</pre> </dd><dt><strong>a</strong></dt><dd> <p>Similar to <strong>s</strong>, but the resulting string is
converted into an atom.</p> </dd><dt><strong>c</strong></dt><dd> <p>The number of characters equal to the field width are
read (default is 1) and returned as an Erlang string.
However, leading and trailing whitespace characters
are not omitted as they are with <strong>s</strong>. All
characters are returned.</p> <p>The Unicode translation modifier works as with <strong>s</strong>:
</p> <pre>
1&gt; <span class="input">io:fread("Prompt&gt; ","~c").</span>
Prompt&gt; <span class="input">&lt;Character beyond latin1 range not printable in this medium&gt;</span>
{error,{fread,string}}
2&gt; <span class="input">io:fread("Prompt&gt; ","~tc").</span>
Prompt&gt; <span class="input">&lt;Character beyond latin1 range not printable in this medium&gt;</span>
{ok,[[1091]]}</pre> </dd><dt><strong>l</strong></dt><dd> <p>Returns the number of characters that have been
scanned up to that point, including whitespace
characters.</p> </dd></dl> <p>The function returns:</p> <dl><dt><strong>{ok, <span class="anno">Terms</span>}</strong></dt><dd> <p>The read was successful and <strong><span class="anno">Terms</span></strong> is
the list of successfully matched and read items.</p> </dd><dt><strong>eof</strong></dt><dd> <p>End of file was encountered.</p> </dd><dt><strong>{error, <span class="anno">FreadError</span>}</strong></dt><dd> <p>The reading failed and <strong>FreadError</strong> gives a
hint about the error.</p> </dd><dt><strong>{error, <span class="anno">ErrorDescription</span>}</strong></dt><dd> <p>The read operation failed and parameter
<strong><span class="anno">ErrorDescription</span></strong> gives a hint about
the error.</p> </dd></dl> </li></ul><p><em>Examples:</em></p><pre>
20&gt; <span class="input">io:fread('enter&gt;', "~f~f~f").</span>
enter&gt;<span class="input">1.9 35.5e3 15.0</span>
{ok,[1.9,3.55e4,15.0]}
21&gt; <span class="input">io:fread('enter&gt;', "~10f~d").</span>
enter&gt;     <span class="input">5.67899</span>
{ok,[5.678,99]}
22&gt; <span class="input">io:fread('enter&gt;', ":~10s:~10c:").</span>
enter&gt;<span class="input">:</span>   <span class="input">alan</span>   <span class="input">:</span>   <span class="input">joe</span>    <span class="input">:</span>
{ok, ["alan", "   joe    "]}</pre><h3>get_chars/2</h3><h3>get_chars/3</h3><p>Read a specified number of characters.</p><ul><li>server_no_data</li></ul><p>Reads <strong><span class="anno">Count</span></strong> characters from standard input
(<strong><span class="anno">IoDevice</span></strong>), prompting it with
<strong><span class="anno">Prompt</span></strong>.</p><p>The function returns:</p><dl><dt><strong><span class="anno">Data</span></strong></dt><dd> <p>The input characters. If the I/O device supports Unicode,
the data can represent codepoints &gt; 255 (the
<strong>latin1</strong> range). If the I/O server is set to deliver
binaries, they are encoded in UTF-8 (regardless of whether
the I/O device supports Unicode).</p> </dd><dt><strong>eof</strong></dt><dd> <p>End of file was encountered.</p> </dd><dt><strong>{error, <span class="anno">ErrorDescription</span>}</strong></dt><dd> <p>Other (rare) error condition, such as <strong>{error, estale}</strong>
if reading from an NFS file system.</p> </dd></dl><h3>get_line/1</h3><h3>get_line/2</h3><p>Read a line.</p><ul><li>server_no_data</li></ul><p>Reads a line from the standard input (<strong><span class="anno">IoDevice</span></strong>),
prompting it with <strong><span class="anno">Prompt</span></strong>.</p><p>The function returns:</p><dl><dt><strong><span class="anno">Data</span></strong></dt><dd> <p>The characters in the line terminated by a line feed (or end of
file). If the I/O device supports Unicode,
the data can represent codepoints &gt; 255 (the
<strong>latin1</strong> range). If the I/O server is set to deliver
binaries, they are encoded in UTF-8 (regardless of if
the I/O device supports Unicode).</p> </dd><dt><strong>eof</strong></dt><dd> <p>End of file was encountered.</p> </dd><dt><strong>{error, <span class="anno">ErrorDescription</span>}</strong></dt><dd> <p>Other (rare) error condition, such as <strong>{error, estale}</strong>
if reading from an NFS file system.</p> </dd></dl><h3>getopts/0</h3><h3>getopts/1</h3><p>Get the supported options and values from an I/O server. </p><p>Requests all available options and their current
values for a specific I/O device, for example:</p><pre>
1&gt; <span class="input">{ok,F} = file:open("/dev/null",[read]).</span>
{ok,&lt;0.42.0&gt;}
2&gt; <span class="input">io:getopts(F).</span>
[{binary,false},{encoding,latin1}]</pre><p>Here the file I/O server returns all available options for a file,
which are the expected ones, <strong>encoding</strong> and <strong>binary</strong>.
However, the standard shell has some more options:</p><pre>
3&gt; io:getopts().
[{expand_fun,#Fun&lt;group.0.120017273&gt;},
 {echo,true},
 {binary,false},
 {encoding,unicode}]</pre><p>This example is, as can be seen, run in an environment where the
terminal supports Unicode input and output.</p><h3>nl/0</h3><h3>nl/1</h3><p>Write a newline.</p><p>Writes new line to the standard output
(<strong><span class="anno">IoDevice</span></strong>).</p><h3>parse_erl_exprs/1</h3><h3>parse_erl_exprs/2</h3><h3>parse_erl_exprs/3</h3><h3>parse_erl_exprs/4</h3><p>Read, tokenize, and parse Erlang expressions.</p><ul><li>parse_ret</li></ul><ul><li>server_no_data</li></ul><p>Reads data from the standard input
(<strong><span class="anno">IoDevice</span></strong>), prompting it with
<strong><span class="anno">Prompt</span></strong>. Starts reading at location
<strong><span class="anno">StartLocation</span></strong> (<strong>1</strong>). Argument
<strong><span class="anno">Options</span></strong> is passed on as argument
<strong>Options</strong> of function <a href="./erl_scan#tokens/4">erl_scan#tokens/4</a>. The data is tokenized and parsed
as if it was a sequence of Erlang expressions until a final dot
(<strong>.</strong>) is reached.</p><p>The function returns:</p><dl><dt><strong>{ok, ExprList, EndLocation}</strong></dt><dd> <p>The parsing was successful.</p> </dd><dt><strong>{eof, EndLocation}</strong></dt><dd> <p>End of file was encountered by the tokenizer.</p> </dd><dt><strong>eof</strong></dt><dd> <p>End of file was encountered by the I/O server.</p> </dd><dt><strong>{error, ErrorInfo, ErrorLocation}</strong></dt><dd> <p>An error occurred while tokenizing or parsing.</p> </dd><dt><strong>{error, <span class="anno">ErrorDescription</span>}</strong></dt><dd> <p>Other (rare) error condition, such as <strong>{error, estale}</strong>
if reading from an NFS file system.</p> </dd></dl><p>Example:</p><pre>
25&gt; <span class="input">io:parse_erl_exprs('enter&gt;').</span>
enter&gt;<span class="input">abc(), "hey".</span>
{ok, [{call,1,{atom,1,abc},[]},{string,1,"hey"}],2}
26&gt; <span class="input">io:parse_erl_exprs ('enter&gt;').</span>
enter&gt;<span class="input">abc("hey".</span>
{error,{1,erl_parse,["syntax error before: ",["'.'"]]},2}</pre><h3>parse_erl_form/1</h3><h3>parse_erl_form/2</h3><h3>parse_erl_form/3</h3><h3>parse_erl_form/4</h3><p>Read, tokenize, and parse an Erlang form.</p><ul><li>parse_form_ret</li></ul><ul><li>server_no_data</li></ul><p>Reads data from the standard input (<strong><span class="anno">IoDevice</span></strong>),
prompting it with <strong><span class="anno">Prompt</span></strong>. Starts reading at
location <strong><span class="anno">StartLocation</span></strong> (<strong>1</strong>). Argument
<strong><span class="anno">Options</span></strong> is passed on as argument
<strong>Options</strong> of function <a href="./erl_scan#tokens/4">erl_scan#tokens/4</a>. The data is tokenized and parsed
as if it was an Erlang form (one of the valid Erlang expressions
in an Erlang source file) until a final dot (<strong>.</strong>) is reached.</p><p>The function returns:</p><dl><dt><strong>{ok, AbsForm, EndLocation}</strong></dt><dd> <p>The parsing was successful.</p> </dd><dt><strong>{eof, EndLocation}</strong></dt><dd> <p>End of file was encountered by the tokenizer.</p> </dd><dt><strong>eof</strong></dt><dd> <p>End of file was encountered by the I/O server.</p> </dd><dt><strong>{error, ErrorInfo, ErrorLocation}</strong></dt><dd> <p>An error occurred while tokenizing or parsing.</p> </dd><dt><strong>{error, <span class="anno">ErrorDescription</span>}</strong></dt><dd> <p>Other (rare) error condition, such as <strong>{error, estale}</strong>
if reading from an NFS file system.</p> </dd></dl><h3>printable_range/0</h3><p>Get user-requested printable character range.</p><p>Returns the user-requested range of printable Unicode characters.</p><p>The user can request a range of characters that are to be considered
printable in heuristic detection of strings by the shell and by the
formatting functions. This is done by supplying
<strong>+pc &lt;range&gt;</strong> when starting Erlang.</p><p>The only valid values for <strong>&lt;range&gt;</strong> are
<strong>latin1</strong> and <strong>unicode</strong>. <strong>latin1</strong> means that only code
points &lt; 256 (except control characters, and so on)
are considered printable. <strong>unicode</strong> means that all printable
characters in all Unicode character ranges are considered printable
by the I/O functions.</p><p>By default, Erlang is started so that only the <strong>latin1</strong> range
of characters indicate that a list of integers is a string.</p><p>The simplest way to use the setting is to call
<a href="./io_lib#printable_list/1">io_lib#printable_list/1</a>, which uses the return
value of this function to decide if a list is a string of printable
characters.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>In a future release, this function may return more values and
ranges. To avoid compatibility problems, it is recommended to use
function <a href="./io_lib#printable_list/1">io_lib#printable_list/1</a>.</p></div><h3>put_chars/1</h3><h3>put_chars/2</h3><p>Write a list of characters.</p><p>Writes the characters of <strong><span class="anno">CharData</span></strong> to the I/O
server (<strong><span class="anno">IoDevice</span></strong>).</p><h3>read/1</h3><h3>read/2</h3><p>Read a term.</p><ul><li>server_no_data</li></ul><p>Reads a term <strong><span class="anno">Term</span></strong> from the standard input
(<strong><span class="anno">IoDevice</span></strong>), prompting it with
<strong><span class="anno">Prompt</span></strong>.</p><p>The function returns:</p><dl><dt><strong>{ok, <span class="anno">Term</span>}</strong></dt><dd> <p>The parsing was successful.</p> </dd><dt><strong>eof</strong></dt><dd> <p>End of file was encountered.</p> </dd><dt><strong>{error, <span class="anno">ErrorInfo</span>}</strong></dt><dd> <p>The parsing failed.</p> </dd><dt><strong>{error, <span class="anno">ErrorDescription</span>}</strong></dt><dd> <p>Other (rare) error condition, such as <strong>{error, estale}</strong>
if reading from an NFS file system.</p> </dd></dl><h3>read/3</h3><h3>read/4</h3><p>Read a term.</p><ul><li>server_no_data</li></ul><p>Reads a term <strong><span class="anno">Term</span></strong> from
<strong><span class="anno">IoDevice</span></strong>, prompting it
with <strong><span class="anno">Prompt</span></strong>. Reading starts at location
<strong><span class="anno">StartLocation</span></strong>. Argument
<strong><span class="anno">Options</span></strong> is passed on as argument <strong>Options</strong>
of function <a href="./erl_scan#tokens/4">erl_scan#tokens/4</a>.</p><p>The function returns:</p><dl><dt><strong>{ok, Term, <span class="anno">EndLocation</span>}</strong></dt><dd> <p>The parsing was successful.</p> </dd><dt><strong>{eof, <span class="anno">EndLocation</span>}</strong></dt><dd> <p>End of file was encountered.</p> </dd><dt><strong>{error, <span class="anno">ErrorInfo</span>, <span class="anno">ErrorLocation</span>}</strong></dt><dd> <p>The parsing failed.</p> </dd><dt><strong>{error, <span class="anno">ErrorDescription</span>}</strong></dt><dd> <p>Other (rare) error condition, such as <strong>{error, estale}</strong>
if reading from an NFS file system.</p> </dd></dl><h3>rows/0</h3><h3>rows/1</h3><p>Get the number of rows of an I/O device.</p><p>Retrieves the number of rows of <strong><span class="anno">IoDevice</span></strong>
(that is, the height of a terminal). The function
only succeeds for terminal devices, for all other I/O devices
the function returns <strong>{error, enotsup}</strong>.</p><h3>scan_erl_exprs/1</h3><h3>scan_erl_exprs/2</h3><h3>scan_erl_exprs/3</h3><h3>scan_erl_exprs/4</h3><p>Read and tokenize Erlang expressions.</p><ul><li>server_no_data</li></ul><p>Reads data from the standard input (<strong>IoDevice</strong>),
prompting it with <strong>Prompt</strong>. Reading starts at location
<strong>StartLocation</strong> (<strong>1</strong>). Argument <strong><span class="anno">Options</span></strong>
is passed on as argument <strong>Options</strong> of function
<a href="./erl_scan#tokens/4">erl_scan#tokens/4</a>. The data is tokenized as if it
were a sequence of Erlang expressions until a final dot (<strong>.</strong>) is
reached. This token is also returned.</p><p>The function returns:</p><dl><dt><strong>{ok, Tokens, EndLocation}</strong></dt><dd> <p>The tokenization succeeded.</p> </dd><dt><strong>{eof, EndLocation}</strong></dt><dd> <p>End of file was encountered by the tokenizer.</p> </dd><dt><strong>eof</strong></dt><dd> <p>End of file was encountered by the I/O server.</p> </dd><dt><strong>{error, ErrorInfo, ErrorLocation}</strong></dt><dd> <p>An error occurred while tokenizing.</p> </dd><dt><strong>{error, <span class="anno">ErrorDescription</span>}</strong></dt><dd> <p>Other (rare) error condition, such as <strong>{error, estale}</strong>
if reading from an NFS file system.</p> </dd></dl><p><em>Example:</em></p><pre>
23&gt; <span class="input">io:scan_erl_exprs('enter&gt;').</span>
enter&gt;<span class="input">abc(), "hey".</span>
{ok,[{atom,1,abc},{'(',1},{')',1},{',',1},{string,1,"hey"},{dot,1}],2}
24&gt; <span class="input">io:scan_erl_exprs('enter&gt;').</span>
enter&gt;<span class="input">1.0er.</span>
{error,{1,erl_scan,{illegal,float}},2}</pre><h3>scan_erl_form/1</h3><h3>scan_erl_form/2</h3><h3>scan_erl_form/3</h3><h3>scan_erl_form/4</h3><p>Read and tokenize an Erlang form.</p><ul><li>server_no_data</li></ul><p>Reads data from the standard input (<strong><span class="anno">IoDevice</span></strong>),
prompting it with <strong><span class="anno">Prompt</span></strong>. Starts reading
at location <strong><span class="anno">StartLocation</span></strong> (<strong>1</strong>).
Argument <strong><span class="anno">Options</span></strong> is passed on as argument
<strong>Options</strong> of function <a href="./erl_scan#tokens/4">erl_scan#tokens/4</a>. The data is tokenized as if it
was an Erlang form (one of the valid Erlang expressions in an
Erlang source file) until a final dot (<strong>.</strong>) is reached.
This last token is also returned.</p><p>The return values are the same as for
<a href="#scan_erl_exprs/1">scan_erl_exprs/1</a>.</p><h3>setopts/1</h3><h3>setopts/2</h3><p>Set options.</p><p>Set options for the standard I/O device
(<strong><span class="anno">IoDevice</span></strong>).</p><p>Possible options and values vary depending on the
I/O device. For a list of supported options and their current values
on a specific I/O device, use function
<a href="#getopts/1">getopts/1</a>.</p><p>The options and values supported by the OTP I/O devices
are as follows:</p><dl><dt><strong>binary</strong>, <strong>list</strong>, or <strong>{binary, boolean()}</strong></dt><dd> <p>If set in binary mode (<strong>binary</strong> or <strong>{binary, true}</strong>),
the I/O server sends binary data (encoded in UTF-8) as answers
to the <strong>get_line</strong>, <strong>get_chars</strong>, and, if possible,
<strong>get_until</strong> requests (for details, see section
<a href="io_protocol">The Erlang I/O Protocol</a>)
in the User's Guide). The immediate effect is that
<a href="#get_chars/2">get_chars/2</a> and
<a href="#get_line/1">get_line/1</a>
return UTF-8 binaries instead of lists of characters
for the affected I/O device.</p> <p>By default, all I/O devices in OTP are set in <strong>list</strong> mode.
However, the I/O functions can handle any of these modes and so
should other, user-written, modules behaving as clients to I/O
servers.</p> <p>This option is supported by the standard shell
(<strong>group.erl</strong>), the 'oldshell' (<strong>user.erl</strong>), and the
file I/O servers.</p> </dd><dt><strong>{echo, boolean()}</strong></dt><dd> <p>Denotes if the terminal is to echo input. Only supported for
the standard shell I/O server (<strong>group.erl</strong>)</p> </dd><dt><strong>{expand_fun, expand_fun()}</strong></dt><dd> <p>Provides a function for tab-completion (expansion)
like the Erlang shell. This function is called
when the user presses the <em>Tab</em> key. The expansion is
active when calling line-reading functions, such as
<a href="#get_line/1">get_line/1</a>.</p> <p>The function is called with the current line, up to
the cursor, as a reversed string. It is to return a
three-tuple: <strong>{yes|no, string(), [string(), ...]}</strong>. The
first element gives a beep if <strong>no</strong>, otherwise the
expansion is silent; the second is a string that will be
entered at the cursor position; the third is a list of
possible expansions. If this list is not empty,
it is printed and the current input line is written
once again.</p> <p>Trivial example (beep on anything except empty line, which
is expanded to <strong>"quit"</strong>):</p> <pre><code class="">
fun("") -&gt; {yes, "quit", []};
   (_) -&gt; {no, "", ["quit"]} end</code></pre> <p>This option is only supported by the standard shell
(<strong>group.erl</strong>).</p> </dd><dt><strong>{encoding, latin1 | unicode}</strong></dt><dd> <p>Specifies how characters are input or output from or to the I/O
device, implying that, for example, a terminal is set to handle
Unicode input and output or a file is set to handle UTF-8 data
encoding.</p> <p>The option <em>does not</em> affect how data is returned from the
I/O functions or how it is sent in the I/O protocol, it only
affects how the I/O device is to handle Unicode characters to the
"physical" device.</p> <p>The standard shell is set for <strong>unicode</strong> or <strong>latin1</strong>
encoding when
the system is started. The encoding is set with the help of the
<strong>LANG</strong> or <strong>LC_CTYPE</strong> environment variables on Unix-like
system or by other means on other systems.
So, the user can input Unicode characters and the I/O device
is in <strong>{encoding, unicode}</strong> mode if the I/O device supports
it. The mode can be changed, if the assumption of the runtime
system is wrong, by setting this option.</p> <p>The I/O device used when Erlang is started with the "-oldshell"
or "-noshell" flags is by default set to <strong>latin1</strong> encoding,
meaning that any characters &gt; codepoint 255 are escaped
and that input is expected to be plain 8-bit ISO Latin-1.
If the encoding is changed to Unicode, input and output from
the standard file descriptors are in UTF-8 (regardless of
operating system).</p> <p>Files can also be set in <strong>{encoding, unicode}</strong>, meaning
that data is written and read as UTF-8. More encodings are
possible for files, see below.</p> <p><strong>{encoding, unicode | latin1}</strong> is supported by both the
standard shell (<strong>group.erl</strong> including <strong>werl</strong> on
Windows), the 'oldshell' (<strong>user.erl</strong>), and the file I/O
servers.</p> </dd><dt><strong>{encoding, utf8 | utf16 | utf32 | {utf16,big} | {utf16,little} | {utf32,big} | {utf32,little}}</strong></dt><dd> <p>For disk files, the encoding can be set to various UTF variants.
This has the effect that data is expected to be read as the
specified encoding from the file, and the data is written in the
specified encoding to the disk file.</p> <p><strong>{encoding, utf8}</strong> has the same effect as
<strong>{encoding, unicode}</strong> on files.</p> <p>The extended encodings are only supported on disk files
(opened by function
<a href="../kernel/file#open/2">kernel/file#open/2</a>).</p> </dd></dl><h3>write/1</h3><h3>write/2</h3><p>Write a term.</p><p>Writes term <strong><span class="anno">Term</span></strong> to the standard output
(<strong><span class="anno">IoDevice</span></strong>).</p><h3>Standard Input/Output</h3><p>All Erlang processes have a default standard I/O device. This
device is used when no <strong>IoDevice</strong> argument is specified in
the function calls in this module. However, it is sometimes desirable to
use an explicit <strong>IoDevice</strong> argument that refers to the
default I/O device. This is the case with functions that can
access either a file or the default I/O device. The atom
<strong>standard_io</strong> has this special meaning. The following example
illustrates this:</p><pre>
27&gt; <span class="input">io:read('enter&gt;').</span>
enter&gt;<span class="input">foo.</span>
{ok,foo}
28&gt; <span class="input">io:read(standard_io, 'enter&gt;').</span>
enter&gt;<span class="input">bar.</span>
{ok,bar}</pre><p>There is always a process registered under the name of
<strong>user</strong>. This can be used for sending output to the user.</p><h3>Standard Error</h3><p>In certain situations, especially when the standard output is
redirected, access to an I/O server specific for error messages can be
convenient. The I/O device <strong>standard_error</strong> can be used to direct
output to whatever the current operating system considers a suitable
I/O device for error output. Example on a Unix-like operating system:</p><pre>
$ <span class="input">erl -noshell -noinput -eval 'io:format(standard_error,"Error: ~s~n",["error 11"]),'\</span>
<span class="input">'init:stop().' &gt; /dev/null</span>
Error: error 11</pre><h3>Error Information</h3><p>The <strong>ErrorInfo</strong> mentioned in this module is the standard
<strong>ErrorInfo</strong> structure that is returned from all I/O modules.
It has the following format:</p><pre><code class="">
{ErrorLocation, Module, ErrorDescriptor}</code></pre><p>A string that describes the error is obtained with the following
call:</p><pre><code class="">
Module:format_error(ErrorDescriptor)</code></pre><h2>io_lib</h2><p>I/O library functions.</p><p>This module contains functions for converting to and from
strings (lists of characters). They are used for implementing the
functions in the <a href="io">io</a> module.
There is no guarantee that the
character lists returned from some of the functions are flat,
they can be deep lists. Function
<a href="./lists#flatten/1">lists#flatten/1</a>
can be used for flattening deep lists.</p><h2>Data Types</h2><span class="name">chars</span><span class="name">continuation</span><p>A continuation as returned by
<a href="#fread/3">fread/3</a>.</p><span class="name">chars_limit</span><span class="name">depth</span><span class="name">fread_error</span><span class="name">fread_item</span><span class="name">latin1_string</span><span class="name">format_spec</span><p>Where:</p><ul><li><p><strong>control_char</strong> is the type of control
sequence: <strong>$P</strong>, <strong>$w</strong>, and so on.</p> </li><li><p><strong>args</strong> is a list of the arguments used by the
control sequence, or an empty list if the control sequence
does not take any arguments.</p> </li><li><p><strong>width</strong> is the field width.</p> </li><li><p><strong>adjust</strong> is the adjustment.</p> </li><li><p><strong>precision</strong> is the precision of the printed
argument.</p> </li><li><p><strong>pad_char</strong> is the padding character.</p> </li><li><p><strong>encoding</strong> is set to <strong>true</strong> if translation
modifier <strong>t</strong> is present.</p> </li><li><p><strong>strings</strong> is set to <strong>false</strong> if modifier
<strong>l</strong> is present.</p> </li></ul><h2>Functions</h2><h3>build_text/1</h3><p>Build the output text for a preparsed format list.</p><p>For details, see
<a href="#scan_format/2">scan_format/2</a>.</p><h3>char_list/1</h3><p>Test for a list of characters.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a flat list of
characters in the Unicode range, otherwise <strong>false</strong>.</p><h3>deep_char_list/1</h3><p>Test for a deep list of characters.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a, possibly deep,
list of characters in the Unicode range, otherwise <strong>false</strong>.</p><h3>deep_latin1_char_list/1</h3><p>Test for a deep list of characters.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a, possibly deep,
list of characters in the ISO Latin-1 range, otherwise
<strong>false</strong>.</p><h3>format/2</h3><h3>fwrite/2</h3><p>Write formatted output.</p><p>Returns a character list that represents <strong><span class="anno">Data</span></strong>
formatted in accordance with <strong><span class="anno">Format</span></strong>.
For a detailed description of the available formatting options, see
<a href="./io#fwrite/1">io#fwrite/1</a>.
If the format string or argument list contains an error, a fault is
generated.</p><p>If and only if the Unicode translation modifier is used in the
format string (that is, <strong>~ts</strong> or <strong>~tc</strong>), the resulting list
can contain characters beyond the ISO Latin-1 character range
(that is, numbers &gt; 255). If so, the
result is still an ordinary Erlang <strong>string()</strong>, and can well be
used in any context where Unicode data is allowed.</p><h3>format/3</h3><h3>fwrite/3</h3><p>Write formatted output.</p><p>Returns a character list that represents <strong><span class="anno">Data</span></strong>
formatted in accordance with <strong><span class="anno">Format</span></strong> in
the same way as
<a href="#fwrite/2">fwrite/2</a> and
<a href="#format/2">format/2</a>,
but takes an extra argument, a list of options.</p><p>Valid option:</p><dl><dt><strong>{chars_limit, <span class="anno">CharsLimit</span>}</strong></dt><dd> <p>A soft limit on the number of characters returned.
When the number of characters is reached, remaining
structures are replaced by "<strong>...</strong>".
<strong><span class="anno">CharsLimit</span></strong> defaults to -1, which
means no limit on the number of characters returned.</p> </dd></dl><h3>fread/2</h3><p>Read formatted input.</p><p>Tries to read <strong><span class="anno">String</span></strong> in accordance with the
control sequences in <strong><span class="anno">Format</span></strong>.
For a detailed description of the available formatting options, see
<a href="./io#fread/3">io#fread/3</a>. It is
assumed that <strong><span class="anno">String</span></strong> contains whole lines.</p><p>The function returns:</p><dl><dt><strong>{ok, <span class="anno">InputList</span>, <span class="anno">LeftOverChars</span>}</strong></dt><dd> <p>The string was read. <strong><span class="anno">InputList</span></strong> is the list
of successfully matched and read items, and
<strong><span class="anno">LeftOverChars</span></strong> are the input characters not
used.</p> </dd><dt><strong>{more, <span class="anno">RestFormat</span>, <span class="anno">Nchars</span>, <span class="anno">InputStack</span>}</strong></dt><dd> <p>The string was read, but more input is needed to complete the
original format string. <strong><span class="anno">RestFormat</span></strong> is the
remaining format string, <strong><span class="anno">Nchars</span></strong> is the number
of characters scanned, and <strong><span class="anno">InputStack</span></strong> is the
reversed list of inputs matched up to that point.</p> </dd><dt><strong>{error, <span class="anno">What</span>}</strong></dt><dd> <p>The read operation failed and parameter <strong><span class="anno">What</span></strong>
gives a hint about the error.</p> </dd></dl><p><em>Example:</em></p><pre>
3&gt; <span class="input">io_lib:fread("~f~f~f", "15.6 17.3e-6 24.5").</span>
{ok,[15.6,1.73e-5,24.5],[]}</pre><h3>fread/3</h3><p>Re-entrant formatted reader</p><p>This is the re-entrant formatted reader. The continuation of
the first call to the functions must be <strong>[]</strong>. For a complete
description of how the re-entrant input scheme works, see
Armstrong, Virding, Williams: 'Concurrent Programming in
Erlang', Chapter 13.</p><p>The function returns:</p><dl><dt><strong>{done, <span class="anno">Result</span>, <span class="anno">LeftOverChars</span>}</strong></dt><dd> <p>The input is complete. The result is one of the following:</p> <dl><dt><strong>{ok, <span class="anno">InputList</span>}</strong></dt><dd> <p>The string was read. <strong><span class="anno">InputList</span></strong> is the
list of successfully matched and read items, and
<strong><span class="anno">LeftOverChars</span></strong> are the remaining
characters.</p> </dd><dt><strong>eof</strong></dt><dd> <p>End of file was encountered.
<strong><span class="anno">LeftOverChars</span></strong> are the input characters not
used.</p> </dd><dt><strong>{error, <span class="anno">What</span>}</strong></dt><dd> <p>An error occurred and parameter <strong><span class="anno">What</span></strong>
gives a hint about the error.</p> </dd></dl> </dd><dt><strong>{more, <span class="anno">Continuation</span>}</strong></dt><dd> <p>More data is required to build a term.
<strong><span class="anno">Continuation</span></strong> must be passed to <strong>fread/3</strong>
when more data becomes available.</p> </dd></dl><h3>indentation/2</h3><p>Indentation after printing string.</p><p>Returns the indentation if <strong><span class="anno">String</span></strong> has been
printed, starting at <strong><span class="anno">StartIndent</span></strong>.</p><h3>latin1_char_list/1</h3><p>Test for a list of ISO Latin-1 characters.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a flat list of
characters in the ISO Latin-1 range, otherwise <strong>false</strong>.</p><h3>nl/0</h3><p>Write a newline.</p><p>Returns a character list that represents a new line character.</p><h3>print/1</h3><h3>print/4</h3><p>Pretty print a term.</p><p>Returns a list of characters that represents
<strong><span class="anno">Term</span></strong>, but breaks representations longer
than one line into many lines and indents each line sensibly.
Also tries to detect and output lists of printable characters
as strings.</p><ul><li><strong><span class="anno">Column</span></strong> is the starting column; defaults to 1.</li><li><strong><span class="anno">LineLength</span></strong> is the maximum line length; defaults to 80.</li><li><strong><span class="anno">Depth</span></strong> is the maximum print depth; defaults to -1, which means no limitation.</li></ul><h3>printable_latin1_list/1</h3><p>Test for a list of printable ISO Latin-1 characters.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a flat list of
printable ISO Latin-1 characters, otherwise <strong>false</strong>.</p><h3>printable_list/1</h3><p>Test for a list of printable characters.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a flat list of
printable characters, otherwise <strong>false</strong>.</p><p>What is a printable character in this case is determined by
startup flag <strong>+pc</strong> to the Erlang VM; see
<a href="./io#printable_range/0">io#printable_range/0</a> and 
<a href="./erl">erts/erl</a>.</p><h3>printable_unicode_list/1</h3><p>Test for a list of printable Unicode characters.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a flat list of
printable Unicode characters, otherwise <strong>false</strong>.</p><h3>scan_format/2</h3><p>Parse all control sequences in the format string.</p><p>Returns a list corresponding to the specified format string,
where control sequences have been replaced with
corresponding tuples. This list can be passed to:</p><ul><li> <p><a href="#build_text/1">build_text/1</a>
to have the same effect as <strong>format(Format, Args)</strong></p> </li><li> <p><a href="#unscan_format/1">unscan_format/1</a> to get the corresponding pair
of <strong>Format</strong> and <strong>Args</strong> (with every <strong>*</strong> and
corresponding argument expanded to numeric values)</p> </li></ul><p>A typical use of this function is to replace unbounded-size
control sequences like <strong>~w</strong> and <strong>~p</strong> with the
depth-limited variants <strong>~W</strong> and <strong>~P</strong> before
formatting to text in, for example, a logger.</p><h3>unscan_format/1</h3><p>Revert a preparsed format list to a plain character list and a list of arguments.</p><p>For details, see
<a href="#scan_format/2">scan_format/2</a>.</p><h3>write/1</h3><h3>write/2</h3><h3>write/2</h3><p>Write a term.</p><p>Returns a character list that represents <strong><span class="anno">Term</span></strong>.
Option <strong><span class="anno">Depth</span></strong> controls the depth of the
structures written. When the specified depth is reached,
everything below this level is replaced by "<strong>...</strong>".
<strong><span class="anno">Depth</span></strong> defaults to -1, which means
no limitation. Option <strong><span class="anno">CharsLimit</span></strong> puts a
soft limit on the number of characters returned. When the
number of characters is reached, remaining structures are
replaced by "<strong>...</strong>". <strong><span class="anno">CharsLimit</span></strong>
defaults to -1, which means no limit on the number of
characters returned.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">lists:flatten(io_lib:write({1,[2],[3],[4,5],6,7,8,9})).</span>
"{1,[2],[3],[4,5],6,7,8,9}"
2&gt; <span class="input">lists:flatten(io_lib:write({1,[2],[3],[4,5],6,7,8,9}, 5)).</span>
"{1,[2],[3],[...],...}"
3&gt; <span class="input">lists:flatten(io_lib:write({[1,2,3],[4,5],6,7,8,9}, [{chars_limit,20}])).</span>
"{[1,2|...],[4|...],...}"</pre><h3>write_atom/1</h3><p>Write an atom.</p><p>Returns the list of characters needed to print atom
<strong><span class="anno">Atom</span></strong>.</p><h3>write_atom_as_latin1/1</h3><p>Write an atom.</p><p>Returns the list of characters needed to print atom
<strong><span class="anno">Atom</span></strong>. Non-Latin-1 characters
are escaped.</p><h3>write_char/1</h3><p>Write a character.</p><p>Returns the list of characters needed to print a character
constant in the Unicode character set.</p><h3>write_char_as_latin1/1</h3><p>Write a character.</p><p>Returns the list of characters needed to print a character
constant in the Unicode character set. Non-Latin-1 characters
are escaped.</p><h3>write_latin1_char/1</h3><p>Write an ISO Latin-1 character.</p><p>Returns the list of characters needed to print a character
constant in the ISO Latin-1 character set.</p><h3>write_latin1_string/1</h3><p>Write an ISO Latin-1 string.</p><p>Returns the list of characters needed to print
<strong><span class="anno">Latin1String</span></strong> as a string.</p><h3>write_string/1</h3><p>Write a string.</p><p>Returns the list of characters needed to print
<strong><span class="anno">String</span></strong> as a string.</p><h3>write_string_as_latin1/1</h3><p>Write a string.</p><p>Returns the list of characters needed to print
<strong><span class="anno">String</span></strong> as a string. Non-Latin-1
characters are escaped.</p><h2>lists</h2><p>List processing functions.</p><p>This module contains functions for list processing.Unless otherwise stated, all functions assume that position
numbering starts at 1. That is, the first element of a list is at
position 1.Two terms <strong>T1</strong> and <strong>T2</strong> compare equal if
<strong>T1==T2</strong> evaluates to <strong>true</strong>. They match
if <strong>T1=:=T2</strong> evaluates to <strong>true</strong>.Whenever an <a name="ordering_function"></a><em>ordering function</em>
<strong>F</strong> is expected as argument, it is assumed that the
following properties hold of <strong>F</strong> for all x, y, and z:<ul><li><p>If x <strong>F</strong> y and y <strong>F</strong> x, then x = y (<strong>F</strong>
is antisymmetric).</p> </li><li><p>If x <strong>F</strong> y and y <strong>F</strong> z, then x <strong>F</strong> z
(<strong>F</strong> is transitive).</p> </li><li><p>x <strong>F</strong> y or y <strong>F</strong> x (<strong>F</strong> is total).</p> </li></ul>An example of a typical ordering function is less than or equal
to: <strong>=&lt;/2</strong>.</p><h2>Functions</h2><h3>all/2</h3><p>Return <strong>true</strong> if all elements in a list satisfy <strong>Pred</strong>.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Pred</span>(<span class="anno">Elem</span>)</strong>
returns <strong>true</strong> for all elements <strong><span class="anno">Elem</span></strong> in
<strong><span class="anno">List</span></strong>, otherwise <strong>false</strong>.</p><h3>any/2</h3><p>Return <strong>true</strong> if any of the elements in a list satisfies <strong>Pred</strong>.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Pred</span>(<span class="anno">Elem</span>)</strong>
returns <strong>true</strong> for at least one element <strong><span class="anno">Elem</span></strong>
in <strong><span class="anno">List</span></strong>.</p><h3>append/1</h3><p>Append a list of lists.</p><p>Returns a list in which all the sublists of
<strong><span class="anno">ListOfLists</span></strong> have been appended.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:append([[1, 2, 3], [a, b], [4, 5, 6]]).</span>
[1,2,3,a,b,4,5,6]</pre><h3>append/2</h3><p>Append two lists.</p><p>Returns a new list <strong><span class="anno">List3</span></strong>, which is made from
the elements of <strong><span class="anno">List1</span></strong> followed by the elements of
<strong><span class="anno">List2</span></strong>.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:append("abc", "def").</span>
"abcdef"</pre><p><strong>lists:append(A, B)</strong> is equivalent to <strong>A ++ B</strong>.</p><h3>concat/1</h3><p>Concatenate a list of atoms.</p><p>Concatenates the text representation of the elements of
<strong><span class="anno">Things</span></strong>. The elements of <strong><span class="anno">Things</span></strong>
can be atoms, integers, floats, or strings.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:concat([doc, '/', file, '.', 3]).</span>
"doc/file.3"</pre><h3>delete/2</h3><p>Delete an element from a list.</p><p>Returns a copy of <strong><span class="anno">List1</span></strong> where the first element
matching <strong><span class="anno">Elem</span></strong> is deleted, if there is such an
element.</p><h3>droplast/1</h3><p>Drop the last element of a list.</p><p>Drops the last element of a <strong><span class="anno">List</span></strong>. The list is to
be non-empty, otherwise the function crashes with a
<strong>function_clause</strong>.</p><h3>dropwhile/2</h3><p>Drop elements from a list while a predicate is <strong>true</strong>. </p><p>Drops elements <strong><span class="anno">Elem</span></strong> from
<strong><span class="anno">List1</span></strong> while
<strong><span class="anno">Pred</span>(<span class="anno">Elem</span>)</strong> returns <strong>true</strong> and
returns the remaining list.</p><h3>duplicate/2</h3><p>Make <strong>N</strong> copies of element.</p><p>Returns a list containing <strong><span class="anno">N</span></strong> copies of term
<strong><span class="anno">Elem</span></strong>.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:duplicate(5, xx).</span>
[xx,xx,xx,xx,xx]</pre><h3>filter/2</h3><p>Select elements that satisfy a predicate.</p><p><strong><span class="anno">List2</span></strong> is a list of all elements
<strong><span class="anno">Elem</span></strong> in <strong><span class="anno">List1</span></strong> for which
<strong><span class="anno">Pred</span>(<span class="anno">Elem</span>)</strong> returns <strong>true</strong>.</p><h3>filtermap/2</h3><p>Filter and map elements that satisfy a function.</p><p>Calls <strong><span class="anno">Fun</span>(<span class="anno">Elem</span>)</strong> on successive
elements <strong>Elem</strong> of <strong><span class="anno">List1</span></strong>.
<strong><span class="anno">Fun</span>/1</strong> must return either a Boolean or a tuple
<strong>{true, <span class="anno">Value</span>}</strong>. The function returns the list of
elements for which <strong><span class="anno">Fun</span></strong> returns a new value, where
a value of <strong>true</strong> is synonymous with
<strong>{true, <span class="anno">Elem</span>}</strong>.</p><p>That is, <strong>filtermap</strong> behaves as if it had been defined as
follows:</p><pre><code class="">
filtermap(Fun, List1) -&gt;
    lists:foldr(fun(Elem, Acc) -&gt;
                       case Fun(Elem) of
                           false -&gt; Acc;
                           true -&gt; [Elem|Acc];
                           {true,Value} -&gt; [Value|Acc]
                       end
                end, [], List1).</code></pre><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:filtermap(fun(X) -&gt; case X rem 2 of 0 -&gt; {true, X div 2}; _ -&gt; false end end, [1,2,3,4,5]).</span>
[1,2]</pre><h3>flatlength/1</h3><p>Length of flattened deep list.</p><p>Equivalent to <strong>length(flatten(<span class="anno">DeepList</span>))</strong>, but
more efficient.</p><h3>flatmap/2</h3><p>Map and flatten in one pass.</p><p>Takes a function from <strong><span class="anno">A</span></strong>s to lists of
<strong><span class="anno">B</span></strong>s, and a list of <strong><span class="anno">A</span></strong>s
(<strong><span class="anno">List1</span></strong>) and produces a list of
<strong><span class="anno">B</span></strong>s by applying the function to every element in
<strong><span class="anno">List1</span></strong> and appending the resulting lists.</p><p>That is, <strong>flatmap</strong> behaves as if it had been defined as
follows:</p><pre><code class="">
flatmap(Fun, List1) -&gt;
    append(map(Fun, List1)).</code></pre><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:flatmap(fun(X)-&gt;[X,X] end, [a,b,c]).</span>
[a,a,b,b,c,c]</pre><h3>flatten/1</h3><p>Flatten a deep list.</p><p>Returns a flattened version of <strong><span class="anno">DeepList</span></strong>.</p><h3>flatten/2</h3><p>Flatten a deep list.</p><p>Returns a flattened version of <strong><span class="anno">DeepList</span></strong> with tail
<strong><span class="anno">Tail</span></strong> appended.</p><h3>foldl/3</h3><p>Fold a function over a list.</p><p>Calls <strong><span class="anno">Fun</span>(<span class="anno">Elem</span>, <span class="anno">AccIn</span>)</strong>
on successive elements <strong>A</strong> of <strong><span class="anno">List</span></strong>, starting
with <strong><span class="anno">AccIn</span> == <span class="anno">Acc0</span></strong>.
<strong><span class="anno">Fun</span>/2</strong> must return a new accumulator, which is
passed to the next call. The function returns the final value of
the accumulator. <strong><span class="anno">Acc0</span></strong> is returned if the list is
empty.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:foldl(fun(X, Sum) -&gt; X + Sum end, 0, [1,2,3,4,5]).</span>
15
&gt; <span class="input">lists:foldl(fun(X, Prod) -&gt; X * Prod end, 1, [1,2,3,4,5]).</span>
120</pre><h3>foldr/3</h3><p>Fold a function over a list.</p><p>Like <a href="#foldl/3">foldl/3</a>, but the
list is traversed from right to left.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">P = fun(A, AccIn) -&gt; io:format("~p ", [A]), AccIn end.</span>
#Fun&lt;erl_eval.12.2225172&gt;
&gt; <span class="input">lists:foldl(P, void, [1,2,3]).</span>
1 2 3 void
&gt; <span class="input">lists:foldr(P, void, [1,2,3]).</span>
3 2 1 void</pre><p><strong>foldl/3</strong> is tail recursive and is usually preferred to
<strong>foldr/3</strong>.</p><h3>join/2</h3><p>Insert an element between elements in a list</p><p>Inserts <strong><span class="anno">Sep</span></strong> between each element in <strong><span class="anno">List1</span></strong>. Has no
effect on the empty list and on a singleton list. For example:</p><pre>
&gt; <span class="input">lists:join(x, [a,b,c]).</span>
[a,x,b,x,c]
&gt; <span class="input">lists:join(x, [a]).</span>
[a]
&gt; <span class="input">lists:join(x, []).</span>
[]</pre><h3>foreach/2</h3><p>Apply a function to each element of a list.</p><p>Calls <strong><span class="anno">Fun</span>(<span class="anno">Elem</span>)</strong> for each element
<strong><span class="anno">Elem</span></strong> in <strong><span class="anno">List</span></strong>. This function
is used for its side effects and
the evaluation order is defined to be the same as the order
of the elements in the list.</p><h3>keydelete/3</h3><p>Delete an element from a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns a copy of <strong><span class="anno">TupleList1</span></strong> where the first
occurrence of a tuple whose <strong><span class="anno">N</span></strong>th element compares
equal to
<strong><span class="anno">Key</span></strong> is deleted, if there is such a tuple.</p><h3>keyfind/3</h3><p>Search for an element in a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Searches the list of tuples <strong><span class="anno">TupleList</span></strong> for a
tuple whose <strong><span class="anno">N</span></strong>th element compares equal to
<strong><span class="anno">Key</span></strong>.
Returns <strong><span class="anno">Tuple</span></strong> if such a tuple is found,
otherwise <strong>false</strong>.</p><h3>keymap/3</h3><p>Map a function over a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns a list of tuples where, for each tuple in
<strong><span class="anno">TupleList1</span></strong>, the <strong><span class="anno">N</span></strong>th element
<strong><span class="anno">Term1</span></strong> of the tuple
has been replaced with the result of calling
<strong><span class="anno">Fun</span>(<span class="anno">Term1</span>)</strong>.</p><p><em>Examples:</em></p><pre>
&gt; <span class="input">Fun = fun(Atom) -&gt; atom_to_list(Atom) end.</span>
#Fun&lt;erl_eval.6.10732646&gt;
2&gt; <span class="input">lists:keymap(Fun, 2, [{name,jane,22},{name,lizzie,20},{name,lydia,15}]).</span>
[{name,"jane",22},{name,"lizzie",20},{name,"lydia",15}]</pre><h3>keymember/3</h3><p>Test for membership of a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns <strong>true</strong> if there is a tuple in
<strong><span class="anno">TupleList</span></strong> whose <strong><span class="anno">N</span></strong>th element
compares equal to <strong><span class="anno">Key</span></strong>, otherwise <strong>false</strong>.</p><h3>keymerge/3</h3><p>Merge two key-sorted lists of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns the sorted list formed by merging
<strong><span class="anno">TupleList1</span></strong> and <strong><span class="anno">TupleList2</span></strong>.
The merge is performed on the <strong><span class="anno">N</span></strong>th element of each
tuple. Both <strong><span class="anno">TupleList1</span></strong> and
<strong><span class="anno">TupleList2</span></strong> must be key-sorted before evaluating
this function. When two tuples compare equal, the tuple from
<strong><span class="anno">TupleList1</span></strong> is picked before the tuple from
<strong><span class="anno">TupleList2</span></strong>.</p><h3>keyreplace/4</h3><p>Replace an element in a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns a copy of <strong><span class="anno">TupleList1</span></strong> where the first
occurrence of a <strong>T</strong> tuple whose <strong><span class="anno">N</span></strong>th element
compares equal to <strong><span class="anno">Key</span></strong> is replaced with
<strong><span class="anno">NewTuple</span></strong>, if there is such a tuple <strong>T</strong>.</p><h3>keysearch/3</h3><p>Search for an element in a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Searches the list of tuples <strong><span class="anno">TupleList</span></strong> for a
tuple whose <strong><span class="anno">N</span></strong>th element compares equal to
<strong><span class="anno">Key</span></strong>.
Returns <strong>{value, <span class="anno">Tuple</span>}</strong> if such a tuple is found,
otherwise <strong>false</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is retained for backward compatibility. Function
<a href="#keyfind/3">keyfind/3</a>
is usually more convenient.</p></div><h3>keysort/2</h3><p>Sort a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns a list containing the sorted elements of list
<strong><span class="anno">TupleList1</span></strong>. Sorting is performed on the
<strong><span class="anno">N</span></strong>th element of the tuples. The sort is stable.</p><h3>keystore/4</h3><p>Store an element in a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns a copy of <strong><span class="anno">TupleList1</span></strong> where the first
occurrence of a tuple <strong>T</strong> whose <strong><span class="anno">N</span></strong>th element
compares equal to <strong><span class="anno">Key</span></strong> is replaced with
<strong><span class="anno">NewTuple</span></strong>, if there is such a tuple <strong>T</strong>.
If there is no such tuple <strong>T</strong>, a copy of
<strong><span class="anno">TupleList1</span></strong> where
[<strong><span class="anno">NewTuple</span></strong>] has been appended to the end is
returned.</p><h3>keytake/3</h3><p>Extract an element from a list of tuples.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Searches the list of tuples <strong><span class="anno">TupleList1</span></strong> for a
tuple whose <strong><span class="anno">N</span></strong>th element compares equal to
<strong><span class="anno">Key</span></strong>. Returns <strong>{value, <span class="anno">Tuple</span>, <span class="anno">TupleList2</span>}</strong> if such a tuple is found, otherwise
<strong>false</strong>. <strong><span class="anno">TupleList2</span></strong> is a copy
of <strong><span class="anno">TupleList1</span></strong> where the first occurrence of
<strong><span class="anno">Tuple</span></strong> has been removed.</p><h3>last/1</h3><p>Return last element in a list.</p><p>Returns the last element in <strong><span class="anno">List</span></strong>.</p><h3>map/2</h3><p>Map a function over a list.</p><p>Takes a function from <strong><span class="anno">A</span></strong>s to
<strong><span class="anno">B</span></strong>s, and a list of <strong><span class="anno">A</span></strong>s and
produces a list of <strong><span class="anno">B</span></strong>s by applying
the function to every element in the list. This function is
used to obtain the return values. The evaluation order depends on
the implementation.</p><h3>mapfoldl/3</h3><p>Map and fold in one pass.</p><p>Combines the operations of
<a href="#map/2">map/2</a> and 
<a href="#foldl/3">foldl/3</a> into one pass.</p><p><em>Example:</em></p><p>Summing the elements in a list and double them at the same time:</p><pre>
&gt; <span class="input">lists:mapfoldl(fun(X, Sum) -&gt; {2*X, X+Sum} end,</span>
<span class="input">0, [1,2,3,4,5]).</span>
{[2,4,6,8,10],15}</pre><h3>mapfoldr/3</h3><p>Map and fold in one pass.</p><p>Combines the operations of
<a href="#map/2">map/2</a> and 
<a href="#foldr/3">foldr/3</a> into one pass.</p><h3>max/1</h3><p>Return maximum element of a list.</p><p>Returns the first element of <strong><span class="anno">List</span></strong> that compares
greater than or equal to all other elements of
<strong><span class="anno">List</span></strong>.</p><h3>member/2</h3><p>Test for membership of a list.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Elem</span></strong> matches some element
of <strong><span class="anno">List</span></strong>, otherwise <strong>false</strong>.</p><h3>merge/1</h3><p>Merge a list of sorted lists.</p><p>Returns the sorted list formed by merging all the sublists of
<strong><span class="anno">ListOfLists</span></strong>. All sublists must be sorted before
evaluating this function. When two elements compare equal,
the element from the sublist with the lowest position in
<strong><span class="anno">ListOfLists</span></strong> is picked before the other
element.</p><h3>merge/2</h3><p>Merge two sorted lists.</p><p>Returns the sorted list formed by merging <strong><span class="anno">List1</span></strong>
and <strong><span class="anno">List2</span></strong>. Both <strong><span class="anno">List1</span></strong> and
<strong><span class="anno">List2</span></strong> must be
sorted before evaluating this function. When two elements
compare equal, the element from <strong><span class="anno">List1</span></strong> is picked
before the element from <strong><span class="anno">List2</span></strong>.</p><h3>merge/3</h3><p>Merge two sorted list.</p><p>Returns the sorted list formed by merging <strong><span class="anno">List1</span></strong>
and <strong><span class="anno">List2</span></strong>. Both <strong><span class="anno">List1</span></strong> and
<strong><span class="anno">List2</span></strong> must be sorted according to the <a href="#ordering_function">ordering function</a>
<strong><span class="anno">Fun</span></strong> before evaluating this function.
<strong><span class="anno">Fun</span>(<span class="anno">A</span>, <span class="anno">B</span>)</strong> is to return
<strong>true</strong> if <strong><span class="anno">A</span></strong> compares less
than or equal to <strong><span class="anno">B</span></strong> in the ordering, otherwise
<strong>false</strong>. When two elements compare equal, the element from
<strong><span class="anno">List1</span></strong> is picked before the element from
<strong><span class="anno">List2</span></strong>.</p><h3>merge3/3</h3><p>Merge three sorted lists.</p><p>Returns the sorted list formed by merging <strong><span class="anno">List1</span></strong>,
<strong><span class="anno">List2</span></strong>, and <strong><span class="anno">List3</span></strong>. All of
<strong><span class="anno">List1</span></strong>, <strong><span class="anno">List2</span></strong>, and
<strong><span class="anno">List3</span></strong> must be sorted before evaluating this
function. When two elements compare equal, the element from
<strong><span class="anno">List1</span></strong>, if there is such an element,
is picked before the other element, otherwise the element
from <strong><span class="anno">List2</span></strong> is picked before the element from
<strong><span class="anno">List3</span></strong>.</p><h3>min/1</h3><p>Return minimum element of a list.</p><p>Returns the first element of <strong><span class="anno">List</span></strong> that compares
less than or equal to all other elements of
<strong><span class="anno">List</span></strong>.</p><h3>nth/2</h3><p>Return the <strong>N</strong>th element of a list.</p><dl><dt>N</dt><dd>1..length(<span class="anno">List</span>)</dd></dl><p>Returns the <strong><span class="anno">N</span></strong>th element of
<strong><span class="anno">List</span></strong>.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:nth(3, [a, b, c, d, e]).</span>
c</pre><h3>nthtail/2</h3><p>Return the <strong>N</strong>th tail of a list.</p><dl><dt>N</dt><dd>0..length(<span class="anno">List</span>)</dd></dl><p>Returns the <strong><span class="anno">N</span></strong>th tail of <strong><span class="anno">List</span></strong>,
that is, the sublist of <strong><span class="anno">List</span></strong> starting at
<strong><span class="anno">N</span>+1</strong> and continuing up to the end of the list.</p><p><em>Example</em></p><pre>
&gt; <span class="input">lists:nthtail(3, [a, b, c, d, e]).</span>
[d,e]
&gt; <span class="input">tl(tl(tl([a, b, c, d, e]))).</span>
[d,e]
&gt; <span class="input">lists:nthtail(0, [a, b, c, d, e]).</span>
[a,b,c,d,e]
&gt; <span class="input">lists:nthtail(5, [a, b, c, d, e]).</span>
[]</pre><h3>partition/2</h3><p>Partition a list into two lists based on a predicate.</p><p>Partitions <strong><span class="anno">List</span></strong> into two lists, where the first
list contains all elements for which
<strong><span class="anno">Pred</span>(<span class="anno">Elem</span>)</strong> returns <strong>true</strong>,
and the second list contains all elements for which
<strong><span class="anno">Pred</span>(<span class="anno">Elem</span>)</strong> returns <strong>false</strong>.</p><p><em>Examples:</em></p><pre>
&gt; <span class="input">lists:partition(fun(A) -&gt; A rem 2 == 1 end, [1,2,3,4,5,6,7]).</span>
{[1,3,5,7],[2,4,6]}
&gt; <span class="input">lists:partition(fun(A) -&gt; is_atom(A) end, [a,b,1,c,d,2,3,4,e]).</span>
{[a,b,c,d,e],[1,2,3,4]}</pre><p>For a different way to partition a list, see
<a href="#splitwith/2">splitwith/2</a>.</p><h3>prefix/2</h3><p>Test for list prefix.</p><p>Returns <strong>true</strong> if <strong><span class="anno">List1</span></strong> is a prefix of
<strong><span class="anno">List2</span></strong>, otherwise <strong>false</strong>.</p><h3>reverse/1</h3><p>Reverse a list.</p><p>Returns a list with the elements in <strong><span class="anno">List1</span></strong>
in reverse order.</p><h3>reverse/2</h3><p>Reverse a list appending a tail.</p><p>Returns a list with the elements in <strong><span class="anno">List1</span></strong>
in reverse order, with tail <strong><span class="anno">Tail</span></strong> appended.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:reverse([1, 2, 3, 4], [a, b, c]).</span>
[4,3,2,1,a,b,c]</pre><h3>search/2</h3><p>Find the first element that satisfies a predicate.</p><p>If there is a <strong><span class="anno">Value</span></strong> in <strong><span class="anno">List</span></strong>
such that <strong><span class="anno">Pred</span>(<span class="anno">Value</span>)</strong> returns
<strong>true</strong>, returns <strong>{value, <span class="anno">Value</span>}</strong>
for the first such <strong><span class="anno">Value</span></strong>,
otherwise returns <strong>false</strong>.</p><h3>seq/2</h3><h3>seq/3</h3><p>Generate a sequence of integers.</p><p>Returns a sequence of integers that starts with
<strong><span class="anno">From</span></strong> and contains the successive results of
adding <strong><span class="anno">Incr</span></strong> to the previous element, until
<strong><span class="anno">To</span></strong> is reached or passed (in the latter case,
<strong><span class="anno">To</span></strong> is not an element of
the sequence). <strong><span class="anno">Incr</span></strong> defaults to 1.</p><p>Failures:</p><ul><li> <p>If <strong><span class="anno">To</span> &lt; <span class="anno">From</span> - <span class="anno">Incr</span></strong>
and <strong><span class="anno">Incr</span> &gt; 0</strong>.</p> </li><li> <p>If <strong><span class="anno">To</span> &gt; <span class="anno">From</span> - <span class="anno">Incr</span></strong> and
<strong><span class="anno">Incr</span> &lt; 0</strong>.</p> </li><li> <p>If <strong><span class="anno">Incr</span> =:= 0</strong> and
<strong><span class="anno">From</span> =/= <span class="anno">To</span></strong>.</p> </li></ul><p>The following equalities hold for all sequences:</p><pre><code class="">
length(lists:seq(From, To)) =:= To - From + 1
length(lists:seq(From, To, Incr)) =:= (To - From + Incr) div Incr</code></pre><p><em>Examples:</em></p><pre>
&gt; <span class="input">lists:seq(1, 10).</span>
[1,2,3,4,5,6,7,8,9,10]
&gt; <span class="input">lists:seq(1, 20, 3).</span>
[1,4,7,10,13,16,19]
&gt; <span class="input">lists:seq(1, 0, 1).</span>
[]
&gt; <span class="input">lists:seq(10, 6, 4).</span>
[]
&gt; <span class="input">lists:seq(1, 1, 0).</span>
[1]</pre><h3>sort/1</h3><p>Sort a list.</p><p>Returns a list containing the sorted elements of
<strong><span class="anno">List1</span></strong>.</p><h3>sort/2</h3><p>Sort a list.</p><p>Returns a list containing the sorted elements of
<strong><span class="anno">List1</span></strong>, according to the <a href="#ordering_function">ordering function</a>
<strong><span class="anno">Fun</span></strong>. <strong><span class="anno">Fun</span>(<span class="anno">A</span>, <span class="anno">B</span>)</strong> is to return <strong>true</strong> if <strong><span class="anno">A</span></strong>
compares less than or equal to <strong><span class="anno">B</span></strong> in the
ordering, otherwise <strong>false</strong>.</p><h3>split/2</h3><p>Split a list into two lists.</p><dl><dt>N</dt><dd>0..length(<span class="anno">List1</span>)</dd></dl><p>Splits <strong><span class="anno">List1</span></strong> into <strong><span class="anno">List2</span></strong> and
<strong><span class="anno">List3</span></strong>. <strong><span class="anno">List2</span></strong> contains the
first <strong><span class="anno">N</span></strong> elements and <strong><span class="anno">List3</span></strong>
the remaining elements (the <strong><span class="anno">N</span></strong>th tail).</p><h3>splitwith/2</h3><p>Split a list into two lists based on a predicate.</p><p>Partitions <strong><span class="anno">List</span></strong> into two lists according to
<strong><span class="anno">Pred</span></strong>. <strong>splitwith/2</strong> behaves as if it is
defined as follows:</p><pre><code class="">
splitwith(Pred, List) -&gt;
    {takewhile(Pred, List), dropwhile(Pred, List)}.</code></pre><p><em>Examples:</em></p><pre>
&gt; <span class="input">lists:splitwith(fun(A) -&gt; A rem 2 == 1 end, [1,2,3,4,5,6,7]).</span>
{[1],[2,3,4,5,6,7]}
&gt; <span class="input">lists:splitwith(fun(A) -&gt; is_atom(A) end, [a,b,1,c,d,2,3,4,e]).</span>
{[a,b],[1,c,d,2,3,4,e]}</pre><p>For a different way to partition a list, see 
<a href="#partition/2">partition/2</a>.</p><h3>sublist/2</h3><p>Return a sublist of a certain length, starting at the first position.</p><p>Returns the sublist of <strong><span class="anno">List1</span></strong> starting at
position 1 and with (maximum) <strong><span class="anno">Len</span></strong> elements. It is
not an error for <strong><span class="anno">Len</span></strong> to exceed the length of the
list, in that case the whole list is returned.</p><h3>sublist/3</h3><p>Return a sublist starting at a specified position and with a specified number of elements.</p><dl><dt>Start</dt><dd>1..(length(<span class="anno">List1</span>)+1)</dd></dl><p>Returns the sublist of <strong><span class="anno">List1</span></strong> starting at
<strong><span class="anno">Start</span></strong> and with (maximum) <strong><span class="anno">Len</span></strong>
elements. It is not an error for
<strong><span class="anno">Start</span>+<span class="anno">Len</span></strong> to exceed the length of
the list.</p><p><em>Examples:</em></p><pre>
&gt; <span class="input">lists:sublist([1,2,3,4], 2, 2).</span>
[2,3]
&gt; <span class="input">lists:sublist([1,2,3,4], 2, 5).</span>
[2,3,4]
&gt; <span class="input">lists:sublist([1,2,3,4], 5, 2).</span>
[]</pre><h3>subtract/2</h3><p>Subtract the element in one list from another list.</p><p>Returns a new list <strong><span class="anno">List3</span></strong> that is a copy of
<strong><span class="anno">List1</span></strong>, subjected to the following procedure:
for each element in <strong><span class="anno">List2</span></strong>, its first occurrence
in <strong><span class="anno">List1</span></strong> is deleted.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:subtract("123212", "212").</span>
"312".</pre><p><strong>lists:subtract(A, B)</strong> is equivalent to <strong>A -- B</strong>.</p><h3>suffix/2</h3><p>Test for list suffix.</p><p>Returns <strong>true</strong> if <strong><span class="anno">List1</span></strong> is a suffix of
<strong><span class="anno">List2</span></strong>, otherwise <strong>false</strong>.</p><h3>sum/1</h3><p>Return the sum of elements in a list.</p><p>Returns the sum of the elements in <strong><span class="anno">List</span></strong>.</p><h3>takewhile/2</h3><p>Take elements from a list while a predicate is <strong>true</strong>. </p><p>Takes elements <strong><span class="anno">Elem</span></strong> from
<strong><span class="anno">List1</span></strong> while
<strong><span class="anno">Pred</span>(<span class="anno">Elem</span>)</strong> returns <strong>true</strong>, that
is, the function returns the longest prefix of the list for which
all elements satisfy the predicate.</p><h3>ukeymerge/3</h3><p>Merge two key-sorted lists of tuples, removing duplicates. </p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns the sorted list formed by merging
<strong><span class="anno">TupleList1</span></strong> and
<strong><span class="anno">TupleList2</span></strong>. The merge is performed on the
<strong><span class="anno">N</span></strong>th element of each tuple. Both
<strong><span class="anno">TupleList1</span></strong> and <strong><span class="anno">TupleList2</span></strong>
must be key-sorted without duplicates before evaluating this function.
When two tuples compare equal, the tuple from
<strong><span class="anno">TupleList1</span></strong> is picked and the
one from <strong><span class="anno">TupleList2</span></strong> is deleted.</p><h3>ukeysort/2</h3><p>Sort a list of tuples, removing duplicates.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns a list containing the sorted elements of list
<strong><span class="anno">TupleList1</span></strong> where all except the first tuple of
the tuples comparing equal have been deleted. Sorting is
performed on the <strong><span class="anno">N</span></strong>th element of the tuples.</p><h3>umerge/1</h3><p>Merge a list of sorted lists, removing duplicates.</p><p>Returns the sorted list formed by merging all the sublists
of <strong><span class="anno">ListOfLists</span></strong>. All sublists must be sorted and
contain no duplicates before evaluating this function.
When two elements compare equal, the element from the sublist
with the lowest position in <strong><span class="anno">ListOfLists</span></strong> is
picked and the other is deleted.</p><h3>umerge/2</h3><p>Merge two sorted lists, removing duplicates.</p><p>Returns the sorted list formed by merging <strong><span class="anno">List1</span></strong>
and <strong><span class="anno">List2</span></strong>. Both <strong><span class="anno">List1</span></strong> and
<strong><span class="anno">List2</span></strong> must be
sorted and contain no duplicates before evaluating this
function. When two elements compare equal, the element from
<strong><span class="anno">List1</span></strong> is picked and the one from
<strong><span class="anno">List2</span></strong> is deleted.</p><h3>umerge/3</h3><p>Merge two sorted lists, removing duplicates.</p><p>Returns the sorted list formed by merging <strong><span class="anno">List1</span></strong>
and <strong><span class="anno">List2</span></strong>. Both <strong><span class="anno">List1</span></strong> and
<strong><span class="anno">List2</span></strong> must be sorted according to the <a href="#ordering_function">ordering function</a>
<strong>Fun</strong> and contain no duplicates before evaluating this function.
<strong><span class="anno">Fun</span>(<span class="anno">A</span>, <span class="anno">B</span>)</strong> is to return
<strong>true</strong> if <strong><span class="anno">A</span></strong> compares less than or equal to
<strong><span class="anno">B</span></strong> in the ordering, otherwise <strong>false</strong>. When
two elements compare equal, the element from <strong><span class="anno">List1</span></strong>
is picked and the one from <strong><span class="anno">List2</span></strong> is deleted.</p><h3>umerge3/3</h3><p>Merge three sorted lists, removing duplicates.</p><p>Returns the sorted list formed by merging <strong><span class="anno">List1</span></strong>,
<strong><span class="anno">List2</span></strong>, and <strong><span class="anno">List3</span></strong>. All of
<strong><span class="anno">List1</span></strong>, <strong><span class="anno">List2</span></strong>, and
<strong><span class="anno">List3</span></strong> must be sorted and contain no
duplicates before evaluating this function. When two
elements compare equal, the element from <strong><span class="anno">List1</span></strong> is
picked if there is such an element, otherwise the element from
<strong><span class="anno">List2</span></strong> is picked, and the other is deleted.</p><h3>unzip/1</h3><p>Unzip a list of two-tuples into two lists.</p><p>"Unzips" a list of two-tuples into two lists, where the first
list contains the first element of each tuple, and the second
list contains the second element of each tuple.</p><h3>unzip3/1</h3><p>Unzip a list of three-tuples into three lists.</p><p>"Unzips" a list of three-tuples into three lists, where
the first list contains the first element of each tuple,
the second list contains the second element of each tuple, and
the third list contains the third element of each tuple.</p><h3>usort/1</h3><p>Sort a list, removing duplicates.</p><p>Returns a list containing the sorted elements of
<strong><span class="anno">List1</span></strong> where all except the first element of the
elements comparing equal have been deleted.</p><h3>usort/2</h3><p>Sort a list, removing duplicates.</p><p>Returns a list containing the sorted elements of
<strong><span class="anno">List1</span></strong> where all except the first element of the
elements comparing equal according to the <a href="#ordering_function">ordering function</a>
<strong><span class="anno">Fun</span></strong> have been deleted.
<strong><span class="anno">Fun</span>(A, B)</strong> is to return
<strong>true</strong> if <strong>A</strong> compares less than or equal to
<strong>B</strong> in the ordering, otherwise <strong>false</strong>.</p><h3>zip/2</h3><p>Zip two lists into a list of two-tuples.</p><p>"Zips" two lists of equal length into one list of two-tuples,
where the first element of each tuple is taken from the first
list and the second element is taken from the corresponding
element in the second list.</p><h3>zip3/3</h3><p>Zip three lists into a list of three-tuples.</p><p>"Zips" three lists of equal length into one list of
three-tuples, where the first element of each tuple is taken
from the first list, the second element is taken from
the corresponding element in the second list, and the third
element is taken from the corresponding element in the third list.</p><h3>zipwith/3</h3><p>Zip two lists into one list according to a fun.</p><p>Combines the elements of two lists of equal length into one list.
For each pair <strong><span class="anno">X</span>, <span class="anno">Y</span></strong> of list elements
from the two lists, the element in the result list is
<strong><span class="anno">Combine</span>(<span class="anno">X</span>, <span class="anno">Y</span>)</strong>.</p><p><strong>zipwith(fun(X, Y) -&gt; {X,Y} end, List1, List2)</strong> is
equivalent to <strong>zip(List1, List2)</strong>.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">lists:zipwith(fun(X, Y) -&gt; X+Y end, [1,2,3], [4,5,6]).</span>
[5,7,9]</pre><h3>zipwith3/4</h3><p>Zip three lists into one list according to a fun.</p><p>Combines the elements of three lists of equal length into one
list. For each triple <strong><span class="anno">X</span>, <span class="anno">Y</span>, <span class="anno">Z</span></strong> of list elements from the three lists, the element
in the result list is <strong><span class="anno">Combine</span>(<span class="anno">X</span>, <span class="anno">Y</span>, <span class="anno">Z</span>)</strong>.</p><p><strong>zipwith3(fun(X, Y, Z) -&gt; {X,Y,Z} end, List1, List2, List3)</strong> is
equivalent to <strong>zip3(List1, List2, List3)</strong>.</p><p><em>Examples:</em></p><pre>
&gt; <span class="input">lists:zipwith3(fun(X, Y, Z) -&gt; X+Y+Z end, [1,2,3], [4,5,6], [7,8,9]).</span>
[12,15,18]
&gt; <span class="input">lists:zipwith3(fun(X, Y, Z) -&gt; [X,Y,Z] end, [a,b,c], [x,y,z], [1,2,3]).</span>
[[a,x,1],[b,y,2],[c,z,3]]</pre><h2>log_mf_h</h2><p>An event handler that logs events to disk.</p><p>This module is a <strong>gen_event</strong> handler module that can be installed
in any <strong>gen_event</strong> process. It logs onto disk all events that are
sent to an event manager. Each event is written as a binary, which makes
the logging very fast. However, a tool such as the Report Browser
(<a href="./rb">sasl/rb</a>) must be used to read
the files. The events are written to multiple files. When all files have
been used, the first one is reused and overwritten. The directory
location, the number of files, and the size of each file are configurable.
The directory will include one file called <strong>index</strong>, and report files
<strong>1, 2, ...</strong>.</p><h2>Data Types</h2><span class="name">args</span><p>Term to be sent to <a href="./gen_event#add_handler/3">gen_event#add_handler/3</a>.</p><h2>Functions</h2><h3>init/3</h3><h3>init/4</h3><p>Initiate the event handler.</p><p>Initiates the event handler. Returns <strong><span class="anno">Args</span></strong>, which
is to be used in a call to
<strong>gen_event:add_handler(EventMgr, log_mf_h, <span class="anno">Args</span>)</strong>.
</p><p><strong><span class="anno">Dir</span></strong> specifies which directory to use for the log
files. <strong><span class="anno">MaxBytes</span></strong> specifies the size of each
individual file. <strong><span class="anno">MaxFiles</span></strong> specifies how many
files are used. <strong><span class="anno">Pred</span></strong> is a predicate function used
to filter the events. If no predicate function is specified, all
events are logged.</p><h3>See Also</h3><p><a href="gen_event">gen_event</a>,
<a href="./rb">sasl/rb</a></p><h2>maps</h2><p>Maps processing functions.</p><p>This module contains functions for maps processing.</p><h2>Data Types</h2><span class="name">iterator</span><p>An iterator representing the associations in a map with keys of type
<strong><span class="anno">Key</span></strong> and values of type <strong><span class="anno">Value</span></strong>.</p><p>Created using <a href="#iterator-1">iterator-1</a>.</p><p>Consumed by <a href="#next-1">next-1</a>,
<a href="#filter-2">filter-2</a>,
<a href="#fold-3">fold-3</a> and
<a href="#map-2">map-2</a>.</p><span class="name">iterator</span><h2>Functions</h2><h3>filter/2</h3><p>Select pairs that satisfy a predicate.</p><p>Returns a map <strong><span class="anno">Map</span></strong> for which predicate
<strong><span class="anno">Pred</span></strong> holds true in <strong><span class="anno">MapOrIter</span></strong>.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">MapOrIter</span></strong> is not a map or valid iterator,
or with <strong>badarg</strong> if <strong><span class="anno">Pred</span></strong> is not a
function of arity 2.</p><p><em>Example:</em></p><pre><code class="">
&gt; M = #{a =&gt; 2, b =&gt; 3, c=&gt; 4, "a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 4},
  Pred = fun(K,V) -&gt; is_atom(K) andalso (V rem 2) =:= 0 end,
  maps:filter(Pred,M).
#{a =&gt; 2,c =&gt; 4}</code></pre><h3>find/2</h3><p>Returns a tuple <strong>{ok, Value}</strong>, where <strong><span class="anno">Value</span></strong>
is the value associated with <strong><span class="anno">Key</span></strong>, or <strong>error</strong>
if no value is associated with <strong><span class="anno">Key</span></strong> in
<strong><span class="anno">Map</span></strong>.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">Map</span></strong> is not a map.</p><p><em>Example:</em></p><pre><code class="">
&gt; Map = #{"hi" =&gt; 42},
  Key = "hi",
  maps:find(Key,Map).
{ok,42}</code></pre><h3>fold/3</h3><p>Calls <strong>F(Key, Value, AccIn)</strong> for every <strong><span class="anno">Key</span></strong>
to value <strong><span class="anno">Value</span></strong> association in
<strong><span class="anno">MapOrIter</span></strong> in any order. Function <strong>fun F/3</strong>
must return a new accumulator, which is passed to the next successive
call. This function returns the final value of the accumulator.
The initial accumulator value <strong><span class="anno">Init</span></strong> is returned
if the map is empty.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">MapOrIter</span></strong> is not a map or valid iterator,
or with <strong>badarg</strong> if <strong><span class="anno">Fun</span></strong> is not a
function of arity 3.</p><p><em>Example:</em></p><pre><code class="">
&gt; Fun = fun(K,V,AccIn) when is_list(K) -&gt; AccIn + V end,
  Map = #{"k1" =&gt; 1, "k2" =&gt; 2, "k3" =&gt; 3},
  maps:fold(Fun,0,Map).
6</code></pre><h3>from_list/1</h3><p>Takes a list of key-value tuples elements and builds a map. The
associations can be in any order, and both keys and values in the
association can be of any term. If the same key appears more than
once, the latter (right-most) value is used and the previous values
are ignored.</p><p><em>Example:</em></p><pre><code class="">
&gt; List = [{"a",ignored},{1337,"value two"},{42,value_three},{"a",1}],
  maps:from_list(List).
#{42 =&gt; value_three,1337 =&gt; "value two","a" =&gt; 1}</code></pre><h3>get/2</h3><p>Returns value <strong><span class="anno">Value</span></strong> associated with
<strong><span class="anno">Key</span></strong> if <strong><span class="anno">Map</span></strong> contains
<strong><span class="anno">Key</span></strong>.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">Map</span></strong> is not a map, or with a <strong>{badkey,Key}</strong>
exception if no value is associated with <strong><span class="anno">Key</span></strong>.</p><p><em>Example:</em></p><pre><code class="">
&gt; Key = 1337,
  Map = #{42 =&gt; value_two,1337 =&gt; "value one","a" =&gt; 1},
  maps:get(Key,Map).
"value one"</code></pre><h3>get/3</h3><p>Returns value <strong><span class="anno">Value</span></strong> associated with
<strong><span class="anno">Key</span></strong> if <strong><span class="anno">Map</span></strong> contains
<strong><span class="anno">Key</span></strong>. If no value is associated with
<strong><span class="anno">Key</span></strong>, <strong><span class="anno">Default</span></strong> is returned.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">Map</span></strong> is not a map.</p><p><em>Example:</em></p><pre><code class="">
&gt; Map = #{ key1 =&gt; val1, key2 =&gt; val2 }.
#{key1 =&gt; val1,key2 =&gt; val2}
&gt; maps:get(key1, Map, "Default value").
val1
&gt; maps:get(key3, Map, "Default value").
"Default value"</code></pre><h3>is_key/2</h3><p>Returns <strong>true</strong> if map <strong><span class="anno">Map</span></strong> contains
<strong><span class="anno">Key</span></strong> and returns <strong>false</strong> if it does not
contain the <strong><span class="anno">Key</span></strong>.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">Map</span></strong> is not a map.</p><p><em>Example:</em></p><pre><code class="">
&gt; Map = #{"42" =&gt; value}.
#{"42" =&gt; value}
&gt; maps:is_key("42",Map).
true
&gt; maps:is_key(value,Map).
false</code></pre><h3>iterator/1</h3><p>Create a map iterator.</p><p>Returns a map iterator <strong><span class="anno">Iterator</span></strong> that can
be used by <a href="#next-1">next-1</a>
to traverse the key-value associations in a map. When iterating
over a map, the memory usage is guaranteed to be bounded no matter
the size of the map.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">Map</span></strong> is not a map.</p><p><em>Example:</em></p><pre><code class="">
&gt; M = #{ a =&gt; 1, b =&gt; 2 }.
#{a =&gt; 1,b =&gt; 2}
&gt; I = maps:iterator(M), ok.
ok
&gt; {K1, V1, I2} = maps:next(I), {K1, V1}.
{a,1}
&gt; {K2, V2, I3} = maps:next(I2),{K2, V2}.
{b,2}
&gt; maps:next(I3).
none</code></pre><h3>keys/1</h3><p>Returns a complete list of keys, in any order, which resides
within <strong><span class="anno">Map</span></strong>.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">Map</span></strong> is not a map.</p><p><em>Example:</em></p><pre><code class="">
&gt; Map = #{42 =&gt; value_three,1337 =&gt; "value two","a" =&gt; 1},
  maps:keys(Map).
[42,1337,"a"]</code></pre><h3>map/2</h3><p>Produces a new map <strong><span class="anno">Map</span></strong> by calling function
<strong>fun F(Key, Value1)</strong> for every <strong><span class="anno">Key</span></strong> to value
<strong><span class="anno">Value1</span></strong> association in
<strong><span class="anno">MapOrIter</span></strong> in any order. Function <strong>fun Fun/2</strong>
must return value <strong><span class="anno">Value2</span></strong> to be associated with
key <strong><span class="anno">Key</span></strong> for the new map
<strong><span class="anno">Map</span></strong>.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">MapOrIter</span></strong> is not a map or valid iterator,
or with <strong>badarg</strong> if <strong><span class="anno">Fun</span></strong> is not a
function of arity 2.</p><p><em>Example:</em></p><pre><code class="">
&gt; Fun = fun(K,V1) when is_list(K) -&gt; V1*2 end,
  Map = #{"k1" =&gt; 1, "k2" =&gt; 2, "k3" =&gt; 3},
  maps:map(Fun,Map).
#{"k1" =&gt; 2,"k2" =&gt; 4,"k3" =&gt; 6}</code></pre><h3>merge/2</h3><p>Merges two maps into a single map <strong><span class="anno">Map3</span></strong>. If two
keys exist in both maps, the value in <strong><span class="anno">Map1</span></strong> is
superseded by the value in <strong><span class="anno">Map2</span></strong>.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">Map1</span></strong> or <strong><span class="anno">Map2</span></strong> is not a map.</p><p><em>Example:</em></p><pre><code class="">
&gt; Map1 = #{a =&gt; "value_one", b =&gt; "value_two"},
  Map2 = #{a =&gt; 1, c =&gt; 2},
  maps:merge(Map1,Map2).
#{a =&gt; 1,b =&gt; "value_two",c =&gt; 2}</code></pre><h3>new/0</h3><p>Returns a new empty map.</p><p><em>Example:</em></p><pre><code class="">
&gt; maps:new().
#{}</code></pre><h3>next/1</h3><p>Get the next key and value from an iterator.</p><p>Returns the next key-value association in
<strong><span class="anno">Iterator</span></strong> and a new iterator for the
remaining associations in the iterator.
</p><p>
If there are no more associations in the iterator,
<strong>none</strong> is returned.
</p><p><em>Example:</em></p><pre><code class="">
&gt; Map = #{a =&gt; 1, b =&gt; 2, c =&gt; 3}.
#{a =&gt; 1,b =&gt; 2,c =&gt; 3}
&gt; I = maps:iterator(Map), ok.
ok
&gt; {K1, V1, I1} = maps:next(I), {K1, V1}.
{a,1}
&gt; {K2, V2, I2} = maps:next(I1), {K2, V2}.
{b,2}
&gt; {K3, V3, I3} = maps:next(I2), {K3, V3}.
{c,3}
&gt; maps:next(I3).
none</code></pre><h3>put/3</h3><p>Associates <strong><span class="anno">Key</span></strong> with value
<strong><span class="anno">Value</span></strong> and inserts the association into map
<strong>Map2</strong>. If key <strong><span class="anno">Key</span></strong> already exists in map
<strong><span class="anno">Map1</span></strong>, the old associated value is replaced by
value <strong><span class="anno">Value</span></strong>. The function returns a new map
<strong><span class="anno">Map2</span></strong> containing the new association and the old
associations in <strong><span class="anno">Map1</span></strong>.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">Map1</span></strong> is not a map.</p><p><em>Example:</em></p><pre><code class="">
&gt; Map = #{"a" =&gt; 1}.
#{"a" =&gt; 1}
&gt; maps:put("a", 42, Map).
#{"a" =&gt; 42}
&gt; maps:put("b", 1337, Map).
#{"a" =&gt; 1,"b" =&gt; 1337}</code></pre><h3>remove/2</h3><p>Removes the <strong><span class="anno">Key</span></strong>, if it exists, and its
associated value from <strong><span class="anno">Map1</span></strong> and returns a new map
<strong><span class="anno">Map2</span></strong> without key <strong><span class="anno">Key</span></strong>.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">Map1</span></strong> is not a map.</p><p><em>Example:</em></p><pre><code class="">
&gt; Map = #{"a" =&gt; 1}.
#{"a" =&gt; 1}
&gt; maps:remove("a",Map).
#{}
&gt; maps:remove("b",Map).
#{"a" =&gt; 1}</code></pre><h3>size/1</h3><p>Returns the number of key-value associations in
<strong><span class="anno">Map</span></strong>. This operation occurs in constant time.</p><p><em>Example:</em></p><pre><code class="">
&gt; Map = #{42 =&gt; value_two,1337 =&gt; "value one","a" =&gt; 1},
  maps:size(Map).
3</code></pre><h3>take/2</h3><p>The function removes the <strong><span class="anno">Key</span></strong>, if it
exists, and its associated value from <strong><span class="anno">Map1</span></strong>
and returns a tuple with the removed <strong><span class="anno">Value</span></strong>
and the new map <strong><span class="anno">Map2</span></strong> without key
<strong><span class="anno">Key</span></strong>.  If the key does not exist
<strong>error</strong> is returned.
</p><p>The call will fail with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">Map1</span></strong> is not a map.
</p><p>Example:</p><pre><code class="">
&gt; Map = #{"a" =&gt; "hello", "b" =&gt; "world"}.
#{"a" =&gt; "hello", "b" =&gt; "world"}
&gt; maps:take("a",Map).
{"hello",#{"b" =&gt; "world"}}
&gt; maps:take("does not exist",Map).
error</code></pre><h3>to_list/1</h3><p>Returns a list of pairs representing the key-value associations of
<strong><span class="anno">Map</span></strong>, where the pairs
<strong>[{K1,V1}, ..., {Kn,Vn}]</strong> are returned in arbitrary order.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">Map</span></strong> is not a map.</p><p><em>Example:</em></p><pre><code class="">
&gt; Map = #{42 =&gt; value_three,1337 =&gt; "value two","a" =&gt; 1},
  maps:to_list(Map).
[{42,value_three},{1337,"value two"},{"a",1}]</code></pre><h3>update/3</h3><p>If <strong><span class="anno">Key</span></strong> exists in <strong><span class="anno">Map1</span></strong>, the
old associated value is replaced by value <strong><span class="anno">Value</span></strong>.
The function returns a new map <strong><span class="anno">Map2</span></strong> containing
the new associated value.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">Map1</span></strong> is not a map, or with a <strong>{badkey,Key}</strong>
exception if no value is associated with <strong><span class="anno">Key</span></strong>.</p><p><em>Example:</em></p><pre><code class="">
&gt; Map = #{"a" =&gt; 1}.
#{"a" =&gt; 1}
&gt; maps:update("a", 42, Map).
#{"a" =&gt; 42}</code></pre><h3>update_with/3</h3><p>Update a value in a <strong><span class="anno">Map1</span></strong> associated
with <strong><span class="anno">Key</span></strong> by calling
<strong><span class="anno">Fun</span></strong> on the old value to get a new
value. An exception <strong>{badkey,<span class="anno">Key</span>}</strong> is
generated if <strong><span class="anno">Key</span></strong> is not present in the
map.</p><p>Example:</p><pre><code class="">
&gt; Map = #{"counter" =&gt; 1},
  Fun = fun(V) -&gt; V + 1 end,
  maps:update_with("counter",Fun,Map).
#{"counter" =&gt; 2}</code></pre><h3>update_with/4</h3><p>Update a value in a <strong><span class="anno">Map1</span></strong> associated
with <strong><span class="anno">Key</span></strong> by calling
<strong><span class="anno">Fun</span></strong> on the old value to get a new value.
If <strong><span class="anno">Key</span></strong> is not present in
<strong><span class="anno">Map1</span></strong> then <strong><span class="anno">Init</span></strong> will be
associated with <strong><span class="anno">Key</span></strong>.
</p><p>Example:</p><pre><code class="">
&gt; Map = #{"counter" =&gt; 1},
  Fun = fun(V) -&gt; V + 1 end,
  maps:update_with("new counter",Fun,42,Map).
#{"counter" =&gt; 1,"new counter" =&gt; 42}</code></pre><h3>values/1</h3><p>Returns a complete list of values, in arbitrary order, contained in
map <strong>Map</strong>.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">Map</span></strong> is not a map.</p><p><em>Example:</em></p><pre><code class="">
&gt; Map = #{42 =&gt; value_three,1337 =&gt; "value two","a" =&gt; 1},
  maps:values(Map).
[value_three,"value two",1]</code></pre><h3>with/2</h3><p>Returns a new map <strong><span class="anno">Map2</span></strong> with the keys <strong>K1</strong>
through <strong>Kn</strong> and their associated values from map
<strong><span class="anno">Map1</span></strong>. Any key in <strong><span class="anno">Ks</span></strong> that does
not exist in <strong><span class="anno">Map1</span></strong> is ignored.</p><p><em>Example:</em></p><pre><code class="">
&gt; Map = #{42 =&gt; value_three,1337 =&gt; "value two","a" =&gt; 1},
  Ks = ["a",42,"other key"],
  maps:with(Ks,Map).
#{42 =&gt; value_three,"a" =&gt; 1}</code></pre><h3>without/2</h3><p>Returns a new map <strong><span class="anno">Map2</span></strong> without keys <strong>K1</strong>
through <strong>Kn</strong> and their associated values from map
<strong><span class="anno">Map1</span></strong>. Any key in <strong><span class="anno">Ks</span></strong> that does
not exist in <strong><span class="anno">Map1</span></strong> is ignored</p><p><em>Example:</em></p><pre><code class="">
&gt; Map = #{42 =&gt; value_three,1337 =&gt; "value two","a" =&gt; 1},
  Ks = ["a",42,"other key"],
  maps:without(Ks,Map).
#{1337 =&gt; "value two"}</code></pre><h2>math</h2><p>Mathematical functions.</p><p>This module provides an interface to a number of mathematical
functions.</p><h2>Functions</h2><h3>acos/1</h3><h3>acosh/1</h3><h3>asin/1</h3><h3>asinh/1</h3><h3>atan/1</h3><h3>atan2/2</h3><h3>atanh/1</h3><h3>ceil/1</h3><h3>cos/1</h3><h3>cosh/1</h3><h3>exp/1</h3><h3>floor/1</h3><h3>fmod/2</h3><h3>log/1</h3><h3>log10/1</h3><h3>log2/1</h3><h3>pow/2</h3><h3>sin/1</h3><h3>sinh/1</h3><h3>sqrt/1</h3><h3>tan/1</h3><h3>tanh/1</h3><p>Diverse math functions.</p><ul><li>X</li></ul><ul><li>Y</li></ul><p>A collection of mathematical functions that return floats. Arguments
are numbers.</p><h3>erf/1</h3><p>Error function.</p><p>Returns the error function of <strong><span class="anno">X</span></strong>, where:</p><pre>
erf(X) = 2/sqrt(pi)*integral from 0 to X of exp(-t*t) dt.</pre><h3>erfc/1</h3><p>Another error function.</p><p><strong>erfc(X)</strong> returns <strong>1.0</strong> - <strong>erf(X)</strong>, computed by
methods that avoid cancellation for large <strong><span class="anno">X</span></strong>.</p><h3>pi/0</h3><p>A useful number.</p><p>A useful number.</p><h3>Limitations</h3><p>As these are the C library, the same limitations apply.</p><h2>ms_transform</h2><p>A parse transformation that translates fun syntax into match
    specifications.</p><p><a name="top"></a>This module provides the parse transformation that makes calls to
<a href="ets">ets</a> and
<a href="../runtime_tools/dbg#fun2ms/1">runtime_tools/dbg#fun2ms/1</a>
translate into literal match specifications. It also provides the back end
for the same functions when called from the Erlang shell.The translation from funs to match specifications
is accessed through the two "pseudo functions"
<a href="./ets#fun2ms/1">ets#fun2ms/1</a> and
<a href="../runtime_tools/dbg#fun2ms/1">runtime_tools/dbg#fun2ms/1</a>.As everyone trying to use
<a href="./ets#select/1">ets#select/1</a> or
<a href="./dbg">runtime_tools/dbg</a> seems to end up
reading this manual page, this description is an introduction to the
concept of match specifications.Read the whole manual page if it is the first time you are using
the transformations.Match specifications are used more or less as filters. They resemble
usual Erlang matching in a list comprehension or in a fun used with
<a href="./lists#foldl/3">lists#foldl/3</a>, and so on.
However, the syntax of pure match specifications is awkward, as
they are made up purely by Erlang terms, and the language has no
syntax to make the match specifications more readable.As the execution and structure of the match specifications are like
that of a fun, it is more straightforward
to write it using the familiar fun syntax and to have that
translated into a match specification automatically. A real fun is
clearly more powerful than the match specifications allow, but bearing
the match specifications in mind, and what they can do, it is still
more convenient to write it all as a fun. This module contains the
code that translates the fun syntax into match specification
terms.</p><h3>Example 1</h3><p>Using <a href="./ets#select/2">ets#select/2</a>
and a match specification, one can filter out rows of
a table and construct a list of tuples containing relevant parts
of the data in these rows.
One can use <a href="./ets#foldl/3">ets#foldl/3</a>
instead, but the <strong>ets:select/2</strong> call is far more efficient.
Without the translation provided by <strong>ms_transform</strong>,
one must struggle with writing match specifications terms
to accommodate this.</p><p>Consider a simple table of employees:</p><pre><code class="">
-record(emp, {empno,     %Employee number as a string, the key
              surname,   %Surname of the employee
              givenname, %Given name of employee
              dept,      %Department, one of {dev,sales,prod,adm}
              empyear}). %Year the employee was employed</code></pre><p>We create the table using:</p><pre><code class="">
ets:new(emp_tab, [{keypos,#emp.empno},named_table,ordered_set]).</code></pre><p>We fill the table with randomly chosen data:</p><pre><code class="">
[{emp,"011103","Black","Alfred",sales,2000},
 {emp,"041231","Doe","John",prod,2001},
 {emp,"052341","Smith","John",dev,1997},
 {emp,"076324","Smith","Ella",sales,1995},
 {emp,"122334","Weston","Anna",prod,2002},
 {emp,"535216","Chalker","Samuel",adm,1998},
 {emp,"789789","Harrysson","Joe",adm,1996},
 {emp,"963721","Scott","Juliana",dev,2003},
 {emp,"989891","Brown","Gabriel",prod,1999}]</code></pre><p>Assuming that we want the employee numbers of everyone in the sales
department, there are several ways.</p><p><strong>ets:match/2</strong> can be used:</p><pre>
1&gt; <span class="input">ets:match(emp_tab, {'_', '$1', '_', '_', sales, '_'}).</span>
[["011103"],["076324"]]</pre><p><strong>ets:match/2</strong> uses a simpler type of match specification,
but it is still unreadable, and one has little control over the
returned result. It is always a list of lists.</p><p><a href="./ets#foldl/3">ets#foldl/3</a> or
<a href="./ets#foldr/3">ets#foldr/3</a> can be used to avoid the nested lists:</p><pre><code class="">
ets:foldr(fun(#emp{empno = E, dept = sales},Acc) -&gt; [E | Acc];
             (_,Acc) -&gt; Acc
          end,
          [],
          emp_tab).</code></pre><p>The result is <strong>["011103","076324"]</strong>. The fun is
straightforward, so the only problem is that all the data from the
table must be transferred from the table to the calling process for
filtering. That is inefficient compared to the <strong>ets:match/2</strong>
call where the filtering can be done "inside" the emulator and only
the result is transferred to the process.</p><p>Consider a "pure" <strong>ets:select/2</strong> call that does what
<strong>ets:foldr</strong> does:</p><pre><code class="">
ets:select(emp_tab, [{#emp{empno = '$1', dept = sales, _='_'},[],['$1']}]).</code></pre><p>Although the record syntax is used, it is still hard to
read and even harder to write. The first element of the tuple,
<strong>#emp{empno = '$1', dept = sales, _='_'}</strong>, tells what to
match. Elements not matching this are not returned, as in
the <strong>ets:match/2</strong> example. The second element, the empty list,
is a list of guard expressions, which we do not need. The third
element is the list of expressions constructing the return value (in
ETS this is almost always a list containing one single term).
In our case <strong>'$1'</strong> is bound to the employee number in the head
(first element of the tuple), and hence the employee number is
returned. The result is <strong>["011103","076324"]</strong>, as in
the <strong>ets:foldr/3</strong> example, but the result is retrieved much
more efficiently in terms of execution speed and
memory consumption.</p><p>Using <strong>ets:fun2ms/1</strong>, we can combine the ease of use of
the <strong>ets:foldr/3</strong> and the efficiency of the pure
<strong>ets:select/2</strong> example:</p><pre><code class="">
-include_lib("stdlib/include/ms_transform.hrl").

ets:select(emp_tab, ets:fun2ms(
                      fun(#emp{empno = E, dept = sales}) -&gt;
                              E
                      end)).</code></pre><p>This example requires no special knowledge of match
specifications to understand. The head of the fun matches what
you want to filter out and the body returns what you want
returned. As long as the fun can be kept within the limits of the
match specifications, there is no need to transfer all table data
to the process for filtering as in the <strong>ets:foldr/3</strong>
example. It is easier to read than the <strong>ets:foldr/3</strong> example,
as the select call in itself discards anything that does not
match, while the fun of the <strong>ets:foldr/3</strong> call needs to
handle both the elements matching and the ones not matching.</p><p>In the <strong>ets:fun2ms/1</strong> example above, it is needed to
include <strong>ms_transform.hrl</strong> in the source code, as this is
what triggers the parse transformation of the <strong>ets:fun2ms/1</strong>
call to a valid match specification. This also implies that the
transformation is done at compile time (except when called from
the shell) and therefore takes no resources in runtime. That is,
although you use the more intuitive fun syntax, it gets as
efficient in runtime as writing match specifications by hand.</p><h3>Example 2</h3><p>Assume that we want to get all the employee numbers of employees
hired before year 2000. Using <strong>ets:match/2</strong> is not
an alternative here, as relational operators cannot be
expressed there.
Once again, <strong>ets:foldr/3</strong> can do it (slowly, but correct):</p><pre><code class="">
ets:foldr(fun(#emp{empno = E, empyear = Y},Acc) when Y &lt; 2000 -&gt; [E | Acc];
                  (_,Acc) -&gt; Acc
          end,
          [],
          emp_tab).    </code></pre><p>The result is <strong>["052341","076324","535216","789789","989891"]</strong>,
as expected. The equivalent expression using a handwritten match
specification would look like this:</p><pre><code class="">
ets:select(emp_tab, [{#emp{empno = '$1', empyear = '$2', _='_'},
                     [{'&lt;', '$2', 2000}],
                     ['$1']}]).    </code></pre><p>This gives the same result. <strong>[{'&lt;', '$2', 2000}]</strong> is in
the guard part and therefore discards anything that does not have an
<strong>empyear</strong> (bound to <strong>'$2'</strong> in the head) less than 2000, as
the guard in the <strong>foldr/3</strong> example.</p><p>We write it using <strong>ets:fun2ms/1</strong>:</p><pre><code class="">
-include_lib("stdlib/include/ms_transform.hrl").

ets:select(emp_tab, ets:fun2ms(
                      fun(#emp{empno = E, empyear = Y}) when Y &lt; 2000 -&gt;
                           E
                      end)).    </code></pre><h3>Example 3</h3><p>Assume that we want the whole object matching instead of only one
element. One alternative is to assign a variable to every part
of the record and build it up once again in the body of the fun, but
the following is easier:</p><pre><code class="">
ets:select(emp_tab, ets:fun2ms(
                      fun(Obj = #emp{empno = E, empyear = Y}) 
                         when Y &lt; 2000 -&gt;
                              Obj
                      end)).</code></pre><p>As in ordinary Erlang matching, you can bind a variable to the
whole matched object using a "match inside the match", that is, a
<strong>=</strong>. Unfortunately in funs translated to match specifications,
it is allowed only at the "top-level", that is,
matching the <em>whole</em> object arriving to be matched
into a separate variable.
If you are used to writing match specifications by hand, we
mention that variable A is simply translated into '$_'.
Alternatively, pseudo function <strong>object/0</strong>
also returns the whole matched object, see section
<a href="#warnings_and_restrictions"> Warnings and Restrictions</a>.</p><h3>Example 4</h3><p>This example concerns the body of the fun. Assume that all employee
numbers beginning with zero (<strong>0</strong>) must be changed to begin with
one (<strong>1</strong>) instead, and that we want to create the list
<strong>[{&lt;Old empno&gt;,&lt;New empno&gt;}]</strong>:</p><pre><code class="">
ets:select(emp_tab, ets:fun2ms(
                      fun(#emp{empno = [$0 | Rest] }) -&gt;
                              {[$0|Rest],[$1|Rest]}
                      end)).</code></pre><p>This query hits the feature of partially bound
keys in table type <strong>ordered_set</strong>, so that not the whole
table needs to be searched, only the part containing keys
beginning with <strong>0</strong> is looked into.</p><h3>Example 5</h3><p>The fun can have many clauses. Assume that we want to do
the following:</p><ul><li> <p>If an employee started before 1997, return the tuple
<strong>{inventory, &lt;employee number&gt;}</strong>.</p> </li><li> <p>If an employee started 1997 or later, but before 2001, return
<strong>{rookie, &lt;employee number&gt;}</strong>.</p> </li><li> <p>For all other employees, return
<strong>{newbie, &lt;employee number&gt;}</strong>, except for those
named <strong>Smith</strong> as they would be affronted by anything other
than the tag <strong>guru</strong> and that is also what is returned for their
numbers: <strong>{guru, &lt;employee number&gt;}</strong>.</p> </li></ul><p>This is accomplished as follows:</p><pre><code class="">
ets:select(emp_tab, ets:fun2ms(
                      fun(#emp{empno = E, surname = "Smith" }) -&gt;
                              {guru,E};
                         (#emp{empno = E, empyear = Y}) when Y &lt; 1997  -&gt;
                              {inventory, E};
                         (#emp{empno = E, empyear = Y}) when Y &gt; 2001  -&gt;
                              {newbie, E};
                         (#emp{empno = E, empyear = Y}) -&gt; % 1997 -- 2001
                              {rookie, E}
                      end)).    </code></pre><p>The result is as follows:</p><pre><code class="">
[{rookie,"011103"},
 {rookie,"041231"},
 {guru,"052341"},
 {guru,"076324"},
 {newbie,"122334"},
 {rookie,"535216"},
 {inventory,"789789"},
 {newbie,"963721"},
 {rookie,"989891"}]</code></pre><h3>Useful BIFs</h3><p>What more can you do? A simple answer is: see the documentation of
<a href="./match_spec">match specifications</a>
in ERTS User's Guide.
However, the following is a brief overview of the most useful "built-in
functions" that you can use when the fun is to be translated into a match
specification by
<a href="./ets#fun2ms/1">ets#fun2ms/1</a>. It is not
possible to call other functions than those allowed in match
specifications. No "usual" Erlang code can be executed by the fun that
is translated by <strong>ets:fun2ms/1</strong>. The fun is limited
exactly to the power of the match specifications, which is
unfortunate, but the price one must pay for the execution speed of
<strong>ets:select/2</strong> compared to <strong>ets:foldl/foldr</strong>.</p><p>The head of the fun is a head matching (or mismatching)
<em>one</em> parameter, one object of the table we select
from. The object is always a single variable (can be <strong>_</strong>) or
a tuple, as ETS, Dets, and Mnesia tables include
that. The match specification returned by <strong>ets:fun2ms/1</strong> can
be used with <strong>dets:select/2</strong> and <strong>mnesia:select/2</strong>, and
with <strong>ets:select/2</strong>. The use of <strong>=</strong> in the head
is allowed (and encouraged) at the top-level.</p><p>The guard section can contain any guard expression of Erlang.
The following is a list of BIFs and expressions:</p><ul><li> <p>Type tests: <strong>is_atom</strong>, <strong>is_float</strong>, <strong>is_integer</strong>,
<strong>is_list</strong>, <strong>is_number</strong>, <strong>is_pid</strong>, <strong>is_port</strong>,
<strong>is_reference</strong>, <strong>is_tuple</strong>, <strong>is_binary</strong>,
<strong>is_function</strong>, <strong>is_record</strong></p> </li><li> <p>Boolean operators: <strong>not</strong>, <strong>and</strong>, <strong>or</strong>,
<strong>andalso</strong>, <strong>orelse</strong></p> </li><li> <p>Relational operators: &gt;, &gt;=, &lt;, =&lt;, =:=, ==, =/=, /=</p> </li><li> <p>Arithmetics: <strong>+</strong>, <strong>-</strong>, <strong>*</strong>,
<strong>div</strong>, <strong>rem</strong></p> </li><li> <p>Bitwise operators: <strong>band</strong>, <strong>bor</strong>, <strong>bxor</strong>, <strong>bnot</strong>,
<strong>bsl</strong>, <strong>bsr</strong></p> </li><li> <p>The guard BIFs: <strong>abs</strong>, <strong>element</strong>,
<strong>hd</strong>, <strong>length</strong>,
<strong>node</strong>, <strong>round</strong>, <strong>size</strong>, <strong>tl</strong>, <strong>trunc</strong>,
<strong>self</strong></p> </li></ul><p>Contrary to the fact with "handwritten" match specifications, the
<strong>is_record</strong> guard works as in ordinary Erlang code.</p><p>Semicolons (<strong>;</strong>) in guards are allowed, the result is (as
expected) one "match specification clause" for each semicolon-separated
part of the guard. The semantics is identical to the Erlang
semantics.</p><p>The body of the fun is used to construct the
resulting value. When selecting from tables, one usually construct
a suiting term here, using ordinary Erlang term construction, like
tuple parentheses, list brackets, and variables matched out in the
head, possibly with the occasional constant. Whatever
expressions are allowed in guards are also allowed here, but no special
functions exist except <strong>object</strong> and
<strong>bindings</strong> (see further down), which returns the whole
matched object and all known variable bindings, respectively.</p><p>The <strong>dbg</strong> variants of match specifications have an
imperative approach to the match specification body, the ETS
dialect has not. The fun body for <strong>ets:fun2ms/1</strong> returns the result
without side effects. As matching (<strong>=</strong>) in the body of
the match specifications is not allowed (for performance reasons) the
only thing left, more or less, is term construction.</p><h3>Example with dbg</h3><p>This section describes the slightly different match specifications
translated by <a href="../runtime_tools/dbg#fun2ms/1">runtime_tools/dbg#fun2ms/1</a>.</p><p>The same reasons for using the parse transformation apply to
<strong>dbg</strong>, maybe even more, as filtering using Erlang code is
not a good idea when tracing (except afterwards, if you trace
to file). The concept is similar to that of <strong>ets:fun2ms/1</strong>
except that you usually use it directly from the shell
(which can also be done with <strong>ets:fun2ms/1</strong>).</p><p>The following is an example module to trace on:</p><pre><code class="">
-module(toy).

-export([start/1, store/2, retrieve/1]).

start(Args) -&gt;
    toy_table = ets:new(toy_table, Args).

store(Key, Value) -&gt;
    ets:insert(toy_table, {Key,Value}).

retrieve(Key) -&gt;
    [{Key, Value}] = ets:lookup(toy_table, Key),
    Value.</code></pre><p>During model testing, the first test results in
<strong>{badmatch,16}</strong> in <strong>{toy,start,1}</strong>, why?</p><p>We suspect the <strong>ets:new/2</strong> call, as we match hard on the
return value, but want only the particular <strong>new/2</strong> call with
<strong>toy_table</strong> as first parameter. So we start a default tracer
on the node:</p><pre>
1&gt; <span class="input">dbg:tracer().</span>
{ok,&lt;0.88.0&gt;}</pre><p>We turn on call tracing for all processes, we want to
make a pretty restrictive trace pattern, so there is no need to call
trace only a few processes (usually it is not):</p><pre>
2&gt; <span class="input">dbg:p(all,call).</span>
{ok,[{matched,nonode@nohost,25}]}</pre><p>We specify the filter, we want to view calls that resemble
<strong>ets:new(toy_table, &lt;something&gt;)</strong>:</p><pre>
3&gt; <span class="input">dbg:tp(ets,new,dbg:fun2ms(fun([toy_table,_]) -&gt; true end)).</span>
{ok,[{matched,nonode@nohost,1},{saved,1}]}</pre><p>As can be seen, the fun used with
<strong>dbg:fun2ms/1</strong> takes a single list as parameter instead of a
single tuple. The list matches a list of the parameters to the traced
function. A single variable can also be used. The body
of the fun expresses, in a more imperative way, actions to be taken if
the fun head (and the guards) matches. <strong>true</strong> is returned here,
only because the body of a fun cannot be empty. The return value
is discarded.</p><p>The following trace output is received during test:</p><pre><code class="">
(&lt;0.86.0&gt;) call ets:new(toy_table, [ordered_set])    </code></pre><p>Assume that we have not found the problem yet, and want to see what
<strong>ets:new/2</strong> returns. We use a slightly different trace pattern:</p><pre>
4&gt; <span class="input">dbg:tp(ets,new,dbg:fun2ms(fun([toy_table,_]) -&gt; return_trace() end)).</span></pre><p>The following trace output is received during test:</p><pre><code class="">
(&lt;0.86.0&gt;) call ets:new(toy_table,[ordered_set])
(&lt;0.86.0&gt;) returned from ets:new/2 -&gt; 24    </code></pre><p>The call to <strong>return_trace</strong> results in a trace message
when the function returns. It applies only to the specific function call
triggering the match specification (and matching the head/guards of
the match specification). This is by far the most common call in the
body of a <strong>dbg</strong> match specification.</p><p>The test now fails with <strong>{badmatch,24}</strong> because the atom
<strong>toy_table</strong> does not match the number returned for an unnamed table.
So, the problem is found, the table is to be named, and the arguments
supplied by the test program do not include <strong>named_table</strong>. We
rewrite the start function:</p><pre><code class="">
start(Args) -&gt;
    toy_table = ets:new(toy_table, [named_table|Args]).</code></pre><p>With the same tracing turned on, the following trace output is
received:</p><pre><code class="">
(&lt;0.86.0&gt;) call ets:new(toy_table,[named_table,ordered_set])
(&lt;0.86.0&gt;) returned from ets:new/2 -&gt; toy_table    </code></pre><p>Assume that the module now passes all testing and goes into
the system. After a while, it is found that table
<strong>toy_table</strong> grows while the system is running and that
there are many elements with atoms as keys. We expected
only integer keys and so does the rest of the system, but
clearly not the entire system. We turn on call tracing and try to
see calls to the module with an atom as the key:</p><pre>
1&gt; <span class="input">dbg:tracer().</span>
{ok,&lt;0.88.0&gt;}
2&gt; <span class="input">dbg:p(all,call).</span>
{ok,[{matched,nonode@nohost,25}]}
3&gt; <span class="input">dbg:tpl(toy,store,dbg:fun2ms(fun([A,_]) when is_atom(A) -&gt; true end)).</span>
{ok,[{matched,nonode@nohost,1},{saved,1}]}</pre><p>We use <strong>dbg:tpl/3</strong> to ensure to catch local calls
(assume that the module has grown since the smaller version and we are
unsure if this inserting of atoms is not done locally). When in
doubt, always use local call tracing.</p><p>Assume that nothing happens when tracing in this way. The function
is never called with these parameters. We conclude that
someone else (some other module) is doing it and realize that we
must trace on <strong>ets:insert/2</strong> and want to see the calling function.
The calling function can be retrieved using the match specification
function <strong>caller</strong>. To get it into the trace message, the match
specification function <strong>message</strong> must be used. The filter
call looks like this (looking for calls to <strong>ets:insert/2</strong>):</p><pre>
4&gt; <span class="input">dbg:tpl(ets,insert,dbg:fun2ms(fun([toy_table,{A,_}]) when is_atom(A) -&gt; </span>
<span class="input">                                    message(caller()) </span>
<span class="input">                                  end)). </span>
{ok,[{matched,nonode@nohost,1},{saved,2}]}</pre><p>The caller is now displayed in the "additional message" part of the
trace output, and the following is displayed after a while:</p><pre><code class="">
(&lt;0.86.0&gt;) call ets:insert(toy_table,{garbage,can}) ({evil_mod,evil_fun,2})    </code></pre><p>You have realized that function <strong>evil_fun</strong> of the
<strong>evil_mod</strong> module, with arity <strong>2</strong>, is causing all this trouble.
</p><p>This example illustrates the most used calls in match specifications for
<strong>dbg</strong>. The other, more esoteric, calls are listed and explained in
<a href="./match_spec">Match specifications in Erlang</a>
in ERTS User's Guide, as they are beyond
the scope of this description.</p><h3>Warnings and Restrictions</h3><a name="warnings_and_restrictions"></a><p>The following warnings and restrictions apply to the funs used in
with <strong>ets:fun2ms/1</strong> and <strong>dbg:fun2ms/1</strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>To use the pseudo functions triggering the translation,
ensure to include the header file <strong>ms_transform.hrl</strong>
in the source code. Failure to do so possibly results in
runtime errors rather than compile time, as the expression can
be valid as a plain Erlang program without translation.</p></div><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>The fun must be literally constructed inside the
parameter list to the pseudo functions. The fun cannot
be bound to a variable first and then passed to
<strong>ets:fun2ms/1</strong> or <strong>dbg:fun2ms/1</strong>. For example,
<strong>ets:fun2ms(fun(A) -&gt; A end)</strong> works, but not
<strong>F = fun(A) -&gt; A end, ets:fun2ms(F)</strong>. The latter results
in a compile-time error if the header is included, otherwise a
runtime error.</p></div><p>Many restrictions apply to the fun that is translated into a match
specification. To put it simple: you cannot use anything in the fun
that you cannot use in a match specification. This means that,
among others, the following restrictions apply to the fun itself:</p><ul><li> <p>Functions written in Erlang cannot be called, neither can
local functions, global functions, or real funs.</p> </li><li> <p>Everything that is written as a function call is translated
into a match specification call to a built-in function, so that
the call <strong>is_list(X)</strong> is translated to <strong>{'is_list', '$1'}</strong>
(<strong>'$1'</strong> is only an example, the numbering can vary).
If one tries to call a function that is not a match specification
built-in, it causes an error.</p> </li><li> <p>Variables occurring in the head of the fun are replaced by
match specification variables in the order of occurrence, so
that fragment <strong>fun({A,B,C})</strong> is replaced by
<strong>{'$1', '$2', '$3'}</strong>, and so on. Every occurrence of such a
variable in the match specification is replaced by a match
specification variable in the same way, so that the fun
<strong>fun({A,B}) when is_atom(A) -&gt; B end</strong> is translated into
<strong>[{{'$1','$2'},[{is_atom,'$1'}],['$2']}]</strong>.</p> </li><li> <p>Variables that are not included in the head are imported
from the environment and made into match specification
<strong>const</strong> expressions. Example from the shell:</p> <pre>
1&gt; <span class="input">X = 25.</span>
25
2&gt; <span class="input">ets:fun2ms(fun({A,B}) when A &gt; X -&gt; B end).</span>
[{{'$1','$2'},[{'&gt;','$1',{const,25}}],['$2']}]</pre> </li><li> <p>Matching with <strong>=</strong> cannot be used in the body. It can only
be used on the top-level in the head of the fun.
Example from the shell again:</p> <pre>
1&gt; <span class="input">ets:fun2ms(fun({A,[B|C]} = D) when A &gt; B -&gt; D end).</span>
[{{'$1',['$2'|'$3']},[{'&gt;','$1','$2'}],['$_']}]
2&gt; <span class="input">ets:fun2ms(fun({A,[B|C]=D}) when A &gt; B -&gt; D end).</span>
Error: fun with head matching ('=' in head) cannot be translated into 
match_spec 
{error,transform_error}
3&gt; <span class="input">ets:fun2ms(fun({A,[B|C]}) when A &gt; B -&gt; D = [B|C], D end).</span>
Error: fun with body matching ('=' in body) is illegal as match_spec
{error,transform_error}</pre> <p>All variables are bound in the head of a match specification, so
the translator cannot allow multiple bindings. The special case
when matching is done on the top-level makes the variable bind
to <strong>'$_'</strong> in the resulting match specification. It is to allow
a more natural access to the whole matched object. Pseudo
function <strong>object()</strong> can be used instead, see below.</p> <p>The following expressions are translated equally:</p> <pre><code class="">
ets:fun2ms(fun({a,_} = A) -&gt; A end).
ets:fun2ms(fun({a,_}) -&gt; object() end).</code></pre> </li><li> <p>The special match specification variables <strong>'$_'</strong> and <strong>'$*'</strong>
can be accessed through the pseudo functions <strong>object()</strong>
(for <strong>'$_'</strong>) and <strong>bindings()</strong> (for <strong>'$*'</strong>).
As an example, one can translate the following
<strong>ets:match_object/2</strong> call to a <strong>ets:select/2</strong> call:</p> <pre><code class="">
ets:match_object(Table, {'$1',test,'$2'}). </code></pre> <p>This is the same as:</p> <pre><code class="">
ets:select(Table, ets:fun2ms(fun({A,test,B}) -&gt; object() end)).</code></pre> <p>In this simple case, the former
expression is probably preferable in terms of readability.</p> <p>The <strong>ets:select/2</strong> call conceptually looks like this
in the resulting code:</p> <pre><code class="">
ets:select(Table, [{{'$1',test,'$2'},[],['$_']}]).</code></pre> <p>Matching on the top-level of the fun head can be a
more natural way to access <strong>'$_'</strong>, see above.</p> </li><li> <p>Term constructions/literals are translated as much as is needed to
get them into valid match specification. This way tuples are made
into match specification tuple constructions (a one element tuple
containing the tuple) and constant expressions are used when
importing variables from the environment. Records are also
translated into plain tuple constructions, calls to element,
and so on. The guard test <strong>is_record/2</strong> is translated into
match specification code using the three parameter version that is
built into match specification, so that <strong>is_record(A,t)</strong> is
translated into <strong>{is_record,'$1',t,5}</strong> if the record
size of record type <strong>t</strong> is 5.</p> </li><li> <p>Language constructions such as <strong>case</strong>, <strong>if</strong>, and
<strong>catch</strong> that are not present in match specifications are not
allowed.</p> </li><li> <p>If header file <strong>ms_transform.hrl</strong> is not included,
the fun is not translated, which can result in a
<em>runtime error</em> (depending on whether the fun is
valid in a pure Erlang context).</p> <p>Ensure that the header is included when using <strong>ets</strong> and
<strong>dbg:fun2ms/1</strong> in compiled code.</p> </li><li> <p>If pseudo function triggering the translation is
<strong>ets:fun2ms/1</strong>, the head of the fun must contain a single
variable or a single tuple. If the pseudo function is
<strong>dbg:fun2ms/1</strong>, the head of the fun must contain a single
variable or a single list.</p> </li></ul><p>The translation from funs to match specifications is done at compile
time, so runtime performance is not affected by using these pseudo
functions.</p><p>For more information about match specifications, see the
<a href="./match_spec">Match specifications in Erlang</a>
in ERTS User's Guide.</p><h2>Functions</h2><h3>format_error/1</h3><p>Error formatting function as required by the parse transformation interface.</p><p>Takes an error code returned by one of the other functions
in the module and creates a textual description of the
error.</p><h3>parse_transform/2</h3><p>Transforms Erlang abstract format containing calls to ets/dbg:fun2ms/1 into literal match specifications.</p><dl><dt>Options</dt><dd>Option list, required but not used. </dd></dl><p>Implements the transformation at compile time. This
function is called by the compiler to do the source code
transformation if and when header file <strong>ms_transform.hrl</strong>
is included in the source code.</p><p>For information about how to use this parse transformation, see
<a href="ets">ets</a> and
<a href="../runtime_tools/dbg#fun2ms/1">runtime_tools/dbg#fun2ms/1</a>.</p><p>For a description of match specifications, see section
<a href="./match_spec"> Match Specification in Erlang</a> in ERTS User's Guide.</p><h3>transform_from_shell/3</h3><p>Used when transforming funs created in the shell into match_specifications.</p><dl><dt>BoundEnvironment</dt><dd>List of variable bindings in the shell environment.</dd></dl><p>Implements the transformation when the <strong>fun2ms/1</strong>
functions are called from the shell. In this case, the abstract
form is for one single fun (parsed by the Erlang shell).
All imported variables are to be in the key-value list passed
as <strong><span class="anno">BoundEnvironment</span></strong>. The result is a term,
normalized, that is, not in abstract format.</p><h2>orddict</h2><p>Key-value dictionary as ordered list.</p><p>This module provides a <strong>Key</strong>-<strong>Value</strong> dictionary.
An <strong>orddict</strong> is a representation of a dictionary, where a
list of pairs is used to store the keys and values. The list is
ordered after the keys in the <em>Erlang term order</em>.This module provides the same interface as the
<a href="dict">dict</a> module
but with a defined representation. One difference is
that while <strong>dict</strong> considers two keys as different if they
do not match (<strong>=:=</strong>), this module considers two keys as
different if and only if they do not compare equal (<strong>==</strong>).</p><h2>Data Types</h2><span class="name">orddict</span><p>Dictionary as returned by
<a href="#new/0">new/0</a>.</p><span class="name">orddict</span><h2>Functions</h2><h3>append/3</h3><p>Append a value to keys in a dictionary.</p><p>Appends a new <strong><span class="anno">Value</span></strong> to the current list
of values associated with <strong><span class="anno">Key</span></strong>. An exception is
generated if the initial value associated with <strong><span class="anno">Key</span></strong>
is not a list of values.</p><p>See also section <a href="#notes">Notes</a>.</p><h3>append_list/3</h3><p>Append new values to keys in a dictionary.</p><p>Appends a list of values <strong><span class="anno">ValList</span></strong> to
the current list of values associated with <strong><span class="anno">Key</span></strong>.
An exception is generated if the initial value associated with
<strong><span class="anno">Key</span></strong> is not a list of values.</p><p>See also section <a href="#notes">Notes</a>.</p><h3>erase/2</h3><p>Erase a key from a dictionary.</p><p>Erases all items with a specified key from a dictionary.</p><h3>fetch/2</h3><p>Look up values in a dictionary.</p><p>Returns the value associated with <strong><span class="anno">Key</span></strong>
in dictionary <strong><span class="anno">Orddict</span></strong>. This function assumes that
the <strong><span class="anno">Key</span></strong> is present in the dictionary. An exception
is generated if <strong><span class="anno">Key</span></strong> is not in the dictionary.</p><p>See also section <a href="#notes">Notes</a>.</p><h3>fetch_keys/1</h3><p>Return all keys in a dictionary.</p><p>Returns a list of all keys in a dictionary.</p><h3>take/2</h3><p>Return value and new dictionary without element with this value.</p><p>This function returns value from dictionary and new dictionary without this value.
Returns <strong>error</strong> if the key is not present in the dictionary.</p><h3>filter/2</h3><p>Select elements that satisfy a predicate.</p><p><strong><span class="anno">Orddict2</span></strong> is a dictionary of all keys and values
in <strong><span class="anno">Orddict1</span></strong> for which
<strong><span class="anno">Pred</span>(<span class="anno">Key</span>, <span class="anno">Value</span>)</strong> is
<strong>true</strong>.</p><h3>find/2</h3><p>Search for a key in a dictionary.</p><p>Searches for a key in a dictionary. Returns
<strong>{ok, <span class="anno">Value</span>}</strong>, where <strong><span class="anno">Value</span></strong> is
the value associated with <strong><span class="anno">Key</span></strong>, or <strong>error</strong> if
the key is not present in the dictionary.</p><p>See also section <a href="#notes">Notes</a>.</p><h3>fold/3</h3><p>Fold a function over a dictionary.</p><p>Calls <strong><span class="anno">Fun</span></strong> on successive keys and values of
<strong><span class="anno">Orddict</span></strong> together with an extra argument <strong>Acc</strong>
(short for accumulator). <strong><span class="anno">Fun</span></strong> must return a new
accumulator that is passed to the next call. <strong><span class="anno">Acc0</span></strong>
is returned if the list is empty.</p><h3>from_list/1</h3><p>Convert a list of pairs to a dictionary.</p><p>Converts the <strong><span class="anno">Key</span></strong>-<strong><span class="anno">Value</span></strong> list
<strong><span class="anno">List</span></strong> to a dictionary.</p><h3>is_empty/1</h3><p>Return true if the dictionary is empty.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Orddict</span></strong> has no elements,
otherwise <strong>false</strong>.</p><h3>is_key/2</h3><p>Test if a key is in a dictionary.</p><p>Tests if <strong><span class="anno">Key</span></strong> is contained in
dictionary <strong><span class="anno">Orddict</span></strong>.</p><h3>map/2</h3><p>Map a function over a dictionary.</p><p>Calls <strong><span class="anno">Fun</span></strong> on successive keys and values of
<strong><span class="anno">Orddict1</span></strong> tvo return a new value for each key.</p><h3>merge/3</h3><p>Merge two dictionaries.</p><p>Merges two dictionaries, <strong><span class="anno">Orddict1</span></strong> and
<strong><span class="anno">Orddict2</span></strong>, to create a new dictionary. All the
<strong><span class="anno">Key</span></strong>-<strong><span class="anno">Value</span></strong> pairs from both
dictionaries are included in the new dictionary. If a key occurs in
both dictionaries, <strong><span class="anno">Fun</span></strong> is called with the key and
both values to return a new value.
<strong>merge/3</strong> can be defined as follows, but is faster:</p><pre><code class="">
merge(Fun, D1, D2) -&gt;
    fold(fun (K, V1, D) -&gt;
                 update(K, fun (V2) -&gt; Fun(K, V1, V2) end, V1, D)
         end, D2, D1).</code></pre><h3>new/0</h3><p>Create a dictionary.</p><p>Creates a new dictionary.</p><h3>size/1</h3><p>Return the number of elements in an ordered dictionary. </p><p>Returns the number of elements in an <strong><span class="anno">Orddict</span></strong>.</p><h3>store/3</h3><p>Store a value in a dictionary.</p><p>Stores a <strong><span class="anno">Key</span></strong>-<strong><span class="anno">Value</span></strong> pair in a
dictionary. If the <strong><span class="anno">Key</span></strong> already exists in
<strong><span class="anno">Orddict1</span></strong>,
the associated value is replaced by <strong><span class="anno">Value</span></strong>.</p><h3>to_list/1</h3><p>Convert a dictionary to a list of pairs.</p><p>Converts a dictionary to a list representation.</p><h3>update/3</h3><p>Update a value in a dictionary.</p><p>Updates a value in a dictionary by calling <strong><span class="anno">Fun</span></strong>
on the value to get a new value. An exception is generated if
<strong><span class="anno">Key</span></strong> is not present in the dictionary.</p><h3>update/4</h3><p>Update a value in a dictionary.</p><p>Updates a value in a dictionary by calling <strong><span class="anno">Fun</span></strong>
on the value to get a new value. If <strong><span class="anno">Key</span></strong> is not
present in the dictionary, <strong><span class="anno">Initial</span></strong> is stored as
the first value. For example, <strong>append/3</strong> can be defined
as follows:</p><pre><code class="">
append(Key, Val, D) -&gt;
    update(Key, fun (Old) -&gt; Old ++ [Val] end, [Val], D).</code></pre><h3>update_counter/3</h3><p>Increment a value in a dictionary.</p><p>Adds <strong><span class="anno">Increment</span></strong> to the value associated with
<strong><span class="anno">Key</span></strong>
and store this value. If <strong><span class="anno">Key</span></strong> is not present in
the dictionary, <strong><span class="anno">Increment</span></strong> is stored as
the first value.</p><p>This can be defined as follows, but is faster:</p><pre><code class="">
update_counter(Key, Incr, D) -&gt;
    update(Key, fun (Old) -&gt; Old + Incr end, Incr, D).</code></pre><h3>Notes</h3><a name="notes"></a><p>Functions <strong>append/3</strong> and <strong>append_list/3</strong> are included
so that keyed values can be stored in a list <em>accumulator</em>, for
example:</p><pre>
&gt; D0 = orddict:new(),
  D1 = orddict:store(files, [], D0),
  D2 = orddict:append(files, f1, D1),
  D3 = orddict:append(files, f2, D2),
  D4 = orddict:append(files, f3, D3),
  orddict:fetch(files, D4).
[f1,f2,f3]</pre><p>This saves the trouble of first fetching a keyed value,
appending a new value to the list of stored values, and storing
the result.</p><p>Function <strong>fetch/2</strong> is to be used if the key is known to
be in the dictionary, otherwise function <strong>find/2</strong>.</p><h3>See Also</h3><p><a href="dict">dict</a>,
<a href="gb_trees">gb_trees</a></p><h2>ordsets</h2><p>Functions for manipulating sets as ordered lists.
</p><p>Sets are collections of elements with no duplicate elements.
An <strong>ordset</strong> is a representation of a set, where an ordered
list is used to store the elements of the set. An ordered list
is more efficient than an unordered list. Elements are ordered
according to the <em>Erlang term order</em>.This module provides the same interface as the
<a href="sets">sets</a> module
but with a defined representation. One difference is
that while <strong>sets</strong> considers two elements as different if they
do not match (<strong>=:=</strong>), this module considers two elements as
different if and only if they do not compare equal (<strong>==</strong>).</p><h2>Data Types</h2><span class="name">ordset</span><p>As returned by
<a href="#new/0">new/0</a>.</p><h2>Functions</h2><h3>add_element/2</h3><p>Add an element to an <strong>Ordset</strong>.</p><p>Returns a new ordered set formed from <strong><span class="anno">Ordset1</span></strong>
with <strong><span class="anno">Element</span></strong> inserted.</p><h3>del_element/2</h3><p>Remove an element from an <strong>Ordset</strong>.</p><p>Returns <strong><span class="anno">Ordset1</span></strong>, but with
<strong><span class="anno">Element</span></strong> removed.</p><h3>filter/2</h3><p>Filter set elements.</p><p>Filters elements in <strong><span class="anno">Ordset1</span></strong> with boolean function
<strong><span class="anno">Pred</span></strong>.</p><h3>fold/3</h3><p>Fold over set elements.</p><p>Folds <strong><span class="anno">Function</span></strong> over every element in
<strong><span class="anno">Ordset</span></strong> and returns the final value of the
accumulator.</p><h3>from_list/1</h3><p>Convert a list into an <strong>Ordset</strong>.</p><p>Returns an ordered set of the elements in <strong><span class="anno">List</span></strong>.
</p><h3>intersection/1</h3><p>Return the intersection of a list of <strong>Ordsets</strong></p><p>Returns the intersection of the non-empty list of sets.</p><h3>intersection/2</h3><p>Return the intersection of two <strong>Ordsets</strong>.</p><p>Returns the intersection of <strong><span class="anno">Ordset1</span></strong> and
<strong><span class="anno">Ordset2</span></strong>.</p><h3>is_disjoint/2</h3><p>Check whether two <strong>Ordsets</strong> are disjoint.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Ordset1</span></strong> and
<strong><span class="anno">Ordset2</span></strong> are disjoint (have no elements in common),
otherwise <strong>false</strong>.</p><h3>is_element/2</h3><p>Test for membership of an <strong>Ordset</strong>.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Element</span></strong> is an element of
<strong><span class="anno">Ordset</span></strong>, otherwise <strong>false</strong>.</p><h3>is_empty/1</h3><p>Test for empty set.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Ordset</span></strong> is an empty set,
otherwise <strong>false</strong>.</p><h3>is_set/1</h3><p>Test for an <strong>Ordset</strong>.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Ordset</span></strong> is an ordered set
of elements, otherwise <strong>false</strong>.</p><h3>is_subset/2</h3><p>Test for subset.</p><p>Returns <strong>true</strong> when every element of <strong><span class="anno">Ordset1</span></strong>
is also a member of <strong><span class="anno">Ordset2</span></strong>, otherwise
<strong>false</strong>.</p><h3>new/0</h3><p>Return an empty set.</p><p>Returns a new empty ordered set.</p><h3>size/1</h3><p>Return the number of elements in a set.</p><p>Returns the number of elements in <strong><span class="anno">Ordset</span></strong>.</p><h3>subtract/2</h3><p>Return the difference of two <strong>Ordsets</strong>.</p><p>Returns only the elements of <strong><span class="anno">Ordset1</span></strong> that are not
also elements of <strong><span class="anno">Ordset2</span></strong>.</p><h3>to_list/1</h3><p>Convert an <strong>Ordset</strong> into a list.</p><p>Returns the elements of <strong><span class="anno">Ordset</span></strong> as a list.</p><h3>union/1</h3><p>Return the union of a list of <strong>Ordsets</strong>.</p><p>Returns the merged (union) set of the list of sets.</p><h3>union/2</h3><p>Return the union of two <strong>Ordsets</strong>.</p><p>Returns the merged (union) set of <strong><span class="anno">Ordset1</span></strong> and
<strong><span class="anno">Ordset2</span></strong>.</p><h3>See Also</h3><p><a href="gb_sets">gb_sets</a>,
<a href="sets">sets</a></p><h2>pool</h2><p>Load distribution facility.</p><p>This module can be used to run a set of Erlang nodes as a pool
of computational processors. It is organized as a master and a
set of slave nodes and includes the following features:<ul><li>The slave nodes send regular reports to the master about their current load.</li><li>Queries can be sent to the master to determine which node will have the least load.</li></ul>The BIF <strong>statistics(run_queue)</strong> is used for estimating
future loads. It returns the length of the queue of ready to run
processes in the Erlang runtime system.The slave nodes are started with the
<a href="slave">slave</a> module. This
effects terminal I/O, file I/O, and code loading.If the master node fails, the entire pool exits.</p><h2>Functions</h2><h3>attach/1</h3><p>Ensure that a pool master is running.</p><p>Ensures that a pool master is running and includes
<strong><span class="anno">Node</span></strong> in the pool master's pool of nodes.</p><h3>get_node/0</h3><p>Return the node with the expected lowest future load.</p><p>Returns the node with the expected lowest future load.</p><h3>get_nodes/0</h3><p>Return a list of the current member nodes of the pool. </p><p>Returns a list of the current member nodes of the pool.</p><h3>pspawn/3</h3><p>Spawn a process on the pool node with expected lowest future load.</p><p>Spawns a process on the pool node that is expected to have
the lowest future load.</p><h3>pspawn_link/3</h3><p>Spawn and link to a process on the pool node with expected lowest future load.</p><p>Spawns and links to a process on the pool node that is expected to
have the lowest future load.</p><h3>start/1</h3><h3>start/2</h3><p>&gt;Start a new pool.</p><p>Starts a new pool. The file <strong>.hosts.erlang</strong> is read to
find host names where the pool nodes can be started; see
section <a href="#files">Files</a>. The
startup procedure fails if the file is not found.</p><p>The slave nodes are started with
<a href="./slave#start/2">slave#start/2</a>,
passing along <strong><span class="anno">Name</span></strong> and, if provided,
<strong><span class="anno">Args</span></strong>. <strong><span class="anno">Name</span></strong> is used as the
first part of the node names, <strong><span class="anno">Args</span></strong> is used to
specify command-line arguments.</p><p>Access rights must be set so that all nodes in the pool have
the authority to access each other.</p><p>The function is synchronous and all the nodes, and
all the system servers, are running when it returns a value.</p><h3>stop/0</h3><p>Stop the pool and kill all the slave nodes.</p><p>Stops the pool and kills all the slave nodes.</p><a name="files"></a><h3>Files</h3><p><strong>.hosts.erlang</strong> is used to pick hosts where nodes can
be started. For information about format and location of this file, see
<a href="../kernel/net_adm#host_file/0">kernel/net_adm#host_file/0</a>.</p><p><strong>$HOME/.erlang.slave.out.HOST</strong> is used for all extra I/O
that can come from the slave nodes on standard I/O. If the startup
procedure does not work, this file can indicate the reason.</p><h2>proc_lib</h2><p>Functions for asynchronous and synchronous start of processes
    adhering to the OTP design principles.</p><p>This module is used to start processes adhering to
the <a href="./des_princ"> OTP Design Principles</a>. Specifically, the functions in this
module are used by the OTP standard behaviors (for example,
<strong>gen_server</strong> and <strong>gen_statem</strong>)
when starting new processes. The functions
can also be used to start <em>special processes</em>, user-defined
processes that comply to the OTP design principles. For an example,
see section <a href="./spec_proc"> sys and proc_lib</a> in OTP Design Principles.Some useful information is initialized when a process starts.
The registered names, or the process identifiers, of the parent
process, and the parent ancestors, are stored together with
information about the function initially called in the process.While in "plain Erlang", a process is said to terminate normally
only for exit reason <strong>normal</strong>, a process started
using <strong>proc_lib</strong> is also said to terminate normally if it
exits with reason <strong>shutdown</strong> or <strong>{shutdown,Term}</strong>.
<strong>shutdown</strong> is the reason used when
an application (supervision tree) is stopped.When a process that is started using <strong>proc_lib</strong> terminates
abnormally (that is, with another exit reason than <strong>normal</strong>,
<strong>shutdown</strong>, or <strong>{shutdown,Term}</strong>), a <em>crash report</em>
is generated, which is written to terminal by the default logger
handler setup by Kernel. For more information about how crash reports
were logged prior to Erlang/OTP 21.0, see
<a href="./error_logging">SASL Error Logging</a>
in the SASL User's Guide.Unlike in "plain Erlang", <strong>proc_lib</strong> processes will not generate
<em>error reports</em>, which are written to the terminal by the
emulator. All exceptions are
converted to <em>exits</em> which are ignored by the default
<strong>logger</strong> handler.The crash report contains the previously stored information, such
as ancestors and initial function, the termination reason, and
information about other processes that terminate as a result
of this process terminating.</p><h2>Data Types</h2><span class="name">spawn_option</span><p>See <a href="../erts/erlang#spawn_opt/4">erts/erlang#spawn_opt/4</a>.</p><span class="name">priority_level</span><span class="name">max_heap_size</span><p>See <a href="../erts/erlang#process_flag_max_heap_size"> erlang:process_flag(max_heap_size, MaxHeapSize)</a>.</p><span class="name">dict_or_pid</span><h2>Functions</h2><h3>format/1</h3><p>Format a crash report.</p><p>Equivalent to <a href="#format/2">format/2</a>.</p><h3>format/2</h3><p>Format a crash report.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is deprecated in the sense that
the <strong>error_logger</strong> is no longer the preferred
interface for logging in Erlang/OTP. A
new <a href="./logger_chapter">logging API</a> was added in Erlang/OTP 21.0, but
legacy <strong>error_logger</strong> handlers can still be used. New
Logger handlers do not need to use this function, since
the formatting callback (<strong>report_cb</strong>) is included as
metadata in the log event.</p></div><p>This function can be used by a user-defined legacy
<strong>error_logger</strong> event handler to
format a crash report. The crash report is sent using
<a href="./logger">kernel/logger</a>, and the event to be handled is of the format
<strong>{error_report, GL, {Pid, crash_report, <span class="anno">CrashReport</span>}}</strong>,
where <strong>GL</strong> is the group leader pid of process
<strong>Pid</strong> that sent the crash report.</p><h3>format/3</h3><p>Format a crash report.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is deprecated in the sense that
the <strong>error_logger</strong> is no longer the preferred
interface for logging in Erlang/OTP. A
new <a href="./logger_chapter">logging API</a> was added in Erlang/OTP 21.0, but
legacy <strong>error_logger</strong> handlers can still be used. New
Logger handlers do not need to used this function, since
the formatting callback (<strong>report_cb</strong>) is included as
metadata in the log event.</p></div><p>This function can be used by a user-defined legacy
<strong>error_logger</strong> event handler to
format a crash report. When <span class="anno">Depth</span> is specified as a
positive integer, it is used in the format string to
limit the output as follows: <strong>io_lib:format("~P", [Term,<span class="anno">Depth</span>])</strong>.</p><h3>hibernate/3</h3><p>Hibernate a process until a message is sent to it.</p><p>This function does the same as (and does call) the
<a href="../erts/erlang#hibernate/3">erts/erlang#hibernate/3</a> BIF,
but ensures that exception handling and logging continues to
work as expected when the process wakes up.</p><p>Always use this function instead of the BIF for processes started
using <strong>proc_lib</strong> functions.</p><h3>init_ack/1</h3><h3>init_ack/2</h3><p>Used by a process when it has started.</p><p>This function must be used by a process that has been started by
a <a href="#start/3">start/3</a>
function. It tells <strong><span class="anno">Parent</span></strong> that the process has
initialized itself, has started, or has failed to initialize
itself.</p><p>Function <strong>init_ack/1</strong> uses the parent value
previously stored by the start function used.</p><p>If this function is not called, the start function
returns an error tuple (if a link and/or a time-out is used) or
hang otherwise.</p><p>The following example illustrates how this function and
<strong>proc_lib:start_link/3</strong> are used:</p><pre><code class="">
-module(my_proc).
-export([start_link/0]).
-export([init/1]).

start_link() -&gt;
    proc_lib:start_link(my_proc, init, [self()]).

init(Parent) -&gt;
    case do_initialization() of
        ok -&gt;
            proc_lib:init_ack(Parent, {ok, self()});
        {error, Reason} -&gt;
            exit(Reason)
    end,
    loop().

...</code></pre><h3>initial_call/1</h3><p>Extract the initial call of a <strong>proc_lib</strong>spawned process. </p><p>Extracts the initial call of a process that was started
using one of the spawn or start functions in this module.
<strong><span class="anno">Process</span></strong> can either be a pid, an integer tuple
(from which a pid can be created), or the process information of a
process <strong>Pid</strong> fetched through an
<strong>erlang:process_info(Pid)</strong> function call.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The list <strong><span class="anno">Args</span></strong> no longer contains the
arguments, but the same number of atoms as the number of arguments;
the first atom is <strong>'Argument__1'</strong>, the second
<strong>'Argument__2'</strong>, and so on. The reason is that the argument
list could waste a significant amount of memory, and if the
argument list contained funs, it could be impossible to upgrade the
code for the module.</p><p>If the process was spawned using a fun, <strong>initial_call/1</strong> no
longer returns the fun, but the module, function for the
local function implementing the fun, and the arity, for example,
<strong>{some_module,-work/3-fun-0-,0}</strong> (meaning that the fun was
created in function <strong>some_module:work/3</strong>). The reason is that
keeping the fun would prevent code upgrade for the module, and that
a significant amount of memory could be wasted.</p></div><h3>spawn/1</h3><h3>spawn/2</h3><h3>spawn/3</h3><h3>spawn/4</h3><p>Spawn a new process.</p><ul><li>Node</li></ul><ul><li>Fun</li></ul><ul><li>Module</li></ul><ul><li>Function</li></ul><ul><li>Args</li></ul><p>Spawns a new process and initializes it as described in the
beginning of this manual page. The process is spawned using the
<a href="../erts/erlang#spawn/1">erts/erlang#spawn/1</a> BIFs.</p><h3>spawn_link/1</h3><h3>spawn_link/2</h3><h3>spawn_link/3</h3><h3>spawn_link/4</h3><p>Spawn and link to a new process.</p><ul><li>Node</li></ul><ul><li>Fun</li></ul><ul><li>Module</li></ul><ul><li>Function</li></ul><ul><li>Args</li></ul><p>Spawns a new process and initializes it as described in the
beginning of this manual page. The process is spawned using the
<a href="../erts/erlang#spawn_link/1">erts/erlang#spawn_link/1</a>
BIFs.</p><h3>spawn_opt/2</h3><h3>spawn_opt/3</h3><h3>spawn_opt/4</h3><h3>spawn_opt/5</h3><p>Spawn a new process with specified options.</p><ul><li>Node</li></ul><ul><li>Fun</li></ul><ul><li>Module</li></ul><ul><li>Function</li></ul><ul><li>Args</li></ul><ul><li>SpawnOpts</li></ul><p>Spawns a new process and initializes it as described in the
beginning of this manual page. The process is spawned using the
<a href="../erts/erlang#spawn_opt/2">erts/erlang#spawn_opt/2</a>
BIFs.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Using spawn option <strong>monitor</strong> is not
allowed. It causes the function to fail with reason
<strong>badarg</strong>.</p></div><h3>start/3</h3><h3>start/4</h3><h3>start/5</h3><h3>start_link/3</h3><h3>start_link/4</h3><h3>start_link/5</h3><p>Start a new process synchronously.</p><p>Starts a new process synchronously. Spawns the process and
waits for it to start. When the process has started, it
<em>must</em> call
<a href="#init_ack/2">init_ack/2</a>
or <a href="#init_ack/1">init_ack/1</a>,
where <strong>Parent</strong> is the process that evaluates this
function. At this time, <strong>Ret</strong> is returned.</p><p>If function <strong>start_link/3,4,5</strong> is used and
the process crashes before it has called <strong>init_ack/1,2</strong>,
<strong>{error, <span class="anno">Reason</span>}</strong> is returned if the calling
process traps exits.</p><p>If <strong><span class="anno">Time</span></strong> is specified as an integer, this
function waits for <strong><span class="anno">Time</span></strong> milliseconds for the
new process to call <strong>init_ack</strong>, or <strong>{error, timeout}</strong> is
returned, and the process is killed.</p><p>Argument <strong><span class="anno">SpawnOpts</span></strong>, if specified, is passed
as the last argument to the <a href="../erts/erlang#spawn_opt/2">erts/erlang#spawn_opt/2</a> BIF.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Using spawn option <strong>monitor</strong> is not
allowed. It causes the function to fail with reason
<strong>badarg</strong>.</p></div><h3>stop/1</h3><p>Terminate a process synchronously.</p><ul><li>Process</li></ul><p>Equivalent to <a href="#stop/3">stop/3</a>.</p><h3>stop/3</h3><p>Terminate a process synchronously.</p><ul><li>Process</li></ul><ul><li>Reason</li></ul><ul><li>Timeout</li></ul><p>Orders the process to exit with the specified <strong>Reason</strong> and
waits for it to terminate.</p><p>Returns <strong>ok</strong> if the process exits with
the specified <strong>Reason</strong> within <strong>Timeout</strong> milliseconds.</p><p>If the call times out, a <strong>timeout</strong> exception is raised.</p><p>If the process does not exist, a <strong>noproc</strong>
exception is raised.</p><p>The implementation of this function is based on the
<strong>terminate</strong> system message, and requires that the
process handles system messages correctly.
For information about system messages, see
<a href="sys">sys</a> and section
<a href="./spec_proc"> sys and proc_lib</a> in OTP Design Principles.</p><h3>translate_initial_call/1</h3><p>Extract and translate the initial call of a <strong>proc_lib</strong>spawned process.</p><p>This function is used by functions
<a href="./c#i/0">c#i/0</a> and
<a href="./c#regs/0">c#regs/0</a>
to present process information.</p><p>This function extracts the initial call of a process that was
started using one of the spawn or start functions in this module,
and translates it to more useful information.
<strong><span class="anno">Process</span></strong>
can either be a pid, an integer tuple (from which a pid can
be created), or the process information of a process
<strong>Pid</strong> fetched through an <strong>erlang:process_info(Pid)</strong>
function call.</p><p>If the initial call is to one of the system-defined behaviors
such as <strong>gen_server</strong> or <strong>gen_event</strong>, it is
translated to more useful information. If a <strong>gen_server</strong>
is spawned, the returned <strong><span class="anno">Module</span></strong> is the name of
the callback module and <strong><span class="anno">Function</span></strong> is <strong>init</strong>
(the function that initiates the new server).</p><p>A <strong>supervisor</strong> and a <strong>supervisor_bridge</strong> are also
<strong>gen_server</strong> processes. To return information
that this process is a supervisor and the name of the
callback module, <strong><span class="anno">Module</span></strong> is <strong>supervisor</strong> and
<strong><span class="anno">Function</span></strong> is the name of the supervisor callback
module. <strong><span class="anno">Arity</span></strong> is <strong>1</strong>, as the <strong>init/1</strong>
function is called initially in the callback module.</p><p>By default, <strong>{proc_lib,init_p,5}</strong> is returned if no
information about the initial call can be found. It is
assumed that the caller knows that the process has been
spawned with the <strong>proc_lib</strong> module.</p><h3>See Also</h3><p><a href="./error_logger">kernel/error_logger</a></p><p><a href="./logger">kernel/logger</a></p><h2>proplists</h2><p>Support functions for property lists.</p><p>Property lists are ordinary lists containing entries in the form
of either tuples, whose first elements are keys used for lookup and
insertion, or atoms, which work as shorthand for tuples
<strong>{Atom, true}</strong>. (Other terms are allowed in the lists, but are
ignored by this module.) If there is more than one entry in a list for a
certain key, the first occurrence normally overrides any later
(irrespective of the arity of the tuples).Property lists are useful for representing inherited properties,
such as options passed to a function where a user can specify options
overriding the default settings, object properties, annotations,
and so on.Two keys are considered equal if they match (<strong>=:=</strong>). That is,
numbers are compared literally rather than by value, so that,
for example, <strong>1</strong> and <strong>1.0</strong> are different keys.</p><h2>Data Types</h2><span class="name">property</span><span class="name">proplist</span><h2>Functions</h2><h3>append_values/2</h3><p>Similar to
<a href="#get_all_values/2">get_all_values/2</a>,
but each value is wrapped in a list unless it is already itself a
list. The resulting list of lists is concatenated. This is often
useful for "incremental" options.</p><p><em>Example:</em></p><pre><code class="">
append_values(a, [{a, [1,2]}, {b, 0}, {a, 3}, {c, -1}, {a, [4]}])</code></pre><p>returns:</p><pre><code class="">
[1,2,3,4]</code></pre><h3>compact/1</h3><p>Minimizes the representation of all entries in the list. This is
equivalent to <strong>[property(P) || P &lt;- ListIn]</strong>.</p><p>See also
<a href="#property/1">property/1</a>,
<a href="#unfold/1">unfold/1</a>.</p><h3>delete/2</h3><p>Deletes all entries associated with <strong><span class="anno">Key</span></strong> from
<strong><span class="anno">List</span></strong>.</p><h3>expand/2</h3><p>Expands particular properties to corresponding sets of
properties (or other terms). For each pair <strong>{<span class="anno">Property</span>, <span class="anno">Expansion</span>}</strong> in <strong><span class="anno">Expansions</span></strong>: if
<strong>E</strong> is the first entry in <strong><span class="anno">ListIn</span></strong> with the
same key as <strong><span class="anno">Property</span></strong>, and <strong>E</strong> and
<strong><span class="anno">Property</span></strong> have equivalent normal forms, then
<strong>E</strong> is replaced with the terms in <strong><span class="anno">Expansion</span></strong>,
and any following entries with the same key are deleted from
<strong><span class="anno">ListIn</span></strong>.</p><p>For example, the following expressions all return
<strong>[fie, bar, baz, fum]</strong>:</p><pre><code class="">
expand([{foo, [bar, baz]}], [fie, foo, fum])
expand([{{foo, true}, [bar, baz]}], [fie, foo, fum])
expand([{{foo, false}, [bar, baz]}], [fie, {foo, false}, fum])</code></pre><p>However, no expansion is done in the following call
because <strong>{foo, false}</strong> shadows <strong>foo</strong>:</p><pre><code class="">
expand([{{foo, true}, [bar, baz]}], [{foo, false}, fie, foo, fum])</code></pre><p>Notice that if the original property term is to be preserved in the
result when expanded, it must be included in the expansion list. The
inserted terms are not expanded recursively. If
<strong><span class="anno">Expansions</span></strong> contains more than one property with
the same key, only the first occurrence is used.</p><p>See also
<a href="#normalize/2">normalize/2</a>.</p><h3>get_all_values/2</h3><p>Similar to 
<a href="#get_value/2">get_value/2</a>,
but returns the list of values for <em>all</em> entries
<strong>{Key, Value}</strong> in <strong><span class="anno">List</span></strong>. If no such entry
exists, the result is the empty list.</p><h3>get_bool/2</h3><p>Returns the value of a boolean key/value option. If
<strong>lookup(<span class="anno">Key</span>, <span class="anno">List</span>)</strong> would yield
<strong>{<span class="anno">Key</span>, true}</strong>, this function returns <strong>true</strong>,
otherwise <strong>false</strong>.</p><p>See also
<a href="#get_value/2">get_value/2</a>,
<a href="#lookup/2">lookup/2</a>.</p><h3>get_keys/1</h3><p>Returns an unordered list of the keys used in
<strong><span class="anno">List</span></strong>, not containing duplicates.</p><h3>get_value/2</h3><p>Equivalent to
<strong>get_value(<span class="anno">Key</span>, <span class="anno">List</span>, undefined)</strong>.</p><h3>get_value/3</h3><p>Returns the value of a simple key/value property in
<strong><span class="anno">List</span></strong>. If <strong>lookup(<span class="anno">Key</span>, <span class="anno">List</span>)</strong> would yield <strong>{<span class="anno">Key</span>, Value}</strong>,
this function returns the corresponding <strong>Value</strong>, otherwise
<strong><span class="anno">Default</span></strong>.</p><p>See also
<a href="#get_all_values/2">get_all_values/2</a>,
<a href="#get_bool/2">get_bool/2</a>,
<a href="#get_value/2">get_value/2</a>,
<a href="#lookup/2">lookup/2</a>.</p><h3>is_defined/2</h3><p>Returns <strong>true</strong> if <strong><span class="anno">List</span></strong> contains at least
one entry associated with <strong><span class="anno">Key</span></strong>, otherwise
<strong>false</strong>.</p><h3>lookup/2</h3><p>Returns the first entry associated with <strong><span class="anno">Key</span></strong> in
<strong><span class="anno">List</span></strong>, if one exists, otherwise returns
<strong>none</strong>. For an atom <strong>A</strong> in the list, the tuple
<strong>{A, true}</strong> is the entry associated with <strong>A</strong>.</p><p>See also
<a href="#get_bool/2">get_bool/2</a>,
<a href="#get_value/2">get_value/2</a>,
<a href="#lookup_all/2">lookup_all/2</a>.</p><h3>lookup_all/2</h3><p>Returns the list of all entries associated with
<strong><span class="anno">Key</span></strong> in <strong><span class="anno">List</span></strong>. If no such entry
exists, the result is the empty list.</p><p>See also
<a href="#lookup/2">lookup/2</a>.</p><h3>normalize/2</h3><p>Passes <strong><span class="anno">ListIn</span></strong> through a sequence of
substitution/expansion stages. For an <strong>aliases</strong> operation,
function <a href="#substitute_aliases/2">substitute_aliases/2</a> is applied using the
specified list of aliases:</p><ul><li> <p>For a <strong>negations</strong> operation, <strong>substitute_negations/2</strong>
is applied using the specified negation list.</p> </li><li> <p>For an <strong>expand</strong> operation, function
<a href="#expand/2">expand/2</a>
is applied using the specified list of expansions.</p> </li></ul><p>The final result is automatically compacted (compare
<a href="#compact/1">compact/1</a>).</p><p>Typically you want to substitute negations first, then aliases,
then perform one or more expansions (sometimes you want to pre-expand
particular entries before doing the main expansion). You might want
to substitute negations and/or aliases repeatedly, to allow such
forms in the right-hand side of aliases and expansion lists.</p><p>See also <a href="#substitute_negations/2">substitute_negations/2</a>.</p><h3>property/1</h3><p>Creates a normal form (minimal) representation of a property. If
<strong><span class="anno">PropertyIn</span></strong> is <strong>{Key, true}</strong>, where
<strong>Key</strong> is an atom, <strong>Key</strong> is returned, otherwise
the whole term <strong><span class="anno">PropertyIn</span></strong> is returned.</p><p>See also
<a href="#property/2">property/2</a>.</p><h3>property/2</h3><p>Creates a normal form (minimal) representation of a simple key/value
property. Returns <strong><span class="anno">Key</span></strong> if <strong><span class="anno">Value</span></strong>
is <strong>true</strong> and <strong><span class="anno">Key</span></strong> is an atom, otherwise a
tuple <strong>{<span class="anno">Key</span>, <span class="anno">Value</span>}</strong> is returned.</p><p>See also
<a href="#property/1">property/1</a>.</p><h3>split/2</h3><p>Partitions <strong><span class="anno">List</span></strong> into a list of sublists and a
remainder. <strong><span class="anno">Lists</span></strong> contains one sublist for each key
in <strong><span class="anno">Keys</span></strong>, in the corresponding order. The relative
order of the elements in each sublist is preserved from the original
<strong><span class="anno">List</span></strong>. <strong><span class="anno">Rest</span></strong> contains the
elements in <strong><span class="anno">List</span></strong> that are not associated with any
of the specified keys,
also with their original relative order preserved.</p><p><em>Example:</em></p><pre><code class="">
split([{c, 2}, {e, 1}, a, {c, 3, 4}, d, {b, 5}, b], [a, b, c])</code></pre><p>returns:</p><pre><code class="">
{[[a], [{b, 5}, b],[{c, 2}, {c, 3, 4}]], [{e, 1}, d]}</code></pre><h3>substitute_aliases/2</h3><p>Substitutes keys of properties. For each entry in
<strong><span class="anno">ListIn</span></strong>, if it is associated with some key
<strong>K1</strong> such that <strong>{K1, K2}</strong> occurs in
<strong><span class="anno">Aliases</span></strong>, the
key of the entry is changed to <strong>K2</strong>. If the same
<strong>K1</strong> occurs more than once in <strong><span class="anno">Aliases</span></strong>, only
the first occurrence is used.</p><p>For example, <strong>substitute_aliases([{color, colour}], L)</strong>
replaces all tuples <strong>{color, ...}</strong> in <strong>L</strong>
with <strong>{colour, ...}</strong>, and all atoms <strong>color</strong>
with <strong>colour</strong>.</p><p>See also
<a href="#normalize/2">normalize/2</a>,
<a href="#substitute_negations/2">substitute_negations/2</a>.</p><h3>substitute_negations/2</h3><p>Substitutes keys of boolean-valued properties and
simultaneously negates their values. For each entry in
<strong><span class="anno">ListIn</span></strong>, if it is associated with some key
<strong>K1</strong> such that <strong>{K1, K2}</strong> occurs in
<strong><span class="anno">Negations</span></strong>: if the entry was
<strong>{K1, true}</strong>, it is replaced with <strong>{K2, false}</strong>, otherwise
with <strong>{K2, true}</strong>, thus changing the name of the option and
simultaneously negating the value specified by
<a href="#get_bool/2">get_bool/2</a>.
If the same <strong>K1</strong> occurs more than once in
<strong><span class="anno">Negations</span></strong>, only the first occurrence is used.</p><p>For example, <strong>substitute_negations([{no_foo, foo}], L)</strong>
replaces any atom <strong>no_foo</strong> or tuple
<strong>{no_foo, true}</strong> in <strong>L</strong> with <strong>{foo, false}</strong>,
and any other tuple <strong>{no_foo, ...}</strong> with <strong>{foo, true}</strong>.</p><p>See also
<a href="#get_bool/2">get_bool/2</a>,
<a href="#normalize/2">normalize/2</a>,
<a href="#substitute_aliases/2">substitute_aliases/2</a>.</p><h3>unfold/1</h3><p>Unfolds all occurrences of atoms in <strong><span class="anno">ListIn</span></strong> to
tuples <strong>{Atom, true}</strong>.</p><h2>qlc</h2><p>Query interface to Mnesia, ETS, Dets, and so on.
</p><p>This module provides a query interface to
<a href="./mnesia">Mnesia</a>,
<a href="ets">ETS</a>,
<a href="dets">Dets</a>,
and other data structures that provide an iterator style
traversal of objects.</p><h3>Overview</h3><p>This module provides a query interface to <em>QLC tables</em>. Typical QLC tables are Mnesia, ETS, and
Dets tables. Support is also provided for user-defined tables, see section
<a href="#implementing_a_qlc_table"> Implementing a QLC Table</a>.
<a name="query_list_comprehension"></a>
A <em>query</em> is expressed using
<em>Query List Comprehensions</em> (QLCs). The answers to a
query are determined by data in QLC tables that fulfill the
constraints expressed by the QLCs of the query. QLCs are similar
to ordinary list comprehensions as described in
<a href="../doc/reference_manual/expressions#lcs"> Erlang Reference Manual</a> and
<a href="./list_comprehensions"> Programming Examples</a>, except that variables
introduced in patterns cannot be used in list expressions.
In the absence of optimizations and options such as
<strong>cache</strong> and <strong>unique</strong> (see section
<a href="#common_options">Common Options</a>, every
QLC free of QLC tables evaluates to the same list of answers as the
identical ordinary list comprehension.</p><p>While ordinary list comprehensions evaluate to lists, calling
<a href="#q/1">q/1</a> returns a
<a name="query_handle"></a><em>query handle</em>.
To obtain all the answers to a query, <a href="#eval/1">eval/1</a> is to be called with the
query handle as first argument. Query handles are essentially
functional objects (funs) created in the module calling <strong>q/1,2</strong>.
As the funs refer to the module code, be careful not to keep query
handles too long if the module code is to be replaced.
Code replacement is described in section
<a href="./code_loading"> Compilation and Code Loading</a> in the Erlang Reference Manual.
The list of answers can also be traversed in chunks by use of a
<a name="query_cursor"></a><em>query cursor</em>.
Query cursors are created by calling
<a href="#cursor/1">cursor/1</a> with a query
handle as first argument. Query cursors are essentially Erlang processes.
One answer at a time is sent from the query cursor process to
the process that created the cursor.</p><h3>Syntax</h3><p>Syntactically QLCs have the same parts as ordinary list
comprehensions:</p><pre><code class="">
[Expression || Qualifier1, Qualifier2, ...]</code></pre><p><strong>Expression</strong> (the <em>template</em>) is any
Erlang expression. Qualifiers are either <em>filters</em> or
<em>generators</em>. Filters are Erlang expressions returning
<strong>boolean()</strong>. Generators have the form
<strong>Pattern &lt;- ListExpression</strong>, where
<strong>ListExpression</strong> is an expression evaluating to a query
handle or a list. Query handles are returned from
<a href="#append/1">append/1</a>,
<a href="#keysort/2">keysort/2</a>,
<a href="#q/1">q/1</a>,
<a href="#sort/1">sort/1</a>,
<a href="#string_to_handle/1">string_to_handle/1</a>, and
<a href="#table/2">table/2</a>.</p><h3>Evaluation</h3><p>A query handle is evaluated in the following order:</p><ul><li> <p>Inspection of options and the collection of information about
tables. As a result, qualifiers are modified during the optimization
phase.</p> </li><li> <p>All list expressions are evaluated. If a cursor has been created,
evaluation takes place in the cursor process. For list expressions
that are QLCs, the list expressions of the generators of the QLCs
are evaluated as well. Be careful if list expressions have side
effects, as list expressions are evaluated in unspecified order.</p> </li><li> <p>The answers are found by evaluating the qualifiers from left to
right, backtracking when some filter returns <strong>false</strong>, or
collecting the template when all filters return <strong>true</strong>.</p> </li></ul><p>Filters that do not return <strong>boolean()</strong> but fail are handled
differently depending on their syntax: if the filter is a guard,
it returns <strong>false</strong>, otherwise the query evaluation fails.
This behavior makes it possible for the <strong>qlc</strong> module to do
some optimizations without affecting the meaning of a query. For
example, when testing some position of a table and one or more
constants for equality, only
the objects with equal values are candidates for further
evaluation. The other objects are guaranteed to make the filter
return <strong>false</strong>, but never fail. The (small) set of
candidate objects can often be found by looking up some key
values of the table or by traversing the table using a match
specification. It is necessary to place the guard filters
immediately after the table generator, otherwise the candidate
objects are not restricted to a small set. The reason is
that objects that could make the query evaluation fail must not
be excluded by looking up a key or running a match specification.</p><h3>Join</h3><p>The <strong>qlc</strong> module supports fast join of two query handles.
Fast join is possible if some position <strong>P1</strong> of one query
handler and some position <strong>P2</strong> of another query handler are
tested for equality. Two fast join methods are provided:</p><ul><li><p><em>Lookup join</em> traverses all objects of one query handle
and finds objects of the other handle (a QLC table) such that the
values at <strong>P1</strong> and <strong>P2</strong> match or compare equal.
The <strong>qlc</strong> module does not create
any indexes but looks up values using the key position and
the indexed positions of the QLC table.</p> </li><li><p><em>Merge join</em> sorts the objects of each query handle if
necessary and filters out objects where the values at
<strong>P1</strong> and <strong>P2</strong> do not compare equal. If
many objects with the same value of <strong>P2</strong> exist, a temporary
file is used for the equivalence classes.</p> </li></ul><p>The <strong>qlc</strong> module warns at compile time if a QLC
combines query handles in such a way that more than one join is
possible. That is, no query planner is provided that can
select a good order between possible join operations. It is up
to the user to order the joins by introducing query handles.</p><p>The join is to be expressed as a guard filter. The filter must
be placed immediately after the two joined generators, possibly
after guard filters that use variables from no other generators
but the two joined generators. The <strong>qlc</strong> module inspects
the operands of
<strong>=:=/2</strong>, <strong>==/2</strong>, <strong>is_record/2</strong>, <strong>element/2</strong>,
and logical operators (<strong>and/2</strong>, <strong>or/2</strong>,
<strong>andalso/2</strong>, <strong>orelse/2</strong>, <strong>xor/2</strong>) when
determining which joins to consider.</p><a name="common_options"></a><h3>Common Options</h3><p>The following options are accepted by
<a href="#cursor/2">cursor/2</a>,
<a href="#eval/2">eval/2</a>,
<a href="#fold/4">fold/4</a>, and
<a href="#info/2">info/2</a>:</p><ul><li><p><strong>{cache_all, Cache}</strong>, where <strong>Cache</strong> is
equal to <strong>ets</strong> or <strong>list</strong> adds a
<strong>{cache,Cache}</strong> option to every list expression
of the query except tables and lists. Defaults to
<strong>{cache_all,no}</strong>. Option <strong>cache_all</strong> is
equivalent to <strong>{cache_all,ets}</strong>.</p> </li><li><p><a name="max_list_size"></a><strong>{max_list_size, MaxListSize}</strong>, where <strong>MaxListSize</strong> is the
size in bytes of terms on the external format. If the
accumulated size of collected objects exceeds
<strong>MaxListSize</strong>, the objects are written onto a temporary
file. This option is used by option <strong>{cache,list}</strong>
and by the merge join method. Defaults to 512*1024 bytes.</p> </li><li><p><strong>{tmpdir_usage, TmpFileUsage}</strong> determines the
action taken when <strong>qlc</strong> is about to create temporary
files on the directory set by option <strong>tmpdir</strong>. If the
value is <strong>not_allowed</strong>, an error tuple is returned,
otherwise temporary files are created as needed. Default is
<strong>allowed</strong>, which means that no further action is taken.
The values <strong>info_msg</strong>, <strong>warning_msg</strong>, and
<strong>error_msg</strong> mean that the function with the corresponding
name in module
<a href="./error_logger">kernel/error_logger</a>
is called for printing some information (currently the stacktrace).</p> </li><li><p><strong>{tmpdir, TempDirectory}</strong> sets the directory used by
merge join for temporary files and by option
<strong>{cache,list}</strong>. The option also overrides
option <strong>tmpdir</strong> of
<a href="#keysort/3">keysort/3</a> and
<a href="#sort/2">sort/2</a>.
Defaults to <strong>""</strong>, which means that
the directory returned by <strong>file:get_cwd()</strong> is used.</p> </li><li><p><strong>{unique_all, true}</strong> adds a
<strong>{unique,true}</strong> option to every list expression of
the query. Defaults to <strong>{unique_all,false}</strong>.
Option <strong>unique_all</strong> is equivalent to
<strong>{unique_all,true}</strong>.</p> </li></ul><a name="getting_started"></a><h3>Getting Started</h3><p>As mentioned earlier,
queries are expressed in the list comprehension syntax as described
in section
<a href="./expressions">Expressions</a>
in Erlang Reference Manual. In the following, some familiarity
with list comprehensions is assumed. The examples in section
<a href="./list_comprehensions"> List Comprehensions</a> in Programming Examples can get you
started. Notice that list comprehensions do not add any computational
power to the language; anything that can be done with list
comprehensions can also be done without them. But they add
syntax for expressing simple search problems, which is compact
and clear once you get used to it.</p><p>Many list comprehension expressions can be evaluated by the
<strong>qlc</strong> module. Exceptions are expressions, such that
variables introduced in patterns (or filters) are used in some
generator later in the list comprehension. As an example,
consider an implementation of <strong>lists:append(L)</strong>:
<strong>[X ||Y &lt;- L, X &lt;- Y]</strong>.
<strong>Y</strong> is introduced in the first generator and used in the second.
The ordinary list comprehension is normally to be preferred when
there is a choice as to which to use. One difference is that
<a href="#eval/1">eval/1</a>
collects answers in a list that is finally
reversed, while list comprehensions collect answers on the stack
that is finally unwound.</p><p>What the <strong>qlc</strong> module primarily adds to list
comprehensions is that data can be read from QLC tables in small
chunks. A QLC table is created by calling
<a href="#table/2">table/2</a>.
Usually <strong>qlc:table/2</strong> is not called directly from the query
but through an interface function of some data structure.
Erlang/OTP includes a few examples of such functions:
<a href="../mnesia/mnesia#table/1">mnesia/mnesia#table/1</a>,
<a href="./ets#table/1">ets#table/1</a>, and
<a href="./dets#table/1">dets#table/1</a>.
For a given data structure, many functions can create QLC tables, but
common for these functions is that they return a query handle created by
<a href="#table/2">table/2</a>.
Using the QLC tables provided by Erlang/OTP is usually
probably sufficient, but for the more advanced user section
<a href="#implementing_a_qlc_table">Implementing a QLC Table</a> describes the implementation of a function
calling <strong>qlc:table/2</strong>.</p><p>Besides <strong>qlc:table/2</strong>, other functions
return query handles. They are used more seldom than tables,
but are sometimes useful.
<a href="#append/1">append/1</a> traverses
objects from many tables or lists after each other. If, for
example, you want to traverse all answers to a query <strong>QH</strong> and
then finish off by a term <strong>{finished}</strong>, you can do that by
calling <strong>qlc:append(QH, [{finished}])</strong>. <strong>append/2</strong> first
returns all objects of <strong>QH</strong>, then <strong>{finished}</strong>. If a tuple
<strong>{finished}</strong> exists among the answers to <strong>QH</strong>, it is
returned twice from <strong>append/2</strong>.</p><p>As another example, consider concatenating the answers to two
queries <strong>QH1</strong> and <strong>QH2</strong> while removing all duplicates. This is
accomplished by using option <strong>unique</strong>:</p><pre><code class="">
qlc:q([X || X &lt;- qlc:append(QH1, QH2)], {unique, true})</code></pre><p>The cost is substantial: every returned answer is stored
in an ETS table. Before returning an answer, it is looked up in
the ETS table to check if it has already been returned. Without
the <strong>unique</strong> option, all answers to <strong>QH1</strong> would be returned
followed by all answers to <strong>QH2</strong>. The <strong>unique</strong> option keeps
the order between the remaining answers.</p><p>If the order of the answers is not important, there is an
alternative to the <strong>unique</strong> option, namely to sort the
answers uniquely:</p><pre><code class="">
qlc:sort(qlc:q([X || X &lt;- qlc:append(QH1, QH2)], {unique, true})).</code></pre><p>This query also removes duplicates but the answers are
sorted. If there are many answers, temporary files are used.
Notice that to get the first unique answer, all answers
must be found and sorted. Both alternatives find duplicates by comparing
answers, that is, if <strong>A1</strong> and <strong>A2</strong> are answers found in
that order, then <strong>A2</strong> is a removed if <strong>A1 == A2</strong>.</p><p>To return only a few answers, cursors can be used. The following
code returns no more than five answers using an ETS table for
storing the unique answers:</p><pre><code class="">
C = qlc:cursor(qlc:q([X || X &lt;- qlc:append(QH1, QH2)],{unique,true})),
R = qlc:next_answers(C, 5),
ok = qlc:delete_cursor(C),
R.</code></pre><p>QLCs are convenient for stating
constraints on data from two or more tables. The following example
does a natural join on two query handles on position 2:</p><pre><code class="">
qlc:q([{X1,X2,X3,Y1} || 
          {X1,X2,X3} &lt;- QH1, 
          {Y1,Y2} &lt;- QH2, 
          X2 =:= Y2])</code></pre><p>The <strong>qlc</strong> module evaluates this differently depending on the
query handles <strong>QH1</strong> and <strong>QH2</strong>. If, for example, <strong>X2</strong> is
matched against the key of a QLC table, the lookup join method
traverses the objects of <strong>QH2</strong> while looking up key
values in the table. However, if not <strong>X2</strong> or
<strong>Y2</strong> is matched against the key or an indexed position of a
QLC table, the merge join method ensures that <strong>QH1</strong>
and <strong>QH2</strong> are both sorted on position 2 and next do the
join by traversing the objects one by one.</p><p>Option <strong>join</strong> can be used to force the <strong>qlc</strong> module to use
a certain join method. For the rest of this section it is assumed
that the excessively slow join method called "nested loop" has
been chosen:</p><pre><code class="">
qlc:q([{X1,X2,X3,Y1} || 
          {X1,X2,X3} &lt;- QH1, 
          {Y1,Y2} &lt;- QH2, 
          X2 =:= Y2],
      {join, nested_loop})</code></pre><p>In this case the filter is applied to every possible pair
of answers to <strong>QH1</strong> and <strong>QH2</strong>, one at a time.
If there are M answers to <strong>QH1</strong> and N answers to <strong>QH2</strong>,
the filter is run M*N times.</p><p>If <strong>QH2</strong> is a call to the function for
<a href="gb_trees">gb_trees</a>, as defined
in section <a href="#implementing_a_qlc_table">Implementing a QLC Table</a>, then <strong>gb_table:table/1</strong>, the
iterator for the gb-tree is initiated for each answer to
<strong>QH1</strong>. The objects of the gb-tree are then returned one
by one. This is probably the most efficient way of traversing
the table in that case, as it takes minimal computational
power to get the following object. But if <strong>QH2</strong> is not a table but
a more complicated QLC, it can be more efficient to use some RAM
memory for collecting the answers in a cache, particularly if
there are only a few answers. It must then be assumed that
evaluating <strong>QH2</strong> has no side effects so that the meaning of the
query does not change if <strong>QH2</strong> is evaluated only once. One way of
caching the answers is to evaluate <strong>QH2</strong> first of all and
substitute the list of answers for <strong>QH2</strong> in the query. Another way
is to use option <strong>cache</strong>. It is expressed like this:</p><pre><code class="">
QH2' = qlc:q([X || X &lt;- QH2], {cache, ets})</code></pre><p>or only</p><pre><code class="">
QH2' = qlc:q([X || X &lt;- QH2], cache)</code></pre><p>The effect of option <strong>cache</strong> is that when
generator <strong>QH2'</strong> is run the first time, every answer is stored in
an ETS table. When the next answer of <strong>QH1</strong> is tried,
answers to <strong>QH2'</strong>
are copied from the ETS table, which is very fast. As for
option <strong>unique</strong> the cost is a possibly substantial amount
of RAM memory.</p><p>Option <strong>{cache,list}</strong> offers the
possibility to store the answers in a list on the process heap.
This has the potential of being faster than ETS tables,
as there is no need to copy answers from the table. However, it can
often result in slower evaluation because of more garbage
collections of the process heap and increased RAM memory
consumption because of larger heaps. Another drawback with cache
lists is that if the list size exceeds a limit, a
temporary file is used. Reading the answers from a file is
much slower than copying them from an ETS table. But if the
available RAM memory is scarce, setting the <a href="#max_list_size">limit</a> to some low value is an
alternative.</p><p>Option <strong>cache_all</strong> can be set to
<strong>ets</strong> or <strong>list</strong> when evaluating a query. It adds a
<strong>cache</strong> or <strong>{cache,list}</strong> option to every list
expression except QLC tables and lists on all levels of the
query. This can be used for testing if caching would improve
efficiency at all. If the answer is yes, further testing is
needed to pinpoint the generators that are to be cached.</p><a name="implementing_a_qlc_table"></a><h3>Implementing a QLC Table</h3><p>As an example of
how to use function <a href="#table/2">table/2</a>,
the implementation of a QLC table for the <a href="gb_trees">gb_trees</a> module is given:</p><pre><code class="">
-module(gb_table).

-export([table/1]).

table(T) -&gt;
    TF = fun() -&gt; qlc_next(gb_trees:next(gb_trees:iterator(T))) end,
    InfoFun = fun(num_of_objects) -&gt; gb_trees:size(T);
                 (keypos) -&gt; 1;
                 (is_sorted_key) -&gt; true;
                 (is_unique_objects) -&gt; true;
                 (_) -&gt; undefined
              end,
    LookupFun =
        fun(1, Ks) -&gt;
                lists:flatmap(fun(K) -&gt;
                                      case gb_trees:lookup(K, T) of
                                          {value, V} -&gt; [{K,V}];
                                          none -&gt; []
                                      end
                              end, Ks)
        end,
    FormatFun =
        fun({all, NElements, ElementFun}) -&gt;
                ValsS = io_lib:format("gb_trees:from_orddict(~w)",
                                      [gb_nodes(T, NElements, ElementFun)]),
                io_lib:format("gb_table:table(~s)", [ValsS]);
           ({lookup, 1, KeyValues, _NElements, ElementFun}) -&gt;
                ValsS = io_lib:format("gb_trees:from_orddict(~w)",
                                      [gb_nodes(T, infinity, ElementFun)]),
                io_lib:format("lists:flatmap(fun(K) -&gt; "
                              "case gb_trees:lookup(K, ~s) of "
                              "{value, V} -&gt; [{K,V}];none -&gt; [] end "
                              "end, ~w)",
                              [ValsS, [ElementFun(KV) || KV &lt;- KeyValues]])
        end,
    qlc:table(TF, [{info_fun, InfoFun}, {format_fun, FormatFun},
                   {lookup_fun, LookupFun},{key_equality,'=='}]).

qlc_next({X, V, S}) -&gt;
    [{X,V} | fun() -&gt; qlc_next(gb_trees:next(S)) end];
qlc_next(none) -&gt;
    [].

gb_nodes(T, infinity, ElementFun) -&gt;
    gb_nodes(T, -1, ElementFun);
gb_nodes(T, NElements, ElementFun) -&gt;
    gb_iter(gb_trees:iterator(T), NElements, ElementFun).

gb_iter(_I, 0, _EFun) -&gt;
    '...';
gb_iter(I0, N, EFun) -&gt;
    case gb_trees:next(I0) of
        {X, V, I} -&gt;
            [EFun({X,V}) | gb_iter(I, N-1, EFun)];
        none -&gt;
            []
    end.</code></pre><p><strong>TF</strong> is the traversal function. The <strong>qlc</strong> module
requires that there is a way of traversing all objects of the
data structure. <strong>gb_trees</strong> has an iterator function
suitable for that purpose. Notice that for each object returned, a
new fun is created. As long as the list is not terminated by
<strong>[]</strong>, it is assumed that the tail of the list is a nullary
function and that calling the function returns further objects
(and functions).</p><p>The lookup function is optional. It is assumed that the lookup
function always finds values much faster than it would take to
traverse the table. The first argument is the position of the
key. As <strong>qlc_next/1</strong> returns the objects as <strong>{Key,Value}</strong>
pairs, the position is 1. Notice that the lookup function is to return
<strong>{Key,Value}</strong> pairs, as the traversal function does.</p><p>The format function is also optional. It is called by
<a href="#info/1">info/1</a>
to give feedback at runtime of how the query
is to be evaluated. Try to give as good feedback as
possible without showing too much details. In the example, at
most seven objects of the table are shown. The format function
handles two cases: <strong>all</strong> means that all objects of the
table are traversed; <strong>{lookup,1,KeyValues}</strong>
means that the lookup function is used for looking up key
values.</p><p>Whether the whole table is traversed or only some keys
looked up depends on how the query is expressed. If the query has
the form</p><pre><code class="">
qlc:q([T || P &lt;- LE, F])</code></pre><p>and <strong>P</strong> is a tuple, the <strong>qlc</strong> module analyzes
<strong>P</strong> and <strong>F</strong> in
compile time to find positions of tuple <strong>P</strong> that are tested
for equality to constants. If such a position at runtime turns
out to be the key position, the lookup function can be used,
otherwise all objects of the table must be traversed.
The info function <strong>InfoFun</strong> returns the key position.
There can be indexed positions as well, also returned by the
info function. An index is an extra table that makes lookup on
some position fast. Mnesia maintains indexes upon request,
and introduces so called secondary keys. The <strong>qlc</strong>
module prefers to look up objects using the key before secondary
keys regardless of the number of constants to look up.</p><h3>Key Equality</h3><p>Erlang/OTP has two operators for testing term equality: <strong>==/2</strong>
and <strong>=:=/2</strong>. The difference is all about the integers that can be
represented by floats. For example, <strong>2 == 2.0</strong> evaluates to
<strong>true</strong> while <strong>2 =:= 2.0</strong> evaluates to <strong>false</strong>.
Normally this is a minor issue, but the <strong>qlc</strong> module cannot
ignore the difference, which affects the user's choice of
operators in QLCs.</p><p>If the <strong>qlc</strong> module at compile time can determine that some
constant is free of integers, it does not matter which one of
<strong>==/2</strong> or <strong>=:=/2</strong> is used:</p><pre>
1&gt; <span class="input">E1 = ets:new(t, [set]), % uses =:=/2 for key equality</span>
<span class="input">Q1 = qlc:q([K ||</span>
<span class="input">{K} &lt;- ets:table(E1),</span>
<span class="input">K == 2.71 orelse K == a]),</span>
<span class="input">io:format("~s~n", [qlc:info(Q1)]).</span>
ets:match_spec_run(
       lists:flatmap(fun(V) -&gt;
			    ets:lookup(#Ref&lt;0.3098908599.2283929601.256025&gt;,
				       V)
		     end,
		     [a, 2.71]),
       ets:match_spec_compile([{{'$1'}, [], ['$1']}]))</pre><p>In the example, operator <strong>==/2</strong> has been handled
exactly as <strong>=:=/2</strong> would have been handled. However,
if it cannot be determined at compile time that some
constant is free of integers, and the table uses <strong>=:=/2</strong>
when comparing keys for equality (see option <a href="#key_equality">key_equality</a>), then the
<strong>qlc</strong> module does not try to look up the constant. The
reason is that there is in the general case no upper limit on
the number of key values that can compare equal to such a
constant; every combination of integers and floats must be
looked up:</p><pre>
2&gt; <span class="input">E2 = ets:new(t, [set]),</span>
<span class="input">true = ets:insert(E2, [{{2,2},a},{{2,2.0},b},{{2.0,2},c}]),</span>
<span class="input">F2 = fun(I) -&gt;</span>
<span class="input">qlc:q([V || {K,V} &lt;- ets:table(E2), K == I])</span>
<span class="input">end,</span>
<span class="input">Q2 = F2({2,2}),</span>
<span class="input">io:format("~s~n", [qlc:info(Q2)]).</span>
ets:table(#Ref&lt;0.3098908599.2283929601.256125&gt;,
          [{traverse,
            {select,
             [{{'$1', '$2'}, [{'==', '$1', {const, {2, 2}}}], ['$2']}]}}])
3&gt; <span class="input">lists:sort(qlc:e(Q2)).</span>
[a,b,c]</pre><p>Looking up only <strong>{2,2}</strong> would not return <strong>b</strong> and
<strong>c</strong>.</p><p>If the table uses <strong>==/2</strong> when comparing keys for equality,
the <strong>qlc</strong> module looks up the constant regardless of
which operator is used in the QLC. However, <strong>==/2</strong> is to
be preferred:</p><pre>
4&gt; <span class="input">E3 = ets:new(t, [ordered_set]), % uses ==/2 for key equality</span>
<span class="input">true = ets:insert(E3, [{{2,2.0},b}]),</span>
<span class="input">F3 = fun(I) -&gt;</span>
<span class="input">qlc:q([V || {K,V} &lt;- ets:table(E3), K == I])</span>
<span class="input">end,</span>
<span class="input">Q3 = F3({2,2}),</span>
<span class="input">io:format("~s~n", [qlc:info(Q3)]).</span>
ets:match_spec_run(ets:lookup(#Ref&lt;0.3098908599.2283929601.256211&gt;,
                              {2, 2}),
                   ets:match_spec_compile([{{'$1', '$2'}, [], ['$2']}]))
5&gt; <span class="input">qlc:e(Q3).</span>
[b]</pre><p>Lookup join is handled analogously to lookup of constants in a
table: if the join operator is <strong>==/2</strong>, and the table where
constants are to be looked up uses <strong>=:=/2</strong> when testing
keys for equality, then the <strong>qlc</strong> module does not consider
lookup join for that table.</p><h2>Data Types</h2><span class="name">abstract_expr</span><p>Parse trees for Erlang expression, see section <a href="./absform">The Abstract Format</a>
in the ERTS User's Guide.</p><span class="name">answer</span><span class="name">answers</span><span class="name">cache</span><span class="name">match_expression</span><p>Matchspecification, see section <a href="./match_spec">Match Specifications in Erlang</a>
in the ERTS User's Guide and <a href="ms_transform">ms_transform</a>.</p><span class="name">no_files</span><p>An integer &gt; 1.</p><span class="name">key_pos</span><span class="name">max_list_size</span><span class="name">order</span><span class="name">order_fun</span><span class="name">query_cursor</span><p>A <a href="#query_cursor">query cursor</a>.</p><span class="name">query_handle</span><p>A <a href="#query_handle">query handle</a>.</p><span class="name">query_handle_or_list</span><span class="name">query_list_comprehension</span><p>A literal
<a href="#query_list_comprehension">query list comprehension</a>.</p><span class="name">spawn_options</span><span class="name">sort_options</span><span class="name">sort_option</span><p>See <a href="file_sorter">file_sorter</a>.</p><span class="name">tmp_directory</span><span class="name">tmp_file_usage</span><h2>Functions</h2><h3>append/1</h3><p>Return a query handle.</p><p>Returns a query handle. When evaluating query handle
<strong><span class="anno">QH</span></strong>, all answers to the first query handle in
<strong><span class="anno">QHL</span></strong> are returned, followed by all answers
to the remaining query handles in <strong><span class="anno">QHL</span></strong>.</p><h3>append/2</h3><p>Return a query handle.</p><p>Returns a query handle. When evaluating query handle
<strong><span class="anno">QH3</span></strong>, all answers to
<strong><span class="anno">QH1</span></strong> are returned, followed by all answers
to <strong><span class="anno">QH2</span></strong>.</p><p><strong>append(QH1,QH2)</strong> is equivalent to
<strong>append([QH1,QH2])</strong>.</p><h3>cursor/1</h3><h3>cursor/2</h3><p>Create a query cursor.</p><p>Creates a query cursor and
makes the calling process the owner of the cursor. The
cursor is to be used as argument to
<a href="#next_answers/1">next_answers/1</a> and (eventually)
<a href="#delete_cursor/1">delete_cursor/1</a>.
Calls <a href="../erts/erlang#spawn_opt/2">erts/erlang#spawn_opt/2</a> to spawn and link to
a process that evaluates the query handle. The value of option
<strong>spawn_options</strong> is used as last argument when calling
<strong>spawn_opt/2</strong>. Defaults to <strong>[link]</strong>.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">QH = qlc:q([{X,Y} || X &lt;- [a,b], Y &lt;- [1,2]]),</span>
<span class="input">QC = qlc:cursor(QH),</span>
<span class="input">qlc:next_answers(QC, 1).</span>
[{a,1}]
2&gt; <span class="input">qlc:next_answers(QC, 1).</span>
[{a,2}]
3&gt; <span class="input">qlc:next_answers(QC, all_remaining).</span>
[{b,1},{b,2}]
4&gt; <span class="input">qlc:delete_cursor(QC).</span>
ok</pre><p><strong>cursor(<span class="anno">QH</span>)</strong> is equivalent to
<strong>cursor(<span class="anno">QH</span>, [])</strong>.</p><h3>delete_cursor/1</h3><p>Delete a query cursor.</p><p>Deletes a query cursor. Only the owner of the cursor can
delete the cursor.</p><h3>e/1</h3><h3>e/2</h3><h3>eval/1</h3><h3>eval/2</h3><p>Return all answers to a query.</p><p>Evaluates a query handle in the
calling process and collects all answers in a list.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">QH = qlc:q([{X,Y} || X &lt;- [a,b], Y &lt;- [1,2]]),</span>
<span class="input">qlc:eval(QH).</span>
[{a,1},{a,2},{b,1},{b,2}]</pre><p><strong>eval(<span class="anno">QH</span>)</strong> is equivalent to
<strong>eval(<span class="anno">QH</span>, [])</strong>.</p><h3>fold/3</h3><h3>fold/4</h3><p>Fold a function over the answers to a query.</p><p>Calls <strong><span class="anno">Function</span></strong> on successive answers to
the query handle together with an extra argument
<strong><span class="anno">AccIn</span></strong>. The query handle and the function
are evaluated in the calling process.
<strong><span class="anno">Function</span></strong> must return a new accumulator,
which is passed to the next call.
<strong><span class="anno">Acc0</span></strong> is returned if there are no answers
to the query handle.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">QH = [1,2,3,4,5,6],</span>
<span class="input">qlc:fold(fun(X, Sum) -&gt; X + Sum end, 0, QH).</span>
21</pre><p><strong>fold(<span class="anno">Function</span>, <span class="anno">Acc0</span>, <span class="anno">QH</span>)</strong> is equivalent to
<strong>fold(<span class="anno">Function</span>, <span class="anno">Acc0</span>, <span class="anno">QH</span>, [])</strong>.</p><h3>format_error/1</h3><p>Return an English description of a an error tuple.</p><p>Returns a descriptive string in English of an error tuple
returned by some of the functions of the <strong>qlc</strong> module
or the parse transform. This function is mainly used by the
compiler invoking the parse transform.</p><h3>info/1</h3><h3>info/2</h3><p>Return code describing a query handle.</p><p>Returns information about a
query handle. The information describes the simplifications
and optimizations that are the results of preparing the
query for evaluation. This function is probably mainly useful
during debugging.</p><p>The information has the form of an Erlang expression where
QLCs most likely occur. Depending on the format functions of
mentioned QLC tables, it is not certain that the information
is absolutely accurate.</p><p>Options:</p><ul><li> <p>The default is to return a sequence of QLCs in a block, but
if option <strong>{flat,false}</strong> is specified, one single
QLC is returned.</p> </li><li> <p>The default is to return a string, but if
option <strong>{format,abstract_code}</strong> is specified,
abstract code is returned instead. In the abstract code,
port identifiers, references, and pids are represented by
strings.</p> </li><li> <p>The default is to return all elements in lists, but if
option <strong>{n_elements,NElements}</strong> is specified, only
a limited number of elements are returned.</p> </li><li> <p>The default is to show all parts of
objects and match specifications,
but if option <strong>{depth,Depth}</strong> is specified, parts
of terms below a certain depth are replaced by <strong>'...'</strong>.</p> </li></ul><p><strong>info(<span class="anno">QH</span>)</strong> is equivalent to
<strong>info(<span class="anno">QH</span>, [])</strong>.</p><p><em>Examples:</em></p><p>In the following example two simple QLCs are inserted only to
hold option <strong>{unique,true}</strong>:</p><pre>
1&gt; <span class="input">QH = qlc:q([{X,Y} || X &lt;- [x,y], Y &lt;- [a,b]]),</span>
<span class="input">io:format("~s~n", [qlc:info(QH, unique_all)]).</span>
begin
    V1 =
        qlc:q([
               SQV ||
                   SQV &lt;- [x, y]
              ],
              [{unique, true}]),
    V2 =
        qlc:q([
               SQV ||
                   SQV &lt;- [a, b]
              ],
              [{unique, true}]),
    qlc:q([
           {X,Y} ||
               X &lt;- V1,
               Y &lt;- V2
          ],
          [{unique, true}])
end</pre><p>In the following example QLC <strong>V2</strong> has
been inserted to show the joined generators and the join
method chosen. A convention is used for lookup join: the
first generator (<strong>G2</strong>) is the one traversed, the second
(<strong>G1</strong>) is the table where constants are looked up.</p><pre>
1&gt; <span class="input">E1 = ets:new(e1, []),</span>
<span class="input">E2 = ets:new(e2, []),</span>
<span class="input">true = ets:insert(E1, [{1,a},{2,b}]),</span>
<span class="input">true = ets:insert(E2, [{a,1},{b,2}]),</span>
<span class="input">Q = qlc:q([{X,Z,W} ||</span>
<span class="input">{X, Z} &lt;- ets:table(E1),</span>
<span class="input">{W, Y} &lt;- ets:table(E2),</span>
<span class="input">X =:= Y]),</span>
<span class="input">io:format("~s~n", [qlc:info(Q)]).</span>
begin
    V1 =
        qlc:q([
               P0 ||
                   P0 = {W, Y} &lt;-
                       ets:table(#Ref&lt;0.3098908599.2283929601.256549&gt;)
              ]),
    V2 =
        qlc:q([
               [G1 | G2] ||
                   G2 &lt;- V1,
                   G1 &lt;-
                       ets:table(#Ref&lt;0.3098908599.2283929601.256548&gt;),
                   element(2, G1) =:= element(1, G2)
              ],
              [{join, lookup}]),
    qlc:q([
           {X, Z, W} ||
               [{X, Z} | {W, Y}] &lt;- V2
          ])
end</pre><h3>keysort/2</h3><h3>keysort/3</h3><p>Return a query handle.</p><p>Returns a query handle. When evaluating query handle
<strong><span class="anno">QH2</span></strong>, the answers to query handle
<strong><span class="anno">QH1</span></strong> are sorted by <a href="./file_sorter#keysort/4">file_sorter#keysort/4</a>
according to the options.</p><p>The sorter uses temporary files only if
<strong><span class="anno">QH1</span></strong> does not evaluate to a list and the
size of the binary representation of the answers exceeds
<strong>Size</strong> bytes, where <strong>Size</strong> is the value of option
<strong>size</strong>.</p><p><strong>keysort(<span class="anno">KeyPos</span>, <span class="anno">QH1</span>)</strong>
is equivalent to
<strong>keysort(<span class="anno">KeyPos</span>, <span class="anno">QH1</span>, [])</strong>.</p><h3>next_answers/1</h3><h3>next_answers/2</h3><p>Return some or all answers to a query.</p><p>Returns some or all of the remaining answers to a query
cursor. Only the owner of <strong><span class="anno">QueryCursor</span></strong> can
retrieve answers.</p><p>Optional argument <strong>NumberOfAnswers</strong> determines the
maximum number of answers returned. Defaults to
<strong>10</strong>. If less than the requested number of answers is
returned, subsequent calls to <strong>next_answers</strong>
return <strong>[]</strong>.</p><h3>q/1</h3><h3>q/2</h3><p>Return a handle for a query list comprehension.</p><p>Returns a query handle for a QLC.
The QLC must be the first argument to this function, otherwise
it is evaluated as an ordinary list comprehension. It is also
necessary to add the following line to the source code:</p><pre><code class="">
-include_lib("stdlib/include/qlc.hrl").</code></pre><p>This causes a parse transform to substitute a fun for the QLC. The
(compiled) fun is called when the query handle is evaluated.</p><p>When calling <strong>qlc:q/1,2</strong> from the Erlang shell, the
parse transform is automatically called. When this occurs, the fun
substituted for the QLC is not compiled but is evaluated by
<a href="erl_eval">erl_eval</a>. This
is also true when expressions are evaluated by
<strong>file:eval/1,2</strong> or in the debugger.</p><p>To be explicit, this does not work:</p><pre>
...
A = [X || {X} &lt;- [{1},{2}]],
QH = qlc:q(A),
...</pre><p>Variable <strong>A</strong> is bound to the evaluated value
of the list comprehension (<strong>[1,2]</strong>). The compiler
complains with an error message ("argument is not a query
list comprehension"); the shell process stops with a
<strong>badarg</strong> reason.</p><p><strong>q(<span class="anno">QLC</span>)</strong> is equivalent to
<strong>q(<span class="anno">QLC</span>, [])</strong>.</p><p>Options:</p><ul><li> <p>Option <strong>{cache,ets}</strong> can be used to cache
the answers to a QLC. The answers are stored in one ETS
table for each cached QLC. When a cached QLC is
evaluated again, answers are fetched from the table without
any further computations. Therefore, when all answers to a
cached QLC have been found, the ETS tables used for
caching answers to the qualifiers of the QLC can be emptied.
Option <strong>cache</strong> is equivalent to <strong>{cache,ets}</strong>.</p> </li><li> <p>Option <strong>{cache,list}</strong> can be used to cache
the answers to a QLC like
<strong>{cache,ets}</strong>. The difference is that the answers
are kept in a list (on the process heap). If the answers
would occupy more than a certain amount of RAM memory, a
temporary file is used for storing the answers. Option
<strong>max_list_size</strong> sets the limit in bytes and the temporary
file is put on the directory set by option <strong>tmpdir</strong>.</p> <p>Option <strong>cache</strong> has no effect if it is known that
the QLC is to be evaluated at most once.
This is always true for the top-most QLC
and also for the list expression of the first
generator in a list of qualifiers. Notice that in the presence
of side effects in filters or callback functions, the answers
to QLCs can be affected by option <strong>cache</strong>.</p> </li><li> <p>Option <strong>{unique,true}</strong> can be used to remove
duplicate answers to a QLC. The unique
answers are stored in one ETS table for each QLC.
The table is emptied every time it is known
that there are no more answers to the QLC.
Option <strong>unique</strong> is equivalent to
<strong>{unique,true}</strong>. If option <strong>unique</strong> is
combined with option <strong>{cache,ets}</strong>, two ETS
tables are used, but the full answers are stored in one
table only. If option <strong>unique</strong> is combined with option
<strong>{cache,list}</strong>, the answers are sorted
twice using
<a href="#keysort/3">keysort/3</a>;
once to remove duplicates and once to restore the order.</p> </li></ul><p>Options <strong>cache</strong> and <strong>unique</strong> apply not only
to the QLC itself but also to the results of looking up constants,
running match specifications, and joining handles.</p><p><em>Example:</em></p><p>In the following example the cached results of the merge join are
traversed for each value of <strong>A</strong>. Notice that without option
<strong>cache</strong> the join would have been carried out
three times, once for each value of <strong>A</strong>.</p><pre>
1&gt; <span class="input">Q = qlc:q([{A,X,Z,W} ||</span>
<span class="input">A &lt;- [a,b,c],</span>
<span class="input">{X,Z} &lt;- [{a,1},{b,4},{c,6}],</span>
<span class="input">{W,Y} &lt;- [{2,a},{3,b},{4,c}],</span>
<span class="input">X =:= Y],</span>
<span class="input">{cache, list}),</span>
<span class="input">io:format("~s~n", [qlc:info(Q)]).</span>
begin
    V1 =
        qlc:q([
               P0 ||
                   P0 = {X, Z} &lt;-
                       qlc:keysort(1, [{a, 1}, {b, 4}, {c, 6}], [])
              ]),
    V2 =
        qlc:q([
               P0 ||
                   P0 = {W, Y} &lt;-
                       qlc:keysort(2, [{2, a}, {3, b}, {4, c}], [])
              ]),
    V3 =
        qlc:q([
               [G1 | G2] ||
                   G1 &lt;- V1,
                   G2 &lt;- V2,
                   element(1, G1) == element(2, G2)
              ],
              [{join, merge}, {cache, list}]),
    qlc:q([
           {A, X, Z, W} ||
               A &lt;- [a, b, c],
               [{X, Z} | {W, Y}] &lt;- V3,
               X =:= Y
          ])
end</pre><p><a href="#sort/1">sort/1</a> and
<a href="#keysort/2">keysort/2</a>
can also be used for
caching answers and for removing duplicates. When sorting
answers are cached in a list, possibly stored on a temporary
file, and no ETS tables are used.</p><p>Sometimes (see <a href="#table/2">table/2</a>) traversal
of tables can be done by looking up key values, which is
assumed to be fast. Under certain (rare) circumstances
there can be too many key values to look up.
<a name="max_lookup"></a>
Option <strong>{max_lookup,MaxLookup}</strong> can then be used
to limit the number of lookups: if more than
<strong>MaxLookup</strong> lookups would be required, no lookups are
done but the table is traversed instead. Defaults to
<strong>infinity</strong>, which means that there is no limit on the
number of keys to look up.</p><p><em>Example:</em></p><p>In the following example, using the <strong>gb_table</strong> module from
section <a href="#implementing_a_qlc_table">Implementing a QLC Table</a>, there are six keys to look up:
<strong>{1,a}</strong>, <strong>{1,b}</strong>, <strong>{1,c}</strong>, <strong>{2,a}</strong>,
<strong>{2,b}</strong>, and <strong>{2,c}</strong>. The reason is that the two
elements of key <strong>{X,Y}</strong> are compared separately.</p><pre>
1&gt; <span class="input">T = gb_trees:empty(),</span>
<span class="input">QH = qlc:q([X || {{X,Y},_} &lt;- gb_table:table(T),</span>
<span class="input">((X == 1) or (X == 2)) andalso</span>
<span class="input">((Y == a) or (Y == b) or (Y == c))]),</span>
<span class="input">io:format("~s~n", [qlc:info(QH)]).</span>
ets:match_spec_run(
       lists:flatmap(fun(K) -&gt;
                            case
                                gb_trees:lookup(K,
                                                gb_trees:from_orddict([]))
                            of
                                {value, V} -&gt;
                                    [{K, V}];
                                none -&gt;
                                    []
                            end
                     end,
                     [{1, a},
                      {1, b},
                      {1, c},
                      {2, a},
                      {2, b},
                      {2, c}]),
       ets:match_spec_compile([{{{'$1', '$2'}, '_'},
                                [],
                                ['$1']}]))</pre><p>Options:</p><ul><li> <p>Option <strong>{lookup,true}</strong> can be used to ensure
that the <strong>qlc</strong> module looks up constants in some
QLC table. If there are more than one QLC table among the
list expressions of the generators,
constants must be looked up in at least one
of the tables. The evaluation of the query fails if there
are no constants to look up. This option is useful
when it would be unacceptable to traverse all
objects in some table. Setting option <strong>lookup</strong> to
<strong>false</strong> ensures that no constants are looked up
(<strong>{max_lookup,0}</strong> has the same effect).
Defaults to <strong>any</strong>, which means that constants are
looked up whenever possible.</p> </li><li> <p>Option <strong>{join,Join}</strong> can be used to ensure
that a certain join method is used:</p> <ul><li><strong>{join,lookup}</strong> invokes the lookup join method.</li><li><strong>{join,merge}</strong> invokes the merge join method.</li><li><strong>{join,nested_loop}</strong> invokes the method of matching every pair of objects from two handles. This method is mostly very slow.</li></ul> <p>The evaluation of the query fails if the <strong>qlc</strong> module
cannot carry out the chosen join method. Defaults to
<strong>any</strong>, which means that some fast join
method is used if possible.</p> </li></ul><h3>sort/1</h3><h3>sort/2</h3><p>Return a query handle.</p><p>Returns a query handle. When evaluating query handle
<strong><span class="anno">QH2</span></strong>, the answers to query handle
<strong><span class="anno">QH1</span></strong> are sorted by <a href="./file_sorter#sort/3">file_sorter#sort/3</a>
according to the options.</p><p>The sorter uses temporary files only if
<strong><span class="anno">QH1</span></strong> does not evaluate to a list and the
size of the binary representation of the answers exceeds
<strong>Size</strong> bytes, where <strong>Size</strong> is the value of option
<strong>size</strong>.</p><p><strong>sort(<span class="anno">QH1</span>)</strong> is equivalent to
<strong>sort(<span class="anno">QH1</span>, [])</strong>.</p><h3>string_to_handle/1</h3><h3>string_to_handle/2</h3><h3>string_to_handle/3</h3><p>Return a handle for a query list comprehension.</p><p>A string version of <a href="#q/1">q/1</a>.
When the query handle is evaluated, the fun created by the parse
transform is interpreted by
<a href="erl_eval">erl_eval</a>.
The query string is to be one single QLC terminated by a period.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">L = [1,2,3],</span>
<span class="input">Bs = erl_eval:add_binding('L', L, erl_eval:new_bindings()),</span>
<span class="input">QH = qlc:string_to_handle("[X+1 || X &lt;- L].", [], Bs),</span>
<span class="input">qlc:eval(QH).</span>
[2,3,4]</pre><p><strong>string_to_handle(<span class="anno">QueryString</span>)</strong>
is equivalent to
<strong>string_to_handle(<span class="anno">QueryString</span>, [])</strong>.</p><p><strong>string_to_handle(<span class="anno">QueryString</span>, <span class="anno">Options</span>)</strong> is equivalent to
<strong>string_to_handle(<span class="anno">QueryString</span>, <span class="anno">Options</span>, erl_eval:new_bindings())</strong>.</p><p>This function is probably mainly useful when called from
outside of Erlang, for example from a driver written in C.</p><h3>table/2</h3><p>Return a query handle for a table.</p><p>Returns a query handle for a QLC table.
In Erlang/OTP there is support for ETS, Dets, and
Mnesia tables, but many other data structures can be turned
into QLC tables. This is accomplished by letting function(s) in the
module implementing the data structure create a query handle by
calling <strong>qlc:table/2</strong>. The different ways to traverse the table
and properties of the table are handled by callback
functions provided as options to <strong>qlc:table/2</strong>.</p><ul><li> <p>Callback function <strong><span class="anno">TraverseFun</span></strong> is
used for traversing the table. It is to return a list of
objects terminated by either <strong>[]</strong> or a nullary fun to
be used for traversing the not yet traversed objects of the
table. Any other return value is immediately returned as
value of the query evaluation. Unary
<strong><span class="anno">TraverseFun</span></strong>s are to accept a match
specification as argument. The match specification is
created by the parse transform by analyzing the pattern of
the generator calling <strong>qlc:table/2</strong> and filters using
variables introduced in the pattern. If the parse transform
cannot find a match specification equivalent to the pattern
and filters, <strong><span class="anno">TraverseFun</span></strong> is called
with a match specification returning every object.</p> <ul><li> <p>Modules that can use match specifications for optimized
traversal of tables are to call <strong>qlc:table/2</strong> with an unary
<strong><span class="anno">TraverseFun</span></strong>. An example is
<a href="./ets#table/2">ets#table/2</a>.</p> </li><li> <p>Other modules can provide a nullary
<strong><span class="anno">TraverseFun</span></strong>. An example is
<strong>gb_table:table/1</strong> in section
<a href="#implementing_a_qlc_table">Implementing a QLC Table</a>.</p> </li></ul> </li><li> <p>Unary callback function <strong><span class="anno">PreFun</span></strong> is
called once before the table is read for the first time.
If the call fails, the query evaluation fails.</p> <p>Argument <strong><span class="anno">PreArgs</span></strong> is a list of tagged values.
There are two tags, <strong>parent_value</strong> and <strong>stop_fun</strong>, used
by Mnesia for managing transactions.</p> <ul><li> <p>The value of <strong>parent_value</strong> is
the value returned by <strong><span class="anno">ParentFun</span></strong>, or
<strong>undefined</strong> if there is no <strong>ParentFun</strong>.
<strong><span class="anno">ParentFun</span></strong> is called once just before the
call of <strong><span class="anno">PreFun</span></strong> in the context of the
process calling
<a href="#eval/1">eval/1</a>,
<a href="#fold/3">fold/3</a>, or
<a href="#cursor/1">cursor/1</a>.
</p> </li><li> <p>The value of <strong>stop_fun</strong> is a nullary fun
that deletes the cursor if called from the parent, or
<strong>undefined</strong> if there is no cursor.</p> </li></ul> </li><li> <p>Nullary callback function
<strong><span class="anno">PostFun</span></strong> is called once after the table
was last read. The return value, which is caught, is ignored.
If <strong><span class="anno">PreFun</span></strong> has been called for a table,
<strong><span class="anno">PostFun</span></strong> is guaranteed to be called for
that table, even if the evaluation of the query fails for
some reason.</p> <p>The pre (post) functions for different tables are evaluated in
unspecified order.</p> <p>Other table access than reading, such as calling
<strong><span class="anno">InfoFun</span></strong>, is assumed to be OK at any time.</p> </li><li> <p><a name="lookup_fun"></a>Binary callback
function <strong><span class="anno">LookupFun</span></strong> is used for looking
up objects in the table. The first argument
<strong><span class="anno">Position</span></strong> is the key position or an
indexed position and the second argument
<strong><span class="anno">Keys</span></strong> is a sorted list of unique values.
The return value is to be a list of all objects (tuples),
such that the element at <strong>Position</strong> is a member of
<strong><span class="anno">Keys</span></strong>. Any other return value is
immediately returned as value of the query evaluation.
<strong><span class="anno">LookupFun</span></strong> is called instead of
traversing the table if the parse transform at compile time
can determine that the filters match and compare the element
at <strong><span class="anno">Position</span></strong> in such a way that only
<strong><span class="anno">Keys</span></strong> need to be looked up to
find all potential answers.</p> <p>The key position is obtained by calling
<strong><span class="anno">InfoFun</span>(keypos)</strong> and the indexed
positions by calling
<strong><span class="anno">InfoFun</span>(indices)</strong>. If the key position
can be used for lookup, it is always chosen, otherwise the
indexed position requiring the least number of lookups is
chosen. If there is a tie between two indexed positions, the
one occurring first in the list returned by
<strong><span class="anno">InfoFun</span></strong> is chosen. Positions requiring
more than <a href="#max_lookup">max_lookup</a>
lookups are ignored.</p> </li><li> <p>Unary callback function <strong><span class="anno">InfoFun</span></strong> is
to return information about the table. <strong>undefined</strong>
is to be returned if the value of some tag is unknown:</p> <dl><dt><strong>indices</strong></dt><dd>Returns a list of indexed positions, a list of positive integers.</dd><dt><strong>is_unique_objects</strong></dt><dd>Returns <strong>true</strong> if the objects returned by <strong>TraverseFun</strong> are unique. </dd><dt><strong>keypos</strong></dt><dd>Returns the position of the table key, a positive integer. </dd><dt><strong>is_sorted_key</strong></dt><dd>Returns <strong>true</strong> if the objects returned by <strong>TraverseFun</strong> are sorted on the key. </dd><dt><strong>num_of_objects</strong></dt><dd>Returns the number of objects in the table, a non-negative integer. </dd></dl> </li><li> <p>Unary callback function <strong><span class="anno">FormatFun</span></strong>
is used by <a href="#info/1">info/1</a>
for displaying the call that created the query handle of the
table. Defaults to <strong>undefined</strong>, which means that
<strong>info/1,2</strong> displays a call to <strong>'$MOD':'$FUN'/0</strong>.
It is up to <strong><span class="anno">FormatFun</span></strong> to present the
selected objects of the table in a suitable way. However, if
a character list is chosen for presentation, it must be an
Erlang expression that can be scanned and parsed (a trailing
dot is added by <strong>info/1,2</strong> though).</p> <p><strong><span class="anno">FormatFun</span></strong> is called with an argument
that describes the selected objects based on optimizations
done as a result of analyzing the filters of the QLC where
the call to <strong>qlc:table/2</strong> occurs. The argument can have the
following values:</p> <dl><dt><strong>{lookup, Position, Keys, NElements, DepthFun}</strong>.</dt><dd> <p><strong>LookupFun</strong> is used for looking up objects in the
table.</p> </dd><dt><strong>{match_spec, MatchExpression}</strong></dt><dd> <p>No way of finding all possible answers by looking up keys
was found, but the filters could be transformed into a
match specification. All answers are found by calling
<strong>TraverseFun(MatchExpression)</strong>.</p> </dd><dt><strong>{all, NElements, DepthFun}</strong></dt><dd> <p>No optimization was found. A match specification matching
all objects is used if <strong>TraverseFun</strong> is unary.</p> <p><strong>NElements</strong> is the value of the <strong>info/1,2</strong> option
<strong>n_elements</strong>.</p> <p><strong>DepthFun</strong> is a function that can be used for
limiting the size of terms; calling
<strong>DepthFun(Term)</strong> substitutes <strong>'...'</strong> for
parts of <strong>Term</strong> below the depth specified by the
<strong>info/1,2</strong> option <strong>depth</strong>.</p> <p>If calling <strong><span class="anno">FormatFun</span></strong> with an
argument including <strong>NElements</strong> and
<strong>DepthFun</strong> fails, <strong><span class="anno">FormatFun</span></strong>
is called once again with an argument excluding
<strong>NElements</strong> and <strong>DepthFun</strong>
(<strong>{lookup,Position,Keys}</strong> or
<strong>all</strong>).</p> </dd></dl> </li><li><p><a name="key_equality"></a>The value of option
<strong>key_equality</strong> is to be <strong>'=:='</strong> if the table
considers two keys equal if they match, and to be
<strong>'=='</strong> if two keys are equal if they compare equal.
Defaults to <strong>'=:='</strong>.</p> </li></ul><p>For the various options recognized by <strong>table/1,2</strong>
in respective module, see
<a href="./ets#table/1">ets#table/1</a>,
<a href="./dets#table/1">dets#table/1</a>, and
<a href="../mnesia/mnesia#table/1">mnesia/mnesia#table/1</a>.
</p><h3>See Also</h3><p><a href="dets">dets</a>,
<a href="erl_eval">erl_eval</a>,
<a href="./erlang">erts/erlang</a>,
<a href="./error_logger">kernel/error_logger</a>,
<a href="ets">ets</a>,
<a href="./file">kernel/file</a>,
<a href="file_sorter">file_sorter</a>,
<a href="./mnesia">mnesia/mnesia</a>,
<a href="shell">shell</a>,
<a href="./users_guide"> Erlang Reference Manual</a>,
<a href="./users_guide"> Programming Examples</a></p><h2>queue</h2><p>Abstract data type for FIFO queues.</p><p>This module provides (double-ended) FIFO queues
in an efficient manner.All functions fail with reason <strong>badarg</strong> if arguments
are of wrong type, for example, queue arguments are not
queues, indexes are not integers, and list arguments are
not lists. Improper lists cause internal crashes.
An index out of range for a queue also causes
a failure with reason <strong>badarg</strong>.Some functions, where noted, fail with reason <strong>empty</strong>
for an empty queue.The data representing a queue as used by this module
is to be regarded as opaque by other modules. Any code
assuming knowledge of the format is running on thin ice.All operations has an amortized O(1) running time, except
<a href="#filter/2">filter/2</a>,
<a href="#join/2">join/2</a>,
<a href="#len/1">len/1</a>,
<a href="#member/2">member/2</a>,
<a href="#split/2">split/2</a> that have O(n).
To minimize the size of a queue minimizing
the amount of garbage built by queue operations, the queues
do not contain explicit length information, and that is
why <strong>len/1</strong> is O(n). If better performance for this
particular operation is essential, it is easy for
the caller to keep track of the length.Queues are double-ended. The mental picture of
a queue is a line of people (items) waiting for
their turn. The queue front is the end with the item
that has waited the longest. The queue rear is the end
an item enters when it starts to wait. If instead using
the mental picture of a list, the front is called head
and the rear is called tail.Entering at the front and exiting at the rear
are reverse operations on the queue.This module has three sets of interface functions: the
"Original API", the "Extended API", and the "Okasaki API".The "Original API" and the "Extended API" both use the
mental picture of a waiting line of items. Both
have reverse operations suffixed "_r".The "Original API" item removal functions return compound
terms with both the removed item and the resulting queue.
The "Extended API" contains alternative functions that build
less garbage and functions for just inspecting the
queue ends. Also the "Okasaki API" functions build less garbage.The "Okasaki API" is inspired by "Purely Functional Data Structures"
by Chris Okasaki. It regards queues as lists.
This API is by many regarded as strange and avoidable.
For example, many reverse operations have lexically reversed names,
some with more readable but perhaps less understandable aliases.</p><h3>Original API</h3><h2>Data Types</h2><span class="name">queue</span><p>As returned by
<a href="#new/0">new/0</a>.</p><span class="name">queue</span><h2>Functions</h2><h3>filter/2</h3><p>Filter a queue.</p><p>Returns a queue <strong><span class="anno">Q2</span></strong> that is the result of calling
<strong><span class="anno">Fun</span>(<span class="anno">Item</span>)</strong> on all items in
<strong><span class="anno">Q1</span></strong>, in order from front to rear.</p><p>If <strong><span class="anno">Fun</span>(<span class="anno">Item</span>)</strong> returns <strong>true</strong>,
<strong>Item</strong> is copied to the result queue. If it returns <strong>false</strong>,
<strong><span class="anno">Item</span></strong> is not copied. If it returns a list,
the list elements are inserted instead of <strong>Item</strong> in the
result queue.</p><p>So, <strong><span class="anno">Fun</span>(<span class="anno">Item</span>)</strong> returning
<strong>[<span class="anno">Item</span>]</strong> is thereby
semantically equivalent to returning <strong>true</strong>, just
as returning <strong>[]</strong> is semantically equivalent to
returning <strong>false</strong>. But returning a list builds
more garbage than returning an atom.</p><h3>from_list/1</h3><p>Convert a list to a queue.</p><p>Returns a queue containing the items in <strong><span class="anno">L</span></strong> in the
same order; the head item of the list becomes the front
item of the queue.</p><h3>in/2</h3><p>Insert an item at the rear of a queue.</p><p>Inserts <strong><span class="anno">Item</span></strong> at the rear of queue
<strong><span class="anno">Q1</span></strong>.
Returns the resulting queue <strong><span class="anno">Q2</span></strong>.</p><h3>in_r/2</h3><p>Insert an item at the front of a queue.</p><p>Inserts <strong><span class="anno">Item</span></strong> at the front of queue
<strong><span class="anno">Q1</span></strong>.
Returns the resulting queue <strong><span class="anno">Q2</span></strong>.</p><h3>is_empty/1</h3><p>Test if a queue is empty.</p><p>Tests if <strong><span class="anno">Q</span></strong> is empty and returns <strong>true</strong> if
so, otherwise <strong>false</strong>.</p><h3>is_queue/1</h3><p>Test if a term is a queue.</p><p>Tests if <strong><span class="anno">Term</span></strong> is a queue and returns <strong>true</strong>
if so, otherwise <strong>false</strong>.</p><h3>join/2</h3><p>Join two queues.</p><p>Returns a queue <strong><span class="anno">Q3</span></strong> that is the result of joining
<strong><span class="anno">Q1</span></strong> and <strong><span class="anno">Q2</span></strong> with
<strong><span class="anno">Q1</span></strong> in front of <strong><span class="anno">Q2</span></strong>.</p><h3>len/1</h3><p>Get the length of a queue.</p><p>Calculates and returns the length of queue <strong><span class="anno">Q</span></strong>.</p><h3>member/2</h3><p>Test if an item is in a queue.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Item</span></strong> matches some element
in <strong><span class="anno">Q</span></strong>, otherwise <strong>false</strong>.</p><h3>new/0</h3><p>Create an empty queue.</p><p>Returns an empty queue.</p><h3>out/1</h3><p>Remove the front item from a queue.</p><p>Removes the item at the front of queue <strong><span class="anno">Q1</span></strong>.
Returns tuple <strong>{{value, <span class="anno">Item</span>}, <span class="anno">Q2</span>}</strong>,
where <strong><span class="anno">Item</span></strong> is the item removed and
<strong><span class="anno">Q2</span></strong> is the resulting queue. If
<strong><span class="anno">Q1</span></strong> is empty, tuple
<strong>{empty, <span class="anno">Q1</span>}</strong> is returned.</p><h3>out_r/1</h3><p>Remove the rear item from a queue.</p><p>Removes the item at the rear of queue <strong><span class="anno">Q1</span></strong>.
Returns tuple <strong>{{value, <span class="anno">Item</span>}, <span class="anno">Q2</span>}</strong>,
where <strong><span class="anno">Item</span></strong> is the item removed and
<strong><span class="anno">Q2</span></strong> is the new queue. If <strong><span class="anno">Q1</span></strong> is
empty, tuple <strong>{empty, <span class="anno">Q1</span>}</strong> is returned.</p><h3>reverse/1</h3><p>Reverse a queue.</p><p>Returns a queue <strong><span class="anno">Q2</span></strong> containing the items of
<strong><span class="anno">Q1</span></strong> in the reverse order.</p><h3>split/2</h3><p>Split a queue in two.</p><p>Splits <strong><span class="anno">Q1</span></strong> in two. The <strong><span class="anno">N</span></strong>
front items are put in <strong><span class="anno">Q2</span></strong> and the rest in
<strong><span class="anno">Q3</span></strong>.</p><h3>to_list/1</h3><p>Convert a queue to a list.</p><p>Returns a list of the items in the queue in the same order;
the front item of the queue becomes the head of the list.</p><h3>Extended API</h3><h2>Functions</h2><h3>drop/1</h3><p>Remove the front item from a queue.</p><p>Returns a queue <strong><span class="anno">Q2</span></strong> that is the result of removing
the front item from <strong><span class="anno">Q1</span></strong>.</p><p>Fails with reason <strong>empty</strong> if <strong><span class="anno">Q1</span></strong> is empty.</p><h3>drop_r/1</h3><p>Remove the rear item from a queue.</p><p>Returns a queue <strong><span class="anno">Q2</span></strong> that is the result of removing
the rear item from <strong><span class="anno">Q1</span></strong>.</p><p>Fails with reason <strong>empty</strong> if <strong><span class="anno">Q1</span></strong> is empty.</p><h3>get/1</h3><p>Return the front item of a queue.</p><p>Returns <strong><span class="anno">Item</span></strong> at the front of queue
<strong><span class="anno">Q</span></strong>.</p><p>Fails with reason <strong>empty</strong> if <strong><span class="anno">Q</span></strong> is empty.</p><h3>get_r/1</h3><p>Return the rear item of a queue.</p><p>Returns <strong><span class="anno">Item</span></strong> at the rear of queue
<strong><span class="anno">Q</span></strong>.</p><p>Fails with reason <strong>empty</strong> if <strong><span class="anno">Q</span></strong> is empty.</p><h3>peek/1</h3><p>Return the front item of a queue.</p><p>Returns tuple <strong>{value, <span class="anno">Item</span>}</strong>, where
<strong><span class="anno">Item</span></strong> is the front item of <strong><span class="anno">Q</span></strong>,
or <strong>empty</strong> if <strong><span class="anno">Q</span></strong> is empty.</p><h3>peek_r/1</h3><p>Return the rear item of a queue.</p><p>Returns tuple <strong>{value, <span class="anno">Item</span>}</strong>, where
<strong><span class="anno">Item</span></strong> is the rear item of <strong><span class="anno">Q</span></strong>,
or <strong>empty</strong> if <strong><span class="anno">Q</span></strong> is empty.</p><h3>Okasaki API</h3><h2>Functions</h2><h3>cons/2</h3><p>Insert an item at the head of a queue.</p><p>Inserts <strong><span class="anno">Item</span></strong> at the head of queue
<strong><span class="anno">Q1</span></strong>. Returns
the new queue <strong><span class="anno">Q2</span></strong>.</p><h3>daeh/1</h3><p>Return the tail item of a queue.</p><p>Returns the tail item of queue <strong><span class="anno">Q</span></strong>.</p><p>Fails with reason <strong>empty</strong> if <strong><span class="anno">Q</span></strong> is empty.</p><h3>head/1</h3><p>Return the item at the head of a queue.</p><p>Returns <strong><span class="anno">Item</span></strong> from the head of queue
<strong><span class="anno">Q</span></strong>.</p><p>Fails with reason <strong>empty</strong> if <strong><span class="anno">Q</span></strong> is empty.</p><h3>init/1</h3><p>Remove the tail item from a queue.</p><p>Returns a queue <strong><span class="anno">Q2</span></strong> that is the result of removing
the tail item from <strong><span class="anno">Q1</span></strong>.</p><p>Fails with reason <strong>empty</strong> if <strong><span class="anno">Q1</span></strong> is empty.</p><h3>lait/1</h3><p>Remove the tail item from a queue.</p><p>Returns a queue <strong><span class="anno">Q2</span></strong> that is the result of removing
the tail item from <strong><span class="anno">Q1</span></strong>.</p><p>Fails with reason <strong>empty</strong> if <strong><span class="anno">Q1</span></strong> is empty.</p><p>The name <strong>lait/1</strong> is a misspelling - do not use it anymore.</p><h3>last/1</h3><p>Return the tail item of a queue.</p><p>Returns the tail item of queue <strong><span class="anno">Q</span></strong>.</p><p>Fails with reason <strong>empty</strong> if <strong><span class="anno">Q</span></strong> is empty.</p><h3>liat/1</h3><p>Remove the tail item from a queue.</p><p>Returns a queue <strong><span class="anno">Q2</span></strong> that is the result of removing
the tail item from <strong><span class="anno">Q1</span></strong>.</p><p>Fails with reason <strong>empty</strong> if <strong><span class="anno">Q1</span></strong> is empty.</p><h3>snoc/2</h3><p>Insert an item at the tail of a queue.</p><p>Inserts <strong><span class="anno">Item</span></strong> as the tail item of queue
<strong><span class="anno">Q1</span></strong>. Returns
the new queue <strong><span class="anno">Q2</span></strong>.</p><h3>tail/1</h3><p>Remove the head item from a queue.</p><p>Returns a queue <strong><span class="anno">Q2</span></strong> that is the result of removing
the head item from <strong><span class="anno">Q1</span></strong>.</p><p>Fails with reason <strong>empty</strong> if <strong><span class="anno">Q1</span></strong> is empty.</p><h2>rand</h2><p>Pseudo random number generation.</p><p>
This module provides a pseudo random number generator.
The module contains a number of algorithms.
The uniform distribution algorithms are based on the
<a href="http://xorshift.di.unimi.it"> Xoroshiro and Xorshift algorithms </a>
by Sebastiano Vigna.
The normal distribution algorithm uses the
<a href="http://www.jstatsoft.org/v05/i08"> Ziggurat Method by Marsaglia and Tsang </a>
on top of the uniform distribution algorithm.

For most algorithms, jump functions are provided for generating
non-overlapping sequences for parallel computations.
The jump functions perform calculations
equivalent to perform a large number of repeated calls
for calculating new states.
The following algorithms are provided:<dl><dt><strong>exsss</strong></dt><dd> <p>Xorshift116**, 58 bits precision and period of 2^116-1</p> <p>Jump function: equivalent to 2^64 calls</p> <p>
This is the Xorshift116 generator combined with the StarStar scrambler
from the 2018 paper by David Blackman and Sebastiano Vigna:
<a href="http://vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf"> Scrambled Linear Pseudorandom Number Generators </a>
</p> <p>
The generator does not need 58-bit rotates so it is faster
than the Xoroshiro116 generator, and when combined with
the StarStar scrambler it does not have any weak low bits
like <strong>exrop</strong> (Xoroshiro116+).
</p> <p>
Alas, this combination is about 10% slower than <strong>exrop</strong>,
but is despite that the default algorithm thanks to its
statistical qualities.
</p> </dd><dt><strong>exro928ss</strong></dt><dd> <p>Xoroshiro928**, 58 bits precision and a period of 2^928-1</p> <p>Jump function: equivalent to 2^512 calls</p> <p>
This is a 58 bit version of Xoroshiro1024**,
from the 2018 paper by David Blackman and Sebastiano Vigna:
<a href="http://vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf"> Scrambled Linear Pseudorandom Number Generators </a>
that on a 64 bit Erlang system executes only about 40% slower than
the default <strong>exsss</strong> algorithm but with much longer period
and better statistical properties, and on the flip side
a larger state.
</p> <p>
Many thanks to Sebastiano Vigna for his help with
the 58 bit adaption.
</p> </dd><dt><strong>exrop</strong></dt><dd> <p>Xoroshiro116+, 58 bits precision and period of 2^116-1</p> <p>Jump function: equivalent to 2^64 calls</p> </dd><dt><strong>exs1024s</strong></dt><dd> <p>Xorshift1024*, 64 bits precision and a period of 2^1024-1</p> <p>Jump function: equivalent to 2^512 calls</p> </dd><dt><strong>exsp</strong></dt><dd> <p>Xorshift116+, 58 bits precision and period of 2^116-1</p> <p>Jump function: equivalent to 2^64 calls</p> <p>
This is a corrected version of the previous default algorithm,
that now has been superseded by Xoroshiro116+ (<strong>exrop</strong>).
Since there is no native 58 bit rotate instruction this
algorithm executes a little (say &lt; 15%) faster than <strong>exrop</strong>.
See the 
<a href="http://xorshift.di.unimi.it">algorithms' homepage</a>.
</p> </dd></dl>
The default algorithm is <strong>exsss</strong> (Xorshift116**).
If a specific algorithm is
required, ensure to always use <a href="#seed-1">seed-1</a> to initialize the state.

Undocumented (old) algorithms are deprecated but still implemented
so old code relying on them will produce
the same pseudo random sequences as before.
Every time a random number is requested, a state is used to
calculate it and a new state is produced. The state can either be
implicit or be an explicit argument and return value.The functions with implicit state use the process dictionary
variable <strong>rand_seed</strong> to remember the current state.If a process calls
<a href="#uniform-0">uniform-0</a>,
<a href="#uniform-1">uniform-1</a> or
<a href="#uniform_real-0">uniform_real-0</a> without
setting a seed first, <a href="#seed-1">seed-1</a>
is called automatically with the default algorithm and creates a
non-constant seed.The functions with explicit state never use the process dictionary.<em>Examples:</em>Simple use; creates and seeds the default algorithm
with a non-constant seed if not already done:<pre>
R0 = rand:uniform(),
R1 = rand:uniform(),</pre>Use a specified algorithm:<pre>
_ = rand:seed(exs928ss),
R2 = rand:uniform(),</pre>Use a specified algorithm with a constant seed:<pre>
_ = rand:seed(exs928ss, {123, 123534, 345345}),
R3 = rand:uniform(),</pre>Use the functional API with a non-constant seed:<pre>
S0 = rand:seed_s(exsss),
{R4, S1} = rand:uniform_s(S0),</pre>Textbook basic form Box-Muller standard normal deviate<pre>
R5 = rand:uniform_real(),
R6 = rand:uniform(),
SND0 = math:sqrt(-2 * math:log(R5)) * math:cos(math:pi() * R6)</pre>Create a standard normal deviate:<pre>
{SND1, S2} = rand:normal_s(S1),</pre>Create a normal deviate with mean -3 and variance 0.5:<pre>
{ND0, S3} = rand:normal_s(-3, 0.5, S2),</pre>
For all these generators except <strong>exro928ss</strong> and <strong>exsss</strong>
the lowest bit(s) has got a slightly less
random behaviour than all other bits.
1 bit for <strong>exrop</strong> (and <strong>exsp</strong>),
and 3 bits for <strong>exs1024s</strong>.
See for example the explanation in the
<a href="http://xoroshiro.di.unimi.it/xoroshiro128plus.c"> Xoroshiro128+ </a>
generator source code:
<pre>
Beside passing BigCrush, this generator passes the PractRand test suite
up to (and included) 16TB, with the exception of binary rank tests,
which fail due to the lowest bit being an LFSR; all other bits pass all
tests. We suggest to use a sign test to extract a random Boolean value.</pre>
If this is a problem; to generate a boolean with these algorithms
use something like this:
<pre>(rand:uniform(16) &gt; 8)</pre>
And for a general range, with <strong>N = 1</strong> for <strong>exrop</strong>,
and <strong>N = 3</strong> for <strong>exs1024s</strong>:
<pre>(((rand:uniform(Range bsl N) - 1) bsr N) + 1)</pre>
The floating point generating functions in this module
waste the lowest bits when converting from an integer
so they avoid this snag.
</p><h2>Data Types</h2><span class="name">builtin_alg</span><span class="name">alg</span><span class="name">alg_handler</span><span class="name">alg_state</span><span class="name">state</span><p>Algorithm-dependent state.</p><span class="name">export_state</span><p>
Algorithm-dependent state that can be printed or saved to file.
</p><span class="name">seed</span><p>
A seed value for the generator.
</p><p>
A list of integers sets the generator's internal state directly,
after algorithm-dependent checks of the value
and masking to the proper word size.
</p><p>
An integer is used as the initial state for a SplitMix64 generator.
The output values of that is then used for setting
the generator's internal state
after masking to the proper word size
and if needed avoiding zero values.
</p><p>
A traditional 3-tuple of integers seed is passed through
algorithm-dependent hashing functions to create
the generator's initial state.
</p><span class="name">exsplus_state</span><p>Algorithm specific internal state</p><span class="name">exro928_state</span><p>Algorithm specific internal state</p><span class="name">exrop_state</span><p>Algorithm specific internal state</p><span class="name">exs1024_state</span><p>Algorithm specific internal state</p><span class="name">exs64_state</span><p>Algorithm specific internal state</p><h2>Functions</h2><h3>export_seed/0</h3><p>Export the random number generation state.</p><a name="export_seed-0"></a><p>Returns the random number state in an external format.
To be used with <a href="#seed-1">seed-1</a>.</p><h3>export_seed_s/1</h3><p>Export the random number generation state.</p><a name="export_seed_s-1"></a><p>Returns the random number generator state in an external format.
To be used with <a href="#seed-1">seed-1</a>.</p><h3>jump/0</h3><p>Return the seed after performing jump calculation to the state in the process dictionary.</p><a name="jump-0"></a><p>Returns the state
after performing jump calculation
to the state in the process dictionary.</p><p>This function generates a <strong>not_implemented</strong> error exception
when the jump function is not implemented for
the algorithm specified in the state
in the process dictionary.</p><h3>jump/1</h3><p>Return the seed after performing jump calculation.</p><a name="jump-1"></a><p>Returns the state after performing jump calculation
to the given state. </p><p>This function generates a <strong>not_implemented</strong> error exception
when the jump function is not implemented for
the algorithm specified in the state.</p><h3>normal/0</h3><p>Return a standard normal distributed random float.</p><p>Returns a standard normal deviate float (that is, the mean
is 0 and the standard deviation is 1) and updates the state in
the process dictionary.</p><h3>normal/2</h3><p>Return a normal distributed random float.</p><p>Returns a normal N(Mean, Variance) deviate float
and updates the state in the process dictionary.</p><h3>normal_s/1</h3><p>Return a standard normal distributed random float.</p><p>Returns, for a specified state, a standard normal
deviate float (that is, the mean is 0 and the standard
deviation is 1) and a new state.</p><h3>normal_s/3</h3><p>Return a normal distributed random float.</p><p>Returns, for a specified state, a normal N(Mean, Variance)
deviate float and a new state.</p><h3>seed/1</h3><p>Seed random number generator.</p><a name="seed-1"></a><p>
Seeds random number generation with the specifed algorithm and
time-dependent data if <strong><span class="anno">AlgOrStateOrExpState</span></strong>
is an algorithm.
</p><p>Otherwise recreates the exported seed in the process dictionary,
and returns the state. See also
<a href="#export_seed-0">export_seed-0</a>.</p><h3>seed/2</h3><p>Seed the random number generation.</p><p>Seeds random number generation with the specified algorithm and
integers in the process dictionary and returns the state.</p><h3>seed_s/1</h3><p>Seed random number generator.</p><p>
Seeds random number generation with the specifed algorithm and
time-dependent data if <strong><span class="anno">AlgOrStateOrExpState</span></strong>
is an algorithm.
</p><p>Otherwise recreates the exported seed and returns the state.
See also <a href="#export_seed-0">export_seed-0</a>.</p><h3>seed_s/2</h3><p>Seed the random number generation.</p><p>Seeds random number generation with the specified algorithm and
integers and returns the state.</p><h3>uniform/0</h3><p>Return a random float.</p><a name="uniform-0"></a><p>
Returns a random float uniformly distributed in the value
range <strong>0.0 =&lt; <span class="anno">X</span> &lt; 1.0</strong> and
updates the state in the process dictionary.
</p><p>
The generated numbers are on the form N * 2.0^(-53),
that is; equally spaced in the interval.
</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>
This function may return exactly <strong>0.0</strong> which can be
fatal for certain applications.  If that is undesired
you can use <strong>(1.0 - rand:uniform())</strong> to get the
interval <strong>0.0 &lt; <span class="anno">X</span> =&lt; 1.0</strong>, or instead use
<a href="#uniform_real-0">uniform_real-0</a>.
</p><p>
If neither endpoint is desired you can test and re-try
like this:
</p><pre>
my_uniform() -&gt;
    case rand:uniform() of
        0.0 -&gt; my_uniform();
	X -&gt; X
    end
end.</pre></div><h3>uniform_real/0</h3><p>Return a random float.</p><a name="uniform_real-0"></a><p>
Returns a random float
uniformly distributed in the value range
<strong>DBL_MIN =&lt; <span class="anno">X</span> &lt; 1.0</strong>
and updates the state in the process dictionary.
</p><p>
Conceptually, a random real number <strong>R</strong> is generated
from the interval <strong>0 =&lt; R &lt; 1</strong> and then the
closest rounded down normalized number
in the IEEE 754 Double precision format
is returned.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
The generated numbers from this function has got better
granularity for small numbers than the regular
<a href="#uniform-0">uniform-0</a>
because all bits in the mantissa are random.
This property, in combination with the fact that exactly zero
is never returned is useful for algoritms doing for example
<strong>1.0 / <span class="anno">X</span></strong> or <strong>math:log(<span class="anno">X</span>)</strong>.
</p></div><p>
See
<a href="#uniform_real_s-1">uniform_real_s-1</a>
for more explanation.
</p><h3>uniform/1</h3><p>Return a random integer.</p><a name="uniform-1"></a><p>Returns, for a specified integer <strong><span class="anno">N</span> &gt;= 1</strong>,
a random integer uniformly distributed in the value range
<strong>1 =&lt; <span class="anno">X</span> =&lt; <span class="anno">N</span></strong> and
updates the state in the process dictionary.</p><h3>uniform_s/1</h3><p>Return a random float.</p><p>
Returns, for a specified state, random float
uniformly distributed in the value range <strong>0.0 =&lt; <span class="anno">X</span> &lt; 1.0</strong> and a new state.
</p><p>
The generated numbers are on the form N * 2.0^(-53),
that is; equally spaced in the interval.
</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>
This function may return exactly <strong>0.0</strong> which can be
fatal for certain applications.  If that is undesired
you can use <strong>(1.0 - rand:uniform(State))</strong> to get the
interval <strong>0.0 &lt; <span class="anno">X</span> =&lt; 1.0</strong>, or instead use
<a href="#uniform_real_s-1">uniform_real_s-1</a>.
</p><p>
If neither endpoint is desired you can test and re-try
like this:
</p><pre>
my_uniform(State) -&gt;
    case rand:uniform(State) of
        {0.0, NewState} -&gt; my_uniform(NewState);
	Result -&gt; Result
    end
end.</pre></div><h3>uniform_real_s/1</h3><p>Return a random float.</p><p>
Returns, for a specified state, a random float
uniformly distributed in the value range
<strong>DBL_MIN =&lt; <span class="anno">X</span> &lt; 1.0</strong>
and updates the state in the process dictionary.
</p><p>
Conceptually, a random real number <strong>R</strong> is generated
from the interval <strong>0 =&lt; R &lt; 1</strong> and then the
closest rounded down normalized number
in the IEEE 754 Double precision format
is returned.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
The generated numbers from this function has got better
granularity for small numbers than the regular
<a href="#uniform_s-1">uniform_s-1</a>
because all bits in the mantissa are random.
This property, in combination with the fact that exactly zero
is never returned is useful for algoritms doing for example
<strong>1.0 / <span class="anno">X</span></strong> or <strong>math:log(<span class="anno">X</span>)</strong>.
</p></div><p>
The concept implicates that the probability to get
exactly zero is extremely low; so low that this function
is in fact guaranteed to never return zero.  The smallest
number that it might return is <strong>DBL_MIN</strong>, which is
2.0^(-1022).
</p><p>
The value range stated at the top of this function
description is technically correct, but
<strong>0.0 =&lt; <span class="anno">X</span> &lt; 1.0</strong>
is a better description of the generated numbers'
statistical distribution.  Except that exactly 0.0
is never returned, which is not possible to observe
statistically.
</p><p>
For example; for all sub ranges
<strong>N*2.0^(-53) =&lt; X &lt; (N+1)*2.0^(-53)</strong>
where
<strong>0 =&lt; integer(N) &lt; 2.0^53</strong>
the probability is the same.
Compare that with the form of the numbers generated by
<a href="#uniform_s-1">uniform_s-1</a>.
</p><p>
Having to generate extra random bits for
small numbers costs a little performance.
This function is about 20% slower than the regular
<a href="#uniform_s-1">uniform_s-1</a>
</p><h3>uniform_s/2</h3><p>Return a random integer.</p><p>Returns, for a specified integer <strong><span class="anno">N</span> &gt;= 1</strong>
and a state, a random integer uniformly distributed in the value
range <strong>1 =&lt; <span class="anno">X</span> =&lt; <span class="anno">N</span></strong> and a
new state.</p><h2>random</h2><p>Pseudo-random number generation.</p><p>This module provides a random number generator. The method is attributed
to B.A. Wichmann and I.D. Hill in 'An efficient and portable
pseudo-random number generator', Journal of Applied
Statistics. AS183. 1982. Also Byte March 1987.The algorithm is a modification of the version attributed
to Richard A. O'Keefe in the standard Prolog library.Every time a random number is requested, a state is used to calculate
it, and a new state is produced. The state can either be implicit (kept
in the process dictionary) or be an explicit argument and return value.
In this implementation, the state (the type <strong>ran()</strong>) consists of a
tuple of three integers.</p><h2>Data Types</h2><span class="name">ran</span><p>The state.</p><h2>Functions</h2><h3>seed/0</h3><p>Seed random number generation with default values.</p><p>Seeds random number generation with default (fixed) values
in the process dictionary and returns the old state.</p><h3>seed/1</h3><p>Seed random number generator.</p><p><strong>seed({<span class="anno">A1</span>, <span class="anno">A2</span>, <span class="anno">A3</span>})</strong>
is equivalent to
<strong>seed(<span class="anno">A1</span>, <span class="anno">A2</span>, <span class="anno">A3</span>)</strong>.</p><h3>seed/3</h3><p>Seed random number generator.</p><p>Seeds random number generation with integer values in the process
dictionary and returns the old state.</p><p>The following is an easy way of obtaining a unique value to seed
with:</p><pre><code class="">
random:seed(erlang:phash2([node()]),
            erlang:monotonic_time(),
            erlang:unique_integer())</code></pre><p>For details, see
<a href="../erts/erlang#phash2/1">erts/erlang#phash2/1</a>,
<a href="../erts/erlang#node/0">erts/erlang#node/0</a>,
<a href="../erts/erlang#monotonic_time/0">erts/erlang#monotonic_time/0</a>, and
<a href="../erts/erlang#unique_integer/0">erts/erlang#unique_integer/0</a>.</p><h3>seed0/0</h3><p>Return default state for random number generation.</p><p>Returns the default state.</p><h3>uniform/0</h3><p>Return a random float.</p><p>Returns a random float uniformly distributed between <strong>0.0</strong>
and <strong>1.0</strong>, updating the state in the process dictionary.</p><h3>uniform/1</h3><p>Return a random integer.</p><p>Returns, for a specified integer <strong><span class="anno">N</span> &gt;= 1</strong>,
a random integer uniformly distributed between <strong>1</strong> and
<strong><span class="anno">N</span></strong>, updating the state in the process
dictionary.</p><h3>uniform_s/1</h3><p>Return a random float.</p><p>Returns, for a specified state, a random float uniformly
distributed between <strong>0.0</strong> and <strong>1.0</strong>, and a new state.</p><h3>uniform_s/2</h3><p>Return a random integer.</p><p>Returns, for a specified integer <strong><span class="anno">N</span> &gt;= 1</strong> and a
state, a random integer uniformly distributed between <strong>1</strong> and
<strong><span class="anno">N</span></strong>, and a new state.</p><h3>Note</h3><p>Some of the functions use the process dictionary variable
<strong>random_seed</strong> to remember the current seed.</p><p>If a process calls
<a href="#uniform/0">uniform/0</a> or
<a href="#uniform/1">uniform/1</a>
without setting a seed first,
<a href="#seed/0">seed/0</a>
is called automatically.</p><p>The implementation changed in Erlang/OTP R15. Upgrading to R15 breaks
applications that expect a specific output for a specified seed. The
output is still deterministic number series, but different compared to
releases older than R15. Seed <strong>{0,0,0}</strong> does, for example, no longer
produce a flawed series of only zeros.</p><h2>re</h2><p>Perl-like regular expressions for Erlang.</p><p>This module contains regular expression matching functions for
strings and binaries.The <a href="#regexp_syntax">regular expression</a>
syntax and semantics resemble that of Perl.The matching algorithms of the library are based on the
PCRE library, but not all of the PCRE library is interfaced and
some parts of the library go beyond what PCRE offers. Currently
PCRE version 8.40 (release date 2017-01-11) is used. The sections
of the PCRE documentation that are relevant to this module are
included here.</p><h2>Data Types</h2><span class="name">mp</span><p>Opaque data type containing a compiled regular expression.
<strong>mp()</strong> is guaranteed to be a tuple() having the atom
<strong>re_pattern</strong> as its first element, to allow for matching in
guards. The arity of the tuple or the content of the other fields
can change in future Erlang/OTP releases.</p><span class="name">nl_spec</span><span class="name">compile_option</span><h2>Functions</h2><h3>version/0</h3><p>Gives the PCRE version of the system in a string format</p><p>The return of this function is a string with the PCRE version of the system that was used in the Erlang/OTP compilation.</p><h3>compile/1</h3><p>Compile a regular expression into a match program</p><p>The same as <strong>compile(<span class="anno">Regexp</span>,[])</strong></p><h3>compile/2</h3><p>Compile a regular expression into a match program.</p><p>Compiles a regular expression, with the syntax
described below, into an internal format to be used later as a
parameter to
<a href="#run/2">run/2</a> and
<a href="#run/3">run/3</a>.</p><p>Compiling the regular expression before matching is useful if
the same expression is to be used in matching against multiple
subjects during the lifetime of the program. Compiling once and
executing many times is far more efficient than compiling each
time one wants to match.</p><p>When option <strong>unicode</strong> is specified, the regular expression
is to be specified as a valid Unicode <strong>charlist()</strong>, otherwise as
any valid <strong>iodata()</strong>.</p><a name="compile_options"></a><p>Options:</p><dl><dt><strong>unicode</strong></dt><dd> <p>The regular expression is specified as a Unicode
<strong>charlist()</strong> and the resulting regular expression code is to
be run against a valid Unicode <strong>charlist()</strong> subject. Also
consider option <strong>ucp</strong> when using Unicode characters.</p> </dd><dt><strong>anchored</strong></dt><dd> <p>The pattern is forced to be "anchored", that is, it is
constrained to match only at the first matching point in the
string that is searched (the "subject string"). This effect can
also be achieved by appropriate constructs in the pattern
itself.</p> </dd><dt><strong>caseless</strong></dt><dd> <p>Letters in the pattern match both uppercase and lowercase
letters. It is equivalent to Perl option <strong>/i</strong> and can be
changed within a pattern by a <strong>(?i)</strong> option setting.
Uppercase and lowercase letters are defined as in the ISO 8859-1
character set.</p> </dd><dt><strong>dollar_endonly</strong></dt><dd> <p>A dollar metacharacter in the pattern matches only at the end of
the subject string. Without this option, a dollar also matches
immediately before a newline at the end of the string (but not
before any other newlines). This option is ignored if option
<strong>multiline</strong> is specified. There is no equivalent option in
Perl, and it cannot be set within a pattern.</p> </dd><dt><strong>dotall</strong></dt><dd> <p>A dot in the pattern matches all characters, including those
indicating newline. Without it, a dot does not match when the
current position is at a newline. This option is equivalent to
Perl option <strong>/s</strong> and it can be changed within a pattern by a
<strong>(?s)</strong> option setting. A negative class, such as <strong>[^a]</strong>,
always matches newline characters, independent of the setting of
this option.</p> </dd><dt><strong>extended</strong></dt><dd> <p>If this option is set, most white space characters in the
pattern are totally ignored except when escaped or inside a
character class. However, white space is not allowed within
sequences such as <strong>(?&gt;</strong> that introduce various
parenthesized subpatterns, nor within a numerical quantifier
such as <strong>{1,3}</strong>. However, ignorable white space is permitted
between an item and a following quantifier and between a
quantifier and a following + that indicates possessiveness.
</p> <p>White space did not used to include the VT character (code
11), because Perl did not treat this character as white space.
However, Perl changed at release 5.18, so PCRE followed at
release 8.34, and VT is now treated as white space.
</p> <p>This also causes characters between an unescaped #
outside a character class and the next newline, inclusive, to
be ignored. This is equivalent to Perl's <strong>/x</strong> option, and it
can be changed within a pattern by a <strong>(?x)</strong> option setting.
</p> <p>With this option, comments inside complicated patterns can be
included. However, notice that this applies only to data
characters. Whitespace characters can never appear within special
character sequences in a pattern, for example within sequence
<strong>(?(</strong> that introduces a conditional subpattern.</p> </dd><dt><strong>firstline</strong></dt><dd> <p>An unanchored pattern is required to match before or at the first
newline in the subject string, although the matched text can
continue over the newline.</p> </dd><dt><strong>multiline</strong></dt><dd> <p>By default, PCRE treats the subject string as consisting of a
single line of characters (even if it contains newlines). The
"start of line" metacharacter (<strong>^</strong>) matches only at the
start of the string, while the "end of line" metacharacter
(<strong>$</strong>) matches only at the end of the string, or before a
terminating newline (unless option <strong>dollar_endonly</strong> is
specified). This is the same as in Perl.</p> <p>When this option is specified, the "start of line" and "end of
line" constructs match immediately following or immediately
before internal newlines in the subject string, respectively, as
well as at the very start and end. This is equivalent to Perl
option <strong>/m</strong> and can be changed within a pattern by a
<strong>(?m)</strong> option setting. If there are no newlines in a subject
string, or no occurrences of <strong>^</strong> or <strong>$</strong> in a pattern,
setting <strong>multiline</strong> has no effect.</p> </dd><dt><strong>no_auto_capture</strong></dt><dd> <p>Disables the use of numbered capturing parentheses in the
pattern. Any opening parenthesis that is not followed by <strong>?</strong>
behaves as if it is followed by <strong>?:</strong>. Named parentheses can
still be used for capturing (and they acquire numbers in the
usual way). There is no equivalent option in Perl.</p> </dd><dt><strong>dupnames</strong></dt><dd> <p>Names used to identify capturing subpatterns need not be unique.
This can be helpful for certain types of pattern when it is known
that only one instance of the named subpattern can ever be
matched. More details of named subpatterns are provided below.</p> </dd><dt><strong>ungreedy</strong></dt><dd> <p>Inverts the "greediness" of the quantifiers so that they are not
greedy by default, but become greedy if followed by "?". It is
not compatible with Perl. It can also be set by a <strong>(?U)</strong>
option setting within the pattern.</p> </dd><dt><strong>{newline, NLSpec}</strong></dt><dd> <p>Overrides the default definition of a newline in the subject
string, which is LF (ASCII 10) in Erlang.</p> <dl><dt><strong>cr</strong></dt><dd> <p>Newline is indicated by a single character <strong>cr</strong>
(ASCII 13).</p> </dd><dt><strong>lf</strong></dt><dd> <p>Newline is indicated by a single character LF (ASCII 10), the
default.</p> </dd><dt><strong>crlf</strong></dt><dd> <p>Newline is indicated by the two-character CRLF (ASCII 13
followed by ASCII 10) sequence.</p> </dd><dt><strong>anycrlf</strong></dt><dd> <p>Any of the three preceding sequences is to be recognized.</p> </dd><dt><strong>any</strong></dt><dd> <p>Any of the newline sequences above, and the Unicode sequences
VT (vertical tab, U+000B), FF (formfeed, U+000C), NEL (next
line, U+0085), LS (line separator, U+2028), and PS (paragraph
separator, U+2029).</p> </dd></dl> </dd><dt><strong>bsr_anycrlf</strong></dt><dd> <p>Specifies specifically that \R is to match only the CR,
LF, or CRLF sequences, not the Unicode-specific newline
characters.</p> </dd><dt><strong>bsr_unicode</strong></dt><dd> <p>Specifies specifically that \R is to match all the Unicode
newline characters (including CRLF, and so on, the default).</p> </dd><dt><strong>no_start_optimize</strong></dt><dd> <p>Disables optimization that can malfunction if "Special
start-of-pattern items" are present in the regular expression. A
typical example would be when matching "DEFABC" against
"(*COMMIT)ABC", where the start optimization of PCRE would skip
the subject up to "A" and never realize that the (*COMMIT)
instruction is to have made the matching fail. This option is only
relevant if you use "start-of-pattern items", as discussed in
section <a href="#regexp_syntax_details">PCRE Regular Expression Details</a>.</p> </dd><dt><strong>ucp</strong></dt><dd> <p>Specifies that Unicode character properties are to be used when
resolving \B, \b, \D, \d, \S, \s, \W and \w. Without this flag,
only ISO Latin-1 properties are used. Using Unicode properties
hurts performance, but is semantically correct when working with
Unicode characters beyond the ISO Latin-1 range.</p> </dd><dt><strong>never_utf</strong></dt><dd> <p>Specifies that the (*UTF) and/or (*UTF8) "start-of-pattern
items" are forbidden. This flag cannot be combined with option
<strong>unicode</strong>. Useful if ISO Latin-1 patterns from an external
source are to be compiled.</p> </dd></dl><h3>inspect/2</h3><p>Inspects a compiled regular expression.</p><p>Takes a compiled regular expression and an item, and returns the
relevant data from the regular expression. The only
supported item is <strong>namelist</strong>, which returns the tuple
<strong>{namelist, [binary()]}</strong>, containing the names of all (unique)
named subpatterns in the regular expression. For example:</p><pre><code class="">
1&gt; {ok,MP} = re:compile("(?&lt;A&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)").
{ok,{re_pattern,3,0,0,
                &lt;&lt;69,82,67,80,119,0,0,0,0,0,0,0,1,0,0,0,255,255,255,255,
                  255,255,...&gt;&gt;}}
2&gt; re:inspect(MP,namelist).
{namelist,[&lt;&lt;"A"&gt;&gt;,&lt;&lt;"B"&gt;&gt;,&lt;&lt;"C"&gt;&gt;]}
3&gt; {ok,MPD} = re:compile("(?&lt;C&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)",[dupnames]).
{ok,{re_pattern,3,0,0,
                &lt;&lt;69,82,67,80,119,0,0,0,0,0,8,0,1,0,0,0,255,255,255,255,
                  255,255,...&gt;&gt;}}
4&gt; re:inspect(MPD,namelist).                                   
{namelist,[&lt;&lt;"B"&gt;&gt;,&lt;&lt;"C"&gt;&gt;]}</code></pre><p>Notice in the second example that the duplicate name only occurs
once in the returned list, and that the list is in alphabetical order
regardless of where the names are positioned in the regular
expression. The order of the names is the same as the order of
captured subexpressions if <strong>{capture, all_names}</strong> is specified as
an option to <a href="#run/3">run/3</a>.
You can therefore create a name-to-value mapping from the result of
<strong>run/3</strong> like this:</p><pre><code class="">
1&gt; {ok,MP} = re:compile("(?&lt;A&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)").
{ok,{re_pattern,3,0,0,
                &lt;&lt;69,82,67,80,119,0,0,0,0,0,0,0,1,0,0,0,255,255,255,255,
                  255,255,...&gt;&gt;}}
2&gt; {namelist, N} = re:inspect(MP,namelist).
{namelist,[&lt;&lt;"A"&gt;&gt;,&lt;&lt;"B"&gt;&gt;,&lt;&lt;"C"&gt;&gt;]}
3&gt; {match,L} = re:run("AA",MP,[{capture,all_names,binary}]).
{match,[&lt;&lt;"A"&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;]}
4&gt; NameMap = lists:zip(N,L).
[{&lt;&lt;"A"&gt;&gt;,&lt;&lt;"A"&gt;&gt;},{&lt;&lt;"B"&gt;&gt;,&lt;&lt;&gt;&gt;},{&lt;&lt;"C"&gt;&gt;,&lt;&lt;&gt;&gt;}]</code></pre><h3>replace/3</h3><p>Match a subject against regular expression and replace matching elements with Replacement.</p><p>Same as <strong>replace(<span class="anno">Subject</span>, <span class="anno">RE</span>, <span class="anno">Replacement</span>, [])</strong>.</p><h3>replace/4</h3><p>Match a subject against regular expression and replace matching elements with Replacement.</p><p>Replaces the matched part of the <strong><span class="anno">Subject</span></strong> string
with the contents of <strong><span class="anno">Replacement</span></strong>.</p><p>The permissible options are the same as for
<a href="#run/3">run/3</a>, except that option<strong> capture</strong> is not allowed. Instead a <strong>{return, <span class="anno">ReturnType</span>}</strong> is present. The default return type is
<strong>iodata</strong>, constructed in a way to minimize copying. The
<strong>iodata</strong> result can be used directly in many I/O operations. If a
flat <strong>list()</strong> is desired, specify <strong>{return, list}</strong>. If a
binary is desired, specify <strong>{return, binary}</strong>.</p><p>As in function <strong>run/3</strong>, an <strong>mp()</strong> compiled with option
<strong>unicode</strong> requires <strong><span class="anno">Subject</span></strong> to be a Unicode
<strong>charlist()</strong>. If compilation is done implicitly and the
<strong>unicode</strong> compilation option is specified to this function, both
the regular expression and <strong><span class="anno">Subject</span></strong> are to
specified as valid Unicode <strong>charlist()</strong>s.</p><p>The replacement string can contain the special character
<strong>&amp;</strong>, which inserts the whole matching expression in the
result, and the special sequence <strong>\</strong>N (where N is an integer &gt;
0), <strong>\g</strong>N, or <strong>\g{</strong>N<strong>}</strong>, resulting in the subexpression
number N, is inserted in the result. If no subexpression with that
number is generated by the regular expression, nothing is
inserted.</p><p>To insert an &amp; or a \ in the result, precede it
with a \. Notice that Erlang already gives a special meaning to
\ in literal strings, so a single \ must be written as
<strong>"\\"</strong> and therefore a double \ as <strong>"\\\\"</strong>.</p><p><em>Example:</em></p><pre><code class="">
re:replace("abcd","c","[&amp;]",[{return,list}]).</code></pre><p>gives</p><pre><code class="">
"ab[c]d"</code></pre><p>while</p><pre><code class="">
re:replace("abcd","c","[\\&amp;]",[{return,list}]).</code></pre><p>gives</p><pre><code class="">
"ab[&amp;]d"</code></pre><p>As with <strong>run/3</strong>, compilation errors raise the <strong>badarg</strong>
exception. <a href="#compile/2">compile/2</a>
can be used to get more information about the error.</p><h3>run/2</h3><p>Match a subject against regular expression and capture subpatterns.</p><p>Same as <strong>run(<span class="anno">Subject</span>,<span class="anno">RE</span>,[])</strong>.</p><h3>run/3</h3><p>Match a subject against regular expression and capture subpatterns.</p><dl><dt>CompileOpt</dt><dd>See <a href="#compile_options">compile_options</a>.</dd></dl><p>Executes a regular expression matching, and returns
<strong>match/{match, <span class="anno">Captured</span>}</strong> or <strong>nomatch</strong>. The
regular expression can be specified either as <strong>iodata()</strong> in
which case it is automatically compiled (as by <strong>compile/2</strong>) and
executed, or as a precompiled <strong>mp()</strong> in which case it is executed
against the subject directly.</p><p>When compilation is involved, exception <strong>badarg</strong> is thrown if a
compilation error occurs. Call <strong>compile/2</strong> to get information
about the location of the error in the regular expression.</p><p>If the regular expression is previously compiled, the option list can
only contain the following options:</p><ul><li><strong>anchored</strong></li><li><strong>{capture, <span class="anno">ValueSpec</span>}/{capture, <span class="anno">ValueSpec</span>, <span class="anno">Type</span>}</strong></li><li><strong>global</strong></li><li><strong>{match_limit, integer() &gt;= 0}</strong></li><li><strong>{match_limit_recursion, integer() &gt;= 0}</strong></li><li><strong>{newline, <span class="anno">NLSpec</span>}</strong></li><li><strong>notbol</strong></li><li><strong>notempty</strong></li><li><strong>notempty_atstart</strong></li><li><strong>noteol</strong></li><li><strong>{offset, integer() &gt;= 0}</strong></li><li><strong>report_errors</strong></li></ul><p>Otherwise all options valid for function <strong>compile/2</strong> are also
allowed. Options allowed both for compilation and execution of a
match, namely <strong>anchored</strong> and <strong>{newline, <span class="anno">NLSpec</span>}</strong>, affect both the compilation and execution if
present together with a non-precompiled regular expression.</p><p>If the regular expression was previously compiled with option
<strong>unicode</strong>, <strong><span class="anno">Subject</span></strong> is to be provided as a
valid Unicode <strong>charlist()</strong>, otherwise any <strong>iodata()</strong> will
do. If compilation is involved and option <strong>unicode</strong> is specified,
both <strong><span class="anno">Subject</span></strong> and the regular expression are to be
specified as valid Unicode <strong>charlists()</strong>.</p><p><strong>{capture, <span class="anno">ValueSpec</span>}/{capture, <span class="anno">ValueSpec</span>, <span class="anno">Type</span>}</strong> defines what to return
from the function upon successful matching. The <strong>capture</strong> tuple
can contain both a value specification, telling which of the captured
substrings are to be returned, and a type specification, telling how
captured substrings are to be returned (as index tuples, lists, or
binaries). The options are described in detail below.</p><p>If the capture options describe that no substring capturing is to be
done (<strong>{capture, none}</strong>), the function returns the single atom
<strong>match</strong> upon successful matching, otherwise the tuple
<strong>{match, <span class="anno">ValueList</span>}</strong>. Disabling capturing can be
done either by specifying <strong>none</strong> or an empty list as
<strong><span class="anno">ValueSpec</span></strong>.</p><p>Option <strong>report_errors</strong> adds the possibility that an error tuple
is returned. The tuple either indicates a matching error
(<strong>match_limit</strong> or <strong>match_limit_recursion</strong>), or a compilation
error, where the error tuple has the format <strong>{error, {compile, <span class="anno">CompileErr</span>}}</strong>. Notice that if option
<strong>report_errors</strong> is not specified, the function never returns
error tuples, but reports compilation errors as a <strong>badarg</strong>
exception and failed matches because of exceeded match limits simply
as <strong>nomatch</strong>.</p><p>The following options are relevant for execution:</p><dl><dt><strong>anchored</strong></dt><dd> <p>Limits <strong>run/3</strong> to matching at the first matching
position. If a pattern was compiled with <strong>anchored</strong>, or
turned out to be anchored by virtue of its contents, it cannot
be made unanchored at matching time, hence there is no
<strong>unanchored</strong> option.</p></dd><dt><strong>global</strong></dt><dd> <p>Implements global (repetitive) search (flag <strong>g</strong> in Perl).
Each match is returned as a separate <strong>list()</strong> containing the
specific match and any matching subexpressions (or as specified
by option <strong>capture</strong>. The <strong><span class="anno">Captured</span></strong> part
of the return value is hence a <strong>list()</strong> of <strong>list()</strong>s
when this option is specified.</p> <p>The interaction of option <strong>global</strong> with a regular
expression that matches an empty string surprises some users.
When option <strong>global</strong> is specified, <strong>run/3</strong> handles
empty matches in the same way as Perl: a zero-length match at any
point is also retried with options <strong>[anchored, notempty_atstart]</strong>. If that search gives a result of length
&gt; 0, the result is included. Example:</p> <pre><code class="">
re:run("cat","(|at)",[global]).</code></pre> <p>The following matchings are performed:</p> <dl><dt>At offset <strong>0</strong></dt><dd> <p>The regular expression <strong>(|at)</strong> first match at the
initial position of string <strong>cat</strong>, giving the result set
<strong>[{0,0},{0,0}]</strong> (the second <strong>{0,0}</strong> is because of
the subexpression marked by the parentheses). As the length
of the match is 0, we do not advance to the next position
yet.</p> </dd><dt>At offset <strong>0</strong> with <strong>[anchored, notempty_atstart]</strong></dt><dd> <p>The search is retried with options <strong>[anchored, notempty_atstart]</strong> at the same position, which does not
give any interesting result of longer length, so the search
position is advanced to the next character (<strong>a</strong>).</p> </dd><dt>At offset <strong>1</strong></dt><dd> <p>The search results in <strong>[{1,0},{1,0}]</strong>, so this search is
also repeated with the extra options.</p> </dd><dt>At offset <strong>1</strong> with <strong>[anchored, notempty_atstart]</strong></dt><dd> <p>Alternative <strong>ab</strong> is found and the result is
[{1,2},{1,2}]. The result is added to the list of results and
the position in the search string is advanced two steps.</p> </dd><dt>At offset <strong>3</strong></dt><dd> <p>The search once again matches the empty string, giving
<strong>[{3,0},{3,0}]</strong>.</p> </dd><dt>At offset <strong>1</strong> with <strong>[anchored, notempty_atstart]</strong></dt><dd> <p>This gives no result of length &gt; 0 and we are at the last
position, so the global search is complete.</p> </dd></dl> <p>The result of the call is:</p> <pre><code class="">
{match,[[{0,0},{0,0}],[{1,0},{1,0}],[{1,2},{1,2}],[{3,0},{3,0}]]}</code></pre> </dd><dt><strong>notempty</strong></dt><dd> <p>An empty string is not considered to be a valid match if this
option is specified. If alternatives in the pattern exist, they
are tried. If all the alternatives match the empty string, the
entire match fails.</p> <p><em>Example:</em></p> <p>If the following pattern is applied to a string not beginning
with "a" or "b", it would normally match the empty string at the
start of the subject:</p> <pre><code class="">
a?b?</code></pre> <p>With option <strong>notempty</strong>, this match is invalid, so
<strong>run/3</strong> searches further into the string for occurrences of
"a" or "b".</p> </dd><dt><strong>notempty_atstart</strong></dt><dd> <p>Like <strong>notempty</strong>, except that an empty string match that is
not at the start of the subject is permitted. If the pattern is
anchored, such a match can occur only if the pattern contains
\K.</p> <p>Perl has no direct equivalent of <strong>notempty</strong> or
<strong>notempty_atstart</strong>, but it does make a special case of a
pattern match of the empty string within its split() function,
and when using modifier <strong>/g</strong>. The Perl behavior can be
emulated after matching a null string by first trying the
match again at the same offset with <strong>notempty_atstart</strong> and
<strong>anchored</strong>, and then, if that fails, by advancing the
starting offset (see below) and trying an ordinary match
again.</p> </dd><dt><strong>notbol</strong></dt><dd> <p>Specifies that the first character of the subject string is not
the beginning of a line, so the circumflex metacharacter is not
to match before it. Setting this without <strong>multiline</strong> (at
compile time) causes circumflex never to match. This option only
affects the behavior of the circumflex metacharacter. It does not
affect \A.</p> </dd><dt><strong>noteol</strong></dt><dd> <p>Specifies that the end of the subject string is not the end of a
line, so the dollar metacharacter is not to match it nor (except
in multiline mode) a newline immediately before it. Setting this
without <strong>multiline</strong> (at compile time) causes dollar never to
match. This option affects only the behavior of the dollar
metacharacter. It does not affect \Z or \z.</p> </dd><dt><strong>report_errors</strong></dt><dd> <p>Gives better control of the error handling in <strong>run/3</strong>. When
specified, compilation errors (if the regular expression is not
already compiled) and runtime errors are explicitly returned as
an error tuple.</p>  <p>The following are the possible runtime errors:</p> <dl><dt><strong>match_limit</strong></dt><dd> <p>The PCRE library sets a limit on how many times the internal
match function can be called. Defaults to 10,000,000 in the
library compiled for Erlang. If <strong>{error, match_limit}</strong>
is returned, the execution of the regular expression has
reached this limit. This is normally to be regarded as a
<strong>nomatch</strong>, which is the default return value when this
occurs, but by specifying <strong>report_errors</strong>, you are
informed when the match fails because of too many internal
calls.</p> </dd><dt><strong>match_limit_recursion</strong></dt><dd> <p>This error is very similar to <strong>match_limit</strong>, but occurs
when the internal match function of PCRE is "recursively"
called more times than the <strong>match_limit_recursion</strong> limit,
which defaults to 10,000,000 as well. Notice that as long as
the <strong>match_limit</strong>
and <strong>match_limit_default</strong> values are
kept at the default values, the <strong>match_limit_recursion</strong>
error cannot occur, as the <strong>match_limit</strong> error occurs
before that (each recursive call is also a call, but not
conversely). Both limits can however be changed, either by
setting limits directly in the regular expression string (see
section <a href="#regexp_syntax_details">PCRE Regular Eexpression Details</a>) or by specifying options to
<strong>run/3</strong>.</p> </dd></dl> <p>It is important to understand that what is referred to as
"recursion" when limiting matches is not recursion on the C stack
of the Erlang machine or on the Erlang process stack. The PCRE
version compiled into the Erlang VM uses machine "heap" memory to
store values that must be kept over recursion in regular
expression matches.</p> </dd><dt><strong>{match_limit, integer() &gt;= 0}</strong></dt><dd> <p>Limits the execution time of a match in an
implementation-specific way. It is described as follows by the
PCRE documentation:</p> <pre><code class="">
The match_limit field provides a means of preventing PCRE from using
up a vast amount of resources when running patterns that are not going
to match, but which have a very large number of possibilities in their
search trees. The classic example is a pattern that uses nested
unlimited repeats.

Internally, pcre_exec() uses a function called match(), which it calls
repeatedly (sometimes recursively). The limit set by match_limit is
imposed on the number of times this function is called during a match,
which has the effect of limiting the amount of backtracking that can
take place. For patterns that are not anchored, the count restarts
from zero for each position in the subject string.</code></pre> <p>This means that runaway regular expression matches can fail
faster if the limit is lowered using this option. The default
value 10,000,000 is compiled into the Erlang VM.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This option does in no way affect the execution of the Erlang
VM in terms of "long running BIFs". <strong>run/3</strong> always gives
control back to the scheduler of Erlang processes at intervals
that ensures the real-time properties of the Erlang system.</p></div> </dd><dt><strong>{match_limit_recursion, integer() &gt;= 0}</strong></dt><dd> <p>Limits the execution time and memory consumption of a match in an
implementation-specific way, very similar to <strong>match_limit</strong>.
It is described as follows by the PCRE documentation:</p> <pre><code class="">
The match_limit_recursion field is similar to match_limit, but instead
of limiting the total number of times that match() is called, it
limits the depth of recursion. The recursion depth is a smaller number
than the total number of calls, because not all calls to match() are
recursive. This limit is of use only if it is set smaller than
match_limit.

Limiting the recursion depth limits the amount of machine stack that
can be used, or, when PCRE has been compiled to use memory on the heap
instead of the stack, the amount of heap memory that can be used.</code></pre> <p>The Erlang VM uses a PCRE library where heap memory is used when
regular expression match recursion occurs. This therefore limits
the use of machine heap, not C stack.</p> <p>Specifying a lower value can result in matches with deep
recursion failing, when they should have matched:</p> <pre><code class="">
1&gt; re:run("aaaaaaaaaaaaaz","(a+)*z").
{match,[{0,14},{0,13}]}
2&gt; re:run("aaaaaaaaaaaaaz","(a+)*z",[{match_limit_recursion,5}]).
nomatch
3&gt; re:run("aaaaaaaaaaaaaz","(a+)*z",[{match_limit_recursion,5},report_errors]).
{error,match_limit_recursion}</code></pre> <p>This option and option <strong>match_limit</strong> are only to be used in
rare cases. Understanding of the PCRE library internals is
recommended before tampering with these limits.</p> </dd><dt><strong>{offset, integer() &gt;= 0}</strong></dt><dd> <p>Start matching at the offset (position) specified in the
subject string. The offset is zero-based, so that the default is
<strong>{offset,0}</strong> (all of the subject string).</p> </dd><dt><strong>{newline, <span class="anno">NLSpec</span>}</strong></dt><dd> <p>Overrides the default definition of a newline in the subject
string, which is LF (ASCII 10) in Erlang.</p> <dl><dt><strong>cr</strong></dt><dd> <p>Newline is indicated by a single character CR (ASCII 13).</p> </dd><dt><strong>lf</strong></dt><dd> <p>Newline is indicated by a single character LF (ASCII 10),
the default.</p> </dd><dt><strong>crlf</strong></dt><dd> <p>Newline is indicated by the two-character CRLF (ASCII 13
followed by ASCII 10) sequence.</p> </dd><dt><strong>anycrlf</strong></dt><dd> <p>Any of the three preceding sequences is be recognized.</p> </dd><dt><strong>any</strong></dt><dd> <p>Any of the newline sequences above, and the Unicode
sequences VT (vertical tab, U+000B), FF (formfeed, U+000C), NEL
(next line, U+0085), LS (line separator, U+2028), and PS
(paragraph separator, U+2029).</p> </dd></dl> </dd><dt><strong>bsr_anycrlf</strong></dt><dd> <p>Specifies specifically that \R is to match only the CR
LF, or CRLF sequences, not the Unicode-specific newline
characters. (Overrides the compilation option.)</p> </dd><dt><strong>bsr_unicode</strong></dt><dd> <p>Specifies specifically that \R is to match all the Unicode
newline characters (including CRLF, and so on, the default).
(Overrides the compilation option.)</p> </dd><dt><strong>{capture, <span class="anno">ValueSpec</span>}</strong>/<strong>{capture, <span class="anno">ValueSpec</span>, <span class="anno">Type</span>}</strong></dt><dd> <p>Specifies which captured substrings are returned and in what
format. By default, <strong>run/3</strong> captures all of the matching
part of the substring and all capturing subpatterns (all of the
pattern is automatically captured). The default return type is
(zero-based) indexes of the captured parts of the string,
specified as <strong>{Offset,Length}</strong> pairs (the <strong>index</strong>
<strong><span class="anno">Type</span></strong> of capturing).</p> <p>As an example of the default behavior, the following call
returns, as first and only captured string, the matching part of
the subject ("abcd" in the middle) as an index pair <strong>{3,4}</strong>,
where character positions are zero-based, just as in offsets:</p> <pre><code class="">
re:run("ABCabcdABC","abcd",[]).</code></pre>       <p>The return value of this call is:</p> <pre><code class="">
{match,[{3,4}]}</code></pre> <p>Another (and quite common) case is where the regular expression
matches all of the subject:</p> <pre><code class="">
re:run("ABCabcdABC",".*abcd.*",[]).</code></pre> <p>Here the return value correspondingly points out all of the
string, beginning at index 0, and it is 10 characters long:</p> <pre><code class="">
{match,[{0,10}]}</code></pre> <p>If the regular expression contains capturing subpatterns, like
in:</p> <pre><code class="">
re:run("ABCabcdABC",".*(abcd).*",[]).</code></pre>       <p>all of the matched subject is captured, as well as the captured
substrings:</p> <pre><code class="">
{match,[{0,10},{3,4}]}</code></pre> <p>The complete matching pattern always gives the first return
value in the list and the remaining subpatterns are added in the
order they occurred in the regular expression.</p> <p>The capture tuple is built up as follows:</p> <dl><dt><strong><span class="anno">ValueSpec</span></strong></dt><dd> <p>Specifies which captured (sub)patterns are to be returned.
<strong><span class="anno">ValueSpec</span></strong> can either be an atom describing
a predefined set of return values, or a list containing the
indexes or the names of specific subpatterns to return.</p> <p>The following are the predefined sets of subpatterns:</p> <dl><dt><strong>all</strong></dt><dd> <p>All captured subpatterns including the complete matching
string. This is the default.</p> </dd><dt><strong>all_names</strong></dt><dd> <p>All <em>named</em> subpatterns in the regular expression,
as if a <strong>list()</strong> of all the names <em>in alphabetical order</em> was specified. The list of all
names can also be retrieved with
<a href="#inspect/2">inspect/2</a>.</p> </dd><dt><strong>first</strong></dt><dd> <p>Only the first captured subpattern, which is always the
complete matching part of the subject. All explicitly
captured subpatterns are discarded.</p> </dd><dt><strong>all_but_first</strong></dt><dd> <p>All but the first matching subpattern, that is, all
explicitly captured subpatterns, but not the complete
matching part of the subject string. This is useful if
the regular expression as a whole matches a large part of
the subject, but the part you are interested in is in an
explicitly captured subpattern. If the return type is
<strong>list</strong> or <strong>binary</strong>, not returning subpatterns
you are not interested in is a good way to optimize.</p> </dd><dt><strong>none</strong></dt><dd> <p>Returns no matching subpatterns, gives the single
atom <strong>match</strong> as the return value of the function
when matching successfully instead of the <strong>{match, list()}</strong> return. Specifying an empty list gives the
same behavior.</p> </dd></dl> <p>The value list is a list of indexes for the subpatterns to
return, where index 0 is for all of the pattern, and 1 is for
the first explicit capturing subpattern in the regular
expression, and so on. When using named captured subpatterns
(see below) in the regular expression, one can use
<strong>atom()</strong>s or <strong>string()</strong>s to specify the subpatterns
to be returned. For example, consider the regular
expression:</p> <pre><code class="">
".*(abcd).*"</code></pre> <p>matched against string "ABCabcdABC", capturing only the
"abcd" part (the first explicit subpattern):</p> <pre><code class="">
re:run("ABCabcdABC",".*(abcd).*",[{capture,[1]}]).</code></pre> <p>The call gives the following result, as the first explicitly
captured subpattern is "(abcd)", matching "abcd" in the
subject, at (zero-based) position 3, of length 4:</p> <pre><code class="">
{match,[{3,4}]}</code></pre> <p>Consider the same regular expression, but with the subpattern
explicitly named 'FOO':</p> <pre><code class="">
".*(?&lt;FOO&gt;abcd).*"</code></pre> <p>With this expression, we could still give the index of the
subpattern with the following call:</p> <pre><code class="">
re:run("ABCabcdABC",".*(?&lt;FOO&gt;abcd).*",[{capture,[1]}]).</code></pre> <p>giving the same result as before. But, as the subpattern is
named, we can also specify its name in the value list:</p> <pre><code class="">
re:run("ABCabcdABC",".*(?&lt;FOO&gt;abcd).*",[{capture,['FOO']}]).</code></pre> <p>This would give the same result as the earlier examples,
namely:</p> <pre><code class="">
{match,[{3,4}]}</code></pre> <p>The values list can specify indexes or names not present in
the regular expression, in which case the return values vary
depending on the type. If the type is <strong>index</strong>, the tuple
<strong>{-1,0}</strong> is returned for values with no corresponding
subpattern in the regular expression, but for the other types
(<strong>binary</strong> and <strong>list</strong>), the values are the empty
binary or list, respectively.</p> </dd><dt><strong><span class="anno">Type</span></strong></dt><dd> <p>Optionally specifies how captured substrings are to be
returned. If omitted, the default of <strong>index</strong> is used.</p> <p><strong><span class="anno">Type</span></strong> can be one of the following:</p> <dl><dt><strong>index</strong></dt><dd> <p>Returns captured substrings as pairs of byte indexes
into the subject string and length of the matching string
in the subject (as if the subject string was flattened
with <a href="../erts/erlang#iolist_to_binary/1">erts/erlang#iolist_to_binary/1</a> or
<a href="./unicode#characters_to_binary/2">unicode#characters_to_binary/2</a> before
matching). Notice that option <strong>unicode</strong> results in
<em>byte-oriented</em> indexes in a (possibly virtual)
<em>UTF-8 encoded</em> binary. A byte index tuple
<strong>{0,2}</strong> can therefore represent one or two
characters when <strong>unicode</strong> is in effect. This can seem
counter-intuitive, but has been deemed the most effective
and useful way to do it. To return lists instead can
result in simpler code if that is desired. This return
type is the default.</p> </dd><dt><strong>list</strong></dt><dd> <p>Returns matching substrings as lists of characters
(Erlang <strong>string()</strong>s). It option <strong>unicode</strong> is
used in combination with the \C sequence in the
regular expression, a captured subpattern can contain
bytes that are not valid UTF-8 (\C matches bytes
regardless of character encoding). In that case the
<strong>list</strong> capturing can result in the same types of
tuples that
<a href="./unicode#characters_to_list/2">unicode#characters_to_list/2</a> can return,
namely three-tuples with tag <strong>incomplete</strong> or
<strong>error</strong>, the successfully converted characters and
the invalid UTF-8 tail of the conversion as a binary. The
best strategy is to avoid using the \C sequence
when capturing lists.</p> </dd><dt><strong>binary</strong></dt><dd> <p>Returns matching substrings as binaries. If option
<strong>unicode</strong> is used, these binaries are in UTF-8. If
the \C sequence is used together with
<strong>unicode</strong>, the binaries can be invalid UTF-8.</p> </dd></dl> </dd></dl> <p>In general, subpatterns that were not assigned a value in the
match are returned as the tuple <strong>{-1,0}</strong> when <strong>type</strong> is
<strong>index</strong>. Unassigned subpatterns are returned as the empty
binary or list, respectively, for other return types. Consider
the following regular expression:</p> <pre><code class="">
".*((?&lt;FOO&gt;abdd)|a(..d)).*"</code></pre> <p>There are three explicitly capturing subpatterns, where the
opening parenthesis position determines the order in the result,
hence <strong>((?&lt;FOO&gt;abdd)|a(..d))</strong> is subpattern index 1,
<strong>(?&lt;FOO&gt;abdd)</strong> is subpattern index 2, and <strong>(..d)</strong>
is subpattern index 3. When matched against the following
string:</p> <pre><code class="">
"ABCabcdABC"</code></pre> <p>the subpattern at index 2 does not match, as "abdd" is not
present in the string, but the complete pattern matches (because
of the alternative <strong>a(..d)</strong>). The subpattern at index 2 is
therefore unassigned and the default return value is:</p> <pre><code class="">
{match,[{0,10},{3,4},{-1,0},{4,3}]}</code></pre> <p>Setting the capture <strong><span class="anno">Type</span></strong> to <strong>binary</strong>
gives:</p> <pre><code class="">
{match,[&lt;&lt;"ABCabcdABC"&gt;&gt;,&lt;&lt;"abcd"&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;"bcd"&gt;&gt;]}</code></pre> <p>Here the empty binary (<strong>&lt;&lt;&gt;&gt;</strong>) represents the
unassigned subpattern. In the <strong>binary</strong> case, some information
about the matching is therefore lost, as
<strong>&lt;&lt;&gt;&gt;</strong> can
also be an empty string captured.</p> <p>If differentiation between empty matches and non-existing
subpatterns is necessary, use the <strong>type</strong> <strong>index</strong> and do
the conversion to the final type in Erlang code.</p> <p>When option <strong>global</strong> is speciified, the <strong>capture</strong>
specification affects each match separately, so that:</p> <pre><code class="">
re:run("cacb","c(a|b)",[global,{capture,[1],list}]).</code></pre> <p>gives</p> <pre><code class="">
{match,[["a"],["b"]]}</code></pre> </dd></dl><p>For a descriptions of options only affecting the compilation step,
see <a href="#compile/2">compile/2</a>.</p><h3>split/2</h3><p>Split a string by tokens specified as a regular expression. </p><p>Same as <strong>split(<span class="anno">Subject</span>, <span class="anno">RE</span>, [])</strong>.</p><h3>split/3</h3><p>Split a string by tokens specified as a regular expression</p><dl><dt>CompileOpt</dt><dd>See <a href="#compile_options">compile_options</a>.</dd></dl><p>Splits the input into parts by finding tokens according to the
regular expression supplied. The splitting is basically done by
running a global regular expression match and dividing the initial
string wherever a match occurs. The matching part of the string is
removed from the output.</p><p>As in <a href="#run/3">run/3</a>, an <strong>mp()</strong>
compiled with option <strong>unicode</strong> requires
<strong><span class="anno">Subject</span></strong> to be a Unicode <strong>charlist()</strong>. If
compilation is done implicitly and the <strong>unicode</strong> compilation
option is specified to this function, both the regular expression and
<strong><span class="anno">Subject</span></strong> are to be specified as valid Unicode
<strong>charlist()</strong>s.</p><p>The result is given as a list of "strings", the preferred
data type specified in option <strong>return</strong> (default
<strong>iodata</strong>).</p><p>If subexpressions are specified in the regular expression, the
matching subexpressions are returned in the resulting list as
well. For example:</p><pre><code class="">
re:split("Erlang","[ln]",[{return,list}]).</code></pre><p>gives</p><pre><code class="">
["Er","a","g"]</code></pre><p>while</p><pre><code class="">
re:split("Erlang","([ln])",[{return,list}]).</code></pre><p>gives</p><pre><code class="">
["Er","l","a","n","g"]</code></pre><p>The text matching the subexpression (marked by the parentheses in the
regular expression) is inserted in the result list where it was found.
This means that concatenating the result of a split where the whole
regular expression is a single subexpression (as in the last example)
always results in the original string.</p><p>As there is no matching subexpression for the last part in the
example (the "g"), nothing is inserted after that. To make
the group of strings and the parts matching the subexpressions more
obvious, one can use option <strong>group</strong>, which groups together the
part of the subject string with the parts matching the subexpressions
when the string was split:</p><pre><code class="">
re:split("Erlang","([ln])",[{return,list},group]).</code></pre><p>gives</p><pre><code class="">
[["Er","l"],["a","n"],["g"]]</code></pre><p>Here the regular expression first matched the "l",
causing "Er" to be the first part in the result. When
the regular expression matched, the (only) subexpression was
bound to the "l", so the "l" is inserted
in the group together with "Er". The next match is of
the "n", making "a" the next part to be
returned. As the subexpression is bound to substring
"n" in this case, the "n" is inserted into
this group. The last group consists of the remaining string,
as no more matches are found.</p><p>By default, all parts of the string, including the empty strings,
are returned from the function, for example:</p><pre><code class="">
re:split("Erlang","[lg]",[{return,list}]).</code></pre><p>gives</p><pre><code class="">
["Er","an",[]]</code></pre><p>as the matching of the "g" in the end of the string
leaves an empty rest, which is also returned. This behavior
differs from the default behavior of the split function in
Perl, where empty strings at the end are by default removed. To
get the "trimming" default behavior of Perl, specify
<strong>trim</strong> as an option:</p><pre><code class="">
re:split("Erlang","[lg]",[{return,list},trim]).</code></pre><p>gives</p><pre><code class="">
["Er","an"]</code></pre><p>The "trim" option says; "give me as many parts as
possible except the empty ones", which sometimes can be
useful. You can also specify how many parts you want, by specifying
<strong>{parts,</strong>N<strong>}</strong>:</p><pre><code class="">
re:split("Erlang","[lg]",[{return,list},{parts,2}]).</code></pre><p>gives</p><pre><code class="">
["Er","ang"]</code></pre><p>Notice that the last part is "ang", not
"an", as splitting was specified into two parts,
and the splitting stops when enough parts are given, which is
why the result differs from that of <strong>trim</strong>.</p><p>More than three parts are not possible with this indata, so</p><pre><code class="">
re:split("Erlang","[lg]",[{return,list},{parts,4}]).</code></pre><p>gives the same result as the default, which is to be
viewed as "an infinite number of parts".</p><p>Specifying <strong>0</strong> as the number of parts gives the same
effect as option <strong>trim</strong>. If subexpressions are
captured, empty subexpressions matched at the end are also
stripped from the result if <strong>trim</strong> or <strong>{parts,0}</strong> is
specified.</p><p>The <strong>trim</strong> behavior corresponds exactly to the Perl default.
<strong>{parts,N}</strong>, where N is a positive integer, corresponds
exactly to the Perl behavior with a positive numerical third
parameter. The default behavior of <strong>split/3</strong> corresponds
to the Perl behavior when a negative integer is specified as
the third parameter for the Perl routine.</p><p>Summary of options not previously described for function
<strong>run/3</strong>:</p><dl><dt><strong>{return,<span class="anno">ReturnType</span>}</strong></dt><dd> <p>Specifies how the parts of the original string are presented in
the result list. Valid types:</p> <dl><dt><strong>iodata</strong></dt><dd> <p>The variant of <strong>iodata()</strong> that gives the least copying
of data with the current implementation (often a binary, but
do not depend on it).</p></dd><dt><strong>binary</strong></dt><dd> <p>All parts returned as binaries.</p></dd><dt><strong>list</strong></dt><dd> <p>All parts returned as lists of characters
("strings").</p> </dd></dl> </dd><dt><strong>group</strong></dt><dd> <p>Groups together the part of the string with
the parts of the string matching the subexpressions of the
regular expression.</p> <p>The return value from the function is in this case a
<strong>list()</strong> of <strong>list()</strong>s. Each sublist begins with the
string picked out of the subject string, followed by the parts
matching each of the subexpressions in order of occurrence in the
regular expression.</p> </dd><dt><strong>{parts,N}</strong></dt><dd> <p>Specifies the number of parts the subject string is to be
split into.</p> <p>The number of parts is to be a positive integer for a specific
maximum number of parts, and <strong>infinity</strong> for the
maximum number of parts possible (the default). Specifying
<strong>{parts,0}</strong> gives as many parts as possible disregarding
empty parts at the end, the same as specifying <strong>trim</strong>.</p> </dd><dt><strong>trim</strong></dt><dd> <p>Specifies that empty parts at the end of the result list are
to be disregarded. The same as specifying <strong>{parts,0}</strong>. This
corresponds to the default behavior of the <strong>split</strong>
built-in function in Perl.</p> </dd></dl><a name="regexp_syntax"></a><h3>Perl-Like Regular Expression Syntax</h3><p>The following sections contain reference material for the regular
expressions used by this module. The information is based on the PCRE
documentation, with changes where this module behaves differently to
the PCRE library.</p><a name="regexp_syntax_details"></a><h3>PCRE Regular Expression Details</h3><p>The syntax and semantics of the regular expressions supported by PCRE are
described in detail in the following sections. Perl's regular expressions
are described in its own documentation, and regular expressions in general
are covered in many books, some with copious examples.
Jeffrey Friedl's "Mastering Regular Expressions", published by O'Reilly,
covers regular expressions in great detail. This description of the PCRE
regular expressions is intended as reference material.</p><p>The reference material is divided into the following sections:</p><ul><li><a href="#sect1">Special Start-of-Pattern Items</a> </li><li><a href="#sect2">Characters and Metacharacters</a> </li><li><a href="#sect3">Backslash</a></li><li><a href="#sect4">Circumflex and Dollar</a></li><li><a href="#sect5">Full Stop (Period, Dot) and \N</a> </li><li><a href="#sect6">Matching a Single Data Unit</a> </li><li><a href="#sect7">Square Brackets and Character Classes</a></li><li><a href="#sect8">Posix Character Classes</a></li><li><a href="#sect9">Vertical Bar</a></li><li><a href="#sect10">Internal Option Setting</a></li><li><a href="#sect11">Subpatterns</a></li><li><a href="#sect12">Duplicate Subpattern Numbers</a> </li><li><a href="#sect13">Named Subpatterns</a></li><li><a href="#sect14">Repetition</a></li><li><a href="#sect15">Atomic Grouping and Possessive Quantifiers</a></li><li><a href="#sect16">Back References</a></li><li><a href="#sect17">Assertions</a></li><li><a href="#sect18">Conditional Subpatterns</a></li><li><a href="#sect19">Comments</a></li><li><a href="#sect20">Recursive Patterns</a></li><li><a href="#sect21">Subpatterns as Subroutines</a> </li><li><a href="#sect22">Oniguruma Subroutine Syntax</a> </li><li><a href="#sect23">Backtracking Control</a></li></ul><a name="sect1"></a><h3>Special Start-of-Pattern Items</h3><p>Some options that can be passed to <a href="#compile/2">compile/2</a> can also be set by special items at the start
of a pattern. These are not Perl-compatible, but are provided to make
these options accessible to pattern writers who are not able to change
the program that processes the pattern. Any number of these items can
appear, but they must all be together right at the start of the
pattern string, and the letters must be in upper case.</p><p><em>UTF Support</em></p><p>Unicode support is basically UTF-8 based. To use Unicode characters, you
either call <a href="#compile/2">compile/2</a> or
<a href="#run/3">run/3</a> with option
<strong>unicode</strong>, or the pattern must start with one of these special
sequences:</p><pre><code class="">
(*UTF8)
(*UTF)</code></pre><p>Both options give the same effect, the input string is interpreted as
UTF-8. Notice that with these instructions, the automatic conversion of
lists to UTF-8 is not performed by the <strong>re</strong> functions. Therefore,
using these sequences is not recommended.
Add option <strong>unicode</strong> when running
<a href="#compile/2">compile/2</a> instead.</p><p>Some applications that allow their users to supply patterns can wish to
restrict them to non-UTF data for security reasons. If option
<strong>never_utf</strong> is set at compile time, (*UTF), and so on, are not
allowed, and their appearance causes an error.</p><p><em>Unicode Property Support</em></p><p>The following is another special sequence that can appear at the start of
a pattern:</p><pre><code class="">
(*UCP)</code></pre><p>This has the same effect as setting option <strong>ucp</strong>: it causes
sequences such as \d and \w to use Unicode properties to
determine character types, instead of recognizing only characters with
codes &lt; 256 through a lookup table.</p><p><em>Disabling Startup Optimizations</em></p><p>If a pattern starts with <strong>(*NO_START_OPT)</strong>,
it has the same effect as
setting option <strong>no_start_optimize</strong> at compile time.</p><p><em>Newline Conventions</em></p><a name="newline_conventions"></a><p>PCRE supports five conventions for indicating line breaks in strings: a
single CR (carriage return) character, a single LF (line feed) character,
the two-character sequence CRLF, any of the three preceding, and any
Unicode newline sequence.</p><p>A newline convention can also be specified by starting a pattern string
with one of the following five sequences:</p><dl><dt>(*CR)</dt><dd>Carriage return</dd><dt>(*LF)</dt><dd>Line feed</dd><dt>(*CRLF)</dt><dd>&gt;Carriage return followed by line feed</dd><dt>(*ANYCRLF)</dt><dd>Any of the three above</dd><dt>(*ANY)</dt><dd>All Unicode newline sequences</dd></dl><p>These override the default and the options specified to
<a href="#compile/2">compile/2</a>. For example, the
following pattern changes the convention to CR:</p><pre><code class="">
(*CR)a.b</code></pre><p>This pattern matches <strong>a\nb</strong>, as LF is no longer a newline.
If more than one of them is present, the last one is used.</p><p>The newline convention affects where the circumflex and dollar assertions
are true. It also affects the interpretation of the dot metacharacter when
<strong>dotall</strong> is not set, and the behavior of \N. However, it does not
affect what the \R escape sequence matches. By default, this is any
Unicode newline sequence, for Perl compatibility. However, this can be
changed; see the description of \R in section
<a href="#newline_sequences">Newline Sequences</a>. A change
of the \R setting can be combined with a change of the newline
convention.</p><p><em>Setting Match and Recursion Limits</em></p><p>The caller of <a href="#run/3">run/3</a> can set a
limit on the number of times the internal match() function is called and
on the maximum depth of recursive calls. These facilities are provided to
catch runaway matches that are provoked by patterns with huge matching
trees (a typical example is a pattern with nested unlimited repeats) and
to avoid running out of system stack by too much recursion. When one of
these limits is reached, <strong>pcre_exec()</strong> gives an error return. The
limits can also be set by items at the start of the pattern of the
following forms:</p><pre><code class="">
(*LIMIT_MATCH=d)
(*LIMIT_RECURSION=d)</code></pre><p>Here d is any number of decimal digits. However, the value of the setting
must be less than the value set by the caller of <strong>run/3</strong> for it to
have any effect. That is, the pattern writer can lower the limit set by
the programmer, but not raise it. If there is more than one setting of one
of these limits, the lower value is used.</p><p>The default value for both the limits is 10,000,000 in the Erlang
VM. Notice that the recursion limit does not affect the stack depth of the
VM, as PCRE for Erlang is compiled in such a way that the match function
never does recursion on the C stack.</p><p>Note that <strong>LIMIT_MATCH</strong> and <strong>LIMIT_RECURSION</strong> can only reduce
the value of the limits set by the caller, not increase them.</p><a name="sect2"></a><h3>Characters and Metacharacters</h3><p>A regular expression is a pattern that is matched against a subject
string from left to right. Most characters stand for themselves in a
pattern and match the corresponding characters in the subject. As a
trivial example, the following pattern matches a portion of a subject
string that is identical to itself:</p><pre><code class="">
The quick brown fox</code></pre><p>When caseless matching is specified (option <strong>caseless</strong>), letters
are matched independently of case.</p><p>The power of regular expressions comes from the ability to include
alternatives and repetitions in the pattern. These are encoded in the
pattern by the use of <em>metacharacters</em>, which do not stand for
themselves but instead are interpreted in some special way.</p><p>Two sets of metacharacters exist: those that are recognized anywhere in
the pattern except within square brackets, and those that are recognized
within square brackets. Outside square brackets, the metacharacters are
as follows:</p><dl><dt>\</dt><dd>General escape character with many uses</dd><dt>^</dt><dd>Assert start of string (or line, in multiline mode) </dd><dt>$</dt><dd>Assert end of string (or line, in multiline mode)</dd><dt>.</dt><dd>Match any character except newline (by default)</dd><dt>[</dt><dd>Start character class definition</dd><dt>|</dt><dd>Start of alternative branch</dd><dt>(</dt><dd>Start subpattern</dd><dt>)</dt><dd>End subpattern</dd><dt>?</dt><dd>Extends the meaning of (, also 0 or 1 quantifier, also quantifier minimizer</dd><dt>*</dt><dd>0 or more quantifiers</dd><dt>+</dt><dd>1 or more quantifier, also "possessive quantifier" </dd><dt>{</dt><dd>Start min/max quantifier</dd></dl><p>Part of a pattern within square brackets is called a "character class".
The following are the only metacharacters in a character class:</p><dl><dt>\</dt><dd>General escape character</dd><dt>^</dt><dd>Negate the class, but only if the first character</dd><dt>-</dt><dd>Indicates character range</dd><dt>[</dt><dd>Posix character class (only if followed by Posix syntax) </dd><dt>]</dt><dd>Terminates the character class</dd></dl><p>The following sections describe the use of each metacharacter.</p><a name="sect3"></a><h3>Backslash</h3><p>The backslash character has many uses. First, if it is followed by a
character that is not a number or a letter, it takes away any special
meaning that a character can have. This use of backslash as an escape
character applies both inside and outside character classes.</p><p>For example, if you want to match a * character, you write \* in the
pattern. This escaping action applies if the following character would
otherwise be interpreted as a metacharacter, so it is always safe to
precede a non-alphanumeric with backslash to specify that it stands for
itself. In particular, if you want to match a backslash, write \\.</p><p>In <strong>unicode</strong> mode, only ASCII numbers and letters have any special
meaning after a backslash. All other characters (in particular, those
whose code points are &gt; 127) are treated as literals.</p><p>If a pattern is compiled with option <strong>extended</strong>, whitespace in the
pattern (other than in a character class) and characters between a #
outside a character class and the next newline are ignored. An escaping
backslash can be used to include a whitespace or # character as part of
the pattern.</p><p>To remove the special meaning from a sequence of characters, put them
between \Q and \E. This is different from Perl in that $ and @ are
handled as literals in \Q...\E sequences in PCRE, while $ and @ cause
variable interpolation in Perl. Notice the following examples:</p><pre><code class="">
Pattern            PCRE matches   Perl matches

\Qabc$xyz\E        abc$xyz        abc followed by the contents of $xyz
\Qabc\$xyz\E       abc\$xyz       abc\$xyz
\Qabc\E\$\Qxyz\E   abc$xyz        abc$xyz</code></pre><p>The \Q...\E sequence is recognized both inside and outside character
classes. An isolated \E that is not preceded by \Q is ignored. If \Q is
not followed by \E later in the pattern, the literal interpretation
continues to the end of the pattern (that is, \E is assumed at the end).
If the isolated \Q is inside a character class, this causes an error, as
the character class is not terminated.</p><p><em>Non-Printing Characters</em></p><a name="non_printing_characters"></a><p>A second use of backslash provides a way of encoding non-printing
characters in patterns in a visible manner. There is no restriction on the
appearance of non-printing characters, apart from the binary zero that
terminates a pattern. When a pattern is prepared by text editing, it is
often easier to use one of the following escape sequences than the binary
character it represents:</p><dl><dt>\a</dt><dd>Alarm, that is, the BEL character (hex 07)</dd><dt>\cx</dt><dd>"Control-x", where x is any ASCII character</dd><dt>\e</dt><dd>Escape (hex 1B)</dd><dt>\f</dt><dd>Form feed (hex 0C)</dd><dt>\n</dt><dd>Line feed (hex 0A)</dd><dt>\r</dt><dd>Carriage return (hex 0D)</dd><dt>\t</dt><dd>Tab (hex 09)</dd><dt>\0dd</dt><dd>Character with octal code 0dd</dd><dt>\ddd</dt><dd>Character with octal code ddd, or back reference </dd><dt>\o{ddd..}</dt><dd>character with octal code ddd..</dd><dt>\xhh</dt><dd>Character with hex code hh</dd><dt>\x{hhh..}</dt><dd>Character with hex code hhh..</dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that \0dd is always an octal code, and that \8 and \9 are
the literal characters "8" and "9".</p></div><p>The precise effect of \cx on ASCII characters is as follows: if x is a
lowercase letter, it is converted to upper case. Then bit 6 of the
character (hex 40) is inverted. Thus \cA to \cZ become hex 01 to hex 1A
(A is 41, Z is 5A), but \c{ becomes hex 3B ({ is 7B), and \c; becomes
hex 7B (; is 3B). If the data item (byte or 16-bit value) following \c
has a value &gt; 127, a compile-time error occurs. This locks out
non-ASCII characters in all modes.</p><p>The \c facility was designed for use with ASCII characters, but with the
extension to Unicode it is even less useful than it once was.</p><p>After \0 up to two further octal digits are read. If there are fewer than
two digits, just those that are present are used. Thus the sequence
\0\x\015 specifies two binary zeros followed by a CR character (code value
13). Make sure you supply two digits after the initial zero if the pattern
character that follows is itself an octal digit.</p><p>The escape \o must be followed by a sequence of octal digits, enclosed
in braces. An error occurs if this is not the case. This escape is a recent
addition to Perl; it provides way of specifying character code points as
octal numbers greater than 0777, and it also allows octal numbers and back
references to be unambiguously specified.</p><p>For greater clarity and unambiguity, it is best to avoid following \ by
a digit greater than zero. Instead, use \o{} or \x{} to specify character
numbers, and \g{} to specify back references. The following paragraphs
describe the old, ambiguous syntax.</p><p>The handling of a backslash followed by a digit other than 0 is
complicated, and Perl has changed in recent releases, causing PCRE also
to change. Outside a character class, PCRE reads the digit and any following
digits as a decimal number. If the number is &lt; 8, or if there have
been at least that many previous capturing left parentheses in the
expression, the entire sequence is taken as a <em>back reference</em>. A
description of how this works is provided later, following the discussion
of parenthesized subpatterns.</p><p>Inside a character class, or if the decimal number following \ is &gt;
7 and there have not been that many capturing subpatterns, PCRE handles
\8 and \9 as the literal characters "8" and "9", and otherwise re-reads
up to three octal digits following the backslash, and using them to
generate a data character. Any subsequent digits stand for themselves.
For example:</p><dl><dt>\040</dt><dd>Another way of writing an ASCII space</dd><dt>\40</dt><dd>The same, provided there are &lt; 40 previous capturing subpatterns</dd><dt>\7</dt><dd>Always a back reference</dd><dt>\11</dt><dd>Can be a back reference, or another way of writing a tab</dd><dt>\011</dt><dd>Always a tab</dd><dt>\0113</dt><dd>A tab followed by character "3"</dd><dt>\113</dt><dd>Can be a back reference, otherwise the character with octal code 113 </dd><dt>\377</dt><dd>Can be a back reference, otherwise value 255 (decimal)</dd><dt>\81</dt><dd>Either a back reference, or the two characters "8" and "1"</dd></dl><p>Notice that octal values &gt;= 100 that are specified using this syntax
must not be introduced by a leading zero, as no more than three octal digits
are ever read.</p><p>By default, after \x that is not followed by {, from zero to two
hexadecimal digits are read (letters can be in upper or lower case). Any
number of hexadecimal digits may appear between \x{ and }. If a character
other than a hexadecimal digit appears between \x{ and }, or if there is no
terminating }, an error occurs.
</p><p>Characters whose value is less than 256 can be defined by either of the
two syntaxes for \x. There is no difference in the way they are handled. For
example, \xdc is exactly the same as \x{dc}.</p><p><em>Constraints on character values</em></p><p>Characters that are specified using octal or hexadecimal numbers are
limited to certain values, as follows:</p><dl><dt>8-bit non-UTF mode</dt><dd><p>&lt; 0x100</p></dd><dt>8-bit UTF-8 mode</dt><dd><p>&lt; 0x10ffff and a valid codepoint</p></dd></dl><p>Invalid Unicode codepoints are the range 0xd800 to 0xdfff (the
so-called "surrogate" codepoints), and 0xffef.</p><p><em>Escape sequences in character classes</em></p><p>All the sequences that define a single character value can be used both
inside and outside character classes. Also, inside a character class, \b
is interpreted as the backspace character (hex 08).</p><p>\N is not allowed in a character class. \B, \R, and \X are not special
inside a character class. Like other unrecognized escape sequences, they
are treated as the literal characters "B", "R", and "X". Outside a
character class, these sequences have different meanings.</p><p><em>Unsupported Escape Sequences</em></p><p>In Perl, the sequences \l, \L, \u, and \U are recognized by its string
handler and used to modify the case of following characters. PCRE does not
support these escape sequences.</p><p><em>Absolute and Relative Back References</em></p><p>The sequence \g followed by an unsigned or a negative number, optionally
enclosed in braces, is an absolute or relative back reference. A named
back reference can be coded as \g{name}. Back references are discussed
later, following the discussion of parenthesized subpatterns.</p><p><em>Absolute and Relative Subroutine Calls</em></p><p>For compatibility with Oniguruma, the non-Perl syntax \g followed by a
name or a number enclosed either in angle brackets or single quotes, is
alternative syntax for referencing a subpattern as a "subroutine".
Details are discussed later. Notice that \g{...} (Perl syntax) and
\g&lt;...&gt; (Oniguruma syntax) are <em>not</em> synonymous. The former
is a back reference and the latter is a subroutine call.</p><p><em>Generic Character Types</em></p><a name="generic_character_types"></a><p>Another use of backslash is for specifying generic character types:</p><dl><dt>\d</dt><dd>Any decimal digit</dd><dt>\D</dt><dd>Any character that is not a decimal digit</dd><dt>\h</dt><dd>Any horizontal whitespace character</dd><dt>\H</dt><dd>Any character that is not a horizontal whitespace character</dd><dt>\s</dt><dd>Any whitespace character</dd><dt>\S</dt><dd>Any character that is not a whitespace character </dd><dt>\v</dt><dd>Any vertical whitespace character</dd><dt>\V</dt><dd>Any character that is not a vertical whitespace character</dd><dt>\w</dt><dd>Any "word" character</dd><dt>\W</dt><dd>Any "non-word" character</dd></dl><p>There is also the single sequence \N, which matches a non-newline
character. This is the same as the "." metacharacter when <strong>dotall</strong>
is not set. Perl also uses \N to match characters by name, but PCRE does
not support this.</p><p>Each pair of lowercase and uppercase escape sequences partitions the
complete set of characters into two disjoint sets. Any given character
matches one, and only one, of each pair. The sequences can appear both
inside and outside character classes. They each match one character of the
appropriate type. If the current matching point is at the end of the
subject string, all fail, as there is no character to match.</p><p>For compatibility with Perl, \s did not used to match the VT character (code
11), which made it different from the the POSIX "space" class. However, Perl
added VT at release 5.18, and PCRE followed suit at release 8.34. The default
\s characters are now HT (9), LF (10), VT (11), FF (12), CR (13), and space
(32), which are defined as white space in the "C" locale. This list may vary if
locale-specific matching is taking place. For example, in some locales the
"non-breaking space" character (\xA0) is recognized as white space, and in
others the VT character is not.</p><p>A "word" character is an underscore or any character that is a letter or
a digit. By default, the definition of letters and digits is controlled by
the PCRE low-valued character tables, in Erlang's case (and without option
<strong>unicode</strong>), the ISO Latin-1 character set.</p><p>By default, in <strong>unicode</strong> mode, characters with values &gt; 255, that
is, all characters outside the ISO Latin-1 character set, never match \d,
\s, or \w, and always match \D, \S, and \W. These sequences retain their
original meanings from before UTF support was available, mainly for
efficiency reasons. However, if option <strong>ucp</strong> is set, the behavior is
changed so that Unicode properties are used to determine character types,
as follows:</p><dl><dt>\d</dt><dd>Any character that \p{Nd} matches (decimal digit) </dd><dt>\s</dt><dd>Any character that \p{Z} or \h or \v </dd><dt>\w</dt><dd>Any character that matches \p{L} or \p{N} matches, plus underscore</dd></dl><p>The uppercase escapes match the inverse sets of characters. Notice that
\d matches only decimal digits, while \w matches any Unicode digit, any
Unicode letter, and underscore. Notice also that <strong>ucp</strong> affects \b and
\B, as they are defined in terms of \w and \W. Matching these sequences is
noticeably slower when <strong>ucp</strong> is set.</p><p>The sequences \h, \H, \v, and \V are features that were added to Perl in
release 5.10. In contrast to the other sequences, which match only ASCII
characters by default, these always match certain high-valued code points,
regardless if <strong>ucp</strong> is set.</p><p>The following are the horizontal space characters:</p><dl><dt>U+0009</dt><dd>Horizontal tab (HT)</dd><dt>U+0020</dt><dd>Space</dd><dt>U+00A0</dt><dd>Non-break space</dd><dt>U+1680</dt><dd>Ogham space mark</dd><dt>U+180E</dt><dd>Mongolian vowel separator</dd><dt>U+2000</dt><dd>En quad</dd><dt>U+2001</dt><dd>Em quad</dd><dt>U+2002</dt><dd>En space</dd><dt>U+2003</dt><dd>Em space</dd><dt>U+2004</dt><dd>Three-per-em space</dd><dt>U+2005</dt><dd>Four-per-em space</dd><dt>U+2006</dt><dd>Six-per-em space</dd><dt>U+2007</dt><dd>Figure space</dd><dt>U+2008</dt><dd>Punctuation space</dd><dt>U+2009</dt><dd>Thin space</dd><dt>U+200A</dt><dd>Hair space</dd><dt>U+202F</dt><dd>Narrow no-break space</dd><dt>U+205F</dt><dd>Medium mathematical space</dd><dt>U+3000</dt><dd>Ideographic space</dd></dl><p>The following are the vertical space characters:</p><dl><dt>U+000A</dt><dd>Line feed (LF)</dd><dt>U+000B</dt><dd>Vertical tab (VT)</dd><dt>U+000C</dt><dd>Form feed (FF)</dd><dt>U+000D</dt><dd>Carriage return (CR)</dd><dt>U+0085</dt><dd>Next line (NEL)</dd><dt>U+2028</dt><dd>Line separator</dd><dt>U+2029</dt><dd>Paragraph separator</dd></dl><p>In 8-bit, non-UTF-8 mode, only the characters with code points &lt; 256
are relevant.</p><p><em>Newline Sequences</em></p><a name="newline_sequences"></a><p>Outside a character class, by default, the escape sequence \R matches any
Unicode newline sequence. In non-UTF-8 mode, \R is equivalent to the
following:</p><pre><code class="">
(?&gt;\r\n|\n|\x0b|\f|\r|\x85)</code></pre><p>This is an example of an "atomic group", details are provided below.</p><p>This particular group matches either the two-character sequence CR
followed by LF, or one of the single characters LF (line feed, U+000A),
VT (vertical tab, U+000B), FF (form feed, U+000C), CR (carriage return,
U+000D), or NEL (next line, U+0085). The two-character sequence is
treated as a single unit that cannot be split.</p><p>In Unicode mode, two more characters whose code points are &gt; 255 are
added: LS (line separator, U+2028) and PS (paragraph separator, U+2029).
Unicode character property support is not needed for these characters to
be recognized.</p><p>\R can be restricted to match only CR, LF, or CRLF (instead of the
complete set of Unicode line endings) by setting option <strong>bsr_anycrlf</strong>
either at compile time or when the pattern is matched. (BSR is an acronym
for "backslash R".) This can be made the default when PCRE is built; if
so, the other behavior can be requested through option
<strong>bsr_unicode</strong>. These settings can also be specified by starting a
pattern string with one of the following sequences:</p><dl><dt>(*BSR_ANYCRLF)</dt><dd>CR, LF, or CRLF only</dd><dt>(*BSR_UNICODE)</dt><dd>Any Unicode newline sequence</dd></dl><p>These override the default and the options specified to the compiling
function, but they can themselves be overridden by options specified to a
matching function. Notice that these special settings, which are not
Perl-compatible, are recognized only at the very start of a pattern, and
that they must be in upper case. If more than one of them is present, the
last one is used. They can be combined with a change of newline
convention; for example, a pattern can start with:</p><pre><code class="">
(*ANY)(*BSR_ANYCRLF)</code></pre><p>They can also be combined with the (*UTF8), (*UTF), or (*UCP) special
sequences. Inside a character class, \R is treated as an unrecognized
escape sequence, and so matches the letter "R" by default.</p><p><em>Unicode Character Properties</em></p><p>Three more escape sequences that match characters with specific
properties are available. When in 8-bit non-UTF-8 mode, these sequences
are limited to testing characters whose code points are &lt;
256, but they do work in this mode. The following are the extra escape
sequences:</p><dl><dt>\p{<em>xx</em>}</dt><dd>A character with property <em>xx</em></dd><dt>\P{<em>xx</em>}</dt><dd>A character without property <em>xx</em></dd><dt>\X</dt><dd>A Unicode extended grapheme cluster</dd></dl><p>The property names represented by <em>xx</em> above are limited to the
Unicode script names, the general category properties, "Any", which
matches any character (including newline), and some special PCRE
properties (described in the next section). Other Perl properties, such as
"InMusicalSymbols", are currently not supported by PCRE. Notice that
\P{Any} does not match any characters and always causes a match
failure.</p><p>Sets of Unicode characters are defined as belonging to certain scripts.
A character from one of these sets can be matched using a script name, for
example:</p><pre><code class="">
\p{Greek} \P{Han}</code></pre><p>Those that are not part of an identified script are lumped together as
"Common". The following is the current list of scripts:</p><ul><li>Arabic</li><li>Armenian</li><li>Avestan</li><li>Balinese</li><li>Bamum</li><li>Bassa_Vah</li><li>Batak</li><li>Bengali</li><li>Bopomofo</li><li>Braille</li><li>Buginese</li><li>Buhid</li><li>Canadian_Aboriginal</li><li>Carian</li><li>Caucasian_Albanian</li><li>Chakma</li><li>Cham</li><li>Cherokee</li><li>Common</li><li>Coptic</li><li>Cuneiform</li><li>Cypriot</li><li>Cyrillic</li><li>Deseret</li><li>Devanagari</li><li>Duployan</li><li>Egyptian_Hieroglyphs</li><li>Elbasan</li><li>Ethiopic</li><li>Georgian</li><li>Glagolitic</li><li>Gothic</li><li>Grantha</li><li>Greek</li><li>Gujarati</li><li>Gurmukhi</li><li>Han</li><li>Hangul</li><li>Hanunoo</li><li>Hebrew</li><li>Hiragana</li><li>Imperial_Aramaic</li><li>Inherited</li><li>Inscriptional_Pahlavi</li><li>Inscriptional_Parthian</li><li>Javanese</li><li>Kaithi</li><li>Kannada</li><li>Katakana</li><li>Kayah_Li</li><li>Kharoshthi</li><li>Khmer</li><li>Khojki</li><li>Khudawadi</li><li>Lao</li><li>Latin</li><li>Lepcha</li><li>Limbu</li><li>Linear_A</li><li>Linear_B</li><li>Lisu</li><li>Lycian</li><li>Lydian</li><li>Mahajani</li><li>Malayalam</li><li>Mandaic</li><li>Manichaean</li><li>Meetei_Mayek</li><li>Mende_Kikakui</li><li>Meroitic_Cursive</li><li>Meroitic_Hieroglyphs</li><li>Miao</li><li>Modi</li><li>Mongolian</li><li>Mro</li><li>Myanmar</li><li>Nabataean</li><li>New_Tai_Lue</li><li>Nko</li><li>Ogham</li><li>Ol_Chiki</li><li>Old_Italic</li><li>Old_North_Arabian</li><li>Old_Permic</li><li>Old_Persian</li><li>Oriya</li><li>Old_South_Arabian</li><li>Old_Turkic</li><li>Osmanya</li><li>Pahawh_Hmong</li><li>Palmyrene</li><li>Pau_Cin_Hau</li><li>Phags_Pa</li><li>Phoenician</li><li>Psalter_Pahlavi</li><li>Rejang</li><li>Runic</li><li>Samaritan</li><li>Saurashtra</li><li>Sharada</li><li>Shavian</li><li>Siddham</li><li>Sinhala</li><li>Sora_Sompeng</li><li>Sundanese</li><li>Syloti_Nagri</li><li>Syriac</li><li>Tagalog</li><li>Tagbanwa</li><li>Tai_Le</li><li>Tai_Tham</li><li>Tai_Viet</li><li>Takri</li><li>Tamil</li><li>Telugu</li><li>Thaana</li><li>Thai</li><li>Tibetan</li><li>Tifinagh</li><li>Tirhuta</li><li>Ugaritic</li><li>Vai</li><li>Warang_Citi</li><li>Yi</li></ul><p>Each character has exactly one Unicode general category property,
specified by a two-letter acronym. For compatibility with Perl, negation
can be specified by including a circumflex between the opening brace and
the property name. For example, \p{^Lu} is the same as \P{Lu}.</p><p>If only one letter is specified with \p or \P, it includes all the
general category properties that start with that letter. In this case, in
the absence of negation, the curly brackets in the escape sequence are
optional. The following two examples have the same effect:</p><pre><code class="">
\p{L}
\pL</code></pre><p>The following general category property codes are supported:</p><dl><dt>C</dt><dd>Other</dd><dt>Cc</dt><dd>Control</dd><dt>Cf</dt><dd>Format</dd><dt>Cn</dt><dd>Unassigned</dd><dt>Co</dt><dd>Private use</dd><dt>Cs</dt><dd>Surrogate</dd><dt>L</dt><dd>Letter</dd><dt>Ll</dt><dd>Lowercase letter</dd><dt>Lm</dt><dd>Modifier letter</dd><dt>Lo</dt><dd>Other letter</dd><dt>Lt</dt><dd>Title case letter</dd><dt>Lu</dt><dd>Uppercase letter</dd><dt>M</dt><dd>Mark</dd><dt>Mc</dt><dd>Spacing mark</dd><dt>Me</dt><dd>Enclosing mark</dd><dt>Mn</dt><dd>Non-spacing mark</dd><dt>N</dt><dd>Number</dd><dt>Nd</dt><dd>Decimal number</dd><dt>Nl</dt><dd>Letter number</dd><dt>No</dt><dd>Other number</dd><dt>P</dt><dd>Punctuation</dd><dt>Pc</dt><dd>Connector punctuation</dd><dt>Pd</dt><dd>Dash punctuation</dd><dt>Pe</dt><dd>Close punctuation</dd><dt>Pf</dt><dd>Final punctuation</dd><dt>Pi</dt><dd>Initial punctuation</dd><dt>Po</dt><dd>Other punctuation</dd><dt>Ps</dt><dd>Open punctuation</dd><dt>S</dt><dd>Symbol</dd><dt>Sc</dt><dd>Currency symbol</dd><dt>Sk</dt><dd>Modifier symbol</dd><dt>Sm</dt><dd>Mathematical symbol</dd><dt>So</dt><dd>Other symbol</dd><dt>Z</dt><dd>Separator</dd><dt>Zl</dt><dd>Line separator</dd><dt>Zp</dt><dd>Paragraph separator</dd><dt>Zs</dt><dd>Space separator</dd></dl><p>The special property L&amp; is also supported. It matches a character
that has the Lu, Ll, or Lt property, that is, a letter that is not
classified as a modifier or "other".</p><p>The Cs (Surrogate) property applies only to characters in the range
U+D800 to U+DFFF. Such characters are invalid in Unicode strings and so
cannot be tested by PCRE. Perl does not support the Cs property.</p><p>The long synonyms for property names supported by Perl (such as
\p{Letter}) are not supported by PCRE. It is not permitted to prefix any
of these properties with "Is".</p><p>No character in the Unicode table has the Cn (unassigned) property.
This property is instead assumed for any code point that is not in the
Unicode table.</p><p>Specifying caseless matching does not affect these escape sequences. For
example, \p{Lu} always matches only uppercase letters. This is different
from the behavior of current versions of Perl.</p><p>Matching characters by Unicode property is not fast, as PCRE must do a
multistage table lookup to find a character property. That is why the
traditional escape sequences such as \d and \w do not use Unicode
properties in PCRE by default. However, you can make them do so by setting
option <strong>ucp</strong> or by starting the pattern with (*UCP).</p><p><em>Extended Grapheme Clusters</em></p><p>The \X escape matches any number of Unicode characters that form an
"extended grapheme cluster", and treats the sequence as an atomic group
(see below). Up to and including release 8.31, PCRE matched an earlier,
simpler definition that was equivalent to <strong>(?&gt;\PM\pM*)</strong>. That is,
it matched a character without the "mark" property, followed by zero or
more characters with the "mark" property. Characters with the "mark"
property are typically non-spacing accents that affect the preceding
character.</p><p>This simple definition was extended in Unicode to include more
complicated kinds of composite character by giving each character a
grapheme breaking property, and creating rules that use these properties
to define the boundaries of extended grapheme clusters. In PCRE releases
later than 8.31, \X matches one of these clusters.</p><p>\X always matches at least one character. Then it decides whether to add
more characters according to the following rules for ending a cluster:</p><ul><li> <p>End at the end of the subject string.</p> </li><li> <p>Do not end between CR and LF; otherwise end after any control
character.</p> </li><li> <p>Do not break Hangul (a Korean script) syllable sequences. Hangul
characters are of five types: L, V, T, LV, and LVT. An L character can
be followed by an L, V, LV, or LVT character. An LV or V character can
be followed by a V or T character. An LVT or T character can be
followed only by a T character.</p> </li><li> <p>Do not end before extending characters or spacing marks. Characters
with the "mark" property always have the "extend" grapheme breaking
property.</p> </li><li> <p>Do not end after prepend characters.</p> </li><li> <p>Otherwise, end the cluster.</p> </li></ul><p><em>PCRE Additional Properties</em></p><p>In addition to the standard Unicode properties described earlier, PCRE
supports four more that make it possible to convert traditional escape
sequences, such as \w and \s to use Unicode
properties. PCRE uses these non-standard, non-Perl properties internally
when the <strong>ucp</strong> option is passed. However, they can also be used
explicitly. The properties are as follows:</p><dl><dt>Xan</dt><dd> <p>Any alphanumeric character. Matches characters that have either the
L (letter) or the N (number) property.</p> </dd><dt>Xps</dt><dd> <p>Any Posix space character. Matches the characters tab, line feed,
vertical tab, form feed, carriage return, and any other character
that has the Z (separator) property.</p> </dd><dt>Xsp</dt><dd> <p>Any Perl space character. Matches the same as Xps, except that
vertical tab is excluded.</p> </dd><dt>Xwd</dt><dd> <p>Any Perl "word" character. Matches the same characters as Xan, plus
underscore.</p> </dd></dl><p>Perl and POSIX space are now the same. Perl added VT to its space
character set at release 5.18 and PCRE changed at release 8.34.</p><p>Xan matches characters that have either the L (letter) or the N (number)
property. Xps matches the characters tab, linefeed, vertical tab, form feed,
or carriage return, and any other character that has the Z (separator)
property. Xsp is the same as Xps; it used to exclude vertical tab, for Perl
compatibility, but Perl changed, and so PCRE followed at release 8.34. Xwd
matches the same characters as Xan, plus underscore.
</p><p>There is another non-standard property, Xuc, which matches any character
that can be represented by a Universal Character Name in C++ and other
programming languages. These are the characters $, @, ` (grave accent),
and all characters with Unicode code points &gt;= U+00A0, except for the
surrogates U+D800 to U+DFFF. Notice that most base (ASCII) characters are
excluded. (Universal Character Names are of the form \uHHHH or \UHHHHHHHH,
where H is a hexadecimal digit. Notice that the Xuc property does not
match these sequences but the characters that they represent.)</p><p><em>Resetting the Match Start</em></p><p>The escape sequence \K causes any previously matched characters not to
be included in the final matched sequence. For example, the following
pattern matches "foobar", but reports that it has matched "bar":</p><pre><code class="">
foo\Kbar</code></pre><p>This feature is similar to a lookbehind assertion
(described below). However, in this case, the part of the subject before
the real match does not have to be of fixed length, as lookbehind
assertions do. The use of \K does not interfere with the setting of
captured substrings. For example, when the following pattern matches
"foobar", the first substring is still set to "foo":</p><pre><code class="">
(foo)\Kbar</code></pre><p>Perl documents that the use of \K within assertions is "not well
defined". In PCRE, \K is acted upon when it occurs inside positive
assertions, but is ignored in negative assertions. Note that when a
pattern such as (?=ab\K) matches, the reported start of the match can
be greater than the end of the match.</p><p><em>Simple Assertions</em></p><p>The final use of backslash is for certain simple assertions. An
assertion specifies a condition that must be met at a particular point in
a match, without consuming any characters from the subject string. The
use of subpatterns for more complicated assertions is described below. The
following are the backslashed assertions:</p><dl><dt>\b</dt><dd>Matches at a word boundary.</dd><dt>\B</dt><dd>Matches when not at a word boundary.</dd><dt>\A</dt><dd>Matches at the start of the subject.</dd><dt>\Z</dt><dd>Matches at the end of the subject, and before a newline at the end of the subject.</dd><dt>\z</dt><dd>Matches only at the end of the subject.</dd><dt>\G</dt><dd>Matches at the first matching position in the subject. </dd></dl><p>Inside a character class, \b has a different meaning; it matches the
backspace character. If any other of these assertions appears in a
character class, by default it matches the corresponding literal character
(for example, \B matches the letter B).</p><p>A word boundary is a position in the subject string where the current
character and the previous character do not both match \w or \W (that is,
one matches \w and the other matches \W), or the start or end of the
string if the first or last character matches \w, respectively. In UTF
mode, the meanings of \w and \W can be changed by setting option
<strong>ucp</strong>. When this is done, it also affects \b and \B. PCRE and Perl do
not have a separate "start of word" or "end of word" metasequence.
However, whatever follows \b normally determines which it is. For example,
the fragment \ba matches "a" at the start of a word.</p><p>The \A, \Z, and \z assertions differ from the traditional circumflex and
dollar (described in the next section) in that they only ever match at the
very start and end of the subject string, whatever options are set. Thus,
they are independent of multiline mode. These three assertions are not
affected by options <strong>notbol</strong> or <strong>noteol</strong>, which affect only the
behavior of the circumflex and dollar metacharacters. However, if argument
<strong>startoffset</strong> of <a href="#run/3">run/3</a> is
non-zero, indicating that matching is to start at a point other than the
beginning of the subject, \A can never match. The difference between \Z
and \z is that \Z matches before a newline at the end of the string and
at the very end, while \z matches only at the end.</p><p>The \G assertion is true only when the current matching position is at
the start point of the match, as specified by argument <strong>startoffset</strong>
of <strong>run/3</strong>. It differs from \A when the value of <strong>startoffset</strong>
is non-zero. By calling <strong>run/3</strong> multiple times with appropriate
arguments, you can mimic the Perl option <strong>/g</strong>, and it is in this
kind of implementation where \G can be useful.</p><p>Notice, however, that the PCRE interpretation of \G, as the start of the
current match, is subtly different from Perl, which defines it as the end
of the previous match. In Perl, these can be different when the previously
matched string was empty. As PCRE does only one match at a time, it cannot
reproduce this behavior.</p><p>If all the alternatives of a pattern begin with \G, the expression is
anchored to the starting match position, and the "anchored" flag is set in
the compiled regular expression.</p><a name="sect4"></a><h3>Circumflex and Dollar</h3><p>The circumflex and dollar metacharacters are zero-width assertions. That
is, they test for a particular condition to be true without consuming any
characters from the subject string.</p><p>Outside a character class, in the default matching mode, the circumflex
character is an assertion that is true only if the current matching point
is at the start of the subject string. If argument <strong>startoffset</strong> of
<a href="#run/3">run/3</a> is non-zero, circumflex
can never match if option <strong>multiline</strong> is unset. Inside a character
class, circumflex has an entirely different meaning (see below).</p><p>Circumflex needs not to be the first character of the pattern if
some alternatives are involved, but it is to be the first thing in
each alternative in which it appears if the pattern is ever to match that
branch. If all possible alternatives start with a circumflex, that is, if
the pattern is constrained to match only at the start of the subject, it
is said to be an "anchored" pattern. (There are also other constructs that
can cause a pattern to be anchored.)</p><p>The dollar character is an assertion that is true only if the current
matching point is at the end of the subject string, or immediately before
a newline at the end of the string (by default). Notice however that it
does not match the newline. Dollar needs not to be the last character of
the pattern if some alternatives are involved, but it is to be the
last item in any branch in which it appears. Dollar has no special meaning
in a character class.</p><p>The meaning of dollar can be changed so that it matches only at the very
end of the string, by setting option <strong>dollar_endonly</strong> at compile
time. This does not affect the \Z assertion.</p><p>The meanings of the circumflex and dollar characters are changed if
option <strong>multiline</strong> is set. When this is the case, a circumflex
matches immediately after internal newlines and at the start of the
subject string. It does not match after a newline that ends the string. A
dollar matches before any newlines in the string, and at the very end,
when <strong>multiline</strong> is set. When newline is specified as the
two-character sequence CRLF, isolated CR and LF characters do not
indicate newlines.</p><p>For example, the pattern /^abc$/ matches the subject string "def\nabc"
(where \n represents a newline) in multiline mode, but not otherwise.
So, patterns that are anchored in single-line mode because all
branches start with ^ are not anchored in multiline mode, and a match for
circumflex is possible when argument <em>startoffset</em> of <strong>run/3</strong>
is non-zero. Option <strong>dollar_endonly</strong> is ignored if <strong>multiline</strong>
is set.</p><p>Notice that the sequences \A, \Z, and \z can be used to match the start
and end of the subject in both modes. If all branches of a pattern start
with \A, it is always anchored, regardless if <strong>multiline</strong> is set.</p><a name="sect5"></a><h3>Full Stop (Period, Dot) and \N</h3><p>Outside a character class, a dot in the pattern matches any character in
the subject string except (by default) a character that signifies the end
of a line.</p><p>When a line ending is defined as a single character, dot never matches
that character. When the two-character sequence CRLF is used, dot does not
match CR if it is immediately followed by LF, otherwise it matches all
characters (including isolated CRs and LFs). When any Unicode line endings
are recognized, dot does not match CR, LF, or any of the other
line-ending characters.</p><p>The behavior of dot regarding newlines can be changed.  If option
<strong>dotall</strong> is set, a dot matches any character, without exception. If
the two-character sequence CRLF is present in the subject string, it takes
two dots to match it.</p><p>The handling of dot is entirely independent of the handling of circumflex
and dollar, the only relationship is that both involve newlines. Dot has
no special meaning in a character class.</p><p>The escape sequence \N behaves like a dot, except that it is not affected
by option <strong>PCRE_DOTALL</strong>. That is, it matches any character except one
that signifies the end of a line. Perl also uses \N to match characters by
name but PCRE does not support this.</p><a name="sect6"></a><h3>Matching a Single Data Unit</h3><p>Outside a character class, the escape sequence \C matches any data unit,
regardless if a UTF mode is set. One data unit is one byte. Unlike a dot,
\C always matches line-ending characters. The feature is provided in Perl
to match individual bytes in UTF-8 mode, but it is unclear how it can
usefully be used. As \C breaks up characters into individual data units,
matching one unit with \C in a UTF mode means that the remaining string
can start with a malformed UTF character. This has undefined results, as
PCRE assumes that it deals with valid UTF strings.</p><p>PCRE does not allow \C to appear in lookbehind assertions (described
below) in a UTF mode, as this would make it impossible to calculate the
length of the lookbehind.</p><p>The \C escape sequence is best avoided. However, one way of using it that
avoids the problem of malformed UTF characters is to use a lookahead to
check the length of the next character, as in the following pattern, which
can be used with a UTF-8 string (ignore whitespace and line breaks):</p><pre><code class="">
(?| (?=[\x00-\x7f])(\C) |
    (?=[\x80-\x{7ff}])(\C)(\C) |
    (?=[\x{800}-\x{ffff}])(\C)(\C)(\C) |
    (?=[\x{10000}-\x{1fffff}])(\C)(\C)(\C)(\C))</code></pre><p>A group that starts with (?| resets the capturing parentheses numbers in
each alternative (see section <a href="#sect12">Duplicate Subpattern Numbers</a>). The assertions at the start of each branch
check the next UTF-8 character for values whose encoding uses 1, 2, 3, or
4 bytes, respectively. The individual bytes of the character are then
captured by the appropriate number of groups.</p><a name="sect7"></a><h3>Square Brackets and Character Classes</h3><p>An opening square bracket introduces a character class, terminated by a
closing square bracket. A closing square bracket on its own is not special
by default. However, if option <strong>PCRE_JAVASCRIPT_COMPAT</strong> is set, a
lone closing square bracket causes a compile-time error. If a closing
square bracket is required as a member of the class, it is to be the first
data character in the class (after an initial circumflex, if present) or
escaped with a backslash.</p><p>A character class matches a single character in the subject. In a UTF
mode, the character can be more than one data unit long. A matched
character must be in the set of characters defined by the class, unless
the first character in the class definition is a circumflex, in which case
the subject character must not be in the set defined by the class. If a
circumflex is required as a member of the class, ensure that it is not the
first character, or escape it with a backslash.</p><p>For example, the character class <strong>[aeiou]</strong> matches any lowercase
vowel, while <strong>[^aeiou]</strong> matches any character that is not a lowercase
vowel. Notice that a circumflex is just a convenient notation for
specifying the characters that are in the class by enumerating those that
are not. A class that starts with a circumflex is not an assertion; it
still consumes a character from the subject string, and therefore it fails
if the current pointer is at the end of the string.</p><p>In UTF-8 mode, characters with values &gt; 255 (0xffff) can be included
in a class as a literal string of data units, or by using the \x{ escaping
mechanism.</p><p>When caseless matching is set, any letters in a class represent both
their uppercase and lowercase versions. For example, a caseless
<strong>[aeiou]</strong> matches "A" and "a", and a caseless <strong>[^aeiou]</strong> does
not match "A", but a caseful version would. In a UTF mode, PCRE always
understands the concept of case for characters whose values are &lt; 256,
so caseless matching is always possible. For characters with higher
values, the concept of case is supported only if PCRE is compiled with
Unicode property support. If you want to use caseless matching in a UTF
mode for characters &gt;=, ensure that PCRE is compiled with Unicode
property support and with UTF support.</p><p>Characters that can indicate line breaks are never treated in any special
way when matching character classes, whatever line-ending sequence is in
use, and whatever setting of options <strong>PCRE_DOTALL</strong> and
<strong>PCRE_MULTILINE</strong> is used. A class such as [^a] always matches one of
these characters.</p><p>The minus (hyphen) character can be used to specify a range of characters
in a character class. For example, [d-m] matches any letter between d and
m, inclusive. If a minus character is required in a class, it must be
escaped with a backslash or appear in a position where it cannot be
interpreted as indicating a range, typically as the first or last
character in the class, or immediately after a range. For example, [b-d-z]
matches letters in the range b to d, a hyphen character, or z.</p><p>The literal character "]" cannot be the end character of a range. A
pattern such as [W-]46] is interpreted as a class of two characters ("W"
and "-") followed by a literal string "46]", so it would match "W46]" or
"-46]". However, if "]" is escaped with a backslash, it is interpreted as
the end of range, so [W-\]46] is interpreted as a class containing a range
followed by two other characters. The octal or hexadecimal representation
of "]" can also be used to end a range.</p><p>An error is generated if a POSIX character class (see below) or an
escape sequence other than one that defines a single character appears at
a point where a range ending character is expected. For example, [z-\xff]
is valid, but [A-\d] and [A-[:digit:]] are not.</p><p>Ranges operate in the collating sequence of character values. They can
also be used for characters specified numerically, for example,
[\000-\037]. Ranges can include any characters that are valid for the
current mode.</p><p>If a range that includes letters is used when caseless matching is set,
it matches the letters in either case. For example, [W-c] is equivalent to
[][\\^_`wxyzabc], matched caselessly. In a non-UTF mode, if character
tables for a French locale are in use, [\xc8-\xcb] matches accented E
characters in both cases. In UTF modes, PCRE supports the concept of case
for characters with values &gt; 255 only when it is compiled with Unicode
property support.</p><p>The character escape sequences \d, \D, \h, \H, \p, \P, \s, \S, \v, \V,
\w, and \W can appear in a character class, and add the characters that
they match to the class. For example, [\dABCDEF] matches any hexadecimal
digit. In UTF modes, option <strong>ucp</strong> affects the meanings of \d, \s, \w
and their uppercase partners, just as it does when they appear outside a
character class, as described in section
<a href="#generic_character_types">Generic Character Types</a> earlier. The escape sequence \b has a different meaning
inside a character class; it matches the backspace character. The
sequences \B, \N, \R, and \X are not special inside a character class.
Like any other unrecognized escape sequences, they are treated as the
literal characters "B", "N", "R", and "X".</p><p>A circumflex can conveniently be used with the uppercase character types
to specify a more restricted set of characters than the matching lowercase
type. For example, class [^\W_] matches any letter or digit, but not
underscore, while [\w] includes underscore. A positive character class
is to be read as "something OR something OR ..." and a negative class as
"NOT something AND NOT something AND NOT ...".</p><p>Only the following metacharacters are recognized in character
classes:</p><ul><li>Backslash</li><li>Hyphen (only where it can be interpreted as specifying a range)</li><li>Circumflex (only at the start)</li><li>Opening square bracket (only when it can be interpreted as introducing a Posix class name, or for a special compatibility feature; see the next two sections)</li><li>Terminating closing square bracket</li></ul><p>However, escaping other non-alphanumeric characters does no harm.</p><a name="sect8"></a><h3>Posix Character Classes</h3><p>Perl supports the Posix notation for character classes. This uses names
enclosed by [: and :] within the enclosing square brackets. PCRE also
supports this notation. For example, the following matches "0", "1", any
alphabetic character, or "%":</p><pre><code class="">
[01[:alpha:]%]</code></pre><p>The following are the supported class names:</p><dl><dt>alnum</dt><dd>Letters and digits</dd><dt>alpha</dt><dd>Letters</dd><dt>ascii</dt><dd>Character codes 0-127</dd><dt>blank</dt><dd>Space or tab only</dd><dt>cntrl</dt><dd>Control characters</dd><dt>digit</dt><dd>Decimal digits (same as \d)</dd><dt>graph</dt><dd>Printing characters, excluding space</dd><dt>lower</dt><dd>Lowercase letters</dd><dt>print</dt><dd>Printing characters, including space</dd><dt>punct</dt><dd>Printing characters, excluding letters, digits, and space</dd><dt>space</dt><dd>Whitespace (the same as \s from PCRE 8.34)</dd><dt>upper</dt><dd>Uppercase letters</dd><dt>word</dt><dd>"Word" characters (same as \w)</dd><dt>xdigit</dt><dd>Hexadecimal digits</dd></dl><p>The default "space" characters are HT (9), LF (10), VT (11), FF (12),
CR (13), and space (32). If locale-specific matching is taking place, the
list of space characters may be different; there may be fewer or more of
them. "Space" used to be different to \s, which did not include VT, for
Perl compatibility. However, Perl changed at release 5.18, and PCRE followed
at release 8.34. "Space" and \s now match the same set of characters.</p><p>The name "word" is a Perl extension, and "blank" is a GNU extension from
Perl 5.8. Another Perl extension is negation, which is indicated by a ^
character after the colon. For example, the following matches "1", "2",
or any non-digit:</p><pre><code class="">
[12[:^digit:]]</code></pre><p>PCRE (and Perl) also recognize the Posix syntax [.ch.] and [=ch=] where
"ch" is a "collating element", but these are not supported, and an error
is given if they are encountered.</p><p>By default, characters with values &gt; 255 do not match
any of the Posix character classes. However, if option <strong>PCRE_UCP</strong> is
passed to <strong>pcre_compile()</strong>, some of the classes are changed so that
Unicode character properties are used. This is achieved by replacing
certain Posix classes by other sequences, as follows:</p><dl><dt>[:alnum:]</dt><dd>Becomes <em>\p{Xan}</em></dd><dt>[:alpha:]</dt><dd>Becomes <em>\p{L}</em></dd><dt>[:blank:]</dt><dd>Becomes <em>\h</em></dd><dt>[:digit:]</dt><dd>Becomes <em>\p{Nd}</em></dd><dt>[:lower:]</dt><dd>Becomes <em>\p{Ll}</em></dd><dt>[:space:]</dt><dd>Becomes <em>\p{Xps}</em></dd><dt>[:upper:]</dt><dd>Becomes <em>\p{Lu}</em></dd><dt>[:word:]</dt><dd>Becomes <em>\p{Xwd}</em></dd></dl><p>Negated versions, such as [:^alpha:], use \P instead of \p. Three other
POSIX classes are handled specially in UCP mode:</p><dl><dt>[:graph:]</dt><dd><p>This matches characters that have glyphs that mark the page
when printed. In Unicode property terms, it matches all characters with
the L, M, N, P, S, or Cf properties, except for:</p> <dl><dt>U+061C</dt><dd><p>Arabic Letter Mark</p></dd><dt>U+180E</dt><dd><p>Mongolian Vowel Separator</p></dd><dt>U+2066 - U+2069</dt><dd><p>Various "isolate"s</p></dd></dl> </dd><dt>[:print:]</dt><dd><p>This matches the same characters as [:graph:] plus space
characters that are not controls, that is, characters with the Zs
property.</p></dd><dt>[:punct:]</dt><dd><p>This matches all characters that have
the Unicode P (punctuation) property, plus those characters whose code
points are less than 128 that have the S (Symbol) property.</p></dd></dl><p>The other POSIX classes are unchanged, and match only characters with
code points less than 128.
</p><p><em>Compatibility Feature for Word Boundaries</em></p><p>In the POSIX.2 compliant library that was included in 4.4BSD Unix,
the ugly syntax [[:&lt;:]] and [[:&gt;:]] is used for matching "start
of word" and "end of word". PCRE treats these items as follows:</p><dl><dt>[[:&lt;:]]</dt><dd><p>is converted to  \b(?=\w)</p></dd><dt>[[:&gt;:]]</dt><dd><p>is converted to  \b(?&lt;=\w)</p></dd></dl><p>Only these exact character sequences are recognized. A sequence such as
[a[:&lt;:]b] provokes error for an unrecognized POSIX class name. This
support is not compatible with Perl. It is provided to help migrations from
other environments, and is best not used in any new patterns. Note that \b
matches at the start and the end of a word (see "Simple assertions" above),
and in a Perl-style pattern the preceding or following character normally
shows which is wanted, without the need for the assertions that are used
above in order to give exactly the POSIX behaviour.</p><a name="sect9"></a><h3>Vertical Bar</h3><p>Vertical bar characters are used to separate alternative patterns. For
example, the following pattern matches either "gilbert" or "sullivan":</p><pre><code class="">
gilbert|sullivan</code></pre><p>Any number of alternatives can appear, and an empty alternative is
permitted (matching the empty string). The matching process tries each
alternative in turn, from left to right, and the first that succeeds is
used. If the alternatives are within a subpattern (defined in section
<a href="#sect11">Subpatterns</a>), "succeeds" means
matching the remaining main pattern and the alternative in the
subpattern.</p><a name="sect10"></a><h3>Internal Option Setting</h3><p>The settings of the Perl-compatible options <strong>caseless</strong>,
<strong>multiline</strong>, <strong>dotall</strong>, and <strong>extended</strong> can be changed from
within the pattern by a sequence of Perl option letters enclosed between
"(?" and ")". The option letters are as follows:</p><dl><dt>i</dt><dd>For <strong>caseless</strong></dd><dt>m</dt><dd>For <strong>multiline</strong></dd><dt>s</dt><dd>For <strong>dotall</strong></dd><dt>x</dt><dd>For <strong>extended</strong></dd></dl><p>For example, <strong>(?im)</strong> sets caseless, multiline matching. These
options can also be unset by preceding the letter with a hyphen. A
combined setting and unsetting such as <strong>(?im-sx)</strong>, which sets
<strong>caseless</strong> and <strong>multiline</strong>, while unsetting <strong>dotall</strong> and
<strong>extended</strong>, is also permitted. If a letter appears both before and
after the hyphen, the option is unset.</p><p>The PCRE-specific options <strong>dupnames</strong>, <strong>ungreedy</strong>, and
<strong>extra</strong> can be changed in the same way as the Perl-compatible
options by using the characters J, U, and X respectively.</p><p>When one of these option changes occurs at top-level (that is, not inside
subpattern parentheses), the change applies to the remainder of the
pattern that follows.</p><p>An option change within a subpattern (see section
<a href="#sect11">Subpatterns</a>) affects only that part of
the subpattern that follows it. So, the following matches abc and aBc and
no other strings (assuming <strong>caseless</strong> is not used):</p><pre><code class="">
(a(?i)b)c</code></pre><p>By this means, options can be made to have different settings in
different parts of the pattern. Any changes made in one alternative do
carry on into subsequent branches within the same subpattern. For
example:</p><pre><code class="">
(a(?i)b|c)</code></pre><p>matches "ab", "aB", "c", and "C", although when matching "C" the first
branch is abandoned before the option setting. This is because the effects
of option settings occur at compile time. There would be some weird
behavior otherwise.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Other PCRE-specific options can be set by the application when the
compiling or matching functions are called. Sometimes the pattern can
contain special leading sequences, such as (*CRLF), to override what
the application has set or what has been defaulted. Details are provided
in section <a href="#newline_sequences"> Newline Sequences</a> earlier.</p><p>The (*UTF8) and (*UCP) leading sequences can be used to set UTF and
Unicode property modes. They are equivalent to setting options
<strong>unicode</strong> and <strong>ucp</strong>, respectively. The (*UTF) sequence is a
generic version that can be used with any of the libraries. However,
the application can set option <strong>never_utf</strong>, which locks out the
use of the (*UTF) sequences.</p></div><a name="sect11"></a><h3>Subpatterns</h3><p>Subpatterns are delimited by parentheses (round brackets), which can be
nested. Turning part of a pattern into a subpattern does two things:</p><dl><dt>1.</dt><dd> <p>It localizes a set of alternatives. For example, the following
pattern matches "cataract", "caterpillar", or "cat":</p> <pre><code class="">
cat(aract|erpillar|)</code></pre> <p>Without the parentheses, it would match "cataract", "erpillar", or an
empty string.</p> </dd><dt>2.</dt><dd> <p>It sets up the subpattern as a capturing subpattern. That is, when
the complete pattern matches, that portion of the subject string that
matched the subpattern is passed back to the caller through the
return value of <a href="#run/3">run/3</a>.</p> </dd></dl><p>Opening parentheses are counted from left to right (starting from 1) to
obtain numbers for the capturing subpatterns. For example, if the string
"the red king" is matched against the following pattern, the captured
substrings are "red king", "red", and "king", and are numbered 1, 2, and
3, respectively:</p><pre><code class="">
the ((red|white) (king|queen))</code></pre><p>It is not always helpful that plain parentheses fulfill two functions.
Often a grouping subpattern is required without a capturing requirement.
If an opening parenthesis is followed by a question mark and a colon, the
subpattern does not do any capturing, and is not counted when computing
the number of any subsequent capturing subpatterns. For example, if the
string "the white queen" is matched against the following pattern, the
captured substrings are "white queen" and "queen", and are numbered 1 and
2:</p><pre><code class="">
the ((?:red|white) (king|queen))</code></pre><p>The maximum number of capturing subpatterns is 65535.</p><p>As a convenient shorthand, if any option settings are required at the
start of a non-capturing subpattern, the option letters can appear between
"?" and ":". Thus, the following two patterns match the same set of
strings:</p><pre><code class="">
(?i:saturday|sunday)
(?:(?i)saturday|sunday)</code></pre><p>As alternative branches are tried from left to right, and options are not
reset until the end of the subpattern is reached, an option setting in one
branch does affect subsequent branches, so the above patterns match both
"SUNDAY" and "Saturday".</p><a name="sect12"></a><h3>Duplicate Subpattern Numbers</h3><p>Perl 5.10 introduced a feature where each alternative in a subpattern
uses the same numbers for its capturing parentheses. Such a subpattern
starts with <strong>(?|</strong> and is itself a non-capturing subpattern. For
example, consider the following pattern:</p><pre><code class="">
(?|(Sat)ur|(Sun))day</code></pre><p>As the two alternatives are inside a <strong>(?|</strong> group, both sets of
capturing parentheses are numbered one. Thus, when the pattern matches,
you can look at captured substring number one, whichever alternative
matched. This construct is useful when you want to capture a part, but
not all, of one of many alternatives. Inside a <strong>(?|</strong> group,
parentheses are numbered as usual, but the number is reset at the start
of each branch. The numbers of any capturing parentheses that follow the
subpattern start after the highest number used in any branch.
The following example is from the Perl documentation; the numbers
underneath show in which buffer the captured content is stored:</p><pre><code class="">
# before  ---------------branch-reset----------- after
/ ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
# 1            2         2  3        2     3     4</code></pre><p>A back reference to a numbered subpattern uses the most recent value that
is set for that number by any subpattern. The following pattern matches
"abcabc" or "defdef":</p><pre><code class="">
/(?|(abc)|(def))\1/</code></pre><p>In contrast, a subroutine call to a numbered subpattern always refers to
the first one in the pattern with the given number. The following pattern
matches "abcabc" or "defabc":</p><pre><code class="">
/(?|(abc)|(def))(?1)/</code></pre><p>If a condition test for a subpattern having matched refers to a
non-unique number, the test is true if any of the subpatterns of that
number have matched.</p><p>An alternative approach using this "branch reset" feature is to use
duplicate named subpatterns, as described in the next section.</p><a name="sect13"></a><h3>Named Subpatterns</h3><p>Identifying capturing parentheses by number is simple, but it can be
hard to keep track of the numbers in complicated regular expressions.
Also, if an expression is modified, the numbers can change. To help with
this difficulty, PCRE supports the naming of subpatterns. This feature was
not added to Perl until release 5.10. Python had the feature earlier, and
PCRE introduced it at release 4.0, using the Python syntax. PCRE now
supports both the Perl and the Python syntax. Perl allows identically
numbered subpatterns to have different names, but PCRE does not.</p><p>In PCRE, a subpattern can be named in one of three ways:
<strong>(?&lt;name&gt;...)</strong> or <strong>(?'name'...)</strong> as in Perl, or
<strong>(?P&lt;name&gt;...)</strong> as in Python. References to capturing
parentheses from other parts of the pattern, such as back references,
recursion, and conditions, can be made by name and by number.</p><p>Names consist of up to 32 alphanumeric characters and underscores, but
must start with a non-digit. Named capturing parentheses are still allocated
numbers as well as names, exactly as if the names were not present.
The <strong>capture</strong> specification to <a href="#run/3">run/3</a> can use named values if they are present in the
regular expression.</p><p>By default, a name must be unique within a pattern, but this constraint
can be relaxed by setting option <strong>dupnames</strong> at compile time.
(Duplicate names are also always permitted for subpatterns with the same
number, set up as described in the previous section.) Duplicate names can
be useful for patterns where only one instance of the named parentheses
can match. Suppose that you want to match the name of a weekday, either as
a 3-letter abbreviation or as the full name, and in both cases you want to
extract the abbreviation. The following pattern (ignoring the line
breaks) does the job:</p><pre><code class="">
(?&lt;DN&gt;Mon|Fri|Sun)(?:day)?|
(?&lt;DN&gt;Tue)(?:sday)?|
(?&lt;DN&gt;Wed)(?:nesday)?|
(?&lt;DN&gt;Thu)(?:rsday)?|
(?&lt;DN&gt;Sat)(?:urday)?</code></pre><p>There are five capturing substrings, but only one is ever set after a
match. (An alternative way of solving this problem is to use a "branch
reset" subpattern, as described in the previous section.)</p><p>For capturing named subpatterns which names are not unique, the first
matching occurrence (counted from left to right in the subject) is
returned from <a href="#run/3">run/3</a>, if the name
is specified in the <strong>values</strong> part of the <strong>capture</strong> statement.
The <strong>all_names</strong> capturing value matches all the names in the same
way.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>You cannot use different names to distinguish between two subpatterns
with the same number, as PCRE uses only the numbers when matching. For
this reason, an error is given at compile time if different names are
specified to subpatterns with the same number. However, you can specify
the same name to subpatterns with the same number, even when
<strong>dupnames</strong> is not set.</p></div><a name="sect14"></a><h3>Repetition</h3><p>Repetition is specified by quantifiers, which can follow any of the
following items:</p><ul><li>A literal data character</li><li>The dot metacharacter</li><li>The \C escape sequence</li><li>The \X escape sequence</li><li>The \R escape sequence</li><li>An escape such as \d or \pL that matches a single character</li><li>A character class</li><li>A back reference (see the next section)</li><li>A parenthesized subpattern (including assertions)</li><li>A subroutine call to a subpattern (recursive or otherwise)</li></ul><p>The general repetition quantifier specifies a minimum and maximum number
of permitted matches, by giving the two numbers in curly brackets
(braces), separated by a comma. The numbers must be &lt; 65536, and the
first must be less than or equal to the second. For example, the following
matches "zz", "zzz", or "zzzz":</p><pre><code class="">
z{2,4}</code></pre><p>A closing brace on its own is not a special character. If the second
number is omitted, but the comma is present, there is no upper limit. If
the second number and the comma are both omitted, the quantifier specifies
an exact number of required matches. Thus, the following matches at least
three successive vowels, but can match many more:</p><pre><code class="">
[aeiou]{3,}</code></pre><p>The following matches exactly eight digits:</p><pre><code class="">
\d{8}</code></pre><p>An opening curly bracket that appears in a position where a quantifier is
not allowed, or one that does not match the syntax of a quantifier, is
taken as a literal character. For example, {,6} is not a quantifier, but a
literal string of four characters.</p><p>In Unicode mode, quantifiers apply to characters rather than to
individual data units. Thus, for example, \x{100}{2} matches two
characters, each of which is represented by a 2-byte sequence in a
UTF-8 string. Similarly, \X{3} matches three Unicode extended grapheme
clusters, each of which can be many data units long (and they can be of
different lengths).</p><p>The quantifier {0} is permitted, causing the expression to behave as if
the previous item and the quantifier were not present. This can be useful
for subpatterns that are referenced as subroutines from elsewhere in the
pattern (but see also section <a href="#defining_subpatterns"> Defining Subpatterns for Use by Reference Only</a>). Items other
than subpatterns that have a {0} quantifier are omitted from the compiled
pattern.</p><p>For convenience, the three most common quantifiers have single-character
abbreviations:</p><dl><dt>*</dt><dd>Equivalent to {0,}</dd><dt>+</dt><dd>Equivalent to {1,}</dd><dt>?</dt><dd>Equivalent to {0,1}</dd></dl><p>Infinite loops can be constructed by following a subpattern that can
match no characters with a quantifier that has no upper limit, for
example:</p><pre><code class="">
(a?)*</code></pre><p>Earlier versions of Perl and PCRE used to give an error at compile time
for such patterns. However, as there are cases where this can be useful,
such patterns are now accepted. However, if any repetition of the
subpattern matches no characters, the loop is forcibly broken.</p><p>By default, the quantifiers are "greedy", that is, they match as much as
possible (up to the maximum number of permitted times), without causing
the remaining pattern to fail. The classic example of where this gives
problems is in trying to match comments in C programs. These appear
between /* and */. Within the comment, individual * and / characters can
appear. An attempt to match C comments by applying the pattern</p><pre><code class="">
/\*.*\*/</code></pre><p>to the string</p><pre><code class="">
/* first comment */  not comment  /* second comment */</code></pre><p>fails, as it matches the entire string owing to the greediness of the .* 
item.</p><p>However, if a quantifier is followed by a question mark, it ceases to be
greedy, and instead matches the minimum number of times possible, so the
following pattern does the right thing with the C comments:</p><pre><code class="">
/\*.*?\*/</code></pre><p>The meaning of the various quantifiers is not otherwise changed, only
the preferred number of matches. Do not confuse this use of question mark
with its use as a quantifier in its own right. As it has two uses, it can
sometimes appear doubled, as in</p><pre><code class="">
\d??\d</code></pre><p>which matches one digit by preference, but can match two if that is the
only way the remaining pattern matches.</p><p>If option <strong>ungreedy</strong> is set (an option that is not available in
Perl), the quantifiers are not greedy by default, but individual ones can
be made greedy by following them with a question mark. That is, it inverts
the default behavior.</p><p>When a parenthesized subpattern is quantified with a minimum repeat count
that is &gt; 1 or with a limited maximum, more memory is required for the
compiled pattern, in proportion to the size of the minimum or maximum.</p><p>If a pattern starts with .* or .{0,} and option <strong>dotall</strong> (equivalent
to Perl option <strong>/s</strong>) is set, thus allowing the dot to match newlines,
the pattern is implicitly anchored, because whatever follows is tried
against every character position in the subject string. So, there is no
point in retrying the overall match at any position after the first. PCRE
normally treats such a pattern as if it was preceded by \A.</p><p>In cases where it is known that the subject string contains no newlines,
it is worth setting <strong>dotall</strong> to obtain this optimization, or
alternatively using ^ to indicate anchoring explicitly.</p><p>However, there are some cases where the optimization cannot be used. When
.* is inside capturing parentheses that are the subject of a back
reference elsewhere in the pattern, a match at the start can fail where a
later one succeeds. Consider, for example:</p><pre><code class="">
(.*)abc\1</code></pre><p>If the subject is "xyz123abc123", the match point is the fourth
character. Therefore, such a pattern is not implicitly anchored.</p><p>Another case where implicit anchoring is not applied is when the leading
.* is inside an atomic group. Once again, a match at the start can fail
where a later one succeeds. Consider the following pattern:</p><pre><code class="">
(?&gt;.*?a)b</code></pre><p>It matches "ab" in the subject "aab". The use of the backtracking control
verbs (*PRUNE) and (*SKIP) also disable this optimization.</p><p>When a capturing subpattern is repeated, the value captured is the
substring that matched the final iteration. For example, after</p><pre><code class="">
(tweedle[dume]{3}\s*)+</code></pre><p>has matched "tweedledum tweedledee", the value of the captured substring
is "tweedledee". However, if there are nested capturing subpatterns, the
corresponding captured values can have been set in previous iterations.
For example, after</p><pre><code class="">
/(a|(b))+/</code></pre><p>matches "aba", the value of the second captured substring is "b".</p><a name="sect15"></a><h3>Atomic Grouping and Possessive Quantifiers</h3><p>With both maximizing ("greedy") and minimizing ("ungreedy" or "lazy")
repetition, failure of what follows normally causes the repeated item to
be re-evaluated to see if a different number of repeats allows the
remaining pattern to match. Sometimes it is useful to prevent this, either
to change the nature of the match, or to cause it to fail earlier than it
otherwise might, when the author of the pattern knows that there is no
point in carrying on.</p><p>Consider, for example, the pattern \d+foo when applied to the following
subject line:</p><pre><code class="">
123456bar</code></pre><p>After matching all six digits and then failing to match "foo", the normal
action of the matcher is to try again with only five digits matching item
\d+, and then with four, and so on, before ultimately failing. "Atomic
grouping" (a term taken from Jeffrey Friedl's book) provides the means for
specifying that once a subpattern has matched, it is not to be
re-evaluated in this way.</p><p>If atomic grouping is used for the previous example, the matcher gives up
immediately on failing to match "foo" the first time. The notation is a
kind of special parenthesis, starting with <strong>(?&gt;</strong> as in the
following example:</p><pre><code class="">
(?&gt;\d+)foo</code></pre><p>This kind of parenthesis "locks up" the part of the pattern it contains
once it has matched, and a failure further into the pattern is prevented
from backtracking into it. Backtracking past it to previous items,
however, works as normal.</p><p>An alternative description is that a subpattern of this type matches the
string of characters that an identical standalone pattern would match, if
anchored at the current point in the subject string.</p><p>Atomic grouping subpatterns are not capturing subpatterns. Simple cases
such as the above example can be thought of as a maximizing repeat that
must swallow everything it can. So, while both \d+ and \d+? are prepared
to adjust the number of digits they match to make the remaining pattern
match, <strong>(?&gt;\d+)</strong> can only match an entire sequence of digits.</p><p>Atomic groups in general can contain any complicated
subpatterns, and can be nested. However, when the subpattern for an atomic
group is just a single repeated item, as in the example above, a simpler
notation, called a "possessive quantifier" can be used. This consists of
an extra + character following a quantifier. Using this notation, the
previous example can be rewritten as</p><pre><code class="">
\d++foo</code></pre><p>Notice that a possessive quantifier can be used with an entire group,
for example:</p><pre><code class="">
(abc|xyz){2,3}+</code></pre><p>Possessive quantifiers are always greedy; the setting of option
<strong>ungreedy</strong> is ignored. They are a convenient notation for the simpler
forms of an atomic group. However, there is no difference in the meaning
of a possessive quantifier and the equivalent atomic group, but there can
be a performance difference; possessive quantifiers are probably slightly
faster.</p><p>The possessive quantifier syntax is an extension to the Perl 5.8 syntax.
Jeffrey Friedl originated the idea (and the name) in the first edition of
his book. Mike McCloskey liked it, so implemented it when he built the
Sun Java package, and PCRE copied it from there. It ultimately found its
way into Perl at release 5.10.</p><p>PCRE has an optimization that automatically "possessifies" certain simple
pattern constructs. For example, the sequence A+B is treated as A++B, as
there is no point in backtracking into a sequence of A:s when B must
follow.</p><p>When a pattern contains an unlimited repeat inside a subpattern that can
itself be repeated an unlimited number of times, the use of an atomic
group is the only way to avoid some failing matches taking a long time.
The pattern</p><pre><code class="">
(\D+|&lt;\d+&gt;)*[!?]</code></pre><p>matches an unlimited number of substrings that either consist of
non-digits, or digits enclosed in &lt;&gt;, followed by ! or ?. When it
matches, it runs quickly. However, if it is applied to</p><pre><code class="">
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code></pre><p>it takes a long time before reporting failure. This is because the string
can be divided between the internal \D+ repeat and the external * repeat
in many ways, and all must be tried. (The example uses [!?] rather than a
single character at the end, as both PCRE and Perl have an optimization
that allows for fast failure when a single character is used. They
remember the last single character that is required for a match, and fail
early if it is not present in the string.) If the pattern is changed so
that it uses an atomic group, like the following, sequences of non-digits
cannot be broken, and failure happens quickly:</p><pre><code class="">
((?&gt;\D+)|&lt;\d+&gt;)*[!?]</code></pre><a name="sect16"></a><h3>Back References</h3><p>Outside a character class, a backslash followed by a digit &gt; 0 (and
possibly further digits) is a back reference to a capturing subpattern
earlier (that is, to its left) in the pattern, provided there have been
that many previous capturing left parentheses.</p><p>However, if the decimal number following the backslash is &lt; 10, it is
always taken as a back reference, and causes an error only if there are
not that many capturing left parentheses in the entire pattern. That is,
the parentheses that are referenced do need not be to the left of the
reference for numbers &lt; 10. A "forward back reference" of this type can
make sense when a repetition is involved and the subpattern to the right
has participated in an earlier iteration.</p><p>It is not possible to have a numerical "forward back reference" to a
subpattern whose number is 10 or more using this syntax, as a sequence
such as \50 is interpreted as a character defined in octal. For more
details of the handling of digits following a backslash, see section
<a href="#non_printing_characters">Non-Printing Characters</a> earlier. There is no such problem when named
parentheses are used. A back reference to any subpattern is possible
using named parentheses (see below).</p><p>Another way to avoid the ambiguity inherent in the use of digits
following a backslash is to use the \g escape sequence. This escape must
be followed by an unsigned number or a negative number, optionally
enclosed in braces. The following examples are identical:</p><pre><code class="">
(ring), \1
(ring), \g1
(ring), \g{1}</code></pre><p>An unsigned number specifies an absolute reference without the ambiguity
that is present in the older syntax. It is also useful when literal digits
follow the reference. A negative number is a relative reference. Consider
the following example:</p><pre><code class="">
(abc(def)ghi)\g{-1}</code></pre><p>The sequence \g{-1} is a reference to the most recently started capturing
subpattern before \g, that is, it is equivalent to \2 in this example.
Similarly, \g{-2} would be equivalent to \1. The use of relative
references can be helpful in long patterns, and also in patterns that are
created by joining fragments containing references within themselves.</p><p>A back reference matches whatever matched the capturing subpattern in the
current subject string, rather than anything matching the subpattern
itself (section <a href="#sect21">Subpattern as Subroutines</a> describes a way of doing that). So, the
following pattern matches "sense and sensibility" and "response and
responsibility", but not "sense and responsibility":</p><pre><code class="">
(sens|respons)e and \1ibility</code></pre><p>If caseful matching is in force at the time of the back reference, the
case of letters is relevant. For example, the following matches "rah rah"
and "RAH RAH", but not "RAH rah", although the original capturing
subpattern is matched caselessly:</p><pre><code class="">
((?i)rah)\s+\1</code></pre><p>There are many different ways of writing back references to named
subpatterns. The .NET syntax <strong>\k{name}</strong> and the Perl syntax
<strong>\k&lt;name&gt;</strong> or <strong>\k'name'</strong> are supported, as is the Python
syntax <strong>(?P=name)</strong>. The unified back reference syntax in Perl 5.10,
in which \g can be used for both numeric and named references, is also
supported. The previous example can be rewritten in the following
ways:</p><pre><code class="">
(?&lt;p1&gt;(?i)rah)\s+\k&lt;p1&gt;
(?'p1'(?i)rah)\s+\k{p1}
(?P&lt;p1&gt;(?i)rah)\s+(?P=p1)
(?&lt;p1&gt;(?i)rah)\s+\g{p1}</code></pre><p>A subpattern that is referenced by name can appear in the pattern before
or after the reference.</p><p>There can be more than one back reference to the same subpattern. If a
subpattern has not been used in a particular match, any back references to
it always fails. For example, the following pattern always fails if it
starts to match "a" rather than "bc":</p><pre><code class="">
(a|(bc))\2</code></pre><p>As there can be many capturing parentheses in a pattern, all digits
following the backslash are taken as part of a potential back reference
number. If the pattern continues with a digit character, some delimiter
must be used to terminate the back reference. If option <strong>extended</strong> is
set, this can be whitespace. Otherwise an empty comment (see section
<a href="#sect19">Comments</a>) can be used.</p><p><em>Recursive Back References</em></p><p>A back reference that occurs inside the parentheses to which it refers
fails when the subpattern is first used, so, for example, (a\1) never
matches. However, such references can be useful inside repeated
subpatterns. For example, the following pattern matches any number of
"a"s and also "aba", "ababbaa", and so on:</p><pre><code class="">
(a|b\1)+</code></pre><p>At each iteration of the subpattern, the back reference matches the
character string corresponding to the previous iteration. In order for
this to work, the pattern must be such that the first iteration does not
need to match the back reference. This can be done using alternation, as
in the example above, or by a quantifier with a minimum of zero.</p><p>Back references of this type cause the group that they reference to be
treated as an atomic group. Once the whole group has been matched, a
subsequent matching failure cannot cause backtracking into the middle of
the group.</p><a name="sect17"></a><h3>Assertions</h3><p>An assertion is a test on the characters following or preceding the
current matching point that does not consume any characters. The simple
assertions coded as \b, \B, \A, \G, \Z, \z, ^, and $ are described in
the previous sections.</p><p>More complicated assertions are coded as subpatterns. There are two
kinds: those that look ahead of the current position in the subject
string, and those that look behind it. An assertion subpattern is matched
in the normal way, except that it does not cause the current matching
position to be changed.</p><p>Assertion subpatterns are not capturing subpatterns. If such an assertion
contains capturing subpatterns within it, these are counted for the
purposes of numbering the capturing subpatterns in the whole pattern.
However, substring capturing is done only for positive assertions. (Perl
sometimes, but not always, performs capturing in negative assertions.)</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If a positive assertion containing one or more capturing subpatterns
succeeds, but failure to match later in the pattern causes backtracking over
this assertion, the captures within the assertion are reset only if no higher
numbered captures are already set. This is, unfortunately, a fundamental
limitation of the current implementation, and as PCRE1 is now in
maintenance-only status, it is unlikely ever to change.</p></div><p>For compatibility with Perl, assertion subpatterns can be repeated.
However, it makes no sense to assert the same thing many times, the side
effect of capturing parentheses can occasionally be useful. In practice,
there are only three cases:</p><ul><li> <p>If the quantifier is {0}, the assertion is never obeyed during
matching. However, it can contain internal capturing parenthesized
groups that are called from elsewhere through the subroutine
mechanism.</p> </li><li> <p>If quantifier is {0,n}, where n &gt; 0, it is treated as if it was
{0,1}. At runtime, the remaining pattern match is tried with and
without the assertion, the order depends on the greediness of the
quantifier.</p> </li><li> <p>If the minimum repetition is &gt; 0, the quantifier is ignored. The
assertion is obeyed only once when encountered during matching.</p> </li></ul><p><em>Lookahead Assertions</em></p><p>Lookahead assertions start with (?= for positive assertions and (?! for
negative assertions. For example, the following matches a word followed by
a semicolon, but does not include the semicolon in the match:</p><pre><code class="">
\w+(?=;)</code></pre><p>The following matches any occurrence of "foo" that is not followed by
"bar":</p><pre><code class="">
foo(?!bar)</code></pre><p>Notice that the apparently similar pattern</p><pre><code class="">
(?!foo)bar</code></pre><p>does not find an occurrence of "bar" that is preceded by something other
than "foo". It finds any occurrence of "bar" whatsoever, as the assertion
(?!foo) is always true when the next three characters are "bar". A
lookbehind assertion is needed to achieve the other effect.</p><p>If you want to force a matching failure at some point in a pattern, the
most convenient way to do it is with (?!), as an empty string always
matches. So, an assertion that requires there is not to be an empty
string must always fail. The backtracking control verb (*FAIL) or (*F) is
a synonym for (?!).</p><p><em>Lookbehind Assertions</em></p><p>Lookbehind assertions start with (?&lt;= for positive assertions and
(?&lt;! for negative assertions. For example, the following finds an
occurrence of "bar" that is not preceded by "foo":</p><pre><code class="">
(?&lt;!foo)bar</code></pre><p>The contents of a lookbehind assertion are restricted such that all the
strings it matches must have a fixed length. However, if there are many
top-level alternatives, they do not all have to have the same fixed
length. Thus, the following is permitted:</p><pre><code class="">
(?&lt;=bullock|donkey)</code></pre><p>The following causes an error at compile time:</p><pre><code class="">
(?&lt;!dogs?|cats?)</code></pre><p>Branches that match different length strings are permitted only at the
top-level of a lookbehind assertion. This is an extension compared with
Perl, which requires all branches to match the same length of string. An
assertion such as the following is not permitted, as its single top-level
branch can match two different lengths:</p><pre><code class="">
(?&lt;=ab(c|de))</code></pre><p>However, it is acceptable to PCRE if rewritten to use two top-level
branches:</p><pre><code class="">
(?&lt;=abc|abde)</code></pre><p>Sometimes the escape sequence \K (see above) can be used instead of
a lookbehind assertion to get round the fixed-length restriction.</p><p>The implementation of lookbehind assertions is, for each alternative, to
move the current position back temporarily by the fixed length and then
try to match. If there are insufficient characters before the current
position, the assertion fails.</p><p>In a UTF mode, PCRE does not allow the \C escape (which matches a single
data unit even in a UTF mode) to appear in lookbehind assertions, as it
makes it impossible to calculate the length of the lookbehind. The \X and
\R escapes, which can match different numbers of data units, are not
permitted either.</p><p>"Subroutine" calls (see below), such as (?2) or (?&amp;X), are permitted
in lookbehinds, as long as the subpattern matches a fixed-length string.
Recursion, however, is not supported.</p><p>Possessive quantifiers can be used with lookbehind
assertions to specify efficient matching of fixed-length strings at the
end of subject strings. Consider the following simple pattern when applied
to a long string that does not match:</p><pre><code class="">
abcd$</code></pre><p>As matching proceeds from left to right, PCRE looks for each "a" in the
subject and then sees if what follows matches the remaining pattern. If
the pattern is specified as</p><pre><code class="">
^.*abcd$</code></pre><p>the initial .* matches the entire string at first. However, when this
fails (as there is no following "a"), it backtracks to match all but the
last character, then all but the last two characters, and so on. Once
again the search for "a" covers the entire string, from right to left, so
we are no better off. However, if the pattern is written as</p><pre><code class="">
^.*+(?&lt;=abcd)</code></pre><p>there can be no backtracking for the .*+ item; it can match only the
entire string. The subsequent lookbehind assertion does a single test on
the last four characters. If it fails, the match fails immediately. For
long strings, this approach makes a significant difference to the
processing time.</p><p><em>Using Multiple Assertions</em></p><p>Many assertions (of any sort) can occur in succession. For example, the
following matches "foo" preceded by three digits that are not "999":</p><pre><code class="">
(?&lt;=\d{3})(?&lt;!999)foo</code></pre><p>Notice that each of the assertions is applied independently at the same
point in the subject string. First there is a check that the previous
three characters are all digits, and then there is a check that the same
three characters are not "999".  This pattern does <em>not</em> match
"foo" preceded by six characters, the first of which are digits and the
last three of which are not "999". For example, it does not match
"123abcfoo". A pattern to do that is the following:</p><pre><code class="">
(?&lt;=\d{3}...)(?&lt;!999)foo</code></pre><p>This time the first assertion looks at the preceding six characters,
checks that the first three are digits, and then the second assertion
checks that the preceding three characters are not "999".</p><p>Assertions can be nested in any combination. For example, the following
matches an occurrence of "baz" that is preceded by "bar", which in turn is
not preceded by "foo":</p><pre><code class="">
(?&lt;=(?&lt;!foo)bar)baz</code></pre><p>The following pattern matches "foo" preceded by three digits and any
three characters that are not "999":</p><pre><code class="">
(?&lt;=\d{3}(?!999)...)foo</code></pre><a name="sect18"></a><h3>Conditional Subpatterns</h3><p>It is possible to cause the matching process to obey a subpattern
conditionally or to choose between two alternative subpatterns, depending
on the result of an assertion, or whether a specific capturing subpattern
has already been matched. The following are the two possible forms of
conditional subpattern:</p><pre><code class="">
(?(condition)yes-pattern)
(?(condition)yes-pattern|no-pattern)</code></pre><p>If the condition is satisfied, the yes-pattern is used, otherwise the
no-pattern (if present). If more than two alternatives exist in the
subpattern, a compile-time error occurs. Each of the two alternatives can
itself contain nested subpatterns of any form, including conditional
subpatterns; the restriction to two alternatives applies only at the level
of the condition. The following pattern fragment is an example where the
alternatives are complex:</p><pre><code class="">
(?(1) (A|B|C) | (D | (?(2)E|F) | E) )</code></pre><p>There are four kinds of condition: references to subpatterns, references
to recursion, a pseudo-condition called DEFINE, and assertions.</p><p><em>Checking for a Used Subpattern By Number</em></p><p>If the text between the parentheses consists of a sequence of digits,
the condition is true if a capturing subpattern of that number has
previously matched. If more than one capturing subpattern with the same
number exists (see section <a href="#sect12"> Duplicate Subpattern Numbers</a> earlier), the condition is true if
any of them have matched. An alternative notation is to precede the
digits with a plus or minus sign. In this case, the subpattern number is
relative rather than absolute. The most recently opened parentheses can be
referenced by (?(-1), the next most recent by (?(-2), and so on. Inside
loops, it can also make sense to refer to subsequent groups. The next
parentheses to be opened can be referenced as (?(+1), and so on. (The
value zero in any of these forms is not used; it provokes a compile-time
error.)</p><p>Consider the following pattern, which contains non-significant whitespace
to make it more readable (assume option <strong>extended</strong>) and to divide it
into three parts for ease of discussion:</p><pre><code class="">
( \( )?    [^()]+    (?(1) \) )</code></pre><p>The first part matches an optional opening parenthesis, and if that
character is present, sets it as the first captured substring. The second
part matches one or more characters that are not parentheses. The third
part is a conditional subpattern that tests whether the first set of
parentheses matched or not. If they did, that is, if subject started with
an opening parenthesis, the condition is true, and so the yes-pattern is
executed and a closing parenthesis is required. Otherwise, as no-pattern
is not present, the subpattern matches nothing. That is, this pattern
matches a sequence of non-parentheses, optionally enclosed in
parentheses.</p><p>If this pattern is embedded in a larger one, a relative reference can be
used:</p><pre><code class="">
...other stuff... ( \( )?    [^()]+    (?(-1) \) ) ...</code></pre><p>This makes the fragment independent of the parentheses in the larger
pattern.</p><p><em>Checking for a Used Subpattern By Name</em></p><p>Perl uses the syntax (?(&lt;name&gt;)...) or (?('name')...) to test for a
used subpattern by name. For compatibility with earlier versions of PCRE,
which had this facility before Perl, the syntax (?(name)...) is also
recognized.</p><p>Rewriting the previous example to use a named subpattern gives:</p><pre><code class="">
(?&lt;OPEN&gt; \( )?    [^()]+    (?(&lt;OPEN&gt;) \) )</code></pre><p>If the name used in a condition of this kind is a duplicate, the test is
applied to all subpatterns of the same name, and is true if any one of
them has matched.</p><p><em>Checking for Pattern Recursion</em></p><p>If the condition is the string (R), and there is no subpattern with the
name R, the condition is true if a recursive call to the whole pattern or
any subpattern has been made. If digits or a name preceded by ampersand
follow the letter R, for example:</p><pre><code class="">
(?(R3)...) or (?(R&amp;name)...)</code></pre><p>the condition is true if the most recent recursion is into a subpattern
whose number or name is given. This condition does not check the entire
recursion stack. If the name used in a condition of this kind is a
duplicate, the test is applied to all subpatterns of the same name, and is
true if any one of them is the most recent recursion.</p><p>At "top-level", all these recursion test conditions are false. The syntax
for recursive patterns is described below.</p><p><em>Defining Subpatterns for Use By Reference Only</em></p><a name="defining_subpatterns"></a><p>If the condition is the string (DEFINE), and there is no subpattern with
the name DEFINE, the condition is always false. In this case, there can be
only one alternative in the subpattern. It is always skipped if control
reaches this point in the pattern. The idea of DEFINE is that it can be
used to define "subroutines" that can be referenced from elsewhere. (The
use of subroutines is described below.) For example, a pattern to match
an IPv4 address, such as "192.168.23.245", can be written like this
(ignore whitespace and line breaks):</p><pre><code class="">
(?(DEFINE) (?&lt;byte&gt; 2[0-4]\d | 25[0-5] | 1\d\d | [1-9]?\d) ) \b (?&amp;byte) (\.(?&amp;byte)){3} \b</code></pre><p>The first part of the pattern is a DEFINE group inside which is a another
group named "byte" is defined. This matches an individual component of an
IPv4 address (a number &lt; 256). When matching takes place, this part of
the pattern is skipped, as DEFINE acts like a false condition. The
remaining pattern uses references to the named group to match the four
dot-separated components of an IPv4 address, insisting on a word boundary
at each end.</p><p><em>Assertion Conditions</em></p><p>If the condition is not in any of the above formats, it must be an
assertion. This can be a positive or negative lookahead or lookbehind
assertion. Consider the following pattern, containing non-significant
whitespace, and with the two alternatives on the second line:</p><pre><code class="">
(?(?=[^a-z]*[a-z])
\d{2}-[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )</code></pre><p>The condition is a positive lookahead assertion that matches an optional
sequence of non-letters followed by a letter. That is, it tests for the
presence of at least one letter in the subject. If a letter is found, the
subject is matched against the first alternative, otherwise it is matched
against the second. This pattern matches strings in one of the two forms
dd-aaa-dd or dd-dd-dd, where aaa are letters and dd are digits.</p><a name="sect19"></a><h3>Comments</h3><p>There are two ways to include comments in patterns that are processed by
PCRE. In both cases, the start of the comment must not be in a character
class, or in the middle of any other sequence of related characters such
as (?: or a subpattern name or number. The characters that make up a
comment play no part in the pattern matching.</p><p>The sequence (?# marks the start of a comment that continues up to the
next closing parenthesis. Nested parentheses are not permitted. If option
PCRE_EXTENDED is set, an unescaped # character also introduces a comment,
which in this case continues to immediately after the next newline
character or character sequence in the pattern. Which characters are
interpreted as newlines is controlled by the options passed to a
compiling function or by a special sequence at the start of the pattern,
as described in section <a href="#newline_conventions"> Newline Conventions</a> earlier.</p><p>Notice that the end of this type of comment is a literal newline sequence
in the pattern; escape sequences that happen to represent a newline do not
count. For example, consider the following pattern when <strong>extended</strong> is
set, and the default newline convention is in force:</p><pre><code class="">
abc #comment \n still comment</code></pre><p>On encountering character #, <strong>pcre_compile()</strong> skips along, looking
for a newline in the pattern. The sequence \n is still literal at this
stage, so it does not terminate the comment. Only a character with code
value 0x0a (the default newline) does so.</p><a name="sect20"></a><h3>Recursive Patterns</h3><p>Consider the problem of matching a string in parentheses, allowing for
unlimited nested parentheses. Without the use of recursion, the best that
can be done is to use a pattern that matches up to some fixed depth of
nesting. It is not possible to handle an arbitrary nesting depth.</p><p>For some time, Perl has provided a facility that allows regular
expressions to recurse (among other things). It does this by
interpolating Perl code in the expression at runtime, and the code can
refer to the expression itself. A Perl pattern using code interpolation to
solve the parentheses problem can be created like this:</p><pre><code class="">
$re = qr{\( (?: (?&gt;[^()]+) | (?p{$re}) )* \)}x;</code></pre><p>Item (?p{...}) interpolates Perl code at runtime, and in this case refers
recursively to the pattern in which it appears.</p><p>Obviously, PCRE cannot support the interpolation of Perl code. Instead,
it supports special syntax for recursion of the entire pattern, and for
individual subpattern recursion. After its introduction in PCRE and
Python, this kind of recursion was later introduced into Perl at
release 5.10.</p><p>A special item that consists of (? followed by a number &gt; 0 and a
closing parenthesis is a recursive subroutine call of the subpattern of
the given number, if it occurs inside that subpattern. (If not,
it is a non-recursive subroutine call, which is described in the next
section.) The special item (?R) or (?0) is a recursive call of the entire
regular expression.</p><p>This PCRE pattern solves the nested parentheses problem (assume that
option <strong>extended</strong> is set so that whitespace is ignored):</p><pre><code class="">
\( ( [^()]++ | (?R) )* \)</code></pre><p>First it matches an opening parenthesis. Then it matches any number of
substrings, which can either be a sequence of non-parentheses or a
recursive match of the pattern itself (that is, a correctly parenthesized
substring). Finally there is a closing parenthesis. Notice the use of a
possessive quantifier to avoid backtracking into sequences of
non-parentheses.</p><p>If this was part of a larger pattern, you would not want to recurse the
entire pattern, so instead you can use:</p><pre><code class="">
( \( ( [^()]++ | (?1) )* \) )</code></pre><p>The pattern is here within parentheses so that the recursion refers to
them instead of the whole pattern.</p><p>In a larger pattern, keeping track of parenthesis numbers can be tricky.
This is made easier by the use of relative references. Instead of (?1) in
the pattern above, you can write (?-2) to refer to the second most
recently opened parentheses preceding the recursion. That is, a negative
number counts capturing parentheses leftwards from the point at which it
is encountered.</p><p>It is also possible to refer to later opened parentheses, by
writing references such as (?+2). However, these cannot be recursive, as
the reference is not inside the parentheses that are referenced. They are
always non-recursive subroutine calls, as described in the next
section.</p><p>An alternative approach is to use named parentheses instead. The Perl
syntax for this is (?&amp;name). The earlier PCRE syntax (?P&gt;name) is
also supported. We can rewrite the above example as follows:</p><pre><code class="">
(?&lt;pn&gt; \( ( [^()]++ | (?&amp;pn) )* \) )</code></pre><p>If there is more than one subpattern with the same name, the earliest
one is used.</p><p>This particular example pattern that we have studied contains nested
unlimited repeats, and so the use of a possessive quantifier for matching
strings of non-parentheses is important when applying the pattern to
strings that do not match. For example, when this pattern is applied
to</p><pre><code class="">
(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</code></pre><p>it gives "no match" quickly. However, if a possessive quantifier is not
used, the match runs for a long time, as there are so many different
ways the + and * repeats can carve up the subject, and all must be tested
before failure can be reported.</p><p>At the end of a match, the values of capturing parentheses are those from
the outermost level. If the pattern above is matched against</p><pre><code class="">
(ab(cd)ef)</code></pre><p>the value for the inner capturing parentheses (numbered 2) is "ef",
which is the last value taken on at the top-level. If a capturing
subpattern is not matched at the top level, its final captured value is
unset, even if it was (temporarily) set at a deeper level during the
matching process.</p><p>Do not confuse item (?R) with condition (R), which tests for recursion.
Consider the following pattern, which matches text in angle brackets,
allowing for arbitrary nesting. Only digits are allowed in nested brackets
(that is, when recursing), while any characters are permitted at the
outer level.</p><pre><code class="">
&lt; (?: (?(R) \d++  | [^&lt;&gt;]*+) | (?R)) * &gt;</code></pre><p>Here (?(R) is the start of a conditional subpattern, with two different
alternatives for the recursive and non-recursive cases. Item (?R) is the
actual recursive call.</p><p><em>Differences in Recursion Processing between PCRE and Perl</em></p><p>Recursion processing in PCRE differs from Perl in two important ways. In
PCRE (like Python, but unlike Perl), a recursive subpattern call is always
treated as an atomic group. That is, once it has matched some of the
subject string, it is never re-entered, even if it contains untried
alternatives and there is a subsequent matching failure. This can be
illustrated by the following pattern, which means to match a palindromic
string containing an odd number of characters (for example, "a", "aba",
"abcba", "abcdcba"):</p><pre><code class="">
^(.|(.)(?1)\2)$</code></pre><p>The idea is that it either matches a single character, or two identical
characters surrounding a subpalindrome. In Perl, this pattern works; in
PCRE it does not work if the pattern is longer than three characters.
Consider the subject string "abcba".</p><p>At the top level, the first character is matched, but as it is not at
the end of the string, the first alternative fails, the second
alternative is taken, and the recursion kicks in. The recursive call to
subpattern 1 successfully matches the next character ("b"). (Notice that
the beginning and end of line tests are not part of the recursion.)</p><p>Back at the top level, the next character ("c") is compared with what
subpattern 2 matched, which was "a". This fails. As the recursion is
treated as an atomic group, there are now no backtracking points, and so
the entire match fails. (Perl can now re-enter the recursion
and try the second alternative.) However, if the pattern is written with
the alternatives in the other order, things are different:</p><pre><code class="">
^((.)(?1)\2|.)$</code></pre><p>This time, the recursing alternative is tried first, and continues to
recurse until it runs out of characters, at which point the recursion
fails. But this time we have another alternative to try at the higher
level. That is the significant difference: in the previous case the
remaining alternative is at a deeper recursion level, which PCRE cannot
use.</p><p>To change the pattern so that it matches all palindromic strings, not
only those with an odd number of characters, it is tempting to change the
pattern to this:</p><pre><code class="">
^((.)(?1)\2|.?)$</code></pre><p>Again, this works in Perl, but not in PCRE, and for the same reason. When
a deeper recursion has matched a single character, it cannot be entered
again to match an empty string. The solution is to separate the two cases,
and write out the odd and even cases as alternatives at the higher
level:</p><pre><code class="">
^(?:((.)(?1)\2|)|((.)(?3)\4|.))</code></pre><p>If you want to match typical palindromic phrases, the pattern must ignore
all non-word characters, which can be done as follows:</p><pre><code class="">
^\W*+(?:((.)\W*+(?1)\W*+\2|)|((.)\W*+(?3)\W*+\4|\W*+.\W*+))\W*+$</code></pre><p>If run with option <strong>caseless</strong>, this pattern matches phrases such as
"A man, a plan, a canal: Panama!" and it works well in both PCRE and Perl.
Notice the use of the possessive quantifier *+ to avoid backtracking into
sequences of non-word characters. Without this, PCRE takes much longer
(10 times or more) to match typical phrases, and Perl takes so long that
you think it has gone into a loop.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The palindrome-matching patterns above work only if the subject string
does not start with a palindrome that is shorter than the entire string.
For example, although "abcba" is correctly matched, if the subject is
"ababa", PCRE finds palindrome "aba" at the start, and then fails at top
level, as the end of the string does not follow. Once again, it cannot
jump back into the recursion to try other alternatives, so the entire
match fails.</p></div><p>The second way in which PCRE and Perl differ in their recursion
processing is in the handling of captured values. In Perl, when a
subpattern is called recursively or as a subpattern (see the next
section), it has no access to any values that were captured outside the
recursion. In PCRE these values can be referenced. Consider the following
pattern:</p><pre><code class="">
^(.)(\1|a(?2))</code></pre><p>In PCRE, it matches "bab". The first capturing parentheses match "b",
then in the second group, when the back reference \1 fails to match "b",
the second alternative matches "a", and then recurses. In the recursion,
\1 does now match "b" and so the whole match succeeds. In Perl, the
pattern fails to match because inside the recursive call \1 cannot access
the externally set value.</p><a name="sect21"></a><h3>Subpatterns as Subroutines</h3><p>If the syntax for a recursive subpattern call (either by number or by
name) is used outside the parentheses to which it refers, it operates
like a subroutine in a programming language. The called subpattern can be
defined before or after the reference. A numbered reference can be
absolute or relative, as in the following examples:</p><pre><code class="">
(...(absolute)...)...(?2)...
(...(relative)...)...(?-1)...
(...(?+1)...(relative)...</code></pre><p>An earlier example pointed out that the following pattern matches "sense
and sensibility" and "response and responsibility", but not "sense and
responsibility":</p><pre><code class="">
(sens|respons)e and \1ibility</code></pre><p>If instead the following pattern is used, it matches "sense and
responsibility" and the other two strings:</p><pre><code class="">
(sens|respons)e and (?1)ibility</code></pre><p>Another example is provided in the discussion of DEFINE earlier.</p><p>All subroutine calls, recursive or not, are always treated as atomic
groups. That is, once a subroutine has matched some of the subject string,
it is never re-entered, even if it contains untried alternatives and there
is a subsequent matching failure. Any capturing parentheses that are set
during the subroutine call revert to their previous values afterwards.</p><p>Processing options such as case-independence are fixed when a subpattern
is defined, so if it is used as a subroutine, such options cannot be
changed for different calls. For example, the following pattern matches
"abcabc" but not "abcABC", as the change of processing option does not
affect the called subpattern:</p><pre><code class="">
(abc)(?i:(?-1))</code></pre><a name="sect22"></a><h3>Oniguruma Subroutine Syntax</h3><p>For compatibility with Oniguruma, the non-Perl syntax \g followed by a
name or a number enclosed either in angle brackets or single quotes, is
alternative syntax for referencing a subpattern as a subroutine, possibly
recursively. Here follows two of the examples used above, rewritten using
this syntax:</p><pre><code class="">
(?&lt;pn&gt; \( ( (?&gt;[^()]+) | \g&lt;pn&gt; )* \) )
(sens|respons)e and \g'1'ibility</code></pre><p>PCRE supports an extension to Oniguruma: if a number is preceded by a
plus or minus sign, it is taken as a relative reference, for example:</p><pre><code class="">
(abc)(?i:\g&lt;-1&gt;)</code></pre><p>Notice that \g{...} (Perl syntax) and \g&lt;...&gt; (Oniguruma syntax)
are <em>not</em> synonymous. The former is a back reference; the latter
is a subroutine call.</p><a name="sect23"></a><h3>Backtracking Control</h3><p>Perl 5.10 introduced some "Special Backtracking Control Verbs",
which are still described in the Perl documentation as "experimental and
subject to change or removal in a future version of Perl". It goes on to
say: "Their usage in production code should be noted to avoid problems
during upgrades." The same remarks apply to the PCRE features described
in this section.</p><p>The new verbs make use of what was previously invalid syntax: an opening
parenthesis followed by an asterisk. They are generally of the form
(*VERB) or (*VERB:NAME). Some can take either form, possibly behaving
differently depending on whether a name is present. A name is any sequence
of characters that does not include a closing parenthesis. The maximum
name length is 255 in the 8-bit library and 65535 in the 16-bit and 32-bit
libraries. If the name is empty, that is, if the closing parenthesis
immediately follows the colon, the effect is as if the colon was not
there. Any number of these verbs can occur in a pattern.</p><p>The behavior of these verbs in repeated groups, assertions, and in
subpatterns called as subroutines (whether or not recursively) is
described below.</p><p><em>Optimizations That Affect Backtracking Verbs</em></p><p>PCRE contains some optimizations that are used to speed up matching by
running some checks at the start of each match attempt. For example, it
can know the minimum length of matching subject, or that a particular
character must be present. When one of these optimizations bypasses the
running of a match, any included backtracking verbs are not processed.
processed. You can suppress the start-of-match optimizations by setting
option <strong>no_start_optimize</strong> when calling
<a href="#compile/2">compile/2</a> or
<a href="#run/3">run/3</a>, or by starting the
pattern with (*NO_START_OPT).</p><p>Experiments with Perl suggest that it too has similar optimizations,
sometimes leading to anomalous results.</p><p><em>Verbs That Act Immediately</em></p><p>The following verbs act as soon as they are encountered. They must not
be followed by a name.</p><pre><code class="">
(*ACCEPT)</code></pre><p>This verb causes the match to end successfully, skipping the remainder of
the pattern. However, when it is inside a subpattern that is called as a
subroutine, only that subpattern is ended successfully. Matching then
continues at the outer level. If (*ACCEPT) is triggered in a positive
assertion, the assertion succeeds; in a negative assertion, the assertion
fails.</p><p>If (*ACCEPT) is inside capturing parentheses, the data so far is
captured. For example, the following matches "AB", "AAD", or "ACD". When
it matches "AB", "B" is captured by the outer parentheses.</p><pre><code class="">
A((?:A|B(*ACCEPT)|C)D)</code></pre><p>The following verb causes a matching failure, forcing backtracking to
occur. It is equivalent to (?!) but easier to read.</p><pre><code class="">
(*FAIL) or (*F)</code></pre><p>The Perl documentation states that it is probably useful only when
combined with (?{}) or (??{}). Those are Perl features that
are not present in PCRE.</p><p>A match with the string "aaaa" always fails, but the callout is taken
before each backtrack occurs (in this example, 10 times).</p><p><em>Recording Which Path Was Taken</em></p><p>The main purpose of this verb is to track how a match was arrived at,
although it also has a secondary use in with advancing the match
starting point (see (*SKIP) below).</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>In Erlang, there is no interface to retrieve a mark with
<a href="#run/2">run/2</a>, so only the secondary
purpose is relevant to the Erlang programmer.</p><p>The rest of this section is therefore deliberately not adapted for
reading by the Erlang programmer, but the examples can help in
understanding NAMES as they can be used by (*SKIP).</p></div><pre><code class="">
(*MARK:NAME) or (*:NAME)</code></pre><p>A name is always required with this verb. There can be as many instances
of (*MARK) as you like in a pattern, and their names do not have to be
unique.</p><p>When a match succeeds, the name of the last encountered (*MARK:NAME),
(*PRUNE:NAME), or (*THEN:NAME) on the matching path is passed back to the
caller as described in section "Extra data for <strong>pcre_exec()</strong>" in the
<strong>pcreapi</strong> documentation. In the following example of <strong>pcretest</strong>
output, the /K modifier requests the retrieval and outputting of (*MARK)
data:</p><pre><code class="">
  re&gt; /X(*MARK:A)Y|X(*MARK:B)Z/K
data&gt; XY
 0: XY
MK: A
XZ
 0: XZ
MK: B</code></pre><p>The (*MARK) name is tagged with "MK:" in this output, and in this example
it indicates which of the two alternatives matched. This is a more
efficient way of obtaining this information than putting each alternative
in its own capturing parentheses.</p><p>If a verb with a name is encountered in a positive assertion that is
true, the name is recorded and passed back if it is the last encountered.
This does not occur for negative assertions or failing positive
assertions.</p><p>After a partial match or a failed match, the last encountered name in the
entire match process is returned, for example:</p><pre><code class="">
  re&gt; /X(*MARK:A)Y|X(*MARK:B)Z/K
data&gt; XP
No match, mark = B</code></pre><p>Notice that in this unanchored example, the mark is retained from the
match attempt that started at letter "X" in the subject. Subsequent match
attempts starting at "P" and then with an empty string do not get as far
as the (*MARK) item, nevertheless do not reset it.</p><p><em>Verbs That Act after Backtracking</em></p><p>The following verbs do nothing when they are encountered. Matching
continues with what follows, but if there is no subsequent match, causing
a backtrack to the verb, a failure is forced. That is, backtracking cannot
pass to the left of the verb. However, when one of these verbs appears
inside an atomic group or an assertion that is true, its effect is
confined to that group, as once the group has been matched, there is never
any backtracking into it. In this situation, backtracking can "jump back"
to the left of the entire atomic group or assertion. (Remember also, as
stated above, that this localization also applies in subroutine
calls.)</p><p>These verbs differ in exactly what kind of failure occurs when
backtracking reaches them. The behavior described below is what occurs
when the verb is not in a subroutine or an assertion. Subsequent sections
cover these special cases.</p><p>The following verb, which must not be followed by a name, causes the
whole match to fail outright if there is a later matching failure that
causes backtracking to reach it. Even if the pattern is unanchored, no
further attempts to find a match by advancing the starting point take
place.</p><pre><code class="">
(*COMMIT)</code></pre><p>If (*COMMIT) is the only backtracking verb that is encountered, once it
has been passed, <a href="#run/2">run/2</a> is
committed to find a match at the current starting point, or not at all,
for example:</p><pre><code class="">
a+(*COMMIT)b</code></pre><p>This matches "xxaab" but not "aacaab". It can be thought of as a kind of
dynamic anchor, or "I've started, so I must finish". The name of the most
recently passed (*MARK) in the path is passed back when (*COMMIT) forces
a match failure.</p><p>If more than one backtracking verb exists in a pattern, a different one
that follows (*COMMIT) can be triggered first, so merely passing (*COMMIT)
during a match does not always guarantee that a match must be at this
starting point.</p><p>Notice that (*COMMIT) at the start of a pattern is not the same as an
anchor, unless the PCRE start-of-match optimizations are turned off, as
shown in the following example:</p><pre><code class="">
1&gt; re:run("xyzabc","(*COMMIT)abc",[{capture,all,list}]).
{match,["abc"]}
2&gt; re:run("xyzabc","(*COMMIT)abc",[{capture,all,list},no_start_optimize]).
nomatch</code></pre><p>For this pattern, PCRE knows that any match must start with "a", so the
optimization skips along the subject to "a" before applying the pattern to the
first set of data. The match attempt then succeeds. In the second call the
<strong>no_start_optimize</strong> disables the optimization that skips along to the
first character. The pattern is now applied starting at "x", and so the
(*COMMIT) causes the match to fail without trying any other starting
points.</p><p>The following verb causes the match to fail at the current starting
position in the subject if there is a later matching failure that causes
backtracking to reach it:</p><pre><code class="">
(*PRUNE) or (*PRUNE:NAME)</code></pre><p>If the pattern is unanchored, the normal "bumpalong" advance to the next
starting character then occurs. Backtracking can occur as usual to the
left of (*PRUNE), before it is reached, or when matching to the right of
(*PRUNE), but if there is no match to the right, backtracking cannot
cross (*PRUNE). In simple cases, the use of (*PRUNE) is just an
alternative to an atomic group or possessive quantifier, but there are
some uses of (*PRUNE) that cannot be expressed in any other way. In an
anchored pattern, (*PRUNE) has the same effect as (*COMMIT).</p><p>The behavior of (*PRUNE:NAME) is the not the same as
(*MARK:NAME)(*PRUNE). It is like (*MARK:NAME) in that the name is
remembered for passing back to the caller. However, (*SKIP:NAME) searches
only for names set with (*MARK).</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The fact that (*PRUNE:NAME) remembers the name is useless to the Erlang
programmer, as names cannot be retrieved.</p></div><p>The following verb, when specified without a name, is like (*PRUNE),
except that if the pattern is unanchored, the "bumpalong" advance is not
to the next character, but to the position in the subject where (*SKIP)
was encountered.</p><pre><code class="">
(*SKIP)</code></pre><p>(*SKIP) signifies that whatever text was matched leading up to it cannot
be part of a successful match. Consider:</p><pre><code class="">
a+(*SKIP)b</code></pre><p>If the subject is "aaaac...", after the first match attempt fails
(starting at the first character in the string), the starting point skips
on to start the next attempt at "c". Notice that a possessive quantifier
does not have the same effect as this example; although it would suppress
backtracking during the first match attempt, the second attempt would
start at the second character instead of skipping on to "c".</p><p>When (*SKIP) has an associated name, its behavior is modified:</p><pre><code class="">
(*SKIP:NAME)</code></pre><p>When this is triggered, the previous path through the pattern is searched
for the most recent (*MARK) that has the same name. If one is found, the
"bumpalong" advance is to the subject position that corresponds to that
(*MARK) instead of to where (*SKIP) was encountered. If no (*MARK) with a
matching name is found, (*SKIP) is ignored.</p><p>Notice that (*SKIP:NAME) searches only for names set by (*MARK:NAME). It
ignores names that are set by (*PRUNE:NAME) or (*THEN:NAME).</p><p>The following verb causes a skip to the next innermost alternative when
backtracking reaches it. That is, it cancels any further backtracking
within the current alternative.</p><pre><code class="">
(*THEN) or (*THEN:NAME)</code></pre><p>The verb name comes from the observation that it can be used for a
pattern-based if-then-else block:</p><pre><code class="">
( COND1 (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ ) ...</code></pre><p>If the COND1 pattern matches, FOO is tried (and possibly further items
after the end of the group if FOO succeeds). On failure, the matcher skips
to the second alternative and tries COND2, without backtracking into
COND1. If that succeeds and BAR fails, COND3 is tried. If BAZ then fails,
there are no more alternatives, so there is a backtrack to whatever
came before the entire group. If (*THEN) is not inside an alternation, it
acts like (*PRUNE).</p><p>The behavior of (*THEN:NAME) is the not the same as (*MARK:NAME)(*THEN).
It is like (*MARK:NAME) in that the name is remembered for passing back to
the caller. However, (*SKIP:NAME) searches only for names set with
(*MARK).</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The fact that (*THEN:NAME) remembers the name is useless to the Erlang
programmer, as names cannot be retrieved.</p></div><p>A subpattern that does not contain a | character is just a part of the
enclosing alternative; it is not a nested alternation with only one
alternative. The effect of (*THEN) extends beyond such a subpattern to the
enclosing alternative. Consider the following pattern, where A, B, and so
on, are complex pattern fragments that do not contain any | characters at
this level:</p><pre><code class="">
A (B(*THEN)C) | D</code></pre><p>If A and B are matched, but there is a failure in C, matching does not
backtrack into A; instead it moves to the next alternative, that is, D.
However, if the subpattern containing (*THEN) is given an alternative, it
behaves differently:</p><pre><code class="">
A (B(*THEN)C | (*FAIL)) | D</code></pre><p>The effect of (*THEN) is now confined to the inner subpattern. After a
failure in C, matching moves to (*FAIL), which causes the whole subpattern
to fail, as there are no more alternatives to try. In this case, matching
does now backtrack into A.</p><p>Notice that a conditional subpattern is not considered as having two
alternatives, as only one is ever used. That is, the | character in a
conditional subpattern has a different meaning. Ignoring whitespace,
consider:</p><pre><code class="">
^.*? (?(?=a) a | b(*THEN)c )</code></pre><p>If the subject is "ba", this pattern does not match. As .*? is ungreedy,
it initially matches zero characters. The condition (?=a) then fails, the
character "b" is matched, but "c" is not. At this point, matching does not
backtrack to .*? as can perhaps be expected from the presence of the |
character. The conditional subpattern is part of the single alternative
that comprises the whole pattern, and so the match fails. (If there was a
backtrack into .*?, allowing it to match "b", the match would
succeed.)</p><p>The verbs described above provide four different "strengths" of control
when subsequent matching fails:</p><ul><li> <p>(*THEN) is the weakest, carrying on the match at the next
alternative.</p> </li><li> <p>(*PRUNE) comes next, fails the match at the current starting
position, but allows an advance to the next character (for an
unanchored pattern).</p> </li><li> <p>(*SKIP) is similar, except that the advance can be more than one
character.</p> </li><li> <p>(*COMMIT) is the strongest, causing the entire match to fail.</p> </li></ul><p><em>More than One Backtracking Verb</em></p><p>If more than one backtracking verb is present in a pattern, the one that
is backtracked onto first acts. For example, consider the following
pattern, where A, B, and so on, are complex pattern fragments:</p><pre><code class="">
(A(*COMMIT)B(*THEN)C|ABD)</code></pre><p>If A matches but B fails, the backtrack to (*COMMIT) causes the entire
match to fail. However, if A and B match, but C fails, the backtrack to
(*THEN) causes the next alternative (ABD) to be tried. This behavior is
consistent, but is not always the same as in Perl. It means that if two or
more backtracking verbs appear in succession, the last of them has no
effect. Consider the following example:</p><pre><code class="">
...(*COMMIT)(*PRUNE)...</code></pre><p>If there is a matching failure to the right, backtracking onto (*PRUNE)
causes it to be triggered, and its action is taken. There can never be a
backtrack onto (*COMMIT).</p><p><em>Backtracking Verbs in Repeated Groups</em></p><p>PCRE differs from Perl in its handling of backtracking verbs in repeated
groups. For example, consider:</p><pre><code class="">
/(a(*COMMIT)b)+ac/</code></pre><p>If the subject is "abac", Perl matches, but PCRE fails because the
(*COMMIT) in the second repeat of the group acts.</p><p><em>Backtracking Verbs in Assertions</em></p><p>(*FAIL) in an assertion has its normal effect: it forces an immediate
backtrack.</p><p>(*ACCEPT) in a positive assertion causes the assertion to succeed without
any further processing. In a negative assertion, (*ACCEPT) causes the
assertion to fail without any further processing.</p><p>The other backtracking verbs are not treated specially if they appear in
a positive assertion. In particular, (*THEN) skips to the next alternative
in the innermost enclosing group that has alternations, regardless if this
is within the assertion.</p><p>Negative assertions are, however, different, to ensure that changing a
positive assertion into a negative assertion changes its result.
Backtracking into (*COMMIT), (*SKIP), or (*PRUNE) causes a negative
assertion to be true, without considering any further alternative branches
in the assertion. Backtracking into (*THEN) causes it to skip to the next
enclosing alternative within the assertion (the normal behavior), but if
the assertion does not have such an alternative, (*THEN) behaves like
(*PRUNE).</p><p><em>Backtracking Verbs in Subroutines</em></p><p>These behaviors occur regardless if the subpattern is called recursively.
The treatment of subroutines in Perl is different in some cases.</p><ul><li> <p>(*FAIL) in a subpattern called as a subroutine has its normal effect:
it forces an immediate backtrack.</p> </li><li> <p>(*ACCEPT) in a subpattern called as a subroutine causes the
subroutine match to succeed without any further processing. Matching
then continues after the subroutine call.</p> </li><li> <p>(*COMMIT), (*SKIP), and (*PRUNE) in a subpattern called as a
subroutine cause the subroutine match to fail.</p> </li><li> <p>(*THEN) skips to the next alternative in the innermost enclosing
group within the subpattern that has alternatives. If there is no such
group within the subpattern, (*THEN) causes the subroutine match to
fail.</p> </li></ul><h2>sets</h2><p>Functions for set manipulation.</p><p>Sets are collections of elements with no duplicate elements.
The representation of a set is undefined.This module provides the same interface as the
<a href="ordsets">ordsets</a> module
but with an undefined representation. One difference is
that while this module considers two elements as different if they
do not match (<strong>=:=</strong>), <strong>ordsets</strong> considers two elements as
different if and only if they do not compare equal (<strong>==</strong>).</p><h2>Data Types</h2><span class="name">set</span><p>As returned by
<a href="#new/0">new/0</a>.</p><span class="name">set</span><h2>Functions</h2><h3>add_element/2</h3><p>Add an element to a <strong>Set</strong>.</p><p>Returns a new set formed from <strong><span class="anno">Set1</span></strong> with
<strong><span class="anno">Element</span></strong> inserted.</p><h3>del_element/2</h3><p>Remove an element from a <strong>Set</strong>.</p><p>Returns <strong><span class="anno">Set1</span></strong>, but with
<strong><span class="anno">Element</span></strong> removed.</p><h3>filter/2</h3><p>Filter set elements.</p><p>Filters elements in <strong><span class="anno">Set1</span></strong> with boolean function
<strong><span class="anno">Pred</span></strong>.</p><h3>fold/3</h3><p>Fold over set elements.</p><p>Folds <strong><span class="anno">Function</span></strong> over every element in
<strong><span class="anno">Set</span></strong> and returns the final value of the
accumulator. The evaluation order is undefined.</p><h3>from_list/1</h3><p>Convert a list into a <strong>Set</strong>.</p><p>Returns a set of the elements in <strong><span class="anno">List</span></strong>.</p><h3>intersection/1</h3><p>Return the intersection of a list of <strong>Sets</strong>.</p><p>Returns the intersection of the non-empty list of sets.</p><h3>intersection/2</h3><p>Return the intersection of two <strong>Sets</strong>.</p><p>Returns the intersection of <strong><span class="anno">Set1</span></strong> and
<strong><span class="anno">Set2</span></strong>.</p><h3>is_disjoint/2</h3><p>Check whether two <strong>Sets</strong> are disjoint.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Set1</span></strong> and
<strong><span class="anno">Set2</span></strong> are disjoint (have no elements in common),
otherwise <strong>false</strong>.</p><h3>is_element/2</h3><p>Test for membership of a <strong>Set</strong>.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Element</span></strong> is an element of
<strong><span class="anno">Set</span></strong>, otherwise <strong>false</strong>.</p><h3>is_empty/1</h3><p>Test for empty set.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Set</span></strong> is an empty set,
otherwise <strong>false</strong>.</p><h3>is_set/1</h3><p>Test for a <strong>Set</strong>.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Set</span></strong> is a set of
elements, otherwise <strong>false</strong>.</p><h3>is_subset/2</h3><p>Test for subset.</p><p>Returns <strong>true</strong> when every element of <strong><span class="anno">Set1</span></strong> is
also a member of <strong><span class="anno">Set2</span></strong>, otherwise <strong>false</strong>.</p><h3>new/0</h3><p>Return an empty set.</p><p>Returns a new empty set.</p><h3>size/1</h3><p>Return the number of elements in a set.</p><p>Returns the number of elements in <strong><span class="anno">Set</span></strong>.</p><h3>subtract/2</h3><p>Return the difference of two <strong>Sets</strong>.</p><p>Returns only the elements of <strong><span class="anno">Set1</span></strong> that are not
also elements of <strong><span class="anno">Set2</span></strong>.</p><h3>to_list/1</h3><p>Convert a <strong>Set</strong>into a list.</p><p>Returns the elements of <strong><span class="anno">Set</span></strong> as a list.
The order of the returned elements is undefined.</p><h3>union/1</h3><p>Return the union of a list of <strong>Sets</strong>.</p><p>Returns the merged (union) set of the list of sets.</p><h3>union/2</h3><p>Return the union of two <strong>Sets</strong>.</p><p>Returns the merged (union) set of <strong><span class="anno">Set1</span></strong> and
<strong><span class="anno">Set2</span></strong>.</p><h3>See Also</h3><p><a href="gb_sets">gb_sets</a>,
<a href="ordsets">ordsets</a></p><h2>shell</h2><p>The Erlang shell.</p><p>This module provides an Erlang shell.The shell is a user interface program
for entering expression sequences. The expressions are
evaluated and a value is returned.
A history mechanism saves previous commands and their
values, which can then be incorporated in later commands.
How many commands and results to save can be determined by the user,
either interactively, by calling
<a href="#history/1">history/1</a> and
<a href="#results/1">results/1</a>,
or by setting the application configuration
parameters <strong>shell_history_length</strong> and
<strong>shell_saved_results</strong> for the STDLIB application.The shell uses a helper process for evaluating commands
to protect the history mechanism from exceptions. By
default the evaluator process is killed when an exception
occurs, but by calling <a href="#catch_exception/1">catch_exception/1</a> or by
setting the application configuration parameter
<strong>shell_catch_exception</strong> for the STDLIB application
this behavior can be changed. See also the example below.Variable bindings, and local process dictionary changes
that are generated in user expressions are preserved, and the variables
can be used in later commands to access their values. The
bindings can also be forgotten so the variables can be reused.The special shell commands all have the syntax of (local)
function calls. They are evaluated as
normal function calls and many commands can be used in one
expression sequence.If a command (local function call) is not recognized by the
shell, an attempt is first made to find the function in
module <strong>user_default</strong>, where customized local commands
can be placed. If found, the function is evaluated,
otherwise an attempt is made to evaluate the function in
module <strong>shell_default</strong>. Module
<strong>user_default</strong> must be explicitly loaded.The shell also permits the user to start multiple concurrent
jobs. A job can be regarded as a set of processes that can
communicate with the shell.There is some support for reading and printing records in
the shell. During compilation record expressions are translated
to tuple expressions. In runtime it is not known whether a tuple
represents a record, and the record definitions
used by the compiler are unavailable at runtime. So, to read the
record syntax and print tuples as records when possible, record
definitions must be maintained by the shell itself.The shell commands for reading, defining, forgetting, listing, and
printing records are described below. Notice that each job has its
own set of record definitions. To facilitate matters, record
definitions in modules <strong>shell_default</strong> and
<strong>user_default</strong> (if loaded) are read each time a new job is
started. For example, adding the following line
to <strong>user_default</strong> makes the definition of <strong>file_info</strong>
readily available in the shell:<pre><code class="">
-include_lib("kernel/include/file.hrl").</code></pre>The shell runs in two modes:<ul><li> <p><strong>Normal (possibly restricted)</strong> mode, in which
commands can be edited and expressions evaluated</p> </li><li> <p>Job Control Mode, <strong>JCL</strong>, in which jobs can be
started, killed, detached, and connected</p> </li></ul>Only the currently connected job can 'talk' to the shell.</p><h3>Shell Commands</h3><dl><dt><strong>b()</strong></dt><dd> <p>Prints the current variable bindings.</p> </dd><dt><strong>f()</strong></dt><dd> <p>Removes all variable bindings.</p> </dd><dt><strong>f(X)</strong></dt><dd> <p>Removes the binding of variable <strong>X</strong>.</p> </dd><dt><strong>h()</strong></dt><dd> <p>Prints the history list.</p> </dd><dt><strong>history(N)</strong></dt><dd> <p>Sets the number of previous commands to keep in the
history list to <strong>N</strong>. The previous number is returned.
Defaults to 20.</p> </dd><dt><strong>results(N)</strong></dt><dd> <p>Sets the number of results from previous commands to keep in
the history list to <strong>N</strong>. The previous number is returned.
Defaults to 20.</p> </dd><dt><strong>e(N)</strong></dt><dd> <p>Repeats command <strong>N</strong>, if <strong>N</strong> is positive. If
it is negative, the <strong>N</strong>th previous command is repeated
(that is, <strong>e(-1)</strong> repeats the previous command).</p> </dd><dt><strong>v(N)</strong></dt><dd> <p>Uses the return value of command <strong>N</strong> in the
current command, if <strong>N</strong> is positive. If it is negative,
the return value of the <strong>N</strong>th previous command is used
(that is, <strong>v(-1)</strong> uses the value of the previous command).</p> </dd><dt><strong>help()</strong></dt><dd> <p>Evaluates <strong>shell_default:help()</strong>.</p> </dd><dt><strong>c(Mod)</strong></dt><dd> <p>Evaluates <strong>shell_default:c(Mod)</strong>. This compiles and
loads the module <strong>Mod</strong> and purges old versions of the
code, if necessary. <strong>Mod</strong> can be either a module name or a
a source file path, with or without <strong>.erl</strong> extension.</p> </dd><dt><strong>catch_exception(Bool)</strong></dt><dd> <p>Sets the exception handling of the evaluator process. The
previous exception handling is returned. The default
(<strong>false</strong>) is to kill the evaluator process when an
exception occurs, which causes the shell to create a new
evaluator process. When the exception handling is set to
<strong>true</strong>, the evaluator process lives on. This means,
for example, that ports and ETS tables as well as processes
linked to the evaluator process survive the exception.</p> </dd><dt><strong>rd(RecordName, RecordDefinition)</strong></dt><dd> <p>Defines a record in the shell. <strong>RecordName</strong> is
an atom and <strong>RecordDefinition</strong> lists the field names
and the default values. Usually record definitions are made
known to the shell by use of the <strong>rr/1,2,3</strong> commands
described below, but sometimes it is handy to define records
on the fly.</p> </dd><dt><strong>rf()</strong></dt><dd> <p>Removes all record definitions, then reads record
definitions from the modules <strong>shell_default</strong> and
<strong>user_default</strong> (if loaded). Returns the names of the
records defined.</p> </dd><dt><strong>rf(RecordNames)</strong></dt><dd> <p>Removes selected record definitions.
<strong>RecordNames</strong> is a record name or a list of record names.
To remove all record definitions, use <strong>'_'</strong>.</p> </dd><dt><strong>rl()</strong></dt><dd> <p>Prints all record definitions.</p> </dd><dt><strong>rl(RecordNames)</strong></dt><dd> <p>Prints selected record definitions.
<strong>RecordNames</strong> is a record name or a list of record names.</p> </dd><dt><strong>rp(Term)</strong></dt><dd> <p>Prints a term using the record definitions known to the
shell. All of <strong>Term</strong> is printed; the depth is not
limited as is the case when a return value is printed.</p> </dd><dt><strong>rr(Module)</strong></dt><dd> <p>Reads record definitions from a module's BEAM file. If
there are no record definitions in the BEAM file, the
source file is located and read instead. Returns the names
of the record definitions read. <strong>Module</strong> is an atom.</p> </dd><dt><strong>rr(Wildcard)</strong></dt><dd> <p>Reads record definitions from files. Existing
definitions of any of the record names read are replaced.
<strong>Wildcard</strong> is a wildcard string as defined in
<a href="filelib">filelib</a>,
but not an atom.</p> </dd><dt><strong>rr(WildcardOrModule, RecordNames)</strong></dt><dd> <p>Reads record definitions from files but
discards record names not mentioned in <strong>RecordNames</strong> (a
record name or a list of record names).</p> </dd><dt><strong>rr(WildcardOrModule, RecordNames, Options)</strong></dt><dd> <p>Reads record definitions from files. The compiler
options <strong>{i,Dir}</strong>, <strong>{d,Macro}</strong>, and
<strong>{d,Macro,Value}</strong> are recognized and used
for setting up the include path and macro definitions.
To read all record definitions, use
<strong>'_'</strong> as value of <strong>RecordNames</strong>.</p> </dd></dl><h3>Example</h3><p>The following example is a long dialog with the shell. Commands
starting with <strong>&gt;</strong> are inputs to the shell. All other lines
are output from the shell.</p><pre>
strider 1&gt; <span class="input">erl</span>
Erlang (BEAM) emulator version 5.3 [hipe] [threads:0]

Eshell V5.3  (abort with ^G)
1&gt; <span class="input">Str = "abcd".</span>
"abcd"</pre><p>Command 1 sets variable <strong>Str</strong> to string <strong>"abcd"</strong>.</p><pre>
2&gt; <span class="input">L = length(Str).</span>
4</pre><p>Command 2 sets <strong>L</strong> to the length of string <strong>Str</strong>.</p><pre>
3&gt; <span class="input">Descriptor = {L, list_to_atom(Str)}.</span>
{4,abcd}</pre><p>Command 3 builds the tuple <strong>Descriptor</strong>, evaluating the BIF
<a href="../erts/erlang#list_to_atom/1">erts/erlang#list_to_atom/1</a>.</p><pre>
4&gt; <span class="input">L.</span> 
4</pre><p>Command 4 prints the value of variable <strong>L</strong>.</p><pre>
5&gt; <span class="input">b().</span>
Descriptor = {4,abcd}
L = 4
Str = "abcd"
ok</pre><p>Command 5 evaluates the internal shell command <strong>b()</strong>, which
is an abbreviation of "bindings". This prints
the current shell variables and their bindings. <strong>ok</strong> at
the end is the return value of function <strong>b()</strong>.</p><pre>
6&gt; <span class="input">f(L).</span> 
ok</pre><p>Command 6 evaluates the internal shell command <strong>f(L)</strong> (abbreviation
of "forget"). The value of variable <strong>L</strong> is removed.</p><pre>
7&gt; <span class="input">b().</span>
Descriptor = {4,abcd}
Str = "abcd"
ok</pre><p>Command 7 prints the new bindings.</p><pre>
8&gt; <span class="input">f(L).</span>
ok</pre><p>Command 8 has no effect, as <strong>L</strong> has no value.</p><pre>
9&gt; <span class="input">{L, _} = Descriptor.</span>
{4,abcd}</pre><p>Command 9 performs a pattern matching operation on
<strong>Descriptor</strong>, binding a new value to <strong>L</strong>.</p><pre>
10&gt; <span class="input">L.</span>
4</pre><p>Command 10 prints the current value of <strong>L</strong>.</p><pre>
11&gt; <span class="input">{P, Q, R} = Descriptor.</span>
** exception error: no match of right hand side value {4,abcd}</pre><p>Command 11 tries to match <strong>{P, Q, R}</strong> against
<strong>Descriptor</strong>, which is <strong>{4, abc}</strong>. The match fails and
none of the new variables become bound. The printout starting
with "<strong>** exception error:</strong>" is not the value of the
expression (the expression had no value because its evaluation
failed), but a warning printed by the system to inform
the user that an error has occurred. The values of the other
variables (<strong>L</strong>, <strong>Str</strong>, and so on) are unchanged.</p><pre>
12&gt; <span class="input">P.</span>
* 1: variable 'P' is unbound
13&gt; <span class="input">Descriptor.</span>
{4,abcd}</pre><p>Commands 12 and 13 show that <strong>P</strong> is unbound because the
previous command failed, and that <strong>Descriptor</strong> has not
changed.</p><pre>
14&gt;<span class="input">{P, Q} = Descriptor.</span>
{4,abcd}
15&gt; <span class="input">P.</span>
4</pre><p>Commands 14 and 15 show a correct match where <strong>P</strong> and
<strong>Q</strong> are bound.</p><pre>
16&gt; <span class="input">f().</span>
ok</pre><p>Command 16 clears all bindings.</p><p>The next few commands assume that <strong>test1:demo(X)</strong> is
defined as follows:</p><p><strong>demo(X) -&gt;</strong><br/>
<strong>put(aa, worked),</strong><br/>
<strong>X = 1,</strong><br/>
<strong>X + 10.</strong></p><pre>
17&gt; <span class="input">put(aa, hello).</span>
undefined
18&gt; <span class="input">get(aa).</span>
hello</pre><p>Commands 17 and 18 set and inspect the value of item
<strong>aa</strong> in the process dictionary.</p><pre>
19&gt; <span class="input">Y = test1:demo(1).</span>
11</pre><p>Command 19 evaluates <strong>test1:demo(1)</strong>. The evaluation
succeeds and the changes made in the process dictionary become
visible to the shell. The new value of dictionary item
<strong>aa</strong> can be seen in command 20.</p><pre>
20&gt; <span class="input">get().</span>
[{aa,worked}]
21&gt; <span class="input">put(aa, hello).</span>
worked
22&gt; <span class="input">Z = test1:demo(2).</span>
** exception error: no match of right hand side value 1
     in function  test1:demo/1</pre><p>Commands 21 and 22 change the value of dictionary item
<strong>aa</strong> to <strong>hello</strong> and call <strong>test1:demo(2)</strong>. Evaluation
fails and the changes made to the dictionary in
<strong>test1:demo(2)</strong>, before the error occurred, are discarded.</p><pre>
23&gt; <span class="input">Z.</span>
* 1: variable 'Z' is unbound
24&gt; <span class="input">get(aa).</span>
hello</pre><p>Commands 23 and 24 show that <strong>Z</strong> was not bound and that
dictionary item <strong>aa</strong> has retained its original value.</p><pre>
25&gt; <span class="input">erase(), put(aa, hello).</span>
undefined
26&gt; <span class="input">spawn(test1, demo, [1]).</span>
&lt;0.57.0&gt;
27&gt; <span class="input">get(aa).</span>
hello</pre><p>Commands 25, 26, and 27 show the effect of evaluating
<strong>test1:demo(1)</strong> in the background. In this case, the
expression is evaluated in a newly spawned process. Any
changes made in the process dictionary are local to the newly
spawned process and therefore not visible to the shell.</p><pre>
28&gt; <span class="input">io:format("hello hello\n").</span>
hello hello
ok
29&gt; <span class="input">e(28).</span>
hello hello
ok
30&gt; <span class="input">v(28).</span>
ok</pre><p>Commands 28, 29 and 30 use the history facilities of the shell.
Command 29 re-evaluates command 28. Command 30 uses the value (result)
of command 28. In the cases of a pure function (a function
with no side effects), the result is the same. For a function
with side effects, the result can be different.</p><p>The next few commands show some record manipulation. It is
assumed that <strong>ex.erl</strong> defines a record as follows:</p><p><strong>-record(rec, {a, b = val()}).</strong></p><p><strong>val() -&gt;</strong><br/>
<strong>3.</strong></p><pre>
31&gt; <span class="input">c(ex).</span>
{ok,ex}
32&gt; <span class="input">rr(ex).</span>
[rec]</pre><p>Commands 31 and 32 compile file <strong>ex.erl</strong> and read
the record definitions in <strong>ex.beam</strong>. If the compiler did not
output any record definitions on the BEAM file, <strong>rr(ex)</strong>
tries to read record definitions from the source file instead.</p><pre>
33&gt; <span class="input">rl(rec).</span>
-record(rec,{a,b = val()}).
ok</pre><p>Command 33 prints the definition of the record named
<strong>rec</strong>.</p><pre>
34&gt; <span class="input">#rec{}.</span>
** exception error: undefined shell command val/0</pre><p>Command 34 tries to create a <strong>rec</strong> record, but fails
as function <strong>val/0</strong> is undefined.</p><pre>
35&gt; <span class="input">#rec{b = 3}.</span>
#rec{a = undefined,b = 3}</pre><p>Command 35 shows the workaround: explicitly assign values to record
fields that cannot otherwise be initialized.</p><pre>
36&gt; <span class="input">rp(v(-1)).</span>
#rec{a = undefined,b = 3}
ok</pre><p>Command 36 prints the newly created record using record
definitions maintained by the shell.</p><pre>
37&gt; <span class="input">rd(rec, {f = orddict:new()}).</span>
rec</pre><p>Command 37 defines a record directly in the shell. The 
definition replaces the one read from file <strong>ex.beam</strong>.</p><pre>
38&gt; <span class="input">#rec{}.</span>
#rec{f = []}
ok</pre><p>Command 38 creates a record using the new definition, and
prints the result.</p><pre>
39&gt; <span class="input">rd(rec, {c}), A.</span>
* 1: variable 'A' is unbound
40&gt; <span class="input">#rec{}.</span>
#rec{c = undefined}
ok</pre><p>Command 39 and 40 show that record definitions are updated
as side effects. The evaluation of the command fails, but
the definition of <strong>rec</strong> has been carried out.</p><p>For the next command, it is assumed that <strong>test1:loop(N)</strong> is
defined as follows:</p><p><strong>loop(N) -&gt;</strong><br/>
<strong>io:format("Hello Number: ~w~n", [N]),</strong><br/> 
<strong>loop(N+1).</strong></p><pre>
41&gt; <span class="input">test1:loop(0).</span>
Hello Number: 0
Hello Number: 1
Hello Number: 2
Hello Number: 3

User switch command
 --&gt; i
 --&gt; c
.
.
.
Hello Number: 3374
Hello Number: 3375
Hello Number: 3376
Hello Number: 3377
Hello Number: 3378
** exception exit: killed</pre><p>Command 41 evaluates <strong>test1:loop(0)</strong>, which puts the
system into an infinite loop. At this point the user types
<strong>^G</strong> (Control G), which suspends output from the
current process,
which is stuck in a loop, and activates <strong>JCL</strong> mode. In <strong>JCL</strong>
mode the user can start and stop jobs.</p><p>In this particular case, command <strong>i</strong> ("interrupt")
terminates the looping program, and command <strong>c</strong>
connects to the shell again. As the process was
running in the background before we killed it, more
printouts occur before message "<strong>** exception exit: killed</strong>"
is shown.</p><pre>
42&gt; <span class="input">E = ets:new(t, []).</span>
#Ref&lt;0.1662103692.2407923716.214192&gt;</pre><p>Command 42 creates an ETS table.</p><pre>
43&gt; <span class="input">ets:insert({d,1,2}).</span>
** exception error: undefined function ets:insert/1</pre><p>Command 43 tries to insert a tuple into the ETS table, but the
first argument (the table) is missing. The exception kills the
evaluator process.</p><pre>
44&gt; <span class="input">ets:insert(E, {d,1,2}).</span>
** exception error: argument is of wrong type
     in function  ets:insert/2
        called as ets:insert(16,{d,1,2})</pre><p>Command 44 corrects the mistake, but the ETS table has been
destroyed as it was owned by the killed evaluator process.</p><pre>
45&gt; <span class="input">f(E).</span>
ok
46&gt; <span class="input">catch_exception(true).</span>
false</pre><p>Command 46 sets the exception handling of the evaluator process
to <strong>true</strong>. The exception handling can also be set when
starting Erlang by <strong>erl -stdlib shell_catch_exception true</strong>.</p><pre>
47&gt; <span class="input">E = ets:new(t, []).</span>
#Ref&lt;0.1662103692.2407923716.214197&gt;
48&gt; <span class="input">ets:insert({d,1,2}).</span>
* exception error: undefined function ets:insert/1</pre><p>Command 48 makes the same mistake as in command 43, but this time
the evaluator process lives on. The single star at the beginning
of the printout signals that the exception has been caught.</p><pre>
49&gt; <span class="input">ets:insert(E, {d,1,2}).</span>
true</pre><p>Command 49 successfully inserts the tuple into the ETS table.</p><pre>
50&gt; <span class="input">ets:insert(#Ref&lt;0.1662103692.2407923716.214197&gt;, {e,3,4}).</span>
true</pre><p>Command 50 inserts another tuple into the ETS table. This time
the first argument is the table identifier itself. The shell can
parse commands with pids (<strong>&lt;0.60.0&gt;</strong>), ports
(<strong>#Port&lt;0.536&gt;</strong>), references
(<strong>#Ref&lt;0.1662103692.2407792644.214210&gt;</strong>), and external
functions (<strong>#Fun&lt;a.b.1&gt;</strong>), but the command fails unless
the corresponding pid, port, reference, or function can be created
in the running system.</p><pre>
51&gt; <span class="input">halt().</span>
strider 2&gt;</pre><p>Command 51 exits the Erlang runtime system.</p><h3>JCL Mode</h3><p>When the shell starts, it starts a single evaluator
process. This process, together with any local processes that
it spawns, is referred to as a <strong>job</strong>. Only the current job,
which is said to be <strong>connected</strong>, can perform operations
with standard I/O. All other jobs, which are said to be <strong>detached</strong>,
are <strong>blocked</strong> if they attempt to use standard I/O.</p><p>All jobs that do not use standard I/O run in the normal way.</p><p>The shell escape key <strong>^G</strong> (Control G) detaches the current
job and activates <strong>JCL</strong> mode. The <strong>JCL</strong> mode prompt is
<strong>"--&gt;"</strong>. If <strong>"?"</strong> is entered at the prompt, the following help
message is displayed:</p><pre>
--&gt; ?
c [nn]            - connect to job
i [nn]            - interrupt job
k [nn]            - kill job
j                 - list all jobs
s [shell]         - start local shell
r [node [shell]]  - start remote shell
q                 - quit erlang
? | h             - this message</pre><p>The <strong>JCL</strong> commands have the following meaning:</p><dl><dt><strong>c [nn]</strong></dt><dd> <p>Connects to job number <strong>&lt;nn&gt;</strong> or the current
job. The standard shell is resumed. Operations that use
standard I/O by the current job are interleaved with
user inputs to the shell.</p> </dd><dt><strong>i [nn]</strong></dt><dd> <p>Stops the current evaluator process for job number
<strong>nn</strong> or the current job, but does not kill the shell
process. So, any variable bindings and the process
dictionary are preserved and the job can be connected again.
This command can be used to interrupt an endless loop.</p> </dd><dt><strong>k [nn]</strong></dt><dd> <p>Kills job number <strong>nn</strong> or the current
job. All spawned processes in the job are
killed, provided they have not evaluated the
<strong>group_leader/1</strong> BIF and are located on
the local machine. Processes spawned on remote nodes
are not killed.</p> </dd><dt><strong>j</strong></dt><dd> <p>Lists all jobs. A list of all known jobs is
printed. The current job name is prefixed with '*'.</p> </dd><dt><strong>s</strong></dt><dd> <p>Starts a new job. This is assigned the new index
<strong>[nn]</strong>, which can be used in references.</p> </dd><dt><strong>s [shell]</strong></dt><dd> <p>Starts a new job. This is assigned the new index
<strong>[nn]</strong>, which can be used in references.
If optional argument <strong>shell</strong> is specified, it is assumed
to be a module that implements an alternative shell.</p> </dd><dt><strong>r [node]</strong></dt><dd> <p>Starts a remote job on <strong>node</strong>. This is used in
distributed Erlang to allow a shell running on one node to
control a number of applications running on a network of nodes.
If optional argument <strong>shell</strong> is specified, it is assumed
to be a module that implements an alternative shell.</p> </dd><dt><strong>q</strong></dt><dd> <p>Quits Erlang. Notice that this option is disabled if
Erlang is started with the ignore break, <strong>+Bi</strong>,
system flag (which can be useful, for example when running
a restricted shell, see the next section).</p> </dd><dt><strong>?</strong></dt><dd> <p>Displays the help message above.</p> </dd></dl><p>The behavior of shell escape can be changed by the STDLIB
application variable <strong>shell_esc</strong>. The value of
the variable can be either <strong>jcl</strong> (<strong>erl -stdlib shell_esc jcl</strong>) 
or <strong>abort</strong> (<strong>erl -stdlib shell_esc abort</strong>). The 
first option sets <strong>^G</strong> to activate <strong>JCL</strong> mode (which
is also default behavior). The latter sets <strong>^G</strong> to
terminate the current shell and start a new one.
<strong>JCL</strong> mode cannot be invoked when 
<strong>shell_esc</strong> is set to <strong>abort</strong>.</p><p>If you want an Erlang node to have a remote job active from the start
(rather than the default local job), start Erlang with flag
<strong>-remsh</strong>, for example,
<strong>erl -sname this_node -remsh other_node@other_host</strong></p><h3>Restricted Shell</h3><p>The shell can be started in a
restricted mode. In this mode, the shell evaluates a function call
only if allowed. This feature makes it possible to, for example,
prevent a user from accidentally calling a function from the
prompt that could harm a running system (useful in combination
with system flag <strong>+Bi</strong>).</p><p>When the restricted shell evaluates an expression and
encounters a function call or an operator application,
it calls a callback function (with
information about the function call in question). This callback
function returns <strong>true</strong> to let the shell go ahead with the
evaluation, or <strong>false</strong> to abort it. There are two possible
callback functions for the user to implement:</p><ul><li> <p><strong>local_allowed(Func, ArgList, State) -&gt; {boolean(),NewState}</strong></p> <p>This is used to determine if the call to the local function
<strong>Func</strong> with arguments <strong>ArgList</strong> is to be allowed.</p> </li><li> <p><strong>non_local_allowed(FuncSpec, ArgList, State) -&gt; {boolean(),NewState} | {{redirect,NewFuncSpec,NewArgList},NewState}</strong></p> <p>This is used to determine if the call to non-local function
<strong>FuncSpec</strong> (<strong>{Module,Func}</strong> or a fun) with arguments
<strong>ArgList</strong> is to be allowed. The return value
<strong>{redirect,NewFuncSpec,NewArgList}</strong> can be used to let
the shell evaluate some other function than the one specified by
<strong>FuncSpec</strong> and <strong>ArgList</strong>.</p> </li></ul><p>These callback functions are called from local and
non-local evaluation function handlers, described in the
<a href="erl_eval">erl_eval</a> 
manual page. (Arguments in <strong>ArgList</strong> are evaluated before the
callback functions are called.)</p><p>Argument <strong>State</strong> is a tuple
<strong>{ShellState,ExprState}</strong>. The return value <strong>NewState</strong>
has the same form. This can be used to carry a state between calls
to the callback functions. Data saved in <strong>ShellState</strong> lives
through an entire shell session. Data saved in <strong>ExprState</strong>
lives only through the evaluation of the current expression.</p><p>There are two ways to start a restricted shell session:</p><ul><li> <p>Use STDLIB application variable <strong>restricted_shell</strong>
and specify, as its value, the name of the callback
module. Example (with callback functions implemented in
<strong>callback_mod.erl</strong>):
<strong>$ erl -stdlib restricted_shell callback_mod</strong>.</p> </li><li> <p>From a normal shell session, call function
<a href="#start_restricted/1">start_restricted/1</a>. This exits the current evaluator
and starts a new one in restricted mode.</p> </li></ul><p><em>Notes:</em></p><ul><li> <p>When restricted shell mode is activated or
deactivated, new jobs started on the node run in restricted
or normal mode, respectively.</p> </li><li> <p>If restricted mode has been enabled on a
particular node, remote shells connecting to this node also
run in restricted mode.</p> </li><li> <p>The callback functions cannot be used to allow or disallow
execution of functions called from compiled code (only functions
called from expressions entered at the shell prompt).</p> </li></ul><p>Errors when loading the callback module is handled in different
ways depending on how the restricted shell is activated:</p><ul><li> <p>If the restricted shell is activated by setting the STDLIB
variable during emulator startup, and the callback module cannot be
loaded, a default restricted shell allowing only the commands
<strong>q()</strong> and <strong>init:stop()</strong> is used as fallback.</p> </li><li> <p>If the restricted shell is activated using
<a href="#start_restricted/1">start_restricted/1</a> and the callback module cannot
be loaded, an error report is sent to the error logger and the call
returns <strong>{error,Reason}</strong>.</p> </li></ul><h3>Prompting</h3><p>The default shell prompt function displays the name of the node
(if the node can be part of a distributed system) and the
current command number. The user can customize the prompt
function by calling <a href="#prompt_func/1">prompt_func/1</a> or by setting application
configuration parameter <strong>shell_prompt_func</strong> for the
STDLIB application.</p><p>A customized prompt function is stated as a tuple
<strong>{Mod,Func}</strong>. The function is called as
<strong>Mod:Func(L)</strong>, where <strong>L</strong> is a list of key-value pairs
created by the shell. Currently there is only one pair:
<strong>{history, N}</strong>, where <strong>N</strong> is the current command number. The
function is to return a list of characters or an atom. This
constraint is because of the Erlang I/O protocol. Unicode characters
beyond code point 255 are allowed in the list and the atom. Notice
that in restricted mode the call <strong>Mod:Func(L)</strong> must be
allowed or the default shell prompt function is called.</p><h2>Functions</h2><h3>catch_exception(Bool) -&gt; boolean()</h3><p>Set the exception handling of the shell.</p><ul><li><span class="v">Bool = boolean()</span></li></ul><p>Sets the exception handling of the evaluator process. The
previous exception handling is returned. The default
(<strong>false</strong>) is to kill the evaluator process when an
exception occurs, which causes the shell to create a new
evaluator process. When the exception handling is set to
<strong>true</strong>, the evaluator process lives on, which means that,
for example, ports and ETS tables as well as processes
linked to the evaluator process survive the exception.</p><h3>history/1</h3><p>Set the number of previous commands to keep.</p><p>Sets the number of previous commands to keep in the
history list to <strong><span class="anno">N</span></strong>. The previous number is
returned. Defaults to 20.</p><h3>prompt_func/1</h3><p>Set the shell prompt.</p><p>Sets the shell prompt function to <strong><span class="anno">PromptFunc</span></strong>.
The previous prompt function is returned.</p><h3>results/1</h3><p>Set the number of previous results to keep.</p><p>Sets the number of results from previous commands to keep in
the history list to <strong><span class="anno">N</span></strong>. The previous number is
returned. Defaults to 20.</p><h3>start_restricted/1</h3><p>Exit a normal shell and starts a restricted shell.</p><p>Exits a normal shell and starts a restricted shell.
<strong><span class="anno">Module</span></strong> specifies the callback module for the
functions <strong>local_allowed/3</strong> and <strong>non_local_allowed/3</strong>.
The function is meant to be called from the shell.</p><p>If the callback module cannot be loaded, an error tuple is
returned. The <strong><span class="anno">Reason</span></strong> in the error tuple is the one
returned by the code loader when trying to load the code of the
callback module.</p><h3>stop_restricted/0</h3><p>Exit a restricted shell and starts a normal shell.</p><p>Exits a restricted shell and starts a normal shell. The function
is meant to be called from the shell.</p><h3>strings/1</h3><p>Set the shell's string recognition flag.</p><p>Sets pretty printing of lists to <strong><span class="anno">Strings</span></strong>.
The previous value of the flag is returned.</p><p>The flag can also be set by the STDLIB application variable
<strong>shell_strings</strong>. Defaults to
<strong>true</strong>, which means that lists of integers are
printed using the string syntax, when possible. Value
<strong>false</strong> means that no lists are printed using the
string syntax.</p><h2>shell_default</h2><p>Customizing the Erlang environment.</p><p>The functions in this module are called when no module name is
specified in a shell command.Consider the following shell dialog:<pre>
1&gt; <span class="input">lists:reverse("abc").</span>
"cba"
2&gt; <span class="input">c(foo).</span>
{ok, foo}</pre>In command one, module <a href="lists">lists</a> is
called. In command two, no module name is specified. The shell searches
module <strong>user_default</strong> followed by module <strong>shell_default</strong> for
function <strong>c/1</strong>.<strong>shell_default</strong> is intended for "system wide"
customizations to the shell. <strong>user_default</strong> is intended for
"local" or individual user customizations.</p><h3>Hint</h3><p>To add your own commands to the shell, create a module called
<strong>user_default</strong> and add the commands you want. Then add the
following line as the <em>first</em> line in your <strong>.erlang</strong> file in
your home directory.</p><pre>
code:load_abs("$PATH/user_default").</pre><p><strong>$PATH</strong> is the directory where your
<strong>user_default</strong> module can be found.</p><h2>slave</h2><p>Functions for starting and controlling slave nodes.
</p><p>This module provides functions for starting Erlang slave nodes.
All slave nodes that are started by a master terminate
automatically when the master terminates. All terminal output produced
at the slave is sent back to the master node. File I/O is
done through the master.Slave nodes on other hosts than the current one are started with
the <strong>ssh</strong> program. The user must be allowed to <strong>ssh</strong> to
the remote hosts without being prompted for a password. This can
be arranged in a number of ways (for details, see the <strong>ssh</strong>
documentation). A slave node started on the same host
as the master inherits certain environment values from the master,
such as the current directory and the environment variables. For
what can be assumed about the environment when a slave is started
on another host, see the documentation for the <strong>ssh</strong>
program.An alternative to the <strong>ssh</strong> program can be specified on
the command line to
<a href="./erl">erts/erl</a> as follows:<pre>
-rsh Program</pre>Note that the command specified with the <strong>-rsh</strong> flag is
treated as a file name which may contain spaces. It is thus not
possible to include any command line options. The remote node will
be launched as <strong>"$RSH" "$REMOTE_HOSTNAME" erl -detached -noinput ...</strong>, so the
<strong>erl</strong> command must be found in the path on the remote host.The slave node is to use the same file system at the master. At
least, Erlang/OTP is to be installed in the same place on both
computers and the same version of Erlang is to be used.A node running on Windows can only start slave
nodes on the host on which it is running.The master node must be alive.</p><h2>Functions</h2><h3>pseudo([Master | ServerList]) -&gt; ok</h3><p>Start a number of pseudo servers.</p><ul><li><span class="v">Master = node()</span></li><li><span class="v">ServerList = [atom()]</span></li></ul><p>Calls <strong>pseudo(Master, ServerList)</strong>. If you want to start
a node from the command line and set up a number of pseudo
servers, an Erlang runtime system can be started as follows:</p><pre>
% erl -name abc -s slave pseudo klacke@super x --</pre><h3>pseudo/2</h3><p>Start a number of pseudo servers.</p><p>Starts a number of pseudo servers. A pseudo server is a
server with a registered name that does nothing
but pass on all message to the real server that executes at a
master node. A pseudo server is an intermediary that only has
the same registered name as the real server.</p><p>For example, if you have started a slave node <strong>N</strong> and
want to execute <strong>pxw</strong> graphics code on this node, you can
start server <strong>pxw_server</strong> as a pseudo server at
the slave node. This is illustrated as follows:</p><pre><code class="">
rpc:call(N, slave, pseudo, [node(), [pxw_server]]).</code></pre><h3>relay/1</h3><p>Run a pseudo server.</p><p>Runs a pseudo server. This function never returns any value
and the process that executes the function receives
messages. All messages received are simply passed on to
<strong><span class="anno">Pid</span></strong>.</p><h3>start/1</h3><h3>start/2</h3><h3>start/3</h3><p>Start a slave node on a host.</p><p>Starts a slave node on host <strong><span class="anno">Host</span></strong>. Host names
need not necessarily be specified as fully qualified names; short
names can also be used. This is the same condition that
applies to names of distributed Erlang nodes.</p><p>The name of the started node becomes
<strong><span class="anno">Name</span>@<span class="anno">Host</span></strong>. If no
name is provided, the name becomes the same as the node that
executes the call (except the host name part of the node name).</p><p>The slave node resets its <strong>user</strong> process so that all
terminal I/O that is produced at the slave is automatically
relayed to the master. Also, the file process is relayed
to the master.</p><p>Argument <strong><span class="anno">Args</span></strong> is used to set <strong>erl</strong>
command-line arguments. If provided, it is passed to the new
node and can be used for a variety of purposes; see
<a href="./erl">erts/erl</a>.</p><p>As an example, suppose that you want to start a slave node at
host <strong>H</strong> with node name <strong>Name@H</strong> and
want the slave node to have the following properties:</p><ul><li>Directory <strong>Dir</strong> is to be added to the code path.</li><li>The Mnesia directory is to be set to <strong>M</strong>.</li><li>The Unix <strong>DISPLAY</strong> environment variable is to be set to the display of the master node.</li></ul><p>The following code is executed to achieve this:</p><pre><code class="">
E = " -env DISPLAY " ++ net_adm:localhost() ++ ":0 ",
Arg = "-mnesia_dir " ++ M ++ " -pa " ++ Dir ++ E,
slave:start(H, Name, Arg).</code></pre><p>The function returns <strong>{ok, <span class="anno">Node</span>}</strong>, where
<strong><span class="anno">Node</span></strong> is the name of the new node, otherwise
<strong>{error, <span class="anno">Reason</span>}</strong>, where <strong><span class="anno">Reason</span></strong>
can be one of:</p><dl><dt><strong>timeout</strong></dt><dd> <p>The master node failed to get in contact with the slave
node. This can occur in a number of circumstances:</p> <ul><li>Erlang/OTP is not installed on the remote host.</li><li>The file system on the other host has a different structure to the the master.</li><li>The Erlang nodes have different cookies.</li></ul> </dd><dt><strong>no_rsh</strong></dt><dd> <p>No remote shell program was found on the computer. Note
that <strong>ssh</strong> is used by default, but this can be overridden
with the <strong>-rsh</strong> flag.</p> </dd><dt><strong>{already_running, <span class="anno">Node</span>}</strong></dt><dd> <p>A node with name <strong><span class="anno">Name</span>@<span class="anno">Host</span></strong>
already exists.</p> </dd></dl><h3>start_link/1</h3><h3>start_link/2</h3><h3>start_link/3</h3><p>Start and link to a slave node on a host.</p><p>Starts a slave node in the same way as <strong>start/1,2,3</strong>,
except that the slave node is linked to the currently
executing process. If that process terminates, the slave node
also terminates.</p><p>For a description of arguments and return values, see
<a href="#start/1">start/1</a>.</p><h3>stop/1</h3><p>Stop (kill) a node.</p><p>Stops (kills) a node.</p><h2>sofs</h2><p>Functions for manipulating sets of sets.</p><p>This module provides operations on finite sets and
relations represented as sets. Intuitively, a set is a
collection of elements; every element belongs to the set, and
the set contains every element.Given a set A and a sentence S(x), where x is a free variable,
a new set B whose elements are exactly those elements of A for
which S(x) holds can be formed, this is denoted B=
{xinA: S(x)}. Sentences are expressed using
the logical operators "for some" (or "there exists"), "for all",
"and", "or", "not". If the existence of a set containing all the
specified elements is known (as is always the case in this
module), this is denoted B= {x: S(x)}.<ul><li> <p>The <em>unordered set</em> containing the elements a, b, and c is
denoted {a,b,c}. This notation is not to be confused with
tuples.</p> <p>The <em>ordered pair</em> of a and b, with first <em>coordinate</em>
a and second coordinate b, is denoted (a,b). An ordered pair
is an <em>ordered set</em> of two elements. In this module, ordered
sets can contain one, two, or more elements, and parentheses are
used to enclose the elements.</p> <p>Unordered sets and ordered sets are orthogonal, again in this
module; there is no unordered set equal to any ordered set.</p> </li><li> <p>The <em>empty set</em> contains no elements.</p> <p>Set A is <a name="equal"></a><em>equal</em> to set B if they
contain the same elements, which is denoted A=B. Two
ordered sets are equal if they contain the same number of elements
and have equal elements at each coordinate.</p> <p>Set B is a <a name="subset"></a><em>subset</em> of set A
if A contains all elements that B contains.</p> <p>The <a name="union"></a><em>union</em> of two sets A and B
is the smallest set that contains all elements of A and all elements
of B.</p> <p>The <a name="intersection"></a><em>intersection</em> of two
sets A and B is the set that contains all elements of A that belong
to B.</p> <p>Two sets are <a name="disjoint"></a><em>disjoint</em> if
their intersection is the empty set.</p> <p>The <a name="difference"></a><em>difference</em> of two sets
A and B is the set that contains all elements of A that do not belong
to B.</p> <p>The <a name="symmetric_difference"></a><em>symmetric  difference</em> of two sets is the set that contains those element
that belong to either of the two sets, but not both.</p> <p>The <a name="union_n"></a><em>union</em> of a collection
of sets is the smallest set that contains all the elements that
belong to at least one set of the collection.</p> <p>The <a name="intersection_n"></a><em>intersection</em> of
a non-empty collection of sets is the set that contains all elements
that belong to every set of the collection.</p> </li><li> <p>The <a name="Cartesian_product"></a><em>Cartesian product</em> of two sets X and Y, denoted XY, is
the set {a: a= (x,y) for some xinX and
for some yinY}.</p> <p>A <a name="relation"></a><em>relation</em> is a subset of
XY. Let R be a relation. The fact that (x,y)
belongs to R is written as xRy. As relations are sets,
the definitions of the last item (subset, union, and so on) apply to
relations as well.</p> <p>The <a name="domain"></a><em>domain</em> of R is the set
{x: xRy for some yinY}.</p> <p>The <a name="range"></a><em>range</em> of R is the set
{y: xRy for some xinX}.</p> <p>The <a name="converse"></a><em>converse</em> of R is the
set {a: a= (y,x) for some
(x,y)inR}.</p> <p>If A is a subset of X, the <a name="image"></a><em>image</em>
of A under R is the set {y: xRy for some
xinA}. If B is a subset of Y, the
<a name="inverse_image"></a><em>inverse image</em> of B is the
set {x: xRy for some yinB}.</p> <p>If R is a relation from X to Y, and S is a relation from Y to Z, the 
<a name="relative_product"></a><em>relative product</em> of R
and S is the relation T from X to Z defined so that xTz
if and only if there exists an element y in Y such that
xRy and ySz.</p> <p>The <a name="restriction"></a><em>restriction</em> of R to A
is the set S defined so that xSy if and only if there
exists an element x in A such that xRy.</p> <p>If S is a restriction of R to A, then R is an
<a name="extension"></a><em>extension</em> of S to X.</p> <p>If X=Y, then R is called a relation <em>in</em> X.</p> <p>The <a name="field"></a><em>field</em> of a relation R in X
is the union of the domain of R and the range of R.</p> <p>If R is a relation in X, and if S is defined so that xSy
if xRy and not x=y, then S is the
<a name="strict_relation"></a><em>strict</em> relation
corresponding to R. Conversely, if S is a relation in X, and if R is
defined so that xRy if xSy or x=y,
then R is the <a name="weak_relation"></a><em>weak</em>
relation corresponding to S.</p> <p>A relation R in X is <em>reflexive</em> if xRx for every
element x of X, it is <em>symmetric</em> if xRy implies
that yRx, and it is <em>transitive</em> if
xRy and yRz imply that xRz.</p> </li><li> <p>A <a name="function"></a><em>function</em> F is a relation,
a subset of XY, such that the domain of F is equal
to X and such that for every x in X there is a unique element y in Y
with (x,y) in F. The latter condition can be formulated as
follows: if xFy and xFz, then y=z.
In this module, it is not required that the domain of F is equal to X
for a relation to be considered a function.</p> <p>Instead of writing (x,y)inF or xFy, we
write F(x)=y when F is a function, and say that F maps x
onto y, or that the value of F at x is y.</p> <p>As functions are relations, the definitions of the last item (domain,
range, and so on) apply to functions as well.</p> <p>If the converse of a function F is a function F', then F' is called 
the <a name="inverse"></a><em>inverse</em> of F.</p> <p>The relative product of two functions F1 and F2 is called
the <a name="composite"></a><em>composite</em> of F1 and F2
if the range of F1 is a subset of the domain of F2.</p> </li><li> <p>Sometimes, when the range of a function is more important than the
function itself, the function is called a <em>family</em>.</p> <p>The domain of a family is called the <em>index set</em>, and the
range is called the <em>indexed set</em>.</p> <p>If x is a family from I to X, then x[i] denotes the value of the
function at index i. The notation "a family in X" is used for such a
family.</p> <p>When the indexed set is a set of subsets of a set X, we call x a 
<a name="family"></a><em>family of subsets</em> of X.</p> <p>If x is a family of subsets of X, the union of the range of x is
called the <em>union of the family</em> x.</p> <p>If x is non-empty (the index set is non-empty), the <em>intersection of the family</em> x is the intersection of the range of x.</p> <p>In this module, the only families that are considered are families
of subsets of some set X; in the following, the word "family" is
used for such families of subsets.</p> </li><li> <p>A <a name="partition"></a><em>partition</em> of a set X is a
collection S of non-empty subsets of X whose union is X and whose
elements are pairwise disjoint.</p> <p>A relation in a set is an <em>equivalence relation</em> if it is
reflexive, symmetric, and transitive.</p> <p>If R is an equivalence relation in X, and x is an element of X, the 
<a name="equivalence_class"></a><em>equivalence class</em> of
x with respect to R is the set of all those elements y of X for which
xRy holds. The equivalence classes constitute a
partitioning of X. Conversely, if C is a partition of X, the relation
that holds for any two elements of X if they belong to the same
equivalence class, is an equivalence relation induced by the
partition C.</p> <p>If R is an equivalence relation in X, the
<a name="canonical_map"></a><em>canonical map</em> is the
function that maps every element of X onto its equivalence class.</p> </li><li> <p><a name="binary_relation"></a>Relations as defined above
(as sets of ordered pairs) are from now on referred to as <em>binary relations</em>.</p> <p>We call a set of ordered sets (x[1],...,x[n]) an
<a name="n_ary_relation"></a><em>(n-ary) relation</em>, and
say that the relation is a subset of the
<a name="Cartesian_product_tuple"></a>Cartesian product
X[1]...X[n], where x[i] is
an element of X[i], 1&lt;=i&lt;=n.</p> <p>The <a name="projection"></a><em>projection</em> of an n-ary
relation R onto coordinate i is the set {x[i]:
(x[1],...,x[i],...,x[n]) in R for some
x[j]inX[j], 1&lt;=j&lt;=n and
not i=j}. The projections of a binary relation R onto the
first and second coordinates are the domain and the range of R,
respectively.</p> <p>The relative product of binary relations can be generalized to n-ary
relations as follows. Let TR be an ordered set
(R[1],...,R[n]) of binary relations from X to Y[i]
and S a binary relation from
(Y[1]...Y[n]) to Z. The
<a name="tuple_relative_product"></a><em>relative product</em>
of TR and S is the binary relation T from X to Z defined so that
xTz if and only if there exists an element y[i] in Y[i]
for each 1&lt;=i&lt;=n such that
xR[i]y[i] and
(y[1],...,y[n])Sz. Now let TR be a an
ordered set (R[1],...,R[n]) of binary relations from
X[i] to Y[i] and S a subset of
X[1]...X[n].
The <a name="multiple_relative_product"></a><em>multiple relative product</em> of TR and S is defined to be the set
{z: z= ((x[1],...,x[n]), (y[1],...,y[n]))
for some (x[1],...,x[n])inS and for some
(x[i],y[i]) in R[i], 1&lt;=i&lt;=n}.</p> <p>The <a name="natural_join"></a><em>natural join</em> of an
n-ary relation R and an m-ary relation S on coordinate i and j is
defined to be the set
{z: z= (x[1],...,x[n],
y[1],...,y[j-1],y[j+1],...,y[m])
for some (x[1],...,x[n])inR and for some
(y[1],...,y[m])inS such that
x[i]=y[j]}.</p> </li><li> <p><a name="sets_definition"></a>The sets recognized by this
module are represented by elements of the relation Sets, which is
defined as the smallest set such that:</p> <ul><li> <p>For every atom T, except '_', and for every term X,
(T,X) belongs to Sets (<em>atomic sets</em>).</p> </li><li> <p>(['_'],[]) belongs to Sets (the <em>untyped empty set</em>).</p> </li><li> <p>For every tuple T= {T[1],...,T[n]} and
for every tuple X= {X[1],...,X[n]}, if
(T[i],X[i]) belongs to Sets for every
1&lt;=i&lt;=n, then (T,X) belongs
to Sets (<em>ordered sets</em>).</p> </li><li> <p>For every term T, if X is the empty list or a non-empty
sorted list [X[1],...,X[n]] without duplicates
such that (T,X[i]) belongs to Sets for every
1&lt;=i&lt;=n, then ([T],X)
belongs to Sets (<em>typed unordered sets</em>).</p> </li></ul> <p>An <a name="external_set"></a><em>external set</em> is an
element of the range of Sets.</p> <p>A <a name="type"></a><em>type</em> is an element of the
domain of Sets.</p> <p>If S is an element (T,X) of Sets, then T is a
<a name="valid_type"></a><em>valid type</em> of X, T is the
type of S, and X is the external set of S.
<a href="#from_term/2">from_term/2</a> creates a
set from a type and an Erlang term turned into an external set.</p> <p>The sets represented by Sets are the elements of the range of
function Set from Sets to Erlang terms and sets of Erlang terms:</p> <ul><li>Set(T,Term)= Term, where T is an atom</li><li>Set({T[1],...,T[n]},{X[1],..., X[n]})= (Set(T[1],X[1]),..., Set(T[n],X[n]))</li><li>Set([T],[X[1],...,X[n]])= {Set(T,X[1]),...,Set(T,X[n])}</li><li>Set([T],[])= {}</li></ul> <p>When there is no risk of confusion, elements of Sets are identified
with the sets they represent. For example, if U is the result of
calling <a href="#union/2">union/2</a> with S1
and S2 as arguments, then U is said to be the union of S1 and S2.
A more precise formulation is that Set(U) is the union of Set(S1)
and Set(S2).</p> </li></ul>The types are used to implement the various conditions that
sets must fulfill. As an example, consider the relative
product of two sets R and S, and recall that the relative
product of R and S is defined if R is a binary relation to Y and
S is a binary relation from Y. The function that implements the
relative product, <a href="#relative_product/2">relative_product/2</a>, checks
that the arguments represent binary relations by matching [{A,B}]
against the type of the first argument (Arg1 say), and [{C,D}]
against the type of the second argument (Arg2 say). The fact
that [{A,B}] matches the type of Arg1 is to be interpreted as
Arg1 representing a binary relation from X to Y, where X is
defined as all sets Set(x) for some element x in Sets the type
of which is A, and similarly for Y. In the same way Arg2 is
interpreted as representing a binary relation from W to Z.
Finally it is checked that B matches C, which is sufficient to
ensure that W is equal to Y. The untyped empty set is handled
separately: its type, ['_'], matches the type of any unordered
set.A few functions of this module
(<a href="#drestriction/3">drestriction/3</a>,
<a href="#family_projection/2">family_projection/2</a>,
<a href="#partition/2">partition/2</a>,
<a href="#partition_family/2">partition_family/2</a>,
<a href="#projection/2">projection/2</a>,
<a href="#restriction/3">restriction/3</a>,
<a href="#substitution/2">substitution/2</a>)
accept an Erlang
function as a means to modify each element of a given unordered
set. <a name="set_fun"></a>Such a function, called
SetFun in the following, can be specified as a functional object (fun),
a tuple <strong>{external,Fun}</strong>, or an integer:<ul><li> <p>If SetFun is specified as a fun, the fun is applied to each element
of the given set and the return value is assumed to be a set.</p> </li><li> <p>If SetFun is specified as a tuple <strong>{external, Fun}</strong>, Fun is
applied to the external set of each element of the given set and the
return value is assumed to be an external set. Selecting the
elements of an unordered set as external sets and assembling a
new unordered set from a list of external sets is in the present
implementation more efficient than modifying each element as a
set. However, this optimization can only be used when the
elements of the unordered set are atomic or ordered sets. It
must also be the case that the type of the elements matches some
clause of Fun (the type of the created set is the result of
applying Fun to the type of the given set), and that Fun does
nothing but selecting, duplicating, or rearranging parts of the
elements.</p> </li><li> <p>Specifying a SetFun as an integer I is equivalent to
specifying <strong>{external, fun(X)-&gt; element(I,X)end}</strong>, but is to be preferred, as it
makes it possible to handle this case even more efficiently.</p> </li></ul>Examples of SetFuns:<pre>
fun sofs:union/1
fun(S) -&gt; sofs:partition(1, S) end
{external, fun(A) -&gt; A end}
{external, fun({A,_,C}) -&gt; {C,A} end}
{external, fun({_,{_,C}}) -&gt; C end}
{external, fun({_,{_,{_,E}=C}}) -&gt; {E,{E,C}} end}
2</pre>The order in which a SetFun is applied to the elements of an
unordered set is not specified, and can change in future
versions of this module.The execution time of the functions of this module is dominated
by the time it takes to sort lists. When no sorting is needed,
the execution time is in the worst case proportional to the sum
of the sizes of the input arguments and the returned value. A
few functions execute in constant time:
<a href="#from_external/2">from_external/2</a>,
<a href="#is_empty_set/1">is_empty_set/1</a>,
<a href="#is_set/1">is_set/1</a>,
<a href="#is_sofs_set/1">is_sofs_set/1</a>,
<a href="#to_external/1">to_external/1</a>
<a href="#type/1">type/1</a>.The functions of this module exit the process with a
<strong>badarg</strong>, <strong>bad_function</strong>, or <strong>type_mismatch</strong>
message when given badly formed arguments or sets the types of
which are not compatible.When comparing external sets, operator <strong>==/2</strong> is used.</p><h2>Data Types</h2><span class="name">anyset</span><p>Any kind of set (also included are the atomic sets).</p><span class="name">binary_relation</span><p>A <a href="#binary_relation">binary relation</a>.</p><span class="name">external_set</span><p>An <a href="#external_set">external set</a>.</p><span class="name">family</span><p>A <a href="#family">family</a> (of subsets).</p><span class="name">a_function</span><p>A <a href="#function">function</a>.</p><span class="name">ordset</span><p>An <a href="#sets_definition">ordered set</a>.</p><span class="name">relation</span><p>An <a href="#n_ary_relation">n-ary relation</a>.
</p><span class="name">a_set</span><p>An <a href="#sets_definition">unordered set</a>.</p><span class="name">set_of_sets</span><p>An <a href="#sets_definition">unordered set</a> of unordered sets.</p><span class="name">set_fun</span><p>A <a href="#set_fun">SetFun</a>.</p><span class="name">spec_fun</span><span class="name">type</span><p>A <a href="#type">type</a>.</p><span class="name">tuple_of(T)</span><p>A tuple where the elements are of type <strong>T</strong>.</p><h2>Functions</h2><h3>a_function/1</h3><h3>a_function/2</h3><p>Create a function.</p><p>Creates a <a href="#function">function</a>.
<strong>a_function(F,T)</strong> is equivalent to
<strong>from_term(F,T)</strong> if the result is a function. If
no <a href="#type">type</a> is explicitly
specified, <strong>[{atom,atom}]</strong> is used as the
function type.</p><h3>canonical_relation/1</h3><p>Return the canonical map.</p><p>Returns the binary relation containing the elements
(E,Set) such that Set belongs to <strong><span class="anno">SetOfSets</span></strong>
and E belongs to Set. If <strong>SetOfSets</strong> is
a <a href="#partition">partition</a> of a set X and
R is the equivalence relation in X induced by <strong>SetOfSets</strong>,
then the returned relation is
the <a href="#canonical_map">canonical map</a> from
X onto the equivalence classes with respect to R.</p><pre>
1&gt; <span class="input">Ss = sofs:from_term([[a,b],[b,c]]),</span>
<span class="input">CR = sofs:canonical_relation(Ss),</span>
<span class="input">sofs:to_external(CR).</span>
[{a,[a,b]},{b,[a,b]},{b,[b,c]},{c,[b,c]}]</pre><h3>composite/2</h3><p>Return the composite of two functions.</p><p>Returns the <a href="#composite">composite</a> of 
the functions <strong><span class="anno">Function1</span></strong> and
<strong><span class="anno">Function2</span></strong>.</p><pre>
1&gt; <span class="input">F1 = sofs:a_function([{a,1},{b,2},{c,2}]),</span>
<span class="input">F2 = sofs:a_function([{1,x},{2,y},{3,z}]),</span>
<span class="input">F = sofs:composite(F1, F2),</span>
<span class="input">sofs:to_external(F).</span>
[{a,x},{b,y},{c,y}]</pre><h3>constant_function/2</h3><p>Create the function that maps each element of a set onto another set.</p><p>Creates the <a href="#function">function</a>
that maps each element of set <strong>Set</strong> onto <strong>AnySet</strong>.</p><pre>
1&gt; <span class="input">S = sofs:set([a,b]),</span>
<span class="input">E = sofs:from_term(1),</span>
<span class="input">R = sofs:constant_function(S, E),</span>
<span class="input">sofs:to_external(R).</span>
[{a,1},{b,1}]</pre><h3>converse/1</h3><p>Return the converse of a binary relation.</p><p>Returns the <a href="#converse">converse</a>
of the binary relation <strong><span class="anno">BinRel1</span></strong>.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{1,a},{2,b},{3,a}]),</span>
<span class="input">R2 = sofs:converse(R1),</span>
<span class="input">sofs:to_external(R2).</span>
[{a,1},{a,3},{b,2}]</pre><h3>difference/2</h3><p>Return the difference of two sets.</p><p>Returns the <a href="#difference">difference</a> of
the sets <strong><span class="anno">Set1</span></strong> and <strong><span class="anno">Set2</span></strong>.</p><h3>digraph_to_family/1</h3><h3>digraph_to_family/2</h3><p>Create a family from a directed graph.</p><p>Creates a <a href="#family">family</a> from
the directed graph <strong><span class="anno">Graph</span></strong>. Each vertex a of
<strong><span class="anno">Graph</span></strong> is
represented by a pair (a,{b[1],...,b[n]}),
where the b[i]:s are the out-neighbors of a. If no type is
explicitly specified, [{atom,[atom]}] is used as type of
the family. It is assumed that <strong><span class="anno">Type</span></strong> is
a <a href="#valid_type">valid type</a> of the 
external set of the family.</p><p>If G is a directed graph, it holds that the vertices and
edges of G are the same as the vertices and edges of
<strong>family_to_digraph(digraph_to_family(G))</strong>.</p><h3>domain/1</h3><p>Return the domain of a binary relation.</p><p>Returns the <a href="#domain">domain</a> of
the binary relation <strong><span class="anno">BinRel</span></strong>.</p><pre>
1&gt; <span class="input">R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]),</span>
<span class="input">S = sofs:domain(R),</span>
<span class="input">sofs:to_external(S).</span>
[1,2]</pre><h3>drestriction/2</h3><p>Return a restriction of a binary relation.</p><p>Returns the difference between the binary relation
<strong><span class="anno">BinRel1</span></strong>
and the <a href="#restriction">restriction</a>
of <strong><span class="anno">BinRel1</span></strong> to <strong><span class="anno">Set</span></strong>.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{1,a},{2,b},{3,c}]),</span>
<span class="input">S = sofs:set([2,4,6]),</span>
<span class="input">R2 = sofs:drestriction(R1, S),</span>
<span class="input">sofs:to_external(R2).</span>
[{1,a},{3,c}]</pre><p><strong>drestriction(R,S)</strong> is equivalent to
<strong>difference(R,restriction(R,S))</strong>.</p><h3>drestriction/3</h3><p>Return a restriction of a relation.</p><p>Returns a subset of <strong><span class="anno">Set1</span></strong> containing those
elements that do not give
an element in <strong><span class="anno">Set2</span></strong> as the result of applying
<strong><span class="anno">SetFun</span></strong>.</p><pre>
1&gt; <span class="input">SetFun = {external, fun({_A,B,C}) -&gt; {B,C} end},</span>
<span class="input">R1 = sofs:relation([{a,aa,1},{b,bb,2},{c,cc,3}]),</span>
<span class="input">R2 = sofs:relation([{bb,2},{cc,3},{dd,4}]),</span>
<span class="input">R3 = sofs:drestriction(SetFun, R1, R2),</span>
<span class="input">sofs:to_external(R3).</span>
[{a,aa,1}]</pre><p><strong>drestriction(F,S1,S2)</strong> is equivalent to
<strong>difference(S1,restriction(F,S1,S2))</strong>.</p><h3>empty_set/0</h3><p>Return the untyped empty set.</p><p>Returns the <a href="#sets_definition">untyped empty set</a>. <strong>empty_set()</strong> is equivalent to
<strong>from_term([],['_'])</strong>.</p><h3>extension/3</h3><p>Extend the domain of a binary relation.</p><p>Returns the <a href="#extension">extension</a> of
<strong><span class="anno">BinRel1</span></strong> such that for
each element E in <strong><span class="anno">Set</span></strong> that does not belong to the
<a href="#domain">domain</a> of
<strong><span class="anno">BinRel1</span></strong>, <strong><span class="anno">BinRel2</span></strong> contains the
pair (E,<strong>AnySet</strong>).</p><pre>
1&gt; <span class="input">S = sofs:set([b,c]),</span>
<span class="input">A = sofs:empty_set(),</span>
<span class="input">R = sofs:family([{a,[1,2]},{b,[3]}]),</span>
<span class="input">X = sofs:extension(R, S, A),</span>
<span class="input">sofs:to_external(X).</span>
[{a,[1,2]},{b,[3]},{c,[]}]</pre><h3>family/1</h3><h3>family/2</h3><p>Create a family of subsets.</p><p>Creates a <a href="#family">family of subsets</a>.
<strong>family(F,T)</strong> is equivalent to
<strong>from_term(F,T)</strong> if the result is a family. If
no <a href="#type">type</a> is explicitly
specified, <strong>[{atom,[atom]}]</strong> is used as the
family type.</p><h3>family_difference/2</h3><p>Return the difference of two families.</p><p>If <strong><span class="anno">Family1</span></strong> and <strong><span class="anno">Family2</span></strong>
are <a href="#family">families</a>, then
<strong><span class="anno">Family3</span></strong> is the family
such that the index set is equal to the index set of
<strong><span class="anno">Family1</span></strong>, and <strong><span class="anno">Family3</span></strong>[i] is
the difference between <strong><span class="anno">Family1</span></strong>[i]
and <strong><span class="anno">Family2</span></strong>[i] if <strong><span class="anno">Family2</span></strong>
maps i, otherwise <strong><span class="anno">Family1</span>[i]</strong>.</p><pre>
1&gt; <span class="input">F1 = sofs:family([{a,[1,2]},{b,[3,4]}]),</span>
<span class="input">F2 = sofs:family([{b,[4,5]},{c,[6,7]}]),</span>
<span class="input">F3 = sofs:family_difference(F1, F2),</span>
<span class="input">sofs:to_external(F3).</span>
[{a,[1,2]},{b,[3]}]</pre><h3>family_domain/1</h3><p>Return a family of domains.</p><p>If <strong><span class="anno">Family1</span></strong> is
a <a href="#family">family</a>
and <strong><span class="anno">Family1</span></strong>[i] is a binary relation for every i
in the index set of <strong><span class="anno">Family1</span></strong>,
then <strong><span class="anno">Family2</span></strong> is the family with the same index
set as <strong><span class="anno">Family1</span></strong> such
that <strong><span class="anno">Family2</span></strong>[i] is
the <a href="#domain">domain</a> of
<strong><span class="anno">Family1</span>[i]</strong>.</p><pre>
1&gt; <span class="input">FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]),</span>
<span class="input">F = sofs:family_domain(FR),</span>
<span class="input">sofs:to_external(F).</span>
[{a,[1,2,3]},{b,[]},{c,[4,5]}]</pre><h3>family_field/1</h3><p>Return a family of fields.</p><p>If <strong><span class="anno">Family1</span></strong> is
a <a href="#family">family</a>
and <strong><span class="anno">Family1</span></strong>[i] is a binary relation for every i
in the index set of <strong><span class="anno">Family1</span></strong>,
then <strong><span class="anno">Family2</span></strong> is the family with the same index
set as <strong><span class="anno">Family1</span></strong> such
that <strong><span class="anno">Family2</span></strong>[i] is
the <a href="#field">field</a> of
<strong><span class="anno">Family1</span></strong>[i].</p><pre>
1&gt; <span class="input">FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]),</span>
<span class="input">F = sofs:family_field(FR),</span>
<span class="input">sofs:to_external(F).</span>
[{a,[1,2,3,a,b,c]},{b,[]},{c,[4,5,d,e]}]</pre><p><strong>family_field(Family1)</strong> is equivalent to
<strong>family_union(family_domain(Family1), family_range(Family1))</strong>.</p><h3>family_intersection/1</h3><p>Return the intersection of a family of sets of sets.</p><p>If <strong><span class="anno">Family1</span></strong> is
a <a href="#family">family</a>
and <strong><span class="anno">Family1</span></strong>[i] is a set of sets for every i in
the index set of <strong><span class="anno">Family1</span></strong>,
then <strong><span class="anno">Family2</span></strong> is the family with the same index
set as <strong><span class="anno">Family1</span></strong> such
that <strong><span class="anno">Family2</span></strong>[i] is
the <a href="#intersection_n">intersection</a>
of <strong><span class="anno">Family1</span></strong>[i].</p><p>If <strong><span class="anno">Family1</span></strong>[i] is an empty set for some i,
the process exits with a <strong>badarg</strong> message.</p><pre>
1&gt; <span class="input">F1 = sofs:from_term([{a,[[1,2,3],[2,3,4]]},{b,[[x,y,z],[x,y]]}]),</span>
<span class="input">F2 = sofs:family_intersection(F1),</span>
<span class="input">sofs:to_external(F2).</span>
[{a,[2,3]},{b,[x,y]}]</pre><h3>family_intersection/2</h3><p>Return the intersection of two families.</p><p>If <strong><span class="anno">Family1</span></strong> and <strong><span class="anno">Family2</span></strong>
are <a href="#family">families</a>,
then <strong><span class="anno">Family3</span></strong> is the family such that the index
set is the intersection of <strong><span class="anno">Family1</span></strong>:s and
<strong><span class="anno">Family2</span></strong>:s index sets,
and <strong><span class="anno">Family3</span></strong>[i] is the intersection of
<strong><span class="anno">Family1</span></strong>[i] and <strong><span class="anno">Family2</span></strong>[i].</p><pre>
1&gt; <span class="input">F1 = sofs:family([{a,[1,2]},{b,[3,4]},{c,[5,6]}]),</span>
<span class="input">F2 = sofs:family([{b,[4,5]},{c,[7,8]},{d,[9,10]}]),</span>
<span class="input">F3 = sofs:family_intersection(F1, F2),</span>
<span class="input">sofs:to_external(F3).</span>
[{b,[4]},{c,[]}]</pre><h3>family_projection/2</h3><p>Return a family of modified subsets.</p><p>If <strong><span class="anno">Family1</span></strong> is
a <a href="#family">family</a>,
then <strong><span class="anno">Family2</span></strong> is the family with the same index
set as <strong><span class="anno">Family1</span></strong> such
that <strong><span class="anno">Family2</span></strong>[i] is the result of
calling <strong><span class="anno">SetFun</span></strong> with <strong><span class="anno">Family1</span></strong>[i]
as argument.</p><pre>
1&gt; <span class="input">F1 = sofs:from_term([{a,[[1,2],[2,3]]},{b,[[]]}]),</span>
<span class="input">F2 = sofs:family_projection(fun sofs:union/1, F1),</span>
<span class="input">sofs:to_external(F2).</span>
[{a,[1,2,3]},{b,[]}]</pre><h3>family_range/1</h3><p>Return a family of ranges.</p><p>If <strong><span class="anno">Family1</span></strong> is
a <a href="#family">family</a>
and <strong><span class="anno">Family1</span></strong>[i] is a binary relation for every i
in the index set of <strong><span class="anno">Family1</span></strong>,
then <strong><span class="anno">Family2</span></strong> is the family with the same index
set as <strong><span class="anno">Family1</span></strong> such
that <strong><span class="anno">Family2</span></strong>[i] is
the <a href="#range">range</a> of
<strong><span class="anno">Family1</span></strong>[i].</p><pre>
1&gt; <span class="input">FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]),</span>
<span class="input">F = sofs:family_range(FR),</span>
<span class="input">sofs:to_external(F).</span>
[{a,[a,b,c]},{b,[]},{c,[d,e]}]</pre><h3>family_specification/2</h3><p>Select a subset of a family using a predicate.</p><p>If <strong><span class="anno">Family1</span></strong> is
a <a href="#family">family</a>,
then <strong><span class="anno">Family2</span></strong> is
the <a href="#restriction">restriction</a> of
<strong><span class="anno">Family1</span></strong> to those elements i of the index set
for which <strong><span class="anno">Fun</span></strong> applied
to <strong><span class="anno">Family1</span></strong>[i] returns
<strong>true</strong>. If <strong><span class="anno">Fun</span></strong> is a
tuple <strong>{external,Fun2}</strong>, then <strong>Fun2</strong> is applied to
the <a href="#external_set">external set</a>
of <strong><span class="anno">Family1</span></strong>[i], otherwise <strong><span class="anno">Fun</span></strong>
is applied to <strong><span class="anno">Family1</span></strong>[i].</p><pre>
1&gt; <span class="input">F1 = sofs:family([{a,[1,2,3]},{b,[1,2]},{c,[1]}]),</span>
<span class="input">SpecFun = fun(S) -&gt; sofs:no_elements(S) =:= 2 end,</span>
<span class="input">F2 = sofs:family_specification(SpecFun, F1),</span>
<span class="input">sofs:to_external(F2).</span>
[{b,[1,2]}]</pre><h3>family_to_digraph/1</h3><h3>family_to_digraph/2</h3><p>Create a directed graph from a family.</p><p>Creates a directed graph from
<a href="#family">family</a> <strong><span class="anno">Family</span></strong>.
For each pair (a,{b[1],...,b[n]})
of <strong><span class="anno">Family</span></strong>, vertex
a and the edges (a,b[i]) for
1&lt;=i&lt;=n are added to a newly
created directed graph.</p><p>If no graph type is specified, <a href="./digraph#new/0">digraph#new/0</a> is used for
creating the directed graph, otherwise argument
<strong><span class="anno">GraphType</span></strong> is passed on as second argument to
<a href="./digraph#new/1">digraph#new/1</a>.</p><p>It F is a family, it holds that F is a subset of
<strong>digraph_to_family(family_to_digraph(F),type(F))</strong>.
Equality holds if <strong>union_of_family(F)</strong> is a subset of
<strong>domain(F)</strong>.</p><p>Creating a cycle in an acyclic graph exits the process with
a <strong>cyclic</strong> message.</p><h3>family_to_relation/1</h3><p>Create a binary relation from a family.</p><p>If <strong><span class="anno">Family</span></strong> is
a <a href="#family">family</a>,
then <strong><span class="anno">BinRel</span></strong> is the binary relation containing
all pairs (i,x) such that i belongs to the index set
of <strong><span class="anno">Family</span></strong> and x belongs
to <strong><span class="anno">Family</span></strong>[i].</p><pre>
1&gt; <span class="input">F = sofs:family([{a,[]}, {b,[1]}, {c,[2,3]}]),</span>
<span class="input">R = sofs:family_to_relation(F),</span>
<span class="input">sofs:to_external(R).</span>
[{b,1},{c,2},{c,3}]</pre><h3>family_union/1</h3><p>Return the union of a family of sets of sets.</p><p>If <strong><span class="anno">Family1</span></strong> is
a <a href="#family">family</a>
and <strong><span class="anno">Family1</span></strong>[i] is a set of sets for each i in
the index set of <strong><span class="anno">Family1</span></strong>,
then <strong><span class="anno">Family2</span></strong> is the family with the same index
set as <strong><span class="anno">Family1</span></strong> such
that <strong><span class="anno">Family2</span></strong>[i] is
the <a href="#union_n">union</a> of
<strong><span class="anno">Family1</span></strong>[i].</p><pre>
1&gt; <span class="input">F1 = sofs:from_term([{a,[[1,2],[2,3]]},{b,[[]]}]),</span>
<span class="input">F2 = sofs:family_union(F1),</span>
<span class="input">sofs:to_external(F2).</span>
[{a,[1,2,3]},{b,[]}]</pre><p><strong>family_union(F)</strong> is equivalent to
<strong>family_projection(fun sofs:union/1,F)</strong>.</p><h3>family_union/2</h3><p>Return the union of two families.</p><p>If <strong><span class="anno">Family1</span></strong> and <strong><span class="anno">Family2</span></strong>
are <a href="#family">families</a>,
then <strong><span class="anno">Family3</span></strong> is the family such that the index
set is the union of <strong><span class="anno">Family1</span></strong>:s
and <strong><span class="anno">Family2</span></strong>:s index sets,
and <strong><span class="anno">Family3</span></strong>[i] is the union
of <strong><span class="anno">Family1</span></strong>[i] and <strong><span class="anno">Family2</span></strong>[i]
if both map i, otherwise <strong><span class="anno">Family1</span></strong>[i]
or <strong><span class="anno">Family2</span></strong>[i].</p><pre>
1&gt; <span class="input">F1 = sofs:family([{a,[1,2]},{b,[3,4]},{c,[5,6]}]),</span>
<span class="input">F2 = sofs:family([{b,[4,5]},{c,[7,8]},{d,[9,10]}]),</span>
<span class="input">F3 = sofs:family_union(F1, F2),</span>
<span class="input">sofs:to_external(F3).</span>
[{a,[1,2]},{b,[3,4,5]},{c,[5,6,7,8]},{d,[9,10]}]</pre><h3>field/1</h3><p>Return the field of a binary relation.</p><p>Returns the <a href="#field">field</a> of the
binary relation <strong><span class="anno">BinRel</span></strong>.</p><pre>
1&gt; <span class="input">R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]),</span>
<span class="input">S = sofs:field(R),</span>
<span class="input">sofs:to_external(S).</span>
[1,2,a,b,c]</pre><p><strong>field(R)</strong> is equivalent
to <strong>union(domain(R), range(R))</strong>.</p><h3>from_external/2</h3><p>Create a set.</p><p>Creates a set from the <a href="#external_set">external  set</a> <strong><span class="anno">ExternalSet</span></strong> and
the <a href="#type">type</a> <strong><span class="anno">Type</span></strong>.
It is assumed that <strong><span class="anno">Type</span></strong> is
a <a href="#valid_type">valid type</a> of <strong><span class="anno">ExternalSet</span></strong>.</p><h3>from_sets/1</h3><p>Create a set out of a list of sets.</p><p>Returns the <a href="#sets_definition">unordered set</a> containing the sets of list
<strong><span class="anno">ListOfSets</span></strong>.</p><pre>
1&gt; <span class="input">S1 = sofs:relation([{a,1},{b,2}]),</span>
<span class="input">S2 = sofs:relation([{x,3},{y,4}]),</span>
<span class="input">S = sofs:from_sets([S1,S2]),</span>
<span class="input">sofs:to_external(S).</span>
[[{a,1},{b,2}],[{x,3},{y,4}]]</pre><h3>from_sets/1</h3><p>Create an ordered set out of a tuple of sets.</p><p>Returns the <a href="#sets_definition">ordered set</a> containing the sets of the non-empty tuple
<strong><span class="anno">TupleOfSets</span></strong>.</p><h3>from_term/1</h3><h3>from_term/2</h3><p>Create a set.</p><p><a name="from_term"></a>Creates an element
of <a href="#sets_definition">Sets</a> by
traversing term <strong><span class="anno">Term</span></strong>, sorting lists,
removing duplicates, and
deriving or verifying a <a href="#valid_type">valid type</a> for the so obtained external set. An
explicitly specified <a href="#type">type</a>
<strong><span class="anno">Type</span></strong>
can be used to limit the depth of the traversal; an atomic
type stops the traversal, as shown by the following example
where <strong>"foo"</strong> and <strong>{"foo"}</strong> are left unmodified:</p><pre>
1&gt; <span class="input">S = sofs:from_term([{{"foo"},[1,1]},{"foo",[2,2]}], [{atom,[atom]}]),</span>
<span class="input">sofs:to_external(S).</span>
[{{"foo"},[1]},{"foo",[2]}]</pre><p><strong>from_term</strong> can be used for creating atomic or ordered
sets. The only purpose of such a set is that of later
building unordered sets, as all functions in this module
that <em>do</em> anything operate on unordered sets.
Creating unordered sets from a collection of ordered sets
can be the way to go if the ordered sets are big and one
does not want to waste heap by rebuilding the elements of
the unordered set. The following example shows that a set can be
built "layer by layer":</p><pre>
1&gt; <span class="input">A = sofs:from_term(a),</span>
<span class="input">S = sofs:set([1,2,3]),</span>
<span class="input">P1 = sofs:from_sets({A,S}),</span>
<span class="input">P2 = sofs:from_term({b,[6,5,4]}),</span>
<span class="input">Ss = sofs:from_sets([P1,P2]),</span>
<span class="input">sofs:to_external(Ss).</span>
[{a,[1,2,3]},{b,[4,5,6]}]</pre><p>Other functions that create sets are
<a href="#from_external/2">from_external/2</a>
and <a href="#from_sets/1">from_sets/1</a>.
Special cases of <strong>from_term/2</strong> are
<a href="#a_function/1">a_function/1</a>,
<a href="#empty_set/0">empty_set/0</a>,
<a href="#family/1">family/1</a>,
<a href="#relation/1">relation/1</a>, and
<a href="#set/1">set/1</a>.</p><h3>image/2</h3><p>Return the image of a set under a binary relation.</p><p>Returns the <a href="#image">image</a> of
set <strong><span class="anno">Set1</span></strong> under the binary
relation <strong><span class="anno">BinRel</span></strong>.</p><pre>
1&gt; <span class="input">R = sofs:relation([{1,a},{2,b},{2,c},{3,d}]),</span>
<span class="input">S1 = sofs:set([1,2]),</span>
<span class="input">S2 = sofs:image(R, S1),</span>
<span class="input">sofs:to_external(S2).</span>
[a,b,c]</pre><h3>intersection/1</h3><p>Return the intersection of a set of sets.</p><p>Returns
the <a href="#intersection_n">intersection</a> of
the set of sets <strong><span class="anno">SetOfSets</span></strong>.</p><p>Intersecting an empty set of sets exits the process with a
<strong>badarg</strong> message.</p><h3>intersection/2</h3><p>Return the intersection of two sets.</p><p>Returns
the <a href="#intersection">intersection</a> of
<strong><span class="anno">Set1</span></strong> and <strong><span class="anno">Set2</span></strong>.</p><h3>intersection_of_family/1</h3><p>Return the intersection of a family.</p><p>Returns the intersection of
<a href="#family">family</a> <strong><span class="anno">Family</span></strong>.
</p><p>Intersecting an empty family exits the process with a
<strong>badarg</strong> message.</p><pre>
1&gt; <span class="input">F = sofs:family([{a,[0,2,4]},{b,[0,1,2]},{c,[2,3]}]),</span>
<span class="input">S = sofs:intersection_of_family(F),</span>
<span class="input">sofs:to_external(S).</span>
[2]</pre><h3>inverse/1</h3><p>Return the inverse of a function.</p><p>Returns the <a href="#inverse">inverse</a>
of function <strong><span class="anno">Function1</span></strong>.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{1,a},{2,b},{3,c}]),</span>
<span class="input">R2 = sofs:inverse(R1),</span>
<span class="input">sofs:to_external(R2).</span>
[{a,1},{b,2},{c,3}]</pre><h3>inverse_image/2</h3><p>Return the inverse image of a set under a binary relation.</p><p>Returns the <a href="#inverse_image">inverse image</a> of <strong><span class="anno">Set1</span></strong> under the binary
relation <strong><span class="anno">BinRel</span></strong>.</p><pre>
1&gt; <span class="input">R = sofs:relation([{1,a},{2,b},{2,c},{3,d}]),</span>
<span class="input">S1 = sofs:set([c,d,e]),</span>
<span class="input">S2 = sofs:inverse_image(R, S1),</span>
<span class="input">sofs:to_external(S2).</span>
[2,3]</pre><h3>is_a_function/1</h3><p>Test for a function.</p><p>Returns <strong>true</strong> if the binary relation <strong><span class="anno">BinRel</span></strong>
is a <a href="#function">function</a> or the
untyped empty set, otherwise <strong>false</strong>.</p><h3>is_disjoint/2</h3><p>Test for disjoint sets.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Set1</span></strong>
and <strong><span class="anno">Set2</span></strong>
are <a href="#disjoint">disjoint</a>, otherwise
<strong>false</strong>.</p><h3>is_empty_set/1</h3><p>Test for an empty set.</p><p>Returns <strong>true</strong> if <strong><span class="anno">AnySet</span></strong> is an empty
unordered set, otherwise <strong>false</strong>.</p><h3>is_equal/2</h3><p>Test two sets for equality.</p><p>Returns <strong>true</strong> if <strong><span class="anno">AnySet1</span></strong>
and <strong><span class="anno">AnySet2</span></strong>
are <a href="#equal">equal</a>, otherwise
<strong>false</strong>. The following  example shows that <strong>==/2</strong> is
used when comparing sets for equality:</p><pre>
1&gt; <span class="input">S1 = sofs:set([1.0]),</span>
<span class="input">S2 = sofs:set([1]),</span>
<span class="input">sofs:is_equal(S1, S2).</span>
true</pre><h3>is_set/1</h3><p>Test for an unordered set.</p><p>Returns <strong>true</strong> if <strong><span class="anno">AnySet</span></strong> is
an <a href="#sets_definition">unordered set</a>, and
<strong>false</strong> if <strong><span class="anno">AnySet</span></strong> is an ordered set or an
atomic set.</p><h3>is_sofs_set/1</h3><p>Test for an unordered set.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is
an <a href="#sets_definition">unordered set</a>, an
ordered set, or an atomic set, otherwise <strong>false</strong>.</p><h3>is_subset/2</h3><p>Test two sets for subset.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Set1</span></strong> is
a <a href="#subset">subset</a>
of <strong><span class="anno">Set2</span></strong>, otherwise <strong>false</strong>.</p><h3>is_type/1</h3><p>Test for a type.</p><p>Returns <strong>true</strong> if term <strong><span class="anno">Term</span></strong> is
a <a href="#type">type</a>.</p><h3>join/4</h3><p>Return the join of two relations.</p><p>Returns the <a href="#natural_join">natural join</a> of the relations <strong><span class="anno">Relation1</span></strong>
and <strong><span class="anno">Relation2</span></strong> on coordinates <strong><span class="anno">I</span></strong>
and <strong><span class="anno">J</span></strong>.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{a,x,1},{b,y,2}]),</span>
<span class="input">R2 = sofs:relation([{1,f,g},{1,h,i},{2,3,4}]),</span>
<span class="input">J = sofs:join(R1, 3, R2, 1),</span>
<span class="input">sofs:to_external(J).</span>
[{a,x,1,f,g},{a,x,1,h,i},{b,y,2,3,4}]</pre><h3>multiple_relative_product/2</h3><p>Return the multiple relative product of a tuple of binary relations and a relation.</p><p>If <strong><span class="anno">TupleOfBinRels</span></strong> is a non-empty tuple
{R[1],...,R[n]} of binary relations
and <strong><span class="anno">BinRel1</span></strong> is a binary relation,
then <strong><span class="anno">BinRel2</span></strong> is
the <a href="#multiple_relative_product">multiple relative product</a> of the ordered set
(R[i],...,R[n]) and <strong><span class="anno">BinRel1</span></strong>.</p><pre>
1&gt; <span class="input">Ri = sofs:relation([{a,1},{b,2},{c,3}]),</span>
<span class="input">R = sofs:relation([{a,b},{b,c},{c,a}]),</span>
<span class="input">MP = sofs:multiple_relative_product({Ri, Ri}, R),</span>
<span class="input">sofs:to_external(sofs:range(MP)).</span>
[{1,2},{2,3},{3,1}]</pre><h3>no_elements/1</h3><p>Return the number of elements of a set.</p><p>Returns the number of elements of the ordered or unordered
set <strong><span class="anno">ASet</span></strong>.</p><h3>partition/1</h3><p>Return the coarsest partition given a set of sets.</p><p>Returns the <a href="#partition">partition</a> of
the union of the set of sets <strong><span class="anno">SetOfSets</span></strong> such that
two elements are considered equal if they belong to the same
elements of <strong><span class="anno">SetOfSets</span></strong>.</p><pre>
1&gt; <span class="input">Sets1 = sofs:from_term([[a,b,c],[d,e,f],[g,h,i]]),</span>
<span class="input">Sets2 = sofs:from_term([[b,c,d],[e,f,g],[h,i,j]]),</span>
<span class="input">P = sofs:partition(sofs:union(Sets1, Sets2)),</span>
<span class="input">sofs:to_external(P).</span>
[[a],[b,c],[d],[e,f],[g],[h,i],[j]]</pre><h3>partition/2</h3><p>Return a partition of a set.</p><p>Returns the <a href="#partition">partition</a> of
<strong><span class="anno">Set</span></strong> such that two elements are considered equal
if the results of applying <strong><span class="anno">SetFun</span></strong> are equal.</p><pre>
1&gt; <span class="input">Ss = sofs:from_term([[a],[b],[c,d],[e,f]]),</span>
<span class="input">SetFun = fun(S) -&gt; sofs:from_term(sofs:no_elements(S)) end,</span>
<span class="input">P = sofs:partition(SetFun, Ss),</span>
<span class="input">sofs:to_external(P).</span>
[[[a],[b]],[[c,d],[e,f]]]</pre><h3>partition/3</h3><p>Return a partition of a set.</p><p>Returns a pair of sets that, regarded as constituting a
set, forms a <a href="#partition">partition</a> of
<strong><span class="anno">Set1</span></strong>. If the
result of applying <strong><span class="anno">SetFun</span></strong> to an element of
<strong><span class="anno">Set1</span></strong> gives an element in <strong><span class="anno">Set2</span></strong>,
the element belongs to <strong><span class="anno">Set3</span></strong>, otherwise the
element belongs to <strong><span class="anno">Set4</span></strong>.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{1,a},{2,b},{3,c}]),</span>
<span class="input">S = sofs:set([2,4,6]),</span>
<span class="input">{R2,R3} = sofs:partition(1, R1, S),</span>
<span class="input">{sofs:to_external(R2),sofs:to_external(R3)}.</span>
{[{2,b}],[{1,a},{3,c}]}</pre><p><strong>partition(F,S1,S2)</strong> is equivalent to
<strong>{restriction(F,S1,S2), drestriction(F,S1,S2)}</strong>.</p><h3>partition_family/2</h3><p>Return a family indexing a partition.</p><p>Returns <a href="#family">family</a>
<strong><span class="anno">Family</span></strong> where the indexed set is
a <a href="#partition">partition</a>
of <strong><span class="anno">Set</span></strong> such that two elements are considered
equal if the results of applying <strong><span class="anno">SetFun</span></strong> are the
same value i. This i is the index that <strong><span class="anno">Family</span></strong>
maps onto the <a href="#equivalence_class">equivalence class</a>.</p><pre>
1&gt; <span class="input">S = sofs:relation([{a,a,a,a},{a,a,b,b},{a,b,b,b}]),</span>
<span class="input">SetFun = {external, fun({A,_,C,_}) -&gt; {A,C} end},</span>
<span class="input">F = sofs:partition_family(SetFun, S),</span>
<span class="input">sofs:to_external(F).</span>
[{{a,a},[{a,a,a,a}]},{{a,b},[{a,a,b,b},{a,b,b,b}]}]</pre><h3>product/1</h3><p>Return the Cartesian product of a tuple of sets.</p><p>Returns the <a href="#Cartesian_product_tuple">Cartesian product</a> of the non-empty tuple of sets
<strong><span class="anno">TupleOfSets</span></strong>. If (x[1],...,x[n]) is
an element of the n-ary relation <strong><span class="anno">Relation</span></strong>, then
x[i] is drawn from element i of <strong><span class="anno">TupleOfSets</span></strong>.</p><pre>
1&gt; <span class="input">S1 = sofs:set([a,b]),</span>
<span class="input">S2 = sofs:set([1,2]),</span>
<span class="input">S3 = sofs:set([x,y]),</span>
<span class="input">P3 = sofs:product({S1,S2,S3}),</span>
<span class="input">sofs:to_external(P3).</span>
[{a,1,x},{a,1,y},{a,2,x},{a,2,y},{b,1,x},{b,1,y},{b,2,x},{b,2,y}]</pre><h3>product/2</h3><p>Return the Cartesian product of two sets.</p><p>Returns the <a href="#Cartesian_product">Cartesian product</a> of <strong><span class="anno">Set1</span></strong>
and <strong><span class="anno">Set2</span></strong>.</p><pre>
1&gt; <span class="input">S1 = sofs:set([1,2]),</span>
<span class="input">S2 = sofs:set([a,b]),</span>
<span class="input">R = sofs:product(S1, S2),</span>
<span class="input">sofs:to_external(R).</span>
[{1,a},{1,b},{2,a},{2,b}]</pre><p><strong>product(S1,S2)</strong> is equivalent to
<strong>product({S1,S2})</strong>.</p><h3>projection/2</h3><p>Return a set of substituted elements.</p><p>Returns the set created by substituting each element of
<strong><span class="anno">Set1</span></strong> by the result of
applying <strong><span class="anno">SetFun</span></strong> to the element.</p><p>If <strong><span class="anno">SetFun</span></strong> is a number i&gt;=1 and
<strong><span class="anno">Set1</span></strong> is a relation, then the returned set is
the <a href="#projection">projection</a> of
<strong><span class="anno">Set1</span></strong> onto coordinate i.</p><pre>
1&gt; <span class="input">S1 = sofs:from_term([{1,a},{2,b},{3,a}]),</span>
<span class="input">S2 = sofs:projection(2, S1),</span>
<span class="input">sofs:to_external(S2).</span>
[a,b]</pre><h3>range/1</h3><p>Return the range of a binary relation.</p><p>Returns the <a href="#range">range</a> of the
binary relation <strong><span class="anno">BinRel</span></strong>.</p><pre>
1&gt; <span class="input">R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]),</span>
<span class="input">S = sofs:range(R),</span>
<span class="input">sofs:to_external(S).</span>
[a,b,c]</pre><h3>relation/1</h3><h3>relation/2</h3><p>Create a relation.</p><p>Creates a <a href="#relation">relation</a>.
<strong>relation(R,T)</strong> is equivalent to
<strong>from_term(R,T)</strong>, if T is
a <a href="#type">type</a> and the result is a
relation. If <strong><span class="anno">Type</span></strong> is an integer N, then
<strong>[{atom,...,atom}])</strong>, where the tuple size
is N, is used as type of the relation. If no type is
explicitly specified, the size of the first tuple of
<strong><span class="anno">Tuples</span></strong> is
used if there is such a tuple. <strong>relation([])</strong> is
equivalent to <strong>relation([],2)</strong>.</p><h3>relation_to_family/1</h3><p>Create a family from a binary relation.</p><p>Returns <a href="#family">family</a>
<strong><span class="anno">Family</span></strong> such that the index set is equal to
the <a href="#domain">domain</a> of the binary
relation <strong><span class="anno">BinRel</span></strong>, and <strong><span class="anno">Family</span></strong>[i]
is the <a href="#image">image</a> of the set of i
under <strong><span class="anno">BinRel</span></strong>.</p><pre>
1&gt; <span class="input">R = sofs:relation([{b,1},{c,2},{c,3}]),</span>
<span class="input">F = sofs:relation_to_family(R),</span>
<span class="input">sofs:to_external(F).</span>
[{b,[1]},{c,[2,3]}]</pre><h3>relative_product/1</h3><h3>relative_product/2</h3><p>Return the relative product of a list of binary relations and a binary relation.</p><p>If <strong><span class="anno">ListOfBinRels</span></strong> is a non-empty list
[R[1],...,R[n]] of binary relations and
<strong><span class="anno">BinRel1</span></strong>
is a binary relation, then <strong><span class="anno">BinRel2</span></strong> is the
<a href="#tuple_relative_product">relative product</a>
of the ordered set (R[i],...,R[n]) and
<strong><span class="anno">BinRel1</span></strong>.</p><p>If <strong><span class="anno">BinRel1</span></strong> is omitted, the relation of equality
between the elements of
the <a href="#Cartesian_product_tuple">Cartesian product</a> of the ranges of R[i],
rangeR[1]...rangeR[n],
is used instead (intuitively, nothing is "lost").</p><pre>
1&gt; <span class="input">TR = sofs:relation([{1,a},{1,aa},{2,b}]),</span>
<span class="input">R1 = sofs:relation([{1,u},{2,v},{3,c}]),</span>
<span class="input">R2 = sofs:relative_product([TR, R1]),</span>
<span class="input">sofs:to_external(R2).</span>
[{1,{a,u}},{1,{aa,u}},{2,{b,v}}]</pre><p>Notice that <strong>relative_product([R1],R2)</strong> is
different from <strong>relative_product(R1,R2)</strong>; the
list of one element is not identified with the element itself.</p><h3>relative_product/2</h3><p>Return the relative product of two binary relations.</p><p>Returns the <a href="#relative_product">relative product</a> of the binary relations <strong><span class="anno">BinRel1</span></strong>
and <strong><span class="anno">BinRel2</span></strong>.</p><h3>relative_product1/2</h3><p>Return the relative_product of two binary relations.</p><p>Returns the <a href="#relative_product">relative product</a> of
the <a href="#converse">converse</a> of the
binary relation <strong><span class="anno">BinRel1</span></strong> and the binary
relation <strong><span class="anno">BinRel2</span></strong>.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{1,a},{1,aa},{2,b}]),</span>
<span class="input">R2 = sofs:relation([{1,u},{2,v},{3,c}]),</span>
<span class="input">R3 = sofs:relative_product1(R1, R2),</span>
<span class="input">sofs:to_external(R3).</span>
[{a,u},{aa,u},{b,v}]</pre><p><strong>relative_product1(R1,R2)</strong> is equivalent to
<strong>relative_product(converse(R1),R2)</strong>.</p><h3>restriction/2</h3><p>Return a restriction of a binary relation.</p><p>Returns the <a href="#restriction">restriction</a> of
the binary relation <strong><span class="anno">BinRel1</span></strong>
to <strong><span class="anno">Set</span></strong>.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{1,a},{2,b},{3,c}]),</span>
<span class="input">S = sofs:set([1,2,4]),</span>
<span class="input">R2 = sofs:restriction(R1, S),</span>
<span class="input">sofs:to_external(R2).</span>
[{1,a},{2,b}]</pre><h3>restriction/3</h3><p>Return a restriction of a set.</p><p>Returns a subset of <strong><span class="anno">Set1</span></strong> containing those
elements that gives an element in <strong><span class="anno">Set2</span></strong> as the
result of applying <strong><span class="anno">SetFun</span></strong>.</p><pre>
1&gt; <span class="input">S1 = sofs:relation([{1,a},{2,b},{3,c}]),</span>
<span class="input">S2 = sofs:set([b,c,d]),</span>
<span class="input">S3 = sofs:restriction(2, S1, S2),</span>
<span class="input">sofs:to_external(S3).</span>
[{2,b},{3,c}]</pre><h3>set/1</h3><h3>set/2</h3><p>Create a set of atoms or any type of sets.</p><p>Creates an <a href="#sets_definition">unordered set</a>. <strong>set(L,T)</strong> is equivalent to
<strong>from_term(L,T)</strong>, if the result is an unordered
set. If no <a href="#type">type</a> is
explicitly specified, <strong>[atom]</strong> is used as the set type.</p><h3>specification/2</h3><p>Select a subset using a predicate.</p><p>Returns the set containing every element
of <strong><span class="anno">Set1</span></strong> for which <strong><span class="anno">Fun</span></strong>
returns <strong>true</strong>. If <strong><span class="anno">Fun</span></strong> is a tuple
<strong>{external,Fun2}</strong>, <strong>Fun2</strong> is applied to the
<a href="#external_set">external set</a> of
each element, otherwise <strong><span class="anno">Fun</span></strong> is applied to each
element.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{a,1},{b,2}]),</span>
<span class="input">R2 = sofs:relation([{x,1},{x,2},{y,3}]),</span>
<span class="input">S1 = sofs:from_sets([R1,R2]),</span>
<span class="input">S2 = sofs:specification(fun sofs:is_a_function/1, S1),</span>
<span class="input">sofs:to_external(S2).</span>
[[{a,1},{b,2}]]</pre><h3>strict_relation/1</h3><p>Return the strict relation corresponding to a given relation.</p><p>Returns the <a href="#strict_relation">strict relation</a> corresponding to the binary
relation <strong><span class="anno">BinRel1</span></strong>.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{1,1},{1,2},{2,1},{2,2}]),</span>
<span class="input">R2 = sofs:strict_relation(R1),</span>
<span class="input">sofs:to_external(R2).</span>
[{1,2},{2,1}]</pre><h3>substitution/2</h3><p>Return a function with a given set as domain.</p><p>Returns a function, the domain of which
is <strong><span class="anno">Set1</span></strong>. The value of an element of the domain
is the result of applying <strong><span class="anno">SetFun</span></strong> to the
element.</p><pre>
1&gt; <span class="input">L = [{a,1},{b,2}].</span>
[{a,1},{b,2}]
2&gt; <span class="input">sofs:to_external(sofs:projection(1,sofs:relation(L))).</span>
[a,b]
3&gt; <span class="input">sofs:to_external(sofs:substitution(1,sofs:relation(L))).</span>
[{{a,1},a},{{b,2},b}]
4&gt; <span class="input">SetFun = {external, fun({A,_}=E) -&gt; {E,A} end},</span>
<span class="input">sofs:to_external(sofs:projection(SetFun,sofs:relation(L))).</span>
[{{a,1},a},{{b,2},b}]</pre><p>The relation of equality between the elements of {a,b,c}:</p><pre>
1&gt; <span class="input">I = sofs:substitution(fun(A) -&gt; A end, sofs:set([a,b,c])),</span>
<span class="input">sofs:to_external(I).</span>
[{a,a},{b,b},{c,c}]</pre><p>Let <strong>SetOfSets</strong> be a set of sets and <strong>BinRel</strong> a binary
relation. The function that maps each element <strong>Set</strong> of
<strong>SetOfSets</strong> onto the <a href="#image">image</a>
of <strong>Set</strong> under <strong>BinRel</strong> is returned by the following
function:</p><pre>
images(SetOfSets, BinRel) -&gt;
   Fun = fun(Set) -&gt; sofs:image(BinRel, Set) end,
   sofs:substitution(Fun, SetOfSets).</pre><p>External unordered sets are represented as sorted lists. So,
creating the image of a set under a relation R can traverse all
elements of R (to that comes the sorting of results, the
image). In <a href="#image/2">image/2</a>,
<strong>BinRel</strong> is traversed once
for each element of <strong>SetOfSets</strong>, which can take too long. The
following efficient function can be used instead under the
assumption that the image of each element of <strong>SetOfSets</strong> under
<strong>BinRel</strong> is non-empty:</p><pre>
images2(SetOfSets, BinRel) -&gt;
   CR = sofs:canonical_relation(SetOfSets),
   R = sofs:relative_product1(CR, BinRel),
   sofs:relation_to_family(R).</pre><h3>symdiff/2</h3><p>Return the symmetric difference of two sets.</p><p>Returns the <a href="#symmetric_difference">symmetric difference</a> (or the Boolean sum)
of <strong><span class="anno">Set1</span></strong> and <strong><span class="anno">Set2</span></strong>.</p><pre>
1&gt; <span class="input">S1 = sofs:set([1,2,3]),</span>
<span class="input">S2 = sofs:set([2,3,4]),</span>
<span class="input">P = sofs:symdiff(S1, S2),</span>
<span class="input">sofs:to_external(P).</span>
[1,4]</pre><h3>symmetric_partition/2</h3><p>Return a partition of two sets.</p><p>Returns a triple of sets:</p><ul><li><strong><span class="anno">Set3</span></strong> contains the elements of <strong><span class="anno">Set1</span></strong> that do not belong to <strong><span class="anno">Set2</span></strong>. </li><li><strong><span class="anno">Set4</span></strong> contains the elements of <strong><span class="anno">Set1</span></strong> that belong to <strong><span class="anno">Set2</span></strong>. </li><li><strong><span class="anno">Set5</span></strong> contains the elements of <strong><span class="anno">Set2</span></strong> that do not belong to <strong><span class="anno">Set1</span></strong>. </li></ul><h3>to_external/1</h3><p>Return the elements of a set.</p><p>Returns the <a href="#external_set">external set</a> of an atomic, ordered, or unordered set.</p><h3>to_sets/1</h3><p>Return a list or a tuple of the elements of a set.</p><p>Returns the elements of the ordered set <strong><span class="anno">ASet</span></strong>
as a tuple of sets, and the elements of the unordered set
<strong><span class="anno">ASet</span></strong> as a sorted list of sets without
duplicates.</p><h3>type/1</h3><p>Return the type of a set.</p><p>Returns the <a href="#type">type</a> of an
atomic, ordered, or unordered set.</p><h3>union/1</h3><p>Return the union of a set of sets.</p><p>Returns the <a href="#union_n">union</a> of the
set of sets <strong><span class="anno">SetOfSets</span></strong>.</p><h3>union/2</h3><p>Return the union of two sets.</p><p>Returns the <a href="#union">union</a> of
<strong><span class="anno">Set1</span></strong> and <strong><span class="anno">Set2</span></strong>.</p><h3>union_of_family/1</h3><p>Return the union of a family.</p><p>Returns the union of <a href="#family">family</a>
<strong><span class="anno">Family</span></strong>.</p><pre>
1&gt; <span class="input">F = sofs:family([{a,[0,2,4]},{b,[0,1,2]},{c,[2,3]}]),</span>
<span class="input">S = sofs:union_of_family(F),</span>
<span class="input">sofs:to_external(S).</span>
[0,1,2,3,4]</pre><h3>weak_relation/1</h3><p>Return the weak relation corresponding to a given relation.</p><p>Returns a subset S of the <a href="#weak_relation">weak relation</a> W
corresponding to the binary relation <strong><span class="anno">BinRel1</span></strong>.
Let F be the <a href="#field">field</a> of
<strong><span class="anno">BinRel1</span></strong>. The
subset S is defined so that x S y if x W y for some x in F
and for some y in F.</p><pre>
1&gt; <span class="input">R1 = sofs:relation([{1,1},{1,2},{3,1}]),</span>
<span class="input">R2 = sofs:weak_relation(R1),</span>
<span class="input">sofs:to_external(R2).</span>
[{1,1},{1,2},{2,2},{3,1},{3,3}]</pre><h3>See Also</h3><p><a href="dict">dict</a>,
<a href="digraph">digraph</a>,
<a href="orddict">orddict</a>,
<a href="ordsets">ordsets</a>,
<a href="sets">sets</a></p><h2>string</h2><p>String processing functions.</p><p>This module provides functions for string processing.A string in this module is represented by <a href="./unicode#type-chardata">unicode#type-chardata</a>, that is, a list of codepoints,
binaries with UTF-8-encoded codepoints
(<em>UTF-8 binaries</em>), or a mix of the two.<pre><code class="">
"abcd"               is a valid string
&lt;&lt;"abcd"&gt;&gt;           is a valid string
["abcd"]             is a valid string
&lt;&lt;"abc.."/utf8&gt;&gt;  is a valid string
&lt;&lt;"abc.."&gt;&gt;       is NOT a valid string,
                     but a binary with Latin-1-encoded codepoints
[&lt;&lt;"abc"&gt;&gt;, ".."] is a valid string
[atom]               is NOT a valid string</code></pre>
This module operates on grapheme clusters. A <em>grapheme cluster</em>
is a user-perceived character, which can be represented by several
codepoints.
<pre><code class="">
""  [229] or [97, 778]
"e"  [101, 778]</code></pre>
The string length of "e" is 3, even though it is represented by the
codepoints <strong>[223,8593,101,778]</strong> or the UTF-8 binary
<strong>&lt;&lt;195,159,226,134,145,101,204,138&gt;&gt;</strong>.

Grapheme clusters for codepoints of class <strong>prepend</strong>
and non-modern (or decomposed) Hangul is not handled for performance
reasons in
<a href="#find/3">find/3</a>,
<a href="#replace/3">replace/3</a>,
<a href="#split/2">split/2</a>,
<a href="#lexemes/2">lexemes/2</a> and
<a href="#trim/3">trim/3</a>.

Splitting and appending strings is to be done on grapheme clusters
borders.
There is no verification that the results of appending strings are
valid or normalized.

Most of the functions expect all input to be normalized to one form,
see for example <a href="./unicode#characters_to_nfc_list/1">unicode#characters_to_nfc_list/1</a>.

Language or locale specific handling of input is not considered
in any function.

The functions can crash for non-valid input strings. For example,
the functions expect UTF-8 binaries but not all functions
verify that all binaries are encoded correctly.

Unless otherwise specified the return value type is the same as
the input type. That is, binary input returns binary output,
list input returns a list output, and mixed input can return a
mixed output.<pre><code class="">
1&gt; string:trim("  sarah  ").
"sarah"
2&gt; string:trim(&lt;&lt;"  sarah  "&gt;&gt;).
&lt;&lt;"sarah"&gt;&gt;
3&gt; string:lexemes("foo bar", " ").
["foo","bar"]
4&gt; string:lexemes(&lt;&lt;"foo bar"&gt;&gt;, " ").
[&lt;&lt;"foo"&gt;&gt;,&lt;&lt;"bar"&gt;&gt;]</code></pre>This module has been reworked in Erlang/OTP 20 to
handle <a href="./unicode#type-chardata">unicode#type-chardata</a> and operate on grapheme
clusters. The <a href="#oldapi">oldapi</a> that only work on Latin-1 lists as input
are still available but should not be used, they will be
deprecated in a future release.
</p><h2>Data Types</h2><span class="name">direction</span><span class="name">grapheme_cluster</span><p>A user-perceived character, consisting of one or more
codepoints.</p><h2>Functions</h2><h3>casefold/1</h3><p>Convert a string to a comparable string.</p><p>
Converts <strong><span class="anno">String</span></strong> to a case-agnostic
comparable string. Function <strong>casefold/1</strong> is preferred
over <strong>lowercase/1</strong> when two strings are to be compared
for equality. See also <a href="#equal/4">equal/4</a>.
</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">string:casefold(" and  SHARP S").</span>
" and ss sharp s"</pre><h3>chomp/1</h3><p>Remove trailing end of line control characters.</p><p>
Returns a string where any trailing <strong>\n</strong> or
<strong>\r\n</strong> have been removed from <strong><span class="anno">String</span></strong>.
</p><p><em>Example:</em></p><pre>
182&gt; <span class="input">string:chomp(&lt;&lt;"\nHello\n\n"&gt;&gt;).</span>
&lt;&lt;"\nHello"&gt;&gt;
183&gt; <span class="input">string:chomp("\nHello\r\r\n").</span>
"\nHello\r"</pre><h3>equal/2</h3><h3>equal/3</h3><h3>equal/4</h3><p>Test string equality.</p><p>
Returns <strong>true</strong> if <strong><span class="anno">A</span></strong> and
<strong><span class="anno">B</span></strong> are equal, otherwise <strong>false</strong>.
</p><p>
If <strong><span class="anno">IgnoreCase</span></strong> is <strong>true</strong>
the function does <a href="#casefold/1"> ing</a> on the fly before the equality test.
</p><p>If <strong><span class="anno">Norm</span></strong> is not <strong>none</strong>
the function applies normalization on the fly before the equality test.
There are four available normalization forms:
<a href="./unicode#characters_to_nfc_list/1">unicode#characters_to_nfc_list/1</a>,
<a href="./unicode#characters_to_nfd_list/1">unicode#characters_to_nfd_list/1</a>,
<a href="./unicode#characters_to_nfkc_list/1">unicode#characters_to_nfkc_list/1</a>, and
<a href="./unicode#characters_to_nfkd_list/1">unicode#characters_to_nfkd_list/1</a>.
</p><p>By default,
<strong><span class="anno">IgnoreCase</span></strong> is <strong>false</strong> and
<strong><span class="anno">Norm</span></strong> is <strong>none</strong>.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">string:equal("", &lt;&lt;""/utf8&gt;&gt;).</span>
true
2&gt; <span class="input">string:equal("", unicode:characters_to_nfd_binary("")).</span>
false
3&gt; <span class="input">string:equal("", unicode:characters_to_nfd_binary(""), true, nfc).</span>
true</pre><h3>find/2</h3><h3>find/3</h3><p>Find start of substring.</p><p>
Removes anything before <strong><span class="anno">SearchPattern</span></strong> in <strong><span class="anno">String</span></strong>
and returns the remainder of the string or <strong>nomatch</strong> if <strong><span class="anno">SearchPattern</span></strong> is not
found.
<strong><span class="anno">Dir</span></strong>, which can be <strong>leading</strong> or
<strong>trailing</strong>, indicates from which direction characters
are to be searched.
</p><p>
By default, <strong><span class="anno">Dir</span></strong> is <strong>leading</strong>.
</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">string:find("ab..cd..ef", ".").</span>
"..cd..ef"
2&gt; <span class="input">string:find(&lt;&lt;"ab..cd..ef"&gt;&gt;, "..", trailing).</span>
&lt;&lt;"..ef"&gt;&gt;
3&gt; <span class="input">string:find(&lt;&lt;"ab..cd..ef"&gt;&gt;, "x", leading).</span>
nomatch
4&gt; <span class="input">string:find("ab..cd..ef", "x", trailing).</span>
nomatch</pre><h3>is_empty/1</h3><p>Check if the string is empty.</p><p>Returns <strong>true</strong> if <strong><span class="anno">String</span></strong> is the
empty string, otherwise <strong>false</strong>.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">string:is_empty("foo").</span>
false
2&gt; <span class="input">string:is_empty(["",&lt;&lt;&gt;&gt;]).</span>
true</pre><h3>length/1</h3><p>Calculate length of the string.</p><p>
Returns the number of grapheme clusters in <strong><span class="anno">String</span></strong>.
</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">string:length("e").</span>
3
2&gt; <span class="input">string:length(&lt;&lt;195,159,226,134,145,101,204,138&gt;&gt;).</span>
3</pre><h3>lexemes/2</h3><p>Split string into lexemes.</p><p>
Returns a list of lexemes in <strong><span class="anno">String</span></strong>, separated
by the grapheme clusters in <strong><span class="anno">SeparatorList</span></strong>.
</p><p>
Notice that, as shown in this example, two or more
adjacent separator graphemes clusters in <strong><span class="anno">String</span></strong>
are treated as one. That is, there are no empty
strings in the resulting list of lexemes.
See also <a href="#split/3">split/3</a> which returns
empty strings.
</p><p>Notice that <strong>[$\r,$\n]</strong> is one grapheme cluster.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">string:lexemes("abc defxxghix jkl\r\nfoo", "x e" ++ [[$\r,$\n]]).</span>
["abc","def","ghi","jkl","foo"]
2&gt; <span class="input">string:lexemes(&lt;&lt;"abc defxxghix jkl\r\nfoo"/utf8&gt;&gt;, "x e" ++ [$\r,$\n]).</span>
[&lt;&lt;"abc"&gt;&gt;,&lt;&lt;"def"/utf8&gt;&gt;,&lt;&lt;"ghi"&gt;&gt;,&lt;&lt;"jkl\r\nfoo"&gt;&gt;]</pre><h3>lowercase/1</h3><p>Convert a string to lowercase</p><p>
Converts <strong><span class="anno">String</span></strong> to lowercase.
</p><p>
Notice that function <a href="#casefold/1">casefold/1</a>
should be used when converting a string to
be tested for equality.
</p><p><em>Example:</em></p><pre>
2&gt; <span class="input">string:lowercase(string:uppercase("Micha")).</span>
"micha"</pre><h3>next_codepoint/1</h3><p>Pick the first codepoint.</p><p>
Returns the first codepoint in <strong><span class="anno">String</span></strong>
and the rest of <strong><span class="anno">String</span></strong> in the tail. Returns
an empty list if <strong><span class="anno">String</span></strong> is empty or an
<strong>{error, String}</strong> tuple if the next byte is invalid.
</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">string:next_codepoint(unicode:characters_to_binary("efg")).</span>
[101|&lt;&lt;"fg"/utf8&gt;&gt;]</pre><h3>next_grapheme/1</h3><p>Pick the first grapheme cluster.</p><p>
Returns the first grapheme cluster in <strong><span class="anno">String</span></strong>
and the rest of <strong><span class="anno">String</span></strong> in the tail. Returns
an empty list if <strong><span class="anno">String</span></strong> is empty or an
<strong>{error, String}</strong> tuple if the next byte is invalid.
</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">string:next_grapheme(unicode:characters_to_binary("efg")).</span>
["e"|&lt;&lt;"fg"&gt;&gt;]</pre><h3>nth_lexeme/3</h3><p>Pick the nth lexeme.</p><p>Returns lexeme number <strong><span class="anno">N</span></strong> in
<strong><span class="anno">String</span></strong>, where lexemes are separated by
the grapheme clusters in <strong><span class="anno">SeparatorList</span></strong>.
</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">string:nth_lexeme("abc.def.ghiejkl", 3, ".e").</span>
"ghi"</pre><h3>pad/2</h3><h3>pad/3</h3><h3>pad/4</h3><p>Pad a string to given length.</p><p>
Pads <strong><span class="anno">String</span></strong> to <strong><span class="anno">Length</span></strong> with
grapheme cluster <strong><span class="anno">Char</span></strong>.
<strong><span class="anno">Dir</span></strong>, which can be <strong>leading</strong>, <strong>trailing</strong>,
or <strong>both</strong>, indicates where the padding should be added.
</p><p>By default, <strong><span class="anno">Char</span></strong> is <strong>$\s</strong> and
<strong><span class="anno">Dir</span></strong> is <strong>trailing</strong>.
</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">string:pad(&lt;&lt;"Hell"/utf8&gt;&gt;, 8).</span>
[&lt;&lt;72,101,204,138,108,108,195,182&gt;&gt;,32,32,32]
2&gt; <span class="input">io:format("'~ts'~n",[string:pad("Hell", 8, leading)]).</span>
'   Hell'
3&gt; <span class="input">io:format("'~ts'~n",[string:pad("Hell", 8, both)]).</span>
' Hell  '</pre><h3>prefix/2</h3><p>Remove prefix from string.</p><p>
If <strong><span class="anno">Prefix</span></strong> is the prefix of
<strong><span class="anno">String</span></strong>, removes it and returns the
remainder of <strong><span class="anno">String</span></strong>, otherwise returns
<strong>nomatch</strong>.
</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">string:prefix(&lt;&lt;"prefix of string"&gt;&gt;, "pre").</span>
&lt;&lt;"fix of string"&gt;&gt;
2&gt; <span class="input">string:prefix("pre", "prefix").</span>
nomatch</pre><h3>replace/3</h3><h3>replace/4</h3><p>Replace a pattern in string.</p><p>
Replaces <strong><span class="anno">SearchPattern</span></strong> in <strong><span class="anno">String</span></strong>
with <strong><span class="anno">Replacement</span></strong>.
<strong><span class="anno">Where</span></strong>, default <strong>leading</strong>, indicates whether
the <strong>leading</strong>, the <strong>trailing</strong> or <strong>all</strong> encounters of
<strong><span class="anno">SearchPattern</span></strong> are to be replaced.
</p><p>Can be implemented as:</p><pre>lists:join(Replacement, split(String, SearchPattern, Where)).</pre><p><em>Example:</em></p><pre>
1&gt; <span class="input">string:replace(&lt;&lt;"ab..cd..ef"&gt;&gt;, "..", "*").</span>
[&lt;&lt;"ab"&gt;&gt;,"*",&lt;&lt;"cd..ef"&gt;&gt;]
2&gt; <span class="input">string:replace(&lt;&lt;"ab..cd..ef"&gt;&gt;, "..", "*", all).</span>
[&lt;&lt;"ab"&gt;&gt;,"*",&lt;&lt;"cd"&gt;&gt;,"*",&lt;&lt;"ef"&gt;&gt;]</pre><h3>reverse/1</h3><p>Reverses a string</p><p>
Returns the reverse list of the grapheme clusters in <strong><span class="anno">String</span></strong>.
</p><p><em>Example:</em></p><pre>
1&gt; Reverse = <span class="input">string:reverse(unicode:characters_to_nfd_binary("")).</span>
[[79,776],[65,776],[65,778]]
2&gt; <span class="input">io:format("~ts~n",[Reverse]).</span>
OAA</pre><h3>slice/2</h3><h3>slice/3</h3><p>Extract a part of string</p><p>Returns a substring of <strong><span class="anno">String</span></strong> of
at most <strong><span class="anno">Length</span></strong> grapheme clusters, starting at position
<strong><span class="anno">Start</span></strong>.</p><p>By default, <strong><span class="anno">Length</span></strong> is <strong>infinity</strong>.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">string:slice(&lt;&lt;"Hell Wrld"/utf8&gt;&gt;, 4).</span>
&lt;&lt;" Wrld"/utf8&gt;&gt;
2&gt; <span class="input">string:slice(["Hell ", &lt;&lt;"Wrld"/utf8&gt;&gt;], 4,4).</span>
" W"
3&gt; <span class="input">string:slice(["Hell ", &lt;&lt;"Wrld"/utf8&gt;&gt;], 4,50).</span>
" Wrld"</pre><h3>split/2</h3><h3>split/3</h3><p>Split a string into substrings.</p><p>
Splits <strong><span class="anno">String</span></strong> where <strong><span class="anno">SearchPattern</span></strong>
is encountered and return the remaining parts.
<strong><span class="anno">Where</span></strong>, default <strong>leading</strong>, indicates whether
the <strong>leading</strong>, the <strong>trailing</strong> or <strong>all</strong> encounters of
<strong><span class="anno">SearchPattern</span></strong> will split <strong><span class="anno">String</span></strong>.
</p><p><em>Example:</em></p><pre>
0&gt; <span class="input">string:split("ab..bc..cd", "..").</span>
["ab","bc..cd"]
1&gt; <span class="input">string:split(&lt;&lt;"ab..bc..cd"&gt;&gt;, "..", trailing).</span>
[&lt;&lt;"ab..bc"&gt;&gt;,&lt;&lt;"cd"&gt;&gt;]
2&gt; <span class="input">string:split(&lt;&lt;"ab..bc....cd"&gt;&gt;, "..", all).</span>
[&lt;&lt;"ab"&gt;&gt;,&lt;&lt;"bc"&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;"cd"&gt;&gt;]</pre><h3>take/2</h3><h3>take/3</h3><h3>take/4</h3><p>Take leading or trailing parts.</p><p>Takes characters from <strong><span class="anno">String</span></strong> as long as
the characters are members of set <strong><span class="anno">Characters</span></strong>
or the complement of set <strong><span class="anno">Characters</span></strong>.
<strong><span class="anno">Dir</span></strong>,
which can be <strong>leading</strong> or <strong>trailing</strong>, indicates from
which direction characters are to be taken.
</p><p><em>Example:</em></p><pre>
5&gt; <span class="input">string:take("abc0z123", lists:seq($a,$z)).</span>
{"abc","0z123"}
6&gt; <span class="input">string:take(&lt;&lt;"abc0z123"&gt;&gt;, lists:seq($0,$9), true, leading).</span>
{&lt;&lt;"abc"&gt;&gt;,&lt;&lt;"0z123"&gt;&gt;}
7&gt; <span class="input">string:take("abc0z123", lists:seq($0,$9), false, trailing).</span>
{"abc0z","123"}
8&gt; <span class="input">string:take(&lt;&lt;"abc0z123"&gt;&gt;, lists:seq($a,$z), true, trailing).</span>
{&lt;&lt;"abc0z"&gt;&gt;,&lt;&lt;"123"&gt;&gt;}</pre><h3>titlecase/1</h3><p>Convert a string to titlecase.</p><p>
Converts <strong><span class="anno">String</span></strong> to titlecase.
</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">string:titlecase(" is a SHARP s").</span>
"Ss is a SHARP s"</pre><h3>to_float/1</h3><p>Return a float whose text representation is the integers (ASCII values) of a string.</p><p>Argument <strong><span class="anno">String</span></strong> is expected to start with a
valid text represented float (the digits are ASCII values).
Remaining characters in the string after the float are returned in
<strong><span class="anno">Rest</span></strong>.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">{F1,Fs} = string:to_float("1.0-1.0e-1"),</span>
&gt; <span class="input">{F2,[]} = string:to_float(Fs),</span>
&gt; <span class="input">F1+F2.</span>
0.9
&gt; <span class="input">string:to_float("3/2=1.5").</span>
{error,no_float}
&gt; <span class="input">string:to_float("-1.5eX").</span>
{-1.5,"eX"}</pre><h3>to_integer/1</h3><p>Return an integer whose text representation is the integers (ASCII values) of a string.</p><p>Argument <strong><span class="anno">String</span></strong> is expected to start with a
valid text represented integer (the digits are ASCII values).
Remaining characters in the string after the integer are returned in
<strong><span class="anno">Rest</span></strong>.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">{I1,Is} = string:to_integer("33+22"),</span>
&gt; <span class="input">{I2,[]} = string:to_integer(Is),</span>
&gt; <span class="input">I1-I2.</span>
11
&gt; <span class="input">string:to_integer("0.5").</span>
{0,".5"}
&gt; <span class="input">string:to_integer("x=2").</span>
{error,no_integer}</pre><h3>to_graphemes/1</h3><p>Convert a string to a list of grapheme clusters.</p><p>
Converts <strong><span class="anno">String</span></strong> to a list of grapheme clusters.
</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">string:to_graphemes("e").</span>
[223,8593,[101,778]]
2&gt; <span class="input">string:to_graphemes(&lt;&lt;"e"/utf8&gt;&gt;).</span>
[223,8593,[101,778]]</pre><h3>trim/1</h3><h3>trim/2</h3><h3>trim/3</h3><p>Trim leading or trailing, or both, characters.</p><p>
Returns a string, where leading or trailing, or both,
<strong><span class="anno">Characters</span></strong> have been removed.
<strong><span class="anno">Dir</span></strong> which can be <strong>leading</strong>, <strong>trailing</strong>,
or <strong>both</strong>, indicates from which direction characters
are to be removed.
</p><p> Default <strong><span class="anno">Characters</span></strong> is the set of
nonbreakable whitespace codepoints, defined as
Pattern_White_Space in
<a href="http://unicode.org/reports/tr31/">Unicode Standard Annex #31</a>.
<strong>By default, <span class="anno">Dir</span></strong> is <strong>both</strong>.
</p><p>
Notice that <strong>[$\r,$\n]</strong> is one grapheme cluster according
to the Unicode Standard.
</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">string:trim("\t  Hello  \n").</span>
"Hello"
2&gt; <span class="input">string:trim(&lt;&lt;"\t  Hello  \n"&gt;&gt;, leading).</span>
&lt;&lt;"Hello  \n"&gt;&gt;
3&gt; <span class="input">string:trim(&lt;&lt;".Hello.\n"&gt;&gt;, trailing, "\n.").</span>
&lt;&lt;".Hello"&gt;&gt;</pre><h3>uppercase/1</h3><p>Convert a string to uppercase.</p><p>
Converts <strong><span class="anno">String</span></strong> to uppercase.
</p><p>See also <a href="#titlecase/1">titlecase/1</a>.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">string:uppercase("Micha").</span>
"MICHA"</pre><a name="oldapi"></a><h3>Obsolete API functions</h3><p>Here follows the function of the old API.
These functions only work on a list of Latin-1 characters.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
The functions are kept for backward compatibility, but are
not recommended.
They will be deprecated in a future release.
</p><p>Any undocumented functions in <strong>string</strong> are not to be used.</p></div><h2>Functions</h2><h3>centre/2</h3><h3>centre/3</h3><p>Center a string.</p><p>Returns a string, where <strong><span class="anno">String</span></strong> is centered in the
string and surrounded by blanks or <strong><span class="anno">Character</span></strong>.
The resulting string has length <strong><span class="anno">Number</span></strong>.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="#pad/3">pad/3</a>.
</p><h3>chars/2</h3><h3>chars/3</h3><p>Return a string consisting of numbers of characters.</p><p>Returns a string consisting of <strong><span class="anno">Number</span></strong> characters
<strong><span class="anno">Character</span></strong>. Optionally, the string can end with
string <strong><span class="anno">Tail</span></strong>.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="./lists#duplicate/2">lists#duplicate/2</a>.</p><h3>chr/2</h3><p>Return the index of the first occurrence of a character in a string.</p><p>Returns the index of the first occurrence of
<strong><span class="anno">Character</span></strong> in <strong><span class="anno">String</span></strong>. Returns
<strong>0</strong> if <strong><span class="anno">Character</span></strong> does not occur.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="#find/2">find/2</a>.</p><h3>concat/2</h3><p>Concatenate two strings.</p><p>Concatenates <strong><span class="anno">String1</span></strong> and
<strong><span class="anno">String2</span></strong> to form a new string
<strong><span class="anno">String3</span></strong>, which is returned.</p><p>
This function is <a href="#oldapi">obsolete</a>.
Use <strong>[<span class="anno">String1</span>, <span class="anno">String2</span>]</strong> as
<strong>Data</strong> argument, and call
<a href="./unicode#characters_to_list/2">unicode#characters_to_list/2</a> or
<a href="./unicode#characters_to_binary/2">unicode#characters_to_binary/2</a>
to flatten the output.
</p><h3>copies/2</h3><p>Copy a string.</p><p>Returns a string containing <strong><span class="anno">String</span></strong> repeated
<strong><span class="anno">Number</span></strong> times.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="./lists#duplicate/2">lists#duplicate/2</a>.</p><h3>cspan/2</h3><p>Span characters at start of a string.</p><p>Returns the length of the maximum initial segment of
<strong><span class="anno">String</span></strong>, which consists entirely of characters
not from <strong><span class="anno">Chars</span></strong>.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="#take/3">take/3</a>.</p><p><em>Example:</em></p><pre><code class="">
&gt; string:cspan("\t    abcdef", " \t").
0</code></pre><h3>join/2</h3><p>Join a list of strings with separator.</p><p>Returns a string with the elements of <strong><span class="anno">StringList</span></strong>
separated by the string in <strong><span class="anno">Separator</span></strong>.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="./lists#join/2">lists#join/2</a>.</p><p><em>Example:</em></p><pre><code class="">
&gt; join(["one", "two", "three"], ", ").
"one, two, three"</code></pre><h3>left/2</h3><h3>left/3</h3><p>Adjust left end of a string.</p><p>Returns <strong><span class="anno">String</span></strong> with the length adjusted in
accordance with <strong><span class="anno">Number</span></strong>. The left margin is
fixed. If <strong>length(<span class="anno">String</span>)</strong> &lt;
<strong><span class="anno">Number</span></strong>, then <strong><span class="anno">String</span></strong> is padded
with blanks or <strong><span class="anno">Character</span></strong>s.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="#pad/2">pad/2</a> or
<a href="#pad/3">pad/3</a>.</p><p><em>Example:</em></p><pre><code class="">
&gt; string:left("Hello",10,$.).
"Hello....."</code></pre><h3>len/1</h3><p>Return the length of a string.</p><p>Returns the number of characters in <strong><span class="anno">String</span></strong>.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="#length/1">length/1</a>.</p><h3>rchr/2</h3><p>Return the index of the last occurrence of a character in a string.</p><p>Returns the index of the last occurrence of
<strong><span class="anno">Character</span></strong> in <strong><span class="anno">String</span></strong>. Returns
<strong>0</strong> if <strong><span class="anno">Character</span></strong> does not occur.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="#find/3">find/3</a>.</p><h3>right/2</h3><h3>right/3</h3><p>Adjust right end of a string.</p><p>Returns <strong><span class="anno">String</span></strong> with the length adjusted in
accordance with <strong><span class="anno">Number</span></strong>. The right margin is
fixed. If the length of <strong>(<span class="anno">String</span>)</strong> &lt;
<strong><span class="anno">Number</span></strong>, then <strong><span class="anno">String</span></strong> is padded
with blanks or <strong><span class="anno">Character</span></strong>s.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="#pad/3">pad/3</a>.</p><p><em>Example:</em></p><pre><code class="">
&gt; string:right("Hello", 10, $.).
".....Hello"</code></pre><h3>rstr/2</h3><p>Find the index of a substring.</p><p>Returns the position where the last occurrence of
<strong><span class="anno">SubString</span></strong> begins in <strong><span class="anno">String</span></strong>.
Returns <strong>0</strong> if <strong><span class="anno">SubString</span></strong>
does not exist in <strong><span class="anno">String</span></strong>.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="#find/3">find/3</a>.</p><p><em>Example:</em></p><pre><code class="">
&gt; string:rstr(" Hello Hello World World ", "Hello World").
8</code></pre><h3>span/2</h3><p>Span characters at start of a string.</p><p>Returns the length of the maximum initial segment of
<strong><span class="anno">String</span></strong>, which consists entirely of characters
from <strong><span class="anno">Chars</span></strong>.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="#take/2">take/2</a>.</p><p><em>Example:</em></p><pre><code class="">
&gt; string:span("\t    abcdef", " \t").
5</code></pre><h3>str/2</h3><p>Find the index of a substring.</p><p>Returns the position where the first occurrence of
<strong><span class="anno">SubString</span></strong> begins in <strong><span class="anno">String</span></strong>.
Returns <strong>0</strong> if <strong><span class="anno">SubString</span></strong>
does not exist in <strong><span class="anno">String</span></strong>.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="#find/2">find/2</a>.</p><p><em>Example:</em></p><pre><code class="">
&gt; string:str(" Hello Hello World World ", "Hello World").
8</code></pre><h3>strip/1</h3><h3>strip/2</h3><h3>strip/3</h3><p>Strip leading or trailing characters.</p><p>Returns a string, where leading or trailing, or both, blanks or a
number of <strong><span class="anno">Character</span></strong> have been removed.
<strong><span class="anno">Direction</span></strong>, which can be <strong>left</strong>, <strong>right</strong>,
or <strong>both</strong>, indicates from which direction blanks are to be
removed. <strong>strip/1</strong> is equivalent to
<strong>strip(String, both)</strong>.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="#trim/3">trim/3</a>.</p><p><em>Example:</em></p><pre><code class="">
&gt; string:strip("...Hello.....", both, $.).
"Hello"</code></pre><h3>sub_string/2</h3><h3>sub_string/3</h3><p>Extract a substring.</p><p>Returns a substring of <strong><span class="anno">String</span></strong>, starting at
position <strong><span class="anno">Start</span></strong> to the end of the string, or to
and including position <strong><span class="anno">Stop</span></strong>.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="#slice/3">slice/3</a>.</p><p><em>Example:</em></p><pre><code class="">
sub_string("Hello World", 4, 8).
"lo Wo"</code></pre><h3>substr/2</h3><h3>substr/3</h3><p>Return a substring of a string.</p><p>Returns a substring of <strong><span class="anno">String</span></strong>, starting at
position <strong><span class="anno">Start</span></strong>, and ending at the end of the
string or at length <strong><span class="anno">Length</span></strong>.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="#slice/3">slice/3</a>.</p><p><em>Example:</em></p><pre><code class="">
&gt; substr("Hello World", 4, 5).
"lo Wo"</code></pre><h3>sub_word/2</h3><h3>sub_word/3</h3><p>Extract subword.</p><p>Returns the word in position <strong><span class="anno">Number</span></strong> of
<strong><span class="anno">String</span></strong>. Words are separated by blanks or
<strong><span class="anno">Character</span></strong>s.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="#nth_lexeme/3">nth_lexeme/3</a>.</p><p><em>Example:</em></p><pre><code class="">
&gt; string:sub_word(" Hello old boy !",3,$o).
"ld b"</code></pre><h3>to_lower/1</h3><h3>to_lower/1</h3><h3>to_upper/1</h3><h3>to_upper/1</h3><p>Convert case of string (ISO/IEC 8859-1).</p><ul><li>String</li></ul><ul><li>Result</li></ul><ul><li>Char</li></ul><ul><li>CharResult</li></ul><p>The specified string or character is case-converted. Notice that
the supported character set is ISO/IEC 8859-1 (also called Latin 1);
all values outside this set are unchanged</p><p>This function is <a href="#oldapi">obsolete</a> use
<a href="#lowercase/1">lowercase/1</a>,
<a href="#uppercase/1">uppercase/1</a>,
<a href="#titlecase/1">titlecase/1</a> or
<a href="#casefold/1">casefold/1</a>.</p><h3>tokens/2</h3><p>Split string into tokens.</p><p>Returns a list of tokens in <strong><span class="anno">String</span></strong>, separated
by the characters in <strong><span class="anno">SeparatorList</span></strong>.</p><p><em>Example:</em></p><pre><code class="">
&gt; tokens("abc defxxghix jkl", "x ").
["abc", "def", "ghi", "jkl"]</code></pre><p>Notice that, as shown in this example, two or more
adjacent separator characters in <strong><span class="anno">String</span></strong>
are treated as one. That is, there are no empty
strings in the resulting list of tokens.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="#lexemes/2">lexemes/2</a>.</p><h3>words/1</h3><h3>words/2</h3><p>Count blank separated words.</p><p>Returns the number of words in <strong><span class="anno">String</span></strong>, separated
by blanks or <strong><span class="anno">Character</span></strong>.</p><p>This function is <a href="#oldapi">obsolete</a>.
Use
<a href="#lexemes/2">lexemes/2</a>.</p><p><em>Example:</em></p><pre><code class="">
&gt; words(" Hello old boy!", $o).
4</code></pre><h3>Notes</h3><p>Some of the general string functions can seem to overlap each
other. The reason is that this string package is the
combination of two earlier packages and all functions of
both packages have been retained.</p><h2>supervisor</h2><p>Generic supervisor behavior.</p><p>This behavior module provides a supervisor, a process that
supervises other processes called child processes. A child
process can either be another supervisor or a worker process.
Worker processes are normally implemented using one of the
<a href="gen_event">gen_event</a>,
<a href="gen_server">gen_server</a>, or
<a href="gen_statem">gen_statem</a>
behaviors. A supervisor implemented using this module has
a standard set of interface functions and include functionality
for tracing and error reporting. Supervisors are used to build a
hierarchical process structure called a supervision tree, a
nice way to structure a fault-tolerant application. For more
information, see <a href="./sup_princ"> Supervisor Behaviour</a> in OTP Design Principles.A supervisor expects the definition of which child processes to
supervise to be specified in a callback module exporting a
predefined set of functions.Unless otherwise stated, all functions in this module fail
if the specified supervisor does not exist or if bad arguments
are specified.</p><a name="supervision_princ"></a><h3>Supervision Principles</h3><p>The supervisor is responsible for starting, stopping, and
monitoring its child processes. The basic idea of a supervisor is
that it must keep its child processes alive by restarting them
when necessary.</p><p>The children of a supervisor are defined as a list of
<em>child specifications</em>. When the supervisor is started, the child
processes are started in order from left to right according to
this list. When the supervisor terminates, it first terminates
its child processes in reversed start order, from right to left.</p><a name="sup_flags"></a><p>The supervisor properties are defined by the supervisor flags.
The type definition for the supervisor flags is as follows:</p><pre>
sup_flags() = #{strategy =&gt; strategy(),         % optional
                intensity =&gt; non_neg_integer(), % optional
                period =&gt; pos_integer()}        % optional</pre><p>A supervisor can have one of the following <em>restart strategies</em>
specified with the <strong>strategy</strong> key in the above map:</p><ul><li> <p><strong>one_for_one</strong> - If one child process terminates and
is to be restarted, only that child process is
affected. This is the default restart strategy.</p> </li><li> <p><strong>one_for_all</strong> - If one child process terminates and
is to be restarted, all other child processes are terminated
and then all child processes are restarted.</p> </li><li> <p><strong>rest_for_one</strong> - If one child process terminates and
is to be restarted, the 'rest' of the child processes (that
is, the child processes after the terminated child process
in the start order) are terminated. Then the terminated
child process and all child processes after it are restarted.</p> </li><li> <p><strong>simple_one_for_one</strong> - A simplified <strong>one_for_one</strong>
supervisor, where all child processes are dynamically added
instances of the same process type, that is, running the same
code.</p> <p>Functions
<a href="#delete_child/2">delete_child/2</a> and
<a href="#restart_child/2">restart_child/2</a>
are invalid for <strong>simple_one_for_one</strong> supervisors and return
<strong>{error,simple_one_for_one}</strong> if the specified supervisor
uses this restart strategy.</p> <p>Function <a href="#terminate_child/2">terminate_child/2</a> can be used for
children under <strong>simple_one_for_one</strong> supervisors by
specifying the child's <strong>pid()</strong> as the second argument. If
instead the child specification identifier is used,
<strong>terminate_child/2</strong> return
<strong>{error,simple_one_for_one}</strong>.</p> <p>As a <strong>simple_one_for_one</strong> supervisor can have
many children, it shuts them all down asynchronously. This
means that the children do their cleanup in parallel,
and therefore the order in which they are stopped is not
defined.</p> </li></ul><p>To prevent a supervisor from getting into an infinite loop of
child process terminations and restarts, a <em>maximum restart intensity</em> is defined using two integer values specified
with keys <strong>intensity</strong> and <strong>period</strong> in the above
map. Assuming the values <strong>MaxR</strong> for <strong>intensity</strong>
and <strong>MaxT</strong> for <strong>period</strong>, then, if more than <strong>MaxR</strong>
restarts occur within <strong>MaxT</strong> seconds, the supervisor
terminates all child processes and then itself. The termination
reason for the supervisor itself in that case will be <strong>shutdown</strong>.
<strong>intensity</strong> defaults to <strong>1</strong> and <strong>period</strong> defaults to
<strong>5</strong>.</p><a name="child_spec"></a><p>The type definition of a child specification is as follows:</p><pre>
child_spec() = #{id =&gt; child_id(),       % mandatory
                 start =&gt; mfargs(),      % mandatory
                 restart =&gt; restart(),   % optional
                 shutdown =&gt; shutdown(), % optional
                 type =&gt; worker(),       % optional
                 modules =&gt; modules()}   % optional</pre><p>The old tuple format is kept for backwards compatibility,
see <a href="#type-child_spec">child_spec()</a>,
but the map is preferred.</p><ul><li> <p><strong>id</strong> is used to identify the child
specification internally by the supervisor.</p> <p>The <strong>id</strong> key is mandatory.</p> <p>Notice that this identifier on occations has been called
"name". As far as possible, the terms "identifier" or "id"
are now used but to keep backward compatibility,
some occurences of "name" can still be found, for example
in error messages.</p> </li><li> <p><strong>start</strong> defines the function call used to start the
child process. It must be a module-function-arguments
tuple <strong>{M,F,A}</strong> used as <strong>apply(M,F,A)</strong>.</p> <p>The start function <em>must create and link to</em> the child
process, and must return <strong>{ok,Child}</strong> or
<strong>{ok,Child,Info}</strong>, where <strong>Child</strong> is the pid of
the child process and <strong>Info</strong> any term that is
ignored by the supervisor.</p> <p>The start function can also return <strong>ignore</strong> if the child
process for some reason cannot be started, in which case
the child specification is kept by the supervisor
(unless it is a temporary child) but the non-existing child
process is ignored.</p> <p>If something goes wrong, the function can also return an
error tuple <strong>{error,Error}</strong>.</p> <p>Notice that the <strong>start_link</strong> functions of the different
behavior modules fulfill the above requirements.</p> <p>The <strong>start</strong> key is mandatory.</p> </li><li> <p><strong>restart</strong> defines when a terminated child process
must be restarted. A <strong>permanent</strong> child process is
always restarted. A <strong>temporary</strong> child process is
never restarted (even when the supervisor's restart strategy
is <strong>rest_for_one</strong> or <strong>one_for_all</strong> and a sibling's
death causes the temporary process to be terminated).
A <strong>transient</strong> child process is restarted only if
it terminates abnormally, that is, with another exit reason
than <strong>normal</strong>, <strong>shutdown</strong>, or <strong>{shutdown,Term}</strong>.</p> <p>The <strong>restart</strong> key is optional. If it is not specified,
it defaults to <strong>permanent</strong>.</p> </li><li> <p><strong>shutdown</strong> defines how a child process must be
terminated. <strong>brutal_kill</strong> means that the child process
is unconditionally terminated using <strong>exit(Child,kill)</strong>.
An integer time-out value means that the supervisor tells
the child process to terminate by calling
<strong>exit(Child,shutdown)</strong> and then wait for an exit signal
with reason <strong>shutdown</strong> back from the child process. If no
exit signal is received within the specified number of milliseconds,
the child process is unconditionally terminated using
<strong>exit(Child,kill)</strong>.</p> <p>If the child process is another supervisor, the shutdown time
must be set to <strong>infinity</strong> to give the subtree ample
time to shut down.</p> <div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Setting the shutdown time to anything other
than <strong>infinity</strong> for a child of type <strong>supervisor</strong>
can cause a race condition where the child in question
unlinks its own children, but fails to terminate them
before it is killed.</p></div> <p>It is also allowed to set it to <strong>infinity</strong>,
if the child process is a worker.</p> <div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Be careful when setting the shutdown time to
<strong>infinity</strong> when the child process is a worker. Because, in this
situation, the termination of the supervision tree depends on the
child process, it must be implemented in a safe way and its cleanup
procedure must always return.</p></div> <p>Notice that all child processes implemented using the standard
OTP behavior modules automatically adhere to the shutdown
protocol.</p> <p>The <strong>shutdown</strong> key is optional. If it is not specified,
it defaults to <strong>5000</strong> if the child is
of type <strong>worker</strong> and it defaults to <strong>infinity</strong> if
the child is of type <strong>supervisor</strong>.</p> </li><li> <p><strong>type</strong> specifies if the child process is a supervisor or
a worker.</p> <p>The <strong>type</strong> key is optional. If it is not specified,
it defaults to <strong>worker</strong>.</p> </li><li> <p><strong>modules</strong> is used by the release handler during code
replacement to determine which processes are using a certain
module. As a rule of thumb, if the child process is a
<strong>supervisor</strong>, <strong>gen_server</strong> or,
<strong>gen_statem</strong>,
this is to be a list with one element <strong>[Module]</strong>,
where <strong>Module</strong> is the callback module. If the child
process is an event manager (<strong>gen_event</strong>) with a
dynamic set of callback modules, value <strong>dynamic</strong>
must be used. For more information about release handling, see
<a href="./release_handling"> Release Handling</a>
in OTP Design Principles.</p> <p>The <strong>modules</strong> key is optional. If it is not specified, it
defaults to <strong>[M]</strong>, where <strong>M</strong> comes from the
child's start <strong>{M,F,A}</strong>.</p> </li><li> <p>Internally, the supervisor also keeps track of the pid
<strong>Child</strong> of the child process, or <strong>undefined</strong> if no
pid exists.</p> </li></ul><h2>Data Types</h2><span class="name">child</span><span class="name">child_id</span><p>Not a <strong>pid()</strong>.</p><span class="name">child_spec</span><p>The tuple format is kept for backward compatibility
only. A map is preferred; see more details
<a href="#child_spec">above</a>.</p><span class="name">mfargs</span><p>Value <strong>undefined</strong> for <strong><span class="anno">A</span></strong> (the
argument list) is only to be used internally
in <strong>supervisor</strong>. If the restart type of the child
is <strong>temporary</strong>, the process is never to be
restarted and therefore there is no need to store the real
argument list. Value <strong>undefined</strong> is then stored instead.</p><span class="name">modules</span><span class="name">restart</span><span class="name">shutdown</span><span class="name">strategy</span><span class="name">sup_flags</span><p>The tuple format is kept for backward compatibility
only. A map is preferred; see more details
<a href="#sup_flags">above</a>.</p><span class="name">sup_ref</span><span class="name">worker</span><h2>Functions</h2><h3>check_childspecs/1</h3><p>Check if children specifications are syntactically correct. </p><p>Takes a list of child specification as argument
and returns <strong>ok</strong> if all of them are syntactically
correct, otherwise <strong>{error,<span class="anno">Error</span>}</strong>.</p><h3>count_children/1</h3><p>Return counts for the number of child specifications, active children, supervisors, and workers.</p><p>Returns a property list (see <a href="proplists">proplists</a>) containing the
counts for each of the following elements of the supervisor's
child specifications and managed processes:</p><ul><li> <p><strong>specs</strong> - The total count of children, dead or alive.</p> </li><li> <p><strong>active</strong> - The count of all actively running child
processes managed by this supervisor. For a
<strong>simple_one_for_one</strong> supervisors, no check is done to ensure
that each child process is still alive, although the result
provided here is likely to be very
accurate unless the supervisor is heavily overloaded.</p> </li><li> <p><strong>supervisors</strong> - The count of all children marked as
<strong>child_type = supervisor</strong> in the specification list,
regardless if the child process is still alive.</p> </li><li> <p><strong>workers</strong> - The count of all children marked as
<strong>child_type = worker</strong> in the specification list,
regardless if the child process is still alive.</p> </li></ul><p>For a description of <strong><span class="anno">SupRef</span></strong>, see
<a href="#SupRef">SupRef</a>.</p><h3>delete_child/2</h3><p>Delete a child specification from a supervisor.</p><p>Tells supervisor <strong><span class="anno">SupRef</span></strong> to delete the child
specification identified by <strong><span class="anno">Id</span></strong>. The corresponding
child process must not be running. Use
<a href="#terminate_child/2">terminate_child/2</a> to terminate it.</p><p>For a description of <strong><span class="anno">SupRef</span></strong>, see
<a href="#SupRef">SupRef</a>.</p><p>If successful, the function returns <strong>ok</strong>. If the child
specification identified by <strong><span class="anno">Id</span></strong> exists but the
corresponding child process is running or is about to be restarted,
the function returns <strong>{error,running}</strong> or
<strong>{error,restarting}</strong>, respectively. If the child specification
identified by <strong><span class="anno">Id</span></strong> does not exist, the function
returns <strong>{error,not_found}</strong>.</p><h3>get_childspec/2</h3><p>Return the child specification map for the specified child.</p><p>Returns the child specification map for the child identified
by <strong>Id</strong> under supervisor <strong>SupRef</strong>. The returned
map contains all keys, both mandatory and optional.</p><p>For a description of <strong><span class="anno">SupRef</span></strong>, see
<a href="#SupRef">SupRef</a>.</p><h3>restart_child/2</h3><p>Restart a terminated child process belonging to a supervisor. </p><p>Tells supervisor <strong><span class="anno">SupRef</span></strong> to restart
a child process corresponding to the child specification
identified by <strong><span class="anno">Id</span></strong>. The child
specification must exist, and the corresponding child process
must not be running.</p><p>Notice that for temporary children, the child specification
is automatically deleted when the child terminates; thus,
it is not possible to restart such children.</p><p>For a description of <strong><span class="anno">SupRef</span></strong>, see
<a href="#SupRef">SupRef</a>.</p><p>If the child specification identified
by <strong><span class="anno">Id</span></strong> does not exist, the function
returns <strong>{error,not_found}</strong>. If the child specification
exists but the corresponding process is already running, the
function returns <strong>{error,running}</strong>.</p><p>If the child process start function
returns <strong>{ok,<span class="anno">Child</span>}</strong>
or <strong>{ok,<span class="anno">Child</span>,<span class="anno">Info</span>}</strong>, the pid
is added to the supervisor and the function returns the same
value.</p><p>If the child process start function returns <strong>ignore</strong>,
the pid remains set to <strong>undefined</strong> and the function
returns <strong>{ok,undefined}</strong>.</p><p>If the child process start function returns an error tuple
or an erroneous value, or if it fails, the function returns
<strong>{error,<span class="anno">Error</span>}</strong>,
where <strong><span class="anno">Error</span></strong> is a term containing
information about the error.</p><h3>start_child/2</h3><p>Dynamically add a child process to a supervisor.</p><ul><li>startchild_ret</li></ul><ul><li>startchild_err</li></ul><p>Dynamically adds a child specification to supervisor
<strong><span class="anno">SupRef</span></strong>, which starts the corresponding child
process.</p><p><a name="SupRef"></a><strong><span class="anno">SupRef</span></strong> can be any of the
following:</p><ul><li>The pid</li><li><strong>Name</strong>, if the supervisor is locally registered</li><li><strong>{Name,Node}</strong>, if the supervisor is locally registered at another node</li><li><strong>{global,Name}</strong>, if the supervisor is globally registered</li><li><strong>{via,Module,Name}</strong>, if the supervisor is registered through an alternative process registry</li></ul><p><strong><span class="anno">ChildSpec</span></strong> must be a valid child specification
(unless the supervisor is a <strong>simple_one_for_one</strong>
supervisor; see below). The child process is started by
using the start function as defined in the child specification.</p><p>For a <strong>simple_one_for_one</strong> supervisor,
the child specification defined in <strong>Module:init/1</strong> is used,
and <strong><span class="anno">ChildSpec</span></strong> must instead be an arbitrary
list of terms <strong><span class="anno">List</span></strong>. The child process is then
started by appending <strong><span class="anno">List</span></strong> to the existing start
function arguments, that is, by calling
<strong>apply(M, F, A++<span class="anno">List</span>)</strong>, where <strong>{M,F,A}</strong> is the
start function defined in the child specification.</p><ul><li> <p>If there already exists a child specification with the specified
identifier, <strong><span class="anno">ChildSpec</span></strong> is discarded, and
the function returns <strong>{error,already_present}</strong> or
<strong>{error,{already_started,<span class="anno">Child</span>}}</strong>, depending on
if the corresponding child process is running or not.</p> </li><li> <p>If the child process start function returns
<strong>{ok,<span class="anno">Child</span>}</strong> or
<strong>{ok,<span class="anno">Child</span>,<span class="anno">Info</span>}</strong>, the child
specification and pid are added to the supervisor and the
function returns the same value.</p> </li><li> <p>If the child process start function returns <strong>ignore</strong>,
the child specification is added to the supervisor (unless the
supervisor is a <strong>simple_one_for_one</strong> supervisor, see below),
the pid is set to <strong>undefined</strong>, and the function returns
<strong>{ok,undefined}</strong>.</p> </li></ul><p>For a <strong>simple_one_for_one</strong> supervisor, when a child
process start function returns <strong>ignore</strong>, the functions returns
<strong>{ok,undefined}</strong> and no child is added to the supervisor.</p><p>If the child process start function returns an error tuple or
an erroneous value, or if it fails, the child specification is
discarded, and the function returns <strong>{error,Error}</strong>, where
<strong>Error</strong> is a term containing information about the error
and child specification.</p><h3>start_link/2</h3><h3>start_link/3</h3><p>Create a supervisor process.</p><ul><li>startlink_ret</li></ul><ul><li>startlink_err</li></ul><ul><li>sup_name</li></ul><p>Creates a supervisor process as part of a supervision tree.
For example, the function ensures that the supervisor is linked to
the calling process (its supervisor).</p><p>The created supervisor process calls
<strong><span class="anno">Module</span>:init/1</strong> to
find out about restart strategy, maximum restart intensity,
and child processes. To ensure a synchronized startup
procedure, <strong>start_link/2,3</strong> does not return until
<strong><span class="anno">Module</span>:init/1</strong> has returned and all child
processes have been started.</p><ul><li> <p>If <strong><span class="anno">SupName</span>={local,Name}</strong>, the supervisor is
registered locally as <strong>Name</strong> using <strong>register/2</strong>.</p> </li><li> <p>If <strong><span class="anno">SupName</span>={global,Name}</strong>, the supervisor is
registered globally as <strong>Name</strong> using
<a href="../kernel/global#register_name/2">kernel/global#register_name/2</a>.</p> </li><li> <p>If
<strong><span class="anno">SupName</span>={via,<span class="anno">Module</span>,<span class="anno">Name</span>}</strong>,
the supervisor is registered as <strong>Name</strong> using the registry
represented by <strong>Module</strong>. The <strong>Module</strong> callback must
export the functions <strong>register_name/2</strong>,
<strong>unregister_name/1</strong>, and <strong>send/2</strong>, which must behave
like the corresponding functions in
<a href="./global">kernel/global</a>. Thus,
<strong>{via,global,<span class="anno">Name</span>}</strong> is a valid reference.</p> </li></ul><p>If no name is provided, the supervisor is not registered.</p><p><strong><span class="anno">Module</span></strong> is the name of the callback module.</p><p><strong><span class="anno">Args</span></strong> is any term that is passed as
the argument to <strong><span class="anno">Module</span>:init/1</strong>.</p><ul><li> <p>If the supervisor and its child processes are successfully
created (that is, if all child process start functions return
<strong>{ok,Child}</strong>, <strong>{ok,Child,Info}</strong>, or <strong>ignore</strong>),
the function returns <strong>{ok,Pid}</strong>, where <strong>Pid</strong> is
the pid of the supervisor.</p> </li><li> <p>If there already exists a process with the specified
<strong><span class="anno">SupName</span></strong>, the function returns
<strong>{error,{already_started,Pid}}</strong>, where <strong>Pid</strong> is
the pid of that process.</p> </li><li> <p>If <strong><span class="anno">Module</span>:init/1</strong> returns <strong>ignore</strong>, this
function returns <strong>ignore</strong> as well, and the supervisor
terminates with reason <strong>normal</strong>.</p> </li><li> <p>If <strong><span class="anno">Module</span>:init/1</strong> fails or returns an
incorrect value, this function returns <strong>{error,Term}</strong>, where
<strong>Term</strong> is a term with information about the error, and the
supervisor terminates with reason <strong>Term</strong>.</p> </li><li> <p>If any child process start function fails or returns an error
tuple or an erroneous value, the supervisor first terminates
all already started child processes with reason <strong>shutdown</strong>
and then terminate itself and returns
<strong>{error, {shutdown, Reason}}</strong>.</p> </li></ul><h3>terminate_child/2</h3><p>Terminate a child process belonging to a supervisor.</p><p>Tells supervisor <strong><span class="anno">SupRef</span></strong> to terminate the
specified child.</p><p>If the supervisor is not <strong>simple_one_for_one</strong>,
<strong><span class="anno">Id</span></strong> must be the child specification
identifier. The process, if any, is terminated and,
unless it is a temporary child, the child specification is
kept by the supervisor. The child process can later be
restarted by the supervisor. The child process can also be
restarted explicitly by calling
<a href="#restart_child/2">restart_child/2</a>.
Use
<a href="#delete_child/2">delete_child/2</a>
to remove the child specification.</p><p>If the child is temporary, the child specification is deleted as
soon as the process terminates. This means
that <strong>delete_child/2</strong> has no meaning
and <strong>restart_child/2</strong> cannot be used for these children.</p><p>If the supervisor is <strong>simple_one_for_one</strong>,
<strong><span class="anno">Id</span></strong>
must be the <strong>pid()</strong> of the child process. If the specified
process is alive, but is not a child of the specified
supervisor, the function returns
<strong>{error,not_found}</strong>. If the child specification
identifier is specified instead of a <strong>pid()</strong>, the
function returns <strong>{error,simple_one_for_one}</strong>.</p><p>If successful, the function returns <strong>ok</strong>. If there is
no child specification with the specified <strong><span class="anno">Id</span></strong>, the
function returns <strong>{error,not_found}</strong>.</p><p>For a description of <strong><span class="anno">SupRef</span></strong>, see
<a href="#SupRef">SupRef</a>.</p><h3>which_children/1</h3><p>Return information about all children specifications and child processes belonging to a supervisor.</p><p>Returns a newly created list with information about all child
specifications and child processes belonging to
supervisor <strong><span class="anno">SupRef</span></strong>.</p><p>Notice that calling this function when supervising many
childrens under low memory conditions can cause an
out of memory exception.</p><p>For a description of <strong><span class="anno">SupRef</span></strong>, see
<a href="#SupRef">SupRef</a>.</p><p>The following information is given for each child
specification/process:</p><ul><li> <p><strong><span class="anno">Id</span></strong> - As defined in the child specification or
<strong>undefined</strong> for a <strong>simple_one_for_one</strong> supervisor.</p> </li><li> <p><strong><span class="anno">Child</span></strong> - The pid of the corresponding child
process, the atom <strong>restarting</strong> if the process is about to be
restarted, or <strong>undefined</strong> if there is no such process.</p> </li><li> <p><strong><span class="anno">Type</span></strong> - As defined in the child
specification.</p> </li><li> <p><strong><span class="anno">Modules</span></strong> - As defined in the child
specification.</p> </li></ul><h3>Callback Functions</h3><p>The following function must be exported from a
<strong>supervisor</strong> callback module.</p><h2>Functions</h2><h3>Module:init(Args) -&gt; Result</h3><p>Return a supervisor specification.</p><ul><li><span class="v">Args = term()</span></li><li><span class="v">Result = {ok,{SupFlags,[ChildSpec]}} | ignore</span></li><li><span class="v">SupFlags = </span></li><li><span class="v">ChildSpec = </span></li></ul><p>Whenever a supervisor is started using
<a href="#start_link/2">start_link/2</a>,
this function is called by
the new process to find out about restart strategy, maximum
restart intensity, and child specifications.</p><p><strong>Args</strong> is the <strong>Args</strong> argument provided to the start
function.</p><p><strong>SupFlags</strong> is the supervisor flags defining the
restart strategy and maximum restart intensity for the
supervisor. <strong>[ChildSpec]</strong> is a list of valid child
specifications defining which child processes the supervisor
must start and monitor. See the discussion in section
<a href="#supervision_princ">supervision_princ</a> earlier.</p><p>Notice that when the restart strategy is
<strong>simple_one_for_one</strong>, the list of child specifications
must be a list with one child specification only.
(The child specification identifier is ignored.)
No child process is then started
during the initialization phase, but all children are assumed
to be started dynamically using
<a href="#start_child/2">start_child/2</a>.</p><p>The function can also return <strong>ignore</strong>.</p><p>Notice that this function can also be called as a part of a code
upgrade procedure. Therefore, the function is not to have any side
effects. For more information about code upgrade of supervisors, see
section
<a href="../doc/design_principles/appup_cookbook#sup">Changing a Supervisor</a> in OTP Design Principles.</p><h3>See Also</h3><p><a href="gen_event">gen_event</a>, 
<a href="gen_statem">gen_statem</a>,
<a href="gen_server">gen_server</a>, 
<a href="sys">sys</a></p><h2>supervisor_bridge</h2><p>Generic supervisor bridge behavior.</p><p>This behavior module provides a supervisor bridge, a process
that connects a subsystem not designed according to the OTP design
principles to a supervision tree. The supervisor bridge sits between
a supervisor and the subsystem. It behaves like a real supervisor to
its own supervisor, but has a different interface than a real
supervisor to the subsystem. For more information, see
<a href="./sup_princ"> Supervisor Behaviour</a> in OTP Design Principles.
A supervisor bridge assumes the functions for starting and stopping
the subsystem to be located in a callback module exporting a
predefined set of functions.The <a href="sys">sys</a> module can be used
for debugging a supervisor bridge.Unless otherwise stated, all functions in this module fail if
the specified supervisor bridge does not exist or if bad arguments are
specified.</p><h2>Functions</h2><h3>start_link/2</h3><h3>start_link/3</h3><p>Create a supervisor bridge process.</p><p>Creates a supervisor bridge process, linked to the calling process,
which calls <strong><span class="anno">Module</span>:init/1</strong> to start the subsystem.
To ensure a synchronized startup procedure, this function does
not return until <strong><span class="anno">Module</span>:init/1</strong> has returned.</p><ul><li> <p>If <strong><span class="anno">SupBridgeName</span>={local,<span class="anno">Name</span>}</strong>,
the supervisor bridge is registered locally as
<strong><span class="anno">Name</span></strong> using <strong>register/2</strong>.</p> </li><li> <p>If <strong><span class="anno">SupBridgeName</span>={global,<span class="anno">Name</span>}</strong>,
the supervisor bridge is registered globally as
<strong><span class="anno">Name</span></strong> using
<a href="../kernel/global#register_name/2">kernel/global#register_name/2</a>.</p> </li><li> <p>If
<strong><span class="anno">SupBridgeName</span>={via,<span class="anno">Module</span>,<span class="anno">Name</span>}</strong>,
the supervisor bridge is registered as <strong><span class="anno">Name</span></strong>
using a registry represented by <span class="anno">Module</span>. The
<strong>Module</strong> callback is to export functions
<strong>register_name/2</strong>, <strong>unregister_name/1</strong>, and <strong>send/2</strong>,
which are to behave like the corresponding functions in
<a href="./global">kernel/global</a>.
Thus, <strong>{via,global,GlobalName}</strong> is a valid reference.</p> </li></ul><p>If no name is provided, the supervisor bridge is not registered.</p><p><strong><span class="anno">Module</span></strong> is the name of the callback module.</p><p><strong><span class="anno">Args</span></strong> is an arbitrary term that is passed as the
argument to <strong><span class="anno">Module</span>:init/1</strong>.</p><ul><li> <p>If the supervisor bridge and the subsystem are successfully
started, the function returns <strong>{ok,<span class="anno">Pid</span>}</strong>, where
<strong><span class="anno">Pid</span></strong> is is the pid of the supervisor
bridge.</p> </li><li> <p>If there already exists a process with the specified
<strong><span class="anno">SupBridgeName</span></strong>, the function returns
<strong>{error,{already_started,<span class="anno">Pid</span>}}</strong>, where
<strong><span class="anno">Pid</span></strong> is the pid of that process.</p> </li><li> <p>If <strong><span class="anno">Module</span>:init/1</strong> returns <strong>ignore</strong>, this
function returns <strong>ignore</strong> as well and the supervisor bridge
terminates with reason <strong>normal</strong>.</p> </li><li> <p>If <strong><span class="anno">Module</span>:init/1</strong> fails or returns an error
tuple or an incorrect value, this function returns
<strong>{error,<span class="anno">Error</span>r}</strong>, where
<strong><span class="anno">Error</span></strong> is a term with information about the
error, and the supervisor bridge
terminates with reason <strong><span class="anno">Error</span></strong>.</p> </li></ul><h3>Callback Functions</h3><p>The following functions must be exported from a
<strong>supervisor_bridge</strong> callback module.</p><h2>Functions</h2><h3>Module:init(Args) -&gt; Result</h3><p>Initialize process and start subsystem.</p><ul><li><span class="v">Args = term()</span></li><li><span class="v">Result = {ok,Pid,State} | ignore | {error,Error}</span></li><li><span class="v">Pid = pid()</span></li><li><span class="v">State = term()</span></li><li><span class="v">Error = term()</span></li></ul><p>Whenever a supervisor bridge is started using
<a href="#start_link/2">start_link/2</a>,
this function is called
by the new process to start the subsystem and initialize.</p><p><strong>Args</strong> is the <strong>Args</strong> argument provided to the start
function.</p><p>The function is to return <strong>{ok,Pid,State}</strong>, where <strong>Pid</strong>
is the pid of the main process in the subsystem and <strong>State</strong>
is any term.</p><p>If later <strong>Pid</strong> terminates with a reason <strong>Reason</strong>,
the supervisor bridge terminates with reason <strong>Reason</strong> as well.
If later the supervisor bridge is stopped by its supervisor with
reason <strong>Reason</strong>, it calls
<strong>Module:terminate(Reason,State)</strong> to terminate.</p><p>If the initialization fails, the function is to return
<strong>{error,Error}</strong>, where <strong>Error</strong> is any term,
or <strong>ignore</strong>.</p><h3>Module:terminate(Reason, State)</h3><p>Clean up and stop subsystem.</p><ul><li><span class="v">Reason = shutdown | term()</span></li><li><span class="v">State = term()</span></li></ul><p>This function is called by the supervisor bridge when it is about
to terminate. It is to be the opposite of <strong>Module:init/1</strong>
and stop the subsystem and do any necessary cleaning up.
The return value is ignored.</p><p><strong>Reason</strong> is <strong>shutdown</strong> if the supervisor bridge is
terminated by its supervisor. If the supervisor bridge terminates
because a a linked process (apart from the main process of
the subsystem) has terminated with reason <strong>Term</strong>,
then <strong>Reason</strong> becomes <strong>Term</strong>.</p><p><strong>State</strong> is taken from the return value of
<strong>Module:init/1</strong>.</p><h3>See Also</h3><p><a href="supervisor">supervisor</a>, 
<a href="sys">sys</a></p><h2>sys</h2><p>A functional interface to system messages.</p><p>This module contains functions for sending system messages used by
programs, and messages used for debugging purposes.Functions used for implementation of processes are also expected to
understand system messages, such as debug messages and code change. These
functions must be used to implement the use of system messages for a
process; either directly, or through standard behaviors, such as
<a href="gen_server">gen_server</a>.The default time-out is 5000 ms, unless otherwise specified.
<strong>timeout</strong> defines the time to wait for the process to
respond to a request. If the process does not respond, the
function evaluates <strong>exit({timeout, {M, F, A}})</strong>.
<a name="dbg_opt"></a>The functions make references to a debug structure.
The debug structure is a list of <strong>dbg_opt()</strong>, which is an internal
data type used by function <a href="#handle_system_msg/6">handle_system_msg/6</a>. No debugging is performed if it is 
an empty list.</p><h3>System Messages</h3><p>Processes that are not implemented as one of the standard
behaviors must still understand system messages. The following 
three messages must be understood:</p><ul><li> <p>Plain system messages. These are received as
<strong>{system, From, Msg}</strong>. The content and meaning of
this message are not interpreted by the
receiving process module. When a system message is received, function 
<a href="#handle_system_msg/6">handle_system_msg/6</a>
is called to handle the request.</p> </li><li> <p>Shutdown messages. If the process traps exits, it must
be able to handle a shutdown request from its parent, the
supervisor. The message <strong>{'EXIT', Parent, Reason}</strong>
from the parent is an order to terminate. The process must 
terminate when this message is received, normally with the
same <strong>Reason</strong> as <strong>Parent</strong>.
</p> </li><li> <p>If the modules used to implement the process change dynamically
during runtime, the process must understand one more message. An
example is the <a href="gen_event">gen_event</a>
processes. The message is <strong>{_Label, {From, Ref}, get_modules}</strong>.
The reply to this message is <strong>From ! {Ref, Modules}</strong>, where
<strong>Modules</strong> is a list of the currently active modules in the
process.</p> <p>This message is used by the release handler to find which
processes that execute a certain module. The process can later be
suspended and ordered to perform a code change for one of its
modules.</p> </li></ul><h3>System Events</h3><p>When debugging a process with the functions of this
module, the process generates <em>system_events</em>, which are
then treated in the debug function. For example, <strong>trace</strong>
formats the system events to the terminal.
</p><p>Four predefined system events are used when a
process receives or sends a message. The process can also define its
own system events. It is always up to the process itself
to format these events.</p><h2>Data Types</h2><span class="name">name</span><span class="name">system_event</span><dl><dt><strong>{in,<span class="anno">Msg</span>}</strong></dt><dd> <p>
Is produced by <strong>gen_server</strong> and <strong>gen_event</strong>
when the message <strong>Msg</strong> arrives.
</p> </dd><dt><strong>{in,<span class="anno">Msg</span>,<span class="anno">State</span>}</strong></dt><dd> <p>
Is produced by <strong>gen_statem</strong>
when the message <strong>Msg</strong> arrives in state <strong>State</strong>.
</p> <p>
For <strong>gen_statem</strong> the <strong><span class="anno">Msg</span></strong> term is
an <strong>{EventType,EventContent}</strong> tuple.
</p> </dd><dt><strong>{out,<span class="anno">Msg</span>,<span class="anno">To</span>}</strong></dt><dd> <p>
Is produced by <strong>gen_statem</strong> when the reply <strong>Msg</strong>
is sent back to <strong>To</strong> by returning
a <strong>{reply,To,Msg}</strong> action from the callback module.
</p> <p>
<strong><span class="anno">To</span></strong> is of the same type
as the first argument to <strong>gen_statem:reply/2</strong>.
</p> </dd><dt> <strong>{out,<span class="anno">Msg</span>,<span class="anno">To</span>,<span class="anno">State</span>}</strong> </dt><dd> <p>
Is produced by <strong>gen_server</strong>
when the reply <strong><span class="anno">Msg</span></strong>
is sent back to <strong><span class="anno">To</span></strong>
by returning a <strong>{reply,...}</strong> tuple
from the callback module.
</p> <p>
<strong><span class="anno">To</span></strong> is of the same type
as the first argument to <strong>gen_server:reply/2</strong>.
</p> <p>
<strong><span class="anno">State</span></strong> is the new server state.
</p> </dd><dt> <strong>{noreply,<span class="anno">State</span>}</strong> </dt><dd> <p>
Is produced by <strong>gen_server</strong>
when a <strong>{noreply,...}</strong> tuple is returned
from the callback module.
</p> <p>
<strong><span class="anno">State</span></strong> is the new server state.
</p> </dd><dt> <strong>{continue,<span class="anno">Continuation</span>}</strong> </dt><dd> <p>
Is produced by <strong>gen_server</strong>
when a <strong>{continue,<span class="anno">Continuation</span>}</strong>
tuple is returned from the callback module.
</p> </dd><dt> <strong>{code_change,<span class="anno">Event</span>,<span class="anno">State</span>}</strong> </dt><dd> <p>
Is produced by <strong>gen_statem</strong>
when the message <strong><span class="anno">Event</span></strong>
arrives in state <strong><span class="anno">State</span></strong>
as the first event after a code change.
</p> <p>
<strong><span class="anno">Event</span></strong> is
an <strong>{EventType,EventContent}</strong> tuple.
</p> </dd><dt> <strong> {postpone,<span class="anno">Event</span>,<span class="anno">State</span>,<span class="anno">NextState</span>} </strong> </dt><dd> <p>
Is produced by <strong>gen_statem</strong>
when the message <strong><span class="anno">Event</span></strong>
is postponed in state <strong><span class="anno">State</span></strong>.
<strong><span class="anno">NextState</span></strong> is the new state.
</p> <p>
<strong><span class="anno">Event</span></strong> is
an <strong>{EventType,EventContent}</strong> tuple.
</p> </dd><dt> <strong> {consume,<span class="anno">Event</span>,<span class="anno">State</span>,<span class="anno">NextState</span>} </strong> </dt><dd> <p>
Is produced by <strong>gen_statem</strong>
when the message <strong><span class="anno">Event</span></strong>
is consumed in state <strong><span class="anno">State</span></strong>.
<strong><span class="anno">NextState</span></strong> is the new state.
</p> <p>
<strong><span class="anno">Event</span></strong> is
an <strong>{EventType,EventContent}</strong> tuple.
</p> </dd><dt> <strong> {enter,<span class="anno">State</span>} </strong> </dt><dd> <p>
Is produced by <strong>gen_statem</strong>
when the first state <strong><span class="anno">State</span></strong> is entered.
</p> </dd><dt> <strong> {terminate,<span class="anno">Reason</span>,<span class="anno">State</span>} </strong> </dt><dd> <p>
Is produced by <strong>gen_statem</strong>
when it terminates with reason <strong><span class="anno">Reason</span></strong>
in state <strong><span class="anno">State</span></strong>.
</p> </dd></dl><span class="name">dbg_opt</span><p>See the introduction of this manual page.</p><span class="name">dbg_fun</span><span class="name">debug_option</span><span class="name">format_fun</span><h2>Functions</h2><h3>change_code/4</h3><h3>change_code/5</h3><p>Send the code change system message to the process.</p><p>Tells the process to change code. The process must be
suspended to handle this message. Argument <strong><span class="anno">Extra</span></strong>
is reserved for each process to use as its own. Function
<strong><span class="anno">Module</span>:system_code_change/4</strong> is called.
<strong><span class="anno">OldVsn</span></strong> is the old version of the
<strong><span class="anno">Module</span></strong>.</p><h3>get_state/1</h3><h3>get_state/2</h3><p>Get the state of the process.</p><p>Gets the state of the process.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>These functions are intended only to help with debugging. They are
provided for convenience, allowing developers to avoid having to
create their own state extraction functions and also avoid having
to interactively extract the state from the return values of
<a href="#get_status-1">get_status-1</a> or
<a href="#get_status-2">get_status-2</a>
while debugging.</p></div><p>The value of <strong><span class="anno">State</span></strong> varies for different types of
processes, as follows:</p><ul><li> <p>For a
<a href="gen_server">gen_server</a>
process, the returned <strong><span class="anno">State</span></strong>
is the state of the callback module.</p> </li><li> <p>For a
<a href="gen_statem">gen_statem</a>
process, <strong><span class="anno">State</span></strong> is the tuple
<strong>{CurrentState,CurrentData}</strong>.</p> </li><li> <p>For a
<a href="gen_event">gen_event</a>
process, <strong><span class="anno">State</span></strong> is a list of tuples,
where each tuple corresponds to an event handler registered
in the process and contains <strong>{Module, Id, HandlerState}</strong>,
as follows:</p> <dl><dt><strong>Module</strong></dt><dd> <p>The module name of the event handler.</p> </dd><dt><strong>Id</strong></dt><dd> <p>The ID of the handler (which is <strong>false</strong> if it was 
registered without an ID).</p> </dd><dt><strong>HandlerState</strong></dt><dd> <p>The state of the handler.</p> </dd></dl> </li></ul><p>If the callback module exports a function <strong>system_get_state/1</strong>,
it is called in the target process to get its state. Its argument is
the same as the <strong>Misc</strong> value returned by
<a href="#get_status-1">get_status-1</a>, and
function <a href="#Module:system_get_state/1">Module:system_get_state/1</a> is expected to extract the
state of the callback module from it. Function
<strong>system_get_state/1</strong> must return <strong>{ok, State}</strong>, where
<strong>State</strong> is the state of the callback module.</p><p>If the callback module does not export a <strong>system_get_state/1</strong>
function, <strong>get_state/1,2</strong> assumes that the <strong>Misc</strong> value is
the state of the callback module and returns it directly instead.</p><p>If the callback module's <strong>system_get_state/1</strong> function crashes
or throws an exception, the caller exits with error 
<strong>{callback_failed, {Module, system_get_state}, {Class, Reason}}</strong>,
where <strong>Module</strong> is the name of the callback module and
<strong>Class</strong> and <strong>Reason</strong> indicate details of the exception.</p><p>Function <strong>system_get_state/1</strong> is primarily useful for
user-defined behaviors and modules that implement OTP
<a href="#special_process">special processes</a>. 
The <strong>gen_server</strong>,
<strong>gen_statem</strong>, and <strong>gen_event</strong> OTP
behavior modules export this function, so callback modules for those
behaviors need not to supply their own.</p><p>For more information about a process, including its state, see
<a href="#get_status-1">get_status-1</a> and
<a href="#get_status-2">get_status-2</a>.</p><h3>get_status/1</h3><h3>get_status/2</h3><p>Get the status of the process.</p><p>Gets the status of the process.</p><p>The value of <strong><span class="anno">Misc</span></strong> varies for different types of
processes, for example:</p><ul><li> <p>A <a href="gen_server">gen_server</a>
process returns the state of the callback module.</p> </li><li> <p>A <a href="gen_statem">gen_statem</a>
process returns information, such as its current
state name and state data.</p> </li><li> <p>A <a href="gen_event">gen_event</a>
process returns information about each of its
registered handlers.</p> </li></ul><p>Callback modules for <strong>gen_server</strong>,
<strong>gen_statem</strong>, and <strong>gen_event</strong>
can also change the value of <strong><span class="anno">Misc</span></strong>
by exporting a function <strong>format_status/2</strong>, which contributes
module-specific information. For details, see
<a href="./gen_server#Module:format_status/2">gen_server#Module:format_status/2</a>,
<a href="./gen_statem#Module:format_status/2">gen_statem#Module:format_status/2</a>, and
<a href="./gen_event#Module:format_status/2">gen_event#Module:format_status/2</a>.</p><h3>install/2</h3><h3>install/3</h3><p>Install a debug function in the process.</p><p>Enables installation of alternative debug functions. An example of
such a function is a trigger, a function that waits for some
special event and performs some action when the event is
generated. For example, turning on low-level tracing.</p><p><strong><span class="anno">Func</span></strong> is called whenever a system event is
generated. This function is to return <strong>done</strong>, or a new
<strong>Func</strong> state. In the first case, the function is removed. It is 
also removed if the function fails. If one debug function should be 
installed more times, a unique <strong><span class="anno">FuncId</span></strong> must be 
specified for each installation.</p><h3>log/2</h3><h3>log/3</h3><p>Log system events in memory.</p><p>Turns the logging of system events on or off. If on, a
maximum of <strong><span class="anno">N</span></strong> events are kept in the
debug structure (default is 10).</p><p>If <strong><span class="anno">Flag</span></strong> is <strong>get</strong>, a list of all logged
events is returned.</p><p>If <strong><span class="anno">Flag</span></strong> is <strong>print</strong>, the logged events
are printed to <strong>standard_io</strong>.</p><p>The events are formatted with a function that is defined by the
process that generated the event (with a call to
<a href="#handle_debug/4"> )</a>.</p><h3>log_to_file/2</h3><h3>log_to_file/3</h3><p>Log system events to the specified file.</p><p>Enables or disables the logging of all system events in text
format to the file. The events are formatted with a function that is 
defined by the process that generated the event (with a call to
<a href="#handle_debug/4">handle_debug/4</a>).
The file is opened with encoding UTF-8.</p><h3>no_debug/1</h3><h3>no_debug/2</h3><p>Turn off debugging.</p><p>Turns off all debugging for the process. This includes
functions that are installed explicitly with function
<a href="#install/2">install/2</a>,
for example, triggers.</p><h3>remove/2</h3><h3>remove/3</h3><p>Remove a debug function from the process.</p><p>Removes an installed debug function from the
process. <strong><span class="anno">Func</span></strong> or <strong><span class="anno">FuncId</span></strong> must be 
the same as previously installed.</p><h3>replace_state/2</h3><h3>replace_state/3</h3><p>Replace the state of the process.</p><p>Replaces the state of the process, and returns the new state.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>These functions are intended only to help with debugging, and are
not to be called from normal code. They are provided for
convenience, allowing developers to avoid having to create their own
custom state replacement functions.</p></div><p>Function <strong><span class="anno">StateFun</span></strong> provides a new state for the
process. Argument <strong><span class="anno">State</span></strong> and the
<strong><span class="anno">NewState</span></strong> return value of
<strong><span class="anno">StateFun</span></strong> vary for different types of 
processes as follows:</p><ul><li> <p>For a <a href="gen_server">gen_server</a>
process, <strong><span class="anno">State</span></strong> is the state of the callback
module and <strong><span class="anno">NewState</span></strong> 
is a new instance of that state.</p> </li><li> <p>For a <a href="gen_statem">gen_statem</a>
process, <strong><span class="anno">State</span></strong> is the
tuple <strong>{CurrentState,CurrentData}</strong>,
and <strong><span class="anno">NewState</span></strong> is a
similar tuple, which can contain
a new current state, new state data, or both.</p> </li><li> <p>For a <a href="gen_event">gen_event</a>
process, <strong><span class="anno">State</span></strong> is the
tuple <strong>{Module, Id, HandlerState}</strong> as follows:</p> <dl><dt><strong>Module</strong></dt><dd> <p>The module name of the event handler.</p> </dd><dt><strong>Id</strong></dt><dd> <p>The ID of the handler (which is <strong>false</strong> if it was
registered without an ID).</p> </dd><dt><strong>HandlerState</strong></dt><dd> <p>The state of the handler.</p> </dd></dl> <p><strong><span class="anno">NewState</span></strong> is a similar tuple where
<strong>Module</strong> and <strong>Id</strong> are to have the same values as in
<strong><span class="anno">State</span></strong>, but the value of <strong>HandlerState</strong>
can be different. Returning a <strong><span class="anno">NewState</span></strong>, whose
<strong>Module</strong> or <strong>Id</strong> values differ from those of
<strong><span class="anno">State</span></strong>, leaves the state of the event handler
unchanged. For a <strong>gen_event</strong> process,
<strong><span class="anno">StateFun</span></strong> is called once for each event handler
registered in the <strong>gen_event</strong> process.</p> </li></ul><p>If a <strong><span class="anno">StateFun</span></strong> function decides not to effect any
change in process state, then regardless of process type, it can
return its <strong><span class="anno">State</span></strong> argument.</p><p>If a <strong><span class="anno">StateFun</span></strong> function crashes or throws an
exception, the original state of the process is unchanged for
<strong>gen_server</strong>, and <strong>gen_statem</strong> processes.
For <strong>gen_event</strong> processes, a crashing or
failing <strong><span class="anno">StateFun</span></strong> function
means that only the state of the particular event handler it was
working on when it failed or crashed is unchanged; it can still
succeed in changing the states of other event
handlers registered in the same <strong>gen_event</strong> process.</p><p>If the callback module exports a 
<a href="#Module:system_replace_state/2">Module:system_replace_state/2</a> function, it is called in the
target process to replace its state using <strong>StateFun</strong>. Its two
arguments are <strong>StateFun</strong> and <strong>Misc</strong>, where 
<strong>Misc</strong> is the same as the <strong>Misc</strong> value returned by
<a href="#get_status-1">get_status-1</a>.
A <strong>system_replace_state/2</strong> function is expected to return 
<strong>{ok, NewState, NewMisc}</strong>, where <strong>NewState</strong> is the new state
of the callback module, obtained by calling <strong>StateFun</strong>, and
<strong>NewMisc</strong> is
a possibly new value used to replace the original <strong>Misc</strong>
(required as <strong>Misc</strong> often contains the state of the callback
module within it).</p><p>If the callback module does not export a
<strong>system_replace_state/2</strong> function,
<a href="#replace_state/2">replace_state/2</a>
assumes that <strong>Misc</strong> is the state of the callback module,
passes it to <strong>StateFun</strong> and uses the return value as
both the new state and as the new value of <strong>Misc</strong>.</p><p>If the callback module's function <strong>system_replace_state/2</strong>
crashes or throws an exception, the caller exits with error
<strong>{callback_failed, {Module, system_replace_state}, {Class, Reason}}</strong>, where <strong>Module</strong> is the name of the callback module
and <strong>Class</strong> and <strong>Reason</strong> indicate details of the exception.
If the callback module does not provide a
<strong>system_replace_state/2</strong> function and <strong>StateFun</strong> crashes or
throws an exception, the caller exits with error
<strong>{callback_failed, StateFun, {Class, Reason}}</strong>.</p><p>Function <strong>system_replace_state/2</strong> is primarily useful for
user-defined behaviors and modules that implement OTP
<a href="#special_process">special processes</a>. The
OTP behavior modules <strong>gen_server</strong>,
<strong>gen_statem</strong>, and <strong>gen_event</strong>
export this function, so callback modules for those
behaviors need not to supply their own.</p><h3>resume/1</h3><h3>resume/2</h3><p>Resume a suspended process.</p><p>Resumes a suspended process.</p><h3>statistics/2</h3><h3>statistics/3</h3><p>Enable or disable the collections of statistics.</p><p>Enables or disables the collection of statistics. If 
<strong><span class="anno">Flag</span></strong> is <strong>get</strong>, 
the statistical collection is returned.</p><h3>suspend/1</h3><h3>suspend/2</h3><p>Suspend the process.</p><p>Suspends the process. When the process is suspended, it
only responds to other system messages, but not other
messages.</p><h3>terminate/2</h3><h3>terminate/3</h3><p>Terminate the process.</p><p>Orders the process to terminate with the
specified <strong><span class="anno">Reason</span></strong>. The termination is done
asynchronously, so it is not guaranteed that the process is
terminated when the function returns.</p><h3>trace/2</h3><h3>trace/3</h3><p>Print all system events on <strong>standard_io</strong>.</p><p>Prints all system events on <strong>standard_io</strong>. The events are
formatted with a function that is defined by the process that
generated the event (with a call to
<a href="#handle_debug/4">handle_debug/4</a>).
</p><h3>Process Implementation Functions</h3><a name="special_process"></a><p>The following functions are used when implementing a
special process. This is an ordinary process, which does not use a
standard behavior, but a process that understands the standard system
messages.</p><h2>Functions</h2><h3>debug_options/1</h3><p>Convert a list of options to a debug structure.</p><p>Can be used by a process that initiates a debug
structure from a list of options. The values of argument
<strong><span class="anno">Opt</span></strong> are the same as for the corresponding
functions.</p><h3>get_debug/3</h3><p>Get the data associated with a debug option.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>
<strong>get_debug/3</strong> is deprecated since it returns
data of an internal type only useful for debugging.
</p></div><p>Gets the data associated with a debug option.
<strong><span class="anno">Default</span></strong>
is returned if <strong><span class="anno">Item</span></strong> is not found. Can be
used by the process to retrieve debug data for printing before it
terminates.</p><h3>handle_debug/4</h3><p>Generate a system event.</p><p>This function is called by a process when it generates a
system event. <strong><span class="anno">FormFunc</span></strong> is a formatting
function, called as <strong><span class="anno">FormFunc</span>(Device, <span class="anno">Event</span>, <span class="anno">Extra</span>)</strong> to print the events, 
which is necessary if tracing is activated.
<strong><span class="anno">Extra</span></strong> is any extra information that the
process needs in the format function, for example, the process
name.</p><h3>handle_system_msg/6</h3><p>Take care of system messages.</p><p>This function is used by a process module to take care of system
messages. The process receives a 
<strong>{system, <span class="anno">From</span>, <span class="anno">Msg</span>}</strong> message and
passes <strong><span class="anno">Msg</span></strong> and <strong><span class="anno">From</span></strong> to this
function.</p><p>This function <em>never</em> returns. It calls either of the
following functions:</p><ul><li> <p><strong><span class="anno">Module</span>:system_continue(<span class="anno">Parent</span>, NDebug, <span class="anno">Misc</span>)</strong>,
where the process continues the execution.</p> </li><li> <p><strong><span class="anno">Module</span>:system_terminate(Reason, <span class="anno">Parent</span>, <span class="anno">Debug</span>, <span class="anno">Misc</span>)</strong>,
if the process is to terminate.</p> </li></ul><p><strong><span class="anno">Module</span></strong> must export the following:</p><ul><li><strong>system_continue/3</strong></li><li><strong>system_terminate/4</strong></li><li><strong>system_code_change/4</strong></li><li><strong>system_get_state/1</strong></li><li><strong>system_replace_state/2</strong></li></ul><p>Argument <strong><span class="anno">Misc</span></strong> can be used to save internal data
in a process, for example, its state. It is sent to
<strong><span class="anno">Module</span>:system_continue/3</strong> or
<strong><span class="anno">Module</span>:system_terminate/4</strong>.</p><h3>print_log/1</h3><p>Print the logged events in the debug structure.</p><p>Prints the logged system events in the debug structure,
using <strong>FormFunc</strong> as defined when the event was
generated by a call to
<a href="#handle_debug/4">handle_debug/4</a>.</p><h3>get_log/1</h3><p>Return the logged events in the debug structure.</p><p>
Returns the logged system events in the debug structure,
that is the last argument to
<a href="#handle_debug/4">handle_debug/4</a>.
</p><h3>Module:system_code_change(Misc, Module, OldVsn, Extra) -&gt;
        {ok, NMisc}</h3><p>Called when the process is to perform a code change.</p><ul><li><span class="v">Misc = term()</span></li><li><span class="v">OldVsn = undefined | term()</span></li><li><span class="v">Module = atom()</span></li><li><span class="v">Extra = term()</span></li><li><span class="v">NMisc = term()</span></li></ul><p>Called from <a href="#handle_system_msg/6">handle_system_msg/6</a> when the process is to perform a
code change. The code change is used when the
internal data structure has changed. This function
converts argument <strong>Misc</strong> to the new data
structure. <strong>OldVsn</strong> is attribute <em>vsn</em> of the
old version of the <strong>Module</strong>. If no such attribute is
defined, the atom <strong>undefined</strong> is sent.</p><h3>Module:system_continue(Parent, Debug, Misc) -&gt; none()</h3><p>Called when the process is to continue its execution.</p><ul><li><span class="v">Parent = pid()</span></li><li><span class="v">Debug = []</span></li><li><span class="v">Misc = term()</span></li></ul><p>Called from <a href="#handle_system_msg/6">handle_system_msg/6</a> when the process is to continue
its execution (for example, after it has been
suspended). This function never returns.</p><h3>Module:system_get_state(Misc) -&gt; {ok, State}</h3><p>Called when the process is to return its current state. </p><ul><li><span class="v">Misc = term()</span></li><li><span class="v">State = term()</span></li></ul><p>Called from <a href="#handle_system_msg/6">handle_system_msg/6</a>
when the process is to return a term that reflects its current state. 
<strong>State</strong> is the value returned by 
<a href="#get_state/2">get_state/2</a>.</p><h3>Module:system_replace_state(StateFun, Misc) -&gt;
        {ok, NState, NMisc}</h3><p>Called when the process is to replace its current state. </p><ul><li><span class="v">StateFun = fun((State :: term()) -&gt; NState)</span></li><li><span class="v">Misc = term()</span></li><li><span class="v">NState = term()</span></li><li><span class="v">NMisc = term()</span></li></ul><p>Called from <a href="#handle_system_msg/6">handle_system_msg/6</a> when the process is to replace
its current state. <strong>NState</strong> is the value returned by
<a href="#replace_state/3">replace_state/3</a>.
</p><h3>Module:system_terminate(Reason, Parent, Debug, Misc) -&gt; none()</h3><p>Called when the process is to terminate.</p><ul><li><span class="v">Reason = term()</span></li><li><span class="v">Parent = pid()</span></li><li><span class="v">Debug = []</span></li><li><span class="v">Misc = term()</span></li></ul><p>Called from <a href="#handle_system_msg/6">handle_system_msg/6</a> when the process is to terminate.
For example, this function is called when
the process is suspended and its parent orders shutdown.
It gives the process a chance to do a cleanup. This function never
returns.</p><h2>timer</h2><p>Timer functions.</p><p>This module provides useful functions related to time. Unless otherwise
stated, time is always measured in <em>milliseconds</em>. All
timer functions return immediately, regardless of work done by another
process.Successful evaluations of the timer functions give return values
containing a timer reference, denoted <strong>TRef</strong>. By using
<a href="#cancel/1">cancel/1</a>,
the returned reference can be used to cancel any
requested action. A <strong>TRef</strong> is an Erlang term, which contents
must not be changed.The time-outs are not exact, but are <em>at least</em> as long
as requested.</p><h2>Data Types</h2><span class="name">time</span><p>Time in milliseconds.</p><span class="name">tref</span><p>A timer reference.</p><h2>Functions</h2><h3>apply_after/4</h3><p>Apply <strong>Module:Function(Arguments)</strong> after a specified <strong>Time</strong>.</p><p>Evaluates <strong>apply(<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Arguments</span>)</strong> after <strong><span class="anno">Time</span></strong>
milliseconds.</p><p>Returns <strong>{ok, <span class="anno">TRef</span>}</strong> or
<strong>{error, <span class="anno">Reason</span>}</strong>.</p><h3>apply_interval/4</h3><p>Evaluate <strong>Module:Function(Arguments)</strong> repeatedly at intervals of <strong>Time</strong>.</p><p>Evaluates <strong>apply(<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Arguments</span>)</strong> repeatedly at intervals of
<strong><span class="anno">Time</span></strong>.</p><p>Returns <strong>{ok, <span class="anno">TRef</span>}</strong> or
<strong>{error, <span class="anno">Reason</span>}</strong>.</p><h3>cancel/1</h3><p>Cancel a previously requested time-out identified by <strong>TRef</strong>.</p><p>Cancels a previously requested time-out. <strong><span class="anno">TRef</span></strong> is
a unique
timer reference returned by the related timer function.</p><p>Returns <strong>{ok, cancel}</strong>, or <strong>{error, <span class="anno">Reason</span>}</strong>
when <strong><span class="anno">TRef</span></strong> is not a timer reference.</p><h3>exit_after/2</h3><h3>exit_after/3</h3><p>Send an exit signal with <strong>Reason</strong> after a specified <strong>Time</strong>.</p><p><strong>exit_after/2</strong> is the same as
<strong>exit_after(<span class="anno">Time</span>, self(), <span class="anno">Reason1</span>)</strong>.</p><p><strong>exit_after/3</strong> sends an exit signal with reason
<strong><span class="anno">Reason1</span></strong> to
pid <strong><span class="anno">Pid</span></strong>. Returns <strong>{ok, <span class="anno">TRef</span>}</strong>
or <strong>{error, <span class="anno">Reason2</span>}</strong>.</p><h3>hms/3</h3><p>Convert <strong>Hours</strong>+<strong>Minutes</strong>+<strong>Seconds</strong> to <strong>Milliseconds</strong>.</p><p>Returns the number of milliseconds in <strong><span class="anno">Hours</span> + <span class="anno">Minutes</span> + <span class="anno">Seconds</span></strong>.</p><h3>hours/1</h3><p>Convert <strong>Hours</strong> to <strong>Milliseconds</strong>.</p><p>Returns the number of milliseconds in <strong><span class="anno">Hours</span></strong>.</p><h3>kill_after/1</h3><h3>kill_after/2</h3><p>Send an exit signal with <strong>Reason</strong> after a specified <strong>Time</strong>.</p><p><strong>kill_after/1</strong> is the same as
<strong>exit_after(<span class="anno">Time</span>, self(), kill)</strong>.</p><p><strong>kill_after/2</strong> is the same as
<strong>exit_after(<span class="anno">Time</span>, <span class="anno">Pid</span>, kill)</strong>.</p><h3>minutes/1</h3><p>Converts <strong>Minutes</strong> to <strong>Milliseconds</strong>.</p><p>Returns the number of milliseconds in
<strong><span class="anno">Minutes</span></strong>.</p><h3>now_diff/2</h3><p>Calculate time difference between time stamps.</p><dl><dt>Tdiff</dt><dd>In microseconds</dd></dl><p>Calculates the time difference <strong><span class="anno">Tdiff</span> = <span class="anno">T2</span> - <span class="anno">T1</span></strong> in <em>microseconds</em>,
where <strong><span class="anno">T1</span></strong> and <strong><span class="anno">T2</span></strong>
are time-stamp tuples on the same format as returned from
<a href="../erts/erlang#timestamp/0">erts/erlang#timestamp/0</a> or
<a href="../kernel/os#timestamp/0">kernel/os#timestamp/0</a>.</p><h3>seconds/1</h3><p>Convert <strong>Seconds</strong> to <strong>Milliseconds</strong>.</p><p>Returns the number of milliseconds in
<strong><span class="anno">Seconds</span></strong>.</p><h3>send_after/2</h3><h3>send_after/3</h3><p>Send <strong>Message</strong> to <strong>Pid</strong> after a specified <strong>Time</strong>.</p><dl><dt><strong>send_after/3</strong></dt><dd> <p>Evaluates <strong><span class="anno">Pid</span> ! <span class="anno">Message</span></strong> after
<strong><span class="anno">Time</span></strong> milliseconds. (<strong><span class="anno">Pid</span></strong>
can also be an atom of a registered name.)</p> <p>Returns <strong>{ok, <span class="anno">TRef</span>}</strong> or
<strong>{error, <span class="anno">Reason</span>}</strong>.</p> </dd><dt><strong>send_after/2</strong></dt><dd> <p>Same as <strong>send_after(<span class="anno">Time</span>, self(), <span class="anno">Message</span>)</strong>.</p> </dd></dl><h3>send_interval/2</h3><h3>send_interval/3</h3><p>Send <strong>Message</strong> repeatedly at intervals of <strong>Time</strong>. </p><dl><dt><strong>send_interval/3</strong></dt><dd> <p>Evaluates <strong><span class="anno">Pid</span> ! <span class="anno">Message</span></strong>
repeatedly after <strong><span class="anno">Time</span></strong> milliseconds.
(<strong><span class="anno">Pid</span></strong> can also be
an atom of a registered name.)</p> <p>Returns <strong>{ok, <span class="anno">TRef</span>}</strong> or
<strong>{error, <span class="anno">Reason</span>}</strong>.</p> </dd><dt><strong>send_interval/2</strong></dt><dd> <p>Same as <strong>send_interval(<span class="anno">Time</span>, self(), <span class="anno">Message</span>)</strong>.</p> </dd></dl><h3>sleep/1</h3><p>Suspend the calling process for <strong>Time</strong> milliseconds. </p><p>Suspends the process calling this function for
<strong><span class="anno">Time</span></strong> milliseconds and then returns <strong>ok</strong>,
or suspends the process forever if <strong><span class="anno">Time</span></strong> is the
atom <strong>infinity</strong>. Naturally, this
function does <em>not</em> return immediately.</p><h3>start/0</h3><p>Start a global timer server (named <strong>timer_server</strong>). </p><p>Starts the timer server. Normally, the server does not need
to be started explicitly. It is started dynamically if it
is needed. This is useful during development, but in a
target system the server is to be started explicitly. Use
configuration parameters for
<a href="./index">Kernel</a> for this.</p><h3>tc/1</h3><h3>tc/2</h3><h3>tc/3</h3><p>Measure the real time it takes to evaluate <strong>apply(Module, Function, Arguments)</strong> or <strong>apply(Fun, Arguments)</strong>.</p><dl><dt>Time</dt><dd>In microseconds</dd></dl><dl><dt><strong>tc/3</strong></dt><dd> <p>Evaluates <strong>apply(<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Arguments</span>)</strong> and measures the elapsed real time as 
reported by <a href="../erts/erlang#monotonic_time/0">erts/erlang#monotonic_time/0</a>.</p> <p>Returns <strong>{<span class="anno">Time</span>, <span class="anno">Value</span>}</strong>, where
<strong><span class="anno">Time</span></strong> is the elapsed real time in
<em>microseconds</em>, and <strong><span class="anno">Value</span></strong> is what is
returned from the apply.</p> </dd><dt><strong>tc/2</strong></dt><dd> <p>Evaluates <strong>apply(<span class="anno">Fun</span>, <span class="anno">Arguments</span>)</strong>.
Otherwise the same as <strong>tc/3</strong>.</p> </dd><dt><strong>tc/1</strong></dt><dd> <p>Evaluates <strong><span class="anno">Fun</span>()</strong>. Otherwise the same as
<strong>tc/2</strong>.</p> </dd></dl><h3>Examples</h3><p><em>Example 1</em></p><p>The following example shows how to print "Hello World!" in 5 seconds:</p><pre>
1&gt; <span class="input">timer:apply_after(5000, io, format, ["~nHello World!~n", []]).</span>
{ok,TRef}
Hello World!</pre><p><em>Example 2</em></p><p>The following example shows a process performing a 
certain action, and if this action is not completed within a certain 
limit, the process is killed:</p><pre><code class="">
Pid = spawn(mod, fun, [foo, bar]),
%% If pid is not finished in 10 seconds, kill him
{ok, R} = timer:kill_after(timer:seconds(10), Pid),
...
%% We change our mind...
timer:cancel(R),
...</code></pre><h3>Notes</h3><p>A timer can always be removed by calling
<a href="#cancel/1">cancel/1</a>.</p><p>An interval timer, that is, a timer created by evaluating any of the
functions
<a href="#apply_interval/4">apply_interval/4</a>,
<a href="#send_interval/3">send_interval/3</a>, and
<a href="#send_interval/2">send_interval/2</a>
is linked to the process to which the timer performs its task.</p><p>A one-shot timer, that is, a timer created by evaluating any of the
functions
<a href="#apply_after/4">apply_after/4</a>,
<a href="#send_after/3">send_after/3</a>,
<a href="#send_after/2">send_after/2</a>,
<a href="#exit_after/3">exit_after/3</a>,
<a href="#exit_after/2">exit_after/2</a>,
<a href="#kill_after/2">kill_after/2</a>, and
<a href="#kill_after/1">kill_after/1</a>
is not linked to any process. Hence, such a timer is removed only
when it reaches its time-out, or if it is explicitly removed by a call to
<a href="#cancel/1">cancel/1</a>.</p><h2>unicode</h2><p>Functions for converting Unicode characters.</p><p>This module contains functions for converting between different character 
representations. It converts between ISO Latin-1 characters and Unicode
characters, but it can also convert between different Unicode encodings
(like UTF-8, UTF-16, and UTF-32).The default Unicode encoding in Erlang is in binaries UTF-8, which is also
the format in which built-in functions and libraries in OTP expect to find
binary Unicode data. In lists, Unicode data is encoded as integers, each
integer representing one character and encoded simply as the Unicode code
point for the character.Other Unicode encodings than integers representing code points or UTF-8
in binaries are referred to as "external encodings". The ISO
Latin-1 encoding
is in binaries and lists referred to as latin1-encoding.It is recommended to only use external encodings for communication with
external entities where this is required. When working inside the
Erlang/OTP environment, it is recommended to keep binaries in UTF-8 when
representing Unicode characters. ISO Latin-1 encoding is supported both
for backward compatibility and for communication
with external entities not supporting Unicode character sets.Programs should always operate on a normalized form and compare
canonical-equivalent Unicode characters as equal. All characters
should thus be normalized to one form once on the system borders.
One of the following functions can convert characters to their
normalized forms <a href="#characters_to_nfc_list/1">characters_to_nfc_list/1</a>,
<a href="#characters_to_nfc_binary/1">characters_to_nfc_binary/1</a>,
<a href="#characters_to_nfd_list/1">characters_to_nfd_list/1</a> or
<a href="#characters_to_nfd_binary/1">characters_to_nfd_binary/1</a>.
For general text
<a href="#characters_to_nfc_list/1">characters_to_nfc_list/1</a> or
<a href="#characters_to_nfc_binary/1">characters_to_nfc_binary/1</a> is preferred, and
for identifiers one of the compatibility normalization
functions, such as
<a href="#characters_to_nfkc_list/1">characters_to_nfkc_list/1</a>,
is preferred for security reasons.
The normalization functions where introduced in OTP 20.
Additional information on normalization can be found in the
<a href="http://unicode.org/faq/normalization.html">Unicode FAQ</a>.
</p><h2>Data Types</h2><span class="name">encoding</span><span class="name">endian</span><span class="name">unicode_binary</span><p>A <strong>binary()</strong> with characters encoded in the UTF-8 coding
standard.</p><span class="name">chardata</span><span class="name">charlist</span><span class="name">external_unicode_binary</span><p>A <strong>binary()</strong> with characters coded in a user-specified Unicode
encoding other than UTF-8 (that is, UTF-16 or UTF-32).</p><span class="name">external_chardata</span><span class="name">external_charlist</span><span class="name">latin1_binary</span><p>A <strong>binary()</strong> with characters coded in ISO Latin-1.</p><span class="name">latin1_char</span><p>An <strong>integer()</strong> representing a valid ISO Latin-1
character (0-255).</p><span class="name">latin1_chardata</span><p>Same as <strong>iodata()</strong>.</p><span class="name">latin1_charlist</span><p>Same as <strong>iolist()</strong>.</p><h2>Functions</h2><h3>bom_to_encoding/1</h3><p>Identify UTF byte order marks in a binary.</p><ul><li>endian</li></ul><dl><dt>Bin</dt><dd> A <strong>binary()</strong> such that <strong>byte_size(<span class="anno">Bin</span>) &gt;= 4</strong>. </dd></dl><p>Checks for a UTF Byte Order Mark (BOM) in the beginning of a
binary. If the supplied binary <strong><span class="anno">Bin</span></strong> begins with a
valid BOM for either UTF-8, UTF-16, or UTF-32, the function
returns the encoding identified along with the BOM length
in bytes.</p><p>If no BOM is found, the function returns <strong>{latin1,0}</strong>.</p><h3>characters_to_binary/1</h3><p>Convert a collection of characters to a UTF-8 binary.</p><p>Same as <strong>characters_to_binary(<span class="anno">Data</span>, unicode, unicode)</strong>.</p><h3>characters_to_binary/2</h3><p>Convert a collection of characters to a UTF-8 binary.</p><p>Same as <strong>characters_to_binary(<span class="anno">Data</span>,  <span class="anno">InEncoding</span>, unicode)</strong>.</p><h3>characters_to_binary/3</h3><p>Convert a collection of characters to a UTF-8 binary.</p><p>Behaves as <a href="#characters_to_list/2">characters_to_list/2</a>, but produces a binary
instead of a Unicode list.</p><p><strong><span class="anno">InEncoding</span></strong> defines how input is to be interpreted
if binaries are present in <strong>Data</strong></p><p><strong><span class="anno">OutEncoding</span></strong> defines in what format output is to
be generated.</p><p>Options:</p><dl><dt><strong>unicode</strong></dt><dd> <p>An alias for <strong>utf8</strong>, as this is the preferred encoding for 
Unicode characters in binaries.</p> </dd><dt><strong>utf16</strong></dt><dd> <p>An alias for <strong>{utf16,big}</strong>.</p> </dd><dt><strong>utf32</strong></dt><dd> <p>An alias for <strong>{utf32,big}</strong>.</p> </dd></dl><p>The atoms <strong>big</strong> and <strong>little</strong> denote big- or little-endian
encoding.</p><p>Errors and exceptions occur as in
<a href="#characters_to_list/2">characters_to_list/2</a>, but the second element
in tuple <strong>error</strong> or <strong>incomplete</strong> is a <strong>binary()</strong>
and not a <strong>list()</strong>.</p><h3>characters_to_list/1</h3><p>Convert a collection of characters to a list of Unicode characters.</p><p>Same as <strong>characters_to_list(<span class="anno">Data</span>, unicode)</strong>.</p><h3>characters_to_list/2</h3><p>Convert a collection of characters to a list of Unicode characters.</p><p>Converts a possibly deep list of integers and
binaries into a list of integers representing Unicode
characters. The binaries in the input can have characters
encoded as one of the following:</p><ul><li> <p>ISO Latin-1 (0-255, one character per byte). Here,
case parameter <strong><span class="anno">InEncoding</span></strong> is to be specified
as <strong>latin1</strong>.</p> </li><li> <p>One of the UTF-encodings, which is specified as parameter 
<strong><span class="anno">InEncoding</span></strong>.</p> </li></ul><p>
Note that integers in the list always represent code points
regardless of <strong><span class="anno">InEncoding</span></strong> passed. If
<strong><span class="anno">InEncoding</span> latin1</strong> is passed, only code
points &lt; 256 are allowed; otherwise, all valid unicode code
points are allowed.
</p><p>If <strong><span class="anno">InEncoding</span></strong> is <strong>latin1</strong>, parameter
<strong><span class="anno">Data</span></strong> corresponds to the <strong>iodata()</strong> type,
but for <strong>unicode</strong>, parameter <strong><span class="anno">Data</span></strong> can
contain integers &gt; 255
(Unicode characters beyond the ISO Latin-1 range), which
makes it invalid as <strong>iodata()</strong>.</p><p>The purpose of the function is mainly to convert
combinations of Unicode characters into a pure Unicode
string in list representation for further processing. For
writing the data to an external entity, the reverse function
<a href="#characters_to_binary/3">characters_to_binary/3</a>
comes in handy.</p><p>Option <strong>unicode</strong> is an alias for <strong>utf8</strong>, as this is the
preferred encoding for Unicode characters in
binaries. <strong>utf16</strong> is an alias for <strong>{utf16,big}</strong> and
<strong>utf32</strong> is an alias for <strong>{utf32,big}</strong>. The atoms <strong>big</strong>
and <strong>little</strong> denote big- or little-endian encoding.</p><p>If the data cannot be converted, either
because of illegal Unicode/ISO Latin-1 characters in the list, 
or because of invalid UTF encoding in any binaries, an error
tuple is returned. The error tuple contains the tag
<strong>error</strong>, a list representing the characters that could be
converted before the error occurred and a representation of the
characters including and after the offending integer/bytes. The
last part is mostly for debugging, as it still constitutes a
possibly deep or mixed list, or both, not necessarily of the same
depth as the original data. The error occurs when traversing the
list and whatever is left to decode is returned "as is".</p><p>However, if the input <strong><span class="anno">Data</span></strong> is a pure binary,
the third part of the error tuple is guaranteed to be a binary as
well.</p><p>Errors occur for the following reasons:</p><ul><li> <p>Integers out of range.</p> <p>If <strong><span class="anno">InEncoding</span></strong> is <strong>latin1</strong>, 
an error occurs whenever an integer &gt; 255 is found
in the lists.</p> <p>If <strong><span class="anno">InEncoding</span></strong> is of a Unicode type,
an error occurs whenever either of the following is found:</p> <ul><li> <p>An integer &gt; 16#10FFFF
(the maximum Unicode character)</p> </li><li> <p>An integer in the range 16#D800 to 16#DFFF (invalid range
reserved for UTF-16 surrogate pairs)</p> </li></ul> </li><li> <p>Incorrect UTF encoding.</p> <p>If <strong><span class="anno">InEncoding</span></strong> is one of the UTF types,
the bytes in any binaries must be valid in that encoding.</p> <p>Errors can occur for various reasons, including the
following:</p> <ul><li> <p>"Pure" decoding errors 
(like the upper bits of the bytes being wrong).</p> </li><li> <p>The bytes are decoded to a too large number.</p> </li><li> <p>The bytes are decoded to a code point in the invalid
Unicode range.</p> </li><li> <p>Encoding is "overlong", meaning that a number
should have been encoded in fewer bytes.</p> </li></ul> <p>The case of a truncated UTF is handled specially, see the
paragraph about incomplete binaries below.</p> <p>If <strong><span class="anno">InEncoding</span></strong> is <strong>latin1</strong>, binaries are
always valid as long as they contain whole bytes,
as each byte falls into the valid ISO Latin-1 range.</p> </li></ul><p>A special type of error is when no actual invalid integers or
bytes are found, but a trailing <strong>binary()</strong> consists of too
few bytes to decode the last character. This error can occur
if bytes are read from a file in chunks or if binaries in other
ways are split on non-UTF character boundaries. An <strong>incomplete</strong>
tuple is then returned instead of the <strong>error</strong> tuple.
It consists of the same parts as the <strong>error</strong> tuple, but
the tag is <strong>incomplete</strong> instead of <strong>error</strong> and the
last element is always guaranteed to be a binary consisting of
the first part of a (so far) valid UTF character.</p><p>If one UTF character is split over two consecutive binaries in
the <strong><span class="anno">Data</span></strong>, the conversion succeeds. This means
that a character can be decoded from a range of binaries as long
as the whole range is specified as input without errors occurring.</p><p><em>Example:</em></p><pre><code class="">
decode_data(Data) -&gt;
   case unicode:characters_to_list(Data,unicode) of
      {incomplete,Encoded, Rest} -&gt;
            More = get_some_more_data(),
            Encoded ++ decode_data([Rest, More]);
      {error,Encoded,Rest} -&gt;
            handle_error(Encoded,Rest);
      List -&gt;
            List
   end.</code></pre><p>However, bit strings that are not whole bytes are not allowed,
so a UTF character must be split along 8-bit boundaries to
ever be decoded.</p><p>A <strong>badarg</strong> exception is thrown for the following cases:</p><ul><li>Any parameters are of the wrong type.</li><li>The list structure is invalid (a number as tail).</li><li>The binaries do not contain whole bytes (bit strings).</li></ul><h3>characters_to_nfc_list/1</h3><p>Normalize characters to a list of canonical equivalent composed Unicode characters.</p><p>Converts a possibly deep list of characters and binaries
into a Normalized Form of canonical equivalent Composed
characters according to the Unicode standard.</p><p>Any binaries in the input must be encoded with utf8
encoding.
</p><p>The result is a list of characters.</p><pre><code class="">
3&gt; unicode:characters_to_nfc_list([&lt;&lt;"abc..a"&gt;&gt;,[778],$a,[776],$o,[776]]).
"abc.."
</code></pre><h3>characters_to_nfc_binary/1</h3><p>Normalize characters to a utf8 binary of canonical equivalent composed Unicode characters.</p><p>Converts a possibly deep list of characters and binaries
into a Normalized Form of canonical equivalent Composed
characters according to the Unicode standard.</p><p>Any binaries in the input must be encoded with utf8
encoding.</p><p>The result is an utf8 encoded binary.</p><pre><code class="">
4&gt; unicode:characters_to_nfc_binary([&lt;&lt;"abc..a"&gt;&gt;,[778],$a,[776],$o,[776]]).
&lt;&lt;"abc.."/utf8&gt;&gt;
</code></pre><h3>characters_to_nfd_list/1</h3><p>Normalize characters to a list of canonical equivalent decomposed Unicode characters.</p><p>Converts a possibly deep list of characters and binaries
into a Normalized Form of canonical equivalent Decomposed
characters according to the Unicode standard.</p><p>Any binaries in the input must be encoded with utf8
encoding.
</p><p>The result is a list of characters.</p><pre><code class="">
1&gt; unicode:characters_to_nfd_list("abc..").
[97,98,99,46,46,97,778,97,776,111,776]
</code></pre><h3>characters_to_nfd_binary/1</h3><p>Normalize characters to a utf8 binary of canonical equivalent decomposed Unicode characters.</p><p>Converts a possibly deep list of characters and binaries
into a Normalized Form of canonical equivalent Decomposed
characters according to the Unicode standard.</p><p>Any binaries in the input must be encoded with utf8
encoding.</p><p>The result is an utf8 encoded binary.</p><pre><code class="">
2&gt; unicode:characters_to_nfd_binary("abc..").
&lt;&lt;97,98,99,46,46,97,204,138,97,204,136,111,204,136&gt;&gt;
</code></pre><h3>characters_to_nfkc_list/1</h3><p>Normalize characters to a list of canonical equivalent composed Unicode characters.</p><p>Converts a possibly deep list of characters and binaries
into a Normalized Form of compatibly equivalent Composed
characters according to the Unicode standard.</p><p>Any binaries in the input must be encoded with utf8
encoding.
</p><p>The result is a list of characters.</p><pre><code class="">
3&gt; unicode:characters_to_nfkc_list([&lt;&lt;"abc..a"&gt;&gt;,[778],$a,[776],$o,[776],[65299,65298]]).
"abc..32"
</code></pre><h3>characters_to_nfkc_binary/1</h3><p>Normalize characters to a utf8 binary of compatibly equivalent composed Unicode characters.</p><p>Converts a possibly deep list of characters and binaries
into a Normalized Form of compatibly equivalent Composed
characters according to the Unicode standard.</p><p>Any binaries in the input must be encoded with utf8
encoding.</p><p>The result is an utf8 encoded binary.</p><pre><code class="">
4&gt; unicode:characters_to_nfkc_binary([&lt;&lt;"abc..a"&gt;&gt;,[778],$a,[776],$o,[776],[65299,65298]]).
&lt;&lt;"abc..32"/utf8&gt;&gt;
</code></pre><h3>characters_to_nfkd_list/1</h3><p>Normalize characters to a list of compatibly equivalent decomposed Unicode characters.</p><p>Converts a possibly deep list of characters and binaries
into a Normalized Form of compatibly equivalent Decomposed
characters according to the Unicode standard.</p><p>Any binaries in the input must be encoded with utf8
encoding.
</p><p>The result is a list of characters.</p><pre><code class="">
1&gt; unicode:characters_to_nfkd_list(["abc..",[65299,65298]]).
[97,98,99,46,46,97,778,97,776,111,776,51,50]
</code></pre><h3>characters_to_nfkd_binary/1</h3><p>Normalize characters to a utf8 binary of compatibly equivalent decomposed Unicode characters.</p><p>Converts a possibly deep list of characters and binaries
into a Normalized Form of compatibly equivalent Decomposed
characters according to the Unicode standard.</p><p>Any binaries in the input must be encoded with utf8
encoding.</p><p>The result is an utf8 encoded binary.</p><pre><code class="">
2&gt; unicode:characters_to_nfkd_binary(["abc..",[65299,65298]]).
&lt;&lt;97,98,99,46,46,97,204,138,97,204,136,111,204,136,51,50&gt;&gt;
</code></pre><h3>encoding_to_bom/1</h3><p>Create a binary UTF byte order mark from encoding.</p><dl><dt>Bin</dt><dd> A <strong>binary()</strong> such that <strong>byte_size(<span class="anno">Bin</span>) &gt;= 4</strong>. </dd></dl><p>Creates a UTF Byte Order Mark (BOM) as a binary from the
supplied <strong><span class="anno">InEncoding</span></strong>. The BOM is, if supported at
all, expected to be placed first in UTF encoded files or messages.</p><p>The function returns <strong>&lt;&lt;&gt;&gt;</strong> for
<strong>latin1</strong> encoding, as there is no BOM for ISO Latin-1.</p><p>Notice that the BOM for UTF-8 is seldom used, and it
is really not a <em>byte order</em> mark. There are obviously no
byte order issues with UTF-8, so the BOM is only there to
differentiate UTF-8 encoding from other UTF formats.</p><h2>uri_string</h2><p>URI processing functions.</p><p>This module contains functions for parsing and handling URIs
(<a href="https://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>) and
form-urlencoded query strings (<a href="https://www.w3.org/TR/html52/">HTML 5.2</a>).

Parsing and serializing non-UTF-8 form-urlencoded query strings are also supported
(<a href="https://www.w3.org/TR/html50/">HTML 5.0</a>).
A URI is an identifier consisting of a sequence of characters   matching the syntax
rule named <em>URI</em> in <a href="https://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>.
  The generic URI syntax consists of a hierarchical sequence of components referred
to as the scheme, authority, path, query, and fragment:<pre>
    URI         = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
    hier-part   = "//" authority path-abempty
                   / path-absolute
                   / path-rootless
                   / path-empty
    scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
    authority   = [ userinfo "@" ] host [ ":" port ]
    userinfo    = *( unreserved / pct-encoded / sub-delims / ":" )

    reserved    = gen-delims / sub-delims
    gen-delims  = ":" / "/" / "?" / "#" / "[" / "]" / "@"
    sub-delims  = "!" / "$" / "&amp;" / "'" / "(" / ")"
                / "*" / "+" / "," / ";" / "="

    unreserved  = ALPHA / DIGIT / "-" / "." / "_" / "~"
    </pre><br/>The interpretation of a URI depends only on the characters used and not on how those
characters are represented in a network protocol.The functions implemented by this module cover the following use cases:<ul><li>Parsing URIs into its components and returing a map<br/> <a href="#parse/1">parse/1</a> </li><li>Recomposing a map of URI components into a URI string<br/> <a href="#recompose/1">recompose/1</a> </li><li>Changing inbound binary and percent-encoding of URIs<br/> <a href="#transcode/2">transcode/2</a> </li><li>Transforming URIs into a normalized form<br/> <a href="#normalize/1">normalize/1</a><br/> <a href="#normalize/2">normalize/2</a> </li><li>Composing form-urlencoded query strings from a list of key-value pairs<br/> <a href="#compose_query/1">compose_query/1</a><br/> <a href="#compose_query/2">compose_query/2</a> </li><li>Dissecting form-urlencoded query strings into a list of key-value pairs<br/> <a href="#dissect_query/1">dissect_query/1</a> </li></ul>There are four different encodings present during the handling of URIs:<ul><li>Inbound binary encoding in binaries</li><li>Inbound percent-encoding in lists and binaries</li><li>Outbound binary encoding in binaries</li><li>Outbound percent-encoding in lists and binaries</li></ul>Functions with <strong>uri_string()</strong> argument accept lists, binaries and
mixed lists (lists with binary elements) as input type. All of the functions but
<strong>transcode/2</strong> expects input as lists of unicode codepoints, UTF-8 encoded binaries
and UTF-8 percent-encoded URI parts ("%C3%B6" corresponds to the unicode character "").Unless otherwise specified the return value type and encoding are the same as the input
type and encoding. That is, binary input returns binary output, list input returns a list
output but mixed input returns list output.In case of lists there is only percent-encoding. In binaries, however, both binary encoding
and percent-encoding shall be considered. <strong>transcode/2</strong> provides the means to convert
between the supported encodings, it takes a <strong>uri_string()</strong> and a list of options
specifying inbound and outbound encodings.<a href="https://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a> does not mandate any specific
character encoding and it is usually defined by the protocol or surrounding text. This library
takes the same assumption, binary and percent-encoding are handled as one configuration unit,
they cannot be set to different values.</p><h2>Data Types</h2><span class="name">error</span><p>Error tuple indicating the type of error. Possible values of the second component:</p><ul><li><strong>invalid_character</strong></li><li><strong>invalid_encoding</strong></li><li><strong>invalid_input</strong></li><li><strong>invalid_map</strong></li><li><strong>invalid_percent_encoding</strong></li><li><strong>invalid_scheme</strong></li><li><strong>invalid_uri</strong></li><li><strong>invalid_utf8</strong></li><li><strong>missing_value</strong></li></ul><p>The third component is a term providing additional information about the
cause of the error.</p><span class="name">uri_map</span><p>Map holding the main components of a URI.</p><span class="name">uri_string</span><p>List of unicode codepoints, a UTF-8 encoded binary, or a mix of the two,
representing an <a href="https://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>
compliant URI (<em>percent-encoded form</em>).
A URI is a sequence of characters from a very limited set: the letters of
the basic Latin alphabet, digits, and a few special characters.</p><h2>Functions</h2><h3>compose_query/1</h3><p>Compose urlencoded query string.</p><p>Composes a form-urlencoded <strong><span class="anno">QueryString</span></strong> based on a
<strong><span class="anno">QueryList</span></strong>, a list of non-percent-encoded key-value pairs.
Form-urlencoding is defined in section
4.10.21.6 of the <a href="https://www.w3.org/TR/html52/">HTML 5.2</a>
specification and in section 4.10.22.6 of the
<a href="https://www.w3.org/TR/html50/">HTML 5.0</a> specification for
non-UTF-8 encodings.
</p><p>See also the opposite operation <a href="#dissect_query/1">dissect_query/1</a>.
</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">uri_string:compose_query([{"foo bar","1"},{"city","rebro"}]).</span>
"foo+bar=1&amp;city=%C3%B6rebro"
2&gt; uri_string:compose_query([{&lt;&lt;"foo bar"&gt;&gt;,&lt;&lt;"1"&gt;&gt;},
2&gt; {&lt;&lt;"city"&gt;&gt;,&lt;&lt;"rebro"/utf8&gt;&gt;}]).
&lt;&lt;"foo+bar=1&amp;city=%C3%B6rebro"&gt;&gt;
	</pre><h3>compose_query/2</h3><p>Compose urlencoded query string.</p><p>Same as <strong>compose_query/1</strong> but with an additional
<strong><span class="anno">Options</span></strong> parameter, that controls the encoding ("charset")
used by the encoding algorithm. There are two supported encodings: <strong>utf8</strong>
(or <strong>unicode</strong>) and <strong>latin1</strong>.
</p><p>Each character in the entry's name and value that cannot be expressed using
the selected character encoding, is replaced by a string consisting of a U+0026
AMPERSAND character (&amp;), a "#" (U+0023) character, one or more ASCII
digits representing the Unicode code point of the character in base ten, and
finally	a ";" (U+003B) character.
</p><p>Bytes that are out of the range 0x2A, 0x2D, 0x2E, 0x30 to 0x39, 0x41 to 0x5A, 0x5F,
0x61 to 0x7A, are percent-encoded (U+0025 PERCENT SIGN character (%) followed by
uppercase ASCII hex digits representing the hexadecimal value of the byte).
</p><p>See also the opposite operation <a href="#dissect_query/1">dissect_query/1</a>.
</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">uri_string:compose_query([{"foo bar","1"},{"city","rebro"}],</span>
1&gt; [{encoding, latin1}]).
"foo+bar=1&amp;city=%F6rebro"
2&gt; uri_string:compose_query([{&lt;&lt;"foo bar"&gt;&gt;,&lt;&lt;"1"&gt;&gt;},
2&gt; {&lt;&lt;"city"&gt;&gt;,&lt;&lt;""/utf8&gt;&gt;}], [{encoding, latin1}]).
&lt;&lt;"foo+bar=1&amp;city=%26%2326481%3B%26%2320140%3B"&gt;&gt;
	</pre><h3>dissect_query/1</h3><p>Dissect query string.</p><p>Dissects an urlencoded <strong><span class="anno">QueryString</span></strong> and returns a
<strong><span class="anno">QueryList</span></strong>, a list of non-percent-encoded key-value pairs.
Form-urlencoding is defined in section
4.10.21.6 of the <a href="https://www.w3.org/TR/html52/">HTML 5.2</a>
specification and in section 4.10.22.6 of the
<a href="https://www.w3.org/TR/html50/">HTML 5.0</a> specification for
non-UTF-8 encodings.
</p><p>See also the opposite operation <a href="#compose_query/1">compose_query/1</a>.
</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">uri_string:dissect_query("foo+bar=1&amp;city=%C3%B6rebro").</span>
[{"foo bar","1"},{"city","rebro"}]
2&gt; uri_string:dissect_query(&lt;&lt;"foo+bar=1&amp;city=%26%2326481%3B%26%2320140%3B"&gt;&gt;).
[{&lt;&lt;"foo bar"&gt;&gt;,&lt;&lt;"1"&gt;&gt;},
 {&lt;&lt;"city"&gt;&gt;,&lt;&lt;230,157,177,228,186,172&gt;&gt;}] 
	</pre><h3>normalize/1</h3><p>Syntax-based normalization.</p><p>Transforms an <strong><span class="anno">URI</span></strong> into a normalized form
using Syntax-Based Normalization as defined by
<a href="https://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>.</p><p>This function implements case normalization, percent-encoding
normalization, path segment normalization and scheme based normalization
for HTTP(S) with basic support for FTP, SSH, SFTP and TFTP.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">uri_string:normalize("/a/b/c/./../../g").</span>
"/a/g"
2&gt; uri_string:normalize(&lt;&lt;"mid/content=5/../6"&gt;&gt;).
&lt;&lt;"mid/6"&gt;&gt;
3&gt; uri_string:normalize("http://localhost:80").
"https://localhost/"
4&gt; <span class="input">uri_string:normalize(#{scheme =&gt; "http",port =&gt; 80,path =&gt; "/a/b/c/./../../g",</span>
4&gt; host =&gt; "localhost-rebro"}).
"http://localhost-%C3%B6rebro/a/g"
	</pre><h3>normalize/2</h3><p>Syntax-based normalization.</p><p>Same as <strong>normalize/1</strong> but with an additional
<strong><span class="anno">Options</span></strong> parameter, that controls if the normalized URI
shall be returned as an uri_map().
There is one supported option: <strong>return_map</strong>.
</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">uri_string:normalize("/a/b/c/./../../g", [return_map]).</span>
#{path =&gt; "/a/g"}
2&gt; uri_string:normalize(&lt;&lt;"mid/content=5/../6"&gt;&gt;, [return_map]).
#{path =&gt; &lt;&lt;"mid/6"&gt;&gt;}
3&gt; uri_string:normalize("http://localhost:80", [return_map]).
#{scheme =&gt; "http",path =&gt; "/",host =&gt; "localhost"}
4&gt; <span class="input">uri_string:normalize(#{scheme =&gt; "http",port =&gt; 80,path =&gt; "/a/b/c/./../../g",</span>
4&gt; host =&gt; "localhost-rebro"}, [return_map]).
#{scheme =&gt; "http",path =&gt; "/a/g",host =&gt; "localhost-rebro"}
	</pre><h3>parse/1</h3><p>Parse URI into a map.</p><p>Parses an <a href="https://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>
compliant <strong>uri_string()</strong> into a <strong>uri_map()</strong>, that holds the parsed
components of the <strong>URI</strong>.
If parsing fails, an error tuple is returned.</p><p>See also the opposite operation <a href="#recompose/1">recompose/1</a>.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">uri_string:parse("foo://user@example.com:8042/over/there?name=ferret#nose").</span>
#{fragment =&gt; "nose",host =&gt; "example.com",
  path =&gt; "/over/there",port =&gt; 8042,query =&gt; "name=ferret",
  scheme =&gt; foo,userinfo =&gt; "user"}
2&gt; uri_string:parse(&lt;&lt;"foo://user@example.com:8042/over/there?name=ferret"&gt;&gt;).
#{host =&gt; &lt;&lt;"example.com"&gt;&gt;,path =&gt; &lt;&lt;"/over/there"&gt;&gt;,
  port =&gt; 8042,query =&gt; &lt;&lt;"name=ferret"&gt;&gt;,scheme =&gt; &lt;&lt;"foo"&gt;&gt;,
  userinfo =&gt; &lt;&lt;"user"&gt;&gt;}
	</pre><h3>recompose/1</h3><p>Recompose URI.</p><p>Creates an <a href="https://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a> compliant
<strong><span class="anno">URIString</span></strong> (percent-encoded), based on the components of
<strong><span class="anno">URIMap</span></strong>.
If the <strong><span class="anno">URIMap</span></strong> is invalid, an error tuple is returned.</p><p>See also the opposite operation <a href="#parse/1">parse/1</a>.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">URIMap = #{fragment =&gt; "nose", host =&gt; "example.com", path =&gt; "/over/there",</span>
1&gt; port =&gt; 8042, query =&gt; "name=ferret", scheme =&gt; "foo", userinfo =&gt; "user"}.
#{fragment =&gt; "top",host =&gt; "example.com",
  path =&gt; "/over/there",port =&gt; 8042,query =&gt; "?name=ferret",
  scheme =&gt; foo,userinfo =&gt; "user"}

2&gt; <span class="input">uri_string:recompose(URIMap).</span>
"foo://example.com:8042/over/there?name=ferret#nose"</pre><h3>transcode/2</h3><p>Transcode URI.</p><p>Transcodes an <a href="https://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>
compliant <strong><span class="anno">URIString</span></strong>,
where <strong><span class="anno">Options</span></strong> is a list of tagged tuples, specifying the inbound
(<strong>in_encoding</strong>) and outbound (<strong>out_encoding</strong>) encodings. <strong>in_encoding</strong>
and <strong>out_encoding</strong> specifies both binary encoding and percent-encoding for the
input and output data. Mixed encoding, where binary encoding is not the same as
percent-encoding, is not supported.
If an argument is invalid, an error tuple is returned.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">uri_string:transcode(&lt;&lt;"foo%00%00%00%F6bar"/utf32&gt;&gt;,</span>
1&gt; [{in_encoding, utf32},{out_encoding, utf8}]).
&lt;&lt;"foo%C3%B6bar"/utf8&gt;&gt;
2&gt; uri_string:transcode("foo%F6bar", [{in_encoding, latin1},
2&gt; {out_encoding, utf8}]).
"foo%C3%B6bar"
	</pre><h2>win32reg</h2><p>Provides access to the registry on Windows.</p><p>This module provides read and write access to the
registry on Windows. It is essentially a port driver wrapped around the
Win32 API calls for accessing the registry.The registry is a hierarchical database, used to store various system
and software information in Windows.
It contains installation data, and is updated by installers
and system programs. The Erlang installer updates the registry by adding
data that Erlang needs.The registry contains keys and values. Keys are like the directories
in a file system, they form a hierarchy. Values are like files, they have
a name and a value, and also a type.Paths to keys are left to right, with subkeys to the right and backslash
between keys. (Remember that backslashes must be doubled in Erlang
strings.) Case is preserved but not significant.For example,
<strong>"\\hkey_local_machine\\software\\Ericsson\\Erlang\\5.0"</strong> is the key
for the installation data for the latest Erlang release.There are six entry points in the Windows registry, top-level keys.
They can be abbreviated in this module as follows:<pre>
Abbreviation     Registry key
============     ============
hkcr             HKEY_CLASSES_ROOT
current_user     HKEY_CURRENT_USER
hkcu             HKEY_CURRENT_USER
local_machine    HKEY_LOCAL_MACHINE
hklm             HKEY_LOCAL_MACHINE
users            HKEY_USERS
hku              HKEY_USERS
current_config   HKEY_CURRENT_CONFIG
hkcc             HKEY_CURRENT_CONFIG
dyn_data         HKEY_DYN_DATA
hkdd             HKEY_DYN_DATA</pre>The key above can be written as
<strong>"\\hklm\\software\\ericsson\\erlang\\5.0"</strong>.This module uses a current key. It works much like the
current directory. From the current key, values can be fetched, subkeys
can be listed, and so on.Under a key, any number of named values can be stored. They have names,
types, and data.<strong>win32reg</strong> supports storing of the following types:<ul><li><strong>REG_DWORD</strong>, which is an integer</li><li><strong>REG_SZ</strong>, which is a string</li><li><strong>REG_BINARY</strong>, which is a binary</li></ul>Other types can be read, and are returned as binaries.There is also a "default" value, which has the empty string as name. It
is read and written with the atom <strong>default</strong> instead of the name.Some registry values are stored as strings with references to environment
variables, for example, <strong>%SystemRoot%Windows</strong>. <strong>SystemRoot</strong> is
an environment variable, and is to be replaced with its value. Function
<a href="#expand/1">expand/1</a> is provided so that
environment variables surrounded by <strong>%</strong> can be expanded to their
values.For more information on the Windows registry, see consult the Win32
Programmer's Reference.</p><h2>Data Types</h2><span class="name">reg_handle</span><p>As returned by
<a href="#open/1">open/1</a>.</p><span class="name">name</span><span class="name">value</span><h2>Functions</h2><h3>change_key/2</h3><p>Move to a key in the registry.</p><p>Changes the current key to another key. Works like <strong>cd</strong>.
The key can be specified as a relative path or as an
absolute path, starting with <strong>\.</strong></p><h3>change_key_create/2</h3><p>Move to a key, create it if it is not there.</p><p>Creates a key, or just changes to it, if it is already there. Works
like a combination of <strong>mkdir</strong> and <strong>cd</strong>.
Calls the Win32 API function <strong>RegCreateKeyEx()</strong>.</p><p>The registry must have been opened in write mode.</p><h3>close/1</h3><p>Close the registry.</p><p>Closes the registry. After that, the <strong><span class="anno">RegHandle</span></strong>
cannot be used.</p><h3>current_key/1</h3><p>Return the path to the current key.</p><p>Returns the path to the current key. This is the equivalent of
<strong>pwd</strong>.</p><p>Notice that the current key is stored in the driver, and can be
invalid (for example, if the key has been removed).</p><h3>delete_key/1</h3><p>Delete the current key.</p><p>Deletes the current key, if it is valid. Calls the Win32 API
function <strong>RegDeleteKey()</strong>. Notice that this call does not change
the current key (unlike
<a href="#change_key_create/2">change_key_create/2</a>).
This means that after the call, the current key is invalid.</p><h3>delete_value/2</h3><p>Delete the named value on the current key.</p><p>Deletes a named value on the current key. The atom <strong>default</strong> is
used for the default value.</p><p>The registry must have been opened in write mode.</p><h3>expand/1</h3><p>Expand a string with environment variables.</p><p>Expands a string containing environment variables between percent
characters. Anything between two <strong>%</strong> is taken for an environment
variable, and is replaced by the value. Two consecutive <strong>%</strong> are
replaced by one <strong>%</strong>.</p><p>A variable name that is not in the environment results in an
error.</p><h3>format_error/1</h3><p>Convert a POSIX error code to a string.</p><p>Converts a POSIX error code to a string
(by calling <strong>erl_posix_msg:message/1</strong>).</p><h3>open/1</h3><p>Open the registry for reading or writing.</p><p>Opens the registry for reading or writing. The current key is the
root (<strong>HKEY_CLASSES_ROOT</strong>). Flag <strong>read</strong> in the mode list
can be omitted.</p><p>Use <a href="#change_key/2">change_key/2</a>
with an absolute path after
<a href="#open/1">open/1</a>.</p><h3>set_value/3</h3><p>Set value at the current registry key with specified name. </p><p>Sets the named (or default) value to <strong>value</strong>. Calls the Win32
API function <strong>RegSetValueEx()</strong>. The value can be of three types,
and the corresponding registry type is used. The supported types
are the following:</p><ul><li><strong>REG_DWORD</strong> for integers</li><li><strong>REG_SZ</strong> for strings</li><li><strong>REG_BINARY</strong> for binaries</li></ul><p>Other types cannot be added or changed.</p><p>The registry must have been opened in write mode.</p><h3>sub_keys/1</h3><p>Get subkeys to the current key.</p><p>Returns a list of subkeys to the current key. Calls the Win32
API function <strong>EnumRegKeysEx()</strong>.</p><p>Avoid calling this on the root keys, as it can be slow.</p><h3>value/2</h3><p>Get the named value on the current key.</p><p>Retrieves the named value (or default) on the current key.
Registry values of type <strong>REG_SZ</strong> are returned as strings.
Type <strong>REG_DWORD</strong> values are returned as integers. All other
types are returned as binaries.</p><h3>values/1</h3><p>Get all values on the current key.</p><p>Retrieves a list of all values on the current key. The values
have types corresponding to the registry types, see
<a href="#value/2">value/2</a>.
Calls the Win32 API function <strong>EnumRegValuesEx()</strong>.</p><h3>See Also</h3><p><strong>erl_posix_msg</strong>,
The Windows 95 Registry (book from O'Reilly),
Win32 Programmer's Reference (from Microsoft)</p><h2>zip</h2><p>Utility for reading and creating 'zip' archives.
</p><p>This module archives and extracts files to and from a zip
archive. The zip format is specified by the "ZIP Appnote.txt" file,
available on the PKWARE web site
<a href="http://www.pkware.com">www.pkware.com</a>.The zip module supports zip archive versions up to 6.1. However,
password-protection and Zip64 are not supported.By convention, the name of a zip file is to end with <strong>.zip</strong>.
To abide to the convention, add <strong>.zip</strong> to the filename.<ul><li> <p>To create zip archives, use function
<a href="#zip/2">zip/2</a> or
<a href="#zip/2">zip/2</a>. They are
also available as <strong>create/2,3</strong>, to resemble the
<a href="erl_tar">erl_tar</a> module.</p> </li><li> <p>To extract files from a zip archive, use function
<a href="#unzip/1">unzip/1</a> or
<a href="#unzip/2">unzip/2</a>. They are
also available as <strong>extract/1,2</strong>, to resemble the
<a href="erl_tar">erl_tar</a> module.</p> </li><li> <p>To fold a function over all files in a zip archive, use function
<a href="#foldl/3">foldl/3</a>.</p> </li><li> <p>To return a list of the files in a zip archive, use function
<a href="#list_dir/1">list_dir/1</a> or
<a href="#list_dir/2">list_dir/2</a>. They are
also available as <strong>table/1,2</strong>, to resemble the
<a href="erl_tar">erl_tar</a> module.</p> </li><li> <p>To print a list of files to the Erlang shell, use function
<a href="#t/1">t/1</a> or
<a href="#tt/1">tt/1</a>.</p> </li><li> <p>Sometimes it is desirable to open a zip archive, and to
unzip files from it file by file, without having to reopen the
archive. This can be done by functions
<a href="#zip_open/1">zip_open/1</a>,
<a href="#zip_get/1">zip_get/1</a>,
<a href="#zip_list_dir/1">zip_list_dir/1</a>, and
<a href="#zip_close/1">zip_close/1</a>.</p> </li></ul></p><h3>Limitations</h3><ul><li> <p>Zip64 archives are not supported.</p> </li><li> <p>Password-protected and encrypted archives are not supported.</p> </li><li> <p>Only the DEFLATE (zlib-compression) and the STORE (uncompressed
data) zip methods are supported.</p> </li><li> <p>The archive size is limited to 2 GB (32 bits).</p> </li><li> <p>Comments for individual files are not supported when creating zip
archives. The zip archive comment for the whole zip archive is
supported.</p> </li><li> <p>Changing a zip archive is not supported.
To add or remove a file from an archive, the whole archive must be
recreated.</p> </li></ul><h2>Data Types</h2><span class="name">zip_comment</span><p>The record <strong>zip_comment</strong> only contains the archive comment for
a zip archive.</p><span class="name">zip_file</span><p>The record <strong>zip_file</strong> contains the following fields:</p><dl><dt><strong>name</strong></dt><dd> <p>The filename</p> </dd><dt><strong>info</strong></dt><dd> <p>File information as in
<a href="../kernel/file#read_file_info/1">kernel/file#read_file_info/1</a>
in Kernel</p> </dd><dt><strong>comment</strong></dt><dd> <p>The comment for the file in the zip archive</p> </dd><dt><strong>offset</strong></dt><dd> <p>The file offset in the zip archive (used internally)</p> </dd><dt><strong>comp_size</strong></dt><dd> <p>The size of the compressed file (the size of the uncompressed
file is found in <strong>info</strong>)</p> </dd></dl><span class="name">filename</span><p>The name of a zip file.</p><span class="name">extension</span><span class="name">extension_spec</span><span class="name">create_option</span><p>These options are described in <a href="#zip_options">zip_options</a>.</p><span class="name">handle</span><p>As returned by
<a href="#zip_open/2">zip_open/2</a>.</p><h2>Functions</h2><h3>foldl/3</h3><p>Fold a function over all files in a zip archive.</p><p>Calls <strong><span class="anno">Fun</span>(<span class="anno">FileInArchive</span>, <span class="anno">GetInfo </span>, <span class="anno">GetBin</span>, <span class="anno">AccIn</span>)</strong> on
successive files in the <strong>Archive</strong>, starting with
<strong><span class="anno">AccIn</span> == <span class="anno">Acc0</span></strong>.</p><p><strong><span class="anno">FileInArchive</span></strong> is the name that the file
has in the archive.</p><p><strong><span class="anno">GetInfo</span></strong> is a fun that returns information
about the file.</p><p><strong><span class="anno">GetBin</span></strong> returns the file contents.</p><p>Both <strong><span class="anno">GetInfo</span></strong> and <strong><span class="anno">GetBin</span></strong>
must be called within the <strong><span class="anno">Fun</span></strong>. Their behavior is
undefined if they are called outside the context of
<strong><span class="anno">Fun</span></strong>.</p><p>The <strong><span class="anno">Fun</span></strong> must return a new accumulator, which is 
passed to the next call. <strong>foldl/3</strong> returns the final accumulator
value. <strong><span class="anno">Acc0</span></strong> is returned if the archive is
empty. It is not necessary to iterate over all files in the archive.
The iteration can be ended prematurely in a controlled manner
by throwing an exception.</p><p><em>Example:</em></p><pre>
&gt; <span class="input">Name = "dummy.zip".</span>
"dummy.zip"
&gt; <span class="input">{ok, {Name, Bin}} = zip:create(Name, [{"foo", &lt;&lt;"FOO"&gt;&gt;}, {"bar", &lt;&lt;"BAR"&gt;&gt;}], [memory]).</span>
{ok,{"dummy.zip",
     &lt;&lt;80,75,3,4,20,0,0,0,0,0,74,152,97,60,171,39,212,26,3,0,
       0,0,3,0,0,...&gt;&gt;}}
&gt; <span class="input">{ok, FileSpec} = zip:foldl(fun(N, I, B, Acc) -&gt; [{N, B(), I()} | Acc] end, [], {Name, Bin}).</span>
{ok,[{"bar",&lt;&lt;"BAR"&gt;&gt;,
      {file_info,3,regular,read_write,
                 {{2010,3,1},{19,2,10}},
                 {{2010,3,1},{19,2,10}},
                 {{2010,3,1},{19,2,10}},
                 54,1,0,0,0,0,0}},
     {"foo",&lt;&lt;"FOO"&gt;&gt;,
      {file_info,3,regular,read_write,
                 {{2010,3,1},{19,2,10}},
                 {{2010,3,1},{19,2,10}},
                 {{2010,3,1},{19,2,10}},
                 54,1,0,0,0,0,0}}]}
&gt; <span class="input">{ok, {Name, Bin}} = zip:create(Name, lists:reverse(FileSpec), [memory]).</span>
{ok,{"dummy.zip",
     &lt;&lt;80,75,3,4,20,0,0,0,0,0,74,152,97,60,171,39,212,26,3,0,
       0,0,3,0,0,...&gt;&gt;}}
&gt; <span class="input">catch zip:foldl(fun("foo", _, B, _) -&gt; throw(B()); (_,_,_,Acc) -&gt; Acc end, [], {Name, Bin}). </span>
&lt;&lt;"FOO"&gt;&gt;
</pre><h3>list_dir/1</h3><h3>list_dir/2</h3><h3>table/1</h3><h3>table/2</h3><p>Retrieve the name of all files in a zip archive.</p><p><strong>list_dir/1</strong> retrieves all filenames in the zip archive
<strong><span class="anno">Archive</span></strong>.</p><p><strong>list_dir/2</strong> provides options.</p><p><strong>table/1</strong> and <strong>table/2</strong> are provided as synonyms 
to resemble the
<a href="erl_tar">erl_tar</a> module.</p><p>The result value is the tuple <strong>{ok, List}</strong>, where <strong>List</strong>
contains the zip archive comment as the first element.</p><p>One option is available:</p><dl><dt><strong>cooked</strong></dt><dd> <p>By default, this function opens the zip file in
<strong>raw</strong> mode, which is faster but does not allow a remote
(Erlang) file server to be used. Adding <strong>cooked</strong> to the
mode list overrides the default
and opens the zip file without option <strong>raw</strong>.</p> </dd></dl><h3>t/1</h3><p>Print the name of each file in a zip archive.</p><p>Prints all filenames in the zip archive <strong><span class="anno">Archive</span></strong>
to  the Erlang shell. (Similar to <strong>tart</strong>.)</p><h3>tt/1</h3><p>Print name and information for each file in a zip archive. </p><p>Prints filenames and information about all files in the zip archive
<strong><span class="anno">Archive</span></strong> to the Erlang shell.
(Similar to <strong>tar tv</strong>.)</p><h3>unzip/1</h3><h3>unzip/2</h3><h3>extract/1</h3><h3>extract/2</h3><p>Extract files from a zip archive.</p><p><strong>unzip/1</strong> extracts all files from a zip archive.</p><p><strong>unzip/2</strong> provides options to extract some files, and more.</p><p><strong>extract/1</strong> and <strong>extract/2</strong> are provided as synonyms
to resemble module 
<a href="erl_tar">erl_tar</a>.</p><p>If argument <strong><span class="anno">Archive</span></strong> is specified as a binary,
the contents of the binary is assumed to be a zip archive,
otherwise a filename.</p><p>Options:</p><dl><dt><strong>{file_list, <span class="anno">FileList</span>}</strong></dt><dd> <p>By default, all files are extracted from the zip
archive. With option <strong>{file_list, <span class="anno">FileList</span>}</strong>,
function <strong>unzip/2</strong> only extracts the files
whose names are included in <strong><span class="anno">FileList</span></strong>. The full
paths, including the names of all subdirectories within
the zip archive, must be specified.</p> </dd><dt><strong>cooked</strong></dt><dd> <p>By default, this function opens the
zip file in <strong>raw</strong> mode, which is faster but does not allow
a remote (Erlang) file server to be used. Adding <strong>cooked</strong>
to the mode list overrides the default and opens the zip file
without option <strong>raw</strong>. The same applies for the files
extracted.</p> </dd><dt><strong>keep_old_files</strong></dt><dd> <p>By default, all files with the same name as files in
the zip archive are overwritten. With option <strong>keep_old_files</strong>
set, function <strong>unzip/2</strong> does not overwrite existing files.
Notice that
even with option <strong>memory</strong> specified, which
means that no files are overwritten, existing files are
excluded from the result.</p> </dd><dt><strong>verbose</strong></dt><dd> <p>Prints an informational message for each extracted file.</p> </dd><dt><strong>memory</strong></dt><dd> <p>Instead of extracting to the current directory,
the result is given as a list of tuples
<strong>{Filename, Binary}</strong>, where <strong>Binary</strong> is a binary
containing the extracted data of file <strong>Filename</strong>
in the zip archive.</p> </dd><dt><strong>{cwd, CWD}</strong></dt><dd> <p>Uses the specified directory as current directory. It is
prepended to filenames when extracting them from the
zip archive. (Acting like
<a href="../kernel/file#set_cwd/1">kernel/file#set_cwd/1</a> in Kernel,
but without changing the global <strong>cwd</strong> property.)</p> </dd></dl><h3>zip/2</h3><h3>zip/3</h3><h3>create/2</h3><h3>create/3</h3><p>Create a zip archive with options.</p><p>Creates a zip archive containing the files specified in
<strong><span class="anno">FileList</span></strong>.</p><p><strong>create/2</strong> and <strong>create/3</strong> are provided as synonyms 
to resemble module 
<a href="erl_tar">erl_tar</a>.</p><p><strong><span class="anno">FileList</span></strong> is a list of files, with paths relative 
to the current directory, which are stored with this path in the
archive. Files can also be specified with data in binaries
to create an archive directly from data.</p><p>Files are compressed using the DEFLATE compression, as
described in the "Appnote.txt" file. However, files are
stored without compression if they are already compressed.
<strong>zip/2</strong> and <strong>zip/3</strong> check the file extension
to determine if the file is to be stored without compression.
Files with the following extensions are not compressed:
<strong>.Z</strong>, <strong>.zip</strong>, <strong>.zoo</strong>, <strong>.arc</strong>, <strong>.lzh</strong>,
<strong>.arj</strong>.</p><p>It is possible to override the default behavior and control
what types of files that are to be compressed by using options
<strong>{compress, <span class="anno">What</span>}</strong> and
<strong>{uncompress, <span class="anno">What</span>}</strong>. It is also possible to use
many <strong>compress</strong> and <strong>uncompress</strong> options.</p><p>To trigger file compression, its extension must match with the
<strong>compress</strong> condition and must not match the
<strong>uncompress</strong> condition. For example, if <strong>compress</strong> is
set to <strong>["gif", "jpg"]</strong> and <strong>uncompress</strong> is set to
<strong>["jpg"]</strong>, only files with extension <strong>"gif"</strong> are
compressed.</p><a name="zip_options"></a><p>Options:</p><dl><dt><strong>cooked</strong></dt><dd> <p>By default, this function opens the
zip file in mode <strong>raw</strong>, which is faster but does not allow
a remote (Erlang) file server to be used. Adding <strong>cooked</strong>
to the mode list overrides the default and opens the zip file
without the <strong>raw</strong> option. The same applies for the files
added.</p> </dd><dt><strong>verbose</strong></dt><dd> <p>Prints an informational message about each added file.</p> </dd><dt><strong>memory</strong></dt><dd> <p>The output is not to a file, but instead as a tuple
<strong>{<span class="anno">FileName</span>, binary()}</strong>. The binary is a full zip
archive with header and can be extracted with, for example,
<a href="#unzip/2">unzip/2</a>.</p> </dd><dt><strong>{comment, <span class="anno">Comment</span>}</strong></dt><dd> <p>Adds a comment to the zip archive.</p> </dd><dt><strong>{cwd, <span class="anno">CWD</span>}</strong></dt><dd> <p>Uses the specified directory as current work directory
(<strong>cwd</strong>). This is prepended to filenames when adding them,
although not in the zip archive (acting like
<a href="../kernel/file#set_cwd/1">kernel/file#set_cwd/1</a> in Kernel, but without
changing the global <strong>cwd</strong> property.).</p> </dd><dt><strong>{compress, <span class="anno">What</span>}</strong></dt><dd> <p>Controls what types of files to be compressed. Defaults to
<strong>all</strong>. The following values of <strong>What</strong> are allowed:</p> <dl><dt><strong>all</strong></dt><dd> <p>All files are compressed (as long
as they pass the <strong>uncompress</strong> condition).</p> </dd><dt><strong>[<span class="anno">Extension</span>]</strong></dt><dd> <p>Only files with exactly these extensions
are compressed.</p> </dd><dt><strong>{add,[<span class="anno">Extension</span>]}</strong></dt><dd> <p>Adds these extensions to the list of compress
extensions.</p> </dd><dt><strong>{del,[<span class="anno">Extension</span>]}</strong></dt><dd> <p>Deletes these extensions from the list of compress
extensions.</p> </dd></dl> </dd><dt><strong>{uncompress, <span class="anno">What</span>}</strong></dt><dd> <p>Controls what types of files to be uncompressed. Defaults to
<strong>[".Z", ".zip", ".zoo", ".arc", ".lzh", ".arj"]</strong>.
The following values of <strong>What</strong> are allowed:</p> <dl><dt><strong>all</strong></dt><dd> <p>No files are compressed.</p> </dd><dt><strong>[<span class="anno">Extension</span>]</strong></dt><dd> <p>Files with these extensions are uncompressed.</p> </dd><dt><strong>{add,[<span class="anno">Extension</span>]}</strong></dt><dd> <p>Adds these extensions to the list of uncompress
extensions.</p> </dd><dt><strong>{del,[<span class="anno">Extension</span>]}</strong></dt><dd> <p>Deletes these extensions from the list of uncompress
extensions.</p> </dd></dl> </dd></dl><h3>zip_close/1</h3><p>Close an open archive.</p><p>Closes a zip archive, previously opened with
<a href="#zip_open/1">zip_open/1</a>.
All resources are closed, and the handle is not to be used after
closing.</p><h3>zip_get/1</h3><h3>zip_get/2</h3><p>Extract files from an open archive.</p><p>Extracts one or all files from an open archive.</p><p>The files are unzipped to memory or to file, depending on
the options specified to function
<a href="#zip_open/1">zip_open/1</a>
when opening the archive.</p><h3>zip_list_dir/1</h3><p>Return a table of files in open zip archive.</p><p>Returns the file list of an open zip archive. The first returned
element is the zip archive comment.</p><h3>zip_open/1</h3><h3>zip_open/2</h3><p>Open an archive and return a handle to it.</p><p>Opens a zip archive, and reads and saves its directory. This
means that later reading files from the archive is
faster than unzipping files one at a time with
<a href="#unzip/1">unzip/1</a>.</p><p>The archive must be closed with
<a href="#zip_close/1">zip_close/1</a>.</p><p>The <strong><span class="anno">ZipHandle</span></strong> is closed if the
process that originally opened the archive dies.</p></body></html>