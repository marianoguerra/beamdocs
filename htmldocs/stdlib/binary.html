<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>binary</h1><h1>binary</h1><p>Library for handling binary data.</p><p>This module contains functions for manipulating byte-oriented
binaries. Although the majority of functions could be provided
using bit-syntax, the functions in this library are highly
optimized and are expected to either execute faster or consume
less memory, or both, than a counterpart written in pure Erlang.The module is provided according to Erlang Enhancement Proposal
(EEP) 31.</p><h1>Data Types</h1><span class="name">cp</span><p>Opaque data type representing a compiled
search pattern. Guaranteed to be a <strong>tuple()</strong> to allow programs to
distinguish it from non-precompiled search patterns.</p><span class="name">part</span><p>A representaion of a part (or range) in a binary. <strong>Start</strong> is
a zero-based offset into a <strong>binary()</strong> and <strong>Length</strong> is the
length of that part. As input to functions in this module, a reverse
part specification is allowed, constructed with a negative
<strong>Length</strong>, so that the part of the binary begins at <strong>Start</strong> +
<strong>Length</strong> and is -<strong>Length</strong> long. This is useful for referencing
the last <strong>N</strong> bytes of a binary as <strong>{size(Binary), -N}</strong>. The
functions in this module always return <strong>part()</strong>s with positive
<strong>Length</strong>.</p><h1>Functions</h1><h2>at/2</h2><p>Return the byte at a specific position in a binary.</p><p>Returns the byte at position <strong><span class="anno">Pos</span></strong> (zero-based) in
binary <strong><span class="anno">Subject</span></strong> as an integer. If
<strong><span class="anno">Pos</span></strong> &gt;= <strong>byte_size(<span class="anno">Subject</span>)</strong>,
a <strong>badarg</strong> exception is raised.</p><h2>bin_to_list/1</h2><p>Convert a binary to a list of integers.</p><p>Same as <strong>bin_to_list(<span class="anno">Subject</span>, {0,byte_size(<span class="anno">Subject</span>)})</strong>.</p><h2>bin_to_list/2</h2><p>Convert a binary to a list of integers.</p><p>Converts <strong><span class="anno">Subject</span></strong> to a list of <strong>byte()</strong>s, each
representing the value of one byte. <strong>part()</strong> denotes which part of
the <strong>binary()</strong> to convert.</p><p><em>Example:</em></p><pre><code class="">
1&gt; binary:bin_to_list(&lt;&lt;"erlang"&gt;&gt;, {1,3}).
"rla"
%% or [114,108,97] in list notation.</code></pre><p>If <strong><span class="anno">PosLen</span></strong> in any way references outside the binary,
a <strong>badarg</strong> exception is raised.</p><h2>bin_to_list/3</h2><p>Convert a binary to a list of integers.</p><p>Same as<strong> bin_to_list(<span class="anno">Subject</span>, {<span class="anno">Pos</span>, <span class="anno">Len</span>})</strong>.</p><h2>compile_pattern/1</h2><p>Precompile a binary search pattern.</p><p>Builds an internal structure representing a compilation of a
search pattern, later to be used in functions
<a href="#match-3">match-3</a>,
<a href="#matches-3">matches-3</a>,
<a href="#split-3">split-3</a>, or
<a href="#replace-4">replace-4</a>.
The <strong>cp()</strong> returned is guaranteed to be a
<strong>tuple()</strong> to allow programs to distinguish it from
non-precompiled search patterns.</p><p>When a list of binaries is specified, it denotes a set of
alternative binaries to search for. For example, if
<strong>[&lt;&lt;"functional"&gt;&gt;,&lt;&lt;"programming"&gt;&gt;]</strong>
is specified as <strong><span class="anno">Pattern</span></strong>, this
means either <strong>&lt;&lt;"functional"&gt;&gt;</strong> or
<strong>&lt;&lt;"programming"&gt;&gt;</strong>". The pattern is a set of
alternatives; when only a single binary is specified, the set has
only one element. The order of alternatives in a pattern is
not significant.</p><p>The list of binaries used for search alternatives must be flat and
proper.</p><p>If <strong><span class="anno">Pattern</span></strong> is not a binary or a flat proper list of
binaries with length &gt; 0, a <strong>badarg</strong> exception is raised.</p><h2>copy/1</h2><p>Create a duplicate of a binary.</p><p>Same as <strong>copy(<span class="anno">Subject</span>, 1)</strong>.</p><h2>copy/2</h2><p>Duplicate a binary <strong>N</strong> times and create a new.</p><p>Creates a binary with the content of <strong><span class="anno">Subject</span></strong>
duplicated <strong><span class="anno">N</span></strong> times.</p><p>This function always creates a new binary, even if <strong><span class="anno">N</span> = 1</strong>. By using <a href="#copy/1">copy/1</a>
on a binary referencing a larger binary, one
can free up the larger binary for garbage collection.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>By deliberately copying a single binary to avoid referencing
a larger binary, one can, instead of freeing up the larger
binary for later garbage collection, create much more binary
data than needed. Sharing binary data is usually good. Only in
special cases, when small parts reference large binaries and the
large binaries are no longer used in any process, deliberate
copying can be a good idea.</p></div><p>If <strong><span class="anno">N</span></strong> &lt; <strong>0</strong>, a <strong>badarg</strong> exception is
raised.</p><h2>decode_unsigned/1</h2><p>Decode a whole binary into an integer of arbitrary size. </p><p>Same as <strong>decode_unsigned(<span class="anno">Subject</span>, big)</strong>.</p><h2>decode_unsigned/2</h2><p>Decode a whole binary into an integer of arbitrary size. </p><p>Converts the binary digit representation, in big endian or little
endian, of a positive integer in <strong><span class="anno">Subject</span></strong> to an Erlang
<strong>integer()</strong>.</p><p><em>Example:</em></p><pre><code class="">
1&gt; binary:decode_unsigned(&lt;&lt;169,138,199&gt;&gt;,big).
11111111</code></pre><h2>encode_unsigned/1</h2><p>Encode an unsigned integer into the minimal binary.</p><p>Same as <strong>encode_unsigned(<span class="anno">Unsigned</span>, big)</strong>.</p><h2>encode_unsigned/2</h2><p>Encode an unsigned integer into the minimal binary.</p><p>Converts a positive integer to the smallest possible
representation in a binary digit representation, either big endian
or little endian.</p><p><em>Example:</em></p><pre><code class="">
1&gt; binary:encode_unsigned(11111111, big).
&lt;&lt;169,138,199&gt;&gt;</code></pre><h2>first/1</h2><p>Return the first byte of a binary.</p><p>Returns the first byte of binary <strong><span class="anno">Subject</span></strong> as an
integer. If the size of <strong><span class="anno">Subject</span></strong> is zero, a
<strong>badarg</strong> exception is raised.</p><h2>last/1</h2><p>Return the last byte of a binary.</p><p>Returns the last byte of binary <strong><span class="anno">Subject</span></strong> as an
integer. If the size of <strong><span class="anno">Subject</span></strong> is zero, a
<strong>badarg</strong> exception is raised.</p><h2>list_to_bin/1</h2><p>Convert a list of integers and binaries to a binary.</p><p>Works exactly as
<a href="../erts/erlang#list_to_binary/1">erts/erlang#list_to_binary/1</a>,
added for completeness.</p><h2>longest_common_prefix/1</h2><p>Return length of longest common prefix for a set of binaries. </p><p>Returns the length of the longest common prefix of the
binaries in list <strong><span class="anno">Binaries</span></strong>.</p><p><em>Example:</em></p><pre><code class="">
1&gt; binary:longest_common_prefix([&lt;&lt;"erlang"&gt;&gt;, &lt;&lt;"ergonomy"&gt;&gt;]).
2
2&gt; binary:longest_common_prefix([&lt;&lt;"erlang"&gt;&gt;, &lt;&lt;"perl"&gt;&gt;]).
0</code></pre><p>If <strong><span class="anno">Binaries</span></strong> is not a flat list of binaries, a
<strong>badarg</strong> exception is raised.</p><h2>longest_common_suffix/1</h2><p>Return length of longest common suffix for a set of binaries. </p><p>Returns the length of the longest common suffix of the
binaries in list <strong><span class="anno">Binaries</span></strong>.</p><p><em>Example:</em></p><pre><code class="">
1&gt; binary:longest_common_suffix([&lt;&lt;"erlang"&gt;&gt;, &lt;&lt;"fang"&gt;&gt;]).
3
2&gt; binary:longest_common_suffix([&lt;&lt;"erlang"&gt;&gt;, &lt;&lt;"perl"&gt;&gt;]).
0</code></pre><p>If <strong>Binaries</strong> is not a flat list of binaries, a <strong>badarg</strong>
exception is raised.</p><h2>match/2</h2><p>Search for the first match of a pattern in a binary.</p><p>Same as <strong>match(<span class="anno">Subject</span>, <span class="anno">Pattern</span>, [])</strong>.
</p><h2>match/3</h2><p>Search for the first match of a pattern in a binary.</p><ul><li>part</li></ul><p>Searches for the first occurrence of <strong><span class="anno">Pattern</span></strong> in
<strong><span class="anno">Subject</span></strong> and returns the position and length.</p><p>The function returns <strong>{Pos, Length}</strong> for the binary
in <strong><span class="anno">Pattern</span></strong>, starting at the lowest position in
<strong><span class="anno">Subject</span></strong>.</p><p><em>Example:</em></p><pre><code class="">
1&gt; binary:match(&lt;&lt;"abcde"&gt;&gt;, [&lt;&lt;"bcde"&gt;&gt;, &lt;&lt;"cd"&gt;&gt;],[]).
{1,4}</code></pre><p>Even though <strong>&lt;&lt;"cd"&gt;&gt;</strong> ends before
<strong>&lt;&lt;"bcde"&gt;&gt;</strong>, <strong>&lt;&lt;"bcde"&gt;&gt;</strong>
begins first and is therefore the first match. If two
overlapping matches begin at the same position, the longest is
returned.</p><p>Summary of the options:</p><dl><dt>{scope, {<span class="anno">Start</span>, <span class="anno">Length</span>}}</dt><dd><p>Only the specified part is searched. Return values still have
offsets from the beginning of <strong><span class="anno">Subject</span></strong>. A negative
<strong>Length</strong> is allowed as described in section Data Types in this
manual.</p></dd></dl><p>If none of the strings in <strong><span class="anno">Pattern</span></strong> is found, the
atom <strong>nomatch</strong> is returned.</p><p>For a description of <strong><span class="anno">Pattern</span></strong>, see function
<a href="#compile_pattern-1">compile_pattern-1</a>.
</p><p>If <strong>{scope, {Start,Length}}</strong> is specified in the options such
that <strong>Start</strong> &gt; size of <strong>Subject</strong>, <strong>Start</strong> +
<strong>Length</strong> &lt; 0 or <strong>Start</strong> + <strong>Length</strong> &gt; size of
<strong>Subject</strong>, a <strong>badarg</strong> exception is raised.</p><h2>matches/2</h2><p>Search for all matches of a pattern in a binary.</p><p>Same as <strong>matches(<span class="anno">Subject</span>, <span class="anno">Pattern</span>, [])</strong>.
</p><h2>matches/3</h2><p>Search for all matches of a pattern in a binary.</p><ul><li>part</li></ul><p>As <a href="#match-2">match-2</a>,
but <strong><span class="anno">Subject</span></strong> is searched until
exhausted and a list of all non-overlapping parts matching
<strong><span class="anno">Pattern</span></strong> is returned (in order).</p><p>The first and longest match is preferred to a shorter,
which is illustrated by the following example:</p><pre><code class="">
1&gt; binary:matches(&lt;&lt;"abcde"&gt;&gt;,
                  [&lt;&lt;"bcde"&gt;&gt;,&lt;&lt;"bc"&gt;&gt;,&lt;&lt;"de"&gt;&gt;],[]).
[{1,4}]</code></pre><p>The result shows that &lt;&lt;"bcde"&gt;&gt; is selected instead of
the shorter match &lt;&lt;"bc"&gt;&gt; (which would have given raise to
one more match, &lt;&lt;"de"&gt;&gt;).
This corresponds to the behavior of
POSIX regular expressions (and programs like awk), but is not
consistent with alternative matches in <strong>re</strong> (and Perl), where
instead lexical ordering in the search pattern selects which
string matches.</p><p>If none of the strings in a pattern is found, an empty list is
returned.</p><p>For a description of <strong><span class="anno">Pattern</span></strong>, see
<a href="#compile_pattern-1">compile_pattern-1</a>.
For a description of available options, see
<a href="#match-3">match-3</a>.</p><p>If <strong>{scope, {<span class="anno">Start</span>,<span class="anno">Length</span>}}</strong> is
specified in the options such that <strong><span class="anno">Start</span></strong> &gt; size
of <strong><span class="anno">Subject</span></strong>, <strong><span class="anno">Start</span> + <span class="anno">Length</span></strong> &lt; 0 or <strong><span class="anno">Start</span> + <span class="anno">Length</span></strong> is &gt; size of <strong><span class="anno">Subject</span></strong>,
a <strong>badarg</strong> exception is raised.</p><h2>part/2</h2><p>Extract a part of a binary.</p><p>Extracts the part of binary <strong><span class="anno">Subject</span></strong> described by
<strong><span class="anno">PosLen</span></strong>.</p><p>A negative length can be used to extract bytes at the end of a
binary:</p><pre><code class="">
1&gt; Bin = &lt;&lt;1,2,3,4,5,6,7,8,9,10&gt;&gt;.
2&gt; binary:part(Bin, {byte_size(Bin), -5}).
&lt;&lt;6,7,8,9,10&gt;&gt;</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><a href="#part-2">part/2</a> and
<a href="#part-3">part/3</a> are also available in the
<a href="./erlang">erts/erlang</a>
module under the names <strong>binary_part/2</strong> and
<strong>binary_part/3</strong>. Those BIFs are allowed in guard tests.</p></div><p>If <strong><span class="anno">PosLen</span></strong> in any way references outside the binary,
a <strong>badarg</strong> exception is raised.</p><h2>part/3</h2><p>Extract a part of a binary.</p><p>Same as <strong>part(<span class="anno">Subject</span>, {<span class="anno">Pos</span>, <span class="anno">Len</span>})</strong>.</p><h2>referenced_byte_size/1</h2><p>Determine the size of the binary pointed out by a subbinary. </p><p>If a binary references a larger binary (often described as
being a subbinary), it can be useful to get the size of the
referenced binary. This function can be used in a program to trigger the
use of <a href="#copy/1">copy/1</a>. By copying a
binary, one can dereference the original, possibly large, binary that a
smaller binary is a reference to.</p><p><em>Example:</em></p><pre><code class="">
store(Binary, GBSet) -&gt;
  NewBin =
      case binary:referenced_byte_size(Binary) of
          Large when Large &gt; 2 * byte_size(Binary) -&gt;
             binary:copy(Binary);
          _ -&gt;
             Binary
      end,
  gb_sets:insert(NewBin,GBSet).</code></pre><p>In this example, we chose to copy the binary content before
inserting it in <strong>gb_sets:set()</strong> if it references a binary more than
twice the data size we want to keep. Of course,
different rules apply when copying to different programs.</p><p>Binary sharing occurs whenever binaries are taken apart.
This is the fundamental reason why binaries are fast,
decomposition can always be done with O(1) complexity. In rare
circumstances this data sharing is however undesirable, why this
function together with <strong>copy/1</strong> can be useful when optimizing
for memory use.</p><p>Example of binary sharing:</p><pre><code class="">
1&gt; A = binary:copy(&lt;&lt;1&gt;&gt;, 100).
&lt;&lt;1,1,1,1,1 ...
2&gt; byte_size(A).
100
3&gt; binary:referenced_byte_size(A)
100
4&gt; &lt;&lt;_:10/binary,B:10/binary,_/binary&gt;&gt; = A.
&lt;&lt;1,1,1,1,1 ...
5&gt; byte_size(B).
10
6&gt; binary:referenced_byte_size(B)
100</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Binary data is shared among processes. If another process
still references the larger binary, copying the part this
process uses only consumes more memory and does not free up the
larger binary for garbage collection. Use this kind of intrusive
functions with extreme care and only if a real problem is detected.</p></div><h2>replace/3</h2><p>Replace bytes in a binary according to a pattern.</p><p>Same as <strong>replace(<span class="anno">Subject</span>, <span class="anno">Pattern</span>, <span class="anno">Replacement</span>,[])</strong>.</p><h2>replace/4</h2><p>Replace bytes in a binary according to a pattern.</p><dl><dt>OnePos</dt><dd>An integer() =&lt; byte_size(<span class="anno">Replacement</span>) </dd></dl><p>Constructs a new binary by replacing the parts in
<strong><span class="anno">Subject</span></strong> matching <strong><span class="anno">Pattern</span></strong> with
the content of <strong><span class="anno">Replacement</span></strong>.</p><p>If the matching subpart of <strong><span class="anno">Subject</span></strong> giving raise
to the replacement is to be inserted in the result, option
<strong>{insert_replaced, <span class="anno">InsPos</span>}</strong> inserts the matching part
into <strong><span class="anno">Replacement</span></strong> at the specified position (or
positions) before inserting <strong><span class="anno">Replacement</span></strong> into
<strong><span class="anno">Subject</span></strong>.</p><p><em>Example:</em></p><pre><code class="">
1&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,&lt;&lt;"b"&gt;&gt;,&lt;&lt;"[]"&gt;&gt;, [{insert_replaced,1}]).
&lt;&lt;"a[b]cde"&gt;&gt;
2&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,[&lt;&lt;"b"&gt;&gt;,&lt;&lt;"d"&gt;&gt;],&lt;&lt;"[]"&gt;&gt;,[global,{insert_replaced,1}]).
&lt;&lt;"a[b]c[d]e"&gt;&gt;
3&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,[&lt;&lt;"b"&gt;&gt;,&lt;&lt;"d"&gt;&gt;],&lt;&lt;"[]"&gt;&gt;,[global,{insert_replaced,[1,1]}]).
&lt;&lt;"a[bb]c[dd]e"&gt;&gt;
4&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,[&lt;&lt;"b"&gt;&gt;,&lt;&lt;"d"&gt;&gt;],&lt;&lt;"[-]"&gt;&gt;,[global,{insert_replaced,[1,2]}]).
&lt;&lt;"a[b-b]c[d-d]e"&gt;&gt;</code></pre><p>If any position specified in <strong><span class="anno">InsPos</span></strong> &gt; size
of the replacement binary, a <strong>badarg</strong> exception is raised.</p><p>Options <strong>global</strong> and <strong>{scope, part()}</strong> work as for
<a href="#split-3">split-3</a>.
The return type is always a <strong>binary()</strong>.</p><p>For a description of <strong><span class="anno">Pattern</span></strong>, see
<a href="#compile_pattern-1">compile_pattern-1</a>.
</p><h2>split/2</h2><p>Split a binary according to a pattern.</p><p>Same as <strong>split(<span class="anno">Subject</span>, <span class="anno">Pattern</span>, [])</strong>.</p><h2>split/3</h2><p>Split a binary according to a pattern.</p><p>Splits <strong><span class="anno">Subject</span></strong> into a list of binaries based on
<strong><span class="anno">Pattern</span></strong>. If option <strong>global</strong> is not specified,
only the first occurrence of <strong><span class="anno">Pattern</span></strong> in
<strong><span class="anno">Subject</span></strong> gives rise to a split.</p><p>The parts of <strong><span class="anno">Pattern</span></strong> found in
<strong><span class="anno">Subject</span></strong> are not included in the result.</p><p><em>Example:</em></p><pre><code class="">
1&gt; binary:split(&lt;&lt;1,255,4,0,0,0,2,3&gt;&gt;, [&lt;&lt;0,0,0&gt;&gt;,&lt;&lt;2&gt;&gt;],[]).
[&lt;&lt;1,255,4&gt;&gt;, &lt;&lt;2,3&gt;&gt;]
2&gt; binary:split(&lt;&lt;0,1,0,0,4,255,255,9&gt;&gt;, [&lt;&lt;0,0&gt;&gt;, &lt;&lt;255,255&gt;&gt;],[global]).
[&lt;&lt;0,1&gt;&gt;,&lt;&lt;4&gt;&gt;,&lt;&lt;9&gt;&gt;]</code></pre><p>Summary of options:</p><dl><dt>{scope, part()}</dt><dd><p>Works as in <a href="#match-3">match-3</a>
and <a href="#matches-3">matches-3</a>. Notice that
this only defines the scope of the search for matching strings,
it does not cut the binary before splitting. The bytes before and after
the scope are kept in the result. See the example below.</p></dd><dt>trim</dt><dd><p>Removes trailing empty parts of the result (as does <strong>trim</strong>
in <a href="./re#split/3">re#split/3</a>.</p></dd><dt>trim_all</dt><dd><p>Removes all empty parts of the result.</p></dd><dt>global</dt><dd><p>Repeats the split until <strong><span class="anno">Subject</span></strong> is
exhausted. Conceptually option <strong>global</strong> makes split work
on the positions returned by
<a href="#matches-3">matches-3</a>, while it
normally works on the position returned by
<a href="#match-3">match-3</a>.</p></dd></dl><p>Example of the difference between a scope and taking the
binary apart before splitting:</p><pre><code class="">
1&gt; binary:split(&lt;&lt;"banana"&gt;&gt;, [&lt;&lt;"a"&gt;&gt;],[{scope,{2,3}}]).
[&lt;&lt;"ban"&gt;&gt;,&lt;&lt;"na"&gt;&gt;]
2&gt; binary:split(binary:part(&lt;&lt;"banana"&gt;&gt;,{2,3}), [&lt;&lt;"a"&gt;&gt;],[]).
[&lt;&lt;"n"&gt;&gt;,&lt;&lt;"n"&gt;&gt;]</code></pre><p>The return type is always a list of binaries that are all
referencing <strong><span class="anno">Subject</span></strong>. This means that the data in
<strong><span class="anno">Subject</span></strong> is not copied to new binaries, and that
<strong><span class="anno">Subject</span></strong> cannot be garbage collected until the results
of the split are no longer referenced.</p><p>For a description of <strong><span class="anno">Pattern</span></strong>, see
<a href="#compile_pattern-1">compile_pattern-1</a>.
</p></body></html>