<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>io_lib</h1><h1>io_lib</h1><p>I/O library functions.</p><p>This module contains functions for converting to and from
strings (lists of characters). They are used for implementing the
functions in the <a href="io">io</a> module.
There is no guarantee that the
character lists returned from some of the functions are flat,
they can be deep lists. Function
<a href="./lists#flatten/1">lists#flatten/1</a>
can be used for flattening deep lists.</p><h1>Data Types</h1><span class="name">chars</span><span class="name">continuation</span><p>A continuation as returned by
<a href="#fread/3">fread/3</a>.</p><span class="name">chars_limit</span><span class="name">depth</span><span class="name">fread_error</span><span class="name">fread_item</span><span class="name">latin1_string</span><span class="name">format_spec</span><p>Where:</p><ul><li><p><strong>control_char</strong> is the type of control
sequence: <strong>$P</strong>, <strong>$w</strong>, and so on.</p> </li><li><p><strong>args</strong> is a list of the arguments used by the
control sequence, or an empty list if the control sequence
does not take any arguments.</p> </li><li><p><strong>width</strong> is the field width.</p> </li><li><p><strong>adjust</strong> is the adjustment.</p> </li><li><p><strong>precision</strong> is the precision of the printed
argument.</p> </li><li><p><strong>pad_char</strong> is the padding character.</p> </li><li><p><strong>encoding</strong> is set to <strong>true</strong> if translation
modifier <strong>t</strong> is present.</p> </li><li><p><strong>strings</strong> is set to <strong>false</strong> if modifier
<strong>l</strong> is present.</p> </li></ul><h1>Functions</h1><h2>build_text/1</h2><p>Build the output text for a preparsed format list.</p><p>For details, see
<a href="#scan_format/2">scan_format/2</a>.</p><h2>char_list/1</h2><p>Test for a list of characters.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a flat list of
characters in the Unicode range, otherwise <strong>false</strong>.</p><h2>deep_char_list/1</h2><p>Test for a deep list of characters.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a, possibly deep,
list of characters in the Unicode range, otherwise <strong>false</strong>.</p><h2>deep_latin1_char_list/1</h2><p>Test for a deep list of characters.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a, possibly deep,
list of characters in the ISO Latin-1 range, otherwise
<strong>false</strong>.</p><h2>format/2</h2><h2>fwrite/2</h2><p>Write formatted output.</p><p>Returns a character list that represents <strong><span class="anno">Data</span></strong>
formatted in accordance with <strong><span class="anno">Format</span></strong>.
For a detailed description of the available formatting options, see
<a href="./io#fwrite/1">io#fwrite/1</a>.
If the format string or argument list contains an error, a fault is
generated.</p><p>If and only if the Unicode translation modifier is used in the
format string (that is, <strong>~ts</strong> or <strong>~tc</strong>), the resulting list
can contain characters beyond the ISO Latin-1 character range
(that is, numbers &gt; 255). If so, the
result is still an ordinary Erlang <strong>string()</strong>, and can well be
used in any context where Unicode data is allowed.</p><h2>format/3</h2><h2>fwrite/3</h2><p>Write formatted output.</p><p>Returns a character list that represents <strong><span class="anno">Data</span></strong>
formatted in accordance with <strong><span class="anno">Format</span></strong> in
the same way as
<a href="#fwrite/2">fwrite/2</a> and
<a href="#format/2">format/2</a>,
but takes an extra argument, a list of options.</p><p>Valid option:</p><dl><dt><strong>{chars_limit, <span class="anno">CharsLimit</span>}</strong></dt><dd> <p>A soft limit on the number of characters returned.
When the number of characters is reached, remaining
structures are replaced by "<strong>...</strong>".
<strong><span class="anno">CharsLimit</span></strong> defaults to -1, which
means no limit on the number of characters returned.</p> </dd></dl><h2>fread/2</h2><p>Read formatted input.</p><p>Tries to read <strong><span class="anno">String</span></strong> in accordance with the
control sequences in <strong><span class="anno">Format</span></strong>.
For a detailed description of the available formatting options, see
<a href="./io#fread/3">io#fread/3</a>. It is
assumed that <strong><span class="anno">String</span></strong> contains whole lines.</p><p>The function returns:</p><dl><dt><strong>{ok, <span class="anno">InputList</span>, <span class="anno">LeftOverChars</span>}</strong></dt><dd> <p>The string was read. <strong><span class="anno">InputList</span></strong> is the list
of successfully matched and read items, and
<strong><span class="anno">LeftOverChars</span></strong> are the input characters not
used.</p> </dd><dt><strong>{more, <span class="anno">RestFormat</span>, <span class="anno">Nchars</span>, <span class="anno">InputStack</span>}</strong></dt><dd> <p>The string was read, but more input is needed to complete the
original format string. <strong><span class="anno">RestFormat</span></strong> is the
remaining format string, <strong><span class="anno">Nchars</span></strong> is the number
of characters scanned, and <strong><span class="anno">InputStack</span></strong> is the
reversed list of inputs matched up to that point.</p> </dd><dt><strong>{error, <span class="anno">What</span>}</strong></dt><dd> <p>The read operation failed and parameter <strong><span class="anno">What</span></strong>
gives a hint about the error.</p> </dd></dl><p><em>Example:</em></p><pre>
3&gt; <span class="input">io_lib:fread("~f~f~f", "15.6 17.3e-6 24.5").</span>
{ok,[15.6,1.73e-5,24.5],[]}</pre><h2>fread/3</h2><p>Re-entrant formatted reader</p><p>This is the re-entrant formatted reader. The continuation of
the first call to the functions must be <strong>[]</strong>. For a complete
description of how the re-entrant input scheme works, see
Armstrong, Virding, Williams: 'Concurrent Programming in
Erlang', Chapter 13.</p><p>The function returns:</p><dl><dt><strong>{done, <span class="anno">Result</span>, <span class="anno">LeftOverChars</span>}</strong></dt><dd> <p>The input is complete. The result is one of the following:</p> <dl><dt><strong>{ok, <span class="anno">InputList</span>}</strong></dt><dd> <p>The string was read. <strong><span class="anno">InputList</span></strong> is the
list of successfully matched and read items, and
<strong><span class="anno">LeftOverChars</span></strong> are the remaining
characters.</p> </dd><dt><strong>eof</strong></dt><dd> <p>End of file was encountered.
<strong><span class="anno">LeftOverChars</span></strong> are the input characters not
used.</p> </dd><dt><strong>{error, <span class="anno">What</span>}</strong></dt><dd> <p>An error occurred and parameter <strong><span class="anno">What</span></strong>
gives a hint about the error.</p> </dd></dl> </dd><dt><strong>{more, <span class="anno">Continuation</span>}</strong></dt><dd> <p>More data is required to build a term.
<strong><span class="anno">Continuation</span></strong> must be passed to <strong>fread/3</strong>
when more data becomes available.</p> </dd></dl><h2>indentation/2</h2><p>Indentation after printing string.</p><p>Returns the indentation if <strong><span class="anno">String</span></strong> has been
printed, starting at <strong><span class="anno">StartIndent</span></strong>.</p><h2>latin1_char_list/1</h2><p>Test for a list of ISO Latin-1 characters.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a flat list of
characters in the ISO Latin-1 range, otherwise <strong>false</strong>.</p><h2>nl/0</h2><p>Write a newline.</p><p>Returns a character list that represents a new line character.</p><h2>print/1</h2><h2>print/4</h2><p>Pretty print a term.</p><p>Returns a list of characters that represents
<strong><span class="anno">Term</span></strong>, but breaks representations longer
than one line into many lines and indents each line sensibly.
Also tries to detect and output lists of printable characters
as strings.</p><ul><li><strong><span class="anno">Column</span></strong> is the starting column; defaults to 1.</li><li><strong><span class="anno">LineLength</span></strong> is the maximum line length; defaults to 80.</li><li><strong><span class="anno">Depth</span></strong> is the maximum print depth; defaults to -1, which means no limitation.</li></ul><h2>printable_latin1_list/1</h2><p>Test for a list of printable ISO Latin-1 characters.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a flat list of
printable ISO Latin-1 characters, otherwise <strong>false</strong>.</p><h2>printable_list/1</h2><p>Test for a list of printable characters.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a flat list of
printable characters, otherwise <strong>false</strong>.</p><p>What is a printable character in this case is determined by
startup flag <strong>+pc</strong> to the Erlang VM; see
<a href="./io#printable_range/0">io#printable_range/0</a> and 
<a href="./erl">erts/erl</a>.</p><h2>printable_unicode_list/1</h2><p>Test for a list of printable Unicode characters.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a flat list of
printable Unicode characters, otherwise <strong>false</strong>.</p><h2>scan_format/2</h2><p>Parse all control sequences in the format string.</p><p>Returns a list corresponding to the specified format string,
where control sequences have been replaced with
corresponding tuples. This list can be passed to:</p><ul><li> <p><a href="#build_text/1">build_text/1</a>
to have the same effect as <strong>format(Format, Args)</strong></p> </li><li> <p><a href="#unscan_format/1">unscan_format/1</a> to get the corresponding pair
of <strong>Format</strong> and <strong>Args</strong> (with every <strong>*</strong> and
corresponding argument expanded to numeric values)</p> </li></ul><p>A typical use of this function is to replace unbounded-size
control sequences like <strong>~w</strong> and <strong>~p</strong> with the
depth-limited variants <strong>~W</strong> and <strong>~P</strong> before
formatting to text in, for example, a logger.</p><h2>unscan_format/1</h2><p>Revert a preparsed format list to a plain character list and a list of arguments.</p><p>For details, see
<a href="#scan_format/2">scan_format/2</a>.</p><h2>write/1</h2><h2>write/2</h2><h2>write/2</h2><p>Write a term.</p><p>Returns a character list that represents <strong><span class="anno">Term</span></strong>.
Option <strong><span class="anno">Depth</span></strong> controls the depth of the
structures written. When the specified depth is reached,
everything below this level is replaced by "<strong>...</strong>".
<strong><span class="anno">Depth</span></strong> defaults to -1, which means
no limitation. Option <strong><span class="anno">CharsLimit</span></strong> puts a
soft limit on the number of characters returned. When the
number of characters is reached, remaining structures are
replaced by "<strong>...</strong>". <strong><span class="anno">CharsLimit</span></strong>
defaults to -1, which means no limit on the number of
characters returned.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">lists:flatten(io_lib:write({1,[2],[3],[4,5],6,7,8,9})).</span>
"{1,[2],[3],[4,5],6,7,8,9}"
2&gt; <span class="input">lists:flatten(io_lib:write({1,[2],[3],[4,5],6,7,8,9}, 5)).</span>
"{1,[2],[3],[...],...}"
3&gt; <span class="input">lists:flatten(io_lib:write({[1,2,3],[4,5],6,7,8,9}, [{chars_limit,20}])).</span>
"{[1,2|...],[4|...],...}"</pre><h2>write_atom/1</h2><p>Write an atom.</p><p>Returns the list of characters needed to print atom
<strong><span class="anno">Atom</span></strong>.</p><h2>write_atom_as_latin1/1</h2><p>Write an atom.</p><p>Returns the list of characters needed to print atom
<strong><span class="anno">Atom</span></strong>. Non-Latin-1 characters
are escaped.</p><h2>write_char/1</h2><p>Write a character.</p><p>Returns the list of characters needed to print a character
constant in the Unicode character set.</p><h2>write_char_as_latin1/1</h2><p>Write a character.</p><p>Returns the list of characters needed to print a character
constant in the Unicode character set. Non-Latin-1 characters
are escaped.</p><h2>write_latin1_char/1</h2><p>Write an ISO Latin-1 character.</p><p>Returns the list of characters needed to print a character
constant in the ISO Latin-1 character set.</p><h2>write_latin1_string/1</h2><p>Write an ISO Latin-1 string.</p><p>Returns the list of characters needed to print
<strong><span class="anno">Latin1String</span></strong> as a string.</p><h2>write_string/1</h2><p>Write a string.</p><p>Returns the list of characters needed to print
<strong><span class="anno">String</span></strong> as a string.</p><h2>write_string_as_latin1/1</h2><p>Write a string.</p><p>Returns the list of characters needed to print
<strong><span class="anno">String</span></strong> as a string. Non-Latin-1
characters are escaped.</p></body></html>