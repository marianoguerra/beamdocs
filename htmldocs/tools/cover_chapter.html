<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>cover</h1><h2>Introduction</h2><p>The module <strong>cover</strong> provides a set of functions for coverage
analysis of Erlang programs, counting how many times each
<a href="#lines">executable line</a> is executed.</p><p>Coverage analysis can be used to verify test cases, making sure all
relevant code is covered, and may be helpful when looking for
bottlenecks in the code.</p><h2>Getting Started With Cover</h2><h2>Example</h2><p>Assume that a test case for the following program should be
verified:</p><pre><code class="">
-module(channel).
-behaviour(gen_server).

-export([start_link/0,stop/0]).
-export([alloc/0,free/1]). % client interface
-export([init/1,handle_call/3,terminate/2]). % callback functions

start_link() -&gt;
    gen_server:start_link({local,channel},channel,[],[]).

stop() -&gt;
    gen_server:call(channel,stop).

%%%-Client interface functions-------------------------------------------

alloc() -&gt;
    gen_server:call(channel,alloc).

free(Channel) -&gt;
    gen_server:call(channel,{free,Channel}).

%%%-gen_server callback functions----------------------------------------

init(_Arg) -&gt;
    {ok,channels()}.

handle_call(stop,Client,Channels) -&gt;
    {stop,normal,ok,Channels};

handle_call(alloc,Client,Channels) -&gt;
    {Ch,Channels2} = alloc(Channels),
    {reply,{ok,Ch},Channels2};

handle_call({free,Channel},Client,Channels) -&gt;
    Channels2 = free(Channel,Channels),
    {reply,ok,Channels2}.

terminate(_Reason,Channels) -&gt;
    ok.

%%%-Internal functions---------------------------------------------------

channels() -&gt;
    [ch1,ch2,ch3].

alloc([Channel|Channels]) -&gt;
    {Channel,Channels};
alloc([]) -&gt;
    false.

free(Channel,Channels) -&gt;
    [Channel|Channels].</code></pre><p>The test case is implemented as follows:</p><pre><code class="">
-module(test).
-export([s/0]).

s() -&gt;
    {ok,Pid} = channel:start_link(),
    {ok,Ch1} = channel:alloc(),
    ok = channel:free(Ch1),
    ok = channel:stop().</code></pre><h2>Preparation</h2><p>First of all, Cover must be started. This spawns a process which
owns the Cover database where all coverage data will be stored.</p><pre>
1&gt; <span class="input">cover:start().</span>
{ok,&lt;0.30.0&gt;}</pre><p>To include other nodes in the coverage analysis, use
<strong>start/1</strong>. All cover compiled modules will then be loaded
on all nodes, and data from all nodes will be summed up when
analysing. For simplicity this example only involves the
current node.</p><p>Before any analysis can take place, the involved modules must be
<em>Cover compiled</em>. This means that some extra information is
added to the module before it is compiled into a binary which then
is <a href="#loading">loaded</a>. The source file of
the module is not affected and no <strong>.beam</strong> file is created.</p><pre>
2&gt; <span class="input">cover:compile_module(channel).</span>
{ok,channel}</pre><p>Each time a function in the Cover compiled module <strong>channel</strong>
is called, information about the call will be added to the Cover
database. Run the test case:</p><pre>
3&gt; <span class="input">test:s().</span>
ok</pre><p>Cover analysis is performed by examining the contents of the Cover
database. The output is determined by two parameters, <strong>Level</strong>
and <strong>Analysis</strong>. <strong>Analysis</strong> is either <strong>coverage</strong> or
<strong>calls</strong> and determines the type of the analysis. <strong>Level</strong>
is either <strong>module</strong>, <strong>function</strong>, <strong>clause</strong>, or
<strong>line</strong> and determines the level of the analysis.</p><h2>Coverage Analysis</h2><p>Analysis of type <strong>coverage</strong> is used to find out how much of
the code has been executed and how much has not been executed.
Coverage is represented by a tuple <strong>{Cov,NotCov}</strong>, where
<strong>Cov</strong> is the number of executable lines that have been executed
at least once and <strong>NotCov</strong> is the number of executable lines
that have not been executed.</p><p>If the analysis is made on module level, the result is given for
the entire module as a tuple <strong>{Module,{Cov,NotCov}}</strong>:</p><pre>
4&gt; <span class="input">cover:analyse(channel,coverage,module).</span>
{ok,{channel,{14,1}}}</pre><p>For <strong>channel</strong>, the result shows that 14 lines in the module
are covered but one line is not covered.</p><p>If the analysis is made on function level, the result is given as
a list of tuples <strong>{Function,{Cov,NotCov}}</strong>, one for each
function in the module. A function is specified by its module name,
function name and arity:</p><pre>
5&gt; <span class="input">cover:analyse(channel,coverage,function).</span>
{ok,[{{channel,start_link,0},{1,0}},
     {{channel,stop,0},{1,0}},
     {{channel,alloc,0},{1,0}},
     {{channel,free,1},{1,0}},
     {{channel,init,1},{1,0}},
     {{channel,handle_call,3},{5,0}},
     {{channel,terminate,2},{1,0}},
     {{channel,channels,0},{1,0}},
     {{channel,alloc,1},{1,1}},
     {{channel,free,2},{1,0}}]}</pre><p>For <strong>channel</strong>, the result shows that the uncovered line is in
the function <strong>channel:alloc/1</strong>.</p><p>If the analysis is made on clause level, the result is given as
a list of tuples <strong>{Clause,{Cov,NotCov}}</strong>, one for each
function clause in the module. A clause is specified by its module
name, function name, arity and position within the function
definition:</p><pre>
6&gt; <span class="input">cover:analyse(channel,coverage,clause).</span>
{ok,[{{channel,start_link,0,1},{1,0}},
     {{channel,stop,0,1},{1,0}},
     {{channel,alloc,0,1},{1,0}},
     {{channel,free,1,1},{1,0}},
     {{channel,init,1,1},{1,0}},
     {{channel,handle_call,3,1},{1,0}},
     {{channel,handle_call,3,2},{2,0}},
     {{channel,handle_call,3,3},{2,0}},
     {{channel,terminate,2,1},{1,0}},
     {{channel,channels,0,1},{1,0}},
     {{channel,alloc,1,1},{1,0}},
     {{channel,alloc,1,2},{0,1}},
     {{channel,free,2,1},{1,0}}]}</pre><p>For <strong>channel</strong>, the result shows that the uncovered line is in
the second clause of <strong>channel:alloc/1</strong>.</p><p>Finally, if the analysis is made on line level, the result is given
as a list of tuples <strong>{Line,{Cov,NotCov}}</strong>, one for each
executable line in the source code. A line is specified by its
module name and line number.</p><pre>
7&gt; <span class="input">cover:analyse(channel,coverage,line).</span>
{ok,[{{channel,9},{1,0}},
     {{channel,12},{1,0}},
     {{channel,17},{1,0}},
     {{channel,20},{1,0}},
     {{channel,25},{1,0}},
     {{channel,28},{1,0}},
     {{channel,31},{1,0}},
     {{channel,32},{1,0}},
     {{channel,35},{1,0}},
     {{channel,36},{1,0}},
     {{channel,39},{1,0}},
     {{channel,44},{1,0}},
     {{channel,47},{1,0}},
     {{channel,49},{0,1}},
     {{channel,52},{1,0}}]}</pre><p>For <strong>channel</strong>, the result shows that the uncovered line is
line number 49.</p><h2>Call Statistics</h2><p>Analysis of type <strong>calls</strong> is used to find out how many times
something has been called and is represented by an integer
<strong>Calls</strong>.</p><p>If the analysis is made on module level, the result is given as a
tuple <strong>{Module,Calls}</strong>. Here <strong>Calls</strong> is the total number
of calls to functions in the module:</p><pre>
8&gt; <span class="input">cover:analyse(channel,calls,module).</span>
{ok,{channel,12}}</pre><p>For <strong>channel</strong>, the result shows that a total of twelve calls
have been made to functions in the module.</p><p>If the analysis is made on function level, the result is given as
a list of tuples <strong>{Function,Calls}</strong>. Here <strong>Calls</strong> is
the number of calls to each function:</p><pre>
9&gt; <span class="input">cover:analyse(channel,calls,function).</span>
{ok,[{{channel,start_link,0},1},
     {{channel,stop,0},1},
     {{channel,alloc,0},1},
     {{channel,free,1},1},
     {{channel,init,1},1},
     {{channel,handle_call,3},3},
     {{channel,terminate,2},1},
     {{channel,channels,0},1},
     {{channel,alloc,1},1},
     {{channel,free,2},1}]}</pre><p>For <strong>channel</strong>, the result shows that <strong>handle_call/3</strong> is
the most called function in the module (three calls). All other
functions have been called once.</p><p>If the analysis is made on clause level, the result is given as
a list of tuples <strong>{Clause,Calls}</strong>. Here <strong>Calls</strong> is
the number of calls to each function clause:</p><pre>
10&gt; <span class="input">cover:analyse(channel,calls,clause).</span>
{ok,[{{channel,start_link,0,1},1},
     {{channel,stop,0,1},1},
     {{channel,alloc,0,1},1},
     {{channel,free,1,1},1},
     {{channel,init,1,1},1},
     {{channel,handle_call,3,1},1},
     {{channel,handle_call,3,2},1},
     {{channel,handle_call,3,3},1},
     {{channel,terminate,2,1},1},
     {{channel,channels,0,1},1},
     {{channel,alloc,1,1},1},
     {{channel,alloc,1,2},0},
     {{channel,free,2,1},1}]}</pre><p>For <strong>channel</strong>, the result shows that all clauses have been
called once, except the second clause of <strong>channel:alloc/1</strong>
which has not been called at all.</p><p>Finally, if the analysis is made on line level, the result is given
as a list of tuples <strong>{Line,Calls}</strong>. Here <strong>Calls</strong> is 
the number of times each line has been executed:</p><pre>
11&gt; <span class="input">cover:analyse(channel,calls,line).</span>
{ok,[{{channel,9},1},
     {{channel,12},1},
     {{channel,17},1},
     {{channel,20},1},
     {{channel,25},1},
     {{channel,28},1},
     {{channel,31},1},
     {{channel,32},1},
     {{channel,35},1},
     {{channel,36},1},
     {{channel,39},1},
     {{channel,44},1},
     {{channel,47},1},
     {{channel,49},0},
     {{channel,52},1}]}</pre><p>For <strong>channel</strong>, the result shows that all lines have been
executed once, except line number 49 which has not been executed at
all.</p><h2>Analysis to File</h2><p>A line level calls analysis of <strong>channel</strong> can be written to
a file using <strong>cover:analysis_to_file/1</strong>:</p><pre>
12&gt; <span class="input">cover:analyse_to_file(channel).</span>
{ok,"channel.COVER.out"}</pre><p>The function creates a copy of <strong>channel.erl</strong> where it for
each executable line is specified how many times that line has been
executed. The output file is called <strong>channel.COVER.out</strong>.</p><pre>
File generated from channel.erl by COVER 2001-05-21 at 11:16:38

****************************************************************************

        |  -module(channel).
        |  -behaviour(gen_server).
        |  
        |  -export([start_link/0,stop/0]).
        |  -export([alloc/0,free/1]). % client interface
        |  -export([init/1,handle_call/3,terminate/2]). % callback functions
        |  
        |  start_link() -&gt;
     1..|      gen_server:start_link({local,channel},channel,[],[]).
        |  
        |  stop() -&gt;
     1..|      gen_server:call(channel,stop).
        |  
        |  %%%-Client interface functions------------------------------------
        |  
        |  alloc() -&gt;
     1..|      gen_server:call(channel,alloc).
        |  
        |  free(Channel) -&gt;
     1..|      gen_server:call(channel,{free,Channel}).
        |  
        |  %%%-gen_server callback functions---------------------------------
        |  
        |  init(_Arg) -&gt;
     1..|      {ok,channels()}.
        |  
        |  handle_call(stop,Client,Channels) -&gt;
     1..|      {stop,normal,ok,Channels};
        |  
        |  handle_call(alloc,Client,Channels) -&gt;
     1..|      {Ch,Channels2} = alloc(Channels),
     1..|      {reply,{ok,Ch},Channels2};
        |  
        |  handle_call({free,Channel},Client,Channels) -&gt;
     1..|      Channels2 = free(Channel,Channels),
     1..|      {reply,ok,Channels2}.
        |  
        |  terminate(_Reason,Channels) -&gt;
     1..|      ok.
        |  
        |  %%%-Internal functions--------------------------------------------
        |  
        |  channels() -&gt;
     1..|      [ch1,ch2,ch3].
        |  
        |  alloc([Channel|Channels]) -&gt;
     1..|      {Channel,Channels};
        |  alloc([]) -&gt;
     0..|      false.
        |  
        |  free(Channel,Channels) -&gt;
     1..|      [Channel|Channels].</pre><h2>Conclusion</h2><p>By looking at the results from the analyses, it can be deducted
that the test case does not cover the case when all channels are
allocated and <strong>test.erl</strong> should be extended accordingly.        <br/>
Incidentally, when the test case is corrected a bug in <strong>channel</strong>
should indeed be discovered.</p><p>When the Cover analysis is ready, Cover is stopped and all Cover
compiled modules are <a href="#loading">unloaded</a>.
The code for <strong>channel</strong> is now loaded as usual from a
<strong>.beam</strong> file in the current path.</p><pre>
13&gt; <span class="input">code:which(channel).</span>
cover_compiled
14&gt; <span class="input">cover:stop().</span>
ok
15&gt; <span class="input">code:which(channel).</span>
"./channel.beam"</pre><h2>Miscellaneous</h2><h2>Performance</h2><p>Execution of code in Cover compiled modules is slower and more
memory consuming than for regularly compiled modules. As the Cover
database contains information about each executable line in each
Cover compiled module, performance decreases proportionally to
the size and number of the Cover compiled modules.</p><p>To improve performance when analysing cover results it is possible
to do multiple calls to <a href="./cover#analyse-1">analyse</a>
and <a href="./cover#analyse_to_file-1">analyse_to_file</a>
at once. You can also use the 
<a href="./cover#async_analyse_to_file-1">async_analyse_to_file</a> 
convenience function.
</p><a name="lines"></a><h2>Executable Lines</h2><p>Cover uses the concept of <em>executable lines</em>, which is lines
of code containing an executable expression such as a matching or
a function call. A blank line or a line containing a comment,
function head or pattern in a <strong>case</strong>- or <strong>receive</strong>
statement is not executable.</p><p>In the example below, lines number 2,4,6,8 and 11 are executable
lines:</p><pre>
1: is_loaded(Module,Compiled) -&gt;
2:   case get_file(Module,Compiled) of
3:     {ok,File} -&gt;
4:       case code:which(Module) of
5:         ?TAG -&gt;
6:           {loaded,File};
7:         _ -&gt;
8:           unloaded
9:       end;
10:    false -&gt;
11:      false
12:  end.</pre><a name="loading"></a><h2>Code Loading Mechanism</h2><p>When a module is Cover compiled, it is also loaded using the normal
code loading mechanism of Erlang. This means that if a Cover
compiled module is re-loaded during a Cover session, for example
using <strong>c(Module)</strong>, it will no longer be Cover compiled.</p><p>Use <strong>cover:is_compiled/1</strong> or <strong>code:which/1</strong> to see if
a module is Cover compiled (and still loaded) or not.</p><p>When Cover is stopped, all Cover compiled modules are unloaded.</p></body></html>