<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>cprof</h1><h1>cprof</h1><p>A simple Call Count Profiling Tool using breakpoints for minimal runtime performance impact.</p><p>The <strong>cprof</strong> module is used to profile a program
to find out how many times different functions are called.
Breakpoints similar to local call trace, but containing a
counter, are used to minimise runtime performance impact. 
Since breakpoints are used there is no need for special
compilation of any module to be profiled. For now these
breakpoints can only be set on BEAM code so <span class="term">BIF</span>s
cannot be call count traced.
The size of the call counters is the host machine word
size. One bit is used when pausing the counter, so the maximum
counter value for a 32-bit host is 2147483647.
The profiling result is delivered as a term containing a
sorted list of entries, one per module. Each module entry
contains a sorted list of functions. The sorting order in both
cases is of decreasing call count.
Call count tracing is very lightweight compared to other forms
of tracing since no trace message has to be generated. Some 
measurements indicates performance degradation in the vicinity
of 10 percent.
<a name="analyse"></a>
</p><h1>Functions</h1><h2>analyse() -&gt; {AllCallCount, ModAnalysisList}</h2><h2>analyse(Limit) -&gt; {AllCallCount, ModAnalysisList}</h2><h2>analyse(Mod) -&gt; ModAnalysis</h2><h2>analyse(Mod, Limit) -&gt; ModAnalysis</h2><p>Collect and analyse call counters.</p><ul><li><span class="v">Limit = integer()</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">AllCallCount = integer()</span></li><li><span class="v">ModAnalysisList = [ModAnalysis]</span></li><li><span class="v">ModAnalysis = {Mod, ModCallCount, FuncAnalysisList}</span></li><li><span class="v">ModCallCount = integer()</span></li><li><span class="v">FuncAnalysisList = [{{Mod, Func, Arity}, FuncCallCount}]</span></li><li><span class="v">Func = atom()</span></li><li><span class="v">Arity = integer()</span></li><li><span class="v">FuncCallCount = integer()</span></li></ul><p>Collects and analyses the call counters presently in the
node for either module <strong>Mod</strong>, or for all modules
(except <strong>cprof</strong> itself), and returns: </p><dl><dt><strong>FuncAnalysisList</strong></dt><dd>A list of tuples, one for each function in a module, in decreasing <strong>FuncCallCount</strong> order.</dd><dt><strong>ModCallCount</strong></dt><dd>The sum of <strong>FuncCallCount</strong> values for all functions in module <strong>Mod</strong>.</dd><dt><strong>AllCallCount</strong></dt><dd>The sum of <strong>ModCallCount</strong> values for all modules concerned in <strong>ModAnalysisList</strong>.</dd><dt><strong>ModAnalysisList</strong></dt><dd>A list of tuples, one for each module except <strong>cprof</strong>, in decreasing <strong>ModCallCount</strong> order.</dd></dl><p>If call counters are still running while
<strong>analyse/0..2</strong> is executing, you might get an
inconsistent result. This happens if the process executing
<strong>analyse/0..2</strong> gets scheduled out so some other process
can increment the counters that are being analysed, Calling
<strong>pause()</strong> before analysing takes care of the problem.
</p><p>If the <strong>Mod</strong> argument is given, the result contains a
<strong>ModAnalysis</strong> tuple for module <strong>Mod</strong> only,
otherwise the result contains one <strong>ModAnalysis</strong> tuple
for all  modules returned from <strong>code:all_loaded()</strong>
except <strong>cprof</strong> itself.
</p><p>All functions with a <strong>FuncCallCount</strong> lower than
<strong>Limit</strong> are excluded from <strong>FuncAnalysisList</strong>. They
are still included in <strong>ModCallCount</strong>, though. 
The default value for <strong>Limit</strong> is <strong>1</strong>.
<a name="pause_0"></a>
</p><h2>pause() -&gt; integer()</h2><p>Pause running call count trace for all functions.</p><p>Pause call count tracing for all functions in all modules
and stop it for all functions in modules to be
loaded. This is the same as 
<strong>(pause({'_','_','_'})+stop({on_load}))</strong>.
</p><p>See also 
<a href="#pause">pause/1..3</a> below.
<a name="pause"></a>
</p><h2>pause(FuncSpec) -&gt; integer()</h2><h2>pause(Mod, Func) -&gt; integer()</h2><h2>pause(Mod, Func, Arity) -&gt; integer()</h2><p>Pause running call count trace for matching functions.</p><ul><li><span class="v">FuncSpec = Mod | {Mod,Func,Arity}, {FS}</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">Func = atom()</span></li><li><span class="v">Arity = integer()</span></li><li><span class="v">FS = term()</span></li></ul><p>Pause call counters for matching functions in matching 
modules. The <strong>FS</strong> argument can be used to
specify the first argument to
<strong>erlang:trace_pattern/3</strong>. See erlang(3). 
</p><p>The call counters for all matching functions that
has got call count breakpoints are paused at their current
count. 
</p><p>Return the number of matching functions that can have
call count breakpoints, the same as
<strong>start/0..3</strong> with the same arguments would have
returned. 
<a name="restart"></a>
</p><h2>restart() -&gt; integer()</h2><h2>restart(FuncSpec) -&gt; integer()</h2><h2>restart(Mod, Func) -&gt; integer()</h2><h2>restart(Mod, Func, Arity) -&gt; integer()</h2><p>Restart existing call counters for matching functions.</p><ul><li><span class="v">FuncSpec = Mod | {Mod,Func,Arity}, {FS}</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">Func = atom()</span></li><li><span class="v">Arity = integer()</span></li><li><span class="v">FS = term()</span></li></ul><p>Restart call counters for the matching functions in
matching modules that are call count traced. The <strong>FS</strong>
argument can be used to specify the first argument to
<strong>erlang:trace_pattern/3</strong>. See erlang(3).
</p><p>The call counters for all matching functions that has got
call count breakpoints are set to zero and running.
</p><p>Return the number of matching functions that can have
call count breakpoints, the same as
<strong>start/0..3</strong> with the same arguments would have
returned. 
<a name="start_0"></a>
</p><h2>start() -&gt; integer()</h2><p>Start call count tracing for all functions.</p><p>Start call count tracing for all functions in all modules, 
and also for all functions in modules to be
loaded. This is the same as 
<strong>(start({'_','_','_'})+start({on_load}))</strong>.
</p><p>See also 
<a href="#start">start/1..3</a> below.
<a name="start"></a>
</p><h2>start(FuncSpec) -&gt; integer()</h2><h2>start(Mod, Func) -&gt; integer()</h2><h2>start(Mod, Func, Arity) -&gt; integer()</h2><p>Start call count tracing for matching functions.</p><ul><li><span class="v">FuncSpec = Mod | {Mod,Func,Arity}, {FS}</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">Func = atom()</span></li><li><span class="v">Arity = integer()</span></li><li><span class="v">FS = term()</span></li></ul><p>Start call count tracing for matching functions in matching 
modules. The <strong>FS</strong> argument can be used to specify the
first argument to <strong>erlang:trace_pattern/3</strong>, for example
<strong>on_load</strong>. See erlang(3). 
</p><p>Set call count breakpoints on the matching functions that
has no call count breakpoints. Call counters 
are set to zero and running for all matching functions.
</p><p>Return the number of matching functions that has got
call count breakpoints.
<a name="stop_0"></a>
</p><h2>stop() -&gt; integer()</h2><p>Stop call count tracing for all functions.</p><p>Stop call count tracing for all functions in all modules, 
and also for all functions in modules to be
loaded. This is the same as 
<strong>(stop({'_','_','_'})+stop({on_load}))</strong>.
</p><p>See also 
<a href="#stop">stop/1..3</a> below.
<a name="stop"></a>
</p><h2>stop(FuncSpec) -&gt; integer()</h2><h2>stop(Mod, Func) -&gt; integer()</h2><h2>stop(Mod, Func, Arity) -&gt; integer()</h2><p>Stop call count tracing for matching functions.</p><ul><li><span class="v">FuncSpec = Mod | {Mod,Func,Arity}, {FS}</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">Func = atom()</span></li><li><span class="v">Arity = integer()</span></li><li><span class="v">FS = term()</span></li></ul><p>Stop call count tracing for matching functions in matching 
modules. The <strong>FS</strong> argument can be used to specify the
first argument to <strong>erlang:trace_pattern/3</strong>, for example
<strong>on_load</strong>. See erlang(3). 
</p><p>Remove call count breakpoints from the matching functions that
has call count breakpoints.
</p><p>Return the number of matching functions that can have
call count breakpoints, the same as
<strong>start/0..3</strong> with the same arguments would have
returned. 
</p><h2>See Also</h2><p><a href="eprof">eprof</a>(3), 
<a href="fprof">fprof</a>(3), 
erlang(3), 
<a href="cprof_chapter">User's Guide</a></p></body></html>