<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>eprof</h1><h1>eprof</h1><p>A Time Profiling Tool for Erlang</p><p>The module <strong>eprof</strong> provides a set of functions for time
profiling of Erlang programs to find out how the execution time is
used. The profiling is done using the Erlang trace BIFs. Tracing of
local function calls for a specified set of processes is enabled when
profiling is begun, and disabled when profiling is stopped.When using Eprof, expect a slowdown in program execution.</p><h1>Functions</h1><h2>start() -&gt; {ok,Pid} | {error,Reason}</h2><p>Start Eprof.</p><ul><li><span class="v">Pid = pid()</span></li><li><span class="v">Reason = {already_started,Pid}</span></li></ul><p>Starts the Eprof server which holds the internal state of the collected data.</p><h2>start_profiling(Rootset) -&gt; profiling | {error, Reason}</h2><h2>start_profiling(Rootset,Pattern) -&gt; profiling | {error, Reason}</h2><h2>start_profiling(Rootset,Pattern,Options) -&gt; profiling | {error, Reason}</h2><p>Start profiling.</p><ul><li><span class="v">Rootset = [atom() | pid()]</span></li><li><span class="v">Pattern = {Module, Function, Arity}</span></li><li><span class="v">Module = Function = atom()</span></li><li><span class="v">Arity = integer()</span></li><li><span class="v">Options = [set_on_spawn]</span></li><li><span class="v">Reason = term()</span></li></ul><p>Starts profiling for the processes in <strong>Rootset</strong> (and any new
processes spawned from them). Information about activity in any
profiled process is stored in the Eprof database.</p><p><strong>Rootset</strong> is a list of pids and registered names.</p><p>The function returns <strong>profiling</strong> if tracing could be enabled
for all processes in <strong>Rootset</strong>, or <strong>error</strong> otherwise.</p><p>A pattern can be selected to narrow the profiling. For instance a
specific module can be selected, and only the code executed in that
module will be profiled.</p><p>The <strong>set_on_spawn</strong> option will active call time tracing for
all processes spawned by processes in the rootset. This is
the default behaviour.</p><h2>stop_profiling() -&gt; profiling_stopped | profiling_already_stopped</h2><p>Stop profiling.</p><p>Stops profiling started with <strong>start_profiling/1</strong> or
<strong>profile/1</strong>.</p><h2>profile(Fun) -&gt; profiling | {error, Reason}</h2><h2>profile(Fun, Options) -&gt; profiling | {error, Reason}</h2><h2>profile(Rootset) -&gt; profiling | {error, Reason}</h2><h2>profile(Rootset,Fun) -&gt; {ok, Value} | {error,Reason}</h2><h2>profile(Rootset,Fun,Pattern) -&gt; {ok, Value} | {error, Reason}</h2><h2>profile(Rootset,Module,Function,Args) -&gt; {ok, Value} | {error, Reason}</h2><h2>profile(Rootset,Module,Function,Args,Pattern) -&gt; {ok, Value} | {error, Reason}</h2><h2>profile(Rootset,Module,Function,Args,Pattern,Options) -&gt; {ok, Value} | {error, Reason}</h2><p>Start profiling.</p><ul><li><span class="v">Rootset = [atom() | pid()]</span></li><li><span class="v">Fun = fun() -&gt; term() end</span></li><li><span class="v">Pattern = {Module, Function, Arity}</span></li><li><span class="v">Module = Function = atom()</span></li><li><span class="v">Args = [term()]</span></li><li><span class="v">Arity = integer()</span></li><li><span class="v">Options = [set_on_spawn]</span></li><li><span class="v">Value = Reason = term()</span></li></ul><p>This function first spawns a process <strong>P</strong> which evaluates
<strong>Fun()</strong> or <strong>apply(Module,Function,Args)</strong>. Then, it
starts profiling for <strong>P</strong> and the processes in <strong>Rootset</strong>
(and any new processes spawned from them). Information about
activity in any profiled process is stored in the Eprof database.</p><p><strong>Rootset</strong> is a list of pids and registered names.</p><p>If tracing could be enabled for <strong>P</strong> and all processes in
<strong>Rootset</strong>, the function returns <strong>{ok,Value}</strong> when
<strong>Fun()</strong>/<strong>apply</strong> returns with the value <strong>Value</strong>, or
<strong>{error,Reason}</strong> if <strong>Fun()</strong>/<strong>apply</strong> fails with
exit reason <strong>Reason</strong>. Otherwise it returns <strong>{error, Reason}</strong>
immediately.</p><p>The <strong>set_on_spawn</strong> option will active call time tracing for
all processes spawned by processes in the rootset. This is
the default behaviour.</p><p>The programmer must ensure that the function given as argument
is truly synchronous and that no work continues after
the function has returned a value.</p><h2>analyze() -&gt; ok</h2><h2>analyze(Type) -&gt; ok</h2><h2>analyze(Type,Options) -&gt; ok</h2><p>Display profiling results per process.</p><ul><li><span class="v">Type = procs | total</span></li><li><span class="v">Options = [{filter, Filter} | {sort, Sort}</span></li><li><span class="v">Filter = [{calls, integer()} | {time, float()}]</span></li><li><span class="v">Sort = time | calls | mfa</span></li></ul><p>Call this function when profiling has been stopped to display
the results per process, that is:</p><ul><li>how much time has been used by each process, and</li><li>in which function calls this time has been spent.</li></ul><p>Call <strong>analyze</strong> with <strong>total</strong> option when profiling has been stopped to display
the results per function call, that is in which function calls
the time has been spent.</p><p>Time is shown as percentage of total time and as absolute time.</p><h2>log(File) -&gt; ok</h2><p>Activate logging of <strong>eprof</strong>printouts.</p><ul><li><span class="v">File = atom() | string()</span></li></ul><p>This function ensures that the results displayed by
<strong>analyze/0,1,2</strong> are printed both to the file
<strong>File</strong> and the screen.</p><h2>stop() -&gt; stopped</h2><p>Stop Eprof.</p><p>Stops the Eprof server.</p></body></html>