<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>snmpa</h1><h1>snmpa</h1><p>Interface Functions to the SNMP toolkit agent</p><p>The module <strong>snmpa</strong> contains interface functions to the 
SNMP agent.<a name="data_types"></a></p><h2>DATA TYPES</h2><pre><code class="">
oid() = [byte()] 
atl_type() = read | write | read_write
notification_delivery_info() = #snmpa_notification_delivery_info{}
    </code></pre><p>The <strong>oid()</strong> type is used to represent an ASN.1 OBJECT IDENTIFIER. </p><p>The record <strong>snmpa_notification_delivery_info</strong> contains the following fields: </p><dl><dt><strong>tag = term()</strong></dt><dd> <p>A user defined identity representing this notification send 
operation.</p> </dd><dt><strong>mod = module()</strong></dt><dd> <p>A module implementing the 
<a href="snmpa_notification_delivery_info_receiver">snmpa_notification_delivery_info_receiver</a> 
behaviour. The info functions of this module will be called at 
various stages of delivery. </p> </dd><dt><strong>extra = term()</strong></dt><dd> <p>This is any extra info the user wants to have supplied 
when the functions in the callback module is called. </p> </dd></dl><a name="add_agent_caps"></a><h1>Functions</h1><h2>add_agent_caps(SysORID, SysORDescr) -&gt; SysORIndex</h2><p>Add an AGENT-CAPABILITY definition to the agent</p><ul><li><span class="v">SysORID = oid()</span></li><li><span class="v">SysORDescr = string()</span></li><li><span class="v">SysORIndex = integer()</span></li></ul><p>This function can be used to add an AGENT-CAPABILITY
statement to the sysORTable in the agent.  The table is
defined in the SNMPv2-MIB.</p><a name="del_agent_caps"></a><h2>del_agent_caps(SysORIndex) -&gt; void()</h2><p>Delete an AGENT-CAPABILITY definition from the agent</p><ul><li><span class="v">SysORIndex = integer()</span></li></ul><p>This function can be used to delete an AGENT-CAPABILITY
statement to the sysORTable in the agent.  This table is
defined in the SNMPv2-MIB. </p><a name="get_agent_caps"></a><h2>get_agent_caps() -&gt; [[SysORIndex, SysORID, SysORDescr, SysORUpTime]]</h2><p>Return all AGENT-CAPABILITY definitions in the agent</p><ul><li><span class="v">SysORIndex = integer()</span></li><li><span class="v">SysORId = oid()</span></li><li><span class="v">SysORDescr = string()</span></li><li><span class="v">SysORUpTime = integer()</span></li></ul><p>Returns all AGENT-CAPABILITY statements in the sysORTable
in the agent.  This table is defined in the SNMPv2-MIB. </p><a name="get"></a><h2>get(Agent, Vars) -&gt; Values | {error, Reason}</h2><h2>get(Agent, Vars, Context) -&gt; Values | {error, Reason}</h2><p>Perform a get operation on the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Vars = [oid()]</span></li><li><span class="v">Context = string()</span></li><li><span class="v">Values = [term()]</span></li><li><span class="v">Reason = {atom(), oid()}</span></li></ul><p>Performs a GET operation on the agent.  All loaded MIB
objects are visible in this operation.  The agent calls the
corresponding instrumentation functions just as if it was a
GET request coming from a manager. </p><p>Note that the request specific parameters (such as 
<a href="#current_request_id">current_request_id</a>) 
are not accessible for the instrumentation functions if this 
function is used. </p><a name="get_next"></a><h2>get_next(Agent, Vars) -&gt; Values | {error, Reason}</h2><h2>get_next(Agent, Vars, Context) -&gt; Values | {error, Reason}</h2><p>Perform a get-next operation on the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Vars = [oid()]</span></li><li><span class="v">Context = string()</span></li><li><span class="v">Values = [{oid(), term()}]</span></li><li><span class="v">Reason = {atom(), oid()}</span></li></ul><p>Performs a GET-NEXT operation on the agent.  All loaded MIB
objects are visible in this operation.  The agent calls the
corresponding instrumentation functions just as if it was a
GET request coming from a manager. </p><p>Note that the request specific parameters (such as 
<strong>snmpa:current_request_id/0</strong> are not accessible for the 
instrumentation functions if this function is used. </p><a name="backup"></a><h2>backup(BackupDir) -&gt; ok | {error, Reason}</h2><h2>backup(Agent, BackupDir) -&gt; ok | {error, Reason}</h2><p>Backup agent data</p><ul><li><span class="v">BackupDir = string()</span></li><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Reason = backup_in_progress | term()</span></li></ul><p>Backup persistent/permanent data handled by the agent
(such as local-db, mib-data and vacm). </p><p>Data stored by mnesia is not handled. </p><p>BackupDir cannot be identical to DbDir. </p><p>Simultaneous backup calls are <em>not</em> allowed. 
That is, two different processes cannot simultaneously 
successfully call this function. One of them will be first, 
and succeed. The second will fail with the error reason
<strong>backup_in_progress</strong>. </p><a name="info"></a><h2>info() -&gt; [{Key, Value}]</h2><h2>info(Agent) -&gt; [{Key, Value}]</h2><p>Return information about the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Returns a list (a dictionary) containing information about
the agent. Information includes loaded MIBs, registered
sub-agents, some information about the memory allocation. </p><p>As of version 4.4 the format of the info has been changed. 
To convert the info to the old format, call the 
<a href="#old_info_format">old_info_format</a> 
function. </p><a name="old_info_format"></a><h2>old_info_format(NewInfo) -&gt; OldInfo</h2><p>Return information about the agent</p><ul><li><span class="v">OldInfo = NewInfo = [{Key, Value}]</span></li></ul><p>As of version 4.4 the format of the info has been changed. 
This function is used to convert to the old (pre-4.4) info 
format. </p><a name="load_mib"></a><h2>load_mib(Mib) -&gt; ok | {error, Reason}</h2><h2>load_mib(Agent, Mib) -&gt; ok | {error, Reason}</h2><p>Load single MIB into the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = already_loaded | term()</span></li></ul><p>Load a single <strong>Mib</strong> into an agent. The <strong>MibName</strong> 
is the name of the Mib, including the path to where the compiled 
mib is found. For example: </p><pre><code class="">
          Dir = code:priv_dir(my_app) ++ "/mibs/",
          snmpa:load_mib(snmp_master_agent, Dir ++ "MY-MIB").
        </code></pre><a name="load_mibs"></a><h2>load_mibs(Mibs) -&gt; ok | {error, Reason}</h2><h2>load_mibs(Mibs, Force) -&gt; ok | {error, Reason}</h2><h2>load_mibs(Agent, Mibs) -&gt; ok | {error, Reason}</h2><h2>load_mibs(Agent, Mibs, Force) -&gt; ok | {error, Reason}</h2><p>Load MIBs into the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">Force = boolean()</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = {'load aborted at', MibName, InternalReason}</span></li><li><span class="v">InternalReason = already_loaded | term()</span></li></ul><p>Load <strong>Mibs</strong> into an agent.  If the agent cannot load all 
MIBs (the default value of the <strong>Force</strong> argument is <strong>false</strong>), 
it will indicate where loading was aborted. The <strong>MibName</strong> 
is the name of the Mib, including the path to where the compiled 
mib is found. For example,</p><pre><code class="">
          Dir = code:priv_dir(my_app) ++ "/mibs/",
          snmpa:load_mibs(snmp_master_agent, [Dir ++ "MY-MIB"]).
        </code></pre><p>If <strong>Force = true</strong> then the agent will continue attempting
to load each mib even after failing to load a previous mib. Use with 
care. </p><a name="unload_mib"></a><h2>unload_mib(Mib) -&gt; ok | {error, Reason}</h2><h2>unload_mib(Agent, Mib) -&gt; ok | {error, Reason}</h2><p>Unload single MIB from the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = not_loaded | term()</span></li></ul><p>Unload a single <strong>Mib</strong> from an agent. </p><a name="unload_mibs"></a><h2>unload_mibs(Mibs) -&gt; ok | {error, Reason}</h2><h2>unload_mibs(Mibs, Force) -&gt; ok | {error, Reason}</h2><h2>unload_mibs(Agent, Mibs) -&gt; ok | {error, Reason}</h2><h2>unload_mibs(Agent, Mibs, Force) -&gt; ok | {error, Reason}</h2><p>Unload MIBs from the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">Force = boolean()</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = {'unload aborted at', MibName, InternalReason}</span></li><li><span class="v">InternalReason = not_loaded | term()</span></li></ul><p>Unload <strong>Mibs</strong> from an agent. If it cannot unload all MIBs
(the default value of the <strong>Force</strong> argument is <strong>false</strong>),
it will indicate where unloading was aborted. </p><p>If <strong>Force = true</strong> then the agent will continue attempting
to unload each mib even after failing to unload a previous mib. 
Use with care. </p><a name="which_mibs"></a><h2>which_mibs() -&gt; Mibs</h2><h2>which_mibs(Agent) -&gt; Mibs</h2><p>Get a list of all the loaded mibs</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Mibs = [{MibName, MibFile}]</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">MibFile = string()</span></li></ul><p>Retrieve the list of all the mibs loaded into this agent. Default 
is the master agent. </p><a name="whereis_mib"></a><h2>whereis_mib(MibName) -&gt; {ok, MibFile} | {error, Reason}</h2><h2>whereis_mib(Agent, MibName) -&gt; {ok, MibFile} | {error, Reason}</h2><p>Get the path to the mib file</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">MibFile = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Get the full path to the (compiled) mib-file. </p><a name="current_request_id"></a><a name="current_context"></a><a name="current_community"></a><a name="current_address"></a><h2>current_request_id() -&gt; {value, RequestId} | false</h2><h2>current_context() -&gt; {value, Context} | false</h2><h2>current_community() -&gt; {value, Community} | false</h2><h2>current_address() -&gt; {value, Address} | false</h2><p>Get the request-id, context, community and address of the current request</p><ul><li><span class="v">RequestId = integer()</span></li><li><span class="v">Context = string()</span></li><li><span class="v">Community = string()</span></li><li><span class="v">Address = term()</span></li></ul><p>Get the request-id, context, community and address of the 
request currently being processed by the agent. </p><p>Note that these functions is intended to be called by the 
instrumentation functions and <em>only</em> if they are 
executed in the context of the agent process (e.g. it does 
not work if called from a spawned process).</p><a name="enum_to_int"></a><h2>enum_to_int(Name, Enum) -&gt; {value, Int} | false</h2><h2>enum_to_int(Db, Name, Enum) -&gt; {value, Int} | false</h2><p>Convert an enum value to an integer</p><ul><li><span class="v">Db   = term()</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">Enum = atom()</span></li><li><span class="v">Int  = int()</span></li></ul><p>Converts the symbolic value <strong>Enum</strong> to the
corresponding integer of the enumerated object or type
<strong>Name</strong> in a MIB.  The MIB must be loaded. 
</p><p><strong>false</strong> is returned if the object or type is not
defined in any loaded MIB, or if it does not define the
symbolic value as enumerated.
</p><p><strong>Db</strong> is a reference to the symbolic store database 
(retrieved by a call to <strong>get_symbolic_store_db/0</strong>). </p><a name="int_to_enum"></a><h2>int_to_enum(Name, Int) -&gt; {value, Enum} | false</h2><h2>int_to_enum(Db, Name, Int) -&gt; {value, Enum} | false</h2><p>Convert an integer to an enum value</p><ul><li><span class="v">Db   = term()</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">Int  = int()</span></li><li><span class="v">Enum = atom()</span></li></ul><p>Converts the integer <strong>Int</strong> to the corresponding
symbolic value of the enumerated object or type <strong>Name</strong> in
a MIB.  The MIB must be loaded. 
</p><p><strong>false</strong> is returned if the object or type is not
defined in any loaded MIB, or if it does not define the
symbolic value as enumerated.
</p><p><strong>Db</strong> is a reference to the symbolic store database 
(retrieved by a call to <strong>get_symbolic_store_db/0</strong>). </p><a name="name_to_oid"></a><h2>name_to_oid(Name) -&gt; {value, oid()} | false</h2><h2>name_to_oid(Db, Name) -&gt; {value, oid()} | false</h2><p>Convert a symbolic name to an OID</p><ul><li><span class="v">Db   = term()</span></li><li><span class="v">Name = atom()</span></li></ul><p>Looks up the OBJECT IDENTIFIER of a MIB object, given the
symbolic name.  Note, the OBJECT IDENTIFIER is given for the
object, not for an instance. </p><p><strong>false</strong> is returned if the object is not defined in any
loaded MIB. </p><p><strong>Db</strong> is a reference to the symbolic store database 
(retrieved by a call to <strong>get_symbolic_store_db/0</strong>). </p><a name="oid_to_name"></a><h2>oid_to_name(OID) -&gt; {value, Name} | false</h2><h2>oid_to_name(Db, OID) -&gt; {value, Name} | false</h2><p>Convert an OID to a symbolic name</p><ul><li><span class="v">Db   = term()</span></li><li><span class="v">OID  = oid()</span></li><li><span class="v">Name = atom()</span></li></ul><p>Looks up the symbolic name of a MIB object, given OBJECT
IDENTIFIER. </p><p><strong>false</strong> is returned if the object is not defined in any
loaded MIB. </p><p><strong>Db</strong> is a reference to the symbolic store database 
(retrieved by a call to <strong>get_symbolic_store_db/0</strong>). </p><a name="which_aliasnames"></a><h2>which_aliasnames() -&gt; Result</h2><p>Get all alias-names known to the agent</p><ul><li><span class="v">Result = [atom()]</span></li></ul><p>Retrieve all alias-names known to the agent.</p><a name="which_tables"></a><h2>which_tables() -&gt; Result</h2><p>Get all tables known to the agent</p><ul><li><span class="v">Result = [atom()]</span></li></ul><p>Retrieve all tables known to the agent.</p><a name="which_variables"></a><h2>which_variables() -&gt; Result</h2><p>Get all variables known to the agent</p><ul><li><span class="v">Result = [atom()]</span></li></ul><p>Retrieve all variables known to the agent.</p><a name="which_notifications"></a><h2>which_notifications() -&gt; Result</h2><p>Get all notifications known to the agent</p><ul><li><span class="v">Result = [{Name, MibName, Info}]</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">Info = term()</span></li></ul><p>Retrieve all notifications (and traps) known to the agent.</p><a name="log_to_txt"></a><h2>log_to_txt(LogDir)</h2><h2>log_to_txt(LogDir, Block | Mibs)</h2><h2>log_to_txt(LogDir, Mibs, Block | OutFile) -&gt; ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_txt(LogDir, Mibs, OutFile, Block | LogName) -&gt;  ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_txt(LogDir, Mibs, OutFile, LogName, Block | LogFile) -&gt;  ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block | Start) -&gt;  ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start)  -&gt; ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Start, Stop)  -&gt; ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start, Stop)  -&gt; ok | {ok, Cnt} | {error, Reason}</h2><p>Convert an Audit Trail Log to text format</p><ul><li><span class="v">LogDir = string()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Block = boolean()</span></li><li><span class="v">OutFile = string()</span></li><li><span class="v">LogName = string()</span></li><li><span class="v">LogFile = string()</span></li><li><span class="v">Start = Stop = null | calendar:datetime() | {local_time, calendar:datetime()} | {universal_time, calendar:datetime()} </span></li><li><span class="v">Cnt = {NumOK, NumERR}</span></li><li><span class="v">NumOK = non_neg_integer()</span></li><li><span class="v">NumERR = pos_integer()</span></li><li><span class="v">Reason = disk_log_open_error() | file_open_error() | term()</span></li><li><span class="v">disk_log_open_error() = {LogName, term()}</span></li><li><span class="v">file_open_error() = {OutFile, term()}</span></li></ul><p>Converts an Audit Trail Log to a readable text file. 
<strong>OutFile</strong> defaults to "./snmpa_log.txt". 
<strong>LogName</strong> defaults to "snmpa_log". 
<strong>LogFile</strong> defaults to "snmpa.log". </p><p>The <strong>Block</strong> option indicates if the log should be blocked
during conversion. This could be usefull when converting large 
logs (when otherwise the log could wrap during conversion). 
Defaults to <strong>true</strong>. </p><p>See <a href="./snmp#log_to_txt">snmp:log_to_txt</a> 
for more info.</p><a name="log_to_io"></a><h2>log_to_io(LogDir) -&gt;  ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_io(LogDir, Block | Mibs) -&gt;  ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_io(LogDir, Mibs, Block | LogName) -&gt;  ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_io(LogDir, Mibs, LogName, Block | LogFile) -&gt; ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_io(LogDir, Mibs, LogName, LogFile, Block | Start) -&gt; ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start) -&gt; ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_io(LogDir, Mibs, LogName, LogFile, Start, Stop) -&gt; ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start, Stop) -&gt; ok | {ok, Cnt} | {error, Reason}</h2><p>Convert an Audit Trail Log to text format</p><ul><li><span class="v">LogDir = string()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Block = boolean()</span></li><li><span class="v">LogName = string()</span></li><li><span class="v">LogFile = string()</span></li><li><span class="v">Start = Stop = null | calendar:datetime() | {local_time, calendar:datetime()} | {universal_time, calendar:datetime()} </span></li><li><span class="v">Cnt = {NumOK, NumERR}</span></li><li><span class="v">NumOK = non_neg_integer()</span></li><li><span class="v">NumERR = pos_integer()</span></li><li><span class="v">Reason = disk_log_open_error() | file_open_error() | term()</span></li><li><span class="v">disk_log_open_error() = {LogName, term()}</span></li><li><span class="v">file_open_error() = {OutFile, term()}</span></li></ul><p>Converts an Audit Trail Log to a readable format and 
prints it on stdio. 
<strong>LogName</strong> defaults to "snmpa_log". 
<strong>LogFile</strong> defaults to "snmpa.log".</p><p>The <strong>Block</strong> option indicates if the log should be blocked
during conversion. This could be usefull when converting large 
logs (when otherwise the log could wrap during conversion). 
Defaults to <strong>true</strong>. </p><p>See <a href="./snmp#log_to_io">snmp:log_to_io</a> 
for more info.</p><a name="change_log_size"></a><h2>change_log_size(NewSize) -&gt; ok | {error, Reason}</h2><p>Change the size of the Audit Trail Log</p><ul><li><span class="v">NewSize = {MaxBytes, MaxFiles}</span></li><li><span class="v">MaxBytes = integer()</span></li><li><span class="v">MaxFiles = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Changes the log size of the Audit Trail Log. The application must 
be configured to use the audit trail log function. Please refer to 
disk_log(3) in Kernel Reference Manual for a description of how to 
change the log size. </p><p>The change is permanent, as long as the log is not deleted. 
That means, the log size is remembered across reboots. </p><a name="set_log_type"></a><h2>set_log_type(NewType) -&gt; {ok, OldType} | {error, Reason}</h2><h2>set_log_type(Agent, NewType) -&gt; {ok, OldType} | {error, Reason}</h2><p>Change the type of the Audit Trail Log</p><ul><li><span class="v">NewType = OldType = atl_type()</span></li><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Changes the run-time Audit Trail log type. </p><p>Note that this has no effect on the application configuration as
defined by configuration files, so a node restart will revert the 
config to whatever is in those files. </p><p>This function is primarily useful in testing/debugging 
scenarios. </p><a name="mib_of"></a><h2>mib_of(Oid) -&gt; {ok, MibName} | {error, Reason}</h2><h2>mib_of(Agent, Oid) -&gt; {ok, MibName} | {error, Reason}</h2><p>Which mib an Oid belongs to</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Oid = oid()</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Finds the mib corresponding to the <strong>Oid</strong>. If it is a
variable, the Oid must be 
&lt;Oid for var&gt;.0 and if it is a table, Oid must be 
&lt;table&gt;.&lt;entry&gt;.&lt;col&gt;.&lt;any&gt;</p><a name="me_of"></a><h2>me_of(Oid) -&gt; {ok, Me} | {error, Reason}</h2><h2>me_of(Agent, Oid) -&gt; {ok, Me} | {error, Reason}</h2><p>Retrieve the mib-entry of an Oid</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Oid = oid()</span></li><li><span class="v">Me = #me{}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Finds the mib entry corresponding to the <strong>Oid</strong>. If it is a
variable, the Oid must be 
&lt;Oid for var&gt;.0 and if it is a table, Oid must be 
&lt;table&gt;.&lt;entry&gt;.&lt;col&gt;.&lt;any&gt;</p><a name="invalidate_mibs_cache"></a><h2>invalidate_mibs_cache() -&gt; void()</h2><h2>invalidate_mibs_cache(Agent) -&gt; void()</h2><p>Invalidate the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Invalidate the mib server cache. </p><p>The entire contents of the cache will be deleted. </p><a name="enable_mibs_cache"></a><h2>enable_mibs_cache() -&gt; void()</h2><h2>enable_mibs_cache(Agent) -&gt; void()</h2><p>Enable the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Enable the mib server cache. </p><a name="disable_mibs_cache"></a><h2>disable_mibs_cache() -&gt; void()</h2><h2>disable_mibs_cache(Agent) -&gt; void()</h2><p>Disable the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Disable the mib server cache. </p><a name="which_mibs_cache_size"></a><h2>which_mibs_cache_size() -&gt; void()</h2><h2>which_mibs_cache_size(Agent) -&gt; void()</h2><p>The size of the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Retreive the size of the mib server cache. </p><a name="gc_mibs_cache"></a><h2>gc_mibs_cache() -&gt; {ok, NumElementsGCed} | {error, Reason}</h2><h2>gc_mibs_cache(Agent) -&gt; {ok, NumElementsGCed} | {error, Reason}</h2><h2>gc_mibs_cache(Age) -&gt; {ok, NumElementsGCed} | {error, Reason}</h2><h2>gc_mibs_cache(Agent, Age) -&gt; {ok, NumElementsGCed} | {error, Reason}</h2><h2>gc_mibs_cache(Age, GcLimit) -&gt; {ok, NumElementsGCed} | {error, Reason}</h2><h2>gc_mibs_cache(Agent, Age, GcLimit) -&gt; {ok, NumElementsGCed} | {error, Reason}</h2><p>Perform mib server cache gc</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Age = integer() &gt; 0</span></li><li><span class="v">GcLimit = integer() &gt; 0 | infinity</span></li><li><span class="v">NumElementsGCed = integer() &gt;= 0</span></li><li><span class="v">Reason = term()</span></li></ul><p>Perform mib server cache gc. </p><p>Manually performs a mib server cache gc. 
This can be done regardless of the value of the 
<strong>autogc</strong> option. 
The <strong>NumElementsGCed</strong> value indicates how many 
elements where actually removed from the cache. </p><a name="enable_mibs_cache_autogc"></a><h2>enable_mibs_cache_autogc() -&gt; void()</h2><h2>enable_mibs_cache_autogc(Agent) -&gt; void()</h2><p>Enable automatic gc of the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Enable automatic gc of the mib server cache. </p><a name="disable_mibs_cache_autogc"></a><h2>disable_mibs_cache_autogc() -&gt; void()</h2><h2>disable_mibs_cache_autogc(Agent) -&gt; void()</h2><p>Disable automatic gc of the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Disable automatic gc of the mib server cache. </p><a name="update_mibs_cache_age"></a><h2>update_mibs_cache_age(NewAge) -&gt; ok | {error, Reason}</h2><h2>update_mibs_cache_age(Agent, NewAge) -&gt; ok | {error, Reason}</h2><p>Change the mib server cache age property</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">NewAge = integer() &gt; 0</span></li><li><span class="v">Reason = term()</span></li></ul><p>Change the mib server cache <strong>age</strong> property. </p><a name="update_mibs_cache_gclimit"></a><h2>update_mibs_cache_gclimit(NewGcLimit) -&gt; ok | {error, Reason}</h2><h2>update_mibs_cache_gclimit(Agent, NewGCLimit) -&gt; ok | {error, Reason}</h2><p>Change the mib server cache gclimit property</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">NewGcLimit = integer() &gt; 0 | infinity</span></li><li><span class="v">Reason = term()</span></li></ul><p>Change the mib server cache <strong>gclimit</strong> property. </p><a name="register_notification_filter"></a><h2>register_notification_filter(Id, Mod, Data) -&gt; ok | {error, Reason}</h2><h2>register_notification_filter(Agent, Id, Mod, Data) -&gt; ok | {error, Reason}</h2><h2>register_notification_filter(Id, Mod, Data, Where) -&gt; ok | {error, Reason}</h2><h2>register_notification_filter(Agent, Id, Mod, Data, Where) -&gt; ok | {error, Reason}</h2><p>Register a notification filter</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Id = filter_id()</span></li><li><span class="v">filter_id() = term()</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">Data = term()</span></li><li><span class="v">Where = filter_position()</span></li><li><span class="v">Reason = term()</span></li><li><span class="v">filter_position() = first | last | {insert_before, filter_id()} | {insert_after, filter_id()} </span></li></ul><p>Registers a notification filter.
</p><p><strong>Mod</strong> is a module implementing the 
<strong>snmpa_notification_filter</strong> behaviour.</p><p><strong>Data</strong> will be passed on to the filter when calling the
functions of the behaviour.</p><a name="unregister_notification_filter"></a><h2>unregister_notification_filter(Id) -&gt; ok | {error, Reason}</h2><h2>unregister_notification_filter(Agent, Id) -&gt; ok | {error, Reason}</h2><p>Unregister a notification filter</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Id = filter_id()</span></li><li><span class="v">filter_id() = term()</span></li></ul><p>Unregister a notification filter. </p><a name="which_notification_filter"></a><h2>which_notification_filter() -&gt; Filters</h2><h2>which_notification_filter(Agent) -&gt; Filters</h2><p>Which notification filter</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Filters = [filter_id()]</span></li><li><span class="v">filter_id() = term()</span></li></ul><p>List all notification filters in an agent.</p><a name="set_request_limit"></a><h2>set_request_limit(NewLimit) -&gt; {ok, OldLimit} | {error, Reason}</h2><h2>set_request_limit(Agent, NewLimit) -&gt; {ok, OldLimit} | {error, Reason}</h2><p>Change the request limit</p><ul><li><span class="v">NewLimit = OldLimit = infinity | integer() &gt;= 0</span></li><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Changes the request limit. </p><p>Note that this has no effect on the application configuration as
defined by configuration files, so a node restart will revert the 
config to whatever is in those files. </p><p>This function is primarily useful in load regulation 
scenarios. </p><a name="register_subagent"></a><h2>register_subagent(Agent, SubTreeOid, Subagent) -&gt; ok | {error, Reason}</h2><p>Register a sub-agent under a sub-tree</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">SubTreeOid = oid()</span></li><li><span class="v">SubAgent = pid()</span></li></ul><p>Registers a sub-agent under a sub-tree of another agent. </p><p>It is easy to make mistakes when registering sub-agents and
this activity should be done carefully.  For example, a
strange behaviour would result from the following
configuration:</p><pre>
snmp_agent:register_subagent(MAPid,[1,2,3,4],SA1),
snmp_agent:register_subagent(SA1,[1,2,3], SA2).
        </pre><p><strong>SA2</strong> will not get requests starting with object
identifier <strong>[1,2,3]</strong> since <strong>SA1</strong> does not. </p><a name="unregister_subagent"></a><h2>unregister_subagent(Agent, SubagentOidOrPid) -&gt; ok | {ok, SubAgentPid} | {error, Reason}</h2><p>Unregister a sub-agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">SubTreeOidorPid = oid() | pid()</span></li></ul><p>Unregister a sub-agent.  If the second argument is a pid,
then that sub-agent will be unregistered from all trees in
<strong>Agent</strong>. </p><a name="send_notification2"></a><h2>send_notification2(Agent, Notification, SendOpts) -&gt; void()</h2><p>Send notification</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Notification = atom()</span></li><li><span class="v">SendOpts = [send_option()]</span></li><li><span class="v">send_option() = {receiver, receiver()} | {name, notify_name()} | {context, context_name()} | {varbinds, varbinds()} | {local_engine_id, string()} | {extra, extra_info()}</span></li><li><span class="v">receiver() = no_receiver | {tag(), tag_receiver()} | notification_delivery_info()</span></li><li><span class="v">tag() = term(()</span></li><li><span class="v">tag_receiver() = pid() | registered_name() | {Mod, Func, Args}</span></li><li><span class="v">registered_name() = atom()</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">Func = atom()</span></li><li><span class="v">Args = list()</span></li><li><span class="v">notify_name() = string()</span></li><li><span class="v">context_name() = string()</span></li><li><span class="v">varbinds() = [varbind()]</span></li><li><span class="v">varbind() = {variable(), value()} | {column(), row_index(), value()} | {oid(), value()}</span></li><li><span class="v">variable() = atom()</span></li><li><span class="v">value() = term()</span></li><li><span class="v">column() = atom()</span></li><li><span class="v">row_index() = [int()]</span></li><li><span class="v">extra_info() = term()</span></li></ul><p>Send the notification <strong>Notification</strong> to the management 
targets defined for notify-name (<strong>name</strong>) in the 
<strong>snmpNotifyTable</strong> in SNMP-NOTIFICATION-MIB from the 
specified <strong>context</strong>. </p><p>If no <strong>name</strong> is specified (or if it is <strong>""</strong>), the
notification is sent to all management targets. </p><p>If no <strong>context</strong> is specified, the default context, <strong>""</strong>, 
is used. </p><p>The send option <strong>receiver</strong> specifies where information
about delivery of Inform-Requests should be sent.  The agent
sends Inform-Requests and waits for acknowledgments from the
management targets. 
The <strong>receiver</strong> can have three values: </p><ul><li> <p><strong>no_receiver</strong> - No information is delivered. </p> </li><li> <p><strong>notification_delivery_info()</strong> - The information is 
delivered via a function call according to this data. See the 
<a href="#data_types">DATA TYPES</a> section 
above for details. </p> </li><li> <p><strong>{tag(), tag_receiver()}</strong> - The information is delivered 
either via messages or via a function call according to the value 
of <strong>tag_receiver()</strong>. </p> <p>Delivery is done differently depending on the value
of <strong>tag_receiver()</strong>: </p> <ul><li> <p><strong>pid() | registered_name()</strong> - The info will be delivered in  
the following messages: </p> <ul><li> <p><strong>{snmp_targets, tag(), Addresses}</strong></p> <p>This informs the user which target addresses the 
notification was sent to. </p> </li><li> <p><strong>{snmp_notification, tag(), {got_response, Address}}</strong></p> <p>This informs the user that this target address 
acknowledged the notification. </p> </li><li> <p><strong>{snmp_notification, tag(), {no_response, Address}}</strong></p> <p>This informs the user that this target address 
did not acknowledge the notification. </p> </li></ul> <p>The notification is sent as an Inform-Request to each 
target address in <strong>Addresses</strong> and if there are no 
targets for which an Inform-Request is sent, <strong>Addresses</strong> 
is the empty list <strong>[]</strong>. </p> <p>The <strong>tag_receiver()</strong> will first be sent the 
<strong>snmp_targets</strong> message, and then for each address in 
<strong>Addresses</strong> list, one of the two <strong>snmp_notification</strong> 
messages. </p> </li><li> <p><strong>{Mod, Func, Args}</strong> - The info will be delivered via
the function call: </p> <p><strong>Mod:Func([Msg | Args])</strong></p> <p>where <strong>Msg</strong> has the same content and purpose as the 
messages descrived above.</p> </li></ul> </li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The <strong>extra</strong> info is not normally interpreted by the agent, 
instead it is passed through to the 
<a href="snmp_agent_netif">net-if</a> process. It is 
up to the implementor of that process to make use of this data. </p><p>The version of net-if provided by this application makes no use
of this data, with one exception: 
Any tuple containing the atom 
<strong>snmpa_default_notification_extra_info</strong> 
may be used by the agent and is therefor <em>reserved</em>. </p><p>See the net-if incomming messages for sending a 
<a href="./snmp_agent_netif#im_send_pdu"> trap</a> and 
<a href="./snmp_agent_netif#im_send_pdu_req"> notification</a> for more info. </p></div><a name="send_notification"></a><h2>send_notification(Agent, Notification, Receiver)</h2><h2>send_notification(Agent, Notification, Receiver, Varbinds)</h2><h2>send_notification(Agent, Notification, Receiver, NotifyName, Varbinds)</h2><h2>send_notification(Agent, Notification, Receiver, NotifyName, ContextName, Varbinds) -&gt; void()</h2><h2>send_notification(Agent, Notification, Receiver, NotifyName, ContextName, Varbinds, LocalEngineID) -&gt; void()</h2><p>Send a notification</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Notification = atom()</span></li><li><span class="v">Receiver = no_receiver | {Tag, Recv} | notification_delivery_info()</span></li><li><span class="v">Tag = term()</span></li><li><span class="v">Recv = receiver()</span></li><li><span class="v">receiver() = pid() | atom() | {Mod, Func, Args}</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">Func = atom()</span></li><li><span class="v">Args = list()</span></li><li><span class="v">NotifyName = string()</span></li><li><span class="v">ContextName = string()</span></li><li><span class="v">Varbinds = varbinds()</span></li><li><span class="v">varbinds() = [varbind()]</span></li><li><span class="v">varbind() = {Variable, Value} | {Column, RowIndex, Value} | {OID, Value}</span></li><li><span class="v">Variable = atom()</span></li><li><span class="v">Column = atom()</span></li><li><span class="v">OID = oid()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">RowIndex = [int()]</span></li><li><span class="v">LocalEngineID = string()</span></li></ul><p>Sends the notification <strong>Notification</strong> to the
management targets defined for <strong>NotifyName</strong> in the
<strong>snmpNotifyTable</strong> in SNMP-NOTIFICATION-MIB from the
specified context.  </p><p>If no <strong>NotifyName</strong> is specified (or if it is <strong>""</strong>), 
the notification is sent to all management targets 
(<strong>Addresses</strong> below).  </p><p>If no <strong>ContextName</strong> is specified, the default <strong>""</strong> 
context is used. </p><p>The parameter <strong>Receiver</strong> specifies where information
about delivery of Inform-Requests should be sent.  The agent
sends Inform-Requests and waits for acknowledgments from the
managers. <strong>Receiver</strong> can have three values: </p><ul><li> <p><strong>no_receiver</strong> - No information is delivered. </p> </li><li> <p><strong>notification_delivery_info()</strong> - The information is 
delivered via a function call according to this data. See the 
<a href="#data_types">DATA TYPES</a> section 
above for details. </p> </li><li> <p><strong>{Tag, Recv}</strong> - The information is delivered either via 
messages or via a function call according to the value of 
<strong>Recv</strong>. </p> </li></ul><p>If <strong>Receiver</strong> has the value <strong>{Tag, Recv}</strong>, the delivery is
done according to <strong>Recv</strong>: </p><ul><li> <p><strong>pid() | atom()</strong> - The info will be delivered in  
the following messages: </p> <ul><li> <p><strong>{snmp_targets, Tag, Addresses}</strong></p> <p>This inform the user which target addresses the 
notification was sent to. </p> </li><li> <p><strong>{snmp_notification, Tag, {got_response, Address}}</strong></p> <p>This informs the user that this target address 
acknowledged the notification. </p> </li><li> <p><strong>{snmp_notification, Tag, {no_response, Address}}</strong></p> <p>This informs the user that this target address 
did not acknowledge notification. </p> </li></ul> <p>The notification is sent as an Inform-Request to each 
target address in <strong>Addresses</strong> and if there are no 
targets for which an Inform-Request is sent, <strong>Addresses</strong> 
is the empty list <strong>[]</strong>. </p> <p>The <strong>receiver</strong> will first be sent the <strong>snmp_targets</strong> 
message, and then for each address in <strong>Addresses</strong> list, 
one of the two <strong>snmp_notification</strong> messages. </p> </li><li> <p><strong>{Mod, Func, Args}</strong> - The info will be delivered via
the function call: </p> <p><strong>Mod:Func([Msg | Args])</strong></p> <p>where <strong>Msg</strong> has the same content and purpose as the 
messages descrived above.</p> </li></ul><p><strong>Address</strong> is a management target address and <strong>Addresses</strong> is a 
list of management target addresses. They are defined as followes: </p><pre>
        Addresses  = [address()]
        Address    = address()
        address()  = v1_address() | v3_address()
        v1_address() = {TDomain, TAddress}
        v3_address() = {{TDomain, TAddress}, V3MsgData}
        TDomain    = tdoamin()
        TAddress   = taddress()
        tdomain()  = The oid of snmpUDPDomain 
                     This is the only supported transport domain.
        taddress() = [A1, A2, A3, A4, P1, P3]
                     The 4 first bytes makes up the IP-address and the last 2,
                     the UDP-port number.
        V3MsgData  = v3_msg_data()
        v3_msg_data() = term()
</pre><p>If <strong>Receiver</strong> is a <strong>notification_delivery_info()</strong> record,
then the information about the notification delivery will be delivered 
to the <strong>receiver</strong> via the callback functions defined by the 
<a href="snmpa_notification_delivery_info_receiver">snmpa_notification_delivery_info_receiver</a> 
behaviour according to the content of the <strong>notification_delivery_info()</strong> 
record. </p><p>The optional argument <strong>Varbinds</strong> defines
values for the objects in the notification.  If no value is
given for an object, the <strong>Agent</strong> performs a get-operation
to retrieve the value.
</p><p><strong>Varbinds</strong> is a list of <strong>Varbind</strong>, where each
<strong>Varbind</strong> is one of:
</p><ul><li><strong>{Variable, Value}</strong>, where <strong>Variable</strong> is the symbolic name of a scalar variable referred to in the notification specification. </li><li><strong>{Column, RowIndex, Value}</strong>, where <strong>Column</strong> is the symbolic name of a column variable. <strong>RowIndex</strong> is a list of indices for the specified element.  If this is the case, the OBJECT IDENTIFIER sent in the notification is the <strong>RowIndex</strong> appended to the OBJECT IDENTIFIER for the table column. This is the OBJECT IDENTIFIER which specifies the element. </li><li><strong>{OID, Value}</strong>, where <strong>OID</strong> is the OBJECT IDENTIFIER for an instance of an object, scalar variable, or column variable. </li></ul><p>For example, to specify that <strong>sysLocation</strong> should have the
value <strong>"upstairs"</strong> in the notification, we could use one of:
</p><ul><li><strong>{sysLocation, "upstairs"}</strong> or</li><li><strong>{[1,3,6,1,2,1,1,6,0], "upstairs"}</strong> or</li><li><strong>{?sysLocation_instance, "upstairs"}</strong> (provided that the generated <strong>.hrl</strong> file is included)</li></ul><p>If a variable in the notification is a table element, the
<strong>RowIndex</strong> for the element must be given in the
<strong>Varbinds</strong> list. In this case, the OBJECT IDENTIFIER sent
in the notification is the OBJECT IDENTIFIER that identifies this
element.  This OBJECT IDENTIFIER could be used in a get
operation later.
</p><p>This function is asynchronous, and does not return any
information.  If an error occurs, <strong>user_err/2</strong> of the error
report module is called and the notification is discarded.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that the use of the LocalEngineID argument is only intended 
for special cases, if the agent is to "emulate" multiple EngineIDs!
By default, the agent uses the value of <strong>SnmpEngineID</strong> 
(see SNMP-FRAMEWORK-MIB). </p></div><p><strong>ExtraInfo</strong> is not normally used in any way by the agent. 
It is intended to be passed along to the net-if process, which is
a component that a user can implement themself. The users own net-if
may then make use of ExtraInfo. The net-if provided with this 
application does not process ExtraInfo. </p><p>There is one exception. <em>Any</em> tuple containing the atom
<strong>snmpa_default_notification_extra_info</strong> will, in this context,
be considered belonging to this application, and may be processed
by the agent. </p><a name="discovery"></a><h2>discovery(TargetName, Notification) -&gt; {ok, ManagerEngineID} | {error, Reason}</h2><h2>discovery(TargetName, Notification, Varbinds) -&gt; {ok, ManagerEngineID} | {error, Reason}</h2><h2>discovery(TargetName, Notification, DiscoHandler) -&gt; {ok, ManagerEngineID} | {error, Reason}</h2><h2>discovery(TargetName, Notification, ContextName, Varbinds) -&gt; {ok, ManagerEngineID} | {error, Reason}</h2><h2>discovery(TargetName, Notification, Varbinds, DiscoHandler) -&gt; {ok, ManagerEngineID} | {error, Reason}</h2><h2>discovery(TargetName, Notification, ContextName, Varbinds, DiscoHandler) -&gt; {ok, ManagerEngineID} | {error, Reason}</h2><h2>discovery(TargetName, Notification, ContextName, Varbinds, DiscoHandler, ExtraInfo) -&gt; {ok, ManagerEngineID} | {error, Reason}</h2><p>Initiate the discovery process with a manager</p><ul><li><span class="v">TargetName = string()</span></li><li><span class="v">Notification = atom()</span></li><li><span class="v">ContextName = string() (defaults to "")</span></li><li><span class="v">Varbinds = varbinds()</span></li><li><span class="v">varbinds() = [varbind()]</span></li><li><span class="v">DiscoHandler = snmpa_discovery_handler()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">snmpa_discovery_handler() = Module implementing the snmpa_discovery_handler behaviour</span></li><li><span class="v">ManagerEngineID = string()</span></li><li><span class="v">varbind() = {Variable, Value} | {Column, RowIndex, Value} | {OID, Value}</span></li><li><span class="v">Variable = atom()</span></li><li><span class="v">Column = atom()</span></li><li><span class="v">OID = oid()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">RowIndex = [int()]</span></li><li><span class="v">Reason = term()</span></li></ul><p>Initiate the discovery process with the manager identified by
<strong>TargetName</strong> using the notification <strong>Notification</strong>. </p><p>This function is synchronous, which means that it will return when
the discovery process has been completed or failed. </p><p>The <strong>DiscoHandler</strong> module is used during the discovery 
process. See 
<a href="snmpa_discovery_handler">discovery handler</a>
for more info. </p><p>The <strong>ExtraInfo</strong> argument is passed on to the callback functions
of the <strong>DiscoHandler</strong>. </p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If we are not at security-level <strong>noAuthNoPriv</strong>,
this could be complicated, since the agent will then continue 
with stage 2, before which the usm-related updates must be 
done. </p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The default discovery handler will require 
additional actions by the caller and the discovery will not work
if the security-level is higher then <strong>noAuthNoPriv</strong>. </p></div><a name="convert_config"></a><h2>convert_config(OldConfig) -&gt; AgentConfig</h2><p>Convert old snmp config to new agent config</p><ul><li><span class="v">OldConfig = list()</span></li><li><span class="v">AgentConfig = list()</span></li></ul><p>This off-line utility function can be used to convert
the old snmp application config (pre snmp-4.0) to the 
new snmp agent config (as of snmp-4.0).</p><p>For information about the old config (<strong>OldConfig</strong>) 
see the OTP R9C documentation.</p><p>For information about the current agent config 
(<strong>AgentConfig</strong>), see either
the <a href="snmp_app">SNMP application</a> 
part of the reference manual or the 
<a href="snmp_config">Configuring the application</a> 
chapter of the SNMP user's guide.</p><a name="restart_worker"></a><h2>restart_worker() -&gt; void()</h2><h2>restart_worker(Agent) -&gt; void()</h2><p>Restart the worker process of a multi-threaded agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Restart the worker process of a multi-threaded agent.</p><p>This is a utility function, that can be useful when
e.g. debugging instrumentation functions.</p><a name="restart_set_worker"></a><h2>restart_set_worker() -&gt; void()</h2><h2>restart_set_worker(Agent) -&gt; void()</h2><p>Restart the set worker process of a multi-threaded agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Restart the set worker process of a multi-threaded agent.</p><p>This is a utility function, that can be useful when
e.g. debugging instrumentation functions.</p><a name="print_mib_info"></a><h2>print_mib_info() -&gt; void()</h2><p>Print mib info</p><p>Prints the content of all the (snmp) tables and variables 
for all mibs handled by the snmp agent. </p><a name="print_mib_tables"></a><h2>print_mib_tables() -&gt; void()</h2><p>Print mib tables</p><p>Prints the content of all the (snmp) tables 
for all mibs handled by the snmp agent. </p><a name="print_mib_variables"></a><h2>print_mib_variables() -&gt; void()</h2><p>Print mib variables</p><p>Prints the content of all the (snmp) variables 
for all mibs handled by the snmp agent. </p><a name="verbosity"></a><h2>verbosity(Ref,Verbosity) -&gt; void()</h2><p>Assign a new verbosity for the process</p><ul><li><span class="v">Ref = pid() | sub_agents | master_agent | net_if | mib_server | symbolic_store | note_store | local_db</span></li><li><span class="v">Verbosity = verbosity() | {subagents, verbosity()}</span></li><li><span class="v">verbosity() = silence | info | log | debug | trace </span></li></ul><p>Sets verbosity for the designated process. For the lowest 
verbosity <strong>silence</strong>, nothing is printed. The higher the
verbosity, the more is printed. </p><h2>See Also</h2><p>calendar(3), erlc(1) </p></body></html>