<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>snmp</h1><h1>snmp</h1><p>Interface functions to the SNMP toolkit</p><p>The module <strong>snmp</strong> contains interface functions to the 
SNMP toolkit.</p><h2>Common Data Types</h2><p>The following data-types are used in the functions below: </p><ul><li> <p><strong>datetime() = {date(), time()}</strong></p> <p>See <a href="./calendar">calendar</a> 
for more info.</p> </li></ul><a name="config"></a><h1>Functions</h1><h2>config() -&gt; ok | {error, Reason}</h2><p>Configure with a simple interactive tool</p><p>A simple interactive configuration tool. Simple
configuration files can be generated, but more complex
configurations still have to be edited manually.
</p><p>The tool is a textual based tool that asks some questions
and generates <strong>sys.config</strong> and <strong>*.conf</strong> files.
</p><p><em>Note</em> that if the application shall support version 3, 
then the crypto app must be started before running this function 
(password generation).</p><p><em>Note</em> also that some of the configuration files for the 
agent and manager share the same names. This means that 
they have to be stored in <em>different</em> directories!</p><a name="start"></a><h2>start() -&gt; ok | {error, Reason}</h2><h2>start(Type) -&gt; ok | {error, Reason}</h2><p>Start the SNMP application</p><ul><li><span class="v">Type = start_type()</span></li></ul><p>Starts the SNMP application.</p><p>See <a href="./application">application</a> for more info.</p><a name="start_agent"></a><h2>start_agent() -&gt; ok | {error, Reason}</h2><h2>start_agent(Type) -&gt; ok | {error, Reason}</h2><p>Start the agent part of the SNMP application</p><ul><li><span class="v">Type = start_type()</span></li></ul><p>The SNMP application consists of several entities, of which the
agent is one. This function starts the agent entity of the 
application. 
</p><p>Note that the only way to actually start the agent in this way is
to add the agent related config after starting the application (e.g
it cannot be part of the normal application config; sys.config).
This is done by calling: 
<strong>application:set_env(snmp, agent, Conf)</strong>.
</p><p>The default value for <strong>Type</strong> is <strong>normal</strong>.</p><a name="start_manager"></a><h2>start_manager() -&gt; ok | {error, Reason}</h2><h2>start_manager(Type) -&gt; ok | {error, Reason}</h2><p>Start the manager part of the SNMP application</p><ul><li><span class="v">Type = start_type()</span></li></ul><p>The SNMP application consists of several entities, of which the
manager is one. This function starts the manager entity of the 
application. 
</p><p>Note that the only way to actually start the manager in this way is
to add the manager related config after starting the application (e.g
it cannot be part of the normal application config; sys.config).
This is done by calling: 
<strong>application:set_env(snmp, manager, Conf)</strong>.
</p><p>The default value for <strong>Type</strong> is <strong>normal</strong>.</p><a name="dat"></a><h2>date_and_time() -&gt; DateAndTime</h2><p>Return the current date and time as an OCTET STRING</p><ul><li><span class="v">DateAndTime = [int()]</span></li></ul><p>Returns current date and time as the data type DateAndTime,
as specified in RFC1903. This is an OCTET STRING.</p><a name="dat2ut_dst"></a><h2>date_and_time_to_universal_time_dst(DateAndTime) -&gt; [utc()]</h2><p>Convert a DateAndTime value to a list of possible utc()</p><ul><li><span class="v">DateAndTime = [int()]</span></li><li><span class="v">utc() = {{Y,Mo,D},{H,M,S}}</span></li></ul><p>Converts a DateAndTime list to a list of possible universal 
time(s). The universal time value on the same format as defined in
calendar(3). </p><a name="dat2s"></a><h2>date_and_time_to_string(DateAndTime) -&gt; string()</h2><h2>date_and_time_to_string(DateAndTime, Validate) -&gt; string()</h2><p>Convert a DateAndTime value to a string</p><ul><li><span class="v">DateAndTime = [int()]</span></li><li><span class="v">Validate = fun(Kind, Data) -&gt; boolean()</span></li></ul><p>Converts a DateAndTime list to a printable string, according
to the DISPLAY-HINT definition in RFC2579.</p><p>The validation fun,  <strong>Validate</strong>, allows for a more "flexible" 
validation of the <strong>DateAndTime</strong> argument. Whenever the data 
is found to not follow RFC2579, the fun is called to allow a more
"lax" validation. 
See the <a href="#vdat">validate_date_and_time/2</a> 
function for more info on the <strong>Validate</strong> fun. </p><a name="dat2s2"></a><h2>date_and_time_to_string2(DateAndTime) -&gt; string()</h2><p>Convert a DateAndTime value to a string</p><ul><li><span class="v">DateAndTime = [int()]</span></li></ul><p>Converts a DateAndTime list to a printable string, according
to the DISPLAY-HINT definition in RFC2579, with the extension 
that it also allows the values "hours from UTC" = 14 together with 
"minutes from UTC" = 0. </p><a name="lt2dat_dst"></a><h2>local_time_to_date_and_time_dst(Local) -&gt; [DateAndTime]</h2><p>Convert a Local time value to a list of possible DateAndTime(s)</p><ul><li><span class="v">Local = {{Y,Mo,D},{H,M,S}}</span></li><li><span class="v">DateAndTime = [int()]</span></li></ul><p>Converts a local time value to a list of possible DateAndTime 
list(s). The local time value on the same format as defined in 
calendar(3).</p><a name="ut2dat"></a><h2>universal_time_to_date_and_time(UTC) -&gt; DateAndTime</h2><p>Convert a UTC value to DateAndTime</p><ul><li><span class="v">UTC = {{Y,Mo,D},{H,M,S}}</span></li><li><span class="v">DateAndTime = [int()]</span></li></ul><p>Converts a universal time value to a DateAndTime list.  The
universal time value on the same format as defined in calendar(3).</p><a name="vdat"></a><h2>validate_date_and_time(DateAndTime) -&gt; bool()</h2><h2>validate_date_and_time(DateAndTime, Validate) -&gt; bool()</h2><p>Check if a DateAndTime value is correct</p><ul><li><span class="v">DateAndTime = term()</span></li><li><span class="v">Validate = fun(Kind, Data) -&gt; boolean()</span></li></ul><p>Checks if <strong>DateAndTime</strong> is a correct DateAndTime
value, as specified in RFC2579.  This function can be used in
instrumentation functions to validate a DateAndTime value.</p><p>The validation fun,  <strong>Validate</strong>, allows for a more "flexible" 
validation of the <strong>DateAndTime</strong> argument. Whenever the data 
is found to not follow RFC2579, the fun is called to allow a more
"lax" validation. 
The input to the validation fun looks like this: </p><pre>
          Kind             Data
          --------------   ----------------------
          year             {Year1, Year2}
          month            Month
          day              Day
          hour             Hour
          minute           Minute
          seconds          Seconds
          deci_seconds     DeciSeconds
          diff             [Sign, Hour, Minute]
          valid_date       {Year, Month, Day}
	</pre><a name="passwd2localized_key"></a><h2>passwd2localized_key(Alg, Passwd, EngineID) -&gt; Key</h2><p>Generates an localized key</p><ul><li><span class="v">Alg = algorithm()</span></li><li><span class="v">algorithm() = md5 | sha</span></li><li><span class="v">Passwd = string()</span></li><li><span class="v">EngineID = string()</span></li><li><span class="v">Key = list()</span></li></ul><p>Generates a key that can be used as an authentication
or privacy key using MD5 och SHA.  The key is
localized for EngineID.</p><a name="octet_string_to_bits"></a><h2>octet_string_to_bits(S) -&gt; Val</h2><p>Convert an OCTET-STRING to BITS</p><ul><li><span class="v">Val = bits()</span></li></ul><p>Utility function for converting a value of type 
<strong>OCTET-STRING</strong> to <strong>BITS</strong>. </p><a name="bits_to_octet_string"></a><h2>bits_to_octet_string(B) -&gt; Val</h2><p>Convert an OCTET-STRING to BITS</p><ul><li><span class="v">Val = octet_string()</span></li></ul><p>Utility function for converting a value of type <strong>BITS</strong> 
to <strong>OCTET-STRING</strong>. </p><a name="read_mib"></a><h2>read_mib(FileName) -&gt; {ok, mib()} | {error, Reason}</h2><ul><li><span class="v">FileName = string()</span></li><li><span class="v">mib() = #mib{}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Read a compiled mib.</p><a name="log_to_txt"></a><h2>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile) -&gt;  ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block | Start) -&gt;  ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Start, Block | Stop) -&gt; ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Start, Stop, Block) -&gt; ok | {ok, Cnt} | {error, Reason}</h2><p>Convert an Audit Trail Log to text format</p><ul><li><span class="v">LogDir = string()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">OutFile = string()</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">LogName = string()</span></li><li><span class="v">LogFile = string()</span></li><li><span class="v">Start = Stop = null | datetime() | {local_time,datetime()} |  {universal_time,datetime()} </span></li><li><span class="v">Block = boolean()</span></li><li><span class="v">Cnt = {NumOK, NumERR}</span></li><li><span class="v">NumOK = non_neg_integer()</span></li><li><span class="v">NumERR = pos_integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Converts an Audit Trail Log to a readable text file, where
each item has a trailing TAB character, and any TAB
character in the body of an item has been replaced by ESC
TAB. </p><p>The function can be used on a running system, or by copying
the entire log directory and calling this function. SNMP
must be running in order to provide MIB information. </p><p><strong>LogDir</strong> is the name of the directory where the audit
trail log is stored. 
<strong>Mibs</strong> is a list of Mibs to be used. The function uses 
the information in the Mibs to convert for example object 
identifiers to their symbolic name. 
<strong>OutFile</strong> is the name of the generated text-file.
<strong>LogName</strong> is the name of the log, 
<strong>LogFile</strong> is the name of the log file. 
<strong>Start</strong> is the start (first) date and time from which 
log events will be converted and 
<strong>Stop</strong> is the stop (last) date and time to which log 
events will be converted.
The <strong>Block</strong> argument indicates if the log should be blocked
during conversion. This could be usefull when converting large 
logs (when otherwise the log could wrap during conversion). 
Defaults to <strong>true</strong>. 
</p><p>The format of an audit trail log text item is as follows: </p><p><strong>Tag Addr - Community [TimeStamp] Vsn</strong><br/>
<strong>PDU</strong></p><p>where <strong>Tag</strong> is <strong>request</strong>, <strong>response</strong>, 
<strong>report</strong>, <strong>trap</strong> or <strong>inform</strong>; Addr is 
<strong>IP:Port</strong> (or comma space separated list of such);
<strong>Community</strong> is the community parameter (SNMP version
v1 and v2), or <strong>SecLevel:"AuthEngineID":"UserName"</strong>
(SNMP v3); <strong>TimeStamp</strong> is a date and time stamp,
and <strong>Vsn</strong> is the SNMP version. <strong>PDU</strong> is a textual
version of the protocol data unit. There is a new line
between <strong>Vsn</strong> and <strong>PDU</strong>.</p><p>If the entire log is successfully converted, the function 
will return <strong>ok</strong>. 
If one of more entries fail to convert, the function will instead
return <strong>{ok, {NumOK, NumERR}}</strong>, where the counters indicate
how many valid and erroneous entries where found. 
If instead <strong>{error, Reason}</strong> is returned, the conversion 
encountered a fatal error and where either never done of aborted
midway. </p><a name="log_to_io"></a><h2>log_to_io(LogDir, Mibs, LogName, LogFile) -&gt;  ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_io(LogDir, Mibs, LogName, LogFile, Block | Start) -&gt;  ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_io(LogDir, Mibs, LogName, LogFile, Start, Block | Stop) -&gt; ok | {ok, Cnt} | {error, Reason}</h2><h2>log_to_io(LogDir, Mibs, LogName, LogFile, Start, Stop, Block) -&gt; ok | {ok, Cnt} | {error, Reason}</h2><p>Convert an Audit Trail Log to text format</p><ul><li><span class="v">LogDir = string()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">LogName = string()</span></li><li><span class="v">LogFile = string()</span></li><li><span class="v">Start = Stop = null | datetime() | {local_time,datetime()} |  {universal_time,datetime()} </span></li><li><span class="v">Cnt = {NumOK, NumERR}</span></li><li><span class="v">NumOK = non_neg_integer()</span></li><li><span class="v">NumERR = pos_integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Converts an Audit Trail Log to a readable format and 
prints it on stdio. See 
<a href="./snmp#log_to_txt">log_to_txt</a> 
above for more info.</p><a name="change_log_size"></a><h2>change_log_size(LogName, NewSize) -&gt; ok | {error, Reason}</h2><p>Change the size of the Audit Trail Log</p><ul><li><span class="v">LogName = string()</span></li><li><span class="v">NewSize = {MaxBytes, MaxFiles}</span></li><li><span class="v">MaxBytes = integer()</span></li><li><span class="v">MaxFiles = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Changes the log size of the Audit Trail Log.  The
application must be configured to use the audit trail log
function. Please refer to disk_log(3) in Kernel Reference 
Manual for a description of how to change the log size.
</p><p>The change is permanent, as long as the log is not deleted. 
That means, the log size is remembered across reboots.</p><a name="print_version_info"></a><h2>print_version_info() -&gt; void()</h2><h2>print_version_info(Prefix) -&gt; void()</h2><p>Formatted print of result of the versions functions</p><ul><li><span class="v">Prefix = string() | integer()</span></li></ul><p>Utility function(s) to produce a formatted printout of the versions
info generated by the <strong>versions1</strong> function</p><p>This is the same as doing, e.g.: </p><pre>
           {ok, V} = snmp:versions1(), 
           snmp:print_versions(V).
        </pre><a name="versions1"></a><a name="versions2"></a><h2>versions1() -&gt; {ok, Info} | {error, Reason}</h2><h2>versions2() -&gt; {ok, Info} | {error, Reason}</h2><p>Retrieve various system and application info</p><ul><li><span class="v">Info = [info()]</span></li><li><span class="v">info() = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Utility functions used to retrieve some system and
application info.</p><p>The difference between the two functions is in how they get
the modules to check. <strong>versions1</strong> uses the app-file and
<strong>versions2</strong> uses the function <strong>application:get_key</strong>.</p><a name="print_versions"></a><h2>print_versions(VersionInfo) -&gt; void()</h2><h2>print_versions(Prefix, VersionInfo) -&gt; void()</h2><p>Formatted print of result of the versions functions</p><ul><li><span class="v">VersionInfo = [version_info()]</span></li><li><span class="v">version_info() = term()</span></li><li><span class="v">Prefix = string() | integer()</span></li></ul><p>Utility function to produce a formatted printout of the versions
info generated by the <strong>versions1</strong> and <strong>versions2</strong>
functions</p><p>Example: </p><pre>
           {ok, V} = snmp:versions1(), 
           snmp:print_versions(V).
        </pre><a name="enable_trace"></a><h2>enable_trace() -&gt; void()</h2><p>Starts a tracer</p><p>Starts a dbg tracer that prints trace events to stdout (using
plain io:format after a minor formatting). </p><a name="disable_trace"></a><h2>disable_trace() -&gt; void()</h2><p>Stop the tracer</p><p>Stop the tracer. </p><a name="set_trace1"></a><h2>set_trace(Targets) -&gt; void()</h2><p>Set trace target</p><ul><li><span class="v">Targets = target() | targets()</span></li><li><span class="v">target() = module()</span></li><li><span class="v">module() = atom()</span></li><li><span class="v">targets() = [target() | {target(), target_options()}]</span></li><li><span class="v">target_options() = [target_option()]</span></li><li><span class="v">target_option() = {return_trace, boolean()} | {scope, scope()}</span></li><li><span class="v">scope() = all_functions | exported_functions | function_name() | {function_name(), function_arity()}</span></li><li><span class="v">function_name() = atom()</span></li><li><span class="v">function_arity() = integer() &gt;= 0</span></li></ul><p>This function is used to set up default trace on function(s) 
for the given module or modules. The scope of the trace will be 
all <em>exported</em> functions (both the call info and the return 
value). Timestamp info will also be included. </p><a name="reset_trace"></a><h2>reset_trace(Targets) -&gt; void()</h2><p>Reset trace target</p><ul><li><span class="v">Targets = module() | modules()</span></li><li><span class="v">modules() = [module()]</span></li><li><span class="v">module() = atom()</span></li></ul><p>This function is used to reset (disable) trace for the 
given module(s). </p><a name="set_trace2"></a><h2>set_trace(Targets, Opts) -&gt; void()</h2><p>Set trace target</p><ul><li><span class="v">Targets = target() | targets()</span></li><li><span class="v">target() = module()</span></li><li><span class="v">module() = atom()</span></li><li><span class="v">targets() = [target() | {target(), target_options()}]</span></li><li><span class="v">target_options() = [target_option()]</span></li><li><span class="v">target_option() = {return_trace, boolean()} | {scope, scope()}</span></li><li><span class="v">scope() = all_functions | exported_functions | function_name() | {function_name(), function_arity()}</span></li><li><span class="v">function_name() = atom()</span></li><li><span class="v">function_arity() = integer() &gt;= 0</span></li><li><span class="v">Opts = disable | trace_options()</span></li><li><span class="v">trace_options() = [trace_option()]</span></li><li><span class="v">trace_option() = {timestamp, boolean()} | target_option()</span></li></ul><p>This function is used to set up trace on function(s) for the given
module or modules. </p><p>The example below sets up trace on the exported functions (default) 
of module <strong>snmp_generic</strong> and all functions of module 
<strong>snmp_generic_mnesia</strong>. With return values (which is default)
and timestamps in both cases (which is also default): </p><pre>
	  snmp:enable_trace(),
	  snmp:set_trace([snmp_generic, 
                          {snmp_generic_mnesia, [{scope, all_functions}]}]),
	  .
	  .
	  .
          snmp:set_trace(snmp_generic, disable),
	  .
	  .
	  .
	  snmp:disable_trace(),
	</pre><h2>See Also</h2><p>calendar(3)
</p></body></html>