<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>SNMP User's Guide</h1><p>A multilingual Simple Network Management Protocol application,
featuring an Extensible Agent, a simple manager and a MIB 
compiler and facilities for implementing SNMP MIBs etc.</p><p>The SNMP development toolkit contains the following parts:
</p><ul><li>An Extensible multi-lingual SNMP agent, which understands SNMPv1 (RFC1157), SNMPv2c (RFC1901, 1905, 1906 and 1907), SNMPv3 (RFC2271, 2272, 2273, 2274 and 2275), or any combination of these protocols. </li><li>A multi-lingual SNMP manager. </li><li>A MIB compiler, which understands SMIv1 (RFC1155, 1212, and 1215) and SMIv2 (RFC1902, 1903, and 1904). </li></ul><p>The SNMP development tool provides an environment for
rapid agent/manager prototyping and construction. With the 
following information provided, this tool is used to set up a 
running multi-lingual SNMP agent/manager:
</p><ul><li>a description of a Management Information Base (MIB) in Abstract Syntax Notation One (ASN.1) </li><li>instrumentation functions for the managed objects in the MIB, written in Erlang. </li></ul><p>The advantage of using an extensible (agent/manager) toolkit is to 
remove details such as type-checking, access rights, Protocol Data Unit
(PDU), encoding, decoding, and trap distribution from the
programmer, who only has to write the instrumentation functions,
which implement the MIBs. The <strong>get-next</strong> function only
has to be implemented for tables, and not for every variable in
the global naming tree. This information can be deduced from the
ASN.1 file.
</p><h3>Scope and Purpose</h3><p>This manual describes the SNMP development tool,
as a component of the Erlang/Open Telecom Platform development
environment. It is assumed that the reader is familiar with the
Erlang Development Environment, which is described in a separate
User's Guide.</p><h3>Prerequisites</h3><p>The following prerequisites
is required for understanding the material in the SNMP
User's Guide:
</p><ul><li>the basics of the Simple Network Management Protocol version 1 (SNMPv1) </li><li>the basics of the community-based Simple Network Management Protocol version 2 (SNMPv2c) </li><li>the basics of the Simple Network Management Protocol version 3 (SNMPv3) </li><li>the knowledge of defining MIBs using SMIv1 and SMIv2 </li><li>familiarity with the Erlang system and Erlang programming </li></ul><p>The tool requires Erlang release 4.7 or later.
</p><h3>Definitions</h3><p>The following definitions are used in the SNMP User's Guide.
</p><dl><dt>MIB</dt><dd>The conceptual repository for management information is called the Management Information Base (MIB). It  does not hold any data, merely a definition of what data can be accessed.  A definition of an MIB is a description of a collection of managed objects. </dd><dt>SMI</dt><dd>The MIB is specified in an adapted subset of the Abstract Syntax Notation One (ASN.1) language.  This adapted subset is called the Structure of Management Information (SMI). </dd><dt>ASN.1</dt><dd>ASN.1 is used in two different ways in SNMP.  The SMI is based on ASN.1, and the messages in the protocol are defined by using ASN.1. </dd><dt>Managed object</dt><dd> <p>A resource to be managed is represented by a managed
object, which resides in the MIB. In an SNMP MIB, the managed
objects are either:</p> <ul><li><em>scalar variables</em>, which have only one instance per context. They have single values, not multiple values like vectors or structures. </li><li><em>tables</em>, which can grow dynamically. </li><li>a <em>table element</em>, which is a special type of scalar variable.</li></ul> </dd><dt>Operations</dt><dd>SNMP relies on the three basic operations: get (object), set (object, value) and get-next (object). </dd><dt>Instrumentation function</dt><dd>An instrumentation function is associated with each managed object. This is the function, which actually implements the operations and will be called by the agent when it receives a request from the management station.</dd><dt>Manager</dt><dd>A manager generates commands and receives notifications  from agents. There usually are only a few managers in a system.</dd><dt>Agent</dt><dd>An agent responds to commands from the manager, and sends notification to the manager. There are potentially many agents  in a system.</dd></dl><h3>About This Manual</h3><p>In addition to this introductory chapter, the SNMP User's Guide
contains the following chapters:
</p><ul><li>Chapter 2: "Functional Description" describes the features and operation of the SNMP development toolkit. It includes topics on Sub-agents and MIB loading, Internal MIBs, and Traps. </li><li>Chapter 3: "The MIB Compiler" describes the features and the operation of the MIB compiler. </li><li>Chapter 4: "Running the application" describes how to start and configure the application. Topics on how to debug the application  are also included. </li><li>Chapter 5: "Definition of Agent Configuration Files" is a reference chapter, which contains more detailed information about the agent configuration files. </li><li>Chapter 6: "Definition of Manager Configuration Files" is a reference chapter, which contains more detailed information about the manager configuration files. </li><li>Chapter 7: "Agent Implementation Example" describes how an MIB can be implemented with the SNMP Development Toolkit.  Implementation examples are included. </li><li>Chapter 8: "Instrumentation Functions" describes how instrumentation functions should be defined in Erlang for the different operations. </li><li>Chapter 9: "Definition of Instrumentation Functions" is a reference chapter which contains more detailed information about the instrumentation functions. </li><li>Chapter 10: "Definition of Agent Net if" is a reference chapter, which describes the Agent Net if function in detail. </li><li>Chapter 11: "Definition of Manager Net if" is a reference chapter, which describes the Manager Net if function in detail. </li><li>Chapter 12: "Advanced Agent Topics" describes sub-agents, agent semantics, audit trail logging, and the consideration of distributed tables. </li><li>Appendix A describes the conversion of SNMPv2 to SNMPv1 error messages. </li><li>Appendix B contains the RFC1903 text on <strong>RowStatus</strong>. </li></ul><h3>Where to Find More Information</h3><p>Refer to the following documentation for more information about
SNMP and about the Erlang/OTP development system:
</p><ul><li>Marshall T. Rose (1991), "The Simple Book - An Introduction to Internet Management", Prentice-Hall </li><li>Evan McGinnis and David Perkins (1997), "Understanding SNMP MIBs", Prentice-Hall </li><li>RFC1155, 1157, 1212 and 1215 (SNMPv1) </li><li>RFC1901-1907 (SNMPv2c) </li><li>RFC1908, 2089 (coexistence between SNMPv1 and SNMPv2) </li><li>RFC2271, RFC2273 (SNMP std MIBs) </li><li>the Mnesia User's Guide </li><li>the Erlang 4.4 Extensions User's Guide </li><li>the Reference Manual </li><li>the Erlang Embedded Systems User's Guide </li><li>the System Architecture Support Libraries (SASL) User's Guide </li><li>the Installation Guide </li><li>the Asn1 User's Guide </li><li>Concurrent Programming in Erlang, 2nd Edition (1996), Prentice-Hall, ISBN 0-13-508301-X. </li></ul><p>The SNMP agent system consists of one Master Agent and
optional Sub-agents.
</p><p>The tool makes it easy to dynamically extend an SNMP agent in
run-time. MIBs can be loaded and unloaded at any time. It is also
easy to change the implementation of an MIB in run-time, without
having to recompile the MIB. The MIB implementation is clearly
separated from the agent.
</p><p>To facilitate incremental MIB implementation, the tool can
generate a prototype implementation for a whole MIB, or parts
thereof. This allows different MIBs and management applications to
be developed at the same time.
</p><h3>Features</h3><a name="features"></a><p>To implement an agent, the programmer writes instrumentation
functions for the variables and the tables in the MIBs that the
agent is going to support. A running prototype which handles <strong>set</strong>,
<strong>get</strong>, and <strong>get-next</strong> can be created without any programming.
</p><p>The toolkit provides the following:
</p><ul><li>multi-lingual multi-threaded extensible SNMP agent</li><li>easy writing of instrumentation functions with a high-level programming language</li><li>basic fault handling such as automatic type checking</li><li>access control</li><li>authentication</li><li>privacy through encryption</li><li>loading and unloading of MIBs in run-time</li><li>the ability to change instrumentation functions without recompiling the MIB</li><li>rapid prototyping environment where the MIB compiler can use generic instrumentation functions, which later can be refined by the programmer</li><li>a simple and extensible model for transaction handling and consistency checking of set-requests</li><li>support of the sub-agent concept via distributed Erlang</li><li>a mechanism for sending notifications (traps and informs)</li><li>support for implementing SNMP tables in the Mnesia DBMS.</li></ul><h3>SNMPv1, SNMPv2 and SNMPv3</h3><a name="versions"></a><p>The SNMP development toolkit works with all three versions of
Standard Internet Management Framework; SNMPv1, SNMPv2 and SNMPv3.
They all share the same basic structure and components. And they 
follow the same architecture.</p><p>The versions are defined in following RFCs</p><ul><li>SNMPv1        RFC 1555, 1157 1212, 1213 and 1215</li><li>SNMPv2        RFC 1902 - 1907</li><li>SNMPv3        RFC  2570 - 2575</li></ul><p>Over time, as the Framework has evolved from SNMPv1 , through SNMPv2, 
to SNMPv3 the definitions of each of these architectural components
have become richer and more clearly defined, but the fundamental
architecture has remained consistent.</p><p>The main features of SNMPv2 compared to SNMPv1 are:
</p><ul><li>The <strong>get-bulk</strong> operation for transferring large amounts of data. </li><li>Enhanced error codes. </li><li>A more precise language for MIB specification</li></ul><p>The standard documents that define SNMPv2 are incomplete, in
the sense that they do not specify how an SNMPv2 message looks
like.  The message format and security issues are left to a
special Administrative Framework. One such framework is the
Community-based SNMPv2 Framework (SNMPv2c), which uses the same
message format and framework as SNMPv1.   Other
experimental frameworks as exist, e.g. SNMPv2u and SNMPv2*.
</p><p>The SNMPv3 specifications take a modular 
approach to SNMP.  All modules are
separated from each other, and can be extended or replaced
individually.  Examples of modules are Message definition,
Security and Access Control.  The main features of SNMPv3 are:
</p><ul><li>Encryption and authentication is added. </li><li>MIBs for agent configuration are defined.</li></ul><p>All these specifications are commonly referred to as "SNMPv3",
but it is actually only the Message module, which defines a new
message format, and Security module, which takes care of
encryption and authentication, that cannot be used with SNMPv1 or
SNMPv2c.  In this version of the agent toolkit, all the standard
MIBs for agent configuration are used.  This includes MIBs for
definition of management targets for notifications.  These MIBs
are used regardless of which SNMP version the agent is configured
to use.
</p><p>The extensible agent in this toolkit understands the SNMPv1,
SNMPv2c and SNMPv3. Recall that SNMP consists of two separate
parts, the MIB definition language (SMI), and the protocol.  On
the protocol level, the agent can be configured to speak v1, v2c,
v3 or any combination of them at the same time, i.e. a v1 request
gets an v1 reply, a v2c request gets a v2c reply, and a v3 request
gets a v3 reply.  On the MIB level, the MIB compiler can compile
both SMIv1 and SMIv2 MIBs.  Once compiled, any of the formats can
be loaded into the agent, regardless of which protocol version the
agent is configured to use.  This means that the agent translates
from v2 notifications to v1 traps, and vice versa.  For example,
v2 MIBs can be loaded into an agent that speaks v1 only.  The
procedures for the translation between the two protocols are
described in RFC 1908 and RFC 2089.
</p><p>In order for an implementation to make full use of the enhanced
SNMPv2 error codes, it is essential that the instrumentation
functions always return SNMPv2 error codes, in case of error.
These are translated into the corresponding SNMPv1 error codes by
the agent, if necessary.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The translation from an SMIv1 MIB to an SNMPv2c or SNMPv3 reply
is always very straightforward, but the translation from a v2 MIB
to a v1 reply is somewhat more complicated.  There is one data
type in SMIv2, called <strong>Counter64</strong>, that an SNMPv1 manager cannot
decode correctly.  Therefore, an agent may never send a <strong>Counter64</strong>
object to an SNMPv1 manager.  The common practice in these
situations is to simple ignore any <strong>Counter64</strong> objects, when sending
a reply or a trap to an SNMPv1 manager.  For example, if an SNMPv1
manager tries to GET an object of type <strong>Counter64</strong>, he will get a
<strong>noSuchName</strong> error, while an SNMPv2 manager would get a
correct value.</p></div><h3>Operation</h3><a name="operations"></a><p>The following steps are needed to get a running agent:</p><ul><li> <p>Write your MIB in SMI in a text file.</p> </li><li> <p>Write the instrumentation functions in Erlang and compile them.</p> </li><li> <p>Put their names in the association file.</p> </li><li> <p>Run the MIB together with the association file through the
MIB compiler.</p> </li><li> <p>Configure the application (agent).</p> </li><li> <p>Start the application (agent).</p> </li><li> <p>Load the compiled MIB into the agent.</p> </li></ul><p>The figures in this section illustrate the steps involved in
the development of an SNMP agent.</p><a name="image-1"></a><img src="snmp-um-1-image-1.gif" title="MIB Compiler Principles"></img><p>The compiler parses the SMI file and associates each table or
variable with an instrumentation function (see the figure <a href="#image-1">MIB Compiler Principles</a>). The actual
instrumentation functions are not needed at MIB compile time, only
their names.
</p><p>The binary output file produced by the compiler is read by the
agent at MIB load time (see the figure <a href="#image-2">Starting the Agent</a>). The instrumentation is ordinary Erlang code which
is loaded explicitly or automatically the first time it is called.</p><a name="image-2"></a><img src="snmp-um-1-image-2.gif" title="Starting the Agent"></img><p>The SNMP agent system consists of one Master Agent and optional
sub-agents. The Master Agent can be seen as a special kind of
sub-agent. It implements the core agent functionality, UDP packet
processing, type checking, access control, trap distribution, and
so on. From a user perspective, it is used as an ordinary
sub-agent.
</p><p>Sub-agents are only needed if your application requires special
support for distribution from the SNMP toolkit. A sub-agent can
also be used if the application requires a more complex set
transaction scheme than is found in the master agent.
</p><p>The following illustration shows how a system can look  in runtime.</p><a name="snmp_ch2_fig3"></a><img src="snmp-um-1-image-3.gif" title="Architecture"></img><p>A typical operation could include the following steps:</p><ul><li>The Manager sends a request to the Agent.</li><li>The Master Agent  decodes the incoming UDP packet.</li><li>The Master Agent determines which items in the request that should be processed here and which items should be forwarded to its subagent.</li><li>Step 3 is repeated by all subagents.</li><li>Each sub-agent calls the instrumentation for its loaded MIBs.</li><li>The results of calling the instrumentation are propagated back to the Master Agent.</li><li>The answer to the request is encoded to a UDP Protocol Data Unit (PDU).</li></ul><p>The sequence of steps shown is probably more complex than
normal, but it illustrates the amount of functionality which is
available. The following points should be noted:
</p><ul><li>An agent can have many MIBs loaded at the same time.</li><li>Sub-agents can also have sub-agents. Each sub-agent can have an arbitrary number of child sub-agents registered, forming a hierarchy.</li><li>One MIB can communicate with many applications.</li><li>Instrumentation can use Distributed Erlang to communicate with an application.</li></ul><p>Most applications only need the Master Agent because an agent
can have multiple MIBs loaded at the same time.</p><h3>Sub-agents and MIB Loading</h3><a name="sub_agent_mib_loading"></a><p>Since applications tend to be transient (they are dynamically
loaded and unloaded), the management of these applications must be
dynamic as well. For example, if we have an equipment MIB for a
rack and different MIBs for boards, which can be installed in the
rack, the MIB for a card should be loaded when the card is
inserted, and unloaded when the card is removed.
</p><p>In this agent system, there are two ways to dynamically install
management information. The most common way is to load an MIB into
an agent. The other way is to use a sub-agent, which is controlled
by the application and is able to register and unregister itself. A
sub-agent can register itself for managing a sub-tree (not to be mixed up
with <strong>erlang:register</strong>). The sub-tree is identified by an
Object Identifier. When a sub-agent is registered, it receives all
requests for this particular sub-tree and it is responsible for
answering them. It should also be noted that a sub-agent can be
started and stopped at any time.
</p><p>Compared to other SNMP agent packages, there is a significant
difference in this way of using sub-agents. Other packages normally
use sub-agents to load and unload MIBs in run-time. In Erlang, it is
easy to load code in run-time and it is possible to load an MIB
into an existing sub-agent. It is not necessary to create a new process
for handling a new MIB.
</p><p>Sub-agents are used for the following reasons:
</p><ul><li>to provide a more complex set-transaction scheme than master agent</li><li>to avoid unnecessary process communication</li><li>to provide a more lightweight mechanism for loading and unloading MIBs in run-time</li><li>to provide interaction with other SNMP agent toolkits.</li></ul><p>Refer to the chapter 
<a href="snmp_advanced_agent">Advanced Agent Topics</a> 
in this User's Guide for more information about these topics.
</p><p>The communication protocol between sub-agents is the normal
message passing which is used in distributed Erlang systems. This
implies that sub-agent communication is very efficient compared to
SMUX, DPI, AgentX, and similar protocols.</p><h3>Contexts and Communities</h3><a name="context_and_communities"></a><p>A context is a collection of management information accessible
by an SNMP entity. An instance of a management object may exist in
more than one context. An SNMP entity potentially has access to
many contexts.</p><p>Each managed object can exist in many instances within a
SNMP entity. To identify the instances, specified by an MIB module,
a method to distinguish the actual instance by its 'scope' or 
context is used. Often the context is a physical or a logical device. 
It can include multiple devices, a subset of a single device or a 
subset of multiple devices, but the context is always
defined as a subset of a single SNMP entity. To be able to 
identify a specific 
item of management information within an SNMP entity, the context,
the object type and its instance must be used.</p><p>For example, the managed object type <strong>ifDescr</strong> from RFC1573, is
defined as the description of a network interface.  To identify
the description of device-X's first network interface, four pieces
of information are needed: the snmpEngineID of the SNMP entity
which provides access to the management information at device-X,
the <strong>contextName</strong> (device-X), the managed object type 
(<strong>ifDescr</strong>), and the instance ("1").
</p><p>In SNMPv1 and SNMPv2c, the community string in the message was
used for (at least) three different purposes:
</p><ul><li> <p>to identify the context</p> </li><li> <p>to provide authentication</p> </li><li> <p>to identify a set of trap targets</p> </li></ul><p>In SNMPv3, each of these usage areas has its own unique
mechanism.  A context is identified by the name of the SNMP
entity, <strong>contextEngineID</strong>, and the name of the context,
<strong>contextName</strong>.  Each SNMPv3 message contains values for these
two parameters.
</p><p>There is a MIB, SNMP-COMMUNITY-MIB, which maps a community
string to a <strong>contextEngineID</strong> and <strong>contextName</strong>. Thus, 
each message, an SNMPv1, SNMPv2c or an SNMPv3 message, always 
uniquely identifies a context.
</p><p>For an agent, the <strong>contextEngineID</strong> identified by a received
message, is always equal to the <strong>snmpEngineID</strong> of the agent.
Otherwise, the message was not intended for the agent.  If the
agent is configured with more than one context, the
instrumentation code must be able to figure out for which context
the request was intended.  There is a function
<strong>snmpa:current_context/0</strong> provided for this purpose.
</p><p>By default, the agent has no knowledge of any other contexts
than the default context, <strong>""</strong>.  If it is to support more
contexts, these must be explicitly added, by using an appropriate
configuration file 
<a href="snmp_agent_config_files">Agent Configuration Files</a>.
</p><h3>Management of the Agent</h3><a name="management"></a><p>There is a set of standard MIBs, which are used to control and
configure an SNMP agent.  All of these MIBs, with the exception of
the optional SNMP-PROXY-MIB (which is only used for proxy agents),
are implemented in this agent.  Further, it is configurable which
of these MIBs are actually loaded, and thus made visible to SNMP
managers.  For example, in a non-secure environment, it might be a
good idea to not make MIBs that define access control visible.
Note, the data the MIBs define is used internally in the
agent, even if the MIBs not are loaded.  This chapter describes
these standard MIBs, and some aspects of their implementation.
</p><p>Any SNMP agent must implement the <strong>system</strong> group and the
<strong>snmp</strong> group, defined in MIB-II.  The definitions of these
groups have changed from SNMPv1 to SNMPv2.   MIBs and implementations
for both of these versions are Provided in the
distribution.  The MIB file for SNMPv1 is called STANDARD-MIB, and the
corresponding for SNMPv2 is called SNMPv2-MIB.  If the agent is
configured for SNMPv1 only, the STANDARD-MIB is loaded by default;
otherwise, the SNMPv2-MIB is loaded by default.  It is possible to
override this default behavior, by explicitly loading another
version of this MIB, for example, you could choose to implement
the union of all objects in these two MIBs.
</p><p>An SNMPv3 agent must implement the SNMP-FRAMEWORK-MIB and
SNMP-MPD-MIB.  These MIBs are loaded by default, if the agent is
configured for SNMPv3.  These MIBs can be loaded for other
versions as well.
</p><p>There are five other standard MIBs, which also may be loaded
into the agent.  These MIBs are:
</p><ul><li> <p>SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB, which defines
managed objects for configuration of management targets,
i.e. receivers of notifications (traps and informs).  These
MIBs can be used with any SNMP version.
</p> </li><li> <p>SNMP-VIEW-BASED-ACM-MIB, which defined managed objects
for access control.  This MIB can be used with any SNMP
version.
</p> </li><li> <p>SNMP-COMMUNITY-MIB, which defines managed objects for
coexistence of SNMPv1 and SNMPv2c with SNMPv3.  This MIB is
only useful if SNMPv1 or SNMPv2c is used, possibly in
combination with SNMPv3.
</p> </li><li> <p>SNMP-USER-BASED-SM-MIB, which defines managed objects
for authentication and privacy.  This MIB is only useful
with SNMPv3.
</p> </li></ul><p>All of these MIBs should be loaded into the Master Agent.  Once
loaded, these MIBs are always available in all contexts.
</p><p>The ASN.1 code, the Erlang source code, and the generated
<strong>.hrl</strong> files for them are provided in the distribution and are 
placed  in the directories <strong>mibs</strong>, <strong>src</strong>, and <strong>include</strong>,
respectively, in the <strong>snmp</strong> application.
</p><p>The <strong>.hrl</strong> files are generated with
<strong>snmpc:mib_to_hrl/1</strong>.  Include these files in your code as in
the following example:
</p><pre><code class="">
-include_lib("snmp/include/SNMPv2-MIB.hrl").
    </code></pre><p>The initial values for the managed objects defined in these
tables, are read at start-up from a set of configuration files.
These are described in <a href="snmp_config">Configuration Files</a>.
</p><h3>STANDARD-MIB and SNMPv2-MIB</h3><p>These MIBs contain the <strong>snmp-</strong> and <strong>system</strong> groups
from MIB-II which is defined in RFC1213 (STANDARD-MIB) or
RFC1907 (SNMPv2-MIB).  They are implemented in the
<strong>snmp_standard_mib</strong> module. The <strong>snmp</strong> counters all
reside in volatile memory and the <strong>system</strong> and
<strong>snmpEnableAuthenTraps</strong> variables in persistent memory,
using the SNMP built-in database (refer to the Reference Manual,
section <strong>snmp</strong>, module <strong>snmpa_local_db</strong> for more
details).</p><p>If another implementation of any of these variables is needed,
e.g. to store the persistent variables in a Mnesia database,
an own implementation of the variables must be made. That MIB 
will be compiled and loaded instead of the default MIB. 
The new compiled MIB
must have the same name as the original MIB (i.e. STANDARD-MIB
or SNMPv2-MIB), and be located in the SNMP configuration
directory (see <a href="snmp_config">Configuration Files</a>.) 
</p><p>One of these MIBs is always loaded.  If only SNMPv1 is used,
STANDARD-MIB is loaded, otherwise SNMPv2-MIB is loaded.
</p><h3>Data Types</h3><p>There are some new data types in SNMPv2 that are useful in
SNMPv1 as well.  In the STANDARD-MIB, three data types are
defined, <strong>RowStatus</strong>, <strong>TruthValue</strong> and
<strong>DateAndTime</strong>.  These data types are originally defined
as textual conventions in SNMPv2-TC (RFC1903).
</p><h3>SNMP-FRAMEWORK-MIB and SNMP-MPD-MIB</h3><p>The SNMP-FRAMEWORK-MIB and SNMP-MPD-MIB define additional 
read-only managed objects, which
is used in the generic SNMP framework defined in RFC2271 and the
generic message processing and dispatching module defined in
RFC2272.  They are generic in the sense that they are not tied
to any specific SNMP version.
</p><p>The objects in these MIBs are implemented in the modules
<strong>snmp_framework_mib</strong> and <strong>snmp_standard_mib</strong>,
respectively.  All objects reside in volatile memory, and the
configuration files are always reread at start-up.
</p><p>If SNMPv3 is used, these MIBs are loaded by default.
</p><h3>SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB</h3><p>The SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB define managed 
objects for configuration of notification receivers.  They 
are described in detail in RFC2273.  Only a brief description 
is given here.
</p><p>All tables in these MIBs have a column of type
<strong>StorageType</strong>.  The value of this column specifies how each
row is stored, and what happens in case of a restart of the
agent.  The implementation supports the values <strong>volatile</strong>
and <strong>nonVolatile</strong>.  When the tables are initially filled
with data from the configuration files, these rows will
automatically have storage type <strong>nonVolatile</strong>.  Should the
agent restart, all <strong>nonVolatile</strong> rows survive the restart,
while the <strong>volatile</strong> rows are lost.
The configuration files are not read at restart, by default.
</p><p>These MIBs are not loaded by default.
</p><h3>snmpNotifyTable</h3><p>An entry in the <strong>snmpNotifyTable</strong> selects a set
of management targets, which should receive notifications, 
as well as the type (trap or inform) of notification that 
should be sent to each selected management target.
When an application sends a notification using
the function <strong>send_notification/5</strong> or the function
<strong>send_trap</strong> the parameter <strong>NotifyName</strong>, specified in
the call, is used as an index in the table.  The notification
is sent to the management targets selected by that entry.
</p><h3>snmpTargetAddrTable</h3><p>An entry in the <strong>snmpTargetAddrTable</strong> defines
transport parameters (such as
IP address and UDP port) for each management target.  Each row
in the <strong>snmpNotifyTable</strong> refers to potentially many rows
in the <strong>snmpTargetAddrTable</strong>.  Each row in the
<strong>snmpTargetAddrTable</strong>
refers to an entry in the <strong>snmpTargetParamsTable</strong>.
</p><h3>snmpTargetParamsTable</h3><p>An entry in the <strong>snmpTargetParamsTable</strong> defines 
which SNMP version to use, and which security parameters to use.
</p><p>Which SNMP version to use is implicitly defined by
specifying the Message Processing Model.  This version of the
agent handles the models <strong>v1</strong>, <strong>v2c</strong> and <strong>v3</strong>.
</p><p>Each row specifies which security model to use, along with
security level and security parameters.
</p><h3>SNMP-VIEW-BASED-ACM-MIB</h3><p>The SNMP-VIEW-BASED-ACM-MIB defines managed objects to
control access to the the managed objects for the managers.  
The View Based Access Control Module (VACM) can be used with 
any SNMP version. However, if it is used with SNMPv1 or SNMPv2c, 
the SNMP-COMMUNITY-MIB defines additional objects to map 
community strings to VACM parameters.
</p><p>All tables in this MIB have a column of type <strong>StorageType</strong>.  
The value of this column specifies how each
row is stored, and what happens in case of a restart of the
agent.  The implementation supports the values <strong>volatile</strong>
and <strong>nonVolatile</strong>.  When the tables are initially filled
with data from the configuration files, these rows will
automatically have storage type <strong>nonVolatile</strong>.  Should the
agent restart, all <strong>nonVolatile</strong> rows survive the restart,
while the <strong>volatile</strong> rows are lost.
The configuration files are not read at restart by default.
</p><p>This MIB is not loaded by default.
</p><p>VACM is described in detail in RFC2275.  Here is only a brief
description given.
</p><p>The basic concept is that of a <em>MIB view</em>.  An MIB view
is a subset of all the objects implemented by an agent.  A
manager has access to a certain MIB view, depending on which
security parameters are used, in which context the request is
made, and which type of request is made.
</p><p>The following picture gives an overview of the mechanism to
select an MIB view:</p><img src="MIB_mechanism.gif" title="Overview of the mechanism of MIB selection"></img><h3>vacmContextTable</h3><p>The <strong>vacmContextTable</strong> is a read-only table that lists all
available contexts.
</p><h3>vacmSecurityToGroupTable</h3><p>The <strong>vacmSecurityToGroupTable</strong> maps a <strong>securityModel</strong>
and a
<strong>securityName</strong> to a <strong>groupName</strong>.
</p><h3>vacmAccessTable</h3><p>The <strong>vacmAccessTable</strong> maps the <strong>groupName</strong> (found in
<strong>vacmSecurityToGroupTable</strong>), <strong>contextName</strong>,
<strong>securityModel</strong>, and <strong>securityLevel</strong> to an MIB view
for each type of operation (read, write, or notify).  The MIB
view is represented as a <strong>viewName</strong>.  The definition of
the MIB view represented by the <strong>viewName</strong> is found in
the <strong>vacmViewTreeFamilyTable</strong></p><h3>vacmViewTreeFamilyTable</h3><p>The <strong>vacmViewTreeFamilyTable</strong> is indexed by the
<strong>viewName</strong>, and defines
which objects are included in the MIB view.
</p><p>The MIB definition for the table looks as follows:</p><pre>
VacmViewTreeFamilyEntry ::= SEQUENCE
    {
        vacmViewTreeFamilyViewName     SnmpAdminString,
        vacmViewTreeFamilySubtree      OBJECT IDENTIFIER,
        vacmViewTreeFamilyMask         OCTET STRING,
        vacmViewTreeFamilyType         INTEGER,
        vacmViewTreeFamilyStorageType  StorageType,
        vacmViewTreeFamilyStatus       RowStatus
    }

INDEX { vacmViewTreeFamilyViewName,
        vacmViewTreeFamilySubtree
      }
        </pre><p>Each <strong>vacmViewTreeFamilyViewName</strong> refers to a
collection of sub-trees.
</p><h3>MIB View Semantics</h3><p>An MIB view is a collection of included and excluded
sub-trees. A sub-tree is identified by an OBJECT IDENTIFIER. A
mask is associated with each sub-tree.
</p><p>For each possible MIB object instance, the instance
belongs to a sub-tree if:
</p><ul><li>the OBJECT IDENTIFIER name of that MIB object instance comprises at least as many sub-identifiers as does the sub-tree, and </li><li>each sub-identifier in the name of that MIB object instance matches the corresponding sub-identifier of the sub-tree whenever the corresponding bit of the associated mask is 1 (0 is a wild card that matches anything).</li></ul><p>Membership of an object instance in an MIB view is
determined by the following algorithm:
</p><ul><li>If an MIB object instance does not belong to any of the relevant sub-trees, then the instance is not in the MIB view. </li><li>If an MIB object instance belongs to exactly one sub-tree, then the instance is included in, or excluded from, the relevant MIB view according to the type of that entry. </li><li>If an MIB object instance belongs to more than one sub-tree, then the sub-tree which comprises the greatest number of sub-identifiers, and is the lexicographically greatest, is used. </li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If the OBJECT IDENTIFIER is longer than an OBJECT
IDENTIFIER of an object type in the MIB, it refers to
object instances. Because of this, it is possible to
control whether or not particular rows in a table shall be
visible.</p></div><h3>SNMP-COMMUNITY-MIB</h3><p>The SNMP-COMMUNITY-MIB defines managed objects that is used 
for coexistence between SNMPv1 and SNMPv2c with SNMPv3.  
Specifically, it contains objects for mapping between community 
strings and version-independent SNMP message parameters.  In 
addition, this MIB provides a mechanism for performing source address
validation on incoming requests, and for selecting community
strings based on target addresses for outgoing notifications.
</p><p>All tables in this MIB have a column of type
<strong>StorageType</strong>.  The value of this column specifies how each
row is stored, and what happens in case of a restart of the
agent.  The implementation supports the values <strong>volatile</strong>
and <strong>nonVolatile</strong>.  When the tables are initially filled
with data from the configuration files, these rows will
automatically have storage type <strong>nonVolatile</strong>.  Should the
agent restart, all <strong>nonVolatile</strong> rows survive the restart,
while the <strong>volatile</strong> rows are lost.
The configuration files are not read at restart, by default.
</p><p>This MIB is not loaded by default.
</p><h3>SNMP-USER-BASED-SM-MIB</h3><p>The SNMP-USER-BASED-SM-MIB defines managed objects that is
used for the User-Based Security Model.
</p><p>All tables in this MIB have a column of type
<strong>StorageType</strong>.  The value of the column specifies how each
row is stored, and what happens in case of a restart of the
agent.  The implementation supports the values <strong>volatile</strong>
and <strong>nonVolatile</strong>.  When the tables are initially filled
with data from the configuration files, these rows will
automatically have storage type <strong>nonVolatile</strong>.  Should the
agent restart, all <strong>nonVolatile</strong> rows survive the restart,
while the <strong>volatile</strong> rows are lost.
The configuration files are not read at restart, by default.
</p><p>This MIB is not loaded by default.
</p><h3>OTP-SNMPEA-MIB</h3><p>The OTP-SNMPEA-MIB was used in earlier versions of the agent, before
standard MIBs existed for access control, MIB views, and trap
target specification.  All objects in this MIB are now obsolete.
</p><h3>Notifications</h3><a name="notifications"></a><p>Notifications are defined in SMIv1 with the TRAP-TYPE macro in
the definition of an MIB (see RFC1215).  The corresponding
macro in SMIv2 is NOTIFICATION-TYPE.  When an application
decides to send a notification, it calls one of the following
functions:
</p><pre><code class="">
snmpa:send_notification(Agent, Notification, Receiver
                       [, NotifyName, ContextName, Varbinds])
snmpa:send_trap(Agent, Notification, Community [, Receiver, Varbinds])
    </code></pre><p>providing the registered name or process identifier of the
agent where the MIB, which defines the notification is loaded and
the symbolic name of the notification.
</p><p>If the <strong>send_notification/3,4</strong> function is used, all
management targets are selected, as defined in RFC2273.  The
<strong>Receiver</strong> parameter defines where the agent should send
information about the delivery of inform requests.
</p><p>If the <strong>send_notification/5</strong> function is used, an
<strong>NotifyName</strong> must be provided.  This parameter is used as an
index in the <strong>snmpNotifyTable</strong>, and the management targets
defined by that single entry is used.
</p><p>The <strong>send_notification/6</strong> function is the most general
version of the function.  A <strong>ContextName</strong> must be specified,
from which the notification will be sent.  If this parameter is
not specified, the default context (<strong>""</strong>) is used.
</p><p>The function <strong>send_trap</strong> is kept for backwards
compatibility and should not be used in new code.  Applications
that use this function will
continue to work.  The <strong>snmpNotifyName</strong> is used as the
community string by the agent when a notification is sent.
</p><h3>Notification Sending</h3><p>The simplest way to send a notification is to call the function 
<strong>snmpa:send_notification(Agent, Notification, no_receiver)</strong>.
In this case, the agent performs a get-operation to retrieve the
object values that are defined in the notification
specification (with the TRAP-TYPE or NOTIFICATION-TYPE macros).
The notification is sent to all managers defined in the target
and notify tables, either unacknowledged as traps, or
acknowledged as inform requests.
</p><p>If the caller of the function wants to know whether or not
acknowledgments are received for a certain notification
(provided it is sent as an inform), the <strong>Receiver</strong>
parameter can be specified as <strong>{Tag, ProcessName}</strong> (refer
to the Reference Manual, section snmp, module <strong>snmp</strong> for
more details).  In this case, the agent send a message
<strong>{snmp_notification, Tag, {got_response, ManagerAddr}}</strong> or
<strong>{snmp_notification, Tag, {no_response, ManagerAddr}}</strong> for
each management target.
</p><p>Sometimes it is not possible to retrieve the values for some
of the objects in the notification specification with a
get-operation.  However, they are known when the
<strong>send_notification</strong> function is called. This is the case if
an object is an element in a table.  It is possible to give the
values of some objects to the <strong>send_notification</strong> function
<strong>snmpa:send_notification(Agent, Notification, Receiver, Varbinds)</strong>.  In this function, <strong>Varbinds</strong> is a list of
<strong>Varbind</strong>, where each <strong>Varbind</strong> is one of:
</p><ul><li><strong>{Variable, Value}</strong>, where <strong>Variable</strong> is the symbolic name of a scalar variable referred to in the notification specification. </li><li><strong>{Column, RowIndex, Value}</strong>, where <strong>Column</strong> is the symbolic name of a column variable.  <strong>RowIndex</strong> is a list of indices for the specified element.  If this is the case, the OBJECT IDENTIFIER sent in the trap is the <strong>RowIndex</strong> appended to the OBJECT IDENTIFIER for the table column. This is the OBJECT IDENTIFIER which specifies the element. </li><li><strong>{OID, Value}</strong>, where <strong>OID</strong> is the OBJECT IDENTIFIER for an instance of an object, scalar variable or column variable. </li></ul><p>For example, to specify that <strong>sysLocation</strong> should have the
value <strong>"upstairs"</strong> in the notification, we could use one of:
</p><ul><li><strong>{sysLocation, "upstairs"}</strong> or</li><li><strong>{[1,3,6,1,2,1,1,6,0], "upstairs"}</strong></li></ul><p>It is also possible to specify names and values for extra
variables that should be sent in the notification, but were not
defined in the notification specification.
</p><p>The notification is sent to all management targets found in
the tables.  However, make sure that each manager has access to
the variables in the notification. If a variable is outside a
manager's MIB view, this manager will not receive the
notification.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>By definition, it is not possible to send objects with
ACCESS <strong>not-accessible</strong> in notifications. However,
historically this is often done and for this reason we allow
it in notification sending. If a variable has ACCESS
<strong>not-accessible</strong>, the user must provide a value for the
variable in the <strong>Varbinds</strong> list. It is not possible for
the agent to perform a get-operation to retrieve this value.
</p></div><h3>Notification Filters</h3><p>It is possible to add <em>notification filters</em> to an agent.
These filters will be called when a notification is to be 
sent. Their purpose is to allow modification, suppression or 
other type of actions.</p><p>A notification filter is a module implementing the 
<a href="snmpa_notification_filter">snmpa_notification_filter</a> behaviour. A filter is added/deleted using the functions:
<a href="./snmpa#register_notification_filter">snmpa:register_notification_filter</a> and 
<a href="./snmpa#unregister_notification_filter">snmpa:unregister_notification_filter</a>.</p><p>Unless otherwise specified, the order of the registered filters
will be the order in which they are registered.</p><h3>Sub-agent Path</h3><p>If a value for an object is not given to the
<strong>send_notification</strong> function, the sub-agent will perform a
get-operation to retrieve it. If the object is not implemented
in this sub-agent, its parent agent tries to perform a
get-operation to retrieve it. If the object is not implemented
in this agent either, it forwards the object to its parent, and
so on. Eventually the Master Agent is reached and at this point
all unknown object values must be resolved. If some object is
unknown even to the Master Agent, this is regarded as an error
and is reported with a call to <strong>user_err/2</strong> of the 
error report module. No notifications are sent in this case.
</p><p>For a given notification, the variables, which are referred to
in the notification specification, must be implemented by the
agent that has the MIB loaded, or by some parent to this
agent. If not, the application must provide values for the
unknown variables. The application must also provide values for
all elements in tables.
</p><h3>Discovery</h3><a name="discovery"></a><p>The <em>sender</em> is <em>authoritative</em> for messages containing
payload which does <em>not</em> expect a response (for example 
SNMPv2-Trap, Response or Report PDU). </p><p>The <em>receiver</em> is <em>authoritative</em> for messages containing
payload which expects a response (for example 
Get, GetNext, Get-Bulk, Set or Inform PDU). </p><p>The agent can both perform and respond to discovery.</p><p>The agent responds to discovery autonomously, without interaction
by the user. </p><p>Initiating discovery towards a manager is done by calling the 
<a href="./snmpa#discovery">discovery</a> function. 
The <strong>EngineId</strong> field of the target (manager) entry in the 
<a href="./snmp_agent_config_files#target_addr">target_addr.conf</a> file has to have the value <strong>discovery</strong>. 
Note that if the manager does not respond, the <strong>Timeout</strong> and 
<strong>RetryCount</strong> 
fields decide how long the function will hang before it returns. </p><p>Discovery can only be performed towards one manager at a time.</p><h3>Features</h3><a name="features"></a><p>The manager provided with the tool is a lightweight manager
that basically provides a means to communicate with agents.</p><p>It does not really implement any management capabilities by 
itself. That is up to the <em>user</em>. 
</p><p>A <em>user</em> in this context is basically a module implementing
the <a href="snmpm_user">snmpm_user</a> behaviour. 
A <em>user</em> can issue snmp requests and receive 
notification/traps.</p><p>Agents to be accessed by the manager needs to be registered by 
a user. Once registered, they can be accessed by all registered 
users.</p><p>Notifications/traps from an agent is delivered to the user that 
did the registration.</p><p>Any message from an agent that is not registered is delivered to 
the <em>default user</em>.</p><p>By default, the <em>default user</em> is set to the 
<strong>snmpm_user_default</strong> module, which simply sends an info message
to the error_logger. It is however highly recommended that this
module be replaced by another that does something useful
(see <a href="./snmp_config#configuration_params">configuration params</a> for more info).</p><p>When using version 3, then (at least one) <em>usm user</em> has to 
be registered.</p><p>Requests can be issued in two different ways. Synchronous (see
<a href="./snmpm#sync_set">sync_set</a>,
<a href="./snmpm#sync_get">sync_get</a>, 
<a href="./snmpm#sync_get_next">sync_get_next</a> and 
<a href="./snmpm#sync_get_bulk">sync_get_bulk</a>)
and asynchronous (see 
<a href="./snmpm#async_set">async_set</a>,
<a href="./snmpm#async_get">async_get</a>, 
<a href="./snmpm#async_get_next">async_get_next</a> and  
<a href="./snmpm#async_get_bulk">async_get_bulk</a>). 
With synchronous 
the snmp reply is returned by the function. With asynchronous,
the reply will instead be delivered through a call to one of the
<strong>handle_pdu</strong> callback function defined by the 
<a href="./snmpm_user#handle_pdu">handle_pdu</a> 
behaviour.</p><h3>Operation</h3><a name="operation"></a><p>The following steps are needed to get the manager running:</p><ul><li> <p>[optional] Implement the default user.</p> </li><li> <p>Implement the user(s).</p> </li><li> <p>Configure the application (manager).</p> </li><li> <p>Start the application (manager).</p> </li><li> <p>Register the user(s).</p> </li><li> <p>The user(s) register their agents.</p> </li></ul><h3>MIB loading</h3><a name="mib_loading"></a><p>It is possible to load mibs into the manager, but this is not 
necessary for normal operation, and not recommended.</p><p>The chapter <em>The MIB Compiler</em> describes the MIB compiler
and contains the following topics:
</p><ul><li>Operation</li><li>Import</li><li>Consistency checking between MIBs</li><li>.hrl file generation</li><li>Emacs integration</li><li>Deviations from the standard </li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>When importing MIBs, ensure that the imported MIBs as well as the 
importing MIB are compiled using the same version of the 
SNMP-compiler.</p></div><h3>Operation</h3><p>The MIB must be written as a text file in SMIv1 or SMIv2 using 
an ASN.1 notation before
it will be compiled. This text file must have the same name as the MIB,
but with the suffix <strong>.mib</strong>. This is necessary for handling
the <strong>IMPORT</strong> statement.
</p><p>The association file, which contains the names of
instrumentation functions for the MIB, should have the suffix
<strong>.funcs</strong>. If the compiler does not find the association file,
it gives a warning message and uses default instrumentation
functions.  (See <a href="./snmp_instr_functions#snmp_3">Default Instrumentation</a> for more details).
</p><p>The MIB compiler is started with a call to
<strong>snmpc:compile(&lt;mibname&gt;).</strong> For example:
</p><pre><code class="">
snmpc:compile("RFC1213-MIB").
    </code></pre><p>The output is a new file which is called <strong>&lt;mibname&gt;.bin</strong>.
</p><p>The MIB compiler understands both SMIv1 and SMIv2 MIBs.  It
uses the MODULE-IDENTITY statement to determinate if the MIB is
written in SMI version 1 or 2.
</p><h3>Importing MIBs</h3><p>The compiler handles the <strong>IMPORT</strong> statement. It is important to
import the compiled file and not the ASN.1 (source) file. A MIB must
be recompiled to make changes visible to other MIBs importing it.
</p><p>The compiled files of the imported MIBs must be present in the
current directory, or a directory in the current path. The path is
supplied with the <strong>{i, Path}</strong> option, for example:
</p><pre><code class="">
snmpc:compile("MY-MIB", 
       [{i, ["friend_mibs/", "../standard_mibs/"]}]).
    </code></pre><p>It is also possible to import MIBs from OTP applications in an
<strong>"include_lib"</strong> like fashion with the <strong>il</strong>
option. Example:
</p><pre><code class="">
snmpc:compile("MY-MIB", 
       [{il, ["snmp/priv/mibs/", "myapp/priv/mibs/"]}]).
    </code></pre><p>finds the latest version of the <strong>snmp</strong> and <strong>myapp</strong>
applications in the OTP system and uses the expanded paths as
include paths.
</p><p>Note that an SMIv2 MIB can import an SMIv1 MIB and vice versa.
</p><p>The following MIBs are built-ins of the Erlang SNMP compiler:
SNMPv2-SMI, RFC-1215, RFC-1212, SNMPv2-TC, SNMPv2-CONF, and
RFC1155-SMI. They cannot therefore be compiled separately.
</p><h3>MIB Consistency Checking</h3><p>When an MIB is compiled, the compiler detects if several
managed objects use the same <strong>OBJECT IDENTIFIER</strong>. If that is
the case, it issues an error message. However, the compiler cannot
detect Oid conflicts between different MIBs. These kinds of
conflicts generate an error at load time. To avoid this, the
following function can be used to do consistency checking between
MIBs:
</p><pre>

erl&gt;<span class="input">snmpc:is_consistent(ListOfMibNames).</span>
    </pre><p><strong>ListOfMibNames</strong> is a list of compiled MIBs, for example
<strong>["RFC1213-MIB", "MY-MIB"]</strong>. The function also performs
consistency checking of trap definitions.</p><h3>.hrl File Generation</h3><p>It is possible to generate an <strong>.hrl</strong> file which contains
definitions of Erlang constants from a compiled MIB file. This
file can then be included in Erlang source code. The file will
contain constants for:
</p><ul><li>object Identifiers for tables, table entries and variables</li><li>column numbers</li><li>enumerated values</li><li>default values for variables and table columns. </li></ul><p>Use the following command to  generate a .hrl file from an MIB:
</p><pre>
erl&gt;<span class="input">snmpc:mib_to_hrl(MibName).</span>
    </pre><h3>Emacs Integration</h3><p>With the Emacs editor, the <strong>next-error</strong> (<strong>C-X `</strong>)
function can be used indicate where a compilation error occurred,
provided the error message is described by a line number.
</p><p>Use <strong>M-x compile</strong> to compile an MIB from inside Emacs, and
enter:
</p><pre>
 <span class="input">erl -s snmpc compile &lt;MibName&gt; -noshell</span>
    </pre><p>An example of <strong>&lt;MibName&gt;</strong> is <strong>RFC1213-MIB</strong>.
</p><h3>Compiling from a Shell or a Makefile</h3><p>The <strong>erlc</strong> commands can be used to compile SNMP MIBs. Example:
</p><pre>
 <span class="input">erlc MY-MIB.mib</span>
    </pre><p>All the standard <strong>erlc</strong> flags are supported, e.g.
</p><pre>
 <span class="input">erlc -I mymibs -o mymibs -W MY-MIB.mib</span>
    </pre><p>The flags specific to the MIB compiler can be specified by
using the <strong>+</strong> syntax:
</p><pre>
 <span class="input">erlc +'{group_check,false}' MY-MIB.mib</span>
    </pre><h3>Deviations from the Standard</h3><p>In some aspects the Erlang MIB compiler does not follow or
implement the SMI fully. Here are the differences:
</p><ul><li> <p>Tables must be written in the following order:
<strong>tableObject</strong>, <strong>entryObject</strong>, <strong>column1</strong>, ...,
<strong>columnN</strong> (in order).</p> </li><li> <p>Integer values, for example in the <strong>SIZE</strong> expression
must be entered in decimal syntax, not in hex or bit syntax.</p> </li><li> <p>Symbolic names must be unique within a MIB and within a
system.</p> </li><li> <p>Hyphens are allowed in SMIv2 (a pragmatic approach).  The
reason for this is that according to SMIv2, hyphens are allowed
for objects converted from SMIv1, but not for others.  This is
impossible to check for the compiler.</p> </li><li> <p>If a word is a keyword in any of SMIv1 or SMIv2, it is a
keyword in the compiler (deviates from SMIv1 only).</p> </li><li> <p>Indexes in a table must be objects, not types (deviates
from SMIv1 only).</p> </li><li> <p>A subset of all semantic checks on types are
implemented. For example, strictly the <strong>TimeTicks</strong> may not
be sub-classed but the compiler allows this (standard MIBs must
pass through the compiler) (deviates from SMIv2 only).</p> </li><li> <p>The <strong>MIB.Object</strong> syntax is not implemented (since all
objects must be unique anyway).</p> </li><li> <p>Two different names cannot define the same OBJECT IDENTIFIER.</p> </li><li> <p>The type checking in the SEQUENCE construct is non-strict 
(i.e. subtypes may be specified).  The reason for this is 
that some standard MIBs use this.</p> </li><li>A definition has normally a status field. When the status field has the value deprecated, then the MIB-compiler will ignore this  definition. With the MIB-compiler option <strong>{deprecated,true}</strong>  the MIB-compiler does not ignore the deprecated definitions.</li><li>An object has a DESCRIPTIONS field. The descriptions-field will  not be included in the compiled mib by default. In order to get  the description, the mib must be compiled with the option  <strong>description</strong>.</li></ul><p>The chapter <em>Running the application</em> describes how the 
application is configured and started.
The topics include:</p><ul><li>configuration directories and parameters</li><li>modifying the configuration files</li><li>starting the application (agent and/or manager)</li><li>debugging the application (agent and/or manager)</li></ul><p>Refer also to the chapter(s) 
<a href="snmp_agent_config_files">Definition of Agent  Configuration Files</a> and  
<a href="snmp_manager_config_files">Definition of Manager  Configuration Files</a> which contains more detailed information 
about the agent and manager configuration files.</p><a name="configuration_params"></a><h3>Configuring the application</h3><p>The following two directories must exist in the system
to run the agent:</p><ul><li> <p>the <em>configuration directory</em> stores all
configuration files used by the agent (refer to the chapter 
<a href="snmp_agent_config_files">Definition of Agent Configuration Files</a> for more information). </p> </li><li>the <em>database directory</em> stores the internal database files.</li></ul><p>The following directory must exist in the system
to run the manager:</p><ul><li> <p>the <em>configuration directory</em> stores all
configuration files used by the manager (refer to the chapter 
<a href="snmp_manager_config_files">Definition of Manager  Configuration Files</a> for more information). </p> </li><li> <p>the <em>database directory</em> stores the internal
database files. </p> </li></ul><p>The agent and manager uses (application) configuration parameters to 
find out where these directories are located. The parameters should be
defined in an Erlang system configuration file. The following
configuration parameters are defined for the SNMP application:</p><pre>
      agent_options() = [agent_option()]
      agent_option() = {restart_type,     restart_type()}     | 
                       {agent_type,       agent_type()}       |  
                       {agent_verbosity,  verbosity()}        |  
                       {versions,         versions()}         |  
                       {discovery,        agent_discovery()}  |  
                       {gb_max_vbs,       gb_max_vbs()}       |  
                       {priority,         priority()}         |  
                       {multi_threaded,   multi_threaded()}   |  
                       {db_dir,           db_dir()}           |  
                       {db_init_error,    db_init_error()}    |  
                       {local_db,         local_db()}         |  
                       {net_if,           agent_net_if()}     |  
                       {mibs,             mibs()}             |  
                       {mib_storage,      mib_storage()}      |  
                       {mib_server,       mib_server()}       |  
                       {audit_trail_log,  audit_trail_log()}  |  
                       {error_report_mod, error_report_mod()} |  
                       {note_store,       note_store()}       |  
                       {symbolic_store,   symbolic_store()}   |  
                       {target_cache,     target_cache()}     |  
                       {config,           agent_config()}
      manager_options() = [manager_option()]
      manager_option() = {restart_type,             restart_type()}    | 
                         {net_if,                   manager_net_if()}  |  
                         {server,                   server()}          | 
                         {note_store,               note_store()}      | 
                         {config,                   manager_config()}  |  
                         {inform_request_behaviour, manager_irb()}     | 
                         {mibs,                     manager_mibs()}    | 
                         {priority,                 priority()}        |  
                         {audit_trail_log,          audit_trail_log()} | 
                         {versions,                 versions()}        | 
                         {def_user_mod,             def_user_module()  | 
                         {def_user_data,            def_user_data()}
    </pre><a name="agent_opts_and_types"></a><p>Agent specific config options and types:</p><dl><dt><a name="agent_type"></a> <strong>agent_type() = master | sub &lt;optional&gt;</strong></dt><dd> <p>If <strong>master</strong>, one master agent is
started. Otherwise, no agents are started. </p> <p>Default is <strong>master</strong>.</p> </dd><dt><a name="agent_disco"></a> <strong>agent_discovery() = [agent_discovery_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_discovery_opt() =  {terminating, agent_terminating_discovery_opts()} |  {originating, agent_originating_discovery_opts()}</strong></p> <p>The <strong>terminating</strong> options effects discovery initiated by 
a manager. </p> <p>The <strong>originating</strong> options effects discovery initiated 
by this agent. </p> <p>For defaults see the options in <strong>agent_discovery_opt()</strong>.</p> </dd><dt><a name="agent_term_disco_opts"></a> <strong>agent_terminating_discovery_opts() = [agent_terminating_discovery_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_terminating_discovery_opt() =  {enable, boolean()} |  {stage2, discovery | plain} |  {trigger_username, string()}</strong></p> <p>These are options effecting discovery <strong>terminating</strong> in this
agent (i.e. initiated by a manager). </p> <p>The default values for the <strong>terminating</strong> 
discovery options are: </p> <ul><li>enable: <strong>true</strong></li><li>stage2: <strong>discovery</strong></li><li>trigger_username: <strong>""</strong></li></ul> </dd><dt><a name="agent_orig_disco_opts"></a> <strong>agent_originating_discovery_opts() = [agent_originating_discovery_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_originating_discovery_opt() =  {enable, boolean()}</strong></p> <p>These are options effecting discovery <strong>originating</strong> in this
agent. </p> <p>The default values for the <strong>originating</strong> 
discovery options are: </p> <ul><li>enable: <strong>true</strong></li></ul> </dd><dt><a name="agent_mt"></a> <strong>multi_threaded() = bool() &lt;optional&gt;</strong></dt><dd> <p>If <strong>true</strong>, the agent is multi-threaded, with one
thread for each get request. </p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="agent_data_dir"></a> <strong>db_dir() = string() &lt;mandatory&gt;</strong></dt><dd> <p>Defines where the SNMP agent internal db files are stored.</p> </dd><dt><a name="agent_gb_max_vbs"></a> <strong>gb_max_vbs() = pos_integer() | infinity &lt;optional&gt;</strong></dt><dd> <p>Defines the maximum number of varbinds allowed 
in a Get-BULK response.</p> <p>Default is <strong>1000</strong>.</p> </dd><dt><a name="agent_local_db"></a> <strong>local_db() = [local_db_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>local_db_opt() = {repair, agent_repair()} | {auto_save, agent_auto_save()} |   {verbosity, verbosity()}</strong></p> <p>Defines options specific for the SNMP agent local database.</p> <p>For defaults see the options in <strong>local_db_opt()</strong>.</p> </dd><dt><a name="agent_ldb_repair"></a> <strong>agent_repair() = false | true | force &lt;optional&gt;</strong></dt><dd> <p>When starting snmpa_local_db it always tries to open an
existing database. If <strong>false</strong>, and some errors occur, a new
database is created instead. If <strong>true</strong>, an existing file
will be repaired. If <strong>force</strong>, the table will be repaired
even if it was properly closed. </p> <p>Default is <strong>true</strong>.</p> </dd><dt><a name="agent_ldb_auto_save"></a> <strong>agent_auto_save() = integer() | infinity &lt;optional&gt;</strong></dt><dd> <p>The auto save interval. The table is flushed to disk
whenever not accessed for this amount of time.</p> <p>Default is <strong>5000</strong>.</p> </dd><dt><a name="agent_net_if"></a> <strong>agent_net_if() = [agent_net_if_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_net_if_option() = {module, agent_net_if_module()} |  {verbosity, verbosity()} |  {options, agent_net_if_options()}</strong></p> <p>Defines options specific for the SNMP agent network interface 
entity. </p> <p>For defaults see the options in <strong>agent_net_if_opt()</strong>.</p> </dd><dt><a name="agent_ni_module"></a> <strong>agent_net_if_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>Module which handles the network interface part for the
SNMP agent. Must implement the 
<a href="snmpa_network_interface">snmpa_network_interface</a> behaviour.</p> <p>Default is <strong>snmpa_net_if</strong>.</p> </dd><dt><a name="agent_ni_opts"></a> <strong>agent_net_if_options() = [agent_net_if_option()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_net_if_option() = {bind_to, bind_to()} |   {sndbuf, sndbuf()} |   {recbuf, recbuf()} |   {no_reuse, no_reuse()} |  {req_limit, req_limit()} | {filter, agent_net_if_filter_options()}</strong></p> <p>These options are actually specific to the used module.
The ones shown here are applicable to the default 
<strong>agent_net_if_module()</strong>.</p> <p>For defaults see the options in <strong>agent_net_if_option()</strong>.</p> </dd><dt><a name="agent_ni_req_limit"></a> <strong>req_limit() = integer() | infinity &lt;optional&gt;</strong></dt><dd> <p>Max number of simultaneous requests handled by the agent.</p> <p>Default is <strong>infinity</strong>.</p> </dd><dt><a name="agent_ni_filter_opts"></a> <strong>agent_net_if_filter_options() = [agent_net_if_filter_option()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_net_if_filter_option() = {module, agent_net_if_filter_module()}</strong></p> <p>These options are actually specific to the used module.
The ones shown here are applicable to the default 
<strong>agent_net_if_filter_module()</strong>.</p> <p>For defaults see the options in <strong>agent_net_if_filter_option()</strong>.</p> </dd><dt><a name="agent_ni_filter_module"></a> <strong>agent_net_if_filter_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>Module which handles the network interface filter part for the
SNMP agent. Must implement the 
<a href="snmpa_network_interface_filter">snmpa_network_interface_filter </a> behaviour.</p> <p>Default is <strong>snmpa_net_if_filter</strong>.</p> </dd><dt><a name="agent_mibs"></a> <strong>agent_mibs() = [string()] &lt;optional&gt;</strong></dt><dd> <p>Specifies a list of MIBs (including path) that defines which MIBs
are initially loaded into the SNMP master agent. </p> <p>Note that the following will always be loaded:</p> <ul><li>version v1: <strong>STANDARD-MIB</strong></li><li>version v2: <strong>SNMPv2</strong></li><li>version v3: <strong>SNMPv2</strong>, <strong>SNMP-FRAMEWORK-MIB</strong>  and <strong>SNMP-MPD-MIB</strong></li></ul> <p>Default is <strong>[]</strong>.</p> </dd><dt><a name="agent_mib_storage"></a> <strong>mib_storage() = [mib_storage_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>mib_storage_opt() = {module, mib_storage_module()} |  {options, mib_storage_options()}</strong></p> <p>This option specifies how basic mib data is stored. 
This option is used by two parts of the snmp agent: 
The mib-server and the symbolic-store. </p> <p>Default is <strong>[{module, snmpa_mib_storage_ets}]</strong>. </p> </dd><dt><a name="agent_mst_module"></a> <strong>mib_storage_module() = snmpa_mib_data_ets | snmpa_mib_data_dets | snmpa_mib_data_mnesia | module()</strong></dt><dd> <p>Defines the mib storage module of the SNMP agent as defined by the 
<a href="snmpa_mib_storage">snmpa_mib_storage</a> 
behaviour. </p> <p>Several entities (<strong>mib-server</strong> via the its data module and 
the <strong>symbolic-store</strong>) of the snmp agent uses this for storage 
of miscelaneous mib related data dataretrieved while loading a mib. </p> <p>There are several implementations provided with the agent: 
<strong>snmpa_mib_storage_ets</strong>, <strong>snmpa_mib_storage_dets</strong> and 
<strong>snmpa_mib_storage_mnesia</strong>. </p> <p>Default module is <strong>snmpa_mib_storage_ets</strong>. </p> </dd><dt><a name="agent_mst_options"></a> <strong>mib_storage_options() = list() &lt;optional&gt;</strong></dt><dd> <p>This is implementattion depended. That is, it depends on the 
module. For each module a specific set of options are valid. 
For the module provided with the app, these options are supported: </p> <ul><li> <p><strong>snmpa_mib_storage_ets</strong>: <strong>{dir, filename()} | {action, keep | clear}, {checksum, boolean()}</strong></p> <ul><li> <p><strong>dir</strong> - If present, points to a directory where a file 
to which all data in the ets table is "synced". </p> <p>Also, when a table is opened this file is read, 
if it exists. </p> <p>By default, this will <em>not</em> be used. </p>  </li><li> <p><strong>action</strong> - Specifies the behaviour when a non-empty 
file is found: Keep its content or clear it out. </p> <p>Default is <strong>keep</strong>. </p>  </li><li> <p><strong>checksum</strong> - Defines if the file is checksummed 
or not. </p> <p>Default is <strong>false</strong>. </p>  </li></ul> </li><li> <p><strong>snmpa_mib_storage_dets</strong>: <strong>{dir, filename()} | {action, keep | clear}, {auto_save, default | pos_integer()} | {repair, force | boolean()}</strong></p> <ul><li> <p><strong>dir</strong> - This <em>mandatory</em> option points to a 
directory where to place the file of a dets table. </p> </li><li> <p><strong>action</strong> - Specifies the behaviour when a non-empty 
file is found: Keep its content or clear it out. </p> <p>Default is <strong>keep</strong>. </p>  </li><li> <p><strong>auto_save</strong> - Defines the dets auto-save frequency. </p> <p>Default is <strong>default</strong>. </p>  </li><li> <p><strong>repair</strong> - Defines the dets repair behaviour. </p> <p>Default is <strong>false</strong>. </p>  </li></ul> </li><li> <p><strong>snmpa_mib_storage_mnesia</strong>: <strong>{action, keep | clear}, {nodes, [node()]}</strong></p> <ul><li> <p><strong>action</strong> - Specifies the behaviour when a non-empty, 
already existing, table: Keep its content or clear it out. </p> <p>Default is <strong>keep</strong>. </p> </li><li> <p><strong>nodes</strong> - A list of node names (or an atom 
describing a list of nodes) defining where to open the table. 
Its up to the user to ensure that mnesia is actually running 
on the specified nodes. </p> <p>The following distinct values are recognised: </p> <ul><li> <p><strong>[]</strong> - Translated into a list of the own node: <strong>[node()]</strong></p> </li><li> <p><strong>all</strong> - <strong>erlang:nodes()</strong></p> </li><li> <p><strong>visible</strong> - <strong>erlang:nodes(visible)</strong></p> </li><li> <p><strong>connected</strong> - <strong>erlang:nodes(connected)</strong></p> </li><li> <p><strong>db_nodes</strong> - <strong>mnesia:system_info(db_nodes)</strong></p> </li></ul> <p>Default is the result of the call: <strong>erlang:nodes()</strong>. </p> </li></ul> </li></ul> </dd><dt><a name="agent_mib_server"></a> <strong>mib_server() = [mib_server_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>mib_server_opt() = {mibentry_override, mibentry_override()} |  {trapentry_override, trapentry_override()} |  {verbosity, verbosity()} | {cache, mibs_cache()} | {data_module, mib_server_data_module()}</strong></p> <p>Defines options specific for the SNMP agent mib server. </p> <p>For defaults see the options in <strong>mib_server_opt()</strong>.</p> </dd><dt><a name="agent_ms_meo"></a> <strong>mibentry_override() = bool() &lt;optional&gt;</strong></dt><dd> <p>If this value is false, then when loading a mib each mib-
entry is checked prior to installation of the mib. 
The purpose of the check is to prevent that the same symbolic 
mibentry name is used for different oid's.</p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="agent_ms_teo"></a> <strong>trapentry_override() = bool() &lt;optional&gt;</strong></dt><dd> <p>If this value is false, then when loading a mib each trap
is checked prior to installation of the mib. 
The purpose of the check is to prevent that the same symbolic 
trap name is used for different trap's.</p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="agent_ms_data_module"></a> <strong>mib_server_data_module() = snmpa_mib_data_tttn | module() &lt;optional&gt;</strong></dt><dd> <p>Defines the backend data module of the SNMP agent mib-server as 
defined by the 
<a href="snmpa_mib_data">snmpa_mib_data</a> 
behaviour. </p> <p>At present only the default module is provided with the agent,  
<strong>snmpa_mib_data_tttn</strong>. </p> <p>Default module is <strong>snmpa_mib_data_tttn</strong>. </p> </dd><dt><a name="agent_ms_cache"></a> <strong>mibs_cache() = bool() | mibs_cache_opts() &lt;optional&gt;</strong></dt><dd> <p>Shall the agent utilize the mib server lookup cache or not.</p> <p>Default is <strong>true</strong> (in which case the <strong>mibs_cache_opts()</strong> 
default values apply).</p> </dd><dt><a name="agent_ms_cache_opts"></a> <strong>mibs_cache_opts() = [mibs_cache_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>mibs_cache_opt() = {autogc, mibs_cache_autogc()} | {gclimit, mibs_cache_gclimit()} | {age, mibs_cache_age()}</strong></p> <p>Defines options specific for the SNMP agent mib server cache. </p> <p>For defaults see the options in <strong>mibs_cache_opt()</strong>.</p> </dd><dt><a name="agent_ms_cache_autogc"></a> <strong>mibs_cache_autogc() = bool() &lt;optional&gt;</strong></dt><dd> <p>Defines if the mib server shall perform cache gc automatically or 
leave it to the user (see 
<a href="./snmpa#gc_mibs_cache">gc_mibs_cache/0,1,2,3</a>). </p> <p>Default is <strong>true</strong>.</p> </dd><dt><a name="agent_ms_cache_age"></a> <strong>mibs_cache_age() = integer() &gt; 0 &lt;optional&gt;</strong></dt><dd> <p>Defines how old the entries in the cache will be allowed 
to become before they are GC'ed (assuming GC is performed). 
Each entry in the cache is "touched" whenever it is accessed. </p> <p>The age is defined in milliseconds. </p> <p>Default is <strong>10 timutes</strong>.</p> </dd><dt><a name="agent_ms_cache_gclimit"></a> <strong>mibs_cache_gclimit() = integer() &gt; 0 | infinity &lt;optional&gt;</strong></dt><dd> <p>When performing a GC, this is the max number of cache entries 
that will be deleted from the cache. </p> <p>The reason for having this limit is that if the cache is 
large, the GC can potentially take a long time, during which 
the agent is locked. </p> <p>Default is <strong>100</strong>.</p> </dd><dt><a name="agent_error_report_mod"></a> <strong>error_report_mod() = atom() &lt;optional&gt;</strong></dt><dd> <p>Defines an error report module, implementing the 
<a href="snmpa_error_report">snmpa_error_report</a> 
behaviour. Two modules are provided with the toolkit: 
<strong>snmpa_error_logger</strong> and <strong>snmpa_error_io</strong>.</p> <p>Default is <strong>snmpa_error_logger</strong>.</p> </dd><dt><a name="agent_symbolic_store"></a> <strong>symbolic_store() = [symbolic_store_opt()]</strong></dt><dd> <p><strong>symbolic_store_opt() = {verbosity, verbosity()}</strong></p> <p>Defines options specific for the SNMP agent symbolic store. </p> <p>For defaults see the options in <strong>symbolic_store_opt()</strong>.</p> </dd><dt><a name="agent_target_cache"></a> <strong>target_cache() = [target_cache_opt()]</strong></dt><dd> <p><strong>target_cache_opt() = {verbosity, verbosity()}</strong></p> <p>Defines options specific for the SNMP agent target cache. </p> <p>For defaults see the options in <strong>target_cache_opt()</strong>.</p> </dd><dt><a name="agent_config"></a> <strong>agent_config() = [agent_config_opt()] &lt;mandatory&gt;</strong></dt><dd> <p><strong>agent_config_opt() = {dir, agent_config_dir()} |  {force_load, force_load()} | {verbosity, verbosity()}</strong></p> <p>Defines specific config related options for the SNMP agent. </p> <p>For defaults see the options in <strong>agent_config_opt()</strong>.</p> </dd><dt><a name="agent_config_dir"></a> <strong>agent_config_dir = dir() &lt;mandatory&gt;</strong></dt><dd> <p>Defines where the SNMP agent configuration files are stored.</p> </dd><dt><a name="agent_force_load"></a> <strong>force_load() = bool() &lt;optional&gt;</strong></dt><dd> <p>If <strong>true</strong> the configuration files are re-read
during start-up, and the contents of the configuration 
database ignored.  Thus, if <strong>true</strong>, changes to 
the configuration database are lost upon reboot of the 
agent. </p> <p>Default is <strong>false</strong>.</p> </dd></dl><a name="manager_opts_and_types"></a><p>Manager specific config options and types:</p><dl><dt><a name="manager_server"></a> <strong>server() = [server_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>server_opt() = {timeout, server_timeout()} |  {verbosity, verbosity()}</strong></p> <p>Specifies the options for the manager server process.</p> <p>Default is <strong>silence</strong>.</p> </dd><dt><a name="manager_server_timeout"></a> <strong>server_timeout() = integer() &lt;optional&gt;</strong></dt><dd> <p>Asynchronous request cleanup time. For every requests,
some info is stored internally, in order to be able to 
deliver the reply (when it arrives) to the proper destination.
If the reply arrives, this info will be deleted. But if
there is no reply (in time), the info has to be deleted
after the <em>best before</em> time has been passed.
This cleanup will be performed at regular intervals, defined 
by the <strong>server_timeout()</strong> time.
The information will have a <em>best before</em> time,
defined by the <strong>Expire</strong> time given when calling the
request function (see 
<a href="./snmpm#async_get">async_get</a>,
<a href="./snmpm#async_get_next">async_get_next</a> and 
<a href="./snmpm#async_set">async_set</a>).</p> <p>Time in milli-seconds.</p> <p>Default is <strong>30000</strong>.</p> </dd><dt><a name="manager_config"></a> <strong>manager_config() = [manager_config_opt()] &lt;mandatory&gt;</strong></dt><dd> <p><strong>manager_config_opt() = {dir, manager_config_dir()} |  {db_dir, manager_db_dir()} |  {db_init_error, db_init_error()} |  {repair, manager_repair()} |  {auto_save, manager_auto_save()} |  {verbosity, verbosity()}</strong></p> <p>Defines specific config related options for the SNMP manager. </p> <p>For defaults see the options in <strong>manager_config_opt()</strong>.</p> </dd><dt><a name="manager_config_dir"></a> <strong>manager_config_dir = dir() &lt;mandatory&gt;</strong></dt><dd> <p>Defines where the SNMP manager configuration files are stored.</p> </dd><dt><a name="manager_config_db_dir"></a> <strong>manager_db_dir = dir() &lt;mandatory&gt;</strong></dt><dd> <p>Defines where the SNMP manager store persistent data.</p> </dd><dt><a name="manager_config_repair"></a> <strong>manager_repair() = false | true | force &lt;optional&gt;</strong></dt><dd> <p>Defines the repair option for the persistent database (if 
and how the table is repaired when opened). </p> <p>Default is <strong>true</strong>.</p> </dd><dt><a name="manager_config_auto_save"></a> <strong>manager_auto_save() = integer() | infinity &lt;optional&gt;</strong></dt><dd> <p>The auto save interval. The table is flushed to disk
whenever not accessed for this amount of time.</p> <p>Default is <strong>5000</strong>.</p> </dd><dt><a name="manager_irb"></a> <strong>manager_irb() = auto | user | {user, integer()} &lt;optional&gt;</strong></dt><dd> <p>This option defines how the manager will handle the sending of 
response (acknowledgment) to received inform-requests. </p> <ul><li> <p><strong>auto</strong> - The manager will autonomously send response
(acknowledgment&gt; to inform-request messages.</p> </li><li> <p><strong>{user, integer()}</strong> - The manager will send response
(acknowledgment) to inform-request messages when the 
<a href="./snmpm_user#handle_inform">handle_inform</a> 
function completes. The integer is the time, in milli-seconds, 
that the manager will consider the stored inform-request info 
valid.</p> </li><li> <p><strong>user</strong> - Same as <strong>{user, integer()}</strong>, except that 
the default time, 15000 milli-seconds, is used.</p> </li></ul> <p>See 
<a href="snmpm_network_interface">snmpm_network_interface</a>, 
<a href="snmpm_user">handle_inform</a> and 
<a href="snmp_manager_netif">definition of the manager net if</a> for more info.</p> <p>Default is <strong>auto</strong>.</p> </dd><dt><a name="manager_mibs"></a> <strong>manager_mibs() = [string()] &lt;optional&gt;</strong></dt><dd> <p>Specifies a list of MIBs (including path) and defines which MIBs
are initially loaded into the SNMP manager. </p> <p>Default is <strong>[]</strong>.</p> </dd><dt><a name="manager_net_if"></a> <strong>manager_net_if() = [manager_net_if_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>manager_net_if_opt() = {module, manager_net_if_module()} |  {verbosity, verbosity()} |  {options, manager_net_if_options()}</strong></p> <p>Defines options specific for the SNMP manager network interface 
entity. </p> <p>For defaults see the options in <strong>manager_net_if_opt()</strong>.</p> </dd><dt><a name="manager_ni_opts"></a> <strong>manager_net_if_options() = [manager_net_if_option()] &lt;optional&gt;</strong></dt><dd> <p><strong>manager_net_if_option() = {bind_to, bind_to()} |  {sndbuf, sndbuf()} |  {recbuf, recbuf()} |  {no_reuse, no_reuse()} | {filter, manager_net_if_filter_options()}</strong></p> <p>These options are actually specific to the used module.
The ones shown here are applicable to the default 
<strong>manager_net_if_module()</strong>. </p> <p>For defaults see the options in <strong>manager_net_if_option()</strong>.</p> </dd><dt><a name="manager_ni_module"></a> <strong>manager_net_if_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>The module which handles the network interface part for the
SNMP manager. It must implement the 
<a href="snmpm_network_interface">snmpm_network_interface</a> behaviour. </p> <p>Default is <strong>snmpm_net_if</strong>. </p> </dd><dt><a name="manager_ni_filter_opts"></a> <strong>manager_net_if_filter_options() = [manager_net_if_filter_option()] &lt;optional&gt;</strong></dt><dd> <p><strong>manager_net_if_filter_option() = {module, manager_net_if_filter_module()}</strong></p> <p>These options are actually specific to the used module.
The ones shown here are applicable to the default 
<strong>manager_net_if_filter_module()</strong>.</p> <p>For defaults see the options in 
<strong>manager_net_if_filter_option()</strong>.</p> </dd><dt><a name="manager_ni_filter_module"></a> <strong>manager_net_if_filter_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>Module which handles the network interface filter part for the
SNMP manager. Must implement the 
<a href="snmpm_network_interface_filter">snmpm_network_interface_filter</a> behaviour.</p> <p>Default is <strong>snmpm_net_if_filter</strong>.</p> </dd><dt><a name="manager_def_user_module"></a> <strong>def_user_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>The module implementing the default user. See the 
<a href="snmpm_user">snmpm_user</a> behaviour.</p> <p>Default is <strong>snmpm_user_default</strong>.</p> </dd><dt><a name="manager_def_user_data"></a> <strong>def_user_data() = term() &lt;optional&gt;</strong></dt><dd> <p>Data for the default user. Passed to the user when calling 
the callback functions.</p> <p>Default is <strong>undefined</strong>.</p> </dd></dl><a name="common_types"></a><p>Common config types:</p><dl><dt><a name="restart_type"></a> <strong>restart_type() = permanent | transient | temporary</strong></dt><dd> <p>See <a href="../stdlib/supervisor#child_spec">supervisor</a> 
documentation for more info.</p> <p>Default is <strong>permanent</strong> for the agent and <strong>transient</strong>
for the manager.</p> </dd><dt><a name="db_init_error"></a> <strong>db_init_error() = terminate | create | create_db_and_dir</strong></dt><dd> <p>Defines what to do if the agent is unable to open an
existing database file. <strong>terminate</strong> means that the
agent/manager will terminate, <strong>create</strong> means that the 
agent/manager will remove the faulty file(s) and create new ones,
and <strong>create_db_and_dir</strong> means that the agent/manager will
create the database file along with any missing parent directories
for the database file.</p> <p>Default is <strong>terminate</strong>.</p> </dd><dt><a name="prio"></a> <strong>priority() = atom() &lt;optional&gt;</strong></dt><dd> <p>Defines the Erlang priority for all SNMP processes.</p> <p>Default is <strong>normal</strong>.</p> </dd><dt><a name="versions"></a> <strong>versions() = [version()] &lt;optional&gt;</strong></dt><dd> <p><strong>version() = v1 | v2 | v3</strong></p> <p>Which SNMP versions shall be accepted/used.</p> <p>Default is <strong>[v1,v2,v3]</strong>.</p> </dd><dt><a name="verbosity"></a> <strong>verbosity() = silence | info | log | debug | trace &lt;optional&gt;</strong></dt><dd> <p>Verbosity for a SNMP process. This specifies now much debug info
is printed.</p> <p>Default is <strong>silence</strong>.</p> </dd><dt><a name="bind_to"></a> <strong>bind_to() = bool() &lt;optional&gt;</strong></dt><dd> <p>If <strong>true</strong>, net_if binds to the IP address.
If <strong>false</strong>, net_if listens on any IP address on the host
where it is running. </p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="no_reuse"></a> <strong>no_reuse() = bool() &lt;optional&gt;</strong></dt><dd> <p>If <strong>true</strong>, net_if does not specify that the IP
and port address should be reusable. If <strong>false</strong>, 
the address is set to reusable. </p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="recbuf"></a> <strong>recbuf() = integer() &lt;optional&gt;</strong></dt><dd> <p>Receive buffer size. </p> <p>Default value is defined by <strong>gen_udp</strong>.</p> </dd><dt><a name="sndbuf"></a> <strong>sndbuf() = integer() &lt;optional&gt;</strong></dt><dd> <p>Send buffer size. </p> <p>Default value is defined by <strong>gen_udp</strong>.</p> </dd><dt><a name="note_store"></a> <strong>note_store() = [note_store_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>note_store_opt() = {timeout, note_store_timeout()} |  {verbosity, verbosity()}</strong></p> <p>Specifies the options for the SNMP note store.</p> <p>For defaults see the options in <strong>note_store_opt()</strong>.</p> </dd><dt><a name="ns_timeout"></a> <strong>note_store_timeout() = integer() &lt;optional&gt;</strong></dt><dd> <p>Note cleanup time. When storing a note in the note store,
each note is given lifetime. Every <strong>timeout</strong> the note_store
process performs a GC to remove the expired note's. Time in
milli-seconds.</p> <p>Default is <strong>30000</strong>.</p> </dd><dt><a name="audit_trail_log"></a> <strong>audit_trail_log() [audit_trail_log_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>audit_trail_log_opt() = {type, atl_type()} | {dir, atl_dir()} |  {size, atl_size()} |  {repair, atl_repair()} | {seqno, atl_seqno()}</strong></p> <p>If present, this option specifies the options for the 
<em>audit trail logging</em>. The <strong>disk_log</strong> module is used 
to maintain a wrap log. If present, the <strong>dir</strong> and 
<strong>size</strong> options are mandatory.</p> <p>If not present, audit trail logging is not used.</p> </dd><dt><a name="atl_type"></a> <strong>atl_type() = read | write | read_write &lt;optional&gt;</strong></dt><dd> <p>Specifies what type of an audit trail log should be used. 
The effect of the type is actually different for the the agent
and the manager. </p> <p>For the agent:</p> <ul><li>If <strong>write</strong> is specified, only set requests are logged.  </li><li>If <strong>read</strong> is specified, only get requests are logged.  </li><li>If <strong>read_write</strong>, all requests are logged.  </li></ul> <p>For the manager:</p> <ul><li>If <strong>write</strong> is specified, only sent messages are logged.  </li><li>If <strong>read</strong> is specified, only received messages are logged.  </li><li>If <strong>read_write</strong>, both outgoing and incoming messages are  logged.  </li></ul> <p>Default is <strong>read_write</strong>.</p> </dd><dt><a name="atl_dir"></a> <strong>atl_dir = dir() &lt;mandatory&gt;</strong></dt><dd> <p>Specifies where the audit trail log should be stored.</p> <p>If <strong>audit_trail_log</strong> specifies that logging should take
place, this parameter <em>must</em> be defined.</p> </dd><dt><a name="atl_size"></a> <strong>atl_size() = {integer(), integer()} &lt;mandatory&gt;</strong></dt><dd> <p>Specifies the size of the audit
trail log.  This parameter is sent to <strong>disk_log</strong>.  </p> <p>If <strong>audit_trail_log</strong> specifies that logging should 
take place, this parameter <em>must</em> be defined.</p> </dd><dt><a name="atl_repair"></a> <strong>atl_repair() = true | false | truncate | snmp_repair &lt;optional&gt;</strong></dt><dd> <p>Specifies if and how the audit trail log shall be repaired
when opened. Unless this parameter has the value <strong>snmp_repair</strong>
it is sent to <strong>disk_log</strong>. If, on the other hand, the value is
<strong>snmp_repair</strong>, snmp attempts to handle certain faults on its
own. And even if it cannot repair the file, it does not truncate it 
directly, but instead <em>moves it aside</em> for later off-line 
analysis.</p> <p>Default is <strong>true</strong>.</p> </dd><dt><a name="atl_seqno"></a> <strong>atl_seqno() = true | false &lt;optional&gt;</strong></dt><dd> <p>Specifies if the audit trail log entries will be (sequence)
numbered or not. The range of the sequence numbers are according
to RFC 5424, i.e. 1 through 2147483647. </p> <p>Default is <strong>false</strong>.</p> </dd></dl><h3>Modifying the Configuration Files</h3><p>To to start the application (agent and/or manager), the 
configuration files must be modified and there are two ways 
of doing this. Either edit the files manually, or run the 
configuration tool as follows.</p><p>If authentication or encryption is used (SNMPv3 only), start
the <strong>crypto</strong> application.</p><pre>
1&gt; snmp:config().

Simple SNMP configuration tool (version 4.0)
------------------------------------------------
Note: Non-trivial configurations still has to be
      done manually. IP addresses may be entered 
      as dront.ericsson.se (UNIX only) or
      123.12.13.23
------------------------------------------------

Configure an agent (y/n)? [y] 

Agent system config: 
--------------------
1. Agent process priority (low/normal/high) [normal] 
2. What SNMP version(s) should be used (1,2,3,1&amp;2,1&amp;2&amp;3,2&amp;3)? [3] 1&amp;2&amp;3
3. Configuration directory (absolute path)? [/ldisk/snmp] /ldisk/snmp/agent/conf
4. Config verbosity (silence/info/log/debug/trace)? [silence] 
5. Database directory (absolute path)? [/ldisk/snmp] /ldisk/snmp/agent/db
6. Mib storage type (ets/dets/mnesia)? [ets] 
7. Target cache verbosity (silence/info/log/debug/trace)? [silence] 
8. Symbolic store verbosity (silence/info/log/debug/trace)? [silence] 
9. Local DB verbosity (silence/info/log/debug/trace)? [silence] 
10. Local DB repair (true/false/force)? [true] 
11. Local DB auto save (infinity/milli seconds)? [5000] 
12. Error report module? [snmpa_error_logger] 
13. Agent type (master/sub)? [master] 
14. Master-agent verbosity (silence/info/log/debug/trace)? [silence] log
15. Shall the agent re-read the configuration files during startup 
    (and ignore the configuration database) (true/false)? [true] 
16. Multi threaded agent (true/false)? [false] true
17. Check for duplicate mib entries when installing a mib (true/false)? [false] 
18. Check for duplicate trap names when installing a mib (true/false)? [false] 
19. Mib server verbosity (silence/info/log/debug/trace)? [silence] 
20. Mib server cache (true/false)? [true]
21. Note store verbosity (silence/info/log/debug/trace)? [silence] 
22. Note store GC timeout? [30000] 
23. Shall the agent use an audit trail log (y/n)? [n] y
23b. Audit trail log type (write/read_write)? [read_write] 
23c. Where to store the audit trail log? [/ldisk/snmp] /ldisk/snmp/agent/log
23d. Max number of files? [10] 
23e. Max size (in bytes) of each file? [10240] 
23f. Audit trail log repair (true/false/truncate)? [true] 
24. Which network interface module shall be used? [snmpa_net_if] 
25. Network interface verbosity (silence/info/log/debug/trace)? [silence] log
25a. Bind the agent IP address (true/false)? [false] 
25b. Shall the agents IP address and port be not reusable (true/false)? [false] 
25c. Agent request limit (used for flow control) (infinity/pos integer)? [infinity] 32
25d. Receive buffer size of the agent (in bytes) (default/pos integer)? [default] 
25e. Send buffer size of the agent (in bytes) (default/pos integer)? [default]
25f. Do you wish to specify a network interface filter module (or use default) [default] 

Agent snmp config: 
------------------
1. System name (sysName standard variable) [bmk's agent] 
2. Engine ID (snmpEngineID standard variable) [bmk's engine] 
3. Max message size? [484] 
4. The UDP port the agent listens to. (standard 161) [4000] 
5. IP address for the agent (only used as id 
   when sending traps) [127.0.0.1] 
6. IP address for the manager (only this manager 
   will have access to the agent, traps are sent 
   to this one) [127.0.0.1] 
7. To what UDP port at the manager should traps 
   be sent (standard 162)? [5000] 
8. Do you want a none- minimum- or semi-secure configuration? 
   Note that if you chose v1 or v2, you won't get any security for these
   requests (none, minimum, semi_des, semi_aes) [minimum] 
making sure crypto server is started...
8b. Give a password of at least length 8. It is used to generate 
    private keys for the configuration:  kalle-anka
9. Current configuration files will now be overwritten. Ok (y/n)? [y] 

- - - - - - - - - - - - -
Info: 1. SecurityName "initial" has noAuthNoPriv read access
         and authenticated write access to the "restricted"
         subtree.
      2. SecurityName "all-rights" has noAuthNoPriv read/write
         access to the "internet" subtree.
      3. Standard traps are sent to the manager.
      4. Community "public" is mapped to security name "initial".
      5. Community "all-rights" is mapped to security name "all-rights".
The following agent files were written: agent.conf, community.conf,
standard.conf, target_addr.conf, target_params.conf, 
notify.conf, vacm.conf and usm.conf
- - - - - - - - - - - - -

Configure a manager (y/n)? [y] 

Manager system config: 
----------------------
1. Manager process priority (low/normal/high) [normal] 
2. What SNMP version(s) should be used (1,2,3,1&amp;2,1&amp;2&amp;3,2&amp;3)? [3] 1&amp;2&amp;3
3. Configuration directory (absolute path)? [/ldisk/snmp] /ldisk/snmp/manager/conf
4. Config verbosity (silence/info/log/debug/trace)? [silence] log
5. Database directory (absolute path)? [/ldisk/snmp] /ldisk/snmp/manager/db
6. Database repair (true/false/force)? [true] 
7. Database auto save (infinity/milli seconds)? [5000] 
8. Inform request behaviour (auto/user)? [auto] 
9. Server verbosity (silence/info/log/debug/trace)? [silence] log
10. Server GC timeout? [30000] 
11. Note store verbosity (silence/info/log/debug/trace)? [silence] 
12. Note store GC timeout? [30000] 
13. Which network interface module shall be used? [snmpm_net_if] 
14. Network interface verbosity (silence/info/log/debug/trace)? [silence] log
15. Bind the manager IP address (true/false)? [false] 
16. Shall the manager IP address and port be not reusable (true/false)? [false] 
17. Receive buffer size of the manager (in bytes) (default/pos integer)? [default] 
18. Send buffer size of the manager (in bytes) (default/pos integer)? [default] 
19. Shall the manager use an audit trail log (y/n)? [n] y
19b. Where to store the audit trail log? [/ldisk/snmp] /ldisk/snmp/manager/log
19c. Max number of files? [10] 
19d. Max size (in bytes) of each file? [10240] 
19e. Audit trail log repair (true/false/truncate)? [true] 
20. Do you wish to assign a default user [yes] or use
    the default settings [no] (y/n)? [n] 

Manager snmp config: 
--------------------
1. Engine ID (snmpEngineID standard variable) [bmk's engine] 
2. Max message size? [484] 
3. IP address for the manager (only used as id 
   when sending requests) [127.0.0.1] 
4. Port number (standard 162)? [5000] 
5. Configure a user of this manager (y/n)? [y] 
5b. User id? kalle
5c. User callback module? snmpm_user_default
5d. User (callback) data? [undefined] 
5. Configure a user of this manager (y/n)? [y] n
6. Configure an agent handled by this manager (y/n)? [y] 
6b. User id? kalle
6c. Target name? [bmk's agent] 
6d. Version (1/2/3)? [1] 3
6e. Community string ? [public] 
6f. Engine ID (snmpEngineID standard variable) [bmk's engine] 
6g. IP address for the agent [127.0.0.1] 
6h. The UDP port the agent listens to. (standard 161) [4000] 
6i. Retransmission timeout (infinity/pos integer)? [infinity] 
6j. Max message size? [484] 
6k. Security model (any/v1/v2c/usm)? [any] usm
6l. Security name? ["initial"] 
6m. Security level (noAuthNoPriv/authNoPriv/authPriv)? [noAuthNoPriv] authPriv
6. Configure an agent handled by this manager (y/n)? [y] n
7. Configure an usm user handled by this manager (y/n)? [y] 
7a. Engine ID [bmk's engine] 
7b. User name? hobbes
7c. Security name? [hobbes] 
7d. Authentication protocol (no/sha/md5)? [no] sha
7e  Authentication [sha] key (length 0 or 20)? [""] [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16, \
    17,18,19,20]
7d. Priv protocol (no/des/aes)? [no] des
7f  Priv [des] key (length 0 or 16)? [""] 10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25
7. Configure an usm user handled by this manager (y/n)? [y] n
8. Current configuration files will now be overwritten. Ok (y/n)? [y] 

- - - - - - - - - - - - -
The following manager files were written: manager.conf, agents.conf , users.conf and usm.conf
- - - - - - - - - - - - -

--------------------
Configuration directory for system file (absolute path)? [/ldisk/snmp] 
ok
    </pre><h3>Starting the application</h3><p>Start Erlang with the command:</p><pre><code class="">
erl -config /tmp/snmp/sys
    </code></pre><p>If authentication or encryption is used (SNMPv3 only), start
the <strong>crypto</strong> application.  If this step is forgotten, the
agent will not start, but report a
<strong>{config_error,{unsupported_crypto,_}}</strong> error.</p><pre>
1&gt; <span class="input">application:start(crypto).</span>
ok
    </pre><pre>
2&gt; <span class="input">application:start(snmp).</span>
ok
    </pre><a name="verbosity"></a><h3>Debugging the application</h3><p>It is possible to debug every (non-supervisor) process of the 
application (both agent and manager), possibly with the exception 
of the net_if module(s), which could be supplied by a user of the 
application). This is done by calling the 
<strong>snmpa:verbosity/2</strong> and <strong>snmpm:verbosity/2</strong> function(s) 
and/or using 
<a href="#configuration_params">configuration parameters</a>.
The verbosity itself has several <em>levels</em>: <strong>silence | info |  log | debug | trace</strong>. For the lowest verbosity <strong>silence</strong>, 
nothing is printed. The higher the verbosity, the more is printed.
Default value is always <strong>silence</strong>.</p><pre>
3&gt; <span class="input">snmpa:verbosity(master_agent, log).</span>
ok
5&gt; <span class="input">snmpa:verbosity(net_if, log).</span>
ok
6&gt; 
%% Example of output from the agent when a get-next-request arrives:
** SNMP NET-IF LOG: 
   got packet from {147,12,12,12}:5000

** SNMP NET-IF MPD LOG: 
   v1, community: all-rights

** SNMP NET-IF LOG: 
   got pdu from {147,12,12,12}:5000 {pdu, 'get-next-request',
                                          62612569,noError,0,
                                          [{varbind,[1,1],'NULL','NULL',1}]}

** SNMP MASTER-AGENT LOG: 
   apply: snmp_generic,variable_func,[get,{sysDescr,persistent}]

** SNMP MASTER-AGENT LOG: 
   returned: {value,"Erlang SNMP agent"}

** SNMP NET-IF LOG: 
   reply pdu: {pdu,'get-response',62612569,noError,0,
                   [{varbind,[1,3,6,1,2,1,1,1,0],
                             'OCTET STRING',
                             "Erlang SNMP agent",1}]}

** SNMP NET-IF INFO: time in agent: 19711 mysec
    </pre><p>Other useful function(s) for debugging the agent are: </p><dl><dt><strong>snmpa:info/0,1</strong></dt><dd> <p><a href="./snmpa#info">info</a> is used to retrieve a list of miscellaneous agent information.</p> </dd><dt><strong>snmpa:which_aliasnames/0</strong></dt><dd> <p><a href="./snmpa#which_aliasnames">which_aliasnames</a> is used to retrieve a list of all alias-names known to the agent. </p> </dd><dt><strong>snmpa:which_tables/0</strong></dt><dd> <p><a href="./snmpa#which_tables">which_tables</a> is used to retrieve a list of all (MIB) tables known to the agent. </p> </dd><dt><strong>snmpa:which_variables/0</strong></dt><dd> <p><a href="./snmpa#which_variables">which_variables</a> is used to retrieve a list of all (MIB) variables known to the agent. </p> </dd><dt><strong>snmpa:which_notifications/0</strong></dt><dd> <p><a href="./snmpa#which_notifications">which_notifications</a> is used to retrieve a list of all (MIB) notifications/traps known to the agent. </p> </dd><dt><strong>snmpa:restart_worker/0,1</strong></dt><dd> <p><a href="./snmpa#restart_worker">restart_worker</a> is used to restart the worker process of a multi-threaded agent. </p> </dd><dt><strong>snmpa:restart_set_worker/0,1</strong></dt><dd> <p><a href="./snmpa#restart_set_worker">restart_set_worker</a> is used to restart the set-worker process of a multi-threaded agent. </p> </dd><dt><strong>snmpa_local_db:print/0,1,2</strong></dt><dd> <p>For example, this function can show the counters 
<strong>snmpInPkts</strong> and <strong>snmpOutPkts</strong>.</p> </dd></dl><p>Another usefull way to debug the agent is to pretty-print the content of 
all the tables and/or variables handled directly by the agent. 
This can be done by simply calling: </p><p><strong>snmpa:print_mib_info()</strong></p><p>See 
<a href="./snmpa#print_mib_info">print_mib_info/0</a>, 
<a href="./snmpa#print_mib_tables">print_mib_tables/0</a>
or
<a href="./snmpa#print_mib_variables">print_mib_variables/0</a> 
for more info. </p><p>All configuration data must be included in configuration files
that are located in the configuration directory. The name of this
directory is given in the <strong>config_dir</strong> configuration
parameter.  These files are read at start-up, and are used to
initialize the SNMPv2-MIB or STANDARD-MIB, SNMP-FRAMEWORK-MIB,
SNMP-MPD-MIB, SNMP-VIEW-BASED-ACM-MIB, SNMP-COMMUNITY-MIB,
SNMP-USER-BASED-SM-MIB, SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB
(refer to the 
<a href="./snmp_agent_funct_descr#management">Management of the Agent</a> 
for a description of the MIBs). </p><p>The files are: </p><ul><li> <p><strong>agent.conf</strong>: see 
<a href="#agent_information">Agent Information</a></p> </li><li> <p><strong>standard.conf</strong>: see 
<a href="#system_information">System Information</a></p> </li><li> <p><strong>context.conf</strong>: see 
<a href="#context">Contexts</a></p> </li><li> <p><strong>community.conf</strong>: see 
<a href="#community">Communities</a></p> </li><li> <p><strong>target_addr.conf</strong>: see 
<a href="#target_addr">Target Address Definitions</a></p> </li><li> <p><strong>target_params.conf</strong>: see 
<a href="#target_params">Target Parameters Definitions</a></p> </li><li> <p><strong>vacm.conf</strong>: see 
<a href="#vacm">MIB Views for VACM</a></p> </li><li> <p><strong>usm.conf</strong>: see 
<a href="#usm">Security data for USM</a></p> </li><li> <p><strong>notify.conf</strong>: see 
<a href="#notify">Notify Definitions</a></p> </li></ul><p>The directory where the configuration files are found is given as
a parameter to the agent. </p><p>The entry format in all files are Erlang terms, separated by a
'<em>.</em>' and a <em>newline</em>. In the following sections, the
formats of these terms are described. Comments may be specified as
ordinary Erlang comments. </p><p>Syntax errors in these files are discovered and reported with the
function <strong>config_err/2</strong> of the error report module at start-up. </p><a name="agent_information"></a><h3>Agent Information</h3><p>The agent information should be stored in a file called
<strong>agent.conf</strong>. </p><p>Each entry is a tuple of size two:</p><p><strong>{AgentVariable, Value}.</strong></p><ul><li> <p><strong>AgentVariable</strong> is one of the variables is
SNMP-FRAMEWORK-MIB or one of the internal variables
<strong>intAgentUDPPort</strong>, which defines which UDP port the agent
listens to, or <strong>intAgentTransports</strong>, which defines the
transport domains and addresses of the agent. </p> </li><li> <p><strong>Value</strong> is the value for the variable.</p> </li></ul><p>The following example shows an <strong>agent.conf</strong> file: </p><pre>
{intAgentUDPPort, 4000}.
{intAgentTransports,
 [{transportDomainUdpIpv4, {141,213,11,24}},
  {transportDomainUdpIpv6, {0,0,0,0,0,0,0,1}}]}.
{snmpEngineID, "mbj's engine"}.
{snmpEngineMaxPacketSize, 484}.
    </pre><p>The value of <strong>intAgentTransports</strong> is a list of
<strong>{Domain, Addr}</strong> tuples, where <strong>Domain</strong>
is either <strong>transportDomainUdpIpv4</strong> or <strong>transportDomainUdpIpv6</strong>,
and <strong>Addr</strong> is the address in the domain.
<strong>Addr</strong> can be specified either as an
<strong>IpAddr</strong> or as an <strong>{IpAddr, IpPort}</strong> tuple.
<strong>IpAddr</strong> is either a regular Erlang/OTP
<a href="../kernel/inet#type-ip_address">kernel/inet#type-ip_address</a>
or a traditional SNMP integer list and <strong>IpPort</strong> is an integer.
</p><p>When the <strong>Addr</strong> value does not contain a port number,
the value of <strong>intAgentUDPPort</strong> is used.</p><p>The legacy and intermediate variables <strong>intAgentIpAddress</strong>
and <strong>intAgentTransportDomain</strong> are still supported so old
<strong>agent.conf</strong> files will work.
</p><p>The value of <strong>snmpEngineID</strong> is a string, which for a 
deployed agent should have a very specific structure. See
RFC 2271/2571 for details.</p><a name="context"></a><h3>Contexts</h3><p>The context information should be stored in a file called
<strong>context.conf</strong>.  The default context <strong>""</strong>
need not be present.</p><p>Each row defines a context in the agent.  This information is
used in the table <strong>vacmContextTable</strong> in the
SNMP-VIEW-BASED-ACM-MIB.</p><p>Each entry is a term:</p><p><strong>ContextName.</strong></p><ul><li> <p><strong>ContextName</strong> is a string.</p> </li></ul><a name="system_information"></a><h3>System Information</h3><p>The system information should be stored in a file called
<strong>standard.conf</strong>.</p><p>Each entry is a tuple of size two:</p><p><strong>{SystemVariable, Value}.</strong></p><ul><li> <p><strong>SystemVariable</strong> is one of the variables in the
system group, or <strong>snmpEnableAuthenTraps</strong>. </p> </li><li> <p><strong>Value</strong> is the value for the variable. </p> </li></ul><p>The following example shows a valid <strong>standard.conf</strong> file: </p><pre>
{sysDescr, "Erlang SNMP agent"}.
{sysObjectID, [1,2,3]}.
{sysContact, "(mbj,eklas)@erlang.ericsson.se"}.
{sysName, "test"}.
{sysServices, 72}.
{snmpEnableAuthenTraps, enabled}.
    </pre><p>A value must be provided for all variables, which lack default
values in the MIB. </p><a name="community"></a><h3>Communities</h3><p>The community information should be stored in a file called
<strong>community.conf</strong>. It must be present if the agent is
configured for SNMPv1 or SNMPv2c. </p><p>An SNMP <em>community</em> is a relationship between an SNMP
agent and a set of SNMP managers that defines authentication, access 
control and proxy characteristics. </p><p>The corresponding table is <strong>snmpCommunityTable</strong> in the
SNMP-COMMUNITY-MIB. </p><p>Each entry is a term: </p><p><strong>{CommunityIndex, CommunityName, SecurityName, ContextName, TransportTag}.</strong> </p><ul><li> <p><strong>CommunityIndex</strong> is a non-empty string.</p> </li><li> <p><strong>CommunityName</strong> is a string.</p> </li><li> <p><strong>SecurityName</strong> is a string.</p> </li><li> <p><strong>ContextName</strong> is a string.</p> </li><li> <p><strong>TransportTag</strong> is a string.</p> </li></ul><a name="vacm"></a><h3>MIB Views for VACM</h3><p>The information about MIB Views for VACM should be stored in a 
file called <strong>vacm.conf</strong>.</p><p>The corresponding tables are <strong>vacmSecurityToGroupTable</strong>,
<strong>vacmAccessTable</strong> and <strong>vacmViewTreeFamilyTable</strong> in the
SNMP-VIEW-BASED-ACM-MIB.</p><p>Each entry is one of the terms, one entry corresponds to one
row in one of the tables.</p><p><strong>{vacmSecurityToGroup, SecModel, SecName, GroupName}.</strong></p><p><strong>{vacmAccess, GroupName, Prefix, SecModel, SecLevel, Match, ReadView, WriteView, NotifyView}.</strong></p><p><strong>{vacmViewTreeFamily, ViewIndex, ViewSubtree, ViewStatus, ViewMask}.</strong></p><ul><li> <p><strong>SecModel</strong> is <strong>any</strong>, <strong>v1</strong>, <strong>v2c</strong>, or
<strong>usm</strong>.</p> </li><li> <p><strong>SecName</strong> is a string.</p> </li><li> <p><strong>GroupName</strong> is a string.</p> </li><li> <p><strong>Prefix</strong> is a string.</p> </li><li> <p><strong>SecLevel</strong> is <strong>noAuthNoPriv</strong>, <strong>authNoPriv</strong>,
or <strong>authPriv</strong></p> </li><li> <p><strong>Match</strong> is <strong>prefix</strong> or <strong>exact</strong>.</p> </li><li> <p><strong>ReadView</strong> is a string.</p> </li><li> <p><strong>WriteView</strong> is a string.</p> </li><li> <p><strong>NotifyView</strong> is a string.</p> </li><li> <p><strong>ViewIndex</strong> is an integer.</p> </li><li> <p><strong>ViewSubtree</strong> is a list of integer.</p> </li><li> <p><strong>ViewStatus</strong> is either <strong>included</strong> or <strong>excluded</strong></p> </li><li> <p><strong>ViewMask</strong> is either <strong>null</strong> or a list of ones and
zeros. Ones nominate that an exact match is used for this
sub-identifier. Zeros are wild-cards which match any
sub-identifier. If the mask is shorter than the sub-tree, the
tail is regarded as all ones. <strong>null</strong> is shorthand for a
mask with all ones. </p> </li></ul><a name="usm"></a><h3>Security data for USM</h3><p>The information about Security data for USM should be stored in a 
file called <strong>usm.conf</strong>, which must be present if the agent is 
configured for SNMPv3. </p><p>The corresponding table is <strong>usmUserTable</strong> in the
SNMP-USER-BASED-SM-MIB.</p><p>Each entry is a term:</p><p><strong>{EngineID, UserName, SecName, Clone, AuthP, AuthKeyC, OwnAuthKeyC, PrivP, PrivKeyC, OwnPrivKeyC, Public, AuthKey, PrivKey}.</strong></p><ul><li> <p><strong>EngineID</strong> is a string.</p> </li><li> <p><strong>UserName</strong> is a string.</p> </li><li> <p><strong>SecName</strong> is a string.</p> </li><li> <p><strong>Clone</strong> is <strong>zeroDotZero</strong> or a list of integers.</p> </li><li> <p><strong>AuthP</strong> is a <strong>usmNoAuthProtocol</strong>,
<strong>usmHMACMD5AuthProtocol</strong>, or <strong>usmHMACSHAAuthProtocol</strong>.</p> </li><li> <p><strong>AuthKeyC</strong> is a string.</p> </li><li> <p><strong>OwnAuthKeyC</strong> is a string.</p> </li><li> <p><strong>PrivP</strong> is a <strong>usmNoPrivProtocol</strong>, 
<strong>usmDESPrivProtocol</strong> or <strong>usmAesCfb128Protocol</strong>.</p> </li><li> <p><strong>PrivKeyC</strong> is a string.</p> </li><li> <p><strong>OwnPrivKeyC</strong> is a string.</p> </li><li> <p><strong>Public</strong> is a string.</p> </li><li> <p><strong>AuthKey</strong> is a list (of integer). This is the User's secret
localized authentication key. It is not visible in the MIB. The length
of this key needs to be 16 if <strong>usmHMACMD5AuthProtocol</strong> is used, 
and 20 if <strong>usmHMACSHAAuthProtocol</strong> is used.</p> </li><li> <p><strong>PrivKey</strong> is a list (of integer).  This is the User's secret
localized encryption key.  It is not visible in the MIB.  The length
of this key needs to be 16 if <strong>usmDESPrivProtocol</strong> or 
<strong>usmAesCfb128Protocol</strong> is used. </p> </li></ul><a name="notify"></a><h3>Notify Definitions</h3><p>The information about Notify Definitions should be stored in a
file called <strong>notify.conf</strong>. </p><p>The corresponding table is <strong>snmpNotifyTable</strong> in the
SNMP-NOTIFICATION-MIB.</p><p>Each entry is a term:</p><p><strong>{NotifyName, Tag, Type}.</strong></p><ul><li> <p><strong>NotifyName</strong> is a unique non-empty string.</p> </li><li> <p><strong>Tag</strong> is a string.</p> </li><li> <p><strong>Type</strong> is <strong>trap</strong> or <strong>inform</strong>.</p> </li></ul><a name="target_addr"></a><h3>Target Address Definitions</h3><p>The information about Target Address Definitions should be 
stored in a file called <strong>target_addr.conf</strong>. </p><p>The corresponding tables are <strong>snmpTargetAddrTable</strong> in the
SNMP-TARGET-MIB and <strong>snmpTargetAddrExtTable</strong> in the 
SNMP-COMMUNITY-MIB. </p><p>Each entry is a term: </p><p><strong>{TargetName, Domain, Addr, Timeout, RetryCount, TagList, ParamsName, EngineId}.</strong>
<br/> or <br/>
<strong>{TargetName, Domain, Addr, Timeout, RetryCount, TagList, ParamsName, EngineId, TMask, MaxMessageSize}.</strong> </p><ul><li> <p><strong>TargetName</strong> is a unique non-empty string. </p> </li><li> <p><strong>Domain</strong> is one of the atoms: 
<strong>transportDomainUdpIpv4</strong> | <strong>transportDomainUdpIpv6</strong>. </p> </li><li> <p><strong>Addr</strong> is either an <strong>IpAddr</strong> or
an <strong>{IpAddr, IpPort}</strong> tuple. <strong>IpAddr</strong> is either
a regular Erlang/OTP
<a href="../kernel/inet#type-ip_address">kernel/inet#type-ip_address</a>
or a traditional SNMP integer list, and <strong>IpPort</strong> is an integer.</p> <p>If <strong>IpPort</strong> is omitted <strong>162</strong> is used.</p> </li><li> <p><strong>Timeout</strong> is an integer. </p> </li><li> <p><strong>RetryCount</strong> is an integer. </p> </li><li> <p><strong>TagList</strong> is a string. </p> </li><li> <p><strong>ParamsName</strong> is a string. </p> </li><li> <p><strong>EngineId</strong> is a string or the atom <strong>discovery</strong>. </p> </li><li> <p><strong>TMask</strong> is specified just as <strong>Addr</strong> or as <strong>[]</strong>.
Note in particular that using a list of 6 bytes	for IPv4
or 8 words plus 2 bytes for IPv6 are still valid address formats
so old configurations will work.</p> </li><li> <p><strong>MaxMessageSize</strong> is an integer (default: 2048). </p> </li></ul><p>The old tuple formats with <strong>Ip</strong> address and <strong>Udp</strong>
port number found in old configurations still work.</p><p>Note that if <strong>EngineId</strong> has the value <strong>discovery</strong>, 
the agent cannot send
<strong>inform</strong> messages to that manager until it has performed the
<em>discovery</em> process with that manager. </p><a name="target_params"></a><h3>Target Parameters Definitions</h3><p>The information about Target Parameters Definitions should be
stored in a file called <strong>target_params.conf</strong>. </p><p>The corresponding table is <strong>snmpTargetParamsTable</strong> in the
SNMP-TARGET-MIB. </p><p>Each entry is a term: </p><p><strong>{ParamsName, MPModel, SecurityModel, SecurityName, SecurityLevel}.</strong></p><ul><li> <p><strong>ParamsName</strong> is a unique non-empty string. </p> </li><li> <p><strong>MPModel</strong> is <strong>v1</strong>, <strong>v2c</strong> or <strong>v3</strong></p> </li><li> <p><strong>SecurityModel</strong> is <strong>v1</strong>, <strong>v2c</strong>, or <strong>usm</strong>.</p> </li><li> <p><strong>SecurityName</strong> is a string.</p> </li><li> <p><strong>SecurityLevel</strong> is <strong>noAuthNoPriv</strong>, <strong>authNoPriv</strong>
or <strong>authPriv</strong>. </p> </li></ul><p>Configuration data may be included in configuration files
that is located in the configuration directory. The name of this
directory is given in the <strong>config_dir</strong> configuration
parameter. These files are read at start-up.
</p><p>The directory where the configuration files are found is given as
a parameter to the manager.
</p><p>The entry format in all files are Erlang terms, separated by a
'<em>.</em>' and a <em>newline</em>. In the following sections, the
formats of these terms are described. Comments may be specified as
ordinary Erlang comments.
</p><p>If syntax errors are discovered in these files they are reported with the
function <strong>config_err/2</strong> of the 
<a href="snmpa_error_report">error report module</a>  
at start-up.
</p><a name="manager"></a><a name="manager_information"></a><h3>Manager Information</h3><p>The manager information should be stored in a file called
<strong>manager.conf</strong>.
</p><p>Each entry is a tuple of size two:
</p><p><strong>{Variable, Value}.</strong></p><ul><li> <p><strong>Variable</strong> is one of the following:</p> <ul><li> <p><strong>transports</strong> - which defines the transport domains
and their addresses for the manager. <em>Mandatory</em>
</p> <p><strong>Value</strong> is a list of <strong>{Domain, Addr}</strong> tuples
or <strong>Domain</strong> atoms.
</p> <ul><li> <p><strong>Domain</strong> is one of <strong>transportDomainUdpIpv4</strong>
or <strong>transportDomainUdpIpv6</strong>.</p> </li><li> <p><strong>Addr</strong> is for the currently supported domains
either an <strong>IpAddr</strong> or an <strong>{IpAddr, IpPort}</strong>
tuple.<strong>IpAddr</strong> is either a regular Erlang/OTP
<a href="../kernel/inet#type-ip_address">kernel/inet#type-ip_address</a> or a traditional SNMP integer list
and <strong>IpPort</strong> is an integer.
</p> <p>When <strong>Addr</strong> does not contain a port number,
the value of <strong>port</strong> is used.
</p> <p>When a <strong>Addr</strong> is not specified i.e by
using only a <strong>Domain</strong> atom, the host's name
is resolved to find the IP address, and the value of
<strong>port</strong> is used.
</p> </li></ul> </li><li> <p><strong>port</strong> - which defines which UDP port the manager uses
for communicating with agents.
<em>Mandatory</em> if <strong>transports</strong> does not define
a port number for every transport.</p> </li><li> <p><strong>engine_id</strong> - The <strong>SnmpEngineID</strong> as defined in 
SNMP-FRAMEWORK-MIB. <em>Mandatory</em>.</p> </li><li> <p><strong>max_message_size</strong> - The <strong>snmpEngineMaxMessageSize</strong> as
defined in SNMP-FRAMEWORK-MIB. <em>Mandatory</em>.</p> </li></ul> </li><li> <p><strong>Value</strong> is the value for the variable.
</p> </li></ul><p>The legacy and intermediate variables <strong>address</strong> and <strong>domain</strong>
are still supported so old configurations will work.</p><p>The following example shows a <strong>manager.conf</strong> file: 
</p><pre>
{transports,       [{transportDomainUdpIpv4, {{141,213,11,24}, 5000}},
                    {transportDomainUdpIpv6, {{0,0,0,0,0,0,0,1}, 5000}}]}.
{engine_id,        "mgrEngine"}.
{max_message_size, 484}.
    </pre><p>The value of <strong>engine_id</strong> is a string, which should have a 
very specific structure. See RFC 2271/2571 for details.
</p><a name="users"></a><h3>Users</h3><p>For each <em>manager user</em>, the manager needs some information.
This information is either added in the <strong>users.conf</strong> config 
file or by calling the 
<a href="./snmpm#register_user">register_user</a> 
function in run-time.
</p><p>Each row defines a <em>manager user</em> of the manager. 
</p><p>Each entry is a tuple of size four:
</p><p><strong>{UserId, UserMod, UserData, DefaultAgentConfig}.</strong></p><ul><li> <p><strong>UserId</strong> is any term (used to uniquely identify the user).</p> </li><li> <p><strong>UserMod</strong> is the user callback module (atom).</p> </li><li> <p><strong>UserData</strong> is any term (passed on to the user when calling the
<strong>UserMod</strong>.
</p> </li><li> <p><strong>DefaultAgentConfig</strong> is a list of default agent config's. 
These values are used as default values when this user registers 
agents.
</p> </li></ul><a name="agents"></a><h3>Agents</h3><p>The information needed to handle agents should be stored in a 
file called <strong>agents.conf</strong>. It is also possible to add agents
in run-time by calling the 
<a href="./snmpm#register_agent">register_agent</a>.
</p><p>Each entry is a tuple:
</p><p><strong>{UserId,  TargetName, Comm, Domain, Addr, EngineID, Timeout,  MaxMessageSize, Version, SecModel, SecName, SecLevel}.</strong></p><ul><li> <p><strong>UserId</strong> is the identity of the <em>manager user</em>
responsible for this agent (term).
</p> </li><li> <p><strong>TargetName</strong> is a <em>unique</em> <em>non-empty</em> string.</p> </li><li> <p><strong>Comm</strong> is the community string (string).</p> </li><li> <p><strong>Domain</strong> is the transport domain, either
<strong>transportDomainUdpIpv4</strong> or <strong>transportDomainUdpIpv6</strong>.</p> </li><li> <p><strong>Addr</strong> is the address in the transport domain,
either an <strong>{IpAddr, IpPort}</strong> tuple or a traditional SNMP
integer list containing port number. <strong>IpAddr</strong> is either
a regular Erlang/OTP
<a href="../kernel/inet#type-ip_address">kernel/inet#type-ip_address</a>
or a traditional SNMP integer list not containing port number,
and <strong>IpPort</strong> is an integer.</p> </li><li> <p><strong>EngineID</strong> is the engine-id of the agent (string).</p> </li><li> <p><strong>Timeout</strong> is re-transmission timeout 
(<strong>infinity</strong> | integer).</p> </li><li> <p><strong>MaxMessageSize</strong> is the max message size for outgoing messages 
to this agent (integer).</p> </li><li> <p><strong>Version</strong> is the version (v1 | v2 | v3).</p> </li><li> <p><strong>SecModel</strong> is the security model (any | v1 | v2c | usm).</p> </li><li> <p><strong>SecName</strong> is the security name (string).</p> </li><li> <p><strong>SecLevel</strong> is security level (noAuthNoPriv | authNoPriv | 
authPriv).</p> </li></ul><p>Legacy configurations using tuples without <strong>Domain</strong> element,
as well as with all <strong>TDomain</strong>, <strong>Ip</strong> and <strong>Port</strong> elements
still work.</p><a name="usm"></a><a name="usm_user"></a><h3>Security data for USM</h3><p>The information about Security data for USM should be stored in a 
file called <strong>usm.conf</strong>, which must be present if the manager
wishes to use SNMPv3 when communicating with agents. It is also 
possible to add usm data in run-time by calling the 
<a href="./snmpm#register_usm_user">register_usm_user</a>.
</p><p>The corresponding table is <strong>usmUserTable</strong> in the
SNMP-USER-BASED-SM-MIB.
</p><p>Each entry is a term:
</p><p><strong>{EngineID, UserName, AuthP, AuthKey, PrivP, PrivKey}.</strong>      <br/>
<strong>{EngineID, UserName, SecName, AuthP, AuthKey, PrivP, PrivKey}.</strong></p><p>The first case is when we have the identity-function 
(<strong>SecName</strong> = <strong>UserName</strong>).
</p><ul><li> <p><strong>EngineID</strong> is a string.</p> </li><li> <p><strong>UserName</strong> is a string.</p> </li><li> <p><strong>SecName</strong> is a string.</p> </li><li> <p><strong>AuthP</strong> is a <strong>usmNoAuthProtocol</strong>,
<strong>usmHMACMD5AuthProtocol</strong> or <strong>usmHMACSHAAuthProtocol</strong>.</p> </li><li> <p><strong>AuthKey</strong> is a list (of integer). This is the User's 
secret localized authentication key. It is not visible in the MIB. 
The length of this key needs to be 16 if 
<strong>usmHMACMD5AuthProtocol</strong> is used and 20 if 
<strong>usmHMACSHAAuthProtocol</strong> is used.</p> </li><li> <p><strong>PrivP</strong> is a <strong>usmNoPrivProtocol</strong>, 
<strong>usmDESPrivProtocol</strong> or <strong>usmAesCfb128Protocol</strong>.</p> </li><li> <p><strong>PrivKey</strong> is a list (of integer). This is the User's secret
localized encryption key.  It is not visible in the MIB. The length
of this key needs to be 16 if <strong>usmDESPrivProtocol</strong> 
or <strong>usmAesCfb128Protocol</strong> is used.</p> </li></ul><p>This <em>Implementation Example</em> section describes how an
MIB can be implemented with the SNMP Development Toolkit. </p><p>The example shown can be found in the toolkit distribution. </p><p>The agent is configured with the configuration tool, using
default suggestions for everything but the manager node. </p><h3>MIB</h3><p>The MIB used in this example is called EX1-MIB. It contains two
objects, a variable with a name and a table with friends.
</p><pre><code class="">
EX1-MIB DEFINITIONS ::= BEGIN
 
          IMPORTS
                  experimental   FROM RFC1155-SMI
                  RowStatus      FROM STANDARD-MIB
                  DisplayString  FROM RFC1213-MIB
                  OBJECT-TYPE    FROM RFC-1212
                  ;
 
          example1       OBJECT IDENTIFIER ::= { experimental 7 }
 
          myName OBJECT-TYPE
              SYNTAX  DisplayString (SIZE (0..255))
              ACCESS  read-write
              STATUS  mandatory
              DESCRIPTION
                      "My own name"
              ::= { example1 1 }
 
          friendsTable OBJECT-TYPE
              SYNTAX  SEQUENCE OF FriendsEntry
              ACCESS  not-accessible
              STATUS  mandatory
              DESCRIPTION
                      "A list of friends."
              ::= { example1 4 }
 
          friendsEntry OBJECT-TYPE
              SYNTAX  FriendsEntry
              ACCESS  not-accessible
              STATUS  mandatory
              DESCRIPTION
                      ""
              INDEX   { fIndex }
              ::= { friendsTable 1 }
 
          FriendsEntry ::=
              SEQUENCE {
                   fIndex
                      INTEGER,
                   fName
                      DisplayString,
                   fAddress
                      DisplayString,
                   fStatus
                      RowStatus              }
 
          fIndex OBJECT-TYPE
              SYNTAX  INTEGER
              ACCESS  not-accessible
              STATUS  mandatory
               DESCRIPTION
                      "number of friend"
              ::= { friendsEntry 1 }
 
          fName OBJECT-TYPE
              SYNTAX  DisplayString (SIZE (0..255))
              ACCESS  read-write
              STATUS  mandatory
              DESCRIPTION
                      "Name of friend"
              ::= { friendsEntry 2 }

          fAddress OBJECT-TYPE
              SYNTAX  DisplayString (SIZE (0..255))
              ACCESS  read-write
              STATUS  mandatory
              DESCRIPTION
                      "Address of friend"
              ::= { friendsEntry 3 }

           fStatus OBJECT-TYPE
              SYNTAX      RowStatus
              ACCESS      read-write
              STATUS      mandatory
              DESCRIPTION
                      "The status of this conceptual row."
              ::= { friendsEntry 4 }

          fTrap TRAP-TYPE
              ENTERPRISE  example1
              VARIABLES   { myName, fIndex }
              DESCRIPTION
                      "This trap is sent when something happens to
                      the friend specified by fIndex."
              ::= 1
END
    </code></pre><h3>Default Implementation</h3><p>Without writing any instrumentation functions, we can compile
the MIB and use the default implementation of it. Recall that MIBs
imported by "EX1-MIB.mib" must be present and compiled in the
current directory ("./STANDARD-MIB.bin","./RFC1213-MIB.bin") when
compiling.
</p><pre>
unix&gt; <span class="input">erl -config ./sys</span>
1&gt; <span class="input">application:start(snmp).</span>
ok
2&gt; <span class="input">snmpc:compile("EX1-MIB").</span>
No accessfunction for 'friendsTable', using default.
No accessfunction for 'myName', using default.
{ok, "EX1-MIB.bin"}
3&gt; <span class="input">snmpa:load_mibs(snmp_master_agent, ["EX1-MIB"]).</span>
ok
    </pre><p>This MIB is now loaded into the agent, and a manager can ask
questions. As an example of this, we start another Erlang system
and the simple Erlang manager in the toolkit:
</p><pre>
1&gt; <span class="input">snmp_test_mgr:start_link([{agent,"dront.ericsson.se"},{community,"all-rights"},</span>
 %% making it understand symbolic names: {mibs,["EX1-MIB","STANDARD-MIB"]}]).
{ok, &lt;0.89.0&gt;}
%% a get-next request with one OID.
2&gt; <span class="input">snmp_test_mgr:gn([[1,3,6,1,3,7]]).</span>
ok 
* Got PDU:
[myName,0] = [] 
%% A set-request (now using symbolic names for convenience)
3&gt; <span class="input">snmp_test_mgr:s([{[myName,0], "Martin"}]).</span>
ok                           
* Got PDU:
[myName,0] = "Martin"    
%% Try the same get-next request again
4&gt; <span class="input">snmp_test_mgr:gn([[1,3,6,1,3,7]]).</span>
ok                           
* Got PDU:
[myName,0] = "Martin"    
%% ... and we got the new value.
%% you can event do row operations. How to add a row:
5&gt; <span class="input">snmp_test_mgr:s([{[fName,0], "Martin"}, {[fAddress,0],"home"}, {[fStatus,0],4}]).</span>
 %% createAndGo
ok
* Got PDU:
[fName,0] = "Martin"    
[fAddress,0] = "home"    
[fStatus,0] = 4    
6&gt; <span class="input">snmp_test_mgr:gn([[myName,0]]).</span>
ok
* Got PDU:
[fName,0] = "Martin"    
7&gt; <span class="input">snmp_test_mgr:gn().</span>
ok
* Got PDU:
[fAddress,0] = "home"    
8&gt; <span class="input">snmp_test_mgr:gn().</span>
ok
* Got PDU:
[fStatus,0] = 1    
9&gt; 
    </pre><h3>Manual Implementation</h3><p>The following example shows a "manual" implementation of the
EX1-MIB in Erlang.  In this example, the values of the objects are
stored in an Erlang server.  The server has a 2-tuple as loop
data, where the first element is the value of variable
<strong>myName</strong>, and the second is a sorted list of rows in the
table <strong>friendsTable</strong>.  Each row is a 4-tuple.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>There are more efficient ways to create tables manually, i.e.
to use the module <strong>snmp_index</strong>.</p></div><h3>Code</h3><pre><code class="">
-module(ex1).
-author('dummy@flop.org').
%% External exports
-export([start/0, my_name/1, my_name/2, friends_table/3]).
%% Internal exports
-export([init/0]).
-define(status_col, 4).
-define(active, 1).
-define(notInService, 2).
-define(notReady, 3).
-define(createAndGo, 4).   % Action; written, not read
-define(createAndWait, 5). % Action; written, not read
-define(destroy, 6).       % Action; written, not read
start() -&gt;
    spawn(ex1, init, []).
%%----------------------------------------------------------------
%% Instrumentation function for variable myName.
%% Returns: (get) {value, Name}
%%          (set) noError
%%----------------------------------------------------------------
my_name(get) -&gt;
    ex1_server ! {self(), get_my_name},
    Name = wait_answer(),
    {value, Name}.
my_name(set, NewName) -&gt;
    ex1_server ! {self(), {set_my_name, NewName}},
    noError.
%%----------------------------------------------------------------
%% Instrumentation function for table friendsTable.
%%----------------------------------------------------------------
friends_table(get, RowIndex, Cols) -&gt;
    case get_row(RowIndex) of
   {ok, Row} -&gt;
        get_cols(Cols, Row);
   _  -&gt;
        {noValue, noSuchInstance}
    end;
friends_table(get_next, RowIndex, Cols) -&gt;
    case get_next_row(RowIndex) of
   {ok, Row} -&gt;
        get_next_cols(Cols, Row);
   _  -&gt;
       case get_next_row([]) of
     {ok, Row} -&gt;
         % Get next cols from first row.
         NewCols = add_one_to_cols(Cols),
         get_next_cols(NewCols, Row);
     _  -&gt;
        end_of_table(Cols)
        end
    end;
%%----------------------------------------------------------------
%% If RowStatus is set, then:
%%    *) If set to destroy, check that row does exist
%%    *) If set to createAndGo, check that row does not exist AND
%%         that all columns are given values.
%%    *) Otherwise, error (for simplicity).
%% Otherwise, row is modified; check that row exists.
%%----------------------------------------------------------------
friends_table(is_set_ok, RowIndex, Cols) -&gt;
    RowExists = 
   case get_row(RowIndex) of
        {ok, _Row} -&gt; true;
       _ -&gt; false
   end, 
    case is_row_status_col_changed(Cols) of
   {true, ?destroy} when RowExists == true -&gt;
        {noError, 0};
   {true, ?createAndGo} when RowExists == false,
                                 length(Cols) == 3 -&gt;
        {noError, 0};
   {true, _} -&gt;
       {inconsistentValue, ?status_col};
   false when RowExists == true -&gt;
        {noError, 0};
   _ -&gt;
        [{Col, _NewVal} | _Cols] = Cols,
       {inconsistentName, Col}
      end;
friends_table(set, RowIndex, Cols) -&gt;
    case is_row_status_col_changed(Cols) of
   {true, ?destroy} -&gt;
        ex1_server ! {self(), {delete_row, RowIndex}};
   {true, ?createAndGo} -&gt;
       NewRow = make_row(RowIndex, Cols),
        ex1_server ! {self(), {add_row, NewRow}};
   false -&gt;
       {ok, Row} = get_row(RowIndex),
        NewRow = merge_rows(Row, Cols),
    ex1_server ! {self(), {delete_row, RowIndex}},
       ex1_server ! {self(), {add_row, NewRow}}
   end,
    {noError, 0}.
    
%%----------------------------------------------------------------
%% Make a list of {value, Val} of the Row and Cols list.
%%----------------------------------------------------------------
get_cols([Col | Cols], Row) -&gt;
    [{value, element(Col, Row)} | get_cols(Cols, Row)];
get_cols([], _Row) -&gt;
    [].
%%----------------------------------------------------------------
%% As get_cols, but the Cols list may contain invalid column
%% numbers. If it does, we must find the next valid column,
%% or return endOfTable.
%%----------------------------------------------------------------
get_next_cols([Col | Cols], Row) when Col &lt; 2 -&gt;
    [{[2, element(1, Row)], element(2, Row)} | 
     get_next_cols(Cols, Row)];
get_next_cols([Col | Cols], Row) when Col &gt; 4 -&gt;
    [endOfTable | 
     get_next_cols(Cols, Row)];
get_next_cols([Col | Cols], Row) -&gt;
    [{[Col, element(1, Row)], element(Col, Row)} | 
     get_next_cols(Cols, Row)];
get_next_cols([], _Row) -&gt;
    [].
%%----------------------------------------------------------------
%% Make a list of endOfTable with as many elems as Cols list.
%%----------------------------------------------------------------
end_of_table([Col | Cols]) -&gt;
    [endOfTable | end_of_table(Cols)];
end_of_table([]) -&gt;
    [].
add_one_to_cols([Col | Cols]) -&gt;
    [Col + 1 | add_one_to_cols(Cols)];
add_one_to_cols([]) -&gt;
    [].
is_row_status_col_changed(Cols) -&gt;
    case lists:keysearch(?status_col, 1, Cols) of
   {value, {?status_col, StatusVal}} -&gt;
        {true, StatusVal};
   _ -&gt; false
    end.
get_row(RowIndex) -&gt;
    ex1_server ! {self(), {get_row, RowIndex}},
    wait_answer().
get_next_row(RowIndex) -&gt;
    ex1_server ! {self(), {get_next_row, RowIndex}},
    wait_answer().
wait_answer() -&gt;
    receive
   {ex1_server, Answer} -&gt;
     Answer
    end.
%%%---------------------------------------------------------------
%%% Server code follows
%%%---------------------------------------------------------------
init() -&gt;
    register(ex1_server, self()),
    loop("", []).
    
loop(MyName, Table) -&gt;
    receive
   {From, get_my_name} -&gt;
        From ! {ex1_server, MyName},
       loop(MyName, Table);
   {From, {set_my_name, NewName}} -&gt;
        loop(NewName, Table);
   {From, {get_row, RowIndex}} -&gt;
       Res = table_get_row(Table, RowIndex),
       From ! {ex1_server, Res},
       loop(MyName, Table);
   {From, {get_next_row, RowIndex}} -&gt;
       Res = table_get_next_row(Table, RowIndex),
        From ! {ex1_server, Res},
       loop(MyName, Table);
   {From, {delete_row, RowIndex}} -&gt;
    NewTable = table_delete_row(Table, RowIndex),
       loop(MyName, NewTable);
   {From, {add_row, NewRow}} -&gt;
       NewTable = table_add_row(Table, NewRow),
       loop(MyName, NewTable)
    end.
%%%---------------------------------------------------------------
%%% Functions for table operations. The table is represented as
%%% a list of rows.
%%%---------------------------------------------------------------
table_get_row([{Index, Name, Address, Status} | _], [Index]) -&gt;
    {ok, {Index, Name, Address, Status}};
table_get_row([H | T], RowIndex) -&gt;
    table_get_row(T, RowIndex);
table_get_row([], _RowIndex) -&gt;
    no_such_row.
table_get_next_row([Row | T], []) -&gt;
    {ok, Row};
table_get_next_row([Row | T], [Index | _]) 
when element(1, Row) &gt; Index -&gt;
    {ok, Row};
table_get_next_row([Row | T], RowIndex) -&gt;
    table_get_next_row(T, RowIndex);
table_get_next_row([], RowIndex) -&gt;
    endOfTable.
table_delete_row([{Index, _, _, _} | T], [Index]) -&gt;
    T;
table_delete_row([H | T], RowIndex) -&gt;
    [H | table_delete_row(T, RowIndex)];
table_delete_row([], _RowIndex) -&gt;
    [].
table_add_row([Row | T], NewRow) 
  when element(1, Row) &gt; element(1, NewRow) -&gt;
    [NewRow, Row | T];
table_add_row([H | T], NewRow) -&gt;
    [H | table_add_row(T, NewRow)];
table_add_row([], NewRow) -&gt;
    [NewRow].
make_row([Index], [{2, Name}, {3, Address} | _]) -&gt;
    {Index, Name, Address, ?active}.
merge_rows(Row, [{Col, NewVal} | T]) -&gt;
    merge_rows(setelement(Col, Row, NewVal), T);
merge_rows(Row, []) -&gt;
    Row.
      </code></pre><h3>Association File</h3><p>The association file <strong>EX1-MIB.funcs</strong> for the real
implementation looks as follows:
</p><pre><code class="">
{myName, {ex1, my_name, []}}.
{friendsTable, {ex1, friends_table, []}}.
      </code></pre><h3>Transcript</h3><p>To use the real implementation, we must recompile the MIB and
load it into the agent.
</p><pre>
1&gt; <span class="input">application:start(snmp).</span>
ok
2&gt; <span class="input">snmpc:compile("EX1-MIB").</span>
{ok,"EX1-MIB.bin"}
3&gt; <span class="input">snmpa:load_mibs(snmp_master_agent, ["EX1-MIB"]).</span>
ok
4&gt; <span class="input">ex1:start().</span>
&lt;0.115.0&gt;
%% Now all requests operates on this "real" implementation.
%% The output from the manager requests will *look* exactly the
%% same as for the default implementation.
      </pre><h3>Trap Sending</h3><p>How to send a trap by sending the
<strong>fTrap</strong> from the master agent is shown in this section. 
The master agent has the MIB <strong>EX1-MIB</strong> loaded, where the 
trap is defined. This trap specifies that two variables should 
be sent along with the trap, <strong>myName</strong> and <strong>fIndex</strong>. 
<strong>fIndex</strong> is a table column, so we must provide its value 
and the index for the row in the call to <strong>snmpa:send_trap/4</strong>. 
In the example below, we assume that the row in question is 
indexed by 2 (the row with <strong>fIndex</strong> 2).
</p><p>we use a simple Erlang SNMP manager, which can receive traps.
</p><pre>
[MANAGER]
1&gt; <span class="input">snmp_test_mgr:start_link([{agent,"dront.ericsson.se"},{community,"public"}</span>
 %% does not have write-access
1&gt;<span class="input">{mibs,["EX1-MIB","STANDARD-MIB"]}]).</span>
{ok, &lt;0.100.0&gt;}
2&gt; <span class="input">snmp_test_mgr:s([{[myName,0], "Klas"}]).</span>
ok                           
* Got PDU:
Received a trap:
      Generic: 4       %% authenticationFailure
   Enterprise: [iso,2,3]
     Specific: 0
   Agent addr: [123,12,12,21]
    TimeStamp: 42993
2&gt; 
[AGENT]
3&gt; <span class="input">snmpa:send_trap(snmp_master_agent, fTrap,"standard trap", [{fIndex,[2],2}]).</span>
[MANAGER]
2&gt;
* Got PDU:
Received a trap:             
      Generic: 6
   Enterprise: [example1]
     Specific: 1
   Agent addr: [123,12,12,21]
    TimeStamp: 69649
[myName,0] = "Martin"    
[fIndex,2] = 2    
2&gt;
      </pre><p>This <em>Implementation Example</em> section describes 
how a simple manager can be implemented with the 
SNMP Development Toolkit. </p><p>The example shown, <em>ex2</em>, can be found in the toolkit 
distribution. </p><p>This example has two functions: </p><ul><li> <p>A simple example of how to use the manager component of 
the SNMP Development Toolkit.</p> </li><li> <p>A simple example of how to write agent test cases, using the new
manager.</p> </li></ul><h3>The example manager</h3><p>The example manager, <strong>snmp_ex2_manager</strong>, is a simple example of 
how to implement an snmp manager using the manager component of the
SNMP Development Toolkit.</p><p>The module exports the following functions:</p><ul><li> <p>start_link/0, start_link/1</p> </li><li> <p>stop/0</p> </li><li> <p>agent/2, agent/3</p> </li><li> <p>sync_get/2, sync_get/3</p> </li><li> <p>sync_get_next/2, sync_get_next/3</p> </li><li> <p>sync_get_bulk/4, sync_get_bulk/5</p> </li><li> <p>sync_set/2, sync_set/3</p> </li><li> <p>oid_to_name/1</p> </li></ul><p>This module is also used by the test module described in the 
next section.</p><h3>A simple standard test</h3><p>This simple standard test, <strong>snmp_ex2_simple_standard_test</strong>,
a module which, using the <strong>snmp_ex2_manager</strong> described in the
previous section, implements a simple agent test utility. </p><p>A user-defined instrumentation function for each object attaches
the managed objects to real resources. This function is called by
the agent on a <strong>get</strong> or <strong>set</strong> operation. The function
could read some hardware register, perform a calculation, or
whatever is necessary to implement the semantics associated with the
conceptual variable. These functions must be written both for scalar
variables and for tables. They are specified in the association
file, which is a text file. In this file, the <strong>OBJECT IDENTIFIER</strong>, or symbolic name for each managed object, is
associated with an Erlang tuple <strong>{Module,</strong><strong>Function</strong>,
<strong>ListOfExtraArguments}</strong>.
</p><p>When a managed object is referenced in an SNMP operation, the
associated <strong>{Module, Function, ListOfExtraArguments}</strong> is
called. The function is applied to some standard arguments (for
example, the operation type) and the extra arguments supplied by the
user.
</p><p>Instrumentation functions must be written for <strong>get</strong> and
<strong>set</strong> for scalar variables and tables, and for <strong>get-next</strong>
for tables only.  The <strong>get-bulk</strong> operation is translated into a
series of calls to <strong>get-next</strong>.
</p><h3>Instrumentation Functions</h3><p>The following sections describe how the instrumentation
functions should be defined in Erlang for the different
operations. In the following, <strong>RowIndex</strong> is a list of key
values for the table, and <strong>Column</strong> is a column number.
</p><p>These functions are described in detail in 
<a href="snmp_def_instr_functions">Definition of Instrumentation Functions</a>.
</p><h3>New / Delete Operations</h3><p>For scalar variables:
</p><pre><code class="">
variable_access(new [, ExtraArg1, ...])
variable_access(delete [, ExtraArg1, ...])
      </code></pre><p>For tables:
</p><pre><code class="">
table_access(new [, ExtraArg1, ...])
table_access(delete [, ExtraArg1, ...])
      </code></pre><p>These functions are called for each object in an MIB when the
MIB is unloaded or loaded, respectively.</p><h3>Get Operation</h3><p>For scalar variables:
</p><pre><code class="">
variable_access(get [, ExtraArg1, ...])
      </code></pre><p>For tables:
</p><pre><code class="">
table_access(get,RowIndex,Cols [,ExtraArg1, ...])
      </code></pre><p><strong>Cols</strong> is a list of <strong>Column</strong>. The agent will sort
incoming variables so that all operations on one row (same
index) will be supplied at the same time. The reason for this is
that a database normally retrieves information row by row.
</p><p>These functions must return the current values of the
associated variables.</p><h3>Set Operation</h3><p>For scalar variables:
</p><pre><code class="">
variable_access(set, NewValue [, ExtraArg1, ...])
      </code></pre><p>For tables:
</p><pre><code class="">
table_access(set, RowIndex, Cols [, ExtraArg1,..])
      </code></pre><p><strong>Cols</strong> is a list of tuples <strong>{Column, NewValue}</strong>.
</p><p>These functions returns <strong>noError</strong> if the assignment was
successful, otherwise an error code.</p><h3>Is-set-ok Operation</h3><p>As a complement to the <strong>set</strong> operation, it is possible
to specify a test function. This function has the same syntax as
the set operation above, except that the first argument is
<strong>is_set_ok</strong> instead of <strong>set</strong>. This function is called
before the variable is set. Its purpose is to ensure that it is
permissible to set the variable to the new value.</p><pre><code class="">
variable_access(is_set_ok, NewValue [, ExtraArg1, ...])
      </code></pre><p>For tables:
</p><pre><code class="">
table_access(set, RowIndex, Cols [, ExtraArg1,..])
      </code></pre><p><strong>Cols</strong> is a list of tuples <strong>{Column, NewValue}</strong>.
</p><h3>Undo Operation</h3><p>A function which has been called with <strong>is_set_ok</strong> will
be called again, either with <strong>set</strong> if there was no error,
or with <strong>undo</strong>, if an error occurred. In this way,
resources can be reserved in the <strong>is_set_ok</strong> operation,
released in the <strong>undo</strong> operation, or made permanent in the
<strong>set</strong> operation.</p><pre><code class="">
variable_access(undo, NewValue [, ExtraArg1, ...])
      </code></pre><p>For tables:
</p><pre><code class="">
table_access(set, RowIndex, Cols [, ExtraArg1,..])
      </code></pre><p><strong>Cols</strong> is a list of tuples <strong>{Column, NewValue}</strong>.
</p><h3>GetNext Operation</h3><p>The GetNext Operation operation should only be defined for 
tables since the
agent can find the next instance of plain variables in the MIB
and call the instrumentation with the <strong>get</strong> operation.
</p><pre><code class="">
table_access(get_next, RowIndex, Cols [, ExtraArg1, ...])
      </code></pre><p><strong>Cols</strong> is a list of integers, all greater than or equal
to zero. This indicates that the instrumentation should find the
next accessible instance. This function returns the tuple
<strong>{NextOid, NextValue}</strong>, or
<strong>endOfTable</strong>. <strong>NextOid</strong> should be the
lexicographically next accessible instance of a managed object
in the table. It should be a list of integers, where the first
integer is the column, and the rest of the list is the indices
for the next row. If <strong>endOfTable</strong> is returned, the agent
continues to search for the next instance among the other
variables and tables.
</p><p><strong>RowIndex</strong> may be an empty list, an incompletely
specified row index, or the index for an unspecified row.
</p><p>This operation is best described with an example.
</p><h3>GetNext Example</h3><p>A table called <strong>myTable</strong> has five columns. The first
two are keys (not accessible), and the table has three
rows. The instrumentation function for this table is called
<strong>my_table</strong>.</p><a name="getnext1"></a><img src="getnext1.gif" title="Contents of my_table"></img><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>N/A means not accessible.</p></div><p>The manager issues the following <strong>getNext</strong> request:
</p><pre><code class="">
getNext{ myTable.myTableEntry.3.1.1,
         myTable.myTableEntry.5.1.1 } 
        </code></pre><p>Since both operations involve the 1.1 index, this is
transformed into one call to <strong>my_table</strong>:
</p><pre><code class="">
my_table(get_next, [1, 1], [3, 5])
        </code></pre><p>In this call, <strong>[1, 1]</strong> is the <strong>RowIndex</strong>, where
key 1 has value 1, and key 2 has value 1, and <strong>[3, 5]</strong> is
the list of requested columns. The function should now return
the lexicographically next elements:
</p><pre><code class="">
[{[3, 1, 2], d}, {[5, 1, 2], f}]
        </code></pre><p>This is illustrated in the following table:
</p><a name="getnext2"></a><img src="getnext2.gif" title="GetNext from [3,1,1] and [5,1,1]."></img><p>The manager now issues the following <strong>getNext</strong> request:
</p><pre><code class="">
getNext{ myTable.myTableEntry.3.2.1,
         myTable.myTableEntry.5.2.1 } 
        </code></pre><p>This is transformed into one call to <strong>my_table</strong>:
</p><pre><code class="">
my_table(get_next, [2, 1], [3, 5])
        </code></pre><p>The function should now return:
</p><pre><code class="">
[{[4, 1, 1], b}, endOfTable]
        </code></pre><p>This is illustrated in the following table:
</p><a name="getnext3"></a><img src="getnext3.gif" title="GetNext from [3,2,1] and [5,2,1]."></img><p>The manager now issues the following <strong>getNext</strong> request:
</p><pre><code class="">
getNext{ myTable.myTableEntry.3.1.2,
         myTable.myTableEntry.4.1.2 } 
        </code></pre><p>This will be transform into one call to <strong>my_table</strong>:
</p><pre><code class="">
my_table(get_next, [1, 2], [3, 4])
        </code></pre><p>The function should now return:
</p><pre><code class="">
[{[3, 2, 1], g}, {[5, 1, 1], c}]
        </code></pre><p>This is illustrated in the following table:
</p><a name="getnext4"></a><img src="getnext4.gif" title="GetNext from [3,1,2] and [4,1,2]."></img><p>The manager now issues the following <strong>getNext</strong> request:
</p><pre><code class="">
getNext{ myTable.myTableEntry,
         myTable.myTableEntry.1.3.2 } 
        </code></pre><p>This will be transform into two calls to <strong>my_table</strong>:
</p><pre><code class="">
my_table(get_next, [], [0]) and
my_table(get_next, [3, 2], [1])
        </code></pre><p>The function should now return:
</p><pre><code class="">
[{[3, 1, 1], a}] and
[{[3, 1, 1], a}]
        </code></pre><p>In both cases, the first accessible element in the table
should be returned. As the key columns are not accessible,
this means that the third column is the first row.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Normally, the functions described above behave exactly as
shown, but they are free to perform other actions. For
example, a get-request may have side effects such as setting
some other variable, perhaps a global <strong>lastAccessed</strong>
variable.</p></div><h3>Using the ExtraArgument</h3><p>The <strong>ListOfExtraArguments</strong> can be used to write generic
functions. This list is appended to the standard arguments for
each function. Consider two read-only variables for a device,
<strong>ipAdr</strong> and <strong>name</strong> with object identifiers 1.1.23.4 and
1.1.7 respectively. To access these variables, one could implement
the two Erlang functions <strong>ip_access</strong> and <strong>name_access</strong>,
which will be in the MIB. The functions could be specified in a
text file as follows:
</p><pre><code class="">
{ipAdr, {my_module, ip_access, []}}.
% Or using the oid syntax for 'name'
{[1,1,7], {my_module, name_access, []}}.
    </code></pre><p>The <strong>ExtraArgument</strong> parameter is the empty list. For
example, when the agent receives a get-request for the
<strong>ipAdr</strong> variable, a call will be made to
<strong>ip_access(get)</strong>. The value returned by this function is the
answer to the get-request.
</p><p>If <strong>ip_access</strong> and <strong>name_access</strong> are implemented
similarly, we could write a <strong>generic_access</strong> function using
the <strong>ListOfExtraArguments</strong>:
</p><pre><code class="">
{ipAdr, {my_module, generic_access, ['IPADR']}}.
% The mnemonic 'name' is more convenient than 1.1.7
{name, {my_module, generic_access, ['NAME']}}.
    </code></pre><p>When the agent receives the same get-request as above, a call
will be made to <strong>generic_access(get, </strong>'<strong>IPADR')</strong>.
</p><p>Yet another possibility, closer to the hardware, could be:
</p><pre><code class="">
{ipAdr, {my_module, generic_access, [16#2543]}}.
{name, {my_module, generic_access, [16#A2B3]}}.
    </code></pre><h3>Default Instrumentation</h3><a name="snmp_3"></a><p>When the MIB definition work is finished, there are two major
issues left.
</p><ul><li>Implementing the MIB </li><li>Implementing a Manager Application.</li></ul><p>Implementing an MIB can be a tedious task. Most probably, there
is a need to test the agent before all tables and variables are
implemented. In this case, the default instrumentation functions
are useful. The toolkit can generate default instrumentation
functions for variables as well as for tables. Consequently, a
running prototype agent, which can handle <strong>set</strong>, <strong>get</strong>,
<strong>get-next</strong> and table operations, is generated without any
programming.
</p><p>The agent stores the values in an internal volatile database,
which is based on the standard module <strong>ets</strong>. However, it is
possible to let the MIB compiler generate functions which use an
internal, persistent database, or the Mnesia DBMS. Refer to the
Mnesia User Guide and the Reference Manual, section SNMP, module
<strong>snmp_generic</strong> for more information.
</p><p>When parts of the MIB are implemented, you recompile it and
continue on by using default functions. With this approach, the
SNMP agent can be developed incrementally.
</p><p>The default instrumentation allows the application on the
manager side to be developed and tested simultaneously with the
agent. As soon as the ASN.1 file is completed, let the MIB
compiler generate a default implementation and develop the
management application from this.
</p><h3>Table Operations</h3><p>The generation of default functions for tables works for
tables which use the <strong>RowStatus</strong> textual convention from
SNMPv2, defined in STANDARD-MIB and SNMPv2-TC.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>We strongly encourage the use of the <strong>RowStatus</strong>
convention for every table that can be modified from the
manager, even for newly designed SNMPv1 MIBs. In SNMPv1,
everybody has invented their own scheme for emulating table
operations, which has led to numerous inconsistencies. The
convention in SNMPv2 is flexible and powerful and has been
tested successfully. If the table is read only, no RowStatus
column should be used.
</p></div><h3>Atomic Set</h3><p>In SNMP, the <strong>set</strong> operation is atomic. Either all
variables which are specified in a <strong>set</strong> operation are
changed, or none are changed. Therefore, the <strong>set</strong> operation
is divided into two phases. In the first phase, the new value of
each variable is checked against the definition of the variable in
the MIB. The following definitions are checked:
</p><ul><li>the type</li><li>the length</li><li>the range</li><li>the variable is writable and within the MIB view. </li></ul><p>At
the end of phase one, the user defined <strong>is_set_ok</strong> functions
are called for each scalar variable, and for each group of table
operations.
</p><p>If no error occurs, the second phase is performed. This phase
calls the user defined <strong>set</strong> function for all variables.
</p><p>If an error occurs, either in the <strong>is_set_ok</strong> phase, or in
the <strong>set</strong> phase, all functions which were called with
<strong>is_set_ok</strong> but not <strong>set</strong>, are called with <strong>undo</strong>.
</p><p>There are limitations with this transaction mechanism. If
complex dependencies exist between variables, for example between
<strong>month</strong> and <strong>day</strong>, another mechanism is needed. Setting
the date to 'Feb 31' can be avoided by a somewhat more generic
transaction mechanism. You can continue and find more and more
complex situations and construct an N-phase set-mechanism. This
toolkit only contains a trivial mechanism.
</p><p>The most common application of transaction mechanisms is to
keep row operations together. Since our agent sorts row
operations, the mechanism implemented in combination with the
RowStatus (particularly 'createAndWait' value) solve most
problems elegantly.
</p><p>The section <em>Definition of Instrumentation Functions</em> describes
the user defined functions, which the agent calls at different times.
</p><h3>Variable Instrumentation</h3><p>For scalar variables, a function <strong>f(Operation, ...)</strong> must
be defined.
</p><p>The <strong>Operation</strong> can be <strong>new</strong>, <strong>delete</strong>,
<strong>get</strong>, <strong>is_set_ok</strong>, <strong>set</strong>, or <strong>undo</strong>.
</p><p>In case of an error, all instrumentation functions may return
either an SNMPv1 or an SNMPv2 error code. If it returns an SNMPv2
code, it is converted into an SNMPv1 code before it is sent to a
SNMPv1 manager.  It is  recommended to use the SNMPv2 error codes
for all instrumentation functions, as these provide more
details. See <a href="snmp_app_a">Appendix A</a> for a
description of error code conversions.
</p><h3>f(new [, ExtraArgs])</h3><p>The function <strong>f(new [, ExtraArgs])</strong> is called for each
variable in the MIB when the
MIB is loaded into the agent. This makes it possible to perform
necessary initialization.
</p><p>This function is optional. The return value is discarded.</p><h3>f(delete [, ExtraArgs])</h3><p>The function <strong>f(delete [, ExtraArgs])</strong> is called
for each object in an MIB when the
MIB is unloaded from the agent. This makes it possible to
perform necessary clean-up.
</p><p>This function is optional. The return value is discarded.</p><h3>f(get [, ExtraArgs])</h3><p>The function <strong>f(get [, ExtraArgs])</strong> is called when a
get-request or a get-next
request refers to the variable.
</p><p>This function is mandatory.
</p><h3>Valid Return Values</h3><ul><li><strong>{value, Value}</strong>. The <strong>Value</strong> must be of correct type, length and within ranges, otherwise <strong>genErr</strong> is returned in the response PDU.  If the object is an enumerated integer, the symbolic enum value may be used as an atom. If the object is of type BITS, the return value shall be an integer or a list of bits that are set. </li><li><strong>{noValue, noSuchName}</strong>(SNMPv1) </li><li><strong>{noValue, noSuchObject | noSuchInstance} </strong>(SNMPv2) </li><li><strong>genErr</strong>.  Used if an error occurred.  Note, this should be an internal processing error, e.g. a caused by a programing fault somewhere.  If the variable does not exist, use <strong>{noValue, noSuchName}</strong> or <strong>{noValue, noSuchInstance}</strong>. </li></ul><h3>f(is_set_ok, NewValue [, ExtraArgs])</h3><p>The function <strong>f(is_set_ok, NewValue [, ExtraArgs])</strong> is
called in phase one of the set-request
processing so that the new value can be checked for
inconsistencies.
</p><p><strong>NewValue</strong> is guaranteed to be of the correct type,
length and within ranges, as specified in the MIB.  If the
object is an enumerated integer or of type BITS, the integer
value is used.
</p><p>This function is optional.
</p><p>If this function is called, it will be called again, either
with <strong>undo</strong> or with <strong>set</strong> as first argument.
</p><h3>Valid return values</h3><ul><li><strong>noError</strong></li><li><strong>badValue | noSuchName | genErr</strong>(SNMPv1) </li><li><strong>noAccess | noCreation | inconsistentValue | resourceUnavailable | inconsistentName | genErr</strong>(SNMPv2)</li></ul><h3>f(undo, NewValue [, ExtraArgs])</h3><p>If an error occurred, this function is called after the
<strong>is_set_ok</strong> function is called. If <strong>set</strong> is called for
this object, <strong>undo</strong> is not called.
</p><p><strong>NewValue</strong> is guaranteed to be of the correct type,
length and within ranges, as specified in the MIB.  If the
object is an enumerated integer or of type BITS, the integer
value is used.
</p><p>This function is optional.
</p><h3>Valid return values</h3><ul><li><strong>noError</strong></li><li><strong>genErr</strong>(SNMPv1) </li><li><strong>undoFailed | genErr</strong>(SNMPv2)</li></ul><h3>f(set, NewValue [, ExtraArgs])</h3><p>This function is called to perform the set in phase two of
the set-request processing. It is only called if the
corresponding <strong>is_set_ok</strong> function is present and returns
<strong>noError</strong>.
</p><p><strong>NewValue</strong> is guaranteed to be of the correct type,
length and within ranges, as specified in the MIB.  If the
object is an enumerated integer or of type BITS, the integer
value is used.
</p><p>This function is mandatory.
</p><h3>Valid return values</h3><ul><li><strong>noError</strong></li><li><strong>genErr</strong>(SNMPv1) </li><li><strong>commitFailed | undoFailed | genErr</strong>(SNMPv2)</li></ul><h3>Table Instrumentation</h3><p>For tables, a <strong>f(Operation, ...)</strong> function should be
defined (the function shown is exemplified with <strong>f</strong>).
</p><p>The <strong>Operation</strong> can be <strong>new</strong>, <strong>delete</strong>,
<strong>get</strong>, <strong>next</strong>, <strong>is_set_ok</strong>, <strong>undo</strong> or
<strong>set</strong>.
</p><p>In case of an error, all instrumentation functions may return
either an SNMPv1 or an SNMPv2 error code. If it returns an SNMPv2
code, it is converted into an SNMPv1 code before it is sent to a
SNMPv1 manager. It is  recommended to use the SNMPv2 error codes
for all instrumentation functions, as these provide more
details. See <a href="snmp_app_a">Appendix A</a> for a
description of error code conversions.</p><h3>f(new [, ExtraArgs])</h3><p>The function <strong>f(new [, ExtraArgs])</strong> is called for each object in an MIB when the
MIB is loaded into the agent. This makes it possible to perform
the necessary initialization.
</p><p>This function is optional. The return value is discarded.</p><h3>f(delete [, ExtraArgs])</h3><p>The function <strong>f(delete [, ExtraArgs])</strong> is called for each object in an MIB when the
MIB is unloaded from the agent. This makes it possible to
perform any necessary clean-up.
</p><p>This function is optional. The return value is discarded.</p><h3>f(get, RowIndex, Cols [, ExtraArgs])</h3><p>The function <strong>f(get, RowIndex, Cols [, ExtraArgs])</strong> is
called when a get-request refers to a table.
</p><p>This function is mandatory.
</p><h3>Arguments</h3><ul><li><strong>RowIndex</strong> is a list of integers which define the key values for the row. The <strong>RowIndex</strong> is the list representation (list of integers) which follow the <strong>Cols</strong> integer in the OBJECT IDENTIFIER. </li><li><strong>Cols</strong> is a list of integers which represent the column numbers. The <strong>Cols</strong> are sorted by increasing value and are guaranteed to be valid column numbers.</li></ul><h3>Valid Return Values</h3><ul><li> <p>A list with as many elements as the <strong>Cols</strong> list,
where each element is the value of the corresponding
column.  Each element can be:</p> <ul><li><strong>{value, Value}</strong>. The <strong>Value</strong> must be of correct type, length and within ranges, otherwise <strong>genErr</strong> is returned in the response PDU.  If the object is an enumerated integer, the symbolic enum value may be used (as an atom). If the object is of type BITS, the return value shall be an integer or a list of bits that are set. </li><li><strong>{noValue, noSuchName}</strong>(SNMPv1) </li><li><strong>{noValue, noSuchObject | noSuchInstance}</strong>(SNMPv2) </li></ul> </li><li><strong>{noValue, Error}</strong>. If the row does not exist, because all columns have <strong>{noValue, Error}</strong>), the single tuple <strong>{noValue, Error}</strong> can be returned. This is a shorthand for a list with all elements <strong>{noValue, Error}</strong>. </li><li><strong>genErr</strong>.  Used if an error occurred.  Note that this should be an internal processing error, e.g. a caused by a programing fault somewhere.  If some column does not exist, use <strong>{noValue, noSuchName}</strong> or <strong>{noValue, noSuchInstance}</strong>. </li></ul><h3>f(get_next, RowIndex, Cols [, ExtraArgs])</h3><p>The function <strong>f(get_next, RowIndex, Cols [, ExtraArgs])</strong> is 
called when a get-next- or a
get-bulk-request refers to the table.
</p><p>The <strong>RowIndex</strong> argument may refer to an existing row or a
non-existing row, or it may be unspecified. The <strong>Cols</strong> list
may refer to inaccessible columns or non-existing columns. For
each column in the <strong>Cols</strong> list, the corresponding next
instance is determined, and the last part of its OBJECT
IDENTIFIER and its value is returned.
</p><p>This function is mandatory.
</p><h3>Arguments</h3><ul><li><strong>RowIndex</strong> is a list of integers (possibly empty) that defines the key values for a row. The <strong>RowIndex</strong> is the list representation (list of integers), which follow the <strong>Cols</strong> integer in the OBJECT IDENTIFIER. </li><li><strong>Cols</strong> is a list of integers, greater than or equal to zero, which represents the column numbers.</li></ul><h3>Valid Return Values</h3><ul><li> <p>A list with as many elements as the <strong>Cols</strong> list
Each element can be:</p> <ul><li><strong>{NextOid, NextValue}</strong>, where <strong>NextOid</strong> is the lexicographic next OBJECT IDENTIFIER for the corresponding column. This should be specified as the OBJECT IDENTIFER part following the table entry. This means that the first integer is the column number and the rest is a specification of the keys. <strong>NextValue</strong> is the value of this element. </li><li><strong>endOfTable</strong> if there are no accessible elements after this one. </li></ul> </li><li><strong>{genErr, Column}</strong> where <strong>Column</strong> denotes the column that caused the error.  <strong>Column</strong> must be one of the columns in the <strong>Cols</strong> list.  Note that this should be an internal processing error, e.g. a caused by a programing fault somewhere.  If some column does not exist, you must return the next accessible element (or <strong>endOfTable</strong>).  </li></ul><h3>f(is_set_ok, RowIndex, Cols [, ExtraArgs])</h3><p>The function <strong>f(is_set_ok, RowIndex, Cols [, ExtraArgs])</strong>
is called in phase one of the set-request
processing so that new values can be checked for
inconsistencies.
</p><p>If the function is called, it will be called again with
<strong>undo</strong>, or with <strong>set</strong> as first argument.
</p><p>This function is optional.
</p><h3>Arguments</h3><ul><li><strong>RowIndex</strong> is a list of integers which define the key values for the row. The <strong>RowIndex</strong> is the list representation (list of integers) which follow the <strong>Cols</strong> integer in the OBJECT IDENTIFIER. </li><li><strong>Cols</strong> is a list of <strong>{Column, NewValue}</strong>, where <strong>Column</strong> is an integer, and <strong>NewValue</strong> is guaranteed to be of the correct type, length and within ranges, as specified in the MIB.  If the object is an enumerated integer or of type BITS, the integer value is used.  The list is sorted by <strong>Column</strong> (increasing) and each <strong>Column</strong> is guaranteed to be a valid column number.</li></ul><h3>Valid Return Values</h3><ul><li><strong>{noError, 0}</strong></li><li><strong>{Error, Column}</strong>, where <strong>Error</strong> is the same as for <strong>is_set_ok</strong> for variables, and <strong>Column</strong> denotes the faulty column.  <strong>Column</strong> must be one of the columns in the <strong>Cols</strong> list.</li></ul><h3>f(undo, RowIndex, Cols [, ExtraArgs])</h3><p>If an error occurs, The function
<strong>f(undo, RowIndex, Cols [, ExtraArgs])</strong> is called after the
<strong>is_set_ok</strong> function. If <strong>set</strong> is called for this
object, <strong>undo</strong> is not called.
</p><p>This function is optional.
</p><h3>Arguments</h3><ul><li><strong>RowIndex</strong> is a list of integers which define the key values for the row. The <strong>RowIndex</strong> is the list representation (list of integers) which follow the <strong>Cols</strong> integer in the OBJECT IDENTIFIER. </li><li><strong>Cols</strong> is a list of <strong>{Column, NewValue}</strong>, where <strong>Column</strong> is an integer, and <strong>NewValue</strong> is guaranteed to be of the correct type, length and within ranges, as specified in the MIB.  If the object is an enumerated integer or of type BITS, the integer value is used.  The list is sorted by <strong>Column</strong> (increasing) and each <strong>Column</strong> is guaranteed to be a valid column number. </li></ul><h3>Valid Return Values</h3><ul><li><strong>{noError, 0}</strong></li><li><strong>{Error, Column}</strong> where <strong>Error</strong> is the same as for <strong>undo</strong> for variables, and <strong>Column</strong> denotes the faulty column.  <strong>Column</strong> must be one of the columns in the <strong>Cols</strong> list. </li></ul><h3>f(set, RowIndex, Cols [, ExtraArgs])</h3><p>The function <strong>f(set, RowIndex, Cols [, ExtraArgs])</strong> is
called to perform the set in phase two of
the set-request processing. It is only called if the
corresponding <strong>is_set_ok</strong> function did not exist, or
returned <strong>{noError, 0}</strong>.
</p><p>This function is mandatory.
</p><h3>Arguments</h3><ul><li><strong>RowIndex</strong> is a list of integers that define the key values for the row. The <strong>RowIndex</strong> is the list representation (list of integers) which follow the <strong>Cols</strong> integer in the OBJECT IDENTIFIER. </li><li><strong>Cols</strong> is a list of <strong>{Column, NewValue}</strong>, where <strong>Column</strong> is an integer, and <strong>NewValue</strong> is guaranteed to be of the correct type, length and within ranges, as specified in the MIB.  If the object is an enumerated integer or of type BITS, the integer value is used.  The list is sorted by <strong>Column</strong> (increasing) and each <strong>Column</strong> is guaranteed to be a valid column number. </li></ul><h3>Valid Return Values</h3><ul><li><strong>{noError, 0}</strong></li><li><strong>{Error, Column}</strong> where <strong>Error</strong> is the same as <strong>set</strong> for variables, and <strong>Column</strong> denotes the faulty column.  <strong>Column</strong> must be one of the columns in the <strong>Cols</strong> list.</li></ul><img src="snmp_agent_netif_1.gif" title="The Purpose of Agent Net if"></img><p>The Network Interface (Net if) process delivers SNMP PDUs to a
master agent, and receives SNMP PDUs from the master agent. The most
common behaviour of a Net if process is that is receives bytes from
a network, decodes them into an SNMP PDU, which it sends to a master
agent. When the master agent has processed the PDU, it sends a
response PDU to the Net if process, which encodes the PDU into bytes
and transmits the bytes onto the network.
</p><p>However, that simple behaviour can be modified in numerous
ways. For example, the Net if process can apply some kind of
encrypting/decrypting scheme on the bytes or
act as a proxy filter, which sends some packets to a proxy agent and
some packets to the master agent.
</p><p>It is also possible to write your own Net if process. The default
Net if process is implemented in the module <strong>snmpa_net_if</strong> and
it uses UDP as the transport protocol i.e the transport domains
<strong>transportDomainUdpIpv4</strong> and/or <strong>transportDomainUdpIpv6</strong>.
</p><p>This section describes how to write a Net if process.
</p><a name="mandatory_functions"></a><h3>Mandatory Functions</h3><p>A Net if process must implement the SNMP agent 
<a href="snmpa_network_interface">network interface behaviour</a>.
</p><a name="messages"></a><h3>Messages</h3><p>The section <em>Messages</em> describes mandatory messages, which
Net if must send and be able to receive.     
</p><p>In this section an <strong>Address</strong> field is a
<strong>{Domain, Addr}</strong> tuple where <strong>Domain</strong> is
<strong>transportDomainUdpIpv4</strong> or <strong>transportDomainUdpIpv4</strong>,
and <strong>Addr</strong> is an
<strong>{</strong><a href="../kernel/inet#type-ip_address">kernel/inet#type-ip_address</a><strong>,IpPort}</strong> tuple.</p><a name="outgoing_messages"></a><h3>Outgoing Messages</h3><p>Net if must send the following message when it receives an
SNMP PDU from the network that is aimed for the MasterAgent:
</p><a name="om_snmp_pdu"></a><pre>
MasterAgent ! {snmp_pdu, Vsn, Pdu, PduMS, ACMData, From, Extra}
      </pre><ul><li><strong>Vsn</strong> is either <strong>'version-1'</strong>, <strong>'version-2'</strong>, or <strong>'version-3'</strong>. </li><li><strong>Pdu</strong> is an SNMP PDU record, as defined in <strong>snmp_types.hrl</strong>, with the SNMP request. </li><li><strong>PduMS</strong> is the Maximum Size of the response Pdu allowed.  Normally this is returned from <strong>snmpa_mpd:process_packet</strong> (see Reference Manual). </li><li><strong>ACMData</strong> is data used by the Access Control Module in use.  Normally this is returned from <strong>snmpa_mpd:process_packet</strong> (see Reference Manual). </li><li><strong>From</strong> is the source <strong>Address</strong>. </li><li><strong>Extra</strong> is any term the Net if process wishes to send to the agent. This term can be retrieved by the instrumentation functions by calling <strong>snmp:current_net_if_data()</strong>. This data is also sent back to the Net if process when the agent generates a response to the request.</li></ul><p>The following message is used to report that a response to a
request has been received.  The only request an agent can send
is an Inform-Request.
</p><a name="om_snmp_response_received"></a><pre>
Pid ! {snmp_response_received, Vsn, Pdu, From}
      </pre><ul><li><strong>Pid</strong> is the Process that waits for the response for the request.  The Pid was specified in the <strong>send_pdu_req</strong> message  <a href="#im_send_pdu_req">(see below)</a>. </li><li><strong>Vsn</strong> is either <strong>'version-1'</strong>, <strong>'version-2'</strong>, or <strong>'version-3'</strong>. </li><li><strong>Pdu</strong> is the SNMP Pdu received </li><li><strong>From</strong> is the source <strong>Address</strong>. </li></ul><a name="incoming_messages"></a><h3>Incoming Messages</h3><p>This section describes the incoming messages which a Net if
process must be able to receive.
</p><ul><li> <a name="im_snmp_response"></a> <p><strong>{snmp_response, Vsn, Pdu, Type, ACMData, To, Extra}</strong></p> <p>This message is sent to the Net if process from a master
agent as a response to a previously received request.
</p> <ul><li> <p><strong>Vsn</strong> is either <strong>'version-1'</strong>,
<strong>'version-2'</strong>, or <strong>'version-3'</strong>. </p> </li><li> <p><strong>Pdu</strong> is an SNMP PDU record (as defined in
snmp_types.hrl) with the SNMP response. </p> </li><li> <p><strong>Type</strong> is the <strong>#pdu.type</strong> 
of the original request. </p> </li><li> <p><strong>ACMData</strong> is data used by the Access Control
Module in use.  Normally this is just sent to
<strong>snmpa_mpd:generate_response_message</strong> 
(see Reference Manual). </p> </li><li> <p><strong>To</strong> is the destination <strong>Address</strong> that comes
from the <strong>From</strong> field in the corresponding <strong>snmp_pdu</strong>
message previously sent to the MasterAgent.</p> </li><li> <p><strong>Extra</strong> is the term that the Net if process
sent to the agent when the request was sent to the agent. </p> </li></ul> </li><li> <a name="im_discarded_pdu"></a> <p><strong>{discarded_pdu, Vsn, ReqId, ACMData, Variable, Extra}</strong></p> <p>This message is sent from a master agent if it for some
reason decided to discard the pdu. </p> <ul><li> <p><strong>Vsn</strong> is either <strong>'version-1'</strong>,
<strong>'version-2'</strong>, or <strong>'version-3'</strong>. </p> </li><li> <p><strong>ReqId</strong> is the request id of the original request. </p> </li><li> <p><strong>ACMData</strong> is data used by the Access Control
Module in use. Normally this is just sent to
<strong>snmpa_mpd:generate_response_message</strong> 
(see Reference Manual). </p> </li><li> <p><strong>Variable</strong> is the name of an snmp counter that
represents the error, e.g. <strong>snmpInBadCommunityUses</strong>. </p> </li><li> <p><strong>Extra</strong> is the term that the Net if process
sent to the agent when the request was sent to the agent. </p> </li></ul> </li><li> <a name="im_send_pdu"></a> <p><strong>{send_pdu, Vsn, Pdu, MsgData, To, Extra}</strong></p> <p>This message is sent from a master agent when a trap is
to be sent. </p> <ul><li> <p><strong>Vsn</strong> is either <strong>'version-1'</strong>,
<strong>'version-2'</strong>, or <strong>'version-3'</strong>.</p> </li><li> <p><strong>Pdu</strong> is an SNMP PDU record (as defined in
snmp_types.hrl) with the SNMP response. </p> </li><li> <p><strong>MsgData</strong> is the message specific data used in
the SNMP message.  This value is normally sent to
<strong>snmpa_mpd:generate_message/4</strong>.  In SNMPv1 and
SNMPv2c, this message data is the community string.  In
SNMPv3, it is the context information. </p> </li><li> <p><strong>To</strong> is a list of <strong>{Address, SecData}</strong>
tuples i.e the destination addresses and
their corresponding security parameters.  This value is
normally sent to <strong>snmpa_mpd:generate_message/4</strong>. </p> </li><li> <p><strong>Extra</strong> is any term that the notification sender
wishes to pass to the Net if process when sending a notification 
(see 
<a href="./snmpa#send_notification2">send notification </a> for more info). </p> </li></ul> </li><li> <a name="im_send_pdu_req"></a> <p><strong>{send_pdu_req, Vsn, Pdu, MsgData, To, Pid, Extra}</strong></p> <p>This message is sent from a master agent when a request is to 
be sent.  The only request an agent can send is Inform-Request.  
The net if process needs to remember the request id and the Pid, 
and when a response is received for the request id, send it to Pid, 
using a <strong>snmp_response_received</strong> message. </p> <ul><li> <p><strong>Vsn</strong> is either <strong>'version-1'</strong>,
<strong>'version-2'</strong>,  or <strong>'version-3'</strong>.</p> </li><li> <p><strong>Pdu</strong> is an SNMP PDU record (as defined in
snmp_types.hrl) with the SNMP response. </p> </li><li> <p><strong>MsgData</strong> is the message specific data used in
the SNMP message.  This value is normally sent to
<strong>snmpa_mpd:generate_message/4</strong>. In SNMPv1 and
SNMPv2c, this message data is the community string. In
SNMPv3, it is the context information. </p> </li><li> <p><strong>To</strong> is a list of <strong>{Address, SecData}</strong>
tuples i.e the destination addresses and
their corresponding security parameters. This value is
normally sent to <strong>snmpa_mpd:generate_message/4</strong>. </p> </li><li> <p><strong>Pid</strong> is a process identifier. </p> </li><li> <p><strong>Extra</strong> is any term that the notification sender
wishes to pass to the Net if process when sending a notification 
(see 
<a href="./snmpa#send_notification2">send notification </a> for more info). </p> </li></ul> </li></ul><h3>Notes</h3><p>Since the Net if process is responsible for encoding and
decoding of SNMP messages, it must also update the relevant
counters in the SNMP group in MIB-II. It can use the functions
in the module <strong>snmpa_mpd</strong> for this purpose (refer to the 
Reference Manual, section <strong>snmp</strong>, 
module <a href="snmp_pdus">snmpa_mpd</a>
for more details.)
</p><p>There are also some useful functions for encoding and
decoding of SNMP messages in the module 
<a href="snmp_pdus">snmp_pdus</a>.
</p><img src="snmp_manager_netif_1.gif" title="The Purpose of Manager Net if"></img><p>The Network Interface (Net if) process delivers SNMP PDUs to the
manager server, and receives SNMP PDUs from the manager server. 
The most common behaviour of a Net if process is that is receives 
request PDU from the manager server, encodes the PDU into bytes
and transmits the bytes onto the network to an agent. When the 
reply from the agent is received by the Net if process, which it
decodes into an SNMP PDU, which it sends to the manager server. </p><p>However, that simple behaviour can be modified in numerous
ways. For example, the Net if process can apply some kind of
encrypting/decrypting scheme on the bytes. </p><p>The snmp application provides two different modules, 
<strong>snmpm_net_if</strong> (the default) and <strong>snmpm_net_if_mt</strong>, 
both uses UDP as the transport protocol i.e the transport domains
<strong>transportDomainUdpIpv4</strong> and/or <strong>transportDomainUdpIpv6</strong>.
The difference between the two modules is that the latter is
"multi-threaded",  i.e. for each message/request a new process
is created that processes the message/request and then exits. </p><p>It is also possible to write your own Net if process and
this section describes how to do that.</p><a name="mandatory_functions"></a><h3>Mandatory Functions</h3><p>A Net if process must implement the SNMP manager 
<a href="snmpm_network_interface">network interface behaviour</a>. </p><h3>Messages</h3><p>The section <em>Messages</em> describes mandatory messages, which
Net if must send to the manager server process.     
</p><p>In this section a <strong>Domain</strong> field is the transport domain i.e
one of <strong>transportDomainUdpIpv4</strong> or <strong>transportDomainUdpIpv6</strong>,
and an <strong>Addr</strong> field is an
<strong>{</strong><a href="../kernel/inet#type-ip_address">kernel/inet#type-ip_address</a><strong>,IpPort}</strong> tuple.</p><p>Net if must send the following message when it receives an
SNMP PDU from the network that is aimed for the MasterAgent:
</p><pre>
Server ! {snmp_pdu, Pdu, Domain, Addr}
    </pre><ul><li> <p><strong>Pdu</strong> is an SNMP PDU record, as defined in
<strong>snmp_types.hrl</strong>, with the SNMP request.</p> </li><li> <p><strong>Domain</strong> is the source transport domain. </p> </li><li> <p><strong>Addr</strong> is the source address. </p> </li></ul><pre>
Server ! {snmp_trap, Trap, Domain, Addr}
    </pre><ul><li> <p><strong>Trap</strong> is either an SNMP pdu record or an trappdu record, 
as defined in <strong>snmp_types.hrl</strong>, with the SNMP request.</p> </li><li> <p><strong>Domain</strong> is the source transport domain. </p> </li><li> <p><strong>Addr</strong> is the source address. </p> </li></ul><pre>
Server ! {snmp_inform, Ref, Pdu, PduMS, Domain, Addr}
    </pre><ul><li> <p><strong>Ref</strong> is either the atom <strong>ignore</strong> or something
that can be used to identify the inform-request (e.g. request-id).
<strong>ignore</strong> is used if the response (acknowledgment) to the
inform-request has already been sent (this means that the server 
will not make the call to the 
<a href="./snmpm_network_interface#inform_response">inform_response</a> 
function). See the 
<a href="snmp_app">inform request behaviour</a> 
configuration option for more info.</p> </li><li> <p><strong>Pdu</strong> is an SNMP PDU record, as defined in
<strong>snmp_types.hrl</strong>, with the SNMP request.</p> </li><li> <p><strong>Domain</strong> is the source transport domain. </p> </li><li> <p><strong>Addr</strong> is the source address. </p> </li></ul><pre>
Server ! {snmp_report, Data, Domain, Addr}
    </pre><ul><li> <p><strong>Data</strong> is either <strong>{ok, Pdu}</strong> or 
<strong>{error, ReqId, ReasonInfo, Pdu}</strong>. Which one is used depends 
on the return value from the MPD 
<a href="./snmpm_mpd#process_msg">process_msg</a> function. If the MsgData is <strong>ok</strong>, 
the first is used, and if it is <strong>{error, ReqId, Reason}</strong>
the latter is used.</p> </li><li> <p><strong>Pdu</strong> is an SNMP PDU record, as defined in
<strong>snmp_types.hrl</strong>, with the SNMP request.</p> </li><li> <p><strong>ReqId</strong> is an integer.</p> </li><li> <p><strong>ReasonInfo</strong> is a term().</p> </li><li> <p><strong>Domain</strong> is the source transport domain. </p> </li><li> <p><strong>Addr</strong> is the source address. </p> </li></ul><h3>Notes</h3><p>Since the Net if process is responsible for encoding and
decoding of SNMP messages, it must also update the relevant
counters in the SNMP group in MIB-II.  It can use the functions
in the module <strong>snmpm_mpd</strong> for this purpose (refer to the 
Reference Manual, section <strong>snmp</strong>, module <strong>snmpm_mpd</strong>
for more details).
</p><p>There are also some useful functions for encoding and
decoding of SNMP messages in the module <strong>snmp_pdus</strong>.
</p><p>The chapter <em>Audit Trail Log</em> describes the audit trail logging.
</p><p>Both the agent and the manager can be configured to log 
incoming and outgoing messages. It uses the Erlang standard log
mechanism <strong>disk_log</strong> for logging. The size and location of
the log files are configurable. A wrap log is used, which means
that when the log has grown to a maximum size, it starts from the
beginning of the log, overwriting existing log records.
</p><p>The log can be either a <strong>read</strong>, <strong>write</strong> or a 
<strong>read_write</strong>. 
</p><h3>Agent Logging</h3><p>For the agent, a <strong>write</strong>, means that all <strong>set</strong> 
requests and their responses are stored. No <strong>get</strong> requests
or traps are stored in a <strong>write</strong>. A <strong>read_write</strong>, 
all requests, responses and traps are stored.
</p><p>The log uses a raw data format (basically the BER encoded
message), in order to minimize the CPU load needed for the log
mechanism.  This means that the log is not human readable, but
needs to be formatted off-line before it can be read.  Use the
function 
<a href="./snmpa#log_to_txt">snmpa:log_to_txt</a> 
for this purpose.
</p><h3>Manager Logging</h3><p>For the manager, a <strong>write</strong>, means that all  
requests (<strong>set</strong> and <strong>get</strong>) and their responses are stored. 
No traps are stored in a <strong>write</strong>. A <strong>read_write</strong>, 
all requests, responses and traps are stored.
</p><p>The log uses a raw data format (basically the BER encoded
message), in order to minimize the CPU load needed for the log
mechanism. This means that the log is not human readable, but
needs to be formatted off-line before it can be read. Use the
function 
<a href="./snmpm#log_to_txt">snmpm:log_to_txt</a> 
for this purpose.
</p><p>The chapter <em>Advanced Agent Topics</em> describes the more advanced 
agent related features of the SNMP development tool. The following topics 
are covered:
</p><ul><li>When to use a Sub-agent</li><li>Agent semantics</li><li>Sub-agents and dependencies</li><li>Distributed tables</li><li>Fault tolerance</li><li>Using Mnesia tables as SNMP tables</li><li>Audit Trail Logging</li><li>Deviations from the standard </li></ul><h3>When to use a Sub-agent</h3><p>The section <em>When to use a Sub-agent</em> describes situations
where the mechanism of loading and unloading MIBs is insufficient. 
In these cases a sub-agent is needed.
</p><h3>Special Set Transaction Mechanism</h3><p>Each sub-agent can implement its own mechanisms for
<strong>set</strong>, <strong>get</strong> and <strong>get-next</strong>. For example, if the
application requires the <strong>get</strong> mechanism to be
asynchronous, or needs a N-phase <strong>set</strong> mechanism, a
specialized sub-agent should be used.
</p><p>The toolkit allows different kinds of sub-agents at the same
time. Accordingly, different MIBs can have different <strong>set</strong>
or <strong>get</strong> mechanisms.
</p><h3>Process Communication</h3><p>A simple distributed agent can be managed without sub-agents. 
The instrumentation functions can use distributed Erlang to 
communicate with other parts of the application. However, a 
sub-agent can be used on each node if this generates too much 
unnecessary traffic. A sub-agent processes requests per 
incoming SNMP request, not per variable. Therefore the network 
traffic is minimized.
</p><p>If the instrumentation functions communicate with UNIX
processes, it might be a good idea to use a special
sub-agent. This sub-agent sends the SNMP request to the other
process in one packet in order to minimize context switches. For
example, if a whole MIB is implemented on the C level in UNIX,
but you still want to use the Erlang SNMP tool, then you may
have one special sub-agent, which sends the variables in the
request as a single operation down to C.
</p><h3>Frequent Loading of MIBs</h3><p>Loading and unloading of MIBs are quite cheap
operations. However, if the application does this very often,
perhaps several times per minute, it should load the MIBs once
and for all in a sub-agent. This sub-agent only registers and
unregisters itself under another agent instead of loading the
MIBs each time. This is cheaper than loading an MIB.
</p><h3>Interaction With Other SNMP Agent Toolkits</h3><p>If the SNMP agent needs to interact with sub-agents
constructed in another package, a special sub-agent should be
used, which communicates through a protocol specified by the
other package.
</p><h3>Agent Semantics</h3><p>The agent can be configured to be multi-threaded, to process
one incoming request at a time, or to have a request limit
enabled (this can be used for load control or to limit the effect
of DoS attacks). If it is multi-threaded, read requests (<strong>get</strong>, 
<strong>get-next</strong> and <strong>get-bulk</strong>) and traps are processed in 
parallel with each other and <strong>set</strong> requests. However, all 
<strong>set</strong> requests are serialized, which means that if the agent 
is waiting for the application to complete a complicated write 
operation, it will not process any new write requests until this 
operation is finished. It processes read requests and sends traps, 
concurrently. The reason for not handle write requests in parallel is 
that a complex locking mechanism would be needed even in the simplest 
cases. Even with the scheme described above, the user must be 
careful not to violate that the <strong>set</strong> requests are atoms. 
If this is hard to do, do not use the multi-threaded feature.
</p><p>The order within an request is undefined and variables are not
processed in a defined order. Do not assume that the first
variable in the PDU will be processed before the second, even if
the agent processes variables in this order. It
cannot even be  assumed that requests belonging to different
sub-agents have any order.
</p><p>If the manager tries to set the same variable many times in the
same PDU, the agent is free to improvise. There is no definition
which determines if the instrumentation will be called once or
twice. If called once only, there is no definition that determines 
which of the new values is going to be supplied.
</p><p>When the agent receives a request, it keeps the request ID for
one second after the response is sent. If the agent receives
another request with the same request ID during this time, from
the same IP address and UDP port, that request will be
discarded. This mechanism has nothing to do with the function
<strong>snmpa:current_request_id/0</strong>.</p><h3>Sub-agents and Dependencies</h3><p>The toolkit supports the use of different types of sub-agents,
but not the construction of sub-agents.
</p><p>Also, the toolkit does not support dependencies between
sub-agents. A sub-agent should by definition be stand alone and it is
therefore not good design to create dependencies between them.
</p><h3>Distributed Tables</h3><p>A common situation in more complex systems is that the data in
a table is distributed. Different table rows are implemented in
different places. Some SNMP tool-kits dedicate an SNMP sub-agent for
each part of the table and load the corresponding MIB into all
sub-agents. The Master Agent is responsible for presenting the
distributed table as a single table to the manager. The toolkit
supplied uses a different method.
</p><p>The method used to implement distributed tables with this SNMP
tool is to implement a table coordinator process responsible for 
coordinating the processes, which hold the table data and they 
are called  table holders. All table holders must in some way be 
known by the coordinator; the structure of the table data 
determines how this is achieved. The coordinator may require 
that the table holders explicitly register themselves and specify 
their information. In other cases, the table holders can be 
determined once at compile time.
</p><p>When the instrumentation function for the distributed table is
called, the request should be forwarded to the table
coordinator. The coordinator finds the requested information among
the table holders and then returns the answer to the
instrumentation function. The SNMP toolkit contains no support for
coordination of tables since this must be independent of the
implementation.
</p><p>The advantages of separating the table coordinator from the
SNMP tool are:
</p><ul><li>We do not need a sub-agent for each table holder. Normally, the sub-agent is needed to take care of communication, but in Distributed Erlang we use ordinary message passing. </li><li>Most likely, some type of table coordinator already exists. This process should take care of the instrumentation for the table. </li><li>The method used to present a distributed table is strongly application dependent. The use of different masking techniques is only valid for a small subset of problems and registering every row in a distributed table makes it non-distributed. </li></ul><h3>Fault Tolerance</h3><p>The SNMP agent toolkit gets input from three different sources:
</p><ul><li>UDP packets from the network</li><li>return values from the user defined instrumentation functions</li><li>return values from the MIB. </li></ul><p>The agent is highly fault tolerant. If the manager gets an
unexpected response from the agent, it is possible that some
instrumentation function has returned an erroneous value. The
agent will not crash even if the instrumentation does. It should
be noted that if an instrumentation function enters an infinite
loop, the agent will also be blocked forever. The supervisor ,or
the application, specifies how to restart the agent.
</p><h3>Using the SNMP Agent in a Distributed Environment</h3><p>The normal way to use the agent in a distributed
environment is to use one master agent located at one node,
and zero or more sub-agents located on other nodes.  However,
this configuration makes the master agent node a single point
of failure.  If that node goes down, the agent will not work.
</p><p>One solution to this problem is to make the snmp application
a distributed Erlang application, and that means, the agent
may be configured to run on one of several nodes.  If the node
where it runs goes down, another node restarts the agent.
This is called <em>failover</em>.  When the node starts again,
it may  <em>takeover</em> the application.  This solution to
the problem adds another problem.  Generally, the new node has
another IP address than the first one, which may cause
problems in the  communication between the SNMP managers and
the agent.
</p><p>If the snmp agent is configured as a distributed Erlang
application, it will during takeover try to load the same MIBs
that were loaded at the old node. It uses the same filenames
as the old node. If the MIBs are not located in the same
paths at the different nodes, the MIBs must be loaded
explicitly after takeover.
</p><h3>Using Mnesia Tables as SNMP Tables</h3><p>The Mnesia DBMS can be used for storing data of SNMP
tables. This means that an SNMP table can be implemented as a
Mnesia table, and that a Mnesia table can be made visible via
SNMP. This mapping is largely automated.
</p><p>There are three main reasons for using this mapping:
</p><ul><li>We get all features of Mnesia, such as fault tolerance, persistent data storage, replication, and so on. </li><li>Much of the work involved is automated. This includes <strong>get-next</strong> processing and <strong>RowStatus</strong> handling. </li><li>The table may be used as an ordinary Mnesia table, using the Mnesia API internally in the application at the same time as it is visible through SNMP. </li></ul><p>When this mapping is used, insertion and deletion in the
original Mnesia table is slower, with a factor O(log n). The read
access is not affected.
</p><p>A drawback with implementing an SNMP table as a Mnesia table is
that the internal resource is forced to use the table definition
from the MIB, which means that the external data model must be
used internally. Actually, this is only partially true. The Mnesia
table may extend the SNMP table, which means that the Mnesia table
may have columns which are use internally and are not seen by
SNMP. Still, the data model from SNMP must be maintained. Although
this is undesirable, it is a pragmatic compromise in many
situations where simple and efficient implementation is preferable
to abstraction.
</p><h3>Creating the Mnesia Table</h3><p>The table must be created in Mnesia before the manager can
use it. The table must be declared as type <strong>snmp</strong>.  This
makes the table ordered in accordance with the lexicographical
ordering rules of SNMP.  The name of the Mnesia table must be
identical to the SNMP table name.  The types of the INDEX fields
in the corresponding SNMP table must be specified.
</p><p>If the SNMP table has more than one INDEX column, the
corresponding Mnesia row is a tuple, where the first element 
is a tuple with the INDEX columns. Generally, if the SNMP table 
has <em>N</em> INDEX columns and <em>C</em> data columns, the 
Mnesia table is of arity <em>(C-N)+1</em>, where the key is a 
tuple of arity <em>N</em> if <em>N &gt; 1</em>, or a single term 
if <em>N = 1</em>.
</p><p>Refer to the Mnesia User's Guide for information on how to
declare a Mnesia table as an SNMP table.
</p><p>The following example illustrates a situation in which we
have an SNMP table that we wish to implement as a Mnesia
table. The table stores information about employees at a
company. Each employee is indexed with the department number and
the name.
</p><pre><code class="">
       empTable OBJECT-TYPE
              SYNTAX      SEQUENCE OF EmpEntry
              ACCESS      not-accessible
              STATUS      mandatory
              DESCRIPTION
                      "A table with information about employees."
       ::= { emp 1}
       empEntry OBJECT-TYPE
              SYNTAX      EmpEntry
              ACCESS      not-accessible
              STATUS      mandatory
              DESCRIPTION
                 ""
              INDEX      { empDepNo, empName }
       ::= { empTable 1 }
       EmpEntry ::=
              SEQUENCE {
                  empDepNo         INTEGER,
                  empName          DisplayString,
                  empTelNo         DisplayString,
                  empStatus        RowStatus
              }
      </code></pre><p>The corresponding Mnesia table is specified as follows:
</p><pre><code class="">
mnesia:create_table([{name, employees},
                     {snmp, [{key, {integer, string}}]},
                     {attributes, [key, telno, row_status]}]).
      </code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>In the Mnesia tables, the two key columns are stored as a
tuple with two elements. Therefore, the arity of the table is
3.</p></div><h3>Instrumentation Functions</h3><p>The MIB table shown in the previous section can be compiled
as follows:
</p><pre>
1&gt; <span class="input">snmpc:compile("EmpMIB", [{db, mnesia}]).</span>
      </pre><p>This is all that has to be done! Now the manager can read,
add, and modify rows. Also, you can use the ordinary Mnesia API
to access the table from your programs. The only explicit action
is to create the Mnesia table, an action the user has to perform
in order to create the required table schemas.</p><h3>Adding Own Actions</h3><p>It is often necessary to take some specific action when a
table is modified. This is accomplished with an instrumentation
function. It executes some specific code when the table is set,
and passes all other requests down to the pre-defined function.
</p><p>The following example illustrates this idea:
</p><pre><code class="">
emp_table(set, RowIndex, Cols) -&gt;
    notify_internal_resources(RowIndex, Cols),
    snmp_generic:table_func(set, RowIndex, Cols, {empTable, mnesia});
emp_table(Op, RowIndex, Cols) -&gt;
    snmp_generic:table_func(Op, RowIndex, Cols, {empTable, mnesia}).
      </code></pre><p>The default instrumentation functions are defined in the
module <strong>snmp_generic</strong>. Refer to the Reference Manual,
section SNMP, module <strong>snmp_generic</strong> for details.</p><h3>Extending the Mnesia Table</h3><p>A table may contain columns that are used internally, but
should not be visible to a manager. These internal columns must
be the last columns in the table. The <strong>set</strong> operation will
not work with this arrangement, because there are columns that
the agent does not know about. This situation is handled by
adding values for the internal columns in the <strong>set</strong>
function.
</p><p>To illustrate this, suppose we extend our Mnesia
<strong>empTable</strong> with one internal column. We create it as
before, but with an arity of 4, by adding another attribute.
</p><pre><code class="">
mnesia:create_table([{name, employees},
                     {snmp, [{key, {integer, string}}]},
                     {attributes, {key, telno, row_status, internal_col}}]).
      </code></pre><p>The last column is the internal column. When performing a
<strong>set</strong> operation, which creates a row, we must give a
value to the internal column. The instrumentation functions will now
look as follows:
</p><pre><code class="">
-define(createAndGo, 4).
-define(createAndWait, 5).

emp_table(set, RowIndex, Cols) -&gt;
  notify_internal_resources(RowIndex, Cols),
  NewCols =
    case is_row_created(empTable, Cols) of
      true -&gt; Cols ++ [{4, "internal"}]; % add internal column
      false -&gt; Cols                      % keep original cols
  end,
  snmp_generic:table_func(set, RowIndex, NewCols, {empTable, mnesia});
emp_table(Op, RowIndex, Cols) -&gt;
  snmp_generic:table_func(Op, RowIndex, Cols, {empTable, mnesia}).

is_row_created(Name, Cols) -&gt;
  case snmp_generic:get_status_col(Name, Cols) of
    {ok, ?createAndGo} -&gt; true;
    {ok, ?createAndWait} -&gt; true;
    _ -&gt; false
  end.
      </code></pre><p>If a row is created, we always set the internal column to
<strong>"internal"</strong>.
</p><h3>Deviations from the Standard</h3><p>In some aspects the agent does not implement SNMP fully.  Here
are the differences:
</p><ul><li>The default functions and <strong>snmp_generic</strong> cannot handle an object of type <strong>NetworkAddress</strong> as INDEX (SNMPv1 only!).  Use <strong>IpAddress</strong> instead. </li><li>The agent does not check complex ranges specified for INTEGER objects.  In these cases it just checks that the value lies within the minimum and maximum values specified.  For example, if the range is specified as <strong>1..10 | 12..20</strong> the agent would let 11 through, but not 0 or 21.  The instrumentation functions must check the complex ranges itself. </li><li>The agent will never generate the <strong>wrongEncoding</strong> error.  If a variable binding is erroneous encoded, the <strong>asn1ParseError</strong> counter will be incremented. </li><li>A <strong>tooBig</strong> error in an SNMPv1 packet will always use the <strong>'NULL'</strong> value in all variable bindings. </li><li>The default functions and <strong>snmp_generic</strong> do not check the range of each OCTET in textual conventions derived from OCTET STRING, e.g. <strong>DisplayString</strong> and <strong>DateAndTime</strong>.  This must be checked in an overloaded <strong>is_set_ok</strong> function. </li></ul><h3>Appendix A</h3><p>This appendix describes the conversion of SNMPv2 to SNMPv1
error messages. The instrumentation functions should return v2
error messages.
</p><p>Mapping of SNMPv2 error message to SNMPv1:
</p><table class="table table-bordered table-hover table-striped"><caption>Error Messages</caption><tbody><tr><td>SNMPv2 message</td><td>SNMPv1 message</td></tr><tr><td>noError</td><td>noError</td></tr><tr><td>genErr</td><td>genErr</td></tr><tr><td>noAccess</td><td>noSuchName</td></tr><tr><td>wrongType</td><td>badValue</td></tr><tr><td>wrongLength</td><td>badValue</td></tr><tr><td>wrongEncoding</td><td>badValue</td></tr><tr><td>wrongValue</td><td>badValue</td></tr><tr><td>noCreation</td><td>noSuchName</td></tr><tr><td>inconsistentValue</td><td>badValue</td></tr><tr><td>resourceUnavailable</td><td>genErr</td></tr><tr><td>commitFailed</td><td>genErr</td></tr><tr><td>undoFailed</td><td>genErr</td></tr><tr><td>notWritable</td><td>noSuchName</td></tr><tr><td>inconsistentName</td><td>noSuchName</td></tr></tbody></table><h3>Appendix B</h3><h3>RowStatus (from RFC1903)</h3><pre>
RowStatus ::= TEXTUAL-CONVENTION
    STATUS       current
    DESCRIPTION
            "The RowStatus textual convention is used to manage the
            creation and deletion of conceptual rows, and is used as the
            value of the SYNTAX clause for the status column of a
            conceptual row (as described in Section 7.7.1 in RFC1902.)

            The status column has six defined values:

                 - `active', which indicates that the conceptual row is
                 available for use by the managed device;

                 - `notInService', which indicates that the conceptual
                 row exists in the agent, but is unavailable for use by
                 the managed device (see NOTE below);

                 - `notReady', which indicates that the conceptual row
                 exists in the agent, but is missing information
                 necessary in order to be available for use by the
                 managed device;

                 - `createAndGo', which is supplied by a management
                 station wishing to create a new instance of a
                 conceptual row and to have its status automatically set
                 to active, making it available for use by the managed
                 device;

                 - `createAndWait', which is supplied by a management
                 station wishing to create a new instance of a
                 conceptual row (but not make it available for use by
                 the managed device); and,

                 - `destroy', which is supplied by a management station
                 wishing to delete all of the instances associated with
                 an existing conceptual row.

            Whereas five of the six values (all except `notReady') may
            be specified in a management protocol set operation, only
            three values will be returned in response to a management
            protocol retrieval operation:  `notReady', `notInService' or
            `active'.  That is, when queried, an existing conceptual row
            has only three states:  it is either available for use by
            the managed device (the status column has value `active');
            it is not available for use by the managed device, though
            the agent has sufficient information to make it so (the
            status column has value `notInService'); or, it is not
            available for use by the managed device, and an attempt to
            make it so would fail because the agent has insufficient
            information (the state column has value `notReady').


                                     NOTE WELL

                 This textual convention may be used for a MIB table,
                 irrespective of whether the values of that table's
                 conceptual rows are able to be modified while it is
                 active, or whether its conceptual rows must be taken
                 out of service in order to be modified.  That is, it is
                 the responsibility of the DESCRIPTION clause of the
                 status column to specify whether the status column must
                 not be `active' in order for the value of some other
                 column of the same conceptual row to be modified.  If
                 such a specification is made, affected columns may be
                 changed by an SNMP set PDU if the RowStatus would not
                 be equal to `active' either immediately before or after
                 processing the PDU.  In other words, if the PDU also
                 contained a varbind that would change the RowStatus
                 value, the column in question may be changed if the
                 RowStatus was not equal to `active' as the PDU was
                 received, or if the varbind sets the status to a value
                 other than 'active'.


            Also note that whenever any elements of a row exist, the
            RowStatus column must also exist.

            To summarize the effect of having a conceptual row with a
            status column having a SYNTAX clause value of RowStatus,
            consider the following state diagram:


                                         STATE
              +--------------+-----------+-------------+-------------
              |      A       |     B     |      C      |      D
              |              |status col.|status column|
              |status column |    is     |      is     |status column
    ACTION    |does not exist|  notReady | notInService|  is active
--------------+--------------+-----------+-------------+-------------
set status    |noError    -&gt;D|inconsist- |inconsistent-|inconsistent-
column to     |       or     |   entValue|        Value|        Value
createAndGo   |inconsistent- |           |             |
              |         Value|           |             |
--------------+--------------+-----------+-------------+-------------
set status    |noError  see 1|inconsist- |inconsistent-|inconsistent-
column to     |       or     |   entValue|        Value|        Value
createAndWait |wrongValue    |           |             |
--------------+--------------+-----------+-------------+-------------
set status    |inconsistent- |inconsist- |noError      |noError
column to     |         Value|   entValue|             |
active        |              |           |             |
              |              |     or    |             |
              |              |           |             |
              |              |see 2   -&gt;D|          -&gt;D|          -&gt;D
--------------+--------------+-----------+-------------+-------------
set status    |inconsistent- |inconsist- |noError      |noError   -&gt;C
column to     |         Value|   entValue|             |
notInService  |              |           |             |
              |              |     or    |             |      or
              |              |           |             |
              |              |see 3   -&gt;C|          -&gt;C|wrongValue
--------------+--------------+-----------+-------------+-------------
set status    |noError       |noError    |noError      |noError
column to     |              |           |             |
destroy       |           -&gt;A|        -&gt;A|          -&gt;A|          -&gt;A
--------------+--------------+-----------+-------------+-------------
set any other |see 4         |noError    |noError      |see 5
column to some|              |           |             |
value         |              |      see 1|          -&gt;C|          -&gt;D
--------------+--------------+-----------+-------------+-------------

            (1) goto B or C, depending on information available to the
            agent.

            (2) if other variable bindings included in the same PDU,
            provide values for all columns which are missing but
            required, then return noError and goto D.

            (3) if other variable bindings included in the same PDU,
            provide values for all columns which are missing but
            required, then return noError and goto C.

            (4) at the discretion of the agent, the return value may be
            either:

                 inconsistentName:  because the agent does not choose to
                 create such an instance when the corresponding
                 RowStatus instance does not exist, or

                 inconsistentValue:  if the supplied value is
                 inconsistent with the state of some other MIB object's
                 value, or

                 noError: because the agent chooses to create the
                 instance.

            If noError is returned, then the instance of the status
            column must also be created, and the new state is B or C,
            depending on the information available to the agent.  If
            inconsistentName or inconsistentValue is returned, the row
            remains in state A.

            (5) depending on the MIB definition for the column/table,
            either noError or inconsistentValue may be returned.

            NOTE: Other processing of the set request may result in a
            response other than noError being returned, e.g.,
            wrongValue, noCreation, etc.


                              Conceptual Row Creation

            There are four potential interactions when creating a
            conceptual row:  selecting an instance-identifier which is
            not in use; creating the conceptual row; initializing any
            objects for which the agent does not supply a default; and,
            making the conceptual row available for use by the managed
            device.


            Interaction 1: Selecting an Instance-Identifier

            The algorithm used to select an instance-identifier varies
            for each conceptual row.  In some cases, the instance-
            identifier is semantically significant, e.g., the
            destination address of a route, and a management station
            selects the instance-identifier according to the semantics.

            In other cases, the instance-identifier is used solely to
            distinguish conceptual rows, and a management station
            without specific knowledge of the conceptual row might
            examine the instances present in order to determine an
            unused instance-identifier.  (This approach may be used, but
            it is often highly sub-optimal; however, it is also a
            questionable practice for a naive management station to
            attempt conceptual row creation.)

            Alternately, the MIB module which defines the conceptual row
            might provide one or more objects which provide assistance
            in determining an unused instance-identifier.  For example,
            if the conceptual row is indexed by an integer-value, then
            an object having an integer-valued SYNTAX clause might be
            defined for such a purpose, allowing a management station to
            issue a management protocol retrieval operation.  In order
            to avoid unnecessary collisions between competing management
            stations, `adjacent' retrievals of this object should be
            different.

            Finally, the management station could select a pseudo-random
            number to use as the index.  In the event that this index
            was already in use and an inconsistentValue was returned in
            response to the management protocol set operation, the
            management station should simply select a new pseudo-random
            number and retry the operation.

            A MIB designer should choose between the two latter
            algorithms based on the size of the table (and therefore the
            efficiency of each algorithm).  For tables in which a large
            number of entries are expected, it is recommended that a MIB
            object be defined that returns an acceptable index for
            creation.  For tables with small numbers of entries, it is
            recommended that the latter pseudo-random index mechanism be
            used.


            Interaction 2: Creating the Conceptual Row

            Once an unused instance-identifier has been selected, the
            management station determines if it wishes to create and
            activate the conceptual row in one transaction or in a
            negotiated set of interactions.

            Interaction 2a: Creating and Activating the Conceptual Row

            The management station must first determine the column
            requirements, i.e., it must determine those columns for
            which it must or must not provide values.  Depending on the
            complexity of the table and the management station's
            knowledge of the agent's capabilities, this determination
            can be made locally by the management station.  Alternately,
            the management station issues a management protocol get
            operation to examine all columns in the conceptual row that
            it wishes to create.  In response, for each column, there
            are three possible outcomes:

                 - a value is returned, indicating that some other
                 management station has already created this conceptual
                 row.  We return to interaction 1.

                 - the exception `noSuchInstance' is returned,
                 indicating that the agent implements the object-type
                 associated with this column, and that this column in at
                 least one conceptual row would be accessible in the MIB
                 view used by the retrieval were it to exist. For those
                 columns to which the agent provides read-create access,
                 the `noSuchInstance' exception tells the management
                 station that it should supply a value for this column
                 when the conceptual row is to be created.

                 - the exception `noSuchObject' is returned, indicating
                 that the agent does not implement the object-type
                 associated with this column or that there is no
                 conceptual row for which this column would be
                 accessible in the MIB view used by the retrieval.  As
                 such, the management station cannot issue any
                 management protocol set operations to create an
                 instance of this column.

            Once the column requirements have been determined, a
            management protocol set operation is accordingly issued.
            This operation also sets the new instance of the status
            column to `createAndGo'.

            When the agent processes the set operation, it verifies that
            it has sufficient information to make the conceptual row
            available for use by the managed device.  The information
            available to the agent is provided by two sources:  the
            management protocol set operation which creates the
            conceptual row, and, implementation-specific defaults
            supplied by the agent (note that an agent must provide
            implementation-specific defaults for at least those objects
            which it implements as read-only).  If there is sufficient
            information available, then the conceptual row is created, a
            `noError' response is returned, the status column is set to
            `active', and no further interactions are necessary (i.e.,
            interactions 3 and 4 are skipped).  If there is insufficient
            information, then the conceptual row is not created, and the
            set operation fails with an error of `inconsistentValue'.
            On this error, the management station can issue a management
            protocol retrieval operation to determine if this was
            because it failed to specify a value for a required column,
            or, because the selected instance of the status column
            already existed.  In the latter case, we return to
            interaction 1.  In the former case, the management station
            can re-issue the set operation with the additional
            information, or begin interaction 2 again using
            `createAndWait' in order to negotiate creation of the
            conceptual row.

                                     NOTE WELL

                 Regardless of the method used to determine the column
                 requirements, it is possible that the management
                 station might deem a column necessary when, in fact,
                 the agent will not allow that particular columnar
                 instance to be created or written.  In this case, the
                 management protocol set operation will fail with an
                 error such as `noCreation' or `notWritable'.  In this
                 case, the management station decides whether it needs
                 to be able to set a value for that particular columnar
                 instance.  If not, the management station re-issues the
                 management protocol set operation, but without setting
                 a value for that particular columnar instance;
                 otherwise, the management station aborts the row
                 creation algorithm.

            Interaction 2b: Negotiating the Creation of the Conceptual
            Row

            The management station issues a management protocol set
            operation which sets the desired instance of the status
            column to `createAndWait'.  If the agent is unwilling to
            process a request of this sort, the set operation fails with
            an error of `wrongValue'.  (As a consequence, such an agent
            must be prepared to accept a single management protocol set
            operation, i.e., interaction 2a above, containing all of the
            columns indicated by its column requirements.)  Otherwise,
            the conceptual row is created, a `noError' response is
            returned, and the status column is immediately set to either
            `notInService' or `notReady', depending on whether it has
            sufficient information to make the conceptual row available
            for use by the managed device.  If there is sufficient
            information available, then the status column is set to
            `notInService'; otherwise, if there is insufficient
            information, then the status column is set to `notReady'.
            Regardless, we proceed to interaction 3.

            Interaction 3: Initializing non-defaulted Objects

            The management station must now determine the column
            requirements.  It issues a management protocol get operation
            to examine all columns in the created conceptual row.  In
            the response, for each column, there are three possible
            outcomes:

                 - a value is returned, indicating that the agent
                 implements the object-type associated with this column
                 and had sufficient information to provide a value.  For
                 those columns to which the agent provides read-create
                 access (and for which the agent allows their values to
                 be changed after their creation), a value return tells
                 the management station that it may issue additional
                 management protocol set operations, if it desires, in
                 order to change the value associated with this column.

                 - the exception `noSuchInstance' is returned,
                 indicating that the agent implements the object-type
                 associated with this column, and that this column in at
                 least one conceptual row would be accessible in the MIB
                 view used by the retrieval were it to exist. However,
                 the agent does not have sufficient information to
                 provide a value, and until a value is provided, the
                 conceptual row may not be made available for use by the
                 managed device.  For those columns to which the agent
                 provides read-create access, the `noSuchInstance'
                 exception tells the management station that it must
                 issue additional management protocol set operations, in
                 order to provide a value associated with this column.

                 - the exception `noSuchObject' is returned, indicating
                 that the agent does not implement the object-type
                 associated with this column or that there is no
                 conceptual row for which this column would be
                 accessible in the MIB view used by the retrieval.  As
                 such, the management station cannot issue any
                 management protocol set operations to create an
                 instance of this column.

            If the value associated with the status column is
            `notReady', then the management station must first deal with
            all `noSuchInstance' columns, if any.  Having done so, the
            value of the status column becomes `notInService', and we
            proceed to interaction 4.

            Interaction 4: Making the Conceptual Row Available

            Once the management station is satisfied with the values
            associated with the columns of the conceptual row, it issues
            a management protocol set operation to set the status column
            to `active'.  If the agent has sufficient information to
            make the conceptual row available for use by the managed
            device, the management protocol set operation succeeds (a
            `noError' response is returned).  Otherwise, the management
            protocol set operation fails with an error of
            `inconsistentValue'.


                                     NOTE WELL

                 A conceptual row having a status column with value
                 `notInService' or `notReady' is unavailable to the
                 managed device.  As such, it is possible for the
                 managed device to create its own instances during the
                 time between the management protocol set operation
                 which sets the status column to `createAndWait' and the
                 management protocol set operation which sets the status
                 column to `active'.  In this case, when the management
                 protocol set operation is issued to set the status
                 column to `active', the values held in the agent
                 supersede those used by the managed device.

            If the management station is prevented from setting the
            status column to `active' (e.g., due to management station
            or network failure) the conceptual row will be left in the
            `notInService' or `notReady' state, consuming resources
            indefinitely.  The agent must detect conceptual rows that
            have been in either state for an abnormally long period of
            time and remove them.  It is the responsibility of the
            DESCRIPTION clause of the status column to indicate what an
            abnormally long period of time would be.  This period of
            time should be long enough to allow for human response time
            (including `think time') between the creation of the
            conceptual row and the setting of the status to `active'.
            In the absence of such information in the DESCRIPTION
            clause, it is suggested that this period be approximately 5
            minutes in length.  This removal action applies not only to
            newly-created rows, but also to previously active rows which
            are set to, and left in, the notInService state for a
            prolonged period exceeding that which is considered normal
            for such a conceptual row.


                             Conceptual Row Suspension

            When a conceptual row is `active', the management station
            may issue a management protocol set operation which sets the
            instance of the status column to `notInService'.  If the
            agent is unwilling to do so, the set operation fails with an
            error of `wrongValue'.  Otherwise, the conceptual row is
            taken out of service, and a `noError' response is returned.
            It is the responsibility of the DESCRIPTION clause of the
            status column to indicate under what circumstances the
            status column should be taken out of service (e.g., in order
            for the value of some other column of the same conceptual
            row to be modified).


                              Conceptual Row Deletion

            For deletion of conceptual rows, a management protocol set
            operation is issued which sets the instance of the status
            column to `destroy'.  This request may be made regardless of
            the current value of the status column (e.g., it is possible
            to delete conceptual rows which are either `notReady',
            `notInService' or `active'.)  If the operation succeeds,
            then all instances associated with the conceptual row are
            immediately removed."


    SYNTAX       INTEGER {
                     -- the following two values are states:
                     -- these values may be read or written
                     active(1),
                     notInService(2),

                     -- the following value is a state:
                     -- this value may be read, but not written
                     notReady(3),

                     -- the following three values are
                     -- actions: these values may be written,
                     --   but are never read
                     createAndGo(4),
                     createAndWait(5),
                     destroy(6)
                 }
      </pre></body></html>