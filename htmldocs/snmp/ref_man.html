<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>SNMP Reference Manual</h1><p>A multilingual Simple Network Management Protocol 
application featuring an Extensible Agent, simple manager,
a MIB compiler and facilities for implementing SNMP MIBs etc.
</p><h2>snmp</h2><p>Interface functions to the SNMP toolkit</p><p>The module <strong>snmp</strong> contains interface functions to the 
SNMP toolkit.</p><h3>Common Data Types</h3><p>The following data-types are used in the functions below: </p><ul><li> <p><strong>datetime() = {date(), time()}</strong></p> <p>See <a href="./calendar">calendar</a> 
for more info.</p> </li></ul><a name="config"></a><h2>Functions</h2><h3>config() -&gt; ok | {error, Reason}</h3><p>Configure with a simple interactive tool</p><p>A simple interactive configuration tool. Simple
configuration files can be generated, but more complex
configurations still have to be edited manually.
</p><p>The tool is a textual based tool that asks some questions
and generates <strong>sys.config</strong> and <strong>*.conf</strong> files.
</p><p><em>Note</em> that if the application shall support version 3, 
then the crypto app must be started before running this function 
(password generation).</p><p><em>Note</em> also that some of the configuration files for the 
agent and manager share the same names. This means that 
they have to be stored in <em>different</em> directories!</p><a name="start"></a><h3>start() -&gt; ok | {error, Reason}</h3><h3>start(Type) -&gt; ok | {error, Reason}</h3><p>Start the SNMP application</p><ul><li><span class="v">Type = start_type()</span></li></ul><p>Starts the SNMP application.</p><p>See <a href="./application">application</a> for more info.</p><a name="start_agent"></a><h3>start_agent() -&gt; ok | {error, Reason}</h3><h3>start_agent(Type) -&gt; ok | {error, Reason}</h3><p>Start the agent part of the SNMP application</p><ul><li><span class="v">Type = start_type()</span></li></ul><p>The SNMP application consists of several entities, of which the
agent is one. This function starts the agent entity of the 
application. 
</p><p>Note that the only way to actually start the agent in this way is
to add the agent related config after starting the application (e.g
it cannot be part of the normal application config; sys.config).
This is done by calling: 
<strong>application:set_env(snmp, agent, Conf)</strong>.
</p><p>The default value for <strong>Type</strong> is <strong>normal</strong>.</p><a name="start_manager"></a><h3>start_manager() -&gt; ok | {error, Reason}</h3><h3>start_manager(Type) -&gt; ok | {error, Reason}</h3><p>Start the manager part of the SNMP application</p><ul><li><span class="v">Type = start_type()</span></li></ul><p>The SNMP application consists of several entities, of which the
manager is one. This function starts the manager entity of the 
application. 
</p><p>Note that the only way to actually start the manager in this way is
to add the manager related config after starting the application (e.g
it cannot be part of the normal application config; sys.config).
This is done by calling: 
<strong>application:set_env(snmp, manager, Conf)</strong>.
</p><p>The default value for <strong>Type</strong> is <strong>normal</strong>.</p><a name="dat"></a><h3>date_and_time() -&gt; DateAndTime</h3><p>Return the current date and time as an OCTET STRING</p><ul><li><span class="v">DateAndTime = [int()]</span></li></ul><p>Returns current date and time as the data type DateAndTime,
as specified in RFC1903. This is an OCTET STRING.</p><a name="dat2ut_dst"></a><h3>date_and_time_to_universal_time_dst(DateAndTime) -&gt; [utc()]</h3><p>Convert a DateAndTime value to a list of possible utc()</p><ul><li><span class="v">DateAndTime = [int()]</span></li><li><span class="v">utc() = {{Y,Mo,D},{H,M,S}}</span></li></ul><p>Converts a DateAndTime list to a list of possible universal 
time(s). The universal time value on the same format as defined in
calendar(3). </p><a name="dat2s"></a><h3>date_and_time_to_string(DateAndTime) -&gt; string()</h3><h3>date_and_time_to_string(DateAndTime, Validate) -&gt; string()</h3><p>Convert a DateAndTime value to a string</p><ul><li><span class="v">DateAndTime = [int()]</span></li><li><span class="v">Validate = fun(Kind, Data) -&gt; boolean()</span></li></ul><p>Converts a DateAndTime list to a printable string, according
to the DISPLAY-HINT definition in RFC2579.</p><p>The validation fun,  <strong>Validate</strong>, allows for a more "flexible" 
validation of the <strong>DateAndTime</strong> argument. Whenever the data 
is found to not follow RFC2579, the fun is called to allow a more
"lax" validation. 
See the <a href="#vdat">validate_date_and_time/2</a> 
function for more info on the <strong>Validate</strong> fun. </p><a name="dat2s2"></a><h3>date_and_time_to_string2(DateAndTime) -&gt; string()</h3><p>Convert a DateAndTime value to a string</p><ul><li><span class="v">DateAndTime = [int()]</span></li></ul><p>Converts a DateAndTime list to a printable string, according
to the DISPLAY-HINT definition in RFC2579, with the extension 
that it also allows the values "hours from UTC" = 14 together with 
"minutes from UTC" = 0. </p><a name="lt2dat_dst"></a><h3>local_time_to_date_and_time_dst(Local) -&gt; [DateAndTime]</h3><p>Convert a Local time value to a list of possible DateAndTime(s)</p><ul><li><span class="v">Local = {{Y,Mo,D},{H,M,S}}</span></li><li><span class="v">DateAndTime = [int()]</span></li></ul><p>Converts a local time value to a list of possible DateAndTime 
list(s). The local time value on the same format as defined in 
calendar(3).</p><a name="ut2dat"></a><h3>universal_time_to_date_and_time(UTC) -&gt; DateAndTime</h3><p>Convert a UTC value to DateAndTime</p><ul><li><span class="v">UTC = {{Y,Mo,D},{H,M,S}}</span></li><li><span class="v">DateAndTime = [int()]</span></li></ul><p>Converts a universal time value to a DateAndTime list.  The
universal time value on the same format as defined in calendar(3).</p><a name="vdat"></a><h3>validate_date_and_time(DateAndTime) -&gt; bool()</h3><h3>validate_date_and_time(DateAndTime, Validate) -&gt; bool()</h3><p>Check if a DateAndTime value is correct</p><ul><li><span class="v">DateAndTime = term()</span></li><li><span class="v">Validate = fun(Kind, Data) -&gt; boolean()</span></li></ul><p>Checks if <strong>DateAndTime</strong> is a correct DateAndTime
value, as specified in RFC2579.  This function can be used in
instrumentation functions to validate a DateAndTime value.</p><p>The validation fun,  <strong>Validate</strong>, allows for a more "flexible" 
validation of the <strong>DateAndTime</strong> argument. Whenever the data 
is found to not follow RFC2579, the fun is called to allow a more
"lax" validation. 
The input to the validation fun looks like this: </p><pre>
          Kind             Data
          --------------   ----------------------
          year             {Year1, Year2}
          month            Month
          day              Day
          hour             Hour
          minute           Minute
          seconds          Seconds
          deci_seconds     DeciSeconds
          diff             [Sign, Hour, Minute]
          valid_date       {Year, Month, Day}
	</pre><a name="passwd2localized_key"></a><h3>passwd2localized_key(Alg, Passwd, EngineID) -&gt; Key</h3><p>Generates an localized key</p><ul><li><span class="v">Alg = algorithm()</span></li><li><span class="v">algorithm() = md5 | sha</span></li><li><span class="v">Passwd = string()</span></li><li><span class="v">EngineID = string()</span></li><li><span class="v">Key = list()</span></li></ul><p>Generates a key that can be used as an authentication
or privacy key using MD5 och SHA.  The key is
localized for EngineID.</p><a name="octet_string_to_bits"></a><h3>octet_string_to_bits(S) -&gt; Val</h3><p>Convert an OCTET-STRING to BITS</p><ul><li><span class="v">Val = bits()</span></li></ul><p>Utility function for converting a value of type 
<strong>OCTET-STRING</strong> to <strong>BITS</strong>. </p><a name="bits_to_octet_string"></a><h3>bits_to_octet_string(B) -&gt; Val</h3><p>Convert an OCTET-STRING to BITS</p><ul><li><span class="v">Val = octet_string()</span></li></ul><p>Utility function for converting a value of type <strong>BITS</strong> 
to <strong>OCTET-STRING</strong>. </p><a name="read_mib"></a><h3>read_mib(FileName) -&gt; {ok, mib()} | {error, Reason}</h3><ul><li><span class="v">FileName = string()</span></li><li><span class="v">mib() = #mib{}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Read a compiled mib.</p><a name="log_to_txt"></a><h3>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile) -&gt;  ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block | Start) -&gt;  ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Start, Block | Stop) -&gt; ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Start, Stop, Block) -&gt; ok | {ok, Cnt} | {error, Reason}</h3><p>Convert an Audit Trail Log to text format</p><ul><li><span class="v">LogDir = string()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">OutFile = string()</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">LogName = string()</span></li><li><span class="v">LogFile = string()</span></li><li><span class="v">Start = Stop = null | datetime() | {local_time,datetime()} |  {universal_time,datetime()} </span></li><li><span class="v">Block = boolean()</span></li><li><span class="v">Cnt = {NumOK, NumERR}</span></li><li><span class="v">NumOK = non_neg_integer()</span></li><li><span class="v">NumERR = pos_integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Converts an Audit Trail Log to a readable text file, where
each item has a trailing TAB character, and any TAB
character in the body of an item has been replaced by ESC
TAB. </p><p>The function can be used on a running system, or by copying
the entire log directory and calling this function. SNMP
must be running in order to provide MIB information. </p><p><strong>LogDir</strong> is the name of the directory where the audit
trail log is stored. 
<strong>Mibs</strong> is a list of Mibs to be used. The function uses 
the information in the Mibs to convert for example object 
identifiers to their symbolic name. 
<strong>OutFile</strong> is the name of the generated text-file.
<strong>LogName</strong> is the name of the log, 
<strong>LogFile</strong> is the name of the log file. 
<strong>Start</strong> is the start (first) date and time from which 
log events will be converted and 
<strong>Stop</strong> is the stop (last) date and time to which log 
events will be converted.
The <strong>Block</strong> argument indicates if the log should be blocked
during conversion. This could be usefull when converting large 
logs (when otherwise the log could wrap during conversion). 
Defaults to <strong>true</strong>. 
</p><p>The format of an audit trail log text item is as follows: </p><p><strong>Tag Addr - Community [TimeStamp] Vsn</strong><br/>
<strong>PDU</strong></p><p>where <strong>Tag</strong> is <strong>request</strong>, <strong>response</strong>, 
<strong>report</strong>, <strong>trap</strong> or <strong>inform</strong>; Addr is 
<strong>IP:Port</strong> (or comma space separated list of such);
<strong>Community</strong> is the community parameter (SNMP version
v1 and v2), or <strong>SecLevel:"AuthEngineID":"UserName"</strong>
(SNMP v3); <strong>TimeStamp</strong> is a date and time stamp,
and <strong>Vsn</strong> is the SNMP version. <strong>PDU</strong> is a textual
version of the protocol data unit. There is a new line
between <strong>Vsn</strong> and <strong>PDU</strong>.</p><p>If the entire log is successfully converted, the function 
will return <strong>ok</strong>. 
If one of more entries fail to convert, the function will instead
return <strong>{ok, {NumOK, NumERR}}</strong>, where the counters indicate
how many valid and erroneous entries where found. 
If instead <strong>{error, Reason}</strong> is returned, the conversion 
encountered a fatal error and where either never done of aborted
midway. </p><a name="log_to_io"></a><h3>log_to_io(LogDir, Mibs, LogName, LogFile) -&gt;  ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_io(LogDir, Mibs, LogName, LogFile, Block | Start) -&gt;  ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_io(LogDir, Mibs, LogName, LogFile, Start, Block | Stop) -&gt; ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_io(LogDir, Mibs, LogName, LogFile, Start, Stop, Block) -&gt; ok | {ok, Cnt} | {error, Reason}</h3><p>Convert an Audit Trail Log to text format</p><ul><li><span class="v">LogDir = string()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">LogName = string()</span></li><li><span class="v">LogFile = string()</span></li><li><span class="v">Start = Stop = null | datetime() | {local_time,datetime()} |  {universal_time,datetime()} </span></li><li><span class="v">Cnt = {NumOK, NumERR}</span></li><li><span class="v">NumOK = non_neg_integer()</span></li><li><span class="v">NumERR = pos_integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Converts an Audit Trail Log to a readable format and 
prints it on stdio. See 
<a href="./snmp#log_to_txt">log_to_txt</a> 
above for more info.</p><a name="change_log_size"></a><h3>change_log_size(LogName, NewSize) -&gt; ok | {error, Reason}</h3><p>Change the size of the Audit Trail Log</p><ul><li><span class="v">LogName = string()</span></li><li><span class="v">NewSize = {MaxBytes, MaxFiles}</span></li><li><span class="v">MaxBytes = integer()</span></li><li><span class="v">MaxFiles = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Changes the log size of the Audit Trail Log.  The
application must be configured to use the audit trail log
function. Please refer to disk_log(3) in Kernel Reference 
Manual for a description of how to change the log size.
</p><p>The change is permanent, as long as the log is not deleted. 
That means, the log size is remembered across reboots.</p><a name="print_version_info"></a><h3>print_version_info() -&gt; void()</h3><h3>print_version_info(Prefix) -&gt; void()</h3><p>Formatted print of result of the versions functions</p><ul><li><span class="v">Prefix = string() | integer()</span></li></ul><p>Utility function(s) to produce a formatted printout of the versions
info generated by the <strong>versions1</strong> function</p><p>This is the same as doing, e.g.: </p><pre>
           {ok, V} = snmp:versions1(), 
           snmp:print_versions(V).
        </pre><a name="versions1"></a><a name="versions2"></a><h3>versions1() -&gt; {ok, Info} | {error, Reason}</h3><h3>versions2() -&gt; {ok, Info} | {error, Reason}</h3><p>Retrieve various system and application info</p><ul><li><span class="v">Info = [info()]</span></li><li><span class="v">info() = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Utility functions used to retrieve some system and
application info.</p><p>The difference between the two functions is in how they get
the modules to check. <strong>versions1</strong> uses the app-file and
<strong>versions2</strong> uses the function <strong>application:get_key</strong>.</p><a name="print_versions"></a><h3>print_versions(VersionInfo) -&gt; void()</h3><h3>print_versions(Prefix, VersionInfo) -&gt; void()</h3><p>Formatted print of result of the versions functions</p><ul><li><span class="v">VersionInfo = [version_info()]</span></li><li><span class="v">version_info() = term()</span></li><li><span class="v">Prefix = string() | integer()</span></li></ul><p>Utility function to produce a formatted printout of the versions
info generated by the <strong>versions1</strong> and <strong>versions2</strong>
functions</p><p>Example: </p><pre>
           {ok, V} = snmp:versions1(), 
           snmp:print_versions(V).
        </pre><a name="enable_trace"></a><h3>enable_trace() -&gt; void()</h3><p>Starts a tracer</p><p>Starts a dbg tracer that prints trace events to stdout (using
plain io:format after a minor formatting). </p><a name="disable_trace"></a><h3>disable_trace() -&gt; void()</h3><p>Stop the tracer</p><p>Stop the tracer. </p><a name="set_trace1"></a><h3>set_trace(Targets) -&gt; void()</h3><p>Set trace target</p><ul><li><span class="v">Targets = target() | targets()</span></li><li><span class="v">target() = module()</span></li><li><span class="v">module() = atom()</span></li><li><span class="v">targets() = [target() | {target(), target_options()}]</span></li><li><span class="v">target_options() = [target_option()]</span></li><li><span class="v">target_option() = {return_trace, boolean()} | {scope, scope()}</span></li><li><span class="v">scope() = all_functions | exported_functions | function_name() | {function_name(), function_arity()}</span></li><li><span class="v">function_name() = atom()</span></li><li><span class="v">function_arity() = integer() &gt;= 0</span></li></ul><p>This function is used to set up default trace on function(s) 
for the given module or modules. The scope of the trace will be 
all <em>exported</em> functions (both the call info and the return 
value). Timestamp info will also be included. </p><a name="reset_trace"></a><h3>reset_trace(Targets) -&gt; void()</h3><p>Reset trace target</p><ul><li><span class="v">Targets = module() | modules()</span></li><li><span class="v">modules() = [module()]</span></li><li><span class="v">module() = atom()</span></li></ul><p>This function is used to reset (disable) trace for the 
given module(s). </p><a name="set_trace2"></a><h3>set_trace(Targets, Opts) -&gt; void()</h3><p>Set trace target</p><ul><li><span class="v">Targets = target() | targets()</span></li><li><span class="v">target() = module()</span></li><li><span class="v">module() = atom()</span></li><li><span class="v">targets() = [target() | {target(), target_options()}]</span></li><li><span class="v">target_options() = [target_option()]</span></li><li><span class="v">target_option() = {return_trace, boolean()} | {scope, scope()}</span></li><li><span class="v">scope() = all_functions | exported_functions | function_name() | {function_name(), function_arity()}</span></li><li><span class="v">function_name() = atom()</span></li><li><span class="v">function_arity() = integer() &gt;= 0</span></li><li><span class="v">Opts = disable | trace_options()</span></li><li><span class="v">trace_options() = [trace_option()]</span></li><li><span class="v">trace_option() = {timestamp, boolean()} | target_option()</span></li></ul><p>This function is used to set up trace on function(s) for the given
module or modules. </p><p>The example below sets up trace on the exported functions (default) 
of module <strong>snmp_generic</strong> and all functions of module 
<strong>snmp_generic_mnesia</strong>. With return values (which is default)
and timestamps in both cases (which is also default): </p><pre>
	  snmp:enable_trace(),
	  snmp:set_trace([snmp_generic, 
                          {snmp_generic_mnesia, [{scope, all_functions}]}]),
	  .
	  .
	  .
          snmp:set_trace(snmp_generic, disable),
	  .
	  .
	  .
	  snmp:disable_trace(),
	</pre><h3>See Also</h3><p>calendar(3)
</p><h2>snmp</h2><p>The SNMP Application</p><p>This chapter describes the <strong>snmp</strong>
application in OTP.  The SNMP application provides the following
services:<ul><li> <p>a multilingual extensible SNMP agent</p> </li><li> <p>a SNMP manager</p> </li><li> <p>a MIB compiler</p> </li></ul></p><a name="configuration_params"></a><h3>Configuration</h3><p>The following configuration parameters are defined for the SNMP
application. Refer to application(3) for more information about
configuration parameters.
</p><p>The snmp part of the config file specifying the configuration 
parameters is basically the following tuple:</p><pre>
      {snmp, snmp_components_config()}
    </pre><p>A minimal config file for starting a node with both a manager 
and an agent:</p><pre>
      [{snmp, 
        [{agent, [{db_dir, "/tmp/snmp/agent/db"},
                  {config, [{dir, "/tmp/snmp/agent/conf"}]}]},
         {manager, [{config, [{dir, "/tmp/snmp/manager/conf"},
                              {db_dir, "/tmp/snmp/manager/db"}]}]}]}
        ]
       }
      ].
    </pre><p>Each snmp component has its own set of configuration parameters,
even though some of the types are common to both components. </p><pre>
      snmp_components_config() -&gt; [snmp_component_config()]
      snmp_component_config() -&gt; {agent, agent_options()} | {manager, manager_options()}
      agent_options() = [agent_option()]
      agent_option() = {restart_type,     restart_type()}     | 
                       {agent_type,       agent_type()}       |  
                       {agent_verbosity,  verbosity()}        |  
                       {discovery,        agent_discovery()}  |  
                       {versions,         versions()}         |  
                       {gb_max_vbs,       gb_max_vbs()}       |  
                       {priority,         priority()}         |  
                       {multi_threaded,   multi_threaded()}   |  
                       {db_dir,           db_dir()}           |  
                       {db_init_error,    db_init_error()}    |  
                       {local_db,         local_db()}         |  
                       {net_if,           agent_net_if()}     |  
                       {mibs,             mibs()}             |  
                       {mib_storage,      mib_storage()}      |  
                       {mib_server,       mib_server()}       |  
                       {audit_trail_log,  audit_trail_log()}  |  
                       {error_report_mod, error_report_mod()} |  
                       {note_store,       note_store()}       |  
                       {symbolic_store,   symbolic_store()}   |  
                       {target_cache,     target_cache()}     |  
                       {config,           agent_config()}
      manager_options() = [manager_option()]
      manager_option() = {restart_type,             restart_type()}    | 
                         {net_if,                   manager_net_if()}  |  
                         {server,                   server()}          | 
                         {note_store,               note_store()}      | 
                         {config,                   manager_config()}  |  
                         {inform_request_behaviour, manager_irb()}     | 
                         {mibs,                     manager_mibs()}    | 
                         {priority,                 priority()}        |  
                         {audit_trail_log,          audit_trail_log()} | 
                         {versions,                 versions()}        | 
                         {def_user_mod,             def_user_module()  | 
                         {def_user_data,            def_user_data()}
    </pre><a name="agent_opts_and_types"></a><p>Agent specific config options and types:</p><dl><dt><a name="agent_type"></a> <strong>agent_type() = master | sub &lt;optional&gt;</strong></dt><dd> <p>If <strong>master</strong>, one master agent is
started. Otherwise, no agents are started. </p> <p>Default is <strong>master</strong>.</p> </dd><dt><a name="agent_disco"></a> <strong>agent_discovery() = [agent_discovery_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_discovery_opt() =  {terminating, agent_terminating_discovery_opts()} |  {originating, agent_originating_discovery_opts()}</strong></p> <p>The <strong>terminating</strong> options effects discovery initiated by 
a manager. </p> <p>The <strong>originating</strong> options effects discovery initiated 
by this agent. </p> <p>For defaults see the options in <strong>agent_discovery_opt()</strong>.</p> </dd><dt><a name="agent_term_disco_opts"></a> <strong>agent_terminating_discovery_opts() = [agent_terminating_discovery_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_terminating_discovery_opt() =  {enable, boolean()} |  {stage2, discovery | plain} |  {trigger_username, string()}</strong></p> <p>These are options effecting discovery <strong>terminating</strong> in this
agent (i.e. initiated by a manager). </p> <p>The default values for the <strong>terminating</strong> 
discovery options are: </p> <ul><li>enable: <strong>true</strong></li><li>stage2: <strong>discovery</strong></li><li>trigger_username: <strong>""</strong></li></ul> </dd><dt><a name="agent_orig_disco_opts"></a> <strong>agent_originating_discovery_opts() = [agent_originating_discovery_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_originating_discovery_opt() =  {enable, boolean()}</strong></p> <p>These are options effecting discovery <strong>originating</strong> in this
agent. </p> <p>The default values for the <strong>originating</strong> 
discovery options are: </p> <ul><li>enable: <strong>true</strong></li></ul> </dd><dt><a name="agent_mt"></a> <strong>multi_threaded() = bool() &lt;optional&gt;</strong></dt><dd> <p>If <strong>true</strong>, the agent is multi-threaded, with one
thread for each get request. </p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="agent_data_dir"></a> <strong>db_dir() = string() &lt;mandatory&gt;</strong></dt><dd> <p>Defines where the SNMP agent internal db files are stored.</p> </dd><dt><a name="agent_gb_max_vbs"></a> <strong>gb_max_vbs() = pos_integer() | infinity &lt;optional&gt;</strong></dt><dd> <p>Defines the maximum number of varbinds allowed 
in a Get-BULK response.</p> <p>Default is <strong>1000</strong>.</p> </dd><dt><a name="agent_local_db"></a> <strong>local_db() = [local_db_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>local_db_opt() = {repair, agent_repair()} | {auto_save, agent_auto_save()} |   {verbosity, verbosity()}</strong></p> <p>Defines options specific for the SNMP agent local database.</p> <p>For defaults see the options in <strong>local_db_opt()</strong>.</p> </dd><dt><a name="agent_ldb_repair"></a> <strong>agent_repair() = false | true | force &lt;optional&gt;</strong></dt><dd> <p>When starting snmpa_local_db it always tries to open an
existing database. If <strong>false</strong>, and some errors occur, a new
database is created instead. If <strong>true</strong>, an existing file
will be repaired. If <strong>force</strong>, the table will be repaired
even if it was properly closed. </p> <p>Default is <strong>true</strong>.</p> </dd><dt><a name="agent_ldb_auto_save"></a> <strong>agent_auto_save() = integer() | infinity &lt;optional&gt;</strong></dt><dd> <p>The auto save interval. The table is flushed to disk
whenever not accessed for this amount of time.</p> <p>Default is <strong>5000</strong>.</p> </dd><dt><a name="agent_net_if"></a> <strong>agent_net_if() = [agent_net_if_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_net_if_opt() = {module, agent_net_if_module()} |  {verbosity, verbosity()} |  {options, agent_net_if_options()}</strong></p> <p>Defines options specific for the SNMP agent network interface 
entity. </p> <p>For defaults see the options in <strong>agent_net_if_opt()</strong>.</p> </dd><dt><a name="agent_ni_module"></a> <strong>agent_net_if_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>Module which handles the network interface part for the
SNMP agent. Must implement the 
<a href="snmpa_network_interface">snmpa_network_interface</a> behaviour.</p> <p>Default is <strong>snmpa_net_if</strong>.</p> </dd><dt><a name="agent_ni_opts"></a> <strong>agent_net_if_options() = [agent_net_if_option()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_net_if_option() = {bind_to, bind_to()} |   {sndbuf, sndbuf()} |   {recbuf, recbuf()} |   {no_reuse, no_reuse()} |   {req_limit, req_limit()} | {filter, agent_net_if_filter_options()}</strong></p> <p>These options are actually specific to the used module.
The ones shown here are applicable to the default 
<strong>agent_net_if_module()</strong>.</p> <p>For defaults see the options in <strong>agent_net_if_option()</strong>.</p> </dd><dt><a name="agent_ni_req_limit"></a> <strong>req_limit() = integer() | infinity &lt;optional&gt;</strong></dt><dd> <p>Max number of simultaneous requests handled by the agent.</p> <p>Default is <strong>infinity</strong>.</p> </dd><dt><a name="agent_ni_filter_opts"></a> <strong>agent_net_if_filter_options() = [agent_net_if_filter_option()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_net_if_filter_option() = {module, agent_net_if_filter_module()}</strong></p> <p>These options are actually specific to the used module.
The ones shown here are applicable to the default 
<strong>agent_net_if_filter_module()</strong>.</p> <p>For defaults see the options in 
<strong>agent_net_if_filter_option()</strong>.</p> </dd><dt><a name="agent_ni_filter_module"></a> <strong>agent_net_if_filter_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>Module which handles the network interface filter part for the
SNMP agent. Must implement the 
<a href="snmpa_network_interface_filter">snmpa_network_interface_filter</a> behaviour.</p> <p>Default is <strong>snmpa_net_if_filter</strong>.</p> </dd><dt><a name="agent_mibs"></a> <strong>agent_mibs() = [string()] &lt;optional&gt;</strong></dt><dd> <p>Specifies a list of MIBs (including path) that defines which MIBs
are initially loaded into the SNMP master agent. </p> <p>Note that the following mibs will always be loaded:</p> <ul><li>version v1: <strong>STANDARD-MIB</strong></li><li>version v2: <strong>SNMPv2</strong></li><li>version v3: <strong>SNMPv2</strong>, <strong>SNMP-FRAMEWORK-MIB</strong>  and <strong>SNMP-MPD-MIB</strong></li></ul> <p>Default is <strong>[]</strong>.</p> </dd><dt><a name="agent_mib_storage"></a> <strong>mib_storage() = [mib_storage_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>mib_storage_opt() = {module, mib_storage_module()} |  {options, mib_storage_options()}</strong></p> <p>This option specifies how basic mib data is stored. 
This option is used by two parts of the snmp agent: 
The mib-server and the symbolic-store. </p> <p>Default is <strong>[{module, snmpa_mib_storage_ets}]</strong>. </p> </dd><dt><a name="agent_mst_module"></a> <strong>mib_storage_module() = snmpa_mib_data_ets | snmpa_mib_data_dets | snmpa_mib_data_mnesia | module()</strong></dt><dd> <p>Defines the mib storage module of the SNMP agent as defined by the 
<a href="snmpa_mib_storage">snmpa_mib_storage</a> 
behaviour. </p> <p>Several entities (<strong>mib-server</strong> via the its data module and 
the <strong>symbolic-store</strong>) of the snmp agent uses this for storage 
of miscelaneous mib related data retrieved while loading a mib. </p> <p>There are several implementations provided with the agent: 
<strong>snmpa_mib_storage_ets</strong>, <strong>snmpa_mib_storage_dets</strong> and 
<strong>snmpa_mib_storage_mnesia</strong>. </p> <p>Default module is <strong>snmpa_mib_storage_ets</strong>. </p> </dd><dt><a name="agent_mst_options"></a> <strong>mib_storage_options() = list() &lt;optional&gt;</strong></dt><dd> <p>This is implementattion depended. That is, it depends on the 
module. For each module a specific set of options are valid. 
For the module provided with the app, these options are supported: </p> <ul><li> <p><strong>snmpa_mib_storage_ets</strong>: <strong>{dir, filename()} | {action, keep | clear}, {checksum, boolean()}</strong></p> <ul><li> <p><strong>dir</strong> - If present, points to a directory where a file 
to which all data in the ets table is "synced". </p> <p>Also, when a table is opened this file is read, 
if it exists. </p> <p>By default, this will <em>not</em> be used. </p>  </li><li> <p><strong>action</strong> - Specifies the behaviour when a non-empty 
file is found: Keep its content or clear it out. </p> <p>Default is <strong>keep</strong>. </p>  </li><li> <p><strong>checksum</strong> - Defines if the file is checksummed 
or not. </p> <p>Default is <strong>false</strong>. </p>  </li></ul> </li><li> <p><strong>snmpa_mib_storage_dets</strong>: <strong>{dir, filename()} | {action, keep | clear}, {auto_save, default | pos_integer()} | {repair, force | boolean()}</strong></p> <ul><li> <p><strong>dir</strong> - This <em>mandatory</em> option points to a 
directory where to place the file of a dets table. </p> </li><li> <p><strong>action</strong> - Specifies the behaviour when a non-empty 
file is found: Keep its content or clear it out. </p> <p>Default is <strong>keep</strong>. </p>  </li><li> <p><strong>auto_save</strong> - Defines the dets auto-save frequency. </p> <p>Default is <strong>default</strong>. </p>  </li><li> <p><strong>repair</strong> - Defines the dets repair behaviour. </p> <p>Default is <strong>false</strong>. </p>  </li></ul> </li><li> <p><strong>snmpa_mib_storage_mnesia</strong>: <strong>{action, keep | clear}, {nodes, [node()]}</strong></p> <ul><li> <p><strong>action</strong> - Specifies the behaviour when a non-empty, 
already existing, table: Keep its content or clear it out. </p> <p>Default is <strong>keep</strong>. </p> </li><li> <p><strong>nodes</strong> - A list of node names (or an atom 
describing a list of nodes) defining where to open the table. 
Its up to the user to ensure that mnesia is actually running 
on the specified nodes. </p> <p>The following distinct values are recognised: </p> <ul><li> <p><strong>[]</strong> - Translated into a list of the own node: <strong>[node()]</strong></p> </li><li> <p><strong>all</strong> - <strong>erlang:nodes()</strong></p> </li><li> <p><strong>visible</strong> - <strong>erlang:nodes(visible)</strong></p> </li><li> <p><strong>connected</strong> - <strong>erlang:nodes(connected)</strong></p> </li><li> <p><strong>db_nodes</strong> - <strong>mnesia:system_info(db_nodes)</strong></p> </li></ul> <p>Default is the result of the call: <strong>erlang:nodes()</strong>. </p> </li></ul> </li></ul> </dd><dt><a name="agent_mib_server"></a> <strong>mib_server() = [mib_server_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>mib_server_opt() = {mibentry_override, mibentry_override()} |  {trapentry_override, trapentry_override()} |  {verbosity, verbosity()} | {cache, mibs_cache()} | {data_module, mib_server_data_module()}</strong></p> <p>Defines options specific for the SNMP agent mib server. </p> <p>For defaults see the options in <strong>mib_server_opt()</strong>.</p> </dd><dt><a name="agent_ms_meo"></a> <strong>mibentry_override() = bool() &lt;optional&gt;</strong></dt><dd> <p>If this value is false, then when loading a mib each mib-
entry is checked prior to installation of the mib. 
The purpose of the check is to prevent that the same symbolic 
mibentry name is used for different oid's.</p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="agent_ms_teo"></a> <strong>trapentry_override() = bool() &lt;optional&gt;</strong></dt><dd> <p>If this value is false, then when loading a mib each trap
is checked prior to installation of the mib. 
The purpose of the check is to prevent that the same symbolic 
trap name is used for different trap's.</p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="agent_ms_data_module"></a> <strong>mib_server_data_module() = snmpa_mib_data_tttn | module() &lt;optional&gt;</strong></dt><dd> <p>Defines the backend data module of the SNMP agent mib-server as 
defined by the 
<a href="snmpa_mib_data">snmpa_mib_data</a> 
behaviour. </p> <p>At present only the default module is provided with the agent,  
<strong>snmpa_mib_data_tttn</strong>. </p> <p>Default module is <strong>snmpa_mib_data_tttn</strong>. </p> </dd><dt><a name="agent_ms_cache"></a> <strong>mibs_cache() = bool() | mibs_cache_opts() &lt;optional&gt;</strong></dt><dd> <p>Shall the agent utilize the mib server lookup cache or not.</p> <p>Default is <strong>true</strong> (in which case the <strong>mibs_cache_opts()</strong> 
default values apply).</p> </dd><dt><a name="agent_ms_cache_opts"></a> <strong>mibs_cache_opts() = [mibs_cache_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>mibs_cache_opt() = {autogc, mibs_cache_autogc()} | {gclimit, mibs_cache_gclimit()} | {age, mibs_cache_age()}</strong></p> <p>Defines options specific for the SNMP agent mib server cache. </p> <p>For defaults see the options in <strong>mibs_cache_opt()</strong>.</p> </dd><dt><a name="agent_ms_cache_autogc"></a> <strong>mibs_cache_autogc() = bool() &lt;optional&gt;</strong></dt><dd> <p>Defines if the mib server shall perform cache gc automatically or 
leave it to the user (see 
<a href="./snmpa#gc_mibs_cache">gc_mibs_cache/0,1,2,3</a>). </p> <p>Default is <strong>true</strong>.</p> </dd><dt><a name="agent_ms_cache_age"></a> <strong>mibs_cache_age() = integer() &gt; 0 &lt;optional&gt;</strong></dt><dd> <p>Defines how old the entries in the cache will be allowed 
to become before they are GC'ed (assuming GC is performed). 
Each entry in the cache is "touched" whenever it is accessed. </p> <p>The age is defined in milliseconds. </p> <p>Default is <strong>10 timutes</strong>.</p> </dd><dt><a name="agent_ms_cache_gclimit"></a> <strong>mibs_cache_gclimit() = integer() &gt; 0 | infinity &lt;optional&gt;</strong></dt><dd> <p>When performing a GC, this is the max number of cache entries 
that will be deleted from the cache. </p> <p>The reason for having this limit is that if the cache is 
large, the GC can potentially take a long time, during which 
the agent is locked. </p> <p>Default is <strong>100</strong>.</p> </dd><dt><a name="agent_error_report_mod"></a> <strong>error_report_mod() = atom() &lt;optional&gt;</strong></dt><dd> <p>Defines an error report module, implementing the 
<a href="snmpa_error_report">snmpa_error_report</a> 
behaviour. Two modules are provided with the toolkit: 
<strong>snmpa_error_logger</strong> and <strong>snmpa_error_io</strong>.</p> <p>Default is <strong>snmpa_error_logger</strong>.</p> </dd><dt><a name="agent_symbolic_store"></a> <strong>symbolic_store() = [symbolic_store_opt()]</strong></dt><dd> <p><strong>symbolic_store_opt() = {verbosity, verbosity()}</strong></p> <p>Defines options specific for the SNMP agent symbolic store. </p> <p>For defaults see the options in <strong>symbolic_store_opt()</strong>.</p> </dd><dt><a name="agent_target_cache"></a> <strong>target_cache() = [target_cache_opt()]</strong></dt><dd> <p><strong>target_cache_opt() = {verbosity, verbosity()}</strong></p> <p>Defines options specific for the SNMP agent target cache. </p> <p>For defaults see the options in <strong>target_cache_opt()</strong>.</p> </dd><dt><a name="agent_config"></a> <strong>agent_config() = [agent_config_opt()] &lt;mandatory&gt;</strong></dt><dd> <p><strong>agent_config_opt() = {dir, agent_config_dir()} |  {force_load, force_load()} | {verbosity, verbosity()}</strong></p> <p>Defines specific config related options for the SNMP agent. </p> <p>For defaults see the options in <strong>agent_config_opt()</strong>.</p> </dd><dt><a name="agent_config_dir"></a> <strong>agent_config_dir = dir() &lt;mandatory&gt;</strong></dt><dd> <p>Defines where the SNMP agent configuration files are stored.</p> </dd><dt><a name="agent_force_load"></a> <strong>force_load() = bool() &lt;optional&gt;</strong></dt><dd> <p>If <strong>true</strong> the configuration files are re-read
during start-up, and the contents of the configuration 
database ignored.  Thus, if <strong>true</strong>, changes to 
the configuration database are lost upon reboot of the 
agent. </p> <p>Default is <strong>false</strong>.</p> </dd></dl><a name="manager_opts_and_types"></a><p>Manager specific config options and types:</p><dl><dt><a name="manager_server"></a> <strong>server() = [server_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>server_opt() = {timeout, server_timeout()} |  {verbosity, verbosity()}</strong></p> <p>Specifies the options for the manager server process.</p> <p>Default is <strong>silence</strong>.</p> </dd><dt><a name="manager_server_timeout"></a> <strong>server_timeout() = integer() &lt;optional&gt;</strong></dt><dd> <p>Asynchronous request cleanup time. For every requests,
some info is stored internally, in order to be able to 
deliver the reply (when it arrives) to the proper destination.
If the reply arrives, this info will be deleted. But if
there is no reply (in time), the info has to be deleted
after the <em>best before</em> time has been passed.
This cleanup will be performed at regular intervals, defined 
by the <strong>server_timeout()</strong> time.
The information will have an <em>best before</em> time,
defined by the <strong>Expire</strong> time given when calling the
request function (see 
<a href="./snmpm#async_get">async_get</a>,
<a href="./snmpm#async_get_next">async_get_next</a> and 
<a href="./snmpm#async_set">async_set</a>).</p> <p>Time in milli-seconds.</p> <p>Default is <strong>30000</strong>.</p> </dd><dt><a name="manager_config"></a> <strong>manager_config() = [manager_config_opt()] &lt;mandatory&gt;</strong></dt><dd> <p><strong>manager_config_opt() = {dir, manager_config_dir()} |  {db_dir, manager_db_dir()} |  {db_init_error, db_init_error()} |  {repair, manager_repair()} |  {auto_save, manager_auto_save()} |  {verbosity, verbosity()}</strong></p> <p>Defines specific config related options for the SNMP manager. </p> <p>For defaults see the options in <strong>manager_config_opt()</strong>.</p> </dd><dt><a name="manager_config_dir"></a> <strong>manager_config_dir = dir() &lt;mandatory&gt;</strong></dt><dd> <p>Defines where the SNMP manager configuration files are stored.</p> </dd><dt><a name="manager_config_db_dir"></a> <strong>manager_db_dir = dir() &lt;mandatory&gt;</strong></dt><dd> <p>Defines where the SNMP manager store persistent data.</p> </dd><dt><a name="manager_config_repair"></a> <strong>manager_repair() = false | true | force &lt;optional&gt;</strong></dt><dd> <p>Defines the repair option for the persistent database (if 
and how the table is repaired when opened). </p> <p>Default is <strong>true</strong>.</p> </dd><dt><a name="manager_config_auto_save"></a> <strong>manager_auto_save() = integer() | infinity &lt;optional&gt;</strong></dt><dd> <p>The auto save interval. The table is flushed to disk
whenever not accessed for this amount of time.</p> <p>Default is <strong>5000</strong>.</p> </dd><dt><a name="manager_irb"></a> <strong>manager_irb() = auto | user | {user, integer()} &lt;optional&gt;</strong></dt><dd> <p>This option defines how the manager will handle the sending of 
response (acknowledgment) to received inform-requests. </p> <ul><li> <p><strong>auto</strong> - The manager will autonomously send response
(acknowledgment&gt; to inform-request messages.</p> </li><li> <p><strong>{user, integer()}</strong> - The manager will send response
(acknowledgment) to inform-request messages when the 
<a href="./snmpm_user#handle_inform">handle_inform</a> 
function completes. The integer is the time, in milli-seconds, 
that the manager will consider the stored inform-request info 
valid.</p> </li><li> <p><strong>user</strong> - Same as <strong>{user, integer()}</strong>, except that 
the default time, 15 seconds (15000), is used.</p> </li></ul> <p>See 
<a href="snmpm_network_interface">snmpm_network_interface</a>, 
<a href="snmpm_user">handle_inform</a> and 
<a href="snmp_manager_netif">definition of the manager net if</a> for more info.</p> <p>Default is <strong>auto</strong>.</p> </dd><dt><a name="manager_mibs"></a> <strong>manager_mibs() = [string()] &lt;optional&gt;</strong></dt><dd> <p>Specifies a list of MIBs (including path) and defines which MIBs
are initially loaded into the SNMP manager. </p> <p>Default is <strong>[]</strong>.</p> </dd><dt><a name="manager_net_if"></a> <strong>manager_net_if() = [manager_net_if_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>manager_net_if_opt() = {module, manager_net_if_module()} |  {verbosity, verbosity()} |  {options, manager_net_if_options()}</strong></p> <p>Defines options specific for the SNMP manager network interface 
entity. </p> <p>For defaults see the options in <strong>manager_net_if_opt()</strong>.</p> </dd><dt><a name="manager_ni_opts"></a> <strong>manager_net_if_options() = [manager_net_if_option()] &lt;optional&gt;</strong></dt><dd> <p><strong>manager_net_if_option() = {bind_to, bind_to()} |  {sndbuf, sndbuf()} |   {recbuf, recbuf()} |  {no_reuse, no_reuse()} | {filter, manager_net_if_filter_options()} </strong></p> <p>These options are actually specific to the used module.
The ones shown here are applicable to the default 
<strong>manager_net_if_module()</strong>.</p> <p>For defaults see the options in <strong>manager_net_if_option()</strong>.</p> </dd><dt><a name="manager_ni_module"></a> <strong>manager_net_if_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>The module which handles the network interface part for the
SNMP manager. It must implement the 
<a href="snmpm_network_interface">snmpm_network_interface</a> behaviour.</p> <p>Default is <strong>snmpm_net_if</strong>.</p> </dd><dt><a name="manager_ni_filter_opts"></a> <strong>manager_net_if_filter_options() = [manager_net_if_filter_option()] &lt;optional&gt;</strong></dt><dd> <p><strong>manager_net_if_filter_option() = {module, manager_net_if_filter_module()}</strong></p> <p>These options are actually specific to the used module.
The ones shown here are applicable to the default 
<strong>manager_net_if_filter_module()</strong>.</p> <p>For defaults see the options in 
<strong>manager_net_if_filter_option()</strong>.</p> </dd><dt><a name="manager_ni_filter_module"></a> <strong>manager_net_if_filter_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>Module which handles the network interface filter part for the
SNMP manager. Must implement the 
<a href="snmpm_network_interface_filter">snmpm_network_interface_filter</a> behaviour.</p> <p>Default is <strong>snmpm_net_if_filter</strong>.</p> </dd><dt><a name="manager_def_user_module"></a> <strong>def_user_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>The module implementing the default user. See the 
<a href="snmpm_user">snmpm_user</a> behaviour.</p> <p>Default is <strong>snmpm_user_default</strong>.</p> </dd><dt><a name="manager_def_user_data"></a> <strong>def_user_data() = term() &lt;optional&gt;</strong></dt><dd> <p>Data for the default user. Passed to the user module when 
calling the callback functions.</p> <p>Default is <strong>undefined</strong>.</p> </dd></dl><a name="common_types"></a><p>Common config types:</p><dl><dt><a name="restart_type"></a> <strong>restart_type() = permanent | transient | temporary</strong></dt><dd> <p>See <a href="../stdlib/supervisor#child_spec">supervisor</a> 
documentation for more info.</p> <p>Default is <strong>permanent</strong> for the agent and <strong>transient</strong>
for the manager.</p> </dd><dt><a name="db_init_error"></a> <strong>db_init_error() = terminate | create | create_db_and_dir</strong></dt><dd> <p>Defines what to do if the agent or manager is unable to open an
existing database file. <strong>terminate</strong> means that the
agent/manager will terminate and <strong>create</strong> means that the 
agent/manager will remove the faulty file(s) and create new ones,
and <strong>create_db_and_dir</strong> means that the agent/manager will
create the database file along with any missing parent directories
for the database file.</p> <p>Default is <strong>terminate</strong>.</p> </dd><dt><a name="prio"></a> <strong>priority() = atom() &lt;optional&gt;</strong></dt><dd> <p>Defines the Erlang priority for all SNMP processes.</p> <p>Default is <strong>normal</strong>.</p> </dd><dt><a name="versions"></a> <strong>versions() = [version()] &lt;optional&gt;</strong></dt><dd> <p><strong>version() = v1 | v2 | v3</strong></p> <p>Which SNMP versions shall be accepted/used.</p> <p>Default is <strong>[v1,v2,v3]</strong>.</p> </dd><dt><a name="verbosity"></a> <strong>verbosity() = silence | info | log | debug | trace &lt;optional&gt;</strong></dt><dd> <p>Verbosity for a SNMP process. This specifies now much debug info
is printed.</p> <p>Default is <strong>silence</strong>.</p> </dd><dt><a name="bind_to"></a> <strong>bind_to() = bool() &lt;optional&gt;</strong></dt><dd> <p>If <strong>true</strong>, net_if binds to the IP address.
If <strong>false</strong>, net_if listens on any IP address on the host
where it is running. </p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="no_reuse"></a> <strong>no_reuse() = bool() &lt;optional&gt;</strong></dt><dd> <p>If <strong>true</strong>, net_if does not specify that the IP
and port address should be reusable. If <strong>false</strong>, 
the address is set to reusable. </p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="recbuf"></a> <strong>recbuf() = integer() &lt;optional&gt;</strong></dt><dd> <p>Receive buffer size. </p> <p>Default value is defined by <strong>gen_udp</strong>.</p> </dd><dt><a name="sndbuf"></a> <strong>sndbuf() = integer() &lt;optional&gt;</strong></dt><dd> <p>Send buffer size. </p> <p>Default value is defined by <strong>gen_udp</strong>.</p> </dd><dt><a name="note_store"></a> <strong>note_store() = [note_store_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>note_store_opt() = {timeout, note_store_timeout()} |  {verbosity, verbosity()}</strong></p> <p>Specifies the start-up verbosity for the SNMP note store.</p> <p>For defaults see the options in <strong>note_store_opt()</strong>.</p> </dd><dt><a name="ns_timeout"></a> <strong>note_store_timeout() = integer() &lt;optional&gt;</strong></dt><dd> <p>Note cleanup time. When storing a note in the note store,
each note is given lifetime. Every <strong>timeout</strong> the note_store
process performs a GC to remove the expired note's. Time in
milli-seconds.</p> <p>Default is <strong>30000</strong>.</p> </dd><dt><a name="audit_trail_log"></a> <strong>audit_trail_log() = [audit_trail_log_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>audit_trail_log_opt() = {type, atl_type()} | {dir, atl_dir()} |  {size, atl_size()} |  {repair, atl_repair()} | {seqno, atl_seqno()}</strong></p> <p>If present, this option specifies the options for the 
audit trail logging. The <strong>disk_log</strong> module is used 
to maintain a wrap log. If present, the <strong>dir</strong> and 
<strong>size</strong> options are mandatory.</p> <p>If not present, audit trail logging is not used.</p> </dd><dt><a name="atl_type"></a> <strong>atl_type() = read | write | read_write &lt;optional&gt;</strong></dt><dd> <p>Specifies what type of an audit trail log should be used. 
The effect of the type is actually different for the the agent
and the manager. </p> <p>For the agent:</p> <ul><li>If <strong>write</strong> is specified, only set requests are logged.  </li><li>If <strong>read</strong> is specified, only get requests are logged.  </li><li>If <strong>read_write</strong>, all requests are logged.  </li></ul> <p>For the manager:</p> <ul><li>If <strong>write</strong> is specified, only sent messages are logged.  </li><li>If <strong>read</strong> is specified, only received messages are logged.  </li><li>If <strong>read_write</strong>, both outgoing and incoming messages are  logged.  </li></ul> <p>Default is <strong>read_write</strong>.</p> </dd><dt><a name="atl_dir"></a> <strong>atl_dir = dir() &lt;mandatory&gt;</strong></dt><dd> <p>Specifies where the audit trail log should be stored.</p> <p>If <strong>audit_trail_log</strong> specifies that logging should take
place, this parameter <em>must</em> be defined.</p> </dd><dt><a name="atl_size"></a> <strong>atl_size() = {integer(), integer()} &lt;mandatory&gt;</strong></dt><dd> <p>Specifies the size of the audit
trail log.  This parameter is sent to <strong>disk_log</strong>.  </p> <p>If <strong>audit_trail_log</strong> specifies that logging should 
take place, this parameter <em>must</em> be defined.</p> </dd><dt><a name="atl_repair"></a> <strong>atl_repair() = true | false | truncate | snmp_repair &lt;optional&gt;</strong></dt><dd> <p>Specifies if and how the audit trail log shall be repaired
when opened. Unless this parameter has the value <strong>snmp_repair</strong>
it is sent to <strong>disk_log</strong>. If, on the other hand, the value is
<strong>snmp_repair</strong>, snmp attempts to handle certain faults on its
own. And even if it cannot repair the file, it does not truncate it 
directly, but instead <em>moves it aside</em> for later off-line 
analysis.</p> <p>Default is <strong>true</strong>.</p> </dd><dt><a name="atl_seqno"></a> <strong>atl_seqno() = true | false &lt;optional&gt;</strong></dt><dd> <p>Specifies if the audit trail log entries will be (sequence)
numbered or not. The range of the sequence numbers are according
to RFC 5424, i.e. 1 through 2147483647. </p> <p>Default is <strong>false</strong>.</p> </dd></dl><h3>See Also</h3><p>application(3), disk_log(3)</p><h2>snmpa</h2><p>Interface Functions to the SNMP toolkit agent</p><p>The module <strong>snmpa</strong> contains interface functions to the 
SNMP agent.<a name="data_types"></a></p><h3>DATA TYPES</h3><pre><code class="">
oid() = [byte()] 
atl_type() = read | write | read_write
notification_delivery_info() = #snmpa_notification_delivery_info{}
    </code></pre><p>The <strong>oid()</strong> type is used to represent an ASN.1 OBJECT IDENTIFIER. </p><p>The record <strong>snmpa_notification_delivery_info</strong> contains the following fields: </p><dl><dt><strong>tag = term()</strong></dt><dd> <p>A user defined identity representing this notification send 
operation.</p> </dd><dt><strong>mod = module()</strong></dt><dd> <p>A module implementing the 
<a href="snmpa_notification_delivery_info_receiver">snmpa_notification_delivery_info_receiver</a> 
behaviour. The info functions of this module will be called at 
various stages of delivery. </p> </dd><dt><strong>extra = term()</strong></dt><dd> <p>This is any extra info the user wants to have supplied 
when the functions in the callback module is called. </p> </dd></dl><a name="add_agent_caps"></a><h2>Functions</h2><h3>add_agent_caps(SysORID, SysORDescr) -&gt; SysORIndex</h3><p>Add an AGENT-CAPABILITY definition to the agent</p><ul><li><span class="v">SysORID = oid()</span></li><li><span class="v">SysORDescr = string()</span></li><li><span class="v">SysORIndex = integer()</span></li></ul><p>This function can be used to add an AGENT-CAPABILITY
statement to the sysORTable in the agent.  The table is
defined in the SNMPv2-MIB.</p><a name="del_agent_caps"></a><h3>del_agent_caps(SysORIndex) -&gt; void()</h3><p>Delete an AGENT-CAPABILITY definition from the agent</p><ul><li><span class="v">SysORIndex = integer()</span></li></ul><p>This function can be used to delete an AGENT-CAPABILITY
statement to the sysORTable in the agent.  This table is
defined in the SNMPv2-MIB. </p><a name="get_agent_caps"></a><h3>get_agent_caps() -&gt; [[SysORIndex, SysORID, SysORDescr, SysORUpTime]]</h3><p>Return all AGENT-CAPABILITY definitions in the agent</p><ul><li><span class="v">SysORIndex = integer()</span></li><li><span class="v">SysORId = oid()</span></li><li><span class="v">SysORDescr = string()</span></li><li><span class="v">SysORUpTime = integer()</span></li></ul><p>Returns all AGENT-CAPABILITY statements in the sysORTable
in the agent.  This table is defined in the SNMPv2-MIB. </p><a name="get"></a><h3>get(Agent, Vars) -&gt; Values | {error, Reason}</h3><h3>get(Agent, Vars, Context) -&gt; Values | {error, Reason}</h3><p>Perform a get operation on the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Vars = [oid()]</span></li><li><span class="v">Context = string()</span></li><li><span class="v">Values = [term()]</span></li><li><span class="v">Reason = {atom(), oid()}</span></li></ul><p>Performs a GET operation on the agent.  All loaded MIB
objects are visible in this operation.  The agent calls the
corresponding instrumentation functions just as if it was a
GET request coming from a manager. </p><p>Note that the request specific parameters (such as 
<a href="#current_request_id">current_request_id</a>) 
are not accessible for the instrumentation functions if this 
function is used. </p><a name="get_next"></a><h3>get_next(Agent, Vars) -&gt; Values | {error, Reason}</h3><h3>get_next(Agent, Vars, Context) -&gt; Values | {error, Reason}</h3><p>Perform a get-next operation on the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Vars = [oid()]</span></li><li><span class="v">Context = string()</span></li><li><span class="v">Values = [{oid(), term()}]</span></li><li><span class="v">Reason = {atom(), oid()}</span></li></ul><p>Performs a GET-NEXT operation on the agent.  All loaded MIB
objects are visible in this operation.  The agent calls the
corresponding instrumentation functions just as if it was a
GET request coming from a manager. </p><p>Note that the request specific parameters (such as 
<strong>snmpa:current_request_id/0</strong> are not accessible for the 
instrumentation functions if this function is used. </p><a name="backup"></a><h3>backup(BackupDir) -&gt; ok | {error, Reason}</h3><h3>backup(Agent, BackupDir) -&gt; ok | {error, Reason}</h3><p>Backup agent data</p><ul><li><span class="v">BackupDir = string()</span></li><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Reason = backup_in_progress | term()</span></li></ul><p>Backup persistent/permanent data handled by the agent
(such as local-db, mib-data and vacm). </p><p>Data stored by mnesia is not handled. </p><p>BackupDir cannot be identical to DbDir. </p><p>Simultaneous backup calls are <em>not</em> allowed. 
That is, two different processes cannot simultaneously 
successfully call this function. One of them will be first, 
and succeed. The second will fail with the error reason
<strong>backup_in_progress</strong>. </p><a name="info"></a><h3>info() -&gt; [{Key, Value}]</h3><h3>info(Agent) -&gt; [{Key, Value}]</h3><p>Return information about the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Returns a list (a dictionary) containing information about
the agent. Information includes loaded MIBs, registered
sub-agents, some information about the memory allocation. </p><p>As of version 4.4 the format of the info has been changed. 
To convert the info to the old format, call the 
<a href="#old_info_format">old_info_format</a> 
function. </p><a name="old_info_format"></a><h3>old_info_format(NewInfo) -&gt; OldInfo</h3><p>Return information about the agent</p><ul><li><span class="v">OldInfo = NewInfo = [{Key, Value}]</span></li></ul><p>As of version 4.4 the format of the info has been changed. 
This function is used to convert to the old (pre-4.4) info 
format. </p><a name="load_mib"></a><h3>load_mib(Mib) -&gt; ok | {error, Reason}</h3><h3>load_mib(Agent, Mib) -&gt; ok | {error, Reason}</h3><p>Load single MIB into the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = already_loaded | term()</span></li></ul><p>Load a single <strong>Mib</strong> into an agent. The <strong>MibName</strong> 
is the name of the Mib, including the path to where the compiled 
mib is found. For example: </p><pre><code class="">
          Dir = code:priv_dir(my_app) ++ "/mibs/",
          snmpa:load_mib(snmp_master_agent, Dir ++ "MY-MIB").
        </code></pre><a name="load_mibs"></a><h3>load_mibs(Mibs) -&gt; ok | {error, Reason}</h3><h3>load_mibs(Mibs, Force) -&gt; ok | {error, Reason}</h3><h3>load_mibs(Agent, Mibs) -&gt; ok | {error, Reason}</h3><h3>load_mibs(Agent, Mibs, Force) -&gt; ok | {error, Reason}</h3><p>Load MIBs into the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">Force = boolean()</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = {'load aborted at', MibName, InternalReason}</span></li><li><span class="v">InternalReason = already_loaded | term()</span></li></ul><p>Load <strong>Mibs</strong> into an agent.  If the agent cannot load all 
MIBs (the default value of the <strong>Force</strong> argument is <strong>false</strong>), 
it will indicate where loading was aborted. The <strong>MibName</strong> 
is the name of the Mib, including the path to where the compiled 
mib is found. For example,</p><pre><code class="">
          Dir = code:priv_dir(my_app) ++ "/mibs/",
          snmpa:load_mibs(snmp_master_agent, [Dir ++ "MY-MIB"]).
        </code></pre><p>If <strong>Force = true</strong> then the agent will continue attempting
to load each mib even after failing to load a previous mib. Use with 
care. </p><a name="unload_mib"></a><h3>unload_mib(Mib) -&gt; ok | {error, Reason}</h3><h3>unload_mib(Agent, Mib) -&gt; ok | {error, Reason}</h3><p>Unload single MIB from the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = not_loaded | term()</span></li></ul><p>Unload a single <strong>Mib</strong> from an agent. </p><a name="unload_mibs"></a><h3>unload_mibs(Mibs) -&gt; ok | {error, Reason}</h3><h3>unload_mibs(Mibs, Force) -&gt; ok | {error, Reason}</h3><h3>unload_mibs(Agent, Mibs) -&gt; ok | {error, Reason}</h3><h3>unload_mibs(Agent, Mibs, Force) -&gt; ok | {error, Reason}</h3><p>Unload MIBs from the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">Force = boolean()</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = {'unload aborted at', MibName, InternalReason}</span></li><li><span class="v">InternalReason = not_loaded | term()</span></li></ul><p>Unload <strong>Mibs</strong> from an agent. If it cannot unload all MIBs
(the default value of the <strong>Force</strong> argument is <strong>false</strong>),
it will indicate where unloading was aborted. </p><p>If <strong>Force = true</strong> then the agent will continue attempting
to unload each mib even after failing to unload a previous mib. 
Use with care. </p><a name="which_mibs"></a><h3>which_mibs() -&gt; Mibs</h3><h3>which_mibs(Agent) -&gt; Mibs</h3><p>Get a list of all the loaded mibs</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Mibs = [{MibName, MibFile}]</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">MibFile = string()</span></li></ul><p>Retrieve the list of all the mibs loaded into this agent. Default 
is the master agent. </p><a name="whereis_mib"></a><h3>whereis_mib(MibName) -&gt; {ok, MibFile} | {error, Reason}</h3><h3>whereis_mib(Agent, MibName) -&gt; {ok, MibFile} | {error, Reason}</h3><p>Get the path to the mib file</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">MibFile = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Get the full path to the (compiled) mib-file. </p><a name="current_request_id"></a><a name="current_context"></a><a name="current_community"></a><a name="current_address"></a><h3>current_request_id() -&gt; {value, RequestId} | false</h3><h3>current_context() -&gt; {value, Context} | false</h3><h3>current_community() -&gt; {value, Community} | false</h3><h3>current_address() -&gt; {value, Address} | false</h3><p>Get the request-id, context, community and address of the current request</p><ul><li><span class="v">RequestId = integer()</span></li><li><span class="v">Context = string()</span></li><li><span class="v">Community = string()</span></li><li><span class="v">Address = term()</span></li></ul><p>Get the request-id, context, community and address of the 
request currently being processed by the agent. </p><p>Note that these functions is intended to be called by the 
instrumentation functions and <em>only</em> if they are 
executed in the context of the agent process (e.g. it does 
not work if called from a spawned process).</p><a name="enum_to_int"></a><h3>enum_to_int(Name, Enum) -&gt; {value, Int} | false</h3><h3>enum_to_int(Db, Name, Enum) -&gt; {value, Int} | false</h3><p>Convert an enum value to an integer</p><ul><li><span class="v">Db   = term()</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">Enum = atom()</span></li><li><span class="v">Int  = int()</span></li></ul><p>Converts the symbolic value <strong>Enum</strong> to the
corresponding integer of the enumerated object or type
<strong>Name</strong> in a MIB.  The MIB must be loaded. 
</p><p><strong>false</strong> is returned if the object or type is not
defined in any loaded MIB, or if it does not define the
symbolic value as enumerated.
</p><p><strong>Db</strong> is a reference to the symbolic store database 
(retrieved by a call to <strong>get_symbolic_store_db/0</strong>). </p><a name="int_to_enum"></a><h3>int_to_enum(Name, Int) -&gt; {value, Enum} | false</h3><h3>int_to_enum(Db, Name, Int) -&gt; {value, Enum} | false</h3><p>Convert an integer to an enum value</p><ul><li><span class="v">Db   = term()</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">Int  = int()</span></li><li><span class="v">Enum = atom()</span></li></ul><p>Converts the integer <strong>Int</strong> to the corresponding
symbolic value of the enumerated object or type <strong>Name</strong> in
a MIB.  The MIB must be loaded. 
</p><p><strong>false</strong> is returned if the object or type is not
defined in any loaded MIB, or if it does not define the
symbolic value as enumerated.
</p><p><strong>Db</strong> is a reference to the symbolic store database 
(retrieved by a call to <strong>get_symbolic_store_db/0</strong>). </p><a name="name_to_oid"></a><h3>name_to_oid(Name) -&gt; {value, oid()} | false</h3><h3>name_to_oid(Db, Name) -&gt; {value, oid()} | false</h3><p>Convert a symbolic name to an OID</p><ul><li><span class="v">Db   = term()</span></li><li><span class="v">Name = atom()</span></li></ul><p>Looks up the OBJECT IDENTIFIER of a MIB object, given the
symbolic name.  Note, the OBJECT IDENTIFIER is given for the
object, not for an instance. </p><p><strong>false</strong> is returned if the object is not defined in any
loaded MIB. </p><p><strong>Db</strong> is a reference to the symbolic store database 
(retrieved by a call to <strong>get_symbolic_store_db/0</strong>). </p><a name="oid_to_name"></a><h3>oid_to_name(OID) -&gt; {value, Name} | false</h3><h3>oid_to_name(Db, OID) -&gt; {value, Name} | false</h3><p>Convert an OID to a symbolic name</p><ul><li><span class="v">Db   = term()</span></li><li><span class="v">OID  = oid()</span></li><li><span class="v">Name = atom()</span></li></ul><p>Looks up the symbolic name of a MIB object, given OBJECT
IDENTIFIER. </p><p><strong>false</strong> is returned if the object is not defined in any
loaded MIB. </p><p><strong>Db</strong> is a reference to the symbolic store database 
(retrieved by a call to <strong>get_symbolic_store_db/0</strong>). </p><a name="which_aliasnames"></a><h3>which_aliasnames() -&gt; Result</h3><p>Get all alias-names known to the agent</p><ul><li><span class="v">Result = [atom()]</span></li></ul><p>Retrieve all alias-names known to the agent.</p><a name="which_tables"></a><h3>which_tables() -&gt; Result</h3><p>Get all tables known to the agent</p><ul><li><span class="v">Result = [atom()]</span></li></ul><p>Retrieve all tables known to the agent.</p><a name="which_variables"></a><h3>which_variables() -&gt; Result</h3><p>Get all variables known to the agent</p><ul><li><span class="v">Result = [atom()]</span></li></ul><p>Retrieve all variables known to the agent.</p><a name="which_notifications"></a><h3>which_notifications() -&gt; Result</h3><p>Get all notifications known to the agent</p><ul><li><span class="v">Result = [{Name, MibName, Info}]</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">Info = term()</span></li></ul><p>Retrieve all notifications (and traps) known to the agent.</p><a name="log_to_txt"></a><h3>log_to_txt(LogDir)</h3><h3>log_to_txt(LogDir, Block | Mibs)</h3><h3>log_to_txt(LogDir, Mibs, Block | OutFile) -&gt; ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_txt(LogDir, Mibs, OutFile, Block | LogName) -&gt;  ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_txt(LogDir, Mibs, OutFile, LogName, Block | LogFile) -&gt;  ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block | Start) -&gt;  ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start)  -&gt; ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Start, Stop)  -&gt; ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start, Stop)  -&gt; ok | {ok, Cnt} | {error, Reason}</h3><p>Convert an Audit Trail Log to text format</p><ul><li><span class="v">LogDir = string()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Block = boolean()</span></li><li><span class="v">OutFile = string()</span></li><li><span class="v">LogName = string()</span></li><li><span class="v">LogFile = string()</span></li><li><span class="v">Start = Stop = null | calendar:datetime() | {local_time, calendar:datetime()} | {universal_time, calendar:datetime()} </span></li><li><span class="v">Cnt = {NumOK, NumERR}</span></li><li><span class="v">NumOK = non_neg_integer()</span></li><li><span class="v">NumERR = pos_integer()</span></li><li><span class="v">Reason = disk_log_open_error() | file_open_error() | term()</span></li><li><span class="v">disk_log_open_error() = {LogName, term()}</span></li><li><span class="v">file_open_error() = {OutFile, term()}</span></li></ul><p>Converts an Audit Trail Log to a readable text file. 
<strong>OutFile</strong> defaults to "./snmpa_log.txt". 
<strong>LogName</strong> defaults to "snmpa_log". 
<strong>LogFile</strong> defaults to "snmpa.log". </p><p>The <strong>Block</strong> option indicates if the log should be blocked
during conversion. This could be usefull when converting large 
logs (when otherwise the log could wrap during conversion). 
Defaults to <strong>true</strong>. </p><p>See <a href="./snmp#log_to_txt">snmp:log_to_txt</a> 
for more info.</p><a name="log_to_io"></a><h3>log_to_io(LogDir) -&gt;  ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_io(LogDir, Block | Mibs) -&gt;  ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_io(LogDir, Mibs, Block | LogName) -&gt;  ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_io(LogDir, Mibs, LogName, Block | LogFile) -&gt; ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_io(LogDir, Mibs, LogName, LogFile, Block | Start) -&gt; ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start) -&gt; ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_io(LogDir, Mibs, LogName, LogFile, Start, Stop) -&gt; ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start, Stop) -&gt; ok | {ok, Cnt} | {error, Reason}</h3><p>Convert an Audit Trail Log to text format</p><ul><li><span class="v">LogDir = string()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Block = boolean()</span></li><li><span class="v">LogName = string()</span></li><li><span class="v">LogFile = string()</span></li><li><span class="v">Start = Stop = null | calendar:datetime() | {local_time, calendar:datetime()} | {universal_time, calendar:datetime()} </span></li><li><span class="v">Cnt = {NumOK, NumERR}</span></li><li><span class="v">NumOK = non_neg_integer()</span></li><li><span class="v">NumERR = pos_integer()</span></li><li><span class="v">Reason = disk_log_open_error() | file_open_error() | term()</span></li><li><span class="v">disk_log_open_error() = {LogName, term()}</span></li><li><span class="v">file_open_error() = {OutFile, term()}</span></li></ul><p>Converts an Audit Trail Log to a readable format and 
prints it on stdio. 
<strong>LogName</strong> defaults to "snmpa_log". 
<strong>LogFile</strong> defaults to "snmpa.log".</p><p>The <strong>Block</strong> option indicates if the log should be blocked
during conversion. This could be usefull when converting large 
logs (when otherwise the log could wrap during conversion). 
Defaults to <strong>true</strong>. </p><p>See <a href="./snmp#log_to_io">snmp:log_to_io</a> 
for more info.</p><a name="change_log_size"></a><h3>change_log_size(NewSize) -&gt; ok | {error, Reason}</h3><p>Change the size of the Audit Trail Log</p><ul><li><span class="v">NewSize = {MaxBytes, MaxFiles}</span></li><li><span class="v">MaxBytes = integer()</span></li><li><span class="v">MaxFiles = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Changes the log size of the Audit Trail Log. The application must 
be configured to use the audit trail log function. Please refer to 
disk_log(3) in Kernel Reference Manual for a description of how to 
change the log size. </p><p>The change is permanent, as long as the log is not deleted. 
That means, the log size is remembered across reboots. </p><a name="set_log_type"></a><h3>set_log_type(NewType) -&gt; {ok, OldType} | {error, Reason}</h3><h3>set_log_type(Agent, NewType) -&gt; {ok, OldType} | {error, Reason}</h3><p>Change the type of the Audit Trail Log</p><ul><li><span class="v">NewType = OldType = atl_type()</span></li><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Changes the run-time Audit Trail log type. </p><p>Note that this has no effect on the application configuration as
defined by configuration files, so a node restart will revert the 
config to whatever is in those files. </p><p>This function is primarily useful in testing/debugging 
scenarios. </p><a name="mib_of"></a><h3>mib_of(Oid) -&gt; {ok, MibName} | {error, Reason}</h3><h3>mib_of(Agent, Oid) -&gt; {ok, MibName} | {error, Reason}</h3><p>Which mib an Oid belongs to</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Oid = oid()</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Finds the mib corresponding to the <strong>Oid</strong>. If it is a
variable, the Oid must be 
&lt;Oid for var&gt;.0 and if it is a table, Oid must be 
&lt;table&gt;.&lt;entry&gt;.&lt;col&gt;.&lt;any&gt;</p><a name="me_of"></a><h3>me_of(Oid) -&gt; {ok, Me} | {error, Reason}</h3><h3>me_of(Agent, Oid) -&gt; {ok, Me} | {error, Reason}</h3><p>Retrieve the mib-entry of an Oid</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Oid = oid()</span></li><li><span class="v">Me = #me{}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Finds the mib entry corresponding to the <strong>Oid</strong>. If it is a
variable, the Oid must be 
&lt;Oid for var&gt;.0 and if it is a table, Oid must be 
&lt;table&gt;.&lt;entry&gt;.&lt;col&gt;.&lt;any&gt;</p><a name="invalidate_mibs_cache"></a><h3>invalidate_mibs_cache() -&gt; void()</h3><h3>invalidate_mibs_cache(Agent) -&gt; void()</h3><p>Invalidate the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Invalidate the mib server cache. </p><p>The entire contents of the cache will be deleted. </p><a name="enable_mibs_cache"></a><h3>enable_mibs_cache() -&gt; void()</h3><h3>enable_mibs_cache(Agent) -&gt; void()</h3><p>Enable the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Enable the mib server cache. </p><a name="disable_mibs_cache"></a><h3>disable_mibs_cache() -&gt; void()</h3><h3>disable_mibs_cache(Agent) -&gt; void()</h3><p>Disable the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Disable the mib server cache. </p><a name="which_mibs_cache_size"></a><h3>which_mibs_cache_size() -&gt; void()</h3><h3>which_mibs_cache_size(Agent) -&gt; void()</h3><p>The size of the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Retreive the size of the mib server cache. </p><a name="gc_mibs_cache"></a><h3>gc_mibs_cache() -&gt; {ok, NumElementsGCed} | {error, Reason}</h3><h3>gc_mibs_cache(Agent) -&gt; {ok, NumElementsGCed} | {error, Reason}</h3><h3>gc_mibs_cache(Age) -&gt; {ok, NumElementsGCed} | {error, Reason}</h3><h3>gc_mibs_cache(Agent, Age) -&gt; {ok, NumElementsGCed} | {error, Reason}</h3><h3>gc_mibs_cache(Age, GcLimit) -&gt; {ok, NumElementsGCed} | {error, Reason}</h3><h3>gc_mibs_cache(Agent, Age, GcLimit) -&gt; {ok, NumElementsGCed} | {error, Reason}</h3><p>Perform mib server cache gc</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Age = integer() &gt; 0</span></li><li><span class="v">GcLimit = integer() &gt; 0 | infinity</span></li><li><span class="v">NumElementsGCed = integer() &gt;= 0</span></li><li><span class="v">Reason = term()</span></li></ul><p>Perform mib server cache gc. </p><p>Manually performs a mib server cache gc. 
This can be done regardless of the value of the 
<strong>autogc</strong> option. 
The <strong>NumElementsGCed</strong> value indicates how many 
elements where actually removed from the cache. </p><a name="enable_mibs_cache_autogc"></a><h3>enable_mibs_cache_autogc() -&gt; void()</h3><h3>enable_mibs_cache_autogc(Agent) -&gt; void()</h3><p>Enable automatic gc of the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Enable automatic gc of the mib server cache. </p><a name="disable_mibs_cache_autogc"></a><h3>disable_mibs_cache_autogc() -&gt; void()</h3><h3>disable_mibs_cache_autogc(Agent) -&gt; void()</h3><p>Disable automatic gc of the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Disable automatic gc of the mib server cache. </p><a name="update_mibs_cache_age"></a><h3>update_mibs_cache_age(NewAge) -&gt; ok | {error, Reason}</h3><h3>update_mibs_cache_age(Agent, NewAge) -&gt; ok | {error, Reason}</h3><p>Change the mib server cache age property</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">NewAge = integer() &gt; 0</span></li><li><span class="v">Reason = term()</span></li></ul><p>Change the mib server cache <strong>age</strong> property. </p><a name="update_mibs_cache_gclimit"></a><h3>update_mibs_cache_gclimit(NewGcLimit) -&gt; ok | {error, Reason}</h3><h3>update_mibs_cache_gclimit(Agent, NewGCLimit) -&gt; ok | {error, Reason}</h3><p>Change the mib server cache gclimit property</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">NewGcLimit = integer() &gt; 0 | infinity</span></li><li><span class="v">Reason = term()</span></li></ul><p>Change the mib server cache <strong>gclimit</strong> property. </p><a name="register_notification_filter"></a><h3>register_notification_filter(Id, Mod, Data) -&gt; ok | {error, Reason}</h3><h3>register_notification_filter(Agent, Id, Mod, Data) -&gt; ok | {error, Reason}</h3><h3>register_notification_filter(Id, Mod, Data, Where) -&gt; ok | {error, Reason}</h3><h3>register_notification_filter(Agent, Id, Mod, Data, Where) -&gt; ok | {error, Reason}</h3><p>Register a notification filter</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Id = filter_id()</span></li><li><span class="v">filter_id() = term()</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">Data = term()</span></li><li><span class="v">Where = filter_position()</span></li><li><span class="v">Reason = term()</span></li><li><span class="v">filter_position() = first | last | {insert_before, filter_id()} | {insert_after, filter_id()} </span></li></ul><p>Registers a notification filter.
</p><p><strong>Mod</strong> is a module implementing the 
<strong>snmpa_notification_filter</strong> behaviour.</p><p><strong>Data</strong> will be passed on to the filter when calling the
functions of the behaviour.</p><a name="unregister_notification_filter"></a><h3>unregister_notification_filter(Id) -&gt; ok | {error, Reason}</h3><h3>unregister_notification_filter(Agent, Id) -&gt; ok | {error, Reason}</h3><p>Unregister a notification filter</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Id = filter_id()</span></li><li><span class="v">filter_id() = term()</span></li></ul><p>Unregister a notification filter. </p><a name="which_notification_filter"></a><h3>which_notification_filter() -&gt; Filters</h3><h3>which_notification_filter(Agent) -&gt; Filters</h3><p>Which notification filter</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Filters = [filter_id()]</span></li><li><span class="v">filter_id() = term()</span></li></ul><p>List all notification filters in an agent.</p><a name="set_request_limit"></a><h3>set_request_limit(NewLimit) -&gt; {ok, OldLimit} | {error, Reason}</h3><h3>set_request_limit(Agent, NewLimit) -&gt; {ok, OldLimit} | {error, Reason}</h3><p>Change the request limit</p><ul><li><span class="v">NewLimit = OldLimit = infinity | integer() &gt;= 0</span></li><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Changes the request limit. </p><p>Note that this has no effect on the application configuration as
defined by configuration files, so a node restart will revert the 
config to whatever is in those files. </p><p>This function is primarily useful in load regulation 
scenarios. </p><a name="register_subagent"></a><h3>register_subagent(Agent, SubTreeOid, Subagent) -&gt; ok | {error, Reason}</h3><p>Register a sub-agent under a sub-tree</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">SubTreeOid = oid()</span></li><li><span class="v">SubAgent = pid()</span></li></ul><p>Registers a sub-agent under a sub-tree of another agent. </p><p>It is easy to make mistakes when registering sub-agents and
this activity should be done carefully.  For example, a
strange behaviour would result from the following
configuration:</p><pre>
snmp_agent:register_subagent(MAPid,[1,2,3,4],SA1),
snmp_agent:register_subagent(SA1,[1,2,3], SA2).
        </pre><p><strong>SA2</strong> will not get requests starting with object
identifier <strong>[1,2,3]</strong> since <strong>SA1</strong> does not. </p><a name="unregister_subagent"></a><h3>unregister_subagent(Agent, SubagentOidOrPid) -&gt; ok | {ok, SubAgentPid} | {error, Reason}</h3><p>Unregister a sub-agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">SubTreeOidorPid = oid() | pid()</span></li></ul><p>Unregister a sub-agent.  If the second argument is a pid,
then that sub-agent will be unregistered from all trees in
<strong>Agent</strong>. </p><a name="send_notification2"></a><h3>send_notification2(Agent, Notification, SendOpts) -&gt; void()</h3><p>Send notification</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Notification = atom()</span></li><li><span class="v">SendOpts = [send_option()]</span></li><li><span class="v">send_option() = {receiver, receiver()} | {name, notify_name()} | {context, context_name()} | {varbinds, varbinds()} | {local_engine_id, string()} | {extra, extra_info()}</span></li><li><span class="v">receiver() = no_receiver | {tag(), tag_receiver()} | notification_delivery_info()</span></li><li><span class="v">tag() = term(()</span></li><li><span class="v">tag_receiver() = pid() | registered_name() | {Mod, Func, Args}</span></li><li><span class="v">registered_name() = atom()</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">Func = atom()</span></li><li><span class="v">Args = list()</span></li><li><span class="v">notify_name() = string()</span></li><li><span class="v">context_name() = string()</span></li><li><span class="v">varbinds() = [varbind()]</span></li><li><span class="v">varbind() = {variable(), value()} | {column(), row_index(), value()} | {oid(), value()}</span></li><li><span class="v">variable() = atom()</span></li><li><span class="v">value() = term()</span></li><li><span class="v">column() = atom()</span></li><li><span class="v">row_index() = [int()]</span></li><li><span class="v">extra_info() = term()</span></li></ul><p>Send the notification <strong>Notification</strong> to the management 
targets defined for notify-name (<strong>name</strong>) in the 
<strong>snmpNotifyTable</strong> in SNMP-NOTIFICATION-MIB from the 
specified <strong>context</strong>. </p><p>If no <strong>name</strong> is specified (or if it is <strong>""</strong>), the
notification is sent to all management targets. </p><p>If no <strong>context</strong> is specified, the default context, <strong>""</strong>, 
is used. </p><p>The send option <strong>receiver</strong> specifies where information
about delivery of Inform-Requests should be sent.  The agent
sends Inform-Requests and waits for acknowledgments from the
management targets. 
The <strong>receiver</strong> can have three values: </p><ul><li> <p><strong>no_receiver</strong> - No information is delivered. </p> </li><li> <p><strong>notification_delivery_info()</strong> - The information is 
delivered via a function call according to this data. See the 
<a href="#data_types">DATA TYPES</a> section 
above for details. </p> </li><li> <p><strong>{tag(), tag_receiver()}</strong> - The information is delivered 
either via messages or via a function call according to the value 
of <strong>tag_receiver()</strong>. </p> <p>Delivery is done differently depending on the value
of <strong>tag_receiver()</strong>: </p> <ul><li> <p><strong>pid() | registered_name()</strong> - The info will be delivered in  
the following messages: </p> <ul><li> <p><strong>{snmp_targets, tag(), Addresses}</strong></p> <p>This informs the user which target addresses the 
notification was sent to. </p> </li><li> <p><strong>{snmp_notification, tag(), {got_response, Address}}</strong></p> <p>This informs the user that this target address 
acknowledged the notification. </p> </li><li> <p><strong>{snmp_notification, tag(), {no_response, Address}}</strong></p> <p>This informs the user that this target address 
did not acknowledge the notification. </p> </li></ul> <p>The notification is sent as an Inform-Request to each 
target address in <strong>Addresses</strong> and if there are no 
targets for which an Inform-Request is sent, <strong>Addresses</strong> 
is the empty list <strong>[]</strong>. </p> <p>The <strong>tag_receiver()</strong> will first be sent the 
<strong>snmp_targets</strong> message, and then for each address in 
<strong>Addresses</strong> list, one of the two <strong>snmp_notification</strong> 
messages. </p> </li><li> <p><strong>{Mod, Func, Args}</strong> - The info will be delivered via
the function call: </p> <p><strong>Mod:Func([Msg | Args])</strong></p> <p>where <strong>Msg</strong> has the same content and purpose as the 
messages descrived above.</p> </li></ul> </li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The <strong>extra</strong> info is not normally interpreted by the agent, 
instead it is passed through to the 
<a href="snmp_agent_netif">net-if</a> process. It is 
up to the implementor of that process to make use of this data. </p><p>The version of net-if provided by this application makes no use
of this data, with one exception: 
Any tuple containing the atom 
<strong>snmpa_default_notification_extra_info</strong> 
may be used by the agent and is therefor <em>reserved</em>. </p><p>See the net-if incomming messages for sending a 
<a href="./snmp_agent_netif#im_send_pdu"> trap</a> and 
<a href="./snmp_agent_netif#im_send_pdu_req"> notification</a> for more info. </p></div><a name="send_notification"></a><h3>send_notification(Agent, Notification, Receiver)</h3><h3>send_notification(Agent, Notification, Receiver, Varbinds)</h3><h3>send_notification(Agent, Notification, Receiver, NotifyName, Varbinds)</h3><h3>send_notification(Agent, Notification, Receiver, NotifyName, ContextName, Varbinds) -&gt; void()</h3><h3>send_notification(Agent, Notification, Receiver, NotifyName, ContextName, Varbinds, LocalEngineID) -&gt; void()</h3><p>Send a notification</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Notification = atom()</span></li><li><span class="v">Receiver = no_receiver | {Tag, Recv} | notification_delivery_info()</span></li><li><span class="v">Tag = term()</span></li><li><span class="v">Recv = receiver()</span></li><li><span class="v">receiver() = pid() | atom() | {Mod, Func, Args}</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">Func = atom()</span></li><li><span class="v">Args = list()</span></li><li><span class="v">NotifyName = string()</span></li><li><span class="v">ContextName = string()</span></li><li><span class="v">Varbinds = varbinds()</span></li><li><span class="v">varbinds() = [varbind()]</span></li><li><span class="v">varbind() = {Variable, Value} | {Column, RowIndex, Value} | {OID, Value}</span></li><li><span class="v">Variable = atom()</span></li><li><span class="v">Column = atom()</span></li><li><span class="v">OID = oid()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">RowIndex = [int()]</span></li><li><span class="v">LocalEngineID = string()</span></li></ul><p>Sends the notification <strong>Notification</strong> to the
management targets defined for <strong>NotifyName</strong> in the
<strong>snmpNotifyTable</strong> in SNMP-NOTIFICATION-MIB from the
specified context.  </p><p>If no <strong>NotifyName</strong> is specified (or if it is <strong>""</strong>), 
the notification is sent to all management targets 
(<strong>Addresses</strong> below).  </p><p>If no <strong>ContextName</strong> is specified, the default <strong>""</strong> 
context is used. </p><p>The parameter <strong>Receiver</strong> specifies where information
about delivery of Inform-Requests should be sent.  The agent
sends Inform-Requests and waits for acknowledgments from the
managers. <strong>Receiver</strong> can have three values: </p><ul><li> <p><strong>no_receiver</strong> - No information is delivered. </p> </li><li> <p><strong>notification_delivery_info()</strong> - The information is 
delivered via a function call according to this data. See the 
<a href="#data_types">DATA TYPES</a> section 
above for details. </p> </li><li> <p><strong>{Tag, Recv}</strong> - The information is delivered either via 
messages or via a function call according to the value of 
<strong>Recv</strong>. </p> </li></ul><p>If <strong>Receiver</strong> has the value <strong>{Tag, Recv}</strong>, the delivery is
done according to <strong>Recv</strong>: </p><ul><li> <p><strong>pid() | atom()</strong> - The info will be delivered in  
the following messages: </p> <ul><li> <p><strong>{snmp_targets, Tag, Addresses}</strong></p> <p>This inform the user which target addresses the 
notification was sent to. </p> </li><li> <p><strong>{snmp_notification, Tag, {got_response, Address}}</strong></p> <p>This informs the user that this target address 
acknowledged the notification. </p> </li><li> <p><strong>{snmp_notification, Tag, {no_response, Address}}</strong></p> <p>This informs the user that this target address 
did not acknowledge notification. </p> </li></ul> <p>The notification is sent as an Inform-Request to each 
target address in <strong>Addresses</strong> and if there are no 
targets for which an Inform-Request is sent, <strong>Addresses</strong> 
is the empty list <strong>[]</strong>. </p> <p>The <strong>receiver</strong> will first be sent the <strong>snmp_targets</strong> 
message, and then for each address in <strong>Addresses</strong> list, 
one of the two <strong>snmp_notification</strong> messages. </p> </li><li> <p><strong>{Mod, Func, Args}</strong> - The info will be delivered via
the function call: </p> <p><strong>Mod:Func([Msg | Args])</strong></p> <p>where <strong>Msg</strong> has the same content and purpose as the 
messages descrived above.</p> </li></ul><p><strong>Address</strong> is a management target address and <strong>Addresses</strong> is a 
list of management target addresses. They are defined as followes: </p><pre>
        Addresses  = [address()]
        Address    = address()
        address()  = v1_address() | v3_address()
        v1_address() = {TDomain, TAddress}
        v3_address() = {{TDomain, TAddress}, V3MsgData}
        TDomain    = tdoamin()
        TAddress   = taddress()
        tdomain()  = The oid of snmpUDPDomain 
                     This is the only supported transport domain.
        taddress() = [A1, A2, A3, A4, P1, P3]
                     The 4 first bytes makes up the IP-address and the last 2,
                     the UDP-port number.
        V3MsgData  = v3_msg_data()
        v3_msg_data() = term()
</pre><p>If <strong>Receiver</strong> is a <strong>notification_delivery_info()</strong> record,
then the information about the notification delivery will be delivered 
to the <strong>receiver</strong> via the callback functions defined by the 
<a href="snmpa_notification_delivery_info_receiver">snmpa_notification_delivery_info_receiver</a> 
behaviour according to the content of the <strong>notification_delivery_info()</strong> 
record. </p><p>The optional argument <strong>Varbinds</strong> defines
values for the objects in the notification.  If no value is
given for an object, the <strong>Agent</strong> performs a get-operation
to retrieve the value.
</p><p><strong>Varbinds</strong> is a list of <strong>Varbind</strong>, where each
<strong>Varbind</strong> is one of:
</p><ul><li><strong>{Variable, Value}</strong>, where <strong>Variable</strong> is the symbolic name of a scalar variable referred to in the notification specification. </li><li><strong>{Column, RowIndex, Value}</strong>, where <strong>Column</strong> is the symbolic name of a column variable. <strong>RowIndex</strong> is a list of indices for the specified element.  If this is the case, the OBJECT IDENTIFIER sent in the notification is the <strong>RowIndex</strong> appended to the OBJECT IDENTIFIER for the table column. This is the OBJECT IDENTIFIER which specifies the element. </li><li><strong>{OID, Value}</strong>, where <strong>OID</strong> is the OBJECT IDENTIFIER for an instance of an object, scalar variable, or column variable. </li></ul><p>For example, to specify that <strong>sysLocation</strong> should have the
value <strong>"upstairs"</strong> in the notification, we could use one of:
</p><ul><li><strong>{sysLocation, "upstairs"}</strong> or</li><li><strong>{[1,3,6,1,2,1,1,6,0], "upstairs"}</strong> or</li><li><strong>{?sysLocation_instance, "upstairs"}</strong> (provided that the generated <strong>.hrl</strong> file is included)</li></ul><p>If a variable in the notification is a table element, the
<strong>RowIndex</strong> for the element must be given in the
<strong>Varbinds</strong> list. In this case, the OBJECT IDENTIFIER sent
in the notification is the OBJECT IDENTIFIER that identifies this
element.  This OBJECT IDENTIFIER could be used in a get
operation later.
</p><p>This function is asynchronous, and does not return any
information.  If an error occurs, <strong>user_err/2</strong> of the error
report module is called and the notification is discarded.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that the use of the LocalEngineID argument is only intended 
for special cases, if the agent is to "emulate" multiple EngineIDs!
By default, the agent uses the value of <strong>SnmpEngineID</strong> 
(see SNMP-FRAMEWORK-MIB). </p></div><p><strong>ExtraInfo</strong> is not normally used in any way by the agent. 
It is intended to be passed along to the net-if process, which is
a component that a user can implement themself. The users own net-if
may then make use of ExtraInfo. The net-if provided with this 
application does not process ExtraInfo. </p><p>There is one exception. <em>Any</em> tuple containing the atom
<strong>snmpa_default_notification_extra_info</strong> will, in this context,
be considered belonging to this application, and may be processed
by the agent. </p><a name="discovery"></a><h3>discovery(TargetName, Notification) -&gt; {ok, ManagerEngineID} | {error, Reason}</h3><h3>discovery(TargetName, Notification, Varbinds) -&gt; {ok, ManagerEngineID} | {error, Reason}</h3><h3>discovery(TargetName, Notification, DiscoHandler) -&gt; {ok, ManagerEngineID} | {error, Reason}</h3><h3>discovery(TargetName, Notification, ContextName, Varbinds) -&gt; {ok, ManagerEngineID} | {error, Reason}</h3><h3>discovery(TargetName, Notification, Varbinds, DiscoHandler) -&gt; {ok, ManagerEngineID} | {error, Reason}</h3><h3>discovery(TargetName, Notification, ContextName, Varbinds, DiscoHandler) -&gt; {ok, ManagerEngineID} | {error, Reason}</h3><h3>discovery(TargetName, Notification, ContextName, Varbinds, DiscoHandler, ExtraInfo) -&gt; {ok, ManagerEngineID} | {error, Reason}</h3><p>Initiate the discovery process with a manager</p><ul><li><span class="v">TargetName = string()</span></li><li><span class="v">Notification = atom()</span></li><li><span class="v">ContextName = string() (defaults to "")</span></li><li><span class="v">Varbinds = varbinds()</span></li><li><span class="v">varbinds() = [varbind()]</span></li><li><span class="v">DiscoHandler = snmpa_discovery_handler()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">snmpa_discovery_handler() = Module implementing the snmpa_discovery_handler behaviour</span></li><li><span class="v">ManagerEngineID = string()</span></li><li><span class="v">varbind() = {Variable, Value} | {Column, RowIndex, Value} | {OID, Value}</span></li><li><span class="v">Variable = atom()</span></li><li><span class="v">Column = atom()</span></li><li><span class="v">OID = oid()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">RowIndex = [int()]</span></li><li><span class="v">Reason = term()</span></li></ul><p>Initiate the discovery process with the manager identified by
<strong>TargetName</strong> using the notification <strong>Notification</strong>. </p><p>This function is synchronous, which means that it will return when
the discovery process has been completed or failed. </p><p>The <strong>DiscoHandler</strong> module is used during the discovery 
process. See 
<a href="snmpa_discovery_handler">discovery handler</a>
for more info. </p><p>The <strong>ExtraInfo</strong> argument is passed on to the callback functions
of the <strong>DiscoHandler</strong>. </p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If we are not at security-level <strong>noAuthNoPriv</strong>,
this could be complicated, since the agent will then continue 
with stage 2, before which the usm-related updates must be 
done. </p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The default discovery handler will require 
additional actions by the caller and the discovery will not work
if the security-level is higher then <strong>noAuthNoPriv</strong>. </p></div><a name="convert_config"></a><h3>convert_config(OldConfig) -&gt; AgentConfig</h3><p>Convert old snmp config to new agent config</p><ul><li><span class="v">OldConfig = list()</span></li><li><span class="v">AgentConfig = list()</span></li></ul><p>This off-line utility function can be used to convert
the old snmp application config (pre snmp-4.0) to the 
new snmp agent config (as of snmp-4.0).</p><p>For information about the old config (<strong>OldConfig</strong>) 
see the OTP R9C documentation.</p><p>For information about the current agent config 
(<strong>AgentConfig</strong>), see either
the <a href="snmp_app">SNMP application</a> 
part of the reference manual or the 
<a href="snmp_config">Configuring the application</a> 
chapter of the SNMP user's guide.</p><a name="restart_worker"></a><h3>restart_worker() -&gt; void()</h3><h3>restart_worker(Agent) -&gt; void()</h3><p>Restart the worker process of a multi-threaded agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Restart the worker process of a multi-threaded agent.</p><p>This is a utility function, that can be useful when
e.g. debugging instrumentation functions.</p><a name="restart_set_worker"></a><h3>restart_set_worker() -&gt; void()</h3><h3>restart_set_worker(Agent) -&gt; void()</h3><p>Restart the set worker process of a multi-threaded agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Restart the set worker process of a multi-threaded agent.</p><p>This is a utility function, that can be useful when
e.g. debugging instrumentation functions.</p><a name="print_mib_info"></a><h3>print_mib_info() -&gt; void()</h3><p>Print mib info</p><p>Prints the content of all the (snmp) tables and variables 
for all mibs handled by the snmp agent. </p><a name="print_mib_tables"></a><h3>print_mib_tables() -&gt; void()</h3><p>Print mib tables</p><p>Prints the content of all the (snmp) tables 
for all mibs handled by the snmp agent. </p><a name="print_mib_variables"></a><h3>print_mib_variables() -&gt; void()</h3><p>Print mib variables</p><p>Prints the content of all the (snmp) variables 
for all mibs handled by the snmp agent. </p><a name="verbosity"></a><h3>verbosity(Ref,Verbosity) -&gt; void()</h3><p>Assign a new verbosity for the process</p><ul><li><span class="v">Ref = pid() | sub_agents | master_agent | net_if | mib_server | symbolic_store | note_store | local_db</span></li><li><span class="v">Verbosity = verbosity() | {subagents, verbosity()}</span></li><li><span class="v">verbosity() = silence | info | log | debug | trace </span></li></ul><p>Sets verbosity for the designated process. For the lowest 
verbosity <strong>silence</strong>, nothing is printed. The higher the
verbosity, the more is printed. </p><h3>See Also</h3><p>calendar(3), erlc(1) </p><h2>snmpa_conf</h2><p>Utility functions for handling the agent config files.</p><p>The module <strong>snmpa_conf</strong> contains various utility functions to 
used for manipulating (write/append/read) the config files of the
SNMP agent. <a name="types"></a></p><h3>DATA TYPES</h3><pre><code class="">
transportDomain() = transportDomainUdpIpv4 | transportDomainUdpIpv6

transportAddress() =
    transportAddressIPv4() | transportAddressIPv6()

transportAddressWithPort() =
    transportAddressIPv4WithPort() | transportAddressIPv6WithPort()

transportAddressWithoutPort() =
    transportAddressIPv4WithoutPort() | transportAddressIPv6WithoutPort()

transportAddressIPv4() =
    transportAddressIPv4WithPort() | transportAddressIPv4WithoutPort()
transportAddressIPv4WithPort =
    {transportAddressIPv4WithoutPort(), inet:port_number()} |
    [byte() x 4, byte() x 2]
transportAddressIPv4WithoutPort =
    inet:ip4_address() | [byte() x 4]

transportAddressIPv6() =
    transportAddressIPv6WithPort() | transportAddressIPv6WithoutPort()
transportAddressIPv6WithPort =
    {transportAddressIPv6WithoutPort(), inet:port_number()} |
    [word() x 8, inet:port_number()] |
    [word() x 8, byte() x 2] |
    {byte() x 16, byte() x 2]
transportAddressIPv6WithoutPort =
    inet:ip6_address() | [word() x 8] | [byte() x 16]

transportAddressMask() =
    [] | transportAddressWithPort()

byte() = 0..255
word() = 0..65535
    </code></pre><p>For <strong>inet:ip4_address()</strong>, <strong>inet:ip6_address()</strong>
and <strong>inet:port_number()</strong>, see also
<a href="../kernel/inet#type-ip_address">kernel/inet#type-ip_address</a></p><a name="agent_entry"></a><h2>Functions</h2><h3>agent_entry(Tag, Val) -&gt; agent_entry()</h3><p>Create an agent entry</p><ul><li><span class="v">Tag = intAgentTransports | intAgentUDPPort | intAgentMaxPacketSize | snmpEngineMaxMessageSize | snmpEngineID</span></li><li><span class="v">Val = term()</span></li><li><span class="v">agent_entry() = term()</span></li></ul><p>Create an entry for the agent config file, <strong>agent.conf</strong>. </p><p>The type of <strong>Val</strong> depends on the value of <strong>Tag</strong>, 
see 
<a href="./snmp_agent_config_files#agent_information">Agent Information</a> 
for more info. </p><a name="write_agent_config"></a><h3>write_agent_config(Dir, Conf) -&gt; ok</h3><h3>write_agent_config(Dir, Hdr, Conf) -&gt; ok</h3><p>Write the agent config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [agent_entry()]</span></li></ul><p>Write the agent config to the agent config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#agent_information">Agent Information</a> 
for more info. </p><a name="append_agent_config"></a><h3>append_agent_config(Dir, Conf) -&gt; ok</h3><p>Append the agent config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [agent_entry()]</span></li></ul><p>Append the config to the current agent config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#agent_information">Agent Information</a> 
for more info. </p><a name="read_agent_config"></a><h3>read_agent_config(Dir) -&gt; Conf</h3><p>Read the agent config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [agent_entry()]</span></li></ul><p>Read the current agent config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#agent_information">Agent Information</a> 
for more info. </p><a name="standard_entry"></a><h3>standard_entry(Tag, Val) -&gt; standard_entry()</h3><p>Create an standard entry</p><ul><li><span class="v">Tag = sysDescr | sysObjectID | sysContact | sysName | sysLocation | sysServices | snmpEnableAuthenTraps</span></li><li><span class="v">Val = term()</span></li><li><span class="v">standard_entry() = term()</span></li></ul><p>Create an entry for the agent standard config file, 
<strong>standard.conf</strong>. </p><p>The type of <strong>Val</strong> depends on the value of <strong>Tag</strong>, 
see 
<a href="./snmp_agent_config_files#system_information">System Information</a> 
for more info. </p><a name="write_standard_config"></a><h3>write_standard_config(Dir, Conf) -&gt; ok</h3><h3>write_standard_config(Dir, Hdr, Conf) -&gt; ok</h3><p>Write the agent standard config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [standard_entry()]</span></li></ul><p>Write the agent standard config to the agent standard 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#system_information">System Information</a> 
for more info. </p><a name="append_standard_config"></a><h3>append_standard_config(Dir, Conf) -&gt; ok</h3><p>Append the agent standard config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [standard_entry()]</span></li></ul><p>Append the standard config to the current agent standard 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#system_information">System Information</a> 
for more info. </p><a name="read_standard_config"></a><h3>read_standard_config(Dir) -&gt; Conf</h3><p>Read the agent standard config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [standard_entry()]</span></li></ul><p>Read the current agent standard config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#system_information">System Information</a> 
for more info. </p><a name="context_entry"></a><h3>context_entry(Context) -&gt; context_entry()</h3><p>Create an context entry</p><ul><li><span class="v">Context = string()</span></li><li><span class="v">context_entry() = term()</span></li></ul><p>Create an entry for the agent context config file, 
<strong>context.conf</strong>. </p><p>See 
<a href="./snmp_agent_config_files#context">Contexts</a> 
for more info. </p><a name="write_context_config"></a><h3>write_context_config(Dir, Conf) -&gt; ok</h3><h3>write_context_config(Dir, Hdr, Conf) -&gt; ok</h3><p>Write the agent context(s) to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [context_entry()]</span></li></ul><p>Write the agent context config to the agent context 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#context">Contexts</a> 
for more info. </p><a name="append_context_config"></a><h3>append_context_config(Dir, Conf) -&gt; ok</h3><p>Append the agent context(s) to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [context_entry()]</span></li></ul><p>Append the context config to the current agent context 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#context">Contexts</a> 
for more info. </p><a name="read_context_config"></a><h3>read_context_config(Dir) -&gt; Conf</h3><p>Read the agent context config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [context_entry()]</span></li></ul><p>Read the current agent context config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#context">Contexts</a> 
for more info. </p><a name="community_entry"></a><h3>community_entry(CommunityIndex) -&gt; community_entry()</h3><h3>community_entry(CommunityIndex, CommunityName, SecName, ContextName, TransportTag) -&gt; community_entry()</h3><p>Create an community entry</p><ul><li><span class="v">CommunityIndex = string()</span></li><li><span class="v">CommunityName = string()</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">CtxName = string()</span></li><li><span class="v">TransportTag = string()</span></li><li><span class="v">community_entry() = term()</span></li></ul><p>Create an entry for the agent community config file, 
<strong>community.conf</strong>. </p><p><strong>CommunityIndex</strong> must be a <em>non-empty</em> string. </p><p><strong>community_entry("public")</strong> translates to the following call:
<strong>community_entry(CommunityIndex, CommunityIndex, "initial", "", "")</strong>. </p><p><strong>community_entry("all-rights")</strong> translates to the following 
call: <strong>community_entry(CommunityIndex, CommunityIndex, CommunityIndex, "", "")</strong>. </p><p>See 
<a href="./snmp_agent_config_files#community">Community</a> 
for more info. </p><a name="write_community_config"></a><h3>write_community_config(Dir, Conf) -&gt; ok</h3><h3>write_community_config(Dir, Hdr, Conf) -&gt; ok</h3><p>Write the agent community config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [community_entry()]</span></li></ul><p>Write the agent community config to the agent community 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#community">Community</a> 
for more info. </p><a name="append_community_config"></a><h3>append_community_config(Dir, Conf) -&gt; ok</h3><p>Append the agent community config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [community_entry()]</span></li></ul><p>Append the community config to the current agent community 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#community">Community</a> 
for more info. </p><a name="read_community_config"></a><h3>read_community_config(Dir) -&gt; Conf</h3><p>Read the agent community config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [community_entry()]</span></li></ul><p>Read the current agent community config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#community">Communities</a> 
for more info. </p><a name="target_addr_entry"></a><h3>target_addr_entry(Name, Domain, Addr, TagList, ParamsName, EngineId) -&gt; target_addr_entry()</h3><h3>target_addr_entry(Name, Domain, Addr, TagList, ParamsName, EngineId, TMask) -&gt; target_addr_entry()</h3><h3>target_addr_entry(Name, Domain, Addr, TagList, ParamsName, EngineId, TMask, MaxMessageSize) -&gt; target_addr_entry()</h3><h3>target_addr_entry(Name, Domain, Addr, Timeout, RetryCount, TagList, ParamsName, EngineId, TMask, MaxMessageSize) -&gt; target_addr_entry()</h3><p>Create an target_addr entry</p><ul><li><span class="v">Name = string()</span></li><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Ip = transportAddress() (depends on Domain)</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">RetryCount = integer()</span></li><li><span class="v">TagList = string()</span></li><li><span class="v">ParamsName = string()</span></li><li><span class="v">EngineId = string()</span></li><li><span class="v">TMask = transportAddressMask() (depends on Domain)</span></li><li><span class="v">MaxMessageSize = integer()</span></li><li><span class="v">target_addr_entry() = term()</span></li></ul><p>Create an entry for the agent target_addr config file, 
<strong>target_addr.conf</strong>. </p><p><strong>Name</strong> must be a <em>non-empty</em> string. </p><p><strong>target_addr_entry/6</strong> translates to the following call:
<strong>target_addr_entry(Name, Domain, Addr, TagList, ParamsName, EngineId, [])</strong>. </p><p><strong>target_addr_entry/7</strong> translates to the following call:
<strong>target_addr_entry(Name, Domain, Addr, TagList, ParamsName, EngineId, TMask, 2048)</strong>. </p><p><strong>target_addr_entry/8</strong> translates to the following call:
<strong>target_addr_entry(Name, Domain, Addr, 1500, 3, TagList, ParamsName, EngineId, TMask, MaxMessageSize)</strong>. </p><p>See 
<a href="./snmp_agent_config_files#target_addr">Target Address Definitions</a> 
for more info. </p><a name="write_target_addr_config"></a><h3>write_target_addr_config(Dir, Conf) -&gt; ok</h3><h3>write_target_addr_config(Dir, Hdr, Conf) -&gt; ok</h3><p>Write the agent target_addr config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [target_addr_entry()]</span></li></ul><p>Write the agent target_addr config to the agent target_addr 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#target_addr">Target Address Definitions</a> 
for more info. </p><a name="append_target_addr_config"></a><h3>append_target_addr_config(Dir, Conf) -&gt; ok</h3><p>Append the agent target_addr config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [target_addr_entry()]</span></li></ul><p>Append the target_addr config to the current agent target_addr 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#target_addr">Target Address Definitions</a> 
for more info. </p><a name="read_target_addr_config"></a><h3>read_target_addr_config(Dir) -&gt; Conf</h3><p>Read the agent target_addr config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [target_addr_entry()]</span></li></ul><p>Read the current agent target_addr config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#target_addr">Target Address Definitions</a> 
for more info. </p><a name="target_params_entry"></a><h3>target_params_entry(Name, Vsn) -&gt; target_params_entry()</h3><h3>target_params_entry(Name, Vsn, SecName, SecLevel) -&gt; target_params_entry()</h3><h3>target_params_entry(Name, MPModel, SecModel, SecName, SecLevel) -&gt; target_params_entry()</h3><p>Create an target_params entry</p><ul><li><span class="v">Name = string()</span></li><li><span class="v">Vsn = v1 | v2 | v3</span></li><li><span class="v">MPModel = v1 | v2c | v3</span></li><li><span class="v">SecModel = v1 | v2c | usm</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">SecLevel = noAuthNoPriv | authNoPriv | authPriv</span></li><li><span class="v">target_params_entry() = term()</span></li></ul><p>Create an entry for the agent target_params config file, 
<strong>target_params.conf</strong>. </p><p><strong>Name</strong> must be a <em>non-empty</em> string. </p><p><strong>Vsn</strong> translates into <strong>MPModel</strong> and <strong>SecModel</strong> as follows:</p><pre>
\011  Vsn = v1 =&gt; MPModel = v1,  SecModel = v1
\011  Vsn = v2 =&gt; MPModel = v2c, SecModel = v2c
\011  Vsn = v3 =&gt; MPModel = v3,  SecModel = usm
        </pre><p><strong>target_params_entry/2</strong> translates to the following call:
<strong>target_params_entry(Name, Vsn, "initial", noAuthNoPriv)</strong>. </p><p><strong>target_params_entry/4</strong> translates to the following
call: <strong>target_params_entry(Name, MPModel, SecModel, SecName, SecLevel)</strong> where <strong>MPModel</strong> and
<strong>SecModel</strong> is mapped from <strong>Vsn</strong>, see above. </p><p>See 
<a href="./snmp_agent_config_files#target_params">Target Parameters Definitions</a> 
for more info. </p><a name="write_target_params_config"></a><h3>write_target_params_config(Dir, Conf) -&gt; ok</h3><h3>write_target_params_config(Dir, Hdr, Conf) -&gt; ok</h3><p>Write the agent target_params config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [target_params_entry()]</span></li></ul><p>Write the agent target_params config to the agent target_params 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#target_params">Target Parameters Definitions</a> 
for more info. </p><a name="append_target_params_config"></a><h3>append_target_params_config(Dir, Conf) -&gt; ok</h3><p>Append the agent target_params config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [target_params_entry()]</span></li></ul><p>Append the target_params config to the current agent target_params 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#target_params">Target Parameters Definitions</a> 
for more info. </p><a name="read_target_params_config"></a><h3>read_target_params_config(Dir) -&gt; Conf</h3><p>Read the agent target_params config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [target_params_entry()]</span></li></ul><p>Read the current agent target_params config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#target_params">Target Parameters Definitions</a> 
for more info. </p><a name="vacm_entry"></a><h3>vacm_s2g_entry(SecModel, SecName, GroupName) -&gt; vacm_s2g_entry()</h3><h3>vacm_acc_entry(GroupName, Prefix, SecModel, SecLevel, Match, ReadView, WriteView, NotifyView) -&gt; vacm_acc_entry()</h3><h3>vacm_vtf_entry(ViewIndex, ViewSubtree) -&gt; vacm_vtf_entry()</h3><h3>vacm_vtf_entry(ViewIndex, ViewSubtree, ViewStatus, ViewMask) -&gt; vacm_vtf_entry()</h3><p>Create an vacm entry</p><ul><li><span class="v">SecModel = v1 | v2c | usm</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">GroupName = string()</span></li><li><span class="v">Prefix = string()</span></li><li><span class="v">SecLevel = noAuthNoPriv | authNoPriv | authPriv</span></li><li><span class="v">Match = prefix | exact</span></li><li><span class="v">ReadView = string()</span></li><li><span class="v">WriteView = string()</span></li><li><span class="v">NotifyView = string()</span></li><li><span class="v">ViewIndex = integer()</span></li><li><span class="v">ViewSubtree = [integer()]</span></li><li><span class="v">ViewStatus = included | excluded</span></li><li><span class="v">ViewMask = null | [zero_or_one()]</span></li><li><span class="v">zero_or_one() = 0 | 1</span></li><li><span class="v">vacm_s2g_entry() = term()</span></li><li><span class="v">vacm_acc_entry() = term()</span></li><li><span class="v">vacm_vtf_entry() = term()</span></li></ul><p>Create an entry for the agent vacm config file, 
<strong>vacm.conf</strong>. </p><p><strong>vacm_vtf_entry/2</strong> translates to the following call:
<strong>vacm_vtf_entry(ViewIndex, ViewSubtree, included, null)</strong>. </p><p>See 
<a href="./snmp_agent_config_files#vacm">MIB Views for VACM</a> 
for more info. </p><a name="write_vacm_config"></a><h3>write_vacm_config(Dir, Conf) -&gt; ok</h3><h3>write_vacm_config(Dir, Hdr, Conf) -&gt; ok</h3><p>Write the agent vacm config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [vacm_entry()]</span></li><li><span class="v">vacm_entry() = vacm_sg2_entry() | vacm_acc_entry() | vacm_vtf_entry()</span></li></ul><p>Write the agent vacm config to the agent vacm 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#vacm">MIB Views for VACM</a> 
for more info. </p><a name="append_vacm_config"></a><h3>append_vacm_config(Dir, Conf) -&gt; ok</h3><p>Append the agent vacm config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [vacm_entry()]</span></li></ul><p>Append the vacm config to the current agent vacm 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#vacm">MIB Views for VACM</a> 
for more info. </p><a name="read_vacm_config"></a><h3>read_vacm_config(Dir) -&gt; Conf</h3><p>Read the agent vacm config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [vacm_entry()]</span></li></ul><p>Read the current agent vacm config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#vacm">MIB Views for VACM</a> 
for more info. </p><a name="usm_entry"></a><h3>usm_entry(EngineId) -&gt; usm_entry()</h3><h3>usm_entry(EngineID, UserName, SecName, Clone, AuthP, AuthKeyC, OwnAuthKeyC, PrivP, PrivKeyC, OwnPrivKeyC, Public, AuthKey, PrivKey) -&gt; usm_entry()</h3><p>Create an usm entry</p><ul><li><span class="v">EngineId = string()</span></li><li><span class="v">UserName = string()</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">Clone = zeroDotZero | [integer()]</span></li><li><span class="v">AuthP = usmNoAuthProtocol | usmHMACMD5AuthProtocol, | usmHMACSHAAuthProtocol</span></li><li><span class="v">AuthKeyC = string()</span></li><li><span class="v">OwnAuthKeyC = string()</span></li><li><span class="v">PrivP = usmNoPrivProtocol | usmDESPrivProtocol | usmAesCfb128Protocol</span></li><li><span class="v">PrivKeyC = string()</span></li><li><span class="v">OwnPrivKeyC = string()</span></li><li><span class="v">Public = string()</span></li><li><span class="v">AuthKey = [integer()]</span></li><li><span class="v">PrivKey = [integer()]</span></li><li><span class="v">usm_entry() = term()</span></li></ul><p>Create an entry for the agent vacm config file, 
<strong>vacm.conf</strong>. </p><p><strong>usm_entry/1</strong> translates to the following call:
<strong>usm_entry("initial", "initial", zeroDotZero, usmNoAuthProtocol, "", "", usmNoPrivProtocol, "", "", "", "", "")</strong>. </p><p>See 
<a href="./snmp_agent_config_files#usm">Security data for USM</a> 
for more info. </p><a name="write_usm_config"></a><h3>write_usm_config(Dir, Conf) -&gt; ok</h3><h3>write_usm_config(Dir, Hdr, Conf) -&gt; ok</h3><p>Write the agent usm config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [usm_entry()]</span></li></ul><p>Write the agent usm config to the agent usm 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#usm">Security data for USM</a> 
for more info. </p><a name="append_usm_config"></a><h3>append_usm_config(Dir, Conf) -&gt; ok</h3><p>Append the agent usm config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [usm_entry()]</span></li></ul><p>Append the usm config to the current agent vacm 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#usm">Security data for USM</a> 
for more info. </p><a name="read_usm_config"></a><h3>read_usm_config(Dir) -&gt; Conf</h3><p>Read the agent usm config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [usm_entry()]</span></li></ul><p>Read the current agent usm config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#usm">Security data for USM</a> 
for more info. </p><a name="notify_entry"></a><h3>notify_entry(Name, Tag, Type) -&gt; notify_entry()</h3><p>Create an notify entry</p><ul><li><span class="v">Name = string()</span></li><li><span class="v">Tag = string()</span></li><li><span class="v">Type = trap | inform</span></li><li><span class="v">community_entry() = term()</span></li></ul><p>Create an entry for the agent notify config file, 
<strong>notify.conf</strong>. </p><p><strong>Name</strong> must be a <em>non-empty</em> string. </p><p>See 
<a href="./snmp_agent_config_files#notify">Notify Definitions</a> 
for more info. </p><a name="write_notify_config"></a><h3>write_notify_config(Dir, Conf) -&gt; ok</h3><h3>write_notify_config(Dir, Hdr, Conf) -&gt; ok</h3><p>Write the agent notify config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [notify_entry()]</span></li></ul><p>Write the agent notify config to the agent notify 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#notify">Notify Definitions</a> 
for more info. </p><a name="append_notify_config"></a><h3>append_notify_config(Dir, Conf) -&gt; ok</h3><p>Append the agent notify config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [notify_entry()]</span></li></ul><p>Append the notify config to the current agent notify 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#notify">Notify Definitions</a> 
for more info. </p><a name="read_notify_config"></a><h3>read_notify_config(Dir) -&gt; Conf</h3><p>Read the agent notify config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [community_entry()]</span></li></ul><p>Read the current agent notify config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#notify">Notify Definitions</a> 
for more info. </p><a name="end"></a><h2>snmpa_discovery_handler</h2><p>Behaviour module for the SNMP agent discovery handler.</p><p>This module defines the behaviour of the agent discovery
handler. A <strong>snmpa_discovery_handler</strong> compliant module 
must export the following functions: <ul><li> <p><a href="#stage1_finish">stage1_finish/2</a></p> </li></ul>The semantics of them and their exact signatures are explained
below. <a name="stage1_finish"></a></p><h2>Functions</h2><h3>stage1_finish(TargetName, ManagerEngineID, ExtraInfo) -&gt; ignore | {ok, usm_entry() | [usm_entry()]} | {ok, usm_entry() | [usm_entry()], NewExtraInfo}</h3><p>Discovery stage 1 finish</p><ul><li><span class="v">TargetName = string()</span></li><li><span class="v">ManagerEngineID = string()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">usm_entry() = tuple() compatible with usm.conf</span></li><li><span class="v">NewExtraInfo = term()</span></li></ul><p>This function is called at the end of stage 1 of the 
discovery process. It should return either the atom 
<strong>ignore</strong> or <strong>{ok, usm_entry() | [usm_entry()]}</strong>. See 
<a href="./snmp_agent_config_files#usm">usm_entry()</a>
and 
<a href="./snmpa_conf#usm_entry">usm_entry/13</a>
for more info. </p><p>If the function returns <strong>ignore</strong>, then it is assumed that 
either: </p><ul><li>The caller (of the discovery function) will make the  needed updates later. </li><li>The callback function itself did the updates. </li></ul><p>In either case, the agent will do nothing, but return
the retrieved ManagerEngineID (see 
<a href="./snmpa#discovery">discovery</a>
for more info) and possible continue with stage 2 of 
the discovery process. </p><p>The <strong>ExtraInfo</strong> argument is passed on from the 
<a href="./snmpa#discovery">discovery</a>
function. </p><p>This function may return an updated <strong>NewExtraInfo</strong> 
that will be used in subsequent calls to the callback 
functions. Intended for future use. </p><p>The purpose of this function is to generate the usm-
related security data needed for usm processing in the 
agent. Specifically, updating the usmUserTable. </p><p>When an <strong>usm_entry()</strong> tuple (or a list of such
tuples) is returned, this data is then added to the 
<strong>usmUserTable</strong> by the (master-) agent. </p><p>When an <strong>usm_entry()</strong> tuple (or a list of such
tuples) is returned, this data is then added to the 
<strong>usmUserTable</strong> by the (master-) agent. </p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that the function does not check if this entry 
already exists. </p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that this function is executed in the context of 
the master-agent process. </p></div><h2>snmpa_error_report</h2><p>Behaviour module for reporting SNMP agent errors</p><p><a name="desc"></a>This module defines the behaviour of the agent error reporting.
A <strong>snmpa_error_report</strong> compliant module 
must export the following functions: <ul><li> <p>config_err/2</p> </li><li> <p>user_err/2</p> </li></ul>The semantics of them and their exact signatures are explained
below. </p><h2>Functions</h2><h3>config_err(Format, Args) -&gt; void()</h3><p>Called if a configuration error occurs</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><p>The function is called if an error occurs during the
configuration phase, for example if a syntax error is found in
a configuration file.
</p><p><strong>Format</strong> and <strong>Args</strong> are as in
<strong>io:format(Format, Args)</strong>.</p><h3>user_err(Format, Args) -&gt; void()</h3><p>Called if a user related error occurs</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><p>The function is called if a user related error occurs at
run-time, for example if a user defined instrumentation
function returns erroneous.
</p><p><strong>Format</strong> and <strong>Args</strong> are as in
<strong>io:format(Format, Args)</strong>.</p><h2>snmpa_error</h2><p>Functions for Reporting SNMP Errors</p><p><a name="desc"></a>The module <strong>snmpa_error</strong> contains two callback functions 
which are called if an error occurs at different times during agent 
operation. These functions in turn calls the corresponding function
in the configured error report module, which implements the actual 
report functionality.
Two simple implementation(s) is provided with the
toolkit; the modules 
<a href="snmpa_error_logger">snmpa_error_logger</a> 
which is the default and 
<a href="snmpa_error_io">snmpa_error_io</a>.
The error report module is configured using the directive 
<strong>error_report_mod</strong>, see
<a href="./snmp_config#configuration_params">configuration parameters</a>.
<a name="config_err"></a></p><h2>Functions</h2><h3>config_err(Format, Args) -&gt; void()</h3><p>Called if a configuration error occurs</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><p>The function is called if an error occurs during the
configuration phase, for example if a syntax error is found in
a configuration file.
</p><p><strong>Format</strong> and <strong>Args</strong> are as in
<strong>io:format(Format, Args)</strong>.</p><a name="user_err"></a><h3>user_err(Format, Args) -&gt; void()</h3><p>Called if a user related error occurs</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><p>The function is called if a user related error occurs at
run-time, for example if a user defined instrumentation
function returns erroneous.
</p><p><strong>Format</strong> and <strong>Args</strong> are as in
<strong>io:format(Format, Args)</strong>.</p><h2>snmpa_error_io</h2><p>Functions for Reporting SNMP Errors on stdio</p><p>The module <strong>snmpa_error_io</strong> implements the 
<strong>snmp_error_report</strong> behaviour 
(see <a href="snmpa_error_report">snmpa_error_report</a>) 
containing two callback functions which are called in order to 
report SNMP errors.
This module provides a simple mechanism for reporting SNMP
errors. Errors are written to stdout using the <strong>io</strong> module.
It is provided as an simple example.
This module needs to be explicitly configured, see
<a href="./snmpa_error#desc">snmpa_error</a> and
<a href="./snmp_config#configuration_params">configuration parameters</a>.
</p><h2>Functions</h2><h3>config_err(Format, Args) -&gt; void()</h3><p>Called if a configuration error occurs</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><p>The function is called if an error occurs during the
configuration phase, for example if a syntax error is found in
a configuration file.
</p><p><strong>Format</strong> and <strong>Args</strong> are as in
<strong>io:format(Format, Args)</strong>.</p><h3>user_err(Format, Args) -&gt; void()</h3><p>Called if a user related error occurs</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><p>The function is called if a user related error occurs at
run-time, for example if a user defined instrumentation
function returns erroneous.
</p><p><strong>Format</strong> and <strong>Args</strong> are as in
<strong>io:format(Format, Args)</strong>.</p><h2>snmpa_error_logger</h2><p>Functions for Reporting SNMP Errors through the error_logger</p><p>The module <strong>snmpa_error_logger</strong> implements the 
<strong>snmpa_error_report</strong> behaviour 
(see <a href="snmpa_error_report">snmpa_error_report</a>) 
containing two callback functions which are called in order to 
report SNMP errors.
This module provides a simple mechanism for reporting SNMP
errors. Errors are sent to the <strong>error_logger</strong> after a 
size check. Messages are truncated after 1024 chars. 
It is provided as an example.
This module is the default error report module, but can be 
explicitly configured, see
<a href="./snmpa_error#desc">snmpa_error</a> and
<a href="./snmp_config#configuration_params">configuration parameters</a>.
</p><h2>Functions</h2><h3>config_err(Format, Args) -&gt; void()</h3><p>Called if a configuration error occurs</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><p>The function is called if an error occurs during the
configuration phase, for example if a syntax error is found in
a configuration file.
</p><p><strong>Format</strong> and <strong>Args</strong> are as in
<strong>io:format(Format, Args)</strong>.</p><h3>user_err(Format, Args) -&gt; void()</h3><p>Called if a user related error occurs</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><p>The function is called if a user related error occurs at
run-time, for example if a user defined instrumentation
function returns erroneous.
</p><p><strong>Format</strong> and <strong>Args</strong> are as in
<strong>io:format(Format, Args)</strong>.</p><h3>See Also</h3><p>error_logger(3)</p><h2>snmpa_local_db</h2><p>The SNMP built-in database</p><p>The module <strong>snmpa_local_db</strong> contains functions for
implementing tables (and variables) using the SNMP built-in 
database. The database exists in two instances, one volatile 
and one persistent. The volatile database is implemented with 
ets. The persistent database is implemented with dets. 
There is a scaling problem with this database.
<ul><li>Insertions and deletions are inefficient for large tables. </li></ul>This problem is best solved by using Mnesia instead.
The following functions describe the interface to 
<strong>snmpa_local_db</strong>. Each function has a Mnesia equivalent. 
The argument <strong>NameDb</strong> is a tuple <strong>{Name, Db}</strong> where 
<strong>Name</strong> is the symbolic name of the managed object (as defined 
in the MIB), and <strong>Db</strong> is either <strong>volatile</strong> or 
<strong>persistent</strong>. <strong>mnesia</strong> is not possible since all these 
functions are <strong>snmpa_local_db</strong> specific.
</p><h3>Common Data Types</h3><p>In the functions defined below, the following types are
used:
</p><ul><li> <p><strong>NameDb = {Name, Db}</strong></p> </li><li> <p><strong>Name = atom(), Db = volatile | persistent</strong></p> </li><li> <p><strong>RowIndex = [int()]</strong></p> </li><li> <p><strong>Cols = [Col] | [{Col, Value}], Col = int(), Value = term()</strong></p> </li></ul><p>where <strong>RowIndex</strong> denotes the last part of the OID, that
specifies the index of the row in the table.  <strong>Cols</strong> is a
list of column numbers in case of a get operation, and a list of
column numbers and values in case of a set operation.
</p><h2>Functions</h2><h3>dump() -&gt; ok | {error, Reason}</h3><p>Dump the database to disk</p><ul><li><span class="v">Reason = term()</span></li></ul><p>This function can be used to manually dump the database 
to file.</p><h3>match(NameDb, Pattern)</h3><p>Perform a match on the table</p><p>Performs an ets/dets matching on the table. 
See Stdlib documentation, module ets, for a description of 
<strong>Pattern</strong> and the return values.</p><h3>print()</h3><h3>print(TableName)</h3><h3>print(TableName, Db)</h3><p>Print the database to screen</p><ul><li><span class="v">TableName = atom()</span></li></ul><p>Prints the contents of the database on
screen. This is useful for debugging since the 
<strong>STANDARD-MIB</strong> and <strong>OTP-SNMPEA-MIB</strong> 
(and maybe your own MIBs) are stored in <strong>snmpa_local_db</strong>.
</p><p><strong>TableName</strong> is an atom for a table in the database. 
When no name is supplied, the whole database is shown.</p><h3>table_create(NameDb) -&gt; bool()</h3><p>Create a table</p><p>Creates a table. If the table already exist, the old copy
is destroyed.
</p><p>Returns <strong>false</strong> if the <strong>NameDb</strong> argument is
incorrectly specified, <strong>true</strong> otherwise.</p><h3>table_create_row(NameDb, RowIndex, Row) -&gt; bool()</h3><p>Create a row in a table</p><ul><li><span class="v">Row = {Val1, Val2, ..., ValN}</span></li><li><span class="v">Val1 = Val2 = ... = ValN = term()</span></li></ul><p>Creates a row in a table.  <strong>Row</strong> is a tuple with
values for all columns, including the index columns.</p><h3>table_delete(NameDb) -&gt; void()</h3><p>Delete a table</p><p>Deletes a table.</p><h3>table_delete_row(NameDb, RowIndex) -&gt; bool()</h3><p>Delete the row in the table</p><p>Deletes the row in the table.</p><h3>table_exists(NameDb) -&gt; bool()</h3><p>Check if a table exists</p><p>Checks if a table exists.</p><h3>table_get_row(NameDb, RowIndex) -&gt; Row | undefined</h3><p>Get a row from the table</p><ul><li><span class="v">Row = {Val1, Val2, ..., ValN}</span></li><li><span class="v">Val1 = Val2 = ... = ValN = term()</span></li></ul><p><strong>Row</strong> is a tuple with values for all columns,
including the index columns.</p><h3>See Also</h3><p>ets(3), dets(3), snmp_generic(3)
</p><h2>snmpa_mib_data</h2><p>Behaviour module for the SNMP agent mib-server 
  data module.</p><p>This module defines the behaviour of the SNMP agent mib-server 
data module. A <strong>snmpa_mib_data</strong> compliant module 
must export the following functions: <ul><li> <a href="#new">new/1</a> </li><li> <a href="#close">close/1</a> </li><li> <a href="#sync">sync/1</a> </li><li> <a href="#load_mib">load_mib/4</a> </li><li> <a href="#unload_mib">unload_mib/4</a> </li><li> <a href="#lookup">lookup/2</a> </li><li> <a href="#next">next/3</a> </li><li> <a href="#register_subagent">register_subagent/3</a> </li><li> <a href="#unregister_subagent">unregister_subagent/2</a> </li><li> <a href="#which_mib">which_mib/2</a> </li><li> <a href="#which_mibs">which_mibs/1</a> </li><li> <a href="#whereis_mib">whereis_mib/2</a> </li><li> <a href="#dump">dump/2</a> </li><li> <a href="#info">info/1</a> </li><li> <a href="#backup">backup/2</a> </li><li> <a href="#code_change">code_change/4</a> </li></ul>The semantics of them and their exact signatures are 
explained below. Note that the data extracted from the imported (loaded) 
mibs are stored partly by the mib-server and partly by the 
symbolic-store server. See the default mib-server data 
module, <strong>snmpa_mib_data_tttn</strong> for details. </p><h3>CALLBACK FUNCTIONS</h3><p>The following functions must be exported from a 
<strong>mib-server</strong> data callback module: </p><a name="new"></a><h2>Functions</h2><h3>Module:new(Storage) -&gt; State</h3><p>Create new (mib-server) data instance</p><ul><li><span class="v">Storage = mib_storage()</span></li><li><span class="v">State = term()</span></li></ul><p>Create a new mib-server data instance. </p><a name="close"></a><h3>Module:close(State) -&gt; void()</h3><p>Close the mib-server data instance</p><ul><li><span class="v">State = term()</span></li></ul><p>Close the mib-storage.</p><a name="sync"></a><h3>Module:sync(State) -&gt; void()</h3><p>Synchronize to disc</p><ul><li><span class="v">State = term()</span></li></ul><p>Synchronize (write to disc, if possible) the mib-server data. 
This depends on the <strong>mib_storage</strong> option, and will only have 
an effect if the mib-storage option has an actual disc component 
(such as dets, or ets with a file). </p><a name="load_mib"></a><h3>Module:load_mib(State, Filename, MeOverride, TeOverride) -&gt; {ok, NewState} | {error, Reason}</h3><p>Load a mib into the mib-server</p><ul><li><span class="v">State = NewState = term()</span></li><li><span class="v">Filename = filename()</span></li><li><span class="v">MeOverride = boolean()</span></li><li><span class="v">TeOverride = boolean()</span></li><li><span class="v">Reason = already_loaded | term()</span></li></ul><p>Load the mib specified by the <strong>Filename</strong> argument 
into the mib-server. 
The <strong>MeOverride</strong> and <strong>TeOverride</strong> arguments 
specifies how the mib-server shall handle duplicate mib- and trap-
entries. </p><a name="unload_mib"></a><h3>Module:unload_mib(State, Filename) -&gt; {ok, NewState} | {error, Reason}</h3><p>Unload mib from the mib-server</p><ul><li><span class="v">State = NewState = term()</span></li><li><span class="v">Filename = filename()</span></li><li><span class="v">Reason = not_loaded | term()</span></li></ul><p>Unload the mib specified by the <strong>Filename</strong> argument 
from the mib-server. </p><a name="lookup"></a><h3>Module:lookup(State, Oid) -&gt; Reply</h3><p>Find the mib-entry corresponding to the Oid</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = {variable, ME} | {table_column, ME, TEOid} | {subagent, SAPid, SAOid} | {false, Reason}</span></li><li><span class="v">Oid = TEOid = SAOid = oid()</span></li><li><span class="v">SAPid = pid()</span></li><li><span class="v">ME = me()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Find the mib-entry corresponding to the <strong>Oid</strong>. 
If it is a variable, the <strong>Oid</strong> must be 
&lt;Oid for var&gt;.0 
and if it is a table, <strong>Oid</strong> must be 
&lt;table&gt;.&lt;entry&gt;.&lt;col&gt;.&lt;any&gt;.</p><a name="next"></a><h3>Module:next(State, Oid, MibView) -&gt; Reply</h3><p>Finds the lexicographically next oid</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = false | endOfTable | {subagent, SAPid, SAOid} | {variable, ME, VarOid} | {table, TableOid, TableRestOid, ME}</span></li><li><span class="v">Oid = SAOid = VarOid = TableOid = TableRestOid = oid()</span></li><li><span class="v">SAPid = pid()</span></li><li><span class="v">ME = me()</span></li></ul><p>Finds the lexicographically next oid. </p><a name="register_subagent"></a><h3>Module:register_subagent(State, Oid, Pid) -&gt; Reply</h3><p>Register the subagent</p><ul><li><span class="v">State = NewState = term()</span></li><li><span class="v">Reply = {ok, NewState} | {error, Reason}</span></li><li><span class="v">Oid = oid()</span></li><li><span class="v">Pid = pid()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Register the subagent, process, 
handling part of the mib-tree. </p><a name="unregister_subagent"></a><h3>Module:unregister_subagent(State, PidOrOid) -&gt; Reply</h3><p>Unregister the subagent</p><ul><li><span class="v">State = NewState = term()</span></li><li><span class="v">Reply = {ok, NewState} | {ok, NewState, Pid} | {error, Reason}</span></li><li><span class="v">PidOrOid = pid() | oid()</span></li><li><span class="v">Pid = pid()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Unregister the subagent, handling part of the mib-tree, 
as specified by the <strong>oid()</strong> or <strong>pid()</strong> 
(<strong>PidOrOid</strong>). </p><p>When unregister the subagent using an <strong>oid()</strong>, the <strong>pid()</strong> 
of the process handling the sub-tree is also returned. </p><a name="dump"></a><h3>Module:dump(State, Destination) -&gt; Reply</h3><p>Unregister the subagent</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = ok | {error, Reason}</span></li><li><span class="v">Destination = io | filename()</span></li><li><span class="v">Pid = pid()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Dump the mib-server data to <strong>stdio</strong> (Destination = <strong>io</strong>) or
the specified file. </p><a name="which_mib"></a><h3>Module:which_mib(State, Oid) -&gt; Reply</h3><p>Retrieve the mib file for an oid()</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = {ok, MibFile} | {error, Reason}</span></li><li><span class="v">Oid = oid()</span></li><li><span class="v">MibFile = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retrieve the mib-file to which an given <strong>oid()</strong> belongs. </p><a name="which_mibs"></a><h3>Module:which_mibs(State) -&gt; Reply</h3><p>Retrieve all loaded mib files</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = [{MibName, Filename}]</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">Filename = string()</span></li></ul><p>Retrieve all loaded mib-files. </p><a name="whereis_mib"></a><h3>Module:whereis_mib(State, MibName) -&gt; Reply</h3><p>Retrieve the mib file for the mib</p><ul><li><span class="v">State = term()</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">Reply = {ok, Filename} | {error, Reason}</span></li><li><span class="v">Filename = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retrieve the mib file for the mib. </p><a name="info"></a><h3>Module:info(State) -&gt; Reply</h3><p>Retrieve misc info for the mib data</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = {ok, Filename} | {error, Reason}</span></li><li><span class="v">Filename = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retrieve misc info for the mib data. </p><p>This is a utility function used to inspect, for instance, 
memory usage, in a simple way. </p><a name="backup"></a><h3>Module:backup(State, BackupDir) -&gt; Reply</h3><p>Perform a backup of the mib-server data</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = ok | {error, Reason}</span></li><li><span class="v">BackupDir = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Perform a backup of the mib-server data. </p><p>Note that its implementation dependant (and also 
dependent on mib-storage is used) if a backup is possible. </p><a name="code_change"></a><h3>Module:code_change(Destination, Vsn, Extra, State) -&gt; NewState</h3><p>Perform a code-change</p><ul><li><span class="v">Destination = up | down</span></li><li><span class="v">Vsn = term()</span></li><li><span class="v">Extra = term()</span></li><li><span class="v">State = NewState = term()</span></li></ul><p>Perform a code-change (upgrade or downgrade). </p><p>See 
<a href="./gen_server">gen_server</a>
for more info regarding the <strong>Vsn</strong> and <strong>Extra</strong> arguments. </p><h2>snmpa_mib_storage</h2><p>
    Behaviour module for the SNMP agent mib storage. 
</p><p>This module defines the behaviour of the SNMP agent mib storage. The mib storage is used by the agent to store internal mib-
related information. The mib storage module is used by several entities, 
not just the mib-server. A <strong>snmpa_mib_storage</strong> compliant module 
must export the following functions: <ul><li> <a href="#open">open/5</a> </li><li> <a href="#close">close/1</a> </li><li> <a href="#read">read/2</a> </li><li> <a href="#write">write/2</a> </li><li> <a href="#delete1">delete/1</a> </li><li> <a href="#delete2">delete/2</a> </li><li> <a href="#match_object">match_object/2</a> </li><li> <a href="#match_delete">match_delete/2</a> </li><li> <a href="#tab2list">tab2list/1</a> </li><li> <a href="#info">info/1</a> </li><li> <a href="#sync">sync/1</a> </li><li> <a href="#backup">backup/2</a> </li></ul>The semantics of them and their exact signatures are 
explained below. </p><h3>CALLBACK FUNCTIONS</h3><p>The following functions must be exported from a 
<strong>mib-server</strong> data callback module: </p><a name="open"></a><h2>Functions</h2><h3>Module:open(Name, RecordName, Fields, Type, Options) -&gt; {ok, TabId} | {error, Reason}</h3><p>Create new (mib-server) data instance</p><ul><li><span class="v">Name = atom()</span></li><li><span class="v">RecordName = atom()</span></li><li><span class="v">Fields = [atom()]</span></li><li><span class="v">Type = set | bag()</span></li><li><span class="v">Options = list()</span></li><li><span class="v">TabId = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Create or open a mib storage table. </p><p>Note that the <strong>RecordName</strong> and <strong>Fields</strong> arguments 
my not be used in all implementations (they are actually only 
needed for mnesia-based implementations). </p><p>Note also that the <strong>Options</strong> argument comes from
the <strong>options</strong> config option of the mib-storage config option, 
and is passed on as is. </p><a name="close"></a><h3>Module:close(TabId) -&gt; void()</h3><p>Close the mib-storage table</p><ul><li><span class="v">State = term()</span></li></ul><p>Close the mib-storage table.</p><a name="read"></a><h3>Module:read(TabId, Key) -&gt; false | {value, Record}</h3><p>Read a record from the mib-storage table</p><ul><li><span class="v">TabId = term()</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Record = tuple()</span></li></ul><p>Read a record from the mib-storage table. </p><a name="write"></a><h3>Module:write(TabId, Record) -&gt; ok | {error, Reason}</h3><p>Write a record to the mib-storage table</p><ul><li><span class="v">TabId = term()</span></li><li><span class="v">Record = tuple()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Write a record to the mib-storage table. </p><a name="delete1"></a><h3>Module:delete(TabId) -&gt; void()</h3><p>Delete an entire mib-storage table</p><ul><li><span class="v">TabId = term()</span></li></ul><p>Delete an entire mib-storage table. </p><a name="delete2"></a><h3>Module:delete(TabId, Key) -&gt; ok | {error, Reason}</h3><p>Delete a record from the mib-storage table</p><ul><li><span class="v">TabId = term()</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a record from the mib-storage table. </p><a name="match_object"></a><h3>Module:match_object(TabId, Pattern) -&gt; {ok, Recs} | {error, Reason}</h3><p>Search the mib-storage table for record matching pattern</p><ul><li><span class="v">TabId = term()</span></li><li><span class="v">Pattern = match_pattern()</span></li><li><span class="v">Recs = [tuple()]</span></li><li><span class="v">Reason = term()</span></li></ul><p>Search the mib-storage table for record that match the
specified pattern. </p><a name="match_delete"></a><h3>Module:match_delete(TabId, Pattern) -&gt; {ok, Recs} | {error, Reason}</h3><p>Delete records in the mib-storage table matching pattern</p><ul><li><span class="v">TabId = term()</span></li><li><span class="v">Pattern = match_pattern()</span></li><li><span class="v">Recs = [tuple()]</span></li><li><span class="v">Reason = term()</span></li></ul><p>Search the mib-storage table for record that match the
specified pattern and then delete them. The records deleted are
also returned. </p><a name="tab2list"></a><h3>Module:tab2list(TabId) -&gt; Recs</h3><p>Return all records of the mib-storage table</p><ul><li><span class="v">TabId = term()</span></li><li><span class="v">Recs = [tuple()]</span></li></ul><p>Return all records in the mib-storage table in the form 
of a list. </p><a name="info"></a><h3>Module:info(TabId) -&gt; {ok, Info} | {error, Reason}</h3><p>Returns information about the mib-storage table. </p><ul><li><span class="v">TabId = term()</span></li><li><span class="v">Info = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retrieve implementation dependent mib-storage table 
information. </p><a name="sync"></a><h3>Module:sync(TabId) -&gt; void()</h3><p>Synchronize mib-storage table</p><ul><li><span class="v">TabId = term()</span></li></ul><p>Synchronize the mib-storage table. </p><p>What this means, if anything, is implementation dependent. </p><a name="backup"></a><h3>Module:backup(TabId, BackupDir) -&gt; ok | {error, Reason}</h3><p>Perform a backup of the mib-storage table</p><ul><li><span class="v">TabId = term()</span></li><li><span class="v">BackupDir = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Perform a backup of the mib-storage table. </p><p>What this means, if anything, is implementation dependent. </p><h2>snmpa_mpd</h2><p>Message Processing and Dispatch module for the SNMP agent</p><p>The module <strong>snmpa_mpd</strong> implements the version independent
Message Processing and Dispatch functionality in SNMP for the agent. 
It is supposed to be used from a Network Interface process 
(<a href="snmp_agent_netif">Definition of Agent Net if</a>).
<a name="init"></a></p><h3>DATA TYPES</h3><p>See the <a href="./snmpa_conf#types"> data types in </a>.</p><h2>Functions</h2><h3>init(Vsns) -&gt; mpd_state()</h3><p>Initialize the MPD module</p><ul><li><span class="v">Vsns = [Vsn]</span></li><li><span class="v">Vsn = v1 | v2 | v3</span></li></ul><p>This function can be called from the net_if process at start-up.
The options list defines which versions to use.
</p><p>It also initializes some SNMP counters.
</p><a name="process_packet"></a><h3>process_packet(Packet, From, State, NoteStore, Log) -&gt; {ok, Vsn, Pdu, PduMS, ACMData} | {discarded, Reason} | {discovery, DiscoPacket}</h3><h3>process_packet(Packet, From, LocalEngineID, State, NoteStore, Log) -&gt; {ok, Vsn, Pdu, PduMS, ACMData} | {discarded, Reason} | {discovery, DiscoPacket}</h3><p>Process a packet received from the network</p><ul><li><span class="v">Packet = binary()</span></li><li><span class="v">From = {TDomain, TAddr}</span></li><li><span class="v">TDomain = transportDomainUdpIpv4 | transportDomainUdpIpv6</span></li><li><span class="v">TAddr = {IpAddr, IpPort}</span></li><li><span class="v">LocalEngineID = string()</span></li><li><span class="v">IpAddr = </span></li><li><span class="v">IpPort = inet:port_number()</span></li><li><span class="v">State = mpd_state()</span></li><li><span class="v">NoteStore = pid()</span></li><li><span class="v">Log = snmp_log()</span></li><li><span class="v">Vsn = 'version-1' | 'version-2' | 'version-3'</span></li><li><span class="v">Pdu = #pdu</span></li><li><span class="v">PduMs = integer()</span></li><li><span class="v">ACMData = acm_data()</span></li><li><span class="v">Reason = term()</span></li><li><span class="v">DiscoPacket = binary()</span></li></ul><p>Processes an incoming packet.  Performs authentication and 
decryption as necessary.  The return values should be passed to the
agent.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that the use of the LocalEngineID argument is only intended 
for special cases, if the agent is to "emulate" multiple EngineIDs!
By default, the agent uses the value of <strong>SnmpEngineID</strong> 
(see SNMP-FRAMEWORK-MIB). </p></div><a name="generate_response_msg"></a><h3>generate_response_msg(Vsn, RePdu, Type, ACMData, Log) -&gt; {ok, Packet} | {discarded, Reason}</h3><h3>generate_response_msg(Vsn, RePdu, Type, ACMData, LocalEngineID, Log) -&gt; {ok, Packet} | {discarded, Reason}</h3><p>Generate a response packet to be sent to the network</p><ul><li><span class="v">Vsn = 'version-1' | 'version-2' | 'version-3'</span></li><li><span class="v">RePdu = #pdu</span></li><li><span class="v">Type = atom()</span></li><li><span class="v">ACMData = acm_data()</span></li><li><span class="v">LocalEngineID = string()</span></li><li><span class="v">Packet = binary()</span></li></ul><p>Generates a possibly encrypted response packet to be sent to the
network. <strong>Type</strong> is the <strong>#pdu.type</strong> of the original
request.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that the use of the LocalEngineID argument is only intended 
for special cases, if the agent is to "emulate" multiple EngineIDs!
By default, the agent uses the value of <strong>SnmpEngineID</strong> 
(see SNMP-FRAMEWORK-MIB). </p></div><a name="generate_msg"></a><h3>generate_msg(Vsn, NoteStore, Pdu, MsgData, To) -&gt; {ok, PacketsAndAddresses} | {discarded, Reason}</h3><h3>generate_msg(Vsn, NoteStore, Pdu, MsgData, LocalEngineID, To) -&gt; {ok, PacketsAndAddresses} | {discarded, Reason}</h3><p>Generate a request message to be sent to the network</p><ul><li><span class="v">Vsn = 'version-1' | 'version-2' | 'version-3'</span></li><li><span class="v">NoteStore = pid()</span></li><li><span class="v">Pdu = #pdu</span></li><li><span class="v">MsgData = msg_data()</span></li><li><span class="v">LocalEngineID = string()</span></li><li><span class="v">To = [dest_addrs()]</span></li><li><span class="v">PacketsAndAddresses = [{TDomain, TAddress, Packet}]</span></li><li><span class="v">TDomain = snmpUDPDomain</span></li><li><span class="v">TAddress = {Ip, Udp}</span></li><li><span class="v">Ip = {integer(), integer(), integer(), integer()}</span></li><li><span class="v">Udp = integer()</span></li><li><span class="v">Packet = binary()</span></li></ul><p>Generates a possibly encrypted request packet to be sent to the
network.
</p><p><strong>MsgData</strong> is the message specific data used in
the SNMP message.  This value is received in a
<a href="./snmp_agent_netif#im_send_pdu">snmp_agent_netif#im_send_pdu</a>
or
<a href="./snmp_agent_netif#im_send_pdu_req">snmp_agent_netif#im_send_pdu_req</a>
message from the agent.  In SNMPv1 and
SNMPv2c, this message data is the community string.  In
SNMPv3, it is the context information.</p><p>
<strong>To</strong> is a list of destination addresses and
their corresponding security parameters.  This value is
received in the same message from the agent and then transformed
trough <a href="#process_taddrs">process_taddrs</a>
before passed to this function.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that the use of the LocalEngineID argument is only intended 
for special cases, if the agent is to "emulate" multiple EngineIDs!
By default, the agent uses the value of <strong>SnmpEngineID</strong> 
(see SNMP-FRAMEWORK-MIB). </p></div><a name="process_taddrs"></a><h3>process_taddrs(TDests) -&gt; Dests</h3><p>Transform addresses from internal MIB format to a less internal </p><ul><li><span class="v">TDests = [TDest]</span></li><li><span class="v">TDest = {{TDomain, TAddr}, SecData} | {TDomain, TAddr}</span></li><li><span class="v">TDomain = term()  % Not at tuple</span></li><li><span class="v">TAddr = term()</span></li><li><span class="v">SecData = term()</span></li><li><span class="v">Dests = [Dest]</span></li><li><span class="v">Dest = {{Domain, Addr}, SecData} | {Domain, Addr}</span></li><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddress()  % Depends on Domain</span></li></ul><p>Transforms addresses from internal MIB format to one
more useful to <a href="snmp_agent_netif">Agent Net if</a>.
</p><p>See also <a href="#generate_msg">.</a>
</p><a name="discarded_pdu"></a><h3>discarded_pdu(Variable) -&gt; void()</h3><p>Increment the variable associated with a discarded pdu</p><ul><li><span class="v">Variable = atom()</span></li></ul><p>Increments the variable associated with a discarded pdu.
This function can be used when the net_if process receives a
<strong>discarded_pdu</strong> message from the agent.
</p><h2>snmpa_network_interface</h2><p>Behaviour module for the SNMP agent network interface.</p><p>This module defines the behaviour of the agent network
interface. A <strong>snmpa_network_interface</strong> compliant module 
must export the following functions: <ul><li> <p><a href="#start_link">start_link/4</a></p> </li><li> <p><a href="#info">info/1</a></p> </li><li> <p><a href="#get_log_type">get_log_type/1</a></p> </li><li> <p><a href="#set_log_type">set_log_type/2</a></p> </li><li> <p><a href="#verbosity">verbosity/2</a></p> </li></ul>The semantics of them and their exact signatures are explained
below. But this is not enough. There is also a set of <em>mandatory</em>
messages which the network interface entity must be able to 
receive and be able to send. This is described in chapter
<a href="snmp_agent_netif">snmp_agent_netif</a>.
<a name="start_link"></a></p><h2>Functions</h2><h3>start_link(Prio, NoteStore, MasterAgent, Opts) -&gt; {ok, Pid} | {error, Reason}</h3><p>Start-link the network interface process</p><ul><li><span class="v">Prio        = priority()</span></li><li><span class="v">NoteStore   = pid()</span></li><li><span class="v">MasterAgent = pid()</span></li><li><span class="v">Opts        = [opt()]</span></li><li><span class="v">opt()       = {verbosity, verbosity()} | {versions, versions()} | term()</span></li><li><span class="v">versions()  = [version()]</span></li><li><span class="v">version()   = v1 | v2 | v3</span></li></ul><p>Start-link the network interface process.</p><p><strong>NoteStore</strong> is the pid of the note-store process and 
<strong>MasterAgent</strong> is the pid of the master-agent process.</p><p><strong>Opts</strong> is an (basically) implementation dependent list of 
options to the network interface process. There are however
a number of options which <em>must</em> be handled: 
<strong>versions</strong> and <strong>verbosity</strong>.</p><a name="info"></a><h3>info(Pid) -&gt; [{Key, Value}]</h3><p>Return information about the running network interface process</p><ul><li><span class="v">Pid = pid()</span></li></ul><p>The info returned is basically up to the implementer to decide. 
This implementation provided by the application provides info about 
memory allocation and various socket information.</p><p>The info returned by this function is returned together with other 
info collected by the agent when the 
<a href="./snmpa#info">info</a> function is called 
(tagged with with the key <strong>net_if</strong>).</p><a name="verbosity"></a><h3>verbosity(Pid, Verbosity) -&gt; void()</h3><p>Change the verbosity of a running network interface process</p><ul><li><span class="v">Pid       = pid()</span></li><li><span class="v">Verbosity = verbosity()</span></li></ul><p>Change the verbosity of a running network interface process.</p><a name="get_log_type"></a><h3>get_log_type(Pid) -&gt; {ok, LogType} | {error, Reason}</h3><p>Get the Audit Trail Log type</p><ul><li><span class="v">Pid     = pid()</span></li><li><span class="v">LogType = atl_type()</span></li><li><span class="v">Reason  = term()</span></li></ul><p>The Audit Trail Log is managed by the network interface process. 
So, it is this process that has to retrieve the actual log-type. </p><a name="set_log_type"></a><h3>set_log_type(Pid, NewType) -&gt; {ok, OldType} | {error, Reason}</h3><p>Change the Audit Trail Log type</p><ul><li><span class="v">Pid     = pid()</span></li><li><span class="v">NewType = OldType = atl_type()</span></li><li><span class="v">Reason  = term()</span></li></ul><p>The Audit Trail Log is managed by the network interface process. 
So, it is this process that has to do the actual changing of the 
type. </p><p>See 
<a href="./snmpa#set_log_type">set_log_type</a>
for more info. </p><h2>snmpa_network_interface_filter</h2><p>Behaviour module for the SNMP agent network-interface filter.</p><p>This module defines the behaviour of the agent network interface
filter. A <strong>snmpa_network_interface_filter</strong> compliant module 
must export the following functions: <ul><li> <p><a href="#accept_recv">accept_recv/2</a></p> </li><li> <p><a href="#accept_send">accept_send/2</a></p> </li><li> <p><a href="#accept_recv_pdu">accept_recv_pdu/3</a></p> </li><li> <p><a href="#accept_send_pdu">accept_send_pdu/2</a></p> </li></ul>The semantics of them and their exact signatures are explained
below. The purpose of the network interface filter is to allow for filtering
of messages (accept or reject) receive and send. This is done 
on two levels: <ul><li> <p>The first level is at the transport entry / exit point, i.e.
immediately after the receipt of the message before any message
processing is done (accept_recv) and 
immediately before sending the message after all message
processing is done (accept_send).</p> </li><li> <p>The second level is at the MPD entry / exit point, i.e.
immediately after the basic message processing (accept_recv_pdu) / 
immediately before the basic message processing (accept_send_pdu).</p> </li></ul>Note that the network interface filter is something which is used 
by the network interface implementation provided by the application 
(<strong>snmpa_net_if</strong>). The default filter accepts all messages.A network interface filter can e.g. be used during testing or for load 
regulation. If the intended use is load regulation, see also 
<a href="./snmp_app#configuration_params">req_limit</a> and 
the function 
<a href="./snmpa#register_notification_filter">register_notification_filter</a>. Legacy network interface filter modules used arguments on the form
<strong>(IpAddr, PortNumber,...)</strong> instead of
<strong>(Domain, Addr, ...)</strong>, and if the SNMP agent is run without
changing the configuration to use transport domains
the network interface filter will still get
the old arguments and work as before.</p><h3>DATA TYPES</h3><pre><code class="">
port() = integer() &gt; 0
pdu_type() = 'get-request' | 'get-next-request' | 'get-response' | 
             'set-request' | trap | 'get-bulk-request' | 'inform-request' | 
             report
    </code></pre><p>See also the <a href="./snmpa_conf#types"> data types in </a>.</p><a name="accept_recv"></a><h2>Functions</h2><h3>accept_recv(Domain, Addr) -&gt; boolean()</h3><p>Shall the received message be accepted</p><ul><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddressWithPort()</span></li></ul><p>Called at the reception of a message (before <em>any</em> processing 
has been done).</p><p>For the message to be discarded, the function <em>must</em> return
<em>false</em>. </p><a name="accept_send"></a><h3>accept_send(Domain, Addr) -&gt; boolean()</h3><p>Shall the message be sent</p><ul><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddressWithPort()</span></li></ul><p>Called before the sending of a message (after <em>all</em> processing 
has been done).</p><p>For the message to be discarded, the function <em>must</em> return
<em>false</em>. </p><a name="accept_recv_pdu"></a><h3>accept_recv_pdu(Domain, Addr, PduType) -&gt; boolean()</h3><p>Shall the received pdu be accepted</p><ul><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddressWithPort()</span></li><li><span class="v">PduType = pdu_type()</span></li></ul><p>Called after the basic message processing (MPD) has been done, 
but before the pdu is handed over to the master-agent for 
primary processing.</p><p>For the pdu to be discarded, the function <em>must</em> return
<em>false</em>. </p><a name="accept_send_pdu"></a><h3>accept_send_pdu(Targets, PduType) -&gt; Reply</h3><p>Shall the pdu be sent</p><ul><li><span class="v">Targets = targets()</span></li><li><span class="v">targets() = [target()]</span></li><li><span class="v">target() = {Domain, Addr}</span></li><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddressWithPort()</span></li><li><span class="v">PduType = pdu_type() &gt; 0</span></li><li><span class="v">Reply = boolean() | NewTargets</span></li><li><span class="v">NewTargets = targets()</span></li></ul><p>Called before the basic message processing (MPD) is done, 
when a pdu has been received from the master-agent.</p><p>For the message to be discarded all together, the function 
<em>must</em> return <em>false</em>. </p><p>Note that it is possible for this function to filter out targets
(but <em>not</em> to add its own) by returning an updated
<strong>Targets</strong> list (<strong>NewTargets</strong>). </p><h2>snmpa_notification_delivery_info_receiver</h2><p>
    Behaviour module for the SNMP agent notification delivery 
    information receiver.
</p><p>This module defines the behaviour of the notification 
delivery information receiver. A <strong>snmpa_notification_delivery_info_receiver</strong> compliant module 
must export the following functions: <ul><li> <p><a href="#delivery_targets/3">delivery_targets/3</a></p> </li><li> <p><a href="#delivery_info/4">delivery_info/4</a></p> </li></ul>The semantics of them and their exact signatures are explained
below. Legacy notification delivery information receiver modules
used a target argument on the form
<strong>{IpAddr, PortNumber}</strong> instead of
<strong>{Domain, Addr}</strong>, and if the SNMP Agent is run without
changing the configuration to use transport domains
the notification delivery information receiver will still get
the old arguments and work as before.</p><h3>DATA TYPES</h3><p>See the <a href="./snmpa_conf#types"> data types in </a>.</p><a name="accept_recv"></a><a name="delivery_targets"></a><h2>Functions</h2><h3>delivery_targets(Tag, Targets, Extra) -&gt; void()</h3><p>Inform about target addresses</p><ul><li><span class="v">Tag = term()</span></li><li><span class="v">Targets = [Target]</span></li><li><span class="v">Target = {transportDomain(), transportAddressWithPort()</span></li><li><span class="v">Extra = term()</span></li></ul><p>Inform about target addresses. </p><p>This is the first function called when a notification delivery is
in progress. It informs the <strong>receiver</strong> which targets will
get the notification. The result of the delivery will be 
provided via successive calls to <strong>delivery_info/4</strong> function, 
see below.</p><a name="delivery_info"></a><h3>delivery_info(Tag, Target, DeliveryResult, Extra) -&gt; void()</h3><p>Inform about delivery result</p><ul><li><span class="v">Tag = term()</span></li><li><span class="v">Targets = [Target]</span></li><li><span class="v">Target = {transportDomain(), transportAddressWithPort()</span></li><li><span class="v">DeliveryResult = delivery_result()</span></li><li><span class="v">delivery_result() = no_response | got_response</span></li><li><span class="v">Extra = term()</span></li></ul><p>Inform about delivery result.</p><p>This function is called for each target in the <strong>Targets</strong>
argument of the <strong>delivery_targets/3</strong> function, see above. </p><p>The purpose is to inform the <strong>receiver</strong> of the 
result of the delivery (was the notification acknowledged or 
not) for each target.</p><h2>snmpa_notification_filter</h2><p>Behaviour module for the SNMP agent notification filters.</p><p>This module defines the behaviour of the agent notification
filters. A <strong>snmpa_notification_filter</strong> compliant module 
must export the following functions: <ul><li> <p>handle_notification/2</p> </li></ul>The semantics of them and their exact signatures are explained
below. The purpose of notification filters is to allow for modification
and/or suppression of a notification.A misbehaving filter will be removed.</p><h2>Functions</h2><h3>handle_notification(Notif, Data) -&gt; Reply</h3><p>Handle a notification</p><ul><li><span class="v">Reply = send | {send, NewNotif} | dont_send</span></li><li><span class="v">Notif =  NewNotif = notification() | trap()</span></li><li><span class="v">Data  = term()</span></li></ul><p>Handle a notification to be sent. The filter can either
accept the notification as is, return <strong>send</strong>, modify
the notification, return <strong>{send, NewNotif}</strong> or
suppress the notification, return <strong>dont_send</strong>.</p><p><strong>Data</strong> is supplied at filter registration time,
see <a href="./snmpa#register_notification_filter">register_notification_filter</a>.
</p><h2>snmpa_supervisor</h2><p>A supervisor for the SNMP agent Processes</p><p>This is the top supervisor for the agent part of the SNMP 
application. There is always one supervisor at each node with 
an SNMP agent (master agent or sub-agent).
</p><h2>Functions</h2><h3>start_sub_sup(Opts) -&gt; {ok, pid()} | {error, {already_started, pid()}} | {error, Reason}</h3><p>Start the SNMP supervisor for sub-agents only</p><ul><li><span class="v">Opts = [opt()]</span></li><li><span class="v">opt() = {db_dir, string()} | ...</span></li></ul><p>Starts a supervisor for the SNMP agent system without a
master agent.  The supervisor starts all involved SNMP
processes, but no agent processes.  Sub-agents should be
started by calling <strong>start_sub_agent/3</strong>.
</p><p><strong>db_dir</strong> is mandatory.</p><p>See <a href="./snmp_config#configuration_params">configuration parameters</a> for 
a description of the options.</p><h3>start_master_sup(Opts) -&gt; {ok, pid()} |  {error, {already_started, pid()}} | {error, Reason}</h3><p>Start the SNMP supervisor for all agents</p><ul><li><span class="v">Opts = [opt()]</span></li><li><span class="v">opt() = {db_dir, string()} | {config, ConfOpts()} | ...</span></li><li><span class="v">ConfOpts = [conf_opts()]</span></li><li><span class="v">conf_opts() = {dir, string()} | ...</span></li><li><span class="v">Reason = term()</span></li></ul><p>Starts a supervisor for the SNMP agent system.  The
supervisor starts all involved SNMP processes, including the
master agent.  Sub-agents should be started by calling
<strong>start_subagent/3</strong>.
</p><p><strong>db_dir</strong> is mandatory.</p><p><strong>dir</strong> in config is mandatory.</p><p>See <a href="snmp_config">snmp config</a> for 
a description of the options.</p><h3>start_sub_agent(ParentAgent,Subtree,Mibs) -&gt; {ok, pid()} | {error, Reason}</h3><p>Start a sub-agent</p><ul><li><span class="v">ParentAgent = pid()</span></li><li><span class="v">SubTree = oid()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = [string()]</span></li></ul><p>Starts a sub-agent on the node where the function is
called.  The <strong>snmpa_supervisor</strong> must be running.
</p><p>If the supervisor is not running, the function fails with the
reason <strong>badarg</strong>.</p><h3>stop_sub_agent(SubAgent) -&gt; ok | no_such_child</h3><p>Stop a sub-agent</p><ul><li><span class="v">SubAgent = pid()</span></li></ul><p>Stops the sub-agent on the node where the function is
called.  The <strong>snmpa_supervisor</strong> must be running.
</p><p>If the supervisor is not running, the function fails with the
reason <strong>badarg</strong>.</p><h2>snmp_community_mib</h2><p>Instrumentation Functions for SNMP-COMMUNITY-MIB</p><p>The module <strong>snmp_community_mib</strong> implements the instrumentation
functions for the SNMP-COMMUNITY-MIB, and functions for configuring the 
database. The configuration files are described in the SNMP User's Manual.<a name="configure"></a></p><h2>Functions</h2><h3>configure(ConfDir) -&gt; void()</h3><p>Configure the SNMP-COMMUNITY-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>This function is called from the supervisor at system
start-up.
</p><p>Inserts all data in the configuration files into the
database and destroys all old rows with StorageType
<strong>volatile</strong>.  The rows created from the configuration file
will have StorageType <strong>nonVolatile</strong>.
</p><p>All <strong>snmp</strong> counters are set to zero.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error,
report module and the function fails with reason 
<strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>community.conf</strong>.
</p><a name="reconfigure"></a><h3>reconfigure(ConfDir) -&gt; void()</h3><p>Configure the SNMP-COMMUNITY-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>Inserts all data in the configuration files into the
database and destroys all old data, including the rows with
StorageType <strong>nonVolatile</strong>.  The rows created from the
configuration file will have StorageType <strong>nonVolatile</strong>.
</p><p>Thus, the data in the SNMP-COMMUNITY-MIB, after this
function has been called, is from the configuration files.
</p><p>All <strong>snmp</strong> counters are set to zero.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error report 
module, and the function fails with reason 
<strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>community.conf</strong>.</p><a name="add_community"></a><h3>add_community(Idx, CommName, SecName, CtxName, TransportTag) -&gt; Ret</h3><h3>add_community(Idx, CommName, SecName, EngineId, CtxName, TransportTag) -&gt; Ret</h3><p>Added one community</p><ul><li><span class="v">Idx = string()</span></li><li><span class="v">CommName = string()</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">EngineId = string()</span></li><li><span class="v">CtxName = string()</span></li><li><span class="v">TransportTag = string()</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a community to the agent config. 
Equivalent to one line in the <strong>community.conf</strong> file.</p><p>With the <strong>EngineId</strong> argument it is possible to 
override the configured engine-id (SNMP-FRAMEWORK-MIB).</p><a name="delete_community"></a><h3>delete_community(Key) -&gt; Ret</h3><p>Delete one community</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a community from the agent config.</p><h2>snmp_framework_mib</h2><p>Instrumentation Functions for SNMP-FRAMEWORK-MIB</p><p>The module <strong>snmp_framework_mib</strong> implements instrumentation
functions for the
SNMP-FRAMEWORK-MIB, and functions for initializing and configuring the
database.
The configuration files are described in the SNMP User's Manual.</p><h2>Functions</h2><h3>configure(ConfDir) -&gt; void()</h3><p>Configure the SNMP-FRAMEWORK-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>This function is called from the supervisor at system
start-up.
</p><p>Inserts all data in the configuration files into the
database and destroys all old data.
</p><p>Thus, the data in the SNMP-FRAMEWORK-MIB, after this
function has been called, is from the configuration
files.
</p><p>All <strong>snmp</strong> counters are set to zero.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error 
report module, and the function fails with reason 
<strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>context.conf</strong>.
</p><h3>init() -&gt; void()</h3><p>Initialize the SNMP-FRAMEWORK-MIB</p><p>This function is called from the supervisor at system
start-up.
</p><p>Creates the necessary objects in the database if they do not
exist. It does not destroy any old values.
<a name="add_context"></a>
</p><h3>add_context(Ctx) -&gt; Ret</h3><p>Added one context</p><ul><li><span class="v">Ctx = string()</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a context to the agent config. 
Equivalent to one line in the <strong>context.conf</strong> file.</p><a name="delete_context"></a><h3>delete_context(Key) -&gt; Ret</h3><p>Delete one context</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a context from the agent config.</p><h2>snmp_generic</h2><p>Generic Functions for Implementing SNMP Objects in a Database</p><p><a name="description"></a>The module <strong>snmp_generic</strong> contains generic functions for 
implementing tables (and variables) using the SNMP built-in database 
or Mnesia. These default functions are used if no instrumentation 
function is provided for a managed object in a MIB. Sometimes, 
it might be necessary to customize the behaviour of the default 
functions. For example, in some situations a trap should be sent 
if a row is deleted or modified, or some hardware is to be informed, 
when information is changed. The overall structure is shown in the following figure:<pre>
         +---------------+
         |   SNMP Agent  |
         +- - - - - - - -+
         |      MIB      |
         +---------------+
                 |
         Association file       (associates a MIB object with
                 |               snmp_generic:table_funct
                 |               snmp_generic:variable_func)
+--------------------------------------+
|           snmp_generic               |  Support for get-next,
|                                      |  RowStatus operations
+----------------------+---------------+
|    snmpa_local_db    |    Mnesia     |  Database
+--------------+-------+---------------+
|     dets     |  ets  | 
| (persistent) |       | 
+--------------+-------+     </pre>Each function takes the argument <strong>NameDb</strong>, which is a
tuple <strong>{Name, Db}</strong>, to identify which database the
functions should use. <strong>Name</strong> is the symbolic name of the
managed object as defined in the MIB, and <strong>Db</strong> is either
<strong>volatile</strong>, <strong>persistent</strong>, or <strong>mnesia</strong>. If it is
<strong>mnesia</strong>, all variables are stored in the Mnesia table
<strong>snmp_variables</strong> which must be a table with two attributes
(not a Mnesia SNMP table). The SNMP tables are stored in Mnesia
tables with the same names as the SNMP tables.  All functions
assume that a Mnesia table exists with the correct name and
attributes. It is the programmer's responsibility to ensure
this. Specifically, if variables are stored in Mnesia, the table
<strong>snmp_variables</strong> must be created by the programmer.  The
record definition for this table is defined in the file
<strong>snmp/include/snmp_types.hrl</strong>.
If an instrumentation function in the association file for a
variable <strong>myVar</strong> does not have a name when compiling an
MIB, the compiler generates an entry.
<pre>
{myVar, {snmp_generic, variable_func, [{myVar, Db]}}.
    </pre>And for a table:<pre>
{myTable, {snmp_generic, table_func, [{myTable, Db]}}.
    </pre></p><a name="data_types"></a><h3>DATA TYPES</h3><p>In the functions defined below, the following types are used:</p><pre><code class="">
name_db() = {name(), db()} 
name() = atom()
db() = volatile | persistent | mnesia
row_index() = [int()]
columns() = [column()] | [{column(), value()}]
column() = int()
value() = term()
    </code></pre><dl><dt><strong>row_index()</strong></dt><dd> <p>Denotes the last part of the OID which specifies the 
index of the row in the table (see RFC1212, 4.1.6 for 
more information about INDEX).  </p> </dd><dt><strong>columns()</strong></dt><dd> <p>Is a list of column numbers in the case of a <strong>get</strong> 
operation, and a list of column numbers and values in the 
case of a <strong>set</strong> operation. </p> </dd></dl><a name="get_status_col2"></a><h2>Functions</h2><h3>get_status_col(Name, Cols)</h3><h3>get_status_col(NameDb, Cols) -&gt; {ok, StatusVal} | false</h3><p>Get the value of the status column from <strong>Cols</strong></p><ul><li><span class="v">Name = name()</span></li><li><span class="v">NameDb = name_db()</span></li><li><span class="v">Cols = columns()</span></li><li><span class="v">StatusVal = term()</span></li></ul><p>Gets the value of the status column from <strong>Cols</strong>.
</p><p>This function can be used in instrumentation functions for
<strong>is_set_ok</strong>, <strong>undo</strong> or <strong>set</strong> to check if the
status column of a table is modified.</p><a name="get_index_types"></a><h3>get_index_types(Name)</h3><p>Get the index types of <strong>Name</strong></p><ul><li><span class="v">Name = name()</span></li></ul><p>Gets the index types of <strong>Name</strong></p><p>This function can be used in instrumentation functions to
retrieve the index types part of the table info.</p><a name="get_table_info"></a><h3>get_table_info(Name, Item) -&gt; table_info_result()</h3><p>Get table info item of MIB table <strong>Name</strong></p><ul><li><span class="v">Name = name()</span></li><li><span class="v">Item = table_item() | all</span></li><li><span class="v">table_item() = nbr_of_cols | defvals | status_col | not_accessible |  index_types | first_accessible | first_own_index</span></li><li><span class="v">table_info_result() = Value | [{table_item(), Value}]</span></li><li><span class="v">Value = term()</span></li></ul><p>Get a specific table info item or, if <strong>Item</strong> has the
value <strong>all</strong>, a two tuple list (property list) is instead 
returned with all the items and their respctive values of the 
given table. </p><p>This function can be used in instrumentation functions to
retrieve a given part of the table info.</p><a name="table_func"></a><h3>table_func(Op1, NameDb)</h3><h3>table_func(Op2, RowIndex, Cols, NameDb) -&gt; Ret</h3><p>Default instrumentation function for tables</p><ul><li><span class="v">Op1 = new | delete </span></li><li><span class="v">Op2 = get | next | is_set_ok | set | undo</span></li><li><span class="v">NameDb = name_db()</span></li><li><span class="v">RowIndex = row_index()</span></li><li><span class="v">Cols = columns()</span></li><li><span class="v">Ret = term()</span></li></ul><p>This is the default instrumentation function for tables.
</p><ul><li>The <strong>new</strong> function creates the table if it does not exist, but only if the database is the SNMP internal db.</li><li>The <strong>delete</strong> function does not delete the table from the database since unloading an MIB does not necessarily mean that the table should be destroyed.</li><li>The <strong>is_set_ok</strong> function checks that a row which is to be modified or deleted exists, and that a row which is to be created does not exist.</li><li>The <strong>undo</strong> function does nothing.</li><li>The <strong>set</strong> function checks if it has enough information to make the row change its status from <strong>notReady</strong> to <strong>notInService</strong> (when a row has been been set to <strong>createAndWait</strong>). If a row is set to <strong>createAndWait</strong>, columns without a value are set to <strong>noinit</strong>. If Mnesia is used, the set functionality is handled within a transaction.</li></ul><p>If it is possible for a manager to create or delete rows in
the table, there must be a <strong>RowStatus</strong> column for
<strong>is_set_ok</strong>, <strong>set</strong> and <strong>undo</strong> to work properly.
</p><p>The function returns according to the specification of an
instrumentation function.
</p><a name="table_get_elements"></a><h3>table_get_elements(NameDb, RowIndex, Cols) -&gt; Values</h3><p>Get elements in a table row</p><ul><li><span class="v">NameDb = name_db()</span></li><li><span class="v">RowIndex = row_index()</span></li><li><span class="v">Cols = columns()</span></li><li><span class="v">Values = [value() | noinit]</span></li></ul><p>Returns a list with values for all columns in <strong>Cols</strong>.
If a column is undefined, its value is <strong>noinit</strong>.</p><a name="table_next"></a><h3>table_next(NameDb, RestOid) -&gt; RowIndex | endOfTable</h3><p>Find the next row in the table</p><ul><li><span class="v">NameDb = name_db()</span></li><li><span class="v">RestOid = [int()]</span></li><li><span class="v">RowIndex = row_index()</span></li></ul><p>Finds the indices of the next row in the table.  <strong>RestOid</strong>
does not have to specify an existing row.</p><a name="table_row_exists"></a><h3>table_row_exists(NameDb, RowIndex) -&gt; bool()</h3><p>Check if a row in a table exists</p><ul><li><span class="v">NameDb = name_db()</span></li><li><span class="v">RowIndex = row_index()</span></li></ul><p>Checks if a row in a table exists.</p><a name="table_set_elements"></a><h3>table_set_elements(NameDb, RowIndex, Cols) -&gt; bool()</h3><p>Set elements in a table row</p><ul><li><span class="v">NameDb = name_db()</span></li><li><span class="v">RowIndex = row_index()</span></li><li><span class="v">Cols = columns()</span></li></ul><p>Sets the elements in <strong>Cols</strong> to the row specified by
<strong>RowIndex</strong>.  No checks are performed on the new values.
</p><p>If the Mnesia database is used, this function calls
<strong>mnesia:write</strong> to store the values.  This means that
this function must be called from within a transaction
(<strong>mnesia:transaction/1</strong> or <strong>mnesia:dirty/1</strong>).</p><a name="variable_func"></a><h3>variable_func(Op1, NameDb)</h3><h3>variable_func(Op2, Val, NameDb) -&gt; Ret</h3><p>Default instrumentation function for tables</p><ul><li><span class="v">Op1 = new | delete | get</span></li><li><span class="v">Op2 = is_set_ok | set | undo</span></li><li><span class="v">NameDb = name_db()</span></li><li><span class="v">Val = value()</span></li><li><span class="v">Ret = term()</span></li></ul><p>This is the default instrumentation function for variables.</p><p>The <strong>new</strong> function creates a new variable in the
database with a default value as defined in the MIB, or a zero
value (depending on the type).  </p><p>The <strong>delete</strong> function does not delete the variable from 
the database. </p><p>The function returns according to the specification of an 
instrumentation function. </p><a name="variable_get"></a><h3>variable_get(NameDb) -&gt; {value, Value} | undefined</h3><p>Get the value of a variable</p><ul><li><span class="v">NameDb = name_db()</span></li><li><span class="v">Value = value()</span></li></ul><p>Gets the value of a variable.</p><a name="variable_set"></a><h3>variable_set(NameDb, NewVal) -&gt; true | false</h3><p>Set a value for a variable</p><ul><li><span class="v">NameDb = name_db()</span></li><li><span class="v">NewVal = value()</span></li></ul><p>Sets a new value to a variable.  The variable is created if
it does not exist.  No checks are made on the type of the
new value.  </p><p>Returns <strong>false</strong> if the <strong>NameDb</strong> argument
is incorrectly specified, otherwise <strong>true</strong>.</p><a name="example"></a><h3>Example</h3><p>The following example shows an implementation of a table which is
stored in Mnesia, but with some checks performed at set-request
operations.
</p><pre>
myTable_func(new, NameDb) -&gt;   % pass unchanged
  snmp_generic:table_func(new, NameDb).

myTable_func(delete, NameDb) -&gt;   % pass unchanged
  snmp_generic:table_func(delete, NameDb).

%% change row
myTable_func(is_set_ok, RowIndex, Cols, NameDb) -&gt;
  case snmp_generic:table_func(is_set_ok, RowIndex,
                               Cols, NameDb) of
    {noError, 0} -&gt; 
      myApplication:is_set_ok(RowIndex, Cols);
    Err -&gt;
      Err
  end;

myTable_func(set, RowIndex, Cols, NameDb) -&gt;
  case snmp_generic:table_func(set, RowIndex, Cols,
                               NameDb),
    {noError, 0} -&gt;
      % Now the row is updated, tell the application
      myApplication:update(RowIndex, Cols);
    Err -&gt;
      Err
  end;

myTable_func(Op, RowIndex, Cols, NameDb) -&gt;   % pass unchanged
  snmp_generic:table_func(Op, RowIndex, Cols, NameDb).
    </pre><p>The <strong>.funcs</strong> file would look like:
</p><pre>
{myTable, {myModule, myTable_func, [{myTable, mnesia}]}}.
    </pre><h2>snmp_index</h2><p>Abstract Data Type for SNMP Indexing</p><p>The module <strong>snmp_index</strong> implements an Abstract
Data Type (ADT) for an SNMP
index structure for SNMP tables.  It is implemented as an ets
table of the ordered_set data-type, which means that all operations are
O(log n).  In the table, the key is an ASN.1 OBJECT
IDENTIFIER.
This index is used to separate the implementation of the SNMP
ordering from the actual implementation of the table.  The SNMP
ordering, that is implementation of GET NEXT, is implemented in this
module.
For example, suppose there is an SNMP table, which is best
implemented in Erlang as one process per SNMP table row.  Suppose
further that the INDEX in the SNMP table is an OCTET STRING.  The
index structure would be created as follows:
<pre><code class="">
snmp_index:new(string)
    </code></pre>For each new process we create, we insert an item in an
<strong>snmp_index</strong> structure:
<pre><code class="">
new_process(Name, SnmpIndex) -&gt;
  Pid = start_process(),
  NewSnmpIndex = 
    snmp_index:insert(SnmpIndex, Name, Pid),
  &lt;...&gt;
    </code></pre>With this structure, we can now map an OBJECT IDENTIFIER in
e.g. a GET NEXT request, to the correct process:
<pre><code class="">
get_next_pid(Oid, SnmpIndex) -&gt;
  {ok, {_, Pid}} = snmp_index:get_next(SnmpIndex, Oid),
  Pid.
    </code></pre></p><h3>Common data types</h3><p>The following data types are used in the functions below:
</p><ul><li> <p><strong>index()</strong></p> </li><li> <p><strong>oid() = [byte()]</strong></p> </li><li> <p><strong>key_types = type_spec()  |  {type_spec(), type_spec(), ...}</strong></p> </li><li> <p><strong>type_spec() = fix_string | string | integer</strong></p> </li><li> <p><strong>key() = key_spec() | {key_spec(), key_spec(), ...}</strong></p> </li><li> <p><strong>key_spec() = string() | integer()</strong></p> </li></ul><p>The <strong>index()</strong> type denotes an snmp index structure.
</p><p>The <strong>oid()</strong> type is used to represent an ASN.1 OBJECT
IDENTIFIER.
</p><p>The <strong>key_types()</strong> type is used when creating the
index structure, and the <strong>key()</strong> type is used when inserting
and deleting items from the structure.
</p><p>The <strong>key_types()</strong> type defines the types of the SNMP INDEX
columns for the table.  If the table has one single INDEX column,
this type should be a single atom, but if the table has multiple
INDEX columns, it should be a tuple with atoms.
</p><p>If the INDEX column is of type INTEGER, or derived from
INTEGER, the corresponding type should be <strong>integer</strong>.  If it
is a variable length type (e.g. OBJECT IDENTIFIER, OCTET STRING),
the corresponding type should be <strong>string</strong>.  Finally, if the
type is of variable length, but with a fixed size restriction
(e.g. IpAddress), the corresponding type should be
<strong>fix_string</strong>.
</p><p>For example, if the SNMP table has two INDEX columns, the first
one an OCTET STRING with size 2, and the second one an OBJECT
IDENTIFER, the corresponding <strong>key_types</strong> parameter would be
<strong>{fix_string, string}</strong>.
</p><p>The <strong>key()</strong> type correlates to the <strong>key_types()</strong>
type. If the <strong>key_types()</strong> is a single atom, the
corresponding <strong>key()</strong> is a single type as well, but if the
<strong>key_types()</strong> is a tuple, <strong>key</strong> must be a tuple of the
same size.
</p><p>In the example above, valid <strong>keys</strong> could be <strong>{"hi", "mom"}</strong> and <strong>{"no", "thanks"}</strong>, whereas <strong>"hi"</strong>,
<strong>{"hi", 42}</strong> and <strong>{"hello", "there"}</strong> would be invalid.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><a name="1"></a><p>All API functions that update the index return a <strong>NewIndex</strong>
term. This is for backward compatibility with a previous
implementation that used a B+ tree written purely in Erlang for 
the index. The <strong>NewIndex</strong> return value can now be ignored. 
The return value is now the unchanged table identifier for the 
ets table.</p><p>The implementation using ets tables introduces a semantic
incompatibility with older implementations. In those older 
implementations, using pure Erlang terms, the index was garbage 
collected like any other Erlang term and did not have to be 
deleted when discarded. An ets table is deleted only when the 
process creating it explicitly deletes it or when the creating 
process terminates.</p><p>A new interface <strong>delete/1</strong> is now added to
handle the case when a process wants to discard an index table
(i.e. to build a completely new). Any application using
transient snmp indexes has to be modified to handle this.</p><p>As an snmp adaption usually keeps the index for the whole of the
systems lifetime, this is rarely a problem.</p></div><h2>Functions</h2><h3>delete(Index) -&gt; true</h3><p>Delete an index table</p><ul><li><span class="v">Index = NewIndex = index()</span></li><li><span class="v">Key = key()</span></li></ul><p>Deletes a complete index structure (i.e. the ets table
holding the index). The index can no longer be referenced
after this call. See the <a href="#1">warning note</a>
above.</p><h3>delete(Index, Key) -&gt; NewIndex</h3><p>Delete an item from the index</p><ul><li><span class="v">Index = NewIndex = index()</span></li><li><span class="v">Key = key()</span></li></ul><p>Deletes a key and its value from the index structure.
Returns a new structure.</p><h3>get(Index, KeyOid) -&gt; {ok, {KeyOid, Value}} | undefined</h3><p>Get the item with <strong>KeyOid</strong></p><ul><li><span class="v">Index = index()</span></li><li><span class="v">KeyOid = oid()</span></li><li><span class="v">Value = term()</span></li></ul><p>Gets the item with key <strong>KeyOid</strong>.  Could be used from
within an SNMP instrumentation function.</p><h3>get_last(Index) -&gt; {ok, {KeyOid, Value}} | undefined</h3><p>Get the last item in the index structure</p><ul><li><span class="v">Index = index()</span></li><li><span class="v">KeyOid = oid()</span></li><li><span class="v">Value = term()</span></li></ul><p>Gets the last item in the index structure.</p><h3>get_next(Index, KeyOid) -&gt; {ok, {NextKeyOid, Value}} | undefined</h3><p>Get the next item</p><ul><li><span class="v">Index = index()</span></li><li><span class="v">KeyOid = NextKeyOid = oid()</span></li><li><span class="v">Value = term()</span></li></ul><p>Gets the next item in the SNMP lexicographic ordering,
after <strong>KeyOid</strong> in the index structure.  <strong>KeyOid</strong>
does not have to refer to an existing item in the index.</p><h3>insert(Index, Key, Value) -&gt; NewIndex</h3><p>Insert an item into the index</p><ul><li><span class="v">Index = NewIndex = index()</span></li><li><span class="v">Key = key()</span></li><li><span class="v">Value = term()</span></li></ul><p>Inserts a new key value tuple into the index structure.  If
an item with the same key already exists, the new <strong>Value</strong>
overwrites the old value.</p><h3>key_to_oid(Index, Key) -&gt; KeyOid</h3><p>Convert a key to an OBJECT IDENTIFIER</p><ul><li><span class="v">Index = index()</span></li><li><span class="v">Key = key()</span></li><li><span class="v">KeyOid = NextKeyOid = oid()</span></li></ul><p>Converts <strong>Key</strong> to an OBJECT IDENTIFIER.</p><h3>new(KeyTypes) -&gt; Index</h3><p>Create a new snmp index structure</p><ul><li><span class="v">KeyTypes = key_types()</span></li><li><span class="v">Index = index()</span></li></ul><p>Creates a new snmp index structure.  The <strong>key_types()</strong>
type is described above.</p><h2>snmp_notification_mib</h2><p>Instrumentation Functions for SNMP-NOTIFICATION-MIB</p><p>The module <strong>snmp_notification_mib</strong> implements the
instrumentation functions for the
SNMP-NOTIFICATION-MIB, and functions for configuring the database.
The configuration files are described in the SNMP User's Manual.</p><h2>Functions</h2><h3>configure(ConfDir) -&gt; void()</h3><p>Configure the SNMP-NOTIFICATION-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>This function is called from the supervisor at system
start-up.
</p><p>Inserts all data in the configuration files into the
database and destroys all old rows with StorageType
<strong>volatile</strong>.  The rows created from the configuration file
will have StorageType <strong>nonVolatile</strong>.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the 
error report module,
and the function fails with reason <strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>notify.conf</strong>.
</p><h3>reconfigure(ConfDir) -&gt; void()</h3><p>Configure the SNMP-NOTIFICATION-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>Inserts all data in the configuration files into the
database and destroys all old data, including the rows with
StorageType <strong>nonVolatile</strong>.  The rows created from the
configuration file will have StorageType <strong>nonVolatile</strong>.
</p><p>Thus, the data in the SNMP-NOTIFICATION-MIB, after this
function has been called, is from the configuration files.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the 
error report module,
and the function fails with reason <strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>notify.conf</strong>.
<a name="add_notify"></a>
</p><h3>add_notify(Name, Tag, Type) -&gt; Ret</h3><p>Added one notify definition</p><ul><li><span class="v">Name = string()</span></li><li><span class="v">Tag = string()</span></li><li><span class="v">Type = trap | inform</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a notify definition to the agent config. 
Equivalent to one line in the <strong>notify.conf</strong> file.</p><a name="delete_notify"></a><h3>delete_notify(Key) -&gt; Ret</h3><p>Delete one notify definition</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a notify definition from the agent config.</p><h2>snmp_pdus</h2><p>Encode and Decode Functions for SNMP PDUs</p><p>RFC1157, RFC1905 and/or RFC2272 should be studied carefully
before using this module, <strong>snmp_pdus</strong>.
The module <strong>snmp_pdus</strong> contains functions for encoding 
and decoding of
SNMP protocol data units (PDUs).  In short, this module converts a
list of bytes to Erlang record representations and vice versa.
The record definitions can be found in the file
<strong>snmp/include/snmp_types.hrl</strong>.  If snmpv3 is used, the module
that includes <strong>snmp_types.hrl</strong> must define the constant
<strong>SNMP_USE_V3</strong> before the header file is included.  Example:<pre>
-define(SNMP_USE_V3, true).
-include_lib("snmp/include/snmp_types.hrl").    </pre>Encoding and decoding must be done explicitly when writing your
own Net if process.
</p><h2>Functions</h2><h3>dec_message([byte()]) -&gt; Message</h3><p>Decode an SNMP Message</p><ul><li><span class="v">Message = #message</span></li></ul><p>Decodes a list of bytes into an SNMP Message.  Note, if there
is a v3 message, the <strong>msgSecurityParameters</strong> are not
decoded.  They must be explicitly decoded by a call to a
security model specific decoding function,
e.g. <strong>dec_usm_security_parameters/1</strong>.  Also note, if
the <strong>scopedPDU</strong> is encrypted, the OCTET STRING encoded
<strong>encryptedPDU</strong> will be present in the <strong>data</strong> field.</p><h3>dec_message_only([byte()]) -&gt; Message</h3><p>Decode an SNMP Message, but not the data part</p><ul><li><span class="v">Message = #message</span></li></ul><p>Decodes a list of bytes into an SNMP Message, but does not
decode the data part of the Message. That means, data is still
a list of bytes, normally an encoded <strong>PDU</strong> (v1 and V2) or an
encoded and possibly encrypted <strong>scopedPDU</strong> (v3).</p><h3>dec_pdu([byte()]) -&gt; Pdu</h3><p>Decode an SNMP Pdu</p><ul><li><span class="v">Pdu = #pdu</span></li></ul><p>Decodes a list of bytes into an SNMP Pdu.</p><h3>dec_scoped_pdu([byte()]) -&gt; ScopedPdu</h3><p>Decode an SNMP ScopedPdu</p><ul><li><span class="v">ScopedPdu = #scoped_pdu</span></li></ul><p>Decodes a list of bytes into an SNMP ScopedPdu.</p><h3>dec_scoped_pdu_data([byte()]) -&gt; ScopedPduData</h3><p>Decode an SNMP ScopedPduData</p><ul><li><span class="v">ScopedPduData = #scoped_pdu | EncryptedPDU</span></li><li><span class="v">EncryptedPDU = [byte()]</span></li></ul><p>Decodes a list of bytes into either a scoped pdu record, or
- if the scoped pdu was encrypted - to a list of bytes.</p><h3>dec_usm_security_parameters([byte()]) -&gt; UsmSecParams</h3><p>Decode SNMP UsmSecurityParameters</p><ul><li><span class="v">UsmSecParams = #usmSecurityParameters</span></li></ul><p>Decodes a list of bytes into an SNMP UsmSecurityParameters</p><h3>enc_encrypted_scoped_pdu(EncryptedScopedPdu) -&gt; [byte()]</h3><p>Encode an encrypted SNMP scopedPDU</p><ul><li><span class="v">EncryptedScopedPdu = [byte()]</span></li></ul><p>Encodes an encrypted SNMP ScopedPdu into an OCTET STRING
that can be used as the <strong>data</strong> field in a
<strong>message</strong> record, that later can be encoded with a call
to <strong>enc_message_only/1</strong>. 
</p><p>This function should be used whenever the <strong>ScopedPDU</strong>
is encrypted.</p><h3>enc_message(Message) -&gt; [byte()]</h3><p>Encode an SNMP Message</p><ul><li><span class="v">Message = #message</span></li></ul><p>Encodes a message record to a list of bytes.</p><h3>enc_message_only(Message) -&gt; [byte()]</h3><p>Encode an SNMP Message, but not the data part</p><ul><li><span class="v">Message = #message</span></li></ul><p><strong>Message</strong> is a record where the <strong>data</strong> field is
assumed to be encoded (a list of bytes).  If there is a v1 or v2
message, the <strong>data</strong> field is an encoded <strong>PDU</strong>, and if
there is a v3 message, <strong>data</strong> is an encoded and possibly
encrypted <strong>scopedPDU</strong>.</p><h3>enc_pdu(Pd) -&gt; [byte()]</h3><p>Encode an SNMP Pdu</p><ul><li><span class="v">Pdu = #pdu</span></li></ul><p>Encodes an SNMP Pdu into a list of bytes.</p><h3>enc_scoped_pdu(ScopedPdu) -&gt; [byte()]</h3><p>Encode an SNMP scopedPDU</p><ul><li><span class="v">ScopedPdu = #scoped_pdu</span></li></ul><p>Encodes an SNMP ScopedPdu into a list of bytes, which can be
encrypted, and after encryption, encoded with
a call to <strong>enc_encrypted_scoped_pdu/1</strong>; or it can be
used as the <strong>data</strong> field in a <strong>message</strong> record, which
then can be encoded with <strong>enc_message_only/1</strong>.</p><h3>enc_usm_security_parameters(UsmSecParams) -&gt; [byte()]</h3><p>Encode SNMP UsmSecurityParameters</p><ul><li><span class="v">UsmSecParams = #usmSecurityParameters</span></li></ul><p>Encodes SNMP UsmSecurityParameters into a list of bytes.</p><h2>snmp_standard_mib</h2><p>Instrumentation Functions for STANDARD-MIB and SNMPv2-MIB</p><p>The module <strong>snmp_standard_mib</strong> implements the instrumentation functions for the
STANDARD-MIB and SNMPv2-MIB, and functions for configuring the database.
The configuration files are described in the SNMP User's Manual.</p><h2>Functions</h2><h3>configure(ConfDir) -&gt; void()</h3><p>Configure the STANDARD-MIB and SNMPv2-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>This function is called from the supervisor at system
start-up.
</p><p>Inserts all data in the configuration files into the
database and destroys all old rows with StorageType
<strong>volatile</strong>.  The rows created from the configuration file
will have StorageType <strong>nonVolatile</strong>.
</p><p>All <strong>snmp</strong> counters are set to zero.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error 
report module, and the function fails with the reason 
<strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>standard.conf</strong>.
</p><h3>inc(Name) -&gt; void()</h3><h3>inc(Name, N) -&gt; void()</h3><p>Increment a variable in the MIB</p><ul><li><span class="v">Name = atom()</span></li><li><span class="v">N = integer()</span></li></ul><p>Increments a variable in the MIB with <strong>N</strong>, or one if
<strong>N</strong> is not specified.</p><h3>reconfigure(ConfDir) -&gt; void()</h3><p>Configure the STANDARD-MIB and SNMPv2-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>Inserts all data in the configuration files into the
database and destroys all old data, including the rows with
StorageType <strong>nonVolatile</strong>.  The rows created from the
configuration file will have StorageType <strong>nonVolatile</strong>.
</p><p>Thus, the data in the SNMP-STANDARD-MIB and SNMPv2-MIB,
after this function has been called, is from the
configuration files.
</p><p>All <strong>snmp</strong> counters are set to zero.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error
report module, and the function fails with the reason 
<strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>standard.conf</strong>.
</p><h3>reset() -&gt; void()</h3><p>Reset all <strong>snmp</strong>counters to 0</p><p>Resets all <strong>snmp</strong> counters to 0.</p><h3>sys_up_time() -&gt; Time</h3><p>Get the system up time</p><ul><li><span class="v">Time = int()</span></li></ul><p>Gets the system up time in hundredth of a second.</p><h2>snmp_target_mib</h2><p>Instrumentation Functions for SNMP-TARGET-MIB</p><p>The module <strong>snmp_target_mib</strong> implements the instrumentation
functions for the SNMP-TARGET-MIB, 
and functions for configuring the database. The configuration files are described in the SNMP User's Manual.Legacy API functions <strong>add_addr/10</strong> that does not specify
transport domain, and <strong>add_addr/11</strong> that has got separate
<strong>IpAddr</strong> and <strong>PortNumber</strong> arguments still work as before
for backwards compatibility reasons.<a name="types"></a></p><h3>DATA TYPES</h3><p>See the <a href="./snmpa_conf#types"> data types in </a>.</p><a name="configure"></a><h2>Functions</h2><h3>configure(ConfDir) -&gt; void()</h3><p>Configure the SNMP-TARGET-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>This function is called from the supervisor at system
start-up.
</p><p>Inserts all data in the configuration files into the
database and destroys all old rows with StorageType
<strong>volatile</strong>.  The rows created from the configuration file
will have StorageType <strong>nonVolatile</strong>. </p><p>All <strong>snmp</strong> counters are set to zero. </p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error
report module, and the function fails with the reason 
<strong>configuration_error</strong>. </p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found. </p><p>The configuration files read are: <strong>target_addr.conf</strong>
and <strong>target_params.conf</strong>. </p><a name="reconfigure"></a><h3>reconfigure(ConfDir) -&gt; void()</h3><p>Configure the SNMP-TARGET-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>Inserts all data in the configuration files into the
database and destroys all old data, including the rows with
StorageType <strong>nonVolatile</strong>.  The rows created from the
configuration file will have StorageType <strong>nonVolatile</strong>. </p><p>Thus, the data in the SNMP-TARGET-MIB, after this
function has been called, is the data from the configuration
files. </p><p>All <strong>snmp</strong> counters are set to zero.</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the ,
and the function fails with the reason 
<strong>configuration_error</strong>.</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found. </p><p>The configuration files read are: <strong>target_addr.conf</strong>
and <strong>target_params.conf</strong>. </p><a name="set_target_engine_id"></a><h3>set_target_engine_id(TargetAddrName, EngineId) -&gt; boolean()</h3><p>Set the engine id for a targetAddr row.</p><ul><li><span class="v">TargetAddrName = string()</span></li><li><span class="v">EngineId = string()</span></li></ul><p>Changes the engine id for a target in the 
<strong>snmpTargetAddrTable</strong>.
If notifications are sent as Inform requests to a target, its
engine id must be set. </p><a name="add_addr"></a><h3>add_addr(Name, Domain, Addr, Timeout, Retry, TagList, Params, EngineId, TMask, MMS) -&gt; Ret</h3><p>Add one target address definition</p><ul><li><span class="v">Name = string()</span></li><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddress()  % Default port is 162</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">Retry = integer()</span></li><li><span class="v">TagList = string()</span></li><li><span class="v">ParamsName = string()</span></li><li><span class="v">EngineId = string()</span></li><li><span class="v">TMask = transportAddressMask()  % Depends on Domain</span></li><li><span class="v">MMS = integer()</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a target address definition to the agent config. 
Equivalent to one line in the <strong>target_addr.conf</strong> file.</p><a name="delete_addr"></a><h3>delete_addr(Key) -&gt; Ret</h3><p>Delete one target address definition</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a target address definition from the agent config.</p><a name="add_params"></a><h3>add_params(Name, MPModel, SecModel, SecName, SecLevel) -&gt; Ret</h3><p>Add one target parameter definition</p><ul><li><span class="v">Name = string()</span></li><li><span class="v">MPModel = v1 | v2c | v3</span></li><li><span class="v">SecModel = v1 | v2c | usm</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">SecLevel = noAuthNoPriv | authNoPriv | authPriv</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a target parameter definition to the agent config. 
Equivalent to one line in the <strong>target_params.conf</strong> file.</p><a name="delete_params"></a><h3>delete_params(Key) -&gt; Ret</h3><p>Delete one target parameter definition</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a target parameter definition from the agent config.</p><h2>snmp_user_based_sm_mib</h2><p>Instrumentation Functions for SNMP-USER-BASED-SM-MIB</p><p>The module <strong>snmp_user_based_sm_mib</strong> implements the instrumentation 
functions for the SNMP-USER-BASED-SM-MIB, and functions for configuring 
the database.
The configuration files are described in the SNMP User's Manual.</p><h2>Functions</h2><h3>configure(ConfDir) -&gt; void()</h3><p>Configure the SNMP-USER-BASED-SM-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>This function is called from the supervisor at system
start-up.
</p><p>Inserts all data in the configuration files into the
database and destroys all old rows with StorageType
<strong>volatile</strong>.  The rows created from the configuration file
will have StorageType <strong>nonVolatile</strong>.
</p><p>All <strong>snmp</strong> counters are set to zero.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error
report module, and the function fails with the reason 
<strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>usm.conf</strong>.
</p><h3>reconfigure(ConfDir) -&gt; void()</h3><p>Configure the SNMP-USER-BASED-SM-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>Inserts all data in the configuration files into the
database and destroys all old data, including the rows with
StorageType <strong>nonVolatile</strong>.  The rows created from the
configuration file will have StorageType <strong>nonVolatile</strong>.
</p><p>Thus, the data in the SNMP-USER-BASED-SM-MIB, after this
function has been called, is the data from the configuration
files.
</p><p>All <strong>snmp</strong> counters are set to zero.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error
report module, and the function fails with the reason 
<strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>usm.conf</strong>.
<a name="add_user"></a>
</p><h3>add_user(EngineID, Name, SecName, Clone, AuthP, AuthKeyC, OwnAuthKeyC, PrivP, PrivKeyC, OwnPrivKeyC, Public, AuthKey, PrivKey) -&gt; Ret</h3><p>Add one user</p><ul><li><span class="v">EngineID = string()</span></li><li><span class="v">Name = string()</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">Clone = zeroDotZero | [integer()]</span></li><li><span class="v">AuthP = usmNoAuthProtocol | usmHMACMD5AuthProtocol | usmHMACSHAAuthProtocol</span></li><li><span class="v">AuthKeyC = string()</span></li><li><span class="v">OwnAuthKeyC = string()</span></li><li><span class="v">PrivP = usmNoPrivProtocol | usmDESPrivProtocol</span></li><li><span class="v">PrivKeyC = string()</span></li><li><span class="v">OwnPrivKeyC = string()</span></li><li><span class="v">Public = string()</span></li><li><span class="v">AuthKey = string()</span></li><li><span class="v">PrivKey = string()</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a USM security data (user) to the agent config. 
Equivalent to one line in the <strong>usm.conf</strong> file.</p><a name="delete_user"></a><h3>delete_user(Key) -&gt; Ret</h3><p>Delete one user</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a USM security data (user) from the agent config.</p><h2>snmp_view_based_acm_mib</h2><p>Instrumentation Functions for SNMP-VIEW-BASED-ACM-MIB</p><p>The module <strong>snmp_view_based_acm_mib</strong> implements the instrumentation functions for the
SNMP-VIEW-BASED-ACM-MIB, and functions for configuring the database.
The configuration files are described in the SNMP User's Manual.<a name="configure"></a></p><h2>Functions</h2><h3>configure(ConfDir) -&gt; void()</h3><p>Configure the SNMP-VIEW-BASED-ACM-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>This function is called from the supervisor at system
start-up. </p><p>Inserts all data in the configuration files into the
database and destroys all old rows with StorageType
<strong>volatile</strong>.  The rows created from the configuration file
will have StorageType <strong>nonVolatile</strong>. </p><p>All <strong>snmp</strong> counters are set to zero. </p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error
report module, and the function fails with the reason 
<strong>configuration_error</strong>. </p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found. </p><p>The configuration file read is: <strong>vacm.conf</strong>. </p><a name="reconfigure"></a><h3>reconfigure(ConfDir) -&gt; void()</h3><p>Configure the SNMP-VIEW-BASED-ACM-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>Inserts all data in the configuration files into the
database and destroys all old data, including the rows with
StorageType <strong>nonVolatile</strong>.  The rows created from the
configuration file will have StorageType <strong>nonVolatile</strong>.
</p><p>Thus, the data in the SNMP-VIEW-BASED-ACM-MIB, after this
function has been called, is the data from the configuration
files.
</p><p>All <strong>snmp</strong> counters are set to zero.
</p><p>If an error is found in the configuration file, it is
reported using the function 
<a href="./snmpa_error#config_err">config_err/2</a> 
of the error report module, and the function fails with the reason 
<strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>vacm.conf</strong>. </p><a name="add_sec2group"></a><h3>add_sec2group(SecModel, SecName, GroupName) -&gt; Ret</h3><p>Add one security to group definition</p><ul><li><span class="v">SecModel = v1 | v2c | usm</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">GroupName = string()</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a security to group definition to the agent config. 
Equivalent to one vacmSecurityToGroup-line in the 
<strong>vacm.conf</strong> file.</p><a name="delete_sec2group"></a><h3>delete_sec2group(Key) -&gt; Ret</h3><p>Delete one security to group definition</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a security to group definition from the agent config.</p><a name="add_access"></a><h3>add_access(GroupName, Prefix, SecModel, SecLevel, Match, RV, WV, NV) -&gt; Ret</h3><p>Add one access definition</p><ul><li><span class="v">GroupName = string()</span></li><li><span class="v">Prefix = string()</span></li><li><span class="v">SecModel = v1 | v2c | usm</span></li><li><span class="v">SecLevel = string()</span></li><li><span class="v">Match = prefix | exact</span></li><li><span class="v">RV = string()</span></li><li><span class="v">WV = string()</span></li><li><span class="v">NV = string()</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a access definition to the agent config. 
Equivalent to one vacmAccess-line in the <strong>vacm.conf</strong> file.</p><a name="delete_access"></a><h3>delete_access(Key) -&gt; Ret</h3><p>Delete one access definition</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a access definition from the agent config.</p><a name="add_view_tree_fam"></a><h3>add_view_tree_fam(ViewIndex, SubTree, Status, Mask) -&gt; Ret</h3><p>Add one view tree family definition</p><ul><li><span class="v">ViewIndex = integer()</span></li><li><span class="v">SubTree = oid()</span></li><li><span class="v">Status = included | excluded</span></li><li><span class="v">Mask = null | [integer()], where all values are either 0 or 1</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a view tree family definition to the agent config. 
Equivalent to one vacmViewTreeFamily-line in the 
<strong>vacm.conf</strong> file.</p><a name="delete_view_tree_fam"></a><h3>delete_view_tree_fam(Key) -&gt; Ret</h3><p>Delete one view tree family definition</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a view tree family definition from the agent config.</p><h2>snmpc</h2><p>Interface Functions to the SNMP toolkit MIB compiler</p><p>The module <strong>snmpc</strong> contains interface functions to the 
SNMP toolkit MIB compiler.<a name="compile"></a></p><h2>Functions</h2><h3>compile(File)</h3><h3>compile(File, Options) -&gt; {ok, BinFileName} | {error, Reason}</h3><p>Compile the specified MIB</p><ul><li><span class="v">File = string()</span></li><li><span class="v">Options = [opt()]</span></li><li><span class="v">opt() = db() | relaxed_row_name_assign_check() | deprecated() |  description() | reference() | group_check() |  i() | il() |  imports() | module() | module_identity() | module_compliance() |  agent_capabilities() | outdir() |  no_defs() | verbosity() |  warnings() | warnings_as_errors()</span></li><li><span class="v">db() = {db, volatile|persistent|mnesia}</span></li><li><span class="v">deprecated() = {deprecated, bool()}</span></li><li><span class="v">relaxed_row_name_assign_check() = relaxed_row_name_assign_check</span></li><li><span class="v">description() = description</span></li><li><span class="v">reference() = reference</span></li><li><span class="v">group_check() = {group_check, bool()}</span></li><li><span class="v">i() = {i, [dir()]}</span></li><li><span class="v">il() = {il, [dir()]}</span></li><li><span class="v">imports() = imports</span></li><li><span class="v">module() = {module, atom()}</span></li><li><span class="v">module_identity() = module_identity</span></li><li><span class="v">module_compliance() = module_compliance</span></li><li><span class="v">agent_capabilities() = agent_capabilities</span></li><li><span class="v">no_defs() = no_defs</span></li><li><span class="v">outdir() = {outdir, dir()}</span></li><li><span class="v">verbosity() = {verbosity, silence|warning|info|log|debug|trace}</span></li><li><span class="v">warnings() = {warnings, bool()}</span></li><li><span class="v">warnings_as_errors() = warnings_as_errors</span></li><li><span class="v">dir() = string()</span></li><li><span class="v">BinFileName = string()</span></li></ul><a name="compiler_opts"></a><p>Compiles the specified MIB file <strong>&lt;File&gt;.mib</strong>.  The
compiled file <strong>BinFileName</strong> is called 
<strong>&lt;File&gt;.bin</strong>. </p><ul><li> <p>The option <strong>db</strong> specifies which database should
be used for the default instrumentation. </p> <p>Default is <strong>volatile</strong>. </p> </li><li> <p>The option <strong>deprecated</strong> specifies if a deprecated 
definition should be kept or not. If the option is 
false the MIB compiler will ignore all deprecated
definitions. </p> <p>Default is <strong>true</strong>. </p> </li><li> <p>The option <strong>relaxed_row_name_assign_check</strong>, if present,
specifies that the row name assign check shall not be done 
strictly according to the SMI (which allows only the value 1). 
With this option, all values greater than zero is allowed 
(&gt;= 1). This means that the error will be converted to a 
warning. </p> <p>By default it is not included, but if this option is present 
it will be. </p> </li><li> <p>The option <strong>description</strong> specifies if the text
of the DESCRIPTION field will be included or not. </p> <p>By default it is not included, but if this option is 
present it will be. </p> </li><li> <p>The option <strong>reference</strong> specifies if the text
of the REFERENCE field, when found in a table definition, 
will be included or not. </p> <p>By default it is not included, but if this option is present 
it will be. The reference text will be placed in the allocList 
field of the mib-entry record (#me{}) for the table. </p> </li><li> <p>The option <strong>group_check</strong> specifies whether the
mib compiler should check the OBJECT-GROUP macro and
the NOTIFICATION-GROUP macro for correctness or not.  </p> <p>Default is <strong>true</strong>. </p> </li><li> <p>The option <strong>i</strong> specifies the path to search for
imported (compiled) MIB files. The directories should be
strings with a trailing directory delimiter. </p> <p>Default is <strong>["./"]</strong>. </p> </li><li> <p>The option <strong>il</strong> (include_lib) also specifies a
list of directories to search for imported MIBs. It
assumes that the first element in the directory name
corresponds to an OTP application. The compiler will find
the current installed version. For example, the value
["snmp/mibs/"] will be replaced by ["snmp-3.1.1/mibs/"]
(or what the current version may be in the system). The
current directory and the 
<strong>&lt;snmp-home&gt;/priv/mibs/</strong>
are always listed last in the include path. </p> </li><li> <p>The option <strong>imports</strong>, if present, specifies that 
the IMPORT statement of the MIB shall be included in the 
compiled mib. </p> </li><li> <p>The option <strong>module</strong>, if present, specifies the
name of a module which implements all instrumentation
functions for the MIB.  </p> <p>The name of all instrumentation
functions must be the same as the corresponding managed
object it implements. </p> </li><li> <p>The option <strong>module_identity</strong>, if present, specifies 
that the info part of the MODULE-IDENTITY statement of the MIB 
shall be included in the compiled mib. </p> </li><li> <p>The option <strong>module_compliance</strong>, if present, specifies 
that the MODULE-COMPLIANCE statement of the MIB shall be included 
(with a mib-entry record) in the compiled mib. The mib-entry record 
of the module-compliance will contain <strong>reference</strong> and <strong>module</strong> 
part(s) this info in the <strong>assocList</strong> field). </p> </li><li> <p>The option <strong>agent_capabilities</strong>, if present, specifies 
that the AGENT-CAPABILITIES statement of the MIB shall be included 
(with a mib-entry record) in the compiled mib. The mib-entry record 
of the agent-capabilitie will contain <strong>reference</strong> and <strong>modules</strong> 
part(s) this info in the <strong>assocList</strong> field). </p> </li><li> <p>The option <strong>no_defs</strong>, if present, specifies 
that if a managed object does not have an instrumentation
function, the default instrumentation function should NOT
be used, instead this is reported as an error, and the
compilation aborts. </p> </li><li> <p>The option <strong>verbosity</strong> specifies the verbosity of
the SNMP mib compiler. I.e. if warning, info, log, debug 
and trace messages shall be shown. </p> <p>Default is <strong>silence</strong>. </p> <p>Note that if the option <strong>warnings</strong> is <strong>true</strong> and the 
option <strong>verbosity</strong> is <strong>silence</strong>, warning messages will
still be shown. </p> </li><li> <p>The option <strong>warnings</strong> specifies whether warning
messages should be shown. </p> <p>Default is <strong>true</strong>. </p> </li><li> <p>The option <strong>warnings_as_errors</strong>, if present, specifies 
whether warnings should be treated as errors.</p> </li></ul><p>The MIB compiler understands both SMIv1 and SMIv2 MIBs.  It
uses the <strong>MODULE-IDENTITY</strong> statement to determine if the MIB is
version 1 or 2.
</p><p>The MIB compiler can be invoked from the OS command line by
using the command <strong>erlc</strong>.  <strong>erlc</strong> recognizes the
extension <strong>.mib</strong>, and invokes the SNMP MIB compiler for
files with that extension. The options <strong>db</strong>, 
<strong>group_check</strong>, <strong>deprecated</strong>, <strong>description</strong>,
<strong>verbosity</strong>, <strong>imports</strong> and <strong>module_identity</strong>
have to be specified to <strong>erlc</strong> using the syntax 
<strong>+term</strong>.  See <strong>erlc(1)</strong> for details.
</p><a name="is_consistent"></a><h3>is_consistent(Mibs) -&gt; ok | {error, Reason}</h3><p>Check for OID conflicts between MIBs</p><ul><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = string()</span></li></ul><p>Checks for multiple usage of object identifiers and traps
between MIBs.
</p><a name="mib_to_hrl"></a><h3>mib_to_hrl(MibName) -&gt; ok | {error, Reason}</h3><p>Generate constants for the objects in the MIB</p><ul><li><span class="v">MibName = string()</span></li></ul><p>Generates a <strong>.hrl</strong> file with definitions of Erlang
constants for the objects in the MIB. The <strong>.hrl</strong> file is
called <strong>&lt;MibName&gt;.hrl</strong>. The MIB must be compiled, and
present in the current directory.
</p><p>The <strong>mib_to_hrl</strong> generator can be invoked from the OS
command line by using the command <strong>erlc</strong>.  <strong>erlc</strong>
recognizes the extension <strong>.bin</strong>, and invokes this function
for files with that extension.
</p><h3>See Also</h3><p>erlc(1)
</p><h2>snmpc(command)</h2><p>SNMP MIB compiler frontend</p><p>The <strong>snmpc</strong> program provides a way to run
the SNMP MIB compiler of the Erlang system. </p><h2>Functions</h2><h3>snmpc [options] file.mib | file.bin</h3><p>Compile MIBs</p><p><strong>snmpc</strong> compile a SNMP MIB file, 
see <a href="./snmpc#compile">compile/1,2</a> for 
more info. </p><p>It can also be used to generate a header file (.hrl) 
with definitions of Erlang constants for the objects in 
the MIB, see 
<a href="./snmpc#mib_to_hrl">mib_to_hrl/1</a>. </p><a name="options"></a><h3>Compiler options</h3><p>The following options are supported (note that most of these relate 
to the compilation of the MIB file):</p><a name="option_help"></a><dl><dt>--help</dt><dd> <p>Prints help info.</p> <a name="option_version"></a> </dd><dt>--version</dt><dd> <p>Prints application and mib format version.</p> <a name="option_verbosity"></a> </dd><dt>--verbosity <em>verbosity</em></dt><dd> <p>Print debug info. </p> <p><strong>verbosity</strong> = <strong>trace</strong> | <strong>debug</strong> | <strong>log</strong> | <strong>info</strong> | <strong>silence</strong></p> <p>Defaults to <strong>silence</strong>.</p> <a name="option_w"></a> <a name="option_warnings"></a> </dd><dt>--warnings | --W</dt><dd> <p>Print warning messages. </p> <a name="option_wae"></a> <a name="option_werror"></a> </dd><dt>--wae | --Werror</dt><dd> <p>Warnings as errors. 
Indicates that warnings shall be treated as errors. </p> <a name="option_odir"></a> </dd><dt>--o <em>directory</em></dt><dd> <p>The directory where the compiler should place the output files.
If not specified, output files will be placed in the current working
directory.</p> <a name="option_idir"></a> </dd><dt>--i <em>Directory</em></dt><dd> <p>Specifies the path to search for imported (compiled) MIB files. 
By default, the current working directory is always included. </p> <p>This option can be present several times, each time specifying
<em>one</em> path. </p> <a name="option_ildir"></a> </dd><dt>--il <em>Directory</em></dt><dd> <p>This option (include_lib), specifies a list of directories to 
search for imported MIBs. It assumes that the first element in 
the directory name corresponds to an OTP application. The compiler 
will find the current installed version. For example, the value 
["snmp/mibs/"] will be replaced by ["snmp-3.1.1/mibs/"] (or what 
the current version may be in the system). The current directory 
and the "snmp-home"/priv/mibs/ are always listed last in the
include path. </p> <a name="option_sgc"></a> </dd><dt>--sgc</dt><dd> <p>This option (skip group check), if present, disables the 
group check of the mib compiler. 
That is, should the OBJECT-GROUP and the NOTIFICATION-GROUP 
macro(s) be checked for correctness or not. </p> <a name="option_dep"></a> </dd><dt>--dep</dt><dd> <p>Keep deprecated definition(s). 
If not specified the compiler will ignore deprecated definitions. </p> <a name="option_desc"></a> </dd><dt>--desc</dt><dd> <p>The DESCRIPTION field will be included. </p> <a name="option_ref"></a> </dd><dt>--ref</dt><dd> <p>The REFERENCE field will be included. </p> <a name="option_imp"></a> </dd><dt>--imp</dt><dd> <p>The IMPORTS field will be included. </p> <a name="option_mi"></a> </dd><dt>--mi</dt><dd> <p>The MODULE-IDENTITY field will be included. </p> <a name="option_mc"></a> </dd><dt>--mc</dt><dd> <p>The MODULE-COMPLIANCE field will be included. </p> <a name="option_ac"></a> </dd><dt>--ac</dt><dd> <p>The AGENT-CAPABILITIES field will be included. </p> <a name="option_mod"></a> </dd><dt>--mod <em>module</em></dt><dd> <p>The module which implements all the instrumentation functions. </p> <p>The name of all instrumentation functions must be the 
same as the corresponding managed object it implements. </p> <a name="option_nd"></a> </dd><dt>--nd</dt><dd> <p>The default instrumentation functions will <em>not</em> be
used if a managed object have no instrumentation function.
Instead this will be reported as an error, and the compilation 
aborts. </p> <a name="option_rrnac"></a> </dd><dt>--rrnac</dt><dd> <p>This option, if present, specifies that the row name assign check 
shall not be done strictly according to the SMI (which allows only 
the value 1). </p> <p>With this option, all values greater than zero is allowed (&gt;= 1). 
This means that the error will be converted to a warning. </p> <p>By default it is not included, but if this option is present 
it will be. </p> <a name="see_also"></a> </dd></dl><h3>SEE ALSO</h3><p><a href="./erlc">erlc(1)</a>,
<a href="./compile">compile(3)</a>,
<a href="./snmpc">snmpc(3)</a></p><h2>snmpm</h2><p>Interface functions to the SNMP toolkit manager</p><p>The module <strong>snmpm</strong> contains interface functions to the 
SNMP manager. </p><h3>Common Data Types</h3><p>The following data types are used in the functions below:</p><pre><code class="">
oid() = [byte()]  -  The oid() type is used to represent an ASN.1 OBJECT IDENTIFIER
snmp_reply() = {error_status(), error_index(), varbinds()}
error_status() = noError | atom()
error_index() = integer()
varbinds() = [varbind()]
atl_type() = read | write | read_write
target_name() = string()  -  Is a unique *non-empty* string
vars_and_vals() = [var_and_val()]
var_and_val() = {oid(), value_type(), value()} | {oid(), value()}
value_type() = o ('OBJECT IDENTIFIER') | 
               i ('INTEGER') | 
               u ('Unsigned32') | 
               g ('Unsigned32') | 
               s ('OCTET SRING') | 
               b ('BITS') | 
               ip ('IpAddress') | 
               op ('Opaque') | 
               c32 ('Counter32') | 
               c64 ('Counter64') | 
               tt ('TimeTicks')
value() = term()
community() = string()
sec_model() = any | v1 | v2c | usm
sec_name() = string()
sec_level() = noAuthNoPriv | authNoPriv | authPriv
</code></pre><p>See also the <a href="./snmpa_conf#types"> data types in </a>.</p><a name="monitor"></a><h2>Functions</h2><h3>monitor() -&gt; Ref</h3><p>Monitor the snmp manager</p><ul><li><span class="v">Ref = reference()</span></li></ul><p>Monitor the SNMP manager. In case of a crash, the calling 
(monitoring) process will get a 'DOWN' message (see the erlang 
module for more info). </p><a name="demonitor"></a><h3>demonitor(Ref) -&gt; void()</h3><p>Turn off monitoring of the snmp manager</p><ul><li><span class="v">Ref = reference()</span></li></ul><p>Turn off monitoring of the SNMP manager. </p><a name="notify_started"></a><h3>notify_started(Timeout) -&gt; Pid</h3><p>Request to be notified when manager started</p><ul><li><span class="v">Timeout = integer()</span></li><li><span class="v">Pid = pid()</span></li></ul><p>Request a notification (message) when the SNMP manager has 
started. </p><p>The <strong>Timeout</strong> is the time the request is valid. The 
value has to be greater then zero. </p><p>The <strong>Pid</strong> is the process handling the supervision of the 
SNMP manager start. When the manager has started a completion
message will be sent to the client from this process: 
<strong>{snmpm_started, Pid}</strong>. If the SNMP manager was not started 
in time, a timeout message will be sent to the client: 
<strong>{snmpm_start_timeout, Pid}</strong>. </p><p>A client application that is dependent on the SNMP manager 
will use this function in order to be notified of when the
manager has started. There are two situations when this 
is useful:</p><ul><li> <p>During the start of a system, when a client application 
<em>could</em> start prior to the SNMP manager but is dependent
upon it, and therefor has to wait for it to start.</p> </li><li> <p>When the SNMP manager has crashed, the dependent client 
application has to wait for the SNMP manager to be restarted
before it can <em>reconnect</em>.</p> </li></ul><p>The function returns the pid() of a handler process, that does
the supervision on behalf of the client application. Note that the 
client application is linked to this handler. </p><p>This function is used in conjunction with the monitor function.</p><a name="cancel_notify_started"></a><h3>cancel_notify_started(Pid) -&gt; void()</h3><p>Cancel request to be notified when manager started</p><ul><li><span class="v">Pid = pid()</span></li></ul><p>Cancel a previous request to be notified of SNMP manager start.</p><a name="register_user"></a><h3>register_user(Id, Module, Data) -&gt; ok | {error, Reason}</h3><h3>register_user(Id, Module, Data, DefaultAgentConfig) -&gt; ok | {error, Reason}</h3><p>Register a user of the manager</p><ul><li><span class="v">Id = term()</span></li><li><span class="v">Module = snmpm_user()</span></li><li><span class="v">Data = term()</span></li><li><span class="v">DefaultAgentConfig = [default_agent_config()]</span></li><li><span class="v">default_agent_config() = {Item, Val}</span></li><li><span class="v">Item = community | timeout | max_message_size | version | sec_model | sec_name | sec_level</span></li><li><span class="v">Val = term()</span></li><li><span class="v">Reason = term()</span></li><li><span class="v">snmpm_user() = Module implementing the snmpm_user behaviour</span></li></ul><p>Register the manager entity (=user) responsible for specific 
agent(s). </p><p><strong>Module</strong> is the callback module (snmpm_user behaviour) which 
will be called whenever something happens (detected 
agent, incoming reply or incoming trap/notification).
Note that this could have already been done as a 
consequence of the node config. (see users.conf).</p><p>The argument <strong>DefaultAgentConfig</strong> is used as default 
values when this user register agents.</p><p>The type of <strong>Val</strong> depends on <strong>Item</strong>: </p><pre><code class="">
community = string()
timeout = integer() | snmp_timer()
max_message_size = integer()
version = v1 | v2 | v3 
sec_model = any | v1 | v2c | usm 
sec_name = string() 
sec_level = noAuthNoPriv | authNoPriv | authPriv
        </code></pre><a name="register_user_monitor"></a><h3>register_user_monitor(Id, Module, Data) -&gt; ok | {error, Reason}</h3><h3>register_user_monitor(Id, Module, Data, DefaultAgentConfig) -&gt; ok | {error, Reason}</h3><p>Register a monitored user of the manager</p><ul><li><span class="v">Id = term()</span></li><li><span class="v">Module = snmpm_user()</span></li><li><span class="v">DefaultAgentConfig = [default_agent_config()]</span></li><li><span class="v">default_agent_config() = {Item, Val}</span></li><li><span class="v">Item = community | timeout | max_message_size | version | sec_model | sec_name | sec_level</span></li><li><span class="v">Val = term()</span></li><li><span class="v">Data = term()</span></li><li><span class="v">Reason = term()</span></li><li><span class="v">snmpm_user() = Module implementing the snmpm_user behaviour</span></li></ul><p>Register the monitored manager entity (=user) responsible 
for specific agent(s). </p><p>The process performing the registration will be monitored. 
Which means that if that process should die, all agents 
registered by that user process will be unregistered. All 
outstanding requests will be canceled. </p><p><strong>Module</strong> is the callback module (snmpm_user behaviour) which 
will be called whenever something happens (detected 
agent, incoming reply or incoming trap/notification).
Note that this could have already been done as a 
consequence of the node config. (see users.conf).</p><p>The argument <strong>DefaultAgentConfig</strong> is used as default values when 
this user register agents.</p><p>The type of <strong>Val</strong> depends on <strong>Item</strong>: </p><pre><code class="">
community = string()
timeout = integer() | snmp_timer()
max_message_size = integer()
version = v1 | v2 | v3 
sec_model = any | v1 | v2c | usm 
sec_name = string() 
sec_level = noAuthNoPriv | authNoPriv | authPriv
        </code></pre><a name="unregister_user"></a><h3>unregister_user(Id) -&gt; ok | {error, Reason}</h3><p>Unregister the user</p><ul><li><span class="v">Id = term()</span></li></ul><p>Unregister the user.</p><a name="which_users"></a><h3>which_users() -&gt; Users</h3><p>Get a list of all users</p><ul><li><span class="v">Users = [UserId]</span></li><li><span class="v">UserId = term()</span></li></ul><p>Get a list of the identities of all registered users.</p><a name="register_agent"></a><h3>register_agent(UserId, TargetName, Config) -&gt; ok | {error, Reason}</h3><p>Register this agent</p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">Config = [agent_config()]</span></li><li><span class="v">agent_config() = {Item, Val}</span></li><li><span class="v">Item = engine_id | address | port | community | timeout | max_message_size | version | sec_model | sec_name | sec_level | tdomain</span></li><li><span class="v">Val = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Explicitly instruct the manager to handle this agent, with
<strong>UserId</strong> as the responsible user. </p><p>Called to instruct the manager that this agent shall be handled. 
This function is used when the user knows in advance which agents 
the manager shall handle.
Note that there is an alternate way to do the same thing:
Add the agent to the manager config files (see 
<a href="./snmp_manager_config_files#agents">agents.conf</a>).</p><p><strong>TargetName</strong> is a non-empty string, 
uniquely identifying the agent. </p><p>The type of <strong>Val</strong> depends on <strong>Item</strong>: </p><pre><code class="">
[mandatory] engine_id = string()
[mandatory] tadress = transportAddress()  % Depends on tdomain
[optional]  port = inet:port_number()
[optional]  tdomain = transportDomain()
[optional]  community = string()
[optional]  timeout = integer() | snmp_timer()
[optional]  max_message_size = integer()
[optional]  version = v1 | v2 | v3 
[optional]  sec_model = any | v1 | v2c | usm 
[optional]  sec_name = string() 
[optional]  sec_level = noAuthNoPriv | authNoPriv | authPriv
</code></pre><p>Note that if no <strong>tdomain</strong> is given, the default value,
<strong>transportDomainUdpIpv4</strong>, is used.</p><p>Note that if no <strong>port</strong> is given and if <strong>taddress</strong> does not
contain a port number, the default value is used.</p><a name="unregister_agent"></a><h3>unregister_agent(UserId, TargetName) -&gt; ok | {error, Reason}</h3><p>Unregister the user</p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li></ul><p>Unregister the agent.</p><a name="agent_info"></a><h3>agent_info(TargetName, Item) -&gt; {ok, Val} | {error, Reason}</h3><p>Retrieve agent config</p><ul><li><span class="v">TargetName = target_name()</span></li><li><span class="v">Item = atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retrieve agent config.</p><a name="update_agent_info"></a><h3>update_agent_info(UserId, TargetName, Info) -&gt; ok | {error, Reason}</h3><h3>update_agent_info(UserId, TargetName, Item, Val) -&gt; ok | {error, Reason}</h3><p>Update agent config</p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">Info = [{item(), item_value()}]</span></li><li><span class="v">Item = item()</span></li><li><span class="v">item() = atom()</span></li><li><span class="v">Val = item_value()</span></li><li><span class="v">item_value() = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Update agent config. The function <strong>update_agent_info/3</strong> 
should be used when several values needs to be updated atomically. </p><p>See function 
<a href="#register_agent">register_agent</a>
for more info about what kind of items are allowed. </p><a name="which_agents"></a><h3>which_agents() -&gt; Agents</h3><h3>which_agents(UserId) -&gt; Agents</h3><p>List the registered agents</p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">Agents = [TargetName]</span></li><li><span class="v">TargetName = target_name()</span></li></ul><p>Get a list of all registered agents or all agents registered
by a specific user.</p><a name="register_usm_user"></a><h3>register_usm_user(EngineID, UserName, Conf) -&gt; ok | {error, Reason}</h3><p>Register this USM user</p><ul><li><span class="v">EngineID = string()</span></li><li><span class="v">UserName = string()</span></li><li><span class="v">Conf = [usm_config()]</span></li><li><span class="v">usm_config() = {Item, Val}</span></li><li><span class="v">Item = sec_name | auth | auth_key | priv | priv_key</span></li><li><span class="v">Val = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Explicitly instruct the manager to handle this USM user.
Note that there is an alternate way to do the same thing:
Add the usm user to the manager config files (see 
<a href="./snmp_manager_config_files#usm_user">usm.conf</a>).</p><p>The type of <strong>Val</strong> depends on <strong>Item</strong>: </p><pre><code class="">
sec_name = string()
auth = usmNoAuthProtocol | usmHMACMD5AuthProtocol | usmHMACSHAAuthProtocoltimeout
auth_key = [integer()]   (length 16 if auth = usmHMACMD5AuthProtocol, 
                          length 20 if auth = usmHMACSHAAuthProtocol)
priv = usmNoPrivProtocol | usmDESPrivProtocol | usmAesCfb128Protocol
priv_key = [integer()]   (length is 16 if priv = usmDESPrivProtocol | usmAesCfb128Protocol).
</code></pre><a name="unregister_usm_user"></a><h3>unregister_usm_user(EngineID, UserName) -&gt; ok | {error, Reason}</h3><p>Unregister this USM user</p><ul><li><span class="v">EngineID = string()</span></li><li><span class="v">UserName = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Unregister this USM user.</p><a name="which_usm_users1"></a><h3>usm_user_info(EngineID, UserName, Item) -&gt; {ok, Val} | {error, Reason}</h3><p>Retrieve usm user config</p><ul><li><span class="v">EngineID = string()</span></li><li><span class="v">UsmName = string()</span></li><li><span class="v">Item = sec_name | auth | auth_key | priv | priv_key</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retrieve usm user config.</p><a name="update_usm_user_info"></a><h3>update_usm_user_info(EngineID, UserName, Item, Val) -&gt; ok | {error, Reason}</h3><p>Update agent config</p><ul><li><span class="v">EngineID = string()</span></li><li><span class="v">UsmName = string()</span></li><li><span class="v">Item = sec_name | auth | auth_key | priv | priv_key</span></li><li><span class="v">Val = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Update usm user config.</p><a name="which_usm_users"></a><h3>which_usm_users() -&gt; UsmUsers</h3><p>List all the registered usm users</p><ul><li><span class="v">UsmUsers = [{EngineID,UserName}]</span></li><li><span class="v">EngineID = string()</span></li><li><span class="v">UsmName = string()</span></li></ul><p>Get a list of all registered usm users.</p><a name="which_usm_users2"></a><h3>which_usm_users(EngineID) -&gt; UsmUsers</h3><p>List the registered usm users</p><ul><li><span class="v">UsmUsers = [UserName]</span></li><li><span class="v">UserName = string()</span></li></ul><p>Get a list of all registered usm users with engine-id 
<strong>EngineID</strong>.</p><a name="sync_get2"></a><h3>sync_get2(UserId, TargetName, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_get2(UserId, TargetName, Oids, SendOpts) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><p>Synchronous <strong>get-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">SendOpts = send_opts()</span></li><li><span class="v">send_opts() = [send_opt()]</span></li><li><span class="v">send_opt() = {context, string()} | {timeout, pos_integer()} | {extra, term()} | {community, community()} | {sec_model, sec_model()} | {sec_name, string()} | {sec_level, sec_level()} | {max_message_size, pos_integer()}</span></li><li><span class="v">SnmpReply = snmp_reply()</span></li><li><span class="v">Remaining = integer()</span></li><li><span class="v">Reason = {send_failed, ReqId, ActualReason} | {invalid_sec_info, SecInfo, SnmpInfo} | term()</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">ActualReason = term()</span></li><li><span class="v">SecInfo = [sec_info()]</span></li><li><span class="v">sec_info() = {sec_tag(), ExpectedValue, ReceivedValue}</span></li><li><span class="v">sec_tag() = atom()</span></li><li><span class="v">ExpectedValue = ReceivedValue = term()</span></li><li><span class="v">SnmpInfo = term()</span></li></ul><p>Synchronous <strong>get-request</strong>. </p><p><strong>Remaining</strong> is the remaining time of the given (or default) 
timeout time.</p><p>When <em>Reason</em> is <em>{send_failed, ...}</em> it means that
the net_if process failed to send the message. This could happen
because of any number of reasons, i.e. encoding error. 
<em>ActualReason</em> is the actual reason in this case. </p><p>The send option <strong>extra</strong> specifies an opaque data structure 
passed on to the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a option (when using the built in 
net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><p>Some of the send options (<strong>community</strong>, <strong>sec_model</strong>, 
<strong>sec_name</strong>, <strong>sec_level</strong> and <strong>max_message_size</strong>) 
are <strong>override options</strong>. That is,
for <em>this</em> request, they override any configuration done 
when the agent was registered. </p><p>For <strong>SnmpInfo</strong>, see the user callback function 
<a href="./snmpm_user#handle_report">handle_report</a>.</p><a name="sync_get"></a><h3>sync_get(UserId, TargetName, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_get(UserId, TargetName, ContextName, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_get(UserId, TargetName, Oids, Timeout) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_get(UserId, TargetName, ContextName, Oids, Timeout) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_get(UserId, TargetName, ContextName, Oids, Timeout, ExtraInfo) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><p>Synchronous <strong>get-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">ContextName = string()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">SnmpReply = snmp_reply()</span></li><li><span class="v">Remaining = integer()</span></li><li><span class="v">Reason = {send_failed, ReqId, R} | {invalid_sec_info, SecInfo, SnmpInfo} | term()</span></li><li><span class="v">R = term()</span></li><li><span class="v">SecInfo = [sec_info()]</span></li><li><span class="v">sec_info() = {sec_tag(), ExpectedValue, ReceivedValue}</span></li><li><span class="v">sec_tag() = atom()</span></li><li><span class="v">ExpectedValue = ReceivedValue = term()</span></li><li><span class="v">SnmpInfo = term()</span></li></ul><p>Synchronous <strong>get-request</strong>. </p><p><strong>Remaining</strong> is the remaining time of the given or 
default timeout time.</p><p>When <em>Reason</em> is <em>{send_failed, ...}</em> it means that
the net_if process failed to send the message. This could happen
because of any number of reasons, i.e. encoding error. <em>R</em> 
is the actual reason in this case. </p><p><strong>ExtraInfo</strong> is an opaque data structure passed on to
the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a configuration (when using the 
built in net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><p>For <strong>SnmpInfo</strong>, see the user callback function 
<a href="./snmpm_user#handle_report">handle_report</a>.</p><a name="async_get2"></a><h3>async_get2(UserId, TargetName, Oids) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_get2(UserId, TargetName, Oids, SendOpts) -&gt; {ok, ReqId} | {error, Reason}</h3><p>Asynchronous <strong>get-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">SendOpts = send_opts()</span></li><li><span class="v">send_opts() = [send_opt()]</span></li><li><span class="v">send_opt() = {context, string()} | {timeout, pos_integer()} | {extra, term()} | {community, community()} | {sec_model, sec_model()} | {sec_name, string()} | {sec_level, sec_level()} | {max_message_size, pos_integer()}</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Asynchronous <strong>get-request</strong>.</p><p>The reply, if it arrives, will be delivered to the user 
through a call to the snmpm_user callback function 
<strong>handle_pdu</strong>.</p><p>The send option <strong>timeout</strong> specifies for how long the request is 
valid (after which the manager is free to delete it).</p><p>The send option <strong>extra</strong> specifies an opaque data structure 
passed on to the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a option (when using the built in 
net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><p>Some of the send options (<strong>community</strong>, <strong>sec_model</strong>, 
<strong>sec_name</strong>, <strong>sec_level</strong> and <strong>max_message_size</strong>) 
are <strong>override options</strong>. That is,
for <em>this</em> request, they override any configuration done 
when the agent was registered. </p><a name="async_get"></a><h3>async_get(UserId, TargetName, Oids) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_get(UserId, TargetName, ContextName, Oids) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_get(UserId, TargetName, Oids, Expire) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_get(UserId, TargetName, ContextName, Oids, Expire) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_get(UserId, TargetName, ContextName, Oids, Expire, ExtraInfo) -&gt; {ok, ReqId} | {error, Reason}</h3><p>Asynchronous <strong>get-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">ContextName = string()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">Expire = integer()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Asynchronous <strong>get-request</strong>.</p><p>The reply, if it arrives, will be delivered to the user 
through a call to the snmpm_user callback function 
<strong>handle_pdu</strong>.</p><p>The <strong>Expire</strong> time indicates for how long the request is 
valid (after which the manager is free to delete it).</p><p><strong>ExtraInfo</strong> is an opaque data structure passed on to
the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a configuration (when using the 
built in net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><a name="sync_get_next2"></a><h3>sync_get_next2(UserId, TargetName, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_get_next2(UserId, TargetName, Oids, SendOpts) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><p>Synchronous <strong>get-next-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">SendOpts = send_opts()</span></li><li><span class="v">send_opts() = [send_opt()]</span></li><li><span class="v">send_opt() = {context, string()} | {timeout, pos_integer()} | {extra, term()} | {community, community()} | {sec_model, sec_model()} | {sec_name, string()} | {sec_level, sec_level()} | {max_message_size, pos_integer()}</span></li><li><span class="v">SnmpReply = snmp_reply()</span></li><li><span class="v">Remaining = integer()</span></li><li><span class="v">Reason = {send_failed, ReqId, ActualReason} | {invalid_sec_info, SecInfo, SnmpInfo} | term()</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">ActualReason = term()</span></li><li><span class="v">SecInfo = [sec_info()]</span></li><li><span class="v">sec_info() = {sec_tag(), ExpectedValue, ReceivedValue}</span></li><li><span class="v">sec_tag() = atom()</span></li><li><span class="v">ExpectedValue = ReceivedValue = term()</span></li><li><span class="v">SnmpInfo = term()</span></li></ul><p>Synchronous <strong>get-next-request</strong>. </p><p><strong>Remaining</strong> is the remaining time of the given (or default) 
timeout time.</p><p>When <em>Reason</em> is <em>{send_failed, ...}</em> it means that
the net_if process failed to send the message. This could happen
because of any number of reasons, i.e. encoding error. 
<em>ActualReason</em> is the actual reason in this case. </p><p>The send option <strong>extra</strong> specifies an opaque data structure 
passed on to the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a option (when using the built in 
net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><p>Some of the send options (<strong>community</strong>, <strong>sec_model</strong>, 
<strong>sec_name</strong>, <strong>sec_level</strong> and <strong>max_message_size</strong>) 
are <strong>override options</strong>. That is,
for <em>this</em> request, they override any configuration done 
when the agent was registered. </p><p>For <strong>SnmpInfo</strong>, see the user callback function 
<a href="./snmpm_user#handle_report">handle_report</a>.</p><a name="sync_get_next"></a><h3>sync_get_next(UserId, TargetName, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_get_next(UserId, TargetName, ContextName, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_get_next(UserId, TargetName, Oids, Timeout) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_get_next(UserId, TargetName, ContextName, Oids, Timeout) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_get_next(UserId, TargetName, ContextName, Oids, Timeout, ExtraInfo) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><p>Synchronous <strong>get-next-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">ContextName = string()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">SnmpReply = snmp_reply()</span></li><li><span class="v">Remaining = integer()</span></li><li><span class="v">Reason = {send_failed, ReqId, R} | {invalid_sec_info, SecInfo, SnmpInfo} | term()</span></li><li><span class="v">R = term()</span></li></ul><p>Synchronous <strong>get-next-request</strong>. </p><p><strong>Remaining</strong> time of the given or default timeout time.</p><p>When <em>Reason</em> is <em>{send_failed, ...}</em> it means that
the net_if process failed to send the message. This could happen
because of any number of reasons, i.e. encoding error. <em>R</em> 
is the actual reason in this case. </p><p><strong>ExtraInfo</strong> is an opaque data structure passed on to
the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a configuration (when using the 
built in net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><a name="async_get_next2"></a><h3>async_get_next2(UserId, TargetName, Oids) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_get_next2(UserId, TargetName, Oids, SendOpts) -&gt; {ok, ReqId} | {error, Reason}</h3><p>Asynchronous <strong>get-next-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">send_opt() = {context, string()} | {timeout, pos_integer()} | {extra, term()} | {community, community()} | {sec_model, sec_model()} | {sec_name, string()} | {sec_level, sec_level()} | {max_message_size, pos_integer()}</span></li><li><span class="v">ReqId = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Asynchronous <strong>get-next-request</strong>. </p><p>The reply will be delivered to the user through a call
to the snmpm_user callback function <strong>handle_pdu</strong>.</p><p>The send option <strong>timeout</strong> specifies for how long the request is 
valid (after which the manager is free to delete it).</p><p>The send option <strong>extra</strong> specifies an opaque data structure 
passed on to the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a option (when using the built in 
net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><p>Some of the send options (<strong>community</strong>, <strong>sec_model</strong>, 
<strong>sec_name</strong>, <strong>sec_level</strong> and <strong>max_message_size</strong>) 
are <strong>override options</strong>. That is,
for <em>this</em> request, they override any configuration done 
when the agent was registered. </p><a name="async_get_next"></a><h3>async_get_next(UserId, TargetName, Oids) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_get_next(UserId, TargetName, ContextName, Oids) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_get_next(UserId, TargetName, Oids, Expire) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_get_next(UserId, TargetName, ContextName, Oids, Expire) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_get_next(UserId, TargetName, ContextName, Oids, Expire, ExtraInfo) -&gt; {ok, ReqId} | {error, Reason}</h3><p>Asynchronous <strong>get-next-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">ContextName = string()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">Expire = integer()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">ReqId = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Asynchronous <strong>get-next-request</strong>. </p><p>The reply will be delivered to the user through a call
to the snmpm_user callback function <strong>handle_pdu</strong>.</p><p>The <strong>Expire</strong> time indicates for how long the request is 
valid (after which the manager is free to delete it).</p><p><strong>ExtraInfo</strong> is an opaque data structure passed on to
the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a configuration (when using the 
built in net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><a name="sync_set2"></a><h3>sync_set2(UserId, TargetName, VarsAndVals) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_set2(UserId, TargetName, VarsAndVals, SendOpts) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><p>Synchronous <strong>set-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">VarsAndVals = vars_and_vals()</span></li><li><span class="v">SendOpts = send_opts()</span></li><li><span class="v">send_opts() = [send_opt()]</span></li><li><span class="v">send_opt() = {context, string()} | {timeout, pos_integer()} | {extra, term()} | {community, community()} | {sec_model, sec_model()} | {sec_name, string()} | {sec_level, sec_level()} | {max_message_size, pos_integer()}</span></li><li><span class="v">SnmpReply = snmp_reply()</span></li><li><span class="v">Remaining = integer()</span></li><li><span class="v">Reason = {send_failed, ReqId, ActualReason} | {invalid_sec_info, SecInfo, SnmpInfo} | term()</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">ActualReason = term()</span></li><li><span class="v">SecInfo = [sec_info()]</span></li><li><span class="v">sec_info() = {sec_tag(), ExpectedValue, ReceivedValue}</span></li><li><span class="v">sec_tag() = atom()</span></li><li><span class="v">ExpectedValue = ReceivedValue = term()</span></li><li><span class="v">SnmpInfo = term()</span></li></ul><p>Synchronous <strong>set-request</strong>. </p><p><strong>Remaining</strong> is the remaining time of the given (or default) 
timeout time.</p><p>When <em>Reason</em> is <em>{send_failed, ...}</em> it means that
the net_if process failed to send the message. This could happen
because of any number of reasons, i.e. encoding error. 
<em>ActualReason</em> is the actual reason in this case. </p><p>When <em>var_and_val()</em> is <em>{oid(), value()}</em>, the
manager makes an educated guess based on the loaded mibs. </p><p>The send option <strong>extra</strong> specifies an opaque data structure 
passed on to the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a option (when using the built in 
net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><p>Some of the send options (<strong>community</strong>, <strong>sec_model</strong>, 
<strong>sec_name</strong>, <strong>sec_level</strong> and <strong>max_message_size</strong>) 
are <strong>override options</strong>. That is,
for <em>this</em> request, they override any configuration done 
when the agent was registered. </p><p>For <strong>SnmpInfo</strong>, see the user callback function 
<a href="./snmpm_user#handle_report">handle_report</a>.</p><a name="sync_set"></a><h3>sync_set(UserId, TargetName, VarsAndVals) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_set(UserId, TargetName, ContextName, VarsAndVals) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_set(UserId, TargetName, VarsAndVals, Timeout) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_set(UserId, TargetName, ContextName, VarsAndVals, Timeout) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_set(UserId, TargetName, ContextName, VarsAndVals, Timeout, ExtraInfo) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><p>Synchronous <strong>set-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">ContextName = string()</span></li><li><span class="v">VarsAndVals = vars_and_vals()</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">SnmpReply = snmp_reply()</span></li><li><span class="v">Remaining = integer()</span></li><li><span class="v">Reason = {send_failed, ReqId, ActualReason} | {invalid_sec_info, SecInfo, SnmpInfo} | term()</span></li><li><span class="v">ActualReason = term()</span></li></ul><p>Synchronous <strong>set-request</strong>. </p><p><strong>Remaining</strong> time of the given or default timeout time.</p><p>When <em>Reason</em> is <em>{send_failed, ...}</em> it means that
the net_if process failed to send the message. This could happen
because of any number of reasons, i.e. encoding error. <em>R</em> 
is the actual reason in this case. </p><p>When <em>var_and_val()</em> is <em>{oid(), value()}</em>, the
manager makes an educated guess based on the loaded mibs. </p><p><strong>ExtraInfo</strong> is an opaque data structure passed on to
the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a configuration (when using the 
built in net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><a name="async_set2"></a><h3>async_set2(UserId, TargetName, VarsAndVals) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_set2(UserId, TargetName, VarsAndVals, SendOpts) -&gt; {ok, ReqId} | {error, Reason}</h3><p>Asynchronous <strong>set-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">VarsAndVals = vars_and_vals()</span></li><li><span class="v">SendOpts = send_opts()</span></li><li><span class="v">send_opts() = [send_opt()]</span></li><li><span class="v">send_opt() = {context, string()} | {timeout, pos_integer()} | {extra, term()} | {community, community()} | {sec_model, sec_model()} | {sec_name, string()} | {sec_level, sec_level()} | {max_message_size, pos_integer()}</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Asynchronous <strong>set-request</strong>. </p><p>The reply will be delivered to the user through a call
to the snmpm_user callback function <strong>handle_pdu</strong>.</p><p>The send option <strong>timeout</strong> specifies for how long the request is 
valid (after which the manager is free to delete it).</p><p>When <em>var_and_val()</em> is <em>{oid(), value()}</em>, the
manager makes an educated guess based on the loaded mibs. </p><p>The send option <strong>extra</strong> specifies an opaque data structure 
passed on to the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a option (when using the built in 
net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><p>Some of the send options (<strong>community</strong>, <strong>sec_model</strong>, 
<strong>sec_name</strong>, <strong>sec_level</strong> and <strong>max_message_size</strong>) 
are <strong>override options</strong>. That is,
for <em>this</em> request, they override any configuration done 
when the agent was registered. </p><a name="async_set"></a><h3>async_set(UserId, TargetName, VarsAndVals) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_set(UserId, TargetName, ContextName, VarsAndVals) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_set(UserId, TargetName, VarsAndVals, Expire) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_set(UserId, TargetName, ContextName, VarsAndVals, Expire) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_set(UserId, TargetName, ContextName, VarsAndVals, Expire, ExtraInfo) -&gt; {ok, ReqId} | {error, Reason}</h3><p>Asynchronous <strong>set-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">VarsAndVals = vars_and_vals()</span></li><li><span class="v">Expire = integer()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Asynchronous <strong>set-request</strong>. </p><p>The reply will be delivered to the user through a call
to the snmpm_user callback function <strong>handle_pdu</strong>.</p><p>The <strong>Expire</strong> time indicates for how long the request is 
valid (after which the manager is free to delete it).</p><p>When <em>var_and_val()</em> is <em>{oid(), value()}</em>, the
manager makes an educated guess based on the loaded mibs. </p><p><strong>ExtraInfo</strong> is an opaque data structure passed on to
the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a configuration (when using the 
built in net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><a name="sync_get_bulk2"></a><h3>sync_get_bulk2(UserId, TragetName, NonRep, MaxRep, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_get_bulk2(UserId, TragetName, NonRep, MaxRep, Oids, SendOpts) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><p>Synchronous <strong>get-bulk-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">NonRep = integer()</span></li><li><span class="v">MaxRep = integer()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">SendOpts = send_opts()</span></li><li><span class="v">send_opts() = [send_opt()]</span></li><li><span class="v">send_opt() = {context, string()} | {timeout, pos_integer()} | {extra, term()} | {community, community()} | {sec_model, sec_model()} | {sec_name, string()} | {sec_level, sec_level()} | {max_message_size, pos_integer()}</span></li><li><span class="v">SnmpReply = snmp_reply()</span></li><li><span class="v">Remaining = integer()</span></li><li><span class="v">Reason = {send_failed, ReqId, ActualReason} | {invalid_sec_info, SecInfo, SnmpInfo} | term()</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">ActualReason = term()</span></li><li><span class="v">SecInfo = [sec_info()]</span></li><li><span class="v">sec_info() = {sec_tag(), ExpectedValue, ReceivedValue}</span></li><li><span class="v">sec_tag() = atom()</span></li><li><span class="v">ExpectedValue = ReceivedValue = term()</span></li><li><span class="v">SnmpInfo = term()</span></li></ul><p>Synchronous <strong>get-bulk-request</strong> (See RFC1905).</p><p><strong>Remaining</strong> is the remaining time of the given (or default) 
timeout time.</p><p>When <em>Reason</em> is <em>{send_failed, ...}</em> it means that
the net_if process failed to send the message. This could happen
because of any number of reasons, i.e. encoding error. 
<em>ActualReason</em> is the actual reason in this case. </p><p>The send option <strong>extra</strong> specifies an opaque data structure 
passed on to the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a option (when using the built in 
net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><p>Some of the send options (<strong>community</strong>, <strong>sec_model</strong>, 
<strong>sec_name</strong>, <strong>sec_level</strong> and <strong>max_message_size</strong>) 
are <strong>override options</strong>. That is,
for <em>this</em> request, they override any configuration done 
when the agent was registered. </p><p>For <strong>SnmpInfo</strong>, see the user callback function 
<a href="./snmpm_user#handle_report">handle_report</a>.</p><a name="sync_get_bulk"></a><h3>sync_get_bulk(UserId, TragetName, NonRep, MaxRep, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_get_bulk(UserId, TragetName, NonRep, MaxRep, ContextName, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_get_bulk(UserId, TragetName, NonRep, MaxRep, Oids, Timeout) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_get_bulk(UserId, TragetName, NonRep, MaxRep, ContextName, Oids, Timeout) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><h3>sync_get_bulk(UserId, TragetName, NonRep, MaxRep, ContextName, Oids, Timeout, ExtraInfo) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h3><p>Synchronous <strong>get-bulk-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">NonRep = integer()</span></li><li><span class="v">MaxRep = integer()</span></li><li><span class="v">ContextName = string()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">SnmpReply = snmp_reply()</span></li><li><span class="v">Remaining = integer()</span></li><li><span class="v">Reason = {send_failed, ReqId, R} | {invalid_sec_info, SecInfo, SnmpInfo} | term()</span></li></ul><p>Synchronous <strong>get-bulk-request</strong> (See RFC1905).</p><p><strong>Remaining</strong> time of the given or default timeout time.</p><p>When <em>Reason</em> is <em>{send_failed, ...}</em> it means that
the net_if process failed to send the message. This could happen
because of any number of reasons, i.e. encoding error. <em>R</em> 
is the actual reason in this case. </p><p><strong>ExtraInfo</strong> is an opaque data structure passed on to
the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a configuration (when using the 
built in net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><a name="async_get_bulk2"></a><h3>async_get_bulk2(UserId, TargetName, NonRep, MaxRep, Oids) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_get_bulk2(UserId, TargetName, NonRep, MaxRep, Oids, SendOpts) -&gt; {ok, ReqId} | {error, Reason}</h3><p>Asynchronous <strong>get-bulk-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">NonRep = integer()</span></li><li><span class="v">MaxRep = integer()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">SendOpts = send_opts()</span></li><li><span class="v">send_opts() = [send_opt()]</span></li><li><span class="v">send_opt() = {context, string()} | {timeout, pos_integer()} | {extra, term()} | {community, community()} | {sec_model, sec_model()} | {sec_name, string()} | {sec_level, sec_level()} | {max_message_size, pos_integer()}</span></li><li><span class="v">ReqId = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Asynchronous <strong>get-bulk-request</strong> (See RFC1905).</p><p>The reply will be delivered to the user through a call
to the snmpm_user callback function <strong>handle_pdu</strong>.</p><p>The send option <strong>timeout</strong> specifies for how long the request is 
valid (after which the manager is free to delete it).</p><p>The send option <strong>extra</strong> specifies an opaque data structure 
passed on to the net-if process. The net-if process included in this
application makes no use of this info, so the only use for it
in such a configuration (when using the built in net-if) would
be tracing.</p><p>Some of the send options (<strong>community</strong>, <strong>sec_model</strong>, 
<strong>sec_name</strong>, <strong>sec_level</strong> and <strong>max_message_size</strong>) 
are <strong>override options</strong>. That is,
for <em>this</em> request, they override any configuration done 
when the agent was registered. </p><a name="async_get_bulk"></a><h3>async_get_bulk(UserId, TargetName, NonRep, MaxRep, Oids) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_get_bulk(UserId, TargetName, NonRep, MaxRep, ContextName, Oids) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_get_bulk(UserId, TargetName, NonRep, MaxRep, Oids, Expire) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_get_bulk(UserId, TargetName, NonRep, MaxRep, ContextName, Oids, Expire) -&gt; {ok, ReqId} | {error, Reason}</h3><h3>async_get_bulk(UserId, TargetName, NonRep, MaxRep, ContextName, Oids, Expire, ExtraInfo) -&gt; {ok, ReqId} | {error, Reason}</h3><p>Asynchronous <strong>get-bulk-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">NonRep = integer()</span></li><li><span class="v">MaxRep = integer()</span></li><li><span class="v">ContextName = string()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">Expire = integer()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">ReqId = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Asynchronous <strong>get-bulk-request</strong> (See RFC1905).</p><p>The reply will be delivered to the user through a call
to the snmpm_user callback function <strong>handle_pdu</strong>.</p><p>The <strong>Expire</strong> time indicates for how long the request is 
valid (after which the manager is free to delete it).</p><p><strong>ExtraInfo</strong> is an opaque data structure passed on to
the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a configuration (when using the 
built in net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><a name="cancel_async_request"></a><h3>cancel_async_request(UserId, ReqId) -&gt; ok | {error, Reason}</h3><p>Cancel a asynchronous request</p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Cancel a previous asynchronous request.</p><a name="log_to_txt"></a><h3>log_to_txt(LogDir)</h3><h3>log_to_txt(LogDir, Block | Mibs)</h3><h3>log_to_txt(LogDir, Mibs, Block | OutFile) -&gt; ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_txt(LogDir, Mibs, OutFile, Block | LogName) -&gt;  ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_txt(LogDir, Mibs, OutFile, LogName, Block | LogFile) -&gt;  ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block | Start) -&gt;  ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start)  -&gt; ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Start, Stop)  -&gt; ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start, Stop)  -&gt; ok | {ok, Cnt} | {error, Reason}</h3><p>Convert an Audit Trail Log to text format</p><ul><li><span class="v">LogDir = string()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Block = boolean()</span></li><li><span class="v">OutFile = string()</span></li><li><span class="v">LogName = string()</span></li><li><span class="v">LogFile = string()</span></li><li><span class="v">Start = Stop = null | calendar:datetime() | {local_time, calendar:datetime()} | {universal_time, calendar:datetime()} </span></li><li><span class="v">Cnt = {NumOK, NumERR}</span></li><li><span class="v">NumOK = non_neg_integer()</span></li><li><span class="v">NumERR = pos_integer()</span></li><li><span class="v">Reason = disk_log_open_error() | file_open_error() | term()</span></li><li><span class="v">disk_log_open_error() = {LogName, term()}</span></li><li><span class="v">file_open_error() = {OutFile, term()}</span></li></ul><p>Converts an Audit Trail Log to a readable text file. 
<strong>OutFile</strong> defaults to "./snmpm_log.txt". 
<strong>LogName</strong> defaults to "snmpm_log". 
<strong>LogFile</strong> defaults to "snmpm.log".</p><p>The <strong>Block</strong> argument indicates if the log should be blocked
during conversion. This could be usefull when converting large 
logs (when otherwise the log could wrap during conversion). 
Defaults to <strong>true</strong>. </p><p>See <a href="./snmp#log_to_txt">snmp:log_to_txt</a> 
for more info.</p><a name="log_to_io"></a><h3>log_to_io(LogDir) -&gt; ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_io(LogDir, Block | Mibs) -&gt; ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_io(LogDir, Mibs) -&gt; ok | {error, Reason}</h3><h3>log_to_io(LogDir, Mibs, Block | LogName) -&gt;  ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_io(LogDir, Mibs, LogName, Block | LogFile) -&gt;  ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_io(LogDir, Mibs, LogName, LogFile, Block | Start) -&gt;  ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start)  -&gt; ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_io(LogDir, Mibs, LogName, LogFile, Start, Stop)  -&gt; ok | {ok, Cnt} | {error, Reason}</h3><h3>log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start, Stop)  -&gt; ok | {ok, Cnt} | {error, Reason}</h3><p>Convert an Audit Trail Log to text format</p><ul><li><span class="v">LogDir = string()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Block = boolean()</span></li><li><span class="v">LogName = string()</span></li><li><span class="v">LogFile = string()</span></li><li><span class="v">Start = Stop = null | calendar:datetime() | {local_time, calendar:datetime()} | {universal_time, calendar:datetime()} </span></li><li><span class="v">Cnt = {NumOK, NumERR}</span></li><li><span class="v">NumOK = non_neg_integer()</span></li><li><span class="v">NumERR = pos_integer()</span></li><li><span class="v">Reason = disk_log_open_error() | file_open_error() | term()</span></li><li><span class="v">disk_log_open_error() = {LogName, term()}</span></li><li><span class="v">file_open_error() = {OutFile, term()}</span></li></ul><p>Converts an Audit Trail Log to a readable format and 
prints it on stdio. 
<strong>LogName</strong> defaults to "snmpm_log". 
<strong>LogFile</strong> defaults to "snmpm.log".</p><p>The <strong>Block</strong> argument indicates if the log should be blocked
during conversion. This could be usefull when converting large 
logs (when otherwise the log could wrap during conversion). 
Defaults to <strong>true</strong>. </p><p>See <a href="./snmp#log_to_io">snmp:log_to_io</a> 
for more info.</p><a name="change_log_size"></a><h3>change_log_size(NewSize) -&gt; ok | {error, Reason}</h3><p>Change the size of the Audit Trail Log</p><ul><li><span class="v">NewSize = {MaxBytes, MaxFiles}</span></li><li><span class="v">MaxBytes = integer()</span></li><li><span class="v">MaxFiles = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Changes the log size of the Audit Trail Log. The application must 
be configured to use the audit trail log function. Please refer to 
disk_log(3) in Kernel Reference Manual for a description of how to 
change the log size.
</p><p>The change is permanent, as long as the log is not deleted. 
That means, the log size is remembered across reboots.</p><a name="set_log_type"></a><h3>set_log_type(NewType) -&gt; {ok, OldType} | {error, Reason}</h3><p>Change the Audit Trail Log type</p><ul><li><span class="v">NewType = OldType = atl_type()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Changes the run-time Audit Trail log type. </p><p>Note that this has no effect on the application configuration as
defined by configuration files, so a node restart will revert the 
config to whatever is in those files. </p><p>This function is primarily useful in testing/debugging 
scenarios. </p><a name="load_mib"></a><h3>load_mib(Mib) -&gt; ok | {error, Reason}</h3><p>Load a MIB into the manager</p><ul><li><span class="v">Mib = MibName</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Load a <strong>Mib</strong> into the manager. The <strong>MibName</strong> is the 
name of the Mib, including the path to where the compiled mib is 
found.  For example,</p><pre><code class="">
          Dir = code:priv_dir(my_app) ++ "/mibs/",
          snmpm:load_mib(Dir ++ "MY-MIB").
        </code></pre><a name="unload_mib"></a><h3>unload_mib(Mib) -&gt; ok | {error, Reason}</h3><p>Unload a MIB from the manager</p><ul><li><span class="v">Mib = MibName</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Unload a <strong>Mib</strong> from the manager. The <strong>MibName</strong> is the 
name of the Mib, including the path to where the compiled mib is 
found.  For example,</p><pre><code class="">
          Dir = code:priv_dir(my_app) ++ "/mibs/",
          snmpm:unload_mib(Dir ++ "MY-MIB").
        </code></pre><a name="which_mibs"></a><h3>which_mibs() -&gt; Mibs</h3><p>Which mibs are loaded into the manager</p><ul><li><span class="v">Mibs = [{MibName, MibFile}]</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">MibFile = string()</span></li></ul><p>Get a list of all the mib's loaded into the manager.</p><a name="name_to_oid"></a><h3>name_to_oid(Name) -&gt; {ok, Oids} | {error, Reason}</h3><p>Get all the possible oid's for an alias-name</p><ul><li><span class="v">Name = atom()</span></li><li><span class="v">Oids = [oid()]</span></li></ul><p>Transform a alias-name to its oid.</p><p>Note that an alias-name is only unique within the mib, so
when loading several mib's into a manager, there might be
several instances of the same aliasname.</p><a name="oid_to_name"></a><h3>oid_to_name(Oid) -&gt; {ok, Name} | {error, Reason}</h3><p>Get the alias-name of the oid </p><ul><li><span class="v">Oid = oid()</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Transform a oid to its aliasname.</p><a name="oid_to_type"></a><h3>oid_to_type(Oid) -&gt; {ok, Type} | {error, Reason}</h3><p>Get the type of the the oid</p><ul><li><span class="v">Oid = oid()</span></li><li><span class="v">Type = atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retreive the type (asn1 bertype) of an oid.</p><a name="backup"></a><h3>backup(BackupDir) -&gt; ok | {error, Reason}</h3><p>Backup manager data</p><ul><li><span class="v">BackupDir = string()</span></li></ul><p>Backup persistent data handled by the manager. </p><p>BackupDir cannot be identical to DbDir. </p><a name="info"></a><h3>info() -&gt; [{Key, Value}]</h3><p>Return information about the manager</p><ul><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li></ul><p>Returns a list (a dictionary) containing information about
the manager. Information includes statistics counters, 
miscellaneous info about each process (e.g. memory allocation), 
and so on.</p><a name="verbosity"></a><h3>verbosity(Ref, Verbosity) -&gt; void()</h3><p>Assign a new verbosity for the process</p><ul><li><span class="v">Ref = server | config | net_if | note_store | all</span></li><li><span class="v">Verbosity = verbosity()</span></li><li><span class="v">verbosity() = silence | info | log | debug | trace </span></li></ul><p>Sets verbosity for the designated process. For the lowest 
verbosity <strong>silence</strong>, nothing is printed. The higher the
verbosity, the more is printed.</p><a name="format_reason"></a><h3>format_reason(Reason) -&gt; string()</h3><h3>format_reason(Prefix, Reason) -&gt; string()</h3><p>Assign a new verbosity for the process</p><ul><li><span class="v">Reason = term()</span></li><li><span class="v">Prefix = integer() | string()</span></li></ul><p>This utility function is used to create a formatted 
(pretty printable) string of the error reason received
from either:
</p><ul><li> <p>The <strong>Reason</strong> returned value if any of the 
sync/async get/get-next/set/get-bulk
functions returns <strong>{error, Reason}</strong></p> </li><li> <p>The <strong>Reason</strong> parameter in the 
<a href="./snmpm_user#handle_error">handle_error</a> user callback function.</p> </li></ul><p><strong>Prefix</strong> should either be an indention string
(e.g. a list of spaces) or a positive integer (which will be used
to create the indention string of that length).</p><h2>snmpm_conf</h2><p>Utility functions for handling the manager config files.</p><p>The module <strong>snmpm_conf</strong> contains various utility functions to 
used for manipulating (write/append/read) the config files of the
SNMP manager. <a name="manager_entry"></a></p><h2>Functions</h2><h3>manager_entry(Tag, Val) -&gt; manager_entry()</h3><p>Create an manager entry</p><ul><li><span class="v">Tag = address | port | engine_id | max_message_size</span></li><li><span class="v">Val = term()</span></li><li><span class="v">manager_entry() = term()</span></li></ul><p>Create an entry for the manager config file, 
<strong>manager.conf</strong>. </p><p>The type of <strong>Val</strong> depends on the value of <strong>Tag</strong>, 
see 
<a href="./snmp_manager_config_files#manager_information">Manager Information</a> 
for more info. </p><a name="write_manager_config"></a><h3>write_manager_config(Dir, Conf) -&gt; ok</h3><h3>write_manager_config(Dir, Hdr, Conf) -&gt; ok</h3><p>Write the manager config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [manager_entry()]</span></li></ul><p>Write the manager config to the manager config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_manager_config_files#manager_information">Manager Information</a> 
for more info. </p><a name="append_manager_config"></a><h3>append_manager_config(Dir, Conf) -&gt; ok</h3><p>Append the manager config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [manager_entry()]</span></li></ul><p>Append the config to the current manager config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_manager_config_files#manager_information">Manager Information</a> 
for more info. </p><a name="read_manager_config"></a><h3>read_manager_config(Dir) -&gt; Conf</h3><p>Read the manager config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [manager_entry()]</span></li></ul><p>Read the current manager config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_manager_config_files#manager_information">Manager Information</a> 
for more info. </p><a name="users_entry"></a><h3>users_entry(UserId) -&gt; users_entry()</h3><h3>users_entry(UserId, UserMod) -&gt; users_entry()</h3><h3>users_entry(UserId, UserMod, UserData) -&gt; users_entry()</h3><p>Create an users entry</p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">UserMod = atom()</span></li><li><span class="v">UserData = term()</span></li><li><span class="v">standard_entry() = term()</span></li></ul><p>Create an entry for the manager users config file, 
<strong>users.conf</strong>. </p><p><strong>users_entry(UserId)</strong> translates to the following call:
<strong>users_entry(UserId, snmpm_user_default)</strong>. </p><p><strong>users_entry(UserId, UserMod)</strong> translates to the following 
call: <strong>users_entry(UserId, UserMod, undefined)</strong>. </p><p>See 
<a href="./snmp_manager_config_files#users">Users</a> 
for more info. </p><a name="write_users_config"></a><h3>write_users_config(Dir, Conf) -&gt; ok</h3><h3>write_users_config(Dir, Hdr, Conf) -&gt; ok</h3><p>Write the manager users config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [users_entry()]</span></li></ul><p>Write the manager users config to the manager users 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_manager_config_files#users">Users</a> 
for more info. </p><a name="append_users_config"></a><h3>append_users_config(Dir, Conf) -&gt; ok</h3><p>Append the manager users config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [users_entry()]</span></li></ul><p>Append the users config to the current manager users  
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_manager_config_files#users">Users</a> 
for more info. </p><a name="read_users_config"></a><h3>read_users_config(Dir) -&gt; Conf</h3><p>Read the manager users config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [users_entry()]</span></li></ul><p>Read the current manager users config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_manager_config_files#users">Users</a> 
for more info. </p><a name="agents_entry"></a><h3>agents_entry(UserId, TargetName, Comm, Domain, Addr, EngineID, Timeout, MaxMessageSize, Version, SecModel, SecName, SecLevel) -&gt; agents_entry()</h3><p>Create an agents entry</p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = string()</span></li><li><span class="v">Comm = string()</span></li><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddress()</span></li><li><span class="v">EngineID = string()</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">MaxMessageSize = integer()</span></li><li><span class="v">Version = v1 | v2 | v3</span></li><li><span class="v">SecModel = v1 | v2c | usm</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">SecLevel = noAuthNoPriv | authNoPriv | authPriv</span></li><li><span class="v">agents_entry() = term()</span></li></ul><p>Create an entry for the manager agents config file, 
<strong>agents.conf</strong>. </p><p>See 
<a href="./snmp_manager_config_files#agents">Agents</a> 
for more info. </p><a name="write_agents_config"></a><h3>write_agents_config(Dir, Conf) -&gt; ok</h3><h3>write_agents_config(Dir, Hdr, Conf) -&gt; ok</h3><p>Write the manager agents to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [_entry()]</span></li></ul><p>Write the manager agents config to the manager agents 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_manager_config_files#agents">Agents</a> 
for more info. </p><a name="append_agents_config"></a><h3>append_agents_config(Dir, Conf) -&gt; ok</h3><p>Append the manager agents to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [agents_entry()]</span></li></ul><p>Append the agents config to the current manager agents 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_manager_config_files#agents">Agents</a> 
for more info. </p><a name="read_agents_config"></a><h3>read_agents_config(Dir) -&gt; Conf</h3><p>Read the manager agents config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [agents_entry()]</span></li></ul><p>Read the current manager agents config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_manager_config_files#agents">Agents</a> 
for more info. </p><a name="usm_entry"></a><h3>usm_entry(EngineID, UserName, AuthP, AuthKey, PrivP, PrivKey) -&gt; usm_entry()</h3><h3>usm_entry(EngineID, UserName, SecName, AuthP, AuthKey, PrivP, PrivKey) -&gt; usm_entry()</h3><p>Create an usm entry</p><ul><li><span class="v">EngineID = string()</span></li><li><span class="v">UserName = string()</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">AuthP = usmNoAuthProtocol | usmHMACMD5AuthProtocol | usmHMACSHAAuthProtocol</span></li><li><span class="v">AuthKey = [integer()]</span></li><li><span class="v">PrivP = usmNoPrivProtocol | usmDESPrivProtocol | usmAesCfb128Protocol</span></li><li><span class="v">PrivKey = [integer()]</span></li><li><span class="v">usm_entry() = term()</span></li></ul><p>Create an entry for the agent community config file, 
<strong>community.conf</strong>. </p><p>See 
<a href="./snmp_manager_config_files#usm">Security data for USM</a> 
for more info. </p><a name="write_usm_config"></a><h3>write_usm_config(Dir, Conf) -&gt; ok</h3><h3>write_usm_config(Dir, Hdr, Conf) -&gt; ok</h3><p>Write the manager usm config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [usm_entry()]</span></li></ul><p>Write the manager usm config to the manager usm 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_manager_config_files#usm">Security data for USM</a> 
for more info. </p><a name="append_usm_config"></a><h3>append_usm_config(Dir, Conf) -&gt; ok</h3><p>Append the manager usm  config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [usm_entry()]</span></li></ul><p>Append the usm config to the current manager usm 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_manager_config_files#usm">Security data for USM</a> 
for more info. </p><a name="read_usm_config"></a><h3>read_usm_config(Dir) -&gt; Conf</h3><p>Read the manager usm config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [usm_entry()]</span></li></ul><p>Read the current manager usm config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_manager_config_files#usm">Security data for USM</a> 
for more info. </p><a name="end"></a><h2>snmpm_mpd</h2><p>Message Processing and Dispatch module for the SNMP manager</p><p>The module <strong>snmpm_mpd</strong> implements the version independent
Message Processing and Dispatch functionality in SNMP for the manager. 
It is supposed to be used from a Network Interface process 
(<a href="snmp_manager_netif">Definition of Manager Net if</a>).
Legacy API function <strong>process_msg/7</strong> that has got separate
<strong>IpAddr</strong> and <strong>PortNumber</strong> arguments still works as before
for backwards compatibility reasons.</p><h2>Functions</h2><h3>init_mpd(Vsns) -&gt; mpd_state()</h3><p>Initialize the MPD module</p><ul><li><span class="v">Vsns = [Vsn]</span></li><li><span class="v">Vsn = v1 | v2 | v3</span></li></ul><p>This function can be called from the net_if process at start-up.
The options list defines which versions to use.
</p><p>It also initializes some SNMP counters.
<a name="process_msg"></a>
</p><h3>process_msg(Msg, Domain, Addr, State, NoteStore, Logger) -&gt; {ok, Vsn, Pdu, PduMS, MsgData} | {discarded, Reason}</h3><p>Process a message received from the network</p><ul><li><span class="v">Msg = binary()</span></li><li><span class="v">Domain = transportDomainUdpIpv4 | transportDomainUdpIpv6</span></li><li><span class="v">Addr = {} </span></li><li><span class="v">State = mpd_state()</span></li><li><span class="v">NoteStore = pid()</span></li><li><span class="v">Logger = function()</span></li><li><span class="v">Vsn = 'version-1' | 'version-2' | 'version-3'</span></li><li><span class="v">Pdu = #pdu</span></li><li><span class="v">PduMs = integer()</span></li><li><span class="v">MsgData = term()</span></li></ul><p>Processes an incoming message. Performs authentication and 
decryption as necessary. The return values should be passed the
manager server.
</p><p><strong>NoteStore</strong> is the <strong>pid()</strong> of the note-store process.</p><p><strong>Logger</strong> is the function used for audit trail logging.
</p><p>In the case when the pdu type is <strong>report</strong>, <strong>MsgData</strong> is 
either <strong>ok</strong> or <strong>{error, ReqId, Reason}</strong>.
</p><h3>generate_msg(Vsn, NoteStore, Pdu, MsgData, Logger) -&gt; {ok, Packet} | {discarded, Reason}</h3><p>Generate a request message to be sent to the network</p><ul><li><span class="v">Vsn = 'version-1' | 'version-2' | 'version-3'</span></li><li><span class="v">NoteStore = pid()</span></li><li><span class="v">Pdu = #pdu</span></li><li><span class="v">MsgData = term()</span></li><li><span class="v">Logger = function()</span></li><li><span class="v">Packet = binary()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Generates a possibly encrypted packet to be sent to the network.
</p><p><strong>NoteStore</strong> is the <strong>pid()</strong> of the note-store process.
</p><p><strong>MsgData</strong> is the message specific data used in the SNMP 
message. In SNMPv1 and SNMPv2c, this message data is the community 
string. In SNMPv3, it is the context information.
</p><p><strong>Logger</strong> is the function used for audit trail logging.
</p><h3>generate_response_msg(Vsn, Pdu, MsgData, Logger) -&gt; {ok, Packet} | {discarded, Reason}</h3><p>Generate a response packet to be sent to the network</p><ul><li><span class="v">Vsn = 'version-1' | 'version-2' | 'version-3'</span></li><li><span class="v">Pdu = #pdu</span></li><li><span class="v">MsgData = term()</span></li><li><span class="v">Logger = function()</span></li><li><span class="v">Packet = binary()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Generates a possibly encrypted response packet to be sent to the
network.
</p><p><strong>MsgData</strong> is the message specific data used in the SNMP 
message. This value is received from the 
<a href="./snmpm_mpd#process_msg">process_msg</a> 
function.
</p><h2>snmpm_network_interface</h2><p>Behaviour module for the SNMP manager network interface.</p><p>This module defines the behaviour of the manager network
interface. A <strong>snmpm_network_interface</strong> compliant module 
must export the following functions: <ul><li> <p><a href="#start_link">start_link/2</a></p> </li><li> <p><a href="#stop">stop/1</a></p> </li><li> <p><a href="#send_pdu">send_pdu/7</a></p> </li><li> <p><a href="#inform_response">inform_response/4</a></p> </li><li> <p><a href="#note_store">note_store/2</a></p> </li><li> <p><a href="#info">info/1</a></p> </li><li> <p><a href="#get_log_type">get_log_type/1</a></p> </li><li> <p><a href="#set_log_type">set_log_type/2</a></p> </li><li> <p><a href="#verbosity">verbosity/2</a></p> </li></ul>The semantics of them and their exact signatures are explained
below. Legacy API function <strong>send_pdu/7</strong> that has got separate
<strong>IpAddr</strong> and <strong>PortNumber</strong> arguments still works as before
for backwards compatibility reasons.<a name="start_link"></a></p><h2>Functions</h2><h3>start_link(Server, NoteStore) -&gt; {ok, Pid} | {error, Reason}</h3><p>Start-link the network interface process</p><ul><li><span class="v">Server    = pid()</span></li><li><span class="v">NoteStore = pid()</span></li></ul><p>Start-link the network interface process.</p><p><strong>Server</strong> is the pid of the managing process.</p><p><strong>NoteStore</strong> is the pid of the note-store process.</p><a name="stop"></a><h3>stop(Pid) -&gt; void()</h3><p>Stop the network interface process</p><ul><li><span class="v">Pid = pid()</span></li></ul><p>Stop the network interface process.</p><a name="send_pdu"></a><h3>send_pdu(Pid, Pdu, Vsn, MsgData, Domain, Addr, ExtraInfo) -&gt; void()</h3><p>Request the network interface process to send this pdu</p><ul><li><span class="v">Pid = pid()</span></li><li><span class="v">Pdu = pdu()</span></li><li><span class="v">Vsn = 'version-1' | 'version-2' | 'version-3'</span></li><li><span class="v">MsgData = term()</span></li><li><span class="v">Domain = transportDomainUdpIpv4 | transportDomainUdpIpv6</span></li><li><span class="v">Addr = {} </span></li><li><span class="v">ExtraInfo = term()</span></li></ul><p>Request the network interface process (<strong>Pid</strong>) to send
this pdu (<strong>Pdu</strong>).</p><p><strong>ExtraInfo</strong> is some opaque data that is passed to the
net-if process. It originates from the <strong>ExtraInfo</strong>
parameter in the calls to the 
<a href="./snmpm#sync_get">synchronous get-request</a>, 
<a href="./snmpm#async_get">asynchronous get-request</a>,
<a href="./snmpm#sync_get_next">synchronous get-next-request</a>, 
<a href="./snmpm#async_get_next">asynchronous get-next-request</a>,
<a href="./snmpm#sync_set">synchronous set-request</a>
and 
<a href="./snmpm#async_set">asynchronous set-request</a>
functions. 
Whether the net-if process chooses
to use this is implementation dependent. The net-if process
included in this application ignores it. </p><a name="inform_response"></a><h3>inform_response(Pid, Ref, Addr, Port) -&gt; void()</h3><p>Send the inform-request ack</p><ul><li><span class="v">Pid = pid()</span></li><li><span class="v">Ref = term()</span></li><li><span class="v">Addr = address()</span></li><li><span class="v">Port = integer()</span></li></ul><p>Instruct the network interface process to send the response
(acknowledgment) to an inform-request.</p><p><strong>Ref</strong> is something that can be used to identify the 
inform-request, e.g. request-id of the inform-request.</p><p><strong>Addr</strong> and <strong>Port</strong> identifies the agent, from 
which the inform-request originated.</p><a name="note_store"></a><h3>note_store(Pid, NoteStore) -&gt; void()</h3><p>Change the verbosity of the network interface process</p><ul><li><span class="v">Pid       = pid()</span></li><li><span class="v">NoteStore = pid()</span></li></ul><p>Change the pid of the note-store process.
This is used when the server re-starts the note_store 
(e.g. after a crach).</p><a name="info"></a><h3>info(Pid) -&gt; [{Key, Value}]</h3><p>Return information about the running network interface process</p><ul><li><span class="v">Pid = pid()</span></li></ul><p>The info returned is basically up to the implementer to decide. 
The implementation provided by this application provides info about 
memory allocation and various socket information.</p><p>The info returned by this function is returned together with other
info collected by the manager when the
<a href="./snmpm#info">info</a> function is called 
(tagged with the key <strong>net_if</strong>).</p><a name="verbosity"></a><h3>verbosity(Pid, Verbosity) -&gt; void()</h3><p>Change the verbosity of the network interface process</p><ul><li><span class="v">Pid       = pid()</span></li><li><span class="v">Verbosity = verbosity()</span></li></ul><p>Change the verbosity of the network interface process.</p><a name="get_log_type"></a><h3>get_log_type(Pid) -&gt; {ok, LogType} | {error, Reason}</h3><p>Get the Audit Trail Log type</p><ul><li><span class="v">Pid     = pid()</span></li><li><span class="v">LogType = atl_type()</span></li><li><span class="v">Reason  = term()</span></li></ul><p>The Audit Trail Log is managed by the network interface process.
So, it is this process that has to return the actual log-type. </p><a name="set_log_type"></a><h3>set_log_type(Pid, NewType) -&gt; {ok, OldType} | {error, Reason}</h3><p>Change the Audit Trail Log type</p><ul><li><span class="v">Pid     = pid()</span></li><li><span class="v">NewType = OldType = atl_type()</span></li><li><span class="v">Reason  = term()</span></li></ul><p>The Audit Trail Log is managed by the network interface process.
So, it is this process that has to do the actual changing of the
type. </p><p>See
<a href="./snmpm#set_log_type">set_log_type</a>
for more info. </p><h2>snmpm_user</h2><p>Behaviour module for the SNMP manager user.</p><p>This module defines the behaviour of the manager user. 
A <strong>snmpm_user</strong> compliant module 
must export the following functions: <ul><li> <p>handle_error/3</p> </li><li> <p>handle_agent/4</p> </li><li> <p>handle_pdu/4</p> </li><li> <p>handle_trap/3</p> </li><li> <p>handle_inform/3</p> </li><li> <p>handle_report/3</p> </li><li> <p>handle_invalid_result/2</p> </li></ul>The semantics of them and their exact signatures are explained
below. Some of the function has no defined return value (<strong>void()</strong>), 
they can of course return anything. But the functions that do have
specified return value(s) <em>must</em> adhere to this. None of the 
functions can use exit of throw to return. If the manager is not configured to use any particular
transport domain, the behaviour <strong>handle_agent/4</strong>
will for backwards copmpatibility reasons be called with the old
<strong>IpAddr</strong> and <strong>PortNumber</strong> arguments<a name="types"></a></p><h3>DATA TYPES</h3><pre><code class="">
snmp_gen_info() = {ErrorStatus :: atom(), 
                   ErrorIndex  :: pos_integer(), 
                   Varbinds    :: [snmp:varbind()]}
snmp_v1_trap_info() :: {Enteprise :: snmp:oid(), 
                        Generic   :: integer(), 
                        Spec      :: integer(), 
                        Timestamp :: integer(), 
                        Varbinds  :: [snmp:varbind()]}
    </code></pre><a name="handle_error"></a><h2>Functions</h2><h3>handle_error(ReqId, Reason, UserData) -&gt; void()</h3><p>Handle error</p><ul><li><span class="v">ReqId = integer()</span></li><li><span class="v">Reason = {unexpected_pdu, SnmpInfo} | {invalid_sec_info, SecInfo, SnmpInfo} | {empty_message, Addr, Port} | term()</span></li><li><span class="v">SnmpInfo = snmp_gen_info()</span></li><li><span class="v">SecInfo = term()</span></li><li><span class="v">Addr = ip_address()</span></li><li><span class="v">Port = integer()</span></li><li><span class="v">UserData = term()</span></li></ul><p>This function is called when the manager needs to
communicate an "asynchronous" error to the user:
e.g. failure to send an asynchronous message (i.e. encoding
error), a received message was discarded due to security
error, the manager failed to generate a response message to
a received inform-request, or when receiving an unexpected
PDU from an agent (could be an expired async request). </p><p>If <strong>ReqId</strong> is less then 0, it means that this
information was not available to the manager (that info was
never retrieved before the message was discarded). </p><p>For <strong>SnmpInfo</strong> see handle_agent below.</p><a name="handle_agent"></a><h3>handle_agent(Domain, Addr, Type, SnmpInfo, UserData) -&gt; Reply</h3><p>Handle agent</p><ul><li><span class="v">Domain = transportDomainUdpIpv4 | transportDomainUdpIpv6</span></li><li><span class="v">Addr = {} </span></li><li><span class="v">Type = pdu | trap | report | inform</span></li><li><span class="v">SnmpInfo = SnmpPduInfo | SnmpTrapInfo | SnmpReportInfo | SnmpInformInfo</span></li><li><span class="v">SnmpPduInfo = snmp_gen_info()</span></li><li><span class="v">SnmpTrapInfo = snmp_v1_trap_info()</span></li><li><span class="v">SnmpReportInfo = snmp_gen_info()</span></li><li><span class="v">SnmpInformInfo = snmp_gen_info()</span></li><li><span class="v">UserData = term()</span></li><li><span class="v">Reply = ignore | {register, UserId, TargetName, AgentConfig}</span></li><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">AgentConfig = [agent_config()]</span></li></ul><p>This function is called when a message is received from an 
unknown agent.</p><p>Note that this will always be the default user that is called.</p><p>For more info about the <strong>agent_config()</strong>, see 
<a href="./snmpm#register_agent">register_agent</a>.</p><p>The arguments <strong>Type</strong> and <strong>SnmpInfo</strong> relates in the 
following way: </p><ul><li> <p><strong>pdu</strong> - <strong>SnmpPduInfo</strong> 
(see <a href="#handle_pdu">handle_pdu</a>
for more info).</p> </li><li> <p><strong>trap</strong> - <strong>SnmpTrapInfo</strong> 
(see <a href="#handle_trap">handle_trap</a>
for more info).</p> </li><li> <p><strong>report</strong> - <strong>SnmpReportInfo</strong> 
(see <a href="#handle_report">handle_report</a>
for more info).</p> </li><li> <p><strong>inform</strong> - <strong>SnmpInformInfo</strong> 
(see <a href="#handle_inform">handle_inform</a>
for more info).</p> </li></ul><p>The only user which would return 
<strong>{register, UserId, TargetName, AgentConfig}</strong> is the 
<em>default user</em>.</p><a name="handle_pdu"></a><h3>handle_pdu(TargetName, ReqId, SnmpPduInfo, UserData) -&gt; void()</h3><p>Handle the reply to an asynchronous request</p><ul><li><span class="v">TargetName = target_name()</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">SnmpPduInfo = snmp_gen_info()</span></li><li><span class="v">UserData = term()</span></li></ul><p>Handle the reply to an asynchronous request, such as 
<a href="./snmpm#async_get">async_get</a>, 
<a href="./snmpm#async_get_next">async_get_next</a> or 
<a href="./snmpm#async_set">async_set</a>.</p><p>It could also be a late reply to a synchronous request.</p><p><strong>ReqId</strong> is returned by the asynchronous request function.</p><a name="handle_trap"></a><h3>handle_trap(TargetName, SnmpTrapInfo, UserData) -&gt; Reply</h3><p>Handle a trap/notification message</p><ul><li><span class="v">TargetName = TargetName2 = target_name()</span></li><li><span class="v">SnmpTrapInfo = snmp_v1_trap_info() | snmp_gen_info()</span></li><li><span class="v">UserData = term()</span></li><li><span class="v">Reply = ignore | unregister | {register, UserId, TargetName2, AgentConfig}</span></li><li><span class="v">UserId = term()</span></li><li><span class="v">AgentConfig = [agent_config()]</span></li></ul><p>Handle a trap/notification message from an agent.</p><p>For more info about the <strong>agent_config()</strong>, see 
<a href="./snmpm#register_agent">register_agent</a></p><p>The only user which would return 
<strong>{register, UserId, TargetName2, agent_info()}</strong> is the 
<em>default user</em>.</p><a name="handle_inform"></a><h3>handle_inform(TargetName, SnmpInformInfo, UserData) -&gt; Reply</h3><p>Handle a inform message</p><ul><li><span class="v">TargetName = TargetName2 = target_name()</span></li><li><span class="v">SnmpInformInfo = snmp_gen_info()</span></li><li><span class="v">UserData = term()</span></li><li><span class="v">Reply = ignore | no_reply | unregister | {register, UserId, TargetName2, AgentConfig}</span></li><li><span class="v">UserId = term()</span></li><li><span class="v">AgentConfig = [agent_config()]</span></li></ul><p>Handle a inform message.</p><p>For more info about the <strong>agent_config()</strong>, see 
<a href="./snmpm#register_agent">register_agent</a></p><p>The only user which would return 
<strong>{register, UserId, TargetName2, AgentConfig}</strong> is the 
<em>default user</em>.</p><p>If the 
<a href="snmp_app">inform request behaviour</a> 
configuration option is set to <strong>user</strong> or 
<strong>{user, integer()}</strong>, the response (acknowledgment) to this 
inform-request will be sent when this function returns.</p><a name="handle_report"></a><h3>handle_report(TargetName, SnmpReportInfo, UserData) -&gt; Reply</h3><p>Handle a report message</p><ul><li><span class="v">TargetName = TargetName2 = target_name()</span></li><li><span class="v">Addr = ip_address()</span></li><li><span class="v">Port = integer()</span></li><li><span class="v">SnmpReportInfo = snmp_gen_info()</span></li><li><span class="v">UserData = term()</span></li><li><span class="v">Reply = ignore | unregister | {register, UserId, TargetName2, AgentConfig}</span></li><li><span class="v">UserId = term()</span></li><li><span class="v">AgentConfig = [agent_config()]</span></li></ul><p>Handle a report message.</p><p>For more info about the <strong>agent_config()</strong>, see 
<a href="./snmpm#register_agent">register_agent</a></p><p>The only user which would return 
<strong>{register, UserId, TargetName2, AgentConfig}</strong> is the 
<em>default user</em>.</p><a name="handle_invalid_result"></a><h3>handle_invalid_result(IN, OUT) -&gt; void()</h3><p>Handle a report message</p><ul><li><span class="v">IN = {Func, Args}</span></li><li><span class="v">Func = atom()</span></li><li><span class="v">Args = list()</span></li><li><span class="v">OUT = {crash, CrashInfo} | {result, InvalidResult}</span></li><li><span class="v">CrashInfo = {ErrorType, Error, Stacktrace}</span></li><li><span class="v">ErrorType = atom()</span></li><li><span class="v">Error = term()</span></li><li><span class="v">Stacktrace = list()</span></li><li><span class="v">InvalidResult = term()</span></li></ul><p>If <em>any</em> of the <em>other</em> callback functions crashes 
(exit, throw or a plain crash) or return an invalid result (if a valid 
return has been specified), this function is called. 
The purpose is to allow the user handle this 
error (for instance to issue an error report).</p><p><strong>IN</strong> reprecents the function called (and its arguments). 
<strong>OUT</strong> represents the unexpected/invalid result. </p><h2>snmpm_network_interface_filter</h2><p>Behaviour module for the SNMP manager network-interface filter.</p><p>This module defines the behaviour of the manager network interface
filter. A <strong>snmpm_network_interface_filter</strong> compliant module 
must export the following functions: <ul><li> <p><a href="#accept_recv">accept_recv/2</a></p> </li><li> <p><a href="#accept_send">accept_send/2</a></p> </li><li> <p><a href="#accept_recv_pdu">accept_recv_pdu/3</a></p> </li><li> <p><a href="#accept_send_pdu">accept_send_pdu/2</a></p> </li></ul>The semantics of them and their exact signatures are explained
below. The purpose of the network interface filter is to allow for filtering
of messages (accept or reject) receive and send. This is done 
on two levels: <ul><li> <p>The first level is at the UDP entry / exit point, i.e. 
immediately after the receipt of the message, before any message 
processing is done (accept_recv) and 
immediately before sending the message, after all message 
processing is done (accept_send).</p> </li><li> <p>The second level is at the MPD entry / exit point, i.e.
immediately after the basic message processing (accept_recv_pdu) / 
immediately before the basic message processing (accept_send_pdu).</p> </li></ul>Note that the network interface filter is something which is used 
by the network interface implementation provided by the application 
(<strong>snmpm_net_if</strong> and <strong>snmpm_net_if_mt</strong>). 
The default filter accepts all messages.A network interface filter can e.g. be used during testing or for load 
regulation. Legacy network interface filter modules used arguments on the form
<strong>(IpAddr, PortNumber,...)</strong> instead of
<strong>(Domain, Addr, ...)</strong>, and if the SNMP manager is run without
changing the configuration to use transport domains
the network interface filter will still get
the old arguments and work as before.</p><h3>DATA TYPES</h3><pre><code class="">
port() = integer() &gt; 0
pdu_type() = 'get-request' | 'get-next-request' | 'get-response' | 
             'set-request' | trap | 'get-bulk-request' | 'inform-request' | 
             report | trappdu
    </code></pre><p>See also the <a href="./snmpa_conf#types"> data types in </a>.</p><a name="accept_recv"></a><h2>Functions</h2><h3>accept_recv(Domain, Addr) -&gt; boolean()</h3><p>Shall the received message be accepted</p><ul><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddressWithPort()</span></li></ul><p>Called at the reception of a message (before <em>any</em> processing 
has been done).</p><p>For the message to be rejected, the function <em>must</em> return
<em>false</em>. </p><a name="accept_send"></a><h3>accept_send(Domain, Addr) -&gt; boolean()</h3><p>Shall the message be sent</p><ul><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddressWithPort()</span></li></ul><p>Called before the sending of a message (after <em>all</em> processing 
has been done).</p><p>For the message to be rejected, the function <em>must</em> return
<em>false</em>. </p><a name="accept_recv_pdu"></a><h3>accept_recv_pdu(Domain, Addr, PduType) -&gt; boolean()</h3><p>Shall the received pdu be accepted</p><ul><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddressWithPort()</span></li><li><span class="v">PduType = pdu_type()</span></li></ul><p>Called after the basic message processing (MPD) has been done, 
but before the pdu is handed over to the server for primary 
processing.</p><p>For the pdu to be rejected, the function <em>must</em> return
<em>false</em>. </p><a name="accept_send_pdu"></a><h3>accept_send_pdu(Domain, Addr, PduType) -&gt; boolean()</h3><p>Shall the pdu be sent</p><ul><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddressWithPort()</span></li><li><span class="v">PduType = pdu_type() &gt; 0</span></li></ul><p>Called before the basic message processing (MPD) is done, 
when a pdu has been received from the master-agent.</p><p>For the message to be rejected, the function <em>must</em> return 
<em>false</em>. </p></body></html>