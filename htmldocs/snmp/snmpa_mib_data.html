<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>snmpa_mib_data</h1><h1>snmpa_mib_data</h1><p>Behaviour module for the SNMP agent mib-server 
  data module.</p><p>This module defines the behaviour of the SNMP agent mib-server 
data module. A <strong>snmpa_mib_data</strong> compliant module 
must export the following functions: <ul><li> <a href="#new">new/1</a> </li><li> <a href="#close">close/1</a> </li><li> <a href="#sync">sync/1</a> </li><li> <a href="#load_mib">load_mib/4</a> </li><li> <a href="#unload_mib">unload_mib/4</a> </li><li> <a href="#lookup">lookup/2</a> </li><li> <a href="#next">next/3</a> </li><li> <a href="#register_subagent">register_subagent/3</a> </li><li> <a href="#unregister_subagent">unregister_subagent/2</a> </li><li> <a href="#which_mib">which_mib/2</a> </li><li> <a href="#which_mibs">which_mibs/1</a> </li><li> <a href="#whereis_mib">whereis_mib/2</a> </li><li> <a href="#dump">dump/2</a> </li><li> <a href="#info">info/1</a> </li><li> <a href="#backup">backup/2</a> </li><li> <a href="#code_change">code_change/4</a> </li></ul>The semantics of them and their exact signatures are 
explained below. Note that the data extracted from the imported (loaded) 
mibs are stored partly by the mib-server and partly by the 
symbolic-store server. See the default mib-server data 
module, <strong>snmpa_mib_data_tttn</strong> for details. </p><h2>CALLBACK FUNCTIONS</h2><p>The following functions must be exported from a 
<strong>mib-server</strong> data callback module: </p><a name="new"></a><h1>Functions</h1><h2>Module:new(Storage) -&gt; State</h2><p>Create new (mib-server) data instance</p><ul><li><span class="v">Storage = mib_storage()</span></li><li><span class="v">State = term()</span></li></ul><p>Create a new mib-server data instance. </p><a name="close"></a><h2>Module:close(State) -&gt; void()</h2><p>Close the mib-server data instance</p><ul><li><span class="v">State = term()</span></li></ul><p>Close the mib-storage.</p><a name="sync"></a><h2>Module:sync(State) -&gt; void()</h2><p>Synchronize to disc</p><ul><li><span class="v">State = term()</span></li></ul><p>Synchronize (write to disc, if possible) the mib-server data. 
This depends on the <strong>mib_storage</strong> option, and will only have 
an effect if the mib-storage option has an actual disc component 
(such as dets, or ets with a file). </p><a name="load_mib"></a><h2>Module:load_mib(State, Filename, MeOverride, TeOverride) -&gt; {ok, NewState} | {error, Reason}</h2><p>Load a mib into the mib-server</p><ul><li><span class="v">State = NewState = term()</span></li><li><span class="v">Filename = filename()</span></li><li><span class="v">MeOverride = boolean()</span></li><li><span class="v">TeOverride = boolean()</span></li><li><span class="v">Reason = already_loaded | term()</span></li></ul><p>Load the mib specified by the <strong>Filename</strong> argument 
into the mib-server. 
The <strong>MeOverride</strong> and <strong>TeOverride</strong> arguments 
specifies how the mib-server shall handle duplicate mib- and trap-
entries. </p><a name="unload_mib"></a><h2>Module:unload_mib(State, Filename) -&gt; {ok, NewState} | {error, Reason}</h2><p>Unload mib from the mib-server</p><ul><li><span class="v">State = NewState = term()</span></li><li><span class="v">Filename = filename()</span></li><li><span class="v">Reason = not_loaded | term()</span></li></ul><p>Unload the mib specified by the <strong>Filename</strong> argument 
from the mib-server. </p><a name="lookup"></a><h2>Module:lookup(State, Oid) -&gt; Reply</h2><p>Find the mib-entry corresponding to the Oid</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = {variable, ME} | {table_column, ME, TEOid} | {subagent, SAPid, SAOid} | {false, Reason}</span></li><li><span class="v">Oid = TEOid = SAOid = oid()</span></li><li><span class="v">SAPid = pid()</span></li><li><span class="v">ME = me()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Find the mib-entry corresponding to the <strong>Oid</strong>. 
If it is a variable, the <strong>Oid</strong> must be 
&lt;Oid for var&gt;.0 
and if it is a table, <strong>Oid</strong> must be 
&lt;table&gt;.&lt;entry&gt;.&lt;col&gt;.&lt;any&gt;.</p><a name="next"></a><h2>Module:next(State, Oid, MibView) -&gt; Reply</h2><p>Finds the lexicographically next oid</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = false | endOfTable | {subagent, SAPid, SAOid} | {variable, ME, VarOid} | {table, TableOid, TableRestOid, ME}</span></li><li><span class="v">Oid = SAOid = VarOid = TableOid = TableRestOid = oid()</span></li><li><span class="v">SAPid = pid()</span></li><li><span class="v">ME = me()</span></li></ul><p>Finds the lexicographically next oid. </p><a name="register_subagent"></a><h2>Module:register_subagent(State, Oid, Pid) -&gt; Reply</h2><p>Register the subagent</p><ul><li><span class="v">State = NewState = term()</span></li><li><span class="v">Reply = {ok, NewState} | {error, Reason}</span></li><li><span class="v">Oid = oid()</span></li><li><span class="v">Pid = pid()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Register the subagent, process, 
handling part of the mib-tree. </p><a name="unregister_subagent"></a><h2>Module:unregister_subagent(State, PidOrOid) -&gt; Reply</h2><p>Unregister the subagent</p><ul><li><span class="v">State = NewState = term()</span></li><li><span class="v">Reply = {ok, NewState} | {ok, NewState, Pid} | {error, Reason}</span></li><li><span class="v">PidOrOid = pid() | oid()</span></li><li><span class="v">Pid = pid()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Unregister the subagent, handling part of the mib-tree, 
as specified by the <strong>oid()</strong> or <strong>pid()</strong> 
(<strong>PidOrOid</strong>). </p><p>When unregister the subagent using an <strong>oid()</strong>, the <strong>pid()</strong> 
of the process handling the sub-tree is also returned. </p><a name="dump"></a><h2>Module:dump(State, Destination) -&gt; Reply</h2><p>Unregister the subagent</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = ok | {error, Reason}</span></li><li><span class="v">Destination = io | filename()</span></li><li><span class="v">Pid = pid()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Dump the mib-server data to <strong>stdio</strong> (Destination = <strong>io</strong>) or
the specified file. </p><a name="which_mib"></a><h2>Module:which_mib(State, Oid) -&gt; Reply</h2><p>Retrieve the mib file for an oid()</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = {ok, MibFile} | {error, Reason}</span></li><li><span class="v">Oid = oid()</span></li><li><span class="v">MibFile = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retrieve the mib-file to which an given <strong>oid()</strong> belongs. </p><a name="which_mibs"></a><h2>Module:which_mibs(State) -&gt; Reply</h2><p>Retrieve all loaded mib files</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = [{MibName, Filename}]</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">Filename = string()</span></li></ul><p>Retrieve all loaded mib-files. </p><a name="whereis_mib"></a><h2>Module:whereis_mib(State, MibName) -&gt; Reply</h2><p>Retrieve the mib file for the mib</p><ul><li><span class="v">State = term()</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">Reply = {ok, Filename} | {error, Reason}</span></li><li><span class="v">Filename = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retrieve the mib file for the mib. </p><a name="info"></a><h2>Module:info(State) -&gt; Reply</h2><p>Retrieve misc info for the mib data</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = {ok, Filename} | {error, Reason}</span></li><li><span class="v">Filename = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retrieve misc info for the mib data. </p><p>This is a utility function used to inspect, for instance, 
memory usage, in a simple way. </p><a name="backup"></a><h2>Module:backup(State, BackupDir) -&gt; Reply</h2><p>Perform a backup of the mib-server data</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = ok | {error, Reason}</span></li><li><span class="v">BackupDir = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Perform a backup of the mib-server data. </p><p>Note that its implementation dependant (and also 
dependent on mib-storage is used) if a backup is possible. </p><a name="code_change"></a><h2>Module:code_change(Destination, Vsn, Extra, State) -&gt; NewState</h2><p>Perform a code-change</p><ul><li><span class="v">Destination = up | down</span></li><li><span class="v">Vsn = term()</span></li><li><span class="v">Extra = term()</span></li><li><span class="v">State = NewState = term()</span></li></ul><p>Perform a code-change (upgrade or downgrade). </p><p>See 
<a href="./gen_server">gen_server</a>
for more info regarding the <strong>Vsn</strong> and <strong>Extra</strong> arguments. </p></body></html>