<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Simple Network Management Protocol (SNMP)</h1><h1>Simple Network Management Protocol (SNMP)</h1><p>A multilingual Simple Network Management Protocol application,
featuring an Extensible Agent, a simple manager and a MIB 
compiler and facilities for implementing SNMP MIBs etc.</p><p>The SNMP development toolkit contains the following parts:
</p><ul><li>An Extensible multi-lingual SNMP agent, which understands SNMPv1 (RFC1157), SNMPv2c (RFC1901, 1905, 1906 and 1907), SNMPv3 (RFC2271, 2272, 2273, 2274 and 2275), or any combination of these protocols. </li><li>A multi-lingual SNMP manager. </li><li>A MIB compiler, which understands SMIv1 (RFC1155, 1212, and 1215) and SMIv2 (RFC1902, 1903, and 1904). </li></ul><p>The SNMP development tool provides an environment for
rapid agent/manager prototyping and construction. With the 
following information provided, this tool is used to set up a 
running multi-lingual SNMP agent/manager:
</p><ul><li>a description of a Management Information Base (MIB) in Abstract Syntax Notation One (ASN.1) </li><li>instrumentation functions for the managed objects in the MIB, written in Erlang. </li></ul><p>The advantage of using an extensible (agent/manager) toolkit is to 
remove details such as type-checking, access rights, Protocol Data Unit
(PDU), encoding, decoding, and trap distribution from the
programmer, who only has to write the instrumentation functions,
which implement the MIBs. The <strong>get-next</strong> function only
has to be implemented for tables, and not for every variable in
the global naming tree. This information can be deduced from the
ASN.1 file.
</p><h4>Scope and Purpose</h4><p>This manual describes the SNMP development tool,
as a component of the Erlang/Open Telecom Platform development
environment. It is assumed that the reader is familiar with the
Erlang Development Environment, which is described in a separate
User's Guide.</p><h4>Prerequisites</h4><p>The following prerequisites
is required for understanding the material in the SNMP
User's Guide:
</p><ul><li>the basics of the Simple Network Management Protocol version 1 (SNMPv1) </li><li>the basics of the community-based Simple Network Management Protocol version 2 (SNMPv2c) </li><li>the basics of the Simple Network Management Protocol version 3 (SNMPv3) </li><li>the knowledge of defining MIBs using SMIv1 and SMIv2 </li><li>familiarity with the Erlang system and Erlang programming </li></ul><p>The tool requires Erlang release 4.7 or later.
</p><h4>Definitions</h4><p>The following definitions are used in the SNMP User's Guide.
</p><dl><dt>MIB</dt><dd>The conceptual repository for management information is called the Management Information Base (MIB). It  does not hold any data, merely a definition of what data can be accessed.  A definition of an MIB is a description of a collection of managed objects. </dd><dt>SMI</dt><dd>The MIB is specified in an adapted subset of the Abstract Syntax Notation One (ASN.1) language.  This adapted subset is called the Structure of Management Information (SMI). </dd><dt>ASN.1</dt><dd>ASN.1 is used in two different ways in SNMP.  The SMI is based on ASN.1, and the messages in the protocol are defined by using ASN.1. </dd><dt>Managed object</dt><dd> <p>A resource to be managed is represented by a managed
object, which resides in the MIB. In an SNMP MIB, the managed
objects are either:</p> <ul><li><em>scalar variables</em>, which have only one instance per context. They have single values, not multiple values like vectors or structures. </li><li><em>tables</em>, which can grow dynamically. </li><li>a <em>table element</em>, which is a special type of scalar variable.</li></ul> </dd><dt>Operations</dt><dd>SNMP relies on the three basic operations: get (object), set (object, value) and get-next (object). </dd><dt>Instrumentation function</dt><dd>An instrumentation function is associated with each managed object. This is the function, which actually implements the operations and will be called by the agent when it receives a request from the management station.</dd><dt>Manager</dt><dd>A manager generates commands and receives notifications  from agents. There usually are only a few managers in a system.</dd><dt>Agent</dt><dd>An agent responds to commands from the manager, and sends notification to the manager. There are potentially many agents  in a system.</dd></dl><h4>About This Manual</h4><p>In addition to this introductory chapter, the SNMP User's Guide
contains the following chapters:
</p><ul><li>Chapter 2: "Functional Description" describes the features and operation of the SNMP development toolkit. It includes topics on Sub-agents and MIB loading, Internal MIBs, and Traps. </li><li>Chapter 3: "The MIB Compiler" describes the features and the operation of the MIB compiler. </li><li>Chapter 4: "Running the application" describes how to start and configure the application. Topics on how to debug the application  are also included. </li><li>Chapter 5: "Definition of Agent Configuration Files" is a reference chapter, which contains more detailed information about the agent configuration files. </li><li>Chapter 6: "Definition of Manager Configuration Files" is a reference chapter, which contains more detailed information about the manager configuration files. </li><li>Chapter 7: "Agent Implementation Example" describes how an MIB can be implemented with the SNMP Development Toolkit.  Implementation examples are included. </li><li>Chapter 8: "Instrumentation Functions" describes how instrumentation functions should be defined in Erlang for the different operations. </li><li>Chapter 9: "Definition of Instrumentation Functions" is a reference chapter which contains more detailed information about the instrumentation functions. </li><li>Chapter 10: "Definition of Agent Net if" is a reference chapter, which describes the Agent Net if function in detail. </li><li>Chapter 11: "Definition of Manager Net if" is a reference chapter, which describes the Manager Net if function in detail. </li><li>Chapter 12: "Advanced Agent Topics" describes sub-agents, agent semantics, audit trail logging, and the consideration of distributed tables. </li><li>Appendix A describes the conversion of SNMPv2 to SNMPv1 error messages. </li><li>Appendix B contains the RFC1903 text on <strong>RowStatus</strong>. </li></ul><h4>Where to Find More Information</h4><p>Refer to the following documentation for more information about
SNMP and about the Erlang/OTP development system:
</p><ul><li>Marshall T. Rose (1991), "The Simple Book - An Introduction to Internet Management", Prentice-Hall </li><li>Evan McGinnis and David Perkins (1997), "Understanding SNMP MIBs", Prentice-Hall </li><li>RFC1155, 1157, 1212 and 1215 (SNMPv1) </li><li>RFC1901-1907 (SNMPv2c) </li><li>RFC1908, 2089 (coexistence between SNMPv1 and SNMPv2) </li><li>RFC2271, RFC2273 (SNMP std MIBs) </li><li>the Mnesia User's Guide </li><li>the Erlang 4.4 Extensions User's Guide </li><li>the Reference Manual </li><li>the Erlang Embedded Systems User's Guide </li><li>the System Architecture Support Libraries (SASL) User's Guide </li><li>the Installation Guide </li><li>the Asn1 User's Guide </li><li>Concurrent Programming in Erlang, 2nd Edition (1996), Prentice-Hall, ISBN 0-13-508301-X. </li></ul><p>The SNMP agent system consists of one Master Agent and
optional Sub-agents.
</p><p>The tool makes it easy to dynamically extend an SNMP agent in
run-time. MIBs can be loaded and unloaded at any time. It is also
easy to change the implementation of an MIB in run-time, without
having to recompile the MIB. The MIB implementation is clearly
separated from the agent.
</p><p>To facilitate incremental MIB implementation, the tool can
generate a prototype implementation for a whole MIB, or parts
thereof. This allows different MIBs and management applications to
be developed at the same time.
</p><h4>Features</h4><a name="features"></a><p>To implement an agent, the programmer writes instrumentation
functions for the variables and the tables in the MIBs that the
agent is going to support. A running prototype which handles <strong>set</strong>,
<strong>get</strong>, and <strong>get-next</strong> can be created without any programming.
</p><p>The toolkit provides the following:
</p><ul><li>multi-lingual multi-threaded extensible SNMP agent</li><li>easy writing of instrumentation functions with a high-level programming language</li><li>basic fault handling such as automatic type checking</li><li>access control</li><li>authentication</li><li>privacy through encryption</li><li>loading and unloading of MIBs in run-time</li><li>the ability to change instrumentation functions without recompiling the MIB</li><li>rapid prototyping environment where the MIB compiler can use generic instrumentation functions, which later can be refined by the programmer</li><li>a simple and extensible model for transaction handling and consistency checking of set-requests</li><li>support of the sub-agent concept via distributed Erlang</li><li>a mechanism for sending notifications (traps and informs)</li><li>support for implementing SNMP tables in the Mnesia DBMS.</li></ul><h4>SNMPv1, SNMPv2 and SNMPv3</h4><a name="versions"></a><p>The SNMP development toolkit works with all three versions of
Standard Internet Management Framework; SNMPv1, SNMPv2 and SNMPv3.
They all share the same basic structure and components. And they 
follow the same architecture.</p><p>The versions are defined in following RFCs</p><ul><li>SNMPv1        RFC 1555, 1157 1212, 1213 and 1215</li><li>SNMPv2        RFC 1902 - 1907</li><li>SNMPv3        RFC  2570 - 2575</li></ul><p>Over time, as the Framework has evolved from SNMPv1 , through SNMPv2, 
to SNMPv3 the definitions of each of these architectural components
have become richer and more clearly defined, but the fundamental
architecture has remained consistent.</p><p>The main features of SNMPv2 compared to SNMPv1 are:
</p><ul><li>The <strong>get-bulk</strong> operation for transferring large amounts of data. </li><li>Enhanced error codes. </li><li>A more precise language for MIB specification</li></ul><p>The standard documents that define SNMPv2 are incomplete, in
the sense that they do not specify how an SNMPv2 message looks
like.  The message format and security issues are left to a
special Administrative Framework. One such framework is the
Community-based SNMPv2 Framework (SNMPv2c), which uses the same
message format and framework as SNMPv1.   Other
experimental frameworks as exist, e.g. SNMPv2u and SNMPv2*.
</p><p>The SNMPv3 specifications take a modular 
approach to SNMP.  All modules are
separated from each other, and can be extended or replaced
individually.  Examples of modules are Message definition,
Security and Access Control.  The main features of SNMPv3 are:
</p><ul><li>Encryption and authentication is added. </li><li>MIBs for agent configuration are defined.</li></ul><p>All these specifications are commonly referred to as "SNMPv3",
but it is actually only the Message module, which defines a new
message format, and Security module, which takes care of
encryption and authentication, that cannot be used with SNMPv1 or
SNMPv2c.  In this version of the agent toolkit, all the standard
MIBs for agent configuration are used.  This includes MIBs for
definition of management targets for notifications.  These MIBs
are used regardless of which SNMP version the agent is configured
to use.
</p><p>The extensible agent in this toolkit understands the SNMPv1,
SNMPv2c and SNMPv3. Recall that SNMP consists of two separate
parts, the MIB definition language (SMI), and the protocol.  On
the protocol level, the agent can be configured to speak v1, v2c,
v3 or any combination of them at the same time, i.e. a v1 request
gets an v1 reply, a v2c request gets a v2c reply, and a v3 request
gets a v3 reply.  On the MIB level, the MIB compiler can compile
both SMIv1 and SMIv2 MIBs.  Once compiled, any of the formats can
be loaded into the agent, regardless of which protocol version the
agent is configured to use.  This means that the agent translates
from v2 notifications to v1 traps, and vice versa.  For example,
v2 MIBs can be loaded into an agent that speaks v1 only.  The
procedures for the translation between the two protocols are
described in RFC 1908 and RFC 2089.
</p><p>In order for an implementation to make full use of the enhanced
SNMPv2 error codes, it is essential that the instrumentation
functions always return SNMPv2 error codes, in case of error.
These are translated into the corresponding SNMPv1 error codes by
the agent, if necessary.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The translation from an SMIv1 MIB to an SNMPv2c or SNMPv3 reply
is always very straightforward, but the translation from a v2 MIB
to a v1 reply is somewhat more complicated.  There is one data
type in SMIv2, called <strong>Counter64</strong>, that an SNMPv1 manager cannot
decode correctly.  Therefore, an agent may never send a <strong>Counter64</strong>
object to an SNMPv1 manager.  The common practice in these
situations is to simple ignore any <strong>Counter64</strong> objects, when sending
a reply or a trap to an SNMPv1 manager.  For example, if an SNMPv1
manager tries to GET an object of type <strong>Counter64</strong>, he will get a
<strong>noSuchName</strong> error, while an SNMPv2 manager would get a
correct value.</p></div><h4>Operation</h4><a name="operations"></a><p>The following steps are needed to get a running agent:</p><ul><li> <p>Write your MIB in SMI in a text file.</p> </li><li> <p>Write the instrumentation functions in Erlang and compile them.</p> </li><li> <p>Put their names in the association file.</p> </li><li> <p>Run the MIB together with the association file through the
MIB compiler.</p> </li><li> <p>Configure the application (agent).</p> </li><li> <p>Start the application (agent).</p> </li><li> <p>Load the compiled MIB into the agent.</p> </li></ul><p>The figures in this section illustrate the steps involved in
the development of an SNMP agent.</p><a name="image-1"></a><img src="snmp-um-1-image-1.gif" title="MIB Compiler Principles"></img><p>The compiler parses the SMI file and associates each table or
variable with an instrumentation function (see the figure <a href="#image-1">MIB Compiler Principles</a>). The actual
instrumentation functions are not needed at MIB compile time, only
their names.
</p><p>The binary output file produced by the compiler is read by the
agent at MIB load time (see the figure <a href="#image-2">Starting the Agent</a>). The instrumentation is ordinary Erlang code which
is loaded explicitly or automatically the first time it is called.</p><a name="image-2"></a><img src="snmp-um-1-image-2.gif" title="Starting the Agent"></img><p>The SNMP agent system consists of one Master Agent and optional
sub-agents. The Master Agent can be seen as a special kind of
sub-agent. It implements the core agent functionality, UDP packet
processing, type checking, access control, trap distribution, and
so on. From a user perspective, it is used as an ordinary
sub-agent.
</p><p>Sub-agents are only needed if your application requires special
support for distribution from the SNMP toolkit. A sub-agent can
also be used if the application requires a more complex set
transaction scheme than is found in the master agent.
</p><p>The following illustration shows how a system can look  in runtime.</p><a name="snmp_ch2_fig3"></a><img src="snmp-um-1-image-3.gif" title="Architecture"></img><p>A typical operation could include the following steps:</p><ul><li>The Manager sends a request to the Agent.</li><li>The Master Agent  decodes the incoming UDP packet.</li><li>The Master Agent determines which items in the request that should be processed here and which items should be forwarded to its subagent.</li><li>Step 3 is repeated by all subagents.</li><li>Each sub-agent calls the instrumentation for its loaded MIBs.</li><li>The results of calling the instrumentation are propagated back to the Master Agent.</li><li>The answer to the request is encoded to a UDP Protocol Data Unit (PDU).</li></ul><p>The sequence of steps shown is probably more complex than
normal, but it illustrates the amount of functionality which is
available. The following points should be noted:
</p><ul><li>An agent can have many MIBs loaded at the same time.</li><li>Sub-agents can also have sub-agents. Each sub-agent can have an arbitrary number of child sub-agents registered, forming a hierarchy.</li><li>One MIB can communicate with many applications.</li><li>Instrumentation can use Distributed Erlang to communicate with an application.</li></ul><p>Most applications only need the Master Agent because an agent
can have multiple MIBs loaded at the same time.</p><h4>Sub-agents and MIB Loading</h4><a name="sub_agent_mib_loading"></a><p>Since applications tend to be transient (they are dynamically
loaded and unloaded), the management of these applications must be
dynamic as well. For example, if we have an equipment MIB for a
rack and different MIBs for boards, which can be installed in the
rack, the MIB for a card should be loaded when the card is
inserted, and unloaded when the card is removed.
</p><p>In this agent system, there are two ways to dynamically install
management information. The most common way is to load an MIB into
an agent. The other way is to use a sub-agent, which is controlled
by the application and is able to register and unregister itself. A
sub-agent can register itself for managing a sub-tree (not to be mixed up
with <strong>erlang:register</strong>). The sub-tree is identified by an
Object Identifier. When a sub-agent is registered, it receives all
requests for this particular sub-tree and it is responsible for
answering them. It should also be noted that a sub-agent can be
started and stopped at any time.
</p><p>Compared to other SNMP agent packages, there is a significant
difference in this way of using sub-agents. Other packages normally
use sub-agents to load and unload MIBs in run-time. In Erlang, it is
easy to load code in run-time and it is possible to load an MIB
into an existing sub-agent. It is not necessary to create a new process
for handling a new MIB.
</p><p>Sub-agents are used for the following reasons:
</p><ul><li>to provide a more complex set-transaction scheme than master agent</li><li>to avoid unnecessary process communication</li><li>to provide a more lightweight mechanism for loading and unloading MIBs in run-time</li><li>to provide interaction with other SNMP agent toolkits.</li></ul><p>Refer to the chapter 
<a href="snmp_advanced_agent">Advanced Agent Topics</a> 
in this User's Guide for more information about these topics.
</p><p>The communication protocol between sub-agents is the normal
message passing which is used in distributed Erlang systems. This
implies that sub-agent communication is very efficient compared to
SMUX, DPI, AgentX, and similar protocols.</p><h4>Contexts and Communities</h4><a name="context_and_communities"></a><p>A context is a collection of management information accessible
by an SNMP entity. An instance of a management object may exist in
more than one context. An SNMP entity potentially has access to
many contexts.</p><p>Each managed object can exist in many instances within a
SNMP entity. To identify the instances, specified by an MIB module,
a method to distinguish the actual instance by its 'scope' or 
context is used. Often the context is a physical or a logical device. 
It can include multiple devices, a subset of a single device or a 
subset of multiple devices, but the context is always
defined as a subset of a single SNMP entity. To be able to 
identify a specific 
item of management information within an SNMP entity, the context,
the object type and its instance must be used.</p><p>For example, the managed object type <strong>ifDescr</strong> from RFC1573, is
defined as the description of a network interface.  To identify
the description of device-X's first network interface, four pieces
of information are needed: the snmpEngineID of the SNMP entity
which provides access to the management information at device-X,
the <strong>contextName</strong> (device-X), the managed object type 
(<strong>ifDescr</strong>), and the instance ("1").
</p><p>In SNMPv1 and SNMPv2c, the community string in the message was
used for (at least) three different purposes:
</p><ul><li> <p>to identify the context</p> </li><li> <p>to provide authentication</p> </li><li> <p>to identify a set of trap targets</p> </li></ul><p>In SNMPv3, each of these usage areas has its own unique
mechanism.  A context is identified by the name of the SNMP
entity, <strong>contextEngineID</strong>, and the name of the context,
<strong>contextName</strong>.  Each SNMPv3 message contains values for these
two parameters.
</p><p>There is a MIB, SNMP-COMMUNITY-MIB, which maps a community
string to a <strong>contextEngineID</strong> and <strong>contextName</strong>. Thus, 
each message, an SNMPv1, SNMPv2c or an SNMPv3 message, always 
uniquely identifies a context.
</p><p>For an agent, the <strong>contextEngineID</strong> identified by a received
message, is always equal to the <strong>snmpEngineID</strong> of the agent.
Otherwise, the message was not intended for the agent.  If the
agent is configured with more than one context, the
instrumentation code must be able to figure out for which context
the request was intended.  There is a function
<strong>snmpa:current_context/0</strong> provided for this purpose.
</p><p>By default, the agent has no knowledge of any other contexts
than the default context, <strong>""</strong>.  If it is to support more
contexts, these must be explicitly added, by using an appropriate
configuration file 
<a href="snmp_agent_config_files">Agent Configuration Files</a>.
</p><h4>Management of the Agent</h4><a name="management"></a><p>There is a set of standard MIBs, which are used to control and
configure an SNMP agent.  All of these MIBs, with the exception of
the optional SNMP-PROXY-MIB (which is only used for proxy agents),
are implemented in this agent.  Further, it is configurable which
of these MIBs are actually loaded, and thus made visible to SNMP
managers.  For example, in a non-secure environment, it might be a
good idea to not make MIBs that define access control visible.
Note, the data the MIBs define is used internally in the
agent, even if the MIBs not are loaded.  This chapter describes
these standard MIBs, and some aspects of their implementation.
</p><p>Any SNMP agent must implement the <strong>system</strong> group and the
<strong>snmp</strong> group, defined in MIB-II.  The definitions of these
groups have changed from SNMPv1 to SNMPv2.   MIBs and implementations
for both of these versions are Provided in the
distribution.  The MIB file for SNMPv1 is called STANDARD-MIB, and the
corresponding for SNMPv2 is called SNMPv2-MIB.  If the agent is
configured for SNMPv1 only, the STANDARD-MIB is loaded by default;
otherwise, the SNMPv2-MIB is loaded by default.  It is possible to
override this default behavior, by explicitly loading another
version of this MIB, for example, you could choose to implement
the union of all objects in these two MIBs.
</p><p>An SNMPv3 agent must implement the SNMP-FRAMEWORK-MIB and
SNMP-MPD-MIB.  These MIBs are loaded by default, if the agent is
configured for SNMPv3.  These MIBs can be loaded for other
versions as well.
</p><p>There are five other standard MIBs, which also may be loaded
into the agent.  These MIBs are:
</p><ul><li> <p>SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB, which defines
managed objects for configuration of management targets,
i.e. receivers of notifications (traps and informs).  These
MIBs can be used with any SNMP version.
</p> </li><li> <p>SNMP-VIEW-BASED-ACM-MIB, which defined managed objects
for access control.  This MIB can be used with any SNMP
version.
</p> </li><li> <p>SNMP-COMMUNITY-MIB, which defines managed objects for
coexistence of SNMPv1 and SNMPv2c with SNMPv3.  This MIB is
only useful if SNMPv1 or SNMPv2c is used, possibly in
combination with SNMPv3.
</p> </li><li> <p>SNMP-USER-BASED-SM-MIB, which defines managed objects
for authentication and privacy.  This MIB is only useful
with SNMPv3.
</p> </li></ul><p>All of these MIBs should be loaded into the Master Agent.  Once
loaded, these MIBs are always available in all contexts.
</p><p>The ASN.1 code, the Erlang source code, and the generated
<strong>.hrl</strong> files for them are provided in the distribution and are 
placed  in the directories <strong>mibs</strong>, <strong>src</strong>, and <strong>include</strong>,
respectively, in the <strong>snmp</strong> application.
</p><p>The <strong>.hrl</strong> files are generated with
<strong>snmpc:mib_to_hrl/1</strong>.  Include these files in your code as in
the following example:
</p><pre><code class="">
-include_lib("snmp/include/SNMPv2-MIB.hrl").
    </code></pre><p>The initial values for the managed objects defined in these
tables, are read at start-up from a set of configuration files.
These are described in <a href="snmp_config">Configuration Files</a>.
</p><h4>STANDARD-MIB and SNMPv2-MIB</h4><p>These MIBs contain the <strong>snmp-</strong> and <strong>system</strong> groups
from MIB-II which is defined in RFC1213 (STANDARD-MIB) or
RFC1907 (SNMPv2-MIB).  They are implemented in the
<strong>snmp_standard_mib</strong> module. The <strong>snmp</strong> counters all
reside in volatile memory and the <strong>system</strong> and
<strong>snmpEnableAuthenTraps</strong> variables in persistent memory,
using the SNMP built-in database (refer to the Reference Manual,
section <strong>snmp</strong>, module <strong>snmpa_local_db</strong> for more
details).</p><p>If another implementation of any of these variables is needed,
e.g. to store the persistent variables in a Mnesia database,
an own implementation of the variables must be made. That MIB 
will be compiled and loaded instead of the default MIB. 
The new compiled MIB
must have the same name as the original MIB (i.e. STANDARD-MIB
or SNMPv2-MIB), and be located in the SNMP configuration
directory (see <a href="snmp_config">Configuration Files</a>.) 
</p><p>One of these MIBs is always loaded.  If only SNMPv1 is used,
STANDARD-MIB is loaded, otherwise SNMPv2-MIB is loaded.
</p><h4>Data Types</h4><p>There are some new data types in SNMPv2 that are useful in
SNMPv1 as well.  In the STANDARD-MIB, three data types are
defined, <strong>RowStatus</strong>, <strong>TruthValue</strong> and
<strong>DateAndTime</strong>.  These data types are originally defined
as textual conventions in SNMPv2-TC (RFC1903).
</p><h4>SNMP-FRAMEWORK-MIB and SNMP-MPD-MIB</h4><p>The SNMP-FRAMEWORK-MIB and SNMP-MPD-MIB define additional 
read-only managed objects, which
is used in the generic SNMP framework defined in RFC2271 and the
generic message processing and dispatching module defined in
RFC2272.  They are generic in the sense that they are not tied
to any specific SNMP version.
</p><p>The objects in these MIBs are implemented in the modules
<strong>snmp_framework_mib</strong> and <strong>snmp_standard_mib</strong>,
respectively.  All objects reside in volatile memory, and the
configuration files are always reread at start-up.
</p><p>If SNMPv3 is used, these MIBs are loaded by default.
</p><h4>SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB</h4><p>The SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB define managed 
objects for configuration of notification receivers.  They 
are described in detail in RFC2273.  Only a brief description 
is given here.
</p><p>All tables in these MIBs have a column of type
<strong>StorageType</strong>.  The value of this column specifies how each
row is stored, and what happens in case of a restart of the
agent.  The implementation supports the values <strong>volatile</strong>
and <strong>nonVolatile</strong>.  When the tables are initially filled
with data from the configuration files, these rows will
automatically have storage type <strong>nonVolatile</strong>.  Should the
agent restart, all <strong>nonVolatile</strong> rows survive the restart,
while the <strong>volatile</strong> rows are lost.
The configuration files are not read at restart, by default.
</p><p>These MIBs are not loaded by default.
</p><h4>snmpNotifyTable</h4><p>An entry in the <strong>snmpNotifyTable</strong> selects a set
of management targets, which should receive notifications, 
as well as the type (trap or inform) of notification that 
should be sent to each selected management target.
When an application sends a notification using
the function <strong>send_notification/5</strong> or the function
<strong>send_trap</strong> the parameter <strong>NotifyName</strong>, specified in
the call, is used as an index in the table.  The notification
is sent to the management targets selected by that entry.
</p><h4>snmpTargetAddrTable</h4><p>An entry in the <strong>snmpTargetAddrTable</strong> defines
transport parameters (such as
IP address and UDP port) for each management target.  Each row
in the <strong>snmpNotifyTable</strong> refers to potentially many rows
in the <strong>snmpTargetAddrTable</strong>.  Each row in the
<strong>snmpTargetAddrTable</strong>
refers to an entry in the <strong>snmpTargetParamsTable</strong>.
</p><h4>snmpTargetParamsTable</h4><p>An entry in the <strong>snmpTargetParamsTable</strong> defines 
which SNMP version to use, and which security parameters to use.
</p><p>Which SNMP version to use is implicitly defined by
specifying the Message Processing Model.  This version of the
agent handles the models <strong>v1</strong>, <strong>v2c</strong> and <strong>v3</strong>.
</p><p>Each row specifies which security model to use, along with
security level and security parameters.
</p><h4>SNMP-VIEW-BASED-ACM-MIB</h4><p>The SNMP-VIEW-BASED-ACM-MIB defines managed objects to
control access to the the managed objects for the managers.  
The View Based Access Control Module (VACM) can be used with 
any SNMP version. However, if it is used with SNMPv1 or SNMPv2c, 
the SNMP-COMMUNITY-MIB defines additional objects to map 
community strings to VACM parameters.
</p><p>All tables in this MIB have a column of type <strong>StorageType</strong>.  
The value of this column specifies how each
row is stored, and what happens in case of a restart of the
agent.  The implementation supports the values <strong>volatile</strong>
and <strong>nonVolatile</strong>.  When the tables are initially filled
with data from the configuration files, these rows will
automatically have storage type <strong>nonVolatile</strong>.  Should the
agent restart, all <strong>nonVolatile</strong> rows survive the restart,
while the <strong>volatile</strong> rows are lost.
The configuration files are not read at restart by default.
</p><p>This MIB is not loaded by default.
</p><p>VACM is described in detail in RFC2275.  Here is only a brief
description given.
</p><p>The basic concept is that of a <em>MIB view</em>.  An MIB view
is a subset of all the objects implemented by an agent.  A
manager has access to a certain MIB view, depending on which
security parameters are used, in which context the request is
made, and which type of request is made.
</p><p>The following picture gives an overview of the mechanism to
select an MIB view:</p><img src="MIB_mechanism.gif" title="Overview of the mechanism of MIB selection"></img><h4>vacmContextTable</h4><p>The <strong>vacmContextTable</strong> is a read-only table that lists all
available contexts.
</p><h4>vacmSecurityToGroupTable</h4><p>The <strong>vacmSecurityToGroupTable</strong> maps a <strong>securityModel</strong>
and a
<strong>securityName</strong> to a <strong>groupName</strong>.
</p><h4>vacmAccessTable</h4><p>The <strong>vacmAccessTable</strong> maps the <strong>groupName</strong> (found in
<strong>vacmSecurityToGroupTable</strong>), <strong>contextName</strong>,
<strong>securityModel</strong>, and <strong>securityLevel</strong> to an MIB view
for each type of operation (read, write, or notify).  The MIB
view is represented as a <strong>viewName</strong>.  The definition of
the MIB view represented by the <strong>viewName</strong> is found in
the <strong>vacmViewTreeFamilyTable</strong></p><h4>vacmViewTreeFamilyTable</h4><p>The <strong>vacmViewTreeFamilyTable</strong> is indexed by the
<strong>viewName</strong>, and defines
which objects are included in the MIB view.
</p><p>The MIB definition for the table looks as follows:</p><pre>
VacmViewTreeFamilyEntry ::= SEQUENCE
    {
        vacmViewTreeFamilyViewName     SnmpAdminString,
        vacmViewTreeFamilySubtree      OBJECT IDENTIFIER,
        vacmViewTreeFamilyMask         OCTET STRING,
        vacmViewTreeFamilyType         INTEGER,
        vacmViewTreeFamilyStorageType  StorageType,
        vacmViewTreeFamilyStatus       RowStatus
    }

INDEX { vacmViewTreeFamilyViewName,
        vacmViewTreeFamilySubtree
      }
        </pre><p>Each <strong>vacmViewTreeFamilyViewName</strong> refers to a
collection of sub-trees.
</p><h4>MIB View Semantics</h4><p>An MIB view is a collection of included and excluded
sub-trees. A sub-tree is identified by an OBJECT IDENTIFIER. A
mask is associated with each sub-tree.
</p><p>For each possible MIB object instance, the instance
belongs to a sub-tree if:
</p><ul><li>the OBJECT IDENTIFIER name of that MIB object instance comprises at least as many sub-identifiers as does the sub-tree, and </li><li>each sub-identifier in the name of that MIB object instance matches the corresponding sub-identifier of the sub-tree whenever the corresponding bit of the associated mask is 1 (0 is a wild card that matches anything).</li></ul><p>Membership of an object instance in an MIB view is
determined by the following algorithm:
</p><ul><li>If an MIB object instance does not belong to any of the relevant sub-trees, then the instance is not in the MIB view. </li><li>If an MIB object instance belongs to exactly one sub-tree, then the instance is included in, or excluded from, the relevant MIB view according to the type of that entry. </li><li>If an MIB object instance belongs to more than one sub-tree, then the sub-tree which comprises the greatest number of sub-identifiers, and is the lexicographically greatest, is used. </li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If the OBJECT IDENTIFIER is longer than an OBJECT
IDENTIFIER of an object type in the MIB, it refers to
object instances. Because of this, it is possible to
control whether or not particular rows in a table shall be
visible.</p></div><h4>SNMP-COMMUNITY-MIB</h4><p>The SNMP-COMMUNITY-MIB defines managed objects that is used 
for coexistence between SNMPv1 and SNMPv2c with SNMPv3.  
Specifically, it contains objects for mapping between community 
strings and version-independent SNMP message parameters.  In 
addition, this MIB provides a mechanism for performing source address
validation on incoming requests, and for selecting community
strings based on target addresses for outgoing notifications.
</p><p>All tables in this MIB have a column of type
<strong>StorageType</strong>.  The value of this column specifies how each
row is stored, and what happens in case of a restart of the
agent.  The implementation supports the values <strong>volatile</strong>
and <strong>nonVolatile</strong>.  When the tables are initially filled
with data from the configuration files, these rows will
automatically have storage type <strong>nonVolatile</strong>.  Should the
agent restart, all <strong>nonVolatile</strong> rows survive the restart,
while the <strong>volatile</strong> rows are lost.
The configuration files are not read at restart, by default.
</p><p>This MIB is not loaded by default.
</p><h4>SNMP-USER-BASED-SM-MIB</h4><p>The SNMP-USER-BASED-SM-MIB defines managed objects that is
used for the User-Based Security Model.
</p><p>All tables in this MIB have a column of type
<strong>StorageType</strong>.  The value of the column specifies how each
row is stored, and what happens in case of a restart of the
agent.  The implementation supports the values <strong>volatile</strong>
and <strong>nonVolatile</strong>.  When the tables are initially filled
with data from the configuration files, these rows will
automatically have storage type <strong>nonVolatile</strong>.  Should the
agent restart, all <strong>nonVolatile</strong> rows survive the restart,
while the <strong>volatile</strong> rows are lost.
The configuration files are not read at restart, by default.
</p><p>This MIB is not loaded by default.
</p><h4>OTP-SNMPEA-MIB</h4><p>The OTP-SNMPEA-MIB was used in earlier versions of the agent, before
standard MIBs existed for access control, MIB views, and trap
target specification.  All objects in this MIB are now obsolete.
</p><h4>Notifications</h4><a name="notifications"></a><p>Notifications are defined in SMIv1 with the TRAP-TYPE macro in
the definition of an MIB (see RFC1215).  The corresponding
macro in SMIv2 is NOTIFICATION-TYPE.  When an application
decides to send a notification, it calls one of the following
functions:
</p><pre><code class="">
snmpa:send_notification(Agent, Notification, Receiver
                       [, NotifyName, ContextName, Varbinds])
snmpa:send_trap(Agent, Notification, Community [, Receiver, Varbinds])
    </code></pre><p>providing the registered name or process identifier of the
agent where the MIB, which defines the notification is loaded and
the symbolic name of the notification.
</p><p>If the <strong>send_notification/3,4</strong> function is used, all
management targets are selected, as defined in RFC2273.  The
<strong>Receiver</strong> parameter defines where the agent should send
information about the delivery of inform requests.
</p><p>If the <strong>send_notification/5</strong> function is used, an
<strong>NotifyName</strong> must be provided.  This parameter is used as an
index in the <strong>snmpNotifyTable</strong>, and the management targets
defined by that single entry is used.
</p><p>The <strong>send_notification/6</strong> function is the most general
version of the function.  A <strong>ContextName</strong> must be specified,
from which the notification will be sent.  If this parameter is
not specified, the default context (<strong>""</strong>) is used.
</p><p>The function <strong>send_trap</strong> is kept for backwards
compatibility and should not be used in new code.  Applications
that use this function will
continue to work.  The <strong>snmpNotifyName</strong> is used as the
community string by the agent when a notification is sent.
</p><h4>Notification Sending</h4><p>The simplest way to send a notification is to call the function 
<strong>snmpa:send_notification(Agent, Notification, no_receiver)</strong>.
In this case, the agent performs a get-operation to retrieve the
object values that are defined in the notification
specification (with the TRAP-TYPE or NOTIFICATION-TYPE macros).
The notification is sent to all managers defined in the target
and notify tables, either unacknowledged as traps, or
acknowledged as inform requests.
</p><p>If the caller of the function wants to know whether or not
acknowledgments are received for a certain notification
(provided it is sent as an inform), the <strong>Receiver</strong>
parameter can be specified as <strong>{Tag, ProcessName}</strong> (refer
to the Reference Manual, section snmp, module <strong>snmp</strong> for
more details).  In this case, the agent send a message
<strong>{snmp_notification, Tag, {got_response, ManagerAddr}}</strong> or
<strong>{snmp_notification, Tag, {no_response, ManagerAddr}}</strong> for
each management target.
</p><p>Sometimes it is not possible to retrieve the values for some
of the objects in the notification specification with a
get-operation.  However, they are known when the
<strong>send_notification</strong> function is called. This is the case if
an object is an element in a table.  It is possible to give the
values of some objects to the <strong>send_notification</strong> function
<strong>snmpa:send_notification(Agent, Notification, Receiver, Varbinds)</strong>.  In this function, <strong>Varbinds</strong> is a list of
<strong>Varbind</strong>, where each <strong>Varbind</strong> is one of:
</p><ul><li><strong>{Variable, Value}</strong>, where <strong>Variable</strong> is the symbolic name of a scalar variable referred to in the notification specification. </li><li><strong>{Column, RowIndex, Value}</strong>, where <strong>Column</strong> is the symbolic name of a column variable.  <strong>RowIndex</strong> is a list of indices for the specified element.  If this is the case, the OBJECT IDENTIFIER sent in the trap is the <strong>RowIndex</strong> appended to the OBJECT IDENTIFIER for the table column. This is the OBJECT IDENTIFIER which specifies the element. </li><li><strong>{OID, Value}</strong>, where <strong>OID</strong> is the OBJECT IDENTIFIER for an instance of an object, scalar variable or column variable. </li></ul><p>For example, to specify that <strong>sysLocation</strong> should have the
value <strong>"upstairs"</strong> in the notification, we could use one of:
</p><ul><li><strong>{sysLocation, "upstairs"}</strong> or</li><li><strong>{[1,3,6,1,2,1,1,6,0], "upstairs"}</strong></li></ul><p>It is also possible to specify names and values for extra
variables that should be sent in the notification, but were not
defined in the notification specification.
</p><p>The notification is sent to all management targets found in
the tables.  However, make sure that each manager has access to
the variables in the notification. If a variable is outside a
manager's MIB view, this manager will not receive the
notification.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>By definition, it is not possible to send objects with
ACCESS <strong>not-accessible</strong> in notifications. However,
historically this is often done and for this reason we allow
it in notification sending. If a variable has ACCESS
<strong>not-accessible</strong>, the user must provide a value for the
variable in the <strong>Varbinds</strong> list. It is not possible for
the agent to perform a get-operation to retrieve this value.
</p></div><h4>Notification Filters</h4><p>It is possible to add <em>notification filters</em> to an agent.
These filters will be called when a notification is to be 
sent. Their purpose is to allow modification, suppression or 
other type of actions.</p><p>A notification filter is a module implementing the 
<a href="snmpa_notification_filter">snmpa_notification_filter</a> behaviour. A filter is added/deleted using the functions:
<a href="./snmpa#register_notification_filter">snmpa:register_notification_filter</a> and 
<a href="./snmpa#unregister_notification_filter">snmpa:unregister_notification_filter</a>.</p><p>Unless otherwise specified, the order of the registered filters
will be the order in which they are registered.</p><h4>Sub-agent Path</h4><p>If a value for an object is not given to the
<strong>send_notification</strong> function, the sub-agent will perform a
get-operation to retrieve it. If the object is not implemented
in this sub-agent, its parent agent tries to perform a
get-operation to retrieve it. If the object is not implemented
in this agent either, it forwards the object to its parent, and
so on. Eventually the Master Agent is reached and at this point
all unknown object values must be resolved. If some object is
unknown even to the Master Agent, this is regarded as an error
and is reported with a call to <strong>user_err/2</strong> of the 
error report module. No notifications are sent in this case.
</p><p>For a given notification, the variables, which are referred to
in the notification specification, must be implemented by the
agent that has the MIB loaded, or by some parent to this
agent. If not, the application must provide values for the
unknown variables. The application must also provide values for
all elements in tables.
</p><h4>Discovery</h4><a name="discovery"></a><p>The <em>sender</em> is <em>authoritative</em> for messages containing
payload which does <em>not</em> expect a response (for example 
SNMPv2-Trap, Response or Report PDU). </p><p>The <em>receiver</em> is <em>authoritative</em> for messages containing
payload which expects a response (for example 
Get, GetNext, Get-Bulk, Set or Inform PDU). </p><p>The agent can both perform and respond to discovery.</p><p>The agent responds to discovery autonomously, without interaction
by the user. </p><p>Initiating discovery towards a manager is done by calling the 
<a href="./snmpa#discovery">discovery</a> function. 
The <strong>EngineId</strong> field of the target (manager) entry in the 
<a href="./snmp_agent_config_files#target_addr">target_addr.conf</a> file has to have the value <strong>discovery</strong>. 
Note that if the manager does not respond, the <strong>Timeout</strong> and 
<strong>RetryCount</strong> 
fields decide how long the function will hang before it returns. </p><p>Discovery can only be performed towards one manager at a time.</p><h4>Features</h4><a name="features"></a><p>The manager provided with the tool is a lightweight manager
that basically provides a means to communicate with agents.</p><p>It does not really implement any management capabilities by 
itself. That is up to the <em>user</em>. 
</p><p>A <em>user</em> in this context is basically a module implementing
the <a href="snmpm_user">snmpm_user</a> behaviour. 
A <em>user</em> can issue snmp requests and receive 
notification/traps.</p><p>Agents to be accessed by the manager needs to be registered by 
a user. Once registered, they can be accessed by all registered 
users.</p><p>Notifications/traps from an agent is delivered to the user that 
did the registration.</p><p>Any message from an agent that is not registered is delivered to 
the <em>default user</em>.</p><p>By default, the <em>default user</em> is set to the 
<strong>snmpm_user_default</strong> module, which simply sends an info message
to the error_logger. It is however highly recommended that this
module be replaced by another that does something useful
(see <a href="./snmp_config#configuration_params">configuration params</a> for more info).</p><p>When using version 3, then (at least one) <em>usm user</em> has to 
be registered.</p><p>Requests can be issued in two different ways. Synchronous (see
<a href="./snmpm#sync_set">sync_set</a>,
<a href="./snmpm#sync_get">sync_get</a>, 
<a href="./snmpm#sync_get_next">sync_get_next</a> and 
<a href="./snmpm#sync_get_bulk">sync_get_bulk</a>)
and asynchronous (see 
<a href="./snmpm#async_set">async_set</a>,
<a href="./snmpm#async_get">async_get</a>, 
<a href="./snmpm#async_get_next">async_get_next</a> and  
<a href="./snmpm#async_get_bulk">async_get_bulk</a>). 
With synchronous 
the snmp reply is returned by the function. With asynchronous,
the reply will instead be delivered through a call to one of the
<strong>handle_pdu</strong> callback function defined by the 
<a href="./snmpm_user#handle_pdu">handle_pdu</a> 
behaviour.</p><h4>Operation</h4><a name="operation"></a><p>The following steps are needed to get the manager running:</p><ul><li> <p>[optional] Implement the default user.</p> </li><li> <p>Implement the user(s).</p> </li><li> <p>Configure the application (manager).</p> </li><li> <p>Start the application (manager).</p> </li><li> <p>Register the user(s).</p> </li><li> <p>The user(s) register their agents.</p> </li></ul><h4>MIB loading</h4><a name="mib_loading"></a><p>It is possible to load mibs into the manager, but this is not 
necessary for normal operation, and not recommended.</p><p>The chapter <em>The MIB Compiler</em> describes the MIB compiler
and contains the following topics:
</p><ul><li>Operation</li><li>Import</li><li>Consistency checking between MIBs</li><li>.hrl file generation</li><li>Emacs integration</li><li>Deviations from the standard </li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>When importing MIBs, ensure that the imported MIBs as well as the 
importing MIB are compiled using the same version of the 
SNMP-compiler.</p></div><h4>Operation</h4><p>The MIB must be written as a text file in SMIv1 or SMIv2 using 
an ASN.1 notation before
it will be compiled. This text file must have the same name as the MIB,
but with the suffix <strong>.mib</strong>. This is necessary for handling
the <strong>IMPORT</strong> statement.
</p><p>The association file, which contains the names of
instrumentation functions for the MIB, should have the suffix
<strong>.funcs</strong>. If the compiler does not find the association file,
it gives a warning message and uses default instrumentation
functions.  (See <a href="./snmp_instr_functions#snmp_3">Default Instrumentation</a> for more details).
</p><p>The MIB compiler is started with a call to
<strong>snmpc:compile(&lt;mibname&gt;).</strong> For example:
</p><pre><code class="">
snmpc:compile("RFC1213-MIB").
    </code></pre><p>The output is a new file which is called <strong>&lt;mibname&gt;.bin</strong>.
</p><p>The MIB compiler understands both SMIv1 and SMIv2 MIBs.  It
uses the MODULE-IDENTITY statement to determinate if the MIB is
written in SMI version 1 or 2.
</p><h4>Importing MIBs</h4><p>The compiler handles the <strong>IMPORT</strong> statement. It is important to
import the compiled file and not the ASN.1 (source) file. A MIB must
be recompiled to make changes visible to other MIBs importing it.
</p><p>The compiled files of the imported MIBs must be present in the
current directory, or a directory in the current path. The path is
supplied with the <strong>{i, Path}</strong> option, for example:
</p><pre><code class="">
snmpc:compile("MY-MIB", 
       [{i, ["friend_mibs/", "../standard_mibs/"]}]).
    </code></pre><p>It is also possible to import MIBs from OTP applications in an
<strong>"include_lib"</strong> like fashion with the <strong>il</strong>
option. Example:
</p><pre><code class="">
snmpc:compile("MY-MIB", 
       [{il, ["snmp/priv/mibs/", "myapp/priv/mibs/"]}]).
    </code></pre><p>finds the latest version of the <strong>snmp</strong> and <strong>myapp</strong>
applications in the OTP system and uses the expanded paths as
include paths.
</p><p>Note that an SMIv2 MIB can import an SMIv1 MIB and vice versa.
</p><p>The following MIBs are built-ins of the Erlang SNMP compiler:
SNMPv2-SMI, RFC-1215, RFC-1212, SNMPv2-TC, SNMPv2-CONF, and
RFC1155-SMI. They cannot therefore be compiled separately.
</p><h4>MIB Consistency Checking</h4><p>When an MIB is compiled, the compiler detects if several
managed objects use the same <strong>OBJECT IDENTIFIER</strong>. If that is
the case, it issues an error message. However, the compiler cannot
detect Oid conflicts between different MIBs. These kinds of
conflicts generate an error at load time. To avoid this, the
following function can be used to do consistency checking between
MIBs:
</p><pre>

erl&gt;<span class="input">snmpc:is_consistent(ListOfMibNames).</span>
    </pre><p><strong>ListOfMibNames</strong> is a list of compiled MIBs, for example
<strong>["RFC1213-MIB", "MY-MIB"]</strong>. The function also performs
consistency checking of trap definitions.</p><h4>.hrl File Generation</h4><p>It is possible to generate an <strong>.hrl</strong> file which contains
definitions of Erlang constants from a compiled MIB file. This
file can then be included in Erlang source code. The file will
contain constants for:
</p><ul><li>object Identifiers for tables, table entries and variables</li><li>column numbers</li><li>enumerated values</li><li>default values for variables and table columns. </li></ul><p>Use the following command to  generate a .hrl file from an MIB:
</p><pre>
erl&gt;<span class="input">snmpc:mib_to_hrl(MibName).</span>
    </pre><h4>Emacs Integration</h4><p>With the Emacs editor, the <strong>next-error</strong> (<strong>C-X `</strong>)
function can be used indicate where a compilation error occurred,
provided the error message is described by a line number.
</p><p>Use <strong>M-x compile</strong> to compile an MIB from inside Emacs, and
enter:
</p><pre>
 <span class="input">erl -s snmpc compile &lt;MibName&gt; -noshell</span>
    </pre><p>An example of <strong>&lt;MibName&gt;</strong> is <strong>RFC1213-MIB</strong>.
</p><h4>Compiling from a Shell or a Makefile</h4><p>The <strong>erlc</strong> commands can be used to compile SNMP MIBs. Example:
</p><pre>
 <span class="input">erlc MY-MIB.mib</span>
    </pre><p>All the standard <strong>erlc</strong> flags are supported, e.g.
</p><pre>
 <span class="input">erlc -I mymibs -o mymibs -W MY-MIB.mib</span>
    </pre><p>The flags specific to the MIB compiler can be specified by
using the <strong>+</strong> syntax:
</p><pre>
 <span class="input">erlc +'{group_check,false}' MY-MIB.mib</span>
    </pre><h4>Deviations from the Standard</h4><p>In some aspects the Erlang MIB compiler does not follow or
implement the SMI fully. Here are the differences:
</p><ul><li> <p>Tables must be written in the following order:
<strong>tableObject</strong>, <strong>entryObject</strong>, <strong>column1</strong>, ...,
<strong>columnN</strong> (in order).</p> </li><li> <p>Integer values, for example in the <strong>SIZE</strong> expression
must be entered in decimal syntax, not in hex or bit syntax.</p> </li><li> <p>Symbolic names must be unique within a MIB and within a
system.</p> </li><li> <p>Hyphens are allowed in SMIv2 (a pragmatic approach).  The
reason for this is that according to SMIv2, hyphens are allowed
for objects converted from SMIv1, but not for others.  This is
impossible to check for the compiler.</p> </li><li> <p>If a word is a keyword in any of SMIv1 or SMIv2, it is a
keyword in the compiler (deviates from SMIv1 only).</p> </li><li> <p>Indexes in a table must be objects, not types (deviates
from SMIv1 only).</p> </li><li> <p>A subset of all semantic checks on types are
implemented. For example, strictly the <strong>TimeTicks</strong> may not
be sub-classed but the compiler allows this (standard MIBs must
pass through the compiler) (deviates from SMIv2 only).</p> </li><li> <p>The <strong>MIB.Object</strong> syntax is not implemented (since all
objects must be unique anyway).</p> </li><li> <p>Two different names cannot define the same OBJECT IDENTIFIER.</p> </li><li> <p>The type checking in the SEQUENCE construct is non-strict 
(i.e. subtypes may be specified).  The reason for this is 
that some standard MIBs use this.</p> </li><li>A definition has normally a status field. When the status field has the value deprecated, then the MIB-compiler will ignore this  definition. With the MIB-compiler option <strong>{deprecated,true}</strong>  the MIB-compiler does not ignore the deprecated definitions.</li><li>An object has a DESCRIPTIONS field. The descriptions-field will  not be included in the compiled mib by default. In order to get  the description, the mib must be compiled with the option  <strong>description</strong>.</li></ul><p>The chapter <em>Running the application</em> describes how the 
application is configured and started.
The topics include:</p><ul><li>configuration directories and parameters</li><li>modifying the configuration files</li><li>starting the application (agent and/or manager)</li><li>debugging the application (agent and/or manager)</li></ul><p>Refer also to the chapter(s) 
<a href="snmp_agent_config_files">Definition of Agent  Configuration Files</a> and  
<a href="snmp_manager_config_files">Definition of Manager  Configuration Files</a> which contains more detailed information 
about the agent and manager configuration files.</p><a name="configuration_params"></a><h4>Configuring the application</h4><p>The following two directories must exist in the system
to run the agent:</p><ul><li> <p>the <em>configuration directory</em> stores all
configuration files used by the agent (refer to the chapter 
<a href="snmp_agent_config_files">Definition of Agent Configuration Files</a> for more information). </p> </li><li>the <em>database directory</em> stores the internal database files.</li></ul><p>The following directory must exist in the system
to run the manager:</p><ul><li> <p>the <em>configuration directory</em> stores all
configuration files used by the manager (refer to the chapter 
<a href="snmp_manager_config_files">Definition of Manager  Configuration Files</a> for more information). </p> </li><li> <p>the <em>database directory</em> stores the internal
database files. </p> </li></ul><p>The agent and manager uses (application) configuration parameters to 
find out where these directories are located. The parameters should be
defined in an Erlang system configuration file. The following
configuration parameters are defined for the SNMP application:</p><pre>
      agent_options() = [agent_option()]
      agent_option() = {restart_type,     restart_type()}     | 
                       {agent_type,       agent_type()}       |  
                       {agent_verbosity,  verbosity()}        |  
                       {versions,         versions()}         |  
                       {discovery,        agent_discovery()}  |  
                       {gb_max_vbs,       gb_max_vbs()}       |  
                       {priority,         priority()}         |  
                       {multi_threaded,   multi_threaded()}   |  
                       {db_dir,           db_dir()}           |  
                       {db_init_error,    db_init_error()}    |  
                       {local_db,         local_db()}         |  
                       {net_if,           agent_net_if()}     |  
                       {mibs,             mibs()}             |  
                       {mib_storage,      mib_storage()}      |  
                       {mib_server,       mib_server()}       |  
                       {audit_trail_log,  audit_trail_log()}  |  
                       {error_report_mod, error_report_mod()} |  
                       {note_store,       note_store()}       |  
                       {symbolic_store,   symbolic_store()}   |  
                       {target_cache,     target_cache()}     |  
                       {config,           agent_config()}
      manager_options() = [manager_option()]
      manager_option() = {restart_type,             restart_type()}    | 
                         {net_if,                   manager_net_if()}  |  
                         {server,                   server()}          | 
                         {note_store,               note_store()}      | 
                         {config,                   manager_config()}  |  
                         {inform_request_behaviour, manager_irb()}     | 
                         {mibs,                     manager_mibs()}    | 
                         {priority,                 priority()}        |  
                         {audit_trail_log,          audit_trail_log()} | 
                         {versions,                 versions()}        | 
                         {def_user_mod,             def_user_module()  | 
                         {def_user_data,            def_user_data()}
    </pre><a name="agent_opts_and_types"></a><p>Agent specific config options and types:</p><dl><dt><a name="agent_type"></a> <strong>agent_type() = master | sub &lt;optional&gt;</strong></dt><dd> <p>If <strong>master</strong>, one master agent is
started. Otherwise, no agents are started. </p> <p>Default is <strong>master</strong>.</p> </dd><dt><a name="agent_disco"></a> <strong>agent_discovery() = [agent_discovery_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_discovery_opt() =  {terminating, agent_terminating_discovery_opts()} |  {originating, agent_originating_discovery_opts()}</strong></p> <p>The <strong>terminating</strong> options effects discovery initiated by 
a manager. </p> <p>The <strong>originating</strong> options effects discovery initiated 
by this agent. </p> <p>For defaults see the options in <strong>agent_discovery_opt()</strong>.</p> </dd><dt><a name="agent_term_disco_opts"></a> <strong>agent_terminating_discovery_opts() = [agent_terminating_discovery_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_terminating_discovery_opt() =  {enable, boolean()} |  {stage2, discovery | plain} |  {trigger_username, string()}</strong></p> <p>These are options effecting discovery <strong>terminating</strong> in this
agent (i.e. initiated by a manager). </p> <p>The default values for the <strong>terminating</strong> 
discovery options are: </p> <ul><li>enable: <strong>true</strong></li><li>stage2: <strong>discovery</strong></li><li>trigger_username: <strong>""</strong></li></ul> </dd><dt><a name="agent_orig_disco_opts"></a> <strong>agent_originating_discovery_opts() = [agent_originating_discovery_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_originating_discovery_opt() =  {enable, boolean()}</strong></p> <p>These are options effecting discovery <strong>originating</strong> in this
agent. </p> <p>The default values for the <strong>originating</strong> 
discovery options are: </p> <ul><li>enable: <strong>true</strong></li></ul> </dd><dt><a name="agent_mt"></a> <strong>multi_threaded() = bool() &lt;optional&gt;</strong></dt><dd> <p>If <strong>true</strong>, the agent is multi-threaded, with one
thread for each get request. </p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="agent_data_dir"></a> <strong>db_dir() = string() &lt;mandatory&gt;</strong></dt><dd> <p>Defines where the SNMP agent internal db files are stored.</p> </dd><dt><a name="agent_gb_max_vbs"></a> <strong>gb_max_vbs() = pos_integer() | infinity &lt;optional&gt;</strong></dt><dd> <p>Defines the maximum number of varbinds allowed 
in a Get-BULK response.</p> <p>Default is <strong>1000</strong>.</p> </dd><dt><a name="agent_local_db"></a> <strong>local_db() = [local_db_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>local_db_opt() = {repair, agent_repair()} | {auto_save, agent_auto_save()} |   {verbosity, verbosity()}</strong></p> <p>Defines options specific for the SNMP agent local database.</p> <p>For defaults see the options in <strong>local_db_opt()</strong>.</p> </dd><dt><a name="agent_ldb_repair"></a> <strong>agent_repair() = false | true | force &lt;optional&gt;</strong></dt><dd> <p>When starting snmpa_local_db it always tries to open an
existing database. If <strong>false</strong>, and some errors occur, a new
database is created instead. If <strong>true</strong>, an existing file
will be repaired. If <strong>force</strong>, the table will be repaired
even if it was properly closed. </p> <p>Default is <strong>true</strong>.</p> </dd><dt><a name="agent_ldb_auto_save"></a> <strong>agent_auto_save() = integer() | infinity &lt;optional&gt;</strong></dt><dd> <p>The auto save interval. The table is flushed to disk
whenever not accessed for this amount of time.</p> <p>Default is <strong>5000</strong>.</p> </dd><dt><a name="agent_net_if"></a> <strong>agent_net_if() = [agent_net_if_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_net_if_option() = {module, agent_net_if_module()} |  {verbosity, verbosity()} |  {options, agent_net_if_options()}</strong></p> <p>Defines options specific for the SNMP agent network interface 
entity. </p> <p>For defaults see the options in <strong>agent_net_if_opt()</strong>.</p> </dd><dt><a name="agent_ni_module"></a> <strong>agent_net_if_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>Module which handles the network interface part for the
SNMP agent. Must implement the 
<a href="snmpa_network_interface">snmpa_network_interface</a> behaviour.</p> <p>Default is <strong>snmpa_net_if</strong>.</p> </dd><dt><a name="agent_ni_opts"></a> <strong>agent_net_if_options() = [agent_net_if_option()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_net_if_option() = {bind_to, bind_to()} |   {sndbuf, sndbuf()} |   {recbuf, recbuf()} |   {no_reuse, no_reuse()} |  {req_limit, req_limit()} | {filter, agent_net_if_filter_options()}</strong></p> <p>These options are actually specific to the used module.
The ones shown here are applicable to the default 
<strong>agent_net_if_module()</strong>.</p> <p>For defaults see the options in <strong>agent_net_if_option()</strong>.</p> </dd><dt><a name="agent_ni_req_limit"></a> <strong>req_limit() = integer() | infinity &lt;optional&gt;</strong></dt><dd> <p>Max number of simultaneous requests handled by the agent.</p> <p>Default is <strong>infinity</strong>.</p> </dd><dt><a name="agent_ni_filter_opts"></a> <strong>agent_net_if_filter_options() = [agent_net_if_filter_option()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_net_if_filter_option() = {module, agent_net_if_filter_module()}</strong></p> <p>These options are actually specific to the used module.
The ones shown here are applicable to the default 
<strong>agent_net_if_filter_module()</strong>.</p> <p>For defaults see the options in <strong>agent_net_if_filter_option()</strong>.</p> </dd><dt><a name="agent_ni_filter_module"></a> <strong>agent_net_if_filter_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>Module which handles the network interface filter part for the
SNMP agent. Must implement the 
<a href="snmpa_network_interface_filter">snmpa_network_interface_filter </a> behaviour.</p> <p>Default is <strong>snmpa_net_if_filter</strong>.</p> </dd><dt><a name="agent_mibs"></a> <strong>agent_mibs() = [string()] &lt;optional&gt;</strong></dt><dd> <p>Specifies a list of MIBs (including path) that defines which MIBs
are initially loaded into the SNMP master agent. </p> <p>Note that the following will always be loaded:</p> <ul><li>version v1: <strong>STANDARD-MIB</strong></li><li>version v2: <strong>SNMPv2</strong></li><li>version v3: <strong>SNMPv2</strong>, <strong>SNMP-FRAMEWORK-MIB</strong>  and <strong>SNMP-MPD-MIB</strong></li></ul> <p>Default is <strong>[]</strong>.</p> </dd><dt><a name="agent_mib_storage"></a> <strong>mib_storage() = [mib_storage_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>mib_storage_opt() = {module, mib_storage_module()} |  {options, mib_storage_options()}</strong></p> <p>This option specifies how basic mib data is stored. 
This option is used by two parts of the snmp agent: 
The mib-server and the symbolic-store. </p> <p>Default is <strong>[{module, snmpa_mib_storage_ets}]</strong>. </p> </dd><dt><a name="agent_mst_module"></a> <strong>mib_storage_module() = snmpa_mib_data_ets | snmpa_mib_data_dets | snmpa_mib_data_mnesia | module()</strong></dt><dd> <p>Defines the mib storage module of the SNMP agent as defined by the 
<a href="snmpa_mib_storage">snmpa_mib_storage</a> 
behaviour. </p> <p>Several entities (<strong>mib-server</strong> via the its data module and 
the <strong>symbolic-store</strong>) of the snmp agent uses this for storage 
of miscelaneous mib related data dataretrieved while loading a mib. </p> <p>There are several implementations provided with the agent: 
<strong>snmpa_mib_storage_ets</strong>, <strong>snmpa_mib_storage_dets</strong> and 
<strong>snmpa_mib_storage_mnesia</strong>. </p> <p>Default module is <strong>snmpa_mib_storage_ets</strong>. </p> </dd><dt><a name="agent_mst_options"></a> <strong>mib_storage_options() = list() &lt;optional&gt;</strong></dt><dd> <p>This is implementattion depended. That is, it depends on the 
module. For each module a specific set of options are valid. 
For the module provided with the app, these options are supported: </p> <ul><li> <p><strong>snmpa_mib_storage_ets</strong>: <strong>{dir, filename()} | {action, keep | clear}, {checksum, boolean()}</strong></p> <ul><li> <p><strong>dir</strong> - If present, points to a directory where a file 
to which all data in the ets table is "synced". </p> <p>Also, when a table is opened this file is read, 
if it exists. </p> <p>By default, this will <em>not</em> be used. </p>  </li><li> <p><strong>action</strong> - Specifies the behaviour when a non-empty 
file is found: Keep its content or clear it out. </p> <p>Default is <strong>keep</strong>. </p>  </li><li> <p><strong>checksum</strong> - Defines if the file is checksummed 
or not. </p> <p>Default is <strong>false</strong>. </p>  </li></ul> </li><li> <p><strong>snmpa_mib_storage_dets</strong>: <strong>{dir, filename()} | {action, keep | clear}, {auto_save, default | pos_integer()} | {repair, force | boolean()}</strong></p> <ul><li> <p><strong>dir</strong> - This <em>mandatory</em> option points to a 
directory where to place the file of a dets table. </p> </li><li> <p><strong>action</strong> - Specifies the behaviour when a non-empty 
file is found: Keep its content or clear it out. </p> <p>Default is <strong>keep</strong>. </p>  </li><li> <p><strong>auto_save</strong> - Defines the dets auto-save frequency. </p> <p>Default is <strong>default</strong>. </p>  </li><li> <p><strong>repair</strong> - Defines the dets repair behaviour. </p> <p>Default is <strong>false</strong>. </p>  </li></ul> </li><li> <p><strong>snmpa_mib_storage_mnesia</strong>: <strong>{action, keep | clear}, {nodes, [node()]}</strong></p> <ul><li> <p><strong>action</strong> - Specifies the behaviour when a non-empty, 
already existing, table: Keep its content or clear it out. </p> <p>Default is <strong>keep</strong>. </p> </li><li> <p><strong>nodes</strong> - A list of node names (or an atom 
describing a list of nodes) defining where to open the table. 
Its up to the user to ensure that mnesia is actually running 
on the specified nodes. </p> <p>The following distinct values are recognised: </p> <ul><li> <p><strong>[]</strong> - Translated into a list of the own node: <strong>[node()]</strong></p> </li><li> <p><strong>all</strong> - <strong>erlang:nodes()</strong></p> </li><li> <p><strong>visible</strong> - <strong>erlang:nodes(visible)</strong></p> </li><li> <p><strong>connected</strong> - <strong>erlang:nodes(connected)</strong></p> </li><li> <p><strong>db_nodes</strong> - <strong>mnesia:system_info(db_nodes)</strong></p> </li></ul> <p>Default is the result of the call: <strong>erlang:nodes()</strong>. </p> </li></ul> </li></ul> </dd><dt><a name="agent_mib_server"></a> <strong>mib_server() = [mib_server_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>mib_server_opt() = {mibentry_override, mibentry_override()} |  {trapentry_override, trapentry_override()} |  {verbosity, verbosity()} | {cache, mibs_cache()} | {data_module, mib_server_data_module()}</strong></p> <p>Defines options specific for the SNMP agent mib server. </p> <p>For defaults see the options in <strong>mib_server_opt()</strong>.</p> </dd><dt><a name="agent_ms_meo"></a> <strong>mibentry_override() = bool() &lt;optional&gt;</strong></dt><dd> <p>If this value is false, then when loading a mib each mib-
entry is checked prior to installation of the mib. 
The purpose of the check is to prevent that the same symbolic 
mibentry name is used for different oid's.</p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="agent_ms_teo"></a> <strong>trapentry_override() = bool() &lt;optional&gt;</strong></dt><dd> <p>If this value is false, then when loading a mib each trap
is checked prior to installation of the mib. 
The purpose of the check is to prevent that the same symbolic 
trap name is used for different trap's.</p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="agent_ms_data_module"></a> <strong>mib_server_data_module() = snmpa_mib_data_tttn | module() &lt;optional&gt;</strong></dt><dd> <p>Defines the backend data module of the SNMP agent mib-server as 
defined by the 
<a href="snmpa_mib_data">snmpa_mib_data</a> 
behaviour. </p> <p>At present only the default module is provided with the agent,  
<strong>snmpa_mib_data_tttn</strong>. </p> <p>Default module is <strong>snmpa_mib_data_tttn</strong>. </p> </dd><dt><a name="agent_ms_cache"></a> <strong>mibs_cache() = bool() | mibs_cache_opts() &lt;optional&gt;</strong></dt><dd> <p>Shall the agent utilize the mib server lookup cache or not.</p> <p>Default is <strong>true</strong> (in which case the <strong>mibs_cache_opts()</strong> 
default values apply).</p> </dd><dt><a name="agent_ms_cache_opts"></a> <strong>mibs_cache_opts() = [mibs_cache_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>mibs_cache_opt() = {autogc, mibs_cache_autogc()} | {gclimit, mibs_cache_gclimit()} | {age, mibs_cache_age()}</strong></p> <p>Defines options specific for the SNMP agent mib server cache. </p> <p>For defaults see the options in <strong>mibs_cache_opt()</strong>.</p> </dd><dt><a name="agent_ms_cache_autogc"></a> <strong>mibs_cache_autogc() = bool() &lt;optional&gt;</strong></dt><dd> <p>Defines if the mib server shall perform cache gc automatically or 
leave it to the user (see 
<a href="./snmpa#gc_mibs_cache">gc_mibs_cache/0,1,2,3</a>). </p> <p>Default is <strong>true</strong>.</p> </dd><dt><a name="agent_ms_cache_age"></a> <strong>mibs_cache_age() = integer() &gt; 0 &lt;optional&gt;</strong></dt><dd> <p>Defines how old the entries in the cache will be allowed 
to become before they are GC'ed (assuming GC is performed). 
Each entry in the cache is "touched" whenever it is accessed. </p> <p>The age is defined in milliseconds. </p> <p>Default is <strong>10 timutes</strong>.</p> </dd><dt><a name="agent_ms_cache_gclimit"></a> <strong>mibs_cache_gclimit() = integer() &gt; 0 | infinity &lt;optional&gt;</strong></dt><dd> <p>When performing a GC, this is the max number of cache entries 
that will be deleted from the cache. </p> <p>The reason for having this limit is that if the cache is 
large, the GC can potentially take a long time, during which 
the agent is locked. </p> <p>Default is <strong>100</strong>.</p> </dd><dt><a name="agent_error_report_mod"></a> <strong>error_report_mod() = atom() &lt;optional&gt;</strong></dt><dd> <p>Defines an error report module, implementing the 
<a href="snmpa_error_report">snmpa_error_report</a> 
behaviour. Two modules are provided with the toolkit: 
<strong>snmpa_error_logger</strong> and <strong>snmpa_error_io</strong>.</p> <p>Default is <strong>snmpa_error_logger</strong>.</p> </dd><dt><a name="agent_symbolic_store"></a> <strong>symbolic_store() = [symbolic_store_opt()]</strong></dt><dd> <p><strong>symbolic_store_opt() = {verbosity, verbosity()}</strong></p> <p>Defines options specific for the SNMP agent symbolic store. </p> <p>For defaults see the options in <strong>symbolic_store_opt()</strong>.</p> </dd><dt><a name="agent_target_cache"></a> <strong>target_cache() = [target_cache_opt()]</strong></dt><dd> <p><strong>target_cache_opt() = {verbosity, verbosity()}</strong></p> <p>Defines options specific for the SNMP agent target cache. </p> <p>For defaults see the options in <strong>target_cache_opt()</strong>.</p> </dd><dt><a name="agent_config"></a> <strong>agent_config() = [agent_config_opt()] &lt;mandatory&gt;</strong></dt><dd> <p><strong>agent_config_opt() = {dir, agent_config_dir()} |  {force_load, force_load()} | {verbosity, verbosity()}</strong></p> <p>Defines specific config related options for the SNMP agent. </p> <p>For defaults see the options in <strong>agent_config_opt()</strong>.</p> </dd><dt><a name="agent_config_dir"></a> <strong>agent_config_dir = dir() &lt;mandatory&gt;</strong></dt><dd> <p>Defines where the SNMP agent configuration files are stored.</p> </dd><dt><a name="agent_force_load"></a> <strong>force_load() = bool() &lt;optional&gt;</strong></dt><dd> <p>If <strong>true</strong> the configuration files are re-read
during start-up, and the contents of the configuration 
database ignored.  Thus, if <strong>true</strong>, changes to 
the configuration database are lost upon reboot of the 
agent. </p> <p>Default is <strong>false</strong>.</p> </dd></dl><a name="manager_opts_and_types"></a><p>Manager specific config options and types:</p><dl><dt><a name="manager_server"></a> <strong>server() = [server_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>server_opt() = {timeout, server_timeout()} |  {verbosity, verbosity()}</strong></p> <p>Specifies the options for the manager server process.</p> <p>Default is <strong>silence</strong>.</p> </dd><dt><a name="manager_server_timeout"></a> <strong>server_timeout() = integer() &lt;optional&gt;</strong></dt><dd> <p>Asynchronous request cleanup time. For every requests,
some info is stored internally, in order to be able to 
deliver the reply (when it arrives) to the proper destination.
If the reply arrives, this info will be deleted. But if
there is no reply (in time), the info has to be deleted
after the <em>best before</em> time has been passed.
This cleanup will be performed at regular intervals, defined 
by the <strong>server_timeout()</strong> time.
The information will have a <em>best before</em> time,
defined by the <strong>Expire</strong> time given when calling the
request function (see 
<a href="./snmpm#async_get">async_get</a>,
<a href="./snmpm#async_get_next">async_get_next</a> and 
<a href="./snmpm#async_set">async_set</a>).</p> <p>Time in milli-seconds.</p> <p>Default is <strong>30000</strong>.</p> </dd><dt><a name="manager_config"></a> <strong>manager_config() = [manager_config_opt()] &lt;mandatory&gt;</strong></dt><dd> <p><strong>manager_config_opt() = {dir, manager_config_dir()} |  {db_dir, manager_db_dir()} |  {db_init_error, db_init_error()} |  {repair, manager_repair()} |  {auto_save, manager_auto_save()} |  {verbosity, verbosity()}</strong></p> <p>Defines specific config related options for the SNMP manager. </p> <p>For defaults see the options in <strong>manager_config_opt()</strong>.</p> </dd><dt><a name="manager_config_dir"></a> <strong>manager_config_dir = dir() &lt;mandatory&gt;</strong></dt><dd> <p>Defines where the SNMP manager configuration files are stored.</p> </dd><dt><a name="manager_config_db_dir"></a> <strong>manager_db_dir = dir() &lt;mandatory&gt;</strong></dt><dd> <p>Defines where the SNMP manager store persistent data.</p> </dd><dt><a name="manager_config_repair"></a> <strong>manager_repair() = false | true | force &lt;optional&gt;</strong></dt><dd> <p>Defines the repair option for the persistent database (if 
and how the table is repaired when opened). </p> <p>Default is <strong>true</strong>.</p> </dd><dt><a name="manager_config_auto_save"></a> <strong>manager_auto_save() = integer() | infinity &lt;optional&gt;</strong></dt><dd> <p>The auto save interval. The table is flushed to disk
whenever not accessed for this amount of time.</p> <p>Default is <strong>5000</strong>.</p> </dd><dt><a name="manager_irb"></a> <strong>manager_irb() = auto | user | {user, integer()} &lt;optional&gt;</strong></dt><dd> <p>This option defines how the manager will handle the sending of 
response (acknowledgment) to received inform-requests. </p> <ul><li> <p><strong>auto</strong> - The manager will autonomously send response
(acknowledgment&gt; to inform-request messages.</p> </li><li> <p><strong>{user, integer()}</strong> - The manager will send response
(acknowledgment) to inform-request messages when the 
<a href="./snmpm_user#handle_inform">handle_inform</a> 
function completes. The integer is the time, in milli-seconds, 
that the manager will consider the stored inform-request info 
valid.</p> </li><li> <p><strong>user</strong> - Same as <strong>{user, integer()}</strong>, except that 
the default time, 15000 milli-seconds, is used.</p> </li></ul> <p>See 
<a href="snmpm_network_interface">snmpm_network_interface</a>, 
<a href="snmpm_user">handle_inform</a> and 
<a href="snmp_manager_netif">definition of the manager net if</a> for more info.</p> <p>Default is <strong>auto</strong>.</p> </dd><dt><a name="manager_mibs"></a> <strong>manager_mibs() = [string()] &lt;optional&gt;</strong></dt><dd> <p>Specifies a list of MIBs (including path) and defines which MIBs
are initially loaded into the SNMP manager. </p> <p>Default is <strong>[]</strong>.</p> </dd><dt><a name="manager_net_if"></a> <strong>manager_net_if() = [manager_net_if_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>manager_net_if_opt() = {module, manager_net_if_module()} |  {verbosity, verbosity()} |  {options, manager_net_if_options()}</strong></p> <p>Defines options specific for the SNMP manager network interface 
entity. </p> <p>For defaults see the options in <strong>manager_net_if_opt()</strong>.</p> </dd><dt><a name="manager_ni_opts"></a> <strong>manager_net_if_options() = [manager_net_if_option()] &lt;optional&gt;</strong></dt><dd> <p><strong>manager_net_if_option() = {bind_to, bind_to()} |  {sndbuf, sndbuf()} |  {recbuf, recbuf()} |  {no_reuse, no_reuse()} | {filter, manager_net_if_filter_options()}</strong></p> <p>These options are actually specific to the used module.
The ones shown here are applicable to the default 
<strong>manager_net_if_module()</strong>. </p> <p>For defaults see the options in <strong>manager_net_if_option()</strong>.</p> </dd><dt><a name="manager_ni_module"></a> <strong>manager_net_if_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>The module which handles the network interface part for the
SNMP manager. It must implement the 
<a href="snmpm_network_interface">snmpm_network_interface</a> behaviour. </p> <p>Default is <strong>snmpm_net_if</strong>. </p> </dd><dt><a name="manager_ni_filter_opts"></a> <strong>manager_net_if_filter_options() = [manager_net_if_filter_option()] &lt;optional&gt;</strong></dt><dd> <p><strong>manager_net_if_filter_option() = {module, manager_net_if_filter_module()}</strong></p> <p>These options are actually specific to the used module.
The ones shown here are applicable to the default 
<strong>manager_net_if_filter_module()</strong>.</p> <p>For defaults see the options in 
<strong>manager_net_if_filter_option()</strong>.</p> </dd><dt><a name="manager_ni_filter_module"></a> <strong>manager_net_if_filter_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>Module which handles the network interface filter part for the
SNMP manager. Must implement the 
<a href="snmpm_network_interface_filter">snmpm_network_interface_filter</a> behaviour.</p> <p>Default is <strong>snmpm_net_if_filter</strong>.</p> </dd><dt><a name="manager_def_user_module"></a> <strong>def_user_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>The module implementing the default user. See the 
<a href="snmpm_user">snmpm_user</a> behaviour.</p> <p>Default is <strong>snmpm_user_default</strong>.</p> </dd><dt><a name="manager_def_user_data"></a> <strong>def_user_data() = term() &lt;optional&gt;</strong></dt><dd> <p>Data for the default user. Passed to the user when calling 
the callback functions.</p> <p>Default is <strong>undefined</strong>.</p> </dd></dl><a name="common_types"></a><p>Common config types:</p><dl><dt><a name="restart_type"></a> <strong>restart_type() = permanent | transient | temporary</strong></dt><dd> <p>See <a href="../stdlib/supervisor#child_spec">supervisor</a> 
documentation for more info.</p> <p>Default is <strong>permanent</strong> for the agent and <strong>transient</strong>
for the manager.</p> </dd><dt><a name="db_init_error"></a> <strong>db_init_error() = terminate | create | create_db_and_dir</strong></dt><dd> <p>Defines what to do if the agent is unable to open an
existing database file. <strong>terminate</strong> means that the
agent/manager will terminate, <strong>create</strong> means that the 
agent/manager will remove the faulty file(s) and create new ones,
and <strong>create_db_and_dir</strong> means that the agent/manager will
create the database file along with any missing parent directories
for the database file.</p> <p>Default is <strong>terminate</strong>.</p> </dd><dt><a name="prio"></a> <strong>priority() = atom() &lt;optional&gt;</strong></dt><dd> <p>Defines the Erlang priority for all SNMP processes.</p> <p>Default is <strong>normal</strong>.</p> </dd><dt><a name="versions"></a> <strong>versions() = [version()] &lt;optional&gt;</strong></dt><dd> <p><strong>version() = v1 | v2 | v3</strong></p> <p>Which SNMP versions shall be accepted/used.</p> <p>Default is <strong>[v1,v2,v3]</strong>.</p> </dd><dt><a name="verbosity"></a> <strong>verbosity() = silence | info | log | debug | trace &lt;optional&gt;</strong></dt><dd> <p>Verbosity for a SNMP process. This specifies now much debug info
is printed.</p> <p>Default is <strong>silence</strong>.</p> </dd><dt><a name="bind_to"></a> <strong>bind_to() = bool() &lt;optional&gt;</strong></dt><dd> <p>If <strong>true</strong>, net_if binds to the IP address.
If <strong>false</strong>, net_if listens on any IP address on the host
where it is running. </p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="no_reuse"></a> <strong>no_reuse() = bool() &lt;optional&gt;</strong></dt><dd> <p>If <strong>true</strong>, net_if does not specify that the IP
and port address should be reusable. If <strong>false</strong>, 
the address is set to reusable. </p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="recbuf"></a> <strong>recbuf() = integer() &lt;optional&gt;</strong></dt><dd> <p>Receive buffer size. </p> <p>Default value is defined by <strong>gen_udp</strong>.</p> </dd><dt><a name="sndbuf"></a> <strong>sndbuf() = integer() &lt;optional&gt;</strong></dt><dd> <p>Send buffer size. </p> <p>Default value is defined by <strong>gen_udp</strong>.</p> </dd><dt><a name="note_store"></a> <strong>note_store() = [note_store_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>note_store_opt() = {timeout, note_store_timeout()} |  {verbosity, verbosity()}</strong></p> <p>Specifies the options for the SNMP note store.</p> <p>For defaults see the options in <strong>note_store_opt()</strong>.</p> </dd><dt><a name="ns_timeout"></a> <strong>note_store_timeout() = integer() &lt;optional&gt;</strong></dt><dd> <p>Note cleanup time. When storing a note in the note store,
each note is given lifetime. Every <strong>timeout</strong> the note_store
process performs a GC to remove the expired note's. Time in
milli-seconds.</p> <p>Default is <strong>30000</strong>.</p> </dd><dt><a name="audit_trail_log"></a> <strong>audit_trail_log() [audit_trail_log_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>audit_trail_log_opt() = {type, atl_type()} | {dir, atl_dir()} |  {size, atl_size()} |  {repair, atl_repair()} | {seqno, atl_seqno()}</strong></p> <p>If present, this option specifies the options for the 
<em>audit trail logging</em>. The <strong>disk_log</strong> module is used 
to maintain a wrap log. If present, the <strong>dir</strong> and 
<strong>size</strong> options are mandatory.</p> <p>If not present, audit trail logging is not used.</p> </dd><dt><a name="atl_type"></a> <strong>atl_type() = read | write | read_write &lt;optional&gt;</strong></dt><dd> <p>Specifies what type of an audit trail log should be used. 
The effect of the type is actually different for the the agent
and the manager. </p> <p>For the agent:</p> <ul><li>If <strong>write</strong> is specified, only set requests are logged.  </li><li>If <strong>read</strong> is specified, only get requests are logged.  </li><li>If <strong>read_write</strong>, all requests are logged.  </li></ul> <p>For the manager:</p> <ul><li>If <strong>write</strong> is specified, only sent messages are logged.  </li><li>If <strong>read</strong> is specified, only received messages are logged.  </li><li>If <strong>read_write</strong>, both outgoing and incoming messages are  logged.  </li></ul> <p>Default is <strong>read_write</strong>.</p> </dd><dt><a name="atl_dir"></a> <strong>atl_dir = dir() &lt;mandatory&gt;</strong></dt><dd> <p>Specifies where the audit trail log should be stored.</p> <p>If <strong>audit_trail_log</strong> specifies that logging should take
place, this parameter <em>must</em> be defined.</p> </dd><dt><a name="atl_size"></a> <strong>atl_size() = {integer(), integer()} &lt;mandatory&gt;</strong></dt><dd> <p>Specifies the size of the audit
trail log.  This parameter is sent to <strong>disk_log</strong>.  </p> <p>If <strong>audit_trail_log</strong> specifies that logging should 
take place, this parameter <em>must</em> be defined.</p> </dd><dt><a name="atl_repair"></a> <strong>atl_repair() = true | false | truncate | snmp_repair &lt;optional&gt;</strong></dt><dd> <p>Specifies if and how the audit trail log shall be repaired
when opened. Unless this parameter has the value <strong>snmp_repair</strong>
it is sent to <strong>disk_log</strong>. If, on the other hand, the value is
<strong>snmp_repair</strong>, snmp attempts to handle certain faults on its
own. And even if it cannot repair the file, it does not truncate it 
directly, but instead <em>moves it aside</em> for later off-line 
analysis.</p> <p>Default is <strong>true</strong>.</p> </dd><dt><a name="atl_seqno"></a> <strong>atl_seqno() = true | false &lt;optional&gt;</strong></dt><dd> <p>Specifies if the audit trail log entries will be (sequence)
numbered or not. The range of the sequence numbers are according
to RFC 5424, i.e. 1 through 2147483647. </p> <p>Default is <strong>false</strong>.</p> </dd></dl><h4>Modifying the Configuration Files</h4><p>To to start the application (agent and/or manager), the 
configuration files must be modified and there are two ways 
of doing this. Either edit the files manually, or run the 
configuration tool as follows.</p><p>If authentication or encryption is used (SNMPv3 only), start
the <strong>crypto</strong> application.</p><pre>
1&gt; snmp:config().

Simple SNMP configuration tool (version 4.0)
------------------------------------------------
Note: Non-trivial configurations still has to be
      done manually. IP addresses may be entered 
      as dront.ericsson.se (UNIX only) or
      123.12.13.23
------------------------------------------------

Configure an agent (y/n)? [y] 

Agent system config: 
--------------------
1. Agent process priority (low/normal/high) [normal] 
2. What SNMP version(s) should be used (1,2,3,1&amp;2,1&amp;2&amp;3,2&amp;3)? [3] 1&amp;2&amp;3
3. Configuration directory (absolute path)? [/ldisk/snmp] /ldisk/snmp/agent/conf
4. Config verbosity (silence/info/log/debug/trace)? [silence] 
5. Database directory (absolute path)? [/ldisk/snmp] /ldisk/snmp/agent/db
6. Mib storage type (ets/dets/mnesia)? [ets] 
7. Target cache verbosity (silence/info/log/debug/trace)? [silence] 
8. Symbolic store verbosity (silence/info/log/debug/trace)? [silence] 
9. Local DB verbosity (silence/info/log/debug/trace)? [silence] 
10. Local DB repair (true/false/force)? [true] 
11. Local DB auto save (infinity/milli seconds)? [5000] 
12. Error report module? [snmpa_error_logger] 
13. Agent type (master/sub)? [master] 
14. Master-agent verbosity (silence/info/log/debug/trace)? [silence] log
15. Shall the agent re-read the configuration files during startup 
    (and ignore the configuration database) (true/false)? [true] 
16. Multi threaded agent (true/false)? [false] true
17. Check for duplicate mib entries when installing a mib (true/false)? [false] 
18. Check for duplicate trap names when installing a mib (true/false)? [false] 
19. Mib server verbosity (silence/info/log/debug/trace)? [silence] 
20. Mib server cache (true/false)? [true]
21. Note store verbosity (silence/info/log/debug/trace)? [silence] 
22. Note store GC timeout? [30000] 
23. Shall the agent use an audit trail log (y/n)? [n] y
23b. Audit trail log type (write/read_write)? [read_write] 
23c. Where to store the audit trail log? [/ldisk/snmp] /ldisk/snmp/agent/log
23d. Max number of files? [10] 
23e. Max size (in bytes) of each file? [10240] 
23f. Audit trail log repair (true/false/truncate)? [true] 
24. Which network interface module shall be used? [snmpa_net_if] 
25. Network interface verbosity (silence/info/log/debug/trace)? [silence] log
25a. Bind the agent IP address (true/false)? [false] 
25b. Shall the agents IP address and port be not reusable (true/false)? [false] 
25c. Agent request limit (used for flow control) (infinity/pos integer)? [infinity] 32
25d. Receive buffer size of the agent (in bytes) (default/pos integer)? [default] 
25e. Send buffer size of the agent (in bytes) (default/pos integer)? [default]
25f. Do you wish to specify a network interface filter module (or use default) [default] 

Agent snmp config: 
------------------
1. System name (sysName standard variable) [bmk's agent] 
2. Engine ID (snmpEngineID standard variable) [bmk's engine] 
3. Max message size? [484] 
4. The UDP port the agent listens to. (standard 161) [4000] 
5. IP address for the agent (only used as id 
   when sending traps) [127.0.0.1] 
6. IP address for the manager (only this manager 
   will have access to the agent, traps are sent 
   to this one) [127.0.0.1] 
7. To what UDP port at the manager should traps 
   be sent (standard 162)? [5000] 
8. Do you want a none- minimum- or semi-secure configuration? 
   Note that if you chose v1 or v2, you won't get any security for these
   requests (none, minimum, semi_des, semi_aes) [minimum] 
making sure crypto server is started...
8b. Give a password of at least length 8. It is used to generate 
    private keys for the configuration:  kalle-anka
9. Current configuration files will now be overwritten. Ok (y/n)? [y] 

- - - - - - - - - - - - -
Info: 1. SecurityName "initial" has noAuthNoPriv read access
         and authenticated write access to the "restricted"
         subtree.
      2. SecurityName "all-rights" has noAuthNoPriv read/write
         access to the "internet" subtree.
      3. Standard traps are sent to the manager.
      4. Community "public" is mapped to security name "initial".
      5. Community "all-rights" is mapped to security name "all-rights".
The following agent files were written: agent.conf, community.conf,
standard.conf, target_addr.conf, target_params.conf, 
notify.conf, vacm.conf and usm.conf
- - - - - - - - - - - - -

Configure a manager (y/n)? [y] 

Manager system config: 
----------------------
1. Manager process priority (low/normal/high) [normal] 
2. What SNMP version(s) should be used (1,2,3,1&amp;2,1&amp;2&amp;3,2&amp;3)? [3] 1&amp;2&amp;3
3. Configuration directory (absolute path)? [/ldisk/snmp] /ldisk/snmp/manager/conf
4. Config verbosity (silence/info/log/debug/trace)? [silence] log
5. Database directory (absolute path)? [/ldisk/snmp] /ldisk/snmp/manager/db
6. Database repair (true/false/force)? [true] 
7. Database auto save (infinity/milli seconds)? [5000] 
8. Inform request behaviour (auto/user)? [auto] 
9. Server verbosity (silence/info/log/debug/trace)? [silence] log
10. Server GC timeout? [30000] 
11. Note store verbosity (silence/info/log/debug/trace)? [silence] 
12. Note store GC timeout? [30000] 
13. Which network interface module shall be used? [snmpm_net_if] 
14. Network interface verbosity (silence/info/log/debug/trace)? [silence] log
15. Bind the manager IP address (true/false)? [false] 
16. Shall the manager IP address and port be not reusable (true/false)? [false] 
17. Receive buffer size of the manager (in bytes) (default/pos integer)? [default] 
18. Send buffer size of the manager (in bytes) (default/pos integer)? [default] 
19. Shall the manager use an audit trail log (y/n)? [n] y
19b. Where to store the audit trail log? [/ldisk/snmp] /ldisk/snmp/manager/log
19c. Max number of files? [10] 
19d. Max size (in bytes) of each file? [10240] 
19e. Audit trail log repair (true/false/truncate)? [true] 
20. Do you wish to assign a default user [yes] or use
    the default settings [no] (y/n)? [n] 

Manager snmp config: 
--------------------
1. Engine ID (snmpEngineID standard variable) [bmk's engine] 
2. Max message size? [484] 
3. IP address for the manager (only used as id 
   when sending requests) [127.0.0.1] 
4. Port number (standard 162)? [5000] 
5. Configure a user of this manager (y/n)? [y] 
5b. User id? kalle
5c. User callback module? snmpm_user_default
5d. User (callback) data? [undefined] 
5. Configure a user of this manager (y/n)? [y] n
6. Configure an agent handled by this manager (y/n)? [y] 
6b. User id? kalle
6c. Target name? [bmk's agent] 
6d. Version (1/2/3)? [1] 3
6e. Community string ? [public] 
6f. Engine ID (snmpEngineID standard variable) [bmk's engine] 
6g. IP address for the agent [127.0.0.1] 
6h. The UDP port the agent listens to. (standard 161) [4000] 
6i. Retransmission timeout (infinity/pos integer)? [infinity] 
6j. Max message size? [484] 
6k. Security model (any/v1/v2c/usm)? [any] usm
6l. Security name? ["initial"] 
6m. Security level (noAuthNoPriv/authNoPriv/authPriv)? [noAuthNoPriv] authPriv
6. Configure an agent handled by this manager (y/n)? [y] n
7. Configure an usm user handled by this manager (y/n)? [y] 
7a. Engine ID [bmk's engine] 
7b. User name? hobbes
7c. Security name? [hobbes] 
7d. Authentication protocol (no/sha/md5)? [no] sha
7e  Authentication [sha] key (length 0 or 20)? [""] [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16, \
    17,18,19,20]
7d. Priv protocol (no/des/aes)? [no] des
7f  Priv [des] key (length 0 or 16)? [""] 10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25
7. Configure an usm user handled by this manager (y/n)? [y] n
8. Current configuration files will now be overwritten. Ok (y/n)? [y] 

- - - - - - - - - - - - -
The following manager files were written: manager.conf, agents.conf , users.conf and usm.conf
- - - - - - - - - - - - -

--------------------
Configuration directory for system file (absolute path)? [/ldisk/snmp] 
ok
    </pre><h4>Starting the application</h4><p>Start Erlang with the command:</p><pre><code class="">
erl -config /tmp/snmp/sys
    </code></pre><p>If authentication or encryption is used (SNMPv3 only), start
the <strong>crypto</strong> application.  If this step is forgotten, the
agent will not start, but report a
<strong>{config_error,{unsupported_crypto,_}}</strong> error.</p><pre>
1&gt; <span class="input">application:start(crypto).</span>
ok
    </pre><pre>
2&gt; <span class="input">application:start(snmp).</span>
ok
    </pre><a name="verbosity"></a><h4>Debugging the application</h4><p>It is possible to debug every (non-supervisor) process of the 
application (both agent and manager), possibly with the exception 
of the net_if module(s), which could be supplied by a user of the 
application). This is done by calling the 
<strong>snmpa:verbosity/2</strong> and <strong>snmpm:verbosity/2</strong> function(s) 
and/or using 
<a href="#configuration_params">configuration parameters</a>.
The verbosity itself has several <em>levels</em>: <strong>silence | info |  log | debug | trace</strong>. For the lowest verbosity <strong>silence</strong>, 
nothing is printed. The higher the verbosity, the more is printed.
Default value is always <strong>silence</strong>.</p><pre>
3&gt; <span class="input">snmpa:verbosity(master_agent, log).</span>
ok
5&gt; <span class="input">snmpa:verbosity(net_if, log).</span>
ok
6&gt; 
%% Example of output from the agent when a get-next-request arrives:
** SNMP NET-IF LOG: 
   got packet from {147,12,12,12}:5000

** SNMP NET-IF MPD LOG: 
   v1, community: all-rights

** SNMP NET-IF LOG: 
   got pdu from {147,12,12,12}:5000 {pdu, 'get-next-request',
                                          62612569,noError,0,
                                          [{varbind,[1,1],'NULL','NULL',1}]}

** SNMP MASTER-AGENT LOG: 
   apply: snmp_generic,variable_func,[get,{sysDescr,persistent}]

** SNMP MASTER-AGENT LOG: 
   returned: {value,"Erlang SNMP agent"}

** SNMP NET-IF LOG: 
   reply pdu: {pdu,'get-response',62612569,noError,0,
                   [{varbind,[1,3,6,1,2,1,1,1,0],
                             'OCTET STRING',
                             "Erlang SNMP agent",1}]}

** SNMP NET-IF INFO: time in agent: 19711 mysec
    </pre><p>Other useful function(s) for debugging the agent are: </p><dl><dt><strong>snmpa:info/0,1</strong></dt><dd> <p><a href="./snmpa#info">info</a> is used to retrieve a list of miscellaneous agent information.</p> </dd><dt><strong>snmpa:which_aliasnames/0</strong></dt><dd> <p><a href="./snmpa#which_aliasnames">which_aliasnames</a> is used to retrieve a list of all alias-names known to the agent. </p> </dd><dt><strong>snmpa:which_tables/0</strong></dt><dd> <p><a href="./snmpa#which_tables">which_tables</a> is used to retrieve a list of all (MIB) tables known to the agent. </p> </dd><dt><strong>snmpa:which_variables/0</strong></dt><dd> <p><a href="./snmpa#which_variables">which_variables</a> is used to retrieve a list of all (MIB) variables known to the agent. </p> </dd><dt><strong>snmpa:which_notifications/0</strong></dt><dd> <p><a href="./snmpa#which_notifications">which_notifications</a> is used to retrieve a list of all (MIB) notifications/traps known to the agent. </p> </dd><dt><strong>snmpa:restart_worker/0,1</strong></dt><dd> <p><a href="./snmpa#restart_worker">restart_worker</a> is used to restart the worker process of a multi-threaded agent. </p> </dd><dt><strong>snmpa:restart_set_worker/0,1</strong></dt><dd> <p><a href="./snmpa#restart_set_worker">restart_set_worker</a> is used to restart the set-worker process of a multi-threaded agent. </p> </dd><dt><strong>snmpa_local_db:print/0,1,2</strong></dt><dd> <p>For example, this function can show the counters 
<strong>snmpInPkts</strong> and <strong>snmpOutPkts</strong>.</p> </dd></dl><p>Another usefull way to debug the agent is to pretty-print the content of 
all the tables and/or variables handled directly by the agent. 
This can be done by simply calling: </p><p><strong>snmpa:print_mib_info()</strong></p><p>See 
<a href="./snmpa#print_mib_info">print_mib_info/0</a>, 
<a href="./snmpa#print_mib_tables">print_mib_tables/0</a>
or
<a href="./snmpa#print_mib_variables">print_mib_variables/0</a> 
for more info. </p><p>All configuration data must be included in configuration files
that are located in the configuration directory. The name of this
directory is given in the <strong>config_dir</strong> configuration
parameter.  These files are read at start-up, and are used to
initialize the SNMPv2-MIB or STANDARD-MIB, SNMP-FRAMEWORK-MIB,
SNMP-MPD-MIB, SNMP-VIEW-BASED-ACM-MIB, SNMP-COMMUNITY-MIB,
SNMP-USER-BASED-SM-MIB, SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB
(refer to the 
<a href="./snmp_agent_funct_descr#management">Management of the Agent</a> 
for a description of the MIBs). </p><p>The files are: </p><ul><li> <p><strong>agent.conf</strong>: see 
<a href="#agent_information">Agent Information</a></p> </li><li> <p><strong>standard.conf</strong>: see 
<a href="#system_information">System Information</a></p> </li><li> <p><strong>context.conf</strong>: see 
<a href="#context">Contexts</a></p> </li><li> <p><strong>community.conf</strong>: see 
<a href="#community">Communities</a></p> </li><li> <p><strong>target_addr.conf</strong>: see 
<a href="#target_addr">Target Address Definitions</a></p> </li><li> <p><strong>target_params.conf</strong>: see 
<a href="#target_params">Target Parameters Definitions</a></p> </li><li> <p><strong>vacm.conf</strong>: see 
<a href="#vacm">MIB Views for VACM</a></p> </li><li> <p><strong>usm.conf</strong>: see 
<a href="#usm">Security data for USM</a></p> </li><li> <p><strong>notify.conf</strong>: see 
<a href="#notify">Notify Definitions</a></p> </li></ul><p>The directory where the configuration files are found is given as
a parameter to the agent. </p><p>The entry format in all files are Erlang terms, separated by a
'<em>.</em>' and a <em>newline</em>. In the following sections, the
formats of these terms are described. Comments may be specified as
ordinary Erlang comments. </p><p>Syntax errors in these files are discovered and reported with the
function <strong>config_err/2</strong> of the error report module at start-up. </p><a name="agent_information"></a><h4>Agent Information</h4><p>The agent information should be stored in a file called
<strong>agent.conf</strong>. </p><p>Each entry is a tuple of size two:</p><p><strong>{AgentVariable, Value}.</strong></p><ul><li> <p><strong>AgentVariable</strong> is one of the variables is
SNMP-FRAMEWORK-MIB or one of the internal variables
<strong>intAgentUDPPort</strong>, which defines which UDP port the agent
listens to, or <strong>intAgentTransports</strong>, which defines the
transport domains and addresses of the agent. </p> </li><li> <p><strong>Value</strong> is the value for the variable.</p> </li></ul><p>The following example shows an <strong>agent.conf</strong> file: </p><pre>
{intAgentUDPPort, 4000}.
{intAgentTransports,
 [{transportDomainUdpIpv4, {141,213,11,24}},
  {transportDomainUdpIpv6, {0,0,0,0,0,0,0,1}}]}.
{snmpEngineID, "mbj's engine"}.
{snmpEngineMaxPacketSize, 484}.
    </pre><p>The value of <strong>intAgentTransports</strong> is a list of
<strong>{Domain, Addr}</strong> tuples, where <strong>Domain</strong>
is either <strong>transportDomainUdpIpv4</strong> or <strong>transportDomainUdpIpv6</strong>,
and <strong>Addr</strong> is the address in the domain.
<strong>Addr</strong> can be specified either as an
<strong>IpAddr</strong> or as an <strong>{IpAddr, IpPort}</strong> tuple.
<strong>IpAddr</strong> is either a regular Erlang/OTP
<a href="../kernel/inet#type-ip_address">kernel/inet#type-ip_address</a>
or a traditional SNMP integer list and <strong>IpPort</strong> is an integer.
</p><p>When the <strong>Addr</strong> value does not contain a port number,
the value of <strong>intAgentUDPPort</strong> is used.</p><p>The legacy and intermediate variables <strong>intAgentIpAddress</strong>
and <strong>intAgentTransportDomain</strong> are still supported so old
<strong>agent.conf</strong> files will work.
</p><p>The value of <strong>snmpEngineID</strong> is a string, which for a 
deployed agent should have a very specific structure. See
RFC 2271/2571 for details.</p><a name="context"></a><h4>Contexts</h4><p>The context information should be stored in a file called
<strong>context.conf</strong>.  The default context <strong>""</strong>
need not be present.</p><p>Each row defines a context in the agent.  This information is
used in the table <strong>vacmContextTable</strong> in the
SNMP-VIEW-BASED-ACM-MIB.</p><p>Each entry is a term:</p><p><strong>ContextName.</strong></p><ul><li> <p><strong>ContextName</strong> is a string.</p> </li></ul><a name="system_information"></a><h4>System Information</h4><p>The system information should be stored in a file called
<strong>standard.conf</strong>.</p><p>Each entry is a tuple of size two:</p><p><strong>{SystemVariable, Value}.</strong></p><ul><li> <p><strong>SystemVariable</strong> is one of the variables in the
system group, or <strong>snmpEnableAuthenTraps</strong>. </p> </li><li> <p><strong>Value</strong> is the value for the variable. </p> </li></ul><p>The following example shows a valid <strong>standard.conf</strong> file: </p><pre>
{sysDescr, "Erlang SNMP agent"}.
{sysObjectID, [1,2,3]}.
{sysContact, "(mbj,eklas)@erlang.ericsson.se"}.
{sysName, "test"}.
{sysServices, 72}.
{snmpEnableAuthenTraps, enabled}.
    </pre><p>A value must be provided for all variables, which lack default
values in the MIB. </p><a name="community"></a><h4>Communities</h4><p>The community information should be stored in a file called
<strong>community.conf</strong>. It must be present if the agent is
configured for SNMPv1 or SNMPv2c. </p><p>An SNMP <em>community</em> is a relationship between an SNMP
agent and a set of SNMP managers that defines authentication, access 
control and proxy characteristics. </p><p>The corresponding table is <strong>snmpCommunityTable</strong> in the
SNMP-COMMUNITY-MIB. </p><p>Each entry is a term: </p><p><strong>{CommunityIndex, CommunityName, SecurityName, ContextName, TransportTag}.</strong> </p><ul><li> <p><strong>CommunityIndex</strong> is a non-empty string.</p> </li><li> <p><strong>CommunityName</strong> is a string.</p> </li><li> <p><strong>SecurityName</strong> is a string.</p> </li><li> <p><strong>ContextName</strong> is a string.</p> </li><li> <p><strong>TransportTag</strong> is a string.</p> </li></ul><a name="vacm"></a><h4>MIB Views for VACM</h4><p>The information about MIB Views for VACM should be stored in a 
file called <strong>vacm.conf</strong>.</p><p>The corresponding tables are <strong>vacmSecurityToGroupTable</strong>,
<strong>vacmAccessTable</strong> and <strong>vacmViewTreeFamilyTable</strong> in the
SNMP-VIEW-BASED-ACM-MIB.</p><p>Each entry is one of the terms, one entry corresponds to one
row in one of the tables.</p><p><strong>{vacmSecurityToGroup, SecModel, SecName, GroupName}.</strong></p><p><strong>{vacmAccess, GroupName, Prefix, SecModel, SecLevel, Match, ReadView, WriteView, NotifyView}.</strong></p><p><strong>{vacmViewTreeFamily, ViewIndex, ViewSubtree, ViewStatus, ViewMask}.</strong></p><ul><li> <p><strong>SecModel</strong> is <strong>any</strong>, <strong>v1</strong>, <strong>v2c</strong>, or
<strong>usm</strong>.</p> </li><li> <p><strong>SecName</strong> is a string.</p> </li><li> <p><strong>GroupName</strong> is a string.</p> </li><li> <p><strong>Prefix</strong> is a string.</p> </li><li> <p><strong>SecLevel</strong> is <strong>noAuthNoPriv</strong>, <strong>authNoPriv</strong>,
or <strong>authPriv</strong></p> </li><li> <p><strong>Match</strong> is <strong>prefix</strong> or <strong>exact</strong>.</p> </li><li> <p><strong>ReadView</strong> is a string.</p> </li><li> <p><strong>WriteView</strong> is a string.</p> </li><li> <p><strong>NotifyView</strong> is a string.</p> </li><li> <p><strong>ViewIndex</strong> is an integer.</p> </li><li> <p><strong>ViewSubtree</strong> is a list of integer.</p> </li><li> <p><strong>ViewStatus</strong> is either <strong>included</strong> or <strong>excluded</strong></p> </li><li> <p><strong>ViewMask</strong> is either <strong>null</strong> or a list of ones and
zeros. Ones nominate that an exact match is used for this
sub-identifier. Zeros are wild-cards which match any
sub-identifier. If the mask is shorter than the sub-tree, the
tail is regarded as all ones. <strong>null</strong> is shorthand for a
mask with all ones. </p> </li></ul><a name="usm"></a><h4>Security data for USM</h4><p>The information about Security data for USM should be stored in a 
file called <strong>usm.conf</strong>, which must be present if the agent is 
configured for SNMPv3. </p><p>The corresponding table is <strong>usmUserTable</strong> in the
SNMP-USER-BASED-SM-MIB.</p><p>Each entry is a term:</p><p><strong>{EngineID, UserName, SecName, Clone, AuthP, AuthKeyC, OwnAuthKeyC, PrivP, PrivKeyC, OwnPrivKeyC, Public, AuthKey, PrivKey}.</strong></p><ul><li> <p><strong>EngineID</strong> is a string.</p> </li><li> <p><strong>UserName</strong> is a string.</p> </li><li> <p><strong>SecName</strong> is a string.</p> </li><li> <p><strong>Clone</strong> is <strong>zeroDotZero</strong> or a list of integers.</p> </li><li> <p><strong>AuthP</strong> is a <strong>usmNoAuthProtocol</strong>,
<strong>usmHMACMD5AuthProtocol</strong>, or <strong>usmHMACSHAAuthProtocol</strong>.</p> </li><li> <p><strong>AuthKeyC</strong> is a string.</p> </li><li> <p><strong>OwnAuthKeyC</strong> is a string.</p> </li><li> <p><strong>PrivP</strong> is a <strong>usmNoPrivProtocol</strong>, 
<strong>usmDESPrivProtocol</strong> or <strong>usmAesCfb128Protocol</strong>.</p> </li><li> <p><strong>PrivKeyC</strong> is a string.</p> </li><li> <p><strong>OwnPrivKeyC</strong> is a string.</p> </li><li> <p><strong>Public</strong> is a string.</p> </li><li> <p><strong>AuthKey</strong> is a list (of integer). This is the User's secret
localized authentication key. It is not visible in the MIB. The length
of this key needs to be 16 if <strong>usmHMACMD5AuthProtocol</strong> is used, 
and 20 if <strong>usmHMACSHAAuthProtocol</strong> is used.</p> </li><li> <p><strong>PrivKey</strong> is a list (of integer).  This is the User's secret
localized encryption key.  It is not visible in the MIB.  The length
of this key needs to be 16 if <strong>usmDESPrivProtocol</strong> or 
<strong>usmAesCfb128Protocol</strong> is used. </p> </li></ul><a name="notify"></a><h4>Notify Definitions</h4><p>The information about Notify Definitions should be stored in a
file called <strong>notify.conf</strong>. </p><p>The corresponding table is <strong>snmpNotifyTable</strong> in the
SNMP-NOTIFICATION-MIB.</p><p>Each entry is a term:</p><p><strong>{NotifyName, Tag, Type}.</strong></p><ul><li> <p><strong>NotifyName</strong> is a unique non-empty string.</p> </li><li> <p><strong>Tag</strong> is a string.</p> </li><li> <p><strong>Type</strong> is <strong>trap</strong> or <strong>inform</strong>.</p> </li></ul><a name="target_addr"></a><h4>Target Address Definitions</h4><p>The information about Target Address Definitions should be 
stored in a file called <strong>target_addr.conf</strong>. </p><p>The corresponding tables are <strong>snmpTargetAddrTable</strong> in the
SNMP-TARGET-MIB and <strong>snmpTargetAddrExtTable</strong> in the 
SNMP-COMMUNITY-MIB. </p><p>Each entry is a term: </p><p><strong>{TargetName, Domain, Addr, Timeout, RetryCount, TagList, ParamsName, EngineId}.</strong>
<br/> or <br/>
<strong>{TargetName, Domain, Addr, Timeout, RetryCount, TagList, ParamsName, EngineId, TMask, MaxMessageSize}.</strong> </p><ul><li> <p><strong>TargetName</strong> is a unique non-empty string. </p> </li><li> <p><strong>Domain</strong> is one of the atoms: 
<strong>transportDomainUdpIpv4</strong> | <strong>transportDomainUdpIpv6</strong>. </p> </li><li> <p><strong>Addr</strong> is either an <strong>IpAddr</strong> or
an <strong>{IpAddr, IpPort}</strong> tuple. <strong>IpAddr</strong> is either
a regular Erlang/OTP
<a href="../kernel/inet#type-ip_address">kernel/inet#type-ip_address</a>
or a traditional SNMP integer list, and <strong>IpPort</strong> is an integer.</p> <p>If <strong>IpPort</strong> is omitted <strong>162</strong> is used.</p> </li><li> <p><strong>Timeout</strong> is an integer. </p> </li><li> <p><strong>RetryCount</strong> is an integer. </p> </li><li> <p><strong>TagList</strong> is a string. </p> </li><li> <p><strong>ParamsName</strong> is a string. </p> </li><li> <p><strong>EngineId</strong> is a string or the atom <strong>discovery</strong>. </p> </li><li> <p><strong>TMask</strong> is specified just as <strong>Addr</strong> or as <strong>[]</strong>.
Note in particular that using a list of 6 bytes	for IPv4
or 8 words plus 2 bytes for IPv6 are still valid address formats
so old configurations will work.</p> </li><li> <p><strong>MaxMessageSize</strong> is an integer (default: 2048). </p> </li></ul><p>The old tuple formats with <strong>Ip</strong> address and <strong>Udp</strong>
port number found in old configurations still work.</p><p>Note that if <strong>EngineId</strong> has the value <strong>discovery</strong>, 
the agent cannot send
<strong>inform</strong> messages to that manager until it has performed the
<em>discovery</em> process with that manager. </p><a name="target_params"></a><h4>Target Parameters Definitions</h4><p>The information about Target Parameters Definitions should be
stored in a file called <strong>target_params.conf</strong>. </p><p>The corresponding table is <strong>snmpTargetParamsTable</strong> in the
SNMP-TARGET-MIB. </p><p>Each entry is a term: </p><p><strong>{ParamsName, MPModel, SecurityModel, SecurityName, SecurityLevel}.</strong></p><ul><li> <p><strong>ParamsName</strong> is a unique non-empty string. </p> </li><li> <p><strong>MPModel</strong> is <strong>v1</strong>, <strong>v2c</strong> or <strong>v3</strong></p> </li><li> <p><strong>SecurityModel</strong> is <strong>v1</strong>, <strong>v2c</strong>, or <strong>usm</strong>.</p> </li><li> <p><strong>SecurityName</strong> is a string.</p> </li><li> <p><strong>SecurityLevel</strong> is <strong>noAuthNoPriv</strong>, <strong>authNoPriv</strong>
or <strong>authPriv</strong>. </p> </li></ul><p>Configuration data may be included in configuration files
that is located in the configuration directory. The name of this
directory is given in the <strong>config_dir</strong> configuration
parameter. These files are read at start-up.
</p><p>The directory where the configuration files are found is given as
a parameter to the manager.
</p><p>The entry format in all files are Erlang terms, separated by a
'<em>.</em>' and a <em>newline</em>. In the following sections, the
formats of these terms are described. Comments may be specified as
ordinary Erlang comments.
</p><p>If syntax errors are discovered in these files they are reported with the
function <strong>config_err/2</strong> of the 
<a href="snmpa_error_report">error report module</a>  
at start-up.
</p><a name="manager"></a><a name="manager_information"></a><h4>Manager Information</h4><p>The manager information should be stored in a file called
<strong>manager.conf</strong>.
</p><p>Each entry is a tuple of size two:
</p><p><strong>{Variable, Value}.</strong></p><ul><li> <p><strong>Variable</strong> is one of the following:</p> <ul><li> <p><strong>transports</strong> - which defines the transport domains
and their addresses for the manager. <em>Mandatory</em>
</p> <p><strong>Value</strong> is a list of <strong>{Domain, Addr}</strong> tuples
or <strong>Domain</strong> atoms.
</p> <ul><li> <p><strong>Domain</strong> is one of <strong>transportDomainUdpIpv4</strong>
or <strong>transportDomainUdpIpv6</strong>.</p> </li><li> <p><strong>Addr</strong> is for the currently supported domains
either an <strong>IpAddr</strong> or an <strong>{IpAddr, IpPort}</strong>
tuple.<strong>IpAddr</strong> is either a regular Erlang/OTP
<a href="../kernel/inet#type-ip_address">kernel/inet#type-ip_address</a> or a traditional SNMP integer list
and <strong>IpPort</strong> is an integer.
</p> <p>When <strong>Addr</strong> does not contain a port number,
the value of <strong>port</strong> is used.
</p> <p>When a <strong>Addr</strong> is not specified i.e by
using only a <strong>Domain</strong> atom, the host's name
is resolved to find the IP address, and the value of
<strong>port</strong> is used.
</p> </li></ul> </li><li> <p><strong>port</strong> - which defines which UDP port the manager uses
for communicating with agents.
<em>Mandatory</em> if <strong>transports</strong> does not define
a port number for every transport.</p> </li><li> <p><strong>engine_id</strong> - The <strong>SnmpEngineID</strong> as defined in 
SNMP-FRAMEWORK-MIB. <em>Mandatory</em>.</p> </li><li> <p><strong>max_message_size</strong> - The <strong>snmpEngineMaxMessageSize</strong> as
defined in SNMP-FRAMEWORK-MIB. <em>Mandatory</em>.</p> </li></ul> </li><li> <p><strong>Value</strong> is the value for the variable.
</p> </li></ul><p>The legacy and intermediate variables <strong>address</strong> and <strong>domain</strong>
are still supported so old configurations will work.</p><p>The following example shows a <strong>manager.conf</strong> file: 
</p><pre>
{transports,       [{transportDomainUdpIpv4, {{141,213,11,24}, 5000}},
                    {transportDomainUdpIpv6, {{0,0,0,0,0,0,0,1}, 5000}}]}.
{engine_id,        "mgrEngine"}.
{max_message_size, 484}.
    </pre><p>The value of <strong>engine_id</strong> is a string, which should have a 
very specific structure. See RFC 2271/2571 for details.
</p><a name="users"></a><h4>Users</h4><p>For each <em>manager user</em>, the manager needs some information.
This information is either added in the <strong>users.conf</strong> config 
file or by calling the 
<a href="./snmpm#register_user">register_user</a> 
function in run-time.
</p><p>Each row defines a <em>manager user</em> of the manager. 
</p><p>Each entry is a tuple of size four:
</p><p><strong>{UserId, UserMod, UserData, DefaultAgentConfig}.</strong></p><ul><li> <p><strong>UserId</strong> is any term (used to uniquely identify the user).</p> </li><li> <p><strong>UserMod</strong> is the user callback module (atom).</p> </li><li> <p><strong>UserData</strong> is any term (passed on to the user when calling the
<strong>UserMod</strong>.
</p> </li><li> <p><strong>DefaultAgentConfig</strong> is a list of default agent config's. 
These values are used as default values when this user registers 
agents.
</p> </li></ul><a name="agents"></a><h4>Agents</h4><p>The information needed to handle agents should be stored in a 
file called <strong>agents.conf</strong>. It is also possible to add agents
in run-time by calling the 
<a href="./snmpm#register_agent">register_agent</a>.
</p><p>Each entry is a tuple:
</p><p><strong>{UserId,  TargetName, Comm, Domain, Addr, EngineID, Timeout,  MaxMessageSize, Version, SecModel, SecName, SecLevel}.</strong></p><ul><li> <p><strong>UserId</strong> is the identity of the <em>manager user</em>
responsible for this agent (term).
</p> </li><li> <p><strong>TargetName</strong> is a <em>unique</em> <em>non-empty</em> string.</p> </li><li> <p><strong>Comm</strong> is the community string (string).</p> </li><li> <p><strong>Domain</strong> is the transport domain, either
<strong>transportDomainUdpIpv4</strong> or <strong>transportDomainUdpIpv6</strong>.</p> </li><li> <p><strong>Addr</strong> is the address in the transport domain,
either an <strong>{IpAddr, IpPort}</strong> tuple or a traditional SNMP
integer list containing port number. <strong>IpAddr</strong> is either
a regular Erlang/OTP
<a href="../kernel/inet#type-ip_address">kernel/inet#type-ip_address</a>
or a traditional SNMP integer list not containing port number,
and <strong>IpPort</strong> is an integer.</p> </li><li> <p><strong>EngineID</strong> is the engine-id of the agent (string).</p> </li><li> <p><strong>Timeout</strong> is re-transmission timeout 
(<strong>infinity</strong> | integer).</p> </li><li> <p><strong>MaxMessageSize</strong> is the max message size for outgoing messages 
to this agent (integer).</p> </li><li> <p><strong>Version</strong> is the version (v1 | v2 | v3).</p> </li><li> <p><strong>SecModel</strong> is the security model (any | v1 | v2c | usm).</p> </li><li> <p><strong>SecName</strong> is the security name (string).</p> </li><li> <p><strong>SecLevel</strong> is security level (noAuthNoPriv | authNoPriv | 
authPriv).</p> </li></ul><p>Legacy configurations using tuples without <strong>Domain</strong> element,
as well as with all <strong>TDomain</strong>, <strong>Ip</strong> and <strong>Port</strong> elements
still work.</p><a name="usm"></a><a name="usm_user"></a><h4>Security data for USM</h4><p>The information about Security data for USM should be stored in a 
file called <strong>usm.conf</strong>, which must be present if the manager
wishes to use SNMPv3 when communicating with agents. It is also 
possible to add usm data in run-time by calling the 
<a href="./snmpm#register_usm_user">register_usm_user</a>.
</p><p>The corresponding table is <strong>usmUserTable</strong> in the
SNMP-USER-BASED-SM-MIB.
</p><p>Each entry is a term:
</p><p><strong>{EngineID, UserName, AuthP, AuthKey, PrivP, PrivKey}.</strong>      <br/>
<strong>{EngineID, UserName, SecName, AuthP, AuthKey, PrivP, PrivKey}.</strong></p><p>The first case is when we have the identity-function 
(<strong>SecName</strong> = <strong>UserName</strong>).
</p><ul><li> <p><strong>EngineID</strong> is a string.</p> </li><li> <p><strong>UserName</strong> is a string.</p> </li><li> <p><strong>SecName</strong> is a string.</p> </li><li> <p><strong>AuthP</strong> is a <strong>usmNoAuthProtocol</strong>,
<strong>usmHMACMD5AuthProtocol</strong> or <strong>usmHMACSHAAuthProtocol</strong>.</p> </li><li> <p><strong>AuthKey</strong> is a list (of integer). This is the User's 
secret localized authentication key. It is not visible in the MIB. 
The length of this key needs to be 16 if 
<strong>usmHMACMD5AuthProtocol</strong> is used and 20 if 
<strong>usmHMACSHAAuthProtocol</strong> is used.</p> </li><li> <p><strong>PrivP</strong> is a <strong>usmNoPrivProtocol</strong>, 
<strong>usmDESPrivProtocol</strong> or <strong>usmAesCfb128Protocol</strong>.</p> </li><li> <p><strong>PrivKey</strong> is a list (of integer). This is the User's secret
localized encryption key.  It is not visible in the MIB. The length
of this key needs to be 16 if <strong>usmDESPrivProtocol</strong> 
or <strong>usmAesCfb128Protocol</strong> is used.</p> </li></ul><p>This <em>Implementation Example</em> section describes how an
MIB can be implemented with the SNMP Development Toolkit. </p><p>The example shown can be found in the toolkit distribution. </p><p>The agent is configured with the configuration tool, using
default suggestions for everything but the manager node. </p><h4>MIB</h4><p>The MIB used in this example is called EX1-MIB. It contains two
objects, a variable with a name and a table with friends.
</p><pre><code class="">
EX1-MIB DEFINITIONS ::= BEGIN
 
          IMPORTS
                  experimental   FROM RFC1155-SMI
                  RowStatus      FROM STANDARD-MIB
                  DisplayString  FROM RFC1213-MIB
                  OBJECT-TYPE    FROM RFC-1212
                  ;
 
          example1       OBJECT IDENTIFIER ::= { experimental 7 }
 
          myName OBJECT-TYPE
              SYNTAX  DisplayString (SIZE (0..255))
              ACCESS  read-write
              STATUS  mandatory
              DESCRIPTION
                      "My own name"
              ::= { example1 1 }
 
          friendsTable OBJECT-TYPE
              SYNTAX  SEQUENCE OF FriendsEntry
              ACCESS  not-accessible
              STATUS  mandatory
              DESCRIPTION
                      "A list of friends."
              ::= { example1 4 }
 
          friendsEntry OBJECT-TYPE
              SYNTAX  FriendsEntry
              ACCESS  not-accessible
              STATUS  mandatory
              DESCRIPTION
                      ""
              INDEX   { fIndex }
              ::= { friendsTable 1 }
 
          FriendsEntry ::=
              SEQUENCE {
                   fIndex
                      INTEGER,
                   fName
                      DisplayString,
                   fAddress
                      DisplayString,
                   fStatus
                      RowStatus              }
 
          fIndex OBJECT-TYPE
              SYNTAX  INTEGER
              ACCESS  not-accessible
              STATUS  mandatory
               DESCRIPTION
                      "number of friend"
              ::= { friendsEntry 1 }
 
          fName OBJECT-TYPE
              SYNTAX  DisplayString (SIZE (0..255))
              ACCESS  read-write
              STATUS  mandatory
              DESCRIPTION
                      "Name of friend"
              ::= { friendsEntry 2 }

          fAddress OBJECT-TYPE
              SYNTAX  DisplayString (SIZE (0..255))
              ACCESS  read-write
              STATUS  mandatory
              DESCRIPTION
                      "Address of friend"
              ::= { friendsEntry 3 }

           fStatus OBJECT-TYPE
              SYNTAX      RowStatus
              ACCESS      read-write
              STATUS      mandatory
              DESCRIPTION
                      "The status of this conceptual row."
              ::= { friendsEntry 4 }

          fTrap TRAP-TYPE
              ENTERPRISE  example1
              VARIABLES   { myName, fIndex }
              DESCRIPTION
                      "This trap is sent when something happens to
                      the friend specified by fIndex."
              ::= 1
END
    </code></pre><h4>Default Implementation</h4><p>Without writing any instrumentation functions, we can compile
the MIB and use the default implementation of it. Recall that MIBs
imported by "EX1-MIB.mib" must be present and compiled in the
current directory ("./STANDARD-MIB.bin","./RFC1213-MIB.bin") when
compiling.
</p><pre>
unix&gt; <span class="input">erl -config ./sys</span>
1&gt; <span class="input">application:start(snmp).</span>
ok
2&gt; <span class="input">snmpc:compile("EX1-MIB").</span>
No accessfunction for 'friendsTable', using default.
No accessfunction for 'myName', using default.
{ok, "EX1-MIB.bin"}
3&gt; <span class="input">snmpa:load_mibs(snmp_master_agent, ["EX1-MIB"]).</span>
ok
    </pre><p>This MIB is now loaded into the agent, and a manager can ask
questions. As an example of this, we start another Erlang system
and the simple Erlang manager in the toolkit:
</p><pre>
1&gt; <span class="input">snmp_test_mgr:start_link([{agent,"dront.ericsson.se"},{community,"all-rights"},</span>
 %% making it understand symbolic names: {mibs,["EX1-MIB","STANDARD-MIB"]}]).
{ok, &lt;0.89.0&gt;}
%% a get-next request with one OID.
2&gt; <span class="input">snmp_test_mgr:gn([[1,3,6,1,3,7]]).</span>
ok 
* Got PDU:
[myName,0] = [] 
%% A set-request (now using symbolic names for convenience)
3&gt; <span class="input">snmp_test_mgr:s([{[myName,0], "Martin"}]).</span>
ok                           
* Got PDU:
[myName,0] = "Martin"    
%% Try the same get-next request again
4&gt; <span class="input">snmp_test_mgr:gn([[1,3,6,1,3,7]]).</span>
ok                           
* Got PDU:
[myName,0] = "Martin"    
%% ... and we got the new value.
%% you can event do row operations. How to add a row:
5&gt; <span class="input">snmp_test_mgr:s([{[fName,0], "Martin"}, {[fAddress,0],"home"}, {[fStatus,0],4}]).</span>
 %% createAndGo
ok
* Got PDU:
[fName,0] = "Martin"    
[fAddress,0] = "home"    
[fStatus,0] = 4    
6&gt; <span class="input">snmp_test_mgr:gn([[myName,0]]).</span>
ok
* Got PDU:
[fName,0] = "Martin"    
7&gt; <span class="input">snmp_test_mgr:gn().</span>
ok
* Got PDU:
[fAddress,0] = "home"    
8&gt; <span class="input">snmp_test_mgr:gn().</span>
ok
* Got PDU:
[fStatus,0] = 1    
9&gt; 
    </pre><h4>Manual Implementation</h4><p>The following example shows a "manual" implementation of the
EX1-MIB in Erlang.  In this example, the values of the objects are
stored in an Erlang server.  The server has a 2-tuple as loop
data, where the first element is the value of variable
<strong>myName</strong>, and the second is a sorted list of rows in the
table <strong>friendsTable</strong>.  Each row is a 4-tuple.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>There are more efficient ways to create tables manually, i.e.
to use the module <strong>snmp_index</strong>.</p></div><h4>Code</h4><pre><code class="">
-module(ex1).
-author('dummy@flop.org').
%% External exports
-export([start/0, my_name/1, my_name/2, friends_table/3]).
%% Internal exports
-export([init/0]).
-define(status_col, 4).
-define(active, 1).
-define(notInService, 2).
-define(notReady, 3).
-define(createAndGo, 4).   % Action; written, not read
-define(createAndWait, 5). % Action; written, not read
-define(destroy, 6).       % Action; written, not read
start() -&gt;
    spawn(ex1, init, []).
%%----------------------------------------------------------------
%% Instrumentation function for variable myName.
%% Returns: (get) {value, Name}
%%          (set) noError
%%----------------------------------------------------------------
my_name(get) -&gt;
    ex1_server ! {self(), get_my_name},
    Name = wait_answer(),
    {value, Name}.
my_name(set, NewName) -&gt;
    ex1_server ! {self(), {set_my_name, NewName}},
    noError.
%%----------------------------------------------------------------
%% Instrumentation function for table friendsTable.
%%----------------------------------------------------------------
friends_table(get, RowIndex, Cols) -&gt;
    case get_row(RowIndex) of
   {ok, Row} -&gt;
        get_cols(Cols, Row);
   _  -&gt;
        {noValue, noSuchInstance}
    end;
friends_table(get_next, RowIndex, Cols) -&gt;
    case get_next_row(RowIndex) of
   {ok, Row} -&gt;
        get_next_cols(Cols, Row);
   _  -&gt;
       case get_next_row([]) of
     {ok, Row} -&gt;
         % Get next cols from first row.
         NewCols = add_one_to_cols(Cols),
         get_next_cols(NewCols, Row);
     _  -&gt;
        end_of_table(Cols)
        end
    end;
%%----------------------------------------------------------------
%% If RowStatus is set, then:
%%    *) If set to destroy, check that row does exist
%%    *) If set to createAndGo, check that row does not exist AND
%%         that all columns are given values.
%%    *) Otherwise, error (for simplicity).
%% Otherwise, row is modified; check that row exists.
%%----------------------------------------------------------------
friends_table(is_set_ok, RowIndex, Cols) -&gt;
    RowExists = 
   case get_row(RowIndex) of
        {ok, _Row} -&gt; true;
       _ -&gt; false
   end, 
    case is_row_status_col_changed(Cols) of
   {true, ?destroy} when RowExists == true -&gt;
        {noError, 0};
   {true, ?createAndGo} when RowExists == false,
                                 length(Cols) == 3 -&gt;
        {noError, 0};
   {true, _} -&gt;
       {inconsistentValue, ?status_col};
   false when RowExists == true -&gt;
        {noError, 0};
   _ -&gt;
        [{Col, _NewVal} | _Cols] = Cols,
       {inconsistentName, Col}
      end;
friends_table(set, RowIndex, Cols) -&gt;
    case is_row_status_col_changed(Cols) of
   {true, ?destroy} -&gt;
        ex1_server ! {self(), {delete_row, RowIndex}};
   {true, ?createAndGo} -&gt;
       NewRow = make_row(RowIndex, Cols),
        ex1_server ! {self(), {add_row, NewRow}};
   false -&gt;
       {ok, Row} = get_row(RowIndex),
        NewRow = merge_rows(Row, Cols),
    ex1_server ! {self(), {delete_row, RowIndex}},
       ex1_server ! {self(), {add_row, NewRow}}
   end,
    {noError, 0}.
    
%%----------------------------------------------------------------
%% Make a list of {value, Val} of the Row and Cols list.
%%----------------------------------------------------------------
get_cols([Col | Cols], Row) -&gt;
    [{value, element(Col, Row)} | get_cols(Cols, Row)];
get_cols([], _Row) -&gt;
    [].
%%----------------------------------------------------------------
%% As get_cols, but the Cols list may contain invalid column
%% numbers. If it does, we must find the next valid column,
%% or return endOfTable.
%%----------------------------------------------------------------
get_next_cols([Col | Cols], Row) when Col &lt; 2 -&gt;
    [{[2, element(1, Row)], element(2, Row)} | 
     get_next_cols(Cols, Row)];
get_next_cols([Col | Cols], Row) when Col &gt; 4 -&gt;
    [endOfTable | 
     get_next_cols(Cols, Row)];
get_next_cols([Col | Cols], Row) -&gt;
    [{[Col, element(1, Row)], element(Col, Row)} | 
     get_next_cols(Cols, Row)];
get_next_cols([], _Row) -&gt;
    [].
%%----------------------------------------------------------------
%% Make a list of endOfTable with as many elems as Cols list.
%%----------------------------------------------------------------
end_of_table([Col | Cols]) -&gt;
    [endOfTable | end_of_table(Cols)];
end_of_table([]) -&gt;
    [].
add_one_to_cols([Col | Cols]) -&gt;
    [Col + 1 | add_one_to_cols(Cols)];
add_one_to_cols([]) -&gt;
    [].
is_row_status_col_changed(Cols) -&gt;
    case lists:keysearch(?status_col, 1, Cols) of
   {value, {?status_col, StatusVal}} -&gt;
        {true, StatusVal};
   _ -&gt; false
    end.
get_row(RowIndex) -&gt;
    ex1_server ! {self(), {get_row, RowIndex}},
    wait_answer().
get_next_row(RowIndex) -&gt;
    ex1_server ! {self(), {get_next_row, RowIndex}},
    wait_answer().
wait_answer() -&gt;
    receive
   {ex1_server, Answer} -&gt;
     Answer
    end.
%%%---------------------------------------------------------------
%%% Server code follows
%%%---------------------------------------------------------------
init() -&gt;
    register(ex1_server, self()),
    loop("", []).
    
loop(MyName, Table) -&gt;
    receive
   {From, get_my_name} -&gt;
        From ! {ex1_server, MyName},
       loop(MyName, Table);
   {From, {set_my_name, NewName}} -&gt;
        loop(NewName, Table);
   {From, {get_row, RowIndex}} -&gt;
       Res = table_get_row(Table, RowIndex),
       From ! {ex1_server, Res},
       loop(MyName, Table);
   {From, {get_next_row, RowIndex}} -&gt;
       Res = table_get_next_row(Table, RowIndex),
        From ! {ex1_server, Res},
       loop(MyName, Table);
   {From, {delete_row, RowIndex}} -&gt;
    NewTable = table_delete_row(Table, RowIndex),
       loop(MyName, NewTable);
   {From, {add_row, NewRow}} -&gt;
       NewTable = table_add_row(Table, NewRow),
       loop(MyName, NewTable)
    end.
%%%---------------------------------------------------------------
%%% Functions for table operations. The table is represented as
%%% a list of rows.
%%%---------------------------------------------------------------
table_get_row([{Index, Name, Address, Status} | _], [Index]) -&gt;
    {ok, {Index, Name, Address, Status}};
table_get_row([H | T], RowIndex) -&gt;
    table_get_row(T, RowIndex);
table_get_row([], _RowIndex) -&gt;
    no_such_row.
table_get_next_row([Row | T], []) -&gt;
    {ok, Row};
table_get_next_row([Row | T], [Index | _]) 
when element(1, Row) &gt; Index -&gt;
    {ok, Row};
table_get_next_row([Row | T], RowIndex) -&gt;
    table_get_next_row(T, RowIndex);
table_get_next_row([], RowIndex) -&gt;
    endOfTable.
table_delete_row([{Index, _, _, _} | T], [Index]) -&gt;
    T;
table_delete_row([H | T], RowIndex) -&gt;
    [H | table_delete_row(T, RowIndex)];
table_delete_row([], _RowIndex) -&gt;
    [].
table_add_row([Row | T], NewRow) 
  when element(1, Row) &gt; element(1, NewRow) -&gt;
    [NewRow, Row | T];
table_add_row([H | T], NewRow) -&gt;
    [H | table_add_row(T, NewRow)];
table_add_row([], NewRow) -&gt;
    [NewRow].
make_row([Index], [{2, Name}, {3, Address} | _]) -&gt;
    {Index, Name, Address, ?active}.
merge_rows(Row, [{Col, NewVal} | T]) -&gt;
    merge_rows(setelement(Col, Row, NewVal), T);
merge_rows(Row, []) -&gt;
    Row.
      </code></pre><h4>Association File</h4><p>The association file <strong>EX1-MIB.funcs</strong> for the real
implementation looks as follows:
</p><pre><code class="">
{myName, {ex1, my_name, []}}.
{friendsTable, {ex1, friends_table, []}}.
      </code></pre><h4>Transcript</h4><p>To use the real implementation, we must recompile the MIB and
load it into the agent.
</p><pre>
1&gt; <span class="input">application:start(snmp).</span>
ok
2&gt; <span class="input">snmpc:compile("EX1-MIB").</span>
{ok,"EX1-MIB.bin"}
3&gt; <span class="input">snmpa:load_mibs(snmp_master_agent, ["EX1-MIB"]).</span>
ok
4&gt; <span class="input">ex1:start().</span>
&lt;0.115.0&gt;
%% Now all requests operates on this "real" implementation.
%% The output from the manager requests will *look* exactly the
%% same as for the default implementation.
      </pre><h4>Trap Sending</h4><p>How to send a trap by sending the
<strong>fTrap</strong> from the master agent is shown in this section. 
The master agent has the MIB <strong>EX1-MIB</strong> loaded, where the 
trap is defined. This trap specifies that two variables should 
be sent along with the trap, <strong>myName</strong> and <strong>fIndex</strong>. 
<strong>fIndex</strong> is a table column, so we must provide its value 
and the index for the row in the call to <strong>snmpa:send_trap/4</strong>. 
In the example below, we assume that the row in question is 
indexed by 2 (the row with <strong>fIndex</strong> 2).
</p><p>we use a simple Erlang SNMP manager, which can receive traps.
</p><pre>
[MANAGER]
1&gt; <span class="input">snmp_test_mgr:start_link([{agent,"dront.ericsson.se"},{community,"public"}</span>
 %% does not have write-access
1&gt;<span class="input">{mibs,["EX1-MIB","STANDARD-MIB"]}]).</span>
{ok, &lt;0.100.0&gt;}
2&gt; <span class="input">snmp_test_mgr:s([{[myName,0], "Klas"}]).</span>
ok                           
* Got PDU:
Received a trap:
      Generic: 4       %% authenticationFailure
   Enterprise: [iso,2,3]
     Specific: 0
   Agent addr: [123,12,12,21]
    TimeStamp: 42993
2&gt; 
[AGENT]
3&gt; <span class="input">snmpa:send_trap(snmp_master_agent, fTrap,"standard trap", [{fIndex,[2],2}]).</span>
[MANAGER]
2&gt;
* Got PDU:
Received a trap:             
      Generic: 6
   Enterprise: [example1]
     Specific: 1
   Agent addr: [123,12,12,21]
    TimeStamp: 69649
[myName,0] = "Martin"    
[fIndex,2] = 2    
2&gt;
      </pre><p>This <em>Implementation Example</em> section describes 
how a simple manager can be implemented with the 
SNMP Development Toolkit. </p><p>The example shown, <em>ex2</em>, can be found in the toolkit 
distribution. </p><p>This example has two functions: </p><ul><li> <p>A simple example of how to use the manager component of 
the SNMP Development Toolkit.</p> </li><li> <p>A simple example of how to write agent test cases, using the new
manager.</p> </li></ul><h4>The example manager</h4><p>The example manager, <strong>snmp_ex2_manager</strong>, is a simple example of 
how to implement an snmp manager using the manager component of the
SNMP Development Toolkit.</p><p>The module exports the following functions:</p><ul><li> <p>start_link/0, start_link/1</p> </li><li> <p>stop/0</p> </li><li> <p>agent/2, agent/3</p> </li><li> <p>sync_get/2, sync_get/3</p> </li><li> <p>sync_get_next/2, sync_get_next/3</p> </li><li> <p>sync_get_bulk/4, sync_get_bulk/5</p> </li><li> <p>sync_set/2, sync_set/3</p> </li><li> <p>oid_to_name/1</p> </li></ul><p>This module is also used by the test module described in the 
next section.</p><h4>A simple standard test</h4><p>This simple standard test, <strong>snmp_ex2_simple_standard_test</strong>,
a module which, using the <strong>snmp_ex2_manager</strong> described in the
previous section, implements a simple agent test utility. </p><p>A user-defined instrumentation function for each object attaches
the managed objects to real resources. This function is called by
the agent on a <strong>get</strong> or <strong>set</strong> operation. The function
could read some hardware register, perform a calculation, or
whatever is necessary to implement the semantics associated with the
conceptual variable. These functions must be written both for scalar
variables and for tables. They are specified in the association
file, which is a text file. In this file, the <strong>OBJECT IDENTIFIER</strong>, or symbolic name for each managed object, is
associated with an Erlang tuple <strong>{Module,</strong><strong>Function</strong>,
<strong>ListOfExtraArguments}</strong>.
</p><p>When a managed object is referenced in an SNMP operation, the
associated <strong>{Module, Function, ListOfExtraArguments}</strong> is
called. The function is applied to some standard arguments (for
example, the operation type) and the extra arguments supplied by the
user.
</p><p>Instrumentation functions must be written for <strong>get</strong> and
<strong>set</strong> for scalar variables and tables, and for <strong>get-next</strong>
for tables only.  The <strong>get-bulk</strong> operation is translated into a
series of calls to <strong>get-next</strong>.
</p><h4>Instrumentation Functions</h4><p>The following sections describe how the instrumentation
functions should be defined in Erlang for the different
operations. In the following, <strong>RowIndex</strong> is a list of key
values for the table, and <strong>Column</strong> is a column number.
</p><p>These functions are described in detail in 
<a href="snmp_def_instr_functions">Definition of Instrumentation Functions</a>.
</p><h4>New / Delete Operations</h4><p>For scalar variables:
</p><pre><code class="">
variable_access(new [, ExtraArg1, ...])
variable_access(delete [, ExtraArg1, ...])
      </code></pre><p>For tables:
</p><pre><code class="">
table_access(new [, ExtraArg1, ...])
table_access(delete [, ExtraArg1, ...])
      </code></pre><p>These functions are called for each object in an MIB when the
MIB is unloaded or loaded, respectively.</p><h4>Get Operation</h4><p>For scalar variables:
</p><pre><code class="">
variable_access(get [, ExtraArg1, ...])
      </code></pre><p>For tables:
</p><pre><code class="">
table_access(get,RowIndex,Cols [,ExtraArg1, ...])
      </code></pre><p><strong>Cols</strong> is a list of <strong>Column</strong>. The agent will sort
incoming variables so that all operations on one row (same
index) will be supplied at the same time. The reason for this is
that a database normally retrieves information row by row.
</p><p>These functions must return the current values of the
associated variables.</p><h4>Set Operation</h4><p>For scalar variables:
</p><pre><code class="">
variable_access(set, NewValue [, ExtraArg1, ...])
      </code></pre><p>For tables:
</p><pre><code class="">
table_access(set, RowIndex, Cols [, ExtraArg1,..])
      </code></pre><p><strong>Cols</strong> is a list of tuples <strong>{Column, NewValue}</strong>.
</p><p>These functions returns <strong>noError</strong> if the assignment was
successful, otherwise an error code.</p><h4>Is-set-ok Operation</h4><p>As a complement to the <strong>set</strong> operation, it is possible
to specify a test function. This function has the same syntax as
the set operation above, except that the first argument is
<strong>is_set_ok</strong> instead of <strong>set</strong>. This function is called
before the variable is set. Its purpose is to ensure that it is
permissible to set the variable to the new value.</p><pre><code class="">
variable_access(is_set_ok, NewValue [, ExtraArg1, ...])
      </code></pre><p>For tables:
</p><pre><code class="">
table_access(set, RowIndex, Cols [, ExtraArg1,..])
      </code></pre><p><strong>Cols</strong> is a list of tuples <strong>{Column, NewValue}</strong>.
</p><h4>Undo Operation</h4><p>A function which has been called with <strong>is_set_ok</strong> will
be called again, either with <strong>set</strong> if there was no error,
or with <strong>undo</strong>, if an error occurred. In this way,
resources can be reserved in the <strong>is_set_ok</strong> operation,
released in the <strong>undo</strong> operation, or made permanent in the
<strong>set</strong> operation.</p><pre><code class="">
variable_access(undo, NewValue [, ExtraArg1, ...])
      </code></pre><p>For tables:
</p><pre><code class="">
table_access(set, RowIndex, Cols [, ExtraArg1,..])
      </code></pre><p><strong>Cols</strong> is a list of tuples <strong>{Column, NewValue}</strong>.
</p><h4>GetNext Operation</h4><p>The GetNext Operation operation should only be defined for 
tables since the
agent can find the next instance of plain variables in the MIB
and call the instrumentation with the <strong>get</strong> operation.
</p><pre><code class="">
table_access(get_next, RowIndex, Cols [, ExtraArg1, ...])
      </code></pre><p><strong>Cols</strong> is a list of integers, all greater than or equal
to zero. This indicates that the instrumentation should find the
next accessible instance. This function returns the tuple
<strong>{NextOid, NextValue}</strong>, or
<strong>endOfTable</strong>. <strong>NextOid</strong> should be the
lexicographically next accessible instance of a managed object
in the table. It should be a list of integers, where the first
integer is the column, and the rest of the list is the indices
for the next row. If <strong>endOfTable</strong> is returned, the agent
continues to search for the next instance among the other
variables and tables.
</p><p><strong>RowIndex</strong> may be an empty list, an incompletely
specified row index, or the index for an unspecified row.
</p><p>This operation is best described with an example.
</p><h4>GetNext Example</h4><p>A table called <strong>myTable</strong> has five columns. The first
two are keys (not accessible), and the table has three
rows. The instrumentation function for this table is called
<strong>my_table</strong>.</p><a name="getnext1"></a><img src="getnext1.gif" title="Contents of my_table"></img><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>N/A means not accessible.</p></div><p>The manager issues the following <strong>getNext</strong> request:
</p><pre><code class="">
getNext{ myTable.myTableEntry.3.1.1,
         myTable.myTableEntry.5.1.1 } 
        </code></pre><p>Since both operations involve the 1.1 index, this is
transformed into one call to <strong>my_table</strong>:
</p><pre><code class="">
my_table(get_next, [1, 1], [3, 5])
        </code></pre><p>In this call, <strong>[1, 1]</strong> is the <strong>RowIndex</strong>, where
key 1 has value 1, and key 2 has value 1, and <strong>[3, 5]</strong> is
the list of requested columns. The function should now return
the lexicographically next elements:
</p><pre><code class="">
[{[3, 1, 2], d}, {[5, 1, 2], f}]
        </code></pre><p>This is illustrated in the following table:
</p><a name="getnext2"></a><img src="getnext2.gif" title="GetNext from [3,1,1] and [5,1,1]."></img><p>The manager now issues the following <strong>getNext</strong> request:
</p><pre><code class="">
getNext{ myTable.myTableEntry.3.2.1,
         myTable.myTableEntry.5.2.1 } 
        </code></pre><p>This is transformed into one call to <strong>my_table</strong>:
</p><pre><code class="">
my_table(get_next, [2, 1], [3, 5])
        </code></pre><p>The function should now return:
</p><pre><code class="">
[{[4, 1, 1], b}, endOfTable]
        </code></pre><p>This is illustrated in the following table:
</p><a name="getnext3"></a><img src="getnext3.gif" title="GetNext from [3,2,1] and [5,2,1]."></img><p>The manager now issues the following <strong>getNext</strong> request:
</p><pre><code class="">
getNext{ myTable.myTableEntry.3.1.2,
         myTable.myTableEntry.4.1.2 } 
        </code></pre><p>This will be transform into one call to <strong>my_table</strong>:
</p><pre><code class="">
my_table(get_next, [1, 2], [3, 4])
        </code></pre><p>The function should now return:
</p><pre><code class="">
[{[3, 2, 1], g}, {[5, 1, 1], c}]
        </code></pre><p>This is illustrated in the following table:
</p><a name="getnext4"></a><img src="getnext4.gif" title="GetNext from [3,1,2] and [4,1,2]."></img><p>The manager now issues the following <strong>getNext</strong> request:
</p><pre><code class="">
getNext{ myTable.myTableEntry,
         myTable.myTableEntry.1.3.2 } 
        </code></pre><p>This will be transform into two calls to <strong>my_table</strong>:
</p><pre><code class="">
my_table(get_next, [], [0]) and
my_table(get_next, [3, 2], [1])
        </code></pre><p>The function should now return:
</p><pre><code class="">
[{[3, 1, 1], a}] and
[{[3, 1, 1], a}]
        </code></pre><p>In both cases, the first accessible element in the table
should be returned. As the key columns are not accessible,
this means that the third column is the first row.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Normally, the functions described above behave exactly as
shown, but they are free to perform other actions. For
example, a get-request may have side effects such as setting
some other variable, perhaps a global <strong>lastAccessed</strong>
variable.</p></div><h4>Using the ExtraArgument</h4><p>The <strong>ListOfExtraArguments</strong> can be used to write generic
functions. This list is appended to the standard arguments for
each function. Consider two read-only variables for a device,
<strong>ipAdr</strong> and <strong>name</strong> with object identifiers 1.1.23.4 and
1.1.7 respectively. To access these variables, one could implement
the two Erlang functions <strong>ip_access</strong> and <strong>name_access</strong>,
which will be in the MIB. The functions could be specified in a
text file as follows:
</p><pre><code class="">
{ipAdr, {my_module, ip_access, []}}.
% Or using the oid syntax for 'name'
{[1,1,7], {my_module, name_access, []}}.
    </code></pre><p>The <strong>ExtraArgument</strong> parameter is the empty list. For
example, when the agent receives a get-request for the
<strong>ipAdr</strong> variable, a call will be made to
<strong>ip_access(get)</strong>. The value returned by this function is the
answer to the get-request.
</p><p>If <strong>ip_access</strong> and <strong>name_access</strong> are implemented
similarly, we could write a <strong>generic_access</strong> function using
the <strong>ListOfExtraArguments</strong>:
</p><pre><code class="">
{ipAdr, {my_module, generic_access, ['IPADR']}}.
% The mnemonic 'name' is more convenient than 1.1.7
{name, {my_module, generic_access, ['NAME']}}.
    </code></pre><p>When the agent receives the same get-request as above, a call
will be made to <strong>generic_access(get, </strong>'<strong>IPADR')</strong>.
</p><p>Yet another possibility, closer to the hardware, could be:
</p><pre><code class="">
{ipAdr, {my_module, generic_access, [16#2543]}}.
{name, {my_module, generic_access, [16#A2B3]}}.
    </code></pre><h4>Default Instrumentation</h4><a name="snmp_3"></a><p>When the MIB definition work is finished, there are two major
issues left.
</p><ul><li>Implementing the MIB </li><li>Implementing a Manager Application.</li></ul><p>Implementing an MIB can be a tedious task. Most probably, there
is a need to test the agent before all tables and variables are
implemented. In this case, the default instrumentation functions
are useful. The toolkit can generate default instrumentation
functions for variables as well as for tables. Consequently, a
running prototype agent, which can handle <strong>set</strong>, <strong>get</strong>,
<strong>get-next</strong> and table operations, is generated without any
programming.
</p><p>The agent stores the values in an internal volatile database,
which is based on the standard module <strong>ets</strong>. However, it is
possible to let the MIB compiler generate functions which use an
internal, persistent database, or the Mnesia DBMS. Refer to the
Mnesia User Guide and the Reference Manual, section SNMP, module
<strong>snmp_generic</strong> for more information.
</p><p>When parts of the MIB are implemented, you recompile it and
continue on by using default functions. With this approach, the
SNMP agent can be developed incrementally.
</p><p>The default instrumentation allows the application on the
manager side to be developed and tested simultaneously with the
agent. As soon as the ASN.1 file is completed, let the MIB
compiler generate a default implementation and develop the
management application from this.
</p><h4>Table Operations</h4><p>The generation of default functions for tables works for
tables which use the <strong>RowStatus</strong> textual convention from
SNMPv2, defined in STANDARD-MIB and SNMPv2-TC.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>We strongly encourage the use of the <strong>RowStatus</strong>
convention for every table that can be modified from the
manager, even for newly designed SNMPv1 MIBs. In SNMPv1,
everybody has invented their own scheme for emulating table
operations, which has led to numerous inconsistencies. The
convention in SNMPv2 is flexible and powerful and has been
tested successfully. If the table is read only, no RowStatus
column should be used.
</p></div><h4>Atomic Set</h4><p>In SNMP, the <strong>set</strong> operation is atomic. Either all
variables which are specified in a <strong>set</strong> operation are
changed, or none are changed. Therefore, the <strong>set</strong> operation
is divided into two phases. In the first phase, the new value of
each variable is checked against the definition of the variable in
the MIB. The following definitions are checked:
</p><ul><li>the type</li><li>the length</li><li>the range</li><li>the variable is writable and within the MIB view. </li></ul><p>At
the end of phase one, the user defined <strong>is_set_ok</strong> functions
are called for each scalar variable, and for each group of table
operations.
</p><p>If no error occurs, the second phase is performed. This phase
calls the user defined <strong>set</strong> function for all variables.
</p><p>If an error occurs, either in the <strong>is_set_ok</strong> phase, or in
the <strong>set</strong> phase, all functions which were called with
<strong>is_set_ok</strong> but not <strong>set</strong>, are called with <strong>undo</strong>.
</p><p>There are limitations with this transaction mechanism. If
complex dependencies exist between variables, for example between
<strong>month</strong> and <strong>day</strong>, another mechanism is needed. Setting
the date to 'Feb 31' can be avoided by a somewhat more generic
transaction mechanism. You can continue and find more and more
complex situations and construct an N-phase set-mechanism. This
toolkit only contains a trivial mechanism.
</p><p>The most common application of transaction mechanisms is to
keep row operations together. Since our agent sorts row
operations, the mechanism implemented in combination with the
RowStatus (particularly 'createAndWait' value) solve most
problems elegantly.
</p><p>The section <em>Definition of Instrumentation Functions</em> describes
the user defined functions, which the agent calls at different times.
</p><h4>Variable Instrumentation</h4><p>For scalar variables, a function <strong>f(Operation, ...)</strong> must
be defined.
</p><p>The <strong>Operation</strong> can be <strong>new</strong>, <strong>delete</strong>,
<strong>get</strong>, <strong>is_set_ok</strong>, <strong>set</strong>, or <strong>undo</strong>.
</p><p>In case of an error, all instrumentation functions may return
either an SNMPv1 or an SNMPv2 error code. If it returns an SNMPv2
code, it is converted into an SNMPv1 code before it is sent to a
SNMPv1 manager.  It is  recommended to use the SNMPv2 error codes
for all instrumentation functions, as these provide more
details. See <a href="snmp_app_a">Appendix A</a> for a
description of error code conversions.
</p><h4>f(new [, ExtraArgs])</h4><p>The function <strong>f(new [, ExtraArgs])</strong> is called for each
variable in the MIB when the
MIB is loaded into the agent. This makes it possible to perform
necessary initialization.
</p><p>This function is optional. The return value is discarded.</p><h4>f(delete [, ExtraArgs])</h4><p>The function <strong>f(delete [, ExtraArgs])</strong> is called
for each object in an MIB when the
MIB is unloaded from the agent. This makes it possible to
perform necessary clean-up.
</p><p>This function is optional. The return value is discarded.</p><h4>f(get [, ExtraArgs])</h4><p>The function <strong>f(get [, ExtraArgs])</strong> is called when a
get-request or a get-next
request refers to the variable.
</p><p>This function is mandatory.
</p><h4>Valid Return Values</h4><ul><li><strong>{value, Value}</strong>. The <strong>Value</strong> must be of correct type, length and within ranges, otherwise <strong>genErr</strong> is returned in the response PDU.  If the object is an enumerated integer, the symbolic enum value may be used as an atom. If the object is of type BITS, the return value shall be an integer or a list of bits that are set. </li><li><strong>{noValue, noSuchName}</strong>(SNMPv1) </li><li><strong>{noValue, noSuchObject | noSuchInstance} </strong>(SNMPv2) </li><li><strong>genErr</strong>.  Used if an error occurred.  Note, this should be an internal processing error, e.g. a caused by a programing fault somewhere.  If the variable does not exist, use <strong>{noValue, noSuchName}</strong> or <strong>{noValue, noSuchInstance}</strong>. </li></ul><h4>f(is_set_ok, NewValue [, ExtraArgs])</h4><p>The function <strong>f(is_set_ok, NewValue [, ExtraArgs])</strong> is
called in phase one of the set-request
processing so that the new value can be checked for
inconsistencies.
</p><p><strong>NewValue</strong> is guaranteed to be of the correct type,
length and within ranges, as specified in the MIB.  If the
object is an enumerated integer or of type BITS, the integer
value is used.
</p><p>This function is optional.
</p><p>If this function is called, it will be called again, either
with <strong>undo</strong> or with <strong>set</strong> as first argument.
</p><h4>Valid return values</h4><ul><li><strong>noError</strong></li><li><strong>badValue | noSuchName | genErr</strong>(SNMPv1) </li><li><strong>noAccess | noCreation | inconsistentValue | resourceUnavailable | inconsistentName | genErr</strong>(SNMPv2)</li></ul><h4>f(undo, NewValue [, ExtraArgs])</h4><p>If an error occurred, this function is called after the
<strong>is_set_ok</strong> function is called. If <strong>set</strong> is called for
this object, <strong>undo</strong> is not called.
</p><p><strong>NewValue</strong> is guaranteed to be of the correct type,
length and within ranges, as specified in the MIB.  If the
object is an enumerated integer or of type BITS, the integer
value is used.
</p><p>This function is optional.
</p><h4>Valid return values</h4><ul><li><strong>noError</strong></li><li><strong>genErr</strong>(SNMPv1) </li><li><strong>undoFailed | genErr</strong>(SNMPv2)</li></ul><h4>f(set, NewValue [, ExtraArgs])</h4><p>This function is called to perform the set in phase two of
the set-request processing. It is only called if the
corresponding <strong>is_set_ok</strong> function is present and returns
<strong>noError</strong>.
</p><p><strong>NewValue</strong> is guaranteed to be of the correct type,
length and within ranges, as specified in the MIB.  If the
object is an enumerated integer or of type BITS, the integer
value is used.
</p><p>This function is mandatory.
</p><h4>Valid return values</h4><ul><li><strong>noError</strong></li><li><strong>genErr</strong>(SNMPv1) </li><li><strong>commitFailed | undoFailed | genErr</strong>(SNMPv2)</li></ul><h4>Table Instrumentation</h4><p>For tables, a <strong>f(Operation, ...)</strong> function should be
defined (the function shown is exemplified with <strong>f</strong>).
</p><p>The <strong>Operation</strong> can be <strong>new</strong>, <strong>delete</strong>,
<strong>get</strong>, <strong>next</strong>, <strong>is_set_ok</strong>, <strong>undo</strong> or
<strong>set</strong>.
</p><p>In case of an error, all instrumentation functions may return
either an SNMPv1 or an SNMPv2 error code. If it returns an SNMPv2
code, it is converted into an SNMPv1 code before it is sent to a
SNMPv1 manager. It is  recommended to use the SNMPv2 error codes
for all instrumentation functions, as these provide more
details. See <a href="snmp_app_a">Appendix A</a> for a
description of error code conversions.</p><h4>f(new [, ExtraArgs])</h4><p>The function <strong>f(new [, ExtraArgs])</strong> is called for each object in an MIB when the
MIB is loaded into the agent. This makes it possible to perform
the necessary initialization.
</p><p>This function is optional. The return value is discarded.</p><h4>f(delete [, ExtraArgs])</h4><p>The function <strong>f(delete [, ExtraArgs])</strong> is called for each object in an MIB when the
MIB is unloaded from the agent. This makes it possible to
perform any necessary clean-up.
</p><p>This function is optional. The return value is discarded.</p><h4>f(get, RowIndex, Cols [, ExtraArgs])</h4><p>The function <strong>f(get, RowIndex, Cols [, ExtraArgs])</strong> is
called when a get-request refers to a table.
</p><p>This function is mandatory.
</p><h4>Arguments</h4><ul><li><strong>RowIndex</strong> is a list of integers which define the key values for the row. The <strong>RowIndex</strong> is the list representation (list of integers) which follow the <strong>Cols</strong> integer in the OBJECT IDENTIFIER. </li><li><strong>Cols</strong> is a list of integers which represent the column numbers. The <strong>Cols</strong> are sorted by increasing value and are guaranteed to be valid column numbers.</li></ul><h4>Valid Return Values</h4><ul><li> <p>A list with as many elements as the <strong>Cols</strong> list,
where each element is the value of the corresponding
column.  Each element can be:</p> <ul><li><strong>{value, Value}</strong>. The <strong>Value</strong> must be of correct type, length and within ranges, otherwise <strong>genErr</strong> is returned in the response PDU.  If the object is an enumerated integer, the symbolic enum value may be used (as an atom). If the object is of type BITS, the return value shall be an integer or a list of bits that are set. </li><li><strong>{noValue, noSuchName}</strong>(SNMPv1) </li><li><strong>{noValue, noSuchObject | noSuchInstance}</strong>(SNMPv2) </li></ul> </li><li><strong>{noValue, Error}</strong>. If the row does not exist, because all columns have <strong>{noValue, Error}</strong>), the single tuple <strong>{noValue, Error}</strong> can be returned. This is a shorthand for a list with all elements <strong>{noValue, Error}</strong>. </li><li><strong>genErr</strong>.  Used if an error occurred.  Note that this should be an internal processing error, e.g. a caused by a programing fault somewhere.  If some column does not exist, use <strong>{noValue, noSuchName}</strong> or <strong>{noValue, noSuchInstance}</strong>. </li></ul><h4>f(get_next, RowIndex, Cols [, ExtraArgs])</h4><p>The function <strong>f(get_next, RowIndex, Cols [, ExtraArgs])</strong> is 
called when a get-next- or a
get-bulk-request refers to the table.
</p><p>The <strong>RowIndex</strong> argument may refer to an existing row or a
non-existing row, or it may be unspecified. The <strong>Cols</strong> list
may refer to inaccessible columns or non-existing columns. For
each column in the <strong>Cols</strong> list, the corresponding next
instance is determined, and the last part of its OBJECT
IDENTIFIER and its value is returned.
</p><p>This function is mandatory.
</p><h4>Arguments</h4><ul><li><strong>RowIndex</strong> is a list of integers (possibly empty) that defines the key values for a row. The <strong>RowIndex</strong> is the list representation (list of integers), which follow the <strong>Cols</strong> integer in the OBJECT IDENTIFIER. </li><li><strong>Cols</strong> is a list of integers, greater than or equal to zero, which represents the column numbers.</li></ul><h4>Valid Return Values</h4><ul><li> <p>A list with as many elements as the <strong>Cols</strong> list
Each element can be:</p> <ul><li><strong>{NextOid, NextValue}</strong>, where <strong>NextOid</strong> is the lexicographic next OBJECT IDENTIFIER for the corresponding column. This should be specified as the OBJECT IDENTIFER part following the table entry. This means that the first integer is the column number and the rest is a specification of the keys. <strong>NextValue</strong> is the value of this element. </li><li><strong>endOfTable</strong> if there are no accessible elements after this one. </li></ul> </li><li><strong>{genErr, Column}</strong> where <strong>Column</strong> denotes the column that caused the error.  <strong>Column</strong> must be one of the columns in the <strong>Cols</strong> list.  Note that this should be an internal processing error, e.g. a caused by a programing fault somewhere.  If some column does not exist, you must return the next accessible element (or <strong>endOfTable</strong>).  </li></ul><h4>f(is_set_ok, RowIndex, Cols [, ExtraArgs])</h4><p>The function <strong>f(is_set_ok, RowIndex, Cols [, ExtraArgs])</strong>
is called in phase one of the set-request
processing so that new values can be checked for
inconsistencies.
</p><p>If the function is called, it will be called again with
<strong>undo</strong>, or with <strong>set</strong> as first argument.
</p><p>This function is optional.
</p><h4>Arguments</h4><ul><li><strong>RowIndex</strong> is a list of integers which define the key values for the row. The <strong>RowIndex</strong> is the list representation (list of integers) which follow the <strong>Cols</strong> integer in the OBJECT IDENTIFIER. </li><li><strong>Cols</strong> is a list of <strong>{Column, NewValue}</strong>, where <strong>Column</strong> is an integer, and <strong>NewValue</strong> is guaranteed to be of the correct type, length and within ranges, as specified in the MIB.  If the object is an enumerated integer or of type BITS, the integer value is used.  The list is sorted by <strong>Column</strong> (increasing) and each <strong>Column</strong> is guaranteed to be a valid column number.</li></ul><h4>Valid Return Values</h4><ul><li><strong>{noError, 0}</strong></li><li><strong>{Error, Column}</strong>, where <strong>Error</strong> is the same as for <strong>is_set_ok</strong> for variables, and <strong>Column</strong> denotes the faulty column.  <strong>Column</strong> must be one of the columns in the <strong>Cols</strong> list.</li></ul><h4>f(undo, RowIndex, Cols [, ExtraArgs])</h4><p>If an error occurs, The function
<strong>f(undo, RowIndex, Cols [, ExtraArgs])</strong> is called after the
<strong>is_set_ok</strong> function. If <strong>set</strong> is called for this
object, <strong>undo</strong> is not called.
</p><p>This function is optional.
</p><h4>Arguments</h4><ul><li><strong>RowIndex</strong> is a list of integers which define the key values for the row. The <strong>RowIndex</strong> is the list representation (list of integers) which follow the <strong>Cols</strong> integer in the OBJECT IDENTIFIER. </li><li><strong>Cols</strong> is a list of <strong>{Column, NewValue}</strong>, where <strong>Column</strong> is an integer, and <strong>NewValue</strong> is guaranteed to be of the correct type, length and within ranges, as specified in the MIB.  If the object is an enumerated integer or of type BITS, the integer value is used.  The list is sorted by <strong>Column</strong> (increasing) and each <strong>Column</strong> is guaranteed to be a valid column number. </li></ul><h4>Valid Return Values</h4><ul><li><strong>{noError, 0}</strong></li><li><strong>{Error, Column}</strong> where <strong>Error</strong> is the same as for <strong>undo</strong> for variables, and <strong>Column</strong> denotes the faulty column.  <strong>Column</strong> must be one of the columns in the <strong>Cols</strong> list. </li></ul><h4>f(set, RowIndex, Cols [, ExtraArgs])</h4><p>The function <strong>f(set, RowIndex, Cols [, ExtraArgs])</strong> is
called to perform the set in phase two of
the set-request processing. It is only called if the
corresponding <strong>is_set_ok</strong> function did not exist, or
returned <strong>{noError, 0}</strong>.
</p><p>This function is mandatory.
</p><h4>Arguments</h4><ul><li><strong>RowIndex</strong> is a list of integers that define the key values for the row. The <strong>RowIndex</strong> is the list representation (list of integers) which follow the <strong>Cols</strong> integer in the OBJECT IDENTIFIER. </li><li><strong>Cols</strong> is a list of <strong>{Column, NewValue}</strong>, where <strong>Column</strong> is an integer, and <strong>NewValue</strong> is guaranteed to be of the correct type, length and within ranges, as specified in the MIB.  If the object is an enumerated integer or of type BITS, the integer value is used.  The list is sorted by <strong>Column</strong> (increasing) and each <strong>Column</strong> is guaranteed to be a valid column number. </li></ul><h4>Valid Return Values</h4><ul><li><strong>{noError, 0}</strong></li><li><strong>{Error, Column}</strong> where <strong>Error</strong> is the same as <strong>set</strong> for variables, and <strong>Column</strong> denotes the faulty column.  <strong>Column</strong> must be one of the columns in the <strong>Cols</strong> list.</li></ul><img src="snmp_agent_netif_1.gif" title="The Purpose of Agent Net if"></img><p>The Network Interface (Net if) process delivers SNMP PDUs to a
master agent, and receives SNMP PDUs from the master agent. The most
common behaviour of a Net if process is that is receives bytes from
a network, decodes them into an SNMP PDU, which it sends to a master
agent. When the master agent has processed the PDU, it sends a
response PDU to the Net if process, which encodes the PDU into bytes
and transmits the bytes onto the network.
</p><p>However, that simple behaviour can be modified in numerous
ways. For example, the Net if process can apply some kind of
encrypting/decrypting scheme on the bytes or
act as a proxy filter, which sends some packets to a proxy agent and
some packets to the master agent.
</p><p>It is also possible to write your own Net if process. The default
Net if process is implemented in the module <strong>snmpa_net_if</strong> and
it uses UDP as the transport protocol i.e the transport domains
<strong>transportDomainUdpIpv4</strong> and/or <strong>transportDomainUdpIpv6</strong>.
</p><p>This section describes how to write a Net if process.
</p><a name="mandatory_functions"></a><h4>Mandatory Functions</h4><p>A Net if process must implement the SNMP agent 
<a href="snmpa_network_interface">network interface behaviour</a>.
</p><a name="messages"></a><h4>Messages</h4><p>The section <em>Messages</em> describes mandatory messages, which
Net if must send and be able to receive.     
</p><p>In this section an <strong>Address</strong> field is a
<strong>{Domain, Addr}</strong> tuple where <strong>Domain</strong> is
<strong>transportDomainUdpIpv4</strong> or <strong>transportDomainUdpIpv4</strong>,
and <strong>Addr</strong> is an
<strong>{</strong><a href="../kernel/inet#type-ip_address">kernel/inet#type-ip_address</a><strong>,IpPort}</strong> tuple.</p><a name="outgoing_messages"></a><h4>Outgoing Messages</h4><p>Net if must send the following message when it receives an
SNMP PDU from the network that is aimed for the MasterAgent:
</p><a name="om_snmp_pdu"></a><pre>
MasterAgent ! {snmp_pdu, Vsn, Pdu, PduMS, ACMData, From, Extra}
      </pre><ul><li><strong>Vsn</strong> is either <strong>'version-1'</strong>, <strong>'version-2'</strong>, or <strong>'version-3'</strong>. </li><li><strong>Pdu</strong> is an SNMP PDU record, as defined in <strong>snmp_types.hrl</strong>, with the SNMP request. </li><li><strong>PduMS</strong> is the Maximum Size of the response Pdu allowed.  Normally this is returned from <strong>snmpa_mpd:process_packet</strong> (see Reference Manual). </li><li><strong>ACMData</strong> is data used by the Access Control Module in use.  Normally this is returned from <strong>snmpa_mpd:process_packet</strong> (see Reference Manual). </li><li><strong>From</strong> is the source <strong>Address</strong>. </li><li><strong>Extra</strong> is any term the Net if process wishes to send to the agent. This term can be retrieved by the instrumentation functions by calling <strong>snmp:current_net_if_data()</strong>. This data is also sent back to the Net if process when the agent generates a response to the request.</li></ul><p>The following message is used to report that a response to a
request has been received.  The only request an agent can send
is an Inform-Request.
</p><a name="om_snmp_response_received"></a><pre>
Pid ! {snmp_response_received, Vsn, Pdu, From}
      </pre><ul><li><strong>Pid</strong> is the Process that waits for the response for the request.  The Pid was specified in the <strong>send_pdu_req</strong> message  <a href="#im_send_pdu_req">(see below)</a>. </li><li><strong>Vsn</strong> is either <strong>'version-1'</strong>, <strong>'version-2'</strong>, or <strong>'version-3'</strong>. </li><li><strong>Pdu</strong> is the SNMP Pdu received </li><li><strong>From</strong> is the source <strong>Address</strong>. </li></ul><a name="incoming_messages"></a><h4>Incoming Messages</h4><p>This section describes the incoming messages which a Net if
process must be able to receive.
</p><ul><li> <a name="im_snmp_response"></a> <p><strong>{snmp_response, Vsn, Pdu, Type, ACMData, To, Extra}</strong></p> <p>This message is sent to the Net if process from a master
agent as a response to a previously received request.
</p> <ul><li> <p><strong>Vsn</strong> is either <strong>'version-1'</strong>,
<strong>'version-2'</strong>, or <strong>'version-3'</strong>. </p> </li><li> <p><strong>Pdu</strong> is an SNMP PDU record (as defined in
snmp_types.hrl) with the SNMP response. </p> </li><li> <p><strong>Type</strong> is the <strong>#pdu.type</strong> 
of the original request. </p> </li><li> <p><strong>ACMData</strong> is data used by the Access Control
Module in use.  Normally this is just sent to
<strong>snmpa_mpd:generate_response_message</strong> 
(see Reference Manual). </p> </li><li> <p><strong>To</strong> is the destination <strong>Address</strong> that comes
from the <strong>From</strong> field in the corresponding <strong>snmp_pdu</strong>
message previously sent to the MasterAgent.</p> </li><li> <p><strong>Extra</strong> is the term that the Net if process
sent to the agent when the request was sent to the agent. </p> </li></ul> </li><li> <a name="im_discarded_pdu"></a> <p><strong>{discarded_pdu, Vsn, ReqId, ACMData, Variable, Extra}</strong></p> <p>This message is sent from a master agent if it for some
reason decided to discard the pdu. </p> <ul><li> <p><strong>Vsn</strong> is either <strong>'version-1'</strong>,
<strong>'version-2'</strong>, or <strong>'version-3'</strong>. </p> </li><li> <p><strong>ReqId</strong> is the request id of the original request. </p> </li><li> <p><strong>ACMData</strong> is data used by the Access Control
Module in use. Normally this is just sent to
<strong>snmpa_mpd:generate_response_message</strong> 
(see Reference Manual). </p> </li><li> <p><strong>Variable</strong> is the name of an snmp counter that
represents the error, e.g. <strong>snmpInBadCommunityUses</strong>. </p> </li><li> <p><strong>Extra</strong> is the term that the Net if process
sent to the agent when the request was sent to the agent. </p> </li></ul> </li><li> <a name="im_send_pdu"></a> <p><strong>{send_pdu, Vsn, Pdu, MsgData, To, Extra}</strong></p> <p>This message is sent from a master agent when a trap is
to be sent. </p> <ul><li> <p><strong>Vsn</strong> is either <strong>'version-1'</strong>,
<strong>'version-2'</strong>, or <strong>'version-3'</strong>.</p> </li><li> <p><strong>Pdu</strong> is an SNMP PDU record (as defined in
snmp_types.hrl) with the SNMP response. </p> </li><li> <p><strong>MsgData</strong> is the message specific data used in
the SNMP message.  This value is normally sent to
<strong>snmpa_mpd:generate_message/4</strong>.  In SNMPv1 and
SNMPv2c, this message data is the community string.  In
SNMPv3, it is the context information. </p> </li><li> <p><strong>To</strong> is a list of <strong>{Address, SecData}</strong>
tuples i.e the destination addresses and
their corresponding security parameters.  This value is
normally sent to <strong>snmpa_mpd:generate_message/4</strong>. </p> </li><li> <p><strong>Extra</strong> is any term that the notification sender
wishes to pass to the Net if process when sending a notification 
(see 
<a href="./snmpa#send_notification2">send notification </a> for more info). </p> </li></ul> </li><li> <a name="im_send_pdu_req"></a> <p><strong>{send_pdu_req, Vsn, Pdu, MsgData, To, Pid, Extra}</strong></p> <p>This message is sent from a master agent when a request is to 
be sent.  The only request an agent can send is Inform-Request.  
The net if process needs to remember the request id and the Pid, 
and when a response is received for the request id, send it to Pid, 
using a <strong>snmp_response_received</strong> message. </p> <ul><li> <p><strong>Vsn</strong> is either <strong>'version-1'</strong>,
<strong>'version-2'</strong>,  or <strong>'version-3'</strong>.</p> </li><li> <p><strong>Pdu</strong> is an SNMP PDU record (as defined in
snmp_types.hrl) with the SNMP response. </p> </li><li> <p><strong>MsgData</strong> is the message specific data used in
the SNMP message.  This value is normally sent to
<strong>snmpa_mpd:generate_message/4</strong>. In SNMPv1 and
SNMPv2c, this message data is the community string. In
SNMPv3, it is the context information. </p> </li><li> <p><strong>To</strong> is a list of <strong>{Address, SecData}</strong>
tuples i.e the destination addresses and
their corresponding security parameters. This value is
normally sent to <strong>snmpa_mpd:generate_message/4</strong>. </p> </li><li> <p><strong>Pid</strong> is a process identifier. </p> </li><li> <p><strong>Extra</strong> is any term that the notification sender
wishes to pass to the Net if process when sending a notification 
(see 
<a href="./snmpa#send_notification2">send notification </a> for more info). </p> </li></ul> </li></ul><h4>Notes</h4><p>Since the Net if process is responsible for encoding and
decoding of SNMP messages, it must also update the relevant
counters in the SNMP group in MIB-II. It can use the functions
in the module <strong>snmpa_mpd</strong> for this purpose (refer to the 
Reference Manual, section <strong>snmp</strong>, 
module <a href="snmp_pdus">snmpa_mpd</a>
for more details.)
</p><p>There are also some useful functions for encoding and
decoding of SNMP messages in the module 
<a href="snmp_pdus">snmp_pdus</a>.
</p><img src="snmp_manager_netif_1.gif" title="The Purpose of Manager Net if"></img><p>The Network Interface (Net if) process delivers SNMP PDUs to the
manager server, and receives SNMP PDUs from the manager server. 
The most common behaviour of a Net if process is that is receives 
request PDU from the manager server, encodes the PDU into bytes
and transmits the bytes onto the network to an agent. When the 
reply from the agent is received by the Net if process, which it
decodes into an SNMP PDU, which it sends to the manager server. </p><p>However, that simple behaviour can be modified in numerous
ways. For example, the Net if process can apply some kind of
encrypting/decrypting scheme on the bytes. </p><p>The snmp application provides two different modules, 
<strong>snmpm_net_if</strong> (the default) and <strong>snmpm_net_if_mt</strong>, 
both uses UDP as the transport protocol i.e the transport domains
<strong>transportDomainUdpIpv4</strong> and/or <strong>transportDomainUdpIpv6</strong>.
The difference between the two modules is that the latter is
"multi-threaded",  i.e. for each message/request a new process
is created that processes the message/request and then exits. </p><p>It is also possible to write your own Net if process and
this section describes how to do that.</p><a name="mandatory_functions"></a><h4>Mandatory Functions</h4><p>A Net if process must implement the SNMP manager 
<a href="snmpm_network_interface">network interface behaviour</a>. </p><h4>Messages</h4><p>The section <em>Messages</em> describes mandatory messages, which
Net if must send to the manager server process.     
</p><p>In this section a <strong>Domain</strong> field is the transport domain i.e
one of <strong>transportDomainUdpIpv4</strong> or <strong>transportDomainUdpIpv6</strong>,
and an <strong>Addr</strong> field is an
<strong>{</strong><a href="../kernel/inet#type-ip_address">kernel/inet#type-ip_address</a><strong>,IpPort}</strong> tuple.</p><p>Net if must send the following message when it receives an
SNMP PDU from the network that is aimed for the MasterAgent:
</p><pre>
Server ! {snmp_pdu, Pdu, Domain, Addr}
    </pre><ul><li> <p><strong>Pdu</strong> is an SNMP PDU record, as defined in
<strong>snmp_types.hrl</strong>, with the SNMP request.</p> </li><li> <p><strong>Domain</strong> is the source transport domain. </p> </li><li> <p><strong>Addr</strong> is the source address. </p> </li></ul><pre>
Server ! {snmp_trap, Trap, Domain, Addr}
    </pre><ul><li> <p><strong>Trap</strong> is either an SNMP pdu record or an trappdu record, 
as defined in <strong>snmp_types.hrl</strong>, with the SNMP request.</p> </li><li> <p><strong>Domain</strong> is the source transport domain. </p> </li><li> <p><strong>Addr</strong> is the source address. </p> </li></ul><pre>
Server ! {snmp_inform, Ref, Pdu, PduMS, Domain, Addr}
    </pre><ul><li> <p><strong>Ref</strong> is either the atom <strong>ignore</strong> or something
that can be used to identify the inform-request (e.g. request-id).
<strong>ignore</strong> is used if the response (acknowledgment) to the
inform-request has already been sent (this means that the server 
will not make the call to the 
<a href="./snmpm_network_interface#inform_response">inform_response</a> 
function). See the 
<a href="snmp_app">inform request behaviour</a> 
configuration option for more info.</p> </li><li> <p><strong>Pdu</strong> is an SNMP PDU record, as defined in
<strong>snmp_types.hrl</strong>, with the SNMP request.</p> </li><li> <p><strong>Domain</strong> is the source transport domain. </p> </li><li> <p><strong>Addr</strong> is the source address. </p> </li></ul><pre>
Server ! {snmp_report, Data, Domain, Addr}
    </pre><ul><li> <p><strong>Data</strong> is either <strong>{ok, Pdu}</strong> or 
<strong>{error, ReqId, ReasonInfo, Pdu}</strong>. Which one is used depends 
on the return value from the MPD 
<a href="./snmpm_mpd#process_msg">process_msg</a> function. If the MsgData is <strong>ok</strong>, 
the first is used, and if it is <strong>{error, ReqId, Reason}</strong>
the latter is used.</p> </li><li> <p><strong>Pdu</strong> is an SNMP PDU record, as defined in
<strong>snmp_types.hrl</strong>, with the SNMP request.</p> </li><li> <p><strong>ReqId</strong> is an integer.</p> </li><li> <p><strong>ReasonInfo</strong> is a term().</p> </li><li> <p><strong>Domain</strong> is the source transport domain. </p> </li><li> <p><strong>Addr</strong> is the source address. </p> </li></ul><h4>Notes</h4><p>Since the Net if process is responsible for encoding and
decoding of SNMP messages, it must also update the relevant
counters in the SNMP group in MIB-II.  It can use the functions
in the module <strong>snmpm_mpd</strong> for this purpose (refer to the 
Reference Manual, section <strong>snmp</strong>, module <strong>snmpm_mpd</strong>
for more details).
</p><p>There are also some useful functions for encoding and
decoding of SNMP messages in the module <strong>snmp_pdus</strong>.
</p><p>The chapter <em>Audit Trail Log</em> describes the audit trail logging.
</p><p>Both the agent and the manager can be configured to log 
incoming and outgoing messages. It uses the Erlang standard log
mechanism <strong>disk_log</strong> for logging. The size and location of
the log files are configurable. A wrap log is used, which means
that when the log has grown to a maximum size, it starts from the
beginning of the log, overwriting existing log records.
</p><p>The log can be either a <strong>read</strong>, <strong>write</strong> or a 
<strong>read_write</strong>. 
</p><h4>Agent Logging</h4><p>For the agent, a <strong>write</strong>, means that all <strong>set</strong> 
requests and their responses are stored. No <strong>get</strong> requests
or traps are stored in a <strong>write</strong>. A <strong>read_write</strong>, 
all requests, responses and traps are stored.
</p><p>The log uses a raw data format (basically the BER encoded
message), in order to minimize the CPU load needed for the log
mechanism.  This means that the log is not human readable, but
needs to be formatted off-line before it can be read.  Use the
function 
<a href="./snmpa#log_to_txt">snmpa:log_to_txt</a> 
for this purpose.
</p><h4>Manager Logging</h4><p>For the manager, a <strong>write</strong>, means that all  
requests (<strong>set</strong> and <strong>get</strong>) and their responses are stored. 
No traps are stored in a <strong>write</strong>. A <strong>read_write</strong>, 
all requests, responses and traps are stored.
</p><p>The log uses a raw data format (basically the BER encoded
message), in order to minimize the CPU load needed for the log
mechanism. This means that the log is not human readable, but
needs to be formatted off-line before it can be read. Use the
function 
<a href="./snmpm#log_to_txt">snmpm:log_to_txt</a> 
for this purpose.
</p><p>The chapter <em>Advanced Agent Topics</em> describes the more advanced 
agent related features of the SNMP development tool. The following topics 
are covered:
</p><ul><li>When to use a Sub-agent</li><li>Agent semantics</li><li>Sub-agents and dependencies</li><li>Distributed tables</li><li>Fault tolerance</li><li>Using Mnesia tables as SNMP tables</li><li>Audit Trail Logging</li><li>Deviations from the standard </li></ul><h4>When to use a Sub-agent</h4><p>The section <em>When to use a Sub-agent</em> describes situations
where the mechanism of loading and unloading MIBs is insufficient. 
In these cases a sub-agent is needed.
</p><h4>Special Set Transaction Mechanism</h4><p>Each sub-agent can implement its own mechanisms for
<strong>set</strong>, <strong>get</strong> and <strong>get-next</strong>. For example, if the
application requires the <strong>get</strong> mechanism to be
asynchronous, or needs a N-phase <strong>set</strong> mechanism, a
specialized sub-agent should be used.
</p><p>The toolkit allows different kinds of sub-agents at the same
time. Accordingly, different MIBs can have different <strong>set</strong>
or <strong>get</strong> mechanisms.
</p><h4>Process Communication</h4><p>A simple distributed agent can be managed without sub-agents. 
The instrumentation functions can use distributed Erlang to 
communicate with other parts of the application. However, a 
sub-agent can be used on each node if this generates too much 
unnecessary traffic. A sub-agent processes requests per 
incoming SNMP request, not per variable. Therefore the network 
traffic is minimized.
</p><p>If the instrumentation functions communicate with UNIX
processes, it might be a good idea to use a special
sub-agent. This sub-agent sends the SNMP request to the other
process in one packet in order to minimize context switches. For
example, if a whole MIB is implemented on the C level in UNIX,
but you still want to use the Erlang SNMP tool, then you may
have one special sub-agent, which sends the variables in the
request as a single operation down to C.
</p><h4>Frequent Loading of MIBs</h4><p>Loading and unloading of MIBs are quite cheap
operations. However, if the application does this very often,
perhaps several times per minute, it should load the MIBs once
and for all in a sub-agent. This sub-agent only registers and
unregisters itself under another agent instead of loading the
MIBs each time. This is cheaper than loading an MIB.
</p><h4>Interaction With Other SNMP Agent Toolkits</h4><p>If the SNMP agent needs to interact with sub-agents
constructed in another package, a special sub-agent should be
used, which communicates through a protocol specified by the
other package.
</p><h4>Agent Semantics</h4><p>The agent can be configured to be multi-threaded, to process
one incoming request at a time, or to have a request limit
enabled (this can be used for load control or to limit the effect
of DoS attacks). If it is multi-threaded, read requests (<strong>get</strong>, 
<strong>get-next</strong> and <strong>get-bulk</strong>) and traps are processed in 
parallel with each other and <strong>set</strong> requests. However, all 
<strong>set</strong> requests are serialized, which means that if the agent 
is waiting for the application to complete a complicated write 
operation, it will not process any new write requests until this 
operation is finished. It processes read requests and sends traps, 
concurrently. The reason for not handle write requests in parallel is 
that a complex locking mechanism would be needed even in the simplest 
cases. Even with the scheme described above, the user must be 
careful not to violate that the <strong>set</strong> requests are atoms. 
If this is hard to do, do not use the multi-threaded feature.
</p><p>The order within an request is undefined and variables are not
processed in a defined order. Do not assume that the first
variable in the PDU will be processed before the second, even if
the agent processes variables in this order. It
cannot even be  assumed that requests belonging to different
sub-agents have any order.
</p><p>If the manager tries to set the same variable many times in the
same PDU, the agent is free to improvise. There is no definition
which determines if the instrumentation will be called once or
twice. If called once only, there is no definition that determines 
which of the new values is going to be supplied.
</p><p>When the agent receives a request, it keeps the request ID for
one second after the response is sent. If the agent receives
another request with the same request ID during this time, from
the same IP address and UDP port, that request will be
discarded. This mechanism has nothing to do with the function
<strong>snmpa:current_request_id/0</strong>.</p><h4>Sub-agents and Dependencies</h4><p>The toolkit supports the use of different types of sub-agents,
but not the construction of sub-agents.
</p><p>Also, the toolkit does not support dependencies between
sub-agents. A sub-agent should by definition be stand alone and it is
therefore not good design to create dependencies between them.
</p><h4>Distributed Tables</h4><p>A common situation in more complex systems is that the data in
a table is distributed. Different table rows are implemented in
different places. Some SNMP tool-kits dedicate an SNMP sub-agent for
each part of the table and load the corresponding MIB into all
sub-agents. The Master Agent is responsible for presenting the
distributed table as a single table to the manager. The toolkit
supplied uses a different method.
</p><p>The method used to implement distributed tables with this SNMP
tool is to implement a table coordinator process responsible for 
coordinating the processes, which hold the table data and they 
are called  table holders. All table holders must in some way be 
known by the coordinator; the structure of the table data 
determines how this is achieved. The coordinator may require 
that the table holders explicitly register themselves and specify 
their information. In other cases, the table holders can be 
determined once at compile time.
</p><p>When the instrumentation function for the distributed table is
called, the request should be forwarded to the table
coordinator. The coordinator finds the requested information among
the table holders and then returns the answer to the
instrumentation function. The SNMP toolkit contains no support for
coordination of tables since this must be independent of the
implementation.
</p><p>The advantages of separating the table coordinator from the
SNMP tool are:
</p><ul><li>We do not need a sub-agent for each table holder. Normally, the sub-agent is needed to take care of communication, but in Distributed Erlang we use ordinary message passing. </li><li>Most likely, some type of table coordinator already exists. This process should take care of the instrumentation for the table. </li><li>The method used to present a distributed table is strongly application dependent. The use of different masking techniques is only valid for a small subset of problems and registering every row in a distributed table makes it non-distributed. </li></ul><h4>Fault Tolerance</h4><p>The SNMP agent toolkit gets input from three different sources:
</p><ul><li>UDP packets from the network</li><li>return values from the user defined instrumentation functions</li><li>return values from the MIB. </li></ul><p>The agent is highly fault tolerant. If the manager gets an
unexpected response from the agent, it is possible that some
instrumentation function has returned an erroneous value. The
agent will not crash even if the instrumentation does. It should
be noted that if an instrumentation function enters an infinite
loop, the agent will also be blocked forever. The supervisor ,or
the application, specifies how to restart the agent.
</p><h4>Using the SNMP Agent in a Distributed Environment</h4><p>The normal way to use the agent in a distributed
environment is to use one master agent located at one node,
and zero or more sub-agents located on other nodes.  However,
this configuration makes the master agent node a single point
of failure.  If that node goes down, the agent will not work.
</p><p>One solution to this problem is to make the snmp application
a distributed Erlang application, and that means, the agent
may be configured to run on one of several nodes.  If the node
where it runs goes down, another node restarts the agent.
This is called <em>failover</em>.  When the node starts again,
it may  <em>takeover</em> the application.  This solution to
the problem adds another problem.  Generally, the new node has
another IP address than the first one, which may cause
problems in the  communication between the SNMP managers and
the agent.
</p><p>If the snmp agent is configured as a distributed Erlang
application, it will during takeover try to load the same MIBs
that were loaded at the old node. It uses the same filenames
as the old node. If the MIBs are not located in the same
paths at the different nodes, the MIBs must be loaded
explicitly after takeover.
</p><h4>Using Mnesia Tables as SNMP Tables</h4><p>The Mnesia DBMS can be used for storing data of SNMP
tables. This means that an SNMP table can be implemented as a
Mnesia table, and that a Mnesia table can be made visible via
SNMP. This mapping is largely automated.
</p><p>There are three main reasons for using this mapping:
</p><ul><li>We get all features of Mnesia, such as fault tolerance, persistent data storage, replication, and so on. </li><li>Much of the work involved is automated. This includes <strong>get-next</strong> processing and <strong>RowStatus</strong> handling. </li><li>The table may be used as an ordinary Mnesia table, using the Mnesia API internally in the application at the same time as it is visible through SNMP. </li></ul><p>When this mapping is used, insertion and deletion in the
original Mnesia table is slower, with a factor O(log n). The read
access is not affected.
</p><p>A drawback with implementing an SNMP table as a Mnesia table is
that the internal resource is forced to use the table definition
from the MIB, which means that the external data model must be
used internally. Actually, this is only partially true. The Mnesia
table may extend the SNMP table, which means that the Mnesia table
may have columns which are use internally and are not seen by
SNMP. Still, the data model from SNMP must be maintained. Although
this is undesirable, it is a pragmatic compromise in many
situations where simple and efficient implementation is preferable
to abstraction.
</p><h4>Creating the Mnesia Table</h4><p>The table must be created in Mnesia before the manager can
use it. The table must be declared as type <strong>snmp</strong>.  This
makes the table ordered in accordance with the lexicographical
ordering rules of SNMP.  The name of the Mnesia table must be
identical to the SNMP table name.  The types of the INDEX fields
in the corresponding SNMP table must be specified.
</p><p>If the SNMP table has more than one INDEX column, the
corresponding Mnesia row is a tuple, where the first element 
is a tuple with the INDEX columns. Generally, if the SNMP table 
has <em>N</em> INDEX columns and <em>C</em> data columns, the 
Mnesia table is of arity <em>(C-N)+1</em>, where the key is a 
tuple of arity <em>N</em> if <em>N &gt; 1</em>, or a single term 
if <em>N = 1</em>.
</p><p>Refer to the Mnesia User's Guide for information on how to
declare a Mnesia table as an SNMP table.
</p><p>The following example illustrates a situation in which we
have an SNMP table that we wish to implement as a Mnesia
table. The table stores information about employees at a
company. Each employee is indexed with the department number and
the name.
</p><pre><code class="">
       empTable OBJECT-TYPE
              SYNTAX      SEQUENCE OF EmpEntry
              ACCESS      not-accessible
              STATUS      mandatory
              DESCRIPTION
                      "A table with information about employees."
       ::= { emp 1}
       empEntry OBJECT-TYPE
              SYNTAX      EmpEntry
              ACCESS      not-accessible
              STATUS      mandatory
              DESCRIPTION
                 ""
              INDEX      { empDepNo, empName }
       ::= { empTable 1 }
       EmpEntry ::=
              SEQUENCE {
                  empDepNo         INTEGER,
                  empName          DisplayString,
                  empTelNo         DisplayString,
                  empStatus        RowStatus
              }
      </code></pre><p>The corresponding Mnesia table is specified as follows:
</p><pre><code class="">
mnesia:create_table([{name, employees},
                     {snmp, [{key, {integer, string}}]},
                     {attributes, [key, telno, row_status]}]).
      </code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>In the Mnesia tables, the two key columns are stored as a
tuple with two elements. Therefore, the arity of the table is
3.</p></div><h4>Instrumentation Functions</h4><p>The MIB table shown in the previous section can be compiled
as follows:
</p><pre>
1&gt; <span class="input">snmpc:compile("EmpMIB", [{db, mnesia}]).</span>
      </pre><p>This is all that has to be done! Now the manager can read,
add, and modify rows. Also, you can use the ordinary Mnesia API
to access the table from your programs. The only explicit action
is to create the Mnesia table, an action the user has to perform
in order to create the required table schemas.</p><h4>Adding Own Actions</h4><p>It is often necessary to take some specific action when a
table is modified. This is accomplished with an instrumentation
function. It executes some specific code when the table is set,
and passes all other requests down to the pre-defined function.
</p><p>The following example illustrates this idea:
</p><pre><code class="">
emp_table(set, RowIndex, Cols) -&gt;
    notify_internal_resources(RowIndex, Cols),
    snmp_generic:table_func(set, RowIndex, Cols, {empTable, mnesia});
emp_table(Op, RowIndex, Cols) -&gt;
    snmp_generic:table_func(Op, RowIndex, Cols, {empTable, mnesia}).
      </code></pre><p>The default instrumentation functions are defined in the
module <strong>snmp_generic</strong>. Refer to the Reference Manual,
section SNMP, module <strong>snmp_generic</strong> for details.</p><h4>Extending the Mnesia Table</h4><p>A table may contain columns that are used internally, but
should not be visible to a manager. These internal columns must
be the last columns in the table. The <strong>set</strong> operation will
not work with this arrangement, because there are columns that
the agent does not know about. This situation is handled by
adding values for the internal columns in the <strong>set</strong>
function.
</p><p>To illustrate this, suppose we extend our Mnesia
<strong>empTable</strong> with one internal column. We create it as
before, but with an arity of 4, by adding another attribute.
</p><pre><code class="">
mnesia:create_table([{name, employees},
                     {snmp, [{key, {integer, string}}]},
                     {attributes, {key, telno, row_status, internal_col}}]).
      </code></pre><p>The last column is the internal column. When performing a
<strong>set</strong> operation, which creates a row, we must give a
value to the internal column. The instrumentation functions will now
look as follows:
</p><pre><code class="">
-define(createAndGo, 4).
-define(createAndWait, 5).

emp_table(set, RowIndex, Cols) -&gt;
  notify_internal_resources(RowIndex, Cols),
  NewCols =
    case is_row_created(empTable, Cols) of
      true -&gt; Cols ++ [{4, "internal"}]; % add internal column
      false -&gt; Cols                      % keep original cols
  end,
  snmp_generic:table_func(set, RowIndex, NewCols, {empTable, mnesia});
emp_table(Op, RowIndex, Cols) -&gt;
  snmp_generic:table_func(Op, RowIndex, Cols, {empTable, mnesia}).

is_row_created(Name, Cols) -&gt;
  case snmp_generic:get_status_col(Name, Cols) of
    {ok, ?createAndGo} -&gt; true;
    {ok, ?createAndWait} -&gt; true;
    _ -&gt; false
  end.
      </code></pre><p>If a row is created, we always set the internal column to
<strong>"internal"</strong>.
</p><h4>Deviations from the Standard</h4><p>In some aspects the agent does not implement SNMP fully.  Here
are the differences:
</p><ul><li>The default functions and <strong>snmp_generic</strong> cannot handle an object of type <strong>NetworkAddress</strong> as INDEX (SNMPv1 only!).  Use <strong>IpAddress</strong> instead. </li><li>The agent does not check complex ranges specified for INTEGER objects.  In these cases it just checks that the value lies within the minimum and maximum values specified.  For example, if the range is specified as <strong>1..10 | 12..20</strong> the agent would let 11 through, but not 0 or 21.  The instrumentation functions must check the complex ranges itself. </li><li>The agent will never generate the <strong>wrongEncoding</strong> error.  If a variable binding is erroneous encoded, the <strong>asn1ParseError</strong> counter will be incremented. </li><li>A <strong>tooBig</strong> error in an SNMPv1 packet will always use the <strong>'NULL'</strong> value in all variable bindings. </li><li>The default functions and <strong>snmp_generic</strong> do not check the range of each OCTET in textual conventions derived from OCTET STRING, e.g. <strong>DisplayString</strong> and <strong>DateAndTime</strong>.  This must be checked in an overloaded <strong>is_set_ok</strong> function. </li></ul><h4>Appendix A</h4><p>This appendix describes the conversion of SNMPv2 to SNMPv1
error messages. The instrumentation functions should return v2
error messages.
</p><p>Mapping of SNMPv2 error message to SNMPv1:
</p><table class="table table-bordered table-hover table-striped"><caption>Error Messages</caption><tbody><tr><td>SNMPv2 message</td><td>SNMPv1 message</td></tr><tr><td>noError</td><td>noError</td></tr><tr><td>genErr</td><td>genErr</td></tr><tr><td>noAccess</td><td>noSuchName</td></tr><tr><td>wrongType</td><td>badValue</td></tr><tr><td>wrongLength</td><td>badValue</td></tr><tr><td>wrongEncoding</td><td>badValue</td></tr><tr><td>wrongValue</td><td>badValue</td></tr><tr><td>noCreation</td><td>noSuchName</td></tr><tr><td>inconsistentValue</td><td>badValue</td></tr><tr><td>resourceUnavailable</td><td>genErr</td></tr><tr><td>commitFailed</td><td>genErr</td></tr><tr><td>undoFailed</td><td>genErr</td></tr><tr><td>notWritable</td><td>noSuchName</td></tr><tr><td>inconsistentName</td><td>noSuchName</td></tr></tbody></table><h4>Appendix B</h4><h4>RowStatus (from RFC1903)</h4><pre>
RowStatus ::= TEXTUAL-CONVENTION
    STATUS       current
    DESCRIPTION
            "The RowStatus textual convention is used to manage the
            creation and deletion of conceptual rows, and is used as the
            value of the SYNTAX clause for the status column of a
            conceptual row (as described in Section 7.7.1 in RFC1902.)

            The status column has six defined values:

                 - `active', which indicates that the conceptual row is
                 available for use by the managed device;

                 - `notInService', which indicates that the conceptual
                 row exists in the agent, but is unavailable for use by
                 the managed device (see NOTE below);

                 - `notReady', which indicates that the conceptual row
                 exists in the agent, but is missing information
                 necessary in order to be available for use by the
                 managed device;

                 - `createAndGo', which is supplied by a management
                 station wishing to create a new instance of a
                 conceptual row and to have its status automatically set
                 to active, making it available for use by the managed
                 device;

                 - `createAndWait', which is supplied by a management
                 station wishing to create a new instance of a
                 conceptual row (but not make it available for use by
                 the managed device); and,

                 - `destroy', which is supplied by a management station
                 wishing to delete all of the instances associated with
                 an existing conceptual row.

            Whereas five of the six values (all except `notReady') may
            be specified in a management protocol set operation, only
            three values will be returned in response to a management
            protocol retrieval operation:  `notReady', `notInService' or
            `active'.  That is, when queried, an existing conceptual row
            has only three states:  it is either available for use by
            the managed device (the status column has value `active');
            it is not available for use by the managed device, though
            the agent has sufficient information to make it so (the
            status column has value `notInService'); or, it is not
            available for use by the managed device, and an attempt to
            make it so would fail because the agent has insufficient
            information (the state column has value `notReady').


                                     NOTE WELL

                 This textual convention may be used for a MIB table,
                 irrespective of whether the values of that table's
                 conceptual rows are able to be modified while it is
                 active, or whether its conceptual rows must be taken
                 out of service in order to be modified.  That is, it is
                 the responsibility of the DESCRIPTION clause of the
                 status column to specify whether the status column must
                 not be `active' in order for the value of some other
                 column of the same conceptual row to be modified.  If
                 such a specification is made, affected columns may be
                 changed by an SNMP set PDU if the RowStatus would not
                 be equal to `active' either immediately before or after
                 processing the PDU.  In other words, if the PDU also
                 contained a varbind that would change the RowStatus
                 value, the column in question may be changed if the
                 RowStatus was not equal to `active' as the PDU was
                 received, or if the varbind sets the status to a value
                 other than 'active'.


            Also note that whenever any elements of a row exist, the
            RowStatus column must also exist.

            To summarize the effect of having a conceptual row with a
            status column having a SYNTAX clause value of RowStatus,
            consider the following state diagram:


                                         STATE
              +--------------+-----------+-------------+-------------
              |      A       |     B     |      C      |      D
              |              |status col.|status column|
              |status column |    is     |      is     |status column
    ACTION    |does not exist|  notReady | notInService|  is active
--------------+--------------+-----------+-------------+-------------
set status    |noError    -&gt;D|inconsist- |inconsistent-|inconsistent-
column to     |       or     |   entValue|        Value|        Value
createAndGo   |inconsistent- |           |             |
              |         Value|           |             |
--------------+--------------+-----------+-------------+-------------
set status    |noError  see 1|inconsist- |inconsistent-|inconsistent-
column to     |       or     |   entValue|        Value|        Value
createAndWait |wrongValue    |           |             |
--------------+--------------+-----------+-------------+-------------
set status    |inconsistent- |inconsist- |noError      |noError
column to     |         Value|   entValue|             |
active        |              |           |             |
              |              |     or    |             |
              |              |           |             |
              |              |see 2   -&gt;D|          -&gt;D|          -&gt;D
--------------+--------------+-----------+-------------+-------------
set status    |inconsistent- |inconsist- |noError      |noError   -&gt;C
column to     |         Value|   entValue|             |
notInService  |              |           |             |
              |              |     or    |             |      or
              |              |           |             |
              |              |see 3   -&gt;C|          -&gt;C|wrongValue
--------------+--------------+-----------+-------------+-------------
set status    |noError       |noError    |noError      |noError
column to     |              |           |             |
destroy       |           -&gt;A|        -&gt;A|          -&gt;A|          -&gt;A
--------------+--------------+-----------+-------------+-------------
set any other |see 4         |noError    |noError      |see 5
column to some|              |           |             |
value         |              |      see 1|          -&gt;C|          -&gt;D
--------------+--------------+-----------+-------------+-------------

            (1) goto B or C, depending on information available to the
            agent.

            (2) if other variable bindings included in the same PDU,
            provide values for all columns which are missing but
            required, then return noError and goto D.

            (3) if other variable bindings included in the same PDU,
            provide values for all columns which are missing but
            required, then return noError and goto C.

            (4) at the discretion of the agent, the return value may be
            either:

                 inconsistentName:  because the agent does not choose to
                 create such an instance when the corresponding
                 RowStatus instance does not exist, or

                 inconsistentValue:  if the supplied value is
                 inconsistent with the state of some other MIB object's
                 value, or

                 noError: because the agent chooses to create the
                 instance.

            If noError is returned, then the instance of the status
            column must also be created, and the new state is B or C,
            depending on the information available to the agent.  If
            inconsistentName or inconsistentValue is returned, the row
            remains in state A.

            (5) depending on the MIB definition for the column/table,
            either noError or inconsistentValue may be returned.

            NOTE: Other processing of the set request may result in a
            response other than noError being returned, e.g.,
            wrongValue, noCreation, etc.


                              Conceptual Row Creation

            There are four potential interactions when creating a
            conceptual row:  selecting an instance-identifier which is
            not in use; creating the conceptual row; initializing any
            objects for which the agent does not supply a default; and,
            making the conceptual row available for use by the managed
            device.


            Interaction 1: Selecting an Instance-Identifier

            The algorithm used to select an instance-identifier varies
            for each conceptual row.  In some cases, the instance-
            identifier is semantically significant, e.g., the
            destination address of a route, and a management station
            selects the instance-identifier according to the semantics.

            In other cases, the instance-identifier is used solely to
            distinguish conceptual rows, and a management station
            without specific knowledge of the conceptual row might
            examine the instances present in order to determine an
            unused instance-identifier.  (This approach may be used, but
            it is often highly sub-optimal; however, it is also a
            questionable practice for a naive management station to
            attempt conceptual row creation.)

            Alternately, the MIB module which defines the conceptual row
            might provide one or more objects which provide assistance
            in determining an unused instance-identifier.  For example,
            if the conceptual row is indexed by an integer-value, then
            an object having an integer-valued SYNTAX clause might be
            defined for such a purpose, allowing a management station to
            issue a management protocol retrieval operation.  In order
            to avoid unnecessary collisions between competing management
            stations, `adjacent' retrievals of this object should be
            different.

            Finally, the management station could select a pseudo-random
            number to use as the index.  In the event that this index
            was already in use and an inconsistentValue was returned in
            response to the management protocol set operation, the
            management station should simply select a new pseudo-random
            number and retry the operation.

            A MIB designer should choose between the two latter
            algorithms based on the size of the table (and therefore the
            efficiency of each algorithm).  For tables in which a large
            number of entries are expected, it is recommended that a MIB
            object be defined that returns an acceptable index for
            creation.  For tables with small numbers of entries, it is
            recommended that the latter pseudo-random index mechanism be
            used.


            Interaction 2: Creating the Conceptual Row

            Once an unused instance-identifier has been selected, the
            management station determines if it wishes to create and
            activate the conceptual row in one transaction or in a
            negotiated set of interactions.

            Interaction 2a: Creating and Activating the Conceptual Row

            The management station must first determine the column
            requirements, i.e., it must determine those columns for
            which it must or must not provide values.  Depending on the
            complexity of the table and the management station's
            knowledge of the agent's capabilities, this determination
            can be made locally by the management station.  Alternately,
            the management station issues a management protocol get
            operation to examine all columns in the conceptual row that
            it wishes to create.  In response, for each column, there
            are three possible outcomes:

                 - a value is returned, indicating that some other
                 management station has already created this conceptual
                 row.  We return to interaction 1.

                 - the exception `noSuchInstance' is returned,
                 indicating that the agent implements the object-type
                 associated with this column, and that this column in at
                 least one conceptual row would be accessible in the MIB
                 view used by the retrieval were it to exist. For those
                 columns to which the agent provides read-create access,
                 the `noSuchInstance' exception tells the management
                 station that it should supply a value for this column
                 when the conceptual row is to be created.

                 - the exception `noSuchObject' is returned, indicating
                 that the agent does not implement the object-type
                 associated with this column or that there is no
                 conceptual row for which this column would be
                 accessible in the MIB view used by the retrieval.  As
                 such, the management station cannot issue any
                 management protocol set operations to create an
                 instance of this column.

            Once the column requirements have been determined, a
            management protocol set operation is accordingly issued.
            This operation also sets the new instance of the status
            column to `createAndGo'.

            When the agent processes the set operation, it verifies that
            it has sufficient information to make the conceptual row
            available for use by the managed device.  The information
            available to the agent is provided by two sources:  the
            management protocol set operation which creates the
            conceptual row, and, implementation-specific defaults
            supplied by the agent (note that an agent must provide
            implementation-specific defaults for at least those objects
            which it implements as read-only).  If there is sufficient
            information available, then the conceptual row is created, a
            `noError' response is returned, the status column is set to
            `active', and no further interactions are necessary (i.e.,
            interactions 3 and 4 are skipped).  If there is insufficient
            information, then the conceptual row is not created, and the
            set operation fails with an error of `inconsistentValue'.
            On this error, the management station can issue a management
            protocol retrieval operation to determine if this was
            because it failed to specify a value for a required column,
            or, because the selected instance of the status column
            already existed.  In the latter case, we return to
            interaction 1.  In the former case, the management station
            can re-issue the set operation with the additional
            information, or begin interaction 2 again using
            `createAndWait' in order to negotiate creation of the
            conceptual row.

                                     NOTE WELL

                 Regardless of the method used to determine the column
                 requirements, it is possible that the management
                 station might deem a column necessary when, in fact,
                 the agent will not allow that particular columnar
                 instance to be created or written.  In this case, the
                 management protocol set operation will fail with an
                 error such as `noCreation' or `notWritable'.  In this
                 case, the management station decides whether it needs
                 to be able to set a value for that particular columnar
                 instance.  If not, the management station re-issues the
                 management protocol set operation, but without setting
                 a value for that particular columnar instance;
                 otherwise, the management station aborts the row
                 creation algorithm.

            Interaction 2b: Negotiating the Creation of the Conceptual
            Row

            The management station issues a management protocol set
            operation which sets the desired instance of the status
            column to `createAndWait'.  If the agent is unwilling to
            process a request of this sort, the set operation fails with
            an error of `wrongValue'.  (As a consequence, such an agent
            must be prepared to accept a single management protocol set
            operation, i.e., interaction 2a above, containing all of the
            columns indicated by its column requirements.)  Otherwise,
            the conceptual row is created, a `noError' response is
            returned, and the status column is immediately set to either
            `notInService' or `notReady', depending on whether it has
            sufficient information to make the conceptual row available
            for use by the managed device.  If there is sufficient
            information available, then the status column is set to
            `notInService'; otherwise, if there is insufficient
            information, then the status column is set to `notReady'.
            Regardless, we proceed to interaction 3.

            Interaction 3: Initializing non-defaulted Objects

            The management station must now determine the column
            requirements.  It issues a management protocol get operation
            to examine all columns in the created conceptual row.  In
            the response, for each column, there are three possible
            outcomes:

                 - a value is returned, indicating that the agent
                 implements the object-type associated with this column
                 and had sufficient information to provide a value.  For
                 those columns to which the agent provides read-create
                 access (and for which the agent allows their values to
                 be changed after their creation), a value return tells
                 the management station that it may issue additional
                 management protocol set operations, if it desires, in
                 order to change the value associated with this column.

                 - the exception `noSuchInstance' is returned,
                 indicating that the agent implements the object-type
                 associated with this column, and that this column in at
                 least one conceptual row would be accessible in the MIB
                 view used by the retrieval were it to exist. However,
                 the agent does not have sufficient information to
                 provide a value, and until a value is provided, the
                 conceptual row may not be made available for use by the
                 managed device.  For those columns to which the agent
                 provides read-create access, the `noSuchInstance'
                 exception tells the management station that it must
                 issue additional management protocol set operations, in
                 order to provide a value associated with this column.

                 - the exception `noSuchObject' is returned, indicating
                 that the agent does not implement the object-type
                 associated with this column or that there is no
                 conceptual row for which this column would be
                 accessible in the MIB view used by the retrieval.  As
                 such, the management station cannot issue any
                 management protocol set operations to create an
                 instance of this column.

            If the value associated with the status column is
            `notReady', then the management station must first deal with
            all `noSuchInstance' columns, if any.  Having done so, the
            value of the status column becomes `notInService', and we
            proceed to interaction 4.

            Interaction 4: Making the Conceptual Row Available

            Once the management station is satisfied with the values
            associated with the columns of the conceptual row, it issues
            a management protocol set operation to set the status column
            to `active'.  If the agent has sufficient information to
            make the conceptual row available for use by the managed
            device, the management protocol set operation succeeds (a
            `noError' response is returned).  Otherwise, the management
            protocol set operation fails with an error of
            `inconsistentValue'.


                                     NOTE WELL

                 A conceptual row having a status column with value
                 `notInService' or `notReady' is unavailable to the
                 managed device.  As such, it is possible for the
                 managed device to create its own instances during the
                 time between the management protocol set operation
                 which sets the status column to `createAndWait' and the
                 management protocol set operation which sets the status
                 column to `active'.  In this case, when the management
                 protocol set operation is issued to set the status
                 column to `active', the values held in the agent
                 supersede those used by the managed device.

            If the management station is prevented from setting the
            status column to `active' (e.g., due to management station
            or network failure) the conceptual row will be left in the
            `notInService' or `notReady' state, consuming resources
            indefinitely.  The agent must detect conceptual rows that
            have been in either state for an abnormally long period of
            time and remove them.  It is the responsibility of the
            DESCRIPTION clause of the status column to indicate what an
            abnormally long period of time would be.  This period of
            time should be long enough to allow for human response time
            (including `think time') between the creation of the
            conceptual row and the setting of the status to `active'.
            In the absence of such information in the DESCRIPTION
            clause, it is suggested that this period be approximately 5
            minutes in length.  This removal action applies not only to
            newly-created rows, but also to previously active rows which
            are set to, and left in, the notInService state for a
            prolonged period exceeding that which is considered normal
            for such a conceptual row.


                             Conceptual Row Suspension

            When a conceptual row is `active', the management station
            may issue a management protocol set operation which sets the
            instance of the status column to `notInService'.  If the
            agent is unwilling to do so, the set operation fails with an
            error of `wrongValue'.  Otherwise, the conceptual row is
            taken out of service, and a `noError' response is returned.
            It is the responsibility of the DESCRIPTION clause of the
            status column to indicate under what circumstances the
            status column should be taken out of service (e.g., in order
            for the value of some other column of the same conceptual
            row to be modified).


                              Conceptual Row Deletion

            For deletion of conceptual rows, a management protocol set
            operation is issued which sets the instance of the status
            column to `destroy'.  This request may be made regardless of
            the current value of the status column (e.g., it is possible
            to delete conceptual rows which are either `notReady',
            `notInService' or `active'.)  If the operation succeeds,
            then all instances associated with the conceptual row are
            immediately removed."


    SYNTAX       INTEGER {
                     -- the following two values are states:
                     -- these values may be read or written
                     active(1),
                     notInService(2),

                     -- the following value is a state:
                     -- this value may be read, but not written
                     notReady(3),

                     -- the following three values are
                     -- actions: these values may be written,
                     --   but are never read
                     createAndGo(4),
                     createAndWait(5),
                     destroy(6)
                 }
      </pre><p>A multilingual Simple Network Management Protocol 
application featuring an Extensible Agent, simple manager,
a MIB compiler and facilities for implementing SNMP MIBs etc.
</p><h3>snmp</h3><p>Interface functions to the SNMP toolkit</p><p>The module <strong>snmp</strong> contains interface functions to the 
SNMP toolkit.</p><h4>Common Data Types</h4><p>The following data-types are used in the functions below: </p><ul><li> <p><strong>datetime() = {date(), time()}</strong></p> <p>See <a href="./calendar">calendar</a> 
for more info.</p> </li></ul><a name="config"></a><h3>Functions</h3><h4>config() -&gt; ok | {error, Reason}</h4><p>Configure with a simple interactive tool</p><p>A simple interactive configuration tool. Simple
configuration files can be generated, but more complex
configurations still have to be edited manually.
</p><p>The tool is a textual based tool that asks some questions
and generates <strong>sys.config</strong> and <strong>*.conf</strong> files.
</p><p><em>Note</em> that if the application shall support version 3, 
then the crypto app must be started before running this function 
(password generation).</p><p><em>Note</em> also that some of the configuration files for the 
agent and manager share the same names. This means that 
they have to be stored in <em>different</em> directories!</p><a name="start"></a><h4>start() -&gt; ok | {error, Reason}</h4><h4>start(Type) -&gt; ok | {error, Reason}</h4><p>Start the SNMP application</p><ul><li><span class="v">Type = start_type()</span></li></ul><p>Starts the SNMP application.</p><p>See <a href="./application">application</a> for more info.</p><a name="start_agent"></a><h4>start_agent() -&gt; ok | {error, Reason}</h4><h4>start_agent(Type) -&gt; ok | {error, Reason}</h4><p>Start the agent part of the SNMP application</p><ul><li><span class="v">Type = start_type()</span></li></ul><p>The SNMP application consists of several entities, of which the
agent is one. This function starts the agent entity of the 
application. 
</p><p>Note that the only way to actually start the agent in this way is
to add the agent related config after starting the application (e.g
it cannot be part of the normal application config; sys.config).
This is done by calling: 
<strong>application:set_env(snmp, agent, Conf)</strong>.
</p><p>The default value for <strong>Type</strong> is <strong>normal</strong>.</p><a name="start_manager"></a><h4>start_manager() -&gt; ok | {error, Reason}</h4><h4>start_manager(Type) -&gt; ok | {error, Reason}</h4><p>Start the manager part of the SNMP application</p><ul><li><span class="v">Type = start_type()</span></li></ul><p>The SNMP application consists of several entities, of which the
manager is one. This function starts the manager entity of the 
application. 
</p><p>Note that the only way to actually start the manager in this way is
to add the manager related config after starting the application (e.g
it cannot be part of the normal application config; sys.config).
This is done by calling: 
<strong>application:set_env(snmp, manager, Conf)</strong>.
</p><p>The default value for <strong>Type</strong> is <strong>normal</strong>.</p><a name="dat"></a><h4>date_and_time() -&gt; DateAndTime</h4><p>Return the current date and time as an OCTET STRING</p><ul><li><span class="v">DateAndTime = [int()]</span></li></ul><p>Returns current date and time as the data type DateAndTime,
as specified in RFC1903. This is an OCTET STRING.</p><a name="dat2ut_dst"></a><h4>date_and_time_to_universal_time_dst(DateAndTime) -&gt; [utc()]</h4><p>Convert a DateAndTime value to a list of possible utc()</p><ul><li><span class="v">DateAndTime = [int()]</span></li><li><span class="v">utc() = {{Y,Mo,D},{H,M,S}}</span></li></ul><p>Converts a DateAndTime list to a list of possible universal 
time(s). The universal time value on the same format as defined in
calendar(3). </p><a name="dat2s"></a><h4>date_and_time_to_string(DateAndTime) -&gt; string()</h4><h4>date_and_time_to_string(DateAndTime, Validate) -&gt; string()</h4><p>Convert a DateAndTime value to a string</p><ul><li><span class="v">DateAndTime = [int()]</span></li><li><span class="v">Validate = fun(Kind, Data) -&gt; boolean()</span></li></ul><p>Converts a DateAndTime list to a printable string, according
to the DISPLAY-HINT definition in RFC2579.</p><p>The validation fun,  <strong>Validate</strong>, allows for a more "flexible" 
validation of the <strong>DateAndTime</strong> argument. Whenever the data 
is found to not follow RFC2579, the fun is called to allow a more
"lax" validation. 
See the <a href="#vdat">validate_date_and_time/2</a> 
function for more info on the <strong>Validate</strong> fun. </p><a name="dat2s2"></a><h4>date_and_time_to_string2(DateAndTime) -&gt; string()</h4><p>Convert a DateAndTime value to a string</p><ul><li><span class="v">DateAndTime = [int()]</span></li></ul><p>Converts a DateAndTime list to a printable string, according
to the DISPLAY-HINT definition in RFC2579, with the extension 
that it also allows the values "hours from UTC" = 14 together with 
"minutes from UTC" = 0. </p><a name="lt2dat_dst"></a><h4>local_time_to_date_and_time_dst(Local) -&gt; [DateAndTime]</h4><p>Convert a Local time value to a list of possible DateAndTime(s)</p><ul><li><span class="v">Local = {{Y,Mo,D},{H,M,S}}</span></li><li><span class="v">DateAndTime = [int()]</span></li></ul><p>Converts a local time value to a list of possible DateAndTime 
list(s). The local time value on the same format as defined in 
calendar(3).</p><a name="ut2dat"></a><h4>universal_time_to_date_and_time(UTC) -&gt; DateAndTime</h4><p>Convert a UTC value to DateAndTime</p><ul><li><span class="v">UTC = {{Y,Mo,D},{H,M,S}}</span></li><li><span class="v">DateAndTime = [int()]</span></li></ul><p>Converts a universal time value to a DateAndTime list.  The
universal time value on the same format as defined in calendar(3).</p><a name="vdat"></a><h4>validate_date_and_time(DateAndTime) -&gt; bool()</h4><h4>validate_date_and_time(DateAndTime, Validate) -&gt; bool()</h4><p>Check if a DateAndTime value is correct</p><ul><li><span class="v">DateAndTime = term()</span></li><li><span class="v">Validate = fun(Kind, Data) -&gt; boolean()</span></li></ul><p>Checks if <strong>DateAndTime</strong> is a correct DateAndTime
value, as specified in RFC2579.  This function can be used in
instrumentation functions to validate a DateAndTime value.</p><p>The validation fun,  <strong>Validate</strong>, allows for a more "flexible" 
validation of the <strong>DateAndTime</strong> argument. Whenever the data 
is found to not follow RFC2579, the fun is called to allow a more
"lax" validation. 
The input to the validation fun looks like this: </p><pre>
          Kind             Data
          --------------   ----------------------
          year             {Year1, Year2}
          month            Month
          day              Day
          hour             Hour
          minute           Minute
          seconds          Seconds
          deci_seconds     DeciSeconds
          diff             [Sign, Hour, Minute]
          valid_date       {Year, Month, Day}
	</pre><a name="passwd2localized_key"></a><h4>passwd2localized_key(Alg, Passwd, EngineID) -&gt; Key</h4><p>Generates an localized key</p><ul><li><span class="v">Alg = algorithm()</span></li><li><span class="v">algorithm() = md5 | sha</span></li><li><span class="v">Passwd = string()</span></li><li><span class="v">EngineID = string()</span></li><li><span class="v">Key = list()</span></li></ul><p>Generates a key that can be used as an authentication
or privacy key using MD5 och SHA.  The key is
localized for EngineID.</p><a name="octet_string_to_bits"></a><h4>octet_string_to_bits(S) -&gt; Val</h4><p>Convert an OCTET-STRING to BITS</p><ul><li><span class="v">Val = bits()</span></li></ul><p>Utility function for converting a value of type 
<strong>OCTET-STRING</strong> to <strong>BITS</strong>. </p><a name="bits_to_octet_string"></a><h4>bits_to_octet_string(B) -&gt; Val</h4><p>Convert an OCTET-STRING to BITS</p><ul><li><span class="v">Val = octet_string()</span></li></ul><p>Utility function for converting a value of type <strong>BITS</strong> 
to <strong>OCTET-STRING</strong>. </p><a name="read_mib"></a><h4>read_mib(FileName) -&gt; {ok, mib()} | {error, Reason}</h4><ul><li><span class="v">FileName = string()</span></li><li><span class="v">mib() = #mib{}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Read a compiled mib.</p><a name="log_to_txt"></a><h4>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile) -&gt;  ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block | Start) -&gt;  ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Start, Block | Stop) -&gt; ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Start, Stop, Block) -&gt; ok | {ok, Cnt} | {error, Reason}</h4><p>Convert an Audit Trail Log to text format</p><ul><li><span class="v">LogDir = string()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">OutFile = string()</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">LogName = string()</span></li><li><span class="v">LogFile = string()</span></li><li><span class="v">Start = Stop = null | datetime() | {local_time,datetime()} |  {universal_time,datetime()} </span></li><li><span class="v">Block = boolean()</span></li><li><span class="v">Cnt = {NumOK, NumERR}</span></li><li><span class="v">NumOK = non_neg_integer()</span></li><li><span class="v">NumERR = pos_integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Converts an Audit Trail Log to a readable text file, where
each item has a trailing TAB character, and any TAB
character in the body of an item has been replaced by ESC
TAB. </p><p>The function can be used on a running system, or by copying
the entire log directory and calling this function. SNMP
must be running in order to provide MIB information. </p><p><strong>LogDir</strong> is the name of the directory where the audit
trail log is stored. 
<strong>Mibs</strong> is a list of Mibs to be used. The function uses 
the information in the Mibs to convert for example object 
identifiers to their symbolic name. 
<strong>OutFile</strong> is the name of the generated text-file.
<strong>LogName</strong> is the name of the log, 
<strong>LogFile</strong> is the name of the log file. 
<strong>Start</strong> is the start (first) date and time from which 
log events will be converted and 
<strong>Stop</strong> is the stop (last) date and time to which log 
events will be converted.
The <strong>Block</strong> argument indicates if the log should be blocked
during conversion. This could be usefull when converting large 
logs (when otherwise the log could wrap during conversion). 
Defaults to <strong>true</strong>. 
</p><p>The format of an audit trail log text item is as follows: </p><p><strong>Tag Addr - Community [TimeStamp] Vsn</strong><br/>
<strong>PDU</strong></p><p>where <strong>Tag</strong> is <strong>request</strong>, <strong>response</strong>, 
<strong>report</strong>, <strong>trap</strong> or <strong>inform</strong>; Addr is 
<strong>IP:Port</strong> (or comma space separated list of such);
<strong>Community</strong> is the community parameter (SNMP version
v1 and v2), or <strong>SecLevel:"AuthEngineID":"UserName"</strong>
(SNMP v3); <strong>TimeStamp</strong> is a date and time stamp,
and <strong>Vsn</strong> is the SNMP version. <strong>PDU</strong> is a textual
version of the protocol data unit. There is a new line
between <strong>Vsn</strong> and <strong>PDU</strong>.</p><p>If the entire log is successfully converted, the function 
will return <strong>ok</strong>. 
If one of more entries fail to convert, the function will instead
return <strong>{ok, {NumOK, NumERR}}</strong>, where the counters indicate
how many valid and erroneous entries where found. 
If instead <strong>{error, Reason}</strong> is returned, the conversion 
encountered a fatal error and where either never done of aborted
midway. </p><a name="log_to_io"></a><h4>log_to_io(LogDir, Mibs, LogName, LogFile) -&gt;  ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_io(LogDir, Mibs, LogName, LogFile, Block | Start) -&gt;  ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_io(LogDir, Mibs, LogName, LogFile, Start, Block | Stop) -&gt; ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_io(LogDir, Mibs, LogName, LogFile, Start, Stop, Block) -&gt; ok | {ok, Cnt} | {error, Reason}</h4><p>Convert an Audit Trail Log to text format</p><ul><li><span class="v">LogDir = string()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">LogName = string()</span></li><li><span class="v">LogFile = string()</span></li><li><span class="v">Start = Stop = null | datetime() | {local_time,datetime()} |  {universal_time,datetime()} </span></li><li><span class="v">Cnt = {NumOK, NumERR}</span></li><li><span class="v">NumOK = non_neg_integer()</span></li><li><span class="v">NumERR = pos_integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Converts an Audit Trail Log to a readable format and 
prints it on stdio. See 
<a href="./snmp#log_to_txt">log_to_txt</a> 
above for more info.</p><a name="change_log_size"></a><h4>change_log_size(LogName, NewSize) -&gt; ok | {error, Reason}</h4><p>Change the size of the Audit Trail Log</p><ul><li><span class="v">LogName = string()</span></li><li><span class="v">NewSize = {MaxBytes, MaxFiles}</span></li><li><span class="v">MaxBytes = integer()</span></li><li><span class="v">MaxFiles = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Changes the log size of the Audit Trail Log.  The
application must be configured to use the audit trail log
function. Please refer to disk_log(3) in Kernel Reference 
Manual for a description of how to change the log size.
</p><p>The change is permanent, as long as the log is not deleted. 
That means, the log size is remembered across reboots.</p><a name="print_version_info"></a><h4>print_version_info() -&gt; void()</h4><h4>print_version_info(Prefix) -&gt; void()</h4><p>Formatted print of result of the versions functions</p><ul><li><span class="v">Prefix = string() | integer()</span></li></ul><p>Utility function(s) to produce a formatted printout of the versions
info generated by the <strong>versions1</strong> function</p><p>This is the same as doing, e.g.: </p><pre>
           {ok, V} = snmp:versions1(), 
           snmp:print_versions(V).
        </pre><a name="versions1"></a><a name="versions2"></a><h4>versions1() -&gt; {ok, Info} | {error, Reason}</h4><h4>versions2() -&gt; {ok, Info} | {error, Reason}</h4><p>Retrieve various system and application info</p><ul><li><span class="v">Info = [info()]</span></li><li><span class="v">info() = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Utility functions used to retrieve some system and
application info.</p><p>The difference between the two functions is in how they get
the modules to check. <strong>versions1</strong> uses the app-file and
<strong>versions2</strong> uses the function <strong>application:get_key</strong>.</p><a name="print_versions"></a><h4>print_versions(VersionInfo) -&gt; void()</h4><h4>print_versions(Prefix, VersionInfo) -&gt; void()</h4><p>Formatted print of result of the versions functions</p><ul><li><span class="v">VersionInfo = [version_info()]</span></li><li><span class="v">version_info() = term()</span></li><li><span class="v">Prefix = string() | integer()</span></li></ul><p>Utility function to produce a formatted printout of the versions
info generated by the <strong>versions1</strong> and <strong>versions2</strong>
functions</p><p>Example: </p><pre>
           {ok, V} = snmp:versions1(), 
           snmp:print_versions(V).
        </pre><a name="enable_trace"></a><h4>enable_trace() -&gt; void()</h4><p>Starts a tracer</p><p>Starts a dbg tracer that prints trace events to stdout (using
plain io:format after a minor formatting). </p><a name="disable_trace"></a><h4>disable_trace() -&gt; void()</h4><p>Stop the tracer</p><p>Stop the tracer. </p><a name="set_trace1"></a><h4>set_trace(Targets) -&gt; void()</h4><p>Set trace target</p><ul><li><span class="v">Targets = target() | targets()</span></li><li><span class="v">target() = module()</span></li><li><span class="v">module() = atom()</span></li><li><span class="v">targets() = [target() | {target(), target_options()}]</span></li><li><span class="v">target_options() = [target_option()]</span></li><li><span class="v">target_option() = {return_trace, boolean()} | {scope, scope()}</span></li><li><span class="v">scope() = all_functions | exported_functions | function_name() | {function_name(), function_arity()}</span></li><li><span class="v">function_name() = atom()</span></li><li><span class="v">function_arity() = integer() &gt;= 0</span></li></ul><p>This function is used to set up default trace on function(s) 
for the given module or modules. The scope of the trace will be 
all <em>exported</em> functions (both the call info and the return 
value). Timestamp info will also be included. </p><a name="reset_trace"></a><h4>reset_trace(Targets) -&gt; void()</h4><p>Reset trace target</p><ul><li><span class="v">Targets = module() | modules()</span></li><li><span class="v">modules() = [module()]</span></li><li><span class="v">module() = atom()</span></li></ul><p>This function is used to reset (disable) trace for the 
given module(s). </p><a name="set_trace2"></a><h4>set_trace(Targets, Opts) -&gt; void()</h4><p>Set trace target</p><ul><li><span class="v">Targets = target() | targets()</span></li><li><span class="v">target() = module()</span></li><li><span class="v">module() = atom()</span></li><li><span class="v">targets() = [target() | {target(), target_options()}]</span></li><li><span class="v">target_options() = [target_option()]</span></li><li><span class="v">target_option() = {return_trace, boolean()} | {scope, scope()}</span></li><li><span class="v">scope() = all_functions | exported_functions | function_name() | {function_name(), function_arity()}</span></li><li><span class="v">function_name() = atom()</span></li><li><span class="v">function_arity() = integer() &gt;= 0</span></li><li><span class="v">Opts = disable | trace_options()</span></li><li><span class="v">trace_options() = [trace_option()]</span></li><li><span class="v">trace_option() = {timestamp, boolean()} | target_option()</span></li></ul><p>This function is used to set up trace on function(s) for the given
module or modules. </p><p>The example below sets up trace on the exported functions (default) 
of module <strong>snmp_generic</strong> and all functions of module 
<strong>snmp_generic_mnesia</strong>. With return values (which is default)
and timestamps in both cases (which is also default): </p><pre>
	  snmp:enable_trace(),
	  snmp:set_trace([snmp_generic, 
                          {snmp_generic_mnesia, [{scope, all_functions}]}]),
	  .
	  .
	  .
          snmp:set_trace(snmp_generic, disable),
	  .
	  .
	  .
	  snmp:disable_trace(),
	</pre><h4>See Also</h4><p>calendar(3)
</p><h3>snmp</h3><p>The SNMP Application</p><p>This chapter describes the <strong>snmp</strong>
application in OTP.  The SNMP application provides the following
services:<ul><li> <p>a multilingual extensible SNMP agent</p> </li><li> <p>a SNMP manager</p> </li><li> <p>a MIB compiler</p> </li></ul></p><a name="configuration_params"></a><h4>Configuration</h4><p>The following configuration parameters are defined for the SNMP
application. Refer to application(3) for more information about
configuration parameters.
</p><p>The snmp part of the config file specifying the configuration 
parameters is basically the following tuple:</p><pre>
      {snmp, snmp_components_config()}
    </pre><p>A minimal config file for starting a node with both a manager 
and an agent:</p><pre>
      [{snmp, 
        [{agent, [{db_dir, "/tmp/snmp/agent/db"},
                  {config, [{dir, "/tmp/snmp/agent/conf"}]}]},
         {manager, [{config, [{dir, "/tmp/snmp/manager/conf"},
                              {db_dir, "/tmp/snmp/manager/db"}]}]}]}
        ]
       }
      ].
    </pre><p>Each snmp component has its own set of configuration parameters,
even though some of the types are common to both components. </p><pre>
      snmp_components_config() -&gt; [snmp_component_config()]
      snmp_component_config() -&gt; {agent, agent_options()} | {manager, manager_options()}
      agent_options() = [agent_option()]
      agent_option() = {restart_type,     restart_type()}     | 
                       {agent_type,       agent_type()}       |  
                       {agent_verbosity,  verbosity()}        |  
                       {discovery,        agent_discovery()}  |  
                       {versions,         versions()}         |  
                       {gb_max_vbs,       gb_max_vbs()}       |  
                       {priority,         priority()}         |  
                       {multi_threaded,   multi_threaded()}   |  
                       {db_dir,           db_dir()}           |  
                       {db_init_error,    db_init_error()}    |  
                       {local_db,         local_db()}         |  
                       {net_if,           agent_net_if()}     |  
                       {mibs,             mibs()}             |  
                       {mib_storage,      mib_storage()}      |  
                       {mib_server,       mib_server()}       |  
                       {audit_trail_log,  audit_trail_log()}  |  
                       {error_report_mod, error_report_mod()} |  
                       {note_store,       note_store()}       |  
                       {symbolic_store,   symbolic_store()}   |  
                       {target_cache,     target_cache()}     |  
                       {config,           agent_config()}
      manager_options() = [manager_option()]
      manager_option() = {restart_type,             restart_type()}    | 
                         {net_if,                   manager_net_if()}  |  
                         {server,                   server()}          | 
                         {note_store,               note_store()}      | 
                         {config,                   manager_config()}  |  
                         {inform_request_behaviour, manager_irb()}     | 
                         {mibs,                     manager_mibs()}    | 
                         {priority,                 priority()}        |  
                         {audit_trail_log,          audit_trail_log()} | 
                         {versions,                 versions()}        | 
                         {def_user_mod,             def_user_module()  | 
                         {def_user_data,            def_user_data()}
    </pre><a name="agent_opts_and_types"></a><p>Agent specific config options and types:</p><dl><dt><a name="agent_type"></a> <strong>agent_type() = master | sub &lt;optional&gt;</strong></dt><dd> <p>If <strong>master</strong>, one master agent is
started. Otherwise, no agents are started. </p> <p>Default is <strong>master</strong>.</p> </dd><dt><a name="agent_disco"></a> <strong>agent_discovery() = [agent_discovery_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_discovery_opt() =  {terminating, agent_terminating_discovery_opts()} |  {originating, agent_originating_discovery_opts()}</strong></p> <p>The <strong>terminating</strong> options effects discovery initiated by 
a manager. </p> <p>The <strong>originating</strong> options effects discovery initiated 
by this agent. </p> <p>For defaults see the options in <strong>agent_discovery_opt()</strong>.</p> </dd><dt><a name="agent_term_disco_opts"></a> <strong>agent_terminating_discovery_opts() = [agent_terminating_discovery_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_terminating_discovery_opt() =  {enable, boolean()} |  {stage2, discovery | plain} |  {trigger_username, string()}</strong></p> <p>These are options effecting discovery <strong>terminating</strong> in this
agent (i.e. initiated by a manager). </p> <p>The default values for the <strong>terminating</strong> 
discovery options are: </p> <ul><li>enable: <strong>true</strong></li><li>stage2: <strong>discovery</strong></li><li>trigger_username: <strong>""</strong></li></ul> </dd><dt><a name="agent_orig_disco_opts"></a> <strong>agent_originating_discovery_opts() = [agent_originating_discovery_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_originating_discovery_opt() =  {enable, boolean()}</strong></p> <p>These are options effecting discovery <strong>originating</strong> in this
agent. </p> <p>The default values for the <strong>originating</strong> 
discovery options are: </p> <ul><li>enable: <strong>true</strong></li></ul> </dd><dt><a name="agent_mt"></a> <strong>multi_threaded() = bool() &lt;optional&gt;</strong></dt><dd> <p>If <strong>true</strong>, the agent is multi-threaded, with one
thread for each get request. </p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="agent_data_dir"></a> <strong>db_dir() = string() &lt;mandatory&gt;</strong></dt><dd> <p>Defines where the SNMP agent internal db files are stored.</p> </dd><dt><a name="agent_gb_max_vbs"></a> <strong>gb_max_vbs() = pos_integer() | infinity &lt;optional&gt;</strong></dt><dd> <p>Defines the maximum number of varbinds allowed 
in a Get-BULK response.</p> <p>Default is <strong>1000</strong>.</p> </dd><dt><a name="agent_local_db"></a> <strong>local_db() = [local_db_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>local_db_opt() = {repair, agent_repair()} | {auto_save, agent_auto_save()} |   {verbosity, verbosity()}</strong></p> <p>Defines options specific for the SNMP agent local database.</p> <p>For defaults see the options in <strong>local_db_opt()</strong>.</p> </dd><dt><a name="agent_ldb_repair"></a> <strong>agent_repair() = false | true | force &lt;optional&gt;</strong></dt><dd> <p>When starting snmpa_local_db it always tries to open an
existing database. If <strong>false</strong>, and some errors occur, a new
database is created instead. If <strong>true</strong>, an existing file
will be repaired. If <strong>force</strong>, the table will be repaired
even if it was properly closed. </p> <p>Default is <strong>true</strong>.</p> </dd><dt><a name="agent_ldb_auto_save"></a> <strong>agent_auto_save() = integer() | infinity &lt;optional&gt;</strong></dt><dd> <p>The auto save interval. The table is flushed to disk
whenever not accessed for this amount of time.</p> <p>Default is <strong>5000</strong>.</p> </dd><dt><a name="agent_net_if"></a> <strong>agent_net_if() = [agent_net_if_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_net_if_opt() = {module, agent_net_if_module()} |  {verbosity, verbosity()} |  {options, agent_net_if_options()}</strong></p> <p>Defines options specific for the SNMP agent network interface 
entity. </p> <p>For defaults see the options in <strong>agent_net_if_opt()</strong>.</p> </dd><dt><a name="agent_ni_module"></a> <strong>agent_net_if_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>Module which handles the network interface part for the
SNMP agent. Must implement the 
<a href="snmpa_network_interface">snmpa_network_interface</a> behaviour.</p> <p>Default is <strong>snmpa_net_if</strong>.</p> </dd><dt><a name="agent_ni_opts"></a> <strong>agent_net_if_options() = [agent_net_if_option()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_net_if_option() = {bind_to, bind_to()} |   {sndbuf, sndbuf()} |   {recbuf, recbuf()} |   {no_reuse, no_reuse()} |   {req_limit, req_limit()} | {filter, agent_net_if_filter_options()}</strong></p> <p>These options are actually specific to the used module.
The ones shown here are applicable to the default 
<strong>agent_net_if_module()</strong>.</p> <p>For defaults see the options in <strong>agent_net_if_option()</strong>.</p> </dd><dt><a name="agent_ni_req_limit"></a> <strong>req_limit() = integer() | infinity &lt;optional&gt;</strong></dt><dd> <p>Max number of simultaneous requests handled by the agent.</p> <p>Default is <strong>infinity</strong>.</p> </dd><dt><a name="agent_ni_filter_opts"></a> <strong>agent_net_if_filter_options() = [agent_net_if_filter_option()] &lt;optional&gt;</strong></dt><dd> <p><strong>agent_net_if_filter_option() = {module, agent_net_if_filter_module()}</strong></p> <p>These options are actually specific to the used module.
The ones shown here are applicable to the default 
<strong>agent_net_if_filter_module()</strong>.</p> <p>For defaults see the options in 
<strong>agent_net_if_filter_option()</strong>.</p> </dd><dt><a name="agent_ni_filter_module"></a> <strong>agent_net_if_filter_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>Module which handles the network interface filter part for the
SNMP agent. Must implement the 
<a href="snmpa_network_interface_filter">snmpa_network_interface_filter</a> behaviour.</p> <p>Default is <strong>snmpa_net_if_filter</strong>.</p> </dd><dt><a name="agent_mibs"></a> <strong>agent_mibs() = [string()] &lt;optional&gt;</strong></dt><dd> <p>Specifies a list of MIBs (including path) that defines which MIBs
are initially loaded into the SNMP master agent. </p> <p>Note that the following mibs will always be loaded:</p> <ul><li>version v1: <strong>STANDARD-MIB</strong></li><li>version v2: <strong>SNMPv2</strong></li><li>version v3: <strong>SNMPv2</strong>, <strong>SNMP-FRAMEWORK-MIB</strong>  and <strong>SNMP-MPD-MIB</strong></li></ul> <p>Default is <strong>[]</strong>.</p> </dd><dt><a name="agent_mib_storage"></a> <strong>mib_storage() = [mib_storage_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>mib_storage_opt() = {module, mib_storage_module()} |  {options, mib_storage_options()}</strong></p> <p>This option specifies how basic mib data is stored. 
This option is used by two parts of the snmp agent: 
The mib-server and the symbolic-store. </p> <p>Default is <strong>[{module, snmpa_mib_storage_ets}]</strong>. </p> </dd><dt><a name="agent_mst_module"></a> <strong>mib_storage_module() = snmpa_mib_data_ets | snmpa_mib_data_dets | snmpa_mib_data_mnesia | module()</strong></dt><dd> <p>Defines the mib storage module of the SNMP agent as defined by the 
<a href="snmpa_mib_storage">snmpa_mib_storage</a> 
behaviour. </p> <p>Several entities (<strong>mib-server</strong> via the its data module and 
the <strong>symbolic-store</strong>) of the snmp agent uses this for storage 
of miscelaneous mib related data retrieved while loading a mib. </p> <p>There are several implementations provided with the agent: 
<strong>snmpa_mib_storage_ets</strong>, <strong>snmpa_mib_storage_dets</strong> and 
<strong>snmpa_mib_storage_mnesia</strong>. </p> <p>Default module is <strong>snmpa_mib_storage_ets</strong>. </p> </dd><dt><a name="agent_mst_options"></a> <strong>mib_storage_options() = list() &lt;optional&gt;</strong></dt><dd> <p>This is implementattion depended. That is, it depends on the 
module. For each module a specific set of options are valid. 
For the module provided with the app, these options are supported: </p> <ul><li> <p><strong>snmpa_mib_storage_ets</strong>: <strong>{dir, filename()} | {action, keep | clear}, {checksum, boolean()}</strong></p> <ul><li> <p><strong>dir</strong> - If present, points to a directory where a file 
to which all data in the ets table is "synced". </p> <p>Also, when a table is opened this file is read, 
if it exists. </p> <p>By default, this will <em>not</em> be used. </p>  </li><li> <p><strong>action</strong> - Specifies the behaviour when a non-empty 
file is found: Keep its content or clear it out. </p> <p>Default is <strong>keep</strong>. </p>  </li><li> <p><strong>checksum</strong> - Defines if the file is checksummed 
or not. </p> <p>Default is <strong>false</strong>. </p>  </li></ul> </li><li> <p><strong>snmpa_mib_storage_dets</strong>: <strong>{dir, filename()} | {action, keep | clear}, {auto_save, default | pos_integer()} | {repair, force | boolean()}</strong></p> <ul><li> <p><strong>dir</strong> - This <em>mandatory</em> option points to a 
directory where to place the file of a dets table. </p> </li><li> <p><strong>action</strong> - Specifies the behaviour when a non-empty 
file is found: Keep its content or clear it out. </p> <p>Default is <strong>keep</strong>. </p>  </li><li> <p><strong>auto_save</strong> - Defines the dets auto-save frequency. </p> <p>Default is <strong>default</strong>. </p>  </li><li> <p><strong>repair</strong> - Defines the dets repair behaviour. </p> <p>Default is <strong>false</strong>. </p>  </li></ul> </li><li> <p><strong>snmpa_mib_storage_mnesia</strong>: <strong>{action, keep | clear}, {nodes, [node()]}</strong></p> <ul><li> <p><strong>action</strong> - Specifies the behaviour when a non-empty, 
already existing, table: Keep its content or clear it out. </p> <p>Default is <strong>keep</strong>. </p> </li><li> <p><strong>nodes</strong> - A list of node names (or an atom 
describing a list of nodes) defining where to open the table. 
Its up to the user to ensure that mnesia is actually running 
on the specified nodes. </p> <p>The following distinct values are recognised: </p> <ul><li> <p><strong>[]</strong> - Translated into a list of the own node: <strong>[node()]</strong></p> </li><li> <p><strong>all</strong> - <strong>erlang:nodes()</strong></p> </li><li> <p><strong>visible</strong> - <strong>erlang:nodes(visible)</strong></p> </li><li> <p><strong>connected</strong> - <strong>erlang:nodes(connected)</strong></p> </li><li> <p><strong>db_nodes</strong> - <strong>mnesia:system_info(db_nodes)</strong></p> </li></ul> <p>Default is the result of the call: <strong>erlang:nodes()</strong>. </p> </li></ul> </li></ul> </dd><dt><a name="agent_mib_server"></a> <strong>mib_server() = [mib_server_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>mib_server_opt() = {mibentry_override, mibentry_override()} |  {trapentry_override, trapentry_override()} |  {verbosity, verbosity()} | {cache, mibs_cache()} | {data_module, mib_server_data_module()}</strong></p> <p>Defines options specific for the SNMP agent mib server. </p> <p>For defaults see the options in <strong>mib_server_opt()</strong>.</p> </dd><dt><a name="agent_ms_meo"></a> <strong>mibentry_override() = bool() &lt;optional&gt;</strong></dt><dd> <p>If this value is false, then when loading a mib each mib-
entry is checked prior to installation of the mib. 
The purpose of the check is to prevent that the same symbolic 
mibentry name is used for different oid's.</p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="agent_ms_teo"></a> <strong>trapentry_override() = bool() &lt;optional&gt;</strong></dt><dd> <p>If this value is false, then when loading a mib each trap
is checked prior to installation of the mib. 
The purpose of the check is to prevent that the same symbolic 
trap name is used for different trap's.</p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="agent_ms_data_module"></a> <strong>mib_server_data_module() = snmpa_mib_data_tttn | module() &lt;optional&gt;</strong></dt><dd> <p>Defines the backend data module of the SNMP agent mib-server as 
defined by the 
<a href="snmpa_mib_data">snmpa_mib_data</a> 
behaviour. </p> <p>At present only the default module is provided with the agent,  
<strong>snmpa_mib_data_tttn</strong>. </p> <p>Default module is <strong>snmpa_mib_data_tttn</strong>. </p> </dd><dt><a name="agent_ms_cache"></a> <strong>mibs_cache() = bool() | mibs_cache_opts() &lt;optional&gt;</strong></dt><dd> <p>Shall the agent utilize the mib server lookup cache or not.</p> <p>Default is <strong>true</strong> (in which case the <strong>mibs_cache_opts()</strong> 
default values apply).</p> </dd><dt><a name="agent_ms_cache_opts"></a> <strong>mibs_cache_opts() = [mibs_cache_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>mibs_cache_opt() = {autogc, mibs_cache_autogc()} | {gclimit, mibs_cache_gclimit()} | {age, mibs_cache_age()}</strong></p> <p>Defines options specific for the SNMP agent mib server cache. </p> <p>For defaults see the options in <strong>mibs_cache_opt()</strong>.</p> </dd><dt><a name="agent_ms_cache_autogc"></a> <strong>mibs_cache_autogc() = bool() &lt;optional&gt;</strong></dt><dd> <p>Defines if the mib server shall perform cache gc automatically or 
leave it to the user (see 
<a href="./snmpa#gc_mibs_cache">gc_mibs_cache/0,1,2,3</a>). </p> <p>Default is <strong>true</strong>.</p> </dd><dt><a name="agent_ms_cache_age"></a> <strong>mibs_cache_age() = integer() &gt; 0 &lt;optional&gt;</strong></dt><dd> <p>Defines how old the entries in the cache will be allowed 
to become before they are GC'ed (assuming GC is performed). 
Each entry in the cache is "touched" whenever it is accessed. </p> <p>The age is defined in milliseconds. </p> <p>Default is <strong>10 timutes</strong>.</p> </dd><dt><a name="agent_ms_cache_gclimit"></a> <strong>mibs_cache_gclimit() = integer() &gt; 0 | infinity &lt;optional&gt;</strong></dt><dd> <p>When performing a GC, this is the max number of cache entries 
that will be deleted from the cache. </p> <p>The reason for having this limit is that if the cache is 
large, the GC can potentially take a long time, during which 
the agent is locked. </p> <p>Default is <strong>100</strong>.</p> </dd><dt><a name="agent_error_report_mod"></a> <strong>error_report_mod() = atom() &lt;optional&gt;</strong></dt><dd> <p>Defines an error report module, implementing the 
<a href="snmpa_error_report">snmpa_error_report</a> 
behaviour. Two modules are provided with the toolkit: 
<strong>snmpa_error_logger</strong> and <strong>snmpa_error_io</strong>.</p> <p>Default is <strong>snmpa_error_logger</strong>.</p> </dd><dt><a name="agent_symbolic_store"></a> <strong>symbolic_store() = [symbolic_store_opt()]</strong></dt><dd> <p><strong>symbolic_store_opt() = {verbosity, verbosity()}</strong></p> <p>Defines options specific for the SNMP agent symbolic store. </p> <p>For defaults see the options in <strong>symbolic_store_opt()</strong>.</p> </dd><dt><a name="agent_target_cache"></a> <strong>target_cache() = [target_cache_opt()]</strong></dt><dd> <p><strong>target_cache_opt() = {verbosity, verbosity()}</strong></p> <p>Defines options specific for the SNMP agent target cache. </p> <p>For defaults see the options in <strong>target_cache_opt()</strong>.</p> </dd><dt><a name="agent_config"></a> <strong>agent_config() = [agent_config_opt()] &lt;mandatory&gt;</strong></dt><dd> <p><strong>agent_config_opt() = {dir, agent_config_dir()} |  {force_load, force_load()} | {verbosity, verbosity()}</strong></p> <p>Defines specific config related options for the SNMP agent. </p> <p>For defaults see the options in <strong>agent_config_opt()</strong>.</p> </dd><dt><a name="agent_config_dir"></a> <strong>agent_config_dir = dir() &lt;mandatory&gt;</strong></dt><dd> <p>Defines where the SNMP agent configuration files are stored.</p> </dd><dt><a name="agent_force_load"></a> <strong>force_load() = bool() &lt;optional&gt;</strong></dt><dd> <p>If <strong>true</strong> the configuration files are re-read
during start-up, and the contents of the configuration 
database ignored.  Thus, if <strong>true</strong>, changes to 
the configuration database are lost upon reboot of the 
agent. </p> <p>Default is <strong>false</strong>.</p> </dd></dl><a name="manager_opts_and_types"></a><p>Manager specific config options and types:</p><dl><dt><a name="manager_server"></a> <strong>server() = [server_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>server_opt() = {timeout, server_timeout()} |  {verbosity, verbosity()}</strong></p> <p>Specifies the options for the manager server process.</p> <p>Default is <strong>silence</strong>.</p> </dd><dt><a name="manager_server_timeout"></a> <strong>server_timeout() = integer() &lt;optional&gt;</strong></dt><dd> <p>Asynchronous request cleanup time. For every requests,
some info is stored internally, in order to be able to 
deliver the reply (when it arrives) to the proper destination.
If the reply arrives, this info will be deleted. But if
there is no reply (in time), the info has to be deleted
after the <em>best before</em> time has been passed.
This cleanup will be performed at regular intervals, defined 
by the <strong>server_timeout()</strong> time.
The information will have an <em>best before</em> time,
defined by the <strong>Expire</strong> time given when calling the
request function (see 
<a href="./snmpm#async_get">async_get</a>,
<a href="./snmpm#async_get_next">async_get_next</a> and 
<a href="./snmpm#async_set">async_set</a>).</p> <p>Time in milli-seconds.</p> <p>Default is <strong>30000</strong>.</p> </dd><dt><a name="manager_config"></a> <strong>manager_config() = [manager_config_opt()] &lt;mandatory&gt;</strong></dt><dd> <p><strong>manager_config_opt() = {dir, manager_config_dir()} |  {db_dir, manager_db_dir()} |  {db_init_error, db_init_error()} |  {repair, manager_repair()} |  {auto_save, manager_auto_save()} |  {verbosity, verbosity()}</strong></p> <p>Defines specific config related options for the SNMP manager. </p> <p>For defaults see the options in <strong>manager_config_opt()</strong>.</p> </dd><dt><a name="manager_config_dir"></a> <strong>manager_config_dir = dir() &lt;mandatory&gt;</strong></dt><dd> <p>Defines where the SNMP manager configuration files are stored.</p> </dd><dt><a name="manager_config_db_dir"></a> <strong>manager_db_dir = dir() &lt;mandatory&gt;</strong></dt><dd> <p>Defines where the SNMP manager store persistent data.</p> </dd><dt><a name="manager_config_repair"></a> <strong>manager_repair() = false | true | force &lt;optional&gt;</strong></dt><dd> <p>Defines the repair option for the persistent database (if 
and how the table is repaired when opened). </p> <p>Default is <strong>true</strong>.</p> </dd><dt><a name="manager_config_auto_save"></a> <strong>manager_auto_save() = integer() | infinity &lt;optional&gt;</strong></dt><dd> <p>The auto save interval. The table is flushed to disk
whenever not accessed for this amount of time.</p> <p>Default is <strong>5000</strong>.</p> </dd><dt><a name="manager_irb"></a> <strong>manager_irb() = auto | user | {user, integer()} &lt;optional&gt;</strong></dt><dd> <p>This option defines how the manager will handle the sending of 
response (acknowledgment) to received inform-requests. </p> <ul><li> <p><strong>auto</strong> - The manager will autonomously send response
(acknowledgment&gt; to inform-request messages.</p> </li><li> <p><strong>{user, integer()}</strong> - The manager will send response
(acknowledgment) to inform-request messages when the 
<a href="./snmpm_user#handle_inform">handle_inform</a> 
function completes. The integer is the time, in milli-seconds, 
that the manager will consider the stored inform-request info 
valid.</p> </li><li> <p><strong>user</strong> - Same as <strong>{user, integer()}</strong>, except that 
the default time, 15 seconds (15000), is used.</p> </li></ul> <p>See 
<a href="snmpm_network_interface">snmpm_network_interface</a>, 
<a href="snmpm_user">handle_inform</a> and 
<a href="snmp_manager_netif">definition of the manager net if</a> for more info.</p> <p>Default is <strong>auto</strong>.</p> </dd><dt><a name="manager_mibs"></a> <strong>manager_mibs() = [string()] &lt;optional&gt;</strong></dt><dd> <p>Specifies a list of MIBs (including path) and defines which MIBs
are initially loaded into the SNMP manager. </p> <p>Default is <strong>[]</strong>.</p> </dd><dt><a name="manager_net_if"></a> <strong>manager_net_if() = [manager_net_if_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>manager_net_if_opt() = {module, manager_net_if_module()} |  {verbosity, verbosity()} |  {options, manager_net_if_options()}</strong></p> <p>Defines options specific for the SNMP manager network interface 
entity. </p> <p>For defaults see the options in <strong>manager_net_if_opt()</strong>.</p> </dd><dt><a name="manager_ni_opts"></a> <strong>manager_net_if_options() = [manager_net_if_option()] &lt;optional&gt;</strong></dt><dd> <p><strong>manager_net_if_option() = {bind_to, bind_to()} |  {sndbuf, sndbuf()} |   {recbuf, recbuf()} |  {no_reuse, no_reuse()} | {filter, manager_net_if_filter_options()} </strong></p> <p>These options are actually specific to the used module.
The ones shown here are applicable to the default 
<strong>manager_net_if_module()</strong>.</p> <p>For defaults see the options in <strong>manager_net_if_option()</strong>.</p> </dd><dt><a name="manager_ni_module"></a> <strong>manager_net_if_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>The module which handles the network interface part for the
SNMP manager. It must implement the 
<a href="snmpm_network_interface">snmpm_network_interface</a> behaviour.</p> <p>Default is <strong>snmpm_net_if</strong>.</p> </dd><dt><a name="manager_ni_filter_opts"></a> <strong>manager_net_if_filter_options() = [manager_net_if_filter_option()] &lt;optional&gt;</strong></dt><dd> <p><strong>manager_net_if_filter_option() = {module, manager_net_if_filter_module()}</strong></p> <p>These options are actually specific to the used module.
The ones shown here are applicable to the default 
<strong>manager_net_if_filter_module()</strong>.</p> <p>For defaults see the options in 
<strong>manager_net_if_filter_option()</strong>.</p> </dd><dt><a name="manager_ni_filter_module"></a> <strong>manager_net_if_filter_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>Module which handles the network interface filter part for the
SNMP manager. Must implement the 
<a href="snmpm_network_interface_filter">snmpm_network_interface_filter</a> behaviour.</p> <p>Default is <strong>snmpm_net_if_filter</strong>.</p> </dd><dt><a name="manager_def_user_module"></a> <strong>def_user_module() = atom() &lt;optional&gt;</strong></dt><dd> <p>The module implementing the default user. See the 
<a href="snmpm_user">snmpm_user</a> behaviour.</p> <p>Default is <strong>snmpm_user_default</strong>.</p> </dd><dt><a name="manager_def_user_data"></a> <strong>def_user_data() = term() &lt;optional&gt;</strong></dt><dd> <p>Data for the default user. Passed to the user module when 
calling the callback functions.</p> <p>Default is <strong>undefined</strong>.</p> </dd></dl><a name="common_types"></a><p>Common config types:</p><dl><dt><a name="restart_type"></a> <strong>restart_type() = permanent | transient | temporary</strong></dt><dd> <p>See <a href="../stdlib/supervisor#child_spec">supervisor</a> 
documentation for more info.</p> <p>Default is <strong>permanent</strong> for the agent and <strong>transient</strong>
for the manager.</p> </dd><dt><a name="db_init_error"></a> <strong>db_init_error() = terminate | create | create_db_and_dir</strong></dt><dd> <p>Defines what to do if the agent or manager is unable to open an
existing database file. <strong>terminate</strong> means that the
agent/manager will terminate and <strong>create</strong> means that the 
agent/manager will remove the faulty file(s) and create new ones,
and <strong>create_db_and_dir</strong> means that the agent/manager will
create the database file along with any missing parent directories
for the database file.</p> <p>Default is <strong>terminate</strong>.</p> </dd><dt><a name="prio"></a> <strong>priority() = atom() &lt;optional&gt;</strong></dt><dd> <p>Defines the Erlang priority for all SNMP processes.</p> <p>Default is <strong>normal</strong>.</p> </dd><dt><a name="versions"></a> <strong>versions() = [version()] &lt;optional&gt;</strong></dt><dd> <p><strong>version() = v1 | v2 | v3</strong></p> <p>Which SNMP versions shall be accepted/used.</p> <p>Default is <strong>[v1,v2,v3]</strong>.</p> </dd><dt><a name="verbosity"></a> <strong>verbosity() = silence | info | log | debug | trace &lt;optional&gt;</strong></dt><dd> <p>Verbosity for a SNMP process. This specifies now much debug info
is printed.</p> <p>Default is <strong>silence</strong>.</p> </dd><dt><a name="bind_to"></a> <strong>bind_to() = bool() &lt;optional&gt;</strong></dt><dd> <p>If <strong>true</strong>, net_if binds to the IP address.
If <strong>false</strong>, net_if listens on any IP address on the host
where it is running. </p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="no_reuse"></a> <strong>no_reuse() = bool() &lt;optional&gt;</strong></dt><dd> <p>If <strong>true</strong>, net_if does not specify that the IP
and port address should be reusable. If <strong>false</strong>, 
the address is set to reusable. </p> <p>Default is <strong>false</strong>.</p> </dd><dt><a name="recbuf"></a> <strong>recbuf() = integer() &lt;optional&gt;</strong></dt><dd> <p>Receive buffer size. </p> <p>Default value is defined by <strong>gen_udp</strong>.</p> </dd><dt><a name="sndbuf"></a> <strong>sndbuf() = integer() &lt;optional&gt;</strong></dt><dd> <p>Send buffer size. </p> <p>Default value is defined by <strong>gen_udp</strong>.</p> </dd><dt><a name="note_store"></a> <strong>note_store() = [note_store_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>note_store_opt() = {timeout, note_store_timeout()} |  {verbosity, verbosity()}</strong></p> <p>Specifies the start-up verbosity for the SNMP note store.</p> <p>For defaults see the options in <strong>note_store_opt()</strong>.</p> </dd><dt><a name="ns_timeout"></a> <strong>note_store_timeout() = integer() &lt;optional&gt;</strong></dt><dd> <p>Note cleanup time. When storing a note in the note store,
each note is given lifetime. Every <strong>timeout</strong> the note_store
process performs a GC to remove the expired note's. Time in
milli-seconds.</p> <p>Default is <strong>30000</strong>.</p> </dd><dt><a name="audit_trail_log"></a> <strong>audit_trail_log() = [audit_trail_log_opt()] &lt;optional&gt;</strong></dt><dd> <p><strong>audit_trail_log_opt() = {type, atl_type()} | {dir, atl_dir()} |  {size, atl_size()} |  {repair, atl_repair()} | {seqno, atl_seqno()}</strong></p> <p>If present, this option specifies the options for the 
audit trail logging. The <strong>disk_log</strong> module is used 
to maintain a wrap log. If present, the <strong>dir</strong> and 
<strong>size</strong> options are mandatory.</p> <p>If not present, audit trail logging is not used.</p> </dd><dt><a name="atl_type"></a> <strong>atl_type() = read | write | read_write &lt;optional&gt;</strong></dt><dd> <p>Specifies what type of an audit trail log should be used. 
The effect of the type is actually different for the the agent
and the manager. </p> <p>For the agent:</p> <ul><li>If <strong>write</strong> is specified, only set requests are logged.  </li><li>If <strong>read</strong> is specified, only get requests are logged.  </li><li>If <strong>read_write</strong>, all requests are logged.  </li></ul> <p>For the manager:</p> <ul><li>If <strong>write</strong> is specified, only sent messages are logged.  </li><li>If <strong>read</strong> is specified, only received messages are logged.  </li><li>If <strong>read_write</strong>, both outgoing and incoming messages are  logged.  </li></ul> <p>Default is <strong>read_write</strong>.</p> </dd><dt><a name="atl_dir"></a> <strong>atl_dir = dir() &lt;mandatory&gt;</strong></dt><dd> <p>Specifies where the audit trail log should be stored.</p> <p>If <strong>audit_trail_log</strong> specifies that logging should take
place, this parameter <em>must</em> be defined.</p> </dd><dt><a name="atl_size"></a> <strong>atl_size() = {integer(), integer()} &lt;mandatory&gt;</strong></dt><dd> <p>Specifies the size of the audit
trail log.  This parameter is sent to <strong>disk_log</strong>.  </p> <p>If <strong>audit_trail_log</strong> specifies that logging should 
take place, this parameter <em>must</em> be defined.</p> </dd><dt><a name="atl_repair"></a> <strong>atl_repair() = true | false | truncate | snmp_repair &lt;optional&gt;</strong></dt><dd> <p>Specifies if and how the audit trail log shall be repaired
when opened. Unless this parameter has the value <strong>snmp_repair</strong>
it is sent to <strong>disk_log</strong>. If, on the other hand, the value is
<strong>snmp_repair</strong>, snmp attempts to handle certain faults on its
own. And even if it cannot repair the file, it does not truncate it 
directly, but instead <em>moves it aside</em> for later off-line 
analysis.</p> <p>Default is <strong>true</strong>.</p> </dd><dt><a name="atl_seqno"></a> <strong>atl_seqno() = true | false &lt;optional&gt;</strong></dt><dd> <p>Specifies if the audit trail log entries will be (sequence)
numbered or not. The range of the sequence numbers are according
to RFC 5424, i.e. 1 through 2147483647. </p> <p>Default is <strong>false</strong>.</p> </dd></dl><h4>See Also</h4><p>application(3), disk_log(3)</p><h3>snmpa</h3><p>Interface Functions to the SNMP toolkit agent</p><p>The module <strong>snmpa</strong> contains interface functions to the 
SNMP agent.<a name="data_types"></a></p><h4>DATA TYPES</h4><pre><code class="">
oid() = [byte()] 
atl_type() = read | write | read_write
notification_delivery_info() = #snmpa_notification_delivery_info{}
    </code></pre><p>The <strong>oid()</strong> type is used to represent an ASN.1 OBJECT IDENTIFIER. </p><p>The record <strong>snmpa_notification_delivery_info</strong> contains the following fields: </p><dl><dt><strong>tag = term()</strong></dt><dd> <p>A user defined identity representing this notification send 
operation.</p> </dd><dt><strong>mod = module()</strong></dt><dd> <p>A module implementing the 
<a href="snmpa_notification_delivery_info_receiver">snmpa_notification_delivery_info_receiver</a> 
behaviour. The info functions of this module will be called at 
various stages of delivery. </p> </dd><dt><strong>extra = term()</strong></dt><dd> <p>This is any extra info the user wants to have supplied 
when the functions in the callback module is called. </p> </dd></dl><a name="add_agent_caps"></a><h3>Functions</h3><h4>add_agent_caps(SysORID, SysORDescr) -&gt; SysORIndex</h4><p>Add an AGENT-CAPABILITY definition to the agent</p><ul><li><span class="v">SysORID = oid()</span></li><li><span class="v">SysORDescr = string()</span></li><li><span class="v">SysORIndex = integer()</span></li></ul><p>This function can be used to add an AGENT-CAPABILITY
statement to the sysORTable in the agent.  The table is
defined in the SNMPv2-MIB.</p><a name="del_agent_caps"></a><h4>del_agent_caps(SysORIndex) -&gt; void()</h4><p>Delete an AGENT-CAPABILITY definition from the agent</p><ul><li><span class="v">SysORIndex = integer()</span></li></ul><p>This function can be used to delete an AGENT-CAPABILITY
statement to the sysORTable in the agent.  This table is
defined in the SNMPv2-MIB. </p><a name="get_agent_caps"></a><h4>get_agent_caps() -&gt; [[SysORIndex, SysORID, SysORDescr, SysORUpTime]]</h4><p>Return all AGENT-CAPABILITY definitions in the agent</p><ul><li><span class="v">SysORIndex = integer()</span></li><li><span class="v">SysORId = oid()</span></li><li><span class="v">SysORDescr = string()</span></li><li><span class="v">SysORUpTime = integer()</span></li></ul><p>Returns all AGENT-CAPABILITY statements in the sysORTable
in the agent.  This table is defined in the SNMPv2-MIB. </p><a name="get"></a><h4>get(Agent, Vars) -&gt; Values | {error, Reason}</h4><h4>get(Agent, Vars, Context) -&gt; Values | {error, Reason}</h4><p>Perform a get operation on the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Vars = [oid()]</span></li><li><span class="v">Context = string()</span></li><li><span class="v">Values = [term()]</span></li><li><span class="v">Reason = {atom(), oid()}</span></li></ul><p>Performs a GET operation on the agent.  All loaded MIB
objects are visible in this operation.  The agent calls the
corresponding instrumentation functions just as if it was a
GET request coming from a manager. </p><p>Note that the request specific parameters (such as 
<a href="#current_request_id">current_request_id</a>) 
are not accessible for the instrumentation functions if this 
function is used. </p><a name="get_next"></a><h4>get_next(Agent, Vars) -&gt; Values | {error, Reason}</h4><h4>get_next(Agent, Vars, Context) -&gt; Values | {error, Reason}</h4><p>Perform a get-next operation on the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Vars = [oid()]</span></li><li><span class="v">Context = string()</span></li><li><span class="v">Values = [{oid(), term()}]</span></li><li><span class="v">Reason = {atom(), oid()}</span></li></ul><p>Performs a GET-NEXT operation on the agent.  All loaded MIB
objects are visible in this operation.  The agent calls the
corresponding instrumentation functions just as if it was a
GET request coming from a manager. </p><p>Note that the request specific parameters (such as 
<strong>snmpa:current_request_id/0</strong> are not accessible for the 
instrumentation functions if this function is used. </p><a name="backup"></a><h4>backup(BackupDir) -&gt; ok | {error, Reason}</h4><h4>backup(Agent, BackupDir) -&gt; ok | {error, Reason}</h4><p>Backup agent data</p><ul><li><span class="v">BackupDir = string()</span></li><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Reason = backup_in_progress | term()</span></li></ul><p>Backup persistent/permanent data handled by the agent
(such as local-db, mib-data and vacm). </p><p>Data stored by mnesia is not handled. </p><p>BackupDir cannot be identical to DbDir. </p><p>Simultaneous backup calls are <em>not</em> allowed. 
That is, two different processes cannot simultaneously 
successfully call this function. One of them will be first, 
and succeed. The second will fail with the error reason
<strong>backup_in_progress</strong>. </p><a name="info"></a><h4>info() -&gt; [{Key, Value}]</h4><h4>info(Agent) -&gt; [{Key, Value}]</h4><p>Return information about the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Returns a list (a dictionary) containing information about
the agent. Information includes loaded MIBs, registered
sub-agents, some information about the memory allocation. </p><p>As of version 4.4 the format of the info has been changed. 
To convert the info to the old format, call the 
<a href="#old_info_format">old_info_format</a> 
function. </p><a name="old_info_format"></a><h4>old_info_format(NewInfo) -&gt; OldInfo</h4><p>Return information about the agent</p><ul><li><span class="v">OldInfo = NewInfo = [{Key, Value}]</span></li></ul><p>As of version 4.4 the format of the info has been changed. 
This function is used to convert to the old (pre-4.4) info 
format. </p><a name="load_mib"></a><h4>load_mib(Mib) -&gt; ok | {error, Reason}</h4><h4>load_mib(Agent, Mib) -&gt; ok | {error, Reason}</h4><p>Load single MIB into the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = already_loaded | term()</span></li></ul><p>Load a single <strong>Mib</strong> into an agent. The <strong>MibName</strong> 
is the name of the Mib, including the path to where the compiled 
mib is found. For example: </p><pre><code class="">
          Dir = code:priv_dir(my_app) ++ "/mibs/",
          snmpa:load_mib(snmp_master_agent, Dir ++ "MY-MIB").
        </code></pre><a name="load_mibs"></a><h4>load_mibs(Mibs) -&gt; ok | {error, Reason}</h4><h4>load_mibs(Mibs, Force) -&gt; ok | {error, Reason}</h4><h4>load_mibs(Agent, Mibs) -&gt; ok | {error, Reason}</h4><h4>load_mibs(Agent, Mibs, Force) -&gt; ok | {error, Reason}</h4><p>Load MIBs into the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">Force = boolean()</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = {'load aborted at', MibName, InternalReason}</span></li><li><span class="v">InternalReason = already_loaded | term()</span></li></ul><p>Load <strong>Mibs</strong> into an agent.  If the agent cannot load all 
MIBs (the default value of the <strong>Force</strong> argument is <strong>false</strong>), 
it will indicate where loading was aborted. The <strong>MibName</strong> 
is the name of the Mib, including the path to where the compiled 
mib is found. For example,</p><pre><code class="">
          Dir = code:priv_dir(my_app) ++ "/mibs/",
          snmpa:load_mibs(snmp_master_agent, [Dir ++ "MY-MIB"]).
        </code></pre><p>If <strong>Force = true</strong> then the agent will continue attempting
to load each mib even after failing to load a previous mib. Use with 
care. </p><a name="unload_mib"></a><h4>unload_mib(Mib) -&gt; ok | {error, Reason}</h4><h4>unload_mib(Agent, Mib) -&gt; ok | {error, Reason}</h4><p>Unload single MIB from the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = not_loaded | term()</span></li></ul><p>Unload a single <strong>Mib</strong> from an agent. </p><a name="unload_mibs"></a><h4>unload_mibs(Mibs) -&gt; ok | {error, Reason}</h4><h4>unload_mibs(Mibs, Force) -&gt; ok | {error, Reason}</h4><h4>unload_mibs(Agent, Mibs) -&gt; ok | {error, Reason}</h4><h4>unload_mibs(Agent, Mibs, Force) -&gt; ok | {error, Reason}</h4><p>Unload MIBs from the agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">Force = boolean()</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = {'unload aborted at', MibName, InternalReason}</span></li><li><span class="v">InternalReason = not_loaded | term()</span></li></ul><p>Unload <strong>Mibs</strong> from an agent. If it cannot unload all MIBs
(the default value of the <strong>Force</strong> argument is <strong>false</strong>),
it will indicate where unloading was aborted. </p><p>If <strong>Force = true</strong> then the agent will continue attempting
to unload each mib even after failing to unload a previous mib. 
Use with care. </p><a name="which_mibs"></a><h4>which_mibs() -&gt; Mibs</h4><h4>which_mibs(Agent) -&gt; Mibs</h4><p>Get a list of all the loaded mibs</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Mibs = [{MibName, MibFile}]</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">MibFile = string()</span></li></ul><p>Retrieve the list of all the mibs loaded into this agent. Default 
is the master agent. </p><a name="whereis_mib"></a><h4>whereis_mib(MibName) -&gt; {ok, MibFile} | {error, Reason}</h4><h4>whereis_mib(Agent, MibName) -&gt; {ok, MibFile} | {error, Reason}</h4><p>Get the path to the mib file</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">MibFile = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Get the full path to the (compiled) mib-file. </p><a name="current_request_id"></a><a name="current_context"></a><a name="current_community"></a><a name="current_address"></a><h4>current_request_id() -&gt; {value, RequestId} | false</h4><h4>current_context() -&gt; {value, Context} | false</h4><h4>current_community() -&gt; {value, Community} | false</h4><h4>current_address() -&gt; {value, Address} | false</h4><p>Get the request-id, context, community and address of the current request</p><ul><li><span class="v">RequestId = integer()</span></li><li><span class="v">Context = string()</span></li><li><span class="v">Community = string()</span></li><li><span class="v">Address = term()</span></li></ul><p>Get the request-id, context, community and address of the 
request currently being processed by the agent. </p><p>Note that these functions is intended to be called by the 
instrumentation functions and <em>only</em> if they are 
executed in the context of the agent process (e.g. it does 
not work if called from a spawned process).</p><a name="enum_to_int"></a><h4>enum_to_int(Name, Enum) -&gt; {value, Int} | false</h4><h4>enum_to_int(Db, Name, Enum) -&gt; {value, Int} | false</h4><p>Convert an enum value to an integer</p><ul><li><span class="v">Db   = term()</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">Enum = atom()</span></li><li><span class="v">Int  = int()</span></li></ul><p>Converts the symbolic value <strong>Enum</strong> to the
corresponding integer of the enumerated object or type
<strong>Name</strong> in a MIB.  The MIB must be loaded. 
</p><p><strong>false</strong> is returned if the object or type is not
defined in any loaded MIB, or if it does not define the
symbolic value as enumerated.
</p><p><strong>Db</strong> is a reference to the symbolic store database 
(retrieved by a call to <strong>get_symbolic_store_db/0</strong>). </p><a name="int_to_enum"></a><h4>int_to_enum(Name, Int) -&gt; {value, Enum} | false</h4><h4>int_to_enum(Db, Name, Int) -&gt; {value, Enum} | false</h4><p>Convert an integer to an enum value</p><ul><li><span class="v">Db   = term()</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">Int  = int()</span></li><li><span class="v">Enum = atom()</span></li></ul><p>Converts the integer <strong>Int</strong> to the corresponding
symbolic value of the enumerated object or type <strong>Name</strong> in
a MIB.  The MIB must be loaded. 
</p><p><strong>false</strong> is returned if the object or type is not
defined in any loaded MIB, or if it does not define the
symbolic value as enumerated.
</p><p><strong>Db</strong> is a reference to the symbolic store database 
(retrieved by a call to <strong>get_symbolic_store_db/0</strong>). </p><a name="name_to_oid"></a><h4>name_to_oid(Name) -&gt; {value, oid()} | false</h4><h4>name_to_oid(Db, Name) -&gt; {value, oid()} | false</h4><p>Convert a symbolic name to an OID</p><ul><li><span class="v">Db   = term()</span></li><li><span class="v">Name = atom()</span></li></ul><p>Looks up the OBJECT IDENTIFIER of a MIB object, given the
symbolic name.  Note, the OBJECT IDENTIFIER is given for the
object, not for an instance. </p><p><strong>false</strong> is returned if the object is not defined in any
loaded MIB. </p><p><strong>Db</strong> is a reference to the symbolic store database 
(retrieved by a call to <strong>get_symbolic_store_db/0</strong>). </p><a name="oid_to_name"></a><h4>oid_to_name(OID) -&gt; {value, Name} | false</h4><h4>oid_to_name(Db, OID) -&gt; {value, Name} | false</h4><p>Convert an OID to a symbolic name</p><ul><li><span class="v">Db   = term()</span></li><li><span class="v">OID  = oid()</span></li><li><span class="v">Name = atom()</span></li></ul><p>Looks up the symbolic name of a MIB object, given OBJECT
IDENTIFIER. </p><p><strong>false</strong> is returned if the object is not defined in any
loaded MIB. </p><p><strong>Db</strong> is a reference to the symbolic store database 
(retrieved by a call to <strong>get_symbolic_store_db/0</strong>). </p><a name="which_aliasnames"></a><h4>which_aliasnames() -&gt; Result</h4><p>Get all alias-names known to the agent</p><ul><li><span class="v">Result = [atom()]</span></li></ul><p>Retrieve all alias-names known to the agent.</p><a name="which_tables"></a><h4>which_tables() -&gt; Result</h4><p>Get all tables known to the agent</p><ul><li><span class="v">Result = [atom()]</span></li></ul><p>Retrieve all tables known to the agent.</p><a name="which_variables"></a><h4>which_variables() -&gt; Result</h4><p>Get all variables known to the agent</p><ul><li><span class="v">Result = [atom()]</span></li></ul><p>Retrieve all variables known to the agent.</p><a name="which_notifications"></a><h4>which_notifications() -&gt; Result</h4><p>Get all notifications known to the agent</p><ul><li><span class="v">Result = [{Name, MibName, Info}]</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">Info = term()</span></li></ul><p>Retrieve all notifications (and traps) known to the agent.</p><a name="log_to_txt"></a><h4>log_to_txt(LogDir)</h4><h4>log_to_txt(LogDir, Block | Mibs)</h4><h4>log_to_txt(LogDir, Mibs, Block | OutFile) -&gt; ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_txt(LogDir, Mibs, OutFile, Block | LogName) -&gt;  ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_txt(LogDir, Mibs, OutFile, LogName, Block | LogFile) -&gt;  ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block | Start) -&gt;  ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start)  -&gt; ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Start, Stop)  -&gt; ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start, Stop)  -&gt; ok | {ok, Cnt} | {error, Reason}</h4><p>Convert an Audit Trail Log to text format</p><ul><li><span class="v">LogDir = string()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Block = boolean()</span></li><li><span class="v">OutFile = string()</span></li><li><span class="v">LogName = string()</span></li><li><span class="v">LogFile = string()</span></li><li><span class="v">Start = Stop = null | calendar:datetime() | {local_time, calendar:datetime()} | {universal_time, calendar:datetime()} </span></li><li><span class="v">Cnt = {NumOK, NumERR}</span></li><li><span class="v">NumOK = non_neg_integer()</span></li><li><span class="v">NumERR = pos_integer()</span></li><li><span class="v">Reason = disk_log_open_error() | file_open_error() | term()</span></li><li><span class="v">disk_log_open_error() = {LogName, term()}</span></li><li><span class="v">file_open_error() = {OutFile, term()}</span></li></ul><p>Converts an Audit Trail Log to a readable text file. 
<strong>OutFile</strong> defaults to "./snmpa_log.txt". 
<strong>LogName</strong> defaults to "snmpa_log". 
<strong>LogFile</strong> defaults to "snmpa.log". </p><p>The <strong>Block</strong> option indicates if the log should be blocked
during conversion. This could be usefull when converting large 
logs (when otherwise the log could wrap during conversion). 
Defaults to <strong>true</strong>. </p><p>See <a href="./snmp#log_to_txt">snmp:log_to_txt</a> 
for more info.</p><a name="log_to_io"></a><h4>log_to_io(LogDir) -&gt;  ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_io(LogDir, Block | Mibs) -&gt;  ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_io(LogDir, Mibs, Block | LogName) -&gt;  ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_io(LogDir, Mibs, LogName, Block | LogFile) -&gt; ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_io(LogDir, Mibs, LogName, LogFile, Block | Start) -&gt; ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start) -&gt; ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_io(LogDir, Mibs, LogName, LogFile, Start, Stop) -&gt; ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start, Stop) -&gt; ok | {ok, Cnt} | {error, Reason}</h4><p>Convert an Audit Trail Log to text format</p><ul><li><span class="v">LogDir = string()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Block = boolean()</span></li><li><span class="v">LogName = string()</span></li><li><span class="v">LogFile = string()</span></li><li><span class="v">Start = Stop = null | calendar:datetime() | {local_time, calendar:datetime()} | {universal_time, calendar:datetime()} </span></li><li><span class="v">Cnt = {NumOK, NumERR}</span></li><li><span class="v">NumOK = non_neg_integer()</span></li><li><span class="v">NumERR = pos_integer()</span></li><li><span class="v">Reason = disk_log_open_error() | file_open_error() | term()</span></li><li><span class="v">disk_log_open_error() = {LogName, term()}</span></li><li><span class="v">file_open_error() = {OutFile, term()}</span></li></ul><p>Converts an Audit Trail Log to a readable format and 
prints it on stdio. 
<strong>LogName</strong> defaults to "snmpa_log". 
<strong>LogFile</strong> defaults to "snmpa.log".</p><p>The <strong>Block</strong> option indicates if the log should be blocked
during conversion. This could be usefull when converting large 
logs (when otherwise the log could wrap during conversion). 
Defaults to <strong>true</strong>. </p><p>See <a href="./snmp#log_to_io">snmp:log_to_io</a> 
for more info.</p><a name="change_log_size"></a><h4>change_log_size(NewSize) -&gt; ok | {error, Reason}</h4><p>Change the size of the Audit Trail Log</p><ul><li><span class="v">NewSize = {MaxBytes, MaxFiles}</span></li><li><span class="v">MaxBytes = integer()</span></li><li><span class="v">MaxFiles = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Changes the log size of the Audit Trail Log. The application must 
be configured to use the audit trail log function. Please refer to 
disk_log(3) in Kernel Reference Manual for a description of how to 
change the log size. </p><p>The change is permanent, as long as the log is not deleted. 
That means, the log size is remembered across reboots. </p><a name="set_log_type"></a><h4>set_log_type(NewType) -&gt; {ok, OldType} | {error, Reason}</h4><h4>set_log_type(Agent, NewType) -&gt; {ok, OldType} | {error, Reason}</h4><p>Change the type of the Audit Trail Log</p><ul><li><span class="v">NewType = OldType = atl_type()</span></li><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Changes the run-time Audit Trail log type. </p><p>Note that this has no effect on the application configuration as
defined by configuration files, so a node restart will revert the 
config to whatever is in those files. </p><p>This function is primarily useful in testing/debugging 
scenarios. </p><a name="mib_of"></a><h4>mib_of(Oid) -&gt; {ok, MibName} | {error, Reason}</h4><h4>mib_of(Agent, Oid) -&gt; {ok, MibName} | {error, Reason}</h4><p>Which mib an Oid belongs to</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Oid = oid()</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Finds the mib corresponding to the <strong>Oid</strong>. If it is a
variable, the Oid must be 
&lt;Oid for var&gt;.0 and if it is a table, Oid must be 
&lt;table&gt;.&lt;entry&gt;.&lt;col&gt;.&lt;any&gt;</p><a name="me_of"></a><h4>me_of(Oid) -&gt; {ok, Me} | {error, Reason}</h4><h4>me_of(Agent, Oid) -&gt; {ok, Me} | {error, Reason}</h4><p>Retrieve the mib-entry of an Oid</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Oid = oid()</span></li><li><span class="v">Me = #me{}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Finds the mib entry corresponding to the <strong>Oid</strong>. If it is a
variable, the Oid must be 
&lt;Oid for var&gt;.0 and if it is a table, Oid must be 
&lt;table&gt;.&lt;entry&gt;.&lt;col&gt;.&lt;any&gt;</p><a name="invalidate_mibs_cache"></a><h4>invalidate_mibs_cache() -&gt; void()</h4><h4>invalidate_mibs_cache(Agent) -&gt; void()</h4><p>Invalidate the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Invalidate the mib server cache. </p><p>The entire contents of the cache will be deleted. </p><a name="enable_mibs_cache"></a><h4>enable_mibs_cache() -&gt; void()</h4><h4>enable_mibs_cache(Agent) -&gt; void()</h4><p>Enable the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Enable the mib server cache. </p><a name="disable_mibs_cache"></a><h4>disable_mibs_cache() -&gt; void()</h4><h4>disable_mibs_cache(Agent) -&gt; void()</h4><p>Disable the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Disable the mib server cache. </p><a name="which_mibs_cache_size"></a><h4>which_mibs_cache_size() -&gt; void()</h4><h4>which_mibs_cache_size(Agent) -&gt; void()</h4><p>The size of the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Retreive the size of the mib server cache. </p><a name="gc_mibs_cache"></a><h4>gc_mibs_cache() -&gt; {ok, NumElementsGCed} | {error, Reason}</h4><h4>gc_mibs_cache(Agent) -&gt; {ok, NumElementsGCed} | {error, Reason}</h4><h4>gc_mibs_cache(Age) -&gt; {ok, NumElementsGCed} | {error, Reason}</h4><h4>gc_mibs_cache(Agent, Age) -&gt; {ok, NumElementsGCed} | {error, Reason}</h4><h4>gc_mibs_cache(Age, GcLimit) -&gt; {ok, NumElementsGCed} | {error, Reason}</h4><h4>gc_mibs_cache(Agent, Age, GcLimit) -&gt; {ok, NumElementsGCed} | {error, Reason}</h4><p>Perform mib server cache gc</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Age = integer() &gt; 0</span></li><li><span class="v">GcLimit = integer() &gt; 0 | infinity</span></li><li><span class="v">NumElementsGCed = integer() &gt;= 0</span></li><li><span class="v">Reason = term()</span></li></ul><p>Perform mib server cache gc. </p><p>Manually performs a mib server cache gc. 
This can be done regardless of the value of the 
<strong>autogc</strong> option. 
The <strong>NumElementsGCed</strong> value indicates how many 
elements where actually removed from the cache. </p><a name="enable_mibs_cache_autogc"></a><h4>enable_mibs_cache_autogc() -&gt; void()</h4><h4>enable_mibs_cache_autogc(Agent) -&gt; void()</h4><p>Enable automatic gc of the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Enable automatic gc of the mib server cache. </p><a name="disable_mibs_cache_autogc"></a><h4>disable_mibs_cache_autogc() -&gt; void()</h4><h4>disable_mibs_cache_autogc(Agent) -&gt; void()</h4><p>Disable automatic gc of the mib server cache</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Disable automatic gc of the mib server cache. </p><a name="update_mibs_cache_age"></a><h4>update_mibs_cache_age(NewAge) -&gt; ok | {error, Reason}</h4><h4>update_mibs_cache_age(Agent, NewAge) -&gt; ok | {error, Reason}</h4><p>Change the mib server cache age property</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">NewAge = integer() &gt; 0</span></li><li><span class="v">Reason = term()</span></li></ul><p>Change the mib server cache <strong>age</strong> property. </p><a name="update_mibs_cache_gclimit"></a><h4>update_mibs_cache_gclimit(NewGcLimit) -&gt; ok | {error, Reason}</h4><h4>update_mibs_cache_gclimit(Agent, NewGCLimit) -&gt; ok | {error, Reason}</h4><p>Change the mib server cache gclimit property</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">NewGcLimit = integer() &gt; 0 | infinity</span></li><li><span class="v">Reason = term()</span></li></ul><p>Change the mib server cache <strong>gclimit</strong> property. </p><a name="register_notification_filter"></a><h4>register_notification_filter(Id, Mod, Data) -&gt; ok | {error, Reason}</h4><h4>register_notification_filter(Agent, Id, Mod, Data) -&gt; ok | {error, Reason}</h4><h4>register_notification_filter(Id, Mod, Data, Where) -&gt; ok | {error, Reason}</h4><h4>register_notification_filter(Agent, Id, Mod, Data, Where) -&gt; ok | {error, Reason}</h4><p>Register a notification filter</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Id = filter_id()</span></li><li><span class="v">filter_id() = term()</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">Data = term()</span></li><li><span class="v">Where = filter_position()</span></li><li><span class="v">Reason = term()</span></li><li><span class="v">filter_position() = first | last | {insert_before, filter_id()} | {insert_after, filter_id()} </span></li></ul><p>Registers a notification filter.
</p><p><strong>Mod</strong> is a module implementing the 
<strong>snmpa_notification_filter</strong> behaviour.</p><p><strong>Data</strong> will be passed on to the filter when calling the
functions of the behaviour.</p><a name="unregister_notification_filter"></a><h4>unregister_notification_filter(Id) -&gt; ok | {error, Reason}</h4><h4>unregister_notification_filter(Agent, Id) -&gt; ok | {error, Reason}</h4><p>Unregister a notification filter</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Id = filter_id()</span></li><li><span class="v">filter_id() = term()</span></li></ul><p>Unregister a notification filter. </p><a name="which_notification_filter"></a><h4>which_notification_filter() -&gt; Filters</h4><h4>which_notification_filter(Agent) -&gt; Filters</h4><p>Which notification filter</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Filters = [filter_id()]</span></li><li><span class="v">filter_id() = term()</span></li></ul><p>List all notification filters in an agent.</p><a name="set_request_limit"></a><h4>set_request_limit(NewLimit) -&gt; {ok, OldLimit} | {error, Reason}</h4><h4>set_request_limit(Agent, NewLimit) -&gt; {ok, OldLimit} | {error, Reason}</h4><p>Change the request limit</p><ul><li><span class="v">NewLimit = OldLimit = infinity | integer() &gt;= 0</span></li><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Changes the request limit. </p><p>Note that this has no effect on the application configuration as
defined by configuration files, so a node restart will revert the 
config to whatever is in those files. </p><p>This function is primarily useful in load regulation 
scenarios. </p><a name="register_subagent"></a><h4>register_subagent(Agent, SubTreeOid, Subagent) -&gt; ok | {error, Reason}</h4><p>Register a sub-agent under a sub-tree</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">SubTreeOid = oid()</span></li><li><span class="v">SubAgent = pid()</span></li></ul><p>Registers a sub-agent under a sub-tree of another agent. </p><p>It is easy to make mistakes when registering sub-agents and
this activity should be done carefully.  For example, a
strange behaviour would result from the following
configuration:</p><pre>
snmp_agent:register_subagent(MAPid,[1,2,3,4],SA1),
snmp_agent:register_subagent(SA1,[1,2,3], SA2).
        </pre><p><strong>SA2</strong> will not get requests starting with object
identifier <strong>[1,2,3]</strong> since <strong>SA1</strong> does not. </p><a name="unregister_subagent"></a><h4>unregister_subagent(Agent, SubagentOidOrPid) -&gt; ok | {ok, SubAgentPid} | {error, Reason}</h4><p>Unregister a sub-agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">SubTreeOidorPid = oid() | pid()</span></li></ul><p>Unregister a sub-agent.  If the second argument is a pid,
then that sub-agent will be unregistered from all trees in
<strong>Agent</strong>. </p><a name="send_notification2"></a><h4>send_notification2(Agent, Notification, SendOpts) -&gt; void()</h4><p>Send notification</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Notification = atom()</span></li><li><span class="v">SendOpts = [send_option()]</span></li><li><span class="v">send_option() = {receiver, receiver()} | {name, notify_name()} | {context, context_name()} | {varbinds, varbinds()} | {local_engine_id, string()} | {extra, extra_info()}</span></li><li><span class="v">receiver() = no_receiver | {tag(), tag_receiver()} | notification_delivery_info()</span></li><li><span class="v">tag() = term(()</span></li><li><span class="v">tag_receiver() = pid() | registered_name() | {Mod, Func, Args}</span></li><li><span class="v">registered_name() = atom()</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">Func = atom()</span></li><li><span class="v">Args = list()</span></li><li><span class="v">notify_name() = string()</span></li><li><span class="v">context_name() = string()</span></li><li><span class="v">varbinds() = [varbind()]</span></li><li><span class="v">varbind() = {variable(), value()} | {column(), row_index(), value()} | {oid(), value()}</span></li><li><span class="v">variable() = atom()</span></li><li><span class="v">value() = term()</span></li><li><span class="v">column() = atom()</span></li><li><span class="v">row_index() = [int()]</span></li><li><span class="v">extra_info() = term()</span></li></ul><p>Send the notification <strong>Notification</strong> to the management 
targets defined for notify-name (<strong>name</strong>) in the 
<strong>snmpNotifyTable</strong> in SNMP-NOTIFICATION-MIB from the 
specified <strong>context</strong>. </p><p>If no <strong>name</strong> is specified (or if it is <strong>""</strong>), the
notification is sent to all management targets. </p><p>If no <strong>context</strong> is specified, the default context, <strong>""</strong>, 
is used. </p><p>The send option <strong>receiver</strong> specifies where information
about delivery of Inform-Requests should be sent.  The agent
sends Inform-Requests and waits for acknowledgments from the
management targets. 
The <strong>receiver</strong> can have three values: </p><ul><li> <p><strong>no_receiver</strong> - No information is delivered. </p> </li><li> <p><strong>notification_delivery_info()</strong> - The information is 
delivered via a function call according to this data. See the 
<a href="#data_types">DATA TYPES</a> section 
above for details. </p> </li><li> <p><strong>{tag(), tag_receiver()}</strong> - The information is delivered 
either via messages or via a function call according to the value 
of <strong>tag_receiver()</strong>. </p> <p>Delivery is done differently depending on the value
of <strong>tag_receiver()</strong>: </p> <ul><li> <p><strong>pid() | registered_name()</strong> - The info will be delivered in  
the following messages: </p> <ul><li> <p><strong>{snmp_targets, tag(), Addresses}</strong></p> <p>This informs the user which target addresses the 
notification was sent to. </p> </li><li> <p><strong>{snmp_notification, tag(), {got_response, Address}}</strong></p> <p>This informs the user that this target address 
acknowledged the notification. </p> </li><li> <p><strong>{snmp_notification, tag(), {no_response, Address}}</strong></p> <p>This informs the user that this target address 
did not acknowledge the notification. </p> </li></ul> <p>The notification is sent as an Inform-Request to each 
target address in <strong>Addresses</strong> and if there are no 
targets for which an Inform-Request is sent, <strong>Addresses</strong> 
is the empty list <strong>[]</strong>. </p> <p>The <strong>tag_receiver()</strong> will first be sent the 
<strong>snmp_targets</strong> message, and then for each address in 
<strong>Addresses</strong> list, one of the two <strong>snmp_notification</strong> 
messages. </p> </li><li> <p><strong>{Mod, Func, Args}</strong> - The info will be delivered via
the function call: </p> <p><strong>Mod:Func([Msg | Args])</strong></p> <p>where <strong>Msg</strong> has the same content and purpose as the 
messages descrived above.</p> </li></ul> </li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The <strong>extra</strong> info is not normally interpreted by the agent, 
instead it is passed through to the 
<a href="snmp_agent_netif">net-if</a> process. It is 
up to the implementor of that process to make use of this data. </p><p>The version of net-if provided by this application makes no use
of this data, with one exception: 
Any tuple containing the atom 
<strong>snmpa_default_notification_extra_info</strong> 
may be used by the agent and is therefor <em>reserved</em>. </p><p>See the net-if incomming messages for sending a 
<a href="./snmp_agent_netif#im_send_pdu"> trap</a> and 
<a href="./snmp_agent_netif#im_send_pdu_req"> notification</a> for more info. </p></div><a name="send_notification"></a><h4>send_notification(Agent, Notification, Receiver)</h4><h4>send_notification(Agent, Notification, Receiver, Varbinds)</h4><h4>send_notification(Agent, Notification, Receiver, NotifyName, Varbinds)</h4><h4>send_notification(Agent, Notification, Receiver, NotifyName, ContextName, Varbinds) -&gt; void()</h4><h4>send_notification(Agent, Notification, Receiver, NotifyName, ContextName, Varbinds, LocalEngineID) -&gt; void()</h4><p>Send a notification</p><ul><li><span class="v">Agent = pid() | atom()</span></li><li><span class="v">Notification = atom()</span></li><li><span class="v">Receiver = no_receiver | {Tag, Recv} | notification_delivery_info()</span></li><li><span class="v">Tag = term()</span></li><li><span class="v">Recv = receiver()</span></li><li><span class="v">receiver() = pid() | atom() | {Mod, Func, Args}</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">Func = atom()</span></li><li><span class="v">Args = list()</span></li><li><span class="v">NotifyName = string()</span></li><li><span class="v">ContextName = string()</span></li><li><span class="v">Varbinds = varbinds()</span></li><li><span class="v">varbinds() = [varbind()]</span></li><li><span class="v">varbind() = {Variable, Value} | {Column, RowIndex, Value} | {OID, Value}</span></li><li><span class="v">Variable = atom()</span></li><li><span class="v">Column = atom()</span></li><li><span class="v">OID = oid()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">RowIndex = [int()]</span></li><li><span class="v">LocalEngineID = string()</span></li></ul><p>Sends the notification <strong>Notification</strong> to the
management targets defined for <strong>NotifyName</strong> in the
<strong>snmpNotifyTable</strong> in SNMP-NOTIFICATION-MIB from the
specified context.  </p><p>If no <strong>NotifyName</strong> is specified (or if it is <strong>""</strong>), 
the notification is sent to all management targets 
(<strong>Addresses</strong> below).  </p><p>If no <strong>ContextName</strong> is specified, the default <strong>""</strong> 
context is used. </p><p>The parameter <strong>Receiver</strong> specifies where information
about delivery of Inform-Requests should be sent.  The agent
sends Inform-Requests and waits for acknowledgments from the
managers. <strong>Receiver</strong> can have three values: </p><ul><li> <p><strong>no_receiver</strong> - No information is delivered. </p> </li><li> <p><strong>notification_delivery_info()</strong> - The information is 
delivered via a function call according to this data. See the 
<a href="#data_types">DATA TYPES</a> section 
above for details. </p> </li><li> <p><strong>{Tag, Recv}</strong> - The information is delivered either via 
messages or via a function call according to the value of 
<strong>Recv</strong>. </p> </li></ul><p>If <strong>Receiver</strong> has the value <strong>{Tag, Recv}</strong>, the delivery is
done according to <strong>Recv</strong>: </p><ul><li> <p><strong>pid() | atom()</strong> - The info will be delivered in  
the following messages: </p> <ul><li> <p><strong>{snmp_targets, Tag, Addresses}</strong></p> <p>This inform the user which target addresses the 
notification was sent to. </p> </li><li> <p><strong>{snmp_notification, Tag, {got_response, Address}}</strong></p> <p>This informs the user that this target address 
acknowledged the notification. </p> </li><li> <p><strong>{snmp_notification, Tag, {no_response, Address}}</strong></p> <p>This informs the user that this target address 
did not acknowledge notification. </p> </li></ul> <p>The notification is sent as an Inform-Request to each 
target address in <strong>Addresses</strong> and if there are no 
targets for which an Inform-Request is sent, <strong>Addresses</strong> 
is the empty list <strong>[]</strong>. </p> <p>The <strong>receiver</strong> will first be sent the <strong>snmp_targets</strong> 
message, and then for each address in <strong>Addresses</strong> list, 
one of the two <strong>snmp_notification</strong> messages. </p> </li><li> <p><strong>{Mod, Func, Args}</strong> - The info will be delivered via
the function call: </p> <p><strong>Mod:Func([Msg | Args])</strong></p> <p>where <strong>Msg</strong> has the same content and purpose as the 
messages descrived above.</p> </li></ul><p><strong>Address</strong> is a management target address and <strong>Addresses</strong> is a 
list of management target addresses. They are defined as followes: </p><pre>
        Addresses  = [address()]
        Address    = address()
        address()  = v1_address() | v3_address()
        v1_address() = {TDomain, TAddress}
        v3_address() = {{TDomain, TAddress}, V3MsgData}
        TDomain    = tdoamin()
        TAddress   = taddress()
        tdomain()  = The oid of snmpUDPDomain 
                     This is the only supported transport domain.
        taddress() = [A1, A2, A3, A4, P1, P3]
                     The 4 first bytes makes up the IP-address and the last 2,
                     the UDP-port number.
        V3MsgData  = v3_msg_data()
        v3_msg_data() = term()
</pre><p>If <strong>Receiver</strong> is a <strong>notification_delivery_info()</strong> record,
then the information about the notification delivery will be delivered 
to the <strong>receiver</strong> via the callback functions defined by the 
<a href="snmpa_notification_delivery_info_receiver">snmpa_notification_delivery_info_receiver</a> 
behaviour according to the content of the <strong>notification_delivery_info()</strong> 
record. </p><p>The optional argument <strong>Varbinds</strong> defines
values for the objects in the notification.  If no value is
given for an object, the <strong>Agent</strong> performs a get-operation
to retrieve the value.
</p><p><strong>Varbinds</strong> is a list of <strong>Varbind</strong>, where each
<strong>Varbind</strong> is one of:
</p><ul><li><strong>{Variable, Value}</strong>, where <strong>Variable</strong> is the symbolic name of a scalar variable referred to in the notification specification. </li><li><strong>{Column, RowIndex, Value}</strong>, where <strong>Column</strong> is the symbolic name of a column variable. <strong>RowIndex</strong> is a list of indices for the specified element.  If this is the case, the OBJECT IDENTIFIER sent in the notification is the <strong>RowIndex</strong> appended to the OBJECT IDENTIFIER for the table column. This is the OBJECT IDENTIFIER which specifies the element. </li><li><strong>{OID, Value}</strong>, where <strong>OID</strong> is the OBJECT IDENTIFIER for an instance of an object, scalar variable, or column variable. </li></ul><p>For example, to specify that <strong>sysLocation</strong> should have the
value <strong>"upstairs"</strong> in the notification, we could use one of:
</p><ul><li><strong>{sysLocation, "upstairs"}</strong> or</li><li><strong>{[1,3,6,1,2,1,1,6,0], "upstairs"}</strong> or</li><li><strong>{?sysLocation_instance, "upstairs"}</strong> (provided that the generated <strong>.hrl</strong> file is included)</li></ul><p>If a variable in the notification is a table element, the
<strong>RowIndex</strong> for the element must be given in the
<strong>Varbinds</strong> list. In this case, the OBJECT IDENTIFIER sent
in the notification is the OBJECT IDENTIFIER that identifies this
element.  This OBJECT IDENTIFIER could be used in a get
operation later.
</p><p>This function is asynchronous, and does not return any
information.  If an error occurs, <strong>user_err/2</strong> of the error
report module is called and the notification is discarded.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that the use of the LocalEngineID argument is only intended 
for special cases, if the agent is to "emulate" multiple EngineIDs!
By default, the agent uses the value of <strong>SnmpEngineID</strong> 
(see SNMP-FRAMEWORK-MIB). </p></div><p><strong>ExtraInfo</strong> is not normally used in any way by the agent. 
It is intended to be passed along to the net-if process, which is
a component that a user can implement themself. The users own net-if
may then make use of ExtraInfo. The net-if provided with this 
application does not process ExtraInfo. </p><p>There is one exception. <em>Any</em> tuple containing the atom
<strong>snmpa_default_notification_extra_info</strong> will, in this context,
be considered belonging to this application, and may be processed
by the agent. </p><a name="discovery"></a><h4>discovery(TargetName, Notification) -&gt; {ok, ManagerEngineID} | {error, Reason}</h4><h4>discovery(TargetName, Notification, Varbinds) -&gt; {ok, ManagerEngineID} | {error, Reason}</h4><h4>discovery(TargetName, Notification, DiscoHandler) -&gt; {ok, ManagerEngineID} | {error, Reason}</h4><h4>discovery(TargetName, Notification, ContextName, Varbinds) -&gt; {ok, ManagerEngineID} | {error, Reason}</h4><h4>discovery(TargetName, Notification, Varbinds, DiscoHandler) -&gt; {ok, ManagerEngineID} | {error, Reason}</h4><h4>discovery(TargetName, Notification, ContextName, Varbinds, DiscoHandler) -&gt; {ok, ManagerEngineID} | {error, Reason}</h4><h4>discovery(TargetName, Notification, ContextName, Varbinds, DiscoHandler, ExtraInfo) -&gt; {ok, ManagerEngineID} | {error, Reason}</h4><p>Initiate the discovery process with a manager</p><ul><li><span class="v">TargetName = string()</span></li><li><span class="v">Notification = atom()</span></li><li><span class="v">ContextName = string() (defaults to "")</span></li><li><span class="v">Varbinds = varbinds()</span></li><li><span class="v">varbinds() = [varbind()]</span></li><li><span class="v">DiscoHandler = snmpa_discovery_handler()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">snmpa_discovery_handler() = Module implementing the snmpa_discovery_handler behaviour</span></li><li><span class="v">ManagerEngineID = string()</span></li><li><span class="v">varbind() = {Variable, Value} | {Column, RowIndex, Value} | {OID, Value}</span></li><li><span class="v">Variable = atom()</span></li><li><span class="v">Column = atom()</span></li><li><span class="v">OID = oid()</span></li><li><span class="v">Value = term()</span></li><li><span class="v">RowIndex = [int()]</span></li><li><span class="v">Reason = term()</span></li></ul><p>Initiate the discovery process with the manager identified by
<strong>TargetName</strong> using the notification <strong>Notification</strong>. </p><p>This function is synchronous, which means that it will return when
the discovery process has been completed or failed. </p><p>The <strong>DiscoHandler</strong> module is used during the discovery 
process. See 
<a href="snmpa_discovery_handler">discovery handler</a>
for more info. </p><p>The <strong>ExtraInfo</strong> argument is passed on to the callback functions
of the <strong>DiscoHandler</strong>. </p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If we are not at security-level <strong>noAuthNoPriv</strong>,
this could be complicated, since the agent will then continue 
with stage 2, before which the usm-related updates must be 
done. </p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The default discovery handler will require 
additional actions by the caller and the discovery will not work
if the security-level is higher then <strong>noAuthNoPriv</strong>. </p></div><a name="convert_config"></a><h4>convert_config(OldConfig) -&gt; AgentConfig</h4><p>Convert old snmp config to new agent config</p><ul><li><span class="v">OldConfig = list()</span></li><li><span class="v">AgentConfig = list()</span></li></ul><p>This off-line utility function can be used to convert
the old snmp application config (pre snmp-4.0) to the 
new snmp agent config (as of snmp-4.0).</p><p>For information about the old config (<strong>OldConfig</strong>) 
see the OTP R9C documentation.</p><p>For information about the current agent config 
(<strong>AgentConfig</strong>), see either
the <a href="snmp_app">SNMP application</a> 
part of the reference manual or the 
<a href="snmp_config">Configuring the application</a> 
chapter of the SNMP user's guide.</p><a name="restart_worker"></a><h4>restart_worker() -&gt; void()</h4><h4>restart_worker(Agent) -&gt; void()</h4><p>Restart the worker process of a multi-threaded agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Restart the worker process of a multi-threaded agent.</p><p>This is a utility function, that can be useful when
e.g. debugging instrumentation functions.</p><a name="restart_set_worker"></a><h4>restart_set_worker() -&gt; void()</h4><h4>restart_set_worker(Agent) -&gt; void()</h4><p>Restart the set worker process of a multi-threaded agent</p><ul><li><span class="v">Agent = pid() | atom()</span></li></ul><p>Restart the set worker process of a multi-threaded agent.</p><p>This is a utility function, that can be useful when
e.g. debugging instrumentation functions.</p><a name="print_mib_info"></a><h4>print_mib_info() -&gt; void()</h4><p>Print mib info</p><p>Prints the content of all the (snmp) tables and variables 
for all mibs handled by the snmp agent. </p><a name="print_mib_tables"></a><h4>print_mib_tables() -&gt; void()</h4><p>Print mib tables</p><p>Prints the content of all the (snmp) tables 
for all mibs handled by the snmp agent. </p><a name="print_mib_variables"></a><h4>print_mib_variables() -&gt; void()</h4><p>Print mib variables</p><p>Prints the content of all the (snmp) variables 
for all mibs handled by the snmp agent. </p><a name="verbosity"></a><h4>verbosity(Ref,Verbosity) -&gt; void()</h4><p>Assign a new verbosity for the process</p><ul><li><span class="v">Ref = pid() | sub_agents | master_agent | net_if | mib_server | symbolic_store | note_store | local_db</span></li><li><span class="v">Verbosity = verbosity() | {subagents, verbosity()}</span></li><li><span class="v">verbosity() = silence | info | log | debug | trace </span></li></ul><p>Sets verbosity for the designated process. For the lowest 
verbosity <strong>silence</strong>, nothing is printed. The higher the
verbosity, the more is printed. </p><h4>See Also</h4><p>calendar(3), erlc(1) </p><h3>snmpa_conf</h3><p>Utility functions for handling the agent config files.</p><p>The module <strong>snmpa_conf</strong> contains various utility functions to 
used for manipulating (write/append/read) the config files of the
SNMP agent. <a name="types"></a></p><h4>DATA TYPES</h4><pre><code class="">
transportDomain() = transportDomainUdpIpv4 | transportDomainUdpIpv6

transportAddress() =
    transportAddressIPv4() | transportAddressIPv6()

transportAddressWithPort() =
    transportAddressIPv4WithPort() | transportAddressIPv6WithPort()

transportAddressWithoutPort() =
    transportAddressIPv4WithoutPort() | transportAddressIPv6WithoutPort()

transportAddressIPv4() =
    transportAddressIPv4WithPort() | transportAddressIPv4WithoutPort()
transportAddressIPv4WithPort =
    {transportAddressIPv4WithoutPort(), inet:port_number()} |
    [byte() x 4, byte() x 2]
transportAddressIPv4WithoutPort =
    inet:ip4_address() | [byte() x 4]

transportAddressIPv6() =
    transportAddressIPv6WithPort() | transportAddressIPv6WithoutPort()
transportAddressIPv6WithPort =
    {transportAddressIPv6WithoutPort(), inet:port_number()} |
    [word() x 8, inet:port_number()] |
    [word() x 8, byte() x 2] |
    {byte() x 16, byte() x 2]
transportAddressIPv6WithoutPort =
    inet:ip6_address() | [word() x 8] | [byte() x 16]

transportAddressMask() =
    [] | transportAddressWithPort()

byte() = 0..255
word() = 0..65535
    </code></pre><p>For <strong>inet:ip4_address()</strong>, <strong>inet:ip6_address()</strong>
and <strong>inet:port_number()</strong>, see also
<a href="../kernel/inet#type-ip_address">kernel/inet#type-ip_address</a></p><a name="agent_entry"></a><h3>Functions</h3><h4>agent_entry(Tag, Val) -&gt; agent_entry()</h4><p>Create an agent entry</p><ul><li><span class="v">Tag = intAgentTransports | intAgentUDPPort | intAgentMaxPacketSize | snmpEngineMaxMessageSize | snmpEngineID</span></li><li><span class="v">Val = term()</span></li><li><span class="v">agent_entry() = term()</span></li></ul><p>Create an entry for the agent config file, <strong>agent.conf</strong>. </p><p>The type of <strong>Val</strong> depends on the value of <strong>Tag</strong>, 
see 
<a href="./snmp_agent_config_files#agent_information">Agent Information</a> 
for more info. </p><a name="write_agent_config"></a><h4>write_agent_config(Dir, Conf) -&gt; ok</h4><h4>write_agent_config(Dir, Hdr, Conf) -&gt; ok</h4><p>Write the agent config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [agent_entry()]</span></li></ul><p>Write the agent config to the agent config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#agent_information">Agent Information</a> 
for more info. </p><a name="append_agent_config"></a><h4>append_agent_config(Dir, Conf) -&gt; ok</h4><p>Append the agent config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [agent_entry()]</span></li></ul><p>Append the config to the current agent config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#agent_information">Agent Information</a> 
for more info. </p><a name="read_agent_config"></a><h4>read_agent_config(Dir) -&gt; Conf</h4><p>Read the agent config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [agent_entry()]</span></li></ul><p>Read the current agent config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#agent_information">Agent Information</a> 
for more info. </p><a name="standard_entry"></a><h4>standard_entry(Tag, Val) -&gt; standard_entry()</h4><p>Create an standard entry</p><ul><li><span class="v">Tag = sysDescr | sysObjectID | sysContact | sysName | sysLocation | sysServices | snmpEnableAuthenTraps</span></li><li><span class="v">Val = term()</span></li><li><span class="v">standard_entry() = term()</span></li></ul><p>Create an entry for the agent standard config file, 
<strong>standard.conf</strong>. </p><p>The type of <strong>Val</strong> depends on the value of <strong>Tag</strong>, 
see 
<a href="./snmp_agent_config_files#system_information">System Information</a> 
for more info. </p><a name="write_standard_config"></a><h4>write_standard_config(Dir, Conf) -&gt; ok</h4><h4>write_standard_config(Dir, Hdr, Conf) -&gt; ok</h4><p>Write the agent standard config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [standard_entry()]</span></li></ul><p>Write the agent standard config to the agent standard 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#system_information">System Information</a> 
for more info. </p><a name="append_standard_config"></a><h4>append_standard_config(Dir, Conf) -&gt; ok</h4><p>Append the agent standard config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [standard_entry()]</span></li></ul><p>Append the standard config to the current agent standard 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#system_information">System Information</a> 
for more info. </p><a name="read_standard_config"></a><h4>read_standard_config(Dir) -&gt; Conf</h4><p>Read the agent standard config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [standard_entry()]</span></li></ul><p>Read the current agent standard config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#system_information">System Information</a> 
for more info. </p><a name="context_entry"></a><h4>context_entry(Context) -&gt; context_entry()</h4><p>Create an context entry</p><ul><li><span class="v">Context = string()</span></li><li><span class="v">context_entry() = term()</span></li></ul><p>Create an entry for the agent context config file, 
<strong>context.conf</strong>. </p><p>See 
<a href="./snmp_agent_config_files#context">Contexts</a> 
for more info. </p><a name="write_context_config"></a><h4>write_context_config(Dir, Conf) -&gt; ok</h4><h4>write_context_config(Dir, Hdr, Conf) -&gt; ok</h4><p>Write the agent context(s) to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [context_entry()]</span></li></ul><p>Write the agent context config to the agent context 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#context">Contexts</a> 
for more info. </p><a name="append_context_config"></a><h4>append_context_config(Dir, Conf) -&gt; ok</h4><p>Append the agent context(s) to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [context_entry()]</span></li></ul><p>Append the context config to the current agent context 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#context">Contexts</a> 
for more info. </p><a name="read_context_config"></a><h4>read_context_config(Dir) -&gt; Conf</h4><p>Read the agent context config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [context_entry()]</span></li></ul><p>Read the current agent context config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#context">Contexts</a> 
for more info. </p><a name="community_entry"></a><h4>community_entry(CommunityIndex) -&gt; community_entry()</h4><h4>community_entry(CommunityIndex, CommunityName, SecName, ContextName, TransportTag) -&gt; community_entry()</h4><p>Create an community entry</p><ul><li><span class="v">CommunityIndex = string()</span></li><li><span class="v">CommunityName = string()</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">CtxName = string()</span></li><li><span class="v">TransportTag = string()</span></li><li><span class="v">community_entry() = term()</span></li></ul><p>Create an entry for the agent community config file, 
<strong>community.conf</strong>. </p><p><strong>CommunityIndex</strong> must be a <em>non-empty</em> string. </p><p><strong>community_entry("public")</strong> translates to the following call:
<strong>community_entry(CommunityIndex, CommunityIndex, "initial", "", "")</strong>. </p><p><strong>community_entry("all-rights")</strong> translates to the following 
call: <strong>community_entry(CommunityIndex, CommunityIndex, CommunityIndex, "", "")</strong>. </p><p>See 
<a href="./snmp_agent_config_files#community">Community</a> 
for more info. </p><a name="write_community_config"></a><h4>write_community_config(Dir, Conf) -&gt; ok</h4><h4>write_community_config(Dir, Hdr, Conf) -&gt; ok</h4><p>Write the agent community config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [community_entry()]</span></li></ul><p>Write the agent community config to the agent community 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#community">Community</a> 
for more info. </p><a name="append_community_config"></a><h4>append_community_config(Dir, Conf) -&gt; ok</h4><p>Append the agent community config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [community_entry()]</span></li></ul><p>Append the community config to the current agent community 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#community">Community</a> 
for more info. </p><a name="read_community_config"></a><h4>read_community_config(Dir) -&gt; Conf</h4><p>Read the agent community config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [community_entry()]</span></li></ul><p>Read the current agent community config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#community">Communities</a> 
for more info. </p><a name="target_addr_entry"></a><h4>target_addr_entry(Name, Domain, Addr, TagList, ParamsName, EngineId) -&gt; target_addr_entry()</h4><h4>target_addr_entry(Name, Domain, Addr, TagList, ParamsName, EngineId, TMask) -&gt; target_addr_entry()</h4><h4>target_addr_entry(Name, Domain, Addr, TagList, ParamsName, EngineId, TMask, MaxMessageSize) -&gt; target_addr_entry()</h4><h4>target_addr_entry(Name, Domain, Addr, Timeout, RetryCount, TagList, ParamsName, EngineId, TMask, MaxMessageSize) -&gt; target_addr_entry()</h4><p>Create an target_addr entry</p><ul><li><span class="v">Name = string()</span></li><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Ip = transportAddress() (depends on Domain)</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">RetryCount = integer()</span></li><li><span class="v">TagList = string()</span></li><li><span class="v">ParamsName = string()</span></li><li><span class="v">EngineId = string()</span></li><li><span class="v">TMask = transportAddressMask() (depends on Domain)</span></li><li><span class="v">MaxMessageSize = integer()</span></li><li><span class="v">target_addr_entry() = term()</span></li></ul><p>Create an entry for the agent target_addr config file, 
<strong>target_addr.conf</strong>. </p><p><strong>Name</strong> must be a <em>non-empty</em> string. </p><p><strong>target_addr_entry/6</strong> translates to the following call:
<strong>target_addr_entry(Name, Domain, Addr, TagList, ParamsName, EngineId, [])</strong>. </p><p><strong>target_addr_entry/7</strong> translates to the following call:
<strong>target_addr_entry(Name, Domain, Addr, TagList, ParamsName, EngineId, TMask, 2048)</strong>. </p><p><strong>target_addr_entry/8</strong> translates to the following call:
<strong>target_addr_entry(Name, Domain, Addr, 1500, 3, TagList, ParamsName, EngineId, TMask, MaxMessageSize)</strong>. </p><p>See 
<a href="./snmp_agent_config_files#target_addr">Target Address Definitions</a> 
for more info. </p><a name="write_target_addr_config"></a><h4>write_target_addr_config(Dir, Conf) -&gt; ok</h4><h4>write_target_addr_config(Dir, Hdr, Conf) -&gt; ok</h4><p>Write the agent target_addr config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [target_addr_entry()]</span></li></ul><p>Write the agent target_addr config to the agent target_addr 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#target_addr">Target Address Definitions</a> 
for more info. </p><a name="append_target_addr_config"></a><h4>append_target_addr_config(Dir, Conf) -&gt; ok</h4><p>Append the agent target_addr config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [target_addr_entry()]</span></li></ul><p>Append the target_addr config to the current agent target_addr 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#target_addr">Target Address Definitions</a> 
for more info. </p><a name="read_target_addr_config"></a><h4>read_target_addr_config(Dir) -&gt; Conf</h4><p>Read the agent target_addr config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [target_addr_entry()]</span></li></ul><p>Read the current agent target_addr config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#target_addr">Target Address Definitions</a> 
for more info. </p><a name="target_params_entry"></a><h4>target_params_entry(Name, Vsn) -&gt; target_params_entry()</h4><h4>target_params_entry(Name, Vsn, SecName, SecLevel) -&gt; target_params_entry()</h4><h4>target_params_entry(Name, MPModel, SecModel, SecName, SecLevel) -&gt; target_params_entry()</h4><p>Create an target_params entry</p><ul><li><span class="v">Name = string()</span></li><li><span class="v">Vsn = v1 | v2 | v3</span></li><li><span class="v">MPModel = v1 | v2c | v3</span></li><li><span class="v">SecModel = v1 | v2c | usm</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">SecLevel = noAuthNoPriv | authNoPriv | authPriv</span></li><li><span class="v">target_params_entry() = term()</span></li></ul><p>Create an entry for the agent target_params config file, 
<strong>target_params.conf</strong>. </p><p><strong>Name</strong> must be a <em>non-empty</em> string. </p><p><strong>Vsn</strong> translates into <strong>MPModel</strong> and <strong>SecModel</strong> as follows:</p><pre>
\011  Vsn = v1 =&gt; MPModel = v1,  SecModel = v1
\011  Vsn = v2 =&gt; MPModel = v2c, SecModel = v2c
\011  Vsn = v3 =&gt; MPModel = v3,  SecModel = usm
        </pre><p><strong>target_params_entry/2</strong> translates to the following call:
<strong>target_params_entry(Name, Vsn, "initial", noAuthNoPriv)</strong>. </p><p><strong>target_params_entry/4</strong> translates to the following
call: <strong>target_params_entry(Name, MPModel, SecModel, SecName, SecLevel)</strong> where <strong>MPModel</strong> and
<strong>SecModel</strong> is mapped from <strong>Vsn</strong>, see above. </p><p>See 
<a href="./snmp_agent_config_files#target_params">Target Parameters Definitions</a> 
for more info. </p><a name="write_target_params_config"></a><h4>write_target_params_config(Dir, Conf) -&gt; ok</h4><h4>write_target_params_config(Dir, Hdr, Conf) -&gt; ok</h4><p>Write the agent target_params config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [target_params_entry()]</span></li></ul><p>Write the agent target_params config to the agent target_params 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#target_params">Target Parameters Definitions</a> 
for more info. </p><a name="append_target_params_config"></a><h4>append_target_params_config(Dir, Conf) -&gt; ok</h4><p>Append the agent target_params config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [target_params_entry()]</span></li></ul><p>Append the target_params config to the current agent target_params 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#target_params">Target Parameters Definitions</a> 
for more info. </p><a name="read_target_params_config"></a><h4>read_target_params_config(Dir) -&gt; Conf</h4><p>Read the agent target_params config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [target_params_entry()]</span></li></ul><p>Read the current agent target_params config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#target_params">Target Parameters Definitions</a> 
for more info. </p><a name="vacm_entry"></a><h4>vacm_s2g_entry(SecModel, SecName, GroupName) -&gt; vacm_s2g_entry()</h4><h4>vacm_acc_entry(GroupName, Prefix, SecModel, SecLevel, Match, ReadView, WriteView, NotifyView) -&gt; vacm_acc_entry()</h4><h4>vacm_vtf_entry(ViewIndex, ViewSubtree) -&gt; vacm_vtf_entry()</h4><h4>vacm_vtf_entry(ViewIndex, ViewSubtree, ViewStatus, ViewMask) -&gt; vacm_vtf_entry()</h4><p>Create an vacm entry</p><ul><li><span class="v">SecModel = v1 | v2c | usm</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">GroupName = string()</span></li><li><span class="v">Prefix = string()</span></li><li><span class="v">SecLevel = noAuthNoPriv | authNoPriv | authPriv</span></li><li><span class="v">Match = prefix | exact</span></li><li><span class="v">ReadView = string()</span></li><li><span class="v">WriteView = string()</span></li><li><span class="v">NotifyView = string()</span></li><li><span class="v">ViewIndex = integer()</span></li><li><span class="v">ViewSubtree = [integer()]</span></li><li><span class="v">ViewStatus = included | excluded</span></li><li><span class="v">ViewMask = null | [zero_or_one()]</span></li><li><span class="v">zero_or_one() = 0 | 1</span></li><li><span class="v">vacm_s2g_entry() = term()</span></li><li><span class="v">vacm_acc_entry() = term()</span></li><li><span class="v">vacm_vtf_entry() = term()</span></li></ul><p>Create an entry for the agent vacm config file, 
<strong>vacm.conf</strong>. </p><p><strong>vacm_vtf_entry/2</strong> translates to the following call:
<strong>vacm_vtf_entry(ViewIndex, ViewSubtree, included, null)</strong>. </p><p>See 
<a href="./snmp_agent_config_files#vacm">MIB Views for VACM</a> 
for more info. </p><a name="write_vacm_config"></a><h4>write_vacm_config(Dir, Conf) -&gt; ok</h4><h4>write_vacm_config(Dir, Hdr, Conf) -&gt; ok</h4><p>Write the agent vacm config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [vacm_entry()]</span></li><li><span class="v">vacm_entry() = vacm_sg2_entry() | vacm_acc_entry() | vacm_vtf_entry()</span></li></ul><p>Write the agent vacm config to the agent vacm 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#vacm">MIB Views for VACM</a> 
for more info. </p><a name="append_vacm_config"></a><h4>append_vacm_config(Dir, Conf) -&gt; ok</h4><p>Append the agent vacm config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [vacm_entry()]</span></li></ul><p>Append the vacm config to the current agent vacm 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#vacm">MIB Views for VACM</a> 
for more info. </p><a name="read_vacm_config"></a><h4>read_vacm_config(Dir) -&gt; Conf</h4><p>Read the agent vacm config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [vacm_entry()]</span></li></ul><p>Read the current agent vacm config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#vacm">MIB Views for VACM</a> 
for more info. </p><a name="usm_entry"></a><h4>usm_entry(EngineId) -&gt; usm_entry()</h4><h4>usm_entry(EngineID, UserName, SecName, Clone, AuthP, AuthKeyC, OwnAuthKeyC, PrivP, PrivKeyC, OwnPrivKeyC, Public, AuthKey, PrivKey) -&gt; usm_entry()</h4><p>Create an usm entry</p><ul><li><span class="v">EngineId = string()</span></li><li><span class="v">UserName = string()</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">Clone = zeroDotZero | [integer()]</span></li><li><span class="v">AuthP = usmNoAuthProtocol | usmHMACMD5AuthProtocol, | usmHMACSHAAuthProtocol</span></li><li><span class="v">AuthKeyC = string()</span></li><li><span class="v">OwnAuthKeyC = string()</span></li><li><span class="v">PrivP = usmNoPrivProtocol | usmDESPrivProtocol | usmAesCfb128Protocol</span></li><li><span class="v">PrivKeyC = string()</span></li><li><span class="v">OwnPrivKeyC = string()</span></li><li><span class="v">Public = string()</span></li><li><span class="v">AuthKey = [integer()]</span></li><li><span class="v">PrivKey = [integer()]</span></li><li><span class="v">usm_entry() = term()</span></li></ul><p>Create an entry for the agent vacm config file, 
<strong>vacm.conf</strong>. </p><p><strong>usm_entry/1</strong> translates to the following call:
<strong>usm_entry("initial", "initial", zeroDotZero, usmNoAuthProtocol, "", "", usmNoPrivProtocol, "", "", "", "", "")</strong>. </p><p>See 
<a href="./snmp_agent_config_files#usm">Security data for USM</a> 
for more info. </p><a name="write_usm_config"></a><h4>write_usm_config(Dir, Conf) -&gt; ok</h4><h4>write_usm_config(Dir, Hdr, Conf) -&gt; ok</h4><p>Write the agent usm config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [usm_entry()]</span></li></ul><p>Write the agent usm config to the agent usm 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#usm">Security data for USM</a> 
for more info. </p><a name="append_usm_config"></a><h4>append_usm_config(Dir, Conf) -&gt; ok</h4><p>Append the agent usm config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [usm_entry()]</span></li></ul><p>Append the usm config to the current agent vacm 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#usm">Security data for USM</a> 
for more info. </p><a name="read_usm_config"></a><h4>read_usm_config(Dir) -&gt; Conf</h4><p>Read the agent usm config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [usm_entry()]</span></li></ul><p>Read the current agent usm config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#usm">Security data for USM</a> 
for more info. </p><a name="notify_entry"></a><h4>notify_entry(Name, Tag, Type) -&gt; notify_entry()</h4><p>Create an notify entry</p><ul><li><span class="v">Name = string()</span></li><li><span class="v">Tag = string()</span></li><li><span class="v">Type = trap | inform</span></li><li><span class="v">community_entry() = term()</span></li></ul><p>Create an entry for the agent notify config file, 
<strong>notify.conf</strong>. </p><p><strong>Name</strong> must be a <em>non-empty</em> string. </p><p>See 
<a href="./snmp_agent_config_files#notify">Notify Definitions</a> 
for more info. </p><a name="write_notify_config"></a><h4>write_notify_config(Dir, Conf) -&gt; ok</h4><h4>write_notify_config(Dir, Hdr, Conf) -&gt; ok</h4><p>Write the agent notify config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [notify_entry()]</span></li></ul><p>Write the agent notify config to the agent notify 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_agent_config_files#notify">Notify Definitions</a> 
for more info. </p><a name="append_notify_config"></a><h4>append_notify_config(Dir, Conf) -&gt; ok</h4><p>Append the agent notify config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [notify_entry()]</span></li></ul><p>Append the notify config to the current agent notify 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#notify">Notify Definitions</a> 
for more info. </p><a name="read_notify_config"></a><h4>read_notify_config(Dir) -&gt; Conf</h4><p>Read the agent notify config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [community_entry()]</span></li></ul><p>Read the current agent notify config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_agent_config_files#notify">Notify Definitions</a> 
for more info. </p><a name="end"></a><h3>snmpa_discovery_handler</h3><p>Behaviour module for the SNMP agent discovery handler.</p><p>This module defines the behaviour of the agent discovery
handler. A <strong>snmpa_discovery_handler</strong> compliant module 
must export the following functions: <ul><li> <p><a href="#stage1_finish">stage1_finish/2</a></p> </li></ul>The semantics of them and their exact signatures are explained
below. <a name="stage1_finish"></a></p><h3>Functions</h3><h4>stage1_finish(TargetName, ManagerEngineID, ExtraInfo) -&gt; ignore | {ok, usm_entry() | [usm_entry()]} | {ok, usm_entry() | [usm_entry()], NewExtraInfo}</h4><p>Discovery stage 1 finish</p><ul><li><span class="v">TargetName = string()</span></li><li><span class="v">ManagerEngineID = string()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">usm_entry() = tuple() compatible with usm.conf</span></li><li><span class="v">NewExtraInfo = term()</span></li></ul><p>This function is called at the end of stage 1 of the 
discovery process. It should return either the atom 
<strong>ignore</strong> or <strong>{ok, usm_entry() | [usm_entry()]}</strong>. See 
<a href="./snmp_agent_config_files#usm">usm_entry()</a>
and 
<a href="./snmpa_conf#usm_entry">usm_entry/13</a>
for more info. </p><p>If the function returns <strong>ignore</strong>, then it is assumed that 
either: </p><ul><li>The caller (of the discovery function) will make the  needed updates later. </li><li>The callback function itself did the updates. </li></ul><p>In either case, the agent will do nothing, but return
the retrieved ManagerEngineID (see 
<a href="./snmpa#discovery">discovery</a>
for more info) and possible continue with stage 2 of 
the discovery process. </p><p>The <strong>ExtraInfo</strong> argument is passed on from the 
<a href="./snmpa#discovery">discovery</a>
function. </p><p>This function may return an updated <strong>NewExtraInfo</strong> 
that will be used in subsequent calls to the callback 
functions. Intended for future use. </p><p>The purpose of this function is to generate the usm-
related security data needed for usm processing in the 
agent. Specifically, updating the usmUserTable. </p><p>When an <strong>usm_entry()</strong> tuple (or a list of such
tuples) is returned, this data is then added to the 
<strong>usmUserTable</strong> by the (master-) agent. </p><p>When an <strong>usm_entry()</strong> tuple (or a list of such
tuples) is returned, this data is then added to the 
<strong>usmUserTable</strong> by the (master-) agent. </p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that the function does not check if this entry 
already exists. </p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that this function is executed in the context of 
the master-agent process. </p></div><h3>snmpa_error_report</h3><p>Behaviour module for reporting SNMP agent errors</p><p><a name="desc"></a>This module defines the behaviour of the agent error reporting.
A <strong>snmpa_error_report</strong> compliant module 
must export the following functions: <ul><li> <p>config_err/2</p> </li><li> <p>user_err/2</p> </li></ul>The semantics of them and their exact signatures are explained
below. </p><h3>Functions</h3><h4>config_err(Format, Args) -&gt; void()</h4><p>Called if a configuration error occurs</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><p>The function is called if an error occurs during the
configuration phase, for example if a syntax error is found in
a configuration file.
</p><p><strong>Format</strong> and <strong>Args</strong> are as in
<strong>io:format(Format, Args)</strong>.</p><h4>user_err(Format, Args) -&gt; void()</h4><p>Called if a user related error occurs</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><p>The function is called if a user related error occurs at
run-time, for example if a user defined instrumentation
function returns erroneous.
</p><p><strong>Format</strong> and <strong>Args</strong> are as in
<strong>io:format(Format, Args)</strong>.</p><h3>snmpa_error</h3><p>Functions for Reporting SNMP Errors</p><p><a name="desc"></a>The module <strong>snmpa_error</strong> contains two callback functions 
which are called if an error occurs at different times during agent 
operation. These functions in turn calls the corresponding function
in the configured error report module, which implements the actual 
report functionality.
Two simple implementation(s) is provided with the
toolkit; the modules 
<a href="snmpa_error_logger">snmpa_error_logger</a> 
which is the default and 
<a href="snmpa_error_io">snmpa_error_io</a>.
The error report module is configured using the directive 
<strong>error_report_mod</strong>, see
<a href="./snmp_config#configuration_params">configuration parameters</a>.
<a name="config_err"></a></p><h3>Functions</h3><h4>config_err(Format, Args) -&gt; void()</h4><p>Called if a configuration error occurs</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><p>The function is called if an error occurs during the
configuration phase, for example if a syntax error is found in
a configuration file.
</p><p><strong>Format</strong> and <strong>Args</strong> are as in
<strong>io:format(Format, Args)</strong>.</p><a name="user_err"></a><h4>user_err(Format, Args) -&gt; void()</h4><p>Called if a user related error occurs</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><p>The function is called if a user related error occurs at
run-time, for example if a user defined instrumentation
function returns erroneous.
</p><p><strong>Format</strong> and <strong>Args</strong> are as in
<strong>io:format(Format, Args)</strong>.</p><h3>snmpa_error_io</h3><p>Functions for Reporting SNMP Errors on stdio</p><p>The module <strong>snmpa_error_io</strong> implements the 
<strong>snmp_error_report</strong> behaviour 
(see <a href="snmpa_error_report">snmpa_error_report</a>) 
containing two callback functions which are called in order to 
report SNMP errors.
This module provides a simple mechanism for reporting SNMP
errors. Errors are written to stdout using the <strong>io</strong> module.
It is provided as an simple example.
This module needs to be explicitly configured, see
<a href="./snmpa_error#desc">snmpa_error</a> and
<a href="./snmp_config#configuration_params">configuration parameters</a>.
</p><h3>Functions</h3><h4>config_err(Format, Args) -&gt; void()</h4><p>Called if a configuration error occurs</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><p>The function is called if an error occurs during the
configuration phase, for example if a syntax error is found in
a configuration file.
</p><p><strong>Format</strong> and <strong>Args</strong> are as in
<strong>io:format(Format, Args)</strong>.</p><h4>user_err(Format, Args) -&gt; void()</h4><p>Called if a user related error occurs</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><p>The function is called if a user related error occurs at
run-time, for example if a user defined instrumentation
function returns erroneous.
</p><p><strong>Format</strong> and <strong>Args</strong> are as in
<strong>io:format(Format, Args)</strong>.</p><h3>snmpa_error_logger</h3><p>Functions for Reporting SNMP Errors through the error_logger</p><p>The module <strong>snmpa_error_logger</strong> implements the 
<strong>snmpa_error_report</strong> behaviour 
(see <a href="snmpa_error_report">snmpa_error_report</a>) 
containing two callback functions which are called in order to 
report SNMP errors.
This module provides a simple mechanism for reporting SNMP
errors. Errors are sent to the <strong>error_logger</strong> after a 
size check. Messages are truncated after 1024 chars. 
It is provided as an example.
This module is the default error report module, but can be 
explicitly configured, see
<a href="./snmpa_error#desc">snmpa_error</a> and
<a href="./snmp_config#configuration_params">configuration parameters</a>.
</p><h3>Functions</h3><h4>config_err(Format, Args) -&gt; void()</h4><p>Called if a configuration error occurs</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><p>The function is called if an error occurs during the
configuration phase, for example if a syntax error is found in
a configuration file.
</p><p><strong>Format</strong> and <strong>Args</strong> are as in
<strong>io:format(Format, Args)</strong>.</p><h4>user_err(Format, Args) -&gt; void()</h4><p>Called if a user related error occurs</p><ul><li><span class="v">Format = string()</span></li><li><span class="v">Args = list()</span></li></ul><p>The function is called if a user related error occurs at
run-time, for example if a user defined instrumentation
function returns erroneous.
</p><p><strong>Format</strong> and <strong>Args</strong> are as in
<strong>io:format(Format, Args)</strong>.</p><h4>See Also</h4><p>error_logger(3)</p><h3>snmpa_local_db</h3><p>The SNMP built-in database</p><p>The module <strong>snmpa_local_db</strong> contains functions for
implementing tables (and variables) using the SNMP built-in 
database. The database exists in two instances, one volatile 
and one persistent. The volatile database is implemented with 
ets. The persistent database is implemented with dets. 
There is a scaling problem with this database.
<ul><li>Insertions and deletions are inefficient for large tables. </li></ul>This problem is best solved by using Mnesia instead.
The following functions describe the interface to 
<strong>snmpa_local_db</strong>. Each function has a Mnesia equivalent. 
The argument <strong>NameDb</strong> is a tuple <strong>{Name, Db}</strong> where 
<strong>Name</strong> is the symbolic name of the managed object (as defined 
in the MIB), and <strong>Db</strong> is either <strong>volatile</strong> or 
<strong>persistent</strong>. <strong>mnesia</strong> is not possible since all these 
functions are <strong>snmpa_local_db</strong> specific.
</p><h4>Common Data Types</h4><p>In the functions defined below, the following types are
used:
</p><ul><li> <p><strong>NameDb = {Name, Db}</strong></p> </li><li> <p><strong>Name = atom(), Db = volatile | persistent</strong></p> </li><li> <p><strong>RowIndex = [int()]</strong></p> </li><li> <p><strong>Cols = [Col] | [{Col, Value}], Col = int(), Value = term()</strong></p> </li></ul><p>where <strong>RowIndex</strong> denotes the last part of the OID, that
specifies the index of the row in the table.  <strong>Cols</strong> is a
list of column numbers in case of a get operation, and a list of
column numbers and values in case of a set operation.
</p><h3>Functions</h3><h4>dump() -&gt; ok | {error, Reason}</h4><p>Dump the database to disk</p><ul><li><span class="v">Reason = term()</span></li></ul><p>This function can be used to manually dump the database 
to file.</p><h4>match(NameDb, Pattern)</h4><p>Perform a match on the table</p><p>Performs an ets/dets matching on the table. 
See Stdlib documentation, module ets, for a description of 
<strong>Pattern</strong> and the return values.</p><h4>print()</h4><h4>print(TableName)</h4><h4>print(TableName, Db)</h4><p>Print the database to screen</p><ul><li><span class="v">TableName = atom()</span></li></ul><p>Prints the contents of the database on
screen. This is useful for debugging since the 
<strong>STANDARD-MIB</strong> and <strong>OTP-SNMPEA-MIB</strong> 
(and maybe your own MIBs) are stored in <strong>snmpa_local_db</strong>.
</p><p><strong>TableName</strong> is an atom for a table in the database. 
When no name is supplied, the whole database is shown.</p><h4>table_create(NameDb) -&gt; bool()</h4><p>Create a table</p><p>Creates a table. If the table already exist, the old copy
is destroyed.
</p><p>Returns <strong>false</strong> if the <strong>NameDb</strong> argument is
incorrectly specified, <strong>true</strong> otherwise.</p><h4>table_create_row(NameDb, RowIndex, Row) -&gt; bool()</h4><p>Create a row in a table</p><ul><li><span class="v">Row = {Val1, Val2, ..., ValN}</span></li><li><span class="v">Val1 = Val2 = ... = ValN = term()</span></li></ul><p>Creates a row in a table.  <strong>Row</strong> is a tuple with
values for all columns, including the index columns.</p><h4>table_delete(NameDb) -&gt; void()</h4><p>Delete a table</p><p>Deletes a table.</p><h4>table_delete_row(NameDb, RowIndex) -&gt; bool()</h4><p>Delete the row in the table</p><p>Deletes the row in the table.</p><h4>table_exists(NameDb) -&gt; bool()</h4><p>Check if a table exists</p><p>Checks if a table exists.</p><h4>table_get_row(NameDb, RowIndex) -&gt; Row | undefined</h4><p>Get a row from the table</p><ul><li><span class="v">Row = {Val1, Val2, ..., ValN}</span></li><li><span class="v">Val1 = Val2 = ... = ValN = term()</span></li></ul><p><strong>Row</strong> is a tuple with values for all columns,
including the index columns.</p><h4>See Also</h4><p>ets(3), dets(3), snmp_generic(3)
</p><h3>snmpa_mib_data</h3><p>Behaviour module for the SNMP agent mib-server 
  data module.</p><p>This module defines the behaviour of the SNMP agent mib-server 
data module. A <strong>snmpa_mib_data</strong> compliant module 
must export the following functions: <ul><li> <a href="#new">new/1</a> </li><li> <a href="#close">close/1</a> </li><li> <a href="#sync">sync/1</a> </li><li> <a href="#load_mib">load_mib/4</a> </li><li> <a href="#unload_mib">unload_mib/4</a> </li><li> <a href="#lookup">lookup/2</a> </li><li> <a href="#next">next/3</a> </li><li> <a href="#register_subagent">register_subagent/3</a> </li><li> <a href="#unregister_subagent">unregister_subagent/2</a> </li><li> <a href="#which_mib">which_mib/2</a> </li><li> <a href="#which_mibs">which_mibs/1</a> </li><li> <a href="#whereis_mib">whereis_mib/2</a> </li><li> <a href="#dump">dump/2</a> </li><li> <a href="#info">info/1</a> </li><li> <a href="#backup">backup/2</a> </li><li> <a href="#code_change">code_change/4</a> </li></ul>The semantics of them and their exact signatures are 
explained below. Note that the data extracted from the imported (loaded) 
mibs are stored partly by the mib-server and partly by the 
symbolic-store server. See the default mib-server data 
module, <strong>snmpa_mib_data_tttn</strong> for details. </p><h4>CALLBACK FUNCTIONS</h4><p>The following functions must be exported from a 
<strong>mib-server</strong> data callback module: </p><a name="new"></a><h3>Functions</h3><h4>Module:new(Storage) -&gt; State</h4><p>Create new (mib-server) data instance</p><ul><li><span class="v">Storage = mib_storage()</span></li><li><span class="v">State = term()</span></li></ul><p>Create a new mib-server data instance. </p><a name="close"></a><h4>Module:close(State) -&gt; void()</h4><p>Close the mib-server data instance</p><ul><li><span class="v">State = term()</span></li></ul><p>Close the mib-storage.</p><a name="sync"></a><h4>Module:sync(State) -&gt; void()</h4><p>Synchronize to disc</p><ul><li><span class="v">State = term()</span></li></ul><p>Synchronize (write to disc, if possible) the mib-server data. 
This depends on the <strong>mib_storage</strong> option, and will only have 
an effect if the mib-storage option has an actual disc component 
(such as dets, or ets with a file). </p><a name="load_mib"></a><h4>Module:load_mib(State, Filename, MeOverride, TeOverride) -&gt; {ok, NewState} | {error, Reason}</h4><p>Load a mib into the mib-server</p><ul><li><span class="v">State = NewState = term()</span></li><li><span class="v">Filename = filename()</span></li><li><span class="v">MeOverride = boolean()</span></li><li><span class="v">TeOverride = boolean()</span></li><li><span class="v">Reason = already_loaded | term()</span></li></ul><p>Load the mib specified by the <strong>Filename</strong> argument 
into the mib-server. 
The <strong>MeOverride</strong> and <strong>TeOverride</strong> arguments 
specifies how the mib-server shall handle duplicate mib- and trap-
entries. </p><a name="unload_mib"></a><h4>Module:unload_mib(State, Filename) -&gt; {ok, NewState} | {error, Reason}</h4><p>Unload mib from the mib-server</p><ul><li><span class="v">State = NewState = term()</span></li><li><span class="v">Filename = filename()</span></li><li><span class="v">Reason = not_loaded | term()</span></li></ul><p>Unload the mib specified by the <strong>Filename</strong> argument 
from the mib-server. </p><a name="lookup"></a><h4>Module:lookup(State, Oid) -&gt; Reply</h4><p>Find the mib-entry corresponding to the Oid</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = {variable, ME} | {table_column, ME, TEOid} | {subagent, SAPid, SAOid} | {false, Reason}</span></li><li><span class="v">Oid = TEOid = SAOid = oid()</span></li><li><span class="v">SAPid = pid()</span></li><li><span class="v">ME = me()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Find the mib-entry corresponding to the <strong>Oid</strong>. 
If it is a variable, the <strong>Oid</strong> must be 
&lt;Oid for var&gt;.0 
and if it is a table, <strong>Oid</strong> must be 
&lt;table&gt;.&lt;entry&gt;.&lt;col&gt;.&lt;any&gt;.</p><a name="next"></a><h4>Module:next(State, Oid, MibView) -&gt; Reply</h4><p>Finds the lexicographically next oid</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = false | endOfTable | {subagent, SAPid, SAOid} | {variable, ME, VarOid} | {table, TableOid, TableRestOid, ME}</span></li><li><span class="v">Oid = SAOid = VarOid = TableOid = TableRestOid = oid()</span></li><li><span class="v">SAPid = pid()</span></li><li><span class="v">ME = me()</span></li></ul><p>Finds the lexicographically next oid. </p><a name="register_subagent"></a><h4>Module:register_subagent(State, Oid, Pid) -&gt; Reply</h4><p>Register the subagent</p><ul><li><span class="v">State = NewState = term()</span></li><li><span class="v">Reply = {ok, NewState} | {error, Reason}</span></li><li><span class="v">Oid = oid()</span></li><li><span class="v">Pid = pid()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Register the subagent, process, 
handling part of the mib-tree. </p><a name="unregister_subagent"></a><h4>Module:unregister_subagent(State, PidOrOid) -&gt; Reply</h4><p>Unregister the subagent</p><ul><li><span class="v">State = NewState = term()</span></li><li><span class="v">Reply = {ok, NewState} | {ok, NewState, Pid} | {error, Reason}</span></li><li><span class="v">PidOrOid = pid() | oid()</span></li><li><span class="v">Pid = pid()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Unregister the subagent, handling part of the mib-tree, 
as specified by the <strong>oid()</strong> or <strong>pid()</strong> 
(<strong>PidOrOid</strong>). </p><p>When unregister the subagent using an <strong>oid()</strong>, the <strong>pid()</strong> 
of the process handling the sub-tree is also returned. </p><a name="dump"></a><h4>Module:dump(State, Destination) -&gt; Reply</h4><p>Unregister the subagent</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = ok | {error, Reason}</span></li><li><span class="v">Destination = io | filename()</span></li><li><span class="v">Pid = pid()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Dump the mib-server data to <strong>stdio</strong> (Destination = <strong>io</strong>) or
the specified file. </p><a name="which_mib"></a><h4>Module:which_mib(State, Oid) -&gt; Reply</h4><p>Retrieve the mib file for an oid()</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = {ok, MibFile} | {error, Reason}</span></li><li><span class="v">Oid = oid()</span></li><li><span class="v">MibFile = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retrieve the mib-file to which an given <strong>oid()</strong> belongs. </p><a name="which_mibs"></a><h4>Module:which_mibs(State) -&gt; Reply</h4><p>Retrieve all loaded mib files</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = [{MibName, Filename}]</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">Filename = string()</span></li></ul><p>Retrieve all loaded mib-files. </p><a name="whereis_mib"></a><h4>Module:whereis_mib(State, MibName) -&gt; Reply</h4><p>Retrieve the mib file for the mib</p><ul><li><span class="v">State = term()</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">Reply = {ok, Filename} | {error, Reason}</span></li><li><span class="v">Filename = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retrieve the mib file for the mib. </p><a name="info"></a><h4>Module:info(State) -&gt; Reply</h4><p>Retrieve misc info for the mib data</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = {ok, Filename} | {error, Reason}</span></li><li><span class="v">Filename = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retrieve misc info for the mib data. </p><p>This is a utility function used to inspect, for instance, 
memory usage, in a simple way. </p><a name="backup"></a><h4>Module:backup(State, BackupDir) -&gt; Reply</h4><p>Perform a backup of the mib-server data</p><ul><li><span class="v">State = term()</span></li><li><span class="v">Reply = ok | {error, Reason}</span></li><li><span class="v">BackupDir = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Perform a backup of the mib-server data. </p><p>Note that its implementation dependant (and also 
dependent on mib-storage is used) if a backup is possible. </p><a name="code_change"></a><h4>Module:code_change(Destination, Vsn, Extra, State) -&gt; NewState</h4><p>Perform a code-change</p><ul><li><span class="v">Destination = up | down</span></li><li><span class="v">Vsn = term()</span></li><li><span class="v">Extra = term()</span></li><li><span class="v">State = NewState = term()</span></li></ul><p>Perform a code-change (upgrade or downgrade). </p><p>See 
<a href="./gen_server">gen_server</a>
for more info regarding the <strong>Vsn</strong> and <strong>Extra</strong> arguments. </p><h3>snmpa_mib_storage</h3><p>
    Behaviour module for the SNMP agent mib storage. 
</p><p>This module defines the behaviour of the SNMP agent mib storage. The mib storage is used by the agent to store internal mib-
related information. The mib storage module is used by several entities, 
not just the mib-server. A <strong>snmpa_mib_storage</strong> compliant module 
must export the following functions: <ul><li> <a href="#open">open/5</a> </li><li> <a href="#close">close/1</a> </li><li> <a href="#read">read/2</a> </li><li> <a href="#write">write/2</a> </li><li> <a href="#delete1">delete/1</a> </li><li> <a href="#delete2">delete/2</a> </li><li> <a href="#match_object">match_object/2</a> </li><li> <a href="#match_delete">match_delete/2</a> </li><li> <a href="#tab2list">tab2list/1</a> </li><li> <a href="#info">info/1</a> </li><li> <a href="#sync">sync/1</a> </li><li> <a href="#backup">backup/2</a> </li></ul>The semantics of them and their exact signatures are 
explained below. </p><h4>CALLBACK FUNCTIONS</h4><p>The following functions must be exported from a 
<strong>mib-server</strong> data callback module: </p><a name="open"></a><h3>Functions</h3><h4>Module:open(Name, RecordName, Fields, Type, Options) -&gt; {ok, TabId} | {error, Reason}</h4><p>Create new (mib-server) data instance</p><ul><li><span class="v">Name = atom()</span></li><li><span class="v">RecordName = atom()</span></li><li><span class="v">Fields = [atom()]</span></li><li><span class="v">Type = set | bag()</span></li><li><span class="v">Options = list()</span></li><li><span class="v">TabId = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Create or open a mib storage table. </p><p>Note that the <strong>RecordName</strong> and <strong>Fields</strong> arguments 
my not be used in all implementations (they are actually only 
needed for mnesia-based implementations). </p><p>Note also that the <strong>Options</strong> argument comes from
the <strong>options</strong> config option of the mib-storage config option, 
and is passed on as is. </p><a name="close"></a><h4>Module:close(TabId) -&gt; void()</h4><p>Close the mib-storage table</p><ul><li><span class="v">State = term()</span></li></ul><p>Close the mib-storage table.</p><a name="read"></a><h4>Module:read(TabId, Key) -&gt; false | {value, Record}</h4><p>Read a record from the mib-storage table</p><ul><li><span class="v">TabId = term()</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Record = tuple()</span></li></ul><p>Read a record from the mib-storage table. </p><a name="write"></a><h4>Module:write(TabId, Record) -&gt; ok | {error, Reason}</h4><p>Write a record to the mib-storage table</p><ul><li><span class="v">TabId = term()</span></li><li><span class="v">Record = tuple()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Write a record to the mib-storage table. </p><a name="delete1"></a><h4>Module:delete(TabId) -&gt; void()</h4><p>Delete an entire mib-storage table</p><ul><li><span class="v">TabId = term()</span></li></ul><p>Delete an entire mib-storage table. </p><a name="delete2"></a><h4>Module:delete(TabId, Key) -&gt; ok | {error, Reason}</h4><p>Delete a record from the mib-storage table</p><ul><li><span class="v">TabId = term()</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a record from the mib-storage table. </p><a name="match_object"></a><h4>Module:match_object(TabId, Pattern) -&gt; {ok, Recs} | {error, Reason}</h4><p>Search the mib-storage table for record matching pattern</p><ul><li><span class="v">TabId = term()</span></li><li><span class="v">Pattern = match_pattern()</span></li><li><span class="v">Recs = [tuple()]</span></li><li><span class="v">Reason = term()</span></li></ul><p>Search the mib-storage table for record that match the
specified pattern. </p><a name="match_delete"></a><h4>Module:match_delete(TabId, Pattern) -&gt; {ok, Recs} | {error, Reason}</h4><p>Delete records in the mib-storage table matching pattern</p><ul><li><span class="v">TabId = term()</span></li><li><span class="v">Pattern = match_pattern()</span></li><li><span class="v">Recs = [tuple()]</span></li><li><span class="v">Reason = term()</span></li></ul><p>Search the mib-storage table for record that match the
specified pattern and then delete them. The records deleted are
also returned. </p><a name="tab2list"></a><h4>Module:tab2list(TabId) -&gt; Recs</h4><p>Return all records of the mib-storage table</p><ul><li><span class="v">TabId = term()</span></li><li><span class="v">Recs = [tuple()]</span></li></ul><p>Return all records in the mib-storage table in the form 
of a list. </p><a name="info"></a><h4>Module:info(TabId) -&gt; {ok, Info} | {error, Reason}</h4><p>Returns information about the mib-storage table. </p><ul><li><span class="v">TabId = term()</span></li><li><span class="v">Info = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retrieve implementation dependent mib-storage table 
information. </p><a name="sync"></a><h4>Module:sync(TabId) -&gt; void()</h4><p>Synchronize mib-storage table</p><ul><li><span class="v">TabId = term()</span></li></ul><p>Synchronize the mib-storage table. </p><p>What this means, if anything, is implementation dependent. </p><a name="backup"></a><h4>Module:backup(TabId, BackupDir) -&gt; ok | {error, Reason}</h4><p>Perform a backup of the mib-storage table</p><ul><li><span class="v">TabId = term()</span></li><li><span class="v">BackupDir = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Perform a backup of the mib-storage table. </p><p>What this means, if anything, is implementation dependent. </p><h3>snmpa_mpd</h3><p>Message Processing and Dispatch module for the SNMP agent</p><p>The module <strong>snmpa_mpd</strong> implements the version independent
Message Processing and Dispatch functionality in SNMP for the agent. 
It is supposed to be used from a Network Interface process 
(<a href="snmp_agent_netif">Definition of Agent Net if</a>).
<a name="init"></a></p><h4>DATA TYPES</h4><p>See the <a href="./snmpa_conf#types"> data types in </a>.</p><h3>Functions</h3><h4>init(Vsns) -&gt; mpd_state()</h4><p>Initialize the MPD module</p><ul><li><span class="v">Vsns = [Vsn]</span></li><li><span class="v">Vsn = v1 | v2 | v3</span></li></ul><p>This function can be called from the net_if process at start-up.
The options list defines which versions to use.
</p><p>It also initializes some SNMP counters.
</p><a name="process_packet"></a><h4>process_packet(Packet, From, State, NoteStore, Log) -&gt; {ok, Vsn, Pdu, PduMS, ACMData} | {discarded, Reason} | {discovery, DiscoPacket}</h4><h4>process_packet(Packet, From, LocalEngineID, State, NoteStore, Log) -&gt; {ok, Vsn, Pdu, PduMS, ACMData} | {discarded, Reason} | {discovery, DiscoPacket}</h4><p>Process a packet received from the network</p><ul><li><span class="v">Packet = binary()</span></li><li><span class="v">From = {TDomain, TAddr}</span></li><li><span class="v">TDomain = transportDomainUdpIpv4 | transportDomainUdpIpv6</span></li><li><span class="v">TAddr = {IpAddr, IpPort}</span></li><li><span class="v">LocalEngineID = string()</span></li><li><span class="v">IpAddr = </span></li><li><span class="v">IpPort = inet:port_number()</span></li><li><span class="v">State = mpd_state()</span></li><li><span class="v">NoteStore = pid()</span></li><li><span class="v">Log = snmp_log()</span></li><li><span class="v">Vsn = 'version-1' | 'version-2' | 'version-3'</span></li><li><span class="v">Pdu = #pdu</span></li><li><span class="v">PduMs = integer()</span></li><li><span class="v">ACMData = acm_data()</span></li><li><span class="v">Reason = term()</span></li><li><span class="v">DiscoPacket = binary()</span></li></ul><p>Processes an incoming packet.  Performs authentication and 
decryption as necessary.  The return values should be passed to the
agent.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that the use of the LocalEngineID argument is only intended 
for special cases, if the agent is to "emulate" multiple EngineIDs!
By default, the agent uses the value of <strong>SnmpEngineID</strong> 
(see SNMP-FRAMEWORK-MIB). </p></div><a name="generate_response_msg"></a><h4>generate_response_msg(Vsn, RePdu, Type, ACMData, Log) -&gt; {ok, Packet} | {discarded, Reason}</h4><h4>generate_response_msg(Vsn, RePdu, Type, ACMData, LocalEngineID, Log) -&gt; {ok, Packet} | {discarded, Reason}</h4><p>Generate a response packet to be sent to the network</p><ul><li><span class="v">Vsn = 'version-1' | 'version-2' | 'version-3'</span></li><li><span class="v">RePdu = #pdu</span></li><li><span class="v">Type = atom()</span></li><li><span class="v">ACMData = acm_data()</span></li><li><span class="v">LocalEngineID = string()</span></li><li><span class="v">Packet = binary()</span></li></ul><p>Generates a possibly encrypted response packet to be sent to the
network. <strong>Type</strong> is the <strong>#pdu.type</strong> of the original
request.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that the use of the LocalEngineID argument is only intended 
for special cases, if the agent is to "emulate" multiple EngineIDs!
By default, the agent uses the value of <strong>SnmpEngineID</strong> 
(see SNMP-FRAMEWORK-MIB). </p></div><a name="generate_msg"></a><h4>generate_msg(Vsn, NoteStore, Pdu, MsgData, To) -&gt; {ok, PacketsAndAddresses} | {discarded, Reason}</h4><h4>generate_msg(Vsn, NoteStore, Pdu, MsgData, LocalEngineID, To) -&gt; {ok, PacketsAndAddresses} | {discarded, Reason}</h4><p>Generate a request message to be sent to the network</p><ul><li><span class="v">Vsn = 'version-1' | 'version-2' | 'version-3'</span></li><li><span class="v">NoteStore = pid()</span></li><li><span class="v">Pdu = #pdu</span></li><li><span class="v">MsgData = msg_data()</span></li><li><span class="v">LocalEngineID = string()</span></li><li><span class="v">To = [dest_addrs()]</span></li><li><span class="v">PacketsAndAddresses = [{TDomain, TAddress, Packet}]</span></li><li><span class="v">TDomain = snmpUDPDomain</span></li><li><span class="v">TAddress = {Ip, Udp}</span></li><li><span class="v">Ip = {integer(), integer(), integer(), integer()}</span></li><li><span class="v">Udp = integer()</span></li><li><span class="v">Packet = binary()</span></li></ul><p>Generates a possibly encrypted request packet to be sent to the
network.
</p><p><strong>MsgData</strong> is the message specific data used in
the SNMP message.  This value is received in a
<a href="./snmp_agent_netif#im_send_pdu">snmp_agent_netif#im_send_pdu</a>
or
<a href="./snmp_agent_netif#im_send_pdu_req">snmp_agent_netif#im_send_pdu_req</a>
message from the agent.  In SNMPv1 and
SNMPv2c, this message data is the community string.  In
SNMPv3, it is the context information.</p><p>
<strong>To</strong> is a list of destination addresses and
their corresponding security parameters.  This value is
received in the same message from the agent and then transformed
trough <a href="#process_taddrs">process_taddrs</a>
before passed to this function.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that the use of the LocalEngineID argument is only intended 
for special cases, if the agent is to "emulate" multiple EngineIDs!
By default, the agent uses the value of <strong>SnmpEngineID</strong> 
(see SNMP-FRAMEWORK-MIB). </p></div><a name="process_taddrs"></a><h4>process_taddrs(TDests) -&gt; Dests</h4><p>Transform addresses from internal MIB format to a less internal </p><ul><li><span class="v">TDests = [TDest]</span></li><li><span class="v">TDest = {{TDomain, TAddr}, SecData} | {TDomain, TAddr}</span></li><li><span class="v">TDomain = term()  % Not at tuple</span></li><li><span class="v">TAddr = term()</span></li><li><span class="v">SecData = term()</span></li><li><span class="v">Dests = [Dest]</span></li><li><span class="v">Dest = {{Domain, Addr}, SecData} | {Domain, Addr}</span></li><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddress()  % Depends on Domain</span></li></ul><p>Transforms addresses from internal MIB format to one
more useful to <a href="snmp_agent_netif">Agent Net if</a>.
</p><p>See also <a href="#generate_msg">.</a>
</p><a name="discarded_pdu"></a><h4>discarded_pdu(Variable) -&gt; void()</h4><p>Increment the variable associated with a discarded pdu</p><ul><li><span class="v">Variable = atom()</span></li></ul><p>Increments the variable associated with a discarded pdu.
This function can be used when the net_if process receives a
<strong>discarded_pdu</strong> message from the agent.
</p><h3>snmpa_network_interface</h3><p>Behaviour module for the SNMP agent network interface.</p><p>This module defines the behaviour of the agent network
interface. A <strong>snmpa_network_interface</strong> compliant module 
must export the following functions: <ul><li> <p><a href="#start_link">start_link/4</a></p> </li><li> <p><a href="#info">info/1</a></p> </li><li> <p><a href="#get_log_type">get_log_type/1</a></p> </li><li> <p><a href="#set_log_type">set_log_type/2</a></p> </li><li> <p><a href="#verbosity">verbosity/2</a></p> </li></ul>The semantics of them and their exact signatures are explained
below. But this is not enough. There is also a set of <em>mandatory</em>
messages which the network interface entity must be able to 
receive and be able to send. This is described in chapter
<a href="snmp_agent_netif">snmp_agent_netif</a>.
<a name="start_link"></a></p><h3>Functions</h3><h4>start_link(Prio, NoteStore, MasterAgent, Opts) -&gt; {ok, Pid} | {error, Reason}</h4><p>Start-link the network interface process</p><ul><li><span class="v">Prio        = priority()</span></li><li><span class="v">NoteStore   = pid()</span></li><li><span class="v">MasterAgent = pid()</span></li><li><span class="v">Opts        = [opt()]</span></li><li><span class="v">opt()       = {verbosity, verbosity()} | {versions, versions()} | term()</span></li><li><span class="v">versions()  = [version()]</span></li><li><span class="v">version()   = v1 | v2 | v3</span></li></ul><p>Start-link the network interface process.</p><p><strong>NoteStore</strong> is the pid of the note-store process and 
<strong>MasterAgent</strong> is the pid of the master-agent process.</p><p><strong>Opts</strong> is an (basically) implementation dependent list of 
options to the network interface process. There are however
a number of options which <em>must</em> be handled: 
<strong>versions</strong> and <strong>verbosity</strong>.</p><a name="info"></a><h4>info(Pid) -&gt; [{Key, Value}]</h4><p>Return information about the running network interface process</p><ul><li><span class="v">Pid = pid()</span></li></ul><p>The info returned is basically up to the implementer to decide. 
This implementation provided by the application provides info about 
memory allocation and various socket information.</p><p>The info returned by this function is returned together with other 
info collected by the agent when the 
<a href="./snmpa#info">info</a> function is called 
(tagged with with the key <strong>net_if</strong>).</p><a name="verbosity"></a><h4>verbosity(Pid, Verbosity) -&gt; void()</h4><p>Change the verbosity of a running network interface process</p><ul><li><span class="v">Pid       = pid()</span></li><li><span class="v">Verbosity = verbosity()</span></li></ul><p>Change the verbosity of a running network interface process.</p><a name="get_log_type"></a><h4>get_log_type(Pid) -&gt; {ok, LogType} | {error, Reason}</h4><p>Get the Audit Trail Log type</p><ul><li><span class="v">Pid     = pid()</span></li><li><span class="v">LogType = atl_type()</span></li><li><span class="v">Reason  = term()</span></li></ul><p>The Audit Trail Log is managed by the network interface process. 
So, it is this process that has to retrieve the actual log-type. </p><a name="set_log_type"></a><h4>set_log_type(Pid, NewType) -&gt; {ok, OldType} | {error, Reason}</h4><p>Change the Audit Trail Log type</p><ul><li><span class="v">Pid     = pid()</span></li><li><span class="v">NewType = OldType = atl_type()</span></li><li><span class="v">Reason  = term()</span></li></ul><p>The Audit Trail Log is managed by the network interface process. 
So, it is this process that has to do the actual changing of the 
type. </p><p>See 
<a href="./snmpa#set_log_type">set_log_type</a>
for more info. </p><h3>snmpa_network_interface_filter</h3><p>Behaviour module for the SNMP agent network-interface filter.</p><p>This module defines the behaviour of the agent network interface
filter. A <strong>snmpa_network_interface_filter</strong> compliant module 
must export the following functions: <ul><li> <p><a href="#accept_recv">accept_recv/2</a></p> </li><li> <p><a href="#accept_send">accept_send/2</a></p> </li><li> <p><a href="#accept_recv_pdu">accept_recv_pdu/3</a></p> </li><li> <p><a href="#accept_send_pdu">accept_send_pdu/2</a></p> </li></ul>The semantics of them and their exact signatures are explained
below. The purpose of the network interface filter is to allow for filtering
of messages (accept or reject) receive and send. This is done 
on two levels: <ul><li> <p>The first level is at the transport entry / exit point, i.e.
immediately after the receipt of the message before any message
processing is done (accept_recv) and 
immediately before sending the message after all message
processing is done (accept_send).</p> </li><li> <p>The second level is at the MPD entry / exit point, i.e.
immediately after the basic message processing (accept_recv_pdu) / 
immediately before the basic message processing (accept_send_pdu).</p> </li></ul>Note that the network interface filter is something which is used 
by the network interface implementation provided by the application 
(<strong>snmpa_net_if</strong>). The default filter accepts all messages.A network interface filter can e.g. be used during testing or for load 
regulation. If the intended use is load regulation, see also 
<a href="./snmp_app#configuration_params">req_limit</a> and 
the function 
<a href="./snmpa#register_notification_filter">register_notification_filter</a>. Legacy network interface filter modules used arguments on the form
<strong>(IpAddr, PortNumber,...)</strong> instead of
<strong>(Domain, Addr, ...)</strong>, and if the SNMP agent is run without
changing the configuration to use transport domains
the network interface filter will still get
the old arguments and work as before.</p><h4>DATA TYPES</h4><pre><code class="">
port() = integer() &gt; 0
pdu_type() = 'get-request' | 'get-next-request' | 'get-response' | 
             'set-request' | trap | 'get-bulk-request' | 'inform-request' | 
             report
    </code></pre><p>See also the <a href="./snmpa_conf#types"> data types in </a>.</p><a name="accept_recv"></a><h3>Functions</h3><h4>accept_recv(Domain, Addr) -&gt; boolean()</h4><p>Shall the received message be accepted</p><ul><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddressWithPort()</span></li></ul><p>Called at the reception of a message (before <em>any</em> processing 
has been done).</p><p>For the message to be discarded, the function <em>must</em> return
<em>false</em>. </p><a name="accept_send"></a><h4>accept_send(Domain, Addr) -&gt; boolean()</h4><p>Shall the message be sent</p><ul><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddressWithPort()</span></li></ul><p>Called before the sending of a message (after <em>all</em> processing 
has been done).</p><p>For the message to be discarded, the function <em>must</em> return
<em>false</em>. </p><a name="accept_recv_pdu"></a><h4>accept_recv_pdu(Domain, Addr, PduType) -&gt; boolean()</h4><p>Shall the received pdu be accepted</p><ul><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddressWithPort()</span></li><li><span class="v">PduType = pdu_type()</span></li></ul><p>Called after the basic message processing (MPD) has been done, 
but before the pdu is handed over to the master-agent for 
primary processing.</p><p>For the pdu to be discarded, the function <em>must</em> return
<em>false</em>. </p><a name="accept_send_pdu"></a><h4>accept_send_pdu(Targets, PduType) -&gt; Reply</h4><p>Shall the pdu be sent</p><ul><li><span class="v">Targets = targets()</span></li><li><span class="v">targets() = [target()]</span></li><li><span class="v">target() = {Domain, Addr}</span></li><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddressWithPort()</span></li><li><span class="v">PduType = pdu_type() &gt; 0</span></li><li><span class="v">Reply = boolean() | NewTargets</span></li><li><span class="v">NewTargets = targets()</span></li></ul><p>Called before the basic message processing (MPD) is done, 
when a pdu has been received from the master-agent.</p><p>For the message to be discarded all together, the function 
<em>must</em> return <em>false</em>. </p><p>Note that it is possible for this function to filter out targets
(but <em>not</em> to add its own) by returning an updated
<strong>Targets</strong> list (<strong>NewTargets</strong>). </p><h3>snmpa_notification_delivery_info_receiver</h3><p>
    Behaviour module for the SNMP agent notification delivery 
    information receiver.
</p><p>This module defines the behaviour of the notification 
delivery information receiver. A <strong>snmpa_notification_delivery_info_receiver</strong> compliant module 
must export the following functions: <ul><li> <p><a href="#delivery_targets/3">delivery_targets/3</a></p> </li><li> <p><a href="#delivery_info/4">delivery_info/4</a></p> </li></ul>The semantics of them and their exact signatures are explained
below. Legacy notification delivery information receiver modules
used a target argument on the form
<strong>{IpAddr, PortNumber}</strong> instead of
<strong>{Domain, Addr}</strong>, and if the SNMP Agent is run without
changing the configuration to use transport domains
the notification delivery information receiver will still get
the old arguments and work as before.</p><h4>DATA TYPES</h4><p>See the <a href="./snmpa_conf#types"> data types in </a>.</p><a name="accept_recv"></a><a name="delivery_targets"></a><h3>Functions</h3><h4>delivery_targets(Tag, Targets, Extra) -&gt; void()</h4><p>Inform about target addresses</p><ul><li><span class="v">Tag = term()</span></li><li><span class="v">Targets = [Target]</span></li><li><span class="v">Target = {transportDomain(), transportAddressWithPort()</span></li><li><span class="v">Extra = term()</span></li></ul><p>Inform about target addresses. </p><p>This is the first function called when a notification delivery is
in progress. It informs the <strong>receiver</strong> which targets will
get the notification. The result of the delivery will be 
provided via successive calls to <strong>delivery_info/4</strong> function, 
see below.</p><a name="delivery_info"></a><h4>delivery_info(Tag, Target, DeliveryResult, Extra) -&gt; void()</h4><p>Inform about delivery result</p><ul><li><span class="v">Tag = term()</span></li><li><span class="v">Targets = [Target]</span></li><li><span class="v">Target = {transportDomain(), transportAddressWithPort()</span></li><li><span class="v">DeliveryResult = delivery_result()</span></li><li><span class="v">delivery_result() = no_response | got_response</span></li><li><span class="v">Extra = term()</span></li></ul><p>Inform about delivery result.</p><p>This function is called for each target in the <strong>Targets</strong>
argument of the <strong>delivery_targets/3</strong> function, see above. </p><p>The purpose is to inform the <strong>receiver</strong> of the 
result of the delivery (was the notification acknowledged or 
not) for each target.</p><h3>snmpa_notification_filter</h3><p>Behaviour module for the SNMP agent notification filters.</p><p>This module defines the behaviour of the agent notification
filters. A <strong>snmpa_notification_filter</strong> compliant module 
must export the following functions: <ul><li> <p>handle_notification/2</p> </li></ul>The semantics of them and their exact signatures are explained
below. The purpose of notification filters is to allow for modification
and/or suppression of a notification.A misbehaving filter will be removed.</p><h3>Functions</h3><h4>handle_notification(Notif, Data) -&gt; Reply</h4><p>Handle a notification</p><ul><li><span class="v">Reply = send | {send, NewNotif} | dont_send</span></li><li><span class="v">Notif =  NewNotif = notification() | trap()</span></li><li><span class="v">Data  = term()</span></li></ul><p>Handle a notification to be sent. The filter can either
accept the notification as is, return <strong>send</strong>, modify
the notification, return <strong>{send, NewNotif}</strong> or
suppress the notification, return <strong>dont_send</strong>.</p><p><strong>Data</strong> is supplied at filter registration time,
see <a href="./snmpa#register_notification_filter">register_notification_filter</a>.
</p><h3>snmpa_supervisor</h3><p>A supervisor for the SNMP agent Processes</p><p>This is the top supervisor for the agent part of the SNMP 
application. There is always one supervisor at each node with 
an SNMP agent (master agent or sub-agent).
</p><h3>Functions</h3><h4>start_sub_sup(Opts) -&gt; {ok, pid()} | {error, {already_started, pid()}} | {error, Reason}</h4><p>Start the SNMP supervisor for sub-agents only</p><ul><li><span class="v">Opts = [opt()]</span></li><li><span class="v">opt() = {db_dir, string()} | ...</span></li></ul><p>Starts a supervisor for the SNMP agent system without a
master agent.  The supervisor starts all involved SNMP
processes, but no agent processes.  Sub-agents should be
started by calling <strong>start_sub_agent/3</strong>.
</p><p><strong>db_dir</strong> is mandatory.</p><p>See <a href="./snmp_config#configuration_params">configuration parameters</a> for 
a description of the options.</p><h4>start_master_sup(Opts) -&gt; {ok, pid()} |  {error, {already_started, pid()}} | {error, Reason}</h4><p>Start the SNMP supervisor for all agents</p><ul><li><span class="v">Opts = [opt()]</span></li><li><span class="v">opt() = {db_dir, string()} | {config, ConfOpts()} | ...</span></li><li><span class="v">ConfOpts = [conf_opts()]</span></li><li><span class="v">conf_opts() = {dir, string()} | ...</span></li><li><span class="v">Reason = term()</span></li></ul><p>Starts a supervisor for the SNMP agent system.  The
supervisor starts all involved SNMP processes, including the
master agent.  Sub-agents should be started by calling
<strong>start_subagent/3</strong>.
</p><p><strong>db_dir</strong> is mandatory.</p><p><strong>dir</strong> in config is mandatory.</p><p>See <a href="snmp_config">snmp config</a> for 
a description of the options.</p><h4>start_sub_agent(ParentAgent,Subtree,Mibs) -&gt; {ok, pid()} | {error, Reason}</h4><p>Start a sub-agent</p><ul><li><span class="v">ParentAgent = pid()</span></li><li><span class="v">SubTree = oid()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = [string()]</span></li></ul><p>Starts a sub-agent on the node where the function is
called.  The <strong>snmpa_supervisor</strong> must be running.
</p><p>If the supervisor is not running, the function fails with the
reason <strong>badarg</strong>.</p><h4>stop_sub_agent(SubAgent) -&gt; ok | no_such_child</h4><p>Stop a sub-agent</p><ul><li><span class="v">SubAgent = pid()</span></li></ul><p>Stops the sub-agent on the node where the function is
called.  The <strong>snmpa_supervisor</strong> must be running.
</p><p>If the supervisor is not running, the function fails with the
reason <strong>badarg</strong>.</p><h3>snmp_community_mib</h3><p>Instrumentation Functions for SNMP-COMMUNITY-MIB</p><p>The module <strong>snmp_community_mib</strong> implements the instrumentation
functions for the SNMP-COMMUNITY-MIB, and functions for configuring the 
database. The configuration files are described in the SNMP User's Manual.<a name="configure"></a></p><h3>Functions</h3><h4>configure(ConfDir) -&gt; void()</h4><p>Configure the SNMP-COMMUNITY-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>This function is called from the supervisor at system
start-up.
</p><p>Inserts all data in the configuration files into the
database and destroys all old rows with StorageType
<strong>volatile</strong>.  The rows created from the configuration file
will have StorageType <strong>nonVolatile</strong>.
</p><p>All <strong>snmp</strong> counters are set to zero.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error,
report module and the function fails with reason 
<strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>community.conf</strong>.
</p><a name="reconfigure"></a><h4>reconfigure(ConfDir) -&gt; void()</h4><p>Configure the SNMP-COMMUNITY-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>Inserts all data in the configuration files into the
database and destroys all old data, including the rows with
StorageType <strong>nonVolatile</strong>.  The rows created from the
configuration file will have StorageType <strong>nonVolatile</strong>.
</p><p>Thus, the data in the SNMP-COMMUNITY-MIB, after this
function has been called, is from the configuration files.
</p><p>All <strong>snmp</strong> counters are set to zero.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error report 
module, and the function fails with reason 
<strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>community.conf</strong>.</p><a name="add_community"></a><h4>add_community(Idx, CommName, SecName, CtxName, TransportTag) -&gt; Ret</h4><h4>add_community(Idx, CommName, SecName, EngineId, CtxName, TransportTag) -&gt; Ret</h4><p>Added one community</p><ul><li><span class="v">Idx = string()</span></li><li><span class="v">CommName = string()</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">EngineId = string()</span></li><li><span class="v">CtxName = string()</span></li><li><span class="v">TransportTag = string()</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a community to the agent config. 
Equivalent to one line in the <strong>community.conf</strong> file.</p><p>With the <strong>EngineId</strong> argument it is possible to 
override the configured engine-id (SNMP-FRAMEWORK-MIB).</p><a name="delete_community"></a><h4>delete_community(Key) -&gt; Ret</h4><p>Delete one community</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a community from the agent config.</p><h3>snmp_framework_mib</h3><p>Instrumentation Functions for SNMP-FRAMEWORK-MIB</p><p>The module <strong>snmp_framework_mib</strong> implements instrumentation
functions for the
SNMP-FRAMEWORK-MIB, and functions for initializing and configuring the
database.
The configuration files are described in the SNMP User's Manual.</p><h3>Functions</h3><h4>configure(ConfDir) -&gt; void()</h4><p>Configure the SNMP-FRAMEWORK-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>This function is called from the supervisor at system
start-up.
</p><p>Inserts all data in the configuration files into the
database and destroys all old data.
</p><p>Thus, the data in the SNMP-FRAMEWORK-MIB, after this
function has been called, is from the configuration
files.
</p><p>All <strong>snmp</strong> counters are set to zero.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error 
report module, and the function fails with reason 
<strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>context.conf</strong>.
</p><h4>init() -&gt; void()</h4><p>Initialize the SNMP-FRAMEWORK-MIB</p><p>This function is called from the supervisor at system
start-up.
</p><p>Creates the necessary objects in the database if they do not
exist. It does not destroy any old values.
<a name="add_context"></a>
</p><h4>add_context(Ctx) -&gt; Ret</h4><p>Added one context</p><ul><li><span class="v">Ctx = string()</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a context to the agent config. 
Equivalent to one line in the <strong>context.conf</strong> file.</p><a name="delete_context"></a><h4>delete_context(Key) -&gt; Ret</h4><p>Delete one context</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a context from the agent config.</p><h3>snmp_generic</h3><p>Generic Functions for Implementing SNMP Objects in a Database</p><p><a name="description"></a>The module <strong>snmp_generic</strong> contains generic functions for 
implementing tables (and variables) using the SNMP built-in database 
or Mnesia. These default functions are used if no instrumentation 
function is provided for a managed object in a MIB. Sometimes, 
it might be necessary to customize the behaviour of the default 
functions. For example, in some situations a trap should be sent 
if a row is deleted or modified, or some hardware is to be informed, 
when information is changed. The overall structure is shown in the following figure:<pre>
         +---------------+
         |   SNMP Agent  |
         +- - - - - - - -+
         |      MIB      |
         +---------------+
                 |
         Association file       (associates a MIB object with
                 |               snmp_generic:table_funct
                 |               snmp_generic:variable_func)
+--------------------------------------+
|           snmp_generic               |  Support for get-next,
|                                      |  RowStatus operations
+----------------------+---------------+
|    snmpa_local_db    |    Mnesia     |  Database
+--------------+-------+---------------+
|     dets     |  ets  | 
| (persistent) |       | 
+--------------+-------+     </pre>Each function takes the argument <strong>NameDb</strong>, which is a
tuple <strong>{Name, Db}</strong>, to identify which database the
functions should use. <strong>Name</strong> is the symbolic name of the
managed object as defined in the MIB, and <strong>Db</strong> is either
<strong>volatile</strong>, <strong>persistent</strong>, or <strong>mnesia</strong>. If it is
<strong>mnesia</strong>, all variables are stored in the Mnesia table
<strong>snmp_variables</strong> which must be a table with two attributes
(not a Mnesia SNMP table). The SNMP tables are stored in Mnesia
tables with the same names as the SNMP tables.  All functions
assume that a Mnesia table exists with the correct name and
attributes. It is the programmer's responsibility to ensure
this. Specifically, if variables are stored in Mnesia, the table
<strong>snmp_variables</strong> must be created by the programmer.  The
record definition for this table is defined in the file
<strong>snmp/include/snmp_types.hrl</strong>.
If an instrumentation function in the association file for a
variable <strong>myVar</strong> does not have a name when compiling an
MIB, the compiler generates an entry.
<pre>
{myVar, {snmp_generic, variable_func, [{myVar, Db]}}.
    </pre>And for a table:<pre>
{myTable, {snmp_generic, table_func, [{myTable, Db]}}.
    </pre></p><a name="data_types"></a><h4>DATA TYPES</h4><p>In the functions defined below, the following types are used:</p><pre><code class="">
name_db() = {name(), db()} 
name() = atom()
db() = volatile | persistent | mnesia
row_index() = [int()]
columns() = [column()] | [{column(), value()}]
column() = int()
value() = term()
    </code></pre><dl><dt><strong>row_index()</strong></dt><dd> <p>Denotes the last part of the OID which specifies the 
index of the row in the table (see RFC1212, 4.1.6 for 
more information about INDEX).  </p> </dd><dt><strong>columns()</strong></dt><dd> <p>Is a list of column numbers in the case of a <strong>get</strong> 
operation, and a list of column numbers and values in the 
case of a <strong>set</strong> operation. </p> </dd></dl><a name="get_status_col2"></a><h3>Functions</h3><h4>get_status_col(Name, Cols)</h4><h4>get_status_col(NameDb, Cols) -&gt; {ok, StatusVal} | false</h4><p>Get the value of the status column from <strong>Cols</strong></p><ul><li><span class="v">Name = name()</span></li><li><span class="v">NameDb = name_db()</span></li><li><span class="v">Cols = columns()</span></li><li><span class="v">StatusVal = term()</span></li></ul><p>Gets the value of the status column from <strong>Cols</strong>.
</p><p>This function can be used in instrumentation functions for
<strong>is_set_ok</strong>, <strong>undo</strong> or <strong>set</strong> to check if the
status column of a table is modified.</p><a name="get_index_types"></a><h4>get_index_types(Name)</h4><p>Get the index types of <strong>Name</strong></p><ul><li><span class="v">Name = name()</span></li></ul><p>Gets the index types of <strong>Name</strong></p><p>This function can be used in instrumentation functions to
retrieve the index types part of the table info.</p><a name="get_table_info"></a><h4>get_table_info(Name, Item) -&gt; table_info_result()</h4><p>Get table info item of MIB table <strong>Name</strong></p><ul><li><span class="v">Name = name()</span></li><li><span class="v">Item = table_item() | all</span></li><li><span class="v">table_item() = nbr_of_cols | defvals | status_col | not_accessible |  index_types | first_accessible | first_own_index</span></li><li><span class="v">table_info_result() = Value | [{table_item(), Value}]</span></li><li><span class="v">Value = term()</span></li></ul><p>Get a specific table info item or, if <strong>Item</strong> has the
value <strong>all</strong>, a two tuple list (property list) is instead 
returned with all the items and their respctive values of the 
given table. </p><p>This function can be used in instrumentation functions to
retrieve a given part of the table info.</p><a name="table_func"></a><h4>table_func(Op1, NameDb)</h4><h4>table_func(Op2, RowIndex, Cols, NameDb) -&gt; Ret</h4><p>Default instrumentation function for tables</p><ul><li><span class="v">Op1 = new | delete </span></li><li><span class="v">Op2 = get | next | is_set_ok | set | undo</span></li><li><span class="v">NameDb = name_db()</span></li><li><span class="v">RowIndex = row_index()</span></li><li><span class="v">Cols = columns()</span></li><li><span class="v">Ret = term()</span></li></ul><p>This is the default instrumentation function for tables.
</p><ul><li>The <strong>new</strong> function creates the table if it does not exist, but only if the database is the SNMP internal db.</li><li>The <strong>delete</strong> function does not delete the table from the database since unloading an MIB does not necessarily mean that the table should be destroyed.</li><li>The <strong>is_set_ok</strong> function checks that a row which is to be modified or deleted exists, and that a row which is to be created does not exist.</li><li>The <strong>undo</strong> function does nothing.</li><li>The <strong>set</strong> function checks if it has enough information to make the row change its status from <strong>notReady</strong> to <strong>notInService</strong> (when a row has been been set to <strong>createAndWait</strong>). If a row is set to <strong>createAndWait</strong>, columns without a value are set to <strong>noinit</strong>. If Mnesia is used, the set functionality is handled within a transaction.</li></ul><p>If it is possible for a manager to create or delete rows in
the table, there must be a <strong>RowStatus</strong> column for
<strong>is_set_ok</strong>, <strong>set</strong> and <strong>undo</strong> to work properly.
</p><p>The function returns according to the specification of an
instrumentation function.
</p><a name="table_get_elements"></a><h4>table_get_elements(NameDb, RowIndex, Cols) -&gt; Values</h4><p>Get elements in a table row</p><ul><li><span class="v">NameDb = name_db()</span></li><li><span class="v">RowIndex = row_index()</span></li><li><span class="v">Cols = columns()</span></li><li><span class="v">Values = [value() | noinit]</span></li></ul><p>Returns a list with values for all columns in <strong>Cols</strong>.
If a column is undefined, its value is <strong>noinit</strong>.</p><a name="table_next"></a><h4>table_next(NameDb, RestOid) -&gt; RowIndex | endOfTable</h4><p>Find the next row in the table</p><ul><li><span class="v">NameDb = name_db()</span></li><li><span class="v">RestOid = [int()]</span></li><li><span class="v">RowIndex = row_index()</span></li></ul><p>Finds the indices of the next row in the table.  <strong>RestOid</strong>
does not have to specify an existing row.</p><a name="table_row_exists"></a><h4>table_row_exists(NameDb, RowIndex) -&gt; bool()</h4><p>Check if a row in a table exists</p><ul><li><span class="v">NameDb = name_db()</span></li><li><span class="v">RowIndex = row_index()</span></li></ul><p>Checks if a row in a table exists.</p><a name="table_set_elements"></a><h4>table_set_elements(NameDb, RowIndex, Cols) -&gt; bool()</h4><p>Set elements in a table row</p><ul><li><span class="v">NameDb = name_db()</span></li><li><span class="v">RowIndex = row_index()</span></li><li><span class="v">Cols = columns()</span></li></ul><p>Sets the elements in <strong>Cols</strong> to the row specified by
<strong>RowIndex</strong>.  No checks are performed on the new values.
</p><p>If the Mnesia database is used, this function calls
<strong>mnesia:write</strong> to store the values.  This means that
this function must be called from within a transaction
(<strong>mnesia:transaction/1</strong> or <strong>mnesia:dirty/1</strong>).</p><a name="variable_func"></a><h4>variable_func(Op1, NameDb)</h4><h4>variable_func(Op2, Val, NameDb) -&gt; Ret</h4><p>Default instrumentation function for tables</p><ul><li><span class="v">Op1 = new | delete | get</span></li><li><span class="v">Op2 = is_set_ok | set | undo</span></li><li><span class="v">NameDb = name_db()</span></li><li><span class="v">Val = value()</span></li><li><span class="v">Ret = term()</span></li></ul><p>This is the default instrumentation function for variables.</p><p>The <strong>new</strong> function creates a new variable in the
database with a default value as defined in the MIB, or a zero
value (depending on the type).  </p><p>The <strong>delete</strong> function does not delete the variable from 
the database. </p><p>The function returns according to the specification of an 
instrumentation function. </p><a name="variable_get"></a><h4>variable_get(NameDb) -&gt; {value, Value} | undefined</h4><p>Get the value of a variable</p><ul><li><span class="v">NameDb = name_db()</span></li><li><span class="v">Value = value()</span></li></ul><p>Gets the value of a variable.</p><a name="variable_set"></a><h4>variable_set(NameDb, NewVal) -&gt; true | false</h4><p>Set a value for a variable</p><ul><li><span class="v">NameDb = name_db()</span></li><li><span class="v">NewVal = value()</span></li></ul><p>Sets a new value to a variable.  The variable is created if
it does not exist.  No checks are made on the type of the
new value.  </p><p>Returns <strong>false</strong> if the <strong>NameDb</strong> argument
is incorrectly specified, otherwise <strong>true</strong>.</p><a name="example"></a><h4>Example</h4><p>The following example shows an implementation of a table which is
stored in Mnesia, but with some checks performed at set-request
operations.
</p><pre>
myTable_func(new, NameDb) -&gt;   % pass unchanged
  snmp_generic:table_func(new, NameDb).

myTable_func(delete, NameDb) -&gt;   % pass unchanged
  snmp_generic:table_func(delete, NameDb).

%% change row
myTable_func(is_set_ok, RowIndex, Cols, NameDb) -&gt;
  case snmp_generic:table_func(is_set_ok, RowIndex,
                               Cols, NameDb) of
    {noError, 0} -&gt; 
      myApplication:is_set_ok(RowIndex, Cols);
    Err -&gt;
      Err
  end;

myTable_func(set, RowIndex, Cols, NameDb) -&gt;
  case snmp_generic:table_func(set, RowIndex, Cols,
                               NameDb),
    {noError, 0} -&gt;
      % Now the row is updated, tell the application
      myApplication:update(RowIndex, Cols);
    Err -&gt;
      Err
  end;

myTable_func(Op, RowIndex, Cols, NameDb) -&gt;   % pass unchanged
  snmp_generic:table_func(Op, RowIndex, Cols, NameDb).
    </pre><p>The <strong>.funcs</strong> file would look like:
</p><pre>
{myTable, {myModule, myTable_func, [{myTable, mnesia}]}}.
    </pre><h3>snmp_index</h3><p>Abstract Data Type for SNMP Indexing</p><p>The module <strong>snmp_index</strong> implements an Abstract
Data Type (ADT) for an SNMP
index structure for SNMP tables.  It is implemented as an ets
table of the ordered_set data-type, which means that all operations are
O(log n).  In the table, the key is an ASN.1 OBJECT
IDENTIFIER.
This index is used to separate the implementation of the SNMP
ordering from the actual implementation of the table.  The SNMP
ordering, that is implementation of GET NEXT, is implemented in this
module.
For example, suppose there is an SNMP table, which is best
implemented in Erlang as one process per SNMP table row.  Suppose
further that the INDEX in the SNMP table is an OCTET STRING.  The
index structure would be created as follows:
<pre><code class="">
snmp_index:new(string)
    </code></pre>For each new process we create, we insert an item in an
<strong>snmp_index</strong> structure:
<pre><code class="">
new_process(Name, SnmpIndex) -&gt;
  Pid = start_process(),
  NewSnmpIndex = 
    snmp_index:insert(SnmpIndex, Name, Pid),
  &lt;...&gt;
    </code></pre>With this structure, we can now map an OBJECT IDENTIFIER in
e.g. a GET NEXT request, to the correct process:
<pre><code class="">
get_next_pid(Oid, SnmpIndex) -&gt;
  {ok, {_, Pid}} = snmp_index:get_next(SnmpIndex, Oid),
  Pid.
    </code></pre></p><h4>Common data types</h4><p>The following data types are used in the functions below:
</p><ul><li> <p><strong>index()</strong></p> </li><li> <p><strong>oid() = [byte()]</strong></p> </li><li> <p><strong>key_types = type_spec()  |  {type_spec(), type_spec(), ...}</strong></p> </li><li> <p><strong>type_spec() = fix_string | string | integer</strong></p> </li><li> <p><strong>key() = key_spec() | {key_spec(), key_spec(), ...}</strong></p> </li><li> <p><strong>key_spec() = string() | integer()</strong></p> </li></ul><p>The <strong>index()</strong> type denotes an snmp index structure.
</p><p>The <strong>oid()</strong> type is used to represent an ASN.1 OBJECT
IDENTIFIER.
</p><p>The <strong>key_types()</strong> type is used when creating the
index structure, and the <strong>key()</strong> type is used when inserting
and deleting items from the structure.
</p><p>The <strong>key_types()</strong> type defines the types of the SNMP INDEX
columns for the table.  If the table has one single INDEX column,
this type should be a single atom, but if the table has multiple
INDEX columns, it should be a tuple with atoms.
</p><p>If the INDEX column is of type INTEGER, or derived from
INTEGER, the corresponding type should be <strong>integer</strong>.  If it
is a variable length type (e.g. OBJECT IDENTIFIER, OCTET STRING),
the corresponding type should be <strong>string</strong>.  Finally, if the
type is of variable length, but with a fixed size restriction
(e.g. IpAddress), the corresponding type should be
<strong>fix_string</strong>.
</p><p>For example, if the SNMP table has two INDEX columns, the first
one an OCTET STRING with size 2, and the second one an OBJECT
IDENTIFER, the corresponding <strong>key_types</strong> parameter would be
<strong>{fix_string, string}</strong>.
</p><p>The <strong>key()</strong> type correlates to the <strong>key_types()</strong>
type. If the <strong>key_types()</strong> is a single atom, the
corresponding <strong>key()</strong> is a single type as well, but if the
<strong>key_types()</strong> is a tuple, <strong>key</strong> must be a tuple of the
same size.
</p><p>In the example above, valid <strong>keys</strong> could be <strong>{"hi", "mom"}</strong> and <strong>{"no", "thanks"}</strong>, whereas <strong>"hi"</strong>,
<strong>{"hi", 42}</strong> and <strong>{"hello", "there"}</strong> would be invalid.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><a name="1"></a><p>All API functions that update the index return a <strong>NewIndex</strong>
term. This is for backward compatibility with a previous
implementation that used a B+ tree written purely in Erlang for 
the index. The <strong>NewIndex</strong> return value can now be ignored. 
The return value is now the unchanged table identifier for the 
ets table.</p><p>The implementation using ets tables introduces a semantic
incompatibility with older implementations. In those older 
implementations, using pure Erlang terms, the index was garbage 
collected like any other Erlang term and did not have to be 
deleted when discarded. An ets table is deleted only when the 
process creating it explicitly deletes it or when the creating 
process terminates.</p><p>A new interface <strong>delete/1</strong> is now added to
handle the case when a process wants to discard an index table
(i.e. to build a completely new). Any application using
transient snmp indexes has to be modified to handle this.</p><p>As an snmp adaption usually keeps the index for the whole of the
systems lifetime, this is rarely a problem.</p></div><h3>Functions</h3><h4>delete(Index) -&gt; true</h4><p>Delete an index table</p><ul><li><span class="v">Index = NewIndex = index()</span></li><li><span class="v">Key = key()</span></li></ul><p>Deletes a complete index structure (i.e. the ets table
holding the index). The index can no longer be referenced
after this call. See the <a href="#1">warning note</a>
above.</p><h4>delete(Index, Key) -&gt; NewIndex</h4><p>Delete an item from the index</p><ul><li><span class="v">Index = NewIndex = index()</span></li><li><span class="v">Key = key()</span></li></ul><p>Deletes a key and its value from the index structure.
Returns a new structure.</p><h4>get(Index, KeyOid) -&gt; {ok, {KeyOid, Value}} | undefined</h4><p>Get the item with <strong>KeyOid</strong></p><ul><li><span class="v">Index = index()</span></li><li><span class="v">KeyOid = oid()</span></li><li><span class="v">Value = term()</span></li></ul><p>Gets the item with key <strong>KeyOid</strong>.  Could be used from
within an SNMP instrumentation function.</p><h4>get_last(Index) -&gt; {ok, {KeyOid, Value}} | undefined</h4><p>Get the last item in the index structure</p><ul><li><span class="v">Index = index()</span></li><li><span class="v">KeyOid = oid()</span></li><li><span class="v">Value = term()</span></li></ul><p>Gets the last item in the index structure.</p><h4>get_next(Index, KeyOid) -&gt; {ok, {NextKeyOid, Value}} | undefined</h4><p>Get the next item</p><ul><li><span class="v">Index = index()</span></li><li><span class="v">KeyOid = NextKeyOid = oid()</span></li><li><span class="v">Value = term()</span></li></ul><p>Gets the next item in the SNMP lexicographic ordering,
after <strong>KeyOid</strong> in the index structure.  <strong>KeyOid</strong>
does not have to refer to an existing item in the index.</p><h4>insert(Index, Key, Value) -&gt; NewIndex</h4><p>Insert an item into the index</p><ul><li><span class="v">Index = NewIndex = index()</span></li><li><span class="v">Key = key()</span></li><li><span class="v">Value = term()</span></li></ul><p>Inserts a new key value tuple into the index structure.  If
an item with the same key already exists, the new <strong>Value</strong>
overwrites the old value.</p><h4>key_to_oid(Index, Key) -&gt; KeyOid</h4><p>Convert a key to an OBJECT IDENTIFIER</p><ul><li><span class="v">Index = index()</span></li><li><span class="v">Key = key()</span></li><li><span class="v">KeyOid = NextKeyOid = oid()</span></li></ul><p>Converts <strong>Key</strong> to an OBJECT IDENTIFIER.</p><h4>new(KeyTypes) -&gt; Index</h4><p>Create a new snmp index structure</p><ul><li><span class="v">KeyTypes = key_types()</span></li><li><span class="v">Index = index()</span></li></ul><p>Creates a new snmp index structure.  The <strong>key_types()</strong>
type is described above.</p><h3>snmp_notification_mib</h3><p>Instrumentation Functions for SNMP-NOTIFICATION-MIB</p><p>The module <strong>snmp_notification_mib</strong> implements the
instrumentation functions for the
SNMP-NOTIFICATION-MIB, and functions for configuring the database.
The configuration files are described in the SNMP User's Manual.</p><h3>Functions</h3><h4>configure(ConfDir) -&gt; void()</h4><p>Configure the SNMP-NOTIFICATION-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>This function is called from the supervisor at system
start-up.
</p><p>Inserts all data in the configuration files into the
database and destroys all old rows with StorageType
<strong>volatile</strong>.  The rows created from the configuration file
will have StorageType <strong>nonVolatile</strong>.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the 
error report module,
and the function fails with reason <strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>notify.conf</strong>.
</p><h4>reconfigure(ConfDir) -&gt; void()</h4><p>Configure the SNMP-NOTIFICATION-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>Inserts all data in the configuration files into the
database and destroys all old data, including the rows with
StorageType <strong>nonVolatile</strong>.  The rows created from the
configuration file will have StorageType <strong>nonVolatile</strong>.
</p><p>Thus, the data in the SNMP-NOTIFICATION-MIB, after this
function has been called, is from the configuration files.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the 
error report module,
and the function fails with reason <strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>notify.conf</strong>.
<a name="add_notify"></a>
</p><h4>add_notify(Name, Tag, Type) -&gt; Ret</h4><p>Added one notify definition</p><ul><li><span class="v">Name = string()</span></li><li><span class="v">Tag = string()</span></li><li><span class="v">Type = trap | inform</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a notify definition to the agent config. 
Equivalent to one line in the <strong>notify.conf</strong> file.</p><a name="delete_notify"></a><h4>delete_notify(Key) -&gt; Ret</h4><p>Delete one notify definition</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a notify definition from the agent config.</p><h3>snmp_pdus</h3><p>Encode and Decode Functions for SNMP PDUs</p><p>RFC1157, RFC1905 and/or RFC2272 should be studied carefully
before using this module, <strong>snmp_pdus</strong>.
The module <strong>snmp_pdus</strong> contains functions for encoding 
and decoding of
SNMP protocol data units (PDUs).  In short, this module converts a
list of bytes to Erlang record representations and vice versa.
The record definitions can be found in the file
<strong>snmp/include/snmp_types.hrl</strong>.  If snmpv3 is used, the module
that includes <strong>snmp_types.hrl</strong> must define the constant
<strong>SNMP_USE_V3</strong> before the header file is included.  Example:<pre>
-define(SNMP_USE_V3, true).
-include_lib("snmp/include/snmp_types.hrl").    </pre>Encoding and decoding must be done explicitly when writing your
own Net if process.
</p><h3>Functions</h3><h4>dec_message([byte()]) -&gt; Message</h4><p>Decode an SNMP Message</p><ul><li><span class="v">Message = #message</span></li></ul><p>Decodes a list of bytes into an SNMP Message.  Note, if there
is a v3 message, the <strong>msgSecurityParameters</strong> are not
decoded.  They must be explicitly decoded by a call to a
security model specific decoding function,
e.g. <strong>dec_usm_security_parameters/1</strong>.  Also note, if
the <strong>scopedPDU</strong> is encrypted, the OCTET STRING encoded
<strong>encryptedPDU</strong> will be present in the <strong>data</strong> field.</p><h4>dec_message_only([byte()]) -&gt; Message</h4><p>Decode an SNMP Message, but not the data part</p><ul><li><span class="v">Message = #message</span></li></ul><p>Decodes a list of bytes into an SNMP Message, but does not
decode the data part of the Message. That means, data is still
a list of bytes, normally an encoded <strong>PDU</strong> (v1 and V2) or an
encoded and possibly encrypted <strong>scopedPDU</strong> (v3).</p><h4>dec_pdu([byte()]) -&gt; Pdu</h4><p>Decode an SNMP Pdu</p><ul><li><span class="v">Pdu = #pdu</span></li></ul><p>Decodes a list of bytes into an SNMP Pdu.</p><h4>dec_scoped_pdu([byte()]) -&gt; ScopedPdu</h4><p>Decode an SNMP ScopedPdu</p><ul><li><span class="v">ScopedPdu = #scoped_pdu</span></li></ul><p>Decodes a list of bytes into an SNMP ScopedPdu.</p><h4>dec_scoped_pdu_data([byte()]) -&gt; ScopedPduData</h4><p>Decode an SNMP ScopedPduData</p><ul><li><span class="v">ScopedPduData = #scoped_pdu | EncryptedPDU</span></li><li><span class="v">EncryptedPDU = [byte()]</span></li></ul><p>Decodes a list of bytes into either a scoped pdu record, or
- if the scoped pdu was encrypted - to a list of bytes.</p><h4>dec_usm_security_parameters([byte()]) -&gt; UsmSecParams</h4><p>Decode SNMP UsmSecurityParameters</p><ul><li><span class="v">UsmSecParams = #usmSecurityParameters</span></li></ul><p>Decodes a list of bytes into an SNMP UsmSecurityParameters</p><h4>enc_encrypted_scoped_pdu(EncryptedScopedPdu) -&gt; [byte()]</h4><p>Encode an encrypted SNMP scopedPDU</p><ul><li><span class="v">EncryptedScopedPdu = [byte()]</span></li></ul><p>Encodes an encrypted SNMP ScopedPdu into an OCTET STRING
that can be used as the <strong>data</strong> field in a
<strong>message</strong> record, that later can be encoded with a call
to <strong>enc_message_only/1</strong>. 
</p><p>This function should be used whenever the <strong>ScopedPDU</strong>
is encrypted.</p><h4>enc_message(Message) -&gt; [byte()]</h4><p>Encode an SNMP Message</p><ul><li><span class="v">Message = #message</span></li></ul><p>Encodes a message record to a list of bytes.</p><h4>enc_message_only(Message) -&gt; [byte()]</h4><p>Encode an SNMP Message, but not the data part</p><ul><li><span class="v">Message = #message</span></li></ul><p><strong>Message</strong> is a record where the <strong>data</strong> field is
assumed to be encoded (a list of bytes).  If there is a v1 or v2
message, the <strong>data</strong> field is an encoded <strong>PDU</strong>, and if
there is a v3 message, <strong>data</strong> is an encoded and possibly
encrypted <strong>scopedPDU</strong>.</p><h4>enc_pdu(Pd) -&gt; [byte()]</h4><p>Encode an SNMP Pdu</p><ul><li><span class="v">Pdu = #pdu</span></li></ul><p>Encodes an SNMP Pdu into a list of bytes.</p><h4>enc_scoped_pdu(ScopedPdu) -&gt; [byte()]</h4><p>Encode an SNMP scopedPDU</p><ul><li><span class="v">ScopedPdu = #scoped_pdu</span></li></ul><p>Encodes an SNMP ScopedPdu into a list of bytes, which can be
encrypted, and after encryption, encoded with
a call to <strong>enc_encrypted_scoped_pdu/1</strong>; or it can be
used as the <strong>data</strong> field in a <strong>message</strong> record, which
then can be encoded with <strong>enc_message_only/1</strong>.</p><h4>enc_usm_security_parameters(UsmSecParams) -&gt; [byte()]</h4><p>Encode SNMP UsmSecurityParameters</p><ul><li><span class="v">UsmSecParams = #usmSecurityParameters</span></li></ul><p>Encodes SNMP UsmSecurityParameters into a list of bytes.</p><h3>snmp_standard_mib</h3><p>Instrumentation Functions for STANDARD-MIB and SNMPv2-MIB</p><p>The module <strong>snmp_standard_mib</strong> implements the instrumentation functions for the
STANDARD-MIB and SNMPv2-MIB, and functions for configuring the database.
The configuration files are described in the SNMP User's Manual.</p><h3>Functions</h3><h4>configure(ConfDir) -&gt; void()</h4><p>Configure the STANDARD-MIB and SNMPv2-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>This function is called from the supervisor at system
start-up.
</p><p>Inserts all data in the configuration files into the
database and destroys all old rows with StorageType
<strong>volatile</strong>.  The rows created from the configuration file
will have StorageType <strong>nonVolatile</strong>.
</p><p>All <strong>snmp</strong> counters are set to zero.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error 
report module, and the function fails with the reason 
<strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>standard.conf</strong>.
</p><h4>inc(Name) -&gt; void()</h4><h4>inc(Name, N) -&gt; void()</h4><p>Increment a variable in the MIB</p><ul><li><span class="v">Name = atom()</span></li><li><span class="v">N = integer()</span></li></ul><p>Increments a variable in the MIB with <strong>N</strong>, or one if
<strong>N</strong> is not specified.</p><h4>reconfigure(ConfDir) -&gt; void()</h4><p>Configure the STANDARD-MIB and SNMPv2-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>Inserts all data in the configuration files into the
database and destroys all old data, including the rows with
StorageType <strong>nonVolatile</strong>.  The rows created from the
configuration file will have StorageType <strong>nonVolatile</strong>.
</p><p>Thus, the data in the SNMP-STANDARD-MIB and SNMPv2-MIB,
after this function has been called, is from the
configuration files.
</p><p>All <strong>snmp</strong> counters are set to zero.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error
report module, and the function fails with the reason 
<strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>standard.conf</strong>.
</p><h4>reset() -&gt; void()</h4><p>Reset all <strong>snmp</strong>counters to 0</p><p>Resets all <strong>snmp</strong> counters to 0.</p><h4>sys_up_time() -&gt; Time</h4><p>Get the system up time</p><ul><li><span class="v">Time = int()</span></li></ul><p>Gets the system up time in hundredth of a second.</p><h3>snmp_target_mib</h3><p>Instrumentation Functions for SNMP-TARGET-MIB</p><p>The module <strong>snmp_target_mib</strong> implements the instrumentation
functions for the SNMP-TARGET-MIB, 
and functions for configuring the database. The configuration files are described in the SNMP User's Manual.Legacy API functions <strong>add_addr/10</strong> that does not specify
transport domain, and <strong>add_addr/11</strong> that has got separate
<strong>IpAddr</strong> and <strong>PortNumber</strong> arguments still work as before
for backwards compatibility reasons.<a name="types"></a></p><h4>DATA TYPES</h4><p>See the <a href="./snmpa_conf#types"> data types in </a>.</p><a name="configure"></a><h3>Functions</h3><h4>configure(ConfDir) -&gt; void()</h4><p>Configure the SNMP-TARGET-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>This function is called from the supervisor at system
start-up.
</p><p>Inserts all data in the configuration files into the
database and destroys all old rows with StorageType
<strong>volatile</strong>.  The rows created from the configuration file
will have StorageType <strong>nonVolatile</strong>. </p><p>All <strong>snmp</strong> counters are set to zero. </p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error
report module, and the function fails with the reason 
<strong>configuration_error</strong>. </p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found. </p><p>The configuration files read are: <strong>target_addr.conf</strong>
and <strong>target_params.conf</strong>. </p><a name="reconfigure"></a><h4>reconfigure(ConfDir) -&gt; void()</h4><p>Configure the SNMP-TARGET-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>Inserts all data in the configuration files into the
database and destroys all old data, including the rows with
StorageType <strong>nonVolatile</strong>.  The rows created from the
configuration file will have StorageType <strong>nonVolatile</strong>. </p><p>Thus, the data in the SNMP-TARGET-MIB, after this
function has been called, is the data from the configuration
files. </p><p>All <strong>snmp</strong> counters are set to zero.</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the ,
and the function fails with the reason 
<strong>configuration_error</strong>.</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found. </p><p>The configuration files read are: <strong>target_addr.conf</strong>
and <strong>target_params.conf</strong>. </p><a name="set_target_engine_id"></a><h4>set_target_engine_id(TargetAddrName, EngineId) -&gt; boolean()</h4><p>Set the engine id for a targetAddr row.</p><ul><li><span class="v">TargetAddrName = string()</span></li><li><span class="v">EngineId = string()</span></li></ul><p>Changes the engine id for a target in the 
<strong>snmpTargetAddrTable</strong>.
If notifications are sent as Inform requests to a target, its
engine id must be set. </p><a name="add_addr"></a><h4>add_addr(Name, Domain, Addr, Timeout, Retry, TagList, Params, EngineId, TMask, MMS) -&gt; Ret</h4><p>Add one target address definition</p><ul><li><span class="v">Name = string()</span></li><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddress()  % Default port is 162</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">Retry = integer()</span></li><li><span class="v">TagList = string()</span></li><li><span class="v">ParamsName = string()</span></li><li><span class="v">EngineId = string()</span></li><li><span class="v">TMask = transportAddressMask()  % Depends on Domain</span></li><li><span class="v">MMS = integer()</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a target address definition to the agent config. 
Equivalent to one line in the <strong>target_addr.conf</strong> file.</p><a name="delete_addr"></a><h4>delete_addr(Key) -&gt; Ret</h4><p>Delete one target address definition</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a target address definition from the agent config.</p><a name="add_params"></a><h4>add_params(Name, MPModel, SecModel, SecName, SecLevel) -&gt; Ret</h4><p>Add one target parameter definition</p><ul><li><span class="v">Name = string()</span></li><li><span class="v">MPModel = v1 | v2c | v3</span></li><li><span class="v">SecModel = v1 | v2c | usm</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">SecLevel = noAuthNoPriv | authNoPriv | authPriv</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a target parameter definition to the agent config. 
Equivalent to one line in the <strong>target_params.conf</strong> file.</p><a name="delete_params"></a><h4>delete_params(Key) -&gt; Ret</h4><p>Delete one target parameter definition</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a target parameter definition from the agent config.</p><h3>snmp_user_based_sm_mib</h3><p>Instrumentation Functions for SNMP-USER-BASED-SM-MIB</p><p>The module <strong>snmp_user_based_sm_mib</strong> implements the instrumentation 
functions for the SNMP-USER-BASED-SM-MIB, and functions for configuring 
the database.
The configuration files are described in the SNMP User's Manual.</p><h3>Functions</h3><h4>configure(ConfDir) -&gt; void()</h4><p>Configure the SNMP-USER-BASED-SM-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>This function is called from the supervisor at system
start-up.
</p><p>Inserts all data in the configuration files into the
database and destroys all old rows with StorageType
<strong>volatile</strong>.  The rows created from the configuration file
will have StorageType <strong>nonVolatile</strong>.
</p><p>All <strong>snmp</strong> counters are set to zero.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error
report module, and the function fails with the reason 
<strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>usm.conf</strong>.
</p><h4>reconfigure(ConfDir) -&gt; void()</h4><p>Configure the SNMP-USER-BASED-SM-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>Inserts all data in the configuration files into the
database and destroys all old data, including the rows with
StorageType <strong>nonVolatile</strong>.  The rows created from the
configuration file will have StorageType <strong>nonVolatile</strong>.
</p><p>Thus, the data in the SNMP-USER-BASED-SM-MIB, after this
function has been called, is the data from the configuration
files.
</p><p>All <strong>snmp</strong> counters are set to zero.
</p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error
report module, and the function fails with the reason 
<strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>usm.conf</strong>.
<a name="add_user"></a>
</p><h4>add_user(EngineID, Name, SecName, Clone, AuthP, AuthKeyC, OwnAuthKeyC, PrivP, PrivKeyC, OwnPrivKeyC, Public, AuthKey, PrivKey) -&gt; Ret</h4><p>Add one user</p><ul><li><span class="v">EngineID = string()</span></li><li><span class="v">Name = string()</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">Clone = zeroDotZero | [integer()]</span></li><li><span class="v">AuthP = usmNoAuthProtocol | usmHMACMD5AuthProtocol | usmHMACSHAAuthProtocol</span></li><li><span class="v">AuthKeyC = string()</span></li><li><span class="v">OwnAuthKeyC = string()</span></li><li><span class="v">PrivP = usmNoPrivProtocol | usmDESPrivProtocol</span></li><li><span class="v">PrivKeyC = string()</span></li><li><span class="v">OwnPrivKeyC = string()</span></li><li><span class="v">Public = string()</span></li><li><span class="v">AuthKey = string()</span></li><li><span class="v">PrivKey = string()</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a USM security data (user) to the agent config. 
Equivalent to one line in the <strong>usm.conf</strong> file.</p><a name="delete_user"></a><h4>delete_user(Key) -&gt; Ret</h4><p>Delete one user</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a USM security data (user) from the agent config.</p><h3>snmp_view_based_acm_mib</h3><p>Instrumentation Functions for SNMP-VIEW-BASED-ACM-MIB</p><p>The module <strong>snmp_view_based_acm_mib</strong> implements the instrumentation functions for the
SNMP-VIEW-BASED-ACM-MIB, and functions for configuring the database.
The configuration files are described in the SNMP User's Manual.<a name="configure"></a></p><h3>Functions</h3><h4>configure(ConfDir) -&gt; void()</h4><p>Configure the SNMP-VIEW-BASED-ACM-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>This function is called from the supervisor at system
start-up. </p><p>Inserts all data in the configuration files into the
database and destroys all old rows with StorageType
<strong>volatile</strong>.  The rows created from the configuration file
will have StorageType <strong>nonVolatile</strong>. </p><p>All <strong>snmp</strong> counters are set to zero. </p><p>If an error is found in the configuration file, it is
reported using the function <strong>config_err/2</strong> of the error
report module, and the function fails with the reason 
<strong>configuration_error</strong>. </p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found. </p><p>The configuration file read is: <strong>vacm.conf</strong>. </p><a name="reconfigure"></a><h4>reconfigure(ConfDir) -&gt; void()</h4><p>Configure the SNMP-VIEW-BASED-ACM-MIB</p><ul><li><span class="v">ConfDir = string()</span></li></ul><p>Inserts all data in the configuration files into the
database and destroys all old data, including the rows with
StorageType <strong>nonVolatile</strong>.  The rows created from the
configuration file will have StorageType <strong>nonVolatile</strong>.
</p><p>Thus, the data in the SNMP-VIEW-BASED-ACM-MIB, after this
function has been called, is the data from the configuration
files.
</p><p>All <strong>snmp</strong> counters are set to zero.
</p><p>If an error is found in the configuration file, it is
reported using the function 
<a href="./snmpa_error#config_err">config_err/2</a> 
of the error report module, and the function fails with the reason 
<strong>configuration_error</strong>.
</p><p><strong>ConfDir</strong> is a string which points to the directory
where the configuration files are found.
</p><p>The configuration file read is: <strong>vacm.conf</strong>. </p><a name="add_sec2group"></a><h4>add_sec2group(SecModel, SecName, GroupName) -&gt; Ret</h4><p>Add one security to group definition</p><ul><li><span class="v">SecModel = v1 | v2c | usm</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">GroupName = string()</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a security to group definition to the agent config. 
Equivalent to one vacmSecurityToGroup-line in the 
<strong>vacm.conf</strong> file.</p><a name="delete_sec2group"></a><h4>delete_sec2group(Key) -&gt; Ret</h4><p>Delete one security to group definition</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a security to group definition from the agent config.</p><a name="add_access"></a><h4>add_access(GroupName, Prefix, SecModel, SecLevel, Match, RV, WV, NV) -&gt; Ret</h4><p>Add one access definition</p><ul><li><span class="v">GroupName = string()</span></li><li><span class="v">Prefix = string()</span></li><li><span class="v">SecModel = v1 | v2c | usm</span></li><li><span class="v">SecLevel = string()</span></li><li><span class="v">Match = prefix | exact</span></li><li><span class="v">RV = string()</span></li><li><span class="v">WV = string()</span></li><li><span class="v">NV = string()</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a access definition to the agent config. 
Equivalent to one vacmAccess-line in the <strong>vacm.conf</strong> file.</p><a name="delete_access"></a><h4>delete_access(Key) -&gt; Ret</h4><p>Delete one access definition</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a access definition from the agent config.</p><a name="add_view_tree_fam"></a><h4>add_view_tree_fam(ViewIndex, SubTree, Status, Mask) -&gt; Ret</h4><p>Add one view tree family definition</p><ul><li><span class="v">ViewIndex = integer()</span></li><li><span class="v">SubTree = oid()</span></li><li><span class="v">Status = included | excluded</span></li><li><span class="v">Mask = null | [integer()], where all values are either 0 or 1</span></li><li><span class="v">Ret = {ok, Key} | {error, Reason}</span></li><li><span class="v">Key = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Adds a view tree family definition to the agent config. 
Equivalent to one vacmViewTreeFamily-line in the 
<strong>vacm.conf</strong> file.</p><a name="delete_view_tree_fam"></a><h4>delete_view_tree_fam(Key) -&gt; Ret</h4><p>Delete one view tree family definition</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Ret = ok | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Delete a view tree family definition from the agent config.</p><h3>snmpc</h3><p>Interface Functions to the SNMP toolkit MIB compiler</p><p>The module <strong>snmpc</strong> contains interface functions to the 
SNMP toolkit MIB compiler.<a name="compile"></a></p><h3>Functions</h3><h4>compile(File)</h4><h4>compile(File, Options) -&gt; {ok, BinFileName} | {error, Reason}</h4><p>Compile the specified MIB</p><ul><li><span class="v">File = string()</span></li><li><span class="v">Options = [opt()]</span></li><li><span class="v">opt() = db() | relaxed_row_name_assign_check() | deprecated() |  description() | reference() | group_check() |  i() | il() |  imports() | module() | module_identity() | module_compliance() |  agent_capabilities() | outdir() |  no_defs() | verbosity() |  warnings() | warnings_as_errors()</span></li><li><span class="v">db() = {db, volatile|persistent|mnesia}</span></li><li><span class="v">deprecated() = {deprecated, bool()}</span></li><li><span class="v">relaxed_row_name_assign_check() = relaxed_row_name_assign_check</span></li><li><span class="v">description() = description</span></li><li><span class="v">reference() = reference</span></li><li><span class="v">group_check() = {group_check, bool()}</span></li><li><span class="v">i() = {i, [dir()]}</span></li><li><span class="v">il() = {il, [dir()]}</span></li><li><span class="v">imports() = imports</span></li><li><span class="v">module() = {module, atom()}</span></li><li><span class="v">module_identity() = module_identity</span></li><li><span class="v">module_compliance() = module_compliance</span></li><li><span class="v">agent_capabilities() = agent_capabilities</span></li><li><span class="v">no_defs() = no_defs</span></li><li><span class="v">outdir() = {outdir, dir()}</span></li><li><span class="v">verbosity() = {verbosity, silence|warning|info|log|debug|trace}</span></li><li><span class="v">warnings() = {warnings, bool()}</span></li><li><span class="v">warnings_as_errors() = warnings_as_errors</span></li><li><span class="v">dir() = string()</span></li><li><span class="v">BinFileName = string()</span></li></ul><a name="compiler_opts"></a><p>Compiles the specified MIB file <strong>&lt;File&gt;.mib</strong>.  The
compiled file <strong>BinFileName</strong> is called 
<strong>&lt;File&gt;.bin</strong>. </p><ul><li> <p>The option <strong>db</strong> specifies which database should
be used for the default instrumentation. </p> <p>Default is <strong>volatile</strong>. </p> </li><li> <p>The option <strong>deprecated</strong> specifies if a deprecated 
definition should be kept or not. If the option is 
false the MIB compiler will ignore all deprecated
definitions. </p> <p>Default is <strong>true</strong>. </p> </li><li> <p>The option <strong>relaxed_row_name_assign_check</strong>, if present,
specifies that the row name assign check shall not be done 
strictly according to the SMI (which allows only the value 1). 
With this option, all values greater than zero is allowed 
(&gt;= 1). This means that the error will be converted to a 
warning. </p> <p>By default it is not included, but if this option is present 
it will be. </p> </li><li> <p>The option <strong>description</strong> specifies if the text
of the DESCRIPTION field will be included or not. </p> <p>By default it is not included, but if this option is 
present it will be. </p> </li><li> <p>The option <strong>reference</strong> specifies if the text
of the REFERENCE field, when found in a table definition, 
will be included or not. </p> <p>By default it is not included, but if this option is present 
it will be. The reference text will be placed in the allocList 
field of the mib-entry record (#me{}) for the table. </p> </li><li> <p>The option <strong>group_check</strong> specifies whether the
mib compiler should check the OBJECT-GROUP macro and
the NOTIFICATION-GROUP macro for correctness or not.  </p> <p>Default is <strong>true</strong>. </p> </li><li> <p>The option <strong>i</strong> specifies the path to search for
imported (compiled) MIB files. The directories should be
strings with a trailing directory delimiter. </p> <p>Default is <strong>["./"]</strong>. </p> </li><li> <p>The option <strong>il</strong> (include_lib) also specifies a
list of directories to search for imported MIBs. It
assumes that the first element in the directory name
corresponds to an OTP application. The compiler will find
the current installed version. For example, the value
["snmp/mibs/"] will be replaced by ["snmp-3.1.1/mibs/"]
(or what the current version may be in the system). The
current directory and the 
<strong>&lt;snmp-home&gt;/priv/mibs/</strong>
are always listed last in the include path. </p> </li><li> <p>The option <strong>imports</strong>, if present, specifies that 
the IMPORT statement of the MIB shall be included in the 
compiled mib. </p> </li><li> <p>The option <strong>module</strong>, if present, specifies the
name of a module which implements all instrumentation
functions for the MIB.  </p> <p>The name of all instrumentation
functions must be the same as the corresponding managed
object it implements. </p> </li><li> <p>The option <strong>module_identity</strong>, if present, specifies 
that the info part of the MODULE-IDENTITY statement of the MIB 
shall be included in the compiled mib. </p> </li><li> <p>The option <strong>module_compliance</strong>, if present, specifies 
that the MODULE-COMPLIANCE statement of the MIB shall be included 
(with a mib-entry record) in the compiled mib. The mib-entry record 
of the module-compliance will contain <strong>reference</strong> and <strong>module</strong> 
part(s) this info in the <strong>assocList</strong> field). </p> </li><li> <p>The option <strong>agent_capabilities</strong>, if present, specifies 
that the AGENT-CAPABILITIES statement of the MIB shall be included 
(with a mib-entry record) in the compiled mib. The mib-entry record 
of the agent-capabilitie will contain <strong>reference</strong> and <strong>modules</strong> 
part(s) this info in the <strong>assocList</strong> field). </p> </li><li> <p>The option <strong>no_defs</strong>, if present, specifies 
that if a managed object does not have an instrumentation
function, the default instrumentation function should NOT
be used, instead this is reported as an error, and the
compilation aborts. </p> </li><li> <p>The option <strong>verbosity</strong> specifies the verbosity of
the SNMP mib compiler. I.e. if warning, info, log, debug 
and trace messages shall be shown. </p> <p>Default is <strong>silence</strong>. </p> <p>Note that if the option <strong>warnings</strong> is <strong>true</strong> and the 
option <strong>verbosity</strong> is <strong>silence</strong>, warning messages will
still be shown. </p> </li><li> <p>The option <strong>warnings</strong> specifies whether warning
messages should be shown. </p> <p>Default is <strong>true</strong>. </p> </li><li> <p>The option <strong>warnings_as_errors</strong>, if present, specifies 
whether warnings should be treated as errors.</p> </li></ul><p>The MIB compiler understands both SMIv1 and SMIv2 MIBs.  It
uses the <strong>MODULE-IDENTITY</strong> statement to determine if the MIB is
version 1 or 2.
</p><p>The MIB compiler can be invoked from the OS command line by
using the command <strong>erlc</strong>.  <strong>erlc</strong> recognizes the
extension <strong>.mib</strong>, and invokes the SNMP MIB compiler for
files with that extension. The options <strong>db</strong>, 
<strong>group_check</strong>, <strong>deprecated</strong>, <strong>description</strong>,
<strong>verbosity</strong>, <strong>imports</strong> and <strong>module_identity</strong>
have to be specified to <strong>erlc</strong> using the syntax 
<strong>+term</strong>.  See <strong>erlc(1)</strong> for details.
</p><a name="is_consistent"></a><h4>is_consistent(Mibs) -&gt; ok | {error, Reason}</h4><p>Check for OID conflicts between MIBs</p><ul><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = string()</span></li></ul><p>Checks for multiple usage of object identifiers and traps
between MIBs.
</p><a name="mib_to_hrl"></a><h4>mib_to_hrl(MibName) -&gt; ok | {error, Reason}</h4><p>Generate constants for the objects in the MIB</p><ul><li><span class="v">MibName = string()</span></li></ul><p>Generates a <strong>.hrl</strong> file with definitions of Erlang
constants for the objects in the MIB. The <strong>.hrl</strong> file is
called <strong>&lt;MibName&gt;.hrl</strong>. The MIB must be compiled, and
present in the current directory.
</p><p>The <strong>mib_to_hrl</strong> generator can be invoked from the OS
command line by using the command <strong>erlc</strong>.  <strong>erlc</strong>
recognizes the extension <strong>.bin</strong>, and invokes this function
for files with that extension.
</p><h4>See Also</h4><p>erlc(1)
</p><h3>snmpc(command)</h3><p>SNMP MIB compiler frontend</p><p>The <strong>snmpc</strong> program provides a way to run
the SNMP MIB compiler of the Erlang system. </p><h3>Functions</h3><h4>snmpc [options] file.mib | file.bin</h4><p>Compile MIBs</p><p><strong>snmpc</strong> compile a SNMP MIB file, 
see <a href="./snmpc#compile">compile/1,2</a> for 
more info. </p><p>It can also be used to generate a header file (.hrl) 
with definitions of Erlang constants for the objects in 
the MIB, see 
<a href="./snmpc#mib_to_hrl">mib_to_hrl/1</a>. </p><a name="options"></a><h4>Compiler options</h4><p>The following options are supported (note that most of these relate 
to the compilation of the MIB file):</p><a name="option_help"></a><dl><dt>--help</dt><dd> <p>Prints help info.</p> <a name="option_version"></a> </dd><dt>--version</dt><dd> <p>Prints application and mib format version.</p> <a name="option_verbosity"></a> </dd><dt>--verbosity <em>verbosity</em></dt><dd> <p>Print debug info. </p> <p><strong>verbosity</strong> = <strong>trace</strong> | <strong>debug</strong> | <strong>log</strong> | <strong>info</strong> | <strong>silence</strong></p> <p>Defaults to <strong>silence</strong>.</p> <a name="option_w"></a> <a name="option_warnings"></a> </dd><dt>--warnings | --W</dt><dd> <p>Print warning messages. </p> <a name="option_wae"></a> <a name="option_werror"></a> </dd><dt>--wae | --Werror</dt><dd> <p>Warnings as errors. 
Indicates that warnings shall be treated as errors. </p> <a name="option_odir"></a> </dd><dt>--o <em>directory</em></dt><dd> <p>The directory where the compiler should place the output files.
If not specified, output files will be placed in the current working
directory.</p> <a name="option_idir"></a> </dd><dt>--i <em>Directory</em></dt><dd> <p>Specifies the path to search for imported (compiled) MIB files. 
By default, the current working directory is always included. </p> <p>This option can be present several times, each time specifying
<em>one</em> path. </p> <a name="option_ildir"></a> </dd><dt>--il <em>Directory</em></dt><dd> <p>This option (include_lib), specifies a list of directories to 
search for imported MIBs. It assumes that the first element in 
the directory name corresponds to an OTP application. The compiler 
will find the current installed version. For example, the value 
["snmp/mibs/"] will be replaced by ["snmp-3.1.1/mibs/"] (or what 
the current version may be in the system). The current directory 
and the "snmp-home"/priv/mibs/ are always listed last in the
include path. </p> <a name="option_sgc"></a> </dd><dt>--sgc</dt><dd> <p>This option (skip group check), if present, disables the 
group check of the mib compiler. 
That is, should the OBJECT-GROUP and the NOTIFICATION-GROUP 
macro(s) be checked for correctness or not. </p> <a name="option_dep"></a> </dd><dt>--dep</dt><dd> <p>Keep deprecated definition(s). 
If not specified the compiler will ignore deprecated definitions. </p> <a name="option_desc"></a> </dd><dt>--desc</dt><dd> <p>The DESCRIPTION field will be included. </p> <a name="option_ref"></a> </dd><dt>--ref</dt><dd> <p>The REFERENCE field will be included. </p> <a name="option_imp"></a> </dd><dt>--imp</dt><dd> <p>The IMPORTS field will be included. </p> <a name="option_mi"></a> </dd><dt>--mi</dt><dd> <p>The MODULE-IDENTITY field will be included. </p> <a name="option_mc"></a> </dd><dt>--mc</dt><dd> <p>The MODULE-COMPLIANCE field will be included. </p> <a name="option_ac"></a> </dd><dt>--ac</dt><dd> <p>The AGENT-CAPABILITIES field will be included. </p> <a name="option_mod"></a> </dd><dt>--mod <em>module</em></dt><dd> <p>The module which implements all the instrumentation functions. </p> <p>The name of all instrumentation functions must be the 
same as the corresponding managed object it implements. </p> <a name="option_nd"></a> </dd><dt>--nd</dt><dd> <p>The default instrumentation functions will <em>not</em> be
used if a managed object have no instrumentation function.
Instead this will be reported as an error, and the compilation 
aborts. </p> <a name="option_rrnac"></a> </dd><dt>--rrnac</dt><dd> <p>This option, if present, specifies that the row name assign check 
shall not be done strictly according to the SMI (which allows only 
the value 1). </p> <p>With this option, all values greater than zero is allowed (&gt;= 1). 
This means that the error will be converted to a warning. </p> <p>By default it is not included, but if this option is present 
it will be. </p> <a name="see_also"></a> </dd></dl><h4>SEE ALSO</h4><p><a href="./erlc">erlc(1)</a>,
<a href="./compile">compile(3)</a>,
<a href="./snmpc">snmpc(3)</a></p><h3>snmpm</h3><p>Interface functions to the SNMP toolkit manager</p><p>The module <strong>snmpm</strong> contains interface functions to the 
SNMP manager. </p><h4>Common Data Types</h4><p>The following data types are used in the functions below:</p><pre><code class="">
oid() = [byte()]  -  The oid() type is used to represent an ASN.1 OBJECT IDENTIFIER
snmp_reply() = {error_status(), error_index(), varbinds()}
error_status() = noError | atom()
error_index() = integer()
varbinds() = [varbind()]
atl_type() = read | write | read_write
target_name() = string()  -  Is a unique *non-empty* string
vars_and_vals() = [var_and_val()]
var_and_val() = {oid(), value_type(), value()} | {oid(), value()}
value_type() = o ('OBJECT IDENTIFIER') | 
               i ('INTEGER') | 
               u ('Unsigned32') | 
               g ('Unsigned32') | 
               s ('OCTET SRING') | 
               b ('BITS') | 
               ip ('IpAddress') | 
               op ('Opaque') | 
               c32 ('Counter32') | 
               c64 ('Counter64') | 
               tt ('TimeTicks')
value() = term()
community() = string()
sec_model() = any | v1 | v2c | usm
sec_name() = string()
sec_level() = noAuthNoPriv | authNoPriv | authPriv
</code></pre><p>See also the <a href="./snmpa_conf#types"> data types in </a>.</p><a name="monitor"></a><h3>Functions</h3><h4>monitor() -&gt; Ref</h4><p>Monitor the snmp manager</p><ul><li><span class="v">Ref = reference()</span></li></ul><p>Monitor the SNMP manager. In case of a crash, the calling 
(monitoring) process will get a 'DOWN' message (see the erlang 
module for more info). </p><a name="demonitor"></a><h4>demonitor(Ref) -&gt; void()</h4><p>Turn off monitoring of the snmp manager</p><ul><li><span class="v">Ref = reference()</span></li></ul><p>Turn off monitoring of the SNMP manager. </p><a name="notify_started"></a><h4>notify_started(Timeout) -&gt; Pid</h4><p>Request to be notified when manager started</p><ul><li><span class="v">Timeout = integer()</span></li><li><span class="v">Pid = pid()</span></li></ul><p>Request a notification (message) when the SNMP manager has 
started. </p><p>The <strong>Timeout</strong> is the time the request is valid. The 
value has to be greater then zero. </p><p>The <strong>Pid</strong> is the process handling the supervision of the 
SNMP manager start. When the manager has started a completion
message will be sent to the client from this process: 
<strong>{snmpm_started, Pid}</strong>. If the SNMP manager was not started 
in time, a timeout message will be sent to the client: 
<strong>{snmpm_start_timeout, Pid}</strong>. </p><p>A client application that is dependent on the SNMP manager 
will use this function in order to be notified of when the
manager has started. There are two situations when this 
is useful:</p><ul><li> <p>During the start of a system, when a client application 
<em>could</em> start prior to the SNMP manager but is dependent
upon it, and therefor has to wait for it to start.</p> </li><li> <p>When the SNMP manager has crashed, the dependent client 
application has to wait for the SNMP manager to be restarted
before it can <em>reconnect</em>.</p> </li></ul><p>The function returns the pid() of a handler process, that does
the supervision on behalf of the client application. Note that the 
client application is linked to this handler. </p><p>This function is used in conjunction with the monitor function.</p><a name="cancel_notify_started"></a><h4>cancel_notify_started(Pid) -&gt; void()</h4><p>Cancel request to be notified when manager started</p><ul><li><span class="v">Pid = pid()</span></li></ul><p>Cancel a previous request to be notified of SNMP manager start.</p><a name="register_user"></a><h4>register_user(Id, Module, Data) -&gt; ok | {error, Reason}</h4><h4>register_user(Id, Module, Data, DefaultAgentConfig) -&gt; ok | {error, Reason}</h4><p>Register a user of the manager</p><ul><li><span class="v">Id = term()</span></li><li><span class="v">Module = snmpm_user()</span></li><li><span class="v">Data = term()</span></li><li><span class="v">DefaultAgentConfig = [default_agent_config()]</span></li><li><span class="v">default_agent_config() = {Item, Val}</span></li><li><span class="v">Item = community | timeout | max_message_size | version | sec_model | sec_name | sec_level</span></li><li><span class="v">Val = term()</span></li><li><span class="v">Reason = term()</span></li><li><span class="v">snmpm_user() = Module implementing the snmpm_user behaviour</span></li></ul><p>Register the manager entity (=user) responsible for specific 
agent(s). </p><p><strong>Module</strong> is the callback module (snmpm_user behaviour) which 
will be called whenever something happens (detected 
agent, incoming reply or incoming trap/notification).
Note that this could have already been done as a 
consequence of the node config. (see users.conf).</p><p>The argument <strong>DefaultAgentConfig</strong> is used as default 
values when this user register agents.</p><p>The type of <strong>Val</strong> depends on <strong>Item</strong>: </p><pre><code class="">
community = string()
timeout = integer() | snmp_timer()
max_message_size = integer()
version = v1 | v2 | v3 
sec_model = any | v1 | v2c | usm 
sec_name = string() 
sec_level = noAuthNoPriv | authNoPriv | authPriv
        </code></pre><a name="register_user_monitor"></a><h4>register_user_monitor(Id, Module, Data) -&gt; ok | {error, Reason}</h4><h4>register_user_monitor(Id, Module, Data, DefaultAgentConfig) -&gt; ok | {error, Reason}</h4><p>Register a monitored user of the manager</p><ul><li><span class="v">Id = term()</span></li><li><span class="v">Module = snmpm_user()</span></li><li><span class="v">DefaultAgentConfig = [default_agent_config()]</span></li><li><span class="v">default_agent_config() = {Item, Val}</span></li><li><span class="v">Item = community | timeout | max_message_size | version | sec_model | sec_name | sec_level</span></li><li><span class="v">Val = term()</span></li><li><span class="v">Data = term()</span></li><li><span class="v">Reason = term()</span></li><li><span class="v">snmpm_user() = Module implementing the snmpm_user behaviour</span></li></ul><p>Register the monitored manager entity (=user) responsible 
for specific agent(s). </p><p>The process performing the registration will be monitored. 
Which means that if that process should die, all agents 
registered by that user process will be unregistered. All 
outstanding requests will be canceled. </p><p><strong>Module</strong> is the callback module (snmpm_user behaviour) which 
will be called whenever something happens (detected 
agent, incoming reply or incoming trap/notification).
Note that this could have already been done as a 
consequence of the node config. (see users.conf).</p><p>The argument <strong>DefaultAgentConfig</strong> is used as default values when 
this user register agents.</p><p>The type of <strong>Val</strong> depends on <strong>Item</strong>: </p><pre><code class="">
community = string()
timeout = integer() | snmp_timer()
max_message_size = integer()
version = v1 | v2 | v3 
sec_model = any | v1 | v2c | usm 
sec_name = string() 
sec_level = noAuthNoPriv | authNoPriv | authPriv
        </code></pre><a name="unregister_user"></a><h4>unregister_user(Id) -&gt; ok | {error, Reason}</h4><p>Unregister the user</p><ul><li><span class="v">Id = term()</span></li></ul><p>Unregister the user.</p><a name="which_users"></a><h4>which_users() -&gt; Users</h4><p>Get a list of all users</p><ul><li><span class="v">Users = [UserId]</span></li><li><span class="v">UserId = term()</span></li></ul><p>Get a list of the identities of all registered users.</p><a name="register_agent"></a><h4>register_agent(UserId, TargetName, Config) -&gt; ok | {error, Reason}</h4><p>Register this agent</p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">Config = [agent_config()]</span></li><li><span class="v">agent_config() = {Item, Val}</span></li><li><span class="v">Item = engine_id | address | port | community | timeout | max_message_size | version | sec_model | sec_name | sec_level | tdomain</span></li><li><span class="v">Val = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Explicitly instruct the manager to handle this agent, with
<strong>UserId</strong> as the responsible user. </p><p>Called to instruct the manager that this agent shall be handled. 
This function is used when the user knows in advance which agents 
the manager shall handle.
Note that there is an alternate way to do the same thing:
Add the agent to the manager config files (see 
<a href="./snmp_manager_config_files#agents">agents.conf</a>).</p><p><strong>TargetName</strong> is a non-empty string, 
uniquely identifying the agent. </p><p>The type of <strong>Val</strong> depends on <strong>Item</strong>: </p><pre><code class="">
[mandatory] engine_id = string()
[mandatory] tadress = transportAddress()  % Depends on tdomain
[optional]  port = inet:port_number()
[optional]  tdomain = transportDomain()
[optional]  community = string()
[optional]  timeout = integer() | snmp_timer()
[optional]  max_message_size = integer()
[optional]  version = v1 | v2 | v3 
[optional]  sec_model = any | v1 | v2c | usm 
[optional]  sec_name = string() 
[optional]  sec_level = noAuthNoPriv | authNoPriv | authPriv
</code></pre><p>Note that if no <strong>tdomain</strong> is given, the default value,
<strong>transportDomainUdpIpv4</strong>, is used.</p><p>Note that if no <strong>port</strong> is given and if <strong>taddress</strong> does not
contain a port number, the default value is used.</p><a name="unregister_agent"></a><h4>unregister_agent(UserId, TargetName) -&gt; ok | {error, Reason}</h4><p>Unregister the user</p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li></ul><p>Unregister the agent.</p><a name="agent_info"></a><h4>agent_info(TargetName, Item) -&gt; {ok, Val} | {error, Reason}</h4><p>Retrieve agent config</p><ul><li><span class="v">TargetName = target_name()</span></li><li><span class="v">Item = atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retrieve agent config.</p><a name="update_agent_info"></a><h4>update_agent_info(UserId, TargetName, Info) -&gt; ok | {error, Reason}</h4><h4>update_agent_info(UserId, TargetName, Item, Val) -&gt; ok | {error, Reason}</h4><p>Update agent config</p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">Info = [{item(), item_value()}]</span></li><li><span class="v">Item = item()</span></li><li><span class="v">item() = atom()</span></li><li><span class="v">Val = item_value()</span></li><li><span class="v">item_value() = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Update agent config. The function <strong>update_agent_info/3</strong> 
should be used when several values needs to be updated atomically. </p><p>See function 
<a href="#register_agent">register_agent</a>
for more info about what kind of items are allowed. </p><a name="which_agents"></a><h4>which_agents() -&gt; Agents</h4><h4>which_agents(UserId) -&gt; Agents</h4><p>List the registered agents</p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">Agents = [TargetName]</span></li><li><span class="v">TargetName = target_name()</span></li></ul><p>Get a list of all registered agents or all agents registered
by a specific user.</p><a name="register_usm_user"></a><h4>register_usm_user(EngineID, UserName, Conf) -&gt; ok | {error, Reason}</h4><p>Register this USM user</p><ul><li><span class="v">EngineID = string()</span></li><li><span class="v">UserName = string()</span></li><li><span class="v">Conf = [usm_config()]</span></li><li><span class="v">usm_config() = {Item, Val}</span></li><li><span class="v">Item = sec_name | auth | auth_key | priv | priv_key</span></li><li><span class="v">Val = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Explicitly instruct the manager to handle this USM user.
Note that there is an alternate way to do the same thing:
Add the usm user to the manager config files (see 
<a href="./snmp_manager_config_files#usm_user">usm.conf</a>).</p><p>The type of <strong>Val</strong> depends on <strong>Item</strong>: </p><pre><code class="">
sec_name = string()
auth = usmNoAuthProtocol | usmHMACMD5AuthProtocol | usmHMACSHAAuthProtocoltimeout
auth_key = [integer()]   (length 16 if auth = usmHMACMD5AuthProtocol, 
                          length 20 if auth = usmHMACSHAAuthProtocol)
priv = usmNoPrivProtocol | usmDESPrivProtocol | usmAesCfb128Protocol
priv_key = [integer()]   (length is 16 if priv = usmDESPrivProtocol | usmAesCfb128Protocol).
</code></pre><a name="unregister_usm_user"></a><h4>unregister_usm_user(EngineID, UserName) -&gt; ok | {error, Reason}</h4><p>Unregister this USM user</p><ul><li><span class="v">EngineID = string()</span></li><li><span class="v">UserName = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Unregister this USM user.</p><a name="which_usm_users1"></a><h4>usm_user_info(EngineID, UserName, Item) -&gt; {ok, Val} | {error, Reason}</h4><p>Retrieve usm user config</p><ul><li><span class="v">EngineID = string()</span></li><li><span class="v">UsmName = string()</span></li><li><span class="v">Item = sec_name | auth | auth_key | priv | priv_key</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retrieve usm user config.</p><a name="update_usm_user_info"></a><h4>update_usm_user_info(EngineID, UserName, Item, Val) -&gt; ok | {error, Reason}</h4><p>Update agent config</p><ul><li><span class="v">EngineID = string()</span></li><li><span class="v">UsmName = string()</span></li><li><span class="v">Item = sec_name | auth | auth_key | priv | priv_key</span></li><li><span class="v">Val = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Update usm user config.</p><a name="which_usm_users"></a><h4>which_usm_users() -&gt; UsmUsers</h4><p>List all the registered usm users</p><ul><li><span class="v">UsmUsers = [{EngineID,UserName}]</span></li><li><span class="v">EngineID = string()</span></li><li><span class="v">UsmName = string()</span></li></ul><p>Get a list of all registered usm users.</p><a name="which_usm_users2"></a><h4>which_usm_users(EngineID) -&gt; UsmUsers</h4><p>List the registered usm users</p><ul><li><span class="v">UsmUsers = [UserName]</span></li><li><span class="v">UserName = string()</span></li></ul><p>Get a list of all registered usm users with engine-id 
<strong>EngineID</strong>.</p><a name="sync_get2"></a><h4>sync_get2(UserId, TargetName, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_get2(UserId, TargetName, Oids, SendOpts) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><p>Synchronous <strong>get-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">SendOpts = send_opts()</span></li><li><span class="v">send_opts() = [send_opt()]</span></li><li><span class="v">send_opt() = {context, string()} | {timeout, pos_integer()} | {extra, term()} | {community, community()} | {sec_model, sec_model()} | {sec_name, string()} | {sec_level, sec_level()} | {max_message_size, pos_integer()}</span></li><li><span class="v">SnmpReply = snmp_reply()</span></li><li><span class="v">Remaining = integer()</span></li><li><span class="v">Reason = {send_failed, ReqId, ActualReason} | {invalid_sec_info, SecInfo, SnmpInfo} | term()</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">ActualReason = term()</span></li><li><span class="v">SecInfo = [sec_info()]</span></li><li><span class="v">sec_info() = {sec_tag(), ExpectedValue, ReceivedValue}</span></li><li><span class="v">sec_tag() = atom()</span></li><li><span class="v">ExpectedValue = ReceivedValue = term()</span></li><li><span class="v">SnmpInfo = term()</span></li></ul><p>Synchronous <strong>get-request</strong>. </p><p><strong>Remaining</strong> is the remaining time of the given (or default) 
timeout time.</p><p>When <em>Reason</em> is <em>{send_failed, ...}</em> it means that
the net_if process failed to send the message. This could happen
because of any number of reasons, i.e. encoding error. 
<em>ActualReason</em> is the actual reason in this case. </p><p>The send option <strong>extra</strong> specifies an opaque data structure 
passed on to the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a option (when using the built in 
net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><p>Some of the send options (<strong>community</strong>, <strong>sec_model</strong>, 
<strong>sec_name</strong>, <strong>sec_level</strong> and <strong>max_message_size</strong>) 
are <strong>override options</strong>. That is,
for <em>this</em> request, they override any configuration done 
when the agent was registered. </p><p>For <strong>SnmpInfo</strong>, see the user callback function 
<a href="./snmpm_user#handle_report">handle_report</a>.</p><a name="sync_get"></a><h4>sync_get(UserId, TargetName, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_get(UserId, TargetName, ContextName, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_get(UserId, TargetName, Oids, Timeout) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_get(UserId, TargetName, ContextName, Oids, Timeout) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_get(UserId, TargetName, ContextName, Oids, Timeout, ExtraInfo) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><p>Synchronous <strong>get-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">ContextName = string()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">SnmpReply = snmp_reply()</span></li><li><span class="v">Remaining = integer()</span></li><li><span class="v">Reason = {send_failed, ReqId, R} | {invalid_sec_info, SecInfo, SnmpInfo} | term()</span></li><li><span class="v">R = term()</span></li><li><span class="v">SecInfo = [sec_info()]</span></li><li><span class="v">sec_info() = {sec_tag(), ExpectedValue, ReceivedValue}</span></li><li><span class="v">sec_tag() = atom()</span></li><li><span class="v">ExpectedValue = ReceivedValue = term()</span></li><li><span class="v">SnmpInfo = term()</span></li></ul><p>Synchronous <strong>get-request</strong>. </p><p><strong>Remaining</strong> is the remaining time of the given or 
default timeout time.</p><p>When <em>Reason</em> is <em>{send_failed, ...}</em> it means that
the net_if process failed to send the message. This could happen
because of any number of reasons, i.e. encoding error. <em>R</em> 
is the actual reason in this case. </p><p><strong>ExtraInfo</strong> is an opaque data structure passed on to
the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a configuration (when using the 
built in net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><p>For <strong>SnmpInfo</strong>, see the user callback function 
<a href="./snmpm_user#handle_report">handle_report</a>.</p><a name="async_get2"></a><h4>async_get2(UserId, TargetName, Oids) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_get2(UserId, TargetName, Oids, SendOpts) -&gt; {ok, ReqId} | {error, Reason}</h4><p>Asynchronous <strong>get-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">SendOpts = send_opts()</span></li><li><span class="v">send_opts() = [send_opt()]</span></li><li><span class="v">send_opt() = {context, string()} | {timeout, pos_integer()} | {extra, term()} | {community, community()} | {sec_model, sec_model()} | {sec_name, string()} | {sec_level, sec_level()} | {max_message_size, pos_integer()}</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Asynchronous <strong>get-request</strong>.</p><p>The reply, if it arrives, will be delivered to the user 
through a call to the snmpm_user callback function 
<strong>handle_pdu</strong>.</p><p>The send option <strong>timeout</strong> specifies for how long the request is 
valid (after which the manager is free to delete it).</p><p>The send option <strong>extra</strong> specifies an opaque data structure 
passed on to the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a option (when using the built in 
net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><p>Some of the send options (<strong>community</strong>, <strong>sec_model</strong>, 
<strong>sec_name</strong>, <strong>sec_level</strong> and <strong>max_message_size</strong>) 
are <strong>override options</strong>. That is,
for <em>this</em> request, they override any configuration done 
when the agent was registered. </p><a name="async_get"></a><h4>async_get(UserId, TargetName, Oids) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_get(UserId, TargetName, ContextName, Oids) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_get(UserId, TargetName, Oids, Expire) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_get(UserId, TargetName, ContextName, Oids, Expire) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_get(UserId, TargetName, ContextName, Oids, Expire, ExtraInfo) -&gt; {ok, ReqId} | {error, Reason}</h4><p>Asynchronous <strong>get-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">ContextName = string()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">Expire = integer()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Asynchronous <strong>get-request</strong>.</p><p>The reply, if it arrives, will be delivered to the user 
through a call to the snmpm_user callback function 
<strong>handle_pdu</strong>.</p><p>The <strong>Expire</strong> time indicates for how long the request is 
valid (after which the manager is free to delete it).</p><p><strong>ExtraInfo</strong> is an opaque data structure passed on to
the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a configuration (when using the 
built in net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><a name="sync_get_next2"></a><h4>sync_get_next2(UserId, TargetName, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_get_next2(UserId, TargetName, Oids, SendOpts) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><p>Synchronous <strong>get-next-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">SendOpts = send_opts()</span></li><li><span class="v">send_opts() = [send_opt()]</span></li><li><span class="v">send_opt() = {context, string()} | {timeout, pos_integer()} | {extra, term()} | {community, community()} | {sec_model, sec_model()} | {sec_name, string()} | {sec_level, sec_level()} | {max_message_size, pos_integer()}</span></li><li><span class="v">SnmpReply = snmp_reply()</span></li><li><span class="v">Remaining = integer()</span></li><li><span class="v">Reason = {send_failed, ReqId, ActualReason} | {invalid_sec_info, SecInfo, SnmpInfo} | term()</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">ActualReason = term()</span></li><li><span class="v">SecInfo = [sec_info()]</span></li><li><span class="v">sec_info() = {sec_tag(), ExpectedValue, ReceivedValue}</span></li><li><span class="v">sec_tag() = atom()</span></li><li><span class="v">ExpectedValue = ReceivedValue = term()</span></li><li><span class="v">SnmpInfo = term()</span></li></ul><p>Synchronous <strong>get-next-request</strong>. </p><p><strong>Remaining</strong> is the remaining time of the given (or default) 
timeout time.</p><p>When <em>Reason</em> is <em>{send_failed, ...}</em> it means that
the net_if process failed to send the message. This could happen
because of any number of reasons, i.e. encoding error. 
<em>ActualReason</em> is the actual reason in this case. </p><p>The send option <strong>extra</strong> specifies an opaque data structure 
passed on to the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a option (when using the built in 
net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><p>Some of the send options (<strong>community</strong>, <strong>sec_model</strong>, 
<strong>sec_name</strong>, <strong>sec_level</strong> and <strong>max_message_size</strong>) 
are <strong>override options</strong>. That is,
for <em>this</em> request, they override any configuration done 
when the agent was registered. </p><p>For <strong>SnmpInfo</strong>, see the user callback function 
<a href="./snmpm_user#handle_report">handle_report</a>.</p><a name="sync_get_next"></a><h4>sync_get_next(UserId, TargetName, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_get_next(UserId, TargetName, ContextName, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_get_next(UserId, TargetName, Oids, Timeout) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_get_next(UserId, TargetName, ContextName, Oids, Timeout) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_get_next(UserId, TargetName, ContextName, Oids, Timeout, ExtraInfo) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><p>Synchronous <strong>get-next-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">ContextName = string()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">SnmpReply = snmp_reply()</span></li><li><span class="v">Remaining = integer()</span></li><li><span class="v">Reason = {send_failed, ReqId, R} | {invalid_sec_info, SecInfo, SnmpInfo} | term()</span></li><li><span class="v">R = term()</span></li></ul><p>Synchronous <strong>get-next-request</strong>. </p><p><strong>Remaining</strong> time of the given or default timeout time.</p><p>When <em>Reason</em> is <em>{send_failed, ...}</em> it means that
the net_if process failed to send the message. This could happen
because of any number of reasons, i.e. encoding error. <em>R</em> 
is the actual reason in this case. </p><p><strong>ExtraInfo</strong> is an opaque data structure passed on to
the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a configuration (when using the 
built in net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><a name="async_get_next2"></a><h4>async_get_next2(UserId, TargetName, Oids) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_get_next2(UserId, TargetName, Oids, SendOpts) -&gt; {ok, ReqId} | {error, Reason}</h4><p>Asynchronous <strong>get-next-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">send_opt() = {context, string()} | {timeout, pos_integer()} | {extra, term()} | {community, community()} | {sec_model, sec_model()} | {sec_name, string()} | {sec_level, sec_level()} | {max_message_size, pos_integer()}</span></li><li><span class="v">ReqId = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Asynchronous <strong>get-next-request</strong>. </p><p>The reply will be delivered to the user through a call
to the snmpm_user callback function <strong>handle_pdu</strong>.</p><p>The send option <strong>timeout</strong> specifies for how long the request is 
valid (after which the manager is free to delete it).</p><p>The send option <strong>extra</strong> specifies an opaque data structure 
passed on to the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a option (when using the built in 
net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><p>Some of the send options (<strong>community</strong>, <strong>sec_model</strong>, 
<strong>sec_name</strong>, <strong>sec_level</strong> and <strong>max_message_size</strong>) 
are <strong>override options</strong>. That is,
for <em>this</em> request, they override any configuration done 
when the agent was registered. </p><a name="async_get_next"></a><h4>async_get_next(UserId, TargetName, Oids) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_get_next(UserId, TargetName, ContextName, Oids) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_get_next(UserId, TargetName, Oids, Expire) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_get_next(UserId, TargetName, ContextName, Oids, Expire) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_get_next(UserId, TargetName, ContextName, Oids, Expire, ExtraInfo) -&gt; {ok, ReqId} | {error, Reason}</h4><p>Asynchronous <strong>get-next-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">ContextName = string()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">Expire = integer()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">ReqId = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Asynchronous <strong>get-next-request</strong>. </p><p>The reply will be delivered to the user through a call
to the snmpm_user callback function <strong>handle_pdu</strong>.</p><p>The <strong>Expire</strong> time indicates for how long the request is 
valid (after which the manager is free to delete it).</p><p><strong>ExtraInfo</strong> is an opaque data structure passed on to
the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a configuration (when using the 
built in net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><a name="sync_set2"></a><h4>sync_set2(UserId, TargetName, VarsAndVals) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_set2(UserId, TargetName, VarsAndVals, SendOpts) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><p>Synchronous <strong>set-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">VarsAndVals = vars_and_vals()</span></li><li><span class="v">SendOpts = send_opts()</span></li><li><span class="v">send_opts() = [send_opt()]</span></li><li><span class="v">send_opt() = {context, string()} | {timeout, pos_integer()} | {extra, term()} | {community, community()} | {sec_model, sec_model()} | {sec_name, string()} | {sec_level, sec_level()} | {max_message_size, pos_integer()}</span></li><li><span class="v">SnmpReply = snmp_reply()</span></li><li><span class="v">Remaining = integer()</span></li><li><span class="v">Reason = {send_failed, ReqId, ActualReason} | {invalid_sec_info, SecInfo, SnmpInfo} | term()</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">ActualReason = term()</span></li><li><span class="v">SecInfo = [sec_info()]</span></li><li><span class="v">sec_info() = {sec_tag(), ExpectedValue, ReceivedValue}</span></li><li><span class="v">sec_tag() = atom()</span></li><li><span class="v">ExpectedValue = ReceivedValue = term()</span></li><li><span class="v">SnmpInfo = term()</span></li></ul><p>Synchronous <strong>set-request</strong>. </p><p><strong>Remaining</strong> is the remaining time of the given (or default) 
timeout time.</p><p>When <em>Reason</em> is <em>{send_failed, ...}</em> it means that
the net_if process failed to send the message. This could happen
because of any number of reasons, i.e. encoding error. 
<em>ActualReason</em> is the actual reason in this case. </p><p>When <em>var_and_val()</em> is <em>{oid(), value()}</em>, the
manager makes an educated guess based on the loaded mibs. </p><p>The send option <strong>extra</strong> specifies an opaque data structure 
passed on to the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a option (when using the built in 
net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><p>Some of the send options (<strong>community</strong>, <strong>sec_model</strong>, 
<strong>sec_name</strong>, <strong>sec_level</strong> and <strong>max_message_size</strong>) 
are <strong>override options</strong>. That is,
for <em>this</em> request, they override any configuration done 
when the agent was registered. </p><p>For <strong>SnmpInfo</strong>, see the user callback function 
<a href="./snmpm_user#handle_report">handle_report</a>.</p><a name="sync_set"></a><h4>sync_set(UserId, TargetName, VarsAndVals) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_set(UserId, TargetName, ContextName, VarsAndVals) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_set(UserId, TargetName, VarsAndVals, Timeout) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_set(UserId, TargetName, ContextName, VarsAndVals, Timeout) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_set(UserId, TargetName, ContextName, VarsAndVals, Timeout, ExtraInfo) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><p>Synchronous <strong>set-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">ContextName = string()</span></li><li><span class="v">VarsAndVals = vars_and_vals()</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">SnmpReply = snmp_reply()</span></li><li><span class="v">Remaining = integer()</span></li><li><span class="v">Reason = {send_failed, ReqId, ActualReason} | {invalid_sec_info, SecInfo, SnmpInfo} | term()</span></li><li><span class="v">ActualReason = term()</span></li></ul><p>Synchronous <strong>set-request</strong>. </p><p><strong>Remaining</strong> time of the given or default timeout time.</p><p>When <em>Reason</em> is <em>{send_failed, ...}</em> it means that
the net_if process failed to send the message. This could happen
because of any number of reasons, i.e. encoding error. <em>R</em> 
is the actual reason in this case. </p><p>When <em>var_and_val()</em> is <em>{oid(), value()}</em>, the
manager makes an educated guess based on the loaded mibs. </p><p><strong>ExtraInfo</strong> is an opaque data structure passed on to
the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a configuration (when using the 
built in net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><a name="async_set2"></a><h4>async_set2(UserId, TargetName, VarsAndVals) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_set2(UserId, TargetName, VarsAndVals, SendOpts) -&gt; {ok, ReqId} | {error, Reason}</h4><p>Asynchronous <strong>set-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">VarsAndVals = vars_and_vals()</span></li><li><span class="v">SendOpts = send_opts()</span></li><li><span class="v">send_opts() = [send_opt()]</span></li><li><span class="v">send_opt() = {context, string()} | {timeout, pos_integer()} | {extra, term()} | {community, community()} | {sec_model, sec_model()} | {sec_name, string()} | {sec_level, sec_level()} | {max_message_size, pos_integer()}</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Asynchronous <strong>set-request</strong>. </p><p>The reply will be delivered to the user through a call
to the snmpm_user callback function <strong>handle_pdu</strong>.</p><p>The send option <strong>timeout</strong> specifies for how long the request is 
valid (after which the manager is free to delete it).</p><p>When <em>var_and_val()</em> is <em>{oid(), value()}</em>, the
manager makes an educated guess based on the loaded mibs. </p><p>The send option <strong>extra</strong> specifies an opaque data structure 
passed on to the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a option (when using the built in 
net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><p>Some of the send options (<strong>community</strong>, <strong>sec_model</strong>, 
<strong>sec_name</strong>, <strong>sec_level</strong> and <strong>max_message_size</strong>) 
are <strong>override options</strong>. That is,
for <em>this</em> request, they override any configuration done 
when the agent was registered. </p><a name="async_set"></a><h4>async_set(UserId, TargetName, VarsAndVals) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_set(UserId, TargetName, ContextName, VarsAndVals) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_set(UserId, TargetName, VarsAndVals, Expire) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_set(UserId, TargetName, ContextName, VarsAndVals, Expire) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_set(UserId, TargetName, ContextName, VarsAndVals, Expire, ExtraInfo) -&gt; {ok, ReqId} | {error, Reason}</h4><p>Asynchronous <strong>set-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">VarsAndVals = vars_and_vals()</span></li><li><span class="v">Expire = integer()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Asynchronous <strong>set-request</strong>. </p><p>The reply will be delivered to the user through a call
to the snmpm_user callback function <strong>handle_pdu</strong>.</p><p>The <strong>Expire</strong> time indicates for how long the request is 
valid (after which the manager is free to delete it).</p><p>When <em>var_and_val()</em> is <em>{oid(), value()}</em>, the
manager makes an educated guess based on the loaded mibs. </p><p><strong>ExtraInfo</strong> is an opaque data structure passed on to
the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a configuration (when using the 
built in net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><a name="sync_get_bulk2"></a><h4>sync_get_bulk2(UserId, TragetName, NonRep, MaxRep, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_get_bulk2(UserId, TragetName, NonRep, MaxRep, Oids, SendOpts) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><p>Synchronous <strong>get-bulk-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">NonRep = integer()</span></li><li><span class="v">MaxRep = integer()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">SendOpts = send_opts()</span></li><li><span class="v">send_opts() = [send_opt()]</span></li><li><span class="v">send_opt() = {context, string()} | {timeout, pos_integer()} | {extra, term()} | {community, community()} | {sec_model, sec_model()} | {sec_name, string()} | {sec_level, sec_level()} | {max_message_size, pos_integer()}</span></li><li><span class="v">SnmpReply = snmp_reply()</span></li><li><span class="v">Remaining = integer()</span></li><li><span class="v">Reason = {send_failed, ReqId, ActualReason} | {invalid_sec_info, SecInfo, SnmpInfo} | term()</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">ActualReason = term()</span></li><li><span class="v">SecInfo = [sec_info()]</span></li><li><span class="v">sec_info() = {sec_tag(), ExpectedValue, ReceivedValue}</span></li><li><span class="v">sec_tag() = atom()</span></li><li><span class="v">ExpectedValue = ReceivedValue = term()</span></li><li><span class="v">SnmpInfo = term()</span></li></ul><p>Synchronous <strong>get-bulk-request</strong> (See RFC1905).</p><p><strong>Remaining</strong> is the remaining time of the given (or default) 
timeout time.</p><p>When <em>Reason</em> is <em>{send_failed, ...}</em> it means that
the net_if process failed to send the message. This could happen
because of any number of reasons, i.e. encoding error. 
<em>ActualReason</em> is the actual reason in this case. </p><p>The send option <strong>extra</strong> specifies an opaque data structure 
passed on to the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a option (when using the built in 
net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><p>Some of the send options (<strong>community</strong>, <strong>sec_model</strong>, 
<strong>sec_name</strong>, <strong>sec_level</strong> and <strong>max_message_size</strong>) 
are <strong>override options</strong>. That is,
for <em>this</em> request, they override any configuration done 
when the agent was registered. </p><p>For <strong>SnmpInfo</strong>, see the user callback function 
<a href="./snmpm_user#handle_report">handle_report</a>.</p><a name="sync_get_bulk"></a><h4>sync_get_bulk(UserId, TragetName, NonRep, MaxRep, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_get_bulk(UserId, TragetName, NonRep, MaxRep, ContextName, Oids) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_get_bulk(UserId, TragetName, NonRep, MaxRep, Oids, Timeout) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_get_bulk(UserId, TragetName, NonRep, MaxRep, ContextName, Oids, Timeout) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><h4>sync_get_bulk(UserId, TragetName, NonRep, MaxRep, ContextName, Oids, Timeout, ExtraInfo) -&gt; {ok, SnmpReply, Remaining} | {error, Reason}</h4><p>Synchronous <strong>get-bulk-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">NonRep = integer()</span></li><li><span class="v">MaxRep = integer()</span></li><li><span class="v">ContextName = string()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">SnmpReply = snmp_reply()</span></li><li><span class="v">Remaining = integer()</span></li><li><span class="v">Reason = {send_failed, ReqId, R} | {invalid_sec_info, SecInfo, SnmpInfo} | term()</span></li></ul><p>Synchronous <strong>get-bulk-request</strong> (See RFC1905).</p><p><strong>Remaining</strong> time of the given or default timeout time.</p><p>When <em>Reason</em> is <em>{send_failed, ...}</em> it means that
the net_if process failed to send the message. This could happen
because of any number of reasons, i.e. encoding error. <em>R</em> 
is the actual reason in this case. </p><p><strong>ExtraInfo</strong> is an opaque data structure passed on to
the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a configuration (when using the 
built in net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><a name="async_get_bulk2"></a><h4>async_get_bulk2(UserId, TargetName, NonRep, MaxRep, Oids) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_get_bulk2(UserId, TargetName, NonRep, MaxRep, Oids, SendOpts) -&gt; {ok, ReqId} | {error, Reason}</h4><p>Asynchronous <strong>get-bulk-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">NonRep = integer()</span></li><li><span class="v">MaxRep = integer()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">SendOpts = send_opts()</span></li><li><span class="v">send_opts() = [send_opt()]</span></li><li><span class="v">send_opt() = {context, string()} | {timeout, pos_integer()} | {extra, term()} | {community, community()} | {sec_model, sec_model()} | {sec_name, string()} | {sec_level, sec_level()} | {max_message_size, pos_integer()}</span></li><li><span class="v">ReqId = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Asynchronous <strong>get-bulk-request</strong> (See RFC1905).</p><p>The reply will be delivered to the user through a call
to the snmpm_user callback function <strong>handle_pdu</strong>.</p><p>The send option <strong>timeout</strong> specifies for how long the request is 
valid (after which the manager is free to delete it).</p><p>The send option <strong>extra</strong> specifies an opaque data structure 
passed on to the net-if process. The net-if process included in this
application makes no use of this info, so the only use for it
in such a configuration (when using the built in net-if) would
be tracing.</p><p>Some of the send options (<strong>community</strong>, <strong>sec_model</strong>, 
<strong>sec_name</strong>, <strong>sec_level</strong> and <strong>max_message_size</strong>) 
are <strong>override options</strong>. That is,
for <em>this</em> request, they override any configuration done 
when the agent was registered. </p><a name="async_get_bulk"></a><h4>async_get_bulk(UserId, TargetName, NonRep, MaxRep, Oids) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_get_bulk(UserId, TargetName, NonRep, MaxRep, ContextName, Oids) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_get_bulk(UserId, TargetName, NonRep, MaxRep, Oids, Expire) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_get_bulk(UserId, TargetName, NonRep, MaxRep, ContextName, Oids, Expire) -&gt; {ok, ReqId} | {error, Reason}</h4><h4>async_get_bulk(UserId, TargetName, NonRep, MaxRep, ContextName, Oids, Expire, ExtraInfo) -&gt; {ok, ReqId} | {error, Reason}</h4><p>Asynchronous <strong>get-bulk-request</strong></p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">NonRep = integer()</span></li><li><span class="v">MaxRep = integer()</span></li><li><span class="v">ContextName = string()</span></li><li><span class="v">Oids = [oid()]</span></li><li><span class="v">Expire = integer()</span></li><li><span class="v">ExtraInfo = term()</span></li><li><span class="v">ReqId = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Asynchronous <strong>get-bulk-request</strong> (See RFC1905).</p><p>The reply will be delivered to the user through a call
to the snmpm_user callback function <strong>handle_pdu</strong>.</p><p>The <strong>Expire</strong> time indicates for how long the request is 
valid (after which the manager is free to delete it).</p><p><strong>ExtraInfo</strong> is an opaque data structure passed on to
the net-if process. The net-if process included in this
application makes, with one exception, no use of this info, 
so the only use for it in such a configuration (when using the 
built in net-if) would be tracing. The one usage exception is: 
<em>Any</em> tuple with <strong>snmpm_extra_info_tag</strong> as its first 
element is reserved for internal use. </p><a name="cancel_async_request"></a><h4>cancel_async_request(UserId, ReqId) -&gt; ok | {error, Reason}</h4><p>Cancel a asynchronous request</p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Cancel a previous asynchronous request.</p><a name="log_to_txt"></a><h4>log_to_txt(LogDir)</h4><h4>log_to_txt(LogDir, Block | Mibs)</h4><h4>log_to_txt(LogDir, Mibs, Block | OutFile) -&gt; ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_txt(LogDir, Mibs, OutFile, Block | LogName) -&gt;  ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_txt(LogDir, Mibs, OutFile, LogName, Block | LogFile) -&gt;  ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block | Start) -&gt;  ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start)  -&gt; ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Start, Stop)  -&gt; ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start, Stop)  -&gt; ok | {ok, Cnt} | {error, Reason}</h4><p>Convert an Audit Trail Log to text format</p><ul><li><span class="v">LogDir = string()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Block = boolean()</span></li><li><span class="v">OutFile = string()</span></li><li><span class="v">LogName = string()</span></li><li><span class="v">LogFile = string()</span></li><li><span class="v">Start = Stop = null | calendar:datetime() | {local_time, calendar:datetime()} | {universal_time, calendar:datetime()} </span></li><li><span class="v">Cnt = {NumOK, NumERR}</span></li><li><span class="v">NumOK = non_neg_integer()</span></li><li><span class="v">NumERR = pos_integer()</span></li><li><span class="v">Reason = disk_log_open_error() | file_open_error() | term()</span></li><li><span class="v">disk_log_open_error() = {LogName, term()}</span></li><li><span class="v">file_open_error() = {OutFile, term()}</span></li></ul><p>Converts an Audit Trail Log to a readable text file. 
<strong>OutFile</strong> defaults to "./snmpm_log.txt". 
<strong>LogName</strong> defaults to "snmpm_log". 
<strong>LogFile</strong> defaults to "snmpm.log".</p><p>The <strong>Block</strong> argument indicates if the log should be blocked
during conversion. This could be usefull when converting large 
logs (when otherwise the log could wrap during conversion). 
Defaults to <strong>true</strong>. </p><p>See <a href="./snmp#log_to_txt">snmp:log_to_txt</a> 
for more info.</p><a name="log_to_io"></a><h4>log_to_io(LogDir) -&gt; ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_io(LogDir, Block | Mibs) -&gt; ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_io(LogDir, Mibs) -&gt; ok | {error, Reason}</h4><h4>log_to_io(LogDir, Mibs, Block | LogName) -&gt;  ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_io(LogDir, Mibs, LogName, Block | LogFile) -&gt;  ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_io(LogDir, Mibs, LogName, LogFile, Block | Start) -&gt;  ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start)  -&gt; ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_io(LogDir, Mibs, LogName, LogFile, Start, Stop)  -&gt; ok | {ok, Cnt} | {error, Reason}</h4><h4>log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start, Stop)  -&gt; ok | {ok, Cnt} | {error, Reason}</h4><p>Convert an Audit Trail Log to text format</p><ul><li><span class="v">LogDir = string()</span></li><li><span class="v">Mibs = [MibName]</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Block = boolean()</span></li><li><span class="v">LogName = string()</span></li><li><span class="v">LogFile = string()</span></li><li><span class="v">Start = Stop = null | calendar:datetime() | {local_time, calendar:datetime()} | {universal_time, calendar:datetime()} </span></li><li><span class="v">Cnt = {NumOK, NumERR}</span></li><li><span class="v">NumOK = non_neg_integer()</span></li><li><span class="v">NumERR = pos_integer()</span></li><li><span class="v">Reason = disk_log_open_error() | file_open_error() | term()</span></li><li><span class="v">disk_log_open_error() = {LogName, term()}</span></li><li><span class="v">file_open_error() = {OutFile, term()}</span></li></ul><p>Converts an Audit Trail Log to a readable format and 
prints it on stdio. 
<strong>LogName</strong> defaults to "snmpm_log". 
<strong>LogFile</strong> defaults to "snmpm.log".</p><p>The <strong>Block</strong> argument indicates if the log should be blocked
during conversion. This could be usefull when converting large 
logs (when otherwise the log could wrap during conversion). 
Defaults to <strong>true</strong>. </p><p>See <a href="./snmp#log_to_io">snmp:log_to_io</a> 
for more info.</p><a name="change_log_size"></a><h4>change_log_size(NewSize) -&gt; ok | {error, Reason}</h4><p>Change the size of the Audit Trail Log</p><ul><li><span class="v">NewSize = {MaxBytes, MaxFiles}</span></li><li><span class="v">MaxBytes = integer()</span></li><li><span class="v">MaxFiles = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Changes the log size of the Audit Trail Log. The application must 
be configured to use the audit trail log function. Please refer to 
disk_log(3) in Kernel Reference Manual for a description of how to 
change the log size.
</p><p>The change is permanent, as long as the log is not deleted. 
That means, the log size is remembered across reboots.</p><a name="set_log_type"></a><h4>set_log_type(NewType) -&gt; {ok, OldType} | {error, Reason}</h4><p>Change the Audit Trail Log type</p><ul><li><span class="v">NewType = OldType = atl_type()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Changes the run-time Audit Trail log type. </p><p>Note that this has no effect on the application configuration as
defined by configuration files, so a node restart will revert the 
config to whatever is in those files. </p><p>This function is primarily useful in testing/debugging 
scenarios. </p><a name="load_mib"></a><h4>load_mib(Mib) -&gt; ok | {error, Reason}</h4><p>Load a MIB into the manager</p><ul><li><span class="v">Mib = MibName</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Load a <strong>Mib</strong> into the manager. The <strong>MibName</strong> is the 
name of the Mib, including the path to where the compiled mib is 
found.  For example,</p><pre><code class="">
          Dir = code:priv_dir(my_app) ++ "/mibs/",
          snmpm:load_mib(Dir ++ "MY-MIB").
        </code></pre><a name="unload_mib"></a><h4>unload_mib(Mib) -&gt; ok | {error, Reason}</h4><p>Unload a MIB from the manager</p><ul><li><span class="v">Mib = MibName</span></li><li><span class="v">MibName = string()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Unload a <strong>Mib</strong> from the manager. The <strong>MibName</strong> is the 
name of the Mib, including the path to where the compiled mib is 
found.  For example,</p><pre><code class="">
          Dir = code:priv_dir(my_app) ++ "/mibs/",
          snmpm:unload_mib(Dir ++ "MY-MIB").
        </code></pre><a name="which_mibs"></a><h4>which_mibs() -&gt; Mibs</h4><p>Which mibs are loaded into the manager</p><ul><li><span class="v">Mibs = [{MibName, MibFile}]</span></li><li><span class="v">MibName = atom()</span></li><li><span class="v">MibFile = string()</span></li></ul><p>Get a list of all the mib's loaded into the manager.</p><a name="name_to_oid"></a><h4>name_to_oid(Name) -&gt; {ok, Oids} | {error, Reason}</h4><p>Get all the possible oid's for an alias-name</p><ul><li><span class="v">Name = atom()</span></li><li><span class="v">Oids = [oid()]</span></li></ul><p>Transform a alias-name to its oid.</p><p>Note that an alias-name is only unique within the mib, so
when loading several mib's into a manager, there might be
several instances of the same aliasname.</p><a name="oid_to_name"></a><h4>oid_to_name(Oid) -&gt; {ok, Name} | {error, Reason}</h4><p>Get the alias-name of the oid </p><ul><li><span class="v">Oid = oid()</span></li><li><span class="v">Name = atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Transform a oid to its aliasname.</p><a name="oid_to_type"></a><h4>oid_to_type(Oid) -&gt; {ok, Type} | {error, Reason}</h4><p>Get the type of the the oid</p><ul><li><span class="v">Oid = oid()</span></li><li><span class="v">Type = atom()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retreive the type (asn1 bertype) of an oid.</p><a name="backup"></a><h4>backup(BackupDir) -&gt; ok | {error, Reason}</h4><p>Backup manager data</p><ul><li><span class="v">BackupDir = string()</span></li></ul><p>Backup persistent data handled by the manager. </p><p>BackupDir cannot be identical to DbDir. </p><a name="info"></a><h4>info() -&gt; [{Key, Value}]</h4><p>Return information about the manager</p><ul><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li></ul><p>Returns a list (a dictionary) containing information about
the manager. Information includes statistics counters, 
miscellaneous info about each process (e.g. memory allocation), 
and so on.</p><a name="verbosity"></a><h4>verbosity(Ref, Verbosity) -&gt; void()</h4><p>Assign a new verbosity for the process</p><ul><li><span class="v">Ref = server | config | net_if | note_store | all</span></li><li><span class="v">Verbosity = verbosity()</span></li><li><span class="v">verbosity() = silence | info | log | debug | trace </span></li></ul><p>Sets verbosity for the designated process. For the lowest 
verbosity <strong>silence</strong>, nothing is printed. The higher the
verbosity, the more is printed.</p><a name="format_reason"></a><h4>format_reason(Reason) -&gt; string()</h4><h4>format_reason(Prefix, Reason) -&gt; string()</h4><p>Assign a new verbosity for the process</p><ul><li><span class="v">Reason = term()</span></li><li><span class="v">Prefix = integer() | string()</span></li></ul><p>This utility function is used to create a formatted 
(pretty printable) string of the error reason received
from either:
</p><ul><li> <p>The <strong>Reason</strong> returned value if any of the 
sync/async get/get-next/set/get-bulk
functions returns <strong>{error, Reason}</strong></p> </li><li> <p>The <strong>Reason</strong> parameter in the 
<a href="./snmpm_user#handle_error">handle_error</a> user callback function.</p> </li></ul><p><strong>Prefix</strong> should either be an indention string
(e.g. a list of spaces) or a positive integer (which will be used
to create the indention string of that length).</p><h3>snmpm_conf</h3><p>Utility functions for handling the manager config files.</p><p>The module <strong>snmpm_conf</strong> contains various utility functions to 
used for manipulating (write/append/read) the config files of the
SNMP manager. <a name="manager_entry"></a></p><h3>Functions</h3><h4>manager_entry(Tag, Val) -&gt; manager_entry()</h4><p>Create an manager entry</p><ul><li><span class="v">Tag = address | port | engine_id | max_message_size</span></li><li><span class="v">Val = term()</span></li><li><span class="v">manager_entry() = term()</span></li></ul><p>Create an entry for the manager config file, 
<strong>manager.conf</strong>. </p><p>The type of <strong>Val</strong> depends on the value of <strong>Tag</strong>, 
see 
<a href="./snmp_manager_config_files#manager_information">Manager Information</a> 
for more info. </p><a name="write_manager_config"></a><h4>write_manager_config(Dir, Conf) -&gt; ok</h4><h4>write_manager_config(Dir, Hdr, Conf) -&gt; ok</h4><p>Write the manager config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [manager_entry()]</span></li></ul><p>Write the manager config to the manager config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_manager_config_files#manager_information">Manager Information</a> 
for more info. </p><a name="append_manager_config"></a><h4>append_manager_config(Dir, Conf) -&gt; ok</h4><p>Append the manager config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [manager_entry()]</span></li></ul><p>Append the config to the current manager config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_manager_config_files#manager_information">Manager Information</a> 
for more info. </p><a name="read_manager_config"></a><h4>read_manager_config(Dir) -&gt; Conf</h4><p>Read the manager config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [manager_entry()]</span></li></ul><p>Read the current manager config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_manager_config_files#manager_information">Manager Information</a> 
for more info. </p><a name="users_entry"></a><h4>users_entry(UserId) -&gt; users_entry()</h4><h4>users_entry(UserId, UserMod) -&gt; users_entry()</h4><h4>users_entry(UserId, UserMod, UserData) -&gt; users_entry()</h4><p>Create an users entry</p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">UserMod = atom()</span></li><li><span class="v">UserData = term()</span></li><li><span class="v">standard_entry() = term()</span></li></ul><p>Create an entry for the manager users config file, 
<strong>users.conf</strong>. </p><p><strong>users_entry(UserId)</strong> translates to the following call:
<strong>users_entry(UserId, snmpm_user_default)</strong>. </p><p><strong>users_entry(UserId, UserMod)</strong> translates to the following 
call: <strong>users_entry(UserId, UserMod, undefined)</strong>. </p><p>See 
<a href="./snmp_manager_config_files#users">Users</a> 
for more info. </p><a name="write_users_config"></a><h4>write_users_config(Dir, Conf) -&gt; ok</h4><h4>write_users_config(Dir, Hdr, Conf) -&gt; ok</h4><p>Write the manager users config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [users_entry()]</span></li></ul><p>Write the manager users config to the manager users 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_manager_config_files#users">Users</a> 
for more info. </p><a name="append_users_config"></a><h4>append_users_config(Dir, Conf) -&gt; ok</h4><p>Append the manager users config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [users_entry()]</span></li></ul><p>Append the users config to the current manager users  
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_manager_config_files#users">Users</a> 
for more info. </p><a name="read_users_config"></a><h4>read_users_config(Dir) -&gt; Conf</h4><p>Read the manager users config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [users_entry()]</span></li></ul><p>Read the current manager users config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_manager_config_files#users">Users</a> 
for more info. </p><a name="agents_entry"></a><h4>agents_entry(UserId, TargetName, Comm, Domain, Addr, EngineID, Timeout, MaxMessageSize, Version, SecModel, SecName, SecLevel) -&gt; agents_entry()</h4><p>Create an agents entry</p><ul><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = string()</span></li><li><span class="v">Comm = string()</span></li><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddress()</span></li><li><span class="v">EngineID = string()</span></li><li><span class="v">Timeout = integer()</span></li><li><span class="v">MaxMessageSize = integer()</span></li><li><span class="v">Version = v1 | v2 | v3</span></li><li><span class="v">SecModel = v1 | v2c | usm</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">SecLevel = noAuthNoPriv | authNoPriv | authPriv</span></li><li><span class="v">agents_entry() = term()</span></li></ul><p>Create an entry for the manager agents config file, 
<strong>agents.conf</strong>. </p><p>See 
<a href="./snmp_manager_config_files#agents">Agents</a> 
for more info. </p><a name="write_agents_config"></a><h4>write_agents_config(Dir, Conf) -&gt; ok</h4><h4>write_agents_config(Dir, Hdr, Conf) -&gt; ok</h4><p>Write the manager agents to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [_entry()]</span></li></ul><p>Write the manager agents config to the manager agents 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_manager_config_files#agents">Agents</a> 
for more info. </p><a name="append_agents_config"></a><h4>append_agents_config(Dir, Conf) -&gt; ok</h4><p>Append the manager agents to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [agents_entry()]</span></li></ul><p>Append the agents config to the current manager agents 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_manager_config_files#agents">Agents</a> 
for more info. </p><a name="read_agents_config"></a><h4>read_agents_config(Dir) -&gt; Conf</h4><p>Read the manager agents config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [agents_entry()]</span></li></ul><p>Read the current manager agents config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_manager_config_files#agents">Agents</a> 
for more info. </p><a name="usm_entry"></a><h4>usm_entry(EngineID, UserName, AuthP, AuthKey, PrivP, PrivKey) -&gt; usm_entry()</h4><h4>usm_entry(EngineID, UserName, SecName, AuthP, AuthKey, PrivP, PrivKey) -&gt; usm_entry()</h4><p>Create an usm entry</p><ul><li><span class="v">EngineID = string()</span></li><li><span class="v">UserName = string()</span></li><li><span class="v">SecName = string()</span></li><li><span class="v">AuthP = usmNoAuthProtocol | usmHMACMD5AuthProtocol | usmHMACSHAAuthProtocol</span></li><li><span class="v">AuthKey = [integer()]</span></li><li><span class="v">PrivP = usmNoPrivProtocol | usmDESPrivProtocol | usmAesCfb128Protocol</span></li><li><span class="v">PrivKey = [integer()]</span></li><li><span class="v">usm_entry() = term()</span></li></ul><p>Create an entry for the agent community config file, 
<strong>community.conf</strong>. </p><p>See 
<a href="./snmp_manager_config_files#usm">Security data for USM</a> 
for more info. </p><a name="write_usm_config"></a><h4>write_usm_config(Dir, Conf) -&gt; ok</h4><h4>write_usm_config(Dir, Hdr, Conf) -&gt; ok</h4><p>Write the manager usm config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Hdr = string()</span></li><li><span class="v">Conf = [usm_entry()]</span></li></ul><p>Write the manager usm config to the manager usm 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p><strong>Hdr</strong> is an optional file header (note that this text is
written to the file as is). </p><p>See 
<a href="./snmp_manager_config_files#usm">Security data for USM</a> 
for more info. </p><a name="append_usm_config"></a><h4>append_usm_config(Dir, Conf) -&gt; ok</h4><p>Append the manager usm  config to the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [usm_entry()]</span></li></ul><p>Append the usm config to the current manager usm 
config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_manager_config_files#usm">Security data for USM</a> 
for more info. </p><a name="read_usm_config"></a><h4>read_usm_config(Dir) -&gt; Conf</h4><p>Read the manager usm config from the config file</p><ul><li><span class="v">Dir = string()</span></li><li><span class="v">Conf = [usm_entry()]</span></li></ul><p>Read the current manager usm config file. </p><p><strong>Dir</strong> is the path to the directory where to store the 
config file. </p><p>See 
<a href="./snmp_manager_config_files#usm">Security data for USM</a> 
for more info. </p><a name="end"></a><h3>snmpm_mpd</h3><p>Message Processing and Dispatch module for the SNMP manager</p><p>The module <strong>snmpm_mpd</strong> implements the version independent
Message Processing and Dispatch functionality in SNMP for the manager. 
It is supposed to be used from a Network Interface process 
(<a href="snmp_manager_netif">Definition of Manager Net if</a>).
Legacy API function <strong>process_msg/7</strong> that has got separate
<strong>IpAddr</strong> and <strong>PortNumber</strong> arguments still works as before
for backwards compatibility reasons.</p><h3>Functions</h3><h4>init_mpd(Vsns) -&gt; mpd_state()</h4><p>Initialize the MPD module</p><ul><li><span class="v">Vsns = [Vsn]</span></li><li><span class="v">Vsn = v1 | v2 | v3</span></li></ul><p>This function can be called from the net_if process at start-up.
The options list defines which versions to use.
</p><p>It also initializes some SNMP counters.
<a name="process_msg"></a>
</p><h4>process_msg(Msg, Domain, Addr, State, NoteStore, Logger) -&gt; {ok, Vsn, Pdu, PduMS, MsgData} | {discarded, Reason}</h4><p>Process a message received from the network</p><ul><li><span class="v">Msg = binary()</span></li><li><span class="v">Domain = transportDomainUdpIpv4 | transportDomainUdpIpv6</span></li><li><span class="v">Addr = {} </span></li><li><span class="v">State = mpd_state()</span></li><li><span class="v">NoteStore = pid()</span></li><li><span class="v">Logger = function()</span></li><li><span class="v">Vsn = 'version-1' | 'version-2' | 'version-3'</span></li><li><span class="v">Pdu = #pdu</span></li><li><span class="v">PduMs = integer()</span></li><li><span class="v">MsgData = term()</span></li></ul><p>Processes an incoming message. Performs authentication and 
decryption as necessary. The return values should be passed the
manager server.
</p><p><strong>NoteStore</strong> is the <strong>pid()</strong> of the note-store process.</p><p><strong>Logger</strong> is the function used for audit trail logging.
</p><p>In the case when the pdu type is <strong>report</strong>, <strong>MsgData</strong> is 
either <strong>ok</strong> or <strong>{error, ReqId, Reason}</strong>.
</p><h4>generate_msg(Vsn, NoteStore, Pdu, MsgData, Logger) -&gt; {ok, Packet} | {discarded, Reason}</h4><p>Generate a request message to be sent to the network</p><ul><li><span class="v">Vsn = 'version-1' | 'version-2' | 'version-3'</span></li><li><span class="v">NoteStore = pid()</span></li><li><span class="v">Pdu = #pdu</span></li><li><span class="v">MsgData = term()</span></li><li><span class="v">Logger = function()</span></li><li><span class="v">Packet = binary()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Generates a possibly encrypted packet to be sent to the network.
</p><p><strong>NoteStore</strong> is the <strong>pid()</strong> of the note-store process.
</p><p><strong>MsgData</strong> is the message specific data used in the SNMP 
message. In SNMPv1 and SNMPv2c, this message data is the community 
string. In SNMPv3, it is the context information.
</p><p><strong>Logger</strong> is the function used for audit trail logging.
</p><h4>generate_response_msg(Vsn, Pdu, MsgData, Logger) -&gt; {ok, Packet} | {discarded, Reason}</h4><p>Generate a response packet to be sent to the network</p><ul><li><span class="v">Vsn = 'version-1' | 'version-2' | 'version-3'</span></li><li><span class="v">Pdu = #pdu</span></li><li><span class="v">MsgData = term()</span></li><li><span class="v">Logger = function()</span></li><li><span class="v">Packet = binary()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Generates a possibly encrypted response packet to be sent to the
network.
</p><p><strong>MsgData</strong> is the message specific data used in the SNMP 
message. This value is received from the 
<a href="./snmpm_mpd#process_msg">process_msg</a> 
function.
</p><h3>snmpm_network_interface</h3><p>Behaviour module for the SNMP manager network interface.</p><p>This module defines the behaviour of the manager network
interface. A <strong>snmpm_network_interface</strong> compliant module 
must export the following functions: <ul><li> <p><a href="#start_link">start_link/2</a></p> </li><li> <p><a href="#stop">stop/1</a></p> </li><li> <p><a href="#send_pdu">send_pdu/7</a></p> </li><li> <p><a href="#inform_response">inform_response/4</a></p> </li><li> <p><a href="#note_store">note_store/2</a></p> </li><li> <p><a href="#info">info/1</a></p> </li><li> <p><a href="#get_log_type">get_log_type/1</a></p> </li><li> <p><a href="#set_log_type">set_log_type/2</a></p> </li><li> <p><a href="#verbosity">verbosity/2</a></p> </li></ul>The semantics of them and their exact signatures are explained
below. Legacy API function <strong>send_pdu/7</strong> that has got separate
<strong>IpAddr</strong> and <strong>PortNumber</strong> arguments still works as before
for backwards compatibility reasons.<a name="start_link"></a></p><h3>Functions</h3><h4>start_link(Server, NoteStore) -&gt; {ok, Pid} | {error, Reason}</h4><p>Start-link the network interface process</p><ul><li><span class="v">Server    = pid()</span></li><li><span class="v">NoteStore = pid()</span></li></ul><p>Start-link the network interface process.</p><p><strong>Server</strong> is the pid of the managing process.</p><p><strong>NoteStore</strong> is the pid of the note-store process.</p><a name="stop"></a><h4>stop(Pid) -&gt; void()</h4><p>Stop the network interface process</p><ul><li><span class="v">Pid = pid()</span></li></ul><p>Stop the network interface process.</p><a name="send_pdu"></a><h4>send_pdu(Pid, Pdu, Vsn, MsgData, Domain, Addr, ExtraInfo) -&gt; void()</h4><p>Request the network interface process to send this pdu</p><ul><li><span class="v">Pid = pid()</span></li><li><span class="v">Pdu = pdu()</span></li><li><span class="v">Vsn = 'version-1' | 'version-2' | 'version-3'</span></li><li><span class="v">MsgData = term()</span></li><li><span class="v">Domain = transportDomainUdpIpv4 | transportDomainUdpIpv6</span></li><li><span class="v">Addr = {} </span></li><li><span class="v">ExtraInfo = term()</span></li></ul><p>Request the network interface process (<strong>Pid</strong>) to send
this pdu (<strong>Pdu</strong>).</p><p><strong>ExtraInfo</strong> is some opaque data that is passed to the
net-if process. It originates from the <strong>ExtraInfo</strong>
parameter in the calls to the 
<a href="./snmpm#sync_get">synchronous get-request</a>, 
<a href="./snmpm#async_get">asynchronous get-request</a>,
<a href="./snmpm#sync_get_next">synchronous get-next-request</a>, 
<a href="./snmpm#async_get_next">asynchronous get-next-request</a>,
<a href="./snmpm#sync_set">synchronous set-request</a>
and 
<a href="./snmpm#async_set">asynchronous set-request</a>
functions. 
Whether the net-if process chooses
to use this is implementation dependent. The net-if process
included in this application ignores it. </p><a name="inform_response"></a><h4>inform_response(Pid, Ref, Addr, Port) -&gt; void()</h4><p>Send the inform-request ack</p><ul><li><span class="v">Pid = pid()</span></li><li><span class="v">Ref = term()</span></li><li><span class="v">Addr = address()</span></li><li><span class="v">Port = integer()</span></li></ul><p>Instruct the network interface process to send the response
(acknowledgment) to an inform-request.</p><p><strong>Ref</strong> is something that can be used to identify the 
inform-request, e.g. request-id of the inform-request.</p><p><strong>Addr</strong> and <strong>Port</strong> identifies the agent, from 
which the inform-request originated.</p><a name="note_store"></a><h4>note_store(Pid, NoteStore) -&gt; void()</h4><p>Change the verbosity of the network interface process</p><ul><li><span class="v">Pid       = pid()</span></li><li><span class="v">NoteStore = pid()</span></li></ul><p>Change the pid of the note-store process.
This is used when the server re-starts the note_store 
(e.g. after a crach).</p><a name="info"></a><h4>info(Pid) -&gt; [{Key, Value}]</h4><p>Return information about the running network interface process</p><ul><li><span class="v">Pid = pid()</span></li></ul><p>The info returned is basically up to the implementer to decide. 
The implementation provided by this application provides info about 
memory allocation and various socket information.</p><p>The info returned by this function is returned together with other
info collected by the manager when the
<a href="./snmpm#info">info</a> function is called 
(tagged with the key <strong>net_if</strong>).</p><a name="verbosity"></a><h4>verbosity(Pid, Verbosity) -&gt; void()</h4><p>Change the verbosity of the network interface process</p><ul><li><span class="v">Pid       = pid()</span></li><li><span class="v">Verbosity = verbosity()</span></li></ul><p>Change the verbosity of the network interface process.</p><a name="get_log_type"></a><h4>get_log_type(Pid) -&gt; {ok, LogType} | {error, Reason}</h4><p>Get the Audit Trail Log type</p><ul><li><span class="v">Pid     = pid()</span></li><li><span class="v">LogType = atl_type()</span></li><li><span class="v">Reason  = term()</span></li></ul><p>The Audit Trail Log is managed by the network interface process.
So, it is this process that has to return the actual log-type. </p><a name="set_log_type"></a><h4>set_log_type(Pid, NewType) -&gt; {ok, OldType} | {error, Reason}</h4><p>Change the Audit Trail Log type</p><ul><li><span class="v">Pid     = pid()</span></li><li><span class="v">NewType = OldType = atl_type()</span></li><li><span class="v">Reason  = term()</span></li></ul><p>The Audit Trail Log is managed by the network interface process.
So, it is this process that has to do the actual changing of the
type. </p><p>See
<a href="./snmpm#set_log_type">set_log_type</a>
for more info. </p><h3>snmpm_user</h3><p>Behaviour module for the SNMP manager user.</p><p>This module defines the behaviour of the manager user. 
A <strong>snmpm_user</strong> compliant module 
must export the following functions: <ul><li> <p>handle_error/3</p> </li><li> <p>handle_agent/4</p> </li><li> <p>handle_pdu/4</p> </li><li> <p>handle_trap/3</p> </li><li> <p>handle_inform/3</p> </li><li> <p>handle_report/3</p> </li><li> <p>handle_invalid_result/2</p> </li></ul>The semantics of them and their exact signatures are explained
below. Some of the function has no defined return value (<strong>void()</strong>), 
they can of course return anything. But the functions that do have
specified return value(s) <em>must</em> adhere to this. None of the 
functions can use exit of throw to return. If the manager is not configured to use any particular
transport domain, the behaviour <strong>handle_agent/4</strong>
will for backwards copmpatibility reasons be called with the old
<strong>IpAddr</strong> and <strong>PortNumber</strong> arguments<a name="types"></a></p><h4>DATA TYPES</h4><pre><code class="">
snmp_gen_info() = {ErrorStatus :: atom(), 
                   ErrorIndex  :: pos_integer(), 
                   Varbinds    :: [snmp:varbind()]}
snmp_v1_trap_info() :: {Enteprise :: snmp:oid(), 
                        Generic   :: integer(), 
                        Spec      :: integer(), 
                        Timestamp :: integer(), 
                        Varbinds  :: [snmp:varbind()]}
    </code></pre><a name="handle_error"></a><h3>Functions</h3><h4>handle_error(ReqId, Reason, UserData) -&gt; void()</h4><p>Handle error</p><ul><li><span class="v">ReqId = integer()</span></li><li><span class="v">Reason = {unexpected_pdu, SnmpInfo} | {invalid_sec_info, SecInfo, SnmpInfo} | {empty_message, Addr, Port} | term()</span></li><li><span class="v">SnmpInfo = snmp_gen_info()</span></li><li><span class="v">SecInfo = term()</span></li><li><span class="v">Addr = ip_address()</span></li><li><span class="v">Port = integer()</span></li><li><span class="v">UserData = term()</span></li></ul><p>This function is called when the manager needs to
communicate an "asynchronous" error to the user:
e.g. failure to send an asynchronous message (i.e. encoding
error), a received message was discarded due to security
error, the manager failed to generate a response message to
a received inform-request, or when receiving an unexpected
PDU from an agent (could be an expired async request). </p><p>If <strong>ReqId</strong> is less then 0, it means that this
information was not available to the manager (that info was
never retrieved before the message was discarded). </p><p>For <strong>SnmpInfo</strong> see handle_agent below.</p><a name="handle_agent"></a><h4>handle_agent(Domain, Addr, Type, SnmpInfo, UserData) -&gt; Reply</h4><p>Handle agent</p><ul><li><span class="v">Domain = transportDomainUdpIpv4 | transportDomainUdpIpv6</span></li><li><span class="v">Addr = {} </span></li><li><span class="v">Type = pdu | trap | report | inform</span></li><li><span class="v">SnmpInfo = SnmpPduInfo | SnmpTrapInfo | SnmpReportInfo | SnmpInformInfo</span></li><li><span class="v">SnmpPduInfo = snmp_gen_info()</span></li><li><span class="v">SnmpTrapInfo = snmp_v1_trap_info()</span></li><li><span class="v">SnmpReportInfo = snmp_gen_info()</span></li><li><span class="v">SnmpInformInfo = snmp_gen_info()</span></li><li><span class="v">UserData = term()</span></li><li><span class="v">Reply = ignore | {register, UserId, TargetName, AgentConfig}</span></li><li><span class="v">UserId = term()</span></li><li><span class="v">TargetName = target_name()</span></li><li><span class="v">AgentConfig = [agent_config()]</span></li></ul><p>This function is called when a message is received from an 
unknown agent.</p><p>Note that this will always be the default user that is called.</p><p>For more info about the <strong>agent_config()</strong>, see 
<a href="./snmpm#register_agent">register_agent</a>.</p><p>The arguments <strong>Type</strong> and <strong>SnmpInfo</strong> relates in the 
following way: </p><ul><li> <p><strong>pdu</strong> - <strong>SnmpPduInfo</strong> 
(see <a href="#handle_pdu">handle_pdu</a>
for more info).</p> </li><li> <p><strong>trap</strong> - <strong>SnmpTrapInfo</strong> 
(see <a href="#handle_trap">handle_trap</a>
for more info).</p> </li><li> <p><strong>report</strong> - <strong>SnmpReportInfo</strong> 
(see <a href="#handle_report">handle_report</a>
for more info).</p> </li><li> <p><strong>inform</strong> - <strong>SnmpInformInfo</strong> 
(see <a href="#handle_inform">handle_inform</a>
for more info).</p> </li></ul><p>The only user which would return 
<strong>{register, UserId, TargetName, AgentConfig}</strong> is the 
<em>default user</em>.</p><a name="handle_pdu"></a><h4>handle_pdu(TargetName, ReqId, SnmpPduInfo, UserData) -&gt; void()</h4><p>Handle the reply to an asynchronous request</p><ul><li><span class="v">TargetName = target_name()</span></li><li><span class="v">ReqId = term()</span></li><li><span class="v">SnmpPduInfo = snmp_gen_info()</span></li><li><span class="v">UserData = term()</span></li></ul><p>Handle the reply to an asynchronous request, such as 
<a href="./snmpm#async_get">async_get</a>, 
<a href="./snmpm#async_get_next">async_get_next</a> or 
<a href="./snmpm#async_set">async_set</a>.</p><p>It could also be a late reply to a synchronous request.</p><p><strong>ReqId</strong> is returned by the asynchronous request function.</p><a name="handle_trap"></a><h4>handle_trap(TargetName, SnmpTrapInfo, UserData) -&gt; Reply</h4><p>Handle a trap/notification message</p><ul><li><span class="v">TargetName = TargetName2 = target_name()</span></li><li><span class="v">SnmpTrapInfo = snmp_v1_trap_info() | snmp_gen_info()</span></li><li><span class="v">UserData = term()</span></li><li><span class="v">Reply = ignore | unregister | {register, UserId, TargetName2, AgentConfig}</span></li><li><span class="v">UserId = term()</span></li><li><span class="v">AgentConfig = [agent_config()]</span></li></ul><p>Handle a trap/notification message from an agent.</p><p>For more info about the <strong>agent_config()</strong>, see 
<a href="./snmpm#register_agent">register_agent</a></p><p>The only user which would return 
<strong>{register, UserId, TargetName2, agent_info()}</strong> is the 
<em>default user</em>.</p><a name="handle_inform"></a><h4>handle_inform(TargetName, SnmpInformInfo, UserData) -&gt; Reply</h4><p>Handle a inform message</p><ul><li><span class="v">TargetName = TargetName2 = target_name()</span></li><li><span class="v">SnmpInformInfo = snmp_gen_info()</span></li><li><span class="v">UserData = term()</span></li><li><span class="v">Reply = ignore | no_reply | unregister | {register, UserId, TargetName2, AgentConfig}</span></li><li><span class="v">UserId = term()</span></li><li><span class="v">AgentConfig = [agent_config()]</span></li></ul><p>Handle a inform message.</p><p>For more info about the <strong>agent_config()</strong>, see 
<a href="./snmpm#register_agent">register_agent</a></p><p>The only user which would return 
<strong>{register, UserId, TargetName2, AgentConfig}</strong> is the 
<em>default user</em>.</p><p>If the 
<a href="snmp_app">inform request behaviour</a> 
configuration option is set to <strong>user</strong> or 
<strong>{user, integer()}</strong>, the response (acknowledgment) to this 
inform-request will be sent when this function returns.</p><a name="handle_report"></a><h4>handle_report(TargetName, SnmpReportInfo, UserData) -&gt; Reply</h4><p>Handle a report message</p><ul><li><span class="v">TargetName = TargetName2 = target_name()</span></li><li><span class="v">Addr = ip_address()</span></li><li><span class="v">Port = integer()</span></li><li><span class="v">SnmpReportInfo = snmp_gen_info()</span></li><li><span class="v">UserData = term()</span></li><li><span class="v">Reply = ignore | unregister | {register, UserId, TargetName2, AgentConfig}</span></li><li><span class="v">UserId = term()</span></li><li><span class="v">AgentConfig = [agent_config()]</span></li></ul><p>Handle a report message.</p><p>For more info about the <strong>agent_config()</strong>, see 
<a href="./snmpm#register_agent">register_agent</a></p><p>The only user which would return 
<strong>{register, UserId, TargetName2, AgentConfig}</strong> is the 
<em>default user</em>.</p><a name="handle_invalid_result"></a><h4>handle_invalid_result(IN, OUT) -&gt; void()</h4><p>Handle a report message</p><ul><li><span class="v">IN = {Func, Args}</span></li><li><span class="v">Func = atom()</span></li><li><span class="v">Args = list()</span></li><li><span class="v">OUT = {crash, CrashInfo} | {result, InvalidResult}</span></li><li><span class="v">CrashInfo = {ErrorType, Error, Stacktrace}</span></li><li><span class="v">ErrorType = atom()</span></li><li><span class="v">Error = term()</span></li><li><span class="v">Stacktrace = list()</span></li><li><span class="v">InvalidResult = term()</span></li></ul><p>If <em>any</em> of the <em>other</em> callback functions crashes 
(exit, throw or a plain crash) or return an invalid result (if a valid 
return has been specified), this function is called. 
The purpose is to allow the user handle this 
error (for instance to issue an error report).</p><p><strong>IN</strong> reprecents the function called (and its arguments). 
<strong>OUT</strong> represents the unexpected/invalid result. </p><h3>snmpm_network_interface_filter</h3><p>Behaviour module for the SNMP manager network-interface filter.</p><p>This module defines the behaviour of the manager network interface
filter. A <strong>snmpm_network_interface_filter</strong> compliant module 
must export the following functions: <ul><li> <p><a href="#accept_recv">accept_recv/2</a></p> </li><li> <p><a href="#accept_send">accept_send/2</a></p> </li><li> <p><a href="#accept_recv_pdu">accept_recv_pdu/3</a></p> </li><li> <p><a href="#accept_send_pdu">accept_send_pdu/2</a></p> </li></ul>The semantics of them and their exact signatures are explained
below. The purpose of the network interface filter is to allow for filtering
of messages (accept or reject) receive and send. This is done 
on two levels: <ul><li> <p>The first level is at the UDP entry / exit point, i.e. 
immediately after the receipt of the message, before any message 
processing is done (accept_recv) and 
immediately before sending the message, after all message 
processing is done (accept_send).</p> </li><li> <p>The second level is at the MPD entry / exit point, i.e.
immediately after the basic message processing (accept_recv_pdu) / 
immediately before the basic message processing (accept_send_pdu).</p> </li></ul>Note that the network interface filter is something which is used 
by the network interface implementation provided by the application 
(<strong>snmpm_net_if</strong> and <strong>snmpm_net_if_mt</strong>). 
The default filter accepts all messages.A network interface filter can e.g. be used during testing or for load 
regulation. Legacy network interface filter modules used arguments on the form
<strong>(IpAddr, PortNumber,...)</strong> instead of
<strong>(Domain, Addr, ...)</strong>, and if the SNMP manager is run without
changing the configuration to use transport domains
the network interface filter will still get
the old arguments and work as before.</p><h4>DATA TYPES</h4><pre><code class="">
port() = integer() &gt; 0
pdu_type() = 'get-request' | 'get-next-request' | 'get-response' | 
             'set-request' | trap | 'get-bulk-request' | 'inform-request' | 
             report | trappdu
    </code></pre><p>See also the <a href="./snmpa_conf#types"> data types in </a>.</p><a name="accept_recv"></a><h3>Functions</h3><h4>accept_recv(Domain, Addr) -&gt; boolean()</h4><p>Shall the received message be accepted</p><ul><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddressWithPort()</span></li></ul><p>Called at the reception of a message (before <em>any</em> processing 
has been done).</p><p>For the message to be rejected, the function <em>must</em> return
<em>false</em>. </p><a name="accept_send"></a><h4>accept_send(Domain, Addr) -&gt; boolean()</h4><p>Shall the message be sent</p><ul><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddressWithPort()</span></li></ul><p>Called before the sending of a message (after <em>all</em> processing 
has been done).</p><p>For the message to be rejected, the function <em>must</em> return
<em>false</em>. </p><a name="accept_recv_pdu"></a><h4>accept_recv_pdu(Domain, Addr, PduType) -&gt; boolean()</h4><p>Shall the received pdu be accepted</p><ul><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddressWithPort()</span></li><li><span class="v">PduType = pdu_type()</span></li></ul><p>Called after the basic message processing (MPD) has been done, 
but before the pdu is handed over to the server for primary 
processing.</p><p>For the pdu to be rejected, the function <em>must</em> return
<em>false</em>. </p><a name="accept_send_pdu"></a><h4>accept_send_pdu(Domain, Addr, PduType) -&gt; boolean()</h4><p>Shall the pdu be sent</p><ul><li><span class="v">Domain = transportDomain()</span></li><li><span class="v">Addr = transportAddressWithPort()</span></li><li><span class="v">PduType = pdu_type() &gt; 0</span></li></ul><p>Called before the basic message processing (MPD) is done, 
when a pdu has been received from the master-agent.</p><p>For the message to be rejected, the function <em>must</em> return 
<em>false</em>. </p></body></html>