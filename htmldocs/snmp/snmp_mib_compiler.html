<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>The MIB Compiler</h1><p>The chapter <em>The MIB Compiler</em> describes the MIB compiler
and contains the following topics:
</p><ul><li>Operation</li><li>Import</li><li>Consistency checking between MIBs</li><li>.hrl file generation</li><li>Emacs integration</li><li>Deviations from the standard </li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>When importing MIBs, ensure that the imported MIBs as well as the 
importing MIB are compiled using the same version of the 
SNMP-compiler.</p></div><h2>Operation</h2><p>The MIB must be written as a text file in SMIv1 or SMIv2 using 
an ASN.1 notation before
it will be compiled. This text file must have the same name as the MIB,
but with the suffix <strong>.mib</strong>. This is necessary for handling
the <strong>IMPORT</strong> statement.
</p><p>The association file, which contains the names of
instrumentation functions for the MIB, should have the suffix
<strong>.funcs</strong>. If the compiler does not find the association file,
it gives a warning message and uses default instrumentation
functions.  (See <a href="./snmp_instr_functions#snmp_3">Default Instrumentation</a> for more details).
</p><p>The MIB compiler is started with a call to
<strong>snmpc:compile(&lt;mibname&gt;).</strong> For example:
</p><pre><code class="">
snmpc:compile("RFC1213-MIB").
    </code></pre><p>The output is a new file which is called <strong>&lt;mibname&gt;.bin</strong>.
</p><p>The MIB compiler understands both SMIv1 and SMIv2 MIBs.  It
uses the MODULE-IDENTITY statement to determinate if the MIB is
written in SMI version 1 or 2.
</p><h2>Importing MIBs</h2><p>The compiler handles the <strong>IMPORT</strong> statement. It is important to
import the compiled file and not the ASN.1 (source) file. A MIB must
be recompiled to make changes visible to other MIBs importing it.
</p><p>The compiled files of the imported MIBs must be present in the
current directory, or a directory in the current path. The path is
supplied with the <strong>{i, Path}</strong> option, for example:
</p><pre><code class="">
snmpc:compile("MY-MIB", 
       [{i, ["friend_mibs/", "../standard_mibs/"]}]).
    </code></pre><p>It is also possible to import MIBs from OTP applications in an
<strong>"include_lib"</strong> like fashion with the <strong>il</strong>
option. Example:
</p><pre><code class="">
snmpc:compile("MY-MIB", 
       [{il, ["snmp/priv/mibs/", "myapp/priv/mibs/"]}]).
    </code></pre><p>finds the latest version of the <strong>snmp</strong> and <strong>myapp</strong>
applications in the OTP system and uses the expanded paths as
include paths.
</p><p>Note that an SMIv2 MIB can import an SMIv1 MIB and vice versa.
</p><p>The following MIBs are built-ins of the Erlang SNMP compiler:
SNMPv2-SMI, RFC-1215, RFC-1212, SNMPv2-TC, SNMPv2-CONF, and
RFC1155-SMI. They cannot therefore be compiled separately.
</p><h2>MIB Consistency Checking</h2><p>When an MIB is compiled, the compiler detects if several
managed objects use the same <strong>OBJECT IDENTIFIER</strong>. If that is
the case, it issues an error message. However, the compiler cannot
detect Oid conflicts between different MIBs. These kinds of
conflicts generate an error at load time. To avoid this, the
following function can be used to do consistency checking between
MIBs:
</p><pre>

erl&gt;<span class="input">snmpc:is_consistent(ListOfMibNames).</span>
    </pre><p><strong>ListOfMibNames</strong> is a list of compiled MIBs, for example
<strong>["RFC1213-MIB", "MY-MIB"]</strong>. The function also performs
consistency checking of trap definitions.</p><h2>.hrl File Generation</h2><p>It is possible to generate an <strong>.hrl</strong> file which contains
definitions of Erlang constants from a compiled MIB file. This
file can then be included in Erlang source code. The file will
contain constants for:
</p><ul><li>object Identifiers for tables, table entries and variables</li><li>column numbers</li><li>enumerated values</li><li>default values for variables and table columns. </li></ul><p>Use the following command to  generate a .hrl file from an MIB:
</p><pre>
erl&gt;<span class="input">snmpc:mib_to_hrl(MibName).</span>
    </pre><h2>Emacs Integration</h2><p>With the Emacs editor, the <strong>next-error</strong> (<strong>C-X `</strong>)
function can be used indicate where a compilation error occurred,
provided the error message is described by a line number.
</p><p>Use <strong>M-x compile</strong> to compile an MIB from inside Emacs, and
enter:
</p><pre>
 <span class="input">erl -s snmpc compile &lt;MibName&gt; -noshell</span>
    </pre><p>An example of <strong>&lt;MibName&gt;</strong> is <strong>RFC1213-MIB</strong>.
</p><h2>Compiling from a Shell or a Makefile</h2><p>The <strong>erlc</strong> commands can be used to compile SNMP MIBs. Example:
</p><pre>
 <span class="input">erlc MY-MIB.mib</span>
    </pre><p>All the standard <strong>erlc</strong> flags are supported, e.g.
</p><pre>
 <span class="input">erlc -I mymibs -o mymibs -W MY-MIB.mib</span>
    </pre><p>The flags specific to the MIB compiler can be specified by
using the <strong>+</strong> syntax:
</p><pre>
 <span class="input">erlc +'{group_check,false}' MY-MIB.mib</span>
    </pre><h2>Deviations from the Standard</h2><p>In some aspects the Erlang MIB compiler does not follow or
implement the SMI fully. Here are the differences:
</p><ul><li> <p>Tables must be written in the following order:
<strong>tableObject</strong>, <strong>entryObject</strong>, <strong>column1</strong>, ...,
<strong>columnN</strong> (in order).</p> </li><li> <p>Integer values, for example in the <strong>SIZE</strong> expression
must be entered in decimal syntax, not in hex or bit syntax.</p> </li><li> <p>Symbolic names must be unique within a MIB and within a
system.</p> </li><li> <p>Hyphens are allowed in SMIv2 (a pragmatic approach).  The
reason for this is that according to SMIv2, hyphens are allowed
for objects converted from SMIv1, but not for others.  This is
impossible to check for the compiler.</p> </li><li> <p>If a word is a keyword in any of SMIv1 or SMIv2, it is a
keyword in the compiler (deviates from SMIv1 only).</p> </li><li> <p>Indexes in a table must be objects, not types (deviates
from SMIv1 only).</p> </li><li> <p>A subset of all semantic checks on types are
implemented. For example, strictly the <strong>TimeTicks</strong> may not
be sub-classed but the compiler allows this (standard MIBs must
pass through the compiler) (deviates from SMIv2 only).</p> </li><li> <p>The <strong>MIB.Object</strong> syntax is not implemented (since all
objects must be unique anyway).</p> </li><li> <p>Two different names cannot define the same OBJECT IDENTIFIER.</p> </li><li> <p>The type checking in the SEQUENCE construct is non-strict 
(i.e. subtypes may be specified).  The reason for this is 
that some standard MIBs use this.</p> </li><li>A definition has normally a status field. When the status field has the value deprecated, then the MIB-compiler will ignore this  definition. With the MIB-compiler option <strong>{deprecated,true}</strong>  the MIB-compiler does not ignore the deprecated definitions.</li><li>An object has a DESCRIPTIONS field. The descriptions-field will  not be included in the compiled mib by default. In order to get  the description, the mib must be compiled with the option  <strong>description</strong>.</li></ul></body></html>