<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Observer</h1><h1>Observer</h1><h4>Scope</h4><p>The Observer application is a container including the following
tools for tracing and investigation of distributed systems:</p><ul><li>Observer</li><li>Trace Tool Builder</li><li>Erlang Top</li><li>Crashdump Viewer</li></ul><h4>Prerequisites</h4><p>It is assumed that the reader is familiar with the Erlang
programming language.</p><h4>Introduction</h4><p>Observer is a graphical tool for observing the characteristics of
Erlang systems. Observer displays system information, application
supervisor trees, process information, ETS tables, Mnesia tables
and contains a front end for Erlang tracing.
</p><h4>Getting Started</h4><p>Run Observer from a standalone node to minimize the impact of the 
system being observed.
</p><p><em>Example:</em></p><pre>
% <span class="input">erl -sname observer -hidden -setcookie MyCookie -run observer</span></pre><p>
Select the node to observe with menu <em>Nodes</em>. 
Menu <em>View &gt; Refresh interval</em> controls how often 
the view is to be updated.
The refresh interval is set per viewer so you can
have different settings for each viewer. To minimize the system
impact, only the active viewer is updated. Other views are updated 
when activated.
</p><p>The mouse buttons behave as expected. Use left-click
to select objects, right-click to get a menu with the most used
options, and double-click to display information about the
selected object. In most viewers with many columns, you can change
the sort order by left-clicking the column header.
</p><h4>System Tab</h4><p>Tab <em>System</em> displays general information about the active Erlang node 
and its runtime system, such as build configuration, system capabilities, and 
overall use statistics.
</p><h4>Load Charts Tab</h4><p>Tab <em>Load Charts</em> displays graphs of the current resource use on 
the active Erlang node.</p><p>Graph <strong>Scheduler Utilization</strong> shows scheduler use per scheduler, 
where each scheduler use has a unique color.</p><p>Graph <strong>Memory Usage</strong> shows the total memory use and per memory category
use, where each category has a unique color. The categories are as 
follows:</p><dl><dt><strong>Total</strong></dt><dd><p>The sum of all memory categories.</p></dd><dt><strong>Processes</strong></dt><dd><p>The sum of all process memory used.</p></dd><dt><strong>Atom</strong></dt><dd><p>The size used by the atom table.</p></dd><dt><strong>Binary</strong></dt><dd><p>The sum of all off-heap binaries allocated.</p></dd><dt><strong>Code</strong></dt><dd><p>The memory allocated for code storage.</p></dd><dt><strong>Ets</strong></dt><dd><p>The used memory for all ETS tables.</p></dd></dl><p>Graph <strong>IO Usage</strong> shows the current I/O load on the system.</p><h4>Memory Allocators Tab</h4><p>Tab <em>Memory Allocators</em> displays detailed information of the carrier 
size and current memory carriers. For details about memory carriers, 
see module
<a href="./erts_alloc">erts/erts_alloc</a>
in application ERTS.</p><p>The <strong>Max Carrier size</strong> column shows the maximum value seen by observer
since the last node change or since the start of the application, i.e. switching
nodes will reset the max column. Values are sampled so higher values may have
existed than what is shown.
</p><h4>Applications Tab</h4><p>Tab <em>Applications</em> presents application information.
Select an application in the left list to display its supervisor
tree. The right-click options in the tree are as follows:
</p><dl><dt>Process info</dt><dd><p>Opens a detailed information window on the selected process,
including the following:</p> <dl><dt>Process Information</dt><dd><p>Shows the process information.</p></dd><dt>Messages</dt><dd><p>Shows the process messages.</p></dd><dt>Dictionary</dt><dd><p>Shows the process dictionary.</p></dd><dt>Stack Trace</dt><dd><p>Shows the process current stack trace.</p></dd><dt>State</dt><dd><p>Shows the process state.</p></dd><dt>Log</dt><dd><p>If enabled and available, shows the process SASL
log entries.</p></dd></dl> </dd><dt>Trace process</dt><dd><p>Adds the selected process identifier to tab <em>Trace Overview</em> 
plus the node that the process resides on.</p></dd><dt>Trace named process</dt><dd><p>Adds the registered name of the process. This can be useful when tracing on
many nodes, as processes with that name are then traced on all traced nodes.</p></dd><dt>Trace process tree</dt><dd><p>Adds the selected process and all processes below,
right of it, to tab <em>Trace Overview</em>.</p></dd><dt>Trace named process tree</dt><dd><p>Adds the selected process and all processes below,
right of it, to tab <em>Trace Overview</em>.</p></dd></dl><h4>Processes Tab</h4><p>Tab <em>Processes</em> lists process information in columns.
For each process the following information is displayed:
</p><dl><dt>Pid</dt><dd><p>The process identifier.</p></dd><dt>Reds</dt><dd><p>The number of reductions executed on the process. 
This can be presented as accumulated values or as values since the last update.</p></dd><dt>Memory</dt><dd><p>The size of the process, in bytes, obtained by a
call to <strong>process_info(Pid,memory)</strong>.</p></dd><dt>MsgQ</dt><dd><p>The length of the message queue for the process.</p></dd></dl><p>Option <em>Process info</em> opens a detailed information window on the process under the mouse pointer,
including the following:</p><dl><dt>Process Information</dt><dd><p>Shows the process information.</p></dd><dt>Messages</dt><dd><p>Shows the process messages.</p></dd><dt>Dictionary</dt><dd><p>Shows the process dictionary.</p></dd><dt>Stack Trace</dt><dd><p>Shows the process current stack trace.</p></dd><dt>State</dt><dd><p>Shows the process state.</p></dd><dt>Log</dt><dd><p>If enabled and available, shows the process SASL log entries.</p></dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><em>Log</em> requires application SASL  to be started on the observed node,
with <strong>log_mf_h</strong> as log handler.
The Observed node must be Erlang/OTP R16B02 or higher.
The <strong>rb</strong> server must not be started on the observed node when clicking menu 
<em>Log &gt; Toggle log view</em>. The <strong>rb</strong> server is stopped on the observed node 
when exiting or changing the observed node.
</p></div><p>Option <em>Trace selected processes</em> adds the selected process identifiers to tab
<em>Trace Overview</em> plus the node that the processes reside on.
</p><p>Option <em>Trace selected processes by name</em> adds the registered name of the processes. This can be 
useful when tracing is done on many nodes, as processes with that name are then traced on 
all traced nodes.</p><p>Option <em>Kill process</em> brutally kills the processes under
the mouse pointer by sending an exit signal with
reason <strong>kill</strong>.</p><h4>Ports Tab</h4><p>Tab <em>Ports</em> lists port information in columns.
For each port the following information is displayed:
</p><dl><dt>Id</dt><dd><p>The port identifier.</p></dd><dt>Connected</dt><dd><p>The process identifier for the process that owns the
port.</p></dd><dt>Name</dt><dd><p>The registered name of the port, if any.</p></dd><dt>Controls</dt><dd><p>The name of the command set by <a href="../erts/erlang#open_port-2">erts/erlang#open_port-2</a>.</p></dd><dt>Slot</dt><dd><p>The internal index of the port.</p></dd></dl><p>Option <em>Port info</em> opens a detailed information window
for the port under the mouse pointer. In addition to the
information above, it also shows links and monitors.</p><p>Option <em>Trace selected ports</em> adds the selected port
identifiers, and the nodes that the ports reside on,
to tab <em>Trace Overview</em>.</p><p>Option <em>Trace selected ports by name</em> adds the
registered name of the port to tab <em>Trace Overview</em>. This
can be useful when tracing is done on many nodes, as ports with
that name are then traced on all traced nodes.</p><p>Option <em>Close</em>
executes <a href="../erts/erlang#port_close-1">erts/erlang#port_close-1</a>
on the port under the mouse pointer.</p><h4>Table Viewer Tab</h4><p>Tab <em>Table Viewer</em> lists tables. By default, ETS tables
are displayed whereas unreadable private ETS tables and tables created by OTP
applications are not diplayed. Use menu <em>View</em> to view "system"
ETS tables, unreadable ETS tables, or Mnesia tables.
</p><p>Double-click to view the table content, or right-click and
select option <em>Show Table Content</em>. To view table
information, select the table and activate menu <em>View &gt; Table information</em>, or right-click and select option <em>Table info</em>.</p><p>You can use <a href="./re">regular expressions</a> and search for objects, and edit or delete them.
</p><h4>Trace Overview Tab</h4><p>Tab <em>Trace Overview</em> handles tracing. Trace by selecting
the processes or ports to be traced and how to trace them. For
processes, you can trace messages, function calls, scheduling,
garbage collections, and process-related events such
as <strong>spawn</strong>, <strong>exit</strong>, and many others. For ports, you can
trace messages, scheduling and port-related events.
</p><p>To trace function calls, you also need to set up
<em>trace patterns</em>. Trace patterns select the function calls
to be traced. The number of traced function calls can be
further reduced with <em>match specifications</em>. Match
specifications can also be used to trigger more information
in the trace messages.
</p><p>You can also set match specifications on messages. By default,
if tracing messages, all messages sent and/or received by the
process or port are traced. Match specifications can be used to
reduce the number of traced messages and/or to trigger more
information in the trace messages.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Trace patterns only apply to the traced processes and
ports.</p></div><p>
Processes are added from the <em>Applications</em>
or <em>Processes</em> tabs. Ports are added from
the <em>Ports</em> tab.  A special <em>new</em> identifier,
meaning all processes, or ports, started after trace start, can
be added with buttons <em>Add 'new' Processes</em> and <em>Add 'new' Ports</em>, respecively.
</p><p>
When adding processes or ports, a window with trace options is
displayed. The chosen options are set for the selected
processes/ports.  To change the options, right-click the process
or port and select <em>Edit process options</em>. To remove a
process or port from the list, right-click and select <em>Remove process</em> or <em>Remove port</em>, respectively.
</p><p>
Processes and ports added by process/port identifiers add the
nodes these processes/ports reside on in the node list. More
nodes can be added by clicking button <em>Add Nodes</em>, or by
right-clicking in the <em>Nodes</em> list and select <em>Add Nodes</em>. To remove nodes, select them, then right-click and
choose <em>Remove nodes</em>.
</p><p>
If function calls are traced, trace patterns must be added by clicking button
<em>Add Trace Pattern</em>. Select a module, function(s), and a match specification.
If no functions are selected, all functions in the module are traced.</p><p>
Trace patterns can also be added for traced messages. Click
button <em>Add Trace Pattern</em> and select <em>Messages sent</em> or <em>Messages received</em>, and a match
specification.
</p><p>
A few basic match specifications are provided in the tool, and
you can provide your own match specifications. The syntax of match
specifications is described in the <a href="./match_spec">erts/match_spec</a>. To simplify
the writing of a match specification, they can also be written as
<strong>fun/1</strong>. For details, see module
<a href="./ms_transform">ms_transform</a>
in application STDLIB.
</p><p>Click button <em>Start Trace</em> to start the trace.
By default, trace output is written to a new window. Tracing is stopped 
when the window is closed, or when clicking button <em>Stop Trace</em>.
Trace output can be changed with menu <em>Options &gt; Output</em>.
The trace settings, including match specifications, can be saved to, 
or loaded from, a file.
</p><p>For details about tracing, see module <a href="./dbg">dbg</a> in application Runtime_Tools
and in section "Match specifications in Erlang" in 
<a href="./match_spec">erts/match_spec</a>
and in module
<a href="./ms_transform">stdlib/ms_transform</a>
in application STDLIB.
</p><h4>Introduction</h4><p>Trace Tool Builder is a base for building trace tools for
single node or distributed Erlang systems. It requires the
Runtime_Tools application to be available on the traced
node.
</p><p>The following are the main features of Trace Tool Builder:</p><ul><li>Start tracing to file ports on many nodes with one function call.</li><li>Write more information to a trace information file, which is read during formatting.</li><li>Restore previous configuration by maintaining a history buffer and handling configuration files.</li><li>Provide some simple support for sequential tracing.</li><li>Format binary trace logs and merge logs from multiple nodes.</li></ul><p>The intention of Trace Tool Builder is to serve
as a base for tailor-made trace tools, but it can also be used directly
from the Erlang shell (it can mimic <strong>dbg</strong> behaviour while
still providing useful additions, such as match specification shortcuts).
Trace Tool Builder only allows the use of file port tracer, so to use 
other types of trace clients it is better to use <strong>dbg</strong> directly.</p><h4>Getting Started</h4><p>Module <strong>ttb</strong> is the interface to all functions in
Trace Tool Builder.</p><p>To get started, the least you need to do is to
start a tracer with 
<a href="./ttb#tracer/0">ttb#tracer/0</a>, 
and set the required
trace flags on the processes you want to trace with 
<a href="./ttb#p/2">ttb#p/2</a>.</p><p>When the tracing is completed, stop the tracer with 
<a href="./ttb#stop/0">ttb#stop/0</a> 
and format the trace log with 
<a href="./ttb#format/1">ttb#format/1</a> 
(if there is anything to format).
</p><p><em>Useful functions:</em></p><dl><dt><strong>ttb:tracer/0,1,2</strong></dt><dd><p>Opens a trace port on each node to be traced. By default, 
trace messages are written to binary files on remote nodes (the 
binary trace log).</p></dd><dt><strong>ttb:p/2</strong></dt><dd><p>Specifies the processes to be traced. Trace flags specified 
in this call specify what to trace on each process. This function can be 
called many times if you like different trace flags to be set on different 
processes.</p></dd><dt><strong>ttb:tp/2,3,4</strong> or <strong>ttb:tpl/2,3,4</strong></dt><dd><p>If you want to trace function calls (that is, if you have
trace flag <strong>call</strong> set on any process), you must
also set trace patterns on the required function(s) with
<a href="./ttb#/0">ttb#/0</a> or 
<a href="./ttb#/0">ttb#/0</a>.
A function is only traced 
if it has a trace pattern. The trace pattern specifies how to trace the
function by using match specifications. Match specifications are
described in the 
<a href="./users_guide">ERTS User's Guide</a>.</p></dd><dt><strong>ttb:stop/0,1</strong></dt><dd><p>Stops tracing on all nodes, deletes all trace patterns, and 
flushes the trace port buffer.</p></dd><dt><strong>ttb:format/1/2</strong></dt><dd><p>Translates the binary trace logs into something readable. 
By default, <strong>ttb</strong> presents each trace message as a line of text, 
but you can also write your own handler to make more complex interpretations 
of the trace information. A trace log can also be presented graphically 
with application Event Tracer (ET).</p> <p>If option <strong>format</strong> is specified to <strong>ttb:stop/1</strong>, the formatting 
is automatically done when stopping <strong>ttb</strong>.</p></dd></dl><h4>Tracing Local Node from Erlang Shell</h4><p>The following small module is used in the subsequent example:</p><pre><code class="">
-module(m).
-export([f/0]).
f() -&gt;
   receive 
      From when is_pid(From) -&gt;
         Now = erlang:now(),
         From ! {self(),Now}
   end.      </code></pre><p>The following example shows the basic use of <strong>ttb</strong> from
the Erlang shell. Default options are used both for starting the
tracer and for formatting (the custom fetch directory is however provided).
This gives a trace log named <strong>Node-ttb</strong> in the newly created
directory, where <strong>Node</strong> is the node name. The
default handler prints the formatted trace messages in the
shell:</p><pre>
(tiger@durin)47&gt; %% First I spawn a process running my test function
(tiger@durin)47&gt; <span class="input">Pid = spawn(m,f,[]).</span>
&lt;0.125.0&gt;
(tiger@durin)48&gt; 
(tiger@durin)48&gt; %% Then I start a tracer...
(tiger@durin)48&gt; <span class="input">ttb:tracer().</span>
{ok,[tiger@durin]}
(tiger@durin)49&gt; 
(tiger@durin)49&gt; %% and activate the new process for tracing
(tiger@durin)49&gt; %% function calls and sent messages.
(tiger@durin)49&gt; <span class="input">ttb:p(Pid,[call,send]).</span>
{ok,[{&lt;0.125.0&gt;,[{matched,tiger@durin,1}]}]}
(tiger@durin)50&gt; 
(tiger@durin)50&gt; %% Here I set a trace pattern on erlang:now/0
(tiger@durin)50&gt; %% The trace pattern is a simple match spec
(tiger@durin)50&gt; %% indicating that the return value should be
(tiger@durin)50&gt; %% traced. Refer to the reference_manual for
(tiger@durin)50&gt; %% the full list of match spec shortcuts
(tiger@durin)50&gt; %% available.
(tiger@durin)51&gt; <span class="input">ttb:tp(erlang,now,return).</span>
{ok,[{matched,tiger@durin,1},{saved,1}]}
(tiger@durin)52&gt; 
(tiger@durin)52&gt; %% I run my test (i.e. send a message to
(tiger@durin)52&gt; %% my new process)
(tiger@durin)52&gt; <span class="input">Pid ! self().</span>
&lt;0.72.0&gt;
(tiger@durin)53&gt; 
(tiger@durin)53&gt; %% And then I have to stop ttb in order to flush
(tiger@durin)53&gt; %% the trace port buffer
(tiger@durin)53&gt; <span class="input">ttb:stop([return, {fetch_dir, "fetch"}]).</span>
{stopped, "fetch"}
(tiger@durin)54&gt; 
(tiger@durin)54&gt; %% Finally I format my trace log
(tiger@durin)54&gt; <span class="input">ttb:format("fetch").</span>
({&lt;0.125.0&gt;,{m,f,0},tiger@durin}) call erlang:now()
({&lt;0.125.0&gt;,{m,f,0},tiger@durin}) returned from erlang:now/0 -&gt;
{1031,133451,667611}
({&lt;0.125.0&gt;,{m,f,0},tiger@durin}) &lt;0.72.0&gt; !
{&lt;0.125.0&gt;,{1031,133451,667611}}
ok</pre><h4>Build Your Own Tool</h4><p>The following example shows a simple tool for "debug tracing",
that is, tracing of function calls with return values:</p><pre><code class="">
-module(mydebug).
-export([start/0,trc/1,stop/0,format/1]).
-export([print/4]).
%% Include ms_transform.hrl so that I can use dbg:fun2ms/2 to
%% generate match specifications.
-include_lib("stdlib/include/ms_transform.hrl").
%%% -------------Tool API-------------
%%% ----------------------------------
%%% Star the "mydebug" tool
start() -&gt;
    %% The options specify that the binary log shall be named
    %% &lt;Node&gt;-debug_log and that the print/4 function in this
    %% module shall be used as format handler
    ttb:tracer(all,[{file,"debug_log"},{handler,{{?MODULE,print},0}}]),
    %% All processes (existing and new) shall trace function calls
    %% We want trace messages to be sorted upon format, which requires
    %% timestamp flag. The flag is however enabled by default in ttb.
    ttb:p(all,call).

%%% Set trace pattern on function(s)
trc(M) when is_atom(M) -&gt;
    trc({M,'_','_'});
trc({M,F}) when is_atom(M), is_atom(F) -&gt;
    trc({M,F,'_'});
trc({M,F,_A}=MFA) when is_atom(M), is_atom(F) -&gt;
    %% This match spec shortcut specifies that return values shall
    %% be traced.
    MatchSpec = dbg:fun2ms(fun(_) -&gt; return_trace() end),
    ttb:tpl(MFA,MatchSpec).

%%% Format a binary trace log
format(Dir) -&gt;
    ttb:format(Dir).

%%% Stop the "mydebug" tool
stop() -&gt;
    ttb:stop(return).

%%% --------Internal functions--------
%%% ----------------------------------
%%% Format handler
print(_Out,end_of_trace,_TI,N) -&gt;
    N;
print(Out,Trace,_TI,N) -&gt;
    do_print(Out,Trace,N),
    N+1.

do_print(Out,{trace_ts,P,call,{M,F,A},Ts},N) -&gt;
    io:format(Out,
              "~w: ~w, ~w:~n"
              "Call      : ~w:~w/~w~n"
              "Arguments :~p~n~n",
              [N,Ts,P,M,F,length(A),A]);
do_print(Out,{trace_ts,P,return_from,{M,F,A},R,Ts},N) -&gt;
    io:format(Out,
              "~w: ~w, ~w:~n"
              "Return from  : ~w:~w/~w~n"
              "Return value :~p~n~n",
              [N,Ts,P,M,F,A,R]).      </code></pre><p>To distinguish trace logs produced with this tool from other
logs, option <strong>file</strong> is used in 
<a href="./ttb#tracer/2">ttb#tracer/2</a>. The
logs are therefore fetched to a directory named
<strong>ttb_upload_debug_log-YYYYMMDD-HHMMSS</strong>
</p><p>By using option <strong>handler</strong> when starting the tracer,
the information about how to format the file is stored in the
trace information file (<strong>.ti</strong>). This is not necessary, as
it can be specified when formatting instead. However, It can
be useful if you, for example, want to format trace logs automatically 
using option <strong>format</strong> in <strong>ttb:stop/1</strong>. Also, you do not need 
any knowledge of the content of a binary log to format it the way it 
is intended. If option <strong>handler</strong> is specified both when starting 
the tracer and when formatting, the one specified when formatting is used.
</p><p>Trace flag <strong>call</strong> is set on all processes. This
means that any function activated with command <strong>trc/1</strong>
is traced on all existing and new processes.
</p><h4>Running Trace Tool Builder against Remote Node</h4><p>The Observer application might not always be available on the
node to be traced (in the following called the "traced
node"). However, Trace Tool Builder can still be run from
another node (in the following called the "trace control node") as
long as the following is fulfilled:
</p><ul><li>The Observer application is available on the trace control node.</li><li>The Runtime_Tools application is available on both the trace control node and the traced node.</li></ul><p>If Trace Tool Builder is to be used against a remote node,
it is highly recommended to start the trace control node as
<em>hidden</em>. This way it can connect to the traced node
without being "seen" by it, that is, if the <strong>nodes()</strong>
BIF is called on the traced node, the trace control node does not
show. To start a hidden node, add option <strong>-hidden</strong> to the
<strong>erl</strong> command, for example:</p><pre>
% <span class="input">erl -sname trace_control -hidden</span></pre><h4>Diskless Node</h4><p>If the traced node is diskless, <strong>ttb</strong> must be started from
a trace control node with disk access, and option <strong>file</strong>
must be specified to function <strong>tracer/2</strong> with value
<strong>{local, File}</strong>, for example:</p><pre>
(trace_control@durin)1&gt; <span class="input">ttb:tracer(mynode@diskless, {file,{local,{wrap,"mytrace"}}}).</span>
{ok,[mynode@diskless]}</pre><h4>More Tracing Options</h4><p>When setting up a trace, the following features can also be activated:</p><ul><li>Time-constrained tracing</li><li>Overload protection</li><li>Autoresume</li><li><strong>dbg</strong> mode</li></ul><h4>Time-Constrained Tracing</h4><p>It can sometimes be helpful to enable trace for a
specified period of time (for example, to monitor a system for 24 hours
or half a second). This can be done with option
<strong>{timer, TimerSpec}</strong>. If <strong>TimerSpec</strong> has the
form of <strong>MSec</strong>, the trace is stopped after <strong>MSec</strong>
milliseconds using 
<a href="./ttb#stop/0">ttb#stop/0</a>. If more 
options are provided (<strong>TimerSpec = {MSec, Opts}</strong>), 
<a href="./ttb#stop/1">ttb#stop/1</a>
is called instead with <strong>Opts</strong> as argument.</p><p>The timer is started with 
<a href="./ttb#p/2">ttb#p/2</a>, so any trace patterns 
must be set up in advance. 
<a href="./ttb#start_trace/4">ttb#start_trace/4</a>
always sets up all patterns before invoking <strong>ttb:p/2</strong>.</p><p>The following example shows how to set up a trace that is
automatically stopped and formatted after 5 seconds:
</p><pre>
(tiger@durin)1&gt; <span class="input">ttb:start_trace([node()], [{erlang, now,[]}], {all, call}, [{timer, {5000, format}}]).</span></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Because of network and processing delays, the period
of tracing is approximate.</p></div><h4>Overload Protection</h4><p>When tracing live systems, always take special care to not
overload a node with too heavy tracing. <strong>ttb</strong> provides
option <strong>overload</strong> to address this problem.</p><p><strong>{overload, MSec, Module, Function}</strong> instructs the <strong>ttb</strong> back end
(a part of the <a href="./index">Runtime_Tools</a>
application) to perform overload check every <strong>MSec</strong> millisecond.
If the check (named <strong>Module:Function(check)</strong>) returns
<strong>true</strong>, tracing is disabled on the selected node.</p><p>Overload protection activated on one node does not
affect other nodes, where the tracing continues as normal.
<strong>ttb:stop/0,1</strong> fetches data from all clients, including everything
collected before the activation of overload protection.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
It is not allowed to change trace details 
(with <strong>ttb:p</strong> and <strong>ttb:tp/tpl...</strong>) once overload 
protection is activated in one of the traced nodes. This is to 
avoid trace setup being inconsistent between nodes.</p></div><p><strong>Module:Function</strong> provided with option <strong>overload</strong> must
handle three calls: <strong>init</strong>, <strong>check</strong>, and <strong>stop</strong>. <strong>init</strong>
and <strong>stop</strong> allow some setup and teardown required by
the check. An overload check module can look as follows:
</p><pre><code class="">
-module(overload).
-export([check/1]).

check(init) -&gt;
    Pid = sophisticated_module:start(),
    put(pid, Pid);
check(check) -&gt;
    get(pid) ! is_overloaded,
    receive
        Reply -&gt;
            Reply
    after 5000 -&gt;
            true
    end;
check(stop) -&gt;
    get(pid) ! stop.</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
<strong>check</strong> is always called by the same process, so <strong>put</strong> and
<strong>get</strong> are possible.</p></div><h4>Autoresume</h4><p>A node can crash (probably a buggy one, hence traced).
Use <strong>resume</strong> to resume tracing on the node automatically 
when it gets back. The failing node then tries to reconnect
to trace control node when <strong>Runtime_Tools</strong> is started.
This implies that <strong>Runtime_Tools</strong> must be included in
the startup chain of other nodes (if not, you can still
resume tracing by starting <strong>Runtime_Tools</strong> manually,
that is, by an RPC call).</p><p>To not lose the data that the failing node stored
up to the point of crash, the control node tries to fetch
it before restarting trace. This must occur within the allowed
time frame, otherwise it is aborted (default is 10 seconds, but it
can be changed with <strong>{resume, MSec}</strong>). The data fetched 
this way is then merged with all other traces.</p><p>The autostart feature requires more data to be stored on
traced nodes. By default, the data is stored automatically
to the file named "ttb_autostart.bin" in the currect working directory
(cwd) of the traced node.
Users can change this behaviour (that is, on diskless
nodes) by specifying their own module to handle autostart data
storage and retrieval (<strong>ttb_autostart_module</strong>
environment variable of <strong>runtime_tools</strong>). For information 
about the API, see module
<a href="ttb">ttb</a>. 
The following example shows the default handler:</p><pre><code class="">
-module(ttb_autostart).
-export([read_config/0,
         write_config/1,
         delete_config/0]).

-define(AUTOSTART_FILENAME, "ttb_autostart.bin").

delete_config() -&gt;
    file:delete(?AUTOSTART_FILENAME).

read_config() -&gt;
    case file:read_file(?AUTOSTART_FILENAME) of
        {ok, Data} -&gt; {ok, binary_to_term(Data)};
        Error      -&gt; Error
    end.

write_config(Data) -&gt;
    file:write_file(?AUTOSTART_FILENAME, term_to_binary(Data)).</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Remember that file trace ports buffer the data
by default. If the node crashes, trace messages are not
flushed to the binary log. If the risk of failure is
high, it can be a good idea to flush the buffers every 
now and then automatically. Passing <strong>{flush, MSec}</strong>
as an option of <strong>ttb:tracer/2</strong> flushes all buffers
every <strong>MSec</strong> millisecond.</p></div><h4>dbg Mode</h4><p>Option <strong>{shell, ShellType}</strong> allows making <strong>ttb</strong>
operation similar to 
<a href="./dbg">runtime_tools/dbg</a>.
Using <strong>{shell, true}</strong>
displays all trace messages in the shell before storing them.
<strong>{shell, only}</strong> additionally disables message storage
(making the tool to behave exactly like <strong>dbg</strong>). This is 
allowed only with IP trace ports (<strong>{trace, {local, File}}</strong>).
</p><p>Command <strong>ttb:tracer(dbg)</strong> is a shortcut for the pure
<strong>dbg</strong> mode (<strong>{shell, only}</strong>).</p><a name="trace_info"></a><h4>Trace Information and File .ti</h4><p>In addition to the trace log file(s), a file with extension
<strong>.ti</strong> is created when Trace Tool Builder is started. This
is the trace information file. It is a binary file, which
contains the process information, trace flags used, the name of
the node to which it belongs, and all information written with
function 
<a href="./ttb#write_trace_info/2">ttb#write_trace_info/2</a>. 
<strong>.ti</strong> files are always fetched with other logs when the trace is stopped.
</p><p>Except for the process information, everything in the trace
information file is passed on to the handler function when
formatting. Parameter <strong>TI</strong> is a list of
<strong>{Key,ValueList}</strong> tuples. The keys <strong>flags</strong>,
<strong>handler</strong>, <strong>file</strong>, and <strong>node</strong> are used for
information written directly by <strong>ttb</strong>.
</p><p>Information to the trace information file by
can be added by calling 
<a href="./ttb#write_trace_info/2">ttb#write_trace_info/2</a>. 
Notice that <strong>ValueList</strong>
always is a list, and if you call <strong>write_trace_info/2</strong>
many times with the same <strong>Key</strong>, the <strong>ValueList</strong> is
extended with a new value each time.
</p><p><em>Example:</em></p><p><strong>ttb:write_trace_info(mykey,1)</strong> gives the entry
<strong>{mykey,[1]}</strong> in <strong>TI</strong>. Another call,
<strong>ttb:write_trace_info(mykey,2)</strong>, changes this entry to
<strong>{mykey,[1,2]}</strong>.
</p><h4>Wrap Logs</h4><p>If you want to limit the size of the trace logs, you can use
wrap logs. This works almost like a circular buffer. You can
specify the maximum number of binary logs and the maximum size of
each log. <strong>ttb</strong> then creates a new binary log each time a log
reaches the maximum size. When the maximum number of logs are
reached, the oldest log is deleted before a new one is created.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The overall size of data generated by <strong>ttb</strong> can be greater
than the wrap specification suggests. If a traced node restarts
and autoresume is enabled, the old wrap log is always stored and
a new one is created.
</p></div><p>Wrap logs can be formatted one by one or all at once. See
<a href="#format">Formatting</a>.
</p><a name="format"></a><h4>Formatting</h4><p>Formatting can be done automatically when stopping <strong>ttb</strong>
(see section
<a href="#fetch_format">Automatically Collect and Format Logs from All Nodes</a>), or explicitly by calling function
<strong>ttb:format/1,2</strong>.
</p><p>Formatting means to read a binary log and present it in a
readable format. You can use the default format handler in
<strong>ttb</strong> to present each trace message as a line of text, or
write your own handler to make more complex interpretations of the
trace information. You can also use application ET to
present the trace log graphically (see section
<a href="#et_viewer">Presenting Trace Logs with Event Tracer</a>).
</p><p>The first argument to <strong>ttb:format/1,2</strong> specifies which
binary log(s) to format. This is usually the name of a directory
that <strong>ttb</strong> created during log fetch. Unless option 
<strong>disable_sort</strong> is provided, the logs from different files 
are always sorted according to time-stamp in traces.
</p><p>The second argument to <strong>ttb:format/2</strong> is a list of
options as follows:
</p><dl><dt><strong>out</strong></dt><dd><p>Specifies the destination to write the formatted text. 
Default destination is <strong>standard_io</strong>, but a filename can 
also be specified.</p></dd><dt><strong>handler</strong></dt><dd><p>Specifies the format handler to use. If this option is 
not specified, option <strong>handler</strong> that is specified when starting
the tracer is used. If option <strong>handler</strong> is not specified
when starting the tracer either, a default handler is used, which
prints each trace message as a text line.</p></dd><dt><strong>disable_sort</strong></dt><dd><p>Indicates that the logs are not to be merged according to
time-stamp, but processed one file after another (this can be
a bit faster).</p></dd></dl><p>A format handler is a fun taking four arguments. This fun is
called for each trace message in the binary log(s). A simple
example that only prints each trace message can be as follows:</p><pre><code class="">
fun(Fd, Trace, _TraceInfo, State) -&gt;
   io:format(Fd, "Trace: ~p~n", [Trace]),
   State
end.    </code></pre><p>Here, <strong>Fd</strong> is the file descriptor for the destination file, or
the atom <strong>standard_io</strong>. <strong>_TraceInfo</strong> contains information
from the trace information file (see section
<a href="#trace_info">Trace Information and File .ti</a>). <strong>State</strong> is a state variable for the format
handler fun. The initial value of variable <strong>State</strong> is
specified with the handler option, for example:</p><pre><code class="">
ttb:format("tiger@durin-ttb", [{handler, {{Mod,Fun}, initial_state}}])
                                                     ^^^^^^^^^^^^^    </code></pre><p>Another format handler can be used to calculate the time spent by
the garbage collector:</p><pre><code class="">
fun(_Fd,{trace_ts,P,gc_start,_Info,StartTs},_TraceInfo,State) -&gt;
      [{P,StartTs}|State];
   (Fd,{trace_ts,P,gc_end,_Info,EndTs},_TraceInfo,State) -&gt;
      {value,{P,StartTs}} = lists:keysearch(P,1,State),
      Time = diff(StartTs,EndTs),
      io:format("GC in process ~w: ~w milliseconds~n", [P,Time]),
      State -- [{P,StartTs}]
end    </code></pre><p>A more refined version of this format handler is function
<strong>handle_gc/4</strong> in module <strong>multitrace.erl</strong>
included in directory <strong>src</strong> of the Observer application.
</p><p>The trace message is passed as the second argument (<strong>Trace</strong>).
The possible values of <strong>Trace</strong> are the following:</p><ul><li>All trace messages described in  <a href="../erts/erlang#trace/3">erts/erlang#trace/3</a> </li><li><strong>{drop, N}</strong> if IP tracer is used (see  <a href="../runtime_tools/dbg#trace_port/2">runtime_tools/dbg#trace_port/2</a>) </li><li><strong>end_of_trace</strong> received once when all trace messages are processed</li></ul><p>By giving the format handler 
<a href="./ttb#get_et_handler/0">ttb#get_et_handler/0</a>, 
you can have the trace
log presented graphically with <strong>et_viewer</strong> in the ET
application (see section
<a href="#et_viewer">Presenting Trace Logs with Event Tracer</a>).
</p><p>You can always decide not to format the whole trace data contained
in the fetch directory, but analyze single files instead. To do so, 
a single file (or list of files) must be passed as the first argument 
to <strong>format/1,2</strong>.</p><p>Wrap logs can be formatted one by one or all at once. To
format one of the wrap logs in a set, specify the exact file name. 
To format the whole set of wrap logs, specify the name with <strong>*</strong>
instead of the wrap count.
</p><p><em>Example:</em></p><p>Start tracing:</p><pre>
(tiger@durin)1&gt; <span class="input">ttb:tracer(node(),{file,{wrap,"trace"}}).</span>
{ok,[tiger@durin]}
(tiger@durin)2&gt; <span class="input">ttb:p(...)</span>
...</pre><p>This gives a set of binary logs, for example:</p><pre><code class="">
tiger@durin-trace.0.wrp
tiger@durin-trace.1.wrp
tiger@durin-trace.2.wrp
...    </code></pre><p>Format the whole set of logs:</p><pre>
1&gt; <span class="input">ttb:format("tiger@durin-trace.*.wrp").</span>
....
ok
2&gt;    </pre><p>Format only the first log:</p><pre>
1&gt; <span class="input">ttb:format("tiger@durin-trace.0.wrp").</span>
....
ok
2&gt;    </pre><p>To merge all wrap logs from two nodes:</p><pre>
1&gt; <span class="input">ttb:format(["tiger@durin-trace.*.wrp","lion@durin-trace.*.wrp"]).</span>
....
ok
2&gt;    </pre><a name="et_viewer"></a><h4>Presenting Trace Logs with Event Tracer</h4><p>For detailed information about the Event Tracer, see the
<a href="./users_guide">ET</a> application.
</p><p>By giving the format handler 
<a href="./ttb#get_et_handler/0">ttb#get_et_handler/0</a>, 
you can have the trace log presented graphically with 
<strong>et_viewer</strong> in the ET application.
<strong>ttb</strong> provides filters that can be selected from the 
menu <em>Filter</em> in the <strong>et_viewer</strong> window. The filters 
are names according to the type of actors they present 
(that is, what each vertical line in the sequence diagram represents). 
Interaction between actors is shown as red arrows between two 
vertical lines, and activities within an actor are shown as 
blue text to the right of the actors line.
</p><p>The <strong>processes</strong> filter is the only filter showing all 
trace messages from a trace log. Each vertical line in
the sequence diagram represents a process. Erlang messages,
spawn, and link/unlink are typical interactions between
processes. Function calls, scheduling, and garbage collection, 
are typical activities within a process. <strong>processes</strong> is 
the default filter.
</p><p>The remaining filters only show function calls and
function returns. All other trace message are discarded. To get
the most out of these filters, <strong>et_viewer</strong> must know
the caller of each function and the time of return. This can be
obtained using both the <strong>call</strong> and <strong>return_to</strong>
flags when tracing. Notice that flag <strong>return_to</strong> only
works with local call trace, that is, when trace patterns are set
with <strong>ttb:tpl</strong>.
</p><p>The same result can be obtained by using the flag <strong>call</strong>
only and setting a match specification on local or
global function calls as follows:</p><pre>
1&gt; <span class="input">dbg:fun2ms(fun(_) -&gt; return_trace(),message(caller()) end).</span>
[{'_',[],[{return_trace},{message,{caller}}]}]</pre><p>This must however be done with care, as function
<strong>{return_trace}</strong> in the match specification
destroys tail recursiveness.
</p><p>The <strong>modules</strong> filter shows each module as a vertical
line in the sequence diagram. External function calls/returns
are shown as interactions between modules, and internal function
calls/returns are shown as activities within a module.
</p><p>The <strong>functions</strong> filter shows each function as a vertical
line in the sequence diagram. A function calling itself is shown
as an activity within a function, and all other function calls
are shown as interactions between functions.
</p><p>The <strong>mods_and_procs</strong> and <strong>funcs_and_procs</strong> filters
are equivalent to the <strong>modules</strong> and <strong>functions</strong>
filters respectively, except that each module or function can
have many vertical lines, one for each process it resides on.
</p><p>In the following example, modules <strong>foo</strong> and <strong>bar</strong> are used:</p><pre><code class="">
-module(foo).
-export([start/0,go/0]).

start() -&gt;
    spawn(?MODULE, go, []).

go() -&gt;
    receive
        stop -&gt;
            ok;
        go -&gt;
            bar:f1(),
            go()
    end.</code></pre><pre><code class="">
-module(bar).
-export([f1/0,f3/0]).
f1() -&gt;
    f2(),
    ok.
f2() -&gt;
    spawn(?MODULE,f3,[]).
f3() -&gt;
    ok.</code></pre><p>Setting up the trace:</p><pre>
(tiger@durin)1&gt; %%First we retrieve the Pid to limit traced processes set
(tiger@durin)1&gt; <span class="input">Pid = foo:start().</span>
(tiger@durin)2&gt; %%Now we set up tracing
(tiger@durin)2&gt; <span class="input">ttb:tracer().</span>
(tiger@durin)3&gt; <span class="input">ttb:p(Pid, [call, return_to, procs, set_on_spawn]).</span>
(tiger@durin)4&gt; <span class="input">ttb:tpl(bar, []).</span>
(tiger@durin)5&gt; %%Invoke our test function and see output with et viewer
(tiger@durin)5&gt; <span class="input">Pid ! go.</span>
(tiger@durin)6&gt; <span class="input">ttb:stop({format, {handler, ttb:get_et_handler()}}).</span></pre><p>This renders a result similar to the following:
</p><img src="et_processes.gif" title="Filter: "processes""></img><img src="et_modsprocs.gif" title="Filter: "mods_and_procs""></img><p>Notice that function 
<a href="./ttb#start_trace/4">ttb#start_trace/4</a> 
can be used as help as follows:</p><pre>
(tiger@durin)1&gt; <span class="input">Pid = foo:start().</span>
(tiger@durin)2&gt; <span class="input">ttb:start_trace([node()], [{bar,[]}], {Pid, [call, return_to, procs, set_on_spawn]} {handler, ttb:get_et_handler()}).</span>
(tiger@durin)3&gt; <span class="input">Pid ! go.</span>
(tiger@durin)4&gt; <span class="input">ttb:stop(format).</span></pre><a name="fetch_format"></a><h4>Automatically Collect and Format Logs from All Nodes</h4><p>By default,
<a href="./ttb#stop/1">ttb#stop/1</a> fetches trace logs 
and trace information files from all nodes. The logs are stored in a
new directory named <strong>ttb_upload-Filename-Timestamp</strong> under the 
working directory of the trace control node. Fetching can be disabled 
by providing option <strong>nofetch</strong> to <strong>ttb:stop/1</strong>. The user can
specify a fetch directory by passing option <strong>{fetch_dir, Dir}</strong>.
</p><p>If option <strong>format</strong> is specified to <strong>ttb:stop/1</strong>, the
trace logs are automatically formatted after tracing is
stopped.
</p><h4>History and Configuration Files</h4><p>For the tracing functionality,
<a href="./dbg">runtime_tools/dbg</a>
can be used instead
of <strong>ttb</strong> for setting trace flags on processes and trace
patterns for call trace, that is, the functions 
<strong>p</strong>, <strong>tp</strong>, <strong>tpl</strong>, <strong>ctp</strong>, <strong>ctpl</strong>, and <strong>ctpg</strong>. Only the
following two things are added by <strong>ttb</strong> for these functions:</p><ul><li>All calls are stored in the history buffer and can be recalled and stored in a configuration file. This makes it easy to set up the same trace environment, for example, if you  want to compare two test runs. It also reduces the amount of typing when using <strong>ttb</strong> from the Erlang shell.</li><li>Shortcuts are provided for the most common match specifications (to not force you to use <a href="../runtime_tools/dbg#fun2ms/1">runtime_tools/dbg#fun2ms/1</a>  continually).</li></ul><p>Use 
<a href="./ttb#list_history/0">ttb#list_history/0</a> 
to see the content of the history buffer and 
<a href="./ttb#run_history/1">ttb#run_history/1</a>
to re-execute one of the entries.
</p><p>The main purpose of the history buffer is the possibility to
create configuration files. Any function stored in the history
buffer can be written to a configuration file and used for
creating a specific configuration at any time with a single
function call.
</p><p>A configuration file is created or extended with
<a href="./ttb#write_config/2">ttb#write_config/2</a>. 
Configuration files are binary files
and can therefore only be read and written with functions provided
by <strong>ttb</strong>.
</p><p>The complete content of the history buffer can be written to a
configuration file by calling
<strong>ttb:write_config(ConfigFile,all)</strong>. Selected entries from 
the history can be written by calling
<strong>ttb:write_config(ConfigFile,NumList)</strong>, where
<strong>NumList</strong> is a list of integers pointing out the history
entries to write. Moreover, the history buffer is always dumped
to <strong>ttb_last_config</strong> when <strong>ttb:stop/0,1</strong> is called.
</p><p>User-defined entries can also be written to a configuration file 
by calling function
<strong>ttb:write_config(ConfigFile,ConfigList)</strong>, where
<strong>ConfigList</strong> is a list of <strong>{Module,Function,Args}</strong>.
</p><p>Any existing file <strong>ConfigFile</strong> is deleted and a new file
is created when <strong>write_config/2</strong> is called. Option
<strong>append</strong> can be used to add something at the end
of an existing configuration file, for example,
<strong>ttb:write_config(ConfigFile,What,[append])</strong>.
</p><p><em>Example:</em></p><p>See the content of the history buffer:</p><pre>
(tiger@durin)191&gt; <span class="input">ttb:tracer().</span>
{ok,[tiger@durin]}
(tiger@durin)192&gt; <span class="input">ttb:p(self(),[garbage_collection,call]).</span>
{ok,{[&lt;0.1244.0&gt;],[garbage_collection,call]}}
(tiger@durin)193&gt; <span class="input">ttb:tp(ets,new,2,[]).</span>
{ok,[{matched,1}]}
(tiger@durin)194&gt; <span class="input">ttb:list_history().</span>
[{1,{ttb,tracer,[tiger@durin,[]]}},
 {2,{ttb,p,[&lt;0.1244.0&gt;,[garbage_collection,call]]}},
 {3,{ttb,tp,[ets,new,2,[]]}}]</pre><p>Execute an entry from the history buffer:</p><pre>
(tiger@durin)195&gt; <span class="input">ttb:ctp(ets,new,2).</span>
{ok,[{matched,1}]}
(tiger@durin)196&gt; <span class="input">ttb:list_history().</span>
[{1,{ttb,tracer,[tiger@durin,[]]}},
 {2,{ttb,p,[&lt;0.1244.0&gt;,[garbage_collection,call]]}},
 {3,{ttb,tp,[ets,new,2,[]]}},
 {4,{ttb,ctp,[ets,new,2]}}]
(tiger@durin)197&gt; <span class="input">ttb:run_history(3).</span>
ttb:tp(ets,new,2,[]) -&gt;
{ok,[{matched,1}]}</pre><p>Write the content of the history buffer to a configuration
file:</p><pre>
(tiger@durin)198&gt; <span class="input">ttb:write_config("myconfig",all).</span>
ok
(tiger@durin)199&gt; <span class="input">ttb:list_config("myconfig").</span>
[{1,{ttb,tracer,[tiger@durin,[]]}},
 {2,{ttb,p,[&lt;0.1244.0&gt;,[garbage_collection,call]]}},
 {3,{ttb,tp,[ets,new,2,[]]}},
 {4,{ttb,ctp,[ets,new,2]}},
 {5,{ttb,tp,[ets,new,2,[]]}}]</pre><p>Extend an existing configuration:</p><pre>
(tiger@durin)200&gt; <span class="input">ttb:write_config("myconfig",[{ttb,tp,[ets,delete,1,[]]}], [append]).</span>
ok
(tiger@durin)201&gt; <span class="input">ttb:list_config("myconfig").</span>
[{1,{ttb,tracer,[tiger@durin,[]]}},
 {2,{ttb,p,[&lt;0.1244.0&gt;,[garbage_collection,call]]}},
 {3,{ttb,tp,[ets,new,2,[]]}},
 {4,{ttb,ctp,[ets,new,2]}},
 {5,{ttb,tp,[ets,new,2,[]]}},
 {6,{ttb,tp,[ets,delete,1,[]]}}]</pre><p>Go back to a previous configuration after stopping Trace Tool
Builder:</p><pre>
(tiger@durin)202&gt; <span class="input">ttb:stop().</span>
ok
(tiger@durin)203&gt; <span class="input">ttb:run_config("myconfig").</span>
ttb:tracer(tiger@durin,[]) -&gt;
{ok,[tiger@durin]}

ttb:p(&lt;0.1244.0&gt;,[garbage_collection,call]) -&gt;
{ok,{[&lt;0.1244.0&gt;],[garbage_collection,call]}}

ttb:tp(ets,new,2,[]) -&gt;
{ok,[{matched,1}]}

ttb:ctp(ets,new,2) -&gt;
{ok,[{matched,1}]}

ttb:tp(ets,new,2,[]) -&gt;
{ok,[{matched,1}]}

ttb:tp(ets,delete,1,[]) -&gt;
{ok,[{matched,1}]}

ok</pre><p>Write selected entries from the history buffer to a
configuration file:</p><pre>
(tiger@durin)204&gt; <span class="input">ttb:list_history().</span>
[{1,{ttb,tracer,[tiger@durin,[]]}},
 {2,{ttb,p,[&lt;0.1244.0&gt;,[garbage_collection,call]]}},
 {3,{ttb,tp,[ets,new,2,[]]}},
 {4,{ttb,ctp,[ets,new,2]}},
 {5,{ttb,tp,[ets,new,2,[]]}},
 {6,{ttb,tp,[ets,delete,1,[]]}}]
(tiger@durin)205&gt; <span class="input">ttb:write_config("myconfig",[1,2,3,6]).</span>
ok
(tiger@durin)206&gt; <span class="input">ttb:list_config("myconfig").</span>
[{1,{ttb,tracer,[tiger@durin,[]]}},
 {2,{ttb,p,[&lt;0.1244.0&gt;,[garbage_collection,call]]}},
 {3,{ttb,tp,[ets,new,2,[]]}},
 {4,{ttb,tp,[ets,delete,1,[]]}}]
(tiger@durin)207&gt;</pre><h4>Sequential Tracing</h4><p>To learn what sequential tracing is and how it can be used,
see the Reference Manual for
<a href="./seq_trace">kernel/seq_trace</a>.
</p><p>The support for sequential tracing provided by Trace Tool
Builder includes the following:</p><ul><li>Initiation of the system tracer. This is automatically done when a trace port is started with  <a href="./ttb#tracer/0">ttb#tracer/0</a>.</li><li>Creation of match specifications that activates sequential tracing.</li></ul><p>Starting sequential tracing requires that a tracer is
started with function <strong>ttb:tracer/0,1,2</strong>. Sequential
tracing can then be started in either of the following ways:
</p><ul><li>Through a trigger function with a match specification  created with  <a href="./ttb#seq_trigger_ms/0">ttb#seq_trigger_ms/0</a>.</li><li>Directly by using module <a href="./seq_trace">kernel/seq_trace</a>.</li></ul><p><em>Example 1:</em></p><p>In the following example, function
<strong>dbg:get_tracer/0</strong> is used as trigger for sequential
tracing:</p><pre>
(tiger@durin)110&gt; <span class="input">ttb:tracer().</span>
{ok,[tiger@durin]}
(tiger@durin)111&gt; <span class="input">ttb:p(self(),call).</span>
{ok,{[&lt;0.158.0&gt;],[call]}}
(tiger@durin)112&gt; <span class="input">ttb:tp(dbg,get_tracer,0,ttb:seq_trigger_ms(send)).</span>
{ok,[{matched,1},{saved,1}]}
(tiger@durin)113&gt; <span class="input">dbg:get_tracer(), seq_trace:reset_trace().</span>
true
(tiger@durin)114&gt; <span class="input">ttb:stop(format).</span>
({&lt;0.158.0&gt;,{shell,evaluator,3},tiger@durin}) call dbg:get_tracer()
SeqTrace [0]: ({&lt;0.158.0&gt;,{shell,evaluator,3},tiger@durin})
{&lt;0.237.0&gt;,dbg,tiger@durin} ! {&lt;0.158.0&gt;,{get_tracer,tiger@durin}}
[Serial: {0,1}]
SeqTrace [0]: ({&lt;0.237.0&gt;,dbg,tiger@durin})
{&lt;0.158.0&gt;,{shell,evaluator,3},tiger@durin} ! {dbg,{ok,#Port&lt;0.222&gt;}}
[Serial: {1,2}]
ok
(tiger@durin)116&gt;</pre><p><em>Example 2:</em></p><p>Starting sequential tracing with a trigger is more
useful if the trigger function is not called directly from the
shell, but rather implicitly within a larger system. When
calling a function from the shell, it is simpler to start
sequential tracing directly, for example, as follows:</p><pre>
(tiger@durin)116&gt; <span class="input">ttb:tracer().</span>
{ok,[tiger@durin]}
(tiger@durin)117&gt; <span class="input">seq_trace:set_token(send,true), dbg:get_tracer(), seq_trace:reset_trace().</span>
true
(tiger@durin)118&gt; <span class="input">ttb:stop(format).</span>
SeqTrace [0]: ({&lt;0.158.0&gt;,{shell,evaluator,3},tiger@durin})
{&lt;0.246.0&gt;,dbg,tiger@durin} ! {&lt;0.158.0&gt;,{get_tracer,tiger@durin}}
[Serial: {0,1}]
SeqTrace [0]: ({&lt;0.246.0&gt;,dbg,tiger@durin})
{&lt;0.158.0&gt;,{shell,evaluator,3},tiger@durin} ! {dbg,{ok,#Port&lt;0.229&gt;}}
[Serial: {1,2}]
ok
(tiger@durin)120&gt;</pre><p>In both previous examples, <strong>seq_trace:reset_trace/0</strong>
resets the trace token immediately after the traced function
to avoid many trace messages because of the printouts in
the Erlang shell.
</p><p>All functions in module <strong>seq_trace</strong>, except
<strong>set_system_tracer/1</strong>, can be used after the trace port
is started with <strong>ttb:tracer/0,1,2</strong>.
</p><h4>Multipurpose Trace Tool</h4><p>Module <strong>multitrace</strong> in
directory <strong>src</strong> of the Observer application provides a
small tool with three possible trace settings. The trace messages
are written to binary files, which can be formatted with
function <strong>multitrace:format/1,2</strong>:
</p><dl><dt><strong>multitrace:debug(What)</strong></dt><dd><p>Start calltrace on all processes and trace the specified
function(s). The format handler used is
<strong>multitrace:handle_debug/4</strong> that prints each call and
returns. <strong>What</strong> must be an item or a list of items to trace,
specified on the format <strong>{Module,Function,Arity}</strong>,
<strong>{Module,Function}</strong>, or only <strong>Module</strong>.</p></dd><dt><strong>multitrace:gc(Procs)</strong></dt><dd><p>Trace garbage collection on the specified process(es). The
format handler used is <strong>multitrace:handle_gc/4</strong> that
prints start, stop, and the time spent for each garbage collection.</p></dd><dt><strong>multitrace:schedule(Procs)</strong></dt><dd><p>Trace in-scheduling and out-scheduling on the specified process(es). 
The format handler used is <strong>multitrace:handle_schedule/4</strong> that
prints each in-scheduling and out-scheduling with process, time-stamp, and
current function. It also prints the total time each traced
process was scheduled in.</p></dd></dl><h4>Introduction</h4><p>Erlang Top, <strong>etop</strong>, is a tool for presenting information
about Erlang processes similar to the information presented by
<strong>top</strong> in UNIX.
</p><h4>Getting Started</h4><p>Start Erlang Top in either of the following ways:</p><ul><li>Use script <strong>etop</strong>.</li><li>Use batch file <strong>etop.bat</strong>, for example,  <strong>etop -node tiger@durin</strong>.</li></ul><h4>Output</h4><p>The output from Erlang Top is as follows:</p><pre><code class="">
========================================================================================
 tiger@durin                                                               13:40:32
 Load:  cpu         0               Memory:  total        1997    binary         33
        procs     197                        processes       0    code          173
        runq      135                        atom         1002    ets            95

Pid            Name or Initial Func    Time    Reds  Memory    MsgQ Current Function
----------------------------------------------------------------------------------------
&lt;127.23.0&gt;     code_server                0   59585   78064       0 gen_server:loop/6   
&lt;127.21.0&gt;     file_server_2              0   36380   44276       0 gen_server:loop/6   
&lt;127.2.0&gt;      erl_prim_loader            0   27962    3740       0 erl_prim_loader:loop
&lt;127.9.0&gt;      kernel_sup                 0    6998    4676       0 gen_server:loop/6   
&lt;127.17.0&gt;     net_kernel                62    6018    3136       0 gen_server:loop/6   
&lt;127.0.0&gt;      init                       0    4156    4352       0 init:loop/1         
&lt;127.16.0&gt;     auth                       0    1765    1264       0 gen_server:loop/6   
&lt;127.18.0&gt;     inet_tcp_dist:accept       0     660    1416       0 prim_inet:accept0/2 
&lt;127.5.0&gt;      application_controll       0     569    6756       0 gen_server:loop/6   
&lt;127.137.0&gt;    net_kernel:do_spawn_       0     553    5840       0 dbg:do_relay_1/1    
========================================================================================
    </code></pre><p>The header includes some system information:
</p><dl><dt><strong>Load</strong></dt><dd> <dl><dt><strong>cpu</strong></dt><dd><p><strong>Runtime/Wallclock</strong>, that is, the percentage of time 
where the node has been active.</p></dd><dt><strong>procs</strong></dt><dd><p>The number of processes on the node.</p></dd><dt><strong>runq</strong></dt><dd><p>The number of processes that are ready to run.</p></dd></dl> </dd><dt><strong>Memory</strong></dt><dd><p>The memory allocated by the node in kilobytes.</p></dd></dl><p>For each process the following information is presented:
</p><dl><dt><strong>Time</strong></dt><dd><p>The runtime for the process, that is, the time that the process 
has been scheduled in.</p></dd><dt><strong>Reds</strong></dt><dd><p>The number of reductions executed on the process.</p></dd><dt><strong>Memory</strong></dt><dd><p>The size of the process in bytes, obtained by a
call to <strong>process_info(Pid,memory)</strong>.</p></dd><dt><strong>MsgQ</strong></dt><dd><p>The length of the message queue for the process.</p></dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><em>Time</em> and <em>Reds</em> can be presented as
accumulated values or as values since the last update.</p></div><h4>Configuration</h4><p>All configuration parameters can be set at start by adding
<strong>-OptName Value</strong> to the command line, for example:</p><pre>
% <span class="input">etop -node tiger@durin -setcookie mycookie -lines 15</span></pre><p>A list of all valid Erlang Top configuration parameters is available in
module <a href="etop">etop</a>.
</p><p>The parameters <strong>lines</strong>, <strong>interval</strong>, <strong>accumulate</strong>,
and <strong>sort</strong> can be changed during runtime with function 
<a href="./etop#config/2">etop#config/2</a>.
</p><p><em>Example:</em></p><p>Change configuration parameter <strong>lines</strong> with text-based presentation. 
Before the change, 10 lines are presented as follows:</p><pre><code class="">
========================================================================================
 tiger@durin                                                               10:12:39
 Load:  cpu         0               Memory:  total        1858    binary         33
        procs     191                        processes       0    code          173
        runq        2                        atom         1002    ets            95

Pid            Name or Initial Func    Time    Reds  Memory    MsgQ Current Function
----------------------------------------------------------------------------------------
&lt;127.23.0&gt;     code_server                0   60350   71176       0 gen_server:loop/6   
&lt;127.21.0&gt;     file_server_2              0   36380   44276       0 gen_server:loop/6   
&lt;127.2.0&gt;      erl_prim_loader            0   27962    3740       0 erl_prim_loader:loop
&lt;127.17.0&gt;     net_kernel                 0   13808    3916       0 gen_server:loop/6   
&lt;127.9.0&gt;      kernel_sup                 0    6998    4676       0 gen_server:loop/6   
&lt;127.0.0&gt;      init                       0    4156    4352       0 init:loop/1         
&lt;127.18.0&gt;     inet_tcp_dist:accept       0    2196    1416       0 prim_inet:accept0/2 
&lt;127.16.0&gt;     auth                       0    1893    1264       0 gen_server:loop/6   
&lt;127.43.0&gt;     ddll_server                0     582    3744       0 gen_server:loop/6   
&lt;127.5.0&gt;      application_controll       0     569    6756       0 gen_server:loop/6   
========================================================================================      </code></pre><p>Function <strong>etop:config/2</strong> is called to change the number of showed 
lines to 5:</p><pre>
&gt; <span class="input">etop:config(lines,5).</span>
ok</pre><p>After the change, 5 lines are presented as follows:</p><pre><code class="">
(etop@durin)2&gt; 
========================================================================================
 tiger@durin                                                               10:12:44
 Load:  cpu         0               Memory:  total        1859    binary         33
        procs     192                        processes       0    code          173
        runq        2                        atom         1002    ets            95

Pid            Name or Initial Func    Time    Reds  Memory    MsgQ Current Function
----------------------------------------------------------------------------------------
&lt;127.17.0&gt;     net_kernel               183      70    4092       0 gen_server:loop/6   
&lt;127.335.0&gt;    inet_tcp_dist:do_acc     141      22    1856       0 dist_util:con_loop/9
&lt;127.19.0&gt;     net_kernel:ticker/2      155       6    1244       0 net_kernel:ticker1/2
&lt;127.341.0&gt;    net_kernel:do_spawn_       0       0    5840       0 dbg:do_relay_1/1    
&lt;127.43.0&gt;     ddll_server                0       0    3744       0 gen_server:loop/6   
========================================================================================
      </code></pre><h4>Print to File</h4><p>At any time, the current Erlang Top display can be dumped to a
text file with function 
<a href="./etop#dump/1">etop#dump/1</a>.
</p><h4>Stop</h4><p>To stop Erlang Top, use function 
<a href="./etop#stop/0">etop#stop/0</a>.
</p><h4>Introduction</h4><p>The Crashdump Viewer is a WxWidgets based tool for browsing
Erlang crashdumps.
</p><h4>Getting Started</h4><p>The easiest way to start Crashdump Viewer is to use
shell script <strong>cdv</strong> with the full path to the
Erlang crashdump as argument. The script is located in
directory <strong>priv</strong> of the Observer application. This starts the
Crashdump Viewer GUI and loads the specified file. If no filename is
specified, a file dialog is opened where the file can be
selected.</p><p>Under Windows, the batch file <strong>cdv.bat</strong> can be used.</p><p>Crashdump Viewer can also be started from
an Erlang node by calling <a href="./crashdump_viewer#start/0">crashdump_viewer:start/0</a>
or <a href="./crashdump_viewer#start/1">crashdump_viewer:start/1</a>.</p><h4>GUI</h4><p>The GUI main window is opened when Crashdump Viewer has loaded a
crashdump. It contains a title bar, a menu bar,
information tabs, and a status bar.</p><p>The title bar shows the name of the currently loaded
crashdump.</p><p>The menu bar contains a <em>File</em> menu and a <em>Help</em>
menu. From the <em>File</em> menu, a new crashdump can be loaded or 
the tool can be terminated. From the <em>Help</em> menu, this User's Guide 
and section "How to interpret the Erlang crash dumps" from the
ERTS application can be opened. "How to interpret
the Erlang crash dumps" describes the raw crashdumps in
detail and includes information about each
field in the information pages."How to interpret the Erlang crash dumps" 
is also available in the OTP online documentation.</p><p>The status bar at the bottom of the window shows a warning
if the currently loaded dump is truncated.</p><p>The center area of the main window contains the information
tabs. Each tab displays information about a specific item or a
list of items. Select a tab by clicking the tab title.</p><p>From tabs displaying lists of items, for example, the
<em>Processes</em> tab or the <em>Ports</em> tab, a new window with 
more information can be opened by double-clicking a row or by right-
clicking the row and selecting an item from the drop-down
menu. The new window is called a detail window. Detail windows can
be opened for processes, ports, nodes, and modules.</p><p>The information shown in a detail window can contain
links to processes or ports. Clicking one of these links opens
the detail window for the process or port in question. If the
process or port resides on a remote node, no
information is available. Clicking the link then displays a dialog
where you can choose to open the detail window for the
remote node.
</p><p>Some tabs contain a left-hand menu where subitems of
the information area can be selected. Click one of the
rows, and the information is displayed in the right-hand
information area.</p><h4>Tab Content</h4><p>Each tab in the main window contains an information
page. If no information is found for an item, the page is
empty. The reason for not finding information about an item
can be the following:</p><ul><li>It is a dump from an old OTP release in which this item was not written.</li><li>The item was not present in the system at the point of failure.</li><li>The dump is truncated. In this case, a warning is displayed in the status bar of the main window.</li></ul><p>Even if some information about an item exists, there can be
empty fields if the dump originates from an old OTP release.</p><p>The value <strong>-1</strong> in any field means "unknown", and in most
cases it means that the dump was truncated somewhere around this
field.</p><p>The following sections describe some of the fields in the
information tabs. These are fields that do not exist
in the raw crashdump, or in some way differ from the fields in
the raw crashdump. For details about other fields, see
the 
<a href="./users_guide">ERTS User's Guide</a>, section
"How to interpret the Erlang crash dumps". That section can also
be opened from the <em>Help</em> menu in the main window.
There are also links from the following sections to related information 
in "How to interpret the Erlang crash dumps".</p><a name="general_info"></a><h4>General Tab</h4><p>Tab <em>General</em> shows a short overview
of the dump.</p><p>The following fields are not described in the ERTS
User's Guide:</p><dl><dt><strong>Crashdump created on</strong></dt><dd><p>Time of failure.</p></dd><dt><strong>Memory allocated</strong></dt><dd><p>The total number of bytes allocated, equivalent to
<strong>c:memory(total)</strong>.</p></dd><dt><strong>Memory maximum</strong></dt><dd><p>The maximum number of bytes that has been allocated during
the lifetime of the originating node. This is only shown if
the Erlang runtime system is run instrumented.</p></dd><dt><strong>Atoms</strong></dt><dd><p>If available in the dump, this is the total number of
atoms in the atom table. If the size of the atom table is
unavailable, the number of atoms visible in the dump is
displayed.</p></dd><dt><strong>Processes</strong></dt><dd><p>The number of processes visible in the dump.</p></dd><dt><strong>ETS tables</strong></dt><dd><p>The number of ETS tables visible in the dump.</p></dd><dt><strong>Funs</strong></dt><dd><p>The number of funs visible in the dump.</p></dd></dl><p>For details, see
<a href="../erts/crash_dump#general_info">General Information</a>
in section "How to Interpret the Erlang Crash Dumps" in ERTS.
</p><a name="processes"></a><h4>Processes Tab</h4><p>Tab <em>Processes</em> shows a list of all processes
found in the crashdump, including brief information about
each process. By default, the processes are sorted by their
pids. To sort by another topic, click the desired column heading.</p><p>Column <em>Memory</em> shows the 'Memory' field that was
added to crashdumps in Erlang/OTP R16B01. This is the total amount of memory
used by the process. For crashdumps from earlier releases, this
column shows the 'Stack+heap' field. The value is always in bytes.</p><p>To view detailed information about a specific process, double-
click the row in the list, or right-click the row and select
<em>Properties for &lt;pid&gt;</em>.</p><p>For details, see
<a href="../erts/crash_dump#processes">Process Information</a>
in section "How to Interpret the Erlang Crash Dumps" in ERTS.
</p><a name="ports"></a><h4>Ports Tab</h4><p>Tab <em>Ports</em> is similar to the <em>Processes</em>
tab, except it lists all ports found in the crashdump.</p><p>To view more details about a specific port, double-click the row
or right-click it and select <em>Properties for &lt;port&gt;</em>. From
the right-click menu, you can also select <em>Properties for &lt;pid&gt;</em>, where <strong>&lt;pid&gt;</strong> is the process connected to the
port.</p><p>For details, see
<a href="../erts/crash_dump#ports">Port Information</a>
in section "How to Interpret the Erlang Crash Dumps" in ERTS.
</p><a name="ets_tables"></a><a name="internal_ets_tables"></a><h4>ETS Tables Tab</h4><p>Tab <em>ETS Tables</em> shows all ETS table information
found in the dump. <em>Id</em> is the same as the 'Table' field
in the raw crashdump. <em>Memory</em> is the 'Words' field from the
raw crashdump translated into bytes. For tree tables, there is
no value in the 'Objects' field.</p><p>To open the detailed information page about the table, double-
click, or right-click the row and select <em>Properties for 'Identifier'</em>.</p><p>To open the detailed information page about the owner process
of an ETS table, right-click the row and select <em>Properties for &lt;pid&gt;</em>.</p><p>For details, see
<a href="../erts/crash_dump#ets_tables">ETS Tables</a>
in section "How to Interpret the Erlang Crash Dumps" in ERTS.
</p><a name="timers"></a><h4>Timers Tab</h4><p>Tab <em>Timers</em> shows all timer information found in
the dump.</p><p>To open the detailed information page about the owner process
of a timer, right-click the row and select <em>Properties for &lt;pid&gt;</em>.</p><p>Double-clicking a row in the <em>Timers</em> tab has no effect.</p><p>For details, see
<a href="../erts/crash_dump#timers">Timers</a>
in section "How to Interpret the Erlang Crash Dumps" in ERTS.
</p><a name="schedulers"></a><h4>Schedulers Tab</h4><p>Tab <em>Schedulers</em> shows all scheduler information
found in the dump.</p><p>To open the detailed information page about the scheduler,
double-click, or right-click the row and select <em>Properties for 'Identifier'</em>.</p><p>For details, see
<a href="../erts/crash_dump#scheduler">Scheduler Information</a>
in section "How to Interpret the Erlang Crash Dumps" in ERTS.
</p><a name="funs"></a><h4>Funs Tab</h4><p>Tab <em>Funs</em> shows all fun information found in the
dump.</p><p>To open the detailed information page about the module to which
the fun belongs, right-click the row and select <em>Properties for &lt;mod&gt;</em>.</p><p>Double-clicking a row in the <em>Funs</em> tab has no effect.</p><p>For details, see
<a href="../erts/crash_dump#funs">Fun Information</a>
in section "How to Interpret the Erlang Crash Dumps" in ERTS.
</p><a name="atoms"></a><h4>Atoms Tab</h4><p>Tab <em>Atoms</em> lists all atoms found in the dump. By
default the atoms are sorted in creation order from first to
last. This is opposite of the raw crashdump where atoms are listed
from last to first, meaning that if the dump was truncated in the
middle of the atom list, only the last created atoms are visible
in the <em>Atoms</em> tab.</p><p>For details, see
<a href="../erts/crash_dump#atoms">Atoms</a>
in section "How to Interpret the Erlang Crash Dumps" in ERTS.
</p><a name="distribution_info"></a><h4>Nodes Tab</h4><p>Tab <em>Nodes</em> shows a list of all external Erlang
nodes that are referenced from the crashdump.</p><p>If the page is empty, it means either of the following:</p><ul><li>The crashed node is not distributed.</li><li>The crashed node is distributed but has no references to other nodes.</li><li>The dump is truncated.</li></ul><p>If the node is distributed, all referenced nodes are
visible. Column <em>Connection type</em> shows if the node
is visible, hidden, or not connected. Visible nodes are alive nodes
with a living connection to the originating node. Hidden nodes are
the same as visible nodes, except they are started with flag
<strong>-hidden</strong>. Not connected nodes are nodes that are not
connected to the originating node anymore, but references
(that is, process or port identifiers) exist.</p><p>To see more detailed information about a node, double-click the
row, or right-click the row and select <em>Properties for node &lt;node&gt;</em>. From the right-click menu, you can also select
<em>Properties for &lt;port&gt;</em>, to open the detailed information
window for the controlling port.</p><p>In the detailed information window for a node, any existing
links and monitors between processes on the originating node and
the connected node are displayed. <em>Extra Info</em> can contain
debug information (that is, special information written if the
emulator is debug-compiled) or error information.</p><p>For details, see
<a href="../erts/crash_dump#distribution_info">Distribution Information</a>
in section "How to Interpret the Erlang Crash Dumps" in ERTS.
</p><a name="loaded_modules"></a><h4>Modules Tab</h4><p>Tab <em>Modules</em> lists all modules loaded
on the originating node, and the current code size. If old
code exists, the old size is also shown.</p><p>To view detailed information about a specific module, double-
click the row, or right-click it and select <em>Properties for &lt;mod&gt;</em>.</p><p>For details, see
<a href="../erts/crash_dump#loaded_modules">Loaded Module Information</a>
in section "How to Interpret the Erlang Crash Dumps" in ERTS.
</p><a name="memory"></a><h4>Memory Tab</h4><p>Tab <em>Memory</em> shows memory and allocator
information. From the left-hand menu you can select the following:</p><dl><dt><em>Memory</em></dt><dd><p>See
<a href="../erts/crash_dump#memory">Memory Information</a>
in section "How to Interpret the Erlang Crash Dumps" in ERTS.</p></dd><dt><em>Allocator Summary</em></dt><dd><p>This page presents a summary of values from all allocators underneath it.</p></dd><dt><em>&lt;Allocator&gt;</em></dt><dd><p>One entry per allocator. See
<a href="../erts/crash_dump#allocator">Allocator</a>
in section "How to Interpret the Erlang Crash Dumps" in ERTS.</p></dd><dt><em>Allocated Areas</em></dt><dd><p>See
<a href="../erts/crash_dump#allocated_areas">Allocated Areas</a>
in section "How to Interpret the Erlang Crash Dumps" in ERTS.</p></dd></dl><a name="internal_tables"></a><h4>Internal Tables Tab</h4><p>On tab <em>Internal Tables</em> you can from the
left-hand menu select <em>Hash Tables</em>, <em>Index Tables</em>, 
or <em>Internal ETS Tables</em>.</p><p>For details, see
<a href="../erts/crash_dump#internal_tables">Internal Table Information</a>
in section "How to Interpret the Erlang Crash Dumps" in ERTS.
</p><h3>Observer</h3><p>The Observer Application</p><p>The Observer application contains tools for tracing and
investigation of distributed systems.</p><h4>Configuration</h4><p>No configuration parameters are available for
this application.
</p><h3>observer</h3><p>A GUI tool for observing an Erlang system.</p><p>Observer is a graphical tool for observing the characteristics of
Erlang systems. The tool Observer displays system information, application
supervisor trees, process information, ETS tables, Mnesia tables,
and contains a front end for Erlang tracing with module
<a href="ttb">ttb</a>.
For details about how to get started, see the
<a href="observer_ug">observer_ug</a>.</p><h3>Functions</h3><h4>start() -&gt; ok</h4><p>Start the Observer GUI.</p><p>Starts the Observer GUI.
To stop the tool, close the window.
</p><h3>ttb</h3><p>A base for building trace tools for distributed systems.</p><p>The Trace Tool Builder, <strong>ttb</strong>, is a base for building trace
tools for distributed systems.
When using <strong>ttb</strong>, do not use module <strong>dbg</strong> in application
Runtime_Tools in parallel.</p><h3>Functions</h3><h4>start_trace(Nodes, Patterns, FlagSpec, Opts) -&gt; Result</h4><p>Start a trace port on each specified node.</p><ul><li><span class="v">Result = see p/2</span></li><li><span class="v">Nodes = see tracer/2</span></li><li><span class="v">Patterns = [tuple()]</span></li><li><span class="v">FlagSpec = {Procs, Flags}</span></li><li><span class="v">Proc = see p/2</span></li><li><span class="v">Flags = see p/2</span></li><li><span class="v">Opts = see tracer/2</span></li></ul><p>This function is a shortcut allowing to start a trace with one command. Each
tuple in <strong>Patterns</strong> is converted to a list, which in turn is passed to
<strong>ttb:tpl/2,3,4</strong>.</p><p>The call:</p><pre>
&gt; <span class="input">ttb:start_trace([Node, OtherNode], [{mod, foo, []}, {mod, bar, 2}], {all, call}, [{file, File}, {handler,{fun myhandler/4, S}}]).</span></pre><p> is equivalent to:</p><pre>
&gt; <span class="input">ttb:start_trace([Node, OtherNode], [{file, File}, {handler,{fun myhandler/4, S}}]), ttb:tpl(mod, foo, []), ttb:tpl(mod, bar, 2, []), ttb:p(all, call).</span></pre><h4>tracer() -&gt; Result</h4><p>Equivalent to tracer(node()).</p><p>Equivalent to <strong>tracer(node())</strong>.</p><h4>tracer(Shortcut) -&gt; Result</h4><p>Handy shortcuts for common tracing settings.</p><ul><li><span class="v">Shortcut = shell | dbg</span></li></ul><p>Handy shortcuts for common tracing settings.</p><p><strong>shell</strong> is equivalent to <strong>tracer(node(),[{file, {local, "ttb"}}, shell])</strong>.</p><p><strong>dbg</strong> is equivalent to <strong>tracer(node(),[{shell, only}])</strong>.</p><h4>tracer(Nodes) -&gt; Result</h4><p>Equivalent to tracer(Nodes,[]).</p><p>Equivalent to <strong>tracer(Nodes,[])</strong>.</p><h4>tracer(Nodes,Opts) -&gt; Result</h4><p>Start a trace port on each specified node.</p><ul><li><span class="v">Result = {ok, ActivatedNodes} | {error,Reason}</span></li><li><span class="v">Nodes   = atom() | [atom()] | all | existing | new</span></li><li><span class="v">Opts = Opt | [Opt]</span></li><li><span class="v">Opt = {file,Client} | {handler, FormatHandler} | {process_info,PI} | shell | {shell, ShellSpec} | {timer, TimerSpec} | {overload_check, {MSec, Module, Function}} | {flush, MSec} | resume | {resume, FetchTimeout} | {queue_size, QueueSize}</span></li><li><span class="v">TimerSpec = MSec | {MSec, StopOpts}</span></li><li><span class="v">MSec = FetchTimeout = integer()</span></li><li><span class="v">Module = Function = atom() </span></li><li><span class="v">StopOpts = see stop/2</span></li><li><span class="v">Client = File | {local, File}</span></li><li><span class="v">File = Filename | Wrap</span></li><li><span class="v">Filename = string()</span></li><li><span class="v">Wrap = {wrap,Filename} | {wrap,Filename,Size,Count}</span></li><li><span class="v">FormatHandler = See format/2</span></li><li><span class="v">PI = true | false </span></li><li><span class="v">ShellSpec = true | false | only</span></li><li><span class="v">QueueSize = non_neg_integer()</span></li></ul><p>Starts a file trace port on all specified nodes
and points the system tracer for sequential tracing to
the same port.
</p><p><em>Options:</em></p><dl><dt><strong>Filename</strong></dt><dd><p>The specified <strong>Filename</strong> is prefixed with the node name. 
Default <strong>Filename</strong> is <strong>ttb</strong>.</p></dd><dt><strong>File={wrap,Filename,Size,Count}</strong></dt><dd><p>Can be used if the size of the trace logs must be limited. 
Default values are
<strong>Size=128*1024</strong> and <strong>Count=8</strong>.</p></dd><dt><strong>Client</strong></dt><dd><p>When tracing diskless nodes, <strong>ttb</strong> must be started
from an external "trace control node" with disk access, and
<strong>Client</strong> must be <strong>{local, File}</strong>. All
trace information is then sent to the trace control node where
it is written to file.</p></dd><dt><strong>queue_size</strong></dt><dd><p>When tracing to shell or <strong>{local,File}</strong>, an ip
trace driver is used internally. The ip trace driver has a
queue of maximum <strong>QueueSize</strong> messages waiting to be
delivered. If the driver cannot deliver messages as fast as
they are produced, the queue size might be exceeded and
messages are dropped. This parameter is optional, and is
only useful if many <strong>{drop,N}</strong> trace messages are
received by the trace handler. It has no meaning if shell
or <strong>{local,File}</strong> is not used. See
<a href="../runtime_tools/dbg#trace_port/2">dbg:trace_port/2</a>
for more information about the ip trace driver.</p></dd><dt><strong>process_info</strong></dt><dd><p>Indicates if process
information is to be collected. If <strong>PI = true</strong> (which is
default), each process identifier <strong>Pid</strong> is replaced by a
tuple <strong>{Pid,ProcessInfo,Node}</strong>, where <strong>ProcessInfo</strong>
is the registered process name, its globally registered name,
or its initial function. To turn off this functionality, 
set <strong>PI = false</strong>.</p></dd><dt><strong>{shell, ShellSpec}</strong></dt><dd><p>Indicates that trace messages are to be printed on the 
console as they are received by the tracing process. This implies 
trace client <strong>{local, File}</strong>. If <strong>ShellSpec</strong>
is <strong>only</strong> (instead of <strong>true</strong>), no trace logs are stored.</p></dd><dt><strong>shell</strong></dt><dd><p>Shortcut for <strong>{shell, true}</strong>.</p></dd><dt><strong>timer</strong></dt><dd><p>Indicates that the trace is to be
automatically stopped after <strong>MSec</strong> milliseconds. <strong>StopOpts</strong>
are passed to command <strong>ttb:stop/2</strong> if specified (default is <strong>[]</strong>).
Notice that the timing is approximate, as delays related to
network communication are always present. The timer starts after
<strong>ttb:p/2</strong> is issued, so you can set up your trace patterns before.</p></dd><dt><strong>overload_check</strong></dt><dd><p>Allows to enable overload
checking on the nodes under trace. <strong>Module:Function(check)</strong>
is performed each <strong>MSec</strong> millisecond. If the check returns
<strong>true</strong>, the tracing is disabled on a specified node.</p> <p><strong>Module:Function</strong> must be able to handle at least three
atoms: <strong>init</strong>, <strong>check</strong>, and <strong>stop</strong>. <strong>init</strong> and
<strong>stop</strong> allows you to initialize and clean
up the check environment.</p> <p>When a node gets overloaded, it is not possible to issue <strong>ttb:p/2</strong>
or any command from the <strong>ttb:tp/2,3,4</strong> family, as it would lead to
inconsistent tracing state (different trace specifications on
different nodes).</p></dd><dt><strong>flush</strong></dt><dd><p>Periodically flushes all file trace
port clients (see
<a href="../runtime_tools/dbg#flush_trace_port/1">runtime_tools/dbg#flush_trace_port/1</a>). When enabled,
the buffers are freed each <strong>MSec</strong> millisecond. This option is
not allowed with <strong>{file, {local, File}}</strong> tracing.</p></dd><dt><strong>{resume, FetchTimeout}</strong></dt><dd><p>Enables the autoresume feature.
When enabled, remote nodes try to reconnect to the controlling node
if they are restarted. The feature requires application Runtime_Tools
to be started (so it has to be present in the <strong>.boot</strong>
scripts if the traced nodes run with embedded Erlang). If this is
not possible, resume can be performed manually by starting
<strong>Runtime_Tools</strong> remotely using 
<a href="../kernel/rpc#call/4">kernel/rpc#call/4</a>.</p> <p><strong>ttb</strong> tries to fetch all logs from a reconnecting node before
reinitializing the trace. This must finish within <strong>FetchTimeout</strong> 
milliseconds or is aborted.</p> <p>By default, autostart information is stored in a file named
<strong>ttb_autostart.bin</strong> on each node. If this is not desired
(for example, on diskless nodes), a custom module handling autostart
information storage and retrieval can be provided by specifying
environment variable <strong>ttb_autostart_module</strong> for the application
Runtime_Tools. The module must respond to the following API:</p> <dl><dt><strong>write_config(Data) -&gt; ok</strong></dt><dd><p>Stores the provided data for further retrieval. It is
important to realize that the data storage used must not
be affected by the node crash.</p></dd><dt><strong>read_config() -&gt; {ok, Data} | {error, Error}</strong></dt><dd><p>Retrieves configuration stored with <strong>write_config(Data)</strong>.</p></dd><dt><strong>delete_config() -&gt; ok</strong></dt><dd><p>Deletes configuration stored with <strong>write_config(Data)</strong>.
Notice that after this call any subsequent calls to <strong>read_config</strong>
must return <strong>{error, Error}</strong>.</p> </dd></dl> <p><strong>resume</strong> implies the default <strong>FetchTimeout</strong>, which is
10 seconds</p> </dd></dl><h4>p(Item,Flags) -&gt; Return</h4><p>Set the specified trace flags on the specified processes or ports.</p><ul><li><span class="v">Return  = {ok,[{Item,MatchDesc}]}</span></li><li><span class="v">Items   = Item | [Item]</span></li><li><span class="v">Item    = pid() | port() | RegName | {global,GlobalRegName} | all | processes | ports | existing | existing_processes | existing_ports | new | new_processes | new_ports</span></li><li><span class="v">RegName = atom()</span></li><li><span class="v">GlobalRegName = term()</span></li><li><span class="v">Flags   = Flag | [Flag]</span></li></ul><p>Sets the specified trace flags on the specified processes
or ports. Flag <strong>timestamp</strong> is always turned on.
</p><p>See the Reference Manual for module 
<a href="./dbg">runtime_tools/dbg</a>
for the possible trace flags. Parameter
<strong>MatchDesc</strong> is the same as returned from 
<strong>dbg:p/2</strong>.</p><p>Processes can be specified as registered names, globally
registered names, or process identifiers. Ports can be
specified as registered names or port identifiers. If a
registered name is specified, the flags are set on
processes/ports with this name on all active nodes.</p><p>Issuing this command starts the timer for this trace if option
<strong>timer</strong> is specified with <strong>tracer/2</strong>.
</p><h4>tp, tpl, ctp, ctpl, ctpg</h4><h4>tpe, ctpe</h4><p>Set and clear trace patterns.</p><p>These functions are to be used with trace
flag <strong>call</strong>, <strong>send</strong>, and <strong>'receive'</strong> for
setting and clearing trace patterns.</p><p>When trace flag <strong>call</strong> is set on a process,
function calls are traced on that process if a trace
pattern is set for the called function.</p><p>The <strong>send</strong> and <strong>'receive'</strong> flags enable tracing
of all messages sent and received by the process/port. Trace
patterns set with <strong>tpe</strong> may limit traced messages based
on the message content, the sender, and/or the receiver.</p><p>Trace patterns specify how to trace a function or a message
by using match specifications. Match specifications are
described in the
<a href="./match_spec">erts/match_spec</a>.
</p><p>These functions are equivalent to the corresponding
functions in module
<a href="./dbg">dbg</a>,
but all calls are stored in the
history. The history buffer makes it easy to create configuration
files; the same trace environment can be set up many
times, for example, to compare two test runs. It also
reduces the amount of typing when using <strong>ttb</strong> from the
Erlang shell.
</p><dl><dt><strong>tp</strong></dt><dd><p>Sets trace patterns on global function calls.</p></dd><dt><strong>tpl</strong></dt><dd><p>Sets trace patterns on local and global function calls.</p></dd><dt><strong>tpe</strong></dt><dd><p>Sets trace patterns on messages.</p></dd><dt><strong>ctp</strong></dt><dd><p>Clears trace patterns on local and global function
calls.</p></dd><dt><strong>ctpl</strong></dt><dd><p>Clears trace patterns on local function calls.</p></dd><dt><strong>ctpg</strong></dt><dd><p>Clears trace patterns on global function calls.</p></dd><dt><strong>ctpe</strong></dt><dd><p>Clears trace patterns on messages.</p></dd></dl><p>With <strong>tp</strong> and <strong>tpl</strong>, one of the match specification shortcuts
can be used (for example, <strong>ttb:tp(foo_module, caller)</strong>).</p><p>The shortcuts are as follows:</p><ul><li><strong>return</strong> - for <strong>[{'_',[],[{return_trace}]}]</strong> (report the return value from a traced function)</li><li><strong>caller</strong> - for <strong>[{'_',[],[{message,{caller}}]}]</strong> (report the calling function)</li><li><strong>{codestr, Str}</strong> - for <strong>dbg:fun2ms/1</strong> arguments passed as strings (example: <strong>"fun(_) -&gt; return_trace() end"</strong>) </li></ul><h4>list_history() -&gt; History</h4><p>Return all calls stored in history.</p><ul><li><span class="v">History = [{N,Func,Args}]</span></li></ul><p>All calls to <strong>ttb</strong> is stored in the history. This
function returns the current content of the history. Any entry
can be reexecuted with <strong>run_history/1</strong> or stored in a
configuration file with <strong>write_config/2,3</strong>.</p><h4>run_history(N) -&gt; ok | {error, Reason}</h4><p>Execute one entry of the history.</p><ul><li><span class="v">N = integer() | [integer()]</span></li></ul><p>Executes the specified entry or entries from the history
list. To list history, use <strong>list_history/0</strong>.</p><h4>write_config(ConfigFile,Config)</h4><p>Equivalent to write_config(ConfigFile,Config,[]).</p><p>Equivalent to <strong>write_config(ConfigFile,Config,[])</strong>.</p><h4>write_config(ConfigFile,Config,Opts) -&gt; ok | {error,Reason}</h4><p>Create a configuration file.</p><ul><li><span class="v">ConfigFile = string()</span></li><li><span class="v">Config = all | [integer()] | [{Mod,Func,Args}]</span></li><li><span class="v">Mod = atom()</span></li><li><span class="v">Func = atom()</span></li><li><span class="v">Args = [term()]</span></li><li><span class="v">Opts = Opt | [Opt]</span></li><li><span class="v">Opt = append</span></li></ul><p>Creates or extends a configuration file, which can be
used for restoring a specific configuration later.
</p><p>The contents of the configuration file can either be fetched from
the history or specified directly as a list of
<strong>{Mod,Func,Args}</strong>.
</p><p>If the complete history is to be stored in the configuration file,
<strong>Config</strong> must be <strong>all</strong>. If only a selected number
of entries from the history are to be stored, <strong>Config</strong>
must be a list of integers pointing out the entries to be
stored.
</p><p>If <strong>Opts</strong> is not specified or if it is <strong>[]</strong>,
<strong>ConfigFile</strong> is deleted and a new file is created. If
<strong>Opts = [append]</strong>, <strong>ConfigFile</strong> is not deleted.
The new information is appended at the end of the file.</p><h4>run_config(ConfigFile) -&gt; ok | {error,Reason}</h4><p>Execute all entries in a configuration file.</p><ul><li><span class="v">ConfigFile = string()</span></li></ul><p>Executes all entries in the specified configuration file. 
Notice that the history of the last trace is always available 
in file <strong>ttb_last_config</strong>.</p><h4>run_config(ConfigFile,NumList) -&gt; ok | {error,Reason}</h4><p>Execute selected entries from a configuration file.</p><ul><li><span class="v">ConfigFile = string()</span></li><li><span class="v">NumList = [integer()]</span></li></ul><p>Executes selected entries from the specified configuration
file. <strong>NumList</strong> is a list of integers pointing out the
entries to be executed.
</p><p>To list the contents of a configuration file, use
<strong>list_config/1</strong>.</p><p>Notice that the history of the last trace is always available 
in file <strong>ttb_last_config</strong>.</p><h4>list_config(ConfigFile) -&gt; Config | {error,Reason}</h4><p>List all entries in a configuration file.</p><ul><li><span class="v">ConfigFile = string()</span></li><li><span class="v">Config = [{N,Func,Args}]</span></li></ul><p>Lists all entries in the specified configuration file.</p><h4>write_trace_info(Key,Info) -&gt; ok</h4><p>Write any information to file <strong>.ti</strong>.</p><ul><li><span class="v">Key = term()</span></li><li><span class="v">Info = Data | fun() -&gt; Data</span></li><li><span class="v">Data = term()</span></li></ul><p>File <strong>.ti</strong> contains <strong>{Key,ValueList}</strong>
tuples. This function adds <strong>Data</strong> to the <strong>ValueList</strong>
associated with <strong>Key</strong>. All information written with this
function is included in the call to the format handler.</p><h4>seq_trigger_ms() -&gt; MatchSpec</h4><p>Equivalent to seq_trigger_ms(all).</p><p>Equivalent to <strong>seq_trigger_ms(all)</strong>.</p><h4>seq_trigger_ms(Flags) -&gt; MatchSpec</h4><p>Return a match_spec() which starts sequential tracing.</p><ul><li><span class="v">MatchSpec = match_spec()</span></li><li><span class="v">Flags = all | SeqTraceFlag | [SeqTraceFlag]</span></li><li><span class="v">SeqTraceFlag = atom()</span></li></ul><p>A match specification can turn on or off sequential
tracing. This function returns a match specification, which
turns on sequential tracing with the specified <strong>Flags</strong>.
</p><p>This match specification can be specified as the last argument
to <strong>tp</strong> or <strong>tpl</strong>. The activated <strong>Item</strong>
then becomes a <em>trigger</em> for sequential tracing. This
means that if the item is called on a process with trace flag
<strong>call</strong> set, the process is "contaminated"
with token <strong>seq_trace</strong>.
</p><p>If <strong>Flags = all</strong>, all possible flags are set.
</p><p>The possible values for <strong>SeqTraceFlag</strong> are available in
<a href="./seq_trace">kernel/seq_trace</a>.</p><p>For a description of the <strong>match_spec()</strong> syntax, 
see section
<a href="./match_spec">erts/match_spec</a>
in ERTS, which explains the general match specification "language".
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The <em>system tracer</em> for sequential tracing is
automatically initiated by <strong>ttb</strong> when a trace port is
started with <strong>ttb:tracer/0,1,2</strong>.</p></div><p>An example of how to use function <strong>seq_trigger_ms/0,1</strong> follows:</p><pre>
(tiger@durin)5&gt; <span class="input">ttb:tracer().</span>
{ok,[tiger@durin]}
(tiger@durin)6&gt; <span class="input">ttb:p(all,call).</span>
{ok,{[all],[call]}}
(tiger@durin)7&gt; <span class="input">ttb:tp(mod,func,ttb:seq_trigger_ms()).</span>
{ok,[{matched,1},{saved,1}]}
(tiger@durin)8&gt;</pre><p>Whenever <strong>mod:func(...)</strong> is called after this,
token <strong>seq_trace</strong> is set on the executing process.</p><h4>stop()</h4><p>Equivalent to stop([]).</p><p>Equivalent to <strong>stop([])</strong>.</p><h4>stop(Opts) -&gt; stopped | {stopped, Dir}</h4><p>Stop tracing and fetch/format logs from all nodes.</p><ul><li><span class="v">Opts = Opt | [Opt]</span></li><li><span class="v">Opt = nofetch | {fetch_dir, Dir} | format | {format, FormatOpts} | return_fetch_dir</span></li><li><span class="v">Dir = string()</span></li><li><span class="v">FormatOpts = see format/2</span></li></ul><p>Stops tracing on all nodes. Logs and
trace information files are sent to the trace control
node and stored in a directory named
<strong>ttb_upload_FileName-Timestamp</strong>, where <strong>Filename</strong> is
the one provided with <strong>{file, File}</strong> during trace setup
and <strong>Timestamp</strong> is of the
form <strong>yyyymmdd-hhmmss</strong>. Even logs from nodes on the same
machine as the trace control node are moved to this directory.
The history list is saved to a file named <strong>ttb_last_config</strong>
for further reference (as it is no longer accessible
through history and configuration management functions, like
<strong>ttb:list_history/0</strong>).
</p><p><em>Options:</em></p><dl><dt><strong>nofetch</strong></dt><dd><p>Indicates that trace logs are not to be
collected after tracing is stopped.</p></dd><dt><strong>{fetch, Dir}</strong></dt><dd><p>Allows specification of the directory
to fetch the data to. If the directory already exists, an
error is thrown.</p></dd><dt><strong>format</strong></dt><dd><p>Indicates the trace logs to be formatted after tracing 
is stopped. All logs in the fetch directory are merged.</p></dd><dt><strong>return_fetch_dir</strong></dt><dd><p>Indicates the return value
to be <strong>{stopped, Dir}</strong> and not just <strong>stopped</strong>.
This implies <strong>fetch</strong>.</p></dd></dl><h4>get_et_handler()</h4><p>Return the <strong>et</strong> handler.</p><p>Returns the <strong>et</strong> handler, which can be used with <strong>format/2</strong>
or <strong>tracer/2</strong>.</p><p>Example: <strong>ttb:format(Dir, [{handler, ttb:get_et_handler()}])</strong>.</p><h4>format(File)</h4><p>Equivalent to <strong>format(File,[])</strong>.</p><p>Equivalent to <strong>format(File,[])</strong>.</p><h4>format(File,Options) -&gt; ok | {error, Reason}</h4><p>Format a binary trace log.</p><ul><li><span class="v">File = string() | [string()]</span></li><li><span class="d">This can be the name of a binary log, a list of such logs, or the name of a directory containing one or more binary logs.</span></li><li><span class="v">Options = Opt | [Opt]</span></li><li><span class="v">Opt = {out,Out} | {handler,FormatHandler} | disable_sort</span></li><li><span class="v">Out = standard_io | string()</span></li><li><span class="v">FormatHandler = {Function, InitialState}</span></li><li><span class="v">Function = fun(Fd,Trace,TraceInfo,State) -&gt; State</span></li><li><span class="v">Fd = standard_io | FileDescriptor</span></li><li><span class="d">File descriptor of the destination file Out.</span></li><li><span class="v">Trace = tuple()</span></li><li><span class="d">The trace message. For details, see the Reference Manual for  module erlang.</span></li><li><span class="v">TraceInfo = [{Key,ValueList}]</span></li><li><span class="d">Includes the keys flags, client, and node. If handler is specified as option to the tracer function, this  is also included. Also, all information written with function write_trace_info/2 is included.</span></li></ul><p>Reads the specified binary trace log(s). The logs are processed
in the order of their time stamps as long as option <strong>disable_sort</strong>
is not specified.
</p><p>If <strong>FormatHandler = {Function,InitialState}</strong>,
<strong>Function</strong> is called for each trace message.</p><p>If <strong>FormatHandler = get_et_handler()</strong>, <strong>et_viewer</strong> in
application ET is used for presenting
the trace log graphically. <strong>ttb</strong> provides a few different
filters that can be selected from menu <em>Filters and scaling</em> 
in the <strong>et_viewer</strong>.</p><p>If <strong>FormatHandler</strong> is not specified, a
default handler is used presenting each trace message as a
text line.
</p><p>The state returned from each call of <strong>Function</strong> is passed to 
the next call, even if the next call is to format a message from another 
log file.
</p><p>If <strong>Out</strong> is specified, <strong>FormatHandler</strong> gets the
file descriptor to <strong>Out</strong> as the first parameter.
</p><p><strong>Out</strong> is ignored if the <strong>et</strong> format handler is used.
</p><p>Wrap logs can be formatted one by one or all at once. To
format one of the wrap logs in a set, specify the exact file name.
To format the whole set of wrap logs, specify the name
with <strong>*</strong> instead of the wrap count. For examples, see the
<a href="./ttb_ug#format">ttb_ug#format</a>.
</p><h3>etop</h3><p>Erlang Top is a tool for presenting information about Erlang
  processes similar to the information presented by "top" in UNIX.</p><p>Start Erlang Top with the provided scripts
<strong>etop</strong>. This starts a hidden Erlang node
that connects to the node to be measured. The measured node is
specified with option <strong>-node</strong>. If the measured node has a
different cookie than the default cookie for the user who
invokes the script, the cookie must be explicitly specified with
option <strong>-setcookie</strong>.Under Windows, batch file <strong>etop.bat</strong> can be used.When executing the <strong>etop</strong> script, configuration
parameters can be specified as command-line options,
for example, <strong>etop -node testnode@myhost -setcookie MyCookie</strong>.
The following configuration parameters exist for the
tool:<dl><dt><strong>node</strong></dt><dd><p>The measured node.</p> <p>Value: <strong>atom()</strong></p> <p>Mandatory</p></dd><dt><strong>setcookie</strong></dt><dd><p>Cookie to use for the <strong>etop</strong> node. Must be same as the
cookie on the measured node.</p> <p>Value: <strong>atom()</strong></p></dd><dt><strong>lines</strong></dt><dd><p>Number of lines (processes) to display.</p> <p>Value: <strong>integer()</strong></p> <p>Default: <strong>10</strong></p></dd><dt><strong>interval</strong></dt><dd><p>Time interval (in seconds) between each update of
the display.</p> <p>Value: <strong>integer()</strong></p> <p>Default: <strong>5</strong></p></dd><dt><strong>accumulate</strong></dt><dd><p>If <strong>true</strong>, the execution time and reductions are
accumulated.</p> <p>Value: <strong>boolean()</strong></p> <p>Default: <strong>false</strong></p></dd><dt><strong>sort</strong></dt><dd><p>Identifies what information to sort by.</p> <p>Value: <strong>runtime | reductions | memory | msg_q</strong></p> <p>Default: <strong>runtime</strong> (<strong>reductions</strong> if <strong>tracing=off</strong>)</p></dd><dt><strong>tracing</strong></dt><dd><p><strong>etop</strong> uses the Erlang trace facility, and thus no
other tracing is possible on the measured node while
<strong>etop</strong> is running, unless this option is set to
<strong>off</strong>. Also helpful if the <strong>etop</strong> tracing causes too
high load on the measured node. With tracing off, runtime is
not measured.</p> <p>Value: <strong>on | off</strong></p> <p>Default: <strong>on</strong></p></dd></dl>For details about Erlang Top, see the
<a href="etop_ug">User's Guide</a>.</p><h3>Functions</h3><h4>start() -&gt; ok</h4><p>Start etop.</p><p>Starts <strong>etop</strong>.
Notice that <strong>etop</strong> is preferably started with the <strong>etop</strong> script.</p><h4>start(Options) -&gt; ok</h4><p>Start etop.</p><ul><li><span class="v">Options = [Option]</span></li><li><span class="v">Option = {Key, Value}</span></li><li><span class="v">Key = atom()</span></li><li><span class="v">Value = term()</span></li></ul><p>Starts <strong>etop</strong>. To view the possible options, use
<a href="#help/0">help/0</a>.</p><h4>help() -&gt; ok</h4><p>Display the etop help.</p><p>Displays the help of <strong>etop</strong> and
its options.</p><h4>config(Key,Value) -&gt; Result</h4><p>Change the configuration of the tool.</p><ul><li><span class="v">Result = ok | {error,Reason}</span></li><li><span class="v">Key = lines | interval | accumulate | sort</span></li><li><span class="v">Value = term()</span></li></ul><p>Changes the configuration parameters of the tool during runtime.
Allowed parameters are <strong>lines</strong>, <strong>interval</strong>, <strong>accumulate</strong>,
and <strong>sort</strong>.</p><h4>dump(File) -&gt; Result</h4><p>Dump the current display to a file.</p><ul><li><span class="v">Result = ok | {error,Reason}</span></li><li><span class="v">File = string()</span></li></ul><p>Dumps the current display to a text file.</p><h4>stop() -&gt; stop</h4><p>Terminate etop.</p><p>Terminates <strong>etop</strong>.</p><h3>crashdump_viewer</h3><p>A WxWidgets based tool for browsing Erlang
  crashdumps.</p><p>The Crashdump Viewer is a WxWidgets based tool for browsing Erlang
crashdumps.For details about how to get started with the Crashdump Viewer, see the
<a href="crashdump_ug">crashdump_ug</a>.</p><h3>Functions</h3><h4>start() -&gt; ok</h4><h4>start(File) -&gt; ok</h4><p>Start the Crashdump Viewer.</p><ul><li><span class="v">File = string()</span></li><li><span class="d">The filename of the crashdump.</span></li></ul><p>Starts the Crashdump Viewer GUI and
loads the specified crashdump.</p><p>If <strong>File</strong> is not specified, a file dialog is opened
where the crashdump can be selected.</p><h4>stop() -&gt; ok</h4><p>Terminate the Crashdump Viewer.</p><p>Terminates the Crashdump Viewer and closes
all GUI windows.</p><h3>cdv</h3><p>Script to start the Crashdump Viewer from the
  OS command line.
</p><p>The <strong>cdv</strong> shell script is located in directory <strong>priv</strong>
of the Observer application. The script is used
for starting the Crashdump Viewer tool from the OS command
line.For Windows users, <strong>cdv.bat</strong> is found in the same
location.</p><h3>Functions</h3><h4>cdv [file]</h4><p>Start the Crashdump Viewer and load the given file.</p><p>Argument <strong>file</strong> is optional. If not specified, a file
dialog is displayed, allowing you to select a crashdump
from the file system.</p></body></html>