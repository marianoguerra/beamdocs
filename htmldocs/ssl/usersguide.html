<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>SSL User's Guide</h1><p>The Secure Socket Layer (SSL) application provides secure communication over
sockets.
</p><h3>Purpose</h3><p>Transport Layer Security (TLS) and its predecessor, the Secure
Sockets Layer (SSL), are cryptographic protocols designed to
provide communications security over a computer network. The protocols
use X.509 certificates and hence public key (asymmetric) cryptography to
authenticate the counterpart with whom they communicate,
and to exchange a symmetric key for payload encryption. The protocol provides
data/message confidentiality (encryption), integrity (through message authentication code checks)
and host verification (through certificate path validation). DTLS (Datagram Transport Layer Security) that
is based on TLS but datagram oriented instead of stream oriented.</p><h3>Prerequisites</h3><p>It is assumed that the reader is familiar with the Erlang
programming language, the concepts of OTP, and has a basic
understanding of SSL/TLS/DTLS.</p><p>The Erlang SSL application implements the SSL/TLS/DTLS protocol
for the currently supported versions,  see the
<a href="ssl">ssl(3)</a> manual page.
</p><p>By default SSL/TLS is run over the TCP/IP protocol even
though you can plug in any other reliable transport protocol
with the same Application Programming Interface (API) as the
<strong>gen_tcp</strong> module in Kernel. DTLS is by default run over UDP/IP,
which means that application data has no delivery guarentees. Other 
transports, such as SCTP, may be supported in future releases.</p><p>If a client and a server wants to use an upgrade mechanism, such as
defined by RFC 2817, to upgrade a regular TCP/IP connection to an TLS
connection, this is supported by the Erlang SSL application API. This can be 
useful for, for example, supporting HTTP and HTTPS on the same port and
implementing virtual hosting. Note this is a TLS feature only.
</p><h3>Security Overview</h3><p>To achieve authentication and privacy, the client and server
perform a TLS/DTLS handshake procedure before transmitting or receiving
any data. During the handshake, they agree on a protocol version and
cryptographic algorithms, generate shared secrets using public
key cryptographies, and optionally authenticate each other with
digital certificates.</p><h3>Data Privacy and Integrity</h3><p>A <em>symmetric key</em> algorithm has one key only. The key is
used for both encryption and decryption. These algorithms are fast,
compared to public key algorithms (using two keys, one public and one
private) and are therefore typically used for encrypting bulk
data.
</p><p>The keys for the symmetric encryption are generated uniquely
for each connection and are based on a secret negotiated
in the TLS/DTLS handshake.</p><p>The TLS/DTLS handshake protocol and data transfer is run on top of
the TLS/DTLS Record Protocol, which uses a keyed-hash Message
Authenticity Code (MAC), or a Hash-based MAC (HMAC),
to protect the message data
integrity. From the TLS RFC: "A Message Authentication Code is a
one-way hash computed from a message and some secret data. It is
difficult to forge without knowing the secret data. Its purpose is
to detect if the message has been altered."
</p><h3>Digital Certificates</h3><p>A certificate is similar to a driver's license, or a
passport. The holder of the certificate is called the
<em>subject</em>. The certificate is signed 
with the private key of the issuer of the certificate. A chain
of trust is built by having the issuer in its turn being
certified by another certificate, and so on, until you reach the
so called root certificate, which is self-signed, that is, issued
by itself.</p><p>Certificates are issued by Certification Authorities (CAs) only. 
A handful of top CAs in the world issue root certificates. You can
examine several of these certificates by clicking
through the menus of your web browser.
</p><h3>Peer Authentication</h3><p>Authentication of the peer is done by public key path
validation as defined in RFC 3280. This means basically 
the following:</p><ul><li>Each certificate in the certificate chain is issued by the  previous one.</li><li>The certificates attributes are valid.</li><li>The root certificate is a trusted certificate that is present  in the trusted certificate database kept by the peer.</li></ul><p>The server always sends a certificate chain as part of
the TLS handshake, but the client only sends one if requested
by the server. If the client does not have
an appropriate certificate, it can send an "empty" certificate
to the server.</p><p>The client can choose to accept some path evaluation errors,
for example, a web browser can ask the user whether to
accept an unknown CA root certificate. The server, if it requests
a certificate, does however not accept any path validation
errors. It is configurable if the server is to accept
or reject an "empty" certificate as response to
a certificate request.</p><h3>TLS Sessions</h3><p>From the TLS RFC: "A TLS session is an association between a
client and a server. Sessions are created by the handshake
protocol. Sessions define a set of cryptographic security
parameters, which can be shared among multiple
connections. Sessions are used to avoid the expensive negotiation
of new security parameters for each connection."</p><p>Session data is by default kept by the SSL application in a
memory storage, hence session data is lost at application
restart or takeover. Users can define their own callback module
to handle session data storage if persistent data storage is
required. Session data is also invalidated after 24 hours
from it was saved, for security reasons. The amount of time the 
session data is to be saved can be configured.</p><p>By default the TLS/DTLS clients try to reuse an available session and 
by default the TLS/DTLS servers agree to reuse sessions when clients
ask for it.</p><p>To see relevant version information for ssl, call
<a href="../ssl/ssl#versions-0">ssl/ssl#versions-0</a>
.</p><p>To see all supported cipher suites, call  <a href="../ssl/ssl#cipher_suites-1">ssl/ssl#cipher_suites-1</a>. 
The available cipher suites for a connection depend on your certificate. 
Specific cipher suites that you want your connection to use can also be 
specified. Default is to use the strongest available.</p><h3>Setting up Connections</h3><p>This section shows a small example of how to set up client/server connections
using the Erlang shell. The returned value of the <strong>sslsocket</strong> is abbreviated
with <strong>[...]</strong> as it can be fairly large and is opaque.</p><h3>Minimal Example</h3><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p> The minimal setup is not the most secure setup of SSL/TLS/DTLS.</p></div><p>To set up client/server connections:</p><p><em>Step 1:</em> Start the server side:</p><pre><code class="erl">1 server&gt; ssl:start().
ok</code></pre><p><em>Step 2:</em> Create an TLS listen socket: (To run DTLS add the option {protocol, dtls})</p><pre><code class="erl">2 server&gt; {ok, ListenSocket} =
ssl:listen(9999, [{certfile, "cert.pem"}, {keyfile, "key.pem"},{reuseaddr, true}]).
{ok,{sslsocket, [...]}}</code></pre><p><em>Step 3:</em> Do a transport accept on the TLS listen socket:</p><pre><code class="erl">3 server&gt; {ok, TLSTransportSocket} = ssl:transport_accept(ListenSocket).
{ok,{sslsocket, [...]}}</code></pre><p><em>Step 4:</em> Start the client side: </p><pre><code class="erl">1 client&gt; ssl:start().
ok</code></pre><p> To run DTLS add the option {protocol, dtls} to third argument.</p><pre><code class="erl">2 client&gt; {ok, Socket} = ssl:connect("localhost", 9999,  [], infinity).
{ok,{sslsocket, [...]}}</code></pre><p><em>Step 5:</em> Do the TLS handshake:</p><pre><code class="erl">4 server&gt; {ok, Socket} = ssl:handshake(TLSTransportSocket).
ok</code></pre><p><em>Step 6:</em> Send a message over TLS:</p><pre><code class="erl">5 server&gt; ssl:send(Socket, "foo").
ok</code></pre><p><em>Step 7:</em> Flush the shell message queue to see that the message
was sent on the server side:</p><pre><code class="erl">3 client&gt; flush().
Shell got {ssl,{sslsocket,[...]},"foo"}
ok</code></pre><h3>Upgrade Example - TLS only</h3><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>To upgrade a TCP/IP connection to an SSL connection, the
client and server must agree to do so. The agreement
can be accomplished by using a protocol, for example, the one used by HTTP
specified in RFC 2817.</p></div><p>To upgrade to an SSL connection:</p><p><em>Step 1:</em> Start the server side:</p><pre><code class="erl">1 server&gt; ssl:start().
ok</code></pre><p><em>Step 2:</em> Create a normal TCP listen socket:</p><pre><code class="erl">2 server&gt; {ok, ListenSocket} = gen_tcp:listen(9999, [{reuseaddr, true}]).
{ok, #Port&lt;0.475&gt;}</code></pre><p><em>Step 3:</em> Accept client connection:</p><pre><code class="erl">3 server&gt; {ok, Socket} = gen_tcp:accept(ListenSocket).
{ok, #Port&lt;0.476&gt;}</code></pre><p><em>Step 4:</em> Start the client side:</p><pre><code class="erl">1 client&gt; ssl:start().
ok</code></pre><pre><code class="erl">2 client&gt; {ok, Socket} = gen_tcp:connect("localhost", 9999,  [], infinity).</code></pre><p><em>Step 5:</em> Ensure <strong>active</strong> is set to <strong>false</strong> before trying
to upgrade a connection to an SSL connection, otherwise
SSL handshake messages can be delivered to the wrong process:</p><pre><code class="erl">4 server&gt; inet:setopts(Socket, [{active, false}]).
ok</code></pre><p><em>Step 6:</em> Do the TLS handshake:</p><pre><code class="erl">5 server&gt; {ok, TLSSocket} = ssl:handshake(Socket, [{cacertfile, "cacerts.pem"},
{certfile, "cert.pem"}, {keyfile, "key.pem"}]).
{ok,{sslsocket,[...]}}</code></pre><p><em>Step 7:</em> Upgrade to an TLS connection. The client and server
must agree upon the upgrade. The server must call
<strong>ssl:handshake/2</strong> before the client calls <strong>ssl:connect/3.</strong></p><pre><code class="erl">3 client&gt;{ok, TLSSocket} = ssl:connect(Socket, [{cacertfile, "cacerts.pem"},
{certfile, "cert.pem"}, {keyfile, "key.pem"}], infinity).
{ok,{sslsocket,[...]}}</code></pre><p><em>Step 8:</em> Send a message over TLS:</p><pre><code class="erl">4 client&gt; ssl:send(TLSSocket, "foo").
ok</code></pre><p><em>Step 9:</em> Set <strong>active true</strong> on the TLS socket:</p><pre><code class="erl">4 server&gt; ssl:setopts(TLSSocket, [{active, true}]).
ok</code></pre><p><em>Step 10:</em> Flush the shell message queue to see that the message
was sent on the client side:</p><pre><code class="erl">5 server&gt; flush().
Shell got {ssl,{sslsocket,[...]},"foo"}
ok</code></pre><h3>Customizing cipher suits</h3><p>Fetch default cipher suite list for an TLS/DTLS version. Change default
to all to get all possible cipher suites.</p><pre><code class="erl">1&gt;  Default = ssl:cipher_suites(default, 'tlsv1.2').
    [#{cipher =&gt; aes_256_gcm,key_exchange =&gt; ecdhe_ecdsa,
    mac =&gt; aead,prf =&gt; sha384}, ....]
</code></pre><p>In OTP 20 it is desirable to remove all cipher suites
that uses rsa kexchange (removed from default in 21) </p><pre><code class="erl">2&gt; NoRSA =
    ssl:filter_cipher_suites(Default,
                            [{key_exchange, fun(rsa) -&gt; false;
			                       (_) -&gt; true end}]).
    [...]
    </code></pre><p> Pick just a few suites </p><pre><code class="erl"> 3&gt; Suites =
    ssl:filter_cipher_suites(Default,
                            [{key_exchange, fun(ecdh_ecdsa) -&gt; true;
			                       (_) -&gt; false end},
                             {cipher, fun(aes_128_cbc) -&gt;true;
			                  (_) -&gt;false end}]).
    [#{cipher =&gt; aes_128_cbc,key_exchange =&gt; ecdh_ecdsa,
     mac =&gt; sha256,prf =&gt; sha256},
     #{cipher =&gt; aes_128_cbc,key_exchange =&gt; ecdh_ecdsa,mac =&gt; sha,
     prf =&gt; default_prf}]
    </code></pre><p> Make some particular suites the most preferred, or least
preferred by changing prepend to append.</p><pre><code class="erl"> 4&gt;ssl:prepend_cipher_suites(Suites, Default).
  [#{cipher =&gt; aes_128_cbc,key_exchange =&gt; ecdh_ecdsa,
     mac =&gt; sha256,prf =&gt; sha256},
   #{cipher =&gt; aes_128_cbc,key_exchange =&gt; ecdh_ecdsa,mac =&gt; sha,
     prf =&gt; default_prf},
   #{cipher =&gt; aes_256_cbc,key_exchange =&gt; ecdhe_ecdsa,
     mac =&gt; sha384,prf =&gt; sha384}, ...]
    </code></pre><h3>Using an Engine Stored Key</h3><p>Erlang ssl application is able to use private keys provided
by OpenSSL engines using the following mechanism:</p><pre><code class="erl">1&gt; ssl:start().
ok</code></pre><p>Load a crypto engine, should be done once per engine used. For example
dynamically load the engine called <strong>MyEngine</strong>:
</p><pre><code class="erl">2&gt; {ok, EngineRef} =
crypto:engine_load(&lt;&lt;"dynamic"&gt;&gt;,
                   [{&lt;&lt;"SO_PATH"&gt;&gt;, "/tmp/user/engines/MyEngine"},&lt;&lt;"LOAD"&gt;&gt;],[]).
{ok,#Ref&lt;0.2399045421.3028942852.173962&gt;}
    </code></pre><p>Create a map with the engine information and the algorithm used by the engine:</p><pre><code class="erl">3&gt; PrivKey =
 #{algorithm =&gt; rsa,
   engine =&gt; EngineRef,
   key_id =&gt; "id of the private key in Engine"}.
    </code></pre><p>Use the map in the ssl key option:</p><pre><code class="erl">4&gt; {ok, SSLSocket} =
ssl:connect("localhost", 9999,
            [{cacertfile, "cacerts.pem"},
             {certfile, "cert.pem"},
             {key, PrivKey}], infinity).
    </code></pre><p>See also <a href="../crypto/engine_load#engine_load"> crypto documentation</a> </p><p>This section describes how the Erlang distribution can use 
TLS to get extra verification and security.</p><p>The Erlang distribution can in theory use almost any 
connection-based protocol as bearer. However, a module that 
implements the protocol-specific parts of the connection setup is 
needed. The default distribution module is <strong>inet_tcp_dist</strong> 
in the Kernel application. When starting an
Erlang node distributed, <strong>net_kernel</strong> uses this module to
set up listen ports and connections.</p><p>In the SSL application, an extra distribution
module, <strong>inet_tls_dist</strong>, can be used as an
alternative. All distribution connections will use TLS and
all participating Erlang nodes in a distributed system must use
this distribution module.</p><p>The security level depends on the parameters provided to the
TLS connection setup. Erlang node cookies are however always
used, as they can be used to differentiate between two different
Erlang networks.</p><p>To set up Erlang distribution over TLS:</p><ul><li><em>Step 1:</em> Build boot scripts including the SSL application.</li><li><em>Step 2:</em> Specify the distribution module for  <strong>net_kernel</strong>.</li><li><em>Step 3:</em> Specify the security options and other  SSL options.</li><li><em>Step 4:</em> Set up the environment to always use TLS.</li></ul><p>The following sections describe these steps.</p><h3>Building Boot Scripts Including the SSL Application</h3><p>Boot scripts are built using the <strong>systools</strong> utility in the
SASL application. For more information on <strong>systools</strong>,
see the SASL documentation. This is only an example of
what can be done.</p><p>The simplest boot script possible includes only the Kernel 
and STDLIB applications. Such a script is located in the 
<strong>bin</strong> directory of the Erlang distribution. The source for the 
script is found under the Erlang installation top directory under
<strong>releases/&lt;OTP version&gt;/start_clean.rel</strong>.</p><p>Do the following:</p><ul><li><p>Copy that script to another location (and preferably another 
name).</p></li><li><p>Add the applications Crypto, Public Key, and 
SSL with their current version numbers after the 
STDLIB application.</p></li></ul><p>The following shows an example <strong>.rel</strong> file with TLS 
added:</p><pre><code class="">
      {release, {"OTP  APN 181 01","R15A"}, {erts, "5.9"},
      [{kernel,"2.15"},
      {stdlib,"1.18"},
      {crypto, "2.0.3"},
      {public_key, "0.12"},
      {asn1, "4.0"},
      {ssl, "5.0"}
      ]}.
   </code></pre><p>The version numbers differ in your system. Whenever one of the 
applications included in the script is upgraded, change the script.</p><p>Do the following:</p><ul><li><p>Build the boot script.</p> <p>Assuming the <strong>.rel file</strong> is stored in a file
<strong>start_ssl.rel</strong> in the current directory, a boot script
can be built as follows:</p></li></ul><pre><code class="">
   1&gt; systools:make_script("start_ssl",[]).    </code></pre><p>There is now a <strong>start_ssl.boot</strong> file in the current
directory.</p><p>Do the following:</p><ul><li><p>Test the boot script. To do this, start Erlang with the
<strong>-boot</strong> command-line parameter specifying this boot script
(with its full path, but without the <strong>.boot</strong> suffix). In
UNIX it can look as follows:</p></li></ul><pre><code class="">
$ erl -boot /home/me/ssl/start_ssl
Erlang (BEAM) emulator version 5.0
 
Eshell V5.0  (abort with ^G)
1&gt; whereis(ssl_manager).
&lt;0.41.0&gt;    </code></pre><p>The <strong>whereis</strong> function-call verifies that the SSL 
application is started.</p><p>As an alternative to building a bootscript, you can explicitly
add the path to the SSL <strong>ebin</strong> directory on the command
line. This is done with command-line option <strong>-pa</strong>. This
works as the SSL application does not need to be started for the
distribution to come up, as a clone of the SSL application is
hooked into the Kernel application. So, as long as the
SSL application code can be reached, the distribution starts. 
The <strong>-pa</strong> method is only recommended for testing purposes.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The clone of the SSL application must
enable the use of the SSL code in such an early bootstage as
needed to set up the distribution. However, this makes it
impossible to soft upgrade the SSL application.</p></div><h3>Specifying Distribution Module for net_kernel</h3><p>The distribution module for SSL/TLS is named <strong>inet_tls_dist</strong>
and is specified on the command line with option <strong>-proto_dist</strong>.
The argument to <strong>-proto_dist</strong> is to be the module
name without suffix <strong>_dist</strong>. So, this distribution
module is specified with <strong>-proto_dist inet_tls</strong> on the
command line.</p><p>Extending the command line gives the following:</p><pre><code class="">
$ erl -boot /home/me/ssl/start_ssl -proto_dist inet_tls    </code></pre><p>For the distribution to be started, give the emulator a name as well:</p><pre><code class="">
$ erl -boot /home/me/ssl/start_ssl -proto_dist inet_tls -sname ssl_test
Erlang (BEAM) emulator version 5.0 [source]
 
Eshell V5.0  (abort with ^G)
(ssl_test@myhost)1&gt;     </code></pre><p>However, a node started in this way refuses to talk
to other nodes, as no TLS parameters are supplied
(see the next section).</p><h3>Specifying SSL/TLS Options</h3><p>
The SSL/TLS distribution options can be written into a file
that is consulted when the node is started.  This file name
is then specified with the command line argument
<strong>-ssl_dist_optfile</strong>.
</p><p>
Any available SSL/TLS option can be specified in an options file,
but note that options that take a <strong>fun()</strong> has to use
the syntax <strong>fun Mod:Func/Arity</strong> since a function
body cannot be compiled when consulting a file.
</p><p>
Do not tamper with the socket options
<strong>list</strong>, <strong>binary</strong>, <strong>active</strong>, <strong>packet</strong>,
<strong>nodelay</strong> and <strong>deliver</strong> since they are used
by the distribution protocol handler itself.
Other raw socket options such as <strong>packet_size</strong> may
interfere severely, so beware!
</p><p>
For SSL/TLS to work, at least a public key and a certificate
must be specified for the server side.
In the following example, the PEM file
<strong>"/home/me/ssl/erlserver.pem"</strong> contains both
the server certificate and its private key.
</p><p>
Create a file named for example
<strong>"/home/me/ssl/ssl_test@myhost.conf"</strong>:
</p><pre><code class="">
[{server,
  [{certfile, "/home/me/ssl/erlserver.pem"},
   {secure_renegotiate, true}]},
 {client,
  [{secure_renegotiate, true}]}].
    </code></pre><p>
And then start the node like this
(line breaks in the command are for readability,
and shall not be there when typed):
</p><pre><code class="">
$ erl -boot /home/me/ssl/start_ssl -proto_dist inet_tls
  -ssl_dist_optfile "/home/me/ssl/ssl_test@myhost.conf"
  -sname ssl_test
    </code></pre><p>
The options in the <strong>{server, Opts}</strong> tuple are used
when calling <strong>ssl:ssl_accept/3</strong>, and the options in the
<strong>{client, Opts}</strong> tuple are used when calling
<strong>ssl:connect/4</strong>.
</p><p>
For the client, the option
<strong>{server_name_indication, atom_to_list(TargetNode)}</strong>
is added when connecting.
This makes it possible to use the client option
<strong>{verify, verify_peer}</strong>,
and the client will verify that the certificate matches
the node name you are connecting to.
This only works if the the server certificate is issued
to the name <strong>atom_to_list(TargetNode)</strong>.
</p><p>
For the server it is also possible to use the option
<strong>{verify, verify_peer}</strong> and the server will only accept
client connections with certificates that are trusted by
a root certificate that the server knows.
A client that presents an untrusted certificate will be rejected.
This option is preferably combined with
<strong>{fail_if_no_peer_cert, true}</strong> or a client will
still be accepted if it does not present any certificate.
</p><p>
A node started in this way is fully functional, using TLS
as the distribution protocol.
</p><h3>Specifying SSL/TLS Options (Legacy)</h3><p>
As in the previous section the PEM file
<strong>"/home/me/ssl/erlserver.pem"</strong> contains both
the server certificate and its private key.
</p><p>On the <strong>erl</strong> command line you can specify options that the
SSL/TLS distribution adds when creating a socket.</p><p>The simplest SSL/TLS options in the following list can be specified 
by adding the 
prefix <strong>server_</strong> or <strong>client_</strong> to the option name:</p><ul><li><strong>certfile</strong></li><li><strong>keyfile</strong></li><li><strong>password</strong></li><li><strong>cacertfile</strong></li><li><strong>verify</strong></li><li><strong>verify_fun</strong> (write as <strong>{Module, Function, InitialUserState}</strong>)</li><li><strong>crl_check</strong></li><li><strong>crl_cache</strong> (write as Erlang term)</li><li><strong>reuse_sessions</strong></li><li><strong>secure_renegotiate</strong></li><li><strong>depth</strong></li><li><strong>hibernate_after</strong></li><li><strong>ciphers</strong> (use old string format)</li></ul><p>Note that <strong>verify_fun</strong> needs to be written in a different
form than the corresponding SSL/TLS option, since funs are not
accepted on the command line.</p><p>The server can also take the options <strong>dhfile</strong> and
<strong>fail_if_no_peer_cert</strong> (also prefixed).</p><p><strong>client_</strong>-prefixed options are used when the distribution 
initiates a connection to another node. <strong>server_</strong>-prefixed 
options are used when accepting a connection from a remote node.</p><p>Raw socket options, such as <strong>packet</strong> and <strong>size</strong> must not 
be specified on the command line.</p><p>The command-line argument for specifying the SSL/TLS options is named
<strong>-ssl_dist_opt</strong> and is to be followed by pairs of
SSL options and their values. Argument <strong>-ssl_dist_opt</strong> can
be repeated any number of times.</p><p>
An example command line doing the same as the example
in the previous section can now look as follows
(line breaks in the command are for readability, 
and shall not be there when typed):
</p><pre><code class="">
$ erl -boot /home/me/ssl/start_ssl -proto_dist inet_tls
  -ssl_dist_opt server_certfile "/home/me/ssl/erlserver.pem"
  -ssl_dist_opt server_secure_renegotiate true client_secure_renegotiate true
  -sname ssl_test
Erlang (BEAM) emulator version 5.0 [source]

Eshell V5.0  (abort with ^G)
(ssl_test@myhost)1&gt;
    </code></pre><h3>Setting up Environment to Always Use SSL/TLS (Legacy)</h3><p>A convenient way to specify arguments to Erlang is to use environment 
variable <strong>ERL_FLAGS</strong>. All the flags needed to
use the SSL/TLS distribution can be specified in that variable and are
then interpreted as command-line arguments for all
subsequent invocations of Erlang.</p><p>In a Unix (Bourne) shell, it can look as follows (line breaks are for
readability, they are not to be there when typed):</p><pre><code class="">
$ ERL_FLAGS="-boot /home/me/ssl/start_ssl -proto_dist inet_tls
  -ssl_dist_opt server_certfile /home/me/ssl/erlserver.pem
  -ssl_dist_opt server_secure_renegotiate true client_secure_renegotiate true"
$ export ERL_FLAGS
$ erl -sname ssl_test
Erlang (BEAM) emulator version 5.0 [source]
 
Eshell V5.0  (abort with ^G)
(ssl_test@myhost)1&gt; init:get_arguments().
[{root,["/usr/local/erlang"]},
 {progname,["erl "]},
 {sname,["ssl_test"]},
 {boot,["/home/me/ssl/start_ssl"]},
 {proto_dist,["inet_tls"]},
 {ssl_dist_opt,["server_certfile","/home/me/ssl/erlserver.pem"]},
 {ssl_dist_opt,["server_secure_renegotiate","true",
                "client_secure_renegotiate","true"]
 {home,["/home/me"]}]    </code></pre><p>The <strong>init:get_arguments()</strong> call verifies that the correct
arguments are supplied to the emulator.</p><h3>Using SSL/TLS distribution over IPv6</h3><p>It is possible to use SSL/TLS distribution over IPv6 instead of
IPv4. To do this, pass the option <strong>-proto_dist inet6_tls</strong>
instead of <strong>-proto_dist inet_tls</strong> when starting Erlang,
either on the command line or in the <strong>ERL_FLAGS</strong> environment
variable.</p><p>An example command line with this option would look like this:</p><pre><code class="">
$ erl -boot /home/me/ssl/start_ssl -proto_dist inet6_tls
  -ssl_dist_optfile "/home/me/ssl/ssl_test@myhost.conf"
  -sname ssl_test
    </code></pre><p>A node started in this way will only be able to communicate with
other nodes using SSL/TLS distribution over IPv6.</p><h3>Purpose</h3><p>This section describes the current state of standards compliance of the ssl application.</p><h3>Common (pre TLS 1.3)</h3><ul><li>For security reasons RSA key exchange cipher suites are no longer supported by default, but can be configured. (OTP 21) </li><li>For security reasons DES cipher suites are no longer supported by default, but can be configured. (OTP 20) </li><li>For security reasons 3DES cipher suites are no longer supported by default, but can be configured. (OTP 21) </li><li>Renegotiation Indication Extension <a href="http://www.ietf.org/rfc/rfc5746.txt">RFC 5746</a> is supported </li><li>Ephemeral Diffie-Hellman cipher suites are supported, but not Diffie Hellman Certificates cipher suites. </li><li>Elliptic Curve cipher suites are supported if the Crypto application supports it and named curves are used. </li><li>Export cipher suites are not supported as the U.S. lifted its export restrictions in early 2000. </li><li>IDEA cipher suites are not supported as they have become deprecated by the TLS 1.2 specification so it is not motivated to implement them. </li><li>Compression is not supported. </li></ul><h3>Common</h3><ul><li>CRL validation is supported.</li><li>Policy certificate extensions are not supported.</li><li>'Server Name Indication' extension (<a href="http://www.ietf.org/rfc/rfc6066.txt">RFC 6066</a>) is supported.</li><li>Application Layer Protocol Negotiation (ALPN) and its successor Next Protocol Negotiation (NPN) are supported. </li><li>It is possible to use Pre-Shared Key (PSK) and Secure Remote Password (SRP) cipher suites, but they are not enabled by default. </li></ul><h3>SSL 2.0</h3><p>For security reasons SSL-2.0 is not supported. Interoperability with SSL-2.0 enabled clients dropped. (OTP 21)</p><h3>SSL 3.0</h3><p>For security reasons SSL-3.0 is no longer supported by default, but can be configured. (OTP 19)</p><h3>TLS 1.0</h3><p>For security reasons TLS-1.0 is no longer supported by default, but can be configured. (OTP 22)</p><h3>TLS 1.1</h3><p>For security reasons TLS-1.1 is no longer supported by default, but can be configured. (OTP 22)</p><h3>TLS 1.2</h3><p>Supported</p><h3>DTLS 1.0</h3><p>For security reasons DTLS-1.0 (based on TLS 1.1) is no longer supported by default, but can be configured. (OTP 22)</p><h3>DTLS 1.2</h3><p>Supported (based on TLS 1.2)</p><h3>DTLS 1.3</h3><p>Not yet supported</p><h3>TLS 1.3</h3><p>OTP-22 introduces basic support for TLS 1.3 on the server side. Basic functionality
covers a simple TLS 1.3 handshake with support of the mandatory extensions
(supported_groups, signature_algorithms, key_share, supported_versions and
signature_algorithms_cert). The server supports a selective set of cryptographic algorithms:</p><ul><li>Key Exchange: ECDHE</li><li>Groups: all standard groups supported for the Diffie-Hellman key exchange</li><li>Ciphers: TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256 and TLS_AES_128_CCM_SHA256</li><li>Signature Algorithms: RSA and RSA PSS</li><li>Certificates: currently only certificates with RSA keys are supported</li></ul><p>Other notable features:</p><ul><li>The server supports the HelloRetryRequest mechanism</li><li>PSK and session resumption not supported</li><li>Early data and 0-RTT not supported</li><li>Key and Initialization Vector Update not supported</li></ul><p>For more detailed information see the
<a href="#soc_table">Standards Compliance</a> below.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Note that the client side is not yet functional. It is planned to be released
later in OTP-22.</p></div><p> The following table describes the current state of standards compliance for TLS 1.3.</p><p>(<em>C</em> = Compliant, <em>NC</em> = Non-Compliant, <em>PC</em> = Partially-Compliant,
<em>NA</em> = Not Applicable)</p><a name="soc_table"></a><table class="table table-bordered table-hover table-striped"><caption>Standards Compliance</caption><tbody><tr><td><em>Section</em></td><td><em>Feature</em></td><td><em>State</em></td><td><em>Since</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-1.2"> 1.3. Updates Affecting TLS 1.2 </a> </td><td></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>Version downgrade protection mechanism</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>RSASSA-PSS signature schemes</td><td><em>PC</em></td><td>22</td></tr><tr><td></td><td>supported_versions (ClientHello) extension</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>signature_algorithms_cert extension</td><td><em>C</em></td><td>22</td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-2"> 2. Protocol Overview </a> </td><td></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>(EC)DHE</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>PSK-only</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>PSK with (EC)DHE</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-2.1"> 2.1. Incorrect DHE share </a> </td><td>HelloRetryRequest</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-2.2"> 2.2. Resumption and Pre-Shared Key (PSK) </a> </td><td></td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-2.3"> 2.3. 0-RTT Data </a> </td><td></td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.1.1"> 4.1.1. Cryptographic Negotiation </a> </td><td></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>supported_groups extension</td><td><em>C</em></td><td></td></tr><tr><td></td><td>signature_algorithms extension</td><td><em>C</em></td><td></td></tr><tr><td></td><td>pre_shared_key extension</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.1.2"> 4.1.2. Client Hello </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td>server_name (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>max_fragment_length (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>status_request (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_groups (RFC7919)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signature_algorithms (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>use_srtp (RFC5764)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>heartbeat (RFC6520)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>application_layer_protocol_negotiation (RFC7301)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signed_certificate_timestamp (RFC6962)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>client_certificate_type (RFC7250)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>server_certificate_type (RFC7250)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>padding (RFC7685)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>key_share (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>pre_shared_key (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>psk_key_exchange_modes (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>early_data (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>cookie (RFC8446) </td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_versions (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>certificate_authorities (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>oid_filters (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>post_handshake_auth (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signature_algorithms_cert (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>server_name (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>max_fragment_length (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>status_request (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_groups (RFC7919)</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>signature_algorithms (RFC8446)</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>use_srtp (RFC5764)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>heartbeat (RFC6520)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>application_layer_protocol_negotiation (RFC7301)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signed_certificate_timestamp (RFC6962)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>client_certificate_type (RFC7250)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>server_certificate_type (RFC7250)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>padding (RFC7685)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>key_share (RFC8446)</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>pre_shared_key (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>psk_key_exchange_modes (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>early_data (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>cookie (RFC8446) </td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_versions (RFC8446)</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>certificate_authorities (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>oid_filters (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>post_handshake_auth (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signature_algorithms_cert (RFC8446)</td><td><em>C</em></td><td>22</td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.1.3"> 4.1.3. Server Hello </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td>Version downgrade protection</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>key_share (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>pre_shared_key (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_versions (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>Version downgrade protection</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>key_share (RFC8446)</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>pre_shared_key (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_versions (RFC8446)</td><td><em>C</em></td><td>22</td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.1.4"> 4.1.4. Hello Retry Request </a> </td><td><em>Server</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>key_share (RFC8446)</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>cookie (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_versions (RFC8446)</td><td><em>C</em></td><td>22</td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.1"> 4.2.1. Supported Versions </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.2"> 4.2.2. Cookie </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.3"> 4.2.3. Signature Algorithms </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pkcs1_sha256</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pkcs1_sha384</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pkcs1_sha512</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ecdsa_secp256r1_sha256</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ecdsa_secp384r1_sha384</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ecdsa_secp521r1_sha512</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_rsae_sha256</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_rsae_sha384</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_rsae_sha512</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ed25519</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ed448</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_pss_sha256</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_pss_sha384</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_pss_sha512</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pkcs1_sha1</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ecdsa_sha1</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>rsa_pkcs1_sha256</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>rsa_pkcs1_sha384</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>rsa_pkcs1_sha512</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>ecdsa_secp256r1_sha256</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ecdsa_secp384r1_sha384</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ecdsa_secp521r1_sha512</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_rsae_sha256</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>rsa_pss_rsae_sha384</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>rsa_pss_rsae_sha512</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>ed25519</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ed448</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_pss_sha256</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_pss_sha384</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_pss_sha512</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pkcs1_sha1</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>ecdsa_sha1</td><td><em>C</em></td><td>22</td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.4"> 4.2.4. Certificate Authorities </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.5"> 4.2.5. OID Filters </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.6"> 4.2.6. Post-Handshake Client Authentication </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.7"> 4.2.7. Supported Groups </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td>secp256r1</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>secp384r1</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>secp521r1</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>x25519</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>x448</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ffdhe2048</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ffdhe3072</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ffdhe4096</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ffdhe6144</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ffdhe8192</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>secp256r1</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>secp384r1</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>secp521r1</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>x25519</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>x448</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>ffdhe2048</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>ffdhe3072</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>ffdhe4096</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>ffdhe6144</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>ffdhe8192</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.8"> 4.2.8. Key Share </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.9"> 4.2.9. Pre-Shared Key Exchange Modes </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.10"> 4.2.10. Early Data Indication </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.11"> 4.2.11. Pre-Shared Key Extension </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.11.1"> 4.2.11.1. Ticket Age </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.11.2"> 4.2.11.2. PSK Binder </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.11.3"> 4.2.11.3. Processing Order </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.3.1"> 4.3.1. Encrypted Extensions </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td>server_name (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>max_fragment_length (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_groups (RFC7919)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>use_srtp (RFC5764)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>heartbeat (RFC6520)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>application_layer_protocol_negotiation (RFC7301)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>client_certificate_type (RFC7250)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>server_certificate_type (RFC7250)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>early_data (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_versions (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>server_name (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>max_fragment_length (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_groups (RFC7919)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>use_srtp (RFC5764)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>heartbeat (RFC6520)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>application_layer_protocol_negotiation (RFC7301)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>client_certificate_type (RFC7250)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>server_certificate_type (RFC7250)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>early_data (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_versions (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.3.2"> 4.3.2. Certificate Request </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td>status_request (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signature_algorithms (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signed_certificate_timestamp (RFC6962)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>certificate_authorities (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>oid_filters (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signature_algorithms_cert (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>status_request (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signature_algorithms (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signed_certificate_timestamp (RFC6962)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>certificate_authorities (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>oid_filters (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signature_algorithms_cert (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.4.1"> 4.4.1. The Transcript Hash </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.4.2"> 4.4.2. Certificate </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td>status_request (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signed_certificate_timestamp (RFC6962)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>status_request (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signed_certificate_timestamp (RFC6962)</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.4.2.1"> 4.4.2.1. OCSP Status and SCT Extensions </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.4.2.2"> 4.4.2.2. Server Certificate Selection </a> </td><td><em>Client</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td>certificate type MUST be X.509v3</td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td>certificate's public key is compatible</td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td>The certificate MUST allow the key to be used for signing</td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td>server_name and certificate_authorities are used</td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td><em>Server</em></td><td><em>PC</em></td><td><em></em></td></tr><tr><td></td><td>certificate type MUST be X.509v3</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>certificate's public key is compatible</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>The certificate MUST allow the key to be used for signing</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>server_name and certificate_authorities are used</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.4.2.3"> 4.4.2.3. Client Certificate Selection </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.4.2.4"> 4.4.2.4. Receiving a Certificate Message </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.4.3"> 4.4.3. Certificate Verify </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.4.4"> 4.4.4. Finished </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.5"> 4.5. End of Early Data </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.6.1"> 4.6.1. New Session Ticket Message </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td>early_data (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td>early_data (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.6.2"> 4.6.2. Post-Handshake Authentication </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.6.3"> 4.6.3. Key and Initialization Vector Update </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-5.1"> 5.1. Record Layer </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>MUST NOT be interleaved with other record types</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>MUST NOT span key changes</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>MUST NOT send zero-length fragments</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>Alert messages MUST NOT be fragmented</td><td><em>C</em></td><td>22</td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-5.2"> 5.2. Record Payload Protection </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-5.3"> 5.3. Per-Record Nonce </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-5.4"> 5.4. Record Padding </a> </td><td><em></em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>MAY choose to pad</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>MUST NOT send Handshake and Alert records that have a zero-length TLSInnerPlaintext.content</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>The padding sent is automatically verified</td><td><em>C</em></td><td>22</td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-5.5"> 5.5. Limits on Key Usage </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-6.1"> 6.1. Closure Alerts </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td>close_notify</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>user_cancelled</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-6.2"> 6.2. Error Alerts </a> </td><td><em></em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-7.1"> 7.1. Key Schedule </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-7.2"> 7.2. Updating Traffic Secrets </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-7.3"> 7.3. Traffic Key Calculation </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-7.5"> 7.5. Exporters </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-8"> 8. 0-RTT and Anti-Replay </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-8.1"> 8.1. Single-Use Tickets </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-8.2"> 8.2. Client Hello Recording </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-8.3"> 8.3. Freshness Checks </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-9.1"> 9.1. Mandatory-to-Implement Cipher Suites </a> </td><td><em></em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>MUST implement the TLS_AES_128_GCM_SHA256</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>SHOULD implement the TLS_AES_256_GCM_SHA384</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>SHOULD implement the TLS_CHACHA20_POLY1305_SHA256</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td><em>Digital signatures</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>MUST support rsa_pkcs1_sha256 (for certificates)</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>MUST support rsa_pss_rsae_sha256 (for CertificateVerify and certificates)</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>MUST support ecdsa_secp256r1_sha256</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Key Exchange</em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>MUST support key exchange with secp256r1</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>SHOULD support key exchange with X25519</td><td><em>C</em></td><td>22</td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-9.2"> 9.2. Mandatory-to-Implement Extensions </a> </td><td><em></em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>Supported Versions</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>Cookie</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>Signature Algorithms</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>Signature Algorithms Certificate</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>Negotiated Groups</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>Key Share</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>Server Name Indication</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>MUST send and use these extensions</em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>"supported_versions" is REQUIRED for ClientHello, ServerHello and HelloRetryRequest</td><td><em>PC</em></td><td>22</td></tr><tr><td></td><td>"signature_algorithms" is REQUIRED for certificate authentication</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>"supported_groups" is REQUIRED for ClientHello messages using (EC)DHE key exchange</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>"key_share" is REQUIRED for (EC)DHE key exchange</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>"pre_shared_key" is REQUIRED for PSK key agreement</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>"psk_key_exchange_modes" is REQUIRED for PSK key agreement</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>TLS 1.3 ClientHello</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td>If not containing a "pre_shared_key" extension, it MUST contain both a "signature_algorithms" extension and a "supported_groups" extension.</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>If containing a "supported_groups" extension, it MUST also contain a "key_share" extension, and vice versa.  An empty KeyShare.client_shares vector is permitted.</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>TLS 1.3 ServerHello</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>MUST support the use of the "server_name" extension</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-9.3"> 9.3. Protocol Invariants </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td><em>MUST correctly handle extensible fields</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td>A client sending a ClientHello MUST support all parameters advertised in it.</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>A middlebox which terminates a TLS connection MUST behave as a compliant TLS server</td><td><em>NA</em></td><td></td></tr><tr><td></td><td>A middlebox which forwards ClientHello parameters it does not understand MUST NOT process any messages beyond that ClientHello.</td><td><em>NA</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-B.4"> B.4. Cipher Suites </a> </td><td><em></em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>TLS_AES_128_GCM_SHA256</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>TLS_AES_256_GCM_SHA384</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>TLS_CHACHA20_POLY1305_SHA256</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>TLS_AES_128_CCM_SHA256</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>TLS_AES_128_CCM_8_SHA256</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-C.1"> C.1. Random Number Generation and Seeding </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-C.2"> C.2. Certificates and Authentication </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-C.3"> C.3. Implementation Pitfalls </a> </td><td><em></em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-C.4"> C.4. Client Tracking Prevention </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-C.5"> C.5. Unauthenticated Operation </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-D.1"> D.1. Negotiating with an Older Server </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-D.2"> D.2. Negotiating with an Older Client </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-D.3"> D.3. 0-RTT Backward Compatibility </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-D.4"> D.4. Middlebox Compatibility Mode </a> </td><td><em></em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-D.5"> D.5. Security Restrictions Related to Backward Compatibility </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr></tbody></table></body></html>