<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Secure Socket Layer</h1><h1>SSL Application</h1><p>The Secure Socket Layer (SSL) application provides secure communication over
sockets.
</p><h4>Purpose</h4><p>Transport Layer Security (TLS) and its predecessor, the Secure
Sockets Layer (SSL), are cryptographic protocols designed to
provide communications security over a computer network. The protocols
use X.509 certificates and hence public key (asymmetric) cryptography to
authenticate the counterpart with whom they communicate,
and to exchange a symmetric key for payload encryption. The protocol provides
data/message confidentiality (encryption), integrity (through message authentication code checks)
and host verification (through certificate path validation). DTLS (Datagram Transport Layer Security) that
is based on TLS but datagram oriented instead of stream oriented.</p><h4>Prerequisites</h4><p>It is assumed that the reader is familiar with the Erlang
programming language, the concepts of OTP, and has a basic
understanding of SSL/TLS/DTLS.</p><p>The Erlang SSL application implements the SSL/TLS/DTLS protocol
for the currently supported versions,  see the
<a href="ssl">ssl(3)</a> manual page.
</p><p>By default SSL/TLS is run over the TCP/IP protocol even
though you can plug in any other reliable transport protocol
with the same Application Programming Interface (API) as the
<strong>gen_tcp</strong> module in Kernel. DTLS is by default run over UDP/IP,
which means that application data has no delivery guarentees. Other 
transports, such as SCTP, may be supported in future releases.</p><p>If a client and a server wants to use an upgrade mechanism, such as
defined by RFC 2817, to upgrade a regular TCP/IP connection to an TLS
connection, this is supported by the Erlang SSL application API. This can be 
useful for, for example, supporting HTTP and HTTPS on the same port and
implementing virtual hosting. Note this is a TLS feature only.
</p><h4>Security Overview</h4><p>To achieve authentication and privacy, the client and server
perform a TLS/DTLS handshake procedure before transmitting or receiving
any data. During the handshake, they agree on a protocol version and
cryptographic algorithms, generate shared secrets using public
key cryptographies, and optionally authenticate each other with
digital certificates.</p><h4>Data Privacy and Integrity</h4><p>A <em>symmetric key</em> algorithm has one key only. The key is
used for both encryption and decryption. These algorithms are fast,
compared to public key algorithms (using two keys, one public and one
private) and are therefore typically used for encrypting bulk
data.
</p><p>The keys for the symmetric encryption are generated uniquely
for each connection and are based on a secret negotiated
in the TLS/DTLS handshake.</p><p>The TLS/DTLS handshake protocol and data transfer is run on top of
the TLS/DTLS Record Protocol, which uses a keyed-hash Message
Authenticity Code (MAC), or a Hash-based MAC (HMAC),
to protect the message data
integrity. From the TLS RFC: "A Message Authentication Code is a
one-way hash computed from a message and some secret data. It is
difficult to forge without knowing the secret data. Its purpose is
to detect if the message has been altered."
</p><h4>Digital Certificates</h4><p>A certificate is similar to a driver's license, or a
passport. The holder of the certificate is called the
<em>subject</em>. The certificate is signed 
with the private key of the issuer of the certificate. A chain
of trust is built by having the issuer in its turn being
certified by another certificate, and so on, until you reach the
so called root certificate, which is self-signed, that is, issued
by itself.</p><p>Certificates are issued by Certification Authorities (CAs) only. 
A handful of top CAs in the world issue root certificates. You can
examine several of these certificates by clicking
through the menus of your web browser.
</p><h4>Peer Authentication</h4><p>Authentication of the peer is done by public key path
validation as defined in RFC 3280. This means basically 
the following:</p><ul><li>Each certificate in the certificate chain is issued by the  previous one.</li><li>The certificates attributes are valid.</li><li>The root certificate is a trusted certificate that is present  in the trusted certificate database kept by the peer.</li></ul><p>The server always sends a certificate chain as part of
the TLS handshake, but the client only sends one if requested
by the server. If the client does not have
an appropriate certificate, it can send an "empty" certificate
to the server.</p><p>The client can choose to accept some path evaluation errors,
for example, a web browser can ask the user whether to
accept an unknown CA root certificate. The server, if it requests
a certificate, does however not accept any path validation
errors. It is configurable if the server is to accept
or reject an "empty" certificate as response to
a certificate request.</p><h4>TLS Sessions</h4><p>From the TLS RFC: "A TLS session is an association between a
client and a server. Sessions are created by the handshake
protocol. Sessions define a set of cryptographic security
parameters, which can be shared among multiple
connections. Sessions are used to avoid the expensive negotiation
of new security parameters for each connection."</p><p>Session data is by default kept by the SSL application in a
memory storage, hence session data is lost at application
restart or takeover. Users can define their own callback module
to handle session data storage if persistent data storage is
required. Session data is also invalidated after 24 hours
from it was saved, for security reasons. The amount of time the 
session data is to be saved can be configured.</p><p>By default the TLS/DTLS clients try to reuse an available session and 
by default the TLS/DTLS servers agree to reuse sessions when clients
ask for it.</p><p>To see relevant version information for ssl, call
<a href="../ssl/ssl#versions-0">ssl/ssl#versions-0</a>
.</p><p>To see all supported cipher suites, call  <a href="../ssl/ssl#cipher_suites-1">ssl/ssl#cipher_suites-1</a>. 
The available cipher suites for a connection depend on your certificate. 
Specific cipher suites that you want your connection to use can also be 
specified. Default is to use the strongest available.</p><h4>Setting up Connections</h4><p>This section shows a small example of how to set up client/server connections
using the Erlang shell. The returned value of the <strong>sslsocket</strong> is abbreviated
with <strong>[...]</strong> as it can be fairly large and is opaque.</p><h4>Minimal Example</h4><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p> The minimal setup is not the most secure setup of SSL/TLS/DTLS.</p></div><p>To set up client/server connections:</p><p><em>Step 1:</em> Start the server side:</p><pre><code class="erl">1 server&gt; ssl:start().
ok</code></pre><p><em>Step 2:</em> Create an TLS listen socket: (To run DTLS add the option {protocol, dtls})</p><pre><code class="erl">2 server&gt; {ok, ListenSocket} =
ssl:listen(9999, [{certfile, "cert.pem"}, {keyfile, "key.pem"},{reuseaddr, true}]).
{ok,{sslsocket, [...]}}</code></pre><p><em>Step 3:</em> Do a transport accept on the TLS listen socket:</p><pre><code class="erl">3 server&gt; {ok, TLSTransportSocket} = ssl:transport_accept(ListenSocket).
{ok,{sslsocket, [...]}}</code></pre><p><em>Step 4:</em> Start the client side: </p><pre><code class="erl">1 client&gt; ssl:start().
ok</code></pre><p> To run DTLS add the option {protocol, dtls} to third argument.</p><pre><code class="erl">2 client&gt; {ok, Socket} = ssl:connect("localhost", 9999,  [], infinity).
{ok,{sslsocket, [...]}}</code></pre><p><em>Step 5:</em> Do the TLS handshake:</p><pre><code class="erl">4 server&gt; {ok, Socket} = ssl:handshake(TLSTransportSocket).
ok</code></pre><p><em>Step 6:</em> Send a message over TLS:</p><pre><code class="erl">5 server&gt; ssl:send(Socket, "foo").
ok</code></pre><p><em>Step 7:</em> Flush the shell message queue to see that the message
was sent on the server side:</p><pre><code class="erl">3 client&gt; flush().
Shell got {ssl,{sslsocket,[...]},"foo"}
ok</code></pre><h4>Upgrade Example - TLS only</h4><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>To upgrade a TCP/IP connection to an SSL connection, the
client and server must agree to do so. The agreement
can be accomplished by using a protocol, for example, the one used by HTTP
specified in RFC 2817.</p></div><p>To upgrade to an SSL connection:</p><p><em>Step 1:</em> Start the server side:</p><pre><code class="erl">1 server&gt; ssl:start().
ok</code></pre><p><em>Step 2:</em> Create a normal TCP listen socket:</p><pre><code class="erl">2 server&gt; {ok, ListenSocket} = gen_tcp:listen(9999, [{reuseaddr, true}]).
{ok, #Port&lt;0.475&gt;}</code></pre><p><em>Step 3:</em> Accept client connection:</p><pre><code class="erl">3 server&gt; {ok, Socket} = gen_tcp:accept(ListenSocket).
{ok, #Port&lt;0.476&gt;}</code></pre><p><em>Step 4:</em> Start the client side:</p><pre><code class="erl">1 client&gt; ssl:start().
ok</code></pre><pre><code class="erl">2 client&gt; {ok, Socket} = gen_tcp:connect("localhost", 9999,  [], infinity).</code></pre><p><em>Step 5:</em> Ensure <strong>active</strong> is set to <strong>false</strong> before trying
to upgrade a connection to an SSL connection, otherwise
SSL handshake messages can be delivered to the wrong process:</p><pre><code class="erl">4 server&gt; inet:setopts(Socket, [{active, false}]).
ok</code></pre><p><em>Step 6:</em> Do the TLS handshake:</p><pre><code class="erl">5 server&gt; {ok, TLSSocket} = ssl:handshake(Socket, [{cacertfile, "cacerts.pem"},
{certfile, "cert.pem"}, {keyfile, "key.pem"}]).
{ok,{sslsocket,[...]}}</code></pre><p><em>Step 7:</em> Upgrade to an TLS connection. The client and server
must agree upon the upgrade. The server must call
<strong>ssl:handshake/2</strong> before the client calls <strong>ssl:connect/3.</strong></p><pre><code class="erl">3 client&gt;{ok, TLSSocket} = ssl:connect(Socket, [{cacertfile, "cacerts.pem"},
{certfile, "cert.pem"}, {keyfile, "key.pem"}], infinity).
{ok,{sslsocket,[...]}}</code></pre><p><em>Step 8:</em> Send a message over TLS:</p><pre><code class="erl">4 client&gt; ssl:send(TLSSocket, "foo").
ok</code></pre><p><em>Step 9:</em> Set <strong>active true</strong> on the TLS socket:</p><pre><code class="erl">4 server&gt; ssl:setopts(TLSSocket, [{active, true}]).
ok</code></pre><p><em>Step 10:</em> Flush the shell message queue to see that the message
was sent on the client side:</p><pre><code class="erl">5 server&gt; flush().
Shell got {ssl,{sslsocket,[...]},"foo"}
ok</code></pre><h4>Customizing cipher suits</h4><p>Fetch default cipher suite list for an TLS/DTLS version. Change default
to all to get all possible cipher suites.</p><pre><code class="erl">1&gt;  Default = ssl:cipher_suites(default, 'tlsv1.2').
    [#{cipher =&gt; aes_256_gcm,key_exchange =&gt; ecdhe_ecdsa,
    mac =&gt; aead,prf =&gt; sha384}, ....]
</code></pre><p>In OTP 20 it is desirable to remove all cipher suites
that uses rsa kexchange (removed from default in 21) </p><pre><code class="erl">2&gt; NoRSA =
    ssl:filter_cipher_suites(Default,
                            [{key_exchange, fun(rsa) -&gt; false;
			                       (_) -&gt; true end}]).
    [...]
    </code></pre><p> Pick just a few suites </p><pre><code class="erl"> 3&gt; Suites =
    ssl:filter_cipher_suites(Default,
                            [{key_exchange, fun(ecdh_ecdsa) -&gt; true;
			                       (_) -&gt; false end},
                             {cipher, fun(aes_128_cbc) -&gt;true;
			                  (_) -&gt;false end}]).
    [#{cipher =&gt; aes_128_cbc,key_exchange =&gt; ecdh_ecdsa,
     mac =&gt; sha256,prf =&gt; sha256},
     #{cipher =&gt; aes_128_cbc,key_exchange =&gt; ecdh_ecdsa,mac =&gt; sha,
     prf =&gt; default_prf}]
    </code></pre><p> Make some particular suites the most preferred, or least
preferred by changing prepend to append.</p><pre><code class="erl"> 4&gt;ssl:prepend_cipher_suites(Suites, Default).
  [#{cipher =&gt; aes_128_cbc,key_exchange =&gt; ecdh_ecdsa,
     mac =&gt; sha256,prf =&gt; sha256},
   #{cipher =&gt; aes_128_cbc,key_exchange =&gt; ecdh_ecdsa,mac =&gt; sha,
     prf =&gt; default_prf},
   #{cipher =&gt; aes_256_cbc,key_exchange =&gt; ecdhe_ecdsa,
     mac =&gt; sha384,prf =&gt; sha384}, ...]
    </code></pre><h4>Using an Engine Stored Key</h4><p>Erlang ssl application is able to use private keys provided
by OpenSSL engines using the following mechanism:</p><pre><code class="erl">1&gt; ssl:start().
ok</code></pre><p>Load a crypto engine, should be done once per engine used. For example
dynamically load the engine called <strong>MyEngine</strong>:
</p><pre><code class="erl">2&gt; {ok, EngineRef} =
crypto:engine_load(&lt;&lt;"dynamic"&gt;&gt;,
                   [{&lt;&lt;"SO_PATH"&gt;&gt;, "/tmp/user/engines/MyEngine"},&lt;&lt;"LOAD"&gt;&gt;],[]).
{ok,#Ref&lt;0.2399045421.3028942852.173962&gt;}
    </code></pre><p>Create a map with the engine information and the algorithm used by the engine:</p><pre><code class="erl">3&gt; PrivKey =
 #{algorithm =&gt; rsa,
   engine =&gt; EngineRef,
   key_id =&gt; "id of the private key in Engine"}.
    </code></pre><p>Use the map in the ssl key option:</p><pre><code class="erl">4&gt; {ok, SSLSocket} =
ssl:connect("localhost", 9999,
            [{cacertfile, "cacerts.pem"},
             {certfile, "cert.pem"},
             {key, PrivKey}], infinity).
    </code></pre><p>See also <a href="../crypto/engine_load#engine_load"> crypto documentation</a> </p><p>This section describes how the Erlang distribution can use 
TLS to get extra verification and security.</p><p>The Erlang distribution can in theory use almost any 
connection-based protocol as bearer. However, a module that 
implements the protocol-specific parts of the connection setup is 
needed. The default distribution module is <strong>inet_tcp_dist</strong> 
in the Kernel application. When starting an
Erlang node distributed, <strong>net_kernel</strong> uses this module to
set up listen ports and connections.</p><p>In the SSL application, an extra distribution
module, <strong>inet_tls_dist</strong>, can be used as an
alternative. All distribution connections will use TLS and
all participating Erlang nodes in a distributed system must use
this distribution module.</p><p>The security level depends on the parameters provided to the
TLS connection setup. Erlang node cookies are however always
used, as they can be used to differentiate between two different
Erlang networks.</p><p>To set up Erlang distribution over TLS:</p><ul><li><em>Step 1:</em> Build boot scripts including the SSL application.</li><li><em>Step 2:</em> Specify the distribution module for  <strong>net_kernel</strong>.</li><li><em>Step 3:</em> Specify the security options and other  SSL options.</li><li><em>Step 4:</em> Set up the environment to always use TLS.</li></ul><p>The following sections describe these steps.</p><h4>Building Boot Scripts Including the SSL Application</h4><p>Boot scripts are built using the <strong>systools</strong> utility in the
SASL application. For more information on <strong>systools</strong>,
see the SASL documentation. This is only an example of
what can be done.</p><p>The simplest boot script possible includes only the Kernel 
and STDLIB applications. Such a script is located in the 
<strong>bin</strong> directory of the Erlang distribution. The source for the 
script is found under the Erlang installation top directory under
<strong>releases/&lt;OTP version&gt;/start_clean.rel</strong>.</p><p>Do the following:</p><ul><li><p>Copy that script to another location (and preferably another 
name).</p></li><li><p>Add the applications Crypto, Public Key, and 
SSL with their current version numbers after the 
STDLIB application.</p></li></ul><p>The following shows an example <strong>.rel</strong> file with TLS 
added:</p><pre><code class="">
      {release, {"OTP  APN 181 01","R15A"}, {erts, "5.9"},
      [{kernel,"2.15"},
      {stdlib,"1.18"},
      {crypto, "2.0.3"},
      {public_key, "0.12"},
      {asn1, "4.0"},
      {ssl, "5.0"}
      ]}.
   </code></pre><p>The version numbers differ in your system. Whenever one of the 
applications included in the script is upgraded, change the script.</p><p>Do the following:</p><ul><li><p>Build the boot script.</p> <p>Assuming the <strong>.rel file</strong> is stored in a file
<strong>start_ssl.rel</strong> in the current directory, a boot script
can be built as follows:</p></li></ul><pre><code class="">
   1&gt; systools:make_script("start_ssl",[]).    </code></pre><p>There is now a <strong>start_ssl.boot</strong> file in the current
directory.</p><p>Do the following:</p><ul><li><p>Test the boot script. To do this, start Erlang with the
<strong>-boot</strong> command-line parameter specifying this boot script
(with its full path, but without the <strong>.boot</strong> suffix). In
UNIX it can look as follows:</p></li></ul><pre><code class="">
$ erl -boot /home/me/ssl/start_ssl
Erlang (BEAM) emulator version 5.0
 
Eshell V5.0  (abort with ^G)
1&gt; whereis(ssl_manager).
&lt;0.41.0&gt;    </code></pre><p>The <strong>whereis</strong> function-call verifies that the SSL 
application is started.</p><p>As an alternative to building a bootscript, you can explicitly
add the path to the SSL <strong>ebin</strong> directory on the command
line. This is done with command-line option <strong>-pa</strong>. This
works as the SSL application does not need to be started for the
distribution to come up, as a clone of the SSL application is
hooked into the Kernel application. So, as long as the
SSL application code can be reached, the distribution starts. 
The <strong>-pa</strong> method is only recommended for testing purposes.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The clone of the SSL application must
enable the use of the SSL code in such an early bootstage as
needed to set up the distribution. However, this makes it
impossible to soft upgrade the SSL application.</p></div><h4>Specifying Distribution Module for net_kernel</h4><p>The distribution module for SSL/TLS is named <strong>inet_tls_dist</strong>
and is specified on the command line with option <strong>-proto_dist</strong>.
The argument to <strong>-proto_dist</strong> is to be the module
name without suffix <strong>_dist</strong>. So, this distribution
module is specified with <strong>-proto_dist inet_tls</strong> on the
command line.</p><p>Extending the command line gives the following:</p><pre><code class="">
$ erl -boot /home/me/ssl/start_ssl -proto_dist inet_tls    </code></pre><p>For the distribution to be started, give the emulator a name as well:</p><pre><code class="">
$ erl -boot /home/me/ssl/start_ssl -proto_dist inet_tls -sname ssl_test
Erlang (BEAM) emulator version 5.0 [source]
 
Eshell V5.0  (abort with ^G)
(ssl_test@myhost)1&gt;     </code></pre><p>However, a node started in this way refuses to talk
to other nodes, as no TLS parameters are supplied
(see the next section).</p><h4>Specifying SSL/TLS Options</h4><p>
The SSL/TLS distribution options can be written into a file
that is consulted when the node is started.  This file name
is then specified with the command line argument
<strong>-ssl_dist_optfile</strong>.
</p><p>
Any available SSL/TLS option can be specified in an options file,
but note that options that take a <strong>fun()</strong> has to use
the syntax <strong>fun Mod:Func/Arity</strong> since a function
body cannot be compiled when consulting a file.
</p><p>
Do not tamper with the socket options
<strong>list</strong>, <strong>binary</strong>, <strong>active</strong>, <strong>packet</strong>,
<strong>nodelay</strong> and <strong>deliver</strong> since they are used
by the distribution protocol handler itself.
Other raw socket options such as <strong>packet_size</strong> may
interfere severely, so beware!
</p><p>
For SSL/TLS to work, at least a public key and a certificate
must be specified for the server side.
In the following example, the PEM file
<strong>"/home/me/ssl/erlserver.pem"</strong> contains both
the server certificate and its private key.
</p><p>
Create a file named for example
<strong>"/home/me/ssl/ssl_test@myhost.conf"</strong>:
</p><pre><code class="">
[{server,
  [{certfile, "/home/me/ssl/erlserver.pem"},
   {secure_renegotiate, true}]},
 {client,
  [{secure_renegotiate, true}]}].
    </code></pre><p>
And then start the node like this
(line breaks in the command are for readability,
and shall not be there when typed):
</p><pre><code class="">
$ erl -boot /home/me/ssl/start_ssl -proto_dist inet_tls
  -ssl_dist_optfile "/home/me/ssl/ssl_test@myhost.conf"
  -sname ssl_test
    </code></pre><p>
The options in the <strong>{server, Opts}</strong> tuple are used
when calling <strong>ssl:ssl_accept/3</strong>, and the options in the
<strong>{client, Opts}</strong> tuple are used when calling
<strong>ssl:connect/4</strong>.
</p><p>
For the client, the option
<strong>{server_name_indication, atom_to_list(TargetNode)}</strong>
is added when connecting.
This makes it possible to use the client option
<strong>{verify, verify_peer}</strong>,
and the client will verify that the certificate matches
the node name you are connecting to.
This only works if the the server certificate is issued
to the name <strong>atom_to_list(TargetNode)</strong>.
</p><p>
For the server it is also possible to use the option
<strong>{verify, verify_peer}</strong> and the server will only accept
client connections with certificates that are trusted by
a root certificate that the server knows.
A client that presents an untrusted certificate will be rejected.
This option is preferably combined with
<strong>{fail_if_no_peer_cert, true}</strong> or a client will
still be accepted if it does not present any certificate.
</p><p>
A node started in this way is fully functional, using TLS
as the distribution protocol.
</p><h4>Specifying SSL/TLS Options (Legacy)</h4><p>
As in the previous section the PEM file
<strong>"/home/me/ssl/erlserver.pem"</strong> contains both
the server certificate and its private key.
</p><p>On the <strong>erl</strong> command line you can specify options that the
SSL/TLS distribution adds when creating a socket.</p><p>The simplest SSL/TLS options in the following list can be specified 
by adding the 
prefix <strong>server_</strong> or <strong>client_</strong> to the option name:</p><ul><li><strong>certfile</strong></li><li><strong>keyfile</strong></li><li><strong>password</strong></li><li><strong>cacertfile</strong></li><li><strong>verify</strong></li><li><strong>verify_fun</strong> (write as <strong>{Module, Function, InitialUserState}</strong>)</li><li><strong>crl_check</strong></li><li><strong>crl_cache</strong> (write as Erlang term)</li><li><strong>reuse_sessions</strong></li><li><strong>secure_renegotiate</strong></li><li><strong>depth</strong></li><li><strong>hibernate_after</strong></li><li><strong>ciphers</strong> (use old string format)</li></ul><p>Note that <strong>verify_fun</strong> needs to be written in a different
form than the corresponding SSL/TLS option, since funs are not
accepted on the command line.</p><p>The server can also take the options <strong>dhfile</strong> and
<strong>fail_if_no_peer_cert</strong> (also prefixed).</p><p><strong>client_</strong>-prefixed options are used when the distribution 
initiates a connection to another node. <strong>server_</strong>-prefixed 
options are used when accepting a connection from a remote node.</p><p>Raw socket options, such as <strong>packet</strong> and <strong>size</strong> must not 
be specified on the command line.</p><p>The command-line argument for specifying the SSL/TLS options is named
<strong>-ssl_dist_opt</strong> and is to be followed by pairs of
SSL options and their values. Argument <strong>-ssl_dist_opt</strong> can
be repeated any number of times.</p><p>
An example command line doing the same as the example
in the previous section can now look as follows
(line breaks in the command are for readability, 
and shall not be there when typed):
</p><pre><code class="">
$ erl -boot /home/me/ssl/start_ssl -proto_dist inet_tls
  -ssl_dist_opt server_certfile "/home/me/ssl/erlserver.pem"
  -ssl_dist_opt server_secure_renegotiate true client_secure_renegotiate true
  -sname ssl_test
Erlang (BEAM) emulator version 5.0 [source]

Eshell V5.0  (abort with ^G)
(ssl_test@myhost)1&gt;
    </code></pre><h4>Setting up Environment to Always Use SSL/TLS (Legacy)</h4><p>A convenient way to specify arguments to Erlang is to use environment 
variable <strong>ERL_FLAGS</strong>. All the flags needed to
use the SSL/TLS distribution can be specified in that variable and are
then interpreted as command-line arguments for all
subsequent invocations of Erlang.</p><p>In a Unix (Bourne) shell, it can look as follows (line breaks are for
readability, they are not to be there when typed):</p><pre><code class="">
$ ERL_FLAGS="-boot /home/me/ssl/start_ssl -proto_dist inet_tls
  -ssl_dist_opt server_certfile /home/me/ssl/erlserver.pem
  -ssl_dist_opt server_secure_renegotiate true client_secure_renegotiate true"
$ export ERL_FLAGS
$ erl -sname ssl_test
Erlang (BEAM) emulator version 5.0 [source]
 
Eshell V5.0  (abort with ^G)
(ssl_test@myhost)1&gt; init:get_arguments().
[{root,["/usr/local/erlang"]},
 {progname,["erl "]},
 {sname,["ssl_test"]},
 {boot,["/home/me/ssl/start_ssl"]},
 {proto_dist,["inet_tls"]},
 {ssl_dist_opt,["server_certfile","/home/me/ssl/erlserver.pem"]},
 {ssl_dist_opt,["server_secure_renegotiate","true",
                "client_secure_renegotiate","true"]
 {home,["/home/me"]}]    </code></pre><p>The <strong>init:get_arguments()</strong> call verifies that the correct
arguments are supplied to the emulator.</p><h4>Using SSL/TLS distribution over IPv6</h4><p>It is possible to use SSL/TLS distribution over IPv6 instead of
IPv4. To do this, pass the option <strong>-proto_dist inet6_tls</strong>
instead of <strong>-proto_dist inet_tls</strong> when starting Erlang,
either on the command line or in the <strong>ERL_FLAGS</strong> environment
variable.</p><p>An example command line with this option would look like this:</p><pre><code class="">
$ erl -boot /home/me/ssl/start_ssl -proto_dist inet6_tls
  -ssl_dist_optfile "/home/me/ssl/ssl_test@myhost.conf"
  -sname ssl_test
    </code></pre><p>A node started in this way will only be able to communicate with
other nodes using SSL/TLS distribution over IPv6.</p><h4>Purpose</h4><p>This section describes the current state of standards compliance of the ssl application.</p><h4>Common (pre TLS 1.3)</h4><ul><li>For security reasons RSA key exchange cipher suites are no longer supported by default, but can be configured. (OTP 21) </li><li>For security reasons DES cipher suites are no longer supported by default, but can be configured. (OTP 20) </li><li>For security reasons 3DES cipher suites are no longer supported by default, but can be configured. (OTP 21) </li><li>Renegotiation Indication Extension <a href="http://www.ietf.org/rfc/rfc5746.txt">RFC 5746</a> is supported </li><li>Ephemeral Diffie-Hellman cipher suites are supported, but not Diffie Hellman Certificates cipher suites. </li><li>Elliptic Curve cipher suites are supported if the Crypto application supports it and named curves are used. </li><li>Export cipher suites are not supported as the U.S. lifted its export restrictions in early 2000. </li><li>IDEA cipher suites are not supported as they have become deprecated by the TLS 1.2 specification so it is not motivated to implement them. </li><li>Compression is not supported. </li></ul><h4>Common</h4><ul><li>CRL validation is supported.</li><li>Policy certificate extensions are not supported.</li><li>'Server Name Indication' extension (<a href="http://www.ietf.org/rfc/rfc6066.txt">RFC 6066</a>) is supported.</li><li>Application Layer Protocol Negotiation (ALPN) and its successor Next Protocol Negotiation (NPN) are supported. </li><li>It is possible to use Pre-Shared Key (PSK) and Secure Remote Password (SRP) cipher suites, but they are not enabled by default. </li></ul><h4>SSL 2.0</h4><p>For security reasons SSL-2.0 is not supported. Interoperability with SSL-2.0 enabled clients dropped. (OTP 21)</p><h4>SSL 3.0</h4><p>For security reasons SSL-3.0 is no longer supported by default, but can be configured. (OTP 19)</p><h4>TLS 1.0</h4><p>For security reasons TLS-1.0 is no longer supported by default, but can be configured. (OTP 22)</p><h4>TLS 1.1</h4><p>For security reasons TLS-1.1 is no longer supported by default, but can be configured. (OTP 22)</p><h4>TLS 1.2</h4><p>Supported</p><h4>DTLS 1.0</h4><p>For security reasons DTLS-1.0 (based on TLS 1.1) is no longer supported by default, but can be configured. (OTP 22)</p><h4>DTLS 1.2</h4><p>Supported (based on TLS 1.2)</p><h4>DTLS 1.3</h4><p>Not yet supported</p><h4>TLS 1.3</h4><p>OTP-22 introduces basic support for TLS 1.3 on the server side. Basic functionality
covers a simple TLS 1.3 handshake with support of the mandatory extensions
(supported_groups, signature_algorithms, key_share, supported_versions and
signature_algorithms_cert). The server supports a selective set of cryptographic algorithms:</p><ul><li>Key Exchange: ECDHE</li><li>Groups: all standard groups supported for the Diffie-Hellman key exchange</li><li>Ciphers: TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256 and TLS_AES_128_CCM_SHA256</li><li>Signature Algorithms: RSA and RSA PSS</li><li>Certificates: currently only certificates with RSA keys are supported</li></ul><p>Other notable features:</p><ul><li>The server supports the HelloRetryRequest mechanism</li><li>PSK and session resumption not supported</li><li>Early data and 0-RTT not supported</li><li>Key and Initialization Vector Update not supported</li></ul><p>For more detailed information see the
<a href="#soc_table">Standards Compliance</a> below.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Note that the client side is not yet functional. It is planned to be released
later in OTP-22.</p></div><p> The following table describes the current state of standards compliance for TLS 1.3.</p><p>(<em>C</em> = Compliant, <em>NC</em> = Non-Compliant, <em>PC</em> = Partially-Compliant,
<em>NA</em> = Not Applicable)</p><a name="soc_table"></a><table class="table table-bordered table-hover table-striped"><caption>Standards Compliance</caption><tbody><tr><td><em>Section</em></td><td><em>Feature</em></td><td><em>State</em></td><td><em>Since</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-1.2"> 1.3. Updates Affecting TLS 1.2 </a> </td><td></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>Version downgrade protection mechanism</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>RSASSA-PSS signature schemes</td><td><em>PC</em></td><td>22</td></tr><tr><td></td><td>supported_versions (ClientHello) extension</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>signature_algorithms_cert extension</td><td><em>C</em></td><td>22</td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-2"> 2. Protocol Overview </a> </td><td></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>(EC)DHE</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>PSK-only</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>PSK with (EC)DHE</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-2.1"> 2.1. Incorrect DHE share </a> </td><td>HelloRetryRequest</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-2.2"> 2.2. Resumption and Pre-Shared Key (PSK) </a> </td><td></td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-2.3"> 2.3. 0-RTT Data </a> </td><td></td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.1.1"> 4.1.1. Cryptographic Negotiation </a> </td><td></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>supported_groups extension</td><td><em>C</em></td><td></td></tr><tr><td></td><td>signature_algorithms extension</td><td><em>C</em></td><td></td></tr><tr><td></td><td>pre_shared_key extension</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.1.2"> 4.1.2. Client Hello </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td>server_name (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>max_fragment_length (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>status_request (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_groups (RFC7919)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signature_algorithms (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>use_srtp (RFC5764)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>heartbeat (RFC6520)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>application_layer_protocol_negotiation (RFC7301)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signed_certificate_timestamp (RFC6962)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>client_certificate_type (RFC7250)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>server_certificate_type (RFC7250)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>padding (RFC7685)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>key_share (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>pre_shared_key (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>psk_key_exchange_modes (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>early_data (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>cookie (RFC8446) </td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_versions (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>certificate_authorities (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>oid_filters (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>post_handshake_auth (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signature_algorithms_cert (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>server_name (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>max_fragment_length (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>status_request (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_groups (RFC7919)</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>signature_algorithms (RFC8446)</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>use_srtp (RFC5764)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>heartbeat (RFC6520)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>application_layer_protocol_negotiation (RFC7301)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signed_certificate_timestamp (RFC6962)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>client_certificate_type (RFC7250)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>server_certificate_type (RFC7250)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>padding (RFC7685)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>key_share (RFC8446)</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>pre_shared_key (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>psk_key_exchange_modes (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>early_data (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>cookie (RFC8446) </td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_versions (RFC8446)</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>certificate_authorities (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>oid_filters (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>post_handshake_auth (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signature_algorithms_cert (RFC8446)</td><td><em>C</em></td><td>22</td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.1.3"> 4.1.3. Server Hello </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td>Version downgrade protection</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>key_share (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>pre_shared_key (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_versions (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>Version downgrade protection</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>key_share (RFC8446)</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>pre_shared_key (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_versions (RFC8446)</td><td><em>C</em></td><td>22</td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.1.4"> 4.1.4. Hello Retry Request </a> </td><td><em>Server</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>key_share (RFC8446)</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>cookie (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_versions (RFC8446)</td><td><em>C</em></td><td>22</td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.1"> 4.2.1. Supported Versions </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.2"> 4.2.2. Cookie </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.3"> 4.2.3. Signature Algorithms </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pkcs1_sha256</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pkcs1_sha384</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pkcs1_sha512</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ecdsa_secp256r1_sha256</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ecdsa_secp384r1_sha384</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ecdsa_secp521r1_sha512</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_rsae_sha256</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_rsae_sha384</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_rsae_sha512</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ed25519</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ed448</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_pss_sha256</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_pss_sha384</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_pss_sha512</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pkcs1_sha1</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ecdsa_sha1</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>rsa_pkcs1_sha256</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>rsa_pkcs1_sha384</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>rsa_pkcs1_sha512</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>ecdsa_secp256r1_sha256</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ecdsa_secp384r1_sha384</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ecdsa_secp521r1_sha512</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_rsae_sha256</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>rsa_pss_rsae_sha384</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>rsa_pss_rsae_sha512</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>ed25519</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ed448</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_pss_sha256</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_pss_sha384</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pss_pss_sha512</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>rsa_pkcs1_sha1</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>ecdsa_sha1</td><td><em>C</em></td><td>22</td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.4"> 4.2.4. Certificate Authorities </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.5"> 4.2.5. OID Filters </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.6"> 4.2.6. Post-Handshake Client Authentication </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.7"> 4.2.7. Supported Groups </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td>secp256r1</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>secp384r1</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>secp521r1</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>x25519</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>x448</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ffdhe2048</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ffdhe3072</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ffdhe4096</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ffdhe6144</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>ffdhe8192</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>secp256r1</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>secp384r1</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>secp521r1</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>x25519</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>x448</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>ffdhe2048</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>ffdhe3072</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>ffdhe4096</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>ffdhe6144</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>ffdhe8192</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.8"> 4.2.8. Key Share </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.9"> 4.2.9. Pre-Shared Key Exchange Modes </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.10"> 4.2.10. Early Data Indication </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.11"> 4.2.11. Pre-Shared Key Extension </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.11.1"> 4.2.11.1. Ticket Age </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.11.2"> 4.2.11.2. PSK Binder </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.2.11.3"> 4.2.11.3. Processing Order </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.3.1"> 4.3.1. Encrypted Extensions </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td>server_name (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>max_fragment_length (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_groups (RFC7919)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>use_srtp (RFC5764)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>heartbeat (RFC6520)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>application_layer_protocol_negotiation (RFC7301)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>client_certificate_type (RFC7250)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>server_certificate_type (RFC7250)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>early_data (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_versions (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>server_name (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>max_fragment_length (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_groups (RFC7919)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>use_srtp (RFC5764)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>heartbeat (RFC6520)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>application_layer_protocol_negotiation (RFC7301)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>client_certificate_type (RFC7250)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>server_certificate_type (RFC7250)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>early_data (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>supported_versions (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.3.2"> 4.3.2. Certificate Request </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td>status_request (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signature_algorithms (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signed_certificate_timestamp (RFC6962)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>certificate_authorities (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>oid_filters (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signature_algorithms_cert (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>status_request (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signature_algorithms (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signed_certificate_timestamp (RFC6962)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>certificate_authorities (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>oid_filters (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signature_algorithms_cert (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.4.1"> 4.4.1. The Transcript Hash </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.4.2"> 4.4.2. Certificate </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td>status_request (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signed_certificate_timestamp (RFC6962)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>status_request (RFC6066)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>signed_certificate_timestamp (RFC6962)</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.4.2.1"> 4.4.2.1. OCSP Status and SCT Extensions </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.4.2.2"> 4.4.2.2. Server Certificate Selection </a> </td><td><em>Client</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td>certificate type MUST be X.509v3</td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td>certificate's public key is compatible</td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td>The certificate MUST allow the key to be used for signing</td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td>server_name and certificate_authorities are used</td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td><em>Server</em></td><td><em>PC</em></td><td><em></em></td></tr><tr><td></td><td>certificate type MUST be X.509v3</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>certificate's public key is compatible</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>The certificate MUST allow the key to be used for signing</td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>server_name and certificate_authorities are used</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.4.2.3"> 4.4.2.3. Client Certificate Selection </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.4.2.4"> 4.4.2.4. Receiving a Certificate Message </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.4.3"> 4.4.3. Certificate Verify </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.4.4"> 4.4.4. Finished </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.5"> 4.5. End of Early Data </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.6.1"> 4.6.1. New Session Ticket Message </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td>early_data (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td>early_data (RFC8446)</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.6.2"> 4.6.2. Post-Handshake Authentication </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-4.6.3"> 4.6.3. Key and Initialization Vector Update </a> </td><td><em>Client</em></td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Server</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-5.1"> 5.1. Record Layer </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>MUST NOT be interleaved with other record types</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>MUST NOT span key changes</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>MUST NOT send zero-length fragments</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>Alert messages MUST NOT be fragmented</td><td><em>C</em></td><td>22</td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-5.2"> 5.2. Record Payload Protection </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-5.3"> 5.3. Per-Record Nonce </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-5.4"> 5.4. Record Padding </a> </td><td><em></em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>MAY choose to pad</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>MUST NOT send Handshake and Alert records that have a zero-length TLSInnerPlaintext.content</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>The padding sent is automatically verified</td><td><em>C</em></td><td>22</td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-5.5"> 5.5. Limits on Key Usage </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-6.1"> 6.1. Closure Alerts </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td>close_notify</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>user_cancelled</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-6.2"> 6.2. Error Alerts </a> </td><td><em></em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-7.1"> 7.1. Key Schedule </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-7.2"> 7.2. Updating Traffic Secrets </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-7.3"> 7.3. Traffic Key Calculation </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-7.5"> 7.5. Exporters </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-8"> 8. 0-RTT and Anti-Replay </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-8.1"> 8.1. Single-Use Tickets </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-8.2"> 8.2. Client Hello Recording </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-8.3"> 8.3. Freshness Checks </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-9.1"> 9.1. Mandatory-to-Implement Cipher Suites </a> </td><td><em></em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>MUST implement the TLS_AES_128_GCM_SHA256</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>SHOULD implement the TLS_AES_256_GCM_SHA384</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>SHOULD implement the TLS_CHACHA20_POLY1305_SHA256</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td><em>Digital signatures</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>MUST support rsa_pkcs1_sha256 (for certificates)</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>MUST support rsa_pss_rsae_sha256 (for CertificateVerify and certificates)</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>MUST support ecdsa_secp256r1_sha256</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>Key Exchange</em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>MUST support key exchange with secp256r1</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>SHOULD support key exchange with X25519</td><td><em>C</em></td><td>22</td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-9.2"> 9.2. Mandatory-to-Implement Extensions </a> </td><td><em></em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>Supported Versions</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>Cookie</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>Signature Algorithms</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>Signature Algorithms Certificate</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>Negotiated Groups</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>Key Share</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>Server Name Indication</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>MUST send and use these extensions</em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td></td><td>"supported_versions" is REQUIRED for ClientHello, ServerHello and HelloRetryRequest</td><td><em>PC</em></td><td>22</td></tr><tr><td></td><td>"signature_algorithms" is REQUIRED for certificate authentication</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>"supported_groups" is REQUIRED for ClientHello messages using (EC)DHE key exchange</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>"key_share" is REQUIRED for (EC)DHE key exchange</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>"pre_shared_key" is REQUIRED for PSK key agreement</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>"psk_key_exchange_modes" is REQUIRED for PSK key agreement</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>TLS 1.3 ClientHello</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td>If not containing a "pre_shared_key" extension, it MUST contain both a "signature_algorithms" extension and a "supported_groups" extension.</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>If containing a "supported_groups" extension, it MUST also contain a "key_share" extension, and vice versa.  An empty KeyShare.client_shares vector is permitted.</td><td><em>NC</em></td><td></td></tr><tr><td></td><td><em>TLS 1.3 ServerHello</em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>MUST support the use of the "server_name" extension</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-9.3"> 9.3. Protocol Invariants </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td><em>MUST correctly handle extensible fields</em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td></td><td>A client sending a ClientHello MUST support all parameters advertised in it.</td><td><em>NC</em></td><td></td></tr><tr><td></td><td>A middlebox which terminates a TLS connection MUST behave as a compliant TLS server</td><td><em>NA</em></td><td></td></tr><tr><td></td><td>A middlebox which forwards ClientHello parameters it does not understand MUST NOT process any messages beyond that ClientHello.</td><td><em>NA</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-B.4"> B.4. Cipher Suites </a> </td><td><em></em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td></td><td>TLS_AES_128_GCM_SHA256</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>TLS_AES_256_GCM_SHA384</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>TLS_CHACHA20_POLY1305_SHA256</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>TLS_AES_128_CCM_SHA256</td><td><em>C</em></td><td>22</td></tr><tr><td></td><td>TLS_AES_128_CCM_8_SHA256</td><td><em>NC</em></td><td></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-C.1"> C.1. Random Number Generation and Seeding </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-C.2"> C.2. Certificates and Authentication </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-C.3"> C.3. Implementation Pitfalls </a> </td><td><em></em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-C.4"> C.4. Client Tracking Prevention </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-C.5"> C.5. Unauthenticated Operation </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-D.1"> D.1. Negotiating with an Older Server </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-D.2"> D.2. Negotiating with an Older Client </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-D.3"> D.3. 0-RTT Backward Compatibility </a> </td><td><em></em></td><td><em>NC</em></td><td><em></em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-D.4"> D.4. Middlebox Compatibility Mode </a> </td><td><em></em></td><td><em>PC</em></td><td><em>22</em></td></tr><tr><td> <a href="https://tools.ietf.org/html/rfc8446#section-D.5"> D.5. Security Restrictions Related to Backward Compatibility </a> </td><td><em></em></td><td><em>C</em></td><td><em>22</em></td></tr></tbody></table><h3>ssl</h3><p>The ssl application provides secure communication over
  sockets.</p><p>
The ssl application is an implementation of the SSL, TLS and DTLS protocols in Erlang.
For current statement of standards compliance see the <a href="standards_compliance">User's Guide</a>.</p><h4>DEPENDENCIES</h4><p>The SSL application uses the <strong>public_key</strong>, <strong>asn1</strong> and
Crypto application to handle public keys and encryption, hence
these applications must be loaded for the SSL application to work. 
In an embedded environment this means they must be started with
<strong>application:start/[1,2]</strong> before the SSL application is 
started.</p><h4>CONFIGURATION</h4><p>The application environment configuration parameters in this section 
are defined for the SSL application. For more information 
about configuration parameters, see the 
<a href="./application">application(3)</a>
manual page in Kernel.</p><p>The environment parameters can be set on the command line,
for example:</p><p><strong>erl -ssl protocol_version "['tlsv1.2', 'tlsv1.1']"</strong></p><dl><dt><strong>protocol_version = </strong><a href="./ssl#type-protocol">ssl:ssl_tls_protocol()</a><strong>&lt;optional&gt;</strong></dt><dd><p>Protocol supported by started clients and
servers. If this option is not set, it defaults to all
TLS protocols currently supported by the SSL application.
This option can be overridden by the version option
to <strong>ssl:connect/[2,3]</strong> and <strong>ssl:listen/2</strong>.</p></dd><dt><strong>dtls_protocol_version = </strong><a href="./ssl#type-protocol">ssl:dtls_protocol()</a><strong>&lt;optional&gt;</strong></dt><dd><p>Protocol supported by started clients and
servers. If this option is not set, it defaults to all
DTLS protocols currently supported by the SSL application.
This option can be overridden by the version option
to <strong>ssl:connect/[2,3]</strong> and <strong>ssl:listen/2</strong>.</p></dd><dt><strong>session_lifetime = integer() &lt;optional&gt;</strong></dt><dd><p>Maximum lifetime of the session data in seconds. Defaults to 24 hours which is the maximum
recommended lifetime by <a href="http://www.ietf.org/rfc/5246rfc.txt">RFC 5246</a>. However
sessions may be invalidated earlier due to the maximum limitation of the session cache table.
</p></dd><dt><strong>session_cb = atom() &lt;optional&gt;</strong></dt><dd><p>Name of the session cache callback module that implements
the <strong>ssl_session_cache_api</strong> behavior. Defaults to
<strong>ssl_session_cache</strong>.</p></dd><dt><strong>session_cb_init_args = proplist:proplist() &lt;optional&gt;</strong></dt><dd><p>List of extra user-defined arguments to the <strong>init</strong> function
in the session cache callback module. Defaults to <strong>[]</strong>.</p></dd><dt><strong>session_cache_client_max = integer() &lt;optional&gt;</strong><br/></dt><dd><p>Limits the growth of the clients session cache, that is
how many sessions towards servers that are cached to be used by
new client connections.  If the maximum number of sessions is
reached, the current cache entries will be invalidated
regardless of their remaining lifetime. Defaults to
1000. Recommended ssl-8.2.1 or later for this option to work as intended.</p></dd><dt> <strong>session_cache_server_max = integer() &lt;optional&gt;</strong></dt><dd><p>Limits the growth of the servers session cache, that is
how many client sessions are cached by the server. If the
maximum number of sessions is reached, the current cache entries
will be invalidated regardless of their remaining
lifetime. Defaults to 1000. Recommended ssl-8.2.1 or later for this option to work as intended.</p></dd><dt><strong>ssl_pem_cache_clean = integer() &lt;optional&gt;</strong></dt><dd> <p>
Number of milliseconds between PEM cache validations. Defaults to 2 minutes.
</p> <a href="./ssl#clear_pem_cache-0">ssl:clear_pem_cache/0</a> </dd><dt><strong>bypass_pem_cache = boolean() &lt;optional&gt;</strong></dt><dd> <p>Introduced in ssl-8.0.2. Disables the PEM-cache.
Can be used as a workaround for the PEM-cache bottleneck
before ssl-8.1.1. Defaults to false.
</p> </dd><dt><strong>alert_timeout = integer() &lt;optional&gt;</strong></dt><dd> <p>
Number of milliseconds between sending of a fatal alert and
closing the connection. Waiting a little while improves the
peers chances to properly receiving the alert so it may
shutdown gracefully. Defaults to 5000 milliseconds.   
</p> </dd><dt><strong>internal_active_n = integer() &lt;optional&gt;</strong></dt><dd> <p>
For TLS connections this value is used to handle the
internal socket. As the implementation was changed from an
active once to an active N behavior (N = 100), for
performance reasons, this option exist for possible tweaking
or restoring of the old behavior (internal_active_n = 1) in
unforeseen scenarios.  The option will not affect erlang
distribution over TLS that will always run in active N mode.
Added in ssl-9.1 (OTP-21.2).
</p> </dd></dl><h4>ERROR LOGGER AND EVENT HANDLERS</h4><p>The SSL application uses the default <a href="./error_logger">OTP error logger</a> to log
unexpected errors and TLS/DTLS alerts. The logging of TLS/DTLS alerts may be
turned off with the <strong>log_alert</strong> option. </p><h4>SEE ALSO</h4><p><a href="./application">application(3)</a></p><h3>ssl</h3><p>Interface Functions for Secure Socket Layer</p><p>
This module contains interface functions for the SSL/TLS/DTLS protocol.
For detailed information about the supported standards see 
<a href="ssl_app">ssl(6)</a>.
</p><h3>Data Types</h3><h4>Types used in SSL/TLS/DTLS</h4><span class="name">socket</span><span class="name">sslsocket</span><p>An opaque reference to the TLS/DTLS connection, may be used for equality matching.</p><span class="name">tls_option</span><span class="name">tls_client_option</span><span class="name">tls_server_option</span><span class="name">socket_option</span><p>The default socket options are
<strong>[{mode,list},{packet, 0},{header, 0},{active, true}]</strong>.</p><p>For valid options, see the
<a href="./inet">inet(3)</a>,
<a href="./gen_tcp">gen_tcp(3)</a> and
<a href="./gen_tcp">gen_udp(3)</a> 
manual pages in Kernel. Note that stream oriented options such as packet
are only relevant for SSL/TLS and not DTLS</p><span class="name">active_msgs</span><p>When a TLS/DTLS socket is in active mode (the default), data from the
socket is delivered to the owner of the socket in the form of
messages as described above.</p><p>The <strong>ssl_passive</strong> message is sent only when the socket is in
<strong>{active, N}</strong> mode and the counter dropped to 0. It indicates
that the socket has transitioned to passive (<strong>{active, false}</strong>) mode.</p><span class="name">transport_option</span><p>Defaults to <strong>{gen_tcp, tcp, tcp_closed, tcp_error, tcp_passive}</strong> for TLS (for backward compatibility a four
tuple will be converted to a five tuple with the last element
"second_element"_passive) and <strong>{gen_udp, udp, udp_closed, udp_error}</strong> for DTLS (might also be changed to five tuple in
the future). Can be used to customize the transport layer. The
tag values should be the values used by the underlying
transport in its active mode messages. For TLS the callback
module must implement a reliable transport protocol, behave as
<strong>gen_tcp</strong>, and have functions corresponding to
<strong>inet:setopts/2</strong>, <strong>inet:getopts/2</strong>,
<strong>inet:peername/1</strong>, <strong>inet:sockname/1</strong>, and
<strong>inet:port/1</strong>.  The callback <strong>gen_tcp</strong> is treated
specially and calls <strong>inet</strong> directly. For DTLS this
feature must be considered exprimental.
</p><span class="name">host</span><span class="name">hostname</span><span class="name">ip_address</span><span class="name">protocol_version</span><span class="name">tls_version</span><span class="name">dtls_version</span><span class="name">tls_legacy_version</span><span class="name">dtls_legacy_version</span><span class="name">prf_random</span><span class="name">verify_type</span><span class="name">ciphers</span><span class="name">erl_cipher_suite</span><span class="name">cipher</span><span class="name">legacy_cipher</span><span class="name">cipher_filters</span><span class="name">hash</span><span class="name">sha2</span><span class="name">legacy_hash</span><span class="name">old_cipher_suite</span><span class="name">signature_algs</span><span class="name">sign_algo</span><span class="name">sign_scheme</span><span class="name">kex_algo</span><span class="name">algo_filter</span><span class="name">named_curve</span><span class="name">psk_identity</span><span class="name">srp_identity</span><span class="name">srp_param_type</span><span class="name">app_level_protocol</span><span class="name">protocol_extensions</span><span class="name">error_alert</span><span class="name">tls_alert</span><span class="name">reason</span><h4>TLS/DTLS OPTION DESCRIPTIONS - COMMON for SERVER and CLIENT</h4><span class="name">common_option</span><span class="name">protocol</span><p>Choose TLS or DTLS protocol for the transport layer security.
Defaults to <strong>tls</strong>. For DTLS other transports than UDP are not yet supported.</p><span class="name">handshake_completion</span><p>Defaults to <strong>full</strong>. If hello is specified the handshake will
pause after the hello message and give the user a possibility make decisions
based on hello extensions before continuing or aborting the handshake by calling
<a href="#handshake_continue-3"> handshake_continue/3</a> or
<a href="#handshake_cancel-1"> handshake_cancel/1</a></p><span class="name">cert</span><p>The DER-encoded users certificate. If this option
is supplied, it overrides option <strong>certfile</strong>.</p><span class="name">cert_pem</span><p>Path to a file containing the user certificate on PEM format.</p><span class="name">key</span><p>The DER-encoded user's private key or a map refering to a crypto
engine and its key reference that optionally can be password protected,
seealso <a href="../crypto/crypto#engine_load-4"> crypto:engine_load/4 </a> and  <a href="./engine_load"> Crypto's Users Guide</a>. If this option 
is supplied, it overrides option <strong>keyfile</strong>.</p><span class="name">key_pem</span><p>Path to the file containing the user's
private PEM-encoded key. As PEM-files can contain several
entries, this option defaults to the same file as given by
option <strong>certfile</strong>.</p><span class="name">key_password</span><p>String containing the user's password. Only used if the 
private keyfile is password-protected.</p><span class="name">cipher_suites</span><p>Supported cipher suites. The function
<strong>cipher_suites/2</strong> can be used to find all ciphers that
are supported by default. <strong>cipher_suites(all, 'tlsv1.2')</strong> can be
called to find all available cipher suites. Pre-Shared Key
(<a href="http://www.ietf.org/rfc/rfc4279.txt">RFC 4279</a> and <a href="http://www.ietf.org/rfc/rfc5487.txt">RFC 5487</a>),
Secure Remote Password (<a href="http://www.ietf.org/rfc/rfc5054.txt">RFC 5054</a>),
RC4, 3DES, DES cipher suites, and anonymous cipher suites only work if
explicitly enabled by this option; they are supported/enabled
by the peer also.  Anonymous cipher suites are supported for
testing purposes only and are not be used when security
matters.</p><span class="name">signature_schemes</span><p>
In addition to the signature_algorithms extension from TLS 1.2,
<a href="http://www.ietf.org/rfc/rfc8446.txt#section-4.2.3">TLS 1.3 (RFC 5246 Section 4.2.3)</a>adds the signature_algorithms_cert extension
which enables having special requirements on the signatures used in the
certificates that differs from the requirements on digital signatures as a whole.
If this is not required this extension is not needed.
</p><p>
The client will send a signature_algorithms_cert extension (ClientHello),
if TLS version 1.3 or later is used, and the signature_algs_cert option is
explicitly specified. By default, only the signature_algs extension is sent.
</p><p>
The signature schemes shall be ordered according to the client's preference
(favorite choice first).
</p><span class="name">secure_renegotiation</span><p>Specifies if to reject renegotiation attempt that does
not live up to <a href="http://www.ietf.org/rfc/rfc5746.txt">RFC 5746</a>.  By
default <strong>secure_renegotiate</strong> is set to <strong>true</strong>, that
is, secure renegotiation is enforced. If set to <strong>false</strong>
secure renegotiation will still be used if possible, but it
falls back to insecure renegotiation if the peer does not
support <a href="http://www.ietf.org/rfc/rfc5746.txt">RFC 5746</a>.</p><span class="name">allowed_cert_chain_length</span><p>Maximum number of non-self-issued
intermediate certificates that can follow the peer certificate 
in a valid certification path. So, if depth is 0 the PEER must 
be signed by the trusted ROOT-CA directly; if 1 the path can 
be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, 
ROOT-CA, and so on. The default value is 1.</p><span class="name">custom_verify</span><p>The verification fun is to be defined as follows:</p><pre><code class="">
fun(OtpCert :: #'OTPCertificate'{}, Event :: {bad_cert, Reason :: atom() |
             {revoked, atom()}} |
	     {extension, #'Extension'{}}, InitialUserState :: term()) -&gt;
	{valid, UserState :: term()} | {valid_peer, UserState :: term()} |
	{fail, Reason :: term()} | {unknown, UserState :: term()}.
	</code></pre><p>The verification fun is called during the X509-path
validation when an error or an extension unknown to the SSL
application is encountered. It is also called when a
certificate is considered valid by the path validation to
allow access to each certificate in the path to the user
application. It differentiates between the peer certificate
and the CA certificates by using <strong>valid_peer</strong> or
<strong>valid</strong> as second argument to the verification fun. See
the <a href="./public_key_records">public_key User's Guide</a> for definition of
<strong>#'OTPCertificate'{}</strong> and <strong>#'Extension'{}</strong>.</p><ul><li><p>If the verify callback fun returns <strong>{fail, Reason}</strong>, the verification process is immediately
stopped, an alert is sent to the peer, and the TLS/DTLS
handshake terminates.</p></li><li><p>If the verify callback fun returns <strong>{valid, UserState}</strong>,
the verification process continues.</p></li><li><p>If the verify callback fun always returns
<strong>{valid, UserState}</strong>, the TLS/DTLS handshake does not
terminate regarding verification failures and the connection is
established.</p></li><li><p>If called with an extension unknown to the user application,
return value <strong>{unknown, UserState}</strong> is to be used.</p> <p>Note that if the fun returns <strong>unknown</strong> for an extension marked
as critical, validation will fail.</p> </li></ul><p>Default option <strong>verify_fun</strong> in <strong>verify_peer mode</strong>:</p><pre><code class="">
{fun(_,{bad_cert, _} = Reason, _) -&gt;
	 {fail, Reason};
    (_,{extension, _}, UserState) -&gt;
	 {unknown, UserState};
    (_, valid, UserState) -&gt;
	 {valid, UserState};
    (_, valid_peer, UserState) -&gt;
         {valid, UserState}
 end, []}
      </code></pre><p>Default option <strong>verify_fun</strong> in mode <strong>verify_none</strong>:</p><pre><code class="">
{fun(_,{bad_cert, _}, UserState) -&gt;
	 {valid, UserState};
    (_,{extension, #'Extension'{critical = true}}, UserState) -&gt;
	 {valid, UserState};
    (_,{extension, _}, UserState) -&gt;
	 {unknown, UserState};
    (_, valid, UserState) -&gt;
	 {valid, UserState};
    (_, valid_peer, UserState) -&gt;
         {valid, UserState}
 end, []}
      </code></pre><p>The possible path validation errors are given on form
<strong>{bad_cert, Reason}</strong> where <strong>Reason</strong> is:</p><dl><dt><strong>unknown_ca</strong></dt><dd><p>No trusted CA was found in the trusted store. The
trusted CA is normally a so called ROOT CA, which is a
self-signed certificate. Trust can be claimed for an
intermediate CA (trusted anchor does not have to be
self-signed according to X-509) by using option
<strong>partial_chain</strong>.</p> </dd><dt><strong>selfsigned_peer</strong></dt><dd><p>The chain consisted only of one self-signed certificate.</p></dd><dt><strong>PKIX X-509-path validation error</strong></dt><dd><p>For possible reasons, see <a href="../public_key/public_key#pkix_path_validation-3">public_key:pkix_path_validation/3</a>
</p></dd></dl><span class="name">crl_check</span><p>Perform CRL (Certificate Revocation List) verification
<a href="../public_key/public_key#pkix_crls_validate-3"> (public_key:pkix_crls_validate/3)</a> on all the
certificates during the path validation <a href="../public_key/public_key#pkix_path_validation-3">(public_key:pkix_path_validation/3) </a>
of the certificate chain. Defaults to <strong>false</strong>.</p><dl><dt><strong>peer</strong></dt><dd>check is only performed on the peer certificate.</dd><dt><strong>best_effort</strong></dt><dd>if certificate revocation status cannot be determined it will be accepted as valid.</dd></dl><p>The CA certificates specified for the connection will be used to 
construct the certificate chain validating the CRLs.</p><p>The CRLs will be fetched from a local or external cache. See
<a href="./ssl_crl_cache_api">ssl_crl_cache_api(3)</a>.</p><span class="name">crl_cache_opts</span><p>Specify how to perform lookup and caching of certificate revocation lists.
<strong>Module</strong> defaults to <a href="./ssl_crl_cache">ssl_crl_cache</a>
with <strong> DbHandle </strong> being <strong>internal</strong> and an
empty argument list.</p><p>There are two implementations available:</p><dl><dt><strong>ssl_crl_cache</strong></dt><dd> <p>This module maintains a cache of CRLs.  CRLs can be
added to the cache using the function <a href="../ssl/ssl_crl_cache#insert-1">ssl_crl_cache:insert/1</a>,
and optionally automatically fetched through HTTP if the
following argument is specified:</p> <dl><dt><strong>{http, timeout()}</strong></dt><dd><p>
Enables fetching of CRLs specified as http URIs in<a href="./public_key_records">X509 certificate extensions</a>.
Requires the OTP inets application.</p> </dd></dl> </dd><dt><strong>ssl_crl_hash_dir</strong></dt><dd> <p>This module makes use of a directory where CRLs are
stored in files named by the hash of the issuer name.</p> <p>The file names consist of eight hexadecimal digits
followed by <strong>.rN</strong>, where <strong>N</strong> is an integer,
e.g. <strong>1a2b3c4d.r0</strong>.  For the first version of the
CRL, <strong>N</strong> starts at zero, and for each new version,
<strong>N</strong> is incremented by one.  The OpenSSL utility
<strong>c_rehash</strong> creates symlinks according to this
pattern.</p> <p>For a given hash value, this module finds all
consecutive <strong>.r*</strong> files starting from zero, and those
files taken together make up the revocation list.  CRL
files whose <strong>nextUpdate</strong> fields are in the past, or
that are issued by a different CA that happens to have the
same name hash, are excluded.</p> <p>The following argument is required:</p> <dl><dt><strong>{dir, string()}</strong></dt><dd><p>Specifies the directory in which the CRLs can be found.</p></dd></dl> </dd></dl><span class="name">root_fun</span><pre><code class="">
fun(Chain::[public_key:der_encoded()]) -&gt;
	{trusted_ca, DerCert::public_key:der_encoded()} | unknown_ca}
	</code></pre><p>Claim an intermediate CA in the chain as trusted. TLS then
performs <a href="../public_key/public_key#pkix_path_validation-3">public_key:pkix_path_validation/3</a>
with the selected CA as trusted anchor and the rest of the chain.</p><span class="name">protocol_versions</span><p>TLS protocol versions supported by started clients and servers.
This option overrides the application environment option
<strong>protocol_version</strong> and  <strong>dtls_protocol_version</strong>. If the environment option is not set, it defaults
to all versions, except SSL-3.0, supported by the SSL application.
See also <a href="./ssl_app">ssl(6).</a></p><span class="name">custom_user_lookup</span><p>The lookup fun is to defined as follows:</p><pre><code class="">
fun(psk, PSKIdentity ::string(), UserState :: term()) -&gt;
	{ok, SharedSecret :: binary()} | error;
fun(srp, Username :: string(), UserState :: term()) -&gt;
	{ok, {SRPParams :: srp_param_type(), Salt :: binary(),
	      DerivedKey :: binary()}} | error.
	</code></pre><p>For Pre-Shared Key (PSK) cipher suites, the lookup fun is
called by the client and server to determine the shared
secret. When called by the client, <strong>PSKIdentity</strong> is set to the
hint presented by the server or to undefined. When called by the
server, <strong>PSKIdentity</strong> is the identity presented by the client.</p><p>For Secure Remote Password (SRP), the fun is only used by the server to
obtain parameters that it uses to generate its session keys.
<strong>DerivedKey</strong> is to be derived according to
<a href="http://tools.ietf.org/html/rfc2945#section-3"> RFC 2945</a> and
<a href="http://tools.ietf.org/html/rfc5054#section-2.4"> RFC 5054</a>:
<strong>crypto:sha([Salt, crypto:sha([Username, &lt;&lt;$:&gt;&gt;, Password])])</strong>
</p><span class="name">session_id</span><p>Identifies a TLS session.</p><span class="name">log_alert</span><p>If set to <strong>false</strong>, error reports are not displayed.
Deprecated in OTP 22, use {log_level, <a href="#type-logging_level">logging_level()</a>} instead.</p><span class="name">logging_level</span><p>Specifies the log level for TLS/DTLS. At verbosity level <strong>notice</strong> and above error reports are
displayed in TLS/DTLS. The level <strong>debug</strong> triggers verbose logging of TLS/DTLS protocol
messages.</p><span class="name">hibernate_after</span><p>When an integer-value is specified, <strong>TLS/DTLS-connection</strong> 
goes into hibernation after the specified number of milliseconds 
of inactivity, thus reducing its memory footprint. When
<strong>undefined</strong> is specified (this is the default), the process 
never goes into hibernation.</p><span class="name">handshake_size</span><p>Integer (24 bits unsigned). Used to limit the size of
valid TLS handshake packets to avoid DoS attacks.
Defaults to 256*1024.</p><span class="name">padding_check</span><p>Affects TLS-1.0 connections only.
If set to <strong>false</strong>, it disables the block cipher padding check
to be able to interoperate with legacy software.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Using <strong>{padding_check, boolean()}</strong> makes TLS
vulnerable to the Poodle attack.</p></div><span class="name">beast_mitigation</span><p>Affects SSL-3.0 and TLS-1.0 connections only. Used to change the BEAST
mitigation strategy to interoperate with legacy software.
Defaults to <strong>one_n_minus_one</strong>.</p><p><strong>one_n_minus_one</strong> - Perform 1/n-1 BEAST mitigation.</p><p><strong>zero_n</strong> - Perform 0/n BEAST mitigation.</p><p><strong>disabled</strong> - Disable BEAST mitigation.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Using <strong>{beast_mitigation, disabled}</strong> makes SSL-3.0 or TLS-1.0
vulnerable to the BEAST attack.</p></div><span class="name">ssl_imp</span><p>Deprecated since OTP-17, has no affect.</p><h4>TLS/DTLS OPTION DESCRIPTIONS - CLIENT</h4><span class="name">client_option</span><span class="name">client_verify_type</span><p>In mode <strong>verify_none</strong> the default behavior is to allow
all x509-path validation errors. See also option  <a href="#type-custom_verify">verify_fun</a>.</p><span class="name">client_reuse_session</span><p>Reuses a specific session earlier saved with the option
<strong>{reuse_sessions, save} since OTP-21.3 </strong>
</p><span class="name">client_reuse_sessions</span><p>When <strong>save</strong> is specified a new connection will be negotiated
and saved for later reuse. The session ID can be fetched with 
<a href="#connection_information-2">connection_information/2</a>
and used with the client option <a href="#type-client_reuse_session">reuse_session</a>
The boolean value true specifies that if possible, automatized session reuse will
be performed. If a new session is created, and is unique in regard 
to previous stored sessions, it will be saved for possible later reuse. Since OTP-21.3</p><span class="name">client_cacerts</span><p>The DER-encoded trusted certificates. If this option
is supplied it overrides option <strong>cacertfile</strong>.</p><span class="name">client_cafile</span><p>Path to a file containing PEM-encoded CA certificates. The CA
certificates are used during server authentication and when building the
client certificate chain.</p><span class="name">client_alpn</span><p>The list of protocols supported by the client to be sent to the
server to be used for an Application-Layer Protocol Negotiation (ALPN).
If the server supports ALPN then it will choose a protocol from this
list; otherwise it will fail the connection with a "no_application_protocol"
alert. A server that does not support ALPN will ignore this value.</p><p>The list of protocols must not contain an empty binary.</p><p>The negotiated protocol can be retrieved using the <strong>negotiated_protocol/1</strong> function.</p><span class="name">client_preferred_next_protocols</span><p>Indicates that the client is to try to perform Next Protocol
Negotiation.</p><p>If precedence is server, the negotiated protocol is the
first protocol to be shown on the server advertised list, which is
also on the client preference list.</p><p>If precedence is client, the negotiated protocol is the
first protocol to be shown on the client preference list, which is
also on the server advertised list.</p><p>If the client does not support any of the server advertised
protocols or the server does not advertise any protocols, the
client falls back to the first protocol in its list or to the
default protocol (if a default is supplied). If the
server does not support Next Protocol Negotiation, the
connection terminates if no default protocol is supplied.</p><span class="name">client_psk_identity</span><p>Specifies the identity the client presents to the server.
The matching secret is found by calling <strong>user_lookup_fun</strong></p><span class="name">client_srp_identity</span><p>Specifies the username and password to use to authenticate
to the server.</p><span class="name">sni</span><p>Specify the hostname to be used in TLS Server Name Indication extension.
If not specified it will default to the <strong>Host</strong> argument of <a href="#connect-3">connect/[3,4]</a>
unless it is of type inet:ipaddress().</p><p>
The <strong>HostName</strong> will also be used in the hostname verification of the peer certificate using
<a href="../public_key/public_key#pkix_verify_hostname-2">public_key:pkix_verify_hostname/2</a>.
</p><p> The special value <strong>disable</strong> prevents the Server Name Indication extension from being sent and
disables the hostname verification check
<a href="../public_key/public_key#pkix_verify_hostname-2">public_key:pkix_verify_hostname/2</a> </p><span class="name">customize_hostname_check</span><p> Customizes the hostname verification of the peer certificate, as different protocols that use
TLS such as HTTP or LDAP may want to do it differently, for possible options see
<a href="../public_key/public_key#pkix_verify_hostname-3">public_key:pkix_verify_hostname/3</a> </p><span class="name">fallback</span><p> Send special cipher suite TLS_FALLBACK_SCSV to avoid undesired TLS version downgrade.
Defaults to false</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Note this option is not needed in normal TLS usage and should not be used
to implement new clients. But legacy clients that retries connections in the following manner</p><p><strong> ssl:connect(Host, Port, [...{versions, ['tlsv2', 'tlsv1.1', 'tlsv1', 'sslv3']}])</strong></p><p><strong>  ssl:connect(Host, Port, [...{versions, [tlsv1.1', 'tlsv1', 'sslv3']}, {fallback, true}])</strong></p><p><strong>  ssl:connect(Host, Port, [...{versions, ['tlsv1', 'sslv3']}, {fallback, true}]) </strong></p><p><strong>  ssl:connect(Host, Port, [...{versions, ['sslv3']}, {fallback, true}]) </strong></p><p>may use it to avoid undesired TLS version downgrade. Note that TLS_FALLBACK_SCSV must also
be supported by the server for the prevention to work.
</p></div><span class="name">client_signature_algs</span><p>In addition to the algorithms negotiated by the cipher
suite used for key exchange, payload encryption, message
authentication and pseudo random calculation, the TLS signature
algorithm extension <a href="http://www.ietf.org/rfc/rfc5246.txt">Section 7.4.1.4.1 in RFC 5246</a> may be
used, from TLS 1.2, to negotiate which signature algorithm to use during the
TLS handshake. If no lower TLS versions than 1.2 are supported,
the client will send a TLS signature algorithm extension
with the algorithms specified by this option.
Defaults to</p><pre><code class="">[
%% SHA2
{sha512, ecdsa},
{sha512, rsa},
{sha384, ecdsa},
{sha384, rsa},
{sha256, ecdsa},
{sha256, rsa},
{sha224, ecdsa},
{sha224, rsa},
%% SHA
{sha, ecdsa},
{sha, rsa},
{sha, dsa},
]</code></pre><p>
The algorithms should be in the preferred order.
Selected signature algorithm can restrict which hash functions
that may be selected. Default support for {md5, rsa} removed in ssl-8.0
</p><h4>TLS/DTLS OPTION DESCRIPTIONS - SERVER</h4><span class="name">server_option</span><span class="name">server_cacerts</span><p>The DER-encoded trusted certificates. If this option
is supplied it overrides option <strong>cacertfile</strong>.</p><span class="name">server_cafile</span><p>Path to a file containing PEM-encoded CA
certificates. The CA certificates are used to build the server
certificate chain and for client authentication. The CAs are
also used in the list of acceptable client CAs passed to the
client when a certificate is requested. Can be omitted if
there is no need to verify the client and if there are no
intermediate CAs for the server certificate.</p><span class="name">dh_der</span><p>The DER-encoded Diffie-Hellman parameters. If
specified, it overrides option <strong>dhfile</strong>.</p><span class="name">dh_file</span><p>Path to a file containing PEM-encoded Diffie Hellman
parameters to be used by the server if a cipher suite using
Diffie Hellman key exchange is negotiated. If not specified,
default parameters are used.</p><span class="name">server_verify_type</span><p>A server only does x509-path validation in mode
<strong>verify_peer</strong>, as it then sends a certificate request to
the client (this message is not sent if the verify option is
<strong>verify_none</strong>).  You can then also want to specify option
<strong>fail_if_no_peer_cert</strong>. </p><span class="name">fail_if_no_peer_cert</span><p>Used together with <strong>{verify, verify_peer}</strong> by an
TLS/DTLS server.  If set to <strong>true</strong>, the server fails if
the client does not have a certificate to send, that is, sends
an empty certificate. If set to <strong>false</strong>, it fails only if
the client sends an invalid certificate (an empty certificate
is considered valid). Defaults to false.</p><span class="name">server_reuse_sessions</span><p>The boolean value true specifies that the server will
agree to reuse sessions. Setting it to false will result in an empty
session table, that is no sessions will be reused. 
See also option <a href="#type-server_reuse_session">reuse_session</a>
</p><span class="name">server_reuse_session</span><p>Enables the TLS/DTLS server to have a local policy
for deciding if a session is to be reused or not.  Meaningful
only if <strong>reuse_sessions</strong> is set to <strong>true</strong>.
<strong>SuggestedSessionId</strong> is a <strong>binary()</strong>,
<strong>PeerCert</strong> is a DER-encoded certificate,
<strong>Compression</strong> is an enumeration integer, and
<strong>CipherSuite</strong> is of type <strong>ciphersuite()</strong>.</p><span class="name">server_alpn</span><p>Indicates the server will try to perform
Application-Layer Protocol Negotiation (ALPN).</p><p>The list of protocols is in order of preference. The
protocol negotiated will be the first in the list that
matches one of the protocols advertised by the client. If no
protocol matches, the server will fail the connection with a
"no_application_protocol" alert.</p><p>The negotiated protocol can be retrieved using the
<strong>negotiated_protocol/1</strong> function.</p><span class="name">server_next_protocol</span><p>List of protocols to send to the client if the client
indicates that it supports the Next Protocol extension. The
client can select a protocol that is not on this list. The
list of protocols must not contain an empty binary. If the
server negotiates a Next Protocol, it can be accessed using
the <strong>negotiated_next_protocol/1</strong> method.</p><span class="name">server_psk_identity</span><p>Specifies the server identity hint, which the server presents to
the client.</p><span class="name">honor_cipher_order</span><p>If set to <strong>true</strong>, use the server preference for cipher
selection. If set to <strong>false</strong> (the default), use the client
preference.</p><span class="name">sni_hosts</span><p>If the server receives a SNI (Server Name Indication) from the client
matching a host listed in the <strong>sni_hosts</strong> option, the specific options for
that host will override previously specified options.
The option <strong>sni_fun</strong>, and <strong>sni_hosts</strong> are mutually exclusive.</p><span class="name">sni_fun</span><p>If the server receives a SNI (Server Name Indication)
from the client, the given function will be called to
retrieve <a href="#type-server_option">[server_option()] </a> for the indicated server.
These options will be merged into predefined
<a href="#type-server_option">[server_option()] </a> list.
The function should be defined as:
fun(ServerName :: string()) -&gt; <a href="#type-server_option">[server_option()] </a>
and can be specified as a fun or as named <strong>fun module:function/1</strong>
The option <strong>sni_fun</strong>, and <strong>sni_hosts</strong> are mutually exclusive.</p><span class="name">client_renegotiation</span><p>In protocols that support client-initiated
renegotiation, the cost of resources of such an operation is
higher for the server than the client. This can act as a
vector for denial of service attacks. The SSL application
already takes measures to counter-act such attempts, but
client-initiated renegotiation can be strictly disabled by
setting this option to <strong>false</strong>. The default value is
<strong>true</strong>.  Note that disabling renegotiation can result in
long-lived connections becoming unusable due to limits on the
number of messages the underlying cipher suite can
encipher.</p><span class="name">honor_cipher_order</span><p>If true, use the server's preference for cipher
selection. If false (the default), use the client's
preference.</p><span class="name">honor_ecc_order</span><p>If true, use the server's preference for ECC curve
selection. If false (the default), use the client's
preference.</p><span class="name">server_signature_algs</span><p> The algorithms specified by this option will be the
ones accepted by the server in a signature algorithm
negotiation, introduced in TLS-1.2. The algorithms will also
be offered to the client if a client certificate is
requested. For more details see the <a href="#type-client_signature_algs">corresponding client option</a>.
</p><h3>Functions</h3><h4>append_cipher_suites/2</h4><p>Make <strong>Deferred</strong> suites become the least preferred
suites, that is put them at the end of the cipher suite list
<strong>Suites</strong> after removing them from <strong>Suites</strong> if
present. <strong>Deferred</strong> may be a list of cipher suits or a
list of filters in which case the filters are use on  <strong>Suites</strong> to
extract the Deferred cipher list.</p><h4>cipher_suites/0</h4><h4>cipher_suites/1</h4><p>Returns a list of supported cipher suites.</p><p>Deprecated in OTP 21, use <a href="#cipher_suites-2">cipher_suites/2</a> instead.</p><h4>cipher_suites/2</h4><p>Returns a list of all default or all supported cipher suites.</p><p>Returns all default or all supported (except anonymous),
or all anonymous cipher suites for a
TLS version</p><h4>cipher_suites/3</h4><p>Returns a list of RFC or OpenSSL names</p><p>Same as <a href="#cipher_suites-2">cipher_suites/2</a>
but lists RFC or OpenSSL string names instead of <a href="#type-erl_cipher_suite">erl_cipher_suite()</a>
</p><h4>eccs/0</h4><h4>eccs/1</h4><p>Returns a list of supported ECCs.</p><p>Returns a list of supported ECCs. <strong>eccs()</strong>
is equivalent to calling <strong>eccs(Protocol)</strong> with all
supported protocols and then deduplicating the output.</p><h4>clear_pem_cache/0</h4><p> Clears the pem cache</p><p>PEM files, used by ssl API-functions, are cached. The
cache is regularly checked to see if any cache entries should be
invalidated, however this function provides a way to
unconditionally clear the whole cache.
</p><h4>connect/2</h4><h4>connect/3</h4><p>Upgrades a <strong>gen_tcp</strong>, or equivalent, connected socket to an TLS socket.</p><p>Upgrades a <strong>gen_tcp</strong>, or equivalent,
connected socket to an TLS socket, that is, performs the
client-side TLS handshake.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If the option <strong>verify</strong> is set to
<strong>verify_peer</strong> the option <strong>server_name_indication</strong>
shall also be specified, if it is not no Server Name
Indication extension will be sent, and <a href="../public_key/public_key#pkix_verify_hostname-2">public_key:pkix_verify_hostname/2</a>
will be called with the IP-address of the connection as
<strong>ReferenceID</strong>, which is proably not what you want.</p></div><p> If the option <strong>{handshake, hello}</strong> is used the
handshake is paused after receiving the server hello message
and the success response is <strong>{ok, SslSocket, Ext}</strong>
instead of <strong>{ok, SslSocket}</strong>. Thereafter the handshake
is continued or canceled by calling <a href="#handshake_continue-3">handshake_continue-3</a> or <a href="#handshake_cancel-1">handshake_cancel-1</a>.
</p><p> If the option <strong>active</strong> is set to <strong>once</strong>, <strong>true</strong> or an integer value,
the process owning the sslsocket will receive messages of type 
<a href="#type-active_msgs"> active_msgs() </a>
</p><h4>connect/3</h4><h4>connect/4</h4><p>Opens an TLS/DTLS connection to <strong>Host</strong>, <strong>Port</strong>.</p><p>Opens an TLS/DTLS connection to <strong>Host</strong>, <strong>Port</strong>.</p><p> When the option <strong>verify</strong> is set to <strong>verify_peer</strong> the check 
<a href="../public_key/public_key#pkix_verify_hostname-2">public_key:pkix_verify_hostname/2</a> 
will be performed in addition to the usual x509-path validation checks. If the check fails the error {bad_cert, hostname_check_failed} will
be propagated to the path validation fun <a href="#type-custom_verify">verify_fun</a>, where it is possible to do customized
checks by using the full possibilities of the <a href="../public_key/public_key#pkix_verify_hostname-3">public_key:pkix_verify_hostname/3</a> API.
When the option <strong>server_name_indication</strong> is provided, its value (the DNS name) will be used as <strong>ReferenceID</strong>
to <a href="../public_key/public_key#pkix_verify_hostname-2">public_key:pkix_verify_hostname/2</a>.
When no <strong>server_name_indication</strong> option is given, the <strong>Host</strong> argument will be used as
Server Name Indication extension. The <strong>Host</strong> argument will also be used for the
<a href="../public_key/public_key#pkix_verify_hostname-2">public_key:pkix_verify_hostname/2</a> check and if the <strong>Host</strong>
argument is an <strong>inet:ip_address()</strong> the <strong>ReferenceID</strong> used for the check will be <strong>{ip, Host}</strong> otherwise
<strong>dns_id</strong> will be assumed with a fallback to <strong>ip</strong> if that fails. </p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>According to good practices certificates should not use IP-addresses as "server names". It would
be very surprising if this happen outside a closed network. </p></div><p> If the option <strong>{handshake, hello}</strong> is used the
handshake is paused after receiving the server hello message
and the success response is <strong>{ok, SslSocket, Ext}</strong>
instead of <strong>{ok, SslSocket}</strong>. Thereafter the handshake is continued or
canceled by calling <a href="#handshake_continue-3">handshake_continue-3</a> or <a href="#handshake_cancel-1">handshake_cancel-1</a>.
</p><p> If the option <strong>active</strong> is set to <strong>once</strong>, <strong>true</strong> or an integer value,
the process owning the sslsocket will receive messages of type 
<a href="#type-active_msgs"> active_msgs() </a>
</p><h4>close/1</h4><p>Closes an TLS/DTLS connection.</p><p>Closes an TLS/DTLS connection.</p><h4>close/2</h4><p>Closes an TLS connection.</p><p>Closes or downgrades an TLS connection. In the latter case the transport
connection will be handed over to the <strong>NewController</strong> process after receiving
the TLS close alert from the peer. The returned transport socket will have
the following options set: <strong>[{active, false}, {packet, 0}, {mode, binary}]</strong></p><h4>controlling_process/2</h4><p>Assigns a new controlling process to the TLS/DTLS socket.</p><p>Assigns a new controlling process to the SSL socket. A
controlling process is the owner of an SSL socket, and receives
all messages from the socket.</p><h4>connection_information/1</h4><p>Returns all the connection information. </p><p>Returns the most relevant information about the connection, ssl options that
are undefined will be filtered out. Note that values that affect the security of the
connection will only be returned if explicitly requested by connection_information/2.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The legacy <strong>Item = cipher_suite</strong> is still supported
and returns the cipher suite on its (undocumented) legacy format.
It should be replaced by <strong>selected_cipher_suite</strong>.</p></div><h4>connection_information/2</h4><p>Returns the requested connection information. </p><p>Returns the requested information items about the connection,
if they are defined.</p><p>Note that client_random, server_random  and master_secret are values
that affect the security of connection. Meaningful atoms, not specified
above, are the ssl option names.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If only undefined options are requested the
resulting list can be empty.</p></div><h4>filter_cipher_suites/2</h4><p>Removes cipher suites if any of the filter functions
returns false for any part of the cipher suite. This function
also calls default filter functions to make sure the cipher
suites are supported by crypto. If no filter function is supplied for some
part the default behaviour is fun(Algorithm) -&gt; true.</p><h4>format_error/1</h4><p>Returns an error string.</p><p>Presents the error returned by an SSL function as a printable string.</p><h4>getopts/2</h4><p>Gets the values of the specified options.</p><p>Gets the values of the specified socket options.
</p><h4>getstat/1</h4><h4>getstat/2</h4><p>Get one or more statistic options for a socket</p><p>Gets one or more statistic options for the underlying TCP socket.</p><p>See inet:getstat/2 for statistic options description.</p><h4>handshake/1</h4><h4>handshake/2</h4><p>Performs server-side SSL/TLS handshake.</p><p>Performs the SSL/TLS/DTLS server-side handshake.</p><p>Returns a new TLS/DTLS socket if the handshake is successful.</p><p> If the option <strong>active</strong> is set to <strong>once</strong>, <strong>true</strong> or an integer value,
the process owning the sslsocket will receive messages of type 
<a href="#type-active_msgs"> active_msgs() </a>
</p><h4>handshake/2</h4><h4>handshake/3</h4><p>Performs server-side SSL/TLS/DTLS handshake.</p><p>If <strong>Socket</strong> is a ordinary <strong>socket()</strong>: upgrades a <strong>gen_tcp</strong>,
or equivalent, socket to an SSL socket, that is, performs
the SSL/TLS server-side handshake and returns a TLS socket.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>The <strong>Socket</strong> shall be in passive mode ({active,
false}) before calling this function or else the behavior of this function
is undefined.
</p></div><p>If <strong>Socket</strong> is an 
<a href="#type-sslsocket"> sslsocket() </a>: provides extra SSL/TLS/DTLS
options to those specified in
<a href="#listen-2">listen/2 </a> and then performs
the SSL/TLS/DTLS handshake. Returns a new TLS/DTLS socket if the handshake is successful.</p><p>
If option <strong>{handshake, hello}</strong> is specified the handshake is
paused after receiving the client hello message and the
success response is <strong>{ok, SslSocket, Ext}</strong>  instead of <strong>{ok, SslSocket}</strong>. Thereafter the handshake is continued or
canceled by calling <a href="#handshake_continue-3">handshake_continue-3</a> or <a href="#handshake_cancel-1">handshake_cancel-1</a>.
</p><p> If the option <strong>active</strong> is set to <strong>once</strong>, <strong>true</strong> or an integer value,
the process owning the sslsocket will receive messages of type 
<a href="#type-active_msgs"> active_msgs() </a>
</p><h4>handshake_cancel/1</h4><p>Cancel handshake with a fatal alert</p><p>Cancel the handshake with a fatal <strong>USER_CANCELED</strong> alert.</p><h4>handshake_continue/2</h4><h4>handshake_continue/3</h4><p>Continue the SSL/TLS handshake.</p><p>Continue the SSL/TLS handshake possiby with new, additional or changed options.</p><h4>listen/2</h4><p>Creates an SSL listen socket.</p><p>Creates an SSL listen socket.</p><h4>negotiated_protocol/1</h4><p>Returns the protocol negotiated through ALPN or NPN extensions.</p><p>
Returns the protocol negotiated through ALPN or NPN extensions.
</p><h4>peercert/1</h4><p>Returns the peer certificate.</p><p>The peer certificate is returned as a DER-encoded binary.
The certificate can be decoded with
<a href="../public_key/public_key#pkix_decode_cert-2">public_key:pkix_decode_cert/2</a>
</p><h4>peername/1</h4><p>Returns the peer address and port.</p><p>Returns the address and port number of the peer.</p><h4>prepend_cipher_suites/2</h4><p>Make <strong>Preferred</strong> suites become the most preferred
suites that is put them at the head of the cipher suite list
<strong>Suites</strong> after removing them from <strong>Suites</strong> if
present. <strong>Preferred</strong> may be a list of cipher suits or a
list of filters in which case the filters are use on <strong>Suites</strong> to
extract the preferred cipher list. </p><h4>prf/5</h4><p>Uses a session Pseudo-Random Function to generate key material.</p><p>Uses the Pseudo-Random Function (PRF) of a TLS session to generate
extra key material. It either takes user-generated values for
<strong>Secret</strong> and <strong>Seed</strong> or atoms directing it to use a specific
value from the session security parameters.</p><p>Can only be used with TLS/DTLS connections; <strong>{error, undefined}</strong>
is returned for SSLv3 connections.</p><h4>recv/2</h4><h4>recv/3</h4><p>Receives data on a socket.</p><dl><dt>HttpPacket</dt><dd>See the description of <strong>HttpPacket</strong> in <a href="../erts/erlang#decode_packet/3">erts/erlang#decode_packet/3</a> in ERTS. </dd></dl><p>Receives a packet from a socket in passive
mode. A closed socket is indicated by return value
<strong>{error, closed}</strong>.</p><p>Argument <strong>Length</strong> is meaningful only when
the socket is in mode <strong>raw</strong> and denotes the number of
bytes to read. If <strong>Length</strong> = 0, all available bytes are
returned. If <strong>Length</strong> &gt; 0, exactly <strong>Length</strong>
bytes are returned, or an error; possibly discarding less
than <strong>Length</strong> bytes of data when the socket gets closed
from the other side.</p><p>Optional argument <strong>Timeout</strong> specifies a time-out in
milliseconds. The default value is <strong>infinity</strong>.</p><h4>renegotiate/1</h4><p>Initiates a new handshake.</p><p>Initiates a new handshake. A notable return value is
<strong>{error, renegotiation_rejected}</strong> indicating that the peer
refused to go through with the renegotiation, but the connection
is still active using the previously negotiated session.</p><h4>send/2</h4><p>Writes data to a socket.</p><p>Writes <strong>Data</strong> to <strong>SslSocket</strong>.</p><p>A notable return value is <strong>{error, closed}</strong> indicating that
the socket is closed.</p><h4>setopts/2</h4><p>Sets socket options.</p><p>Sets options according to <strong>Options</strong> for socket
<strong>SslSocket</strong>.</p><h4>shutdown/2</h4><p>Immediately closes a socket.</p><p>Immediately closes a socket in one or two directions.</p><p><strong>How == write</strong> means closing the socket for writing,
reading from it is still possible.</p><p>To be able to handle that the peer has done a shutdown on
the write side, option <strong>{exit_on_close, false}</strong>
is useful.</p><h4>ssl_accept/1</h4><h4>ssl_accept/2</h4><p>Performs server-side SSL/TLS handshake.</p><p>Deprecated in OTP 21, use <a href="#handshake-1">handshake/[1,2]</a> instead.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>handshake/[1,2] always returns a new socket.</p></div><h4>ssl_accept/3</h4><p>Performs server-side SSL/TLS/DTLS handshake.</p><p>Deprecated in OTP 21, use  <a href="#handshake-3">handshake/[2,3]</a> instead.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>handshake/[2,3] always returns a new socket.</p></div><h4>sockname/1</h4><p>Returns the local address and port.</p><p>Returns the local address and port number of socket
<strong>SslSocket</strong>.</p><h4>start/0</h4><h4>start(Type) -&gt; ok | {error, Reason}</h4><p>Starts the SSL application.</p><p>Starts the SSL application. Default type
is <strong>temporary</strong>.</p><h4>stop/0</h4><p>Stops the SSL application.</p><p>Stops the SSL application.</p><h4>str_to_suite/1</h4><p>Converts an RFC or OpenSSL name string to an erlang cipher suite format</p><p>Converts an RFC or OpenSSL name string to an
<a href="#type-erl_cipher_suite">erl_cipher_suite()</a>
Returns an error if the cipher suite is not supported or the name is not a valid cipher suite name.</p><h4>suite_to_openssl_str/1</h4><p>Converts erlang cipher suite format to an OpenSSL name string. </p><p>Converts <a href="#type-erl_cipher_suite">erl_cipher_suite()</a>
to OpenSSL name string. </p><p>PRE TLS-1.3 these names differ for RFC names</p><h4>suite_to_str/1</h4><p>Converts an erlang cipher suite to an RFC name string.</p><p>Converts <a href="#type-erl_cipher_suite">erl_cipher_suite()</a>
to RFC name string.</p><h4>transport_accept/1</h4><h4>transport_accept/2</h4><p>Accepts an incoming connection and prepares for <strong>ssl_accept</strong>.</p><p>Accepts an incoming connection request on a listen socket.
<strong>ListenSocket</strong> must be a socket returned from
<a href="#listen-2"> listen/2</a>.
The socket returned is to be passed to
<a href="#handshake-2"> handshake/[2,3]</a>
to complete handshaking, that is,
establishing the SSL/TLS/DTLS connection.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Most API functions require that the TLS/DTLS 
connection is established to work as expected.
</p></div><p>The accepted socket inherits the options set for
<strong>ListenSocket</strong> in
<a href="#listen-2"> listen/2</a>.</p><p>The default
value for <strong>Timeout</strong> is <strong>infinity</strong>. If
<strong>Timeout</strong> is specified and no connection is accepted
within the given time, <strong>{error, timeout}</strong> is
returned.</p><h4>versions/0</h4><p>Returns version information relevant for the SSL application.</p><p>Returns version information relevant for the SSL
application.</p><dl><dt><strong>app_vsn</strong></dt><dd>The application version of the SSL application.</dd><dt><strong>supported</strong></dt><dd>SSL/TLS versions supported by default. Overridden by a version option on <a href="#connect-2"> connect/[2,3,4]</a>, <a href="#listen-2"> listen/2</a>, and <a href="#ssl_accept-2">ssl_accept/[1,2,3]</a>. For the negotiated SSL/TLS version, see <a href="#connection_information-1">connection_information/1 </a>.</dd><dt><strong>supported_dtls</strong></dt><dd>DTLS versions supported by default. Overridden by a version option on <a href="#connect-2"> connect/[2,3,4]</a>, <a href="#listen-2"> listen/2</a>, and <a href="#ssl_accept-2">ssl_accept/[1,2,3]</a>. For the negotiated DTLS version, see <a href="#connection_information-1">connection_information/1 </a>.</dd><dt><strong>available</strong></dt><dd>All SSL/TLS versions supported by the SSL application. TLS 1.2 requires sufficient support from the Crypto application.</dd><dt><strong>available_dtls</strong></dt><dd>All DTLS versions supported by the SSL application. DTLS 1.2 requires sufficient support from the Crypto application.</dd></dl><h4>SEE ALSO</h4><p><a href="./inet">inet(3)</a> and
<a href="./gen_tcp">gen_tcp(3)</a>
<a href="./gen_udp">gen_udp(3)</a>
</p><h3>ssl_crl_cache</h3><p>CRL cache</p><p>
Implements an internal CRL (Certificate Revocation List) cache.
In addition to implementing the <a href="ssl_crl_cache_api"> ssl_crl_cache_api</a> behaviour
the following functions are available.
</p><h3>Data Types</h3><h4>DATA TYPES</h4><span class="name">crl_src</span><span class="name">uri</span><h3>Functions</h3><h4>delete(Entries) -&gt; ok |  {error, Reason}</h4><p> </p><ul><li><span class="v"> Entries =  ]}</span></li><li><span class="v"> Reason = crl_reason()</span></li></ul><p>Delete CRLs from the ssl applications local cache. </p><h4>insert(CRLSrc) -&gt; ok | {error, Reason}</h4><h4>insert(URI, CRLSrc) -&gt; ok | {error, Reason}</h4><p> </p><ul><li><span class="v"> CRLSrc = ]}</span></li><li><span class="v"> URI =  </span></li><li><span class="v"> Reason = term()</span></li></ul><p>Insert CRLs, available to fetch on DER format from <strong>URI</strong>, into the ssl applications local cache. </p><h3>ssl_crl_cache_api</h3><p>API for a SSL/TLS CRL (Certificate Revocation List) cache.</p><p>
When SSL/TLS performs certificate path validation according to
<a href="http://www.ietf.org/rfc/rfc5280.txt">RFC 5280 </a>
it should also perform CRL validation checks. To enable the CRL
checks the application needs access to CRLs. A database of CRLs
can be set up in many different ways. This module provides the
behavior of the API needed to integrate an arbitrary CRL cache
with the erlang ssl application. It is also used by the
application itself to provide a simple default implementation of
a CRL cache.
</p><h3>Data Types</h3><span class="name">crl_cache_ref</span><p>Reference to the CRL cache.</p><span class="name">dist_point</span><p>For description see <a href="./public_key_records"> X509 certificates records</a></p><h3>Functions</h3><h4>fresh_crl(DistributionPoint, CRL) -&gt; FreshCRL</h4><p> <strong>fun fresh_crl/2 </strong> will be used as input option <strong>update_crl</strong> to public_key:pkix_crls_validate/3 </p><ul><li><span class="v"> DistributionPoint =  </span></li><li><span class="v"> CRL = [] </span></li><li><span class="v"> FreshCRL = [] </span></li></ul><p> <strong>fun fresh_crl/2 </strong> will be used as input option <strong>update_crl</strong> to
<a href="../public_key/public_key#pkix_crls_validate-3">public_key:pkix_crls_validate/3 </a> </p><h4>lookup(DistributionPoint, Issuer, DbHandle) -&gt; not_available | CRLs</h4><h4>lookup(DistributionPoint, DbHandle) -&gt; not_available | CRLs</h4><p> </p><ul><li><span class="v"> DistributionPoint =  </span></li><li><span class="v"> Issuer =  </span></li><li><span class="v"> DbHandle = </span></li><li><span class="v"> CRLs = [] </span></li></ul><p>Lookup the CRLs belonging to the distribution point <strong> Distributionpoint</strong>.
This function may choose to only look in the cache or to follow distribution point
links depending on how the cache is administrated. </p><p>The <strong>Issuer</strong> argument contains the issuer name of the
certificate to be checked.  Normally the returned CRL should
be issued by this issuer, except if the <strong>cRLIssuer</strong> field
of <strong>DistributionPoint</strong> has a value, in which case that
value should be used instead.</p><p>In an earlier version of this API, the <strong>lookup</strong>
function received two arguments, omitting <strong>Issuer</strong>.  For
compatibility, this is still supported: if there is no
<strong>lookup/3</strong> function in the callback module,
<strong>lookup/2</strong> is called instead.</p><h4>select(Issuer, DbHandle) -&gt; CRLs</h4><p>Select the CRLs in the cache that are issued by <strong>Issuer</strong></p><ul><li><span class="v"> Issuer = </span></li><li><span class="v"> DbHandle = </span></li></ul><p>Select the CRLs in the cache that are issued by <strong>Issuer</strong> </p><h3>ssl_session_cache_api</h3><p>TLS session cache API</p><p>
Defines the API for the TLS session cache so
that the data storage scheme can be replaced by
defining a new callback module implementing this API.
</p><h3>Data Types</h3><span class="name">session_cache_ref</span><span class="name">session_cache_key</span><p>A key to an entry in the session cache.</p><span class="name">partial_key</span><p>The opaque part of the key. Does not need to be handled
by the callback.</p><span class="name">session</span><p>The session data that is stored for each session.</p><h3>Functions</h3><h4>delete(Cache, Key) -&gt; _</h4><p>Deletes a cache entry.</p><ul><li><span class="v">Cache = </span></li><li><span class="v">Key =  </span></li></ul><p>Deletes a cache entry. Is only called from the cache
handling process.
</p><h4>foldl(Fun, Acc0, Cache) -&gt; Acc</h4><ul><li><span class="v">Fun = fun()</span></li><li><span class="v">Acc0 = Acc = term()</span></li><li><span class="v">Cache = </span></li></ul><p>Calls <strong>Fun(Elem, AccIn)</strong> on successive elements of the
cache, starting with <strong>AccIn == Acc0</strong>. <strong>Fun/2</strong> must
return a new accumulator, which is passed to the next call.
The function returns the final value of the accumulator.
<strong>Acc0</strong> is returned if the cache is empty.
</p><h4>init(Args) -&gt; Cache</h4><p>Returns cache reference.</p><ul><li><span class="v">Cache = </span></li><li><span class="v">Args = </span></li></ul><p>Includes property <strong>{role, client | server}</strong>.
Currently this is the only predefined property,
there can also be user-defined properties. See also
application environment variable
<a href="ssl_app">session_cb_init_args</a>.
</p><p>Performs possible initializations of the cache and returns
a reference to it that is used as parameter to the other
API functions. Is called by the cache handling processes
<strong>init</strong> function, hence putting the same requirements on it
as a normal process <strong>init</strong> function. This function is
called twice when starting the SSL application, once with
the role client and once with the role server, as the SSL
application must be prepared to take on both roles.
</p><h4>lookup(Cache, Key) -&gt; Entry</h4><p>Looks up a cache entry.</p><ul><li><span class="v">Cache = </span></li><li><span class="v">Key =  </span></li><li><span class="v">Session =  | undefined</span></li></ul><p>Looks up a cache entry. Is to be callable from any
process.
</p><h4>select_session(Cache, PartialKey) -&gt; [Session]</h4><p>Selects sessions that can be reused.</p><ul><li><span class="v">Cache = </span></li><li><span class="v">PartialKey = </span></li><li><span class="v">Session = </span></li></ul><p>Selects sessions that can be reused. Is to be callable
from any process.
</p><h4>size(Cache) -&gt; integer()</h4><p>Returns the number of sessions in the cache.</p><ul><li><span class="v">Cache = </span></li></ul><p>Returns the number of sessions in the cache. If size
exceeds the maximum number of sessions, the current cache
entries will be invalidated regardless of their remaining
lifetime. Is to be callable from any process.
</p><h4>terminate(Cache) -&gt; _</h4><p>Called by the process that handles the cache when it is about to terminate.</p><ul><li><span class="v">Cache = </span></li><li><span class="d">As returned by init/0</span></li></ul><p>Takes care of possible cleanup that is needed when the
cache handling process terminates.
</p><h4>update(Cache, Key, Session) -&gt; _</h4><p>Caches a new session or updates an already cached one.</p><ul><li><span class="v">Cache = </span></li><li><span class="v">Key =  </span></li><li><span class="v">Session = </span></li></ul><p>Caches a new session or updates an already cached one. Is
only called from the cache handling process.
</p></body></html>