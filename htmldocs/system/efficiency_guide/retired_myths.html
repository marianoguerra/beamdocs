<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Retired Myths</h1><p>We belive that the truth finally has caught with the following,
retired myths.</p><a name="retired_myths"></a><h2>Myth: Funs are Slow</h2><p>Funs used to be very slow, slower than <strong>apply/3</strong>.
Originally, funs were implemented using nothing more than
compiler trickery, ordinary tuples, <strong>apply/3</strong>, and a great
deal of ingenuity.</p><p>But that is history. Funs was given its own data type
in R6B and was further optimized in R7B.
Now the cost for a fun call falls roughly between the cost for a call
to a local function and <strong>apply/3</strong>.</p><h2>Myth: List Comprehensions are Slow</h2><p>List comprehensions used to be implemented using funs, and in the
old days funs were indeed slow.</p><p>Nowadays, the compiler rewrites list comprehensions into an ordinary
recursive function. Using a tail-recursive function with
a reverse at the end would be still faster. Or would it?
That leads us to the myth that tail-recursive functions are faster
than body-recursive functions.</p><h2>Myth: List subtraction ("--" operator) is slow</h2><p>List subtraction used to have a run-time complexity proportional to the
product of the length of its operands, so it was extremely slow when both
lists were long.</p><p>As of OTP 22 the run-time complexity is "n log n" and the operation will
complete quickly even when both lists are very long. In fact, it is
faster and uses less memory than the commonly used workaround to convert
both lists to ordered sets before subtracting them with
<strong>ordsets:subtract/2</strong>.</p></body></html>