<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Processes</h1><h2>Creating an Erlang Process</h2><p>An Erlang process is lightweight compared to threads and
processes in operating systems.</p><p>A newly spawned Erlang process uses 309 words of memory
in the non-SMP emulator without HiPE support. (SMP support
and HiPE support both add to this size.) The size can
be found as follows:</p><pre>
Erlang (BEAM) emulator version 5.6 [async-threads:0] [kernel-poll:false]

Eshell V5.6  (abort with ^G)
1&gt; <span class="input">Fun = fun() -&gt; receive after infinity -&gt; ok end end.</span>
#Fun&lt;...&gt;
2&gt; <span class="input">{_,Bytes} = process_info(spawn(Fun), memory).</span>
{memory,1232}
3&gt; <span class="input">Bytes div erlang:system_info(wordsize).</span>
309</pre><p>The size includes 233 words for the heap area (which includes the
stack). The garbage collector increases the heap as needed.</p><p>The main (outer) loop for a process <em>must</em> be tail-recursive.
Otherwise, the stack grows until the process terminates.</p><p><em>DO NOT</em></p><pre><code class="erl">
loop() -&gt; 
  receive
     {sys, Msg} -&gt;
         handle_sys_msg(Msg),
         loop();
     {From, Msg} -&gt;
          Reply = handle_msg(Msg),
          From ! Reply,
          loop()
  end,
  io:format("Message is processed~n", []).</code></pre><p>The call to <strong>io:format/2</strong> will never be executed, but a
return address will still be pushed to the stack each time
<strong>loop/0</strong> is called recursively. The correct tail-recursive
version of the function looks as follows:</p><p><em>DO</em></p><pre><code class="erl">
   loop() -&gt; 
      receive
         {sys, Msg} -&gt;
            handle_sys_msg(Msg),
            loop();
         {From, Msg} -&gt;
            Reply = handle_msg(Msg),
            From ! Reply,
            loop()
    end.</code></pre><h2>Initial Heap Size</h2><p>The default initial heap size of 233 words is quite conservative
to support Erlang systems with hundreds of thousands or
even millions of processes. The garbage collector grows and
shrinks the heap as needed.</p><p>In a system that use comparatively few processes, performance
<em>might</em> be improved by increasing the minimum heap size
using either the <strong>+h</strong> option for
<a href="./erl">erl</a> or on a process-per-process
basis using the <strong>min_heap_size</strong> option for
<a href="../erts/erlang#spawn_opt/4">spawn_opt/4</a>.</p><p>The gain is twofold:</p><ul><li>Although the garbage collector grows the heap, it grows it step-by-step, which is more costly than directly establishing a larger heap when the process is spawned.</li><li>The garbage collector can also shrink the heap if it is much larger than the amount of data stored on it; setting the minimum heap size prevents that.</li></ul><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>The emulator probably uses more memory, and because garbage
collections occur less frequently, huge binaries can be
kept much longer.</p></div><p>In systems with many processes, computation tasks that run
for a short time can be spawned off into a new process with
a higher minimum heap size. When the process is done, it sends
the result of the computation to another process and terminates.
If the minimum heap size is calculated properly, the process might
not have to do any garbage collections at all.
<em>This optimization is not to be attempted without proper measurements.</em></p><h2>Process Messages</h2><p>All data in messages between Erlang processes is copied,
except for
<a href="./binaryhandling#refc_binary">refc binaries</a>
on the same Erlang node.</p><p>When a message is sent to a process on another Erlang node,
it is first encoded to the Erlang External Format before
being sent through a TCP/IP socket. The receiving Erlang node decodes
the message and distributes it to the correct process.</p><h2>Constant Pool</h2><p>Constant Erlang terms (also called <em>literals</em>) are
kept in constant pools; each loaded module has its own pool.
The following function does not build the tuple every time
it is called (only to have it discarded the next time the garbage
collector was run), but the tuple is located in the module's
constant pool:</p><p><em>DO</em></p><pre><code class="erl">
days_in_month(M) -&gt;
    element(M, {31,28,31,30,31,30,31,31,30,31,30,31}).</code></pre><p>But if a constant is sent to another process (or stored in
an Ets table), it is <em>copied</em>.
The reason is that the runtime system must be able
to keep track of all references to constants to unload code
containing constants properly. (When the code is unloaded,
the constants are copied to the heap of the processes that refer
to them.) The copying of constants might be eliminated in a future
Erlang/OTP release.</p><h2>Loss of Sharing</h2><p>Shared subterms are <em>not</em> preserved in the following
cases:</p><ul><li>When a term is sent to another process</li><li>When a term is passed as the initial process arguments in the <strong>spawn</strong> call</li><li>When a term is stored in an Ets table</li></ul><p>That is an optimization. Most applications do not send messages
with shared subterms.</p><p>The following example shows how a shared subterm can be created:</p><pre><code class="erl">
kilo_byte() -&gt;
    kilo_byte(10, [42]).

kilo_byte(0, Acc) -&gt;
    Acc;
kilo_byte(N, Acc) -&gt;
    kilo_byte(N-1, [Acc|Acc]).</code></pre><p><strong>kilo_byte/1</strong> creates a deep list.
If <strong>list_to_binary/1</strong> is called, the deep list can be
converted to a binary of 1024 bytes:</p><pre>
1&gt; <span class="input">byte_size(list_to_binary(efficiency_guide:kilo_byte())).</span>
1024</pre><p>Using the <strong>erts_debug:size/1</strong> BIF, it can be seen that the
deep list only requires 22 words of heap space:</p><pre>
2&gt; <span class="input">erts_debug:size(efficiency_guide:kilo_byte()).</span>
22</pre><p>Using the <strong>erts_debug:flat_size/1</strong> BIF, the size of the
deep list can be calculated if sharing is ignored. It becomes
the size of the list when it has been sent to another process
or stored in an Ets table:</p><pre>
3&gt; <span class="input">erts_debug:flat_size(efficiency_guide:kilo_byte()).</span>
4094</pre><p>It can be verified that sharing will be lost if the data is
inserted into an Ets table:</p><pre>
4&gt; <span class="input">T = ets:new(tab, []).</span>
#Ref&lt;0.1662103692.2407923716.214181&gt;
5&gt; <span class="input">ets:insert(T, {key,efficiency_guide:kilo_byte()}).</span>
true
6&gt; <span class="input">erts_debug:size(element(2, hd(ets:lookup(T, key)))).</span>
4094
7&gt; <span class="input">erts_debug:flat_size(element(2, hd(ets:lookup(T, key)))).</span>
4094</pre><p>When the data has passed through an Ets table,
<strong>erts_debug:size/1</strong> and <strong>erts_debug:flat_size/1</strong>
return the same value. Sharing has been lost.</p><p>In a future Erlang/OTP release, it might be implemented a
way to (optionally) preserve sharing.</p><h2>SMP Emulator</h2><p>The SMP emulator (introduced in R11B) takes advantage of a
multi-core or multi-CPU computer by running several Erlang scheduler
threads (typically, the same as the number of cores). Each scheduler
thread schedules Erlang processes in the same way as the Erlang scheduler
in the non-SMP emulator.</p><p>To gain performance by using the SMP emulator, your application
<em>must have more than one runnable Erlang process</em> most of the time.
Otherwise, the Erlang emulator can still only run one Erlang process
at the time, but you must still pay the overhead for locking. Although
Erlang/OTP tries to reduce the locking overhead as much as possible,
it will never become exactly zero.</p><p>Benchmarks that appear to be concurrent are often sequential.
The estone benchmark, for example, is entirely sequential. So is
the most common implementation of the "ring benchmark"; usually one process
is active, while the others wait in a <strong>receive</strong> statement.</p></body></html>