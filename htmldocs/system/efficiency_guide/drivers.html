<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Drivers</h1><p>This section provides a brief overview on how to write efficient
drivers.</p><p>It is assumed that you have a good understanding of drivers.</p><h2>Drivers and Concurrency</h2><p>The runtime system always takes a lock before running
any code in a driver.</p><p>By default, that lock is at the driver level, that is,
if several ports have been opened to the same driver, only code for
one port at the same time can be running.</p><p>A driver can be configured to have one lock for each port instead.</p><p>If a driver is used in a functional way (that is, holds no state,
but only does some heavy calculation and returns a result), several
ports with registered names can be opened beforehand, and the port to
be used can be chosen based on the scheduler ID as follows:</p><pre><code class="">
-define(PORT_NAMES(),
	{some_driver_01, some_driver_02, some_driver_03, some_driver_04,
	 some_driver_05, some_driver_06, some_driver_07, some_driver_08,
	 some_driver_09, some_driver_10, some_driver_11, some_driver_12,
	 some_driver_13, some_driver_14, some_driver_15, some_driver_16}).

client_port() -&gt;
    element(erlang:system_info(scheduler_id) rem tuple_size(?PORT_NAMES()) + 1,
	    ?PORT_NAMES()).</code></pre><p>As long as there are no more than 16 schedulers, there will never
be any lock contention on the port lock for the driver.</p><h2>Avoiding Copying Binaries When Calling a Driver</h2><p>There are basically two ways to avoid copying a binary that is
sent to a driver:</p><ul><li><p>If the <strong>Data</strong> argument for
<a href="../erts/erlang#port_control/3">port_control/3</a>
is a binary, the driver will be passed a pointer to the contents of
the binary and the binary will not be copied. If the <strong>Data</strong>
argument is an iolist (list of binaries and lists), all binaries in
the iolist will be copied.</p> <p>Therefore, if you want to send both a pre-existing binary and some
extra data to a driver without copying the binary, you must call
<strong>port_control/3</strong> twice; once with the binary and once with the
extra data. However, that will only work if there is only one
process communicating with the port (because otherwise another process
can call the driver in-between the calls).</p></li><li><p>Implement an <strong>outputv</strong> callback (instead of an
<strong>output</strong> callback) in the driver. If a driver has an
<strong>outputv</strong> callback, refc binaries passed in an iolist
in the <strong>Data</strong> argument for
<a href="../erts/erlang#port_command/2">port_command/2</a>
will be passed as references to the driver.</p></li></ul><h2>Returning Small Binaries from a Driver</h2><p>The runtime system can represent binaries up to 64 bytes as
heap binaries. They are always copied when sent in messages,
but they require less memory if they are not sent to another
process and garbage collection is cheaper.</p><p>If you know that the binaries you return are always small, you
are advised to use driver API calls that do not require a pre-allocated
binary, for example,
<a href="../erts/erl_driver#driver_output">driver_output()</a>
or
<a href="../erts/erl_driver#erl_drv_output_term">erl_drv_output_term()</a>,
using the <strong>ERL_DRV_BUF2BINARY</strong> format,
to allow the runtime to construct a heap binary.</p><h2>Returning Large Binaries without Copying from a Driver</h2><p>To avoid copying data when a large binary is sent or returned from
the driver to an Erlang process, the driver must first allocate the
binary and then send it to an Erlang process in some way.</p><p>Use
<a href="../erts/erl_driver#driver_alloc_binary">driver_alloc_binary()</a>
to allocate a binary.</p><p>There are several ways to send a binary created with
<strong>driver_alloc_binary()</strong>:</p><ul><li>From the <strong>control</strong> callback, a binary can be returned if <a href="../erts/erl_driver#set_port_control_flags">set_port_control_flags()</a> has been called with the flag value <strong>PORT_CONTROL_FLAG_BINARY</strong>.</li><li>A single binary can be sent with <a href="../erts/erl_driver#driver_output_binary">driver_output_binary()</a>.</li><li>Using <a href="../erts/erl_driver#erl_drv_output_term">erl_drv_output_term()</a> or <a href="../erts/erl_driver#erl_drv_send_term">erl_drv_send_term()</a>, a binary can be included in an Erlang term.</li></ul></body></html>