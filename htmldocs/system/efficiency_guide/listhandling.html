<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>List Handling</h1><h2>Creating a List</h2><p>Lists can only be built starting from the end and attaching list
elements at the beginning. If you use the "<strong>++</strong>" operator as
follows, a new list is created that is a copy of the elements in
<strong>List1</strong>, followed by <strong>List2</strong>:</p><pre><code class="erl">
List1 ++ List2</code></pre><p>Looking at how <strong>lists:append/1</strong> or <strong>++</strong> would be
implemented in plain Erlang, clearly the first list is copied:</p><pre><code class="erl">
append([H|T], Tail) -&gt;
    [H|append(T, Tail)];
append([], Tail) -&gt;
    Tail.</code></pre><p>When recursing and building a list, it is important to ensure
that you attach the new elements to the beginning of the list. In
this way, you will build <em>one</em> list, not hundreds or thousands
of copies of the growing result list.</p><p>Let us first see how it is not to be done:</p><p><em>DO NOT</em></p><pre><code class="erl">
bad_fib(N) -&gt;
    bad_fib(N, 0, 1, []).

bad_fib(0, _Current, _Next, Fibs) -&gt;
    Fibs;
bad_fib(N, Current, Next, Fibs) -&gt; 
    bad_fib(N - 1, Next, Current + Next, Fibs ++ [Current]).</code></pre><p>Here more than one list is built. In each iteration step a new list
is created that is one element longer than the new previous list.</p><p>To avoid copying the result in each iteration, build the list in
reverse order and reverse the list when you are done:</p><p><em>DO</em></p><pre><code class="erl">
tail_recursive_fib(N) -&gt;
    tail_recursive_fib(N, 0, 1, []).

tail_recursive_fib(0, _Current, _Next, Fibs) -&gt;
    lists:reverse(Fibs);
tail_recursive_fib(N, Current, Next, Fibs) -&gt; 
    tail_recursive_fib(N - 1, Next, Current + Next, [Current|Fibs]).</code></pre><h2>List Comprehensions</h2><p>Lists comprehensions still have a reputation for being slow.
They used to be implemented using funs, which used to be slow.</p><p>A list comprehension:</p><pre><code class="erl">
[Expr(E) || E &lt;- List]</code></pre><p>is basically translated to a local function:</p><pre><code class="erl">
'lc^0'([E|Tail], Expr) -&gt;
    [Expr(E)|'lc^0'(Tail, Expr)];
'lc^0'([], _Expr) -&gt; [].</code></pre><p>If the result of the list comprehension will <em>obviously</em>
not be used, a list will not be constructed. For example, in this code:</p><pre><code class="erl">
[io:put_chars(E) || E &lt;- List],
ok.</code></pre><p>or in this code:</p><pre><code class="erl">
...
case Var of
    ... -&gt;
        [io:put_chars(E) || E &lt;- List];
    ... -&gt;
end,
some_function(...),
...</code></pre><p>the value is not assigned to a variable, not passed to another function,
and not returned. This means that there is no need to construct a list and
the compiler will simplify the code for the list comprehension to:</p><pre><code class="erl">
'lc^0'([E|Tail], Expr) -&gt;
    Expr(E),
    'lc^0'(Tail, Expr);
'lc^0'([], _Expr) -&gt; [].</code></pre><p>The compiler also understands that assigning to '_' means that
the value will not used. Therefore, the code in the following example
will also be optimized:</p><pre><code class="erl">
_ = [io:put_chars(E) || E &lt;- List],
ok.</code></pre><h2>Deep and Flat Lists</h2><p><a href="../stdlib/lists#flatten/1">lists:flatten/1</a>
builds an entirely new list. It is therefore expensive, and even
<em>more</em> expensive than the <strong>++</strong> operator (which copies its
left argument, but not its right argument).</p><p>In the following situations, you can easily avoid calling
<strong>lists:flatten/1</strong>:</p><ul><li>When sending data to a port. Ports understand deep lists so there is no reason to flatten the list before sending it to the port.</li><li>When calling BIFs that accept deep lists, such as <a href="../erts/erlang#list_to_binary/1">list_to_binary/1</a> or <a href="../erts/erlang#iolist_to_binary/1">iolist_to_binary/1</a>.</li><li>When you know that your list is only one level deep, you can use <a href="../stdlib/lists#append/1">lists:append/1</a>.</li></ul><h2>Port Example</h2><p><em>DO</em></p><pre>
      ...
      port_command(Port, DeepList)
      ...</pre><p><em>DO NOT</em></p><pre>
      ...
      port_command(Port, lists:flatten(DeepList))
      ...</pre><p>A common way to send a zero-terminated string to a port is the following:</p><p><em>DO NOT</em></p><pre>
      ...
      TerminatedStr = String ++ [0], % String="foo" =&gt; [$f, $o, $o, 0]
      port_command(Port, TerminatedStr)
      ...</pre><p>Instead:</p><p><em>DO</em></p><pre>
      ...
      TerminatedStr = [String, 0], % String="foo" =&gt; [[$f, $o, $o], 0]
      port_command(Port, TerminatedStr) 
      ...</pre><h2>Append Example</h2><p><em>DO</em></p><pre>
      &gt; lists:append([[1], [2], [3]]).
      [1,2,3]
      &gt;</pre><p><em>DO NOT</em></p><pre>
      &gt; lists:flatten([[1], [2], [3]]).
      [1,2,3]
      &gt;</pre><h2>Recursive List Functions</h2><p>In section about myths, the following myth was exposed:
<a href="./myths#tail_recursive">Tail-Recursive Functions are Much Faster Than Recursive Functions</a>.</p><p>There is usually not much difference between
a body-recursive list function and tail-recursive function that reverses
the list at the end. Therefore, concentrate on writing beautiful code
and forget about the performance of your list functions. In the
time-critical parts of your code (and only there), <em>measure</em>
before rewriting your code.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This section is about list functions that <em>construct</em>
lists. A tail-recursive function that does not construct a list runs
in constant space, while the corresponding body-recursive function
uses stack space proportional to the length of the list.</p></div><p>For example, a function that sums a list of integers, is
<em>not</em> to be written as follows:</p><p><em>DO NOT</em></p><pre><code class="erl">
recursive_sum([H|T]) -&gt; H+recursive_sum(T);
recursive_sum([])    -&gt; 0.</code></pre><p>Instead:</p><p><em>DO</em></p><pre><code class="erl">
sum(L) -&gt; sum(L, 0).

sum([H|T], Sum) -&gt; sum(T, Sum + H);
sum([], Sum)    -&gt; Sum.</code></pre></body></html>