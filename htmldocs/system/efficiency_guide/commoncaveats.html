<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Common Caveats</h1><p>This section lists a few modules and BIFs to watch out for, not only
from a performance point of view.</p><h2>Timer Module</h2><p>Creating timers using <a href="../erts/erlang#send_after/3">erlang:send_after/3</a>
and
<a href="../erts/erlang#start_timer/3">erlang:start_timer/3</a>,
is much more efficient than using the timers provided by the
<a href="./timer">timer</a> module in STDLIB.
The <strong>timer</strong> module uses a separate process to manage the timers.
That process can easily become overloaded if many processes
create and cancel timers frequently (especially when using the
SMP emulator).</p><p>The functions in the <strong>timer</strong> module that do not manage timers
(such as <strong>timer:tc/3</strong> or <strong>timer:sleep/1</strong>), do not call the
timer-server process and are therefore harmless.</p><h2>list_to_atom/1</h2><p>Atoms are not garbage-collected. Once an atom is created, it is never
removed. The emulator terminates if the limit for the number
of atoms (1,048,576 by default) is reached.</p><p>Therefore, converting arbitrary input strings to atoms can be
dangerous in a system that runs continuously.
If only certain well-defined atoms are allowed as input,
<a href="../erts/erlang#list_to_existing_atom/1">list_to_existing_atom/1</a>
can be used to
to guard against a denial-of-service attack. (All atoms that are allowed
must have been created earlier, for example, by simply using all of them
in a module and loading that module.)</p><p>Using <strong>list_to_atom/1</strong> to construct an atom that is passed to
<strong>apply/3</strong> as follows, is quite expensive and not recommended
in time-critical code:</p><pre><code class="erl">
apply(list_to_atom("some_prefix"++Var), foo, Args)</code></pre><h2>length/1</h2><p>The time for calculating the length of a list is proportional to the
length of the list, as opposed to <strong>tuple_size/1</strong>, <strong>byte_size/1</strong>,
and <strong>bit_size/1</strong>, which all execute in constant time.</p><p>Normally, there is no need to worry about the speed of <strong>length/1</strong>,
because it is efficiently implemented in C. In time-critical code,
you might want to avoid it if the input list could potentially be very
long.</p><p>Some uses of <strong>length/1</strong> can be replaced by matching.
For example, the following code:</p><pre><code class="erl">
foo(L) when length(L) &gt;= 3 -&gt;
    ...</code></pre><p>can be rewritten to:</p><pre><code class="erl">
foo([_,_,_|_]=L) -&gt;
   ...</code></pre><p>One slight difference is that <strong>length(L)</strong> fails if <strong>L</strong>
is an improper list, while the pattern in the second code fragment
accepts an improper list.</p><h2>setelement/3</h2><p><a href="../erts/erlang#setelement/3">setelement/3</a>
copies the tuple it modifies. Therefore, updating a tuple in a loop
using <strong>setelement/3</strong> creates a new copy of the tuple every time.</p><p>There is one exception to the rule that the tuple is copied.
If the compiler clearly can see that destructively updating the tuple would
give the same result as if the tuple was copied, the call to
<strong>setelement/3</strong> is replaced with a special destructive <strong>setelement</strong>
instruction. In the following code sequence, the first <strong>setelement/3</strong>
call copies the tuple and modifies the ninth element:</p><pre><code class="erl">
multiple_setelement(T0) -&gt;
    T1 = setelement(9, T0, bar),
    T2 = setelement(7, T1, foobar),
    setelement(5, T2, new_value).</code></pre><p>The two following <strong>setelement/3</strong> calls modify
the tuple in place.</p><p>For the optimization to be applied, <em>all</em> the followings conditions
must be true:</p><ul><li>The indices must be integer literals, not variables or expressions.</li><li>The indices must be given in descending order.</li><li>There must be no calls to another function in between the calls to <strong>setelement/3</strong>.</li><li>The tuple returned from one <strong>setelement/3</strong> call must only be used in the subsequent call to <strong>setelement/3</strong>.</li></ul><p>If the code cannot be structured as in the <strong>multiple_setelement/1</strong>
example, the best way to modify multiple elements in a large tuple is to
convert the tuple to a list, modify the list, and convert it back to
a tuple.</p><h2>size/1</h2><p><strong>size/1</strong> returns the size for both tuples and binaries.</p><p>Using the BIFs <strong>tuple_size/1</strong> and <strong>byte_size/1</strong>
gives the compiler and the runtime system more opportunities for
optimization. Another advantage is that the BIFs give Dialyzer more
type information.</p><h2>split_binary/2</h2><p>It is usually more efficient to split a binary using matching
instead of calling the <strong>split_binary/2</strong> function.
Furthermore, mixing bit syntax matching and <strong>split_binary/2</strong>
can prevent some optimizations of bit syntax matching.</p><p><em>DO</em></p><pre><code class="">
        &lt;&lt;Bin1:Num/binary,Bin2/binary&gt;&gt; = Bin,</code></pre><p><em>DO NOT</em></p><pre><code class="">
        {Bin1,Bin2} = split_binary(Bin, Num)</code></pre></body></html>