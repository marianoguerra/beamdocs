<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Overview</h1><h2>Built-In Mechanisms</h2><p>Two interoperability mechanisms are built into the Erlang
runtime system, <em>distributed Erlang</em> and <em>ports</em>.
A variation of ports is <em>linked-in drivers</em>.</p><a name="dist"></a><h2>Distributed Erlang</h2><p>An Erlang runtime system is made a distributed Erlang node by
giving it a name. A distributed Erlang node can connect to,
and monitor, other nodes. It can also spawn processes at other
nodes. Message passing and error handling between processes at
different nodes are transparent. A number of useful STDLIB
modules are available in a distributed Erlang system. For
example, <strong>global</strong>, which provides global name
registration. The distribution mechanism is implemented using
TCP/IP sockets.</p><p><em>When to use:</em> Distributed Erlang is primarily used
for Erlang-Erlang communication. It can also be used for
communication between Erlang and C, if the C program is
implemented as a C node, see
<a href="#cnode">C and Java Libraries</a>.</p><p><em>Where to read more:</em> Distributed Erlang and some distributed
programming techniques are described in the Erlang book.</p><p>For more information, see <a href="../doc/getting_started/conc_prog#Distributed Programming"> Distributed Programming.</a></p><p>Relevant manual pages are the following:</p><ul><li><a href="./erlang">erlang</a> manual page in ERTS (describes the BIFs)</li><li><a href="./global">global</a> manual page in Kernel</li><li><a href="./net_adm">net_adm</a> manual page in Kernel</li><li><a href="./pg2">pg2</a> manual page in Kernel</li><li><a href="./rpc">rpc</a> manual page in Kernel</li><li><a href="./pool">pool</a> manual page in STDLIB</li><li><a href="./slave">slave</a> manual page in STDLIB</li></ul><h2>Ports and Linked-In Drivers</h2><p>Ports provide the basic mechanism for communication with the
external world, from Erlang's point of view. The ports provide
a byte-oriented interface to an external program. When a port
is created, Erlang can communicate with it by sending and
receiving lists of bytes (not Erlang terms). This means that
the programmer might have to invent a suitable encoding and
decoding scheme.</p><p>The implementation of the port mechanism depends on the
platform. For UNIX, pipes are used and the external program is
assumed to read from standard input and write to standard
output. The external program can be written in any programming
language as long as it can handle the interprocess
communication mechanism with which the port is
implemented.</p><p>The external program resides in another OS process than the
Erlang runtime system. In some cases this is not acceptable.
Consider, for example, drivers with very hard time
requirements. It is therefore possible to write a program in C
according to certain principles, and dynamically link it to
the Erlang runtime system. This is called a <em>linked-in driver</em>.</p><p><em>When to use:</em> Ports can be used for all kinds of
interoperability situations where the Erlang program and the
other program runs on the same machine. Programming is fairly
straight-forward.</p><p>Linked-in drivers involves writing certain call-back
functions in C. This requires very good skills as the code is
linked to the Erlang runtime system.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>A faulty linked-in driver causes the entire Erlang runtime
system to leak memory, hang, or crash.</p></div><p><em>Where to read more:</em> Ports are described in section
"Miscellaneous Items" of the Erlang book. Linked-in drivers
are described in Appendix E.</p><p>The BIF <strong>open_port/2</strong> is documented in the
<a href="./erlang">erlang</a> manual page in
ERTS.</p><p>For linked-in drivers, the programmer needs to read the
<a href="./erl_ddll">erl_ddll</a> manual
page in Kernel.</p><p><em>Examples:</em> Port example in <a href="c_port"> Ports</a>.</p><h2>C and Java Libraries</h2><h2>Erl_Interface</h2><p>The program at the other side of a port is often a C program.
To help the C programmer, the Erl_Interface library
has been developed, including the following five parts:</p><ul><li> <strong>erl_marshal</strong>, <strong>erl_eterm</strong>, <strong>erl_format</strong>, and <strong>erl_malloc</strong>: Handling of the Erlang external term format</li><li> <strong>erl_connect</strong>: Communication with distributed Erlang, see <a href="#cnode">C nodes</a> below</li><li> <strong>erl_error</strong>: Error print routines</li><li> <strong>erl_global</strong>: Access globally registered names</li><li> <strong>Registry</strong>: Store and backup of key-value pairs</li></ul><p>The Erlang external term format is a representation of an
Erlang term as a sequence of bytes, that is, a binary.
Conversion between the two representations is done using the
following BIFs:</p><pre>
Binary = term_to_binary(Term)
Term = binary_to_term(Binary)</pre><p>A port can be set to use binaries instead of lists of bytes.
It is then not necessary to invent any encoding/decoding
scheme. Erl_Interface functions are used for unpacking the
binary and convert it into a struct similar to an Erlang term.
Such a struct can be manipulated in different ways, be
converted to the Erlang external format, and sent to
Erlang.</p><p><em>When to use:</em> In C code, in conjunction with Erlang binaries.</p><p><em>Where to read more:</em> See the Erlang Interface User's
Guide, Command Reference, and Library Reference. In Erlang/OTP
R5B, and earlier versions, the information is part of the
Kernel application.</p><p><em>Examples:</em> Erl_Interface example in
<a href="erl_interface">Erl_Interface</a>.</p><a name="cnode"></a><h2>C Nodes</h2><p>A C program that uses the Erl_Interface functions for setting
up a connection to, and communicating with, a distributed
Erlang node is called a <em>C node</em>, or a <em>hidden node</em>. The main advantage with a C node is that the
communication from the Erlang programmer's perspective is
extremely easy, as the C program behaves as a distributed
Erlang node.</p><p><em>When to use:</em> C nodes can typically be used on device
processors (as opposed to control processors) where C is a
better choice than Erlang due to memory limitations or
application characteristics, or both.</p><p><em>Where to read more:</em> See the <strong>erl_connect</strong> part
of the Erl_Interface documentation. The programmer also needs
to be familiar with TCP/IP sockets, see Sockets in <a href="#sockets">Standard Protocols</a> and Distributed Erlang in <a href="#dist">Built-In Mechanisms</a>.</p><p><em>Example:</em> C node example in <a href="cnode"> C Nodes</a>.</p><h2>Jinterface</h2><p>In Erlang/OTP R6B, a library similar to Erl_Interface for
Java was added called <em>jinterface</em>. It provides a tool
for Java programs to communicate with Erlang nodes.</p><h2>Standard Protocols</h2><p>Sometimes communication between an Erlang program and another
program using a standard protocol is desirable. Erlang/OTP
currently supports TCP/IP and UDP <em>sockets</em>: as
follows:</p><ul><li>SNMP</li><li>HTTP</li><li>IIOP (CORBA)</li></ul><p>Using one of the latter three requires good knowledge about the
protocol and is not covered by this tutorial. See the SNMP,
Inets, and Orber applications, respectively.</p><a name="sockets"></a><h2>Sockets</h2><p>Simply put, connection-oriented socket communication (TCP/IP)
consists of an initiator socket ("server") started at a
certain host with a certain port number. A connector socket
("client"), which is aware of the initiator host name and port
number, can connect to it and data can be sent between
them.</p><p>Connection-less socket communication (UDP) consists of an
initiator socket at a certain host with a certain port number
and a connector socket sending data to it.</p><p>For a detailed description of the socket concept, refer to a
suitable book about network programming. A suggestion is
<em>UNIX Network Programming, Volume 1: Networking APIs - Sockets and XTI</em> by W. Richard Stevens, ISBN:
013490012X.</p><p>In Erlang/OTP, access to TCP/IP and UDP sockets is provided
by the modules <strong>gen_tcp</strong> and <strong>gen_udp</strong> in
Kernel. Both are easy to use and do not require
detailed knowledge about the socket concept.</p><p><em>When to use:</em> For programs running on the same or on
another machine than the Erlang program.</p><p><em>Where to read more:</em> See the <a href="./gen_tcp">gen_tcp</a> and the <a href="./gen_udp">gen_udp</a> manual pages in
Kernel.</p><h2>IC and CORBA</h2><p>IC (Erlang IDL Compiler) is an interface generator that, given
an IDL interface specification, automatically generates stub
code in Erlang, C, or Java. See the IC User's Guide and IC
Reference Manual.</p><p>For details, see the
<a href="https://github.com/erlang/corba">corba repository</a>.</p><h2>Old Applications</h2><p>Two old applications are of interest regarding
interoperability. Both have been replaced by IC and are
mentioned here for reference only:</p><ul><li><p>IG - Removed from Erlang/OTP R6B.</p> <p>IG (Interface Generator) automatically generated code for
port or socket communication between an Erlang program and a
C program, given a C header file with certain keywords.</p> </li><li><p>Jive -  Removed from Erlang/OTP R7B.</p> <p>Jive provided a simple interface between an Erlang program
and a Java program.</p> </li></ul></body></html>