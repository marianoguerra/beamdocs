<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>C Nodes</h1><p>This section outlines an example of how to solve the example
problem in <a href="example">Problem Example</a>
by using a C node. Notice that a C node is not typically
used for solving simple problems like this, a port is
sufficient.</p><h2>Erlang Program</h2><p>From Erlang's point of view, the C node is treated like a
normal Erlang node. Thus, calling the functions <strong>foo</strong> and
<strong>bar</strong> only involves sending a message to the C node asking
for the function to be called, and receiving the result. Sending
a message requires a recipient, that is, a process that can be
defined using either a pid or a tuple, consisting of a
registered name and a node name. In this case, a tuple is the
only alternative as no pid is known:</p><pre>
{RegName, Node} ! Msg</pre><p>The node name <strong>Node</strong> is to be the name of the C node. If
short node names are used, the plain name of the node is
<strong>cN</strong>, where <strong>N</strong> is an integer. If long node names are
used, there is no such restriction. An example of a C node name
using short node names is thus <strong>c1@idril</strong>, an example using
long node names is <strong>cnode@idril.ericsson.se</strong>.</p><p>The registered name, <strong>RegName</strong>, can be any atom. The name
can be ignored by the C code, or, for example, be used to
distinguish between different types of messages. An example of
Erlang code using short node names follows:
</p><pre><code class="">

-module(complex3).
-export([foo/1, bar/1]).

foo(X) -&gt;
    call_cnode({foo, X}).
bar(Y) -&gt;
    call_cnode({bar, Y}).

call_cnode(Msg) -&gt;
    {any, c1@idril} ! {call, self(), Msg},
    receive
	{cnode, Result} -&gt;
	    Result
    end.
</code></pre><p>
When using long node names, the code is slightly different as
shown in the following example:
</p><pre><code class="">

-module(complex4).
-export([foo/1, bar/1]).

foo(X) -&gt;
    call_cnode({foo, X}).
bar(Y) -&gt;
    call_cnode({bar, Y}).

call_cnode(Msg) -&gt;
    {any, 'cnode@idril.du.uab.ericsson.se'} ! {call, self(), Msg},
    receive
	{cnode, Result} -&gt;
	    Result
    end.
</code></pre><h2>C Program</h2><h2>Setting Up Communication</h2><p>Before calling any other function in Erl_Interface, the
memory handling must be initiated:</p><pre>
erl_init(NULL, 0);</pre><p>Now the C node can be initiated. If short node names are
used, this is done by calling <strong>erl_connect_init()</strong>:</p><pre>
erl_connect_init(1, "secretcookie", 0);</pre><p>Here:</p><ul><li>The first argument is the integer used to construct the node name. <p>In the example, the plain node name is <strong>c1</strong>.</p></li><li>The second argument is a string defining the magic cookie.</li><li>The third argument is an integer that is used to identify a particular instance of a C node.</li></ul><p>If long node node names are used, initiation is done by
calling <strong>erl_connect_xinit()</strong>:</p><pre>
erl_connect_xinit("idril", "cnode", "cnode@idril.ericsson.se",
                  &amp;addr, "secretcookie", 0);</pre><p>Here:</p><ul><li>The first argument is the host name.</li><li>The second argument is the plain node name.</li><li>The third argument is the full node name.</li><li>The fourth argument is a pointer to an <strong>in_addr</strong> struct with the IP address of the host.</li><li>The fifth argument is the magic cookie.</li><li>The sixth argument is the instance number.</li></ul><p>The C node can act as a server or a client when setting up
the Erlang-C communication. If it acts as a client, it
connects to an Erlang node by calling <strong>erl_connect()</strong>,
which returns an open file descriptor at success:</p><pre>
fd = erl_connect("e1@idril");</pre><p>If the C node acts as a server, it must first create a socket
(call <strong>bind()</strong> and <strong>listen()</strong>) listening to a
certain port number <strong>port</strong>. It then publishes its name
and port number with <strong>epmd</strong>, the Erlang port mapper
daemon. For details, see the <a href="./epmd">epmd</a> manual page in ERTS:</p><pre>
erl_publish(port);</pre><p>Now the C node server can accept connections from Erlang nodes:</p><pre>
fd = erl_accept(listen, &amp;conn);</pre><p>The second argument to <strong>erl_accept</strong> is a struct
<strong>ErlConnect</strong> which contains useful information when a
connection has been established, for example, the name of the
Erlang node.</p><h2>Sending and Receiving Messages</h2><p>The C node can receive a message from Erlang by calling
<strong>erl_receive msg()</strong>. This function reads data from the
open file descriptor <strong>fd</strong> into a buffer and puts the
result in an <strong>ErlMessage</strong> struct <strong>emsg</strong>.
<strong>ErlMessage</strong> has a field <strong>type</strong> defining what kind
of data is received. In this case, the type of interest is
<strong>ERL_REG_SEND</strong> which indicates that Erlang sent a message
to a registered process at the C node. The actual message, an
<strong>ETERM</strong>, is in the <strong>msg</strong> field.</p><p>It is also necessary to take care of the types
<strong>ERL_ERROR</strong> (an error occurred) and <strong>ERL_TICK</strong>
(alive check from other node, is to be ignored). Other
possible types indicate process events such as link, unlink,
and exit:</p><pre>
  while (loop) {

    got = erl_receive_msg(fd, buf, BUFSIZE, &amp;emsg);
    if (got == ERL_TICK) {
      /* ignore */
    } else if (got == ERL_ERROR) {
      loop = 0; /* exit while loop */
    } else {
      if (emsg.type == ERL_REG_SEND) {</pre><p>As the message is an <strong>ETERM</strong> struct, Erl_Interface
functions can be used to manipulate it. In this case, the
message becomes a 3-tuple, because that is how the Erlang code
is written. The second element will be the pid of the caller
and the third element will be the tuple <strong>{Function,Arg}</strong>
determining which function to call, and with which argument.
The result of calling the function is made into an
<strong>ETERM</strong> struct as well and sent back to Erlang using
<strong>erl_send()</strong>, which takes the open file descriptor, a
pid, and a term as arguments:</p><pre>
        fromp = erl_element(2, emsg.msg);
        tuplep = erl_element(3, emsg.msg);
        fnp = erl_element(1, tuplep);
        argp = erl_element(2, tuplep);

        if (strncmp(ERL_ATOM_PTR(fnp), "foo", 3) == 0) {
          res = foo(ERL_INT_VALUE(argp));
        } else if (strncmp(ERL_ATOM_PTR(fnp), "bar", 3) == 0) {
          res = bar(ERL_INT_VALUE(argp));
        }

        resp = erl_format("{cnode, ~i}", res);
        erl_send(fd, fromp, resp);</pre><p>Finally, the memory allocated by the <strong>ETERM</strong> creating
functions (including <strong>erl_receive_msg()</strong> must be
freed:</p><pre>
        erl_free_term(emsg.from); erl_free_term(emsg.msg);
        erl_free_term(fromp); erl_free_term(tuplep);
        erl_free_term(fnp); erl_free_term(argp);
        erl_free_term(resp);</pre><p>The following examples show the resulting C programs.
First a C node server using short node names:</p><pre><code class="">

/* cnode_s.c */

#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

#include "erl_interface.h"
#include "ei.h"

#define BUFSIZE 1000

int main(int argc, char **argv) {
  int port;                                /* Listen port number */
  int listen;                              /* Listen socket */
  int fd;                                  /* fd to Erlang node */
  ErlConnect conn;                         /* Connection data */

  int loop = 1;                            /* Loop flag */
  int got;                                 /* Result of receive */
  unsigned char buf[BUFSIZE];              /* Buffer for incoming message */
  ErlMessage emsg;                         /* Incoming message */

  ETERM *fromp, *tuplep, *fnp, *argp, *resp;
  int res;

  port = atoi(argv[1]);

  erl_init(NULL, 0);

  if (erl_connect_init(1, "secretcookie", 0) == -1)
    erl_err_quit("erl_connect_init");

  /* Make a listen socket */
  if ((listen = my_listen(port)) &lt;= 0)
    erl_err_quit("my_listen");

  if (erl_publish(port) == -1)
    erl_err_quit("erl_publish");

  if ((fd = erl_accept(listen, &amp;conn)) == ERL_ERROR)
    erl_err_quit("erl_accept");
  fprintf(stderr, "Connected to %s\n\r", conn.nodename);

  while (loop) {

    got = erl_receive_msg(fd, buf, BUFSIZE, &amp;emsg);
    if (got == ERL_TICK) {
      /* ignore */
    } else if (got == ERL_ERROR) {
      loop = 0;
    } else {

      if (emsg.type == ERL_REG_SEND) {
	fromp = erl_element(2, emsg.msg);
	tuplep = erl_element(3, emsg.msg);
	fnp = erl_element(1, tuplep);
	argp = erl_element(2, tuplep);

	if (strncmp(ERL_ATOM_PTR(fnp), "foo", 3) == 0) {
	  res = foo(ERL_INT_VALUE(argp));
	} else if (strncmp(ERL_ATOM_PTR(fnp), "bar", 3) == 0) {
	  res = bar(ERL_INT_VALUE(argp));
	}

	resp = erl_format("{cnode, ~i}", res);
	erl_send(fd, fromp, resp);

	erl_free_term(emsg.from); erl_free_term(emsg.msg);
	erl_free_term(fromp); erl_free_term(tuplep);
	erl_free_term(fnp); erl_free_term(argp);
	erl_free_term(resp);
      }
    }
  } /* while */
}

  
int my_listen(int port) {
  int listen_fd;
  struct sockaddr_in addr;
  int on = 1;

  if ((listen_fd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)
    return (-1);

  setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on));

  memset((void*) &amp;addr, 0, (size_t) sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_port = htons(port);
  addr.sin_addr.s_addr = htonl(INADDR_ANY);

  if (bind(listen_fd, (struct sockaddr*) &amp;addr, sizeof(addr)) &lt; 0)
    return (-1);

  listen(listen_fd, 5);
  return listen_fd;
}
</code></pre><p>A C node server using long node names:</p><pre><code class="">

/* cnode_s2.c */

#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

#include "erl_interface.h"
#include "ei.h"

#define BUFSIZE 1000

int main(int argc, char **argv) {
  struct in_addr addr;                     /* 32-bit IP number of host */
  int port;                                /* Listen port number */
  int listen;                              /* Listen socket */
  int fd;                                  /* fd to Erlang node */
  ErlConnect conn;                         /* Connection data */

  int loop = 1;                            /* Loop flag */
  int got;                                 /* Result of receive */
  unsigned char buf[BUFSIZE];              /* Buffer for incoming message */
  ErlMessage emsg;                         /* Incoming message */

  ETERM *fromp, *tuplep, *fnp, *argp, *resp;
  int res;
  
  port = atoi(argv[1]);

  erl_init(NULL, 0);

  addr.s_addr = inet_addr("134.138.177.89");
  if (erl_connect_xinit("idril", "cnode", "cnode@idril.du.uab.ericsson.se",
			&amp;addr, "secretcookie", 0) == -1)
    erl_err_quit("erl_connect_xinit");

  /* Make a listen socket */
  if ((listen = my_listen(port)) &lt;= 0)
    erl_err_quit("my_listen");

  if (erl_publish(port) == -1)
    erl_err_quit("erl_publish");

  if ((fd = erl_accept(listen, &amp;conn)) == ERL_ERROR)
    erl_err_quit("erl_accept");
  fprintf(stderr, "Connected to %s\n\r", conn.nodename);

  while (loop) {

    got = erl_receive_msg(fd, buf, BUFSIZE, &amp;emsg);
    if (got == ERL_TICK) {
      /* ignore */
    } else if (got == ERL_ERROR) {
      loop = 0;
    } else {

      if (emsg.type == ERL_REG_SEND) {
	fromp = erl_element(2, emsg.msg);
	tuplep = erl_element(3, emsg.msg);
	fnp = erl_element(1, tuplep);
	argp = erl_element(2, tuplep);

	if (strncmp(ERL_ATOM_PTR(fnp), "foo", 3) == 0) {
	  res = foo(ERL_INT_VALUE(argp));
	} else if (strncmp(ERL_ATOM_PTR(fnp), "bar", 3) == 0) {
	  res = bar(ERL_INT_VALUE(argp));
	}

	resp = erl_format("{cnode, ~i}", res);
	erl_send(fd, fromp, resp);

	erl_free_term(emsg.from); erl_free_term(emsg.msg);
	erl_free_term(fromp); erl_free_term(tuplep);
	erl_free_term(fnp); erl_free_term(argp);
	erl_free_term(resp);
      }
    }
  }
}

  
int my_listen(int port) {
  int listen_fd;
  struct sockaddr_in addr;
  int on = 1;

  if ((listen_fd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)
    return (-1);

  setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on));

  memset((void*) &amp;addr, 0, (size_t) sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_port = htons(port);
  addr.sin_addr.s_addr = htonl(INADDR_ANY);

  if (bind(listen_fd, (struct sockaddr*) &amp;addr, sizeof(addr)) &lt; 0)
    return (-1);

  listen(listen_fd, 5);
  return listen_fd;
}
</code></pre><p>Finally, the code for the C node client:</p><pre><code class="">

/* cnode_c.c */

#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

#include "erl_interface.h"
#include "ei.h"

#define BUFSIZE 1000

int main(int argc, char **argv) {
  int fd;                                  /* fd to Erlang node */

  int loop = 1;                            /* Loop flag */
  int got;                                 /* Result of receive */
  unsigned char buf[BUFSIZE];              /* Buffer for incoming message */
  ErlMessage emsg;                         /* Incoming message */

  ETERM *fromp, *tuplep, *fnp, *argp, *resp;
  int res;
  
  erl_init(NULL, 0);

  if (erl_connect_init(1, "secretcookie", 0) == -1)
    erl_err_quit("erl_connect_init");

  if ((fd = erl_connect("e1@idril")) &lt; 0)
    erl_err_quit("erl_connect");
  fprintf(stderr, "Connected to ei@idril\n\r");

  while (loop) {

    got = erl_receive_msg(fd, buf, BUFSIZE, &amp;emsg);
    if (got == ERL_TICK) {
      /* ignore */
    } else if (got == ERL_ERROR) {
      loop = 0;
    } else {

      if (emsg.type == ERL_REG_SEND) {
	fromp = erl_element(2, emsg.msg);
	tuplep = erl_element(3, emsg.msg);
	fnp = erl_element(1, tuplep);
	argp = erl_element(2, tuplep);

	if (strncmp(ERL_ATOM_PTR(fnp), "foo", 3) == 0) {
	  res = foo(ERL_INT_VALUE(argp));
	} else if (strncmp(ERL_ATOM_PTR(fnp), "bar", 3) == 0) {
	  res = bar(ERL_INT_VALUE(argp));
	}

	resp = erl_format("{cnode, ~i}", res);
	erl_send(fd, fromp, resp);

	erl_free_term(emsg.from); erl_free_term(emsg.msg);
	erl_free_term(fromp); erl_free_term(tuplep);
	erl_free_term(fnp); erl_free_term(argp);
	erl_free_term(resp);
      }
    }
  }
}
</code></pre><h2>Running the Example</h2><p><em>Step 1.</em> Compile the C code. This provides the paths to
the Erl_Interface include files and libraries, and to the
<strong>socket</strong> and <strong>nsl</strong> libraries:</p><pre>
&gt;  <span class="input">gcc -o cserver \\ </span>
<span class="input">-I/usr/local/otp/lib/erl_interface-3.2.1/include \\ </span>
<span class="input">-L/usr/local/otp/lib/erl_interface-3.2.1/lib \\ </span>
<span class="input">complex.c cnode_s.c \\ </span>
<span class="input">-lerl_interface -lei -lsocket -lnsl</span>

unix&gt; <span class="input">gcc -o cserver2 \\ </span>
<span class="input">-I/usr/local/otp/lib/erl_interface-3.2.1/include \\ </span>
<span class="input">-L/usr/local/otp/lib/erl_interface-3.2.1/lib \\ </span>
<span class="input">complex.c cnode_s2.c \\ </span>
<span class="input">-lerl_interface -lei -lsocket -lnsl</span>

unix&gt; <span class="input">gcc -o cclient \\ </span>
<span class="input">-I/usr/local/otp/lib/erl_interface-3.2.1/include \\ </span>
<span class="input">-L/usr/local/otp/lib/erl_interface-3.2.1/lib \\ </span>
<span class="input">complex.c cnode_c.c \\ </span>
<span class="input">-lerl_interface -lei -lsocket -lnsl</span></pre><p>In Erlang/OTP R5B and later versions of OTP, the
<strong>include</strong> and <strong>lib</strong> directories are situated under
<strong>OTPROOT/lib/erl_interface-VSN</strong>, where <strong>OTPROOT</strong> is
the root directory of the OTP installation
(<strong>/usr/local/otp</strong> in the recent example) and <strong>VSN</strong> is
the version of the Erl_Interface application (3.2.1 in the
recent example).</p><p>In R4B and earlier versions of OTP, <strong>include</strong> and
<strong>lib</strong> are situated under <strong>OTPROOT/usr</strong>.</p><p><em>Step 2.</em> Compile the Erlang code:</p><pre>
unix&gt; <span class="input">erl -compile complex3 complex4</span></pre><p><em>Step 3.</em> Run the C node server example with short node names.</p><p>Do as follows:</p><ul><li>Start the C program <strong>cserver</strong> and Erlang in different windows.</li><li><strong>cserver</strong> takes a port number as argument and must be started before trying to call the Erlang functions.</li><li>The Erlang node is to be given the short name <strong>e1</strong> and must be set to use the same magic cookie as the C node, <strong>secretcookie</strong>:</li></ul><pre>
unix&gt; <span class="input">cserver 3456</span>

unix&gt; <span class="input">erl -sname e1 -setcookie secretcookie</span>
Erlang (BEAM) emulator version 4.9.1.2
 
Eshell V4.9.1.2  (abort with ^G)
(e1@idril)1&gt; <span class="input">complex3:foo(3).</span>
4
(e1@idril)2&gt; <span class="input">complex3:bar(5).</span>
10</pre><p><em>Step 4.</em> Run the C node client example. Terminate
<strong>cserver</strong>, but not Erlang, and start <strong>cclient</strong>. The
Erlang node must be started before the C node client:</p><pre>
unix&gt; <span class="input">cclient</span>

(e1@idril)3&gt; <span class="input">complex3:foo(3).</span>
4
(e1@idril)4&gt; <span class="input">complex3:bar(5).</span>
10</pre><p><em>Step 5.</em> Run the C node server example with long node names:</p><pre>
unix&gt; <span class="input">cserver2 3456</span>

unix&gt; <span class="input">erl -name e1 -setcookie secretcookie</span>
Erlang (BEAM) emulator version 4.9.1.2
 
Eshell V4.9.1.2  (abort with ^G)
(e1@idril.du.uab.ericsson.se)1&gt; <span class="input">complex4:foo(3).</span>
4
(e1@idril.du.uab.ericsson.se)2&gt; <span class="input">complex4:bar(5).</span>
10</pre></body></html>