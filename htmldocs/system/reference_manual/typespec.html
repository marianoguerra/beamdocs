<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Types and Function Specifications</h1><h2>The Erlang Type Language</h2><p>
Erlang is a dynamically typed language. Still, it comes with a
notation for declaring sets of Erlang terms to form a particular
type. This effectively forms specific subtypes of the set of all
Erlang terms.
</p><p>
Subsequently, these types can be used to specify types of record fields
and also the argument and return types of functions.
</p><p>
Type information can be used for the following:</p><ul><li>To document function interfaces</li><li>To provide more information for bug detection tools, such as Dialyzer</li><li>To be exploited by documentation tools, such as EDoc, for generating program documentation of various forms</li></ul><p>It is expected that the type language described in this section
supersedes and replaces the purely comment-based <strong>@type</strong> and
<strong>@spec</strong> declarations used by EDoc.</p><a name="syntax"></a><h2>Types and their Syntax</h2><p>
Types describe sets of Erlang terms.
Types consist of, and are built from, a set of predefined types,
for example, <strong>integer()</strong>, <strong>atom()</strong>, and <strong>pid()</strong>.
Predefined types represent a typically infinite set of Erlang terms that
belong to this type.  For example, the type <strong>atom()</strong> denotes the
set of all Erlang atoms.
</p><p>
For integers and atoms, it is allowed for singleton types; for example,
the integers
<strong>-1</strong> and <strong>42</strong>, or the atoms <strong>'foo'</strong> and <strong>'bar'</strong>.
All other types are built using unions of either predefined
types or singleton types. In a type union between a type and one
of its subtypes, the subtype is absorbed by the supertype. Thus,
the union is then treated as if the subtype was not a
constituent of the union. For example, the type union:
</p><pre>  atom() | 'bar' | integer() | 42</pre><p>
describes the same set of terms as the type union:
</p><pre>  atom() | integer()</pre><p>
Because of subtype relations that exist between types, types
form a lattice where the top-most element, <strong>any()</strong>, denotes
the set of all Erlang terms and the bottom-most element, <strong>none()</strong>,
denotes the empty set of terms.
</p><p>
The set of predefined types and the syntax for types follows:
</p><pre>
  Type :: any()                 %% The top type, the set of all Erlang terms
        | none()                %% The bottom type, contains no terms
        | pid()
        | port()
        | reference()
        | []                    %% nil
        | Atom
        | Bitstring
        | float()
        | Fun
        | Integer
        | List
        | Map
        | Tuple
        | Union
        | UserDefined           %% described in Type Declarations of User-Defined Types

  Atom :: atom()
        | Erlang_Atom           %% 'foo', 'bar', ...

  Bitstring :: &lt;&lt;&gt;&gt;
             | &lt;&lt;_:M&gt;&gt;          %% M is an Integer_Value that evaluates to a positive integer
             | &lt;&lt;_:_*N&gt;&gt;        %% N is an Integer_Value that evaluates to a positive integer
             | &lt;&lt;_:M, _:_*N&gt;&gt;

  Fun :: fun()                  %% any function
       | fun((...) -&gt; Type)     %% any arity, returning Type
       | fun(() -&gt; Type)
       | fun((TList) -&gt; Type)

  Integer :: integer()
           | Integer_Value
           | Integer_Value..Integer_Value      %% specifies an integer range

  Integer_Value :: Erlang_Integer              %% ..., -1, 0, 1, ... 42 ...
                 | Erlang_Character            %% $a, $b ...
                 | Integer_Value BinaryOp Integer_Value
                 | UnaryOp Integer_Value

  BinaryOp :: '*' | 'div' | 'rem' | 'band' | '+' | '-' | 'bor' | 'bxor' | 'bsl' | 'bsr'

  UnaryOp :: '+' | '-' | 'bnot'

  List :: list(Type)                           %% Proper list ([]-terminated)
        | maybe_improper_list(Type1, Type2)    %% Type1=contents, Type2=termination
        | nonempty_improper_list(Type1, Type2) %% Type1 and Type2 as above
        | nonempty_list(Type)                  %% Proper non-empty list

  Map :: map()                                 %% denotes a map of any size
       | #{}                                   %% denotes the empty map
       | #{AssociationList}

  Tuple :: tuple()                             %% denotes a tuple of any size
         | {}
         | {TList}

  AssociationList :: Association
                   | Association, AssociationList

  Association :: Type := Type                  %% denotes a mandatory association
               | Type =&gt; Type                  %% denotes an optional association

  TList :: Type
         | Type, TList

  Union :: Type1 | Type2
</pre><p>
Integer values are either integer or character literals or expressions
consisting of possibily nested unary or binary operations that evaluate to
an integer. Such expressions can also be used in bit strings and ranges.
</p><p>
The general form of bit strings is <strong>&lt;&lt;_:M, _:_*N&gt;&gt;</strong>,
where <strong>M</strong> and <strong>N</strong> must evaluate to positive integers. It denotes a
bit string that is <strong>M + (k*N)</strong> bits long (that is, a bit string that
starts with <strong>M</strong> bits and continues with <strong>k</strong> segments of
<strong>N</strong> bits each, where <strong>k</strong> is also a positive integer).
The notations <strong>&lt;&lt;_:_*N&gt;&gt;</strong>, <strong>&lt;&lt;_:M&gt;&gt;</strong>,
and <strong>&lt;&lt;&gt;&gt;</strong> are convenient shorthands for the cases
that <strong>M</strong> or <strong>N</strong>, or both, are zero.
</p><p>
Because lists are commonly used, they have shorthand type notations.
The types <strong>list(T)</strong> and <strong>nonempty_list(T)</strong> have the shorthands
<strong>[T]</strong> and <strong>[T,...]</strong>, respectively.
The only difference between the two shorthands is that <strong>[T]</strong> can be an
empty list but <strong>[T,...]</strong> cannot.
</p><p>
Notice that the shorthand for <strong>list()</strong>, that is, the list of
elements of unknown type, is <strong>[_]</strong> (or <strong>[any()]</strong>), not <strong>[]</strong>.
The notation <strong>[]</strong> specifies the singleton type for the empty list.
</p><p>
The general form of map types is <strong>#{AssociationList}</strong>.
The key types in
<strong>AssociationList</strong> are allowed to overlap, and if they do, the
leftmost association takes precedence. A map association has a key in
<strong>AssociationList</strong> if it belongs to this type.
<strong>AssociationList</strong> can contain both mandatory and optional
association types.
If an association type is mandatory, an association with that type
is to be present.
In the case of an optional association type it is not required for
the key type to be present.
</p><p>
Notice that the syntactic representation of <strong>map()</strong> is
<strong>#{any() =&gt; any()}</strong> (or <strong>#{_ =&gt; _}</strong>), not <strong>#{}</strong>.
The notation <strong>#{}</strong> specifies the singleton type for the empty map.
</p><p>
For convenience, the following types are also built-in.
They can be thought as predefined aliases for the type unions also shown in
the table.
</p><table class="table table-bordered table-hover table-striped"><caption>Built-in types, predefined aliases</caption><tbody><tr><td><em>Built-in type</em></td><td><em>Defined as</em></td></tr><tr><td><strong>term()</strong></td><td><strong>any()</strong></td></tr><tr><td><strong>binary()</strong></td><td><strong>&lt;&lt;_:_*8&gt;&gt;</strong></td></tr><tr><td><strong>bitstring()</strong></td><td><strong>&lt;&lt;_:_*1&gt;&gt;</strong></td></tr><tr><td><strong>boolean()</strong></td><td><strong>'false' | 'true'</strong></td></tr><tr><td><strong>byte()</strong></td><td><strong>0..255</strong></td></tr><tr><td><strong>char()</strong></td><td><strong>0..16#10ffff</strong></td></tr><tr><td><strong>nil()</strong></td><td><strong>[]</strong></td></tr><tr><td><strong>number()</strong></td><td><strong>integer() | float()</strong></td></tr><tr><td><strong>list()</strong></td><td><strong>[any()]</strong></td></tr><tr><td><strong>maybe_improper_list()</strong></td><td><strong>maybe_improper_list(any(), any())</strong></td></tr><tr><td><strong>nonempty_list()</strong></td><td><strong>nonempty_list(any())</strong></td></tr><tr><td><strong>string()</strong></td><td><strong>[char()]</strong></td></tr><tr><td><strong>nonempty_string()</strong></td><td><strong>[char(),...]</strong></td></tr><tr><td><strong>iodata()</strong></td><td><strong>iolist() | binary()</strong></td></tr><tr><td><strong>iolist()</strong></td><td><strong>maybe_improper_list(byte() | binary() | iolist(), binary() | [])</strong></td></tr><tr><td><strong>function()</strong></td><td><strong>fun()</strong></td></tr><tr><td><strong>module()</strong></td><td><strong>atom()</strong></td></tr><tr><td><strong>mfa()</strong></td><td><strong>{module(),atom(),arity()}</strong></td></tr><tr><td><strong>arity()</strong></td><td><strong>0..255</strong></td></tr><tr><td><strong>identifier()</strong></td><td><strong>pid() | port() | reference()</strong></td></tr><tr><td><strong>node()</strong></td><td><strong>atom()</strong></td></tr><tr><td><strong>timeout()</strong></td><td><strong>'infinity' | non_neg_integer()</strong></td></tr><tr><td><strong>no_return()</strong></td><td><strong>none()</strong></td></tr></tbody></table><p>
In addition, the following three built-in types exist and can be
thought as defined below, though strictly their "type definition" is
not valid syntax according to the type language defined above.
</p><table class="table table-bordered table-hover table-striped"><caption>Additional built-in types</caption><tbody><tr><td><em>Built-in type</em></td><td><em> Can be thought defined by the syntax</em></td></tr><tr><td><strong>non_neg_integer()</strong></td><td><strong>0..</strong></td></tr><tr><td><strong>pos_integer()</strong></td><td><strong>1..</strong></td></tr><tr><td><strong>neg_integer()</strong></td><td><strong>..-1</strong></td></tr></tbody></table><p>
Users are not allowed to define types with the same names as the
predefined or built-in ones. This is checked by the compiler and
its violation results in a compilation error.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
The following built-in list types also exist,
but they are expected to be rarely used. Hence, they have long names:
</p></div><pre>
  nonempty_maybe_improper_list() :: nonempty_maybe_improper_list(any(), any())
  nonempty_improper_list(Type1, Type2)
  nonempty_maybe_improper_list(Type1, Type2)</pre><p>
where the last two types
define the set of Erlang terms one would expect.
</p><p>
Also for convenience, record notation is allowed to be used.
Records are shorthands for the corresponding tuples:
</p><pre>
  Record :: #Erlang_Atom{}
          | #Erlang_Atom{Fields}</pre><p>
Records are extended to possibly contain type information.
This is described in <a href="#typeinrecords"> Type Information in Record Declarations</a>.
</p><h2>Type Declarations of User-Defined Types</h2><p>
As seen, the basic syntax of a type is an atom followed by closed
parentheses. New types are declared using <strong>-type</strong> and <strong>-opaque</strong>
attributes as in the following:
</p><pre>
  -type my_struct_type() :: Type.
  -opaque my_opaq_type() :: Type.</pre><p>
The type name is the atom <strong>my_struct_type</strong>,
followed by parentheses. <strong>Type</strong> is a type as defined in the
previous section.
A current restriction is that <strong>Type</strong> can contain
only predefined types,
or user-defined types which are either of the following:
</p><ul><li>Module-local type, that is, with a definition that is present in the code of the module</li><li>Remote type, that is, type defined in, and exported by, other modules; more about this soon.</li></ul><p>For module-local types, the restriction that their definition
exists in the module is enforced by the compiler and results in a
compilation error. (A similar restriction currently exists for records.)    </p><p>
Type declarations can also be parameterized by including type variables
between the parentheses. The syntax of type variables is the same as
Erlang variables, that is, starts with an upper-case letter.
Naturally, these variables can - and is to - appear on the RHS of the
definition. A concrete example follows:
</p><pre>
  -type orddict(Key, Val) :: [{Key, Val}].</pre><p>
A module can export some types to declare that other modules
are allowed to refer to them as <em>remote types</em>.
This declaration has the following form:</p><pre>
  -export_type([T1/A1, ..., Tk/Ak]).</pre><p>Here the Ti's are atoms (the name of the type) and the Ai's are their
arguments</p><p><em>Example:</em></p><pre>
  -export_type([my_struct_type/0, orddict/2]).</pre><p>Assuming that these types are exported from module <strong>'mod'</strong>,
you can refer to them from other modules using remote type expressions
like the following:</p><pre>
  mod:my_struct_type()
  mod:orddict(atom(), term())</pre><p>It is not allowed to refer to types that are not declared as exported.
</p><p>
Types declared as <strong>opaque</strong> represent sets of terms whose
structure is not supposed to be visible from outside of
their defining module. That is, only the module defining them
is allowed to depend on their term structure. Consequently, such
types do not make much sense as module local - module local
types are not accessible by other modules anyway - and is
always to be exported.
</p><a name="typeinrecords"></a><h2>Type Information in Record Declarations</h2><p>
The types of record fields can be specified in the declaration of the
record. The syntax for this is as follows:
</p><pre>
  -record(rec, {field1 :: Type1, field2, field3 :: Type3}).</pre><p>
For fields without type annotations, their type defaults to any().
That is, the previous example is a shorthand for the following:
</p><pre>
  -record(rec, {field1 :: Type1, field2 :: any(), field3 :: Type3}).</pre><p>
In the presence of initial values for fields,
the type must be declared after the initialization, as follows:
</p><pre>
  -record(rec, {field1 = [] :: Type1, field2, field3 = 42 :: Type3}).</pre><p>
The initial values for fields are to be compatible
with (that is, a member of) the corresponding types.
This is checked by the compiler and results in a compilation error
if a violation is detected.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Before Erlang/OTP 19, for fields without initial values,
the singleton type <strong>'undefined'</strong> was added to all declared types.
In other words, the following two record declarations had identical
effects:</p><pre>
  -record(rec, {f1 = 42 :: integer(),
                f2      :: float(),
                f3      :: 'a' | 'b'}).

  -record(rec, {f1 = 42 :: integer(),
                f2      :: 'undefined' | float(),
                f3      :: 'undefined' | 'a' | 'b'}).</pre><p>
This is no longer the case. If you require <strong>'undefined'</strong> in your record field
type, you must explicitly add it to the typespec, as in the 2nd example.
</p></div><p>
Any record, containing type information or not, once defined,
can be used as a type using the following syntax:
</p><pre>  #rec{}</pre><p>
In addition, the record fields can be further specified when using
a record type by adding type information about the field
as follows:
</p><pre>  #rec{some_field :: Type}</pre><p>
Any unspecified fields are assumed to have the type in the original
record declaration.
</p><h2>Specifications for Functions</h2><p>
A specification (or contract) for a function is given using the
<strong>-spec</strong> attribute. The general format is as follows:
</p><pre>
  -spec Module:Function(ArgType1, ..., ArgTypeN) -&gt; ReturnType.</pre><p>
The arity of the function must match the number of arguments,
else a compilation error occurs.
</p><p>
This form can also be used in header files (.hrl) to declare type
information for exported functions.
Then these header files can be included in files that (implicitly or
explicitly) import these functions.
</p><p>
Within a given module, the following shorthand suffices in most cases:
</p><pre>
  -spec Function(ArgType1, ..., ArgTypeN) -&gt; ReturnType.</pre><p>
Also, for documentation purposes, argument names can be given:
</p><pre>
  -spec Function(ArgName1 :: Type1, ..., ArgNameN :: TypeN) -&gt; RT.</pre><p>
A function specification can be overloaded.
That is, it can have several types, separated by a semicolon (<strong>;</strong>):
</p><pre>
  -spec foo(T1, T2) -&gt; T3
         ; (T4, T5) -&gt; T6.</pre><p>
A current restriction, which currently results in a warning
(not an error) by the compiler, is that the domains of
the argument types cannot overlap.
For example, the following specification results in a warning:
</p><pre>
  -spec foo(pos_integer()) -&gt; pos_integer()
         ; (integer()) -&gt; integer().</pre><p>
Type variables can be used in specifications to specify relations for
the input and output arguments of a function.
For example, the following specification defines the type of a
polymorphic identity function:
</p><pre>
  -spec id(X) -&gt; X.</pre><p>
Notice that the above specification does not restrict the input
and output type in any way.
These types can be constrained by guard-like subtype constraints
and provide bounded quantification:
</p><pre>  -spec id(X) -&gt; X when X :: tuple().</pre><p>
Currently, the <strong>::</strong> constraint
(read as Â«is a subtype ofÂ») is
the only guard constraint that can be used in the <strong>when</strong>
part of a <strong>-spec</strong> attribute.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
The above function specification uses multiple occurrences of
the same type variable. That provides more type information than the
following function specification, where the type variables are missing:
</p><pre>  -spec id(tuple()) -&gt; tuple().</pre><p>
The latter specification says that the function takes some tuple
and returns some tuple. The specification with the <strong>X</strong> type
variable specifies that the function takes a tuple and returns
<em>the same</em> tuple.
</p><p>
However, it is up to the tools that process the specifications
to choose whether to take this extra information into account
or not.
</p></div><p>
The scope of a <strong>::</strong> constraint is the
<strong>(...) -&gt; RetType</strong>
specification after which it appears. To avoid confusion,
it is suggested that different variables are used in different
constituents of an overloaded contract, as shown in the
following example:
</p><pre>
  -spec foo({X, integer()}) -&gt; X when X :: atom()
         ; ([Y]) -&gt; Y when Y :: number().</pre><p>
Some functions in Erlang are not meant to return;
either because they define servers or because they are used to
throw exceptions, as in the following function:
</p><pre>  my_error(Err) -&gt; erlang:throw({error, Err}).</pre><p>
For such functions, it is recommended to use the special
<strong>no_return()</strong> type for their "return", through a contract
of the following form:
</p><pre>  -spec my_error(term()) -&gt; no_return().</pre></body></html>