<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Data Types</h1><p>Erlang provides a number of data types, which are listed in
this section.</p><h2>Terms</h2><p>A piece of data of any data type is called a <em>term</em>.</p><h2>Number</h2><p>There are two types of numeric literals, <em>integers</em> and
<em>floats</em>. Besides the conventional notation, there are two
Erlang-specific notations:</p><ul><li><strong>$</strong><em>char</em>      <br/> ASCII value or unicode code-point of the character <em>char</em>.</li><li><em>base</em><strong>#</strong><em>value</em>      <br/> Integer with the base <em>base</em>, that must be an integer in the range 2..36.</li></ul><p><em>Examples:</em></p><pre>
1&gt; <span class="input">42.</span>
42
2&gt; <span class="input">$A.</span>
65
3&gt; <span class="input">$\n.</span>
10
4&gt; <span class="input">2#101.</span>
5
5&gt; <span class="input">16#1f.</span>
31
6&gt; <span class="input">2.3.</span>
2.3
7&gt; <span class="input">2.3e3.</span>
2.3e3
8&gt; <span class="input">2.3e-3.</span>
0.0023</pre><h2>Atom</h2><p>An atom is a literal, a constant with name. An atom is to be
enclosed in single quotes (') if it does not begin with a
lower-case letter or if it contains other characters than
alphanumeric characters, underscore (_), or @.</p><p><em>Examples:</em></p><pre>
hello
phone_number
'Monday'
'phone number'</pre><h2>Bit Strings and Binaries</h2><p>A bit string is used to store an area of untyped memory.</p><p>Bit strings are expressed using the
<a href="./expressions#bit_syntax">bit syntax</a>.</p><p>Bit strings that consist of a number of bits that are evenly
divisible by eight, are called <em>binaries</em></p><p><em>Examples:</em></p><pre>
1&gt; <span class="input">&lt;&lt;10,20&gt;&gt;.</span>
&lt;&lt;10,20&gt;&gt;
2&gt; <span class="input">&lt;&lt;"ABC"&gt;&gt;.</span>
&lt;&lt;"ABC"&gt;&gt;
1&gt; <span class="input">&lt;&lt;1:1,0:1&gt;&gt;.</span>
&lt;&lt;2:2&gt;&gt;</pre><p>For more examples,
see <a href="./bit_syntax"> Programming Examples</a>.</p><h2>Reference</h2><p>A reference is a term that is unique in an Erlang runtime
system, created by calling <strong>make_ref/0</strong>.</p><h2>Fun</h2><p>A fun is a functional object. Funs make it possible to create
an anonymous function and pass the function itself -- not its
name -- as argument to other functions.</p><p><em>Example:</em></p><pre>
1&gt; <span class="input">Fun1 = fun (X) -&gt; X+1 end.</span>
#Fun&lt;erl_eval.6.39074546&gt;
2&gt; <span class="input">Fun1(2).</span>
3</pre><p>Read more about funs in <a href="./expressions#funs"> Fun Expressions</a>. For more examples, see
<a href="./funs"> Programming Examples</a>.</p><h2>Port Identifier</h2><p>A port identifier identifies an Erlang port.</p><p><strong>open_port/2</strong>, which is used to create ports, returns
a value of this data type.</p><p>Read more about ports in <a href="ports">Ports and Port Drivers</a>.</p><h2>Pid</h2><p>A process identifier, pid, identifies a process.</p><p>The following BIFs, which are used to create processes, return
values of this data type:</p><ul><li><strong>spawn/1,2,3,4</strong></li><li><strong>spawn_link/1,2,3,4</strong></li><li><strong>spawn_opt/4</strong></li></ul><p><em>Example:</em></p><pre>
1&gt; <span class="input">spawn(m, f, []).</span>
&lt;0.51.0&gt;</pre><p>In the following example, the BIF <strong>self()</strong> returns
the pid of the calling process:</p><pre>
-module(m).
-export([loop/0]).

loop() -&gt;
    receive
        who_are_you -&gt;
            io:format("I am ~p~n", [self()]),
            loop()
    end.

1&gt; <span class="input">P = spawn(m, loop, []).</span>
&lt;0.58.0&gt;
2&gt; <span class="input">P ! who_are_you.</span>
I am &lt;0.58.0&gt;
who_are_you</pre><p>Read more about processes in
<a href="processes">Processes</a>.</p><h2>Tuple</h2><p>A tuple is a compound data type with a fixed number of terms:</p><pre>
{Term1,...,TermN}</pre><p>Each term <strong>Term</strong> in the tuple is called an
<em>element</em>. The number of elements is said to be
the <em>size</em> of the tuple.</p><p>There exists a number of BIFs to manipulate tuples.</p><p><em>Examples:</em></p><pre>
1&gt; <span class="input">P = {adam,24,{july,29}}.</span>
{adam,24,{july,29}}
2&gt; <span class="input">element(1,P).</span>
adam
3&gt; <span class="input">element(3,P).</span>
{july,29}
4&gt; <span class="input">P2 = setelement(2,P,25).</span>
{adam,25,{july,29}}
5&gt; <span class="input">tuple_size(P).</span>
3
6&gt; <span class="input">tuple_size({}).</span>
0</pre><h2>Map</h2><p>A map is a compound data type with a variable number of
key-value associations:</p><pre>
#{Key1=&gt;Value1,...,KeyN=&gt;ValueN}</pre><p>Each key-value association in the map is called an
<em>association pair</em>. The key and value parts of the pair are
called <em>elements</em>. The number of association pairs is said to be
the <em>size</em> of the map.</p><p>There exists a number of BIFs to manipulate maps.</p><p><em>Examples:</em></p><pre>
1&gt; <span class="input">M1 = #{name=&gt;adam,age=&gt;24,date=&gt;{july,29}}.</span>
#{age =&gt; 24,date =&gt; {july,29},name =&gt; adam}
2&gt; <span class="input">maps:get(name,M1).</span>
adam
3&gt; <span class="input">maps:get(date,M1).</span>
{july,29}
4&gt; <span class="input">M2 = maps:update(age,25,M1).</span>
#{age =&gt; 25,date =&gt; {july,29},name =&gt; adam}
5&gt; <span class="input">map_size(M).</span>
3
6&gt; <span class="input">map_size(#{}).</span>
0</pre><p>A collection of maps processing functions can be found in
<a href="./maps">stdlib/maps</a> manual page
in STDLIB.</p><p>Read more about maps in <a href="./expressions#map_expressions"> Map Expressions</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Maps are considered to be experimental during Erlang/OTP R17.</p></div><h2>List</h2><p>A list is a compound data type with a variable number of terms.</p><pre>
[Term1,...,TermN]</pre><p>Each term <strong>Term</strong> in the list is called an
<em>element</em>. The number of elements is said to be
the <em>length</em> of the list.</p><p>Formally, a list is either the empty list <strong>[]</strong> or
consists of a <em>head</em> (first element) and a <em>tail</em>
(remainder of the list).
The <em>tail</em> is also a list. The latter can
be expressed as <strong>[H|T]</strong>. The notation
<strong>[Term1,...,TermN]</strong> above is equivalent with
the list <strong>[Term1|[...|[TermN|[]]]]</strong>.</p><p><em>Example:</em></p><p><strong>[]</strong> is a list, thus      <br/>
<strong>[c|[]]</strong> is a list, thus      <br/>
<strong>[b|[c|[]]]</strong> is a list, thus      <br/>
<strong>[a|[b|[c|[]]]]</strong> is a list, or in short <strong>[a,b,c]</strong></p><p>A list where the tail is a list is sometimes called a <em>proper list</em>. It is allowed to have a list where the tail is not a
list, for example, <strong>[a|b]</strong>. However, this type of list is of
little practical use.</p><p><em>Examples:</em></p><pre>
1&gt; <span class="input">L1 = [a,2,{c,4}].</span>
[a,2,{c,4}]
2&gt; <span class="input">[H|T] = L1.</span>
[a,2,{c,4}]
3&gt; <span class="input">H.</span>
a
4&gt; <span class="input">T.</span>
[2,{c,4}]
5&gt; <span class="input">L2 = [d|T].</span>
[d,2,{c,4}]
6&gt; <span class="input">length(L1).</span>
3
7&gt; <span class="input">length([]).</span>
0</pre><p>A collection of list processing functions can be found in
the <a href="./lists">lists</a> manual
page in STDLIB.</p><h2>String</h2><p>Strings are enclosed in double quotes ("), but is not a
data type in Erlang. Instead, a string <strong>"hello"</strong> is
shorthand for the list <strong>[$h,$e,$l,$l,$o]</strong>, that is,
<strong>[104,101,108,108,111]</strong>.</p><p>Two adjacent string literals are concatenated into one. This is
done in the compilation, thus, does not incur any runtime overhead.</p><p><em>Example:</em></p><pre>
"string" "42"</pre><p>is equivalent to</p><pre>
"string42"</pre><h2>Record</h2><p>A record is a data structure for storing a fixed number of
elements. It has named fields and is similar to a struct in C.
However, a record is not a true data type. Instead, record
expressions are translated to tuple expressions during
compilation. Therefore, record expressions are not understood by
the shell unless special actions are taken. For details, see the
<a href="./shell">shell(3)</a> manual
page in STDLIB).</p><p><em>Examples:</em></p><pre>
-module(person).
-export([new/2]).

-record(person, {name, age}).

new(Name, Age) -&gt;
    #person{name=Name, age=Age}.

1&gt; <span class="input">person:new(ernie, 44).</span>
{person,ernie,44}</pre><p>Read more about records in
<a href="records">Records</a>. More examples can be
found in <a href="./records"> Programming Examples</a>.</p><h2>Boolean</h2><p>There is no Boolean data type in Erlang. Instead the atoms
<strong>true</strong> and <strong>false</strong> are used to denote Boolean values.</p><p><em>Examples:</em></p><pre>
1&gt; <span class="input">2 =&lt; 3</span>.
true
2&gt; <span class="input">true or false</span>.
true</pre><h2>Escape Sequences</h2><p>Within strings and quoted atoms, the following escape sequences
are recognized:</p><table class="table table-bordered table-hover table-striped"><caption>Recognized Escape Sequences</caption><tbody><tr><td><em>Sequence</em></td><td><em>Description</em></td></tr><tr><td>\b</td><td>Backspace</td></tr><tr><td>\d</td><td>Delete</td></tr><tr><td>\e</td><td>Escape</td></tr><tr><td>\f</td><td>Form feed</td></tr><tr><td>\n</td><td>Newline</td></tr><tr><td>\r</td><td>Carriage return</td></tr><tr><td>\s</td><td>Space</td></tr><tr><td>\t</td><td>Tab</td></tr><tr><td>\v</td><td>Vertical tab</td></tr><tr><td>\XYZ, \YZ, \Z</td><td>Character with octal representation XYZ, YZ or Z</td></tr><tr><td>\xXY</td><td>Character with hexadecimal representation XY</td></tr><tr><td>\x{X...}</td><td>Character with hexadecimal representation; X... is one or more hexadecimal characters</td></tr><tr><td>\^a...\^z        <br/> \^A...\^Z</td><td>Control A to control Z</td></tr><tr><td>\'</td><td>Single quote</td></tr><tr><td>\"</td><td>Double quote</td></tr><tr><td>\\</td><td>Backslash</td></tr></tbody></table><h2>Type Conversions</h2><p>There are a number of BIFs for type conversions.</p><p><em>Examples:</em></p><pre>
1&gt; <span class="input">atom_to_list(hello).</span>
"hello"
2&gt; <span class="input">list_to_atom("hello").</span>
hello
3&gt; <span class="input">binary_to_list(&lt;&lt;"hello"&gt;&gt;).</span>
"hello"
4&gt; <span class="input">binary_to_list(&lt;&lt;104,101,108,108,111&gt;&gt;).</span>
"hello"
5&gt; <span class="input">list_to_binary("hello").</span>
&lt;&lt;104,101,108,108,111&gt;&gt;
6&gt; <span class="input">float_to_list(7.0).</span>
"7.00000000000000000000e+00"
7&gt; <span class="input">list_to_float("7.000e+00").</span>
7.0
8&gt; <span class="input">integer_to_list(77).</span>
"77"
9&gt; <span class="input">list_to_integer("77").</span>
77
10&gt; <span class="input">tuple_to_list({a,b,c}).</span>
[a,b,c]
11&gt; <span class="input">list_to_tuple([a,b,c]).</span>
{a,b,c}
12&gt; <span class="input">term_to_binary({a,b,c}).</span>
&lt;&lt;131,104,3,100,0,1,97,100,0,1,98,100,0,1,99&gt;&gt;
13&gt; <span class="input">binary_to_term(&lt;&lt;131,104,3,100,0,1,97,100,0,1,98,100,0,1,99&gt;&gt;).</span>
{a,b,c}
14&gt; <span class="input">binary_to_integer(&lt;&lt;"77"&gt;&gt;).</span>
77
15&gt; <span class="input">integer_to_binary(77).</span>
&lt;&lt;"77"&gt;&gt;
16&gt; <span class="input">float_to_binary(7.0).</span>
&lt;&lt;"7.00000000000000000000e+00"&gt;&gt;
17&gt; <span class="input">binary_to_float(&lt;&lt;"7.000e+00"&gt;&gt;).</span>
7.0</pre></body></html>