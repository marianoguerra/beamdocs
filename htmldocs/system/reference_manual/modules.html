<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Modules</h1><h2>Module Syntax</h2><p>Erlang code is divided into <em>modules</em>. A module consists
of a sequence of attributes and function declarations, each
terminated by period (.).</p><p><em>Example:</em></p><pre>
-module(m).          % module attribute
-export([fact/1]).   % module attribute

fact(N) when N&gt;0 -&gt;  % beginning of function declaration
    N * fact(N-1);   %  |
fact(0) -&gt;           %  |
    1.               % end of function declaration</pre><p>For a description of function declarations, see
<a href="functions">Function Declaration Syntax</a>.</p><h2>Module Attributes</h2><p>A <em>module attribute</em> defines a certain property of a
module.</p><p>A module attribute consists of a tag and a value:</p><pre>
-Tag(Value).</pre><p><strong>Tag</strong> must be an atom, while <strong>Value</strong> must be a literal
term. As a convenience in user-defined attributes, if the literal term
<strong>Value</strong> has the syntax <strong>Name/Arity</strong>
(where <strong>Name</strong> is an atom and <strong>Arity</strong> a positive integer),
the term <strong>Name/Arity</strong> is translated to <strong>{Name,Arity}</strong>.</p><p>Any module attribute can be specified. The attributes are stored
in the compiled code and can be retrieved by calling
<strong>Module:module_info(attributes)</strong>, or by using the module
<a href="../stdlib/beam_lib#chunks/2">beam_lib(3)</a>
in STDLIB.</p><p>Several module attributes have predefined meanings.
Some of them have arity two, but user-defined module
attributes must have arity one.</p><h2>Pre-Defined Module Attributes</h2><p>Pre-defined module attributes is to be placed before any
function declaration.</p><dl><dt><strong>-module(Module).</strong></dt><dd> <p>Module declaration, defining the name of the module.
The name <strong>Module</strong>, an atom, is to be same as
the file name minus the extension <strong>.erl</strong>. Otherwise
<a href="./code_loading#loading">code loading</a> does
not work as intended.</p> <p>This attribute is to be specified first and is the only
mandatory attribute.</p> </dd><dt><strong>-export(Functions).</strong></dt><dd> <p>Exported functions. Specifies which of the functions,
defined within the module, that are visible from outside
the module.</p> <p><strong>Functions</strong> is a list
<strong>[Name1/Arity1, ..., NameN/ArityN]</strong>, where each
<strong>NameI</strong> is an atom and <strong>ArityI</strong> an integer.</p> </dd><dt><strong>-import(Module,Functions).</strong></dt><dd> <p>Imported functions. Can be called
the same way as local functions, that is, without any module
prefix.</p> <p><strong>Module</strong>, an atom, specifies which module to import
functions from. <strong>Functions</strong> is a list similar as for
<strong>export</strong>.</p> </dd><dt><strong>-compile(Options).</strong></dt><dd> <p>Compiler options. <strong>Options</strong> is a single option
or a list of options.
This attribute is added to the option list when
compiling the module. See the <a href="./compile"> compile(3)</a> manual page in Compiler.</p> </dd><dt><strong>-vsn(Vsn).</strong></dt><dd> <p>Module version. <strong>Vsn</strong> is any literal term and can be
retrieved using <strong>beam_lib:version/1</strong>, see the
<a href="../stdlib/beam_lib#version/1">beam_lib(3)</a>
manual page in STDLIB.</p> <p>If this attribute is not specified, the version defaults
to the MD5 checksum of the module.</p> </dd><dt><strong>-on_load(Function).</strong></dt><dd> <p>This attribute names a function that is to be run
automatically when a
module is loaded. For more information, see
<a href="./code_loading#on_load"> Running a Function When a Module is Loaded</a>.</p> </dd></dl><h2>Behaviour Module Attribute</h2><p>It is possible to specify that the module is the callback
module for a <em>behaviour</em>:</p><pre>
-behaviour(Behaviour).</pre><p>The atom <strong>Behaviour</strong> gives the name of the behaviour,
which can be a user-defined behaviour or one of the following OTP
standard behaviours:</p><ul><li><strong>gen_server</strong></li><li><strong>gen_statem</strong></li><li><strong>gen_event</strong></li><li><strong>supervisor</strong></li></ul><p>The spelling <strong>behavior</strong> is also accepted.</p><p>The callback functions of the module can be specified either
directly by the exported function <strong>behaviour_info/1</strong>:</p><pre>
behaviour_info(callbacks) -&gt; Callbacks.</pre><p>or by a <strong>-callback</strong> attribute for each callback
function:</p><pre>
-callback Name(Arguments) -&gt; Result.</pre><p>Here, <strong>Arguments</strong> is a list of zero or more arguments.
The <strong>-callback</strong> attribute is to be preferred since the
extra type information can be used by tools to produce
documentation or find discrepancies.</p><p>Read more about behaviours and callback modules in
<a href="../doc/design_principles/spec_proc#behaviours"> OTP Design Principles</a>.</p><h2>Record Definitions</h2><p>The same syntax as for module attributes is used
for record definitions:</p><pre>
-record(Record,Fields).</pre><p>Record definitions are allowed anywhere in a module,
also among the function declarations.
Read more in <a href="records">Records</a>.</p><h2>Preprocessor</h2><p>The same syntax as for module attributes is used by
the preprocessor, which supports file inclusion, macros,
and conditional compilation:</p><pre>
-include("SomeFile.hrl").
-define(Macro,Replacement).</pre><p>Read more in <a href="macros">Preprocessor</a>.</p><h2>Setting File and Line</h2><p>The same syntax as for module attributes is used for
changing the pre-defined macros <strong>?FILE</strong> and <strong>?LINE</strong>:</p><pre>
-file(File, Line).</pre><p>This attribute is used by tools, such as Yecc, to inform the
compiler that the source program is generated by another tool.
It also indicates the correspondence of source files to lines of
the original user-written file, from which the source program
is produced.</p><h2>Types and function specifications</h2><p>A similar syntax as for module attributes is used for 
specifying types and function specifications:
</p><pre>
-type my_type() :: atom() | integer().
-spec my_function(integer()) -&gt; integer().</pre><p>Read more in <a href="typespec">Types and Function specifications</a>.
</p><p>
The description is based on
<a href="http://www.erlang.org/eeps/eep-0008.html">EEP8 - Types and function specifications</a>,
which is not to be further updated.
</p><h2>Comments</h2><p>Comments can be placed anywhere in a module except within strings
and quoted atoms. A comment begins with the character "%",
continues up to, but does not include the next end-of-line, and
has no effect. Notice that the terminating end-of-line has
the effect of white space.</p><h2>module_info/0 and module_info/1 functions</h2><p>The compiler automatically inserts the two special, exported
functions into each module:</p><ul><li><strong>Module:module_info/0</strong></li><li><strong>Module:module_info/1</strong></li></ul><p>These functions can be called to retrieve information
about the module.</p><h2>module_info/0</h2><p>The <strong>module_info/0</strong> function in each module, returns
a list of <strong>{Key,Value}</strong> tuples with information about
the module. Currently, the list contain tuples with the following
<strong>Key</strong>s: <strong>module</strong>, <strong>attributes</strong>, <strong>compile</strong>,
<strong>exports</strong>, <strong>md5</strong> and <strong>native</strong>.
The order and number of tuples
may change without prior notice.</p><h2>module_info/1</h2><p>The call <strong>module_info(Key)</strong>, where <strong>Key</strong> is an atom,
returns a single piece of information about the module.</p><p>The following values are allowed for <strong>Key</strong>:</p><dl><dt><strong>module</strong></dt><dd> <p>Returns an atom representing the module name.</p> </dd><dt><strong>attributes</strong></dt><dd> <p>Returns a list of <strong>{AttributeName,ValueList}</strong> tuples,
where <strong>AttributeName</strong> is the name of an attribute,
and <strong>ValueList</strong> is a list of values. Notice that a given
attribute can occur more than once in the list with different
values if the attribute occurs more than once in the module.</p> <p>The list of attributes becomes empty if
the module is stripped with the
<a href="../stdlib/beam_lib#strip/1">beam_lib(3)</a>
module (in STDLIB).</p> </dd><dt><strong>compile</strong></dt><dd> <p>Returns a list of tuples with information about
how the module was compiled. This list is empty if
the module has been stripped with the
<a href="../stdlib/beam_lib#strip/1">beam_lib(3)</a>
module (in STDLIB).</p> </dd><dt><strong>md5</strong></dt><dd> <p>Returns a binary representing the MD5 checksum of the module.
If the module has native code loaded, this will be the MD5 of the
native code, not the BEAM bytecode.</p> </dd><dt><strong>exports</strong></dt><dd> <p>Returns a list of <strong>{Name,Arity}</strong> tuples with
all exported functions in the module.</p> </dd><dt><strong>functions</strong></dt><dd> <p>Returns a list of <strong>{Name,Arity}</strong> tuples with
all functions in the module.</p> </dd><dt><strong>nifs</strong></dt><dd> <p>Returns a list of <strong>{Name,Arity}</strong> tuples with
all NIF functions in the module.</p> </dd><dt><strong>native</strong></dt><dd> <p>Return <strong>true</strong> if the module has native compiled code.
Return <strong>false</strong> otherwise. In a system compiled without HiPE
support, the result is always <strong>false</strong></p> </dd></dl></body></html>