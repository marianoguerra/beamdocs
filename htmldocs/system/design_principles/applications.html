<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Applications</h1><a name="appl"></a><p>This section is to be read with the <strong>app(4)</strong> and
<strong>application(3)</strong> manual pages in Kernel.</p><h2>Application Concept</h2><p>When you have written code implementing some specific functionality
you might want to make the code into an <em>application</em>,
that is, a component that can be started and stopped as a unit,
and which can also be reused in other systems.</p><p>To do this, create an
<a href="#callback_module">application callback module</a>,
and describe how the application is to be started and stopped.</p><p>Then, an <em>application specification</em> is needed, which is
put in an
<a href="#appl_res_file">application resource file</a>.
Among other things, this file specifies which modules the application
consists of and the name of the callback module.</p><p>If you use <strong>systools</strong>, the Erlang/OTP tools for packaging code
(see <a href="release_structure">Releases</a>),
the code for each application is placed in a
separate directory following a pre-defined
<a href="#app_dir">directory structure</a>.</p><a name="callback_module"></a><h2>Application Callback Module</h2><p>How to start and stop the code for the application, that is,
the supervision tree, is described by two callback functions:</p><pre><code class="">
start(StartType, StartArgs) -&gt; {ok, Pid} | {ok, Pid, State}
stop(State)
    </code></pre><ul><li><strong>start</strong> is called when starting the application and is to create the supervision tree by starting the top supervisor. It is expected to return the pid of the top supervisor and an optional term, <strong>State</strong>, which defaults to <strong>[]</strong>. This term is passed as is to <strong>stop</strong>.</li><li><strong>StartType</strong> is usually the atom <strong>normal</strong>. It has other values only in the case of a takeover or failover, see <a href="distributed_applications">Distributed Applications</a>. </li><li><strong>StartArgs</strong> is defined by the key <strong>mod</strong> in the <a href="#appl_res_file">application resource file</a>.</li><li><strong>stop/1</strong> is called <em>after</em> the application has been stopped and is to do any necessary cleaning up. The actual stopping of the application, that is, the shutdown of the supervision tree, is handled automatically as described in <a href="#stopping">Starting and Stopping Applications</a>. </li></ul><a name="ch_app"></a><p>Example of an application callback module for packaging
the supervision tree from
<a href="./sup_princ#ex">Supervisor Behaviour</a>:</p><pre><code class="">
-module(ch_app).
-behaviour(application).

-export([start/2, stop/1]).

start(_Type, _Args) -&gt;
    ch_sup:start_link().

stop(_State) -&gt;
    ok.</code></pre><p>A library application that cannot be started or stopped, does not
need any application callback module.</p><a name="appl_res_file"></a><h2>Application Resource File</h2><p>To define an application, an <em>application specification</em> is
created, which is put in an <em>application resource file</em>, or in
short an <strong>.app</strong> file:</p><pre><code class="">
{application, Application, [Opt1,...,OptN]}.</code></pre><ul><li><strong>Application</strong>, an atom, is the name of the application. The file must be named <strong>Application.app</strong>.</li><li>Each <strong>Opt</strong> is a tuple <strong>{Key,Value}</strong>, which define a certain property of the application. All keys are optional. Default values are used for any omitted keys.</li></ul><p>The contents of a minimal <strong>.app</strong> file for a library
application <strong>libapp</strong> looks as follows:</p><pre><code class="">
{application, libapp, []}.</code></pre><p>The contents of a minimal <strong>.app</strong> file <strong>ch_app.app</strong> for
a supervision tree application like <strong>ch_app</strong> looks as follows:</p><pre><code class="">
{application, ch_app,
 [{mod, {ch_app,[]}}]}.</code></pre><p>The key <strong>mod</strong> defines the callback module and start argument of
the application, in this case <strong>ch_app</strong> and <strong>[]</strong>, respectively.
This means that the following is called when the application is to be
started:</p><pre><code class="">
ch_app:start(normal, [])</code></pre><p>The following is called when the application is stopped.</p><pre><code class="">
ch_app:stop([])</code></pre><p>When using <strong>systools</strong>, the Erlang/OTP tools for packaging
code (see Section
<a href="release_structure">Releases</a>), the keys
<strong>description</strong>, <strong>vsn</strong>, <strong>modules</strong>, <strong>registered</strong>,
and <strong>applications</strong> are also to be specified:</p><pre><code class="">
{application, ch_app,
 [{description, "Channel allocator"},
  {vsn, "1"},
  {modules, [ch_app, ch_sup, ch3]},
  {registered, [ch3]},
  {applications, [kernel, stdlib, sasl]},
  {mod, {ch_app,[]}}
 ]}.</code></pre><ul><li><strong>description</strong> - A short description, a string. Defaults to "".</li><li><strong>vsn</strong> - Version number, a string. Defaults to "".</li><li><strong>modules</strong> - All modules <em>introduced</em> by this application. <strong>systools</strong> uses this list when generating boot scripts and tar files. A module must be defined in only one application. Defaults to <strong>[]</strong>.</li><li><strong>registered</strong> - All names of registered processes in the application. <strong>systools</strong> uses this list to detect name clashes between applications. Defaults to <strong>[]</strong>.</li><li><strong>applications</strong> - All applications that must be started before this application is started. <strong>systools</strong> uses this list to generate correct boot scripts. Defaults to <strong>[]</strong>. Notice that all applications have dependencies to at least Kernel and STDLIB.</li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>For details about the syntax and contents of the application
resource file, see the <a href="./app">app</a>
manual page in Kernel.</p></div><a name="app_dir"></a><h2>Directory Structure</h2><p>When packaging code using <strong>systools</strong>, the code for each
application is placed in a separate directory,
<strong>lib/Application-Vsn</strong>, where <strong>Vsn</strong> is the version number.</p><p>This can be useful to know, even if <strong>systools</strong> is not used,
since Erlang/OTP is packaged according to the OTP principles
and thus comes with a specific directory structure. The code server
(see the  <a href="./code">kernel/code</a> manual
page in Kernel) automatically uses code from
the directory with the highest version number, if more than one
version of an application is present.</p><h2>Directory Structure Guidelines for a Development Environment</h2><p>Any directory structure for development will suffice as long as the released directory structure
adhere to the <a href="#app_dir_released">description below</a>,
but it is encouraged that the same directory structure
also be used in a development environment. The version number should be omitted from the
application directory name since this is an artifact of the release step.
</p><p> Some sub-directories are <em>required</em>. Some sub-directories are <em>optional</em>, meaning that it should
only be used if the application itself requires it. Finally, some sub-directories are <em>recommended</em>,
meaning it is encouraged that it is used and used as described here. For example, both documentation
and tests are encouraged to exist in an application for it to be deemed a proper OTP application.</p><pre><code class="">
    â ${application}
    Â  âââ doc
      â Â Â âââ internal
      â Â Â âââ examples
      â Â Â âââ src
    Â  âââ include
    Â  âââ priv
    Â  âââ src
      â Â  âââ ${application}.app.src
    Â  âââ test
</code></pre><ul><li><strong>src</strong> - Required. Contains the Erlang source code, the source of the <strong>.app</strong> file and internal include files used by the application itself. Additional sub-directories within <strong>src</strong> can be used as namespaces to organize source files. These directories should never be deeper than one level.</li><li><strong>priv</strong> - Optional. Used for application specific files. </li><li><strong>include</strong> - Optional. Used for public include files that must be reachable from other applications.</li><li><strong>doc</strong> - Recommended. Any source documentation should be placed in sub-directories here.</li><li><strong>doc/internal</strong> - Recommended. Any documentation that describes implementation details about this application, not intended for publication, should be placed here.</li><li><strong>doc/examples</strong> - Recommended. Source code for examples on how to use this application should be placed here. It is encouraged that examples are sourced to the public documentation from this directory.</li><li><strong>doc/src</strong> - Recommended. All source files for documentation, such as Markdown, AsciiDoc or XML-files, should be placed here.</li><li><strong>test</strong> - Recommended. All files regarding tests, such as test suites and test specifications, should be placed here. </li></ul><p>Other directories in the development environment may be needed. If source code from languages other
than Erlang is used, for instance C-code for NIFs, that code should be placed in a separate directory.
By convention it is recommended to prefix such directories with the language name, for example
<strong>c_src</strong> for C, <strong>java_src</strong> for Java or <strong>go_src</strong> for Go. Directories with <strong>_src</strong>
suffix indicates that it is a part of the application and the compilation step. The final build artifacts
should target the <strong>priv/lib</strong> or <strong>priv/bin</strong> directories.</p><p>The <strong>priv</strong> directory holds assets that the application needs during runtime. Executables should
reside in <strong>priv/bin</strong> and dynamically-linked libraries should reside in <strong>priv/lib</strong>. Other assets
are free to reside within the <strong>priv</strong> directory but it is recommended it does so in a structured manner.</p><p>Source files from other languages that generate Erlang code, such as ASN.1 or Mibs, should be placed
in directories, at the top level or in <strong>src</strong>, with the same name as the source language, for example
<strong>asn1</strong> and <strong>mibs</strong>. Build artifacts should be placed in their respective language directory,
such as <strong>src</strong> for Erlang code or <strong>java_src</strong> for Java code.</p><p>The <strong>.app</strong> file for release may reside in the <strong>ebin</strong>-directory in a development environment
but it is encouraged that this is an artifact of the build step. By convention a <strong>.app.src</strong> file
is used, which resides in the <strong>src</strong> directory. This file is nearly identical as the
<strong>.app</strong> file but certain fields may be replaced during the build step, such as the application version.</p><p>Directory names should not be capitalized.</p><p>It is encouraged to omit empty directories.</p><a name="app_dir_released"></a><h2>Directory Structure for a Released System</h2><p>A released application must follow a certain structure.
</p><pre><code class="">
    â ${application}-${version}
    Â  âââ bin
    Â  âââ doc
      â Â Â âââ html
      â Â Â âââ man[1-9]
      â Â Â âââ pdf
      â Â Â âââ internal
      â Â Â âââ examples
    Â  âââ ebin
      âÂ Â  âââ ${application}.app
    Â  âââ include
    Â  âââ priv
      â Â Â âââ lib
      â Â Â âââ bin
    Â  âââ src
</code></pre><ul><li><strong>src</strong> - Optional. Contains the Erlang source code and internal include files used by the application itself. This directory is no longer required in a released application.</li><li><strong>ebin</strong> - Required. Contains the Erlang object code, the <strong>beam</strong> files. The <strong>.app</strong> file must also be placed here.</li><li><strong>priv</strong> - Optional. Used for application specific files. <strong>code:priv_dir/1</strong> is to be used to access this directory.</li><li><strong>priv/lib</strong> - Recommended. Any shared-object files that are used by the application, such as NIFs or linked-in-drivers, should be placed here.</li><li><strong>priv/bin</strong> - Recommended. Any executable that is used by the application, such as port-programs, should be placed here.</li><li><strong>include</strong> - Optional. Used for public include files that must be reachable from other applications.</li><li><strong>bin</strong> - Optional. Any executable that is a product of the application, such as escripts or shell-scripts, should be placed here.</li><li><strong>doc</strong> - Optional. Any released documentation should be placed in sub-directories here.</li><li><strong>doc/man1</strong> - Recommended. Man pages for Application executables.</li><li><strong>doc/man3</strong> - Recommended. Man pages for module APIs.</li><li><strong>doc/man6</strong> - Recommended. Man pages for Application overview.</li><li><strong>doc/html</strong> - Optional. HTML pages for the entire Application.</li><li><strong>doc/pdf</strong> - Optional. PDF documentation for the entire Application.</li></ul><p>The <strong>src</strong> directory could be useful to release for debugging purposes but is not required.
The <strong>include</strong> directory should only be released if the applications has public include files.</p><p>The only documentation that is recommended to be released in this way are the man pages. HTML and PDF
will normally be distributed in some other manner.</p><p>It is encouraged to omit empty directories.</p><a name="application_controller"></a><h2>Application Controller</h2><p>When an Erlang runtime system is started, a number of processes
are started as part of the Kernel application. One of these
processes is the <em>application controller</em> process,
registered as <strong>application_controller</strong>.</p><p>All operations on applications are coordinated by the application
controller. It is interacted through the functions in
the module <strong>application</strong>, see the <strong>application(3)</strong>
manual page in Kernel. In particular, applications can be
loaded, unloaded, started, and stopped.</p><h2>Loading and Unloading Applications</h2><p>Before an application can be started, it must be <em>loaded</em>.
The application controller reads and stores the information from
the <strong>.app</strong> file:</p><pre>
1&gt; <span class="input">application:load(ch_app).</span>
ok
2&gt; <span class="input">application:loaded_applications().</span>
[{kernel,"ERTS  CXC 138 10","2.8.1.3"},
 {stdlib,"ERTS  CXC 138 10","1.11.4.3"},
 {ch_app,"Channel allocator","1"}]</pre><p>An application that has been stopped, or has never been started,
can be unloaded. The information about the application is
erased from the internal database of the application controller.</p><pre>
3&gt; <span class="input">application:unload(ch_app).</span>
ok
4&gt; <span class="input">application:loaded_applications().</span>
[{kernel,"ERTS  CXC 138 10","2.8.1.3"},
 {stdlib,"ERTS  CXC 138 10","1.11.4.3"}]</pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Loading/unloading an application does not load/unload the code
used by the application. Code loading is done the usual way.</p></div><a name="stopping"></a><h2>Starting and Stopping Applications</h2><p>An application is started by calling:</p><pre>
5&gt; <span class="input">application:start(ch_app).</span>
ok
6&gt; <span class="input">application:which_applications().</span>
[{kernel,"ERTS  CXC 138 10","2.8.1.3"},
 {stdlib,"ERTS  CXC 138 10","1.11.4.3"},
 {ch_app,"Channel allocator","1"}]</pre><p>If the application is not already loaded, the application
controller first loads it using <strong>application:load/1</strong>. It
checks the value of the <strong>applications</strong> key, to ensure
that all applications that are to be started before this
application are running.</p><a name="application_master"></a><p>The application controller then creates an
<em>application master</em> for the application. The application
master becomes the group leader of all the processes in the
application. I/O is forwarded to the previous group leader,
though, this is just a way to identify processes that belong to
the application. Used for example to find itself from any process,
or, reciprocally, to kill them all when it terminates.</p><p>The application master starts the application by calling
the application callback function <strong>start/2</strong> in the module,
and with the start argument, defined by the <strong>mod</strong> key in
the <strong>.app</strong> file.</p><p>An application is stopped, but not unloaded, by calling:</p><pre>
7&gt; <span class="input">application:stop(ch_app).</span>
ok</pre><p>The application master stops the application by telling the top
supervisor to shut down. The top supervisor tells all its child
processes to shut down, and so on; the entire tree is terminated in
reversed start order. The application master then calls
the application callback function <strong>stop/1</strong> in the module
defined by the <strong>mod</strong> key.</p><h2>Configuring an Application</h2><p>An application can be configured using
<em>configuration parameters</em>. These are a list of
<strong>{Par,Val}</strong> tuples
specified by a key <strong>env</strong> in the <strong>.app</strong> file:</p><pre><code class="">
{application, ch_app,
 [{description, "Channel allocator"},
  {vsn, "1"},
  {modules, [ch_app, ch_sup, ch3]},
  {registered, [ch3]},
  {applications, [kernel, stdlib, sasl]},
  {mod, {ch_app,[]}},
  {env, [{file, "/usr/local/log"}]}
 ]}.</code></pre><p><strong>Par</strong> is to be an atom. <strong>Val</strong> is any term.
The application can retrieve the value of a configuration
parameter by calling <strong>application:get_env(App, Par)</strong> or a
number of similar functions, see the <strong>application(3)</strong>
manual page in Kernel.</p><p><em>Example:</em></p><pre>
% <span class="input">erl</span>
Erlang (BEAM) emulator version 5.2.3.6 [hipe] [threads:0]

Eshell V5.2.3.6  (abort with ^G)
1&gt; <span class="input">application:start(ch_app).</span>
ok
2&gt; <span class="input">application:get_env(ch_app, file).</span>
{ok,"/usr/local/log"}</pre><p>The values in the <strong>.app</strong> file can be overridden by values
in a <em>system configuration file</em>. This is a file that
contains configuration parameters for relevant applications:</p><pre><code class="">
[{Application1, [{Par11,Val11},...]},
 ...,
 {ApplicationN, [{ParN1,ValN1},...]}].</code></pre><p>The system configuration is to be called <strong>Name.config</strong> and
Erlang is to be started with the command-line argument
<strong>-config Name</strong>. For details, see the <strong>config(4)</strong>
manual page in Kernel.</p><p><em>Example:</em></p><p>A file <strong>test.config</strong> is created with the following contents:</p><pre><code class="">
[{ch_app, [{file, "testlog"}]}].</code></pre><p>The value of <strong>file</strong> overrides the value of <strong>file</strong>
as defined in the <strong>.app</strong> file:</p><pre>
% <span class="input">erl -config test</span>
Erlang (BEAM) emulator version 5.2.3.6 [hipe] [threads:0]

Eshell V5.2.3.6  (abort with ^G)
1&gt; <span class="input">application:start(ch_app).</span>
ok
2&gt; <span class="input">application:get_env(ch_app, file).</span>
{ok,"testlog"}</pre><p>If
<a href="./release_handling#sys">release handling</a>
is used, exactly one system configuration file is to be used and
that file is to be called <strong>sys.config</strong>.</p><p>The values in the <strong>.app</strong> file and the values in a
system configuration file can be overridden directly from
the command line:</p><pre>
% <span class="input">erl -ApplName Par1 Val1 ... ParN ValN</span></pre><p><em>Example:</em></p><pre>
% <span class="input">erl -ch_app file '"testlog"'</span>
Erlang (BEAM) emulator version 5.2.3.6 [hipe] [threads:0]

Eshell V5.2.3.6  (abort with ^G)
1&gt; <span class="input">application:start(ch_app).</span>
ok
2&gt; <span class="input">application:get_env(ch_app, file).</span>
{ok,"testlog"}</pre><h2>Application Start Types</h2><p>A <em>start type</em> is defined when starting the application:</p><pre><code class="">
application:start(Application, Type)</code></pre><p><strong>application:start(Application)</strong> is the same as calling
<strong>application:start(Application, temporary)</strong>. The type can
also be <strong>permanent</strong> or <strong>transient</strong>:</p><ul><li>If a permanent application terminates, all other applications and the runtime system are also terminated.</li><li>If a transient application terminates with reason <strong>normal</strong>, this is reported but no other applications are terminated. If a transient application terminates abnormally, that is with any other reason than <strong>normal</strong>, all other applications and the runtime system are also terminated.</li><li>If a temporary application terminates, this is reported but no other applications are terminated.</li></ul><p>An application can always be stopped explicitly by
calling <strong>application:stop/1</strong>. Regardless of the mode, no
other applications are affected.</p><p>The transient mode is of little practical use, since when
a supervision tree terminates, the reason is set to
<strong>shutdown</strong>, not <strong>normal</strong>.</p></body></html>