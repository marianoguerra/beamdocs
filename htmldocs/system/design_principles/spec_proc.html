<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>sys and proc_lib</h1><a name="sys and proc_lib"></a><p>The <strong>sys</strong> module has functions for simple debugging of
processes implemented using behaviours. It also has functions that,
together with functions in the <strong>proc_lib</strong> module, can be used
to implement a <em>special process</em> that complies to the OTP
design principles without using a standard behaviour. These
functions can also be used to implement user-defined (non-standard)
behaviours.</p><p>Both <strong>sys</strong> and <strong>proc_lib</strong> belong to the STDLIB
application.</p><h2>Simple Debugging</h2><p>The <strong>sys</strong> module has functions for simple debugging of
processes implemented using behaviours. The <strong>code_lock</strong>
example from
<a href="./statem#Example">gen_statem Behaviour</a>
is used to illustrate this:</p><pre>
Erlang/OTP 20 [DEVELOPMENT] [erts-9.0] [source-5ace45e] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V9.0  (abort with ^G)
1&gt;  code_lock:start_link([1,2,3,4]).
Lock
{ok,&lt;0.63.0&gt;}
2&gt; sys:statistics(code_lock, true).
ok
3&gt;  sys:trace(code_lock, true).
ok
4&gt;  code_lock:button(1).
*DBG* code_lock receive cast {button,1} in state locked
ok
*DBG* code_lock consume cast {button,1} in state locked
5&gt;  code_lock:button(2).
*DBG* code_lock receive cast {button,2} in state locked
ok
*DBG* code_lock consume cast {button,2} in state locked
6&gt;  code_lock:button(3).
*DBG* code_lock receive cast {button,3} in state locked
ok
*DBG* code_lock consume cast {button,3} in state locked
7&gt;  code_lock:button(4).
*DBG* code_lock receive cast {button,4} in state locked
ok
Unlock
*DBG* code_lock consume cast {button,4} in state locked
*DBG* code_lock receive state_timeout lock in state open
Lock
*DBG* code_lock consume state_timeout lock in state open
8&gt; sys:statistics(code_lock, get).
{ok,[{start_time,{{2017,4,21},{16,8,7}}},
     {current_time,{{2017,4,21},{16,9,42}}},
     {reductions,2973},
     {messages_in,5},
     {messages_out,0}]}
9&gt; sys:statistics(code_lock, false).
ok
10&gt; sys:trace(code_lock, false).
ok
11&gt; sys:get_status(code_lock).
{status,&lt;0.63.0&gt;,
        {module,gen_statem},
        [[{'$initial_call',{code_lock,init,1}},
          {'$ancestors',[&lt;0.61.0&gt;]}],
         running,&lt;0.61.0&gt;,[],
         [{header,"Status for state machine code_lock"},
          {data,[{"Status",running},
                 {"Parent",&lt;0.61.0&gt;},
                 {"Logged Events",[]},
                 {"Postponed",[]}]},
          {data,[{"State",
                  {locked,#{code =&gt; [1,2,3,4],remaining =&gt; [1,2,3,4]}}}]}]]}
    </pre><h2>Special Processes</h2><p>This section describes how to write a process that complies to
the OTP design principles, without using a standard behaviour.
Such a process is to:</p><ul><li>Be started in a way that makes the process fit into a supervision tree</li><li>Support the <strong>sys</strong> <a href="#debug">debug facilities</a></li><li>Take care of <a href="#msg">system messages</a>.</li></ul><p>System messages are messages with a special meaning, used in
the supervision tree. Typical system messages are requests for
trace output, and requests to suspend or resume process execution
(used during release handling). Processes implemented using
standard behaviours automatically understand these messages.</p><h2>Example</h2><p>The simple server from
<a href="./des_princ#ch1">Overview</a>,
implemented using <strong>sys</strong> and <strong>proc_lib</strong> so it fits into a
supervision tree:</p><a name="ex"></a><pre>
-module(ch4).
-export([start_link/0]).
-export([alloc/0, free/1]).
-export([init/1]).
-export([system_continue/3, system_terminate/4,
         write_debug/3,
         system_get_state/1, system_replace_state/2]).

start_link() -&gt;
    proc_lib:start_link(ch4, init, [self()]).

alloc() -&gt;
    ch4 ! {self(), alloc},
    receive
        {ch4, Res} -&gt;
            Res
    end.

free(Ch) -&gt;
    ch4 ! {free, Ch},
    ok.

init(Parent) -&gt;
    register(ch4, self()),
    Chs = channels(),
    Deb = sys:debug_options([]),
    proc_lib:init_ack(Parent, {ok, self()}),
    loop(Chs, Parent, Deb).

loop(Chs, Parent, Deb) -&gt;
    receive
        {From, alloc} -&gt;
            Deb2 = sys:handle_debug(Deb, fun ch4:write_debug/3,
                                    ch4, {in, alloc, From}),
            {Ch, Chs2} = alloc(Chs),
            From ! {ch4, Ch},
            Deb3 = sys:handle_debug(Deb2, fun ch4:write_debug/3,
                                    ch4, {out, {ch4, Ch}, From}),
            loop(Chs2, Parent, Deb3);
        {free, Ch} -&gt;
            Deb2 = sys:handle_debug(Deb, fun ch4:write_debug/3,
                                    ch4, {in, {free, Ch}}),
            Chs2 = free(Ch, Chs),
            loop(Chs2, Parent, Deb2);

        {system, From, Request} -&gt;
            sys:handle_system_msg(Request, From, Parent,
                                  ch4, Deb, Chs)
    end.

system_continue(Parent, Deb, Chs) -&gt;
    loop(Chs, Parent, Deb).

system_terminate(Reason, _Parent, _Deb, _Chs) -&gt;
    exit(Reason).

system_get_state(Chs) -&gt;
    {ok, Chs}.

system_replace_state(StateFun, Chs) -&gt;
    NChs = StateFun(Chs),
    {ok, NChs, NChs}.

write_debug(Dev, Event, Name) -&gt;
    io:format(Dev, "~p event = ~p~n", [Name, Event]).</pre><p>Example on how the simple debugging functions in the <strong>sys</strong>
module can also be used for <strong>ch4</strong>:</p><pre>
% <span class="input">erl</span>
Erlang (BEAM) emulator version 5.2.3.6 [hipe] [threads:0]

Eshell V5.2.3.6  (abort with ^G)
1&gt; <span class="input">ch4:start_link().</span>
{ok,&lt;0.30.0&gt;}
2&gt; <span class="input">sys:statistics(ch4, true).</span>
ok
3&gt; <span class="input">sys:trace(ch4, true).</span>
ok
4&gt; <span class="input">ch4:alloc().</span>
ch4 event = {in,alloc,&lt;0.25.0&gt;}
ch4 event = {out,{ch4,ch1},&lt;0.25.0&gt;}
ch1
5&gt; <span class="input">ch4:free(ch1).</span>
ch4 event = {in,{free,ch1}}
ok
6&gt; <span class="input">sys:statistics(ch4, get).</span>
{ok,[{start_time,{{2003,6,13},{9,47,5}}},
     {current_time,{{2003,6,13},{9,47,56}}},
     {reductions,109},
     {messages_in,2},
     {messages_out,1}]}
7&gt; <span class="input">sys:statistics(ch4, false).</span>
ok
8&gt; <span class="input">sys:trace(ch4, false).</span>
ok
9&gt; <span class="input">sys:get_status(ch4).</span>
{status,&lt;0.30.0&gt;,
        {module,ch4},
        [[{'$ancestors',[&lt;0.25.0&gt;]},{'$initial_call',{ch4,init,[&lt;0.25.0&gt;]}}],
         running,&lt;0.25.0&gt;,[],
         [ch1,ch2,ch3]]}</pre><h2>Starting the Process</h2><p>A function in the <strong>proc_lib</strong> module is to be used to
start the process. Several functions are available, for
example, <strong>spawn_link/3,4</strong> for asynchronous start and
<strong>start_link/3,4,5</strong> for synchronous start.</p><p>A process started using one of these functions stores
information (for example, about the ancestors and initial call)
that is needed for a process in a supervision tree.</p><p>If the process terminates with another reason than
<strong>normal</strong> or <strong>shutdown</strong>, a crash report is generated.
For more information about the crash report, see the SASL
User's Guide.</p><p>In the example, synchronous start is used. The process
starts by calling <strong>ch4:start_link()</strong>:</p><pre><code class="">
start_link() -&gt;
    proc_lib:start_link(ch4, init, [self()]).</code></pre><p><strong>ch4:start_link</strong> calls the function
<strong>proc_lib:start_link</strong>. This function takes a module name,
a function name, and an argument list as arguments, spawns,
and links to a new process. The new process starts by executing
the given function, here <strong>ch4:init(Pid)</strong>, where
<strong>Pid</strong> is the pid (<strong>self()</strong>) of the first process,
which is the parent process.</p><p>All initialization, including name registration, is done in
<strong>init</strong>. The new process must also acknowledge that it has
been started to the parent:</p><pre><code class="">
init(Parent) -&gt;
    ...
    proc_lib:init_ack(Parent, {ok, self()}),
    loop(...).</code></pre><p><strong>proc_lib:start_link</strong> is synchronous and does not return
until <strong>proc_lib:init_ack</strong> has been called.</p><a name="debug"></a><h2>Debugging</h2><p>To support the debug facilites in <strong>sys</strong>, a
<em>debug structure</em> is needed. The <strong>Deb</strong> term is
initialized using <strong>sys:debug_options/1</strong>:</p><pre><code class="">
init(Parent) -&gt;
    ...
    Deb = sys:debug_options([]),
    ...
    loop(Chs, Parent, Deb).</code></pre><p><strong>sys:debug_options/1</strong> takes a list of options as argument.
Here the list is empty, which means no debugging is enabled
initially. For information about the possible options, see the
<strong>sys(3)</strong> manual page in STDLIB.</p><p>Then, for each <em>system event</em> to be logged
or traced, the following function is to be called.</p><pre><code class="">
sys:handle_debug(Deb, Func, Info, Event) =&gt; Deb1</code></pre><p>Here:</p><ul><li><strong>Deb</strong> is the debug structure.</li><li><strong>Func</strong> is a fun specifying a (user-defined) function used to format trace output. For each system event, the format function is called as <strong>Func(Dev, Event, Info)</strong>, where: <ul><li><strong>Dev</strong> is the I/O device to which the output is to be printed. See the <strong>io(3)</strong> manual page in STDLIB.</li><li><strong>Event</strong> and <strong>Info</strong> are passed as is from <strong>handle_debug</strong>.</li></ul> </li><li><strong>Info</strong> is used to pass more information to <strong>Func</strong>. It can be any term and is passed as is.</li><li><strong>Event</strong> is the system event. It is up to the user to define what a system event is and how it is to be represented. Typically at least incoming and outgoing messages are considered system events and represented by the tuples <strong>{in,Msg[,From]}</strong> and <strong>{out,Msg,To[,State]}</strong>, respectively.</li></ul><p><strong>handle_debug</strong> returns an updated debug structure
<strong>Deb1</strong>.</p><p>In the example, <strong>handle_debug</strong> is called for each incoming
and outgoing message. The format function <strong>Func</strong> is
the function <strong>ch4:write_debug/3</strong>, which prints the message
using <strong>io:format/3</strong>.</p><pre><code class="">
loop(Chs, Parent, Deb) -&gt;
    receive
        {From, alloc} -&gt;
            Deb2 = sys:handle_debug(Deb, fun ch4:write_debug/3,
                                    ch4, {in, alloc, From}),
            {Ch, Chs2} = alloc(Chs),
            From ! {ch4, Ch},
            Deb3 = sys:handle_debug(Deb2, fun ch4:write_debug/3,
                                    ch4, {out, {ch4, Ch}, From}),
            loop(Chs2, Parent, Deb3);
        {free, Ch} -&gt;
            Deb2 = sys:handle_debug(Deb, fun ch4:write_debug/3,
                                    ch4, {in, {free, Ch}}),
            Chs2 = free(Ch, Chs),
            loop(Chs2, Parent, Deb2);
        ...
    end.

write_debug(Dev, Event, Name) -&gt;
    io:format(Dev, "~p event = ~p~n", [Name, Event]).</code></pre><a name="msg"></a><h2>Handling System Messages</h2><p><em>System messages</em> are received as:</p><pre><code class="">
{system, From, Request}</code></pre><p>The content and meaning of these messages do not need to be
interpreted by the process. Instead the following function
is to be called:</p><pre><code class="">
sys:handle_system_msg(Request, From, Parent, Module, Deb, State)</code></pre><p>This function does not return. It handles the system
message and then either calls the following if process execution is
to continue:</p><pre><code class="">
Module:system_continue(Parent, Deb, State)</code></pre><p>Or calls the following if the process is to terminate:</p><pre><code class="">
Module:system_terminate(Reason, Parent, Deb, State)</code></pre><p>A process in a supervision tree is expected to terminate with
the same reason as its parent.</p><ul><li><strong>Request</strong> and <strong>From</strong> are to be passed as is from the system message to the call to <strong>handle_system_msg</strong>.</li><li><strong>Parent</strong> is the pid of the parent.</li><li><strong>Module</strong> is the name of the module.</li><li><strong>Deb</strong> is the debug structure.</li><li><strong>State</strong> is a term describing the internal state and is passed to <strong>system_continue</strong>/<strong>system_terminate</strong>/ <strong>system_get_state</strong>/<strong>system_replace_state</strong>.</li></ul><p>If the process is to return its state, <strong>handle_system_msg</strong>
calls:</p><pre><code class="">
Module:system_get_state(State)</code></pre><p>If the process is to replace its state using the fun <strong>StateFun</strong>,
<strong>handle_system_msg</strong> calls:</p><pre><code class="">
Module:system_replace_state(StateFun, State)</code></pre><p>In the example:</p><pre><code class="">
loop(Chs, Parent, Deb) -&gt;
    receive
        ...

        {system, From, Request} -&gt;
            sys:handle_system_msg(Request, From, Parent,
                                  ch4, Deb, Chs)
    end.

system_continue(Parent, Deb, Chs) -&gt;
    loop(Chs, Parent, Deb).

system_terminate(Reason, Parent, Deb, Chs) -&gt;
    exit(Reason).

system_get_state(Chs) -&gt;
    {ok, Chs, Chs}.

system_replace_state(StateFun, Chs) -&gt;
    NChs = StateFun(Chs),
    {ok, NChs, NChs}.
</code></pre><p>If the special process is set to trap exits and if the parent
process terminates, the expected behavior is to terminate with
the same reason:</p><pre><code class="">
init(...) -&gt;
    ...,
    process_flag(trap_exit, true),
    ...,
    loop(...).

loop(...) -&gt;
    receive
        ...

        {'EXIT', Parent, Reason} -&gt;
            ..maybe some cleaning up here..
            exit(Reason);
        ...
    end.</code></pre><h2>User-Defined Behaviours</h2><p><a name="behaviours"></a>To implement a user-defined behaviour,
write code similar to
code for a special process, but call functions in a callback
module for handling specific tasks.</p><p>If the compiler is to warn for missing callback functions, as it
does for the OTP behaviours, add <strong>-callback</strong> attributes in the
behaviour module to describe the expected callbacks:</p><pre><code class="">
-callback Name1(Arg1_1, Arg1_2, ..., Arg1_N1) -&gt; Res1.
-callback Name2(Arg2_1, Arg2_2, ..., Arg2_N2) -&gt; Res2.
...
-callback NameM(ArgM_1, ArgM_2, ..., ArgM_NM) -&gt; ResM.</code></pre><p><strong>NameX</strong> are the names of the expected callbacks.
<strong>ArgX_Y</strong> and <strong>ResX</strong> are types as they are described in
<a href="../reference_manual/typespec">Types and Function Specifications</a>. The whole syntax of the <strong>-spec</strong>
attribute is supported by the <strong>-callback</strong> attribute.</p><p>Callback functions that are optional for the user of the
behaviour to implement are specified by use of the
<strong>-optional_callbacks</strong> attribute:</p><pre><code class="">
-optional_callbacks([OptName1/OptArity1, ..., OptNameK/OptArityK]).</code></pre><p>where each <strong>OptName/OptArity</strong> specifies the name and arity
of a callback function. Note that the <strong>-optional_callbacks</strong>
attribute is to be used together with the <strong>-callback</strong>
attribute; it cannot be combined with the
<strong>behaviour_info()</strong> function described below.</p><p>Tools that need to know about optional callback functions can
call <strong>Behaviour:behaviour_info(optional_callbacks)</strong> to get
a list of all optional callback functions.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>We recommend using the <strong>-callback</strong> attribute rather
than the <strong>behaviour_info()</strong> function. The reason is that
the extra type information can be used by tools to produce
documentation or find discrepancies.</p></div><p>As an alternative to the <strong>-callback</strong> and
<strong>-optional_callbacks</strong> attributes you may directly implement
and export <strong>behaviour_info()</strong>:</p><pre><code class="">
behaviour_info(callbacks) -&gt;
    [{Name1, Arity1},...,{NameN, ArityN}].</code></pre><p>where each <strong>{Name, Arity}</strong> specifies the name and arity of
a callback function. This function is otherwise automatically
generated by the compiler using the <strong>-callback</strong>
attributes.</p><p>When the compiler encounters the module attribute
<strong>-behaviour(Behaviour).</strong> in a module <strong>Mod</strong>, it
calls <strong>Behaviour:behaviour_info(callbacks)</strong> and compares the
result with the set of functions actually exported from
<strong>Mod</strong>, and issues a warning if any callback function is
missing.</p><p>Example:</p><pre><code class="">
%% User-defined behaviour module
-module(simple_server).
-export([start_link/2, init/3, ...]).

-callback init(State :: term()) -&gt; 'ok'.
-callback handle_req(Req :: term(), State :: term()) -&gt; {'ok', Reply :: term()}.
-callback terminate() -&gt; 'ok'.
-callback format_state(State :: term()) -&gt; term().

-optional_callbacks([format_state/1]).

%% Alternatively you may define:
%%
%% -export([behaviour_info/1]).
%% behaviour_info(callbacks) -&gt;
%%     [{init,1},
%%      {handle_req,2},
%%      {terminate,0}].

start_link(Name, Module) -&gt;
    proc_lib:start_link(?MODULE, init, [self(), Name, Module]).

init(Parent, Name, Module) -&gt;
    register(Name, self()),
    ...,
    Dbg = sys:debug_options([]),
    proc_lib:init_ack(Parent, {ok, self()}),
    loop(Parent, Module, Deb, ...).

...</code></pre><p>In a callback module:</p><pre><code class="">
-module(db).
-behaviour(simple_server).

-export([init/1, handle_req/2, terminate/0]).

...</code></pre><p>The contracts specified with <strong>-callback</strong> attributes in
behaviour modules can be further refined by adding <strong>-spec</strong>
attributes in callback modules. This can be useful as
<strong>-callback</strong> contracts are usually generic. The same callback
module with contracts for the callbacks:</p><pre><code class="">
-module(db).
-behaviour(simple_server).

-export([init/1, handle_req/2, terminate/0]).

-record(state, {field1 :: [atom()], field2 :: integer()}).

-type state()   :: #state{}.
-type request() :: {'store', term(), term()};
                   {'lookup', term()}.

...

-spec handle_req(request(), state()) -&gt; {'ok', term()}.

...</code></pre><p>Each <strong>-spec</strong> contract is to be a subtype of the respective
<strong>-callback</strong> contract.</p></body></html>