<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>OTP Design Principles</h1><h1>OTP Design Principles</h1><a name="otp design principles"></a><p>The <em>OTP design principles</em> define how to
structure Erlang code in terms of processes, modules,
and directories.</p><h4>Supervision Trees</h4><p>A basic concept in Erlang/OTP is the <em>supervision tree</em>.
This is a process structuring model based on the idea of
<em>workers</em> and <em>supervisors</em>:</p><ul><li>Workers are processes that perform computations, that is, they do the actual work.</li><li>Supervisors are processes that monitor the behaviour of workers. A supervisor can restart a worker if something goes wrong.</li><li>The supervision tree is a hierarchical arrangement of code into supervisors and workers, which makes it possible to design and program fault-tolerant software.</li></ul><p>In the following figure, square boxes represents supervisors and
circles represent workers:</p><a name="sup6"></a><img src="../design_principles/sup6.gif" title="Supervision Tree"></img><h4>Behaviours</h4><p>In a supervision tree, many of the processes have similar
structures, they follow similar patterns. For example,
the supervisors are similar in structure. The only difference
between them is which child processes they supervise. Many
of the workers are servers in a server-client relation,
finite-state machines, or event handlers.</p><p><em>Behaviours</em> are formalizations of these common patterns.
The idea is to divide the code for a process in a generic part
(a behaviour module) and a specific part (a
<em>callback module</em>).</p><p>The behaviour module is part of Erlang/OTP. To implement a
process such as a supervisor, the user only has to implement
the callback module which is to export a pre-defined set of
functions, the <em>callback functions</em>.</p><p>The following example illustrate how code can be divided into a
generic and a specific part. Consider the following code (written in
plain Erlang) for a simple server, which keeps track of a number
of "channels". Other processes can allocate and free the channels
by calling the functions <strong>alloc/0</strong> and <strong>free/1</strong>,
respectively.</p><a name="ch1"></a><pre><code class="">
-module(ch1).
-export([start/0]).
-export([alloc/0, free/1]).
-export([init/0]).

start() -&gt;
    spawn(ch1, init, []).

alloc() -&gt;
    ch1 ! {self(), alloc},
    receive
        {ch1, Res} -&gt;
            Res
    end.

free(Ch) -&gt;
    ch1 ! {free, Ch},
    ok.

init() -&gt;
    register(ch1, self()),
    Chs = channels(),
    loop(Chs).

loop(Chs) -&gt;
    receive
        {From, alloc} -&gt;
            {Ch, Chs2} = alloc(Chs),
            From ! {ch1, Ch},
            loop(Chs2);
        {free, Ch} -&gt;
            Chs2 = free(Ch, Chs),
            loop(Chs2)
    end.</code></pre><p>The code for the server can be rewritten into a generic part
<strong>server.erl</strong>:</p><pre><code class="">
-module(server).
-export([start/1]).
-export([call/2, cast/2]).
-export([init/1]).

start(Mod) -&gt;
    spawn(server, init, [Mod]).

call(Name, Req) -&gt;
    Name ! {call, self(), Req},
    receive
        {Name, Res} -&gt;
            Res
    end.

cast(Name, Req) -&gt;
    Name ! {cast, Req},
    ok.

init(Mod) -&gt;
    register(Mod, self()),
    State = Mod:init(),
    loop(Mod, State).

loop(Mod, State) -&gt;
    receive
        {call, From, Req} -&gt;
            {Res, State2} = Mod:handle_call(Req, State),
            From ! {Mod, Res},
            loop(Mod, State2);
        {cast, Req} -&gt;
            State2 = Mod:handle_cast(Req, State),
            loop(Mod, State2)
    end.</code></pre><p>And a callback module <strong>ch2.erl</strong>:</p><pre><code class="">
-module(ch2).
-export([start/0]).
-export([alloc/0, free/1]).
-export([init/0, handle_call/2, handle_cast/2]).

start() -&gt;
    server:start(ch2).

alloc() -&gt;
    server:call(ch2, alloc).

free(Ch) -&gt;
    server:cast(ch2, {free, Ch}).

init() -&gt;
    channels().

handle_call(alloc, Chs) -&gt;
    alloc(Chs). % =&gt; {Ch,Chs2}

handle_cast({free, Ch}, Chs) -&gt;
    free(Ch, Chs). % =&gt; Chs2</code></pre><p>Notice the following:</p><ul><li>The code in <strong>server</strong> can be reused to build many different servers.</li><li>The server name, in this example the atom <strong>ch2</strong>, is hidden from the users of the client functions. This means that the name can be changed without affecting them.</li><li>The protocol (messages sent to and received from the server) is also hidden. This is good programming practice and allows one to change the protocol without changing the code using the interface functions.</li><li>The functionality of <strong>server</strong> can be extended without having to change <strong>ch2</strong> or any other callback module.</li></ul><p>In <strong>ch1.erl</strong> and <strong>ch2.erl</strong> above, the implementation
of <strong>channels/0</strong>, <strong>alloc/1</strong>, and <strong>free/2</strong> has been
intentionally left out, as it is not relevant to the example.
For completeness, one way to write these functions are given
below. This is an example only, a realistic
implementation must be able to handle situations like running out
of channels to allocate, and so on.</p><pre><code class="">
channels() -&gt;
   {_Allocated = [], _Free = lists:seq(1,100)}.

alloc({Allocated, [H|T] = _Free}) -&gt;
   {H, {[H|Allocated], T}}.

free(Ch, {Alloc, Free} = Channels) -&gt;
   case lists:member(Ch, Alloc) of
      true -&gt;
         {lists:delete(Ch, Alloc), [Ch|Free]};
      false -&gt;
         Channels
   end.        </code></pre><p>Code written without using behaviours can be more
efficient, but the increased efficiency is at the expense of
generality. The ability to manage all applications in the system
in a consistent manner is important.</p><p>Using behaviours also makes it easier to read and understand
code written by other programmers. Improvised programming structures,
while possibly more efficient, are always more difficult to
understand.</p><p>The <strong>server</strong> module corresponds, greatly simplified,
to the Erlang/OTP behaviour <strong>gen_server</strong>.</p><p>The standard Erlang/OTP behaviours are:</p><ul><li><p><a href="gen_server_concepts">gen_server</a></p> <p>For implementing the server of a client-server relation</p></li><li><p><a href="statem">gen_statem</a></p> <p>For implementing state machines</p></li><li><p><a href="events">gen_event</a></p> <p>For implementing event handling functionality</p></li><li><p><a href="sup_princ">supervisor</a></p> <p>For implementing a supervisor in a supervision tree</p></li></ul><p>The compiler understands the module attribute
<strong>-behaviour(Behaviour)</strong> and issues warnings about
missing callback functions, for example:</p><pre><code class="">
-module(chs3).
-behaviour(gen_server).
...

3&gt; c(chs3).
./chs3.erl:10: Warning: undefined call-back function handle_call/3
{ok,chs3}</code></pre><h4>Applications</h4><p>Erlang/OTP comes with a number of components, each implementing
some specific functionality. Components are with Erlang/OTP
terminology called <em>applications</em>. Examples of Erlang/OTP
applications are Mnesia, which has everything needed for
programming database services, and Debugger, which is used
to debug Erlang programs. The minimal system based on Erlang/OTP
consists of the following two applications:</p><ul><li>Kernel - Functionality necessary to run Erlang</li><li>STDLIB - Erlang standard libraries</li></ul><p>The application concept applies both to program structure
(processes) and directory structure (modules).</p><p>The simplest applications do not have any processes,
but consist of a collection of functional modules. Such an
application is called a <em>library application</em>. An example
of a library application is STDLIB.</p><p>An application with processes is easiest implemented as a
supervision tree using the standard behaviours.</p><p>How to program applications is described in
<a href="applications">Applications</a>.</p><h4>Releases</h4><p>A <em>release</em> is a complete system made out from a subset of
Erlang/OTP applications and a set of user-specific applications.</p><p>How to program releases is described in
<a href="release_structure">Releases</a>.</p><p>How to install a release in a target environment is described
in the section about target systems in Section 2 System Principles.</p><h4>Release Handling</h4><p><em>Release handling</em> is upgrading and downgrading between
different versions of a release, in a (possibly) running system.
How to do this is described in
<a href="release_handling">Release Handling</a>.</p><a name="gen_server"></a><p>This section is to be read with the
<a href="./gen_server">gen_server(3)</a>
manual page in <strong>stdlib</strong>, where all interface functions and
callback functions are described in detail.</p><h4>Client-Server Principles</h4><p>The client-server model is characterized by a central server
and an arbitrary number of clients. The client-server model is
used for resource management operations, where several
different clients want to share a common resource. The server is
responsible for managing this resource.</p><a name="clientserver"></a><img src="../design_principles/clientserver.gif" title="Client-Server Model"></img><h4>Example</h4><p>An example of a simple server written in plain Erlang is
provided in
<a href="./des_princ#ch1">Overview</a>.
The server can be reimplemented using <strong>gen_server</strong>,
resulting in this callback module:</p><a name="ex"></a><pre><code class="">
-module(ch3).
-behaviour(gen_server).

-export([start_link/0]).
-export([alloc/0, free/1]).
-export([init/1, handle_call/3, handle_cast/2]).

start_link() -&gt;
    gen_server:start_link({local, ch3}, ch3, [], []).

alloc() -&gt;
    gen_server:call(ch3, alloc).

free(Ch) -&gt;
    gen_server:cast(ch3, {free, Ch}).

init(_Args) -&gt;
    {ok, channels()}.

handle_call(alloc, _From, Chs) -&gt;
    {Ch, Chs2} = alloc(Chs),
    {reply, Ch, Chs2}.

handle_cast({free, Ch}, Chs) -&gt;
    Chs2 = free(Ch, Chs),
    {noreply, Chs2}.</code></pre><p>The code is explained in the next sections.</p><h4>Starting a Gen_Server</h4><p>In the example in the previous section, <strong>gen_server</strong> is
started by calling <strong>ch3:start_link()</strong>:</p><pre><code class="">
start_link() -&gt;
    gen_server:start_link({local, ch3}, ch3, [], []) =&gt; {ok, Pid}</code></pre><p><strong>start_link</strong> calls function <strong>gen_server:start_link/4</strong>.
This function spawns and links to a new process, a
<strong>gen_server</strong>.</p><ul><li> <p>The first argument, <strong>{local, ch3}</strong>, specifies the name.
The gen_server is then locally registered as <strong>ch3</strong>.</p> <p>If the name is omitted, the <strong>gen_server</strong> is not registered.
Instead its pid must be used. The name can also be given
as <strong>{global, Name}</strong>, in which case the <strong>gen_server</strong> is
registered using <strong>global:register_name/2</strong>.</p> </li><li> <p>The second argument, <strong>ch3</strong>, is the name of the callback
module, that is, the module where the callback functions are
located.</p> <p>The interface functions (<strong>start_link</strong>, <strong>alloc</strong>,
and <strong>free</strong>) are then located in the same module
as the callback functions (<strong>init</strong>, <strong>handle_call</strong>, and
<strong>handle_cast</strong>). This is normally good programming
practice, to have the code corresponding to one process
contained in one module.</p> </li><li> <p>The third argument, <strong>[]</strong>, is a term that is passed as is
to the callback function <strong>init</strong>. Here, <strong>init</strong> does not
need any indata and ignores the argument.</p> </li><li> <p>The fourth argument, <strong>[]</strong>, is a list of options. See the
<strong>gen_server(3)</strong> manual page for available options.</p> </li></ul><p>If name registration succeeds, the new <strong>gen_server</strong> process
calls the callback function <strong>ch3:init([])</strong>. <strong>init</strong> is
expected to return <strong>{ok, State}</strong>, where <strong>State</strong> is the
internal state of the <strong>gen_server</strong>. In this case, the state
is the available channels.</p><pre><code class="">
init(_Args) -&gt;
    {ok, channels()}.</code></pre><p><strong>gen_server:start_link</strong> is synchronous. It does not return
until the <strong>gen_server</strong> has been initialized and is ready
to receive requests.</p><p><strong>gen_server:start_link</strong> must be used if the <strong>gen_server</strong>
is part of a supervision tree, that is, started by a supervisor.
There is another function, <strong>gen_server:start</strong>, to start a
standalone <strong>gen_server</strong>, that is, a <strong>gen_server</strong> that
is not part of a supervision tree.</p><h4>Synchronous Requests - Call</h4><p>The synchronous request <strong>alloc()</strong> is implemented using
<strong>gen_server:call/2</strong>:</p><pre><code class="">
alloc() -&gt;
    gen_server:call(ch3, alloc).</code></pre><p><strong>ch3</strong> is the name of the <strong>gen_server</strong> and must agree
with the name used to start it. <strong>alloc</strong> is the actual
request.</p><p>The request is made into a message and sent to the
<strong>gen_server</strong>. When the request is received, the
<strong>gen_server</strong> calls
<strong>handle_call(Request, From, State)</strong>, which is expected to
return a tuple <strong>{reply,Reply,State1}</strong>. <strong>Reply</strong> is
the reply that is to be sent back to the client, and
<strong>State1</strong> is a new value for the state of the
<strong>gen_server</strong>.</p><pre><code class="">
handle_call(alloc, _From, Chs) -&gt;
    {Ch, Chs2} = alloc(Chs),
    {reply, Ch, Chs2}.</code></pre><p>In this case, the reply is the allocated channel <strong>Ch</strong> and
the new state is the set of remaining available channels
<strong>Chs2</strong>.</p><p>Thus, the call <strong>ch3:alloc()</strong> returns the allocated channel
<strong>Ch</strong> and the <strong>gen_server</strong> then waits for new requests,
now with an updated list of available channels.</p><h4>Asynchronous Requests - Cast</h4><p>The asynchronous request <strong>free(Ch)</strong> is implemented using
<strong>gen_server:cast/2</strong>:</p><pre><code class="">
free(Ch) -&gt;
    gen_server:cast(ch3, {free, Ch}).</code></pre><p><strong>ch3</strong> is the name of the <strong>gen_server</strong>.
<strong>{free, Ch}</strong> is the actual request.</p><p>The request is made into a message and sent to the
<strong>gen_server</strong>.
<strong>cast</strong>, and thus <strong>free</strong>, then returns <strong>ok</strong>.</p><p>When the request is received, the <strong>gen_server</strong> calls
<strong>handle_cast(Request, State)</strong>, which is expected to
return a tuple <strong>{noreply,State1}</strong>. <strong>State1</strong> is a new
value for the state of the <strong>gen_server</strong>.</p><pre><code class="">
handle_cast({free, Ch}, Chs) -&gt;
    Chs2 = free(Ch, Chs),
    {noreply, Chs2}.</code></pre><p>In this case, the new state is the updated list of available
channels <strong>Chs2</strong>. The <strong>gen_server</strong> is now ready for new
requests.</p><h4>Stopping</h4><h4>In a Supervision Tree</h4><p>If the <strong>gen_server</strong> is part of a supervision tree, no stop
function is needed. The <strong>gen_server</strong> is automatically
terminated by its supervisor. Exactly how this is done is
defined by a
<a href="./sup_princ#shutdown">shutdown strategy</a>
set in the supervisor.</p><p>If it is necessary to clean up before termination, the shutdown
strategy must be a time-out value and the <strong>gen_server</strong> must
be set to trap exit signals in function <strong>init</strong>. When ordered
to shutdown, the <strong>gen_server</strong> then calls the callback
function <strong>terminate(shutdown, State)</strong>:</p><pre><code class="">
init(Args) -&gt;
    ...,
    process_flag(trap_exit, true),
    ...,
    {ok, State}.

...

terminate(shutdown, State) -&gt;
    ..code for cleaning up here..
    ok.</code></pre><h4>Standalone Gen_Servers</h4><p>If the <strong>gen_server</strong> is not part of a supervision tree, a
stop function can be useful, for example:</p><pre><code class="">
...
export([stop/0]).
...

stop() -&gt;
    gen_server:cast(ch3, stop).
...

handle_cast(stop, State) -&gt;
    {stop, normal, State};
handle_cast({free, Ch}, State) -&gt;
    ....

...

terminate(normal, State) -&gt;
    ok.</code></pre><p>The callback function handling the <strong>stop</strong> request returns
a tuple <strong>{stop,normal,State1}</strong>, where <strong>normal</strong>
specifies that it is a normal termination and <strong>State1</strong> is
a new value for the state of the <strong>gen_server</strong>. This causes
the <strong>gen_server</strong> to call <strong>terminate(normal, State1)</strong>
and then it terminates gracefully.</p><h4>Handling Other Messages</h4><p>If the <strong>gen_server</strong> is to be able to receive other messages
than requests, the callback function <strong>handle_info(Info, State)</strong>
must be implemented to handle them. Examples of other messages
are exit messages, if the <strong>gen_server</strong> is linked to other
processes (than the supervisor) and trapping exit signals.</p><pre><code class="">
handle_info({'EXIT', Pid, Reason}, State) -&gt;
    ..code to handle exits here..
    {noreply, State1}.</code></pre><p>The <strong>code_change</strong> method must also be implemented.</p><pre><code class="">
code_change(OldVsn, State, Extra) -&gt;
    ..code to convert state (and more) during code change
    {ok, NewState}.</code></pre><a name="gen_statem Behaviour"></a><p>
This section is to be read with the
<a href="./gen_statem">stdlib/gen_statem</a>
manual page in STDLIB, where all interface functions and callback
functions are described in detail.
</p><a name="Event-Driven State Machines"></a><h4>Event-Driven State Machines</h4><p>
Established Automata Theory does not deal much with
how a <em>state transition</em> is triggered,
but assumes that the output is a function
of the input (and the state) and that they are
some kind of values.
</p><p>
For an Event-Driven State Machine, the input is an event
that triggers a <em>state transition</em> and the output
is actions executed during the <em>state transition</em>.
It can analogously to the mathematical model of a
Finite State Machine be described as
a set of relations of the following form:
</p><pre>
State(S) x Event(E) -&gt; Actions(A), State(S')</pre><p>
These relations are interpreted as follows:
if we are in state <strong>S</strong> and event <strong>E</strong> occurs, we
are to perform actions <strong>A</strong> and make a transition to
state <strong>S'</strong>. Notice that <strong>S'</strong> can be equal to <strong>S</strong>
and that <strong>A</strong> can be empty.
</p><p>
In <strong>gen_statem</strong> we define
a <em>state change</em> as a <em>state transition</em>
in which the new state <strong>S'</strong> is different from
the current state <strong>S</strong>, where "different" means
Erlang's strict inequality: <strong>=/=</strong>
also know as "does not match".
During a <em>state changes</em>,
<strong>gen_statem</strong> does more things
than during other <em>state transitions</em>.
</p><p>
As <strong>A</strong> and <strong>S'</strong> depend only on
<strong>S</strong> and <strong>E</strong>, the kind of state machine described
here is a Mealy machine
(see, for example, the Wikipedia article "Mealy machine").
</p><p>
Like most <strong>gen_</strong> behaviors, <strong>gen_statem</strong> keeps
a server <strong>Data</strong> besides the state. Because of this, and as
there is no restriction on the number of states
(assuming that there is enough virtual machine memory)
or on the number of distinct input events,
a state machine implemented with this behavior
is in fact Turing complete.
But it feels mostly like an Event-Driven Mealy machine.
</p><a name="When to use gen_statem"></a><h4>When to use gen_statem</h4><p>
If your process logic is convenient to describe as a state machine,
and you want any of these <strong>gen_statem</strong> key features:
</p><ul><li> Co-located callback code for each state, for all <a href="#Event Types">Event Types</a> (such as <em>call</em>, <em>cast</em> and <em>info</em>) </li><li> <a href="#Postponing Events"> Postponing Events </a> (a substitute for selective receive) </li><li> <a href="#Inserted Events"> Inserted Events </a> that is: events from the state machine to itself (in particular purely internal events) </li><li> <a href="#State Enter Calls">State Enter Calls</a> (callback on state entry co-located with the rest of each state's callback code) </li><li> Easy-to-use time-outs (<a href="#State Time-Outs">State Time-Outs</a>, <a href="#Event Time-Outs">Event Time-Outs</a> and <a href="#Generic Time-Outs">Generic Time-outs</a> (named time-outs)) </li></ul><p>
If so, or if possibly needed in future versions,
then you should consider using <strong>gen_statem</strong> over
<a href="./gen_server">stdlib/gen_server</a>.
</p><p>
For simple state machines not needing these features
<a href="./gen_server">stdlib/gen_server</a>
works just fine.
It also has got smaller call overhead,
but we are talking about something like 2 vs 3.3 microseconds
call roundtrip time here, so if the server callback
does just a little bit more than just replying,
or if the call is not extremely frequent,
that difference will be hard to notice.
</p><a name="Callback Module"></a><h4>Callback Module</h4><p>
The <em>callback module</em> contains functions that implement
the state machine.
When an event occurs,
the <strong>gen_statem</strong> behaviour engine
calls a function in the <em>callback module</em> with the event,
current state and server data.
This function performs the actions for this event,
and returns the new state and server data
and also actions to be performed by the behaviour engine.
</p><p>
The behaviour engine holds the state machine state,
server data, timer references, a queue of posponed messages
and other metadata.  It receives all process messages,
handles the system messages, and calls the <em>callback module</em>
with machine specific events.
</p><a name="Callback Modes"></a><h4>Callback Modes</h4><p>
The <strong>gen_statem</strong> behavior supports two <em>callback modes</em>:
</p><dl><dt> <a href="../stdlib/gen_statem#type-callback_mode">stdlib/gen_statem#type-callback_mode</a> </dt><dd> <p>
Events are handled by one callback function per state.
</p> </dd><dt> <a href="../stdlib/gen_statem#type-callback_mode">stdlib/gen_statem#type-callback_mode</a> </dt><dd> <p>
Events are handled by one single callback function.
</p> </dd></dl><p>
The <em>callback mode</em> is selected at server start
and may be changed with a code upgrade/downgrade.
</p><p>
See the section
<a href="#State Callback">State Callback</a>
that describes the event handling callback function(s).
</p><p>
The <em>callback mode</em> is selected by implementing
a mandatory callback function
<a href="../stdlib/gen_statem#Module:callback_mode/0">stdlib/gen_statem#Module:callback_mode/0</a>
that returns one of the <em>callback modes</em>.
</p><p>
The
<a href="../stdlib/gen_statem#Module:callback_mode/0">stdlib/gen_statem#Module:callback_mode/0</a>
function may also return a list containing the <em>callback mode</em>
and the atom <strong>state_enter</strong> in which case
<a href="#State Enter Calls">State Enter Calls</a>
are activated for the <em>callback mode</em>.
</p><a name="Choosing the Callback Mode"></a><h4>Choosing the Callback Mode</h4><p>
The short version: choose <strong>state_functions</strong> -
it is the one most like <strong>gen_fsm</strong>.
But if you do not want the restriction that the state
must be an atom, or if you do not want to write
one <em>state callback</em> function per state; please read on...
</p><p>
The two
<a href="#Callback Modes">Callback Modes</a>
give different possibilities and restrictions,
with one common goal:
to handle all possible combinations of events and states.
</p><p>
This can be done, for example, by focusing on one state at the time
and for every state ensure that all events are handled.
Alternatively, you can focus on one event at the time
and ensure that it is handled in every state.
You can also use a mix of these strategies.
</p><p>
With <strong>state_functions</strong>, you are restricted to use
atom-only states, and the <strong>gen_statem</strong> engine
branches depending on state name for you.
This encourages the <em>callback module</em> to co-locate
the implementation of all event actions particular
to one state in the same place in the code,
hence to focus on one state at the time.
</p><p>
This mode fits well when you have a regular state diagram,
like the ones in this chapter, which describes all events and actions
belonging to a state visually around that state,
and each state has its unique name.
</p><p>
With <strong>handle_event_function</strong>, you are free to mix strategies,
as all events and states are handled in the same callback function.
</p><p>
This mode works equally well when you want to focus on
one event at the time or on
one state at the time, but function
<a href="../stdlib/gen_statem#Module:handle_event/4">stdlib/gen_statem#Module:handle_event/4</a>
quickly grows too large to handle without branching to
helper functions.
</p><p>
The mode enables the use of non-atom states, for example,
complex states or even hierarchical states.
See section
<a href="#Complex State">Complex State</a>.
If, for example, a state diagram is largely alike
for the client side and the server side of a protocol,
you can have a state <strong>{StateName,server}</strong> or
<strong>{StateName,client}</strong>,
and make <strong>StateName</strong> determine where in the code
to handle most events in the state.
The second element of the tuple is then used to select
whether to handle special client-side or server-side events.
</p><a name="State Callback"></a><h4>State Callback</h4><p>
The <em>state callback</em> is the callback function
that handles an event in the current state,
and which function that is depends on the <em>callback mode</em>:
</p><dl><dt><strong>state_functions</strong></dt><dd> The event is handled by:<br/> <a href="../stdlib/gen_statem#Module:StateName/3">stdlib/gen_statem#Module:StateName/3</a> <p>
This form is the one mostly used in the
<a href="#Example">Example</a>
section.
</p> </dd><dt><strong>handle_event_function</strong></dt><dd> The event is handled by:<br/> <a href="../stdlib/gen_statem#Module:handle_event/4">stdlib/gen_statem#Module:handle_event/4</a> <p>
See section
<a href="#One State Callback">One State Callback</a>
for an example.
</p> </dd></dl><p>
The state is either the name of the function itself or an argument to it.
The other arguments are the <strong>EventType</strong> described in section
<a href="#Event Types">Event Types</a>,
the event dependent <strong>EventContent</strong>,
and the current server <strong>Data</strong>.
</p><p>
<em>State enter calls</em> are also handled by the event handler
and have slightly different arguments. See section
<a href="#State Enter Calls">State Enter Calls</a>.
</p><p>
The <em>state callback</em> return values
are defined in the description of
<a href="../stdlib/gen_statem#Module:StateName/3">stdlib/gen_statem#Module:StateName/3</a>
in the <strong>gen_statem</strong> manual page, but here is
a more readable list:
</p><dl><dt> <strong>{next_state, NextState, NewData, Actions}</strong><br/> <strong>{next_state, NextState, NewData}</strong> </dt><dd> <p>
Set next state and update the server data.
If the <strong>Actions</strong> field is used,
execute <em>transition actions</em>.
An empty <strong>Actions</strong> list is equivalent to
not returning the field.
</p> <p>
See section
<a href="#Transition Actions">Transition Actions</a>
for a list of possible
<em>transition actions</em>.
</p> <p>
If <strong>NextState =/= State</strong> this is a <em>state change</em>
so the extra things <strong>gen_statem</strong> does are: the event queue
is restarted from the oldest
<a href="#Postponing Events">postponed event</a>,
any current
<a href="#State Time-Outs">state time-out</a>
is cancelled, and a
<a href="#State Enter Calls">state enter call</a>
is performed, if enabled.
</p> </dd><dt> <strong>{keep_state, NewData, Actions}</strong><br/> <strong>{keep_state, NewData}</strong> </dt><dd> <p>
Same as the <strong>next_state</strong> values with
<strong>NextState =:= State</strong>, that is, no <em>state change</em>.
</p> </dd><dt> <strong>{keep_state_and_data, Actions}</strong><br/> <strong>keep_state_and_data</strong> </dt><dd> <p>
Same as the <strong>keep_state</strong> values with
<strong>NextData =:= Data</strong>, that is, no change in server data.
</p> </dd><dt> <strong>{repeat_state, NewData, Actions}</strong><br/> <strong>{repeat_state, NewData}</strong><br/> <strong>{repeat_state_and_data, Actions}</strong><br/> <strong>repeat_state_and_data</strong> </dt><dd> <p>
Same as the <strong>keep_state</strong> or <strong>keep_state_and_data</strong> values,
and if
<a href="#State Enter Calls"> State Enter Calls </a>
are enabled, repeat the <em>state enter call</em>
as if this state was entered again.
</p> <p>
If these return values are used from a
<em>state enter call</em> the <strong>OldState</strong> does not change,
but if used from an event handling <em>state callback</em>
the new <em>state enter call's</em> <strong>OldState</strong>
will be the current state.
</p> </dd><dt> <strong>{stop, Reason, NewData}</strong><br/> <strong>{stop, Reason}</strong> </dt><dd> <p>
Stop the server with reason <strong>Reason</strong>.
If the <strong>NewData</strong> field is used, first update the server data.
</p> </dd><dt> <strong>{stop_and_reply, Reason, NewData, ReplyActions}</strong><br/> <strong>{stop_and_reply, Reason, ReplyActions}</strong> </dt><dd> <p>
Same as the <strong>stop</strong> values, but first execute the given
<a href="#Transition Actions">Transition Actions</a>
that may only be reply actions.
</p> </dd></dl><a name="The First State"></a><h4>The First State</h4><p>
To decide the first state the
<a href="../stdlib/gen_statem#Module:init/1">stdlib/gen_statem#Module:init/1</a>
callback function is called before any
<a href="#State Callback">State Callback</a>
is called.  This function behaves like an <em>state callback</em>
function, but gets its only argument <strong>Args</strong> from 
the <strong>gen_statem</strong>
<a href="../stdlib/gen_statem#start/3">stdlib/gen_statem#start/3</a>
or
<a href="../stdlib/gen_statem#start_link/3">stdlib/gen_statem#start_link/3</a>
function, and returns <strong>{ok, State, Data}</strong>
or <strong>{ok, State, Data, Actions}</strong>.
If you use the
<a href="#Postponing Events">Postponing Events</a>
action from this function, that action is ignored,
since there is no event	to postpone.
</p><a name="Transition Actions"></a><h4>Transition Actions</h4><p>
In the first section
<a href="#Event-Driven State Machines"> Event-Driven State Machines </a>
actions were mentioned as a part of
the general state machine model. These general actions
are implemented with the code that <em>callback module</em>
<strong>gen_statem</strong> executes in an event-handling
callback function before returning
to the <strong>gen_statem</strong> engine.
</p><p>
There are more specific <em>transition actions</em>
that a callback function can command the <strong>gen_statem</strong>
engine to do after the callback function return.
These are commanded by returning a list of
<a href="../stdlib/gen_statem#type-action">actions</a>
in the
<a href="../stdlib/gen_statem#type-state_callback_result"> return value </a>
from the
<a href="../stdlib/gen_statem#Module:StateName/3">callback function</a>.
These are the possible <em>transition actions</em>:
</p><dl><dt> <a href="../stdlib/gen_statem#type-postpone">stdlib/gen_statem#type-postpone</a> <br/> <strong>{postpone, Boolean}</strong> </dt><dd> If set postpone the current event, see section <a href="#Postponing Events">Postponing Events</a>. </dd><dt> <a href="../stdlib/gen_statem#type-hibernate">stdlib/gen_statem#type-hibernate</a> <br/> <strong>{hibernate, Boolean}</strong> </dt><dd> If set hibernate the <strong>gen_statem</strong>, treated in section <a href="#Hibernation">Hibernation</a>. </dd><dt> <a href="../stdlib/gen_statem#type-state_timeout">stdlib/gen_statem#type-state_timeout</a> <br/> <strong>{state_timeout, EventContent, Time, Opts}</strong> </dt><dd> Start a state time-out, read more in sections <a href="#Time-Outs">Time-Outs</a> and <a href="#State Time-Outs">State Time-Outs</a>. </dd><dt> <a href="../stdlib/gen_statem#type-generic_timeout">stdlib/gen_statem#type-generic_timeout</a> <br/> <strong>{{timeout, Name}, EventContent, Time, Opts}</strong> </dt><dd> Start a generic time-out, read more in sections <a href="#Time-Outs">Time-Outs</a> and <a href="#Generic Time-Outs">Generic Time-Outs</a>. </dd><dt> <a href="../stdlib/gen_statem#type-event_timeout">stdlib/gen_statem#type-event_timeout</a> <br/> <strong>{timeout, EventContent, Time, Opts}</strong><br/> <strong>Time</strong> </dt><dd> Start an event time-out, see more in sections <a href="#Time-Outs">Time-Outs</a> and <a href="#Event Time-Outs">Event Time-Outs</a>. </dd><dt> <a href="../stdlib/gen_statem#type-reply_action">stdlib/gen_statem#type-reply_action</a> </dt><dd> Reply to a caller, mentioned at the end of section <a href="#All State Events">All State Events</a>. </dd><dt> <a href="../stdlib/gen_statem#type-action">stdlib/gen_statem#type-action</a> </dt><dd> Generate the next event to handle, see section  <a href="#Inserted Events">Inserted Events</a>. </dd></dl><p>
For details, see the <strong>gen_statem(3)</strong>
manual page for type
<a href="../stdlib/gen_statem#type-action">stdlib/gen_statem#type-action</a>.
You can, for example, reply to many callers,
generate multiple next events,
and set a time-out to use absolute instead of relative time
(using the <strong>Opts</strong> field).
</p><a name="Event Types"></a><h4>Event Types</h4><p>
Events are categorized in different
<a href="../stdlib/gen_statem#type-event_type">stdlib/gen_statem#type-event_type</a>.
Events of all types are for a given state
handled in the same callback function, and that function gets
<strong>EventType</strong> and <strong>EventContent</strong> as arguments.
</p><p>
The following is a complete list of <em>event types</em> and where
they come from:
</p><dl><dt> <a href="../stdlib/gen_statem#type-external_event_type">stdlib/gen_statem#type-external_event_type</a> </dt><dd> Generated by <a href="../stdlib/gen_statem#cast/2">stdlib/gen_statem#cast/2</a>. </dd><dt> <a href="../stdlib/gen_statem#type-external_event_type">stdlib/gen_statem#type-external_event_type</a> </dt><dd> Generated by <a href="../stdlib/gen_statem#call/2">stdlib/gen_statem#call/2</a>, where <strong>From</strong> is the reply address to use when replying either through the <em>transition action</em> <strong>{reply,From,Msg}</strong> or by calling <a href="../stdlib/gen_statem#reply/1">stdlib/gen_statem#reply/1</a>. </dd><dt> <a href="../stdlib/gen_statem#type-external_event_type">stdlib/gen_statem#type-external_event_type</a> </dt><dd> Generated by any regular process message sent to the <strong>gen_statem</strong> process. </dd><dt> <a href="../stdlib/gen_statem#type-timeout_event_type">stdlib/gen_statem#type-timeout_event_type</a> </dt><dd> Generated by <em>transition action</em> <a href="../stdlib/gen_statem#type-timeout_action">stdlib/gen_statem#type-timeout_action</a> state timer timing out. Read more in sections <a href="#Time-Outs">Time-Outs</a> and <a href="#State Time-Outs">State Time-Outs</a>. </dd><dt> <a href="../stdlib/gen_statem#type-timeout_event_type">stdlib/gen_statem#type-timeout_event_type</a> </dt><dd> Generated by <em>transition action</em> <a href="../stdlib/gen_statem#type-timeout_action">stdlib/gen_statem#type-timeout_action</a> generic timer timing out.  Read more in sections <a href="#Time-Outs">Time-Outs</a> and <a href="#Generic Time-Outs">Generic Time-Outs</a>. </dd><dt> <a href="../stdlib/gen_statem#type-timeout_event_type">stdlib/gen_statem#type-timeout_event_type</a> </dt><dd> Generated by <em>transition action</em> <a href="../stdlib/gen_statem#type-timeout_action">stdlib/gen_statem#type-timeout_action</a> (or its short form <strong>Time</strong>) event timer timing out.  Read more in sections <a href="#Time-Outs">Time-Outs</a> and <a href="#Event Time-Outs">Event Time-Outs</a>. </dd><dt> <a href="../stdlib/gen_statem#type-event_type">stdlib/gen_statem#type-event_type</a> </dt><dd> Generated by <em>transition action</em> <a href="../stdlib/gen_statem#type-enter_action">stdlib/gen_statem#type-enter_action</a>. All <em>event types</em> above can also be generated using the <strong>next_event</strong> action: <strong>{next_event,EventType,EventContent}</strong>. </dd></dl><a name="State Enter Calls"></a><h4>State Enter Calls</h4><p>
The <strong>gen_statem</strong> behavior can if this is enabled,
regardless of <em>callback mode</em>,
automatically
<a href="../stdlib/gen_statem#type-state_enter"> call the state callback </a>
with special arguments whenever the state changes
so you can write state enter actions
near the rest of the <em>state transition</em> rules.
It typically looks like this:
</p><pre>
StateName(enter, OldState, Data) -&gt;
    ... code for state enter actions here ...
    {keep_state, NewData};
StateName(EventType, EventContent, Data) -&gt;
    ... code for actions here ...
    {next_state, NewStateName, NewData}.</pre><p>
Since the <em>state enter call</em> is not an event there are restrictions
on the allowed return value and
<a href="#Transition Actions">State Transition Actions</a>.
You may not change the state,
<a href="#Postponing Events">postpone</a>
this non-event, or
<a href="#Inserted Events">insert any events</a>.
</p><p>
The first state that is entered
will get a <em>state enter call</em>
with <strong>OldState</strong> equal to the current state.
</p><p>
You may repeat the <em>state enter call</em>
using the <strong>{repeat_state,...}</strong>
return value from the 
<a href="#State Callback">state callback</a>.
In this case <strong>OldState</strong> will also be equal to the current state.
</p><p>
Depending on how your state machine is specified,
this can be a very useful feature, but it forces you to handle
the <em>state enter calls</em> in all states.
See also the
<a href="#State Enter Actions"> State Enter Actions </a>
section.
</p><a name="Time-Outs"></a><h4>Time-outs</h4><p>
Time-outs in <strong>gen_statem</strong> are started from a
<a href="#Transition Actions">Transition Actions</a>
during a state transition that is when exiting from the
<a href="#State Callback">State Callback</a>.
</p><p>
There are 3 types of time-outs in <strong>gen_statem</strong>:
</p><dl><dt> <a href="../stdlib/gen_statem#type-state_timeout">stdlib/gen_statem#type-state_timeout</a> </dt><dd> There is one <a href="#State Time-Outs">State Time-Out</a> that is automatically cancelled by a <em>state change</em>. </dd><dt> <a href="../stdlib/gen_statem#type-generic_timeout">stdlib/gen_statem#type-generic_timeout</a> </dt><dd> There are any number of <a href="#Generic Time-Outs">Generic Time-Outs</a> differing by their <strong>Name</strong>. They have no automatic cancelling. </dd><dt> <a href="../stdlib/gen_statem#type-event_timeout">stdlib/gen_statem#type-event_timeout</a> </dt><dd> There is one <a href="#Event Time-Outs">Event Time-Out</a> that is automatically cancelled by any event. Note that <a href="#Postponing Events">postponed </a> and <a href="#Inserted Events">inserted</a> events cancel this timeout just as external events. </dd></dl><p>
When a time-out is started any running time-out with the same tag,
<strong>state_timeout</strong>, <strong>{timeout, Name}</strong> or <strong>timeout</strong>,
is cancelled, that is the time-out is restarted with the new time.
</p><p>
All time-outs has got an <strong>EventContent</strong> that is part of the
<a href="#Transition Actions">Transition Actions</a>
that starts the time-out.
Different <strong>EventContent</strong>s does not create different time-outs.
The <strong>EventContent</strong> is delivered to the
<a href="#State Callback">State Callback</a>
when the time-out expires.
</p><a name="Cancelling a Time-Out"></a><h4>Cancelling a Time-Out</h4><p>
If a time-out is started with the time <strong>infinity</strong> it will
never time out, in fact it will not even be started, and any
running time-out with the same tag will be cancelled.
The <strong>EventContent</strong> will in this case be ignored,
so why not set it to <strong>undefined</strong>.
</p><a name="Time-Out Zero"></a><h4>Time-Out Zero</h4><p>
If a time-out is started with the time <strong>0</strong> it will
actually not be started.  Instead the time-out event will
immediately be inserted to be processed after any events
already enqueued, and before any not yet received external events.
Note that some time-outs are automatically cancelled
so if you for example combine
<a href="#Postponing Events">postponing</a>
an event in a <em>state change</em> with starting an
<a href="#Event Time-Outs">event time-out</a>
with time <strong>0</strong> there will be no timeout event inserted
since the event time-out is cancelled by the postponed
event that is delivered due to the state change.
</p><a name="Example"></a><h4>Example</h4><p>
A door with a code lock can be seen as a state machine.
Initially, the door is locked. When someone presses a button,
an event is generated.
The pressed buttons are collected, up to the number of buttons
in the correct code.
If correct, the door is unlocked for 10 seconds.
If not correct, we wait for a new button to be pressed.
</p><img src="../design_principles/code_lock.svg" title="Code Lock State Diagram"></img><p>
This code lock state machine can be implemented using
<strong>gen_statem</strong> with the following <em>callback module</em>:
</p><pre><code class="erl">
-module(code_lock).
-behaviour(gen_statem).
-define(NAME, code_lock).

-export([start_link/1]).
-export([button/1]).
-export([init/1,callback_mode/0,terminate/3]).
-export([locked/3,open/3]).

start_link(Code) -&gt;
    gen_statem:start_link({local,?NAME}, ?MODULE, Code, []).

button(Button) -&gt;
    gen_statem:cast(?NAME, {button,Button}).

init(Code) -&gt;
    do_lock(),
    Data = #{code =&gt; Code, length =&gt; length(Code), buttons =&gt; []},
    {ok, locked, Data}.

callback_mode() -&gt;
    state_functions.
    </code></pre><pre><code class="erl">
locked(
  cast, {button,Button},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
    NewButtons =
        if
            length(Buttons) &lt; Length -&gt;
                Buttons;
            true -&gt;
                tl(Buttons)
        end ++ [Button],
    if
        NewButtons =:= Code -&gt; % Correct
	    do_unlock(),
            {next_state, open, Data#{buttons := []},
             [{state_timeout,10000,lock}]}; % Time in milliseconds
	true -&gt; % Incomplete | Incorrect
            {next_state, locked, Data#{buttons := NewButtons}}
    end.
    </code></pre><pre><code class="erl">
open(state_timeout, lock,  Data) -&gt;
    do_lock(),
    {next_state, locked, Data};
open(cast, {button,_}, Data) -&gt;
    {next_state, open, Data}.
    </code></pre><pre><code class="erl">
do_lock() -&gt;
    io:format("Lock~n", []).
do_unlock() -&gt;
    io:format("Unlock~n", []).

terminate(_Reason, State, _Data) -&gt;
    State =/= locked andalso do_lock(),
    ok.
    </code></pre><p>The code is explained in the next sections.</p><a name="Starting gen_statem"></a><h4>Starting gen_statem</h4><p>
In the example in the previous section, <strong>gen_statem</strong> is
started by calling <strong>code_lock:start_link(Code)</strong>:
</p><pre><code class="erl">
start_link(Code) -&gt;
    gen_statem:start_link({local,?NAME}, ?MODULE, Code, []).
    </code></pre><p>
<strong>start_link</strong> calls function
<a href="../stdlib/gen_statem#start_link/4">stdlib/gen_statem#start_link/4</a>,
which spawns and links to a new process, a <strong>gen_statem</strong>.
</p><ul><li> <p>
The first argument, <strong>{local,?NAME}</strong>, specifies
the name. In this case, the <strong>gen_statem</strong> is locally
registered as <strong>code_lock</strong> through the macro <strong>?NAME</strong>.
</p> <p>
If the name is omitted, the <strong>gen_statem</strong> is not registered.
Instead its pid must be used. The name can also be specified
as <strong>{global,Name}</strong>, then the <strong>gen_statem</strong> is
registered using
<a href="../kernel/global#register_name/2">kernel/global#register_name/2</a>
in Kernel.
</p> </li><li> <p>
The second argument, <strong>?MODULE</strong>, is the name of
the <em>callback module</em>, that is,
the module where the callback
functions are located, which is this module.
</p> <p>
The interface functions (<strong>start_link/1</strong> and <strong>button/1</strong>)
are located in the same module as the callback functions
(<strong>init/1</strong>, <strong>locked/3</strong>, and <strong>open/3</strong>).
It is normally good programming practice to have the client-side
code and the server-side code contained in one module.
</p> </li><li> <p>
The third argument, <strong>Code</strong>, is a list of digits, which
is the correct unlock code that is passed
to callback function <strong>init/1</strong>.
</p> </li><li> <p>
The fourth argument, <strong>[]</strong>, is a list of options.
For the available options, see
<a href="../stdlib/gen_statem#start_link/3">stdlib/gen_statem#start_link/3</a>.
</p> </li></ul><p>
If name registration succeeds, the new <strong>gen_statem</strong> process
calls callback function <strong>code_lock:init(Code)</strong>.
This function is expected to return <strong>{ok, State, Data}</strong>,
where <strong>State</strong> is the initial state of the <strong>gen_statem</strong>,
in this case <strong>locked</strong>; assuming that the door is locked to begin
with. <strong>Data</strong> is the internal server data of the <strong>gen_statem</strong>.
Here the server data is a <a href="./maps">map</a>
with key <strong>code</strong> that stores the correct button sequence,
key <strong>length</strong> store its length,
and key <strong>buttons</strong> that stores the collected buttons
up to the same length.
</p><pre><code class="erl">
init(Code) -&gt;
    do_lock(),
    Data = #{code =&gt; Code, length =&gt; length(Code), buttons =&gt; []},
    {ok, locked, Data}.
    </code></pre><p>Function
<a href="../stdlib/gen_statem#start_link/3">stdlib/gen_statem#start_link/3</a>
is synchronous. It does not return until the <strong>gen_statem</strong>
is initialized and is ready to receive events.
</p><p>
Function
<a href="../stdlib/gen_statem#start_link/3">stdlib/gen_statem#start_link/3</a>
must be used if the <strong>gen_statem</strong>
is part of a supervision tree, that is, started by a supervisor.
Another function,
<a href="../stdlib/gen_statem#start/3">stdlib/gen_statem#start/3</a>
can be used to start a standalone <strong>gen_statem</strong>, that is,
a <strong>gen_statem</strong> that is not part of a supervision tree.
</p><p>
Function
<a href="../stdlib/gen_statem#Module:callback_mode/0">stdlib/gen_statem#Module:callback_mode/0</a>
selects the
<a href="#Callback Modes">Callback Modes</a>
for the <em>callback module</em>, in this case
<a href="../stdlib/gen_statem#type-callback_mode">stdlib/gen_statem#type-callback_mode</a>.
That is, each state has got its own handler function:
</p><pre><code class="erl">
callback_mode() -&gt;
    state_functions.
    </code></pre><a name="Handling Events"></a><h4>Handling Events</h4><p>The function notifying the code lock about a button event is
implemented using
<a href="../stdlib/gen_statem#cast/2">stdlib/gen_statem#cast/2</a>:
</p><pre><code class="erl">
button(Button) -&gt;
    gen_statem:cast(?NAME, {button,Button}).
    </code></pre><p>
The first argument is the name of the <strong>gen_statem</strong> and must
agree with the name used to start it. So, we use the
same macro <strong>?NAME</strong> as when starting.
<strong>{button,Button}</strong> is the event content.
</p><p>
The event is sent to the <strong>gen_statem</strong>.
When the event is received, the <strong>gen_statem</strong> calls
<strong>StateName(cast, Event, Data)</strong>, which is expected to
return a tuple <strong>{next_state, NewStateName, NewData}</strong>,
or <strong>{next_state, NewStateName, NewData, Actions}</strong>.
<strong>StateName</strong> is the name of the current state and
<strong>NewStateName</strong> is the name of the next state to go to.
<strong>NewData</strong> is a new value for the server data of
the <strong>gen_statem</strong>, and <strong>Actions</strong> is a list of
actions to be performed by the <strong>gen_statem</strong> engine.
</p><pre><code class="erl">
locked(
  cast, {button,Button},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
    NewButtons =
        if
            length(Buttons) &lt; Length -&gt;
                Buttons;
            true -&gt;
                tl(Buttons)
        end ++ [Button],
    if
        NewButtons =:= Code -&gt; % Correct
	    do_unlock(),
            {next_state, open, Data#{buttons := []},
             [{state_timeout,10000,lock}]}; % Time in milliseconds
	true -&gt; % Incomplete | Incorrect
            {next_state, locked, Data#{buttons := NewButtons}}
    end.
    </code></pre><p>
In state <strong>locked</strong>, when a button is pressed,
it is collected with the last pressed buttons
up to the length of the correct code,
and compared with the correct code.
Depending on the result, the door is either unlocked
and the <strong>gen_statem</strong> goes to state <strong>open</strong>,
or the door remains in state <strong>locked</strong>.
</p><p>
When changing to state <strong>open</strong>, the collected
buttons are reset, the lock unlocked, and a state timer
for 10 s is started.
</p><pre><code class="erl">
open(cast, {button,_}, Data) -&gt;
    {next_state, open, Data}.
    </code></pre><p>
In state <strong>open</strong>, a button event is ignored
by staying in the same state.  This can also be done
by returning <strong>{keep_state, Data}</strong> or in this case
since <strong>Data</strong> unchanged even by returning
<strong>keep_state_and_data</strong>.
</p><a name="State Time-Outs"></a><h4>State Time-Outs</h4><p>
When a correct code has been given, the door is unlocked and
the following tuple is returned from <strong>locked/2</strong>:
</p><pre><code class="erl">
{next_state, open, Data#{buttons := []},
 [{state_timeout,10000,lock}]}; % Time in milliseconds
 </code></pre><p>
10,000 is a time-out value in milliseconds.
After this time (10 seconds), a time-out occurs.
Then, <strong>StateName(state_timeout, lock, Data)</strong> is called.
The time-out occurs when the door has been in state <strong>open</strong>
for 10 seconds. After that the door is locked again:
</p><pre><code class="erl">
open(state_timeout, lock,  Data) -&gt;
    do_lock(),
    {next_state, locked, Data};
    </code></pre><p>
The timer for a state time-out is automatically cancelled
when the state machine does a <em>state change</em>.
You can restart a state time-out by setting it to a new time,
which cancels the running timer and starts a new.
This implies that you can cancel a state time-out
by restarting it with time <strong>infinity</strong>.
</p><a name="All State Events"></a><h4>All State Events</h4><p>
Sometimes events can arrive in any state of the <strong>gen_statem</strong>.
It is convenient to handle these in a common state handler function
that all state functions call for events not specific to the state.
</p><p>
Consider a <strong>code_length/0</strong> function that returns
the length of the correct code.
We dispatch all events that are not state-specific
to the common function <strong>handle_common/3</strong>:
</p><pre><code class="erl">
...
-export([button/1,code_length/0]).
...

code_length() -&gt;
    gen_statem:call(?NAME, code_length).

...
locked(...) -&gt; ... ;
locked(EventType, EventContent, Data) -&gt;
    handle_common(EventType, EventContent, Data).

...
open(...) -&gt; ... ;
open(EventType, EventContent, Data) -&gt;
    handle_common(EventType, EventContent, Data).

handle_common({call,From}, code_length, #{code := Code} = Data) -&gt;
    {keep_state, Data,
     [{reply,From,length(Code)}]}.
    </code></pre><p>
Another way to do it is through a convenience macro
<strong>?HANDLE_COMMON/0</strong>:
</p><pre><code class="erl">
...
-export([button/1,code_length/0]).
...

code_length() -&gt;
    gen_statem:call(?NAME, code_length).

-define(HANDLE_COMMON,
    ?FUNCTION_NAME(T, C, D) -&gt; handle_common(T, C, D)).
%%
handle_common({call,From}, code_length, #{code := Code} = Data) -&gt;
    {keep_state, Data,
     [{reply,From,length(Code)}]}.

...
locked(...) -&gt; ... ;
?HANDLE_COMMON.

...
open(...) -&gt; ... ;
?HANDLE_COMMON.
</code></pre><p>
This example uses
<a href="../stdlib/gen_statem#call/2">stdlib/gen_statem#call/2</a>,
which waits for a reply from the server.
The reply is sent with a <strong>{reply,From,Reply}</strong> tuple
in an action list in the <strong>{keep_state, ...}</strong> tuple
that retains the current state.  This return form is convenient
when you want to stay in the current state but do not know or
care about what it is.
</p><p>
If the common <em>state callback</em> needs to know the current state
a function <strong>handle_common/4</strong> can be used instead:
</p><pre><code class="erl">
-define(HANDLE_COMMON,
    ?FUNCTION_NAME(T, C, D) -&gt; handle_common(T, C, ?FUNCTION_NAME, D)).
    </code></pre><a name="One State Callback"></a><h4>One State Callback</h4><p>
If
<a href="#Callback Modes">Callback Modes</a>
<strong>handle_event_function</strong> is used,
all events are handled in
<a href="../stdlib/gen_statem#Module:handle_event/4">stdlib/gen_statem#Module:handle_event/4</a>
and we can (but do not have to) use an event-centered approach
where we first branch depending on event
and then depending on state:
</p><pre><code class="erl">
...
-export([handle_event/4]).

...
callback_mode() -&gt;
    handle_event_function.

handle_event(cast, {button,Button}, State, #{code := Code} = Data) -&gt;
    case State of
	locked -&gt;
            #{length := Length, buttons := Buttons} = Data,
            NewButtons =
                if
                    length(Buttons) &lt; Length -&gt;
                        Buttons;
                    true -&gt;
                        tl(Buttons)
                end ++ [Button],
            if
                NewButtons =:= Code -&gt; % Correct
                    do_unlock(),
                    {next_state, open, Data#{buttons := []},
                     [{state_timeout,10000,lock}]}; % Time in milliseconds
                true -&gt; % Incomplete | Incorrect
                    {keep_state, Data#{buttons := NewButtons}}
            end;
	open -&gt;
            keep_state_and_data
    end;
handle_event(state_timeout, lock, open, Data) -&gt;
    do_lock(),
    {next_state, locked, Data};
handle_event(
  {call,From}, code_length, _State, #{code := Code} = Data) -&gt;
    {keep_state, Data,
     [{reply,From,length(Code)}]}.

...
</code></pre><a name="Stopping"></a><h4>Stopping</h4><a name="In a Supervision Tree"></a><h4>In a Supervision Tree</h4><p>
If the <strong>gen_statem</strong> is part of a supervision tree,
no stop function is needed.
The <strong>gen_statem</strong> is automatically terminated by its supervisor.
Exactly how this is done is defined by a
<a href="./sup_princ#shutdown">shutdown strategy</a>
set in the supervisor.
</p><p>
If it is necessary to clean up before termination, the shutdown
strategy must be a time-out value and the <strong>gen_statem</strong> must
in function <strong>init/1</strong> set itself to trap exit signals
by calling
<a href="../erts/erlang#process_flag/2">erts/erlang#process_flag/2</a>:
</p><pre><code class="erl">
init(Args) -&gt;
    process_flag(trap_exit, true),
    do_lock(),
    ...
    </code></pre><p>
When ordered to shut down, the <strong>gen_statem</strong> then calls
callback function <strong>terminate(shutdown, State, Data)</strong>.
</p><p>
In this example, function <strong>terminate/3</strong>
locks the door if it is open, so we do not accidentally leave the door
open when the supervision tree terminates:
</p><pre><code class="erl">
terminate(_Reason, State, _Data) -&gt;
    State =/= locked andalso do_lock(),
    ok.
    </code></pre><a name="Standalone gen_statem"></a><h4>Standalone gen_statem</h4><p>
If the <strong>gen_statem</strong> is not part of a supervision tree,
it can be stopped using
<a href="../stdlib/gen_statem#stop/1">stdlib/gen_statem#stop/1</a>,
preferably through an API function:
</p><pre><code class="erl">
...
-export([start_link/1,stop/0]).

...
stop() -&gt;
    gen_statem:stop(?NAME).
    </code></pre><p>
This makes the <strong>gen_statem</strong> call callback function
<strong>terminate/3</strong> just like for a supervised server
and waits for the process to terminate.
</p><a name="Event Time-Outs"></a><h4>Event Time-Outs</h4><p>
A time-out feature inherited from <strong>gen_statem</strong>'s predecessor
<a href="./gen_fsm">stdlib/gen_fsm</a>,
is an event time-out, that is,
if an event arrives the timer is cancelled.
You get either an event or a time-out, but not both.
</p><p>
It is ordered by the
<a href="#Transition Actions">Transition Actions</a>
<strong>{timeout,Time,EventContent}</strong>, or just an integer <strong>Time</strong>,
even without the enclosing actions list
(the latter is a form inherited from <strong>gen_fsm</strong>.
</p><p>
This type of time-out is useful for example to act on inactivity.
Let us restart the code sequence
if no button is pressed for say 30 seconds:
</p><pre><code class="erl">
...

locked(timeout, _, Data) -&gt;
    {next_state, locked, Data#{buttons := []}};
locked(
  cast, {button,Button},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
...
	true -&gt; % Incomplete | Incorrect
            {next_state, locked, Data#{buttons := NewButtons},
             30000} % Time in milliseconds
...
</code></pre><p>
Whenever we receive a button event we start an event time-out
of 30 seconds, and if we get an <em>event type</em> of <strong>timeout</strong>
we reset the remaining code sequence.
</p><p>
An event time-out is cancelled by any other event so you either
get some other event or the time-out event.  It is therefore
not possible nor needed to cancel or restart an event time-out.
Whatever event you act on has already cancelled
the event time-out...
</p><p>
Note that an event time-out does not work well with
when you have for example a status call as in section
<a href="#All State Events">All State Events</a>,
or handle unknown events, since all kinds of events
will cancel the event time-out.
</p><a name="Generic Time-Outs"></a><h4>Generic Time-Outs</h4><p>
The previous example of state time-outs only work if
the state machine stays in the same state during the
time-out time.  And event time-outs only work if no
disturbing unrelated events occur.
</p><p>
You may want to start a timer in one state and respond
to the time-out in another, maybe cancel the time-out
without changing states, or perhaps run multiple
time-outs in parallel. All this can be accomplished with
<a href="../stdlib/gen_statem#type-generic_timeout">generic time-outs</a>.
They may look a little bit like
<a href="../stdlib/gen_statem#type-event_timeout">event time-outs</a>
but contain a name to allow for any number of them simultaneously
and they are not automatically cancelled.
</p><p>
Here is how to accomplish the state time-out
in the previous example by instead using a generic time-out
named for example <strong>open</strong>:
</p><pre><code class="erl">
...
locked(
  cast, {button,Button},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
...
    if
        NewButtons =:= Code -&gt; % Correct
	    do_unlock(),
            {next_state, open, Data#{buttons := []},
             [{{timeout,open},10000,lock}]}; % Time in milliseconds
...

open({timeout,open}, lock, Data) -&gt;
    do_lock(),
    {next_state,locked,Data};
open(cast, {button,_}, Data) -&gt;
    {keep_state,Data};
...
</code></pre><p>
Specific generic time-outs can just as
<a href="#State Time-Outs">state time-outs</a>
be restarted or cancelled
by setting it to a new time or <strong>infinity</strong>.
</p><p>
In this particular case we do not need to cancel the time-out
since the time-out event is the only possible reason to
do a <em>state change</em> from <strong>open</strong> to <strong>locked</strong>.
</p><p>
Instead of bothering with when to cancel a time-out,
a late time-out event can be handled by ignoring it
if it arrives in a state where it is known to be late.
</p><a name="Erlang Timers"></a><h4>Erlang Timers</h4><p>
The most versatile way to handle time-outs is to use
Erlang Timers; see
<a href="../erts/erlang#start_timer/4">erts/erlang#start_timer/4</a>.
Most time-out tasks can be performed with the
time-out features in <strong>gen_statem</strong>,
but an example of one that cannot is if you should need
the return value from
<a href="../erts/erlang#cancel_timer/2">erts/erlang#cancel_timer/2</a>, that is; the remaining time of the timer.
</p><p>
Here is how to accomplish the state time-out
in the previous example by instead using an Erlang Timer:
</p><pre><code class="erl">
...
locked(
  cast, {button,Button},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
...
    if
        NewButtons =:= Code -&gt; % Correct
	    do_unlock(),
	    Tref =
                 erlang:start_timer(
                     10000, self(), lock), % Time in milliseconds
            {next_state, open, Data#{buttons := [], timer =&gt; Tref}};
...

open(info, {timeout,Tref,lock}, #{timer := Tref} = Data) -&gt;
    do_lock(),
    {next_state,locked,maps:remove(timer, Data)};
open(cast, {button,_}, Data) -&gt;
    {keep_state,Data};
...
</code></pre><p>
Removing the <strong>timer</strong> key from the map when we
do a <em>state change</em> to <strong>locked</strong> is not strictly
necessary since we can only get into state <strong>open</strong>
with an updated <strong>timer</strong> map value.  But it can be nice
to not have outdated values in the state <strong>Data</strong>!
</p><p>
If you need to cancel a timer because of some other event, you can use
<a href="../erts/erlang#cancel_timer/2">erts/erlang#cancel_timer/2</a>.
Note that a time-out message cannot arrive after this,
unless you have postponed it before (see the next section),
so ensure that you do not accidentally postpone such messages.
Also note that a time-out message may have arrived
just before you cancelling it, so you may have to read out
such a message from the process mailbox depending on
the return value from 
<a href="../erts/erlang#cancel_timer/2">erts/erlang#cancel_timer/2</a>.
</p><p>
Another way to handle a late time-out can be to not cancel it,
but to ignore it if it arrives in a state
where it is known to be late.
</p><a name="Postponing Events"></a><h4>Postponing Events</h4><p>
If you want to ignore a particular event in the current state
and handle it in a future state, you can postpone the event.
A postponed event is retried after a <em>state change</em>,
that is, <strong>OldState =/= NewState</strong>.
</p><p>
Postponing is ordered by the
<a href="#Transition Actions">Transition Actions</a>
<strong>postpone</strong>.
</p><p>
In this example, instead of ignoring button events
while in the <strong>open</strong> state, we can postpone them
and they are queued and later handled in the <strong>locked</strong> state:
</p><pre><code class="erl">
...
open(cast, {button,_}, Data) -&gt;
    {keep_state,Data,[postpone]};
...
</code></pre><p>
Since a postponed event is only retried
after a <em>state change</em>,
you have to think about where to keep a state data item.
You can keep it in the server <strong>Data</strong>
or in the <strong>State</strong> itself,
for example by having two more or less identical states
to keep a boolean value, or by using a complex state
(see section
<a href="#Complex State">Complex State</a>)
with
<a href="#Callback Modes">Callback Modes</a>
<a href="../stdlib/gen_statem#type-callback_mode">stdlib/gen_statem#type-callback_mode</a>.
If a change in the value changes the set of events that is handled,
then the value should be kept in the State.
Otherwise no postponed events will be retried
since only the server Data changes.
</p><p>
This is not important if you do not postpone events.
But if you later decide to start postponing some events,
then the design flaw of not having separate states
when they should be, might become a hard to find bug.
</p><a name="Fuzzy State Diagrams"></a><h4>Fuzzy State Diagrams</h4><p>
It is not uncommon that a state diagram does not specify
how to handle events that are not illustrated
in a particular state in the diagram.
Hopefully this is described in an associated text
or from the context.
</p><p>
Possible actions: ignore as in drop the event
(maybe log it) or deal with the event in some other state
as in postpone it.
</p><a name="Selective Receive"></a><h4>Selective Receive</h4><p>
Erlang's selective receive statement is often used to
describe simple state machine examples in straightforward
Erlang code. The following is a possible implementation of
the first example:
</p><pre><code class="erl">
-module(code_lock).
-define(NAME, code_lock_1).
-export([start_link/1,button/1]).

start_link(Code) -&gt;
    spawn(
      fun () -&gt;
	      true = register(?NAME, self()),
	      do_lock(),
	      locked(Code, length(Code), [])
      end).

button(Button) -&gt;
    ?NAME ! {button,Button}.
    </code></pre><pre><code class="erl">
locked(Code, Length, Buttons) -&gt;
    receive
        {button,Button} -&gt;
            NewButtons =
                if
                    length(Buttons) &lt; Length -&gt;
                        Buttons;
                    true -&gt;
                        tl(Buttons)
                end ++ [Button],
            if
                NewButtons =:= Code -&gt; % Correct
                    do_unlock(),
		    open(Code, Length);
                true -&gt; % Incomplete | Incorrect
                    locked(Code, Length, NewButtons)
            end
    end.
    </code></pre><pre><code class="erl">
open(Code, Length) -&gt;
    receive
    after 10000 -&gt; % Time in milliseconds
	    do_lock(),
	    locked(Code, Length, [])
    end.

do_lock() -&gt;
    io:format("Locked~n", []).
do_unlock() -&gt;
    io:format("Open~n", []).
    </code></pre><p>
The selective receive in this case causes implicitly <strong>open</strong>
to postpone any events to the <strong>locked</strong> state.
</p><p>
A selective receive cannot be used from a <strong>gen_statem</strong>
behavior as for any <strong>gen_*</strong> behavior,
as the receive statement is within the <strong>gen_*</strong> engine itself.
It must be there because all
<a href="./sys">stdlib/sys</a>
compatible behaviors must respond to system messages and therefore
do that in their engine receive loop,
passing non-system messages to the <em>callback module</em>.
</p><p>
The
<a href="#Transition Actions">Transition Actions</a>
<strong>postpone</strong> is designed to model
selective receives. A selective receive implicitly postpones
any not received events, but the <strong>postpone</strong>
<em>transition action</em> explicitly postpones one received event.
</p><p>
Both mechanisms have the same theoretical
time and memory complexity, while the selective receive
language construct has smaller constant factors.
</p><a name="State Enter Actions"></a><h4>State Enter Actions</h4><p>
Say you have a state machine specification
that uses state enter actions.
Allthough you can code this using inserted events
(described in the next section), especially if just
one or a few states has got state enter actions,
this is a perfect use case for the built in
<a href="#State Enter Calls">State Enter Calls</a>.
</p><p>
You return a list containing <strong>state_enter</strong> from your
<a href="../stdlib/gen_statem#Module:callback_mode/0">stdlib/gen_statem#Module:callback_mode/0</a>
function and the <strong>gen_statem</strong> engine will call your
<em>state callback</em> once with an event
<strong>(enter, OldState, ...)</strong>
whenever it does a <em>state change</em>.
Then you just need to handle these event-like calls in all states.
</p><pre><code class="erl">
...
init(Code) -&gt;
    process_flag(trap_exit, true),
    Data = #{code =&gt; Code, length = length(Code)},
    {ok, locked, Data}.

callback_mode() -&gt;
    [state_functions,state_enter].

locked(enter, _OldState, Data) -&gt;
    do_lock(),
    {keep_state,Data#{buttons =&gt; []}};
locked(
  cast, {button,Button},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
...
    if
        NewButtons =:= Code -&gt; % Correct
            {next_state, open, Data};
...

open(enter, _OldState, _Data) -&gt;
    do_unlock(),
    {keep_state_and_data,
     [{state_timeout,10000,lock}]}; % Time in milliseconds
open(state_timeout, lock, Data) -&gt;
    {next_state, locked, Data};
...
</code></pre><p>
You can repeat the state enter code by returning one of
<strong>{repeat_state, ...}</strong>, <strong>{repeat_state_and_data,_}</strong>
or <strong>repeat_state_and_data</strong> that otherwise behaves
exactly like their <strong>keep_state</strong> siblings.
See the type
<a href="../stdlib/gen_statem#type-state_callback_result">stdlib/gen_statem#type-state_callback_result</a>
in the reference manual.
</p><a name="Inserted Events"></a><h4>Inserted Events</h4><p>
It can sometimes be beneficial to be able to generate events
to your own state machine.
This can be done with the
<a href="#Transition Actions">Transition Actions</a>
<strong>{next_event,EventType,EventContent}</strong>.
</p><p>
You can generate events of any existing
<a href="../stdlib/gen_statem#type-action">type</a>,
but the <strong>internal</strong> type can only be generated through action
<strong>next_event</strong>. Hence, it cannot come from an external source,
so you can be certain that an <strong>internal</strong> event is an event
from your state machine to itself.
</p><p>
One example for this is to pre-process incoming data, for example
decrypting chunks or collecting characters up to a line break.
</p><p>
Purists may argue that this should be modelled with a separate
state machine that sends pre-processed events
to the main state machine,
but to decrease overhead the small pre-processing state machine
can be implemented in the common state event handling
of the main state machine using a few state data variables
that then sends the pre-processed events as internal events
to the main state machine.
Using internal events also can make it easier
to synchronize the state machines.
</p><p>
A variant of this is to use a
<a href="#Complex State">complex state</a>
with
<a href="#One State Callback">One State Callback</a>.
The state is then modeled with for example a tuple
<strong>{MainFSMState,SubFSMState}</strong>.
</p><p>
To illustrate this we make up an example where the buttons
instead generate down and up (press and release) events,
and the lock responds to an up event only after
the corresponding down event.
</p><pre><code class="erl">
...
-export([down/1, up/1]).
...
down(Button) -&gt;
    gen_statem:cast(?NAME, {down,Button}).

up(Button) -&gt;
    gen_statem:cast(?NAME, {up,Button}).

...

locked(enter, _OldState, Data) -&gt;
    do_lock(),
    {keep_state,Data#{buttons =&gt; []}};
locked(
  internal, {button,Button},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
...
</code></pre><pre><code class="erl">
handle_common(cast, {down,Button}, Data) -&gt;
    {keep_state, Data#{button =&gt; Button}};
handle_common(cast, {up,Button}, Data) -&gt;
    case Data of
        #{button := Button} -&gt;
            {keep_state,maps:remove(button, Data),
             [{next_event,internal,{button,Button}}]};
        #{} -&gt;
            keep_state_and_data
    end;
...

open(internal, {button,_}, Data) -&gt;
    {keep_state,Data,[postpone]};
...
</code></pre><p>
If you start this program with <strong>code_lock:start([17])</strong>
you can unlock with <strong>code_lock:down(17), code_lock:up(17).</strong>
</p><a name="Example Revisited"></a><h4>Example Revisited</h4><p>
This section includes the example after most of the mentioned
modifications and some more using <em>state enter calls</em>,
which deserves a new state diagram:
</p><img src="../design_principles/code_lock_2.svg" title="Code Lock State Diagram Revisited"></img><p>
Notice that this state diagram does not specify how to handle
a button event in the state <strong>open</strong>. So, you need to
read in some side notes, that is, here: that unspecified events
shall be postponed (handled in some later state).
Also, the state diagram does not show that the <strong>code_length/0</strong>
call must be handled in every state.
</p><a name="Callback Mode: state_functions"></a><h4>Callback Mode: state_functions</h4><p>
Using state functions:
</p><pre><code class="erl">
-module(code_lock).
-behaviour(gen_statem).
-define(NAME, code_lock_2).

-export([start_link/1,stop/0]).
-export([down/1,up/1,code_length/0]).
-export([init/1,callback_mode/0,terminate/3]).
-export([locked/3,open/3]).

start_link(Code) -&gt;
    gen_statem:start_link({local,?NAME}, ?MODULE, Code, []).
stop() -&gt;
    gen_statem:stop(?NAME).

down(Button) -&gt;
    gen_statem:cast(?NAME, {down,Button}).
up(Button) -&gt;
    gen_statem:cast(?NAME, {up,Button}).
code_length() -&gt;
    gen_statem:call(?NAME, code_length).
    </code></pre><pre><code class="erl">
init(Code) -&gt;
    process_flag(trap_exit, true),
    Data = #{code =&gt; Code, length =&gt; length(Code), buttons =&gt; []},
    {ok, locked, Data}.

callback_mode() -&gt;
    [state_functions,state_enter].

-define(HANDLE_COMMON,
    ?FUNCTION_NAME(T, C, D) -&gt; handle_common(T, C, D)).
%%
handle_common(cast, {down,Button}, Data) -&gt;
    {keep_state, Data#{button =&gt; Button}};
handle_common(cast, {up,Button}, Data) -&gt;
    case Data of
        #{button := Button} -&gt;
            {keep_state, maps:remove(button, Data),
             [{next_event,internal,{button,Button}}]};
        #{} -&gt;
            keep_state_and_data
    end;
handle_common({call,From}, code_length, #{code := Code}) -&gt;
    {keep_state_and_data,
     [{reply,From,length(Code)}]}.
    </code></pre><pre><code class="erl">
locked(enter, _OldState, Data) -&gt;
    do_lock(),
    {keep_state, Data#{buttons := []}};
locked(state_timeout, button, Data) -&gt;
    {keep_state, Data#{buttons := []}};
locked(
  internal, {button,Button},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
    NewButtons =
        if
            length(Buttons) &lt; Length -&gt;
                Buttons;
            true -&gt;
                tl(Buttons)
        end ++ [Button],
    if
        NewButtons =:= Code -&gt; % Correct
            {next_state, open, Data};
	true -&gt; % Incomplete | Incorrect
            {keep_state, Data#{buttons := NewButtons},
             [{state_timeout,30000,button}]} % Time in milliseconds
    end;
?HANDLE_COMMON.
</code></pre><pre><code class="erl">
open(enter, _OldState, _Data) -&gt;
    do_unlock(),
    {keep_state_and_data,
     [{state_timeout,10000,lock}]}; % Time in milliseconds
open(state_timeout, lock, Data) -&gt;
    {next_state, locked, Data};
open(internal, {button,_}, _) -&gt;
    {keep_state_and_data, [postpone]};
?HANDLE_COMMON.

do_lock() -&gt;
    io:format("Locked~n", []).
do_unlock() -&gt;
    io:format("Open~n", []).

terminate(_Reason, State, _Data) -&gt;
    State =/= locked andalso do_lock(),
    ok.
    </code></pre><a name="Callback Mode: handle_event_function"></a><h4>Callback Mode: handle_event_function</h4><p>
This section describes what to change in the example
to use one <strong>handle_event/4</strong> function.
The previously used approach to first branch depending on event
does not work that well here
because of the <em>state enter calls</em>,
so this example first branches depending on state:
</p><pre><code class="erl">
-export([handle_event/4]).
</code></pre><pre><code class="erl">
callback_mode() -&gt;
    [handle_event_function,state_enter].
    </code></pre><pre><code class="erl">
%%
%% State: locked
handle_event(enter, _OldState, locked, Data) -&gt;
    do_lock(),
    {keep_state, Data#{buttons := []}};
handle_event(state_timeout, button, locked, Data) -&gt;
    {keep_state, Data#{buttons := []}};
handle_event(
  internal, {button,Button}, locked,
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
    NewButtons =
        if
            length(Buttons) &lt; Length -&gt;
                Buttons;
            true -&gt;
                tl(Buttons)
        end ++ [Button],
    if
        NewButtons =:= Code -&gt; % Correct
            {next_state, open, Data};
	true -&gt; % Incomplete | Incorrect
            {keep_state, Data#{buttons := NewButtons},
             [{state_timeout,30000,button}]} % Time in milliseconds
    end;
    </code></pre><pre><code class="erl">
%%
%% State: open
handle_event(enter, _OldState, open, _Data) -&gt;
    do_unlock(),
    {keep_state_and_data,
     [{state_timeout,10000,lock}]}; % Time in milliseconds
handle_event(state_timeout, lock, open, Data) -&gt;
    {next_state, locked, Data};
handle_event(internal, {button,_}, open, _) -&gt;
    {keep_state_and_data,[postpone]};
    </code></pre><pre><code class="erl">
%% Common events
handle_event(cast, {down,Button}, _State, Data) -&gt;
    {keep_state, Data#{button =&gt; Button}};
handle_event(cast, {up,Button}, _State, Data) -&gt;
    case Data of
        #{button := Button} -&gt;
            {keep_state, maps:remove(button, Data),
             [{next_event,internal,{button,Button}},
              {state_timeout,30000,button}]}; % Time in milliseconds
        #{} -&gt;
            keep_state_and_data
    end;
handle_event({call,From}, code_length, _State, #{length := Length}) -&gt;
    {keep_state_and_data,
     [{reply,From,Length}]}.
    </code></pre><p>
Notice that postponing buttons from the <strong>open</strong> state
to the <strong>locked</strong> state feels like a strange thing to do
for a code lock, but it at least illustrates event postponing.
</p><a name="Filter the State"></a><h4>Filter the State</h4><p>
The example servers so far in this chapter
print the full internal state in the error log, for example,
when killed by an exit signal or because of an internal error.
This state contains both the code lock code
and which digits that remain to unlock.
</p><p>
This state data can be regarded as sensitive,
and maybe not what you want in the error log
because of some unpredictable event.
</p><p>
Another reason to filter the state can be
that the state is too large to print, as it fills
the error log with uninteresting details.
</p><p>
To avoid this, you can format the internal state
that gets in the error log and gets returned from
<a href="../stdlib/sys#get_status/1">stdlib/sys#get_status/1</a>
by implementing function
<a href="../stdlib/gen_statem#Module:format_status/2">stdlib/gen_statem#Module:format_status/2</a>,
for example like this:
</p><pre><code class="erl">
...
-export([init/1,terminate/3,format_status/2]).
...

format_status(Opt, [_PDict,State,Data]) -&gt;
    StateData =
	{State,
	 maps:filter(
	   fun (code, _) -&gt; false;
	       (_, _) -&gt; true
	   end,
	   Data)},
    case Opt of
	terminate -&gt;
	    StateData;
	normal -&gt;
	    [{data,[{"State",StateData}]}]
    end.
    </code></pre><p>
It is not mandatory to implement a
<a href="../stdlib/gen_statem#Module:format_status/2">stdlib/gen_statem#Module:format_status/2</a>
function. If you do not, a default implementation is used that
does the same as this example function without filtering
the <strong>Data</strong> term, that is, <strong>StateData = {State,Data}</strong>,
in this example containing sensitive information.
</p><a name="Complex State"></a><h4>Complex State</h4><p>
The <em>callback mode</em>
<a href="../stdlib/gen_statem#type-callback_mode">stdlib/gen_statem#type-callback_mode</a>
enables using a non-atom state as described in section
<a href="#Callback Modes">Callback Modes</a>,
for example, a complex state term like a tuple.
</p><p>
One reason to use this is when you have a state item
that when changed should cancel the
<a href="#State Time-Outs">state time-out</a>,
or one that affects the event handling
in combination with postponing events.
We will go for the latter and complicate the previous example
by introducing a configurable lock button
(this is the state item in question),
which in the <strong>open</strong> state immediately locks the door,
and an API function <strong>set_lock_button/1</strong> to set the lock button.
</p><p>
Suppose now that we call <strong>set_lock_button</strong>
while the door is open,
and we have already postponed a button event
that was the new lock button:
</p><pre><code class="erl">
1&gt; code_lock:start_link([a,b,c], x).
{ok,&lt;0.666.0&gt;}
2&gt; code_lock:button(a).
ok
3&gt; code_lock:button(b).
ok
4&gt; code_lock:button(c).
ok
Open
5&gt; code_lock:button(y).
ok
6&gt; code_lock:set_lock_button(y).
x
% What should happen here?  Immediate lock or nothing?
</code></pre><p>
We could say that the button was pressed too early
so it is not to be recognized as the lock button.
Or we can make the lock button part of the state so
when we then change the lock button in the locked state,
the change becomes a <em>state change</em>
and all postponed events are retried,
therefore the lock is immediately locked!
</p><p>
We define the state as <strong>{StateName,LockButton}</strong>,
where <strong>StateName</strong> is as before
and <strong>LockButton</strong> is the current lock button:
</p><pre><code class="erl">
-module(code_lock).
-behaviour(gen_statem).
-define(NAME, code_lock_3).

-export([start_link/2,stop/0]).
-export([button/1,set_lock_button/1]).
-export([init/1,callback_mode/0,terminate/3]).
-export([handle_event/4]).

start_link(Code, LockButton) -&gt;
    gen_statem:start_link(
        {local,?NAME}, ?MODULE, {Code,LockButton}, []).
stop() -&gt;
    gen_statem:stop(?NAME).

button(Button) -&gt;
    gen_statem:cast(?NAME, {button,Button}).
set_lock_button(LockButton) -&gt;
    gen_statem:call(?NAME, {set_lock_button,LockButton}).
    </code></pre><pre><code class="erl">
init({Code,LockButton}) -&gt;
    process_flag(trap_exit, true),
    Data = #{code =&gt; Code, length =&gt; length(Code), buttons =&gt; []},
    {ok, {locked,LockButton}, Data}.

callback_mode() -&gt;
    [handle_event_function,state_enter].

%% State: locked
handle_event(enter, _OldState, {locked,_}, Data) -&gt;
    do_lock(),
    {keep_state, Data#{buttons := []}};
handle_event(state_timeout, button, {locked,_}, Data) -&gt;
    {keep_state, Data#{buttons := []}};
handle_event(
  cast, {button,Button}, {locked,LockButton},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
    NewButtons =
        if
            length(Buttons) &lt; Length -&gt;
                Buttons;
            true -&gt;
                tl(Buttons)
        end ++ [Button],
    if
        NewButtons =:= Code -&gt; % Correct
            {next_state, {open,LockButton}, Data};
	true -&gt; % Incomplete | Incorrect
            {keep_state, Data#{buttons := NewButtons},
             [{state_timeout,30000,button}]} % Time in milliseconds
    end;
    </code></pre><pre><code class="erl">
%%
%% State: open
handle_event(enter, _OldState, {open,_}, _Data) -&gt;
    do_unlock(),
    {keep_state_and_data,
     [{state_timeout,10000,lock}]}; % Time in milliseconds
handle_event(state_timeout, lock, {open,LockButton}, Data) -&gt;
    {next_state, {locked,LockButton}, Data};
handle_event(cast, {button,LockButton}, {open,LockButton}, Data) -&gt;
    {next_state, {locked,LockButton}, Data};
handle_event(cast, {button,_}, {open,_}, _Data) -&gt;
    {keep_state_and_data,[postpone]};
    </code></pre><pre><code class="erl">
%%
%% Common events
handle_event(
  {call,From}, {set_lock_button,NewLockButton},
  {StateName,OldLockButton}, Data) -&gt;
    {next_state, {StateName,NewLockButton}, Data,
     [{reply,From,OldLockButton}]}.
    </code></pre><pre><code class="erl">
do_lock() -&gt;
    io:format("Locked~n", []).
do_unlock() -&gt;
    io:format("Open~n", []).

terminate(_Reason, State, _Data) -&gt;
    State =/= locked andalso do_lock(),
    ok.
    </code></pre><a name="Hibernation"></a><h4>Hibernation</h4><p>
If you have many servers in one node
and they have some state(s) in their lifetime in which
the servers can be expected to idle for a while,
and the amount of heap memory all these servers need
is a problem, then the memory footprint of a server
can be mimimized by hibernating it through
<a href="../stdlib/proc_lib#hibernate/3">stdlib/proc_lib#hibernate/3</a>.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
It is rather costly to hibernate a process; see
<a href="../erts/erlang#hibernate/3">erts/erlang#hibernate/3</a>.
It is not something you want to do after every event.
</p></div><p>
We can in this example hibernate in the <strong>{open,_}</strong> state,
because what normally occurs in that state is that
the state time-out after a while
triggers a transition to <strong>{locked,_}</strong>:
</p><pre><code class="erl">
...
%%
%% State: open
handle_event(enter, _OldState, {open,_}, _Data) -&gt;
    do_unlock(),
    {keep_state_and_data,
     [{state_timeout,10000,lock}, % Time in milliseconds
      hibernate]};
...
</code></pre><p>
The atom
<a href="../stdlib/gen_statem#type-hibernate">stdlib/gen_statem#type-hibernate</a>
in the action list on the last line
when entering the <strong>{open,_}</strong> state is the only change.
If any event arrives in the <strong>{open,_},</strong> state, we
do not bother to rehibernate, so the server stays
awake after any event.
</p><p>
To change that we would need to insert
action <strong>hibernate</strong> in more places.
For example, the state-independent <strong>set_lock_button</strong>
operation would have to use <strong>hibernate</strong> but only in the
<strong>{open,_}</strong> state, which would clutter the code.
</p><p>
Another not uncommon scenario is to use the
<a href="#Event Time-Outs">event time-out</a>
to trigger hibernation after a certain time of inactivity.
There is also a server start option
<a href="../stdlib/gen_statem#type-enter_loop_opt">stdlib/gen_statem#type-enter_loop_opt</a>
for
<a href="../stdlib/gen_statem#start/3">stdlib/gen_statem#start/3</a>,
<a href="../stdlib/gen_statem#start_link/3">stdlib/gen_statem#start_link/3</a>
or
<a href="../stdlib/gen_statem#enter_loop/4">stdlib/gen_statem#enter_loop/4</a>
that may be used to automatically hibernate the server.
</p><p>
This particular server probably does not use
heap memory worth hibernating for.
To gain anything from hibernation, your server would
have to produce non-insignificant garbage
during callback execution,
for which this example server can serve as a bad example.
</p><a name="gen_event"></a><p>This section is to be read with the <strong>gen_event(3)</strong> manual
page in STDLIB, where all interface functions and callback
functions are described in detail.</p><h4>Event Handling Principles</h4><p>In OTP, an <em>event manager</em> is a named object to which
events can be sent. An <em>event</em> can be, for example,
an error, an alarm, or some information that is to be logged.</p><p>In the event manager, zero, one, or many <em>event handlers</em>
are installed. When the event manager is notified
about an event, the event is processed by all the installed
event handlers. For example, an event manager for handling errors
can by default have a handler installed, which writes error
messages to the terminal. If the error messages during a certain
period is to be saved to a file as well, the user adds another
event handler that does this. When logging to the file is no
longer necessary, this event handler is deleted.</p><p>An event manager is implemented as a process and each event
handler is implemented as a callback module.</p><p>The event manager essentially maintains a list of
<strong>{Module, State}</strong> pairs, where each <strong>Module</strong> is an
event handler, and <strong>State</strong> is the internal state of that
event handler.</p><h4>Example</h4><p>The callback module for the event handler writing error messages
to the terminal can look as follows:</p><pre><code class="">
-module(terminal_logger).
-behaviour(gen_event).

-export([init/1, handle_event/2, terminate/2]).

init(_Args) -&gt;
    {ok, []}.

handle_event(ErrorMsg, State) -&gt;
    io:format("***Error*** ~p~n", [ErrorMsg]),
    {ok, State}.

terminate(_Args, _State) -&gt;
    ok.</code></pre><p>The callback module for the event handler writing error messages
to a file can look as follows:</p><pre><code class="">
-module(file_logger).
-behaviour(gen_event).

-export([init/1, handle_event/2, terminate/2]).

init(File) -&gt;
    {ok, Fd} = file:open(File, read),
    {ok, Fd}.

handle_event(ErrorMsg, Fd) -&gt;
    io:format(Fd, "***Error*** ~p~n", [ErrorMsg]),
    {ok, Fd}.

terminate(_Args, Fd) -&gt;
    file:close(Fd).</code></pre><p>The code is explained in the next sections.</p><a name="mgr"></a><h4>Starting an Event Manager</h4><p>To start an event manager for handling errors, as described in
the previous example, call the following function:</p><pre><code class="">
gen_event:start_link({local, error_man})</code></pre><p>This function spawns and links to a new process, an event
manager.</p><p>The argument, <strong>{local, error_man}</strong> specifies the name. The
event manager is then locally registered as <strong>error_man</strong>.</p><p>If the name is omitted, the event manager is not registered.
Instead its pid must be used. The name can also be given
as <strong>{global, Name}</strong>, in which case the event manager is
registered using <strong>global:register_name/2</strong>.</p><p><strong>gen_event:start_link</strong> must be used if the event manager is
part of a supervision tree, that is, started by a supervisor.
There is another function, <strong>gen_event:start</strong>, to start a
standalone event manager, that is, an event manager that is not
part of a supervision tree.</p><h4>Adding an Event Handler</h4><p>The following example shows how to start an event manager and
add an event handler to it by using the shell:</p><pre>
1&gt; <span class="input">gen_event:start({local, error_man}).</span>
{ok,&lt;0.31.0&gt;}
2&gt; <span class="input">gen_event:add_handler(error_man, terminal_logger, []).</span>
ok</pre><p>This function sends a message to the event manager registered as
<strong>error_man</strong>, telling it to add the event handler
<strong>terminal_logger</strong>. The event manager calls the callback
function <strong>terminal_logger:init([])</strong>, where the argument
<strong>[]</strong> is the third argument to <strong>add_handler</strong>. <strong>init</strong>
is expected to return <strong>{ok, State}</strong>, where <strong>State</strong> is
the internal state of the event handler.</p><pre><code class="">
init(_Args) -&gt;
    {ok, []}.</code></pre><p>Here, <strong>init</strong> does not need any input data and ignores its
argument. For <strong>terminal_logger</strong>, the internal state is
not used. For <strong>file_logger</strong>, the internal state is used
to save the open file descriptor.</p><pre><code class="">
init(File) -&gt;
    {ok, Fd} = file:open(File, read),
    {ok, Fd}.</code></pre><h4>Notifying about Events</h4><pre>
3&gt; <span class="input">gen_event:notify(error_man, no_reply).</span>
***Error*** no_reply
ok</pre><p><strong>error_man</strong> is the name of the event manager and
<strong>no_reply</strong> is the event.</p><p>The event is made into a message and sent to the event manager.
When the event is received, the event manager calls
<strong>handle_event(Event, State)</strong> for each installed event
handler, in the same order as they were added. The function is
expected to return a tuple <strong>{ok,State1}</strong>, where
<strong>State1</strong> is a new value for the state of the event handler.</p><p>In <strong>terminal_logger</strong>:</p><pre><code class="">
handle_event(ErrorMsg, State) -&gt;
    io:format("***Error*** ~p~n", [ErrorMsg]),
    {ok, State}.</code></pre><p>In <strong>file_logger</strong>:</p><pre><code class="">
handle_event(ErrorMsg, Fd) -&gt;
    io:format(Fd, "***Error*** ~p~n", [ErrorMsg]),
    {ok, Fd}.</code></pre><h4>Deleting an Event Handler</h4><pre>
4&gt; <span class="input">gen_event:delete_handler(error_man, terminal_logger, []).</span>
ok</pre><p>This function sends a message to the event manager registered as
<strong>error_man</strong>, telling it to delete the event handler
<strong>terminal_logger</strong>. The event manager calls the callback
function <strong>terminal_logger:terminate([], State)</strong>, where
the argument <strong>[]</strong> is the third argument to <strong>delete_handler</strong>.
<strong>terminate</strong> is to be the opposite of <strong>init</strong> and do any
necessary cleaning up. Its return value is ignored.</p><p>For <strong>terminal_logger</strong>, no cleaning up is necessary:</p><pre><code class="">
terminate(_Args, _State) -&gt;
    ok.</code></pre><p>For <strong>file_logger</strong>, the file descriptor opened in <strong>init</strong>
must be closed:</p><pre><code class="">
terminate(_Args, Fd) -&gt;
    file:close(Fd).</code></pre><h4>Stopping</h4><p>When an event manager is stopped, it gives each of
the installed event handlers the chance to clean up by calling
<strong>terminate/2</strong>, the same way as when deleting a handler.</p><h4>In a Supervision Tree</h4><p>If the event manager is part of a supervision tree, no stop
function is needed. The event manager is automatically
terminated by its supervisor. Exactly how this is done is
defined by a
<a href="./sup_princ#shutdown">shutdown strategy</a>
set in the supervisor.</p><h4>Standalone Event Managers</h4><p>An event manager can also be stopped by calling:</p><pre>
&gt; <span class="input">gen_event:stop(error_man).</span>
ok</pre><h4>Handling Other Messages</h4><p>If the <strong>gen_event</strong> is to be able to receive other messages
than events, the callback function
<strong>handle_info(Info, StateName, StateData)</strong>
must be implemented to handle them. Examples of other
messages are exit messages, if the <strong>gen_event</strong> is linked to
other processes (than the supervisor) and trapping exit signals.</p><pre><code class="">
handle_info({'EXIT', Pid, Reason}, State) -&gt;
    ..code to handle exits here..
    {ok, NewState}.</code></pre><p>The <strong>code_change</strong> method must also be implemented.</p><pre><code class="">
code_change(OldVsn, State, Extra) -&gt;
    ..code to convert state (and more) during code change
    {ok, NewState}</code></pre><p>This section should be read with the
<a href="./supervisor">supervisor(3)</a> manual page
in STDLIB, where all details about the supervisor
behaviour is given.</p><h4>Supervision Principles</h4><p>A supervisor is responsible for starting, stopping, and
monitoring its child processes. The basic idea of a supervisor is
that it is to keep its child processes alive by restarting them
when necessary.</p><p>Which child processes to start and monitor is specified by a
list of <a href="#spec">child specifications</a>.
The child processes are started in the order specified by this
list, and terminated in the reversed order.</p><h4>Example</h4><p>The callback module for a supervisor starting the server from
<a href="./gen_server_concepts#ex">gen_server Behaviour</a>
can look as follows:</p><a name="ex"></a><pre><code class="">
-module(ch_sup).
-behaviour(supervisor).

-export([start_link/0]).
-export([init/1]).

start_link() -&gt;
    supervisor:start_link(ch_sup, []).

init(_Args) -&gt;
    SupFlags = #{strategy =&gt; one_for_one, intensity =&gt; 1, period =&gt; 5},
    ChildSpecs = [#{id =&gt; ch3,
                    start =&gt; {ch3, start_link, []},
                    restart =&gt; permanent,
                    shutdown =&gt; brutal_kill,
                    type =&gt; worker,
                    modules =&gt; [cg3]}],
    {ok, {SupFlags, ChildSpecs}}.</code></pre><p>The <strong>SupFlags</strong> variable in the return value
from <strong>init/1</strong> represents
the <a href="#flags">supervisor flags</a>.</p><p>The <strong>ChildSpecs</strong> variable in the return value
from <strong>init/1</strong> is a list of <a href="#spec">child specifications</a>.</p><a name="flags"></a><h4>Supervisor Flags</h4><p>This is the type definition for the supervisor flags:</p><pre><code class="">
sup_flags() = #{strategy =&gt; strategy(),         % optional
                intensity =&gt; non_neg_integer(), % optional
                period =&gt; pos_integer()}        % optional
    strategy() = one_for_all
               | one_for_one
               | rest_for_one
               | simple_one_for_one</code></pre><ul><li> <p><strong>strategy</strong> specifies
the <a href="#strategy">restart strategy</a>.</p> </li><li> <p><strong>intensity</strong> and <strong>period</strong> specify
the <a href="#max_intensity">maximum restart intensity</a>.</p> </li></ul><a name="strategy"></a><h4>Restart Strategy</h4><p> The restart strategy is specified by
the <strong>strategy</strong> key in the supervisor flags map returned by
the callback function <strong>init</strong>:</p><pre><code class="">
SupFlags = #{strategy =&gt; Strategy, ...}</code></pre><p>The <strong>strategy</strong> key is optional in this map. If it is not
given, it defaults to <strong>one_for_one</strong>.</p><h4>one_for_one</h4><p>If a child process terminates, only that process is restarted.</p><a name="sup4"></a><img src="../design_principles/sup4.gif" title="One_For_One Supervision"></img><h4>one_for_all</h4><p>If a child process terminates, all other child processes are
terminated, and then all child processes, including
the terminated one, are restarted.</p><a name="sup5"></a><img src="../design_principles/sup5.gif" title="One_For_All Supervision"></img><h4>rest_for_one</h4><p>If a child process terminates, the rest of the child
processes (that is, the child processes after the terminated
process in start order) are terminated. Then the terminated
child process and the rest of the child processes are restarted.</p><h4>simple_one_for_one</h4><p>See <a href="#simple">simple-one-for-one supervisors</a>.</p><a name="max_intensity"></a><h4>Maximum Restart Intensity</h4><p>The supervisors have a built-in mechanism to limit the number of
restarts which can occur in a given time interval. This is
specified by the two keys <strong>intensity</strong> and
<strong>period</strong> in the supervisor flags map returned by the
callback function <strong>init</strong>:</p><pre><code class="">
SupFlags = #{intensity =&gt; MaxR, period =&gt; MaxT, ...}</code></pre><p>If more than <strong>MaxR</strong> number of restarts occur in the last
<strong>MaxT</strong> seconds, the supervisor terminates all the child
processes and then itself.
The termination reason for the supervisor itself in that case will be
<strong>shutdown</strong>.</p><p>When the supervisor terminates, then the next higher-level
supervisor takes some action. It either restarts the terminated
supervisor or terminates itself.</p><p>The intention of the restart mechanism is to prevent a situation
where a process repeatedly dies for the same reason, only to be
restarted again.</p><p>The keys <strong>intensity</strong> and <strong>period</strong> are optional in the
supervisor flags map. If they are not given, they default
to <strong>1</strong> and <strong>5</strong>, respectively.</p><h4>Tuning the intensity and period</h4><p>The default values are 1 restart per 5 seconds. This was chosen to
be safe for most systems, even with deep supervision hierarchies,
but you will probably want to tune the settings for your particular
use case.</p><p>First, the intensity decides how big bursts of restarts you want
to tolerate. For example, you might want to accept a burst of at
most 5 or 10 attempts, even within the same second, if it results
in a successful restart.</p><p>Second, you need to consider the sustained failure rate, if
crashes keep happening but not often enough to make the supervisor
give up. If you set intensity to 10 and set the period as low as 1,
the supervisor will allow child processes to keep restarting up to
10 times per second, forever, filling your logs with crash reports
until someone intervenes manually.</p><p>You should therefore set the period to be long enough that you can
accept that the supervisor keeps going at that rate. For example,
if you have picked an intensity value of 5, then setting the period
to 30 seconds will give you at most one restart per 6 seconds for
any longer period of time, which means that your logs won't fill up
too quickly, and you will have a chance to observe the failures and
apply a fix.</p><p>These choices depend a lot on your problem domain. If you don't
have real time monitoring and ability to fix problems quickly, for
example in an embedded system, you might want to accept at most
one restart per minute before the supervisor should give up and
escalate to the next level to try to clear the error automatically.
On the other hand, if it is more important that you keep trying
even at a high failure rate, you might want a sustained rate of as
much as 1-2 restarts per second.</p><p>Avoiding common mistakes:</p><ul><li> <p>Do not forget to consider the burst rate. If you set intensity
to 1 and period to 6, it gives the same sustained error rate as
5/30 or 10/60, but will not allow even 2 restart attempts in
quick succession. This is probably not what you wanted.</p> </li><li> <p>Do not set the period to a very high value if you want to
tolerate bursts. If you set intensity to 5 and period to 3600
(one hour), the supervisor will allow a short burst of 5
restarts, but then gives up if it sees another single restart
almost an hour later. You probably want to regard those crashes
as separate incidents, so setting the period to 5 or 10 minutes
will be more reasonable.</p> </li><li> <p>If your application has multiple levels of supervision, then
do not simply set the restart intensities to the same values on
all levels. Keep in mind that the total number of restarts
(before the top level supervisor gives up and terminates the
application) will be the product of the intensity values of all
the supervisors above the failing child process.</p> <p>For example, if the top level allows 10 restarts, and the next
level also allows 10, a crashing child below that level will be
restarted 100 times, which is probably excessive. Allowing at
most 3 restarts for the top level supervisor might be a better
choice in this case.</p> </li></ul><a name="spec"></a><h4>Child Specification</h4><p>The type definition for a child specification is as follows:</p><pre><code class="">
child_spec() = #{id =&gt; child_id(),       % mandatory
                 start =&gt; mfargs(),      % mandatory
                 restart =&gt; restart(),   % optional
                 shutdown =&gt; shutdown(), % optional
                 type =&gt; worker(),       % optional
                 modules =&gt; modules()}   % optional
    child_id() = term()
    mfargs() = {M :: module(), F :: atom(), A :: [term()]}
    modules() = [module()] | dynamic
    restart() = permanent | transient | temporary
    shutdown() = brutal_kill | timeout()
    worker() = worker | supervisor</code></pre><ul><li> <p><strong>id</strong> is used to identify the child
specification internally by the supervisor.</p> <p>The <strong>id</strong> key is mandatory.</p> <p>Note that this identifier occasionally has been called
"name". As far as possible, the terms "identifier" or "id"
are now used but in order to keep backwards compatibility,
some occurences of "name" can still be found, for example
in error messages.</p> </li><li> <p><strong>start</strong> defines the function call used to start
the child process. It is a module-function-arguments tuple
used as <strong>apply(M, F, A)</strong>.</p> <p>It is to be (or result in) a call to any of the following:</p> <ul><li><strong>supervisor:start_link</strong></li><li><strong>gen_server:start_link</strong></li><li><strong>gen_statem:start_link</strong></li><li><strong>gen_event:start_link</strong></li><li>A function compliant with these functions. For details, see the <strong>supervisor(3)</strong> manual page.</li></ul> <p>The <strong>start</strong> key is mandatory.</p> </li><li> <p><strong>restart</strong> defines when a terminated child process is to
be restarted.</p> <ul><li>A <strong>permanent</strong> child process is always restarted.</li><li>A <strong>temporary</strong> child process is never restarted (not even when the supervisor restart strategy is <strong>rest_for_one</strong> or <strong>one_for_all</strong> and a sibling death causes the temporary process to be terminated).</li><li>A <strong>transient</strong> child process is restarted only if it terminates abnormally, that is, with an exit reason other than <strong>normal</strong>, <strong>shutdown</strong>, or <strong>{shutdown,Term}</strong>.</li></ul> <p>The <strong>restart</strong> key is optional. If it is not given, the
default value <strong>permanent</strong> will be used.</p> </li><li> <a name="shutdown"></a> <p><strong>shutdown</strong> defines how a child process is to be
terminated.</p> <ul><li><strong>brutal_kill</strong> means that the child process is unconditionally terminated using <strong>exit(Child, kill)</strong>.</li><li>An integer time-out value means that the supervisor tells the child process to terminate by calling <strong>exit(Child, shutdown)</strong> and then waits for an exit signal back. If no exit signal is received within the specified time, the child process is unconditionally terminated using <strong>exit(Child, kill)</strong>.</li><li>If the child process is another supervisor, it must be set to <strong>infinity</strong> to give the subtree enough time to shut down. It is also allowed to set it to <strong>infinity</strong>, if the child process is a worker. See the warning below:</li></ul> <div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Setting the shutdown time to anything other
than <strong>infinity</strong> for a child of type <strong>supervisor</strong>
can cause a race condition where the child in question
unlinks its own children, but fails to terminate them
before it is killed.</p><p>Be careful when setting the shutdown time to
<strong>infinity</strong> when the child process is a worker. Because, in this
situation, the termination of the supervision tree depends on the
child process; it must be implemented in a safe way and its cleanup
procedure must always return.</p></div> <p>The <strong>shutdown</strong> key is optional. If it is not given,
and the child is of type <strong>worker</strong>, the default value
<strong>5000</strong> will be used; if the child is of type
<strong>supervisor</strong>, the default value <strong>infinity</strong> will be
used.</p> </li><li> <p><strong>type</strong> specifies if the child process is a supervisor or
a worker.</p> <p>The <strong>type</strong> key is optional. If it is not given, the
default value <strong>worker</strong> will be used.</p> </li><li> <p><strong>modules</strong> are to be a list with one element
<strong>[Module]</strong>, where <strong>Module</strong> is the name of
the callback module, if the child process is a supervisor,
gen_server, gen_statem.
If the child process is a gen_event,
the value shall be <strong>dynamic</strong>.</p> <p>This information is used by the release handler during
upgrades and downgrades, see
<a href="release_handling">Release Handling</a>.</p> <p>The <strong>modules</strong> key is optional. If it is not given, it
defaults to <strong>[M]</strong>, where <strong>M</strong> comes from the
child's start <strong>{M,F,A}</strong>.</p> </li></ul><p><em>Example:</em> The child specification to start the server
<strong>ch3</strong> in the previous example look as follows:</p><pre><code class="">
#{id =&gt; ch3,
  start =&gt; {ch3, start_link, []},
  restart =&gt; permanent,
  shutdown =&gt; brutal_kill,
  type =&gt; worker,
  modules =&gt; [ch3]}</code></pre><p>or simplified, relying on the default values:</p><pre><code class="">
#{id =&gt; ch3,
  start =&gt; {ch3, start_link, []}
  shutdown =&gt; brutal_kill}</code></pre><p>Example: A child specification to start the event manager from
the chapter about
<a href="./events#mgr">gen_event</a>:</p><pre><code class="">
#{id =&gt; error_man,
  start =&gt; {gen_event, start_link, [{local, error_man}]},
  modules =&gt; dynamic}</code></pre><p>Both server and event manager are registered processes which
can be expected to be always accessible. Thus they are
specified to be <strong>permanent</strong>.</p><p><strong>ch3</strong> does not need to do any cleaning up before
termination. Thus, no shutdown time is needed, but
<strong>brutal_kill</strong> is sufficient. <strong>error_man</strong> can
need some time for the event handlers to clean up, thus
the shutdown time is set to 5000 ms (which is the default
value).</p><p>Example: A child specification to start another supervisor:</p><pre><code class="">
#{id =&gt; sup,
  start =&gt; {sup, start_link, []},
  restart =&gt; transient,
  type =&gt; supervisor} % will cause default shutdown=&gt;infinity</code></pre><a name="super_tree"></a><h4>Starting a Supervisor</h4><p>In the previous example, the supervisor is started by calling
<strong>ch_sup:start_link()</strong>:</p><pre><code class="">
start_link() -&gt;
    supervisor:start_link(ch_sup, []).</code></pre><p><strong>ch_sup:start_link</strong> calls function
<strong>supervisor:start_link/2</strong>, which spawns and links to a new
process, a supervisor.</p><ul><li>The first argument, <strong>ch_sup</strong>, is the name of the callback module, that is, the module where the <strong>init</strong> callback function is located.</li><li>The second argument, <strong>[]</strong>, is a term that is passed as is to the callback function <strong>init</strong>. Here, <strong>init</strong> does not need any indata and ignores the argument.</li></ul><p>In this case, the supervisor is not registered. Instead its pid
must be used. A name can be specified by calling
<strong>supervisor:start_link({local, Name}, Module, Args)</strong> or
<strong>supervisor:start_link({global, Name}, Module, Args)</strong>.</p><p>The new supervisor process calls the callback function
<strong>ch_sup:init([])</strong>. <strong>init</strong> shall return
<strong>{ok, {SupFlags, ChildSpecs}}</strong>:</p><pre><code class="">
init(_Args) -&gt;
    SupFlags = #{},
    ChildSpecs = [#{id =&gt; ch3,
                    start =&gt; {ch3, start_link, []},
                    shutdown =&gt; brutal_kill}],
    {ok, {SupFlags, ChildSpecs}}.</code></pre><p>The supervisor then starts all its child processes according to
the child specifications in the start specification. In this case
there is one child process, <strong>ch3</strong>.</p><p><strong>supervisor:start_link</strong> is synchronous. It does
not return until all child processes have been started.</p><h4>Adding a Child Process</h4><p>In addition to the static supervision tree, dynamic child
processes can be added to an existing supervisor with the following
call:</p><pre><code class="">
supervisor:start_child(Sup, ChildSpec)</code></pre><p><strong>Sup</strong> is the pid, or name, of the supervisor.
<strong>ChildSpec</strong> is a
<a href="#spec">child specification</a>.</p><p>Child processes added using <strong>start_child/2</strong> behave in
the same way as the other child processes, with the an important
exception: if a supervisor dies and is recreated, then
all child processes that were dynamically added to the supervisor
are lost.</p><h4>Stopping a Child Process</h4><p>Any child process, static or dynamic, can be stopped in
accordance with the shutdown specification:</p><pre><code class="">
supervisor:terminate_child(Sup, Id)</code></pre><p>The child specification for a stopped child process is deleted
with the following call:</p><pre><code class="">
supervisor:delete_child(Sup, Id)</code></pre><p><strong>Sup</strong> is the pid, or name, of the supervisor.
<strong>Id</strong> is the value associated with the <strong>id</strong> key in
the <a href="#spec">child specification</a>.</p><p>As with dynamically added child processes, the effects of
deleting a static child process is lost if the supervisor itself
restarts.</p><a name="simple"></a><h4>Simplified one_for_one Supervisors</h4><p>A supervisor with restart strategy <strong>simple_one_for_one</strong> is
a simplified <strong>one_for_one</strong> supervisor, where all child
processes are dynamically added instances of the same process.</p><p>The following is an example of a callback module for a
<strong>simple_one_for_one</strong> supervisor:</p><pre><code class="">
-module(simple_sup).
-behaviour(supervisor).

-export([start_link/0]).
-export([init/1]).

start_link() -&gt;
    supervisor:start_link(simple_sup, []).

init(_Args) -&gt;
    SupFlags = #{strategy =&gt; simple_one_for_one,
                 intensity =&gt; 0,
                 period =&gt; 1},
    ChildSpecs = [#{id =&gt; call,
                    start =&gt; {call, start_link, []},
                    shutdown =&gt; brutal_kill}],
    {ok, {SupFlags, ChildSpecs}}.</code></pre><p>When started, the supervisor does not start any child processes.
Instead, all child processes are added dynamically by calling:</p><pre><code class="">
supervisor:start_child(Sup, List)</code></pre><p><strong>Sup</strong> is the pid, or name, of the supervisor.
<strong>List</strong> is an arbitrary list of terms, which are added to
the list of arguments specified in the child specification. If
the start function is specified as <strong>{M, F, A}</strong>,
the child process is started by calling
<strong>apply(M, F, A++List)</strong>.</p><p>For example, adding a child to <strong>simple_sup</strong> above:</p><pre><code class="">
supervisor:start_child(Pid, [id1])</code></pre><p>The result is that the child process is started by calling
<strong>apply(call, start_link, []++[id1])</strong>, or actually:</p><pre><code class="">
call:start_link(id1)</code></pre><p>A child under a <strong>simple_one_for_one</strong> supervisor can be
terminated with the following:</p><pre><code class="">
supervisor:terminate_child(Sup, Pid)</code></pre><p><strong>Sup</strong> is the pid, or name, of the supervisor and
<strong>Pid</strong> is the pid of the child.</p><p>Because a <strong>simple_one_for_one</strong> supervisor can have many
children, it shuts them all down asynchronously. This means that
the children will do their cleanup in parallel and therefore the
order in which they are stopped is not defined.</p><h4>Stopping</h4><p>Since the supervisor is part of a supervision tree, it is
automatically terminated by its supervisor. When asked to
shut down, it terminates all child processes in reversed start
order according to the respective shutdown specifications, and
then terminates itself.</p><a name="sys and proc_lib"></a><p>The <strong>sys</strong> module has functions for simple debugging of
processes implemented using behaviours. It also has functions that,
together with functions in the <strong>proc_lib</strong> module, can be used
to implement a <em>special process</em> that complies to the OTP
design principles without using a standard behaviour. These
functions can also be used to implement user-defined (non-standard)
behaviours.</p><p>Both <strong>sys</strong> and <strong>proc_lib</strong> belong to the STDLIB
application.</p><h4>Simple Debugging</h4><p>The <strong>sys</strong> module has functions for simple debugging of
processes implemented using behaviours. The <strong>code_lock</strong>
example from
<a href="./statem#Example">gen_statem Behaviour</a>
is used to illustrate this:</p><pre>
Erlang/OTP 20 [DEVELOPMENT] [erts-9.0] [source-5ace45e] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V9.0  (abort with ^G)
1&gt;  code_lock:start_link([1,2,3,4]).
Lock
{ok,&lt;0.63.0&gt;}
2&gt; sys:statistics(code_lock, true).
ok
3&gt;  sys:trace(code_lock, true).
ok
4&gt;  code_lock:button(1).
*DBG* code_lock receive cast {button,1} in state locked
ok
*DBG* code_lock consume cast {button,1} in state locked
5&gt;  code_lock:button(2).
*DBG* code_lock receive cast {button,2} in state locked
ok
*DBG* code_lock consume cast {button,2} in state locked
6&gt;  code_lock:button(3).
*DBG* code_lock receive cast {button,3} in state locked
ok
*DBG* code_lock consume cast {button,3} in state locked
7&gt;  code_lock:button(4).
*DBG* code_lock receive cast {button,4} in state locked
ok
Unlock
*DBG* code_lock consume cast {button,4} in state locked
*DBG* code_lock receive state_timeout lock in state open
Lock
*DBG* code_lock consume state_timeout lock in state open
8&gt; sys:statistics(code_lock, get).
{ok,[{start_time,{{2017,4,21},{16,8,7}}},
     {current_time,{{2017,4,21},{16,9,42}}},
     {reductions,2973},
     {messages_in,5},
     {messages_out,0}]}
9&gt; sys:statistics(code_lock, false).
ok
10&gt; sys:trace(code_lock, false).
ok
11&gt; sys:get_status(code_lock).
{status,&lt;0.63.0&gt;,
        {module,gen_statem},
        [[{'$initial_call',{code_lock,init,1}},
          {'$ancestors',[&lt;0.61.0&gt;]}],
         running,&lt;0.61.0&gt;,[],
         [{header,"Status for state machine code_lock"},
          {data,[{"Status",running},
                 {"Parent",&lt;0.61.0&gt;},
                 {"Logged Events",[]},
                 {"Postponed",[]}]},
          {data,[{"State",
                  {locked,#{code =&gt; [1,2,3,4],remaining =&gt; [1,2,3,4]}}}]}]]}
    </pre><h4>Special Processes</h4><p>This section describes how to write a process that complies to
the OTP design principles, without using a standard behaviour.
Such a process is to:</p><ul><li>Be started in a way that makes the process fit into a supervision tree</li><li>Support the <strong>sys</strong> <a href="#debug">debug facilities</a></li><li>Take care of <a href="#msg">system messages</a>.</li></ul><p>System messages are messages with a special meaning, used in
the supervision tree. Typical system messages are requests for
trace output, and requests to suspend or resume process execution
(used during release handling). Processes implemented using
standard behaviours automatically understand these messages.</p><h4>Example</h4><p>The simple server from
<a href="./des_princ#ch1">Overview</a>,
implemented using <strong>sys</strong> and <strong>proc_lib</strong> so it fits into a
supervision tree:</p><a name="ex"></a><pre>
-module(ch4).
-export([start_link/0]).
-export([alloc/0, free/1]).
-export([init/1]).
-export([system_continue/3, system_terminate/4,
         write_debug/3,
         system_get_state/1, system_replace_state/2]).

start_link() -&gt;
    proc_lib:start_link(ch4, init, [self()]).

alloc() -&gt;
    ch4 ! {self(), alloc},
    receive
        {ch4, Res} -&gt;
            Res
    end.

free(Ch) -&gt;
    ch4 ! {free, Ch},
    ok.

init(Parent) -&gt;
    register(ch4, self()),
    Chs = channels(),
    Deb = sys:debug_options([]),
    proc_lib:init_ack(Parent, {ok, self()}),
    loop(Chs, Parent, Deb).

loop(Chs, Parent, Deb) -&gt;
    receive
        {From, alloc} -&gt;
            Deb2 = sys:handle_debug(Deb, fun ch4:write_debug/3,
                                    ch4, {in, alloc, From}),
            {Ch, Chs2} = alloc(Chs),
            From ! {ch4, Ch},
            Deb3 = sys:handle_debug(Deb2, fun ch4:write_debug/3,
                                    ch4, {out, {ch4, Ch}, From}),
            loop(Chs2, Parent, Deb3);
        {free, Ch} -&gt;
            Deb2 = sys:handle_debug(Deb, fun ch4:write_debug/3,
                                    ch4, {in, {free, Ch}}),
            Chs2 = free(Ch, Chs),
            loop(Chs2, Parent, Deb2);

        {system, From, Request} -&gt;
            sys:handle_system_msg(Request, From, Parent,
                                  ch4, Deb, Chs)
    end.

system_continue(Parent, Deb, Chs) -&gt;
    loop(Chs, Parent, Deb).

system_terminate(Reason, _Parent, _Deb, _Chs) -&gt;
    exit(Reason).

system_get_state(Chs) -&gt;
    {ok, Chs}.

system_replace_state(StateFun, Chs) -&gt;
    NChs = StateFun(Chs),
    {ok, NChs, NChs}.

write_debug(Dev, Event, Name) -&gt;
    io:format(Dev, "~p event = ~p~n", [Name, Event]).</pre><p>Example on how the simple debugging functions in the <strong>sys</strong>
module can also be used for <strong>ch4</strong>:</p><pre>
% <span class="input">erl</span>
Erlang (BEAM) emulator version 5.2.3.6 [hipe] [threads:0]

Eshell V5.2.3.6  (abort with ^G)
1&gt; <span class="input">ch4:start_link().</span>
{ok,&lt;0.30.0&gt;}
2&gt; <span class="input">sys:statistics(ch4, true).</span>
ok
3&gt; <span class="input">sys:trace(ch4, true).</span>
ok
4&gt; <span class="input">ch4:alloc().</span>
ch4 event = {in,alloc,&lt;0.25.0&gt;}
ch4 event = {out,{ch4,ch1},&lt;0.25.0&gt;}
ch1
5&gt; <span class="input">ch4:free(ch1).</span>
ch4 event = {in,{free,ch1}}
ok
6&gt; <span class="input">sys:statistics(ch4, get).</span>
{ok,[{start_time,{{2003,6,13},{9,47,5}}},
     {current_time,{{2003,6,13},{9,47,56}}},
     {reductions,109},
     {messages_in,2},
     {messages_out,1}]}
7&gt; <span class="input">sys:statistics(ch4, false).</span>
ok
8&gt; <span class="input">sys:trace(ch4, false).</span>
ok
9&gt; <span class="input">sys:get_status(ch4).</span>
{status,&lt;0.30.0&gt;,
        {module,ch4},
        [[{'$ancestors',[&lt;0.25.0&gt;]},{'$initial_call',{ch4,init,[&lt;0.25.0&gt;]}}],
         running,&lt;0.25.0&gt;,[],
         [ch1,ch2,ch3]]}</pre><h4>Starting the Process</h4><p>A function in the <strong>proc_lib</strong> module is to be used to
start the process. Several functions are available, for
example, <strong>spawn_link/3,4</strong> for asynchronous start and
<strong>start_link/3,4,5</strong> for synchronous start.</p><p>A process started using one of these functions stores
information (for example, about the ancestors and initial call)
that is needed for a process in a supervision tree.</p><p>If the process terminates with another reason than
<strong>normal</strong> or <strong>shutdown</strong>, a crash report is generated.
For more information about the crash report, see the SASL
User's Guide.</p><p>In the example, synchronous start is used. The process
starts by calling <strong>ch4:start_link()</strong>:</p><pre><code class="">
start_link() -&gt;
    proc_lib:start_link(ch4, init, [self()]).</code></pre><p><strong>ch4:start_link</strong> calls the function
<strong>proc_lib:start_link</strong>. This function takes a module name,
a function name, and an argument list as arguments, spawns,
and links to a new process. The new process starts by executing
the given function, here <strong>ch4:init(Pid)</strong>, where
<strong>Pid</strong> is the pid (<strong>self()</strong>) of the first process,
which is the parent process.</p><p>All initialization, including name registration, is done in
<strong>init</strong>. The new process must also acknowledge that it has
been started to the parent:</p><pre><code class="">
init(Parent) -&gt;
    ...
    proc_lib:init_ack(Parent, {ok, self()}),
    loop(...).</code></pre><p><strong>proc_lib:start_link</strong> is synchronous and does not return
until <strong>proc_lib:init_ack</strong> has been called.</p><a name="debug"></a><h4>Debugging</h4><p>To support the debug facilites in <strong>sys</strong>, a
<em>debug structure</em> is needed. The <strong>Deb</strong> term is
initialized using <strong>sys:debug_options/1</strong>:</p><pre><code class="">
init(Parent) -&gt;
    ...
    Deb = sys:debug_options([]),
    ...
    loop(Chs, Parent, Deb).</code></pre><p><strong>sys:debug_options/1</strong> takes a list of options as argument.
Here the list is empty, which means no debugging is enabled
initially. For information about the possible options, see the
<strong>sys(3)</strong> manual page in STDLIB.</p><p>Then, for each <em>system event</em> to be logged
or traced, the following function is to be called.</p><pre><code class="">
sys:handle_debug(Deb, Func, Info, Event) =&gt; Deb1</code></pre><p>Here:</p><ul><li><strong>Deb</strong> is the debug structure.</li><li><strong>Func</strong> is a fun specifying a (user-defined) function used to format trace output. For each system event, the format function is called as <strong>Func(Dev, Event, Info)</strong>, where: <ul><li><strong>Dev</strong> is the I/O device to which the output is to be printed. See the <strong>io(3)</strong> manual page in STDLIB.</li><li><strong>Event</strong> and <strong>Info</strong> are passed as is from <strong>handle_debug</strong>.</li></ul> </li><li><strong>Info</strong> is used to pass more information to <strong>Func</strong>. It can be any term and is passed as is.</li><li><strong>Event</strong> is the system event. It is up to the user to define what a system event is and how it is to be represented. Typically at least incoming and outgoing messages are considered system events and represented by the tuples <strong>{in,Msg[,From]}</strong> and <strong>{out,Msg,To[,State]}</strong>, respectively.</li></ul><p><strong>handle_debug</strong> returns an updated debug structure
<strong>Deb1</strong>.</p><p>In the example, <strong>handle_debug</strong> is called for each incoming
and outgoing message. The format function <strong>Func</strong> is
the function <strong>ch4:write_debug/3</strong>, which prints the message
using <strong>io:format/3</strong>.</p><pre><code class="">
loop(Chs, Parent, Deb) -&gt;
    receive
        {From, alloc} -&gt;
            Deb2 = sys:handle_debug(Deb, fun ch4:write_debug/3,
                                    ch4, {in, alloc, From}),
            {Ch, Chs2} = alloc(Chs),
            From ! {ch4, Ch},
            Deb3 = sys:handle_debug(Deb2, fun ch4:write_debug/3,
                                    ch4, {out, {ch4, Ch}, From}),
            loop(Chs2, Parent, Deb3);
        {free, Ch} -&gt;
            Deb2 = sys:handle_debug(Deb, fun ch4:write_debug/3,
                                    ch4, {in, {free, Ch}}),
            Chs2 = free(Ch, Chs),
            loop(Chs2, Parent, Deb2);
        ...
    end.

write_debug(Dev, Event, Name) -&gt;
    io:format(Dev, "~p event = ~p~n", [Name, Event]).</code></pre><a name="msg"></a><h4>Handling System Messages</h4><p><em>System messages</em> are received as:</p><pre><code class="">
{system, From, Request}</code></pre><p>The content and meaning of these messages do not need to be
interpreted by the process. Instead the following function
is to be called:</p><pre><code class="">
sys:handle_system_msg(Request, From, Parent, Module, Deb, State)</code></pre><p>This function does not return. It handles the system
message and then either calls the following if process execution is
to continue:</p><pre><code class="">
Module:system_continue(Parent, Deb, State)</code></pre><p>Or calls the following if the process is to terminate:</p><pre><code class="">
Module:system_terminate(Reason, Parent, Deb, State)</code></pre><p>A process in a supervision tree is expected to terminate with
the same reason as its parent.</p><ul><li><strong>Request</strong> and <strong>From</strong> are to be passed as is from the system message to the call to <strong>handle_system_msg</strong>.</li><li><strong>Parent</strong> is the pid of the parent.</li><li><strong>Module</strong> is the name of the module.</li><li><strong>Deb</strong> is the debug structure.</li><li><strong>State</strong> is a term describing the internal state and is passed to <strong>system_continue</strong>/<strong>system_terminate</strong>/ <strong>system_get_state</strong>/<strong>system_replace_state</strong>.</li></ul><p>If the process is to return its state, <strong>handle_system_msg</strong>
calls:</p><pre><code class="">
Module:system_get_state(State)</code></pre><p>If the process is to replace its state using the fun <strong>StateFun</strong>,
<strong>handle_system_msg</strong> calls:</p><pre><code class="">
Module:system_replace_state(StateFun, State)</code></pre><p>In the example:</p><pre><code class="">
loop(Chs, Parent, Deb) -&gt;
    receive
        ...

        {system, From, Request} -&gt;
            sys:handle_system_msg(Request, From, Parent,
                                  ch4, Deb, Chs)
    end.

system_continue(Parent, Deb, Chs) -&gt;
    loop(Chs, Parent, Deb).

system_terminate(Reason, Parent, Deb, Chs) -&gt;
    exit(Reason).

system_get_state(Chs) -&gt;
    {ok, Chs, Chs}.

system_replace_state(StateFun, Chs) -&gt;
    NChs = StateFun(Chs),
    {ok, NChs, NChs}.
</code></pre><p>If the special process is set to trap exits and if the parent
process terminates, the expected behavior is to terminate with
the same reason:</p><pre><code class="">
init(...) -&gt;
    ...,
    process_flag(trap_exit, true),
    ...,
    loop(...).

loop(...) -&gt;
    receive
        ...

        {'EXIT', Parent, Reason} -&gt;
            ..maybe some cleaning up here..
            exit(Reason);
        ...
    end.</code></pre><h4>User-Defined Behaviours</h4><p><a name="behaviours"></a>To implement a user-defined behaviour,
write code similar to
code for a special process, but call functions in a callback
module for handling specific tasks.</p><p>If the compiler is to warn for missing callback functions, as it
does for the OTP behaviours, add <strong>-callback</strong> attributes in the
behaviour module to describe the expected callbacks:</p><pre><code class="">
-callback Name1(Arg1_1, Arg1_2, ..., Arg1_N1) -&gt; Res1.
-callback Name2(Arg2_1, Arg2_2, ..., Arg2_N2) -&gt; Res2.
...
-callback NameM(ArgM_1, ArgM_2, ..., ArgM_NM) -&gt; ResM.</code></pre><p><strong>NameX</strong> are the names of the expected callbacks.
<strong>ArgX_Y</strong> and <strong>ResX</strong> are types as they are described in
<a href="../reference_manual/typespec">Types and Function Specifications</a>. The whole syntax of the <strong>-spec</strong>
attribute is supported by the <strong>-callback</strong> attribute.</p><p>Callback functions that are optional for the user of the
behaviour to implement are specified by use of the
<strong>-optional_callbacks</strong> attribute:</p><pre><code class="">
-optional_callbacks([OptName1/OptArity1, ..., OptNameK/OptArityK]).</code></pre><p>where each <strong>OptName/OptArity</strong> specifies the name and arity
of a callback function. Note that the <strong>-optional_callbacks</strong>
attribute is to be used together with the <strong>-callback</strong>
attribute; it cannot be combined with the
<strong>behaviour_info()</strong> function described below.</p><p>Tools that need to know about optional callback functions can
call <strong>Behaviour:behaviour_info(optional_callbacks)</strong> to get
a list of all optional callback functions.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>We recommend using the <strong>-callback</strong> attribute rather
than the <strong>behaviour_info()</strong> function. The reason is that
the extra type information can be used by tools to produce
documentation or find discrepancies.</p></div><p>As an alternative to the <strong>-callback</strong> and
<strong>-optional_callbacks</strong> attributes you may directly implement
and export <strong>behaviour_info()</strong>:</p><pre><code class="">
behaviour_info(callbacks) -&gt;
    [{Name1, Arity1},...,{NameN, ArityN}].</code></pre><p>where each <strong>{Name, Arity}</strong> specifies the name and arity of
a callback function. This function is otherwise automatically
generated by the compiler using the <strong>-callback</strong>
attributes.</p><p>When the compiler encounters the module attribute
<strong>-behaviour(Behaviour).</strong> in a module <strong>Mod</strong>, it
calls <strong>Behaviour:behaviour_info(callbacks)</strong> and compares the
result with the set of functions actually exported from
<strong>Mod</strong>, and issues a warning if any callback function is
missing.</p><p>Example:</p><pre><code class="">
%% User-defined behaviour module
-module(simple_server).
-export([start_link/2, init/3, ...]).

-callback init(State :: term()) -&gt; 'ok'.
-callback handle_req(Req :: term(), State :: term()) -&gt; {'ok', Reply :: term()}.
-callback terminate() -&gt; 'ok'.
-callback format_state(State :: term()) -&gt; term().

-optional_callbacks([format_state/1]).

%% Alternatively you may define:
%%
%% -export([behaviour_info/1]).
%% behaviour_info(callbacks) -&gt;
%%     [{init,1},
%%      {handle_req,2},
%%      {terminate,0}].

start_link(Name, Module) -&gt;
    proc_lib:start_link(?MODULE, init, [self(), Name, Module]).

init(Parent, Name, Module) -&gt;
    register(Name, self()),
    ...,
    Dbg = sys:debug_options([]),
    proc_lib:init_ack(Parent, {ok, self()}),
    loop(Parent, Module, Deb, ...).

...</code></pre><p>In a callback module:</p><pre><code class="">
-module(db).
-behaviour(simple_server).

-export([init/1, handle_req/2, terminate/0]).

...</code></pre><p>The contracts specified with <strong>-callback</strong> attributes in
behaviour modules can be further refined by adding <strong>-spec</strong>
attributes in callback modules. This can be useful as
<strong>-callback</strong> contracts are usually generic. The same callback
module with contracts for the callbacks:</p><pre><code class="">
-module(db).
-behaviour(simple_server).

-export([init/1, handle_req/2, terminate/0]).

-record(state, {field1 :: [atom()], field2 :: integer()}).

-type state()   :: #state{}.
-type request() :: {'store', term(), term()};
                   {'lookup', term()}.

...

-spec handle_req(request(), state()) -&gt; {'ok', term()}.

...</code></pre><p>Each <strong>-spec</strong> contract is to be a subtype of the respective
<strong>-callback</strong> contract.</p><a name="appl"></a><p>This section is to be read with the <strong>app(4)</strong> and
<strong>application(3)</strong> manual pages in Kernel.</p><h4>Application Concept</h4><p>When you have written code implementing some specific functionality
you might want to make the code into an <em>application</em>,
that is, a component that can be started and stopped as a unit,
and which can also be reused in other systems.</p><p>To do this, create an
<a href="#callback_module">application callback module</a>,
and describe how the application is to be started and stopped.</p><p>Then, an <em>application specification</em> is needed, which is
put in an
<a href="#appl_res_file">application resource file</a>.
Among other things, this file specifies which modules the application
consists of and the name of the callback module.</p><p>If you use <strong>systools</strong>, the Erlang/OTP tools for packaging code
(see <a href="release_structure">Releases</a>),
the code for each application is placed in a
separate directory following a pre-defined
<a href="#app_dir">directory structure</a>.</p><a name="callback_module"></a><h4>Application Callback Module</h4><p>How to start and stop the code for the application, that is,
the supervision tree, is described by two callback functions:</p><pre><code class="">
start(StartType, StartArgs) -&gt; {ok, Pid} | {ok, Pid, State}
stop(State)
    </code></pre><ul><li><strong>start</strong> is called when starting the application and is to create the supervision tree by starting the top supervisor. It is expected to return the pid of the top supervisor and an optional term, <strong>State</strong>, which defaults to <strong>[]</strong>. This term is passed as is to <strong>stop</strong>.</li><li><strong>StartType</strong> is usually the atom <strong>normal</strong>. It has other values only in the case of a takeover or failover, see <a href="distributed_applications">Distributed Applications</a>. </li><li><strong>StartArgs</strong> is defined by the key <strong>mod</strong> in the <a href="#appl_res_file">application resource file</a>.</li><li><strong>stop/1</strong> is called <em>after</em> the application has been stopped and is to do any necessary cleaning up. The actual stopping of the application, that is, the shutdown of the supervision tree, is handled automatically as described in <a href="#stopping">Starting and Stopping Applications</a>. </li></ul><a name="ch_app"></a><p>Example of an application callback module for packaging
the supervision tree from
<a href="./sup_princ#ex">Supervisor Behaviour</a>:</p><pre><code class="">
-module(ch_app).
-behaviour(application).

-export([start/2, stop/1]).

start(_Type, _Args) -&gt;
    ch_sup:start_link().

stop(_State) -&gt;
    ok.</code></pre><p>A library application that cannot be started or stopped, does not
need any application callback module.</p><a name="appl_res_file"></a><h4>Application Resource File</h4><p>To define an application, an <em>application specification</em> is
created, which is put in an <em>application resource file</em>, or in
short an <strong>.app</strong> file:</p><pre><code class="">
{application, Application, [Opt1,...,OptN]}.</code></pre><ul><li><strong>Application</strong>, an atom, is the name of the application. The file must be named <strong>Application.app</strong>.</li><li>Each <strong>Opt</strong> is a tuple <strong>{Key,Value}</strong>, which define a certain property of the application. All keys are optional. Default values are used for any omitted keys.</li></ul><p>The contents of a minimal <strong>.app</strong> file for a library
application <strong>libapp</strong> looks as follows:</p><pre><code class="">
{application, libapp, []}.</code></pre><p>The contents of a minimal <strong>.app</strong> file <strong>ch_app.app</strong> for
a supervision tree application like <strong>ch_app</strong> looks as follows:</p><pre><code class="">
{application, ch_app,
 [{mod, {ch_app,[]}}]}.</code></pre><p>The key <strong>mod</strong> defines the callback module and start argument of
the application, in this case <strong>ch_app</strong> and <strong>[]</strong>, respectively.
This means that the following is called when the application is to be
started:</p><pre><code class="">
ch_app:start(normal, [])</code></pre><p>The following is called when the application is stopped.</p><pre><code class="">
ch_app:stop([])</code></pre><p>When using <strong>systools</strong>, the Erlang/OTP tools for packaging
code (see Section
<a href="release_structure">Releases</a>), the keys
<strong>description</strong>, <strong>vsn</strong>, <strong>modules</strong>, <strong>registered</strong>,
and <strong>applications</strong> are also to be specified:</p><pre><code class="">
{application, ch_app,
 [{description, "Channel allocator"},
  {vsn, "1"},
  {modules, [ch_app, ch_sup, ch3]},
  {registered, [ch3]},
  {applications, [kernel, stdlib, sasl]},
  {mod, {ch_app,[]}}
 ]}.</code></pre><ul><li><strong>description</strong> - A short description, a string. Defaults to "".</li><li><strong>vsn</strong> - Version number, a string. Defaults to "".</li><li><strong>modules</strong> - All modules <em>introduced</em> by this application. <strong>systools</strong> uses this list when generating boot scripts and tar files. A module must be defined in only one application. Defaults to <strong>[]</strong>.</li><li><strong>registered</strong> - All names of registered processes in the application. <strong>systools</strong> uses this list to detect name clashes between applications. Defaults to <strong>[]</strong>.</li><li><strong>applications</strong> - All applications that must be started before this application is started. <strong>systools</strong> uses this list to generate correct boot scripts. Defaults to <strong>[]</strong>. Notice that all applications have dependencies to at least Kernel and STDLIB.</li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>For details about the syntax and contents of the application
resource file, see the <a href="./app">app</a>
manual page in Kernel.</p></div><a name="app_dir"></a><h4>Directory Structure</h4><p>When packaging code using <strong>systools</strong>, the code for each
application is placed in a separate directory,
<strong>lib/Application-Vsn</strong>, where <strong>Vsn</strong> is the version number.</p><p>This can be useful to know, even if <strong>systools</strong> is not used,
since Erlang/OTP is packaged according to the OTP principles
and thus comes with a specific directory structure. The code server
(see the  <a href="./code">kernel/code</a> manual
page in Kernel) automatically uses code from
the directory with the highest version number, if more than one
version of an application is present.</p><h4>Directory Structure Guidelines for a Development Environment</h4><p>Any directory structure for development will suffice as long as the released directory structure
adhere to the <a href="#app_dir_released">description below</a>,
but it is encouraged that the same directory structure
also be used in a development environment. The version number should be omitted from the
application directory name since this is an artifact of the release step.
</p><p> Some sub-directories are <em>required</em>. Some sub-directories are <em>optional</em>, meaning that it should
only be used if the application itself requires it. Finally, some sub-directories are <em>recommended</em>,
meaning it is encouraged that it is used and used as described here. For example, both documentation
and tests are encouraged to exist in an application for it to be deemed a proper OTP application.</p><pre><code class="">
     ${application}
      doc
        internal
        examples
        src
      include
      priv
      src
         ${application}.app.src
      test
</code></pre><ul><li><strong>src</strong> - Required. Contains the Erlang source code, the source of the <strong>.app</strong> file and internal include files used by the application itself. Additional sub-directories within <strong>src</strong> can be used as namespaces to organize source files. These directories should never be deeper than one level.</li><li><strong>priv</strong> - Optional. Used for application specific files. </li><li><strong>include</strong> - Optional. Used for public include files that must be reachable from other applications.</li><li><strong>doc</strong> - Recommended. Any source documentation should be placed in sub-directories here.</li><li><strong>doc/internal</strong> - Recommended. Any documentation that describes implementation details about this application, not intended for publication, should be placed here.</li><li><strong>doc/examples</strong> - Recommended. Source code for examples on how to use this application should be placed here. It is encouraged that examples are sourced to the public documentation from this directory.</li><li><strong>doc/src</strong> - Recommended. All source files for documentation, such as Markdown, AsciiDoc or XML-files, should be placed here.</li><li><strong>test</strong> - Recommended. All files regarding tests, such as test suites and test specifications, should be placed here. </li></ul><p>Other directories in the development environment may be needed. If source code from languages other
than Erlang is used, for instance C-code for NIFs, that code should be placed in a separate directory.
By convention it is recommended to prefix such directories with the language name, for example
<strong>c_src</strong> for C, <strong>java_src</strong> for Java or <strong>go_src</strong> for Go. Directories with <strong>_src</strong>
suffix indicates that it is a part of the application and the compilation step. The final build artifacts
should target the <strong>priv/lib</strong> or <strong>priv/bin</strong> directories.</p><p>The <strong>priv</strong> directory holds assets that the application needs during runtime. Executables should
reside in <strong>priv/bin</strong> and dynamically-linked libraries should reside in <strong>priv/lib</strong>. Other assets
are free to reside within the <strong>priv</strong> directory but it is recommended it does so in a structured manner.</p><p>Source files from other languages that generate Erlang code, such as ASN.1 or Mibs, should be placed
in directories, at the top level or in <strong>src</strong>, with the same name as the source language, for example
<strong>asn1</strong> and <strong>mibs</strong>. Build artifacts should be placed in their respective language directory,
such as <strong>src</strong> for Erlang code or <strong>java_src</strong> for Java code.</p><p>The <strong>.app</strong> file for release may reside in the <strong>ebin</strong>-directory in a development environment
but it is encouraged that this is an artifact of the build step. By convention a <strong>.app.src</strong> file
is used, which resides in the <strong>src</strong> directory. This file is nearly identical as the
<strong>.app</strong> file but certain fields may be replaced during the build step, such as the application version.</p><p>Directory names should not be capitalized.</p><p>It is encouraged to omit empty directories.</p><a name="app_dir_released"></a><h4>Directory Structure for a Released System</h4><p>A released application must follow a certain structure.
</p><pre><code class="">
     ${application}-${version}
      bin
      doc
        html
        man[1-9]
        pdf
        internal
        examples
      ebin
        ${application}.app
      include
      priv
        lib
        bin
      src
</code></pre><ul><li><strong>src</strong> - Optional. Contains the Erlang source code and internal include files used by the application itself. This directory is no longer required in a released application.</li><li><strong>ebin</strong> - Required. Contains the Erlang object code, the <strong>beam</strong> files. The <strong>.app</strong> file must also be placed here.</li><li><strong>priv</strong> - Optional. Used for application specific files. <strong>code:priv_dir/1</strong> is to be used to access this directory.</li><li><strong>priv/lib</strong> - Recommended. Any shared-object files that are used by the application, such as NIFs or linked-in-drivers, should be placed here.</li><li><strong>priv/bin</strong> - Recommended. Any executable that is used by the application, such as port-programs, should be placed here.</li><li><strong>include</strong> - Optional. Used for public include files that must be reachable from other applications.</li><li><strong>bin</strong> - Optional. Any executable that is a product of the application, such as escripts or shell-scripts, should be placed here.</li><li><strong>doc</strong> - Optional. Any released documentation should be placed in sub-directories here.</li><li><strong>doc/man1</strong> - Recommended. Man pages for Application executables.</li><li><strong>doc/man3</strong> - Recommended. Man pages for module APIs.</li><li><strong>doc/man6</strong> - Recommended. Man pages for Application overview.</li><li><strong>doc/html</strong> - Optional. HTML pages for the entire Application.</li><li><strong>doc/pdf</strong> - Optional. PDF documentation for the entire Application.</li></ul><p>The <strong>src</strong> directory could be useful to release for debugging purposes but is not required.
The <strong>include</strong> directory should only be released if the applications has public include files.</p><p>The only documentation that is recommended to be released in this way are the man pages. HTML and PDF
will normally be distributed in some other manner.</p><p>It is encouraged to omit empty directories.</p><a name="application_controller"></a><h4>Application Controller</h4><p>When an Erlang runtime system is started, a number of processes
are started as part of the Kernel application. One of these
processes is the <em>application controller</em> process,
registered as <strong>application_controller</strong>.</p><p>All operations on applications are coordinated by the application
controller. It is interacted through the functions in
the module <strong>application</strong>, see the <strong>application(3)</strong>
manual page in Kernel. In particular, applications can be
loaded, unloaded, started, and stopped.</p><h4>Loading and Unloading Applications</h4><p>Before an application can be started, it must be <em>loaded</em>.
The application controller reads and stores the information from
the <strong>.app</strong> file:</p><pre>
1&gt; <span class="input">application:load(ch_app).</span>
ok
2&gt; <span class="input">application:loaded_applications().</span>
[{kernel,"ERTS  CXC 138 10","2.8.1.3"},
 {stdlib,"ERTS  CXC 138 10","1.11.4.3"},
 {ch_app,"Channel allocator","1"}]</pre><p>An application that has been stopped, or has never been started,
can be unloaded. The information about the application is
erased from the internal database of the application controller.</p><pre>
3&gt; <span class="input">application:unload(ch_app).</span>
ok
4&gt; <span class="input">application:loaded_applications().</span>
[{kernel,"ERTS  CXC 138 10","2.8.1.3"},
 {stdlib,"ERTS  CXC 138 10","1.11.4.3"}]</pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Loading/unloading an application does not load/unload the code
used by the application. Code loading is done the usual way.</p></div><a name="stopping"></a><h4>Starting and Stopping Applications</h4><p>An application is started by calling:</p><pre>
5&gt; <span class="input">application:start(ch_app).</span>
ok
6&gt; <span class="input">application:which_applications().</span>
[{kernel,"ERTS  CXC 138 10","2.8.1.3"},
 {stdlib,"ERTS  CXC 138 10","1.11.4.3"},
 {ch_app,"Channel allocator","1"}]</pre><p>If the application is not already loaded, the application
controller first loads it using <strong>application:load/1</strong>. It
checks the value of the <strong>applications</strong> key, to ensure
that all applications that are to be started before this
application are running.</p><a name="application_master"></a><p>The application controller then creates an
<em>application master</em> for the application. The application
master becomes the group leader of all the processes in the
application. I/O is forwarded to the previous group leader,
though, this is just a way to identify processes that belong to
the application. Used for example to find itself from any process,
or, reciprocally, to kill them all when it terminates.</p><p>The application master starts the application by calling
the application callback function <strong>start/2</strong> in the module,
and with the start argument, defined by the <strong>mod</strong> key in
the <strong>.app</strong> file.</p><p>An application is stopped, but not unloaded, by calling:</p><pre>
7&gt; <span class="input">application:stop(ch_app).</span>
ok</pre><p>The application master stops the application by telling the top
supervisor to shut down. The top supervisor tells all its child
processes to shut down, and so on; the entire tree is terminated in
reversed start order. The application master then calls
the application callback function <strong>stop/1</strong> in the module
defined by the <strong>mod</strong> key.</p><h4>Configuring an Application</h4><p>An application can be configured using
<em>configuration parameters</em>. These are a list of
<strong>{Par,Val}</strong> tuples
specified by a key <strong>env</strong> in the <strong>.app</strong> file:</p><pre><code class="">
{application, ch_app,
 [{description, "Channel allocator"},
  {vsn, "1"},
  {modules, [ch_app, ch_sup, ch3]},
  {registered, [ch3]},
  {applications, [kernel, stdlib, sasl]},
  {mod, {ch_app,[]}},
  {env, [{file, "/usr/local/log"}]}
 ]}.</code></pre><p><strong>Par</strong> is to be an atom. <strong>Val</strong> is any term.
The application can retrieve the value of a configuration
parameter by calling <strong>application:get_env(App, Par)</strong> or a
number of similar functions, see the <strong>application(3)</strong>
manual page in Kernel.</p><p><em>Example:</em></p><pre>
% <span class="input">erl</span>
Erlang (BEAM) emulator version 5.2.3.6 [hipe] [threads:0]

Eshell V5.2.3.6  (abort with ^G)
1&gt; <span class="input">application:start(ch_app).</span>
ok
2&gt; <span class="input">application:get_env(ch_app, file).</span>
{ok,"/usr/local/log"}</pre><p>The values in the <strong>.app</strong> file can be overridden by values
in a <em>system configuration file</em>. This is a file that
contains configuration parameters for relevant applications:</p><pre><code class="">
[{Application1, [{Par11,Val11},...]},
 ...,
 {ApplicationN, [{ParN1,ValN1},...]}].</code></pre><p>The system configuration is to be called <strong>Name.config</strong> and
Erlang is to be started with the command-line argument
<strong>-config Name</strong>. For details, see the <strong>config(4)</strong>
manual page in Kernel.</p><p><em>Example:</em></p><p>A file <strong>test.config</strong> is created with the following contents:</p><pre><code class="">
[{ch_app, [{file, "testlog"}]}].</code></pre><p>The value of <strong>file</strong> overrides the value of <strong>file</strong>
as defined in the <strong>.app</strong> file:</p><pre>
% <span class="input">erl -config test</span>
Erlang (BEAM) emulator version 5.2.3.6 [hipe] [threads:0]

Eshell V5.2.3.6  (abort with ^G)
1&gt; <span class="input">application:start(ch_app).</span>
ok
2&gt; <span class="input">application:get_env(ch_app, file).</span>
{ok,"testlog"}</pre><p>If
<a href="./release_handling#sys">release handling</a>
is used, exactly one system configuration file is to be used and
that file is to be called <strong>sys.config</strong>.</p><p>The values in the <strong>.app</strong> file and the values in a
system configuration file can be overridden directly from
the command line:</p><pre>
% <span class="input">erl -ApplName Par1 Val1 ... ParN ValN</span></pre><p><em>Example:</em></p><pre>
% <span class="input">erl -ch_app file '"testlog"'</span>
Erlang (BEAM) emulator version 5.2.3.6 [hipe] [threads:0]

Eshell V5.2.3.6  (abort with ^G)
1&gt; <span class="input">application:start(ch_app).</span>
ok
2&gt; <span class="input">application:get_env(ch_app, file).</span>
{ok,"testlog"}</pre><h4>Application Start Types</h4><p>A <em>start type</em> is defined when starting the application:</p><pre><code class="">
application:start(Application, Type)</code></pre><p><strong>application:start(Application)</strong> is the same as calling
<strong>application:start(Application, temporary)</strong>. The type can
also be <strong>permanent</strong> or <strong>transient</strong>:</p><ul><li>If a permanent application terminates, all other applications and the runtime system are also terminated.</li><li>If a transient application terminates with reason <strong>normal</strong>, this is reported but no other applications are terminated. If a transient application terminates abnormally, that is with any other reason than <strong>normal</strong>, all other applications and the runtime system are also terminated.</li><li>If a temporary application terminates, this is reported but no other applications are terminated.</li></ul><p>An application can always be stopped explicitly by
calling <strong>application:stop/1</strong>. Regardless of the mode, no
other applications are affected.</p><p>The transient mode is of little practical use, since when
a supervision tree terminates, the reason is set to
<strong>shutdown</strong>, not <strong>normal</strong>.</p><a name="included appl"></a><h4>Introduction</h4><p>An application can <em>include</em> other applications.
An <em>included application</em> has its own application directory
and <strong>.app</strong> file, but it is started as part of the supervisor
tree of another application.</p><p>An application can only be included by one other application.</p><p>An included application can include other applications.</p><p>An application that is not included by any other application is
called a <em>primary application</em>.</p><a name="inclappls"></a><img src="../design_principles/inclappls.gif" title="Primary Application and Included Applications"></img><p>The application controller automatically loads any included
applications when loading a primary application, but does not start
them. Instead, the top supervisor of the included application
must be started by a supervisor in the including application.</p><p>This means that when running, an included application is in fact
part of the primary application, and a process in an included
application considers itself belonging to the primary
application.</p><h4>Specifying Included Applications</h4><p>Which applications to include is defined by
the <strong>included_applications</strong> key in the <strong>.app</strong> file:</p><pre>
{application, prim_app,
 [{description, "Tree application"},
  {vsn, "1"},
  {modules, [prim_app_cb, prim_app_sup, prim_app_server]},
  {registered, [prim_app_server]},
  {included_applications, [incl_app]},
  {applications, [kernel, stdlib, sasl]},
  {mod, {prim_app_cb,[]}},
  {env, [{file, "/usr/local/log"}]}
 ]}.</pre><h4>Synchronizing Processes during Startup</h4><p>The supervisor tree of an included application is started as
part of the supervisor tree of the including application.
If there is a need for synchronization between processes in
the including and included applications, this can be achieved
by using <em>start phases</em>.</p><p>Start phases are defined by the <strong>start_phases</strong> key in
the <strong>.app</strong> file as a list of tuples <strong>{Phase,PhaseArgs}</strong>,
where <strong>Phase</strong> is an atom and <strong>PhaseArgs</strong> is a term.</p><p>The value of the <strong>mod</strong> key of the including application
must be set to <strong>{application_starter,[Module,StartArgs]}</strong>,
where <strong>Module</strong> as usual is the application callback module.
<strong>StartArgs</strong> is a term provided as argument to the callback
function <strong>Module:start/2</strong>:</p><pre><code class="">
{application, prim_app,
 [{description, "Tree application"},
  {vsn, "1"},
  {modules, [prim_app_cb, prim_app_sup, prim_app_server]},
  {registered, [prim_app_server]},
  {included_applications, [incl_app]},
  {start_phases, [{init,[]}, {go,[]}]},
  {applications, [kernel, stdlib, sasl]},
  {mod, {application_starter,[prim_app_cb,[]]}},
  {env, [{file, "/usr/local/log"}]}
 ]}.

{application, incl_app,
 [{description, "Included application"},
  {vsn, "1"},
  {modules, [incl_app_cb, incl_app_sup, incl_app_server]},
  {registered, []},
  {start_phases, [{go,[]}]},
  {applications, [kernel, stdlib, sasl]},
  {mod, {incl_app_cb,[]}}
 ]}.</code></pre><p>When starting a primary application with included applications,
the primary application is started the normal way, that is:</p><ul><li>The application controller creates an application master for the application</li><li>The application master calls <strong>Module:start(normal, StartArgs)</strong> to start the top supervisor.</li></ul><p>Then, for the primary application and each included application
in top-down, left-to-right order, the application master calls
<strong>Module:start_phase(Phase, Type, PhaseArgs)</strong> for each phase
defined for the primary application, in that order. If a phase
is not defined for an included application,
the function is not called for this phase and application.</p><p>The following requirements apply to the <strong>.app</strong> file for
an included application:</p><ul><li>The <strong>{mod, {Module,StartArgs}}</strong> option must be included. This option is used to find the callback module <strong>Module</strong> of the application. <strong>StartArgs</strong> is ignored, as <strong>Module:start/2</strong> is called only for the primary application.</li><li>If the included application itself contains included applications, instead the <strong>{mod, {application_starter, [Module,StartArgs]}}</strong> option must be included.</li><li>The <strong>{start_phases, [{Phase,PhaseArgs}]}</strong> option must be included, and the set of specified phases must be a subset of the set of phases specified for the primary application.</li></ul><p>When starting <strong>prim_app</strong> as defined above, the application
controller calls the following callback functions before
<strong>application:start(prim_app)</strong> returns a value:</p><pre><code class="">
application:start(prim_app)
 =&gt; prim_app_cb:start(normal, [])
 =&gt; prim_app_cb:start_phase(init, normal, [])
 =&gt; prim_app_cb:start_phase(go, normal, [])
 =&gt; incl_app_cb:start_phase(go, normal, [])
ok</code></pre><a name="distributed appl"></a><h4>Introduction</h4><p>In a distributed system with several Erlang nodes, it can be
necessary to control applications in a distributed manner. If
the node, where a certain application is running, goes down,
the application is to be restarted at another node.</p><p>Such an application is called a <em>distributed application</em>.
Notice that it is the control of the application that is distributed.
All applications can be distributed in the sense that they,
for example, use services on other nodes.</p><p>Since a distributed application can move between nodes, some
addressing mechanism is required to ensure that it can be
addressed by other applications, regardless on which node it
currently executes. This issue is not addressed here, but the
<strong>global</strong> or <strong>pg2</strong> modules in Kernel
can be used for this purpose.</p><h4>Specifying Distributed Applications</h4><p>Distributed applications are controlled by both the application
controller and a distributed application controller process,
<strong>dist_ac</strong>. Both these processes are part of the Kernel
application. Distributed applications are thus specified by
configuring the Kernel application, using the following
configuration parameter (see also <strong>kernel(6)</strong>):</p><p><strong>distributed = [{Application, [Timeout,] NodeDesc}]</strong></p><ul><li>Specifies where the application <strong>Application = atom()</strong> can execute.</li><li>&gt;<strong>NodeDesc = [Node | {Node,...,Node}]</strong> is a list of node names in priority order. The order between nodes in a tuple is undefined.</li><li><strong>Timeout = integer()</strong> specifies how many milliseconds to wait before restarting the application at another node. It defaults to 0.</li></ul><p>For distribution of application control to work properly,
the nodes where a distributed application can run must contact
each other and negotiate where to start the application. This is
done using the following configuration parameters in
Kernel:</p><ul><li><strong>sync_nodes_mandatory = [Node]</strong> - Specifies which other nodes must be started (within the time-out specified by <strong>sync_nodes_timeout</strong>).</li><li><strong>sync_nodes_optional = [Node]</strong> - Specifies which other nodes can be started (within the time-out specified by <strong>sync_nodes_timeout</strong>).</li><li><strong>sync_nodes_timeout = integer() | infinity</strong> - Specifies how many milliseconds to wait for the other nodes to start.</li></ul><p>When started, the node waits for all nodes specified by
<strong>sync_nodes_mandatory</strong> and <strong>sync_nodes_optional</strong> to
come up. When all nodes are up, or when all mandatory nodes
are up and the time specified by <strong>sync_nodes_timeout</strong>
has elapsed, all applications start. If not all
mandatory nodes are up, the node terminates.</p><p><em>Example:</em></p><p>An application <strong>myapp</strong> is to run at the node
<strong>cp1@cave</strong>. If this node goes down, <strong>myapp</strong> is to
be restarted at <strong>cp2@cave</strong> or <strong>cp3@cave</strong>. A system
configuration file <strong>cp1.config</strong> for <strong>cp1@cave</strong> can
look as follows:</p><pre><code class="">
[{kernel,
  [{distributed, [{myapp, 5000, [cp1@cave, {cp2@cave, cp3@cave}]}]},
   {sync_nodes_mandatory, [cp2@cave, cp3@cave]},
   {sync_nodes_timeout, 5000}
  ]
 }
].</code></pre><p>The system configuration files for <strong>cp2@cave</strong> and
<strong>cp3@cave</strong> are identical, except for the list of mandatory
nodes, which is to be <strong>[cp1@cave, cp3@cave]</strong> for
<strong>cp2@cave</strong> and <strong>[cp1@cave, cp2@cave]</strong> for
<strong>cp3@cave</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>All involved nodes must have the same value for
<strong>distributed</strong> and <strong>sync_nodes_timeout</strong>.
Otherwise the system behaviour is undefined.</p></div><h4>Starting and Stopping Distributed Applications</h4><p>When all involved (mandatory) nodes have been started,
the distributed application can be started by calling
<strong>application:start(Application)</strong> at <em>all of these nodes.</em></p><p>A boot script (see
<a href="release_structure">Releases</a>)
can be used that automatically starts the application.</p><p>The application is started at the first operational node that
is listed in the list of nodes in the <strong>distributed</strong>
configuration parameter. The application is started as usual.
That is, an application master is created and calls the
application callback function:</p><pre><code class="">
Module:start(normal, StartArgs)</code></pre><p>Example:</p><p>Continuing the example from the previous section, the three nodes
are started, specifying the system configuration file:</p><pre>
&gt; <span class="input">erl -sname cp1 -config cp1</span>
&gt; <span class="input">erl -sname cp2 -config cp2</span>
&gt; <span class="input">erl -sname cp3 -config cp3</span></pre><p>When all nodes are operational, <strong>myapp</strong> can be started.
This is achieved by calling <strong>application:start(myapp)</strong> at
all three nodes. It is then started at <strong>cp1</strong>, as shown in
the following figure:</p><a name="dist1"></a><img src="../design_principles/dist1.gif" title="Application myapp - Situation 1"></img><p>Similarly, the application must be stopped by calling
<strong>application:stop(Application)</strong> at all involved nodes.</p><h4>Failover</h4><p>If the node where the application is running goes down,
the application is restarted (after the specified time-out) at
the first operational node that is listed in the list of nodes
in the <strong>distributed</strong> configuration parameter. This is called a
<em>failover</em>.</p><p>The application is started the normal way at the new node,
that is, by the application master calling:</p><pre><code class="">
Module:start(normal, StartArgs)</code></pre><p>An exception is if the application has the <strong>start_phases</strong>
key defined
(see <a href="included_applications">Included Applications</a>).
The application is then instead started by calling:</p><pre><code class="">
Module:start({failover, Node}, StartArgs)</code></pre><p>Here <strong>Node</strong> is the terminated node.</p><p><em>Example:</em></p><p> If <strong>cp1</strong> goes down, the system checks which one of
the other nodes, <strong>cp2</strong> or <strong>cp3</strong>, has the least number of
running applications, but waits for 5 seconds for <strong>cp1</strong> to
restart. If <strong>cp1</strong> does not restart and <strong>cp2</strong> runs fewer
applications than <strong>cp3</strong>, <strong>myapp</strong> is restarted on
<strong>cp2</strong>.</p><a name="dist2"></a><img src="../design_principles/dist2.gif" title="Application myapp - Situation 2"></img><p>Suppose now that <strong>cp2</strong> goes also down and does not
restart within 5 seconds. <strong>myapp</strong> is now restarted on
<strong>cp3</strong>.</p><a name="dist3"></a><img src="../design_principles/dist3.gif" title="Application myapp - Situation 3"></img><h4>Takeover</h4><p>If a node is started, which has higher priority according
to <strong>distributed</strong> than the node where a distributed
application is running, the application is restarted at the
new node and stopped at the old node. This is
called a <em>takeover</em>.</p><p>The application is started by the application master calling:</p><pre><code class="">
Module:start({takeover, Node}, StartArgs)</code></pre><p>Here <strong>Node</strong> is the old node.</p><p><em>Example: </em></p><p>If <strong>myapp</strong> is running at <strong>cp3</strong>, and if
<strong>cp2</strong> now restarts, it does not restart <strong>myapp</strong>,
as the order between the <strong>cp2</strong> and <strong>cp3</strong> nodes is
undefined.</p><a name="dist4"></a><img src="../design_principles/dist4.gif" title="Application myapp - Situation 4"></img><p>However, if <strong>cp1</strong> also restarts, the function
<strong>application:takeover/2</strong> moves <strong>myapp</strong> to <strong>cp1</strong>,
as <strong>cp1</strong> has a higher priority than <strong>cp3</strong> for this
application. In this case,
<strong>Module:start({takeover, cp3@cave}, StartArgs)</strong> is
executed at <strong>cp1</strong> to start the application.</p><a name="dist5"></a><img src="../design_principles/dist5.gif" title="Application myapp - Situation 5"></img><a name="releases section"></a><p>This section is to be read with the <strong>rel(4)</strong>, <strong>systools(3)</strong>,
and <strong>script(4)</strong> manual pages in SASL.</p><h4>Release Concept</h4><p>When you have written one or more applications, you might want
to create a complete system with these applications and a
subset of the Erlang/OTP applications. This is called a
<em>release</em>.</p><p>To do this, create a
<a href="#res_file">release resource file</a> that
defines which applications are included in the release.</p><p>The release resource file is used to generate
<a href="#boot">boot scripts</a> and
<a href="#pack">release packages</a>. A system
that is transferred to and installed at another site is called a
<em>target system</em>. How to use a release package to create a
target system is described in System Principles.</p><a name="res_file"></a><h4>Release Resource File</h4><p>To define a release, create a <em>release resource file</em>,
or in short a <strong>.rel</strong> file. In the file, specify the name and
version of the release, which ERTS version it is based on,
and which applications it consists of:</p><pre><code class="">
{release, {Name,Vsn}, {erts, EVsn},
 [{Application1, AppVsn1},
   ...
  {ApplicationN, AppVsnN}]}.</code></pre><p><strong>Name</strong>, <strong>Vsn</strong>, <strong>EVsn</strong>, and <strong>AppVsn</strong> are
strings.</p><p>The file must be named <strong>Rel.rel</strong>, where <strong>Rel</strong> is a
unique name.</p><p>Each <strong>Application</strong> (atom) and <strong>AppVsn</strong> is
the name and version of an application included in the release.
The minimal release based on Erlang/OTP consists of
the Kernel and STDLIB applications, so these
applications must be included in the list.</p><p>If the release is to be upgraded, it must also include
the SASL application.</p><a name="ch_rel"></a><p><em>Example: </em> A release of <strong>ch_app</strong> from
<a href="./applications#ch_app">Applications</a>
has the following <strong>.app</strong> file:</p><pre><code class="">
{application, ch_app,
 [{description, "Channel allocator"},
  {vsn, "1"},
  {modules, [ch_app, ch_sup, ch3]},
  {registered, [ch3]},
  {applications, [kernel, stdlib, sasl]},
  {mod, {ch_app,[]}}
 ]}.</code></pre><p>The <strong>.rel</strong> file must also contain <strong>kernel</strong>,
<strong>stdlib</strong>, and <strong>sasl</strong>, as these applications are required
by <strong>ch_app</strong>. The file is called <strong>ch_rel-1.rel</strong>:</p><pre><code class="">
{release,
 {"ch_rel", "A"},
 {erts, "5.3"},
 [{kernel, "2.9"},
  {stdlib, "1.12"},
  {sasl, "1.10"},
  {ch_app, "1"}]
}.</code></pre><a name="boot"></a><h4>Generating Boot Scripts</h4><p><strong>systools</strong> in the SASL application includes tools to
build and check releases. The functions read the <strong>rel</strong> and
<strong>.app</strong> files and performs syntax and dependency checks.
The <strong>systools:make_script/1,2</strong> function is used to generate
a boot script (see System Principles):</p><pre>
1&gt; <span class="input">systools:make_script("ch_rel-1", [local]).</span>
ok</pre><p>This creates a boot script, both the readable version,
<strong>ch_rel-1.script</strong>, and the binary version, <strong>ch_rel-1.boot</strong>,
used by the runtime system.</p><ul><li><strong>"ch_rel-1"</strong> is the name of the <strong>.rel</strong> file, minus the extension.</li><li><strong>local</strong> is an option that means that the directories where the applications are found are used in the boot script, instead of <strong>$ROOT/lib</strong> (<strong>$ROOT</strong> is the root directory of the installed release).</li></ul><p> This is a useful way to test a generated boot script locally.</p><p>When starting Erlang/OTP using the boot script, all applications
from the <strong>.rel</strong> file are automatically loaded and started:</p><pre>
% <span class="input">erl -boot ch_rel-1</span>
Erlang (BEAM) emulator version 5.3

Eshell V5.3  (abort with ^G)
1&gt; 
=PROGRESS REPORT==== 13-Jun-2003::12:01:15 ===
          supervisor: {local,sasl_safe_sup}
             started: [{pid,&lt;0.33.0&gt;},
                       {name,alarm_handler},
                       {mfa,{alarm_handler,start_link,[]}},
                       {restart_type,permanent},
                       {shutdown,2000},
                       {child_type,worker}]

...

=PROGRESS REPORT==== 13-Jun-2003::12:01:15 ===
         application: sasl
          started_at: nonode@nohost

...
=PROGRESS REPORT==== 13-Jun-2003::12:01:15 ===
         application: ch_app
          started_at: nonode@nohost</pre><a name="pack"></a><h4>Creating a Release Package</h4><p>The <strong>systools:make_tar/1,2</strong> function takes a <strong>.rel</strong> file
as input and creates a zipped tar file with the code for the specified
applications, a <em>release package</em>:</p><pre>
1&gt; <span class="input">systools:make_script("ch_rel-1").</span>
ok
2&gt; <span class="input">systools:make_tar("ch_rel-1").</span>
ok</pre><p>The release package by default contains:</p><ul><li>The <strong>.app</strong> files</li><li>The <strong>.rel</strong> file</li><li>The object code for all applications, structured according to the <a href="./applications#app_dir">application directory structure</a></li><li>The binary boot script renamed to <strong>start.boot</strong></li></ul><pre>
% <span class="input">tar tf ch_rel-1.tar</span>
lib/kernel-2.9/ebin/kernel.app
lib/kernel-2.9/ebin/application.beam
...
lib/stdlib-1.12/ebin/stdlib.app
lib/stdlib-1.12/ebin/beam_lib.beam
...
lib/sasl-1.10/ebin/sasl.app
lib/sasl-1.10/ebin/sasl.beam
...
lib/ch_app-1/ebin/ch_app.app
lib/ch_app-1/ebin/ch_app.beam
lib/ch_app-1/ebin/ch_sup.beam
lib/ch_app-1/ebin/ch3.beam
releases/A/start.boot
releases/A/ch_rel-1.rel
releases/ch_rel-1.rel</pre><p>A new boot script was generated, without
the <strong>local</strong> option set, before the release package was made.
In the release package, all application directories are placed
under <strong>lib</strong>. You do not know where the release package
will be installed, so no hard-coded absolute paths are allowed.</p><p>The release resource file <strong>mysystem.rel</strong> is duplicated in
the tar file. Originally, this file was only stored in
the <strong>releases</strong> directory to make it possible for
the <strong>release_handler</strong> to extract this file
separately. After unpacking the tar file, <strong>release_handler</strong>
would automatically copy the file
to <strong>releases/FIRST</strong>. However, sometimes the tar file is
unpacked without involving the <strong>release_handler</strong> (for
example, when unpacking the first target system) and the file
is therefore now instead duplicated in the tar file so no manual
copying is necessary.</p><p>If a <strong>relup</strong> file and/or a system configuration file called
<strong>sys.config</strong>, or a <strong>sys.config.src</strong>, is found, these files
are also included in the release package. See
<a href="./release_handling#req">Release Handling</a>.</p><p>Options can be set to make the release package include source
code and the ERTS binary as well.</p><p>For information on how to install the first target system, using
a release package, see System Principles. For information
on how to install a new release package in an existing system, see
<a href="release_handling">Release Handling</a>.</p><a name="reldir"></a><h4>Directory Structure</h4><p>The directory structure for the code installed by the release handler
from a release package is as follows:</p><pre><code class="">
$ROOT/lib/App1-AVsn1/ebin
                    /priv
         /App2-AVsn2/ebin
                    /priv
         ...
         /AppN-AVsnN/ebin
                    /priv
     /erts-EVsn/bin
     /releases/Vsn
     /bin</code></pre><ul><li><strong>lib</strong> - Application directories</li><li><strong>erts-EVsn/bin</strong> - Erlang runtime system executables</li><li><strong>releases/Vsn</strong> - <strong>.rel</strong> file and boot script <strong>start.boot</strong>; if present in the release package, <strong>relup</strong> and/or <strong>sys.config</strong> or <strong>sys.config.src</strong></li><li><strong>bin</strong> - Top-level Erlang runtime system executables</li></ul><p>Applications are not required to be located under directory
<strong>$ROOT/lib</strong>. Several installation directories, which contain
different parts of a system, can thus exist.
For example, the previous example can be extended as follows:</p><pre>
$SECOND_ROOT/.../SApp1-SAVsn1/ebin
                             /priv
                /SApp2-SAVsn2/ebin
                             /priv
                ...
                /SAppN-SAVsnN/ebin
                             /priv

$THIRD_ROOT/TApp1-TAVsn1/ebin
                        /priv
           /TApp2-TAVsn2/ebin
                        /priv
           ...
           /TAppN-TAVsnN/ebin
                        /priv</pre><p><strong>$SECOND_ROOT</strong> and <strong>$THIRD_ROOT</strong> are introduced as
<strong>variables</strong> in the call to the <strong>systools:make_script/2</strong>
function.</p><h4>Disk-Less and/or Read-Only Clients</h4><p>If a complete system consists of disk-less and/or
read-only client nodes, a <strong>clients</strong> directory is to be
added to the <strong>$ROOT</strong> directory. A read-only node is
a node with a read-only file system.</p><p>The <strong>clients</strong> directory is to have one subdirectory
per supported client node. The name of each client directory
is to be the name of the corresponding client node. As a
minimum, each client directory is to contain the <strong>bin</strong> and
<strong>releases</strong> subdirectories. These directories are used to
store information about installed releases and to appoint the
current release to the client. The <strong>$ROOT</strong>
directory thus contains the following:</p><pre><code class="">
$ROOT/...
    /clients/ClientName1/bin
                        /releases/Vsn
            /ClientName2/bin
                        /releases/Vsn
            ...
            /ClientNameN/bin
                        /releases/Vsn</code></pre><p>This structure is to be used if all clients are running
the same type of Erlang machine. If there are clients running
different types of Erlang machines, or on different operating
systems, the <strong>clients</strong> directory can be divided into one
subdirectory per type of Erlang machine. Alternatively, one
<strong>$ROOT</strong> can be set up per type of machine. For each
type, some of the directories specified for the <strong>$ROOT</strong>
directory are to be included:</p><pre><code class="">
$ROOT/...
    /clients/Type1/lib
                  /erts-EVsn
                  /bin
                  /ClientName1/bin
                              /releases/Vsn
                  /ClientName2/bin
                              /releases/Vsn
                  ...
                  /ClientNameN/bin
                              /releases/Vsn
            ...
            /TypeN/lib
                  /erts-EVsn
                  /bin
                  ...</code></pre><p>With this structure, the root directory for clients of
<strong>Type1</strong> is <strong>$ROOT/clients/Type1</strong>.</p><a name="release handling"></a><h4>Release Handling Principles</h4><p>An important feature of the Erlang programming language is
the ability to change module code in runtime,
<em>code replacement</em>, as described in the Erlang
Reference Manual.</p><p>Based on this feature, the OTP application SASL provides a
framework for upgrading and downgrading between different
versions of an entire release in runtime. This is called
<em>release handling</em>.</p><p>The framework consists of:</p><ul><li>Offline support - <strong>systools</strong> for generating scripts and building release packages</li><li>Online support - <strong>release_handler</strong> for unpacking and installing release packages</li></ul><p>The minimal system based on Erlang/OTP, enabling release handling,
thus consists of the Kernel, STDLIB, and SASL
applications.</p><h4>Release Handling Workflow</h4><p><em>Step 1</em>) A release is created as described in
<a href="release_structure">Releases</a>.</p><p><em>Step 2</em>) The release is transferred to and installed at
target environment. For information of how to install the first
target system, see System Principles.</p><p><em>Step 3</em>) Modifications, for example, error corrections,
are made to the code in the development environment.</p><p><em>Step 4</em>) At some point, it is time to make a new version
of release. The relevant <strong>.app</strong> files are updated and a new
<strong>.rel</strong> file is written.</p><p><em>Step 5</em>) For each modified application, an
<a href="#appup">application upgrade file</a>,
<strong>.appup</strong>, is created. In this file, it is described how to
upgrade and/or downgrade between the old and new version of the
application.</p><p><em>Step 6</em>) Based on the <strong>.appup</strong> files, a
<a href="#relup">release upgrade file</a> called
<strong>relup</strong>, is created. This file describes how to upgrade and/or
downgrade between the old and new version of the entire release.</p><p><em>Step 7</em>) A new release package is made and transferred to
the target system.</p><p><em>Step 8</em>) The new release package is unpacked using the
release handler.</p><p><em>Step 9</em>) The new version of the release is installed,
also using the release handler. This is done by evaluating the
instructions in <strong>relup</strong>. Modules can be added, deleted, or
reloaded, applications can be started, stopped, or restarted, and so
on. In some cases, it is even necessary to restart the entire
emulator.</p><ul><li>If the installation fails, the system can be rebooted. The old release version is then automatically used.</li><li>If the installation succeeds, the new version is made the default version, which is to now be used if there is a system reboot.</li></ul><h4>Release Handling Aspects</h4><p><a href="appup_cookbook">Appup Cookbook</a>,
contains examples of <strong>.appup</strong> files
for typical cases of upgrades/downgrades that are normally easy to
handle in runtime. However, many aspects can make release handling
complicated, for example:</p><ul><li> <p>Complicated or circular dependencies can make it difficult
or even impossible to decide in which order things must be
done without risking runtime errors during an upgrade or
downgrade. Dependencies can be:</p> <ul><li>Between nodes</li><li>Between processes</li><li>Between modules</li></ul> </li><li> <p>During release handling, non-affected processes continue
normal execution. This can lead to time-outs or other problems.
For example, new processes created in the time window between
suspending processes using a certain module, and loading a new
version of this module, can execute old code.</p> </li></ul><p>It is thus recommended that code is changed in as small
steps as possible, and always kept backwards compatible.</p><a name="req"></a><h4>Requirements</h4><p>For release handling to work properly, the runtime system must
have knowledge about which release it is running. It
must also be able to change (in runtime) which boot script and
system configuration file to use if the system is
rebooted, for example, by <strong>heart</strong> after a failure.
Thus, Erlang must be started as an embedded system; for
information on how to do this, see Embedded System.</p><p>For system reboots to work properly, it is also required that
the system is started with heartbeat monitoring, see the
<strong>erl(1)</strong> manual page in ERTS and the <strong>heart(3)</strong>
manual page in Kernel</p><p>Other requirements:</p><ul><li> <p>The boot script included in a release package must be
generated from the same <strong>.rel</strong> file as the release
package itself.</p> <p>Information about applications is fetched from the script
when an upgrade or downgrade is performed.</p> </li><li> <p>The system must be configured using only one system
configuration file, called <strong>sys.config</strong>.</p> <p>If found, this file is automatically included when a release
package is created.</p> </li><li> <p>All versions of a release, except the first one, must
contain a <strong>relup</strong> file.</p> <p>If found, this file is automatically included when a release
package is created.</p> </li></ul><h4>Distributed Systems</h4><p>If the system consists of several Erlang nodes, each node can use
its own version of the release. The release handler is a locally
registered process and must be called at each node where an
upgrade or downgrade is required. A release handling
instruction, <strong>sync_nodes</strong>, can be used to synchronize the
release handler processes at a number of nodes, see the
<strong>appup(4)</strong> manual page in SASL.</p><a name="instr"></a><h4>Release Handling Instructions</h4><p>OTP supports a set of <em>release handling instructions</em>
that are used when creating <strong>.appup</strong> files. The release
handler understands a subset of these, the <em>low-level</em>
instructions. To make it easier for the user, there are also a
number of <em>high-level</em> instructions, which are translated
to low-level instructions by <strong>systools:make_relup</strong>.</p><p>Some of the most frequently used instructions are described in
this section. The complete list of instructions is included in the
<strong>appup(4)</strong> manual page in SASL.</p><p>First, some definitions:</p><ul><li><em>Residence module</em> - The module where a process has its tail-recursive loop function(s). If these functions are implemented in several modules, all those modules are residence modules for the process.</li><li><em>Functional module</em> - A module that is not a residence module for any process.</li></ul><p>For a process implemented using an OTP behaviour, the behaviour
module is the residence module for that process.
The callback module is a functional module.</p><h4>load_module</h4><p>If a simple extension has been made to a functional module, it
is sufficient to load the new version of the module into
the system, and remove the old version. This is called
<em>simple code replacement</em> and for this the following
instruction is used:</p><pre><code class="">
{load_module, Module}</code></pre><h4>update</h4><p>If a more complex change has been made, for example, a change
to the format of the internal state of a <strong>gen_server</strong>, simple
code replacement is not sufficient. Instead, it is necessary to:</p><ul><li>Suspend the processes using the module (to avoid that they try to handle any requests before the code replacement is completed).</li><li>Ask them to transform the internal state format and switch to the new version of the module.</li><li>Remove the old version.</li><li>Resume the processes.</li></ul><p>This is called <em>synchronized code replacement</em> and for
this the following instructions are used:</p><pre><code class="">
{update, Module, {advanced, Extra}}
{update, Module, supervisor}</code></pre><p><strong>update</strong> with argument <strong>{advanced,Extra}</strong> is used
when changing the internal state of a behaviour as described
above. It causes behaviour processes to call the callback
function <strong>code_change</strong>, passing the term <strong>Extra</strong> and
some other information as arguments. See the manual pages for
the respective behaviours and
<a href="./appup_cookbook#int_state">Appup Cookbook</a>.</p><p><strong>update</strong> with argument <strong>supervisor</strong> is used when
changing the start specification of a supervisor. See
<a href="./appup_cookbook#sup">Appup Cookbook</a>.</p><p>When a module is to be updated, the release handler finds
which processes that are <em>using</em> the module by
traversing the supervision tree of each running application
and checking all the child specifications:</p><pre><code class="">
{Id, StartFunc, Restart, Shutdown, Type, Modules}</code></pre><p>A process uses a module if the name is listed in
<strong>Modules</strong> in the child specification for the process.</p><p>If <strong>Modules=dynamic</strong>, which is the case for event
managers, the event manager process informs the release handler
about the list of currently installed event handlers
(<strong>gen_event</strong>), and it is checked if the module name is in
this list instead.</p><p>The release handler suspends, asks for code change, and
resumes processes by calling the functions
<strong>sys:suspend/1,2</strong>, <strong>sys:change_code/4,5</strong>, and
<strong>sys:resume/1,2</strong>, respectively.</p><h4>add_module and delete_module</h4><p>If a new module is introduced, the following instruction is
used:</p><pre><code class="">
{add_module, Module}</code></pre><p>The instruction loads the module and is necessary
when running Erlang in embedded mode. It is not strictly
required when running Erlang in interactive (default) mode,
since the code server then automatically searches for and
loads unloaded modules.</p><p>The opposite of <strong>add_module</strong> is <strong>delete_module</strong>, which
unloads a module:</p><pre><code class="">
{delete_module, Module}</code></pre><p>Any process, in any application, with <strong>Module</strong>
as residence module, is killed when the instruction is
evaluated. The user must therefore ensure that all such
processes are terminated before deleting the module, to avoid
a situation with failing supervisor restarts.</p><h4>Application Instructions</h4><p>The following is the instruction for adding an application:</p><pre><code class="">
{add_application, Application}</code></pre><p>Adding an application means that the modules defined by
the <strong>modules</strong> key in the <strong>.app</strong> file are loaded using
a number of <strong>add_module</strong> instructions, and then the application
is started.</p><p>The following is the instruction for removing an application:</p><pre><code class="">
{remove_application, Application}</code></pre><p>Removing an application means that the application is stopped,
the modules are unloaded using a number of <strong>delete_module</strong>
instructions, and then the application specification is unloaded
from the application controller.</p><p>The following is the instruction for restarting an application:</p><pre><code class="">
{restart_application, Application}</code></pre><p>Restarting an application means that the application is stopped
and then started again similar to using the instructions
<strong>remove_application</strong> and <strong>add_application</strong> in
sequence.</p><h4>apply (Low-Level)</h4><p>To call an arbitrary function from the release handler,
the following instruction is used:</p><pre><code class="">
{apply, {M, F, A}}</code></pre><p>The release handler evalutes <strong>apply(M, F, A)</strong>.</p><a name="restart_new_emulator_instr"></a><h4>restart_new_emulator (Low-Level)</h4><p>This instruction is used when changing to a new emulator
version, or when any of the core applications Kernel,
STDLIB, or SASL is upgraded. If a system reboot
is needed for another reason, the <strong>restart_emulator</strong>
instruction is to be used instead.</p><p>This instruction requires that the system is started with
heartbeat monitoring, see the <strong>erl(1)</strong> manual page in
ERTS and the <strong>heart(3)</strong> manual page in Kernel.</p><p>The <strong>restart_new_emulator</strong> instruction must always be
the first instruction in a relup. If the relup is
generated by <strong>systools:make_relup/3,4</strong>, this is
automatically ensured.</p><p>When the release handler encounters the instruction, it first
generates a temporary boot file, which starts the new versions
of the emulator and the core applications, and the old version
of all other applications. Then it shuts down
the current emulator by calling <strong>init:reboot()</strong>, see the
<strong>init(3)</strong> manual page in Kernel.
All processes are terminated gracefully and
the system is rebooted by the <strong>heart</strong> program, using the
temporary boot file. After the reboot, the rest of the relup
instructions are executed. This is done as a part of the
temporary boot script.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This mechanism causes the new versions of the emulator and
core applications to run with the old version of other
applications during startup. Thus, take extra care to
avoid incompatibility. Incompatible changes in the core
applications can in some situations be necessary. If possible,
such changes are preceded by deprecation over two major
releases before the actual change. To ensure the
application is not crashed by an incompatible change, always
remove any call to deprecated functions as soon as
possible.</p></div><p>An info report is written when the upgrade is completed. To
programmatically find out if the upgrade is complete,
call <strong>release_handler:which_releases(current)</strong> and check
if it returns the expected (that is, the new) release.</p><p>The new release version must be made permanent when the new
emulator is operational. Otherwise, the old version will be
used if there is a new system reboot.</p><p>On UNIX, the release handler tells the <strong>heart</strong> program
which command to use to reboot the system. The environment
variable <strong>HEART_COMMAND</strong>, normally used by the <strong>heart</strong>
program, is ignored in this case. The command instead defaults
to <strong>$ROOT/bin/start</strong>. Another command can be set by using
the SASL configuration parameter <strong>start_prg</strong>, see
the <strong>sasl(6)</strong> manual page.</p><a name="restart_emulator_instr"></a><h4>restart_emulator (Low-Level)</h4><p>This instruction is not related to upgrades of ERTS or any
of the core applications. It can be used by any application to
force a restart of the emulator after all upgrade instructions
are executed.</p><p>A relup script can only have one <strong>restart_emulator</strong>
instruction and it must always be placed at the end. If
the relup is generated by <strong>systools:make_relup/3,4</strong>, this
is automatically ensured.</p><p>When the release handler encounters the instruction, it shuts
down the emulator by calling <strong>init:reboot()</strong>, see the
<strong>init(3)</strong> manual page in Kernel.
All processes are terminated gracefully and the system
can then be rebooted by the <strong>heart</strong> program using the
new release version. No more upgrade instruction is
executed after the restart.</p><a name="appup"></a><h4>Application Upgrade File</h4><p>To define how to upgrade/downgrade between the current version
and previous versions of an application, an
<em>application upgrade file</em>, or in short an <strong>.appup</strong>
file is created.
The file is to be called <strong>Application.appup</strong>, where
<strong>Application</strong> is the application name:</p><pre><code class="">
{Vsn,
 [{UpFromVsn1, InstructionsU1},
  ...,
  {UpFromVsnK, InstructionsUK}],
 [{DownToVsn1, InstructionsD1},
  ...,
  {DownToVsnK, InstructionsDK}]}.</code></pre><ul><li><strong>Vsn</strong>, a string, is the current version of the application, as defined in the <strong>.app</strong> file.</li><li>Each <strong>UpFromVsn</strong> is a previous version of the application to upgrade from.</li><li>Each <strong>DownToVsn</strong> is a previous version of the application to downgrade to.</li><li>Each <strong>Instructions</strong> is a list of release handling instructions.</li></ul><p>For information about the syntax and contents of the <strong>.appup</strong>
file, see the <strong>appup(4)</strong> manual page in SASL.</p><p><a href="appup_cookbook">Appup Cookbook</a>
includes examples of <strong>.appup</strong> files for typical upgrade/downgrade
cases.</p><p><em>Example:</em> Consider the release <strong>ch_rel-1</strong> from
<a href="./release_structure#ch_rel">Releases</a>.
Assume you want to add a function <strong>available/0</strong> to server
<strong>ch3</strong>, which returns the number of available channels (when
trying out the example, change in a copy of the original
directory, so that the first versions are still available):</p><pre><code class="">
-module(ch3).
-behaviour(gen_server).

-export([start_link/0]).
-export([alloc/0, free/1]).
-export([available/0]).
-export([init/1, handle_call/3, handle_cast/2]).

start_link() -&gt;
    gen_server:start_link({local, ch3}, ch3, [], []).

alloc() -&gt;
    gen_server:call(ch3, alloc).

free(Ch) -&gt;
    gen_server:cast(ch3, {free, Ch}).

available() -&gt;
    gen_server:call(ch3, available).

init(_Args) -&gt;
    {ok, channels()}.

handle_call(alloc, _From, Chs) -&gt;
    {Ch, Chs2} = alloc(Chs),
    {reply, Ch, Chs2};
handle_call(available, _From, Chs) -&gt;
    N = available(Chs),
    {reply, N, Chs}.

handle_cast({free, Ch}, Chs) -&gt;
    Chs2 = free(Ch, Chs),
    {noreply, Chs2}.</code></pre><p>A new version of the <strong>ch_app.app</strong> file must now be created,
where the version is updated:</p><pre><code class="">
{application, ch_app,
 [{description, "Channel allocator"},
  {vsn, "2"},
  {modules, [ch_app, ch_sup, ch3]},
  {registered, [ch3]},
  {applications, [kernel, stdlib, sasl]},
  {mod, {ch_app,[]}}
 ]}.</code></pre><p>To upgrade <strong>ch_app</strong> from <strong>"1"</strong> to <strong>"2"</strong> (and
to downgrade from <strong>"2"</strong> to <strong>"1"</strong>), you only need to
load the new (old) version of the <strong>ch3</strong> callback module.
Create the application upgrade file <strong>ch_app.appup</strong> in
the <strong>ebin</strong> directory:</p><pre><code class="">
{"2",
 [{"1", [{load_module, ch3}]}],
 [{"1", [{load_module, ch3}]}]
}.</code></pre><a name="relup"></a><h4>Release Upgrade File</h4><p>To define how to upgrade/downgrade between the new version and
previous versions of a release, a <em>release upgrade file</em>,
or in short <strong>relup</strong> file, is to be created.</p><p>This file does not need to be created manually, it can be
generated by <strong>systools:make_relup/3,4</strong>. The relevant versions
of the <strong>.rel</strong> file, <strong>.app</strong> files, and <strong>.appup</strong> files
are used as input. It is deducted which applications are to be
added and deleted, and which applications that must be upgraded
and/or downgraded. The instructions for this are fetched from
the <strong>.appup</strong> files and transformed into a single list of
low-level instructions in the right order.</p><p>If the <strong>relup</strong> file is relatively simple, it can be created
manually. It it only to contain low-level instructions.</p><p>For details about the syntax and contents of the release upgrade
file, see the <strong>relup(4)</strong> manual page in SASL.</p><p><em>Example, continued from the previous section:</em> You have a
new version "2" of <strong>ch_app</strong> and an <strong>.appup</strong> file. A new
version of the <strong>.rel</strong> file is also needed. This time the file
is called <strong>ch_rel-2.rel</strong> and the release version string is
changed from "A" to "B":</p><pre><code class="">
{release,
 {"ch_rel", "B"},
 {erts, "5.3"},
 [{kernel, "2.9"},
  {stdlib, "1.12"},
  {sasl, "1.10"},
  {ch_app, "2"}]
}.</code></pre><p>Now the <strong>relup</strong> file can be generated:</p><pre>
1&gt; <span class="input">systools:make_relup("ch_rel-2", ["ch_rel-1"], ["ch_rel-1"]).</span>
ok</pre><p>This generates a <strong>relup</strong> file with instructions for
how to upgrade from version "A" ("ch_rel-1") to version "B"
("ch_rel-2") and how to downgrade from version "B" to version "A".</p><p>Both the old and new versions of the <strong>.app</strong> and
<strong>.rel</strong> files must be in the code path, as well as the
<strong>.appup</strong> and (new) <strong>.beam</strong> files. The code path can be
extended by using the option <strong>path</strong>:</p><pre>
1&gt; <span class="input">systools:make_relup("ch_rel-2", ["ch_rel-1"], ["ch_rel-1"],</span>
<span class="input">[{path,["../ch_rel-1",</span>
<span class="input">"../ch_rel-1/lib/ch_app-1/ebin"]}]).</span>
ok</pre><a name="rel_handler"></a><h4>Installing a Release</h4><p>When you have made a new version of a release, a release package
can be created with this new version and transferred to the target
environment.</p><p>To install the new version of the release in runtime,
the <em>release handler</em> is used. This is a process belonging
to the SASL application, which handles unpacking, installation,
and removal of release packages. It is communicated through
the <strong>release_handler</strong> module. For details, see the
<strong>release_handler(3)</strong> manual page in SASL.</p><p>Assuming there is an operational target system with
installation root directory <strong>$ROOT</strong>, the release package with
the new version of the release is to be copied to
<strong>$ROOT/releases</strong>.</p><p>First, <em>unpack</em> the release package.
The files are then extracted from the package:</p><pre><code class="">
release_handler:unpack_release(ReleaseName) =&gt; {ok, Vsn}</code></pre><ul><li><strong>ReleaseName</strong> is the name of the release package except the <strong>.tar.gz</strong> extension.</li><li><strong>Vsn</strong> is the version of the unpacked release, as defined in its <strong>.rel</strong> file.</li></ul><p>A directory <strong>$ROOT/lib/releases/Vsn</strong> is created, where
the <strong>.rel</strong> file, the boot script <strong>start.boot</strong>,
the system configuration file <strong>sys.config</strong>, and <strong>relup</strong>
are placed. For applications with new version numbers,
the application directories are placed under <strong>$ROOT/lib</strong>.
Unchanged applications are not affected.</p><p>An unpacked release can be <em>installed</em>. The release
handler then evaluates the instructions in <strong>relup</strong>, step by
step:</p><pre><code class="">
release_handler:install_release(Vsn) =&gt; {ok, FromVsn, []}</code></pre><p>If an error occurs during the installation, the system is
rebooted using the old version of the release. If installation
succeeds, the system is afterwards using the new version of
the release, but if anything happens and the system is
rebooted, it starts using the previous version again.</p><p>To be made the default version, the newly installed release
must be made <em>permanent</em>, which means the previous
version becomes <em>old</em>:</p><pre><code class="">
release_handler:make_permanent(Vsn) =&gt; ok</code></pre><p>The system keeps information about which versions are old and
permanent in the files <strong>$ROOT/releases/RELEASES</strong> and
<strong>$ROOT/releases/start_erl.data</strong>.</p><p>To downgrade from <strong>Vsn</strong> to <strong>FromVsn</strong>,
<strong>install_release</strong> must be called again:</p><pre><code class="">
release_handler:install_release(FromVsn) =&gt; {ok, Vsn, []}</code></pre><p>An installed, but not permanent, release can be <em>removed</em>.
Information about the release is then deleted from
<strong>$ROOT/releases/RELEASES</strong> and the release-specific code,
that is, the new application directories and
the <strong>$ROOT/releases/Vsn</strong> directory, are removed.</p><pre><code class="">
release_handler:remove_release(Vsn) =&gt; ok</code></pre><h4>Example (continued from the previous sections)</h4><p><em>Step 1)</em> Create a target system as described in
System Principles of the first version <strong>"A"</strong>
of <strong>ch_rel</strong> from
<a href="./release_structure#ch_rel">Releases</a>.
This time <strong>sys.config</strong> must be included in the release package.
If no configuration is needed, the file is to contain the empty
list:</p><pre><code class="">
[].</code></pre><p><em>Step 2)</em> Start the system as a simple target system. In
reality, it is to be started as an embedded system. However, using
<strong>erl</strong> with the correct boot script and config file is enough for
illustration purposes:</p><pre>
% <span class="input">cd $ROOT</span>
% <span class="input">bin/erl -boot $ROOT/releases/A/start -config $ROOT/releases/A/sys</span>
...</pre><p><strong>$ROOT</strong> is the installation directory of the target system.</p><p><em>Step 3)</em> In another Erlang shell, generate start scripts and
create a release package for the new version <strong>"B"</strong>. Remember to
include (a possible updated) <strong>sys.config</strong> and the <strong>relup</strong> file,
see <a href="#relup">Release Upgrade File</a>.</p><pre>
1&gt; <span class="input">systools:make_script("ch_rel-2").</span>
ok
2&gt; <span class="input">systools:make_tar("ch_rel-2").</span>
ok</pre><p>The new release package now also contains version "2" of <strong>ch_app</strong>
and the <strong>relup</strong> file:</p><pre><code class="">
% tar tf ch_rel-2.tar 
lib/kernel-2.9/ebin/kernel.app
lib/kernel-2.9/ebin/application.beam
...
lib/stdlib-1.12/ebin/stdlib.app
lib/stdlib-1.12/ebin/beam_lib.beam
...      
lib/sasl-1.10/ebin/sasl.app
lib/sasl-1.10/ebin/sasl.beam
...
lib/ch_app-2/ebin/ch_app.app
lib/ch_app-2/ebin/ch_app.beam
lib/ch_app-2/ebin/ch_sup.beam
lib/ch_app-2/ebin/ch3.beam
releases/B/start.boot
releases/B/relup
releases/B/sys.config
releases/B/ch_rel-2.rel
releases/ch_rel-2.rel</code></pre><p><em>Step 4)</em> Copy the release package <strong>ch_rel-2.tar.gz</strong>
to the <strong>$ROOT/releases</strong> directory.</p><p><em>Step 5)</em> In the running target system, unpack the release
package:</p><pre>
1&gt; <span class="input">release_handler:unpack_release("ch_rel-2").</span>
{ok,"B"}</pre><p>The new application version <strong>ch_app-2</strong> is installed under
<strong>$ROOT/lib</strong> next to <strong>ch_app-1</strong>. The <strong>kernel</strong>,
<strong>stdlib</strong>, and <strong>sasl</strong> directories are not affected, as
they have not changed.</p><p>Under <strong>$ROOT/releases</strong>, a new directory <strong>B</strong> is created,
containing <strong>ch_rel-2.rel</strong>, <strong>start.boot</strong>,
<strong>sys.config</strong>, and <strong>relup</strong>.</p><p><em>Step 6)</em> Check if the function <strong>ch3:available/0</strong> is
available:</p><pre>
2&gt; <span class="input">ch3:available().</span>
** exception error: undefined function ch3:available/0</pre><p><em>Step 7)</em> Install the new release. The instructions in
<strong>$ROOT/releases/B/relup</strong> are executed one by one, resulting
in the new version of <strong>ch3</strong> being loaded. The function
<strong>ch3:available/0</strong> is now available:</p><pre>
3&gt; <span class="input">release_handler:install_release("B").</span>
{ok,"A",[]}
4&gt; <span class="input">ch3:available().</span>
3
5&gt; <span class="input">code:which(ch3).</span>
".../lib/ch_app-2/ebin/ch3.beam"
6&gt; <span class="input">code:which(ch_sup).</span>
".../lib/ch_app-1/ebin/ch_sup.beam"</pre><p>Processes in <strong>ch_app</strong> for which code have not
been updated, for example, the supervisor, are still evaluating
code from <strong>ch_app-1</strong>.</p><p><em>Step 8)</em> If the target system is now rebooted, it uses
version "A" again. The "B" version must be made permanent, to be
used when the system is rebooted.</p><pre>
7&gt; <span class="input">release_handler:make_permanent("B").</span>
ok</pre><a name="sys"></a><h4>Updating Application Specifications</h4><p>When a new version of a release is installed, the application
specifications are automatically updated for all loaded
applications.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The information about the new application specifications is
fetched from the boot script included in the release package.
Thus, it is important that the boot script is generated from
the same <strong>.rel</strong> file as is used to build the release
package itself.</p></div><p>Specifically, the application configuration parameters are
automatically updated according to (in increasing priority
order):</p><ul><li>The data in the boot script, fetched from the new application resource file <strong>App.app</strong></li><li>The new <strong>sys.config</strong></li><li>Command-line arguments <strong>-App Par Val</strong></li></ul><p>This means that parameter values set in the other system
configuration files and values set using
<strong>application:set_env/3</strong> are disregarded.</p><p>When an installed release is made permanent, the system process
<strong>init</strong> is set to point out the new <strong>sys.config</strong>.</p><p>After the installation, the application controller compares
the old and new configuration parameters for all running
applications and call the callback function:</p><pre><code class="">
Module:config_change(Changed, New, Removed)</code></pre><ul><li><strong>Module</strong> is the application callback module as defined by the <strong>mod</strong> key in the <strong>.app</strong> file.</li><li><strong>Changed</strong> and <strong>New</strong> are lists of <strong>{Par,Val}</strong> for all changed and added configuration parameters, respectively.</li><li><strong>Removed</strong> is a list of all parameters <strong>Par</strong> that have been removed.</li></ul><p>The function is optional and can be omitted when implementing an
application callback module.</p><a name="appup cookbook"></a><p>This section includes examples of <strong>.appup</strong> files for
typical cases of upgrades/downgrades done in runtime.</p><h4>Changing a Functional Module</h4><p>When a functional module has been changed, for example,
if a new function has been added or a bug has been corrected,
simple code replacement is sufficient, for example:</p><pre><code class="">
{"2",
 [{"1", [{load_module, m}]}],
 [{"1", [{load_module, m}]}]
}.</code></pre><h4>Changing a Residence Module</h4><p>In a system implemented according to the OTP design principles,
all processes, except system processes and special processes,
reside in one of the behaviours <strong>supervisor</strong>,
<strong>gen_server</strong>, <strong>gen_fsm</strong>,
<strong>gen_statem</strong> or <strong>gen_event</strong>. These
belong to the STDLIB application and upgrading/downgrading
normally requires an emulator restart.</p><p>OTP thus provides no support for changing residence modules except
in the case of <a href="#spec">special processes</a>.</p><h4>Changing a Callback Module</h4><p>A callback module is a functional module, and for code
extensions simple code replacement is sufficient.</p><p><em>Example:</em> When adding a function to <strong>ch3</strong>,
as described in the example in
<a href="./release_handling#appup">Release Handling</a>,
<strong>ch_app.appup</strong> looks as follows:</p><pre><code class="">
{"2",
 [{"1", [{load_module, ch3}]}],
 [{"1", [{load_module, ch3}]}]
}.</code></pre><p>OTP also supports changing the internal state of behaviour
processes, see <a href="#int_state">Changing Internal State</a>.</p><a name="int_state"></a><h4>Changing Internal State</h4><p>In this case, simple code replacement is not sufficient.
The process must explicitly transform its state using the callback
function <strong>code_change</strong> before switching to the new version
of the callback module. Thus, synchronized code replacement is
used.</p><p><em>Example:</em> Consider <strong>gen_server</strong> <strong>ch3</strong> from
<a href="./gen_server_concepts#ex">gen_server Behaviour</a>.
The internal state is a term <strong>Chs</strong>
representing the available channels. Assume you want to add a counter
<strong>N</strong>, which keeps track of the number of <strong>alloc</strong> requests
so far. This means that the format must be changed to
<strong>{Chs,N}</strong>.</p><p>The <strong>.appup</strong> file can look as follows:</p><pre><code class="">
{"2",
 [{"1", [{update, ch3, {advanced, []}}]}],
 [{"1", [{update, ch3, {advanced, []}}]}]
}.</code></pre><p>The third element of the <strong>update</strong> instruction is a tuple
<strong>{advanced,Extra}</strong>, which says that the affected processes
are to do a state transformation before loading the new version
of the module. This is done by the processes calling the callback
function <strong>code_change</strong> (see the <strong>gen_server(3)</strong> manual
page in STDLIB). The term <strong>Extra</strong>, in this case
<strong>[]</strong>, is passed as is to the function:</p><a name="code_change"></a><pre><code class="">
-module(ch3).
...
-export([code_change/3]).
...
code_change({down, _Vsn}, {Chs, N}, _Extra) -&gt;
    {ok, Chs};
code_change(_Vsn, Chs, _Extra) -&gt;
    {ok, {Chs, 0}}.</code></pre><p>The first argument is <strong>{down,Vsn}</strong> if there is a downgrade,
or <strong>Vsn</strong> if there is a upgrade. The term <strong>Vsn</strong> is
fetched from the 'original' version of the module, that is,
the version you are upgrading from, or downgrading to.</p><p>The version is defined by the module attribute <strong>vsn</strong>, if
any. There is no such attribute in <strong>ch3</strong>, so in this case
the version is the checksum (a huge integer) of the beam file, an
uninteresting value, which is ignored.</p><p>The other callback functions of <strong>ch3</strong> must also be modified
and perhaps a new interface function must be added, but this is not
shown here.</p><h4>Module Dependencies</h4><p>Assume that a module is extended by adding an interface function,
as in the example in
<a href="./release_handling#appup">Release Handling</a>,
where a function <strong>available/0</strong> is added to <strong>ch3</strong>.</p><p>If a call is added to this function, say in module
<strong>m1</strong>, a runtime error could can occur during release upgrade if
the new version of <strong>m1</strong> is loaded first and calls
<strong>ch3:available/0</strong> before the new version of <strong>ch3</strong> is
loaded.</p><p>Thus, <strong>ch3</strong> must be loaded before <strong>m1</strong>, in
the upgrade case, and conversely in the downgrade case.
<strong>m1</strong> is said to be <em>dependent on</em> <strong>ch3</strong>. In a release
handling instruction, this is expressed by the
<strong>DepMods</strong> element:</p><pre><code class="">
{load_module, Module, DepMods}
{update, Module, {advanced, Extra}, DepMods}</code></pre><p><strong>DepMods</strong> is a list of modules, on which <strong>Module</strong> is
dependent.</p><p><em>Example:</em> The module <strong>m1</strong> in application <strong>myapp</strong> is
dependent on <strong>ch3</strong> when upgrading from "1" to "2", or
downgrading from "2" to "1":</p><pre><code class="">
myapp.appup:

{"2",
 [{"1", [{load_module, m1, [ch3]}]}],
 [{"1", [{load_module, m1, [ch3]}]}]
}.

ch_app.appup:

{"2",
 [{"1", [{load_module, ch3}]}],
 [{"1", [{load_module, ch3}]}]
}.</code></pre><p>If instead <strong>m1</strong> and <strong>ch3</strong> belong to the same application,
the <strong>.appup</strong> file can look as follows:</p><pre><code class="">
{"2",
 [{"1",
   [{load_module, ch3},
    {load_module, m1, [ch3]}]}],
 [{"1",
   [{load_module, ch3},
    {load_module, m1, [ch3]}]}]
}.</code></pre><p><strong>m1</strong> is dependent on <strong>ch3</strong> also
when downgrading. <strong>systools</strong> knows the difference between
up- and downgrading and generates a correct <strong>relup</strong>,
where <strong>ch3</strong> is loaded before <strong>m1</strong> when upgrading, but
<strong>m1</strong> is loaded before <strong>ch3</strong> when downgrading.</p><a name="spec"></a><h4>Changing Code for a Special Process</h4><p>In this case, simple code replacement is not sufficient.
When a new version of a residence module for a special process
is loaded, the process must make a fully qualified call to
its loop function to switch to the new code. Thus, synchronized
code replacement must be used.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The name(s) of the user-defined residence module(s) must be
listed in the <strong>Modules</strong> part of the child specification
for the special process. Otherwise the release handler cannot
find the process.</p></div><p><em>Example:</em> Consider the example <strong>ch4</strong> in
<a href="./spec_proc#ex">sys and proc_lib</a>.
When started by a supervisor, the child specification can look
as follows:</p><pre><code class="">
{ch4, {ch4, start_link, []},
 permanent, brutal_kill, worker, [ch4]}</code></pre><p>If <strong>ch4</strong> is part of the application <strong>sp_app</strong> and a new
version of the module is to be loaded when upgrading from
version "1" to "2" of this application, <strong>sp_app.appup</strong> can
look as follows:</p><pre><code class="">
{"2",
 [{"1", [{update, ch4, {advanced, []}}]}],
 [{"1", [{update, ch4, {advanced, []}}]}]
}.</code></pre><p>The <strong>update</strong> instruction must contain the tuple
<strong>{advanced,Extra}</strong>. The instruction makes the special
process call the callback function <strong>system_code_change/4</strong>, a
function the user must implement. The term <strong>Extra</strong>, in this
case <strong>[]</strong>, is passed as is to <strong>system_code_change/4</strong>:</p><pre><code class="">
-module(ch4).
...
-export([system_code_change/4]).
...

system_code_change(Chs, _Module, _OldVsn, _Extra) -&gt;
    {ok, Chs}.</code></pre><ul><li>The first argument is the internal state <strong>State</strong>, passed from function <strong>sys:handle_system_msg(Request, From, Parent, Module, Deb, State)</strong>, and called by the special process when a system message is received. In <strong>ch4</strong>, the internal state is the set of available channels <strong>Chs</strong>.</li><li>The second argument is the name of the module (<strong>ch4</strong>).</li><li>The third argument is <strong>Vsn</strong> or <strong>{down,Vsn}</strong>, as described for <strong>gen_server:code_change/3</strong> in <a href="#code_change">Changing Internal State</a>.</li></ul><p>In this case, all arguments but the first are ignored and
the function simply returns the internal state again. This is
enough if the code only has been extended. If instead the
internal state is changed (similar to the example in
<a href="#int_state">Changing Internal State</a>),
this is done in this function and <strong>{ok,Chs2}</strong> returned.</p><a name="sup"></a><h4>Changing a Supervisor</h4><p>The supervisor behaviour supports changing the internal state,
that is, changing the restart strategy and maximum restart frequency
properties, as well as changing the existing child specifications.</p><p>Child processes can be added or deleted, but this is not
handled automatically. Instructions must be given by in
the <strong>.appup</strong> file.</p><h4>Changing Properties</h4><p>Since the supervisor is to change its internal state,
synchronized code replacement is required. However,
a special <strong>update</strong> instruction must be used.</p><p>First, the new version of the callback module must be loaded,
both in the case of upgrade and downgrade. Then the new return
value of <strong>init/1</strong> can be checked and the internal state be
changed accordingly.</p><p>The following <strong>upgrade</strong> instruction is used for
supervisors:</p><pre><code class="">
{update, Module, supervisor}</code></pre><p><em>Example:</em> To change the restart strategy of
<strong>ch_sup</strong> (from
<a href="./sup_princ#ex">Supervisor Behaviour</a>)
from <strong>one_for_one</strong> to <strong>one_for_all</strong>, change the callback
function <strong>init/1</strong> in <strong>ch_sup.erl</strong>:</p><pre><code class="">
-module(ch_sup).
...

init(_Args) -&gt;
    {ok, {#{strategy =&gt; one_for_all, ...}, ...}}.</code></pre><p>The file <strong>ch_app.appup</strong>:</p><pre><code class="">
{"2",
 [{"1", [{update, ch_sup, supervisor}]}],
 [{"1", [{update, ch_sup, supervisor}]}]
}.</code></pre><h4>Changing Child Specifications</h4><p>The instruction, and thus the <strong>.appup</strong> file, when
changing an existing child specification, is the same as when
changing properties as described earlier:</p><pre><code class="">
{"2",
 [{"1", [{update, ch_sup, supervisor}]}],
 [{"1", [{update, ch_sup, supervisor}]}]
}.</code></pre><p>The changes do not affect existing child processes. For
example, changing the start function only specifies how
the child process is to be restarted, if needed later on.</p><p>The id of the child specification cannot be changed.</p><p>Changing the <strong>Modules</strong> field of the child
specification can affect the release handling process itself,
as this field is used to identify which processes are affected
when doing a synchronized code replacement.</p><a name="sup_add"></a><h4>Adding and Deleting Child Processes</h4><p>As stated earlier, changing child specifications does not affect
existing child processes. New child specifications are
automatically added, but not deleted. Child processes are
not automatically started or terminated, this must be
done using <strong>apply</strong> instructions.</p><p><em>Example:</em> Assume a new child process <strong>m1</strong> is to be
added to <strong>ch_sup</strong> when upgrading <strong>ch_app</strong> from "1" to "2".
This means <strong>m1</strong> is to be deleted when downgrading from
"2" to "1":</p><pre><code class="">
{"2",
 [{"1",
   [{update, ch_sup, supervisor},
    {apply, {supervisor, restart_child, [ch_sup, m1]}}
   ]}],
 [{"1",
   [{apply, {supervisor, terminate_child, [ch_sup, m1]}},
    {apply, {supervisor, delete_child, [ch_sup, m1]}},
    {update, ch_sup, supervisor}
   ]}]
}.</code></pre><p>The order of the instructions is important.</p><p>The supervisor must be registered as
<strong>ch_sup</strong> for the script to work. If the supervisor is not
registered, it cannot be accessed directly from the script.
Instead a help function that finds the pid of the supervisor
and calls <strong>supervisor:restart_child</strong>, and so on, must be
written. This function is then to be called from the script
using the <strong>apply</strong> instruction.</p><p>If the module <strong>m1</strong> is introduced in version "2" of
<strong>ch_app</strong>, it must also be loaded when upgrading and
deleted when downgrading:</p><pre><code class="">
{"2",
 [{"1",
   [{add_module, m1},
    {update, ch_sup, supervisor},
    {apply, {supervisor, restart_child, [ch_sup, m1]}}
   ]}],
 [{"1",
   [{apply, {supervisor, terminate_child, [ch_sup, m1]}},
    {apply, {supervisor, delete_child, [ch_sup, m1]}},
    {update, ch_sup, supervisor},
    {delete_module, m1}
   ]}]
}.</code></pre><p>As stated earlier, the order of the instructions is important.
When upgrading, <strong>m1</strong> must be loaded, and the supervisor
child specification changed, before the new child process can
be started. When downgrading, the child process must be
terminated before the child specification is changed and the module
is deleted.</p><h4>Adding or Deleting a Module</h4><p><em>Example:</em> A new functional module <strong>m</strong> is added to
<strong>ch_app</strong>:</p><pre><code class="">
{"2",
 [{"1", [{add_module, m}]}],
 [{"1", [{delete_module, m}]}]</code></pre><h4>Starting or Terminating a Process</h4><p>In a system structured according to the OTP design principles,
any process would be a child process belonging to a supervisor, see
<a href="#sup_add">Adding and Deleting Child Processes</a>
in Changing a Supervisor.</p><h4>Adding or Removing an Application</h4><p>When adding or removing an application, no <strong>.appup</strong> file
is needed. When generating <strong>relup</strong>, the <strong>.rel</strong> files
are compared and the <strong>add_application</strong> and
<strong>remove_application</strong> instructions are added automatically.</p><h4>Restarting an Application</h4><p>Restarting an application is useful when a change is too
complicated to be made without restarting the processes, for
example, if the supervisor hierarchy has been restructured.</p><p><em>Example:</em> When adding a child <strong>m1</strong> to <strong>ch_sup</strong>, as in
<a href="#sup_add">Adding and Deleting Child Processes</a>
in Changing a Supervisor, an alternative to updating
the supervisor is to restart the entire application:</p><pre><code class="">
{"2",
 [{"1", [{restart_application, ch_app}]}],
 [{"1", [{restart_application, ch_app}]}]
}.</code></pre><a name="app_spec"></a><h4>Changing an Application Specification</h4><p>When installing a release, the application specifications are
automatically updated before evaluating the <strong>relup</strong> script.
Thus, no instructions are needed in the <strong>.appup</strong> file:</p><pre>
{"2",
 [{"1", []}],
 [{"1", []}]
}.</pre><h4>Changing Application Configuration</h4><p>Changing an application configuration by updating the <strong>env</strong>
key in the <strong>.app</strong> file is an instance of changing an
application specification, see the previous section.</p><p>Alternatively, application configuration parameters can be
added or updated in <strong>sys.config</strong>.</p><h4>Changing Included Applications</h4><p>The release handling instructions for adding, removing, and
restarting applications apply to primary applications only.
There are no corresponding instructions for included
applications. However, since an included application is really a
supervision tree with a topmost supervisor, started as a child
process to a supervisor in the including application, a
<strong>relup</strong> file can be manually created.</p><p><em>Example:</em> Assume there is a release containing an application
<strong>prim_app</strong>, which have a supervisor <strong>prim_sup</strong> in its
supervision tree.</p><p>In a new version of the release, the application <strong>ch_app</strong>
is to be included in <strong>prim_app</strong>. That is,
its topmost supervisor <strong>ch_sup</strong> is to be started as a child
process to <strong>prim_sup</strong>.</p><p>The workflow is as follows:</p><p><em>Step 1)</em> Edit the code for <strong>prim_sup</strong>:</p><pre><code class="">
init(...) -&gt;
    {ok, {...supervisor flags...,
          [...,
           {ch_sup, {ch_sup,start_link,[]},
            permanent,infinity,supervisor,[ch_sup]},
           ...]}}.</code></pre><p><em>Step 2)</em> Edit the <strong>.app</strong> file for <strong>prim_app</strong>:</p><pre><code class="">
{application, prim_app,
 [...,
  {vsn, "2"},
  ...,
  {included_applications, [ch_app]},
  ...
 ]}.</code></pre><p><em>Step 3)</em> Create a new <strong>.rel</strong> file, including
<strong>ch_app</strong>:</p><pre><code class="">
{release,
 ...,
 [...,
  {prim_app, "2"},
  {ch_app, "1"}]}.</code></pre><p>The included application can be started in two ways.
This is described in the next two sections.</p><h4>Application Restart</h4><p><em>Step 4a)</em> One way to start the included application is to
restart the entire <strong>prim_app</strong> application. Normally, the
<strong>restart_application</strong> instruction in the <strong>.appup</strong> file
for <strong>prim_app</strong> would be used.</p><p>However, if this is done and a <strong>relup</strong> file is generated,
not only would it contain instructions for restarting (that is,
removing and adding) <strong>prim_app</strong>, it would also contain
instructions for starting <strong>ch_app</strong> (and stopping it, in
the case of downgrade). This is because <strong>ch_app</strong> is included
in the new <strong>.rel</strong> file, but not in the old one.</p><p>Instead, a correct <strong>relup</strong> file can be created manually,
either from scratch or by editing the generated version.
The instructions for starting/stopping <strong>ch_app</strong> are
replaced by instructions for loading/unloading the application:</p><pre><code class="">
{"B",
 [{"A",
   [],
   [{load_object_code,{ch_app,"1",[ch_sup,ch3]}},
    {load_object_code,{prim_app,"2",[prim_app,prim_sup]}},
    point_of_no_return,
    {apply,{application,stop,[prim_app]}},
    {remove,{prim_app,brutal_purge,brutal_purge}},
    {remove,{prim_sup,brutal_purge,brutal_purge}},
    {purge,[prim_app,prim_sup]},
    {load,{prim_app,brutal_purge,brutal_purge}},
    {load,{prim_sup,brutal_purge,brutal_purge}},
    {load,{ch_sup,brutal_purge,brutal_purge}},
    {load,{ch3,brutal_purge,brutal_purge}},
    {apply,{application,load,[ch_app]}},
    {apply,{application,start,[prim_app,permanent]}}]}],
 [{"A",
   [],
   [{load_object_code,{prim_app,"1",[prim_app,prim_sup]}},
    point_of_no_return,
    {apply,{application,stop,[prim_app]}},
    {apply,{application,unload,[ch_app]}},
    {remove,{ch_sup,brutal_purge,brutal_purge}},
    {remove,{ch3,brutal_purge,brutal_purge}},
    {purge,[ch_sup,ch3]},
    {remove,{prim_app,brutal_purge,brutal_purge}},
    {remove,{prim_sup,brutal_purge,brutal_purge}},
    {purge,[prim_app,prim_sup]},
    {load,{prim_app,brutal_purge,brutal_purge}},
    {load,{prim_sup,brutal_purge,brutal_purge}},
    {apply,{application,start,[prim_app,permanent]}}]}]
}.</code></pre><h4>Supervisor Change</h4><p><em>Step 4b)</em> Another way to start the included
application (or stop it
in the case of downgrade) is by combining instructions for
adding and removing child processes to/from <strong>prim_sup</strong> with
instructions for loading/unloading all <strong>ch_app</strong> code and
its application specification.</p><p>Again, the <strong>relup</strong> file is created manually. Either from
scratch or by editing a generated version. Load all code for
<strong>ch_app</strong> first, and also load the application
specification, before <strong>prim_sup</strong> is updated. When
downgrading, <strong>prim_sup</strong> is to updated first, before
the code for <strong>ch_app</strong> and its application specification
are unloaded.</p><pre><code class="">
{"B",
 [{"A",
   [],
   [{load_object_code,{ch_app,"1",[ch_sup,ch3]}},
    {load_object_code,{prim_app,"2",[prim_sup]}},
    point_of_no_return,
    {load,{ch_sup,brutal_purge,brutal_purge}},
    {load,{ch3,brutal_purge,brutal_purge}},
    {apply,{application,load,[ch_app]}},
    {suspend,[prim_sup]},
    {load,{prim_sup,brutal_purge,brutal_purge}},
    {code_change,up,[{prim_sup,[]}]},
    {resume,[prim_sup]},
    {apply,{supervisor,restart_child,[prim_sup,ch_sup]}}]}],
 [{"A",
   [],
   [{load_object_code,{prim_app,"1",[prim_sup]}},
    point_of_no_return,
    {apply,{supervisor,terminate_child,[prim_sup,ch_sup]}},
    {apply,{supervisor,delete_child,[prim_sup,ch_sup]}},
    {suspend,[prim_sup]},
    {load,{prim_sup,brutal_purge,brutal_purge}},
    {code_change,down,[{prim_sup,[]}]},
    {resume,[prim_sup]},
    {remove,{ch_sup,brutal_purge,brutal_purge}},
    {remove,{ch3,brutal_purge,brutal_purge}},
    {purge,[ch_sup,ch3]},
    {apply,{application,unload,[ch_app]}}]}]
}.</code></pre><h4>Changing Non-Erlang Code</h4><p>Changing code for a program written in another programming
language than Erlang, for example, a port program, is
application-dependent and OTP provides no special support for it.</p><p><em>Example:</em> When changing code for a port program, assume that
the Erlang process controlling the port is a <strong>gen_server</strong>
<strong>portc</strong> and that the port is opened in the callback function
<strong>init/1</strong>:</p><pre><code class="">
init(...) -&gt;
    ...,
    PortPrg = filename:join(code:priv_dir(App), "portc"),
    Port = open_port({spawn,PortPrg}, [...]),
    ...,
    {ok, #state{port=Port, ...}}.</code></pre><p>If the port program is to be updated, the code for the
<strong>gen_server</strong> can be extended with a <strong>code_change</strong> function,
which closes the old port and opens a new port.
(If necessary, the <strong>gen_server</strong> can
first request data that must be saved from the port
program and pass this data to the new port):</p><pre><code class="">
code_change(_OldVsn, State, port) -&gt;
    State#state.port ! close,
    receive
        {Port,close} -&gt;
            true
    end,
    PortPrg = filename:join(code:priv_dir(App), "portc"),
    Port = open_port({spawn,PortPrg}, [...]),
    {ok, #state{port=Port, ...}}.</code></pre><p>Update the application version number in the <strong>.app</strong> file
and write an <strong>.appup</strong> file:</p><pre><code class="">
["2",
 [{"1", [{update, portc, {advanced,port}}]}],
 [{"1", [{update, portc, {advanced,port}}]}]
].</code></pre><p>Ensure that the <strong>priv</strong> directory, where the C program is
located, is included in the new release package:</p><pre>
1&gt; <span class="input">systools:make_tar("my_release", [{dirs,[priv]}]).</span>
...</pre><h4>Emulator Restart and Upgrade</h4><p>Two upgrade instructions restart the emulator:</p><ul><li><p><strong>restart_new_emulator</strong></p> <p>Intended when ERTS, Kernel, STDLIB, or
SASL is upgraded. It is automatically added when the
<strong>relup</strong> file is generated by <strong>systools:make_relup/3,4</strong>.
It is executed before all other upgrade instructions.
For more information about this instruction, see
restart_new_emulator (Low-Level) in
<a href="./release_handling#restart_new_emulator_instr">Release Handling Instructions</a>.
</p></li><li><p><strong>restart_emulator</strong></p> <p>Used when a restart of the emulator is required after all
other upgrade instructions are executed.
For more information about this instruction, see
restart_emulator (Low-Level) in
<a href="./release_handling#restart_emulator_instr">Release Handling Instructions</a>.
</p></li></ul><p>If an emulator restart is necessary and no upgrade instructions
are needed, that is, if the restart itself is enough for the
upgraded applications to start running the new versions, a
simple <strong>relup</strong> file can be created manually:</p><pre><code class="">
{"B",
 [{"A",
   [],
   [restart_emulator]}],
 [{"A",
   [],
   [restart_emulator]}]
}.</code></pre><p>In this case, the release handler framework with automatic
packing and unpacking of release packages, automatic path
updates, and so on, can be used without having to specify
<strong>.appup</strong> files.</p><h4>Emulator Upgrade From Pre OTP R15</h4><p>From OTP R15, an emulator upgrade is performed by restarting
the emulator with new versions of the core applications
(Kernel, STDLIB, and SASL) before loading code
and running upgrade instruction for other applications. For this
to work, the release to upgrade from must include OTP R15 or
later.</p><p>For the case where the release to upgrade from includes an
earlier emulator version, <strong>systools:make_relup</strong> creates a
backwards compatible relup file. This means that all upgrade
instructions are executed before the emulator is
restarted. The new application code is therefore loaded into
the old emulator. If the new code is compiled with the new
emulator, there can be cases where the beam format has changed
and beam files cannot be loaded. To overcome this problem, compile
the new code with the old emulator.</p></body></html>