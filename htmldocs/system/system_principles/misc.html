<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Support, Compatibility, Deprecations, and Removal</h1><h2>Introduction</h2><p>This document describes strategy regarding supported Releases,
compatibility, deprecations and removal of functionality. This
document was introduced in OTP 21. Actions taken regarding these
issues before OTP 21 did not adhere this document.</p><a name="supported_releases"></a><h2>Supported Releases</h2><p>
In general, bugs are only fixed on the latest
<a href="./versions#releases_and_patches">release</a>,
and new features are introduced in the upcoming release that is
under development. However, when we, due to internal reasons, fix
bugs on older releases, these will be available and announced as well.
</p><p>
Due to the above, pull requests are only accepted on the
<strong>maint</strong> and the <strong>master</strong> branches in our
<a href="https://github.com/erlang/otp">git repository</a>.
The <strong>maint</strong> branch contains changes planned for the next
<a href="./versions#releases_and_patches">maintenance patch package</a>
on the latest OTP release and the <strong>master</strong> branch contain
changes planned for the upcoming OTP release.
</p><a name="compatibility"></a><h2>Compatibility</h2><p>
We always strive to remain as compatible as possible
even in the cases where we give no compatibility guarantees.
</p><p>
Different parts of the system will be handled differently
regarding compatibility. The following items describe how
different parts of the system are handled.
</p><dl><dt>Erlang Distribution</dt><dd> <p>
Erlang nodes can communicate across at least
two preceding and two subsequent releases.
</p> </dd><dt>Compiled BEAM Code, NIF Libraries and Drivers</dt><dd> <p>
Compiled code can be loaded on at least two
subsequent releases.
</p> <p>
Loading on previous releases is <em>not</em> supported.
</p> </dd><dt>Compiled HiPE Code</dt><dd> <p>
Compiled HiPE code can be loaded on the exact same build
of ERTS that was used when compiling the code. It might
however work on other builds, the emulator verifies
checksums in order to determine if it can load the code
or not. Note that HiPE has some limitations. For more
information see the documentation of the
<a href="./HiPE_app">HiPE</a> application.
</p> </dd><dt>APIs</dt><dd> <p>Compatible between releases.</p> </dd><dt>Compiler Warnings</dt><dd> <p>New warnings may be issued between releases.</p> </dd><dt>Command Line Arguments</dt><dd> <p>Incompatible changes may occur between releases.</p> </dd><dt>OTP Build Procedures</dt><dd><p>Incompatible changes may occur between releases.</p></dd></dl><p>
Under certain circumstances incompatible changes might be
introduced even in parts of the system that should be compatible
between releases. Things that might trigger incompatible changes
like this are:
</p><dl><dt>Security Issues</dt><dd> <p>
It might be necessary to introduce incompatible changes
in order to solve a security issue. This kind of
incompatibility might occur in a patch.
</p> </dd><dt>Bug Fixes</dt><dd> <p>
We will not be bug-compatible. A bug fix might introduce
incompatible changes. This kind of incompatibility
might occur in a patch.
</p> </dd><dt>Severe Previous Design Issues</dt><dd> <p>
Some parts of OTP were designed a very long time ago and
did not necessarily take today's computing environments into
account. In some cases the consequences of those design
decisions are too severe. This may be performance wise,
scalability wise, etc. If we deem the consequences too
severe, we might introduce incompatible changes. This kind
of incompatibility will not be introduced in a patch, but
instead in the next release.
</p> </dd></dl><p>
Peripheral, trace, and debug functionality is at greater
risk of being changed in an incompatible way than functionality
in the language itself and core libraries used during operation.
</p><a name="deprecation"></a><h2>Deprecation</h2><p>
Functionality is deprecated when new functionality is
introduced that is preferred to be used instead of the
old functionality that is being deprecated. The deprecation
does <em>not</em> imply removal of the functionality unless
an upcoming removal is explicitly stated in the deprecation.
</p><p>
Deprecated functionality will be documented as deprecated, and
compiler warnings will be issued, when appropriate, as
early as possible. That is, the new preferred functionality
will appear at the same time as the deprecation is issued.
A new deprecation will at least be announced in a release
note and the documentation.
</p><a name="removal"></a><h2>Removal</h2><p>
Legacy solutions may eventually need to be removed. In such
cases, they will be phased out on a long enough time period
to give users the time to adapt. Before removal of
functionality it will be deprecated at least during one
release with an explicit announcement about
the upcoming removal. A new deprecation will at least be
announced in a release note and the documentation.
</p><p>
Peripheral, trace, and debug functionality is at greater
risk of removal than functionality in the language itself
and core libraries used during operation.
</p></body></html>