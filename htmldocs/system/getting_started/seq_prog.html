<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Sequential Programming</h1><h2>The Erlang Shell</h2><p>
Most operating systems have a command interpreter or shell, UNIX
and Linux have many, Windows has the command prompt. Erlang has
its own shell where bits of Erlang code can be written directly,
and be evaluated to see what happens
(see the <a href="./shell">shell(3)</a>
manual page in STDLIB).
</p><p>Start
the Erlang shell (in Linux or UNIX) by starting a shell or
command interpreter in your operating system and typing
<strong>erl</strong>. You will see something like this.</p><pre>
% <span class="input">erl</span>
Erlang R15B (erts-5.9.1) [source] [smp:8:8] [rq:8] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.9.1  (abort with ^G)
1&gt;</pre><p>Type "2 + 5." in the shell and then press Enter (carriage return).
Notice that you tell the shell you are done entering code by finishing
with a full stop "." and a carriage return.</p><pre>
1&gt; <span class="input">2 + 5.</span>
7
2&gt;</pre><p>As shown, the Erlang shell numbers the lines that
can be entered, (as 1&gt; 2&gt;) and that it correctly says
that 2 + 5 is 7. If you make writing mistakes in the shell,
you can delete with the backspace key, as in most shells.
There are many more editing commands in the shell
(see <a href="./tty">tty - A command line interface</a> in ERTS User's Guide).</p><p>(Notice that many line numbers given by the shell in the
following examples are out of sequence. This is because this
tutorial was written and code-tested in separate sessions).</p><p>Here is a bit more complex calculation:</p><pre>
2&gt; <span class="input">(42 + 77) * 66 / 3.</span>
2618.0</pre><p>Notice the use of brackets, the multiplication operator "*",
and the division operator "/", as in normal arithmetic (see
<a href="./expressions">Expressions</a>).</p><p>Press Control-C to shut down the Erlang system and the Erlang
shell.</p><p>The following output is shown:</p><pre>
BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded
       (v)ersion (k)ill (D)b-tables (d)istribution
<span class="input">a</span>
%</pre><p>Type "a" to leave the Erlang system.</p><p>Another way to shut down the Erlang system is by entering
<strong>halt()</strong>:</p><pre>
3&gt; <span class="input">halt().</span>
% </pre><h2>Modules and Functions</h2><p>A programming language is not much use if you only can run code
from the shell. So here is a small Erlang program. Enter it into
a file named <strong>tut.erl</strong> using a suitable
text editor. The file name <strong>tut.erl</strong> is important, and also
that it is in the same directory as the one where you started
<strong>erl</strong>). If you are lucky your editor has an Erlang mode
that makes it easier for you to enter and format your code
nicely (see <a href="./erlang_mode_chapter">The Erlang mode for Emacs</a> in Tools User's Guide), but you can manage
perfectly well without. Here is the code to enter:</p><pre><code class="">
-module(tut).
-export([double/1]).

double(X) -&gt;
    2 * X.</code></pre><p>It is not hard to guess that this program doubles the value of
numbers. The first two lines of the code are described later.
Let us compile the program. This can be done in an Erlang shell
as follows, where <strong>c</strong> means compile:</p><pre>
3&gt; <span class="input">c(tut).</span>
{ok,tut}</pre><p>The <strong>{ok,tut}</strong> means that the compilation is OK. If it
says "error" it means that there is some mistake in the text
that you entered. Additional error messages gives an idea to
what is wrong so you can modify the text and then try to compile
the program again.</p><p>Now run the program:</p><pre>
4&gt; <span class="input">tut:double(10).</span>
20</pre><p>As expected, double of 10 is 20.</p><p>Now let us get back to the first two lines of the code. Erlang
programs are
written in files. Each file contains an Erlang
<em>module</em>. The first line of code in the module is
the module name (see
<a href="./modules">Modules</a>):</p><pre><code class="">
-module(tut).</code></pre><p>Thus, the module is called <em>tut</em>. Notice
the full stop "." at the end of the line. The files which are
used to store
the module must have the same name as the module but with
the extension ".erl". In this case the file name is <strong>tut.erl</strong>.
When using a function in another module, the syntax
<strong>module_name:function_name(arguments)</strong> is used. So the
following means call function <strong>double</strong> in module <strong>tut</strong>
with argument "10".</p><pre>
4&gt; <span class="input">tut:double(10).</span></pre><p>The second line says that the module <strong>tut</strong> contains a
function called <strong>double</strong>, which takes one argument
(<strong>X</strong> in our example):</p><pre><code class="">
-export([double/1]).</code></pre><p>The second line also says that this function can be called from
outside the module <strong>tut</strong>. More about this later. Again,
notice the "." at the end of the line.</p><p>Now for a more complicated example, the factorial of a number.
For example, the factorial of 4 is 4 * 3 * 2 * 1, which equals 24.</p><p>Enter the following code in a file named <strong>tut1.erl</strong>:</p><pre><code class="">
-module(tut1).
-export([fac/1]).

fac(1) -&gt;
    1;
fac(N) -&gt;
    N * fac(N - 1).</code></pre><p>So this is a module, called <strong>tut1</strong> that contains a
function called <strong>fac&gt;</strong>, which takes one argument,
<strong>N</strong>.</p><p>The first part says that the factorial of 1 is 1.:</p><pre><code class="">
fac(1) -&gt;
    1;</code></pre><p>Notice that this part ends with a semicolon ";" that indicates
that there is more of the function <strong>fac&gt;</strong> to come.</p><p>The second part says that the factorial of N is N multiplied
by the factorial of N - 1:</p><pre><code class="">
fac(N) -&gt;
    N * fac(N - 1).</code></pre><p>Notice that this part ends with a "." saying that there are
no more parts of this function.</p><p>Compile the file:</p><pre>
5&gt; <span class="input">c(tut1).</span>
{ok,tut1}</pre><p>And now calculate the factorial of 4.</p><pre>
6&gt; <span class="input">tut1:fac(4).</span>
24</pre><p>Here the function <strong>fac&gt;</strong> in module <strong>tut1</strong> is called
with argument <strong>4</strong>.</p><p>A function can have many arguments. Let us expand the module
<strong>tut1</strong> with the function to multiply two numbers:</p><pre><code class="">
-module(tut1).
-export([fac/1, mult/2]).

fac(1) -&gt;
    1;
fac(N) -&gt;
    N * fac(N - 1).

mult(X, Y) -&gt;
    X * Y.</code></pre><p>Notice that it is also required to expand the <strong>-export</strong> line
with the information that there is another function <strong>mult</strong>
with two arguments.</p><p>Compile:</p><pre>
7&gt; <span class="input">c(tut1).</span>
{ok,tut1}</pre><p>Try out the new function <strong>mult</strong>:</p><pre>
8&gt; <span class="input">tut1:mult(3,4).</span>
12</pre><p>In this example the numbers are integers and the arguments
in the functions in the code <strong>N</strong>, <strong>X</strong>, and <strong>Y</strong> are
called variables. Variables must start with a capital letter
(see
<a href="./expressions">Variables</a>).
Examples of variables are
<strong>Number</strong>, <strong>ShoeSize</strong>, and <strong>Age</strong>.</p><h2>Atoms</h2><p>Atom is another data type in Erlang. Atoms start with a small
letter (see
<a href="./data_types">Atom</a>),
for example, <strong>charles</strong>,
<strong>centimeter</strong>, and <strong>inch</strong>. Atoms are simply names, nothing
else. They are not like variables, which can have a value.</p><p>Enter the next program in a file named <strong>tut2.erl</strong>). It can be
useful for converting from inches to centimeters and conversely:</p><pre><code class="">
-module(tut2).
-export([convert/2]).

convert(M, inch) -&gt;
    M / 2.54;

convert(N, centimeter) -&gt;
    N * 2.54.</code></pre><p>Compile:</p><pre>
9&gt; <span class="input">c(tut2).</span>
{ok,tut2}
</pre><p>Test:</p><pre>
10&gt; <span class="input">tut2:convert(3, inch).</span>
1.1811023622047243
11&gt; <span class="input">tut2:convert(7, centimeter).</span>
17.78</pre><p>Notice the introduction of decimals (floating point numbers)
without any explanation. Hopefully you can cope with that.</p><p>Let us see what happens if something other than <strong>centimeter</strong> or
<strong>inch</strong> is entered in the <strong>convert</strong> function:</p><pre>
12&gt; <span class="input">tut2:convert(3, miles).</span>
** exception error: no function clause matching tut2:convert(3,miles) (tut2.erl, line 4)</pre><p>The two parts of the <strong>convert</strong> function are called its
clauses. As shown, <strong>miles</strong> is not part of either of
the clauses. The Erlang system cannot <em>match</em> either of
the clauses so an error message <strong>function_clause</strong> is returned.
The shell formats the error message nicely, but the error tuple
is saved in the shell's history list and can be output by the shell
command <strong>v/1</strong>:</p><pre>
13&gt; <span class="input">v(12).</span>
{'EXIT',{function_clause,[{tut2,convert,
                                [3,miles],
                                [{file,"tut2.erl"},{line,4}]},
                          {erl_eval,do_apply,6,
                                    [{file,"erl_eval.erl"},{line,677}]},
                          {shell,exprs,7,[{file,"shell.erl"},{line,687}]},
                          {shell,eval_exprs,7,[{file,"shell.erl"},{line,642}]},
                          {shell,eval_loop,3,
                                 [{file,"shell.erl"},{line,627}]}]}}</pre><h2>Tuples</h2><p>Now the <strong>tut2</strong> program is hardly good programming style.
Consider:</p><pre><code class="">
tut2:convert(3, inch).</code></pre><p>Does this mean that 3 is in inches? Or does it mean that 3 is
in centimeters
and is to be converted to inches? Erlang has a way to group
things together to make things more understandable. These are called
<em>tuples</em> and are surrounded by curly brackets, "{" and "}".</p><p>So, <strong>{inch,3}</strong> denotes 3 inches and
<strong>{centimeter,5}</strong> denotes 5 centimeters. Now let us write a
new program that converts centimeters to inches and conversely.
Enter the following code in a file called <strong>tut3.erl</strong>):</p><pre><code class="">
-module(tut3).
-export([convert_length/1]).

convert_length({centimeter, X}) -&gt;
    {inch, X / 2.54};
convert_length({inch, Y}) -&gt;
    {centimeter, Y * 2.54}.</code></pre><p>Compile and test:</p><pre>
14&gt; <span class="input">c(tut3).</span>
{ok,tut3}
15&gt; <span class="input">tut3:convert_length({inch, 5}).</span>
{centimeter,12.7}
16&gt; <span class="input">tut3:convert_length(tut3:convert_length({inch, 5})).</span>
{inch,5.0}</pre><p>Notice on line 16 that 5 inches is converted to centimeters and back
again and reassuringly get back to the original value. That is,
the argument to a function can be the result of another function.
Consider how line 16 (above) works.
The argument given to the function <strong>{inch,5}</strong> is first
matched against the first head clause of <strong>convert_length</strong>,
that is, <strong>convert_length({centimeter,X})</strong>. It can be seen
that <strong>{centimeter,X}</strong> does not match <strong>{inch,5}</strong>
(the head is the bit before the "-&gt;"). This having failed,
let us try
the head of the next clause that is, <strong>convert_length({inch,Y})</strong>.
This matches, and <strong>Y</strong> gets the value 5.</p><p>Tuples can have more than two parts, in fact
as many parts as you want, and contain any valid Erlang
<em>term</em>. For example, to represent the temperature of
various cities of the world:</p><pre><code class="">
{moscow, {c, -10}}
{cape_town, {f, 70}}
{paris, {f, 28}}</code></pre><p>Tuples have a fixed number of items in them. Each item in a
tuple is called an <em>element</em>. In the tuple
<strong>{moscow,{c,-10}}</strong>, element 1 is <strong>moscow</strong> and element
2 is <strong>{c,-10}</strong>. Here <strong>c</strong> represents Celsius and
<strong>f</strong> Fahrenheit.</p><h2>Lists</h2><p>Whereas tuples group things together, it is also needed to
represent lists of things. Lists in Erlang are surrounded by
square brackets, "[" and "]". For example, a list of the
temperatures of various cities in the world can be:</p><pre><code class="">
[{moscow, {c, -10}}, {cape_town, {f, 70}}, {stockholm, {c, -4}},
 {paris, {f, 28}}, {london, {f, 36}}]</code></pre><p>Notice that this list was so long that it did not fit on one line.
This does not matter, Erlang allows line breaks at all "sensible
places" but not, for example, in the middle of atoms, integers,
and others.</p><p>A useful way of looking at parts of lists, is by using "|".
This is best explained by an example using the shell:</p><pre>
17&gt; <span class="input">[First |TheRest] = [1,2,3,4,5].</span>
[1,2,3,4,5]
18&gt; <span class="input">First.</span>
1
19&gt; <span class="input">TheRest.</span>
[2,3,4,5]</pre><p>To separate the first elements of the list from the rest of the
list, <strong>|</strong> is used. <strong>First</strong> has got value 1 and
<strong>TheRest</strong> has got the value [2,3,4,5].</p><p>Another example:</p><pre>
20&gt; <span class="input">[E1, E2 | R] = [1,2,3,4,5,6,7].</span>
[1,2,3,4,5,6,7]
21&gt; <span class="input">E1.</span>
1
22&gt; <span class="input">E2.</span>
2
23&gt; <span class="input">R.</span>
[3,4,5,6,7]</pre><p>Here you see the use of <strong>|</strong> to get the first two elements from
the list. If you try to get more elements from the list
than there are elements in the list, an error is returned. Notice
also the special case of the list with no elements, []:</p><pre>
24&gt; <span class="input">[A, B | C] = [1, 2].</span>
[1,2]
25&gt; <span class="input">A.</span>
1
26&gt; <span class="input">B.</span>
2
27&gt; <span class="input">C.</span>
[]</pre><p>In the previous examples, new variable names are used, instead of
reusing the old ones: <strong>First</strong>, <strong>TheRest</strong>, <strong>E1</strong>,
<strong>E2</strong>, <strong>R</strong>, <strong>A</strong>, <strong>B</strong>, and <strong>C</strong>. The reason
for this is that a variable can only be given a value once in its
context (scope). More about this later.</p><p>The following example shows how to find the length of a list.
Enter the following code in a file named <strong>tut4.erl</strong>):</p><pre><code class="">
-module(tut4).

-export([list_length/1]).

list_length([]) -&gt;
    0;    
list_length([First | Rest]) -&gt;
    1 + list_length(Rest).</code></pre><p>Compile and test:</p><pre>
28&gt; <span class="input">c(tut4).</span>
{ok,tut4}
29&gt; <span class="input">tut4:list_length([1,2,3,4,5,6,7]).</span>
7</pre><p>Explanation:</p><pre><code class="">
list_length([]) -&gt;
    0;</code></pre><p>The length of an empty list is obviously 0.</p><pre><code class="">
list_length([First | Rest]) -&gt;
    1 + list_length(Rest).</code></pre><p>The length of a list with the first element <strong>First</strong> and
the remaining elements <strong>Rest</strong> is 1 + the length of
<strong>Rest</strong>.</p><p>(Advanced readers only: This is not tail recursive, there is a
better way to write this function.)</p><p>In general, tuples are used where "records"
or "structs" are used in other languages. Also, lists are used when
representing things with varying sizes, that is, where
linked lists are used in other languages.</p><p>Erlang does not have a string data type. Instead, strings can be
represented by lists of Unicode characters. This implies for example that
the list <strong>[97,98,99]</strong> is equivalent to "abc". The Erlang shell is
"clever" and guesses what list you  mean and outputs it
in what it thinks is the most appropriate form, for example:</p><pre>
30&gt; <span class="input">[97,98,99].</span>
"abc"</pre><h2>Maps</h2><p>Maps are a set of key to value associations. These associations
are encapsulated with "#{" and "}". To create an association
from "key" to value 42:</p><pre><code class="">
&gt; #{ "key" =&gt; 42 }.
#{"key" =&gt; 42}</code></pre><p>Let us jump straight into the deep end with an example using some
interesting features.</p><p>The following example shows how to calculate alpha blending
using maps to reference color and alpha channels. Enter the code
in a file named <strong>color.erl</strong>):</p><pre><code class="">
-module(color).

-export([new/4, blend/2]).

-define(is_channel(V), (is_float(V) andalso V &gt;= 0.0 andalso V =&lt; 1.0)).

new(R,G,B,A) when ?is_channel(R), ?is_channel(G),
                  ?is_channel(B), ?is_channel(A) -&gt;
    #{red =&gt; R, green =&gt; G, blue =&gt; B, alpha =&gt; A}.

blend(Src,Dst) -&gt;
    blend(Src,Dst,alpha(Src,Dst)).

blend(Src,Dst,Alpha) when Alpha &gt; 0.0 -&gt;
    Dst#{
        red   := red(Src,Dst) / Alpha,
        green := green(Src,Dst) / Alpha,
        blue  := blue(Src,Dst) / Alpha,
        alpha := Alpha
    };
blend(_,Dst,_) -&gt;
    Dst#{
        red   := 0.0,
        green := 0.0,
        blue  := 0.0,
        alpha := 0.0
    }.

alpha(#{alpha := SA}, #{alpha := DA}) -&gt;
    SA + DA*(1.0 - SA).

red(#{red := SV, alpha := SA}, #{red := DV, alpha := DA}) -&gt;
    SV*SA + DV*DA*(1.0 - SA).
green(#{green := SV, alpha := SA}, #{green := DV, alpha := DA}) -&gt;
    SV*SA + DV*DA*(1.0 - SA).
blue(#{blue := SV, alpha := SA}, #{blue := DV, alpha := DA}) -&gt;
    SV*SA + DV*DA*(1.0 - SA).</code></pre><p>Compile and test:</p><pre>
&gt; <span class="input">c(color).</span>
{ok,color}
&gt; <span class="input">C1 = color:new(0.3,0.4,0.5,1.0).</span>
#{alpha =&gt; 1.0,blue =&gt; 0.5,green =&gt; 0.4,red =&gt; 0.3}
&gt; <span class="input">C2 = color:new(1.0,0.8,0.1,0.3).</span>
#{alpha =&gt; 0.3,blue =&gt; 0.1,green =&gt; 0.8,red =&gt; 1.0}
&gt; <span class="input">color:blend(C1,C2).</span>
#{alpha =&gt; 1.0,blue =&gt; 0.5,green =&gt; 0.4,red =&gt; 0.3}
&gt; <span class="input">color:blend(C2,C1).</span>
#{alpha =&gt; 1.0,blue =&gt; 0.38,green =&gt; 0.52,red =&gt; 0.51}
</pre><p>This example warrants some explanation:</p><pre><code class="">
-define(is_channel(V), (is_float(V) andalso V &gt;= 0.0 andalso V =&lt; 1.0)).</code></pre><p>First a macro <strong>is_channel</strong> is defined to help with the
guard tests. This is only here for convenience and to reduce
syntax cluttering. For more information about macros, see
<a href="./macros"> The Preprocessor</a>.
</p><pre><code class="">
new(R,G,B,A) when ?is_channel(R), ?is_channel(G),
                  ?is_channel(B), ?is_channel(A) -&gt;
    #{red =&gt; R, green =&gt; G, blue =&gt; B, alpha =&gt; A}.</code></pre><p>The function <strong>new/4</strong> creates a new map term and lets the keys
<strong>red</strong>, <strong>green</strong>, <strong>blue</strong>, and <strong>alpha</strong> be
associated with an initial value. In this case, only float
values between and including 0.0 and 1.0 are allowed, as ensured
by the <strong>?is_channel/1</strong> macro for each argument. Only the
<strong>=&gt;</strong> operator is allowed when creating a new map.
</p><p>By calling <strong>blend/2</strong> on any color term created by
<strong>new/4</strong>, the resulting color can be calculated as
determined by the two map terms.
</p><p>The first thing <strong>blend/2</strong> does is to calculate the
resulting alpha channel:
</p><pre><code class="">
alpha(#{alpha := SA}, #{alpha := DA}) -&gt;
    SA + DA*(1.0 - SA).</code></pre><p>The value associated with key <strong>alpha</strong> is fetched for both
arguments using the <strong>:=</strong> operator. The other keys in the
map are ignored, only the key <strong>alpha</strong> is required and
checked for.
</p><p>This is also the case for functions <strong>red/2</strong>,
<strong>blue/2</strong>, and <strong>green/2</strong>.</p><pre><code class="">
red(#{red := SV, alpha := SA}, #{red := DV, alpha := DA}) -&gt;
    SV*SA + DV*DA*(1.0 - SA).</code></pre><p>The difference here is that a check is made for two keys in
each map argument. The other keys are ignored.
</p><p>Finally, let us return the resulting color in <strong>blend/3</strong>:
</p><pre><code class="">
blend(Src,Dst,Alpha) when Alpha &gt; 0.0 -&gt;
    Dst#{
        red   := red(Src,Dst) / Alpha,
        green := green(Src,Dst) / Alpha,
        blue  := blue(Src,Dst) / Alpha,
        alpha := Alpha
    };</code></pre><p>The <strong>Dst</strong> map is updated with new channel values. The
syntax for updating an existing key with a new value is with the
<strong>:=</strong> operator.
</p><h2>Standard Modules and Manual Pages</h2><p>Erlang has many standard modules to help you do things. For
example, the module <strong>io</strong> contains many functions that help
in doing formatted input/output. To look up information about
standard modules, the command <strong>erl -man</strong> can be used at the
operating shell or command prompt (the same place as you started
<strong>erl</strong>). Try the operating system shell command:</p><pre>
% <span class="input">erl -man io</span>
ERLANG MODULE DEFINITION                                    io(3)

MODULE
     io - Standard I/O Server Interface Functions

DESCRIPTION
     This module provides an  interface  to  standard  Erlang  IO
     servers. The output functions all return ok if they are suc-
     ...</pre><p>If this does not work on your system, the documentation is
included as HTML in the Erlang/OTP release. You can also read
the documentation as HTML or download it as PDF from either of
the sites www.erlang.se (commercial Erlang) or www.erlang.org
(open source). For example, for Erlang/OTP release R9B:</p><pre><code class="">
http://www.erlang.org/doc/r9b/doc/index.html</code></pre><h2>Writing Output to a Terminal</h2><p>It is nice to be able to do formatted output in examples, so
the next example shows a simple way to use the <strong>io:format</strong>
function. Like all other exported functions, you can test the
<strong>io:format</strong> function in the shell:</p><pre>
31&gt; <span class="input">io:format("hello world~n", []).</span>
hello world
ok
32&gt; <span class="input">io:format("this outputs one Erlang term: ~w~n", [hello]).</span>
this outputs one Erlang term: hello
ok
33&gt; <span class="input">io:format("this outputs two Erlang terms: ~w~w~n", [hello, world]).</span>
this outputs two Erlang terms: helloworld
ok
34&gt; <span class="input">io:format("this outputs two Erlang terms: ~w ~w~n", [hello, world]).</span>
this outputs two Erlang terms: hello world
ok</pre><p>The function <strong>format/2</strong> (that is, <strong>format</strong> with two
arguments) takes two lists. The first one is nearly always a list
written between " ". This list is printed out as it is,
except that each ~w is replaced by a term taken in order from
the second list. Each ~n is replaced by a new line.
The <strong>io:format/2</strong> function itself returns the atom <strong>ok</strong>
if everything goes as planned. Like other functions in Erlang, it
crashes if an error occurs. This is not a fault in Erlang, it is
a deliberate policy. Erlang has sophisticated mechanisms to
handle errors which are shown later. As an exercise, try to
make <strong>io:format</strong> crash, it should not be difficult. But
notice that although <strong>io:format</strong> crashes, the Erlang shell
itself does not crash.</p><h2>A Larger Example</h2><p>Now for a larger example to consolidate what you have learnt so
far. Assume that you have a list of temperature readings from a number
of cities in the world. Some of them are in Celsius
and some in Fahrenheit (as in the previous list). First let us
convert them all to Celsius, then let us print the data neatly.</p><pre><code class="">
%% This module is in file tut5.erl

-module(tut5).
-export([format_temps/1]).

%% Only this function is exported
format_temps([])-&gt;                        % No output for an empty list
    ok;
format_temps([City | Rest]) -&gt;
    print_temp(convert_to_celsius(City)),
    format_temps(Rest).

convert_to_celsius({Name, {c, Temp}}) -&gt;  % No conversion needed
    {Name, {c, Temp}};
convert_to_celsius({Name, {f, Temp}}) -&gt;  % Do the conversion
    {Name, {c, (Temp - 32) * 5 / 9}}.

print_temp({Name, {c, Temp}}) -&gt;
    io:format("~-15w ~w c~n", [Name, Temp]).</code></pre><pre>
35&gt; <span class="input">c(tut5).</span>
{ok,tut5}
36&gt; <span class="input">tut5:format_temps([{moscow, {c, -10}}, {cape_town, {f, 70}},</span>
<span class="input">{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).</span>
moscow          -10 c
cape_town       21.11111111111111 c
stockholm       -4 c
paris           -2.2222222222222223 c
london          2.2222222222222223 c
ok</pre><p>Before looking at how this program works, notice that
a few comments are added to the code. A comment starts with a
%-character and goes on to the end of the line. Notice also that
the <strong>-export([format_temps/1]).</strong> line only includes
the function <strong>format_temps/1</strong>. The other functions are
<em>local</em> functions, that is, they are not visible from outside
the module <strong>tut5</strong>.</p><p>Notice also that when testing the program from the shell,
the input is spread over two lines as the line was too long.</p><p>When <strong>format_temps</strong> is called the first time, <strong>City</strong>
gets the value <strong>{moscow,{c,-10}}</strong> and <strong>Rest</strong> is
the rest of the list. So the function
<strong>print_temp(convert_to_celsius({moscow,{c,-10}}))</strong> is called.</p><p>Here is a function call as
<strong>convert_to_celsius({moscow,{c,-10}})</strong> as the argument to
the function <strong>print_temp</strong>. When function calls are <em>nested</em>
like this, they execute (evaluate) from the inside out.
That is, first <strong>convert_to_celsius({moscow,{c,-10}})</strong> is evaluated,
which gives the value <strong>{moscow,{c,-10}}</strong> as the temperature
is already in Celsius. Then <strong>print_temp({moscow,{c,-10}})</strong>
is evaluated.
The function <strong>convert_to_celsius</strong> works in a similar way to
the <strong>convert_length</strong> function in the previous example.</p><p><strong>print_temp</strong> simply calls <strong>io:format</strong> in a similar way
to what has been described above. Notice that ~-15w says to print
the "term" with a field length (width) of 15 and left justify it.
(see the <a href="../stdlib/io#fwrite/1">io(3)</a>) manual page in STDLIB.</p><p>Now <strong>format_temps(Rest)</strong> is called with the rest of the list
as an argument. This way of doing things is similar to the loop
constructs in other languages. (Yes, this is recursion, but do not
let that worry you.) So the same <strong>format_temps</strong> function is
called again, this time <strong>City</strong> gets the value
<strong>{cape_town,{f,70}}</strong> and the same procedure is repeated as
before. This is done until the list becomes empty, that is [],
which causes the first clause <strong>format_temps([])</strong> to match.
This simply returns (results in) the atom <strong>ok</strong>, so
the program ends.</p><h2>Matching, Guards, and Scope of Variables</h2><p>It can be useful to find the maximum and minimum temperature
in lists like this. Before extending the program to do this,
let us look at functions for finding the maximum value of
the elements in a list:</p><pre><code class="">
-module(tut6).
-export([list_max/1]).

list_max([Head|Rest]) -&gt;
   list_max(Rest, Head).

list_max([], Res) -&gt;
    Res;
list_max([Head|Rest], Result_so_far) when Head &gt; Result_so_far -&gt;
    list_max(Rest, Head);
list_max([Head|Rest], Result_so_far)  -&gt;
    list_max(Rest, Result_so_far).</code></pre><pre>
37&gt; <span class="input">c(tut6).</span>
{ok,tut6}
38&gt; <span class="input">tut6:list_max([1,2,3,4,5,7,4,3,2,1]).</span>
7</pre><p>First notice that two functions have the same name,
<strong>list_max</strong>. However, each of these takes a different number
of arguments (parameters). In Erlang these are regarded as
completely different functions. Where you need to distinguish
between these functions, you write Name/Arity, where
Name is the function name and Arity is
the number of arguments, in this case <strong>list_max/1</strong> and
<strong>list_max/2</strong>.</p><p>In this example you walk through a list "carrying" a
value, in this case <strong>Result_so_far</strong>.
<strong>list_max/1</strong> simply assumes that the max value of the list
is the head of the list and calls <strong>list_max/2</strong> with the rest
of the list and the value of the head of the list. In the above
this would be <strong>list_max([2,3,4,5,7,4,3,2,1],1)</strong>. If you tried
to use <strong>list_max/1</strong> with an empty list or tried to use it
with something that is not a list at all, you would cause an error.
Notice that the Erlang philosophy is not to handle errors of this
type in the function they occur, but to do so elsewhere. More
about this later.</p><p>In <strong>list_max/2</strong>, you walk down the list and use <strong>Head</strong>
instead of <strong>Result_so_far</strong> when <strong>Head</strong> &gt;
<strong>Result_so_far</strong>. <strong>when</strong> is a special word used before
the -&gt; in the function to say that you only use this part
of the function if the test that follows is true. A test
of this type is called <em>guard</em>. If the guard is false (that is,
the guard fails), the next part of the function is tried. In this
case, if <strong>Head</strong> is not greater than <strong>Result_so_far</strong>, then
it must be smaller or equal to it. This means that a guard on
the next part of the function is not needed.</p><p>Some useful operators in guards are:
</p><ul><li>&lt; less than</li><li>&gt; greater than</li><li>== equal</li><li>&gt;= greater or equal</li><li>=&lt; less or equal</li><li>/= not equal</li></ul><p>(see <a href="./expressions">Guard Sequences</a>).</p><p>To change the above program to one that works out the minimum
value of the element in a list, you only need to
write &lt; instead of &gt;. (But it would be wise to change
the name of the function to <strong>list_min</strong>.)</p><p>Earlier it was mentioned that a variable can only be
given a value once in its scope. In the above you see
that <strong>Result_so_far</strong> is given several values. This is
OK since every time you call <strong>list_max/2</strong> you create a new
scope and one can regard <strong>Result_so_far</strong> as a
different variable in each scope.</p><p>Another way of creating and giving a variable a value is by using
the match operator = . So if you write <strong>M = 5</strong>, a variable
called <strong>M</strong> is created with the value 5. If, in
the same scope, you then write <strong>M = 6</strong>, an error is returned. Try
this out in the shell:</p><pre>
39&gt; <span class="input">M = 5.</span>
5
40&gt; <span class="input">M = 6.</span>
** exception error: no match of right hand side value 6
41&gt; <span class="input">M = M + 1.</span>
** exception error: no match of right hand side value 6
42&gt; <span class="input">N = M + 1.</span>
6</pre><p>The use of the match operator is particularly useful for pulling
apart Erlang terms and creating new ones.</p><pre>
43&gt; <span class="input">{X, Y} = {paris, {f, 28}}.</span>
{paris,{f,28}}
44&gt; <span class="input">X.</span>
paris
45&gt; <span class="input">Y.</span>
{f,28}</pre><p>Here <strong>X</strong> gets the value <strong>paris</strong> and
<strong>Y</strong><strong>{f,28}</strong>.</p><p>If you try to do the same again with another city,
an error is returned:</p><pre>
46&gt; <span class="input">{X, Y} = {london, {f, 36}}.</span>
** exception error: no match of right hand side value {london,{f,36}}</pre><p>Variables can also be used to improve the readability of
programs. For example, in function <strong>list_max/2</strong> above,
you can write:</p><pre><code class="">
list_max([Head|Rest], Result_so_far) when Head &gt; Result_so_far -&gt;
    New_result_far = Head,
    list_max(Rest, New_result_far);</code></pre><p>This is possibly a little clearer.</p><h2>More About Lists</h2><p>Remember that the | operator can be used to get the head of a
list:</p><pre>
47&gt; <span class="input">[M1|T1] = [paris, london, rome].</span>
[paris,london,rome]
48&gt; <span class="input">M1.</span>
paris
49&gt; <span class="input">T1.</span>
[london,rome]</pre><p>The | operator can also be used to add a head to a list:</p><pre>
50&gt; <span class="input">L1 = [madrid | T1].</span>
[madrid,london,rome]
51&gt; <span class="input">L1.</span>
[madrid,london,rome]</pre><p>Now an example of this when working with lists - reversing
the order of a list:</p><pre><code class="">
-module(tut8).

-export([reverse/1]).

reverse(List) -&gt;
    reverse(List, []).

reverse([Head | Rest], Reversed_List) -&gt;
    reverse(Rest, [Head | Reversed_List]);
reverse([], Reversed_List) -&gt;
    Reversed_List.</code></pre><pre>
52&gt; <span class="input">c(tut8).</span>
{ok,tut8}
53&gt; <span class="input">tut8:reverse([1,2,3]).</span>
[3,2,1]</pre><p>Consider how <strong>Reversed_List</strong> is built. It starts as [],
then successively the heads are taken off of the list to be reversed
and added to the the <strong>Reversed_List</strong>, as shown in
the following:</p><pre><code class="">
reverse([1|2,3], []) =&gt;
    reverse([2,3], [1|[]])

reverse([2|3], [1]) =&gt;
    reverse([3], [2|[1])

reverse([3|[]], [2,1]) =&gt;
    reverse([], [3|[2,1]])

reverse([], [3,2,1]) =&gt;
    [3,2,1]</code></pre><p>The module <strong>lists</strong> contains many functions for
manipulating lists, for example, for reversing them. So before
writing a list-manipulating function it is a good idea to check
if one not already is written for you
(see the <a href="./lists">lists(3)</a>
manual page in STDLIB).</p><p>Now let us get back to the cities and temperatures, but take a more
structured approach this time. First let us convert the whole list
to Celsius as follows:</p><pre><code class="">
-module(tut7).
-export([format_temps/1]).

format_temps(List_of_cities) -&gt;
    convert_list_to_c(List_of_cities).

convert_list_to_c([{Name, {f, F}} | Rest]) -&gt;
    Converted_City = {Name, {c, (F -32)* 5 / 9}},
    [Converted_City | convert_list_to_c(Rest)];

convert_list_to_c([City | Rest]) -&gt;
    [City | convert_list_to_c(Rest)];

convert_list_to_c([]) -&gt;
    [].</code></pre><p>Test the function:</p><pre>
54&gt; <span class="input">c(tut7).</span>
{ok, tut7}.
55&gt; <span class="input">tut7:format_temps([{moscow, {c, -10}}, {cape_town, {f, 70}},</span>
<span class="input">{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).</span>
[{moscow,{c,-10}},
 {cape_town,{c,21.11111111111111}},
 {stockholm,{c,-4}},
 {paris,{c,-2.2222222222222223}},
 {london,{c,2.2222222222222223}}]</pre><p>Explanation:</p><pre><code class="">
format_temps(List_of_cities) -&gt;
    convert_list_to_c(List_of_cities).</code></pre><p>Here <strong>format_temps/1</strong> calls
<strong>convert_list_to_c/1</strong>. <strong>convert_list_to_c/1</strong> takes off
the head of the <strong>List_of_cities</strong>, converts it to Celsius if
needed. The | operator is used to add the (maybe) converted
to the converted rest of the list:</p><pre><code class="">
[Converted_City | convert_list_to_c(Rest)];</code></pre><p>or:</p><pre><code class="">
[City | convert_list_to_c(Rest)];</code></pre><p>This is done until the end of the list is reached, that is,
the list is empty:</p><pre><code class="">
convert_list_to_c([]) -&gt;
    [].</code></pre><p>Now when the list is converted, a function to print it is added:</p><pre><code class="">
-module(tut7).
-export([format_temps/1]).

format_temps(List_of_cities) -&gt;
    Converted_List = convert_list_to_c(List_of_cities),
    print_temp(Converted_List).

convert_list_to_c([{Name, {f, F}} | Rest]) -&gt;
    Converted_City = {Name, {c, (F -32)* 5 / 9}},
    [Converted_City | convert_list_to_c(Rest)];

convert_list_to_c([City | Rest]) -&gt;
    [City | convert_list_to_c(Rest)];

convert_list_to_c([]) -&gt;
    [].

print_temp([{Name, {c, Temp}} | Rest]) -&gt;
    io:format("~-15w ~w c~n", [Name, Temp]),
    print_temp(Rest);
print_temp([]) -&gt;
    ok.</code></pre><pre>
56&gt; <span class="input">c(tut7).</span>
{ok,tut7}
57&gt; <span class="input">tut7:format_temps([{moscow, {c, -10}}, {cape_town, {f, 70}},</span>
<span class="input">{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).</span>
moscow          -10 c
cape_town       21.11111111111111 c
stockholm       -4 c
paris           -2.2222222222222223 c
london          2.2222222222222223 c
ok</pre><p>Now a function has to be added to find the cities with
the maximum and minimum temperatures. The following program is not
the most efficient way of doing this as you walk through the list
of cities four times. But it is better to first strive for
clarity and correctness and to make programs efficient only if
needed.</p><pre><code class="">
-module(tut7).
-export([format_temps/1]).

format_temps(List_of_cities) -&gt;
    Converted_List = convert_list_to_c(List_of_cities),
    print_temp(Converted_List),
    {Max_city, Min_city} = find_max_and_min(Converted_List),
    print_max_and_min(Max_city, Min_city).

convert_list_to_c([{Name, {f, Temp}} | Rest]) -&gt;
    Converted_City = {Name, {c, (Temp -32)* 5 / 9}},
    [Converted_City | convert_list_to_c(Rest)];

convert_list_to_c([City | Rest]) -&gt;
    [City | convert_list_to_c(Rest)];

convert_list_to_c([]) -&gt;
    [].

print_temp([{Name, {c, Temp}} | Rest]) -&gt;
    io:format("~-15w ~w c~n", [Name, Temp]),
    print_temp(Rest);
print_temp([]) -&gt;
    ok.

find_max_and_min([City | Rest]) -&gt;
    find_max_and_min(Rest, City, City).

find_max_and_min([{Name, {c, Temp}} | Rest], 
         {Max_Name, {c, Max_Temp}}, 
         {Min_Name, {c, Min_Temp}}) -&gt;
    if 
        Temp &gt; Max_Temp -&gt;
            Max_City = {Name, {c, Temp}};           % Change
        true -&gt; 
            Max_City = {Max_Name, {c, Max_Temp}} % Unchanged
    end,
    if
         Temp &lt; Min_Temp -&gt;
            Min_City = {Name, {c, Temp}};           % Change
        true -&gt; 
            Min_City = {Min_Name, {c, Min_Temp}} % Unchanged
    end,
    find_max_and_min(Rest, Max_City, Min_City);

find_max_and_min([], Max_City, Min_City) -&gt;
    {Max_City, Min_City}.

print_max_and_min({Max_name, {c, Max_temp}}, {Min_name, {c, Min_temp}}) -&gt;
    io:format("Max temperature was ~w c in ~w~n", [Max_temp, Max_name]),
    io:format("Min temperature was ~w c in ~w~n", [Min_temp, Min_name]).</code></pre><pre>
58&gt; <span class="input">c(tut7).</span>
{ok, tut7}
59&gt; <span class="input">tut7:format_temps([{moscow, {c, -10}}, {cape_town, {f, 70}},</span>
<span class="input">{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).</span>
moscow          -10 c
cape_town       21.11111111111111 c
stockholm       -4 c
paris           -2.2222222222222223 c
london          2.2222222222222223 c
Max temperature was 21.11111111111111 c in cape_town
Min temperature was -10 c in moscow
ok</pre><h2>If and Case</h2><p>The function <strong>find_max_and_min</strong> works out the maximum and
minimum temperature. A new construct, <strong>if</strong>, is introduced here.
If works as follows:</p><pre><code class="">
if
    Condition 1 -&gt;
        Action 1;
    Condition 2 -&gt;
        Action 2;
    Condition 3 -&gt;
        Action 3;
    Condition 4 -&gt;
        Action 4
end</code></pre><p>Notice that there is no ";" before <strong>end</strong>. Conditions do
the same as guards, that is, tests that succeed or fail. Erlang
starts at the top
and tests until it finds a condition that succeeds. Then it evaluates
(performs) the action following the condition and ignores all
other conditions and actions before the <strong>end</strong>. If no
condition matches, a run-time failure occurs. A condition
that always succeeds is the atom <strong>true</strong>. This is
often used last in an <strong>if</strong>, meaning, do the action following
the <strong>true</strong> if all other conditions have failed.</p><p>The following is a short program to show the workings of
<strong>if</strong>.</p><pre><code class="">
-module(tut9).
-export([test_if/2]).

test_if(A, B) -&gt;
    if 
        A == 5 -&gt;
            io:format("A == 5~n", []),
            a_equals_5;
        B == 6 -&gt;
            io:format("B == 6~n", []),
            b_equals_6;
        A == 2, B == 3 -&gt;                      %That is A equals 2 and B equals 3
            io:format("A == 2, B == 3~n", []),
            a_equals_2_b_equals_3;
        A == 1 ; B == 7 -&gt;                     %That is A equals 1 or B equals 7
            io:format("A == 1 ; B == 7~n", []),
            a_equals_1_or_b_equals_7
    end.</code></pre><p>Testing this program gives:</p><pre>
60&gt; <span class="input">c(tut9).</span>
{ok,tut9}
61&gt; <span class="input">tut9:test_if(5,33).</span>
A == 5
a_equals_5
62&gt; <span class="input">tut9:test_if(33,6).</span>
B == 6
b_equals_6
63&gt; <span class="input">tut9:test_if(2, 3).</span>
A == 2, B == 3
a_equals_2_b_equals_3
64&gt; <span class="input">tut9:test_if(1, 33).</span>
A == 1 ; B == 7
a_equals_1_or_b_equals_7
65&gt; <span class="input">tut9:test_if(33, 7).</span>
A == 1 ; B == 7
a_equals_1_or_b_equals_7
66&gt; <span class="input">tut9:test_if(33, 33).</span>
** exception error: no true branch found when evaluating an if expression
     in function  tut9:test_if/2 (tut9.erl, line 5)</pre><p>Notice that <strong>tut9:test_if(33,33)</strong> does not cause any
condition to succeed. This leads to the run time error
<strong>if_clause</strong>, here nicely formatted by the shell. See
<a href="./expressions">Guard Sequences</a>
for details of the many guard tests available.</p><p><strong>case</strong> is another construct in Erlang. Recall that the
<strong>convert_length</strong> function was written as:</p><pre><code class="">
convert_length({centimeter, X}) -&gt;
    {inch, X / 2.54};
convert_length({inch, Y}) -&gt;
    {centimeter, Y * 2.54}.</code></pre><p>The same program can also be written as:</p><pre><code class="">
-module(tut10).
-export([convert_length/1]).

convert_length(Length) -&gt;
    case Length of
        {centimeter, X} -&gt;
            {inch, X / 2.54};
        {inch, Y} -&gt;
            {centimeter, Y * 2.54}
    end.</code></pre><pre>
67&gt; <span class="input">c(tut10).</span>
{ok,tut10}
68&gt; <span class="input">tut10:convert_length({inch, 6}).</span>
{centimeter,15.24}
69&gt; <span class="input">tut10:convert_length({centimeter, 2.5}).</span>
{inch,0.984251968503937}</pre><p>Both <strong>case</strong> and <strong>if</strong> have <em>return values</em>, that is,
in the above example <strong>case</strong> returned
either <strong>{inch,X/2.54}</strong> or <strong>{centimeter,Y*2.54}</strong>.
The behaviour of <strong>case</strong> can also be modified by using guards.
The following example clarifies this. It
tells us the length of a month, given the year.
The year must be known, since February has 29 days in a leap year.</p><pre><code class="">
-module(tut11).
-export([month_length/2]).

month_length(Year, Month) -&gt;
    %% All years divisible by 400 are leap
    %% Years divisible by 100 are not leap (except the 400 rule above)
    %% Years divisible by 4 are leap (except the 100 rule above)
    Leap = if
        trunc(Year / 400) * 400 == Year -&gt;
            leap;
        trunc(Year / 100) * 100 == Year -&gt;
            not_leap;
        trunc(Year / 4) * 4 == Year -&gt;
            leap;
        true -&gt;
            not_leap
    end,  
    case Month of
        sep -&gt; 30;
        apr -&gt; 30;
        jun -&gt; 30;
        nov -&gt; 30;
        feb when Leap == leap -&gt; 29;
        feb -&gt; 28;
        jan -&gt; 31;
        mar -&gt; 31;
        may -&gt; 31;
        jul -&gt; 31;
        aug -&gt; 31;
        oct -&gt; 31;
        dec -&gt; 31
    end.</code></pre><pre>
70&gt; <span class="input">c(tut11).</span>
{ok,tut11}
71&gt; <span class="input">tut11:month_length(2004, feb).</span>
29
72&gt; <span class="input">tut11:month_length(2003, feb).</span>
28
73&gt; <span class="input">tut11:month_length(1947, aug).</span>
31</pre><h2>Built-In Functions (BIFs)</h2><p>BIFs are functions that for some reason are
built-in to the Erlang virtual machine. BIFs often implement
functionality that is impossible or is too
inefficient to implement in Erlang. Some BIFs can be called
using the function name only but they are by default belonging
to the <strong>erlang</strong> module. For example, the call to the
BIF <strong>trunc</strong>
below is equivalent to a call to <strong>erlang:trunc</strong>.</p><p>As shown, first it is checked if a year is leap. If a
year is divisible by 400, it is a leap year. To determine this,
first divide the year by 400 and use the BIF
<strong>trunc</strong> (more about this later) to cut off any decimals. Then
multiply by 400 again and see if the same value is returned again.
For example, year 2004:</p><pre><code class="">
2004 / 400 = 5.01
trunc(5.01) = 5
5 * 400 = 2000</code></pre><p>2000 is not the same as 2004, so 2004 is not divisible by 400.
Year 2000:</p><pre><code class="">
2000 / 400 = 5.0
trunc(5.0) = 5
5 * 400 = 2000</code></pre><p>That is, a leap year. The next two <strong>trunc</strong>-tests evaluate
if the year is divisible by 100 or 4 in the same way. The first
<strong>if</strong> returns <strong>leap</strong> or <strong>not_leap</strong>, which lands up
in the variable <strong>Leap</strong>. This variable is used in the guard
for <strong>feb</strong> in the following <strong>case</strong> that tells us how
long the month is.</p><p>This example showed the use of <strong>trunc</strong>. It is easier
to use the Erlang operator <strong>rem</strong> that gives the remainder
after division, for example:</p><pre>
74&gt; <span class="input">2004 rem 400.</span>
4</pre><p>So instead of writing:</p><pre><code class="">
trunc(Year / 400) * 400 == Year -&gt;
    leap;</code></pre><p>it can be written:</p><pre><code class="">
Year rem 400 == 0 -&gt;
    leap;</code></pre><p>There are many other BIFs such as
<strong>trunc</strong>. Only a few BIFs can be used in guards,
and you cannot use functions you have defined yourself in guards.
(see
<a href="./expressions">Guard Sequences</a>)
(For advanced readers: This is to ensure that guards do not have side
effects.) Let us play with a few of these functions in the shell:</p><pre>
75&gt; <span class="input">trunc(5.6).</span>
5
76&gt; <span class="input">round(5.6).</span>
6
77&gt; <span class="input">length([a,b,c,d]).</span>
4
78&gt; <span class="input">float(5).</span>
5.0
79&gt; <span class="input">is_atom(hello).</span>
true
80&gt; <span class="input">is_atom("hello").</span>
false
81&gt; <span class="input">is_tuple({paris, {c, 30}}).</span>
true
82&gt; <span class="input">is_tuple([paris, {c, 30}]).</span>
false</pre><p>All of these can be used in guards. Now for some BIFs that cannot be
used in guards:</p><pre>
83&gt; <span class="input">atom_to_list(hello).</span>
"hello"
84&gt; <span class="input">list_to_atom("goodbye").</span>
goodbye
85&gt; <span class="input">integer_to_list(22).</span>
"22"</pre><p>These three BIFs do conversions that would be difficult (or
impossible) to do in Erlang.</p><h2>Higher-Order Functions (Funs)</h2><p>Erlang, like most modern functional programming languages, has
higher-order functions. Here is an example using the shell:</p><pre>
86&gt; <span class="input">Xf = fun(X) -&gt; X * 2 end.</span>
#Fun&lt;erl_eval.5.123085357&gt;
87&gt; <span class="input">Xf(5).</span>
10</pre><p>Here is defined a function that doubles
the value of a number and assigned this function to a variable. Thus
<strong>Xf(5)</strong> returns value 10. Two useful functions when
working with lists are <strong>foreach</strong> and <strong>map</strong>, which are
defined as follows:</p><pre><code class="">
foreach(Fun, [First|Rest]) -&gt;
    Fun(First),
    foreach(Fun, Rest);
foreach(Fun, []) -&gt;
    ok.

map(Fun, [First|Rest]) -&gt; 
    [Fun(First)|map(Fun,Rest)];
map(Fun, []) -&gt; 
    [].</code></pre><p>These two functions are provided in the standard module
<strong>lists</strong>. <strong>foreach</strong> takes a list and applies a fun to
every element in the list. <strong>map</strong> creates a new list by
applying a fun to every element in a list. Going back to
the shell, <strong>map</strong> is used and a fun to add 3 to
every element of a list:</p><pre>
88&gt; <span class="input">Add_3 = fun(X) -&gt; X + 3 end.</span>
#Fun&lt;erl_eval.5.123085357&gt;
89&gt; <span class="input">lists:map(Add_3, [1,2,3]).</span>
[4,5,6]</pre><p>Let us (again) print the temperatures in a list of cities:</p><pre>
90&gt; <span class="input">Print_City = fun({City, {X, Temp}}) -&gt; io:format("~-15w ~w ~w~n",</span>
<span class="input">[City, X, Temp]) end.</span>
#Fun&lt;erl_eval.5.123085357&gt;
91&gt; <span class="input">lists:foreach(Print_City, [{moscow, {c, -10}}, {cape_town, {f, 70}},</span>
<span class="input">{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).</span>
moscow          c -10
cape_town       f 70
stockholm       c -4
paris           f 28
london          f 36
ok</pre><p>Let us now define a fun that can be used to go through a list
of cities and temperatures and transform them all to Celsius.</p><pre><code class="">
-module(tut13).

-export([convert_list_to_c/1]).

convert_to_c({Name, {f, Temp}}) -&gt;
    {Name, {c, trunc((Temp - 32) * 5 / 9)}};
convert_to_c({Name, {c, Temp}}) -&gt;
    {Name, {c, Temp}}.

convert_list_to_c(List) -&gt;
    lists:map(fun convert_to_c/1, List).</code></pre><pre>
92&gt; <span class="input">tut13:convert_list_to_c([{moscow, {c, -10}}, {cape_town, {f, 70}},</span>
<span class="input">{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).</span>
[{moscow,{c,-10}},
 {cape_town,{c,21}},
 {stockholm,{c,-4}},
 {paris,{c,-2}},
 {london,{c,2}}]</pre><p>The <strong>convert_to_c</strong> function is the same as before, but here
it is used as a fun:</p><pre><code class="">
lists:map(fun convert_to_c/1, List)</code></pre><p>When a function defined elsewhere is used as a fun, it can be referred
to as <strong>Function/Arity</strong> (remember that <strong>Arity</strong> =
number of arguments). So in the <strong>map</strong>-call
<strong>lists:map(fun convert_to_c/1, List)</strong> is written. As shown,
<strong>convert_list_to_c</strong> becomes much shorter and easier to
understand.</p><p>The standard module <strong>lists</strong> also contains a function
<strong>sort(Fun, List)</strong> where <strong>Fun</strong> is a fun with two
arguments. This fun returns <strong>true</strong> if the first
argument is less than the second argument, or else <strong>false</strong>.
Sorting is added to the <strong>convert_list_to_c</strong>:</p><pre><code class="">
-module(tut13).

-export([convert_list_to_c/1]).

convert_to_c({Name, {f, Temp}}) -&gt;
    {Name, {c, trunc((Temp - 32) * 5 / 9)}};
convert_to_c({Name, {c, Temp}}) -&gt;
    {Name, {c, Temp}}.

convert_list_to_c(List) -&gt;
    New_list = lists:map(fun convert_to_c/1, List),
    lists:sort(fun({_, {c, Temp1}}, {_, {c, Temp2}}) -&gt;
                       Temp1 &lt; Temp2 end, New_list).</code></pre><pre>
93&gt; <span class="input">c(tut13).</span>
{ok,tut13}
94&gt; <span class="input">tut13:convert_list_to_c([{moscow, {c, -10}}, {cape_town, {f, 70}},</span>
<span class="input">{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).</span>
[{moscow,{c,-10}},
 {stockholm,{c,-4}},
 {paris,{c,-2}},
 {london,{c,2}},
 {cape_town,{c,21}}]</pre><p>In <strong>sort</strong> the fun is used:</p><pre><code class="">
fun({_, {c, Temp1}}, {_, {c, Temp2}}) -&gt; Temp1 &lt; Temp2 end,</code></pre><p>Here the concept of an <em>anonymous variable</em>
"_" is introduced. This is simply shorthand for a variable that
gets a value, but the value is ignored. This can be used
anywhere suitable, not just in funs. <strong>Temp1 &lt; Temp2</strong>
returns <strong>true</strong> if <strong>Temp1</strong> is less than <strong>Temp2</strong>.</p></body></html>