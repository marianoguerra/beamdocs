<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>ERTS User's Guide</h1><h3>Scope</h3><p>The Erlang Runtime System Application, ERTS, contains
functionality necessary to run the Erlang system.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>By default, <strong>ERTS</strong> is only guaranteed to be
compatible with other Erlang/OTP components from the same release as
<strong>ERTS</strong> itself.</p><p>For information on how to communicate with Erlang/OTP components
from earlier releases, see the documentation of system flag
<a href="./erl#compat_rel">erl#compat_rel</a> in <strong>erl(1)</strong>.
</p></div><h3>Prerequisites</h3><p>It is assumed that the reader is familiar with the Erlang programming
language.</p><p>Communication in Erlang is conceptually performed using
asynchronous signaling. All different executing entities,
such as processes and ports, communicate through asynchronous
signals. The most commonly used signal is a message. Other
common signals are exit, link, unlink, monitor, and demonitor
signals.</p><h3>Passing of Signals</h3><p>The amount of time that passes between a signal is sent
and the arrival of the signal at the destination is unspecified
but positive. If the receiver has terminated, the signal does
not arrive, but it can trigger another signal.
For example, a link signal sent to a non-existing process
triggers an exit signal, which is sent back to where the link
signal originated from. When communicating over the distribution,
signals can be lost if the distribution channel goes down.</p><p>The only signal ordering guarantee given is the following: if
an entity sends multiple signals to the same destination entity,
the order is preserved; that is, if <strong>A</strong> sends
a signal <strong>S1</strong> to <strong>B</strong>, and later sends
signal <strong>S2</strong> to <strong>B</strong>, <strong>S1</strong> is guaranteed not to
arrive after <strong>S2</strong>.</p><h3>Synchronous Communication</h3><p>Some communication is synchronous. If broken down into pieces,
a synchronous communication operation consists of two asynchronous
signals; one request signal and one reply signal. An example of
such a synchronous communication is a call to
<a href="./erlang#process_info/2">erlang#process_info/2</a>
when the first argument is not <strong>self()</strong>. The caller sends
an asynchronous signal requesting information, and then
waits for the reply signal containing the requested information. When
the request signal reaches its destination, the destination process
replies with the requested information.</p><h3>Implementation</h3><p>The implementation of different asynchronous signals in the virtual
machine can vary over time, but the behavior always respects this
concept of asynchronous signals being passed between entities
as described above.</p><p>By inspecting the implementation, you might notice that some
specific signal gives a stricter guarantee than described
above. It is of vital importance that such knowledge about the
implementation is <em>not</em> used by Erlang code, as the
implementation can change at any time without prior notice.</p><p>Examples of major implementation changes:</p><ul><li>As from ERTS 5.5.2 exit signals to processes are truly asynchronously delivered.</li><li>As from ERTS 5.10 all signals from processes to ports are truly asynchronously delivered.</li></ul><h3>New Extended Time Functionality</h3><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from Erlang/OTP 18 (ERTS 7.0) the time functionality
has been extended. This includes a
<a href="#The_New_Time_API">new API</a>
for time and
<a href="#Time_Warp_Modes">time warp modes</a> that change the system behavior when
system time changes.</p><p>The <a href="#No_Time_Warp_Mode">default time warp mode</a> has the same behavior as before, and the
old API still works. Thus, you are not required to change
anything unless you want to. However, <em>you are strongly encouraged to use the new API</em> instead of the old API based
on <a href="./erlang#now/0">erlang#now/0</a>.
<strong>erlang:now/0</strong> is deprecated, as it is and
will be a scalability bottleneck.</p><p>By using the new API, you
automatically get scalability and performance improvements. This
also enables you to use the
<a href="#Multi_Time_Warp_Mode">multi-time warp mode</a>
that improves accuracy and precision of time measurements.</p></div><h3>Terminology</h3><p>To make it easier to understand this section, some terms
are defined. This is a mix of our own terminology
(Erlang/OS system time, Erlang/OS monotonic time, time warp)
and globally accepted terminology.</p><a name="Monotonically_Increasing"></a><h3>Monotonically Increasing</h3><p>In a monotonically increasing sequence of values, all values
that have a predecessor are either larger than or equal to its
predecessor.</p><a name="Strictly_Monotonically_Increasing"></a><h3>Strictly Monotonically Increasing</h3><p>In a strictly monotonically increasing sequence of values,
all values that have a predecessor are larger than its
predecessor.</p><a name="UT1"></a><h3>UT1</h3><p>Universal Time. UT1 is based on the rotation of the earth
and conceptually means solar time at 0Â° longitude.</p><a name="UTC"></a><h3>UTC</h3><p>Coordinated Universal Time. UTC almost aligns with
<a href="#UT1">UT1</a>. However, UTC uses the
SI definition of a second, which has not exactly the same length
as the second used by UT1. This means that UTC slowly drifts from
UT1. To keep UTC relatively in sync with UT1, leap seconds
are inserted, and potentially also deleted. That is, an UTC day can
be 86400, 86401, or 86399 seconds long.</p><a name="POSIX_Time"></a><h3>POSIX Time</h3><p>Time since
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap03.html#tag_21_03_00_17"> Epoch</a>.
Epoch is defined to be 00:00:00 <a href="#UTC">UTC</a>,
1970-01-01.
<a href="http://pubs.opengroup.org/onlinepubs/009604499/basedefs/xbd_chap04.html#tag_04_14"> A day in POSIX time</a>
is defined to be exactly 86400 seconds long. Strangely enough,
Epoch is defined to be a time in UTC, and UTC has another
definition of how long a day is. Quoting the Open Group
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_15"> "POSIX time is therefore not necessarily UTC, despite its appearance"</a>.
The effect of this is that when an UTC leap second is
inserted, POSIX time either stops for a second, or repeats the
last second. If an UTC leap second would be deleted (which has not
happened yet), POSIX time would make a one second leap forward.</p><a name="Time_Resolution"></a><h3>Time Resolution</h3><p>The shortest time interval that can be distinguished when
reading time values.</p><a name="Time_Precision"></a><h3>Time Precision</h3><p>The shortest time interval that can be distinguished
repeatedly and reliably when reading time values. Precision
is limited by the
<a href="#Time_Resolution">resolution</a>, but
resolution and precision can differ significantly.</p><a name="Time_Accuracy"></a><h3>Time Accuracy</h3><p>The correctness of time values.</p><a name="Time_Warp"></a><h3>Time Warp</h3><p>A time warp is a leap forwards or backwards in time. That
is, the difference of time values taken before and after the
time warp does not correspond to the actual elapsed time.</p><a name="OS_System_Time"></a><h3>OS System Time</h3><p>The operating systems view of
<a href="#POSIX_Time">POSIX time</a>. To
retrieve it, call
<a href="../kernel/os#system_time/0">kernel/os#system_time/0</a>.
This may or may not be an accurate view of POSIX time. This time
may typically be adjusted both backwards and forwards without
limitation. That is, <a href="#Time_Warp">time warps</a>
may be observed.</p><p>To get information about the Erlang runtime
system's source of OS system time, call
<a href="./erlang#system_info_os_system_time_source">erlang#system_info_os_system_time_source</a>.</p><a name="OS_Monotonic_Time"></a><h3>OS Monotonic Time</h3><p>A monotonically increasing time provided by the OS.
This time does not leap and has a relatively steady
frequency although not completely correct. However, it is not
uncommon that OS monotonic time stops if the system is
suspended. This time typically increases since some
unspecified point in time that is not connected to
<a href="#OS_System_Time">OS system time</a>.
This type of time is not necessarily provided by all OSs.</p><p>To get information about the Erlang
runtime system's source of OS monotonic time, call
<a href="./erlang#system_info_os_monotonic_time_source">erlang#system_info_os_monotonic_time_source</a>.</p><a name="Erlang_System_Time"></a><h3>Erlang System Time</h3><p>The Erlang runtime systems view of
<a href="#POSIX_Time">POSIX time</a>. To
retrieve it, call
<a href="./erlang#system_time/0">erlang#system_time/0</a>.</p><p>This time may or may not be an accurate view of POSIX time,
and may
or may not align with <a href="#OS_System_Time">OS system time</a>. The runtime system works towards aligning the two
system times. Depending on the
<a href="#Time_Warp_Modes">time warp mode</a> used,
this can be achieved by letting Erlang
system time perform a <a href="#Time_Warp">time warp</a>.</p><a name="Erlang_Monotonic_Time"></a><h3>Erlang Monotonic Time</h3><p>A monotonically increasing time provided by the
Erlang runtime system. Erlang monotonic time increases since
some unspecified point in time. To retrieve it, call
<a href="./erlang#monotonic_time/0">erlang#monotonic_time/0</a>.</p><p>The <a href="#Time_Accuracy">accuracy</a> and
<a href="#Time_Precision">precision</a> of Erlang
monotonic time heavily depends on the following:</p><ul><li>Accuracy and precision of <a href="#OS_Monotonic_Time">OS monotonic time</a> </li><li>Accuracy and precision of <a href="#OS_System_Time">OS system time</a> </li><li><a href="#Time_Warp_Modes"> time warp mode</a> used </li></ul><p>On a system without OS monotonic time, Erlang monotonic
time guarantees monotonicity, but cannot give
other guarantees. The frequency adjustments made to
Erlang monotonic time depend on the time warp mode used.</p><p>Internally in the runtime system, Erlang monotonic
time is the "time engine" that is used for more or less
everything that has anything to do with time. All timers,
regardless of it is a <strong>receive ... after</strong> timer, BIF timer,
or a timer in the
<a href="./timer">stdlib/timer</a>
module, are triggered relative Erlang monotonic time. Even
<a href="#Erlang_System_Time">Erlang system time</a> is based on Erlang monotonic time.
By adding current Erlang monotonic time with current time
offset, you get current Erlang system time.</p><p>To retrieve the current time offset, call
<a href="./erlang#time_offset/0">erlang#time_offset/0</a>.</p><h3>Introduction</h3><p>Time is vital to an Erlang program and, more importantly, <em>correct</em>
time is vital to an Erlang program. As Erlang is a language with
soft real-time properties and we can express
time in our programs, the Virtual Machine and the language must be
careful about what is considered a correct time and in
how time functions behave.</p><p>When Erlang was designed, it was assumed that the wall
clock time in the system showed a monotonic time moving forward at
exactly the same pace as the definition of time. This more or less meant
that an atomic clock (or better time source) was expected to be attached
to your hardware and that the hardware was then expected to be
locked away from any human tinkering forever. While this can be a
compelling thought, it is simply never the case.</p><p>A "normal" modern computer cannot keep time, not on itself and
not unless you have a chip-level atomic clock wired to it. Time,
as perceived by your computer, must normally be corrected. Hence
the Network Time Protocol (NTP) protocol, together with the <strong>ntpd</strong>
process, does its best to keep your computer time in sync with
the correct time. Between NTP corrections, usually a
less potent time-keeper than an atomic clock is used.</p><p>However, NTP is not fail-safe. The NTP server can be unavailable,
<strong>ntp.conf</strong> can be wrongly configured, or your computer can
sometimes be disconnected from Internet. Furthermore, you can have a
user (or even system administrator) who thinks the correct
way to handle Daylight Saving Time is to adjust the clock one
hour two times a year (which is the incorrect way to do it).
To complicate things further, this user fetched your
software from Internet and has not considered what
the correct time is as perceived by a computer. The user does
not care about keeping the wall clock in sync with the correct
time. The user expects your program to have unlimited knowledge
about the time.</p><p>Most programmers also expect time to be reliable, at least until
they realize that the wall clock time on their workstation is off by
a minute. Then they set it to the correct time, but most probably
not in a smooth way.</p><p>The number of problems that arise when you always expect the wall clock
time on the system to be correct can be immense. Erlang therefore
introduced the "corrected estimate of time", or the "time
correction", many years ago. The time correction relies on the fact
that most operating systems have some kind of monotonic clock,
either a real-time extension or some built-in "tick counter" that is
independent of the wall clock settings. This counter can have
microsecond resolution or much less, but it has a drift that cannot
be ignored.</p><a name="Time_Correction"></a><h3>Time Correction</h3><p>If time correction is enabled, the Erlang runtime system
makes use of both
<a href="#OS_System_Time">OS system time</a>
and <a href="#OS_Monotonic_Time">OS monotonic time</a>,
to adjust the frequency of the Erlang
monotonic clock. Time correction ensures that
<a href="#Erlang_Monotonic_Time">Erlang monotonic time</a>
does not warp and that the frequency is relatively accurate.
The type of frequency adjustments depends on the time warp mode used.
Section <a href="#Time_Warp_Modes">Time Warp Modes</a>
provides more details.</p><p>By default time correction is enabled if support for
it exists on the specific platform. Support for it includes
both OS monotonic time, provided by the OS, and an
implementation in the Erlang runtime system using
OS monotonic time. To check if your system has support
for OS monotonic time, call
<a href="./erlang#system_info_os_monotonic_time_source">erlang#system_info_os_monotonic_time_source</a>.
To check if time correction is enabled on your system, call
<a href="./erlang#system_info_time_correction">erlang#system_info_time_correction</a>.</p><p>To enable or disable time correction, pass command-line argument
<a href="./erl#+c">erl#+c</a> to
<a href="erl">erl</a>.</p><p>If time correction is disabled, Erlang monotonic time
can warp forwards or stop, or even freeze for extended
periods of time. There are then no guarantees that the frequency
of the Erlang monotonic clock is accurate or stable.</p><p><em>You typically never want to disable time correction</em>.
Previously a performance penalty was associated with time
correction, but nowadays it is usually the other way around.
If time correction is disabled, you probably get bad scalability,
bad performance, and bad time measurements.</p><a name="Time_Warp_Safe_Code"></a><h3>Time Warp Safe Code</h3><p>Time warp safe code can handle
a <a href="#Time_Warp">time warp</a> of
<a href="#Erlang_System_Time">Erlang system time</a>.</p><p><a href="./erlang#now/0">erlang#now/0</a>
behaves bad when Erlang system time warps. When Erlang
system time does a time warp backwards, the values returned
from <strong>erlang:now/0</strong> freeze (if you disregard the
microsecond increments made because of the actual call) until
OS system time reaches the point of the last value returned by
<strong>erlang:now/0</strong>. This freeze can continue for a long time. It
can take years, decades, and even longer until the freeze stops.</p><p>All uses of <strong>erlang:now/0</strong> are not necessarily
time warp unsafe. If you do not use it to get time, it
is time warp safe. However, <em>all uses of erlang:now/0 are suboptimal</em> from a performance
and scalability perspective. So you really want to replace
the use of it with other functionality. For examples
of how to replace the use of <strong>erlang:now/0</strong>, see section
<a href="#Dos_and_Donts">How to Work with the New API</a>.</p><h3>Time Warp Modes</h3><a name="Time_Warp_Modes"></a><p>Current <a href="#Erlang_System_Time">Erlang system time</a> is determined by adding the current
<a href="./erlang#monotonic_time/0">Erlang monotonic time</a>
with current
<a href="./erlang#time_offset/0">time offset</a>. The
time offset is managed differently depending on which time
warp mode you use.</p><p>To set the time warp mode, pass command-line argument
<a href="./erl#+C_">erl#+C_</a> to
<a href="erl">erl</a>.</p><a name="No_Time_Warp_Mode"></a><h3>No Time Warp Mode</h3><p>The time offset is determined at runtime system start
and does not change later. This is the default behavior, but
not because it is the best mode (which it is not). It is
default <em>only</em> because this is how the runtime system
behaved until ERTS 7.0.
Ensure that your Erlang code that can execute during a time
warp is <a href="#Time_Warp_Safe_Code">time warp safe</a> before enabling other modes.</p><p>As the time offset is not allowed to change, time
correction must adjust the frequency of the Erlang
monotonic clock to align Erlang system time with OS
system time smoothly. A significant downside of this approach
is that we on purpose will use a faulty frequency on the
Erlang monotonic clock if adjustments are needed. This
error can be as large as 1%. This error will show up in all
time measurements in the runtime system.</p><p>If time correction is not enabled, Erlang monotonic
time freezes when OS system time leaps backwards.
The freeze of monotonic time continues until
OS system time catches up. The freeze can continue for
a long time. When OS system time leaps forwards,
Erlang monotonic time also leaps forward.</p><a name="Single_Time_Warp_Mode"></a><h3>Single Time Warp Mode</h3><p>This mode is more or less a backward compatibility mode
as from its introduction.</p><p>On an embedded system it is not uncommon that the system
has no power supply, not even a battery, when it is
shut off. The system clock on such a system is typically
way off when the system boots. If
<a href="#No_Time_Warp_Mode">no time warp mode</a>
is used, and the Erlang runtime system is started before
OS system time has been corrected, Erlang system time
can be wrong for a long time, centuries or even longer.</p><p>If you need to use Erlang code that is not
<a href="#Time_Warp_Safe_Code">time warp safe</a>,
and you need to start the Erlang runtime system before OS
system time has been corrected, you may want to use the single
time warp mode.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>There are limitations to when you can
execute time warp unsafe code using this mode. If it is possible
to use time warp safe code only, it is <em>much</em> better
to use the <a href="#Multi_Time_Warp_Mode">multi-time warp mode</a> instead.</p></div><p>Using the single time warp mode, the time offset is
handled in two phases:</p><dl><dt>Preliminary Phase</dt><dd> <p>This phase starts when the runtime
system starts. A preliminary time offset based on
current OS system time is determined. This offset is from
now on to be fixed during the whole preliminary phase.</p> <p>If time correction is enabled, adjustments to the
Erlang monotonic clock are made to keep its
frequency as correct as possible. However, <em>no</em>
adjustments are made trying to align Erlang system
time and OS system time. That is, during the preliminary phase
Erlang system time and OS system time can diverge
from each other, and no attempt is made to prevent this.</p> <p>If time correction is disabled, changes in OS system
time affects the monotonic clock the same way as
when the <a href="#No_Time_Warp_Mode">no time warp mode</a> is used.</p> </dd><dt>Final Phase</dt><dd> <p>This phase begins when the user finalizes the time
offset by calling
<a href="./erlang#system_flag_time_offset">erlang#system_flag_time_offset</a>.
The finalization can only be performed once.</p> <p>During finalization, the time offset is adjusted and
fixed so that current Erlang system time aligns with the
current OS system time. As the time offset can
change during the finalization, Erlang system time
can do a time warp at this point. The time offset is
from now on fixed until the runtime system terminates.
If time correction has been enabled, the time
correction from now on also makes adjustments
to align Erlang system time with OS system
time. When the system is in the final phase, it behaves
exactly as in <a href="#No_Time_Warp_Mode">no time warp mode</a>.</p> </dd></dl><p>In order for this to work properly, the user must ensure
that the following two requirements are satisfied:</p><dl><dt>Forward Time Warp</dt><dd><p>The time warp made when finalizing the time offset
can only be done forwards without encountering problems.
This implies that the user must ensure that OS
system time is set to a time earlier or equal to actual
POSIX time before starting the Erlang runtime system.</p> <p>If you are not sure that OS system time is correct,
set it to a time that is guaranteed to be earlier than
actual POSIX time before starting the Erlang runtime
system, just to be safe.</p> </dd><dt>Finalize Correct OS System Time</dt><dd><p>OS system time must be correct when
the user finalizes the time offset.</p> </dd></dl><p>If these requirements are not fulfilled, the system
may behave very bad.</p><p>Assuming that these requirements are fulfilled,
time correction is enabled, and OS system time
is adjusted using a time adjustment protocol such as NTP,
only small adjustments of Erlang monotonic
time are needed to keep system times
aligned after finalization. As long as the system is not
suspended, the largest adjustments needed are for
inserted (or deleted) leap seconds.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>To use this mode, ensure that
all Erlang code that will execute in both phases is
<a href="#Time_Warp_Safe_Code">time warp safe</a>.</p><p>Code executing only in the final phase does not have
to be able to cope with the time warp.</p></div><a name="Multi_Time_Warp_Mode"></a><h3>Multi-Time Warp Mode</h3><p><em>Multi-time warp mode in combination with time correction is the preferred configuration</em>. This as
the Erlang runtime system have better performance, scale
better, and behave better on almost all platforms.
Also, the accuracy and precision of time measurements
are better. Only Erlang runtime systems executing on
ancient platforms benefit from another configuration.</p><p>The time offset can change at any time without limitations.
That is, Erlang system time can perform time warps both
forwards and backwards at <em>any</em> time. As we align
Erlang system time with OS system time by changing
the time offset, we can enable a time correction that tries
to adjust the frequency of the Erlang monotonic clock to be as
correct as possible. This makes time measurements using
Erlang monotonic time more accurate and precise.</p><p>If time correction is disabled, Erlang monotonic time
leaps forward if OS system time leaps forward. If
OS system time leaps backwards, Erlang monotonic time
stops briefly, but it does not freeze for extended periods
of time. This as the time offset is changed to
align Erlang system time with OS system time.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>To use this mode, ensure that all
Erlang code that will execute on the runtime system is
<a href="#Time_Warp_Safe_Code">time warp safe</a>.</p></div><h3>New Time API</h3><a name="The_New_Time_API"></a><p>The old time API is based on
<a href="./erlang#now/0">erlang#now/0</a>.
<strong>erlang:now/0</strong> was intended to be used for many unrelated
things. This tied these unrelated operations together and
caused issues with performance, scalability, accuracy, and
precision for operations that did not need to have
such issues. To improve this, the new API spreads different
functionality over multiple functions.</p><p>To be backward compatible, <strong>erlang:now/0</strong>
remains "as is", but <em>you are strongly discouraged from using it</em>. Many use cases of <strong>erlang:now/0</strong>
prevents you from using the new
<a href="#Multi_Time_Warp_Mode">multi-time warp mode</a>, which is an important part of this
new time functionality improvement.</p><p>Some of the new BIFs on some systems, perhaps surprisingly,
return negative integer values on a newly started runtime
system. This is not a bug, but a memory use optimization.</p><p>The new API consists of the following new BIFs:</p><ul><li><p><a href="./erlang#convert_time_unit/3">erlang#convert_time_unit/3</a></p></li><li><p><a href="./erlang#monotonic_time/0">erlang#monotonic_time/0</a></p></li><li><p><a href="./erlang#monotonic_time/1">erlang#monotonic_time/1</a></p></li><li><p><a href="./erlang#system_time/0">erlang#system_time/0</a></p></li><li><p><a href="./erlang#system_time/1">erlang#system_time/1</a></p></li><li><p><a href="./erlang#time_offset/0">erlang#time_offset/0</a></p></li><li><p><a href="./erlang#time_offset/1">erlang#time_offset/1</a></p></li><li><p><a href="./erlang#timestamp/0">erlang#timestamp/0</a></p></li><li><p><a href="./erlang#unique_integer/0">erlang#unique_integer/0</a></p></li><li><p><a href="./erlang#unique_integer/1">erlang#unique_integer/1</a></p></li><li><p><a href="../kernel/os#system_time/0">kernel/os#system_time/0</a></p></li><li><p><a href="../kernel/os#system_time/1">kernel/os#system_time/1</a></p></li></ul><p>The new API also consists of extensions of the following existing BIFs:
</p><ul><li><p><a href="./erlang#monitor/2">erlang#monitor/2</a></p></li><li><p><a href="./erlang#system_flag_time_offset">erlang#system_flag_time_offset</a></p></li><li><p><a href="./erlang#system_info_os_monotonic_time_source">erlang#system_info_os_monotonic_time_source</a></p></li><li><p><a href="./erlang#system_info_os_system_time_source">erlang#system_info_os_system_time_source</a></p></li><li><p><a href="./erlang#system_info_time_offset">erlang#system_info_time_offset</a></p></li><li><p><a href="./erlang#system_info_time_warp_mode">erlang#system_info_time_warp_mode</a></p></li><li><p><a href="./erlang#system_info_time_correction">erlang#system_info_time_correction</a></p></li><li><p><a href="./erlang#system_info_start_time">erlang#system_info_start_time</a></p></li><li><p><a href="./erlang#system_info_end_time">erlang#system_info_end_time</a></p></li></ul><a name="The_New_Erlang_Monotonic_Time"></a><h3>New Erlang Monotonic Time</h3><p>Erlang monotonic time as such is new as from ERTS 7.0.
It is introduced to detach time measurements, such as elapsed
time from calendar time. In many use cases there is a need to
measure elapsed time or specify a time relative to another point
in time without the need to know the involved times in UTC or
any other globally defined time scale. By introducing a time
scale with a local definition of where it starts, time that do
not concern calendar time can be managed on that time
scale. Erlang monotonic time uses such a time scale with a
locally defined start.</p><p>The introduction of Erlang monotonic time allows
us to adjust the two Erlang times (Erlang
monotonic time and Erlang system time) separately. By
doing this, the accuracy of elapsed time does not have to
suffer just because the system time happened to be
wrong at some point in time. Separate adjustments
of the two times are only performed in the time warp
modes, and only fully separated in the
<a href="#Multi_Time_Warp_Mode">multi-time warp mode</a>. All other modes than the
multi-time warp mode are for backward
compatibility reasons. When using these modes, the
accuracy of Erlang monotonic time suffer, as
the adjustments of Erlang monotonic time in these
modes are more or less tied to Erlang system time.</p><p>The adjustment of system time could have been made
smother than using a time warp approach, but we think
that would be a bad choice. As we can
express and measure time that is not connected to
calendar time by the use of Erlang monotonic time, it
is better to expose the change in Erlang system time
immediately. This as the Erlang applications
executing on the system can react on the change in
system time as soon as possible. This is also more or
less exactly how most operating systems handle this
(OS monotonic time and OS system time). By adjusting
system time smoothly, we would just hide the fact that
system time changed and make it harder for the Erlang
applications to react to the change in a sensible way.</p><p>To be able to react to a change in Erlang
system time, you must be able to detect that it
happened. The change in Erlang system time occurs when the
current time offset is changed. We have therefore
introduced the possibility to monitor the time offset using
<a href="./erlang#monitor/2">erlang#monitor/2</a>.
A process monitoring the time
offset is sent a message on the following format
when the time offset is changed:</p><pre><code class="">
{'CHANGE', MonitorReference, time_offset, clock_service, NewTimeOffset}</code></pre><a name="Unique_Values"></a><h3>Unique Values</h3><p>Besides reporting time, <strong>erlang:now/0</strong> also
produces unique and strictly monotonically increasing
values. To detach this functionality from
time measurements, we have introduced
<a href="./erlang#unique_integer/1">erlang#unique_integer/1</a>.</p><a name="Dos_and_Donts"></a><h3>How to Work with the New API</h3><p>Previously <strong>erlang:now/0</strong> was the only option for doing
many things. This section deals with some things that
<strong>erlang:now/0</strong> can be used for, and how you use the new API.</p><a name="Dos_and_Donts_Retrieve_Erlang_System_Time"></a><h3>Retrieve Erlang System Time</h3><div class="alert alert-danger"><h4 class="alert-heading">Don't</h4><p>
Use <strong>erlang:now/0</strong> to retrieve the current Erlang system time.
</p></div><div class="alert alert-success"><h4 class="alert-heading">Do</h4><p>
Use
<a href="./erlang#system_time/1">erlang#system_time/1</a>
to retrieve the current Erlang system time on the
<a href="./erlang#type_time_unit">time unit</a>
of your choice.</p><p>If you want the same format as returned by <strong>erlang:now/0</strong>,
use <a href="./erlang#timestamp/0">erlang#timestamp/0</a>.
</p></div><a name="Dos_and_Donts_Measure_Elapsed_Time"></a><h3>Measure Elapsed Time</h3><div class="alert alert-danger"><h4 class="alert-heading">Don't</h4><p>
Take time stamps with <strong>erlang:now/0</strong> and calculate
the difference in time with
<a href="../stdlib/timer#now_diff/2">stdlib/timer#now_diff/2</a>.
</p></div><div class="alert alert-success"><h4 class="alert-heading">Do</h4><p>
Take time stamps with
<a href="./erlang#monotonic_time/0">erlang#monotonic_time/0</a>
and calculate the time difference using ordinary subtraction.
The result is in <strong>native</strong>
<a href="./erlang#type_time_unit">time unit</a>.
If you want to convert the
result to another time unit, you can use
<a href="./erlang#convert_time_unit/3">erlang#convert_time_unit/3</a>.
</p><p>An easier way to do this is to use
<a href="./erlang#monotonic_time/1">erlang#monotonic_time/1</a>
with the desired time unit. However, you can then lose accuracy
and precision.
</p></div><a name="Dos_and_Donts_Determine_Order_of_Events"></a><h3>Determine Order of Events</h3><div class="alert alert-danger"><h4 class="alert-heading">Don't</h4><p>
Determine the order of events by saving a time stamp
with <strong>erlang:now/0</strong> when the event occurs.
</p></div><div class="alert alert-success"><h4 class="alert-heading">Do</h4><p>
Determine the order of events by saving the integer
returned by
<a href="./erlang#unique_integer/1">erlang#unique_integer/1</a>
when the event occurs. These integers are strictly
monotonically ordered on current runtime system instance
corresponding to creation time.
</p></div><a name="Dos_and_Donts_Determine_Order_of_Events_With_Time_of_the_Event"></a><h3>Determine Order of Events with Time of the Event</h3><div class="alert alert-danger"><h4 class="alert-heading">Don't</h4><p>
Determine the order of events by saving a time stamp
with <strong>erlang:now/0</strong> when the event occurs.
</p></div><div class="alert alert-success"><h4 class="alert-heading">Do</h4><p>
Determine the order of events by saving a tuple containing
<a href="./erlang#monotonic_time/0">monotonic time</a>
and a <a href="./erlang#unique_integer/1">strictly monotonically increasing integer</a> as follows:</p><pre><code class="">
Time = erlang:monotonic_time(),
UMI = erlang:unique_integer([monotonic]),
EventTag = {Time, UMI}</code></pre><p>These tuples are strictly monotonically ordered
on the current runtime system instance according to
creation time. It is important that the
monotonic time is in the first element (the most
significant element when comparing two-tuples). Using
the monotonic time in the tuples, you can calculate time
between events.</p><p>If you are interested in Erlang system time at the
time when the event occurred, you can also save the time
offset before or after saving the events using
<a href="./erlang#time_offset/0">erlang#time_offset/0</a>.
Erlang monotonic time added with the time
offset corresponds to Erlang system time.</p><p>If you are executing in a mode where time offset
can change, and you want to get the actual
Erlang system time when the event occurred, you can
save the time offset as a third element in the tuple
(the least significant element when comparing three-tuples).</p></div><a name="Dos_and_Donts_Create_a_Unique_Name"></a><h3>Create a Unique Name</h3><div class="alert alert-danger"><h4 class="alert-heading">Don't</h4><p>
Use the values returned from <strong>erlang:now/0</strong>
to create a name unique on the current runtime system instance.
</p></div><div class="alert alert-success"><h4 class="alert-heading">Do</h4><p>
Use the value returned from
<a href="./erlang#unique_integer/0">erlang#unique_integer/0</a>
to create a name unique on the current runtime system
instance. If you only want positive integers, you can use
<a href="./erlang#unique_integer/1">erlang#unique_integer/1</a>.
</p></div><a name="Dos_and_Donts_Seed_Random_Number_Generation_With_a_Unique_Value"></a><h3>Seed Random Number Generation with a Unique Value</h3><div class="alert alert-danger"><h4 class="alert-heading">Don't</h4><p>
Seed random number generation using <strong>erlang:now()</strong>.
</p></div><div class="alert alert-success"><h4 class="alert-heading">Do</h4><p>
Seed random number generation using a combination of
<a href="./erlang#monotonic_time/0">erlang#monotonic_time/0</a>,
<a href="./erlang#time_offset/0">erlang#time_offset/0</a>,
<a href="./erlang#unique_integer/0">erlang#unique_integer/0</a>,
and other functionality.
</p></div><p>To sum up this section: <em>Do not use erlang:now/0.</em></p><a name="Supporting_Both_New_and_Old_OTP_Releases"></a><h3>Support of Both New and Old OTP Releases</h3><p>It can be required that your code must run on a variety
of OTP installations of different OTP releases. If so, you
cannot use the new API out of the box, as it will
not be available on releases before OTP 18. The solution
is <em>not</em> to avoid using the new API, as your
code would then not benefit from the scalability
and accuracy improvements made. Instead, use the
new API when available, and fall back on <strong>erlang:now/0</strong>
when the new API is unavailable.</p><p>Fortunately most of the new API can easily be
implemented using existing primitives, except for:</p><ul><li> <a href="./erlang#system_info_start_time">erlang#system_info_start_time</a> </li><li> <a href="./erlang#system_info_end_time">erlang#system_info_end_time</a> </li><li> <a href="./erlang#system_info_os_monotonic_time_source">erlang#system_info_os_monotonic_time_source</a> </li><li> <a href="./erlang#system_info_os_system_time_source">erlang#system_info_os_system_time_source</a> </li></ul><p>By wrapping the API with functions that fall back on
<strong>erlang:now/0</strong> when the new API is unavailable,
and using these wrappers instead of using the API directly,
the problem is solved. These wrappers can, for example,
be implemented as in
<a href="time_compat.erl">$ERL_TOP/erts/example/time_compat.erl</a>.</p><p>A "match specification" (<strong>match_spec</strong>) is an Erlang term describing a
small "program" that tries to match something. It can be used
to either control tracing with
<a href="./erlang#trace_pattern/3">erlang:trace_pattern/3</a>
or to search for objects in an ETS table with for example
<a href="../stdlib/ets#select/2">ets:select/2</a>.
The match specification in many ways works like a small function in Erlang,
but is interpreted/compiled by the Erlang runtime system to something much more
efficient than calling an Erlang function. The match specification is also
very limited compared to the expressiveness of real Erlang functions.</p><p>The most notable difference between a match specification and an Erlang
fun is the syntax. Match specifications are Erlang terms, not Erlang code.
Also, a match specification has a strange concept of exceptions:</p><ul><li> <p>An exception (such as <strong>badarg</strong>) in the
<strong>MatchCondition</strong> part, which resembles an Erlang guard,
generates immediate failure.</p> </li><li> <p>An exception in the <strong>MatchBody</strong> part, which resembles
the body of an Erlang function, is implicitly caught and results in the
single atom <strong>'EXIT'</strong>.</p> </li></ul><h3>Grammar</h3><p>A match specification used in tracing can be described in the following
<em>informal</em> grammar:</p><ul><li>MatchExpression ::= [ MatchFunction, ... ] </li><li>MatchFunction ::= { MatchHead, MatchConditions, MatchBody } </li><li>MatchHead ::=  MatchVariable | <strong>'_'</strong> | [ MatchHeadPart, ... ] </li><li>MatchHeadPart ::= term() | MatchVariable | <strong>'_'</strong> </li><li>MatchVariable ::= '$&lt;number&gt;' </li><li>MatchConditions ::= [ MatchCondition, ...] | <strong>[]</strong> </li><li>MatchCondition ::= { GuardFunction } | { GuardFunction, ConditionExpression, ... } </li><li>BoolFunction ::= <strong>is_atom</strong> | <strong>is_float</strong> | <strong>is_integer</strong> | <strong>is_list</strong> | <strong>is_number</strong> | <strong>is_pid</strong> | <strong>is_port</strong> | <strong>is_reference</strong> | <strong>is_tuple</strong> | <strong>is_map</strong> | <strong>is_map_key</strong> | <strong>is_binary</strong> | <strong>is_function</strong> | <strong>is_record</strong> | <strong>is_seq_trace</strong> | <strong>'and'</strong> | <strong>'or'</strong> | <strong>'not'</strong> | <strong>'xor'</strong> | <strong>'andalso'</strong> | <strong>'orelse'</strong> </li><li>ConditionExpression ::= ExprMatchVariable | { GuardFunction } | { GuardFunction, ConditionExpression, ... } | TermConstruct </li><li>ExprMatchVariable ::= MatchVariable (bound in the MatchHead) | <strong>'$_'</strong> | <strong>'$$'</strong> </li><li>TermConstruct = {{}} | {{ ConditionExpression, ... }} | <strong>[]</strong> | [ConditionExpression, ...] | <strong>#{}</strong> | #{term() =&gt; ConditionExpression, ...} | NonCompositeTerm | Constant </li><li>NonCompositeTerm ::= term() (not list or tuple or map) </li><li>Constant ::= {<strong>const</strong>, term()} </li><li>GuardFunction ::= BoolFunction | <strong>abs</strong> | <strong>element</strong> | <strong>hd</strong> | <strong>length</strong> | <strong>map_get</strong> | <strong>map_size</strong> | <strong>node</strong> | <strong>round</strong> | <strong>size</strong> | <strong>bit_size</strong> | <strong>tl</strong> | <strong>trunc</strong> | <strong>'+'</strong> | <strong>'-'</strong> | <strong>'*'</strong> | <strong>'div'</strong> | <strong>'rem'</strong> | <strong>'band'</strong> | <strong>'bor'</strong> | <strong>'bxor'</strong> | <strong>'bnot'</strong> | <strong>'bsl'</strong> | <strong>'bsr'</strong> | <strong>'&gt;'</strong> | <strong>'&gt;='</strong> | <strong>'&lt;'</strong> | <strong>'=&lt;'</strong> | <strong>'=:='</strong> | <strong>'=='</strong> | <strong>'=/='</strong> | <strong>'/='</strong> | <strong>self</strong> | <strong>get_tcw</strong> </li><li>MatchBody ::= [ ActionTerm ] </li><li>ActionTerm ::= ConditionExpression | ActionCall </li><li>ActionCall ::= {ActionFunction} | {ActionFunction, ActionTerm, ...} </li><li>ActionFunction ::= <strong>set_seq_token</strong> | <strong>get_seq_token</strong> | <strong>message</strong> | <strong>return_trace</strong> | <strong>exception_trace</strong> | <strong>process_dump</strong> | <strong>enable_trace</strong> | <strong>disable_trace</strong> | <strong>trace</strong> | <strong>display</strong> | <strong>caller</strong> | <strong>set_tcw</strong> | <strong>silent</strong> </li></ul><p>A match specification  used in
<a href="./ets">stdlib/ets</a>
can be described in the following <em>informal</em> grammar:</p><ul><li>MatchExpression ::= [ MatchFunction, ... ] </li><li>MatchFunction ::= { MatchHead, MatchConditions, MatchBody } </li><li>MatchHead ::=  MatchVariable | <strong>'_'</strong> | { MatchHeadPart, ... } </li><li>MatchHeadPart ::= term() | MatchVariable | <strong>'_'</strong> </li><li>MatchVariable ::= '$&lt;number&gt;' </li><li>MatchConditions ::= [ MatchCondition, ...] | <strong>[]</strong> </li><li>MatchCondition ::= { GuardFunction } | { GuardFunction, ConditionExpression, ... } </li><li>BoolFunction ::= <strong>is_atom</strong> | <strong>is_float</strong> | <strong>is_integer</strong> | <strong>is_list</strong> | <strong>is_number</strong> | <strong>is_pid</strong> | <strong>is_port</strong> | <strong>is_reference</strong> | <strong>is_tuple</strong> | <strong>is_map</strong> | <strong>map_is_key</strong> | <strong>is_binary</strong> | <strong>is_function</strong> | <strong>is_record</strong> | <strong>'and'</strong> | <strong>'or'</strong> | <strong>'not'</strong> | <strong>'xor'</strong> | <strong>'andalso'</strong> | <strong>'orelse'</strong> </li><li>ConditionExpression ::= ExprMatchVariable | { GuardFunction } | { GuardFunction, ConditionExpression, ... } | TermConstruct </li><li>ExprMatchVariable ::= MatchVariable (bound in the MatchHead) | <strong>'$_'</strong> | <strong>'$$'</strong> </li><li>TermConstruct = {{}} | {{ ConditionExpression, ... }} | <strong>[]</strong> | [ConditionExpression, ...] | #{} | #{term() =&gt; ConditionExpression, ...} | NonCompositeTerm | Constant </li><li>NonCompositeTerm ::= term() (not list or tuple or map) </li><li>Constant ::= {<strong>const</strong>, term()} </li><li>GuardFunction ::= BoolFunction | <strong>abs</strong> | <strong>element</strong> | <strong>hd</strong> | <strong>length</strong> | <strong>map_get</strong> | <strong>map_size</strong> | <strong>node</strong> | <strong>round</strong> | <strong>size</strong> | <strong>bit_size</strong> | <strong>tl</strong> | <strong>trunc</strong> | <strong>'+'</strong> | <strong>'-'</strong> | <strong>'*'</strong> | <strong>'div'</strong> | <strong>'rem'</strong> | <strong>'band'</strong> | <strong>'bor'</strong> | <strong>'bxor'</strong> | <strong>'bnot'</strong> | <strong>'bsl'</strong> | <strong>'bsr'</strong> | <strong>'&gt;'</strong> | <strong>'&gt;='</strong> | <strong>'&lt;'</strong> | <strong>'=&lt;'</strong> | <strong>'=:='</strong> | <strong>'=='</strong> | <strong>'=/='</strong> | <strong>'/='</strong> | <strong>self</strong> </li><li>MatchBody ::= [ ConditionExpression, ... ] </li></ul><h3>Function Descriptions</h3><h3>Functions Allowed in All Types of Match Specifications</h3><p>The functions allowed in <strong>match_spec</strong> work as
follows:</p><dl><dt><strong>is_atom</strong>, <strong>is_float</strong>, <strong>is_integer</strong>, <strong>is_list</strong>, <strong>is_number</strong>, <strong>is_pid</strong>, <strong>is_port</strong>, <strong>is_reference</strong>, <strong>is_tuple</strong>, <strong>is_map</strong>, <strong>is_binary</strong>, <strong>is_function</strong> </dt><dd> <p>Same as the corresponding guard tests in Erlang, return
<strong>true</strong> or <strong>false</strong>.</p> </dd><dt><strong>is_record</strong></dt><dd> <p>Takes an additional parameter, which <em>must</em> be the result
of <strong>record_info(size, &lt;record_type&gt;)</strong>, like in
<strong>{is_record, '$1', rectype, record_info(size, rectype)}</strong>.</p> </dd><dt><strong>'not'</strong></dt><dd> <p>Negates its single argument (anything other
than <strong>false</strong> gives <strong>false</strong>).</p> </dd><dt><strong>'and'</strong></dt><dd> <p>Returns <strong>true</strong> if all its arguments (variable
length argument list) evaluate to <strong>true</strong>, otherwise
<strong>false</strong>. Evaluation order is undefined.</p> </dd><dt><strong>'or'</strong></dt><dd> <p>Returns <strong>true</strong> if any of its arguments
evaluates to <strong>true</strong>. Variable length argument
list. Evaluation order is undefined.</p> </dd><dt><strong>'andalso'</strong></dt><dd> <p>Works as <strong>'and'</strong>, but quits evaluating its
arguments when one argument evaluates to something else
than <strong>true</strong>. Arguments are evaluated left to right.</p> </dd><dt><strong>'orelse'</strong></dt><dd> <p>Works as <strong>'or'</strong>, but quits evaluating as soon
as one of its arguments evaluates to <strong>true</strong>.
Arguments are evaluated left to right.</p> </dd><dt><strong>'xor'</strong></dt><dd> <p>Only two arguments, of which one must be <strong>true</strong> and the
other <strong>false</strong> to return <strong>true</strong>; otherwise
<strong>'xor'</strong> returns false.</p> </dd><dt><strong>abs</strong>, <strong>element</strong>, <strong>hd</strong>, <strong>length</strong>, <strong>map_get</strong>, <strong>map_size</strong>, <strong>node</strong>, <strong>round</strong>, <strong>size</strong>, <strong>bit_size</strong>, <strong>tl</strong>, <strong>trunc</strong>, <strong>'+'</strong>, <strong>'-'</strong>, <strong>'*'</strong>, <strong>'div'</strong>, <strong>'rem'</strong>, <strong>'band'</strong>, <strong>'bor'</strong>, <strong>'bxor'</strong>, <strong>'bnot'</strong>, <strong>'bsl'</strong>, <strong>'bsr'</strong>, <strong>'&gt;'</strong>, <strong>'&gt;='</strong>, <strong>'&lt;'</strong>, <strong>'=&lt;'</strong>, <strong>'=:='</strong>, <strong>'=='</strong>, <strong>'=/='</strong>, <strong>'/='</strong>, <strong>self</strong></dt><dd> <p>Same as the corresponding Erlang BIFs (or operators). In case of
bad arguments, the result depends on the context. In the
<strong>MatchConditions</strong> part of the expression, the test
fails immediately (like in an Erlang guard). In the
<strong>MatchBody</strong> part, exceptions are implicitly caught
and the call results in the atom <strong>'EXIT'</strong>.</p> </dd></dl><h3>Functions Allowed Only for Tracing</h3><p>The functions allowed only for tracing work as follows:</p><dl><dt><strong>is_seq_trace</strong></dt><dd> <p>Returns <strong>true</strong> if a sequential trace token is set
for the current process, otherwise <strong>false</strong>.</p> </dd><dt><strong>set_seq_token</strong></dt><dd> <p>Works as <strong>seq_trace:set_token/2</strong>, but returns
<strong>true</strong> on success, and <strong>'EXIT'</strong>
on error or bad argument. Only allowed in the
<strong>MatchBody</strong> part and only allowed when tracing.</p> </dd><dt><strong>get_seq_token</strong></dt><dd> <p>Same as <strong>seq_trace:get_token/0</strong> and only
allowed in the <strong>MatchBody</strong> part when tracing.</p> </dd><dt><strong>message</strong></dt><dd> <p>Sets an additional message appended to the
trace message sent. One can only set one additional message in
the body. Later calls replace the appended message.</p> <p>As a special case, <strong>{message, false}</strong> disables
sending of trace messages ('call' and 'return_to') for this function
call, just like if the match specification had not matched.
This can be useful if only the side effects of 
the <strong>MatchBody</strong> part are desired.</p> <p>Another special case is <strong>{message, true}</strong>, which
sets the default behavior, as if the function had no match
specification; trace message is sent with no extra information
(if no other calls to <strong>message</strong> are placed before
<strong>{message, true}</strong>, it is in fact a "noop").</p> <p>Takes one argument: the message. Returns <strong>true</strong>
and can only be used in the <strong>MatchBody</strong> part and
when tracing.</p> </dd><dt><strong>return_trace</strong></dt><dd> <p>Causes a <strong>return_from</strong> trace message to be sent
upon return from the current function. Takes no arguments, returns
<strong>true</strong> and can only be used in the
<strong>MatchBody</strong> part when tracing.
If the process trace flag <strong>silent</strong> is active, the
<strong>return_from</strong> trace message is inhibited.</p> <p><em>Warning:</em> If the traced function is tail-recursive, this
match specification function destroys that property. Hence, if a
match specification executing this function is used on a
perpetual server process, it can only be active for a limited
period of time, or the emulator will eventually use all memory in
the host machine and crash. If this match specification function is
inhibited using process trace flag <strong>silent</strong>,
tail-recursiveness still remains.</p> </dd><dt><strong>exception_trace</strong></dt><dd> <p>Works as <strong>return_trace</strong> plus; if the traced function exits
because of an exception,
an <strong>exception_from</strong> trace message is generated,
regardless of the exception is caught or not.</p> </dd><dt><strong>process_dump</strong></dt><dd> <p>Returns some textual information about
the current process as a binary. Takes no arguments and is only
allowed in the <strong>MatchBody</strong> part when tracing.</p> </dd><dt><strong>enable_trace</strong></dt><dd> <p>With one parameter this function turns on tracing like the Erlang
call <strong>erlang:trace(self(), true, [P2])</strong>, where
<strong>P2</strong> is the parameter to
<strong>enable_trace</strong>.</p> <p>With two parameters, the first parameter is to be either a process
identifier or the registered name of a process. In this case tracing
is turned on for the designated process in the same way as in the
Erlang call <strong>erlang:trace(P1, true, [P2])</strong>, where
<strong>P1</strong> is the first and <strong>P2</strong> is the second argument. The
process <strong>P1</strong> gets its trace messages sent to the
same tracer as the process executing the statement uses.
<strong>P1</strong> <em>cannot</em> be one of the atoms
<strong>all</strong>, <strong>new</strong> or 
<strong>existing</strong> (unless they are registered names).
<strong>P2</strong> <em>cannot</em> be
<strong>cpu_timestamp</strong> or <strong>tracer</strong>.</p> <p>Returns <strong>true</strong> and can only be used in
the <strong>MatchBody</strong> part when tracing.</p> </dd><dt><strong>disable_trace</strong></dt><dd> <p>With one parameter this function disables tracing like the Erlang
call <strong>erlang:trace(self(), false, [P2])</strong>, where
<strong>P2</strong> is the parameter to
<strong>disable_trace</strong>.</p> <p>With two parameters this function works as the Erlang call
<strong>erlang:trace(P1, false, [P2])</strong>, where <strong>P1</strong>
can be either a process identifier or a registered name and is
specified as the first argument to the match specification function.
<strong>P2</strong> <em>cannot</em> be
<strong>cpu_timestamp</strong> or <strong>tracer</strong>.</p> <p>Returns <strong>true</strong> and can only be used in the
<strong>MatchBody</strong> part when tracing.</p> </dd><dt><strong>trace</strong></dt><dd> <p>With two parameters this function takes a list
of trace flags to disable as first parameter and a list
of trace flags to enable as second parameter. Logically, the
disable list is applied first, but effectively all changes
are applied atomically. The trace flags
are the same as for <strong>erlang:trace/3</strong>,
not including <strong>cpu_timestamp</strong>, but including
<strong>tracer</strong>.</p> <p>If a tracer is specified in both lists, the tracer in the
enable list takes precedence. If no tracer is specified, the same
tracer as the process executing the match specification is used (not the meta tracer).
If that process doesn't have tracer either, then trace flags are ignored.</p> <p>When using a <a href="erl_tracer">tracer module</a>,
the module must be loaded before the match specification is
executed. If it is not loaded, the match fails.</p> <p>With three parameters to this function, the first is
either a process identifier or the registered name of a
process to set trace flags on, the second is the disable
list, and the third is the enable list.</p> <p>Returns <strong>true</strong> if any trace property was changed
for the trace target process, otherwise <strong>false</strong>.
Can only be used in the <strong>MatchBody</strong> part when
tracing.</p> </dd><dt><strong>caller</strong></dt><dd> <p>Returns the calling function as a tuple <strong>{Module, Function, Arity}</strong> or the atom <strong>undefined</strong> if the calling
function cannot be determined. Can only be used in the
<strong>MatchBody</strong> part when tracing.</p> <p>Notice that if a "technically built in function" (that is, a
function not written in Erlang) is traced, the
<strong>caller</strong> function sometimes returns the atom
<strong>undefined</strong>. The calling
Erlang function is not available during such calls.</p> </dd><dt><strong>display</strong></dt><dd> <p>For debugging purposes only. Displays the single argument as an
Erlang term on <strong>stdout</strong>, which is seldom what is wanted.
Returns <strong>true</strong> and can only be used in the
<strong>MatchBody</strong> part when tracing.</p> </dd><dt><a name="get_tcw"></a><strong>get_tcw</strong></dt><dd> <p>Takes no argument and returns the value of the node's trace
control word. The same is done by
<strong>erlang:system_info(trace_control_word)</strong>.</p> <p>The trace control word is a 32-bit unsigned integer intended for
generic trace control. The trace control word can be tested and
set both from within trace match specifications and with BIFs.
This call is only allowed when tracing.</p> </dd><dt><a name="set_tcw"></a><strong>set_tcw</strong></dt><dd> <p>Takes one unsigned integer argument, sets the value of
the node's trace control word to the value of the argument,
and returns the previous value. The same is done by
<strong>erlang:system_flag(trace_control_word, Value)</strong>.
It is only allowed to use <strong>set_tcw</strong> in the
<strong>MatchBody</strong> part when tracing.</p> </dd><dt><strong>silent</strong></dt><dd> <p>Takes one argument. If the argument is <strong>true</strong>,
the call trace message mode for the current process is set to
silent for this call and all later calls, that is, call trace
messages are inhibited even if
<strong>{message, true}</strong> is called in the
<strong>MatchBody</strong> part for a traced function.</p> <p>This mode can also be activated with flag
<strong>silent</strong> to
<strong>erlang:trace/3</strong>.</p> <p>If the argument is <strong>false</strong>, the call trace
message mode for the current process is set to normal
(non-silent) for this call and all later calls.</p> <p>If the argument is not <strong>true</strong> or
<strong>false</strong>, the call trace message mode is
unaffected.</p> </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>All "function calls" must be tuples, even if they take no arguments.
The value of <strong>self</strong> is the atom()
<strong>self</strong>, but the value of <strong>{self}</strong> is
the pid() of the current process.</p></div><a name="match_target"></a><h3>Match target</h3><p>Each execution of a match specification is done against
a match target term. The format and content of the target term
depends on the context in which the match is done. The match
target for ETS is always a full table tuple. The match target
for call trace is always a list of all function arguments. The
match target for event trace depends on the event type, see
table below.</p><table class="table table-bordered table-hover table-striped"><caption>Match target depending on context</caption><tbody><tr><td>Context</td><td>Type</td><td>Match target</td><td>Description</td></tr><tr><td>ETS</td><td></td><td>{Key, Value1, Value2, ...}</td><td>A table object</td></tr><tr><td>Trace</td><td>call</td><td>[Arg1, Arg2, ...]</td><td>Function arguments</td></tr><tr><td>Trace</td><td>send</td><td>[Receiver, Message]</td><td>Receiving process/port and message term</td></tr><tr><td>Trace</td><td>'receive'</td><td>[Node, Sender, Message]</td><td>Sending node, process/port and message term</td></tr></tbody></table><h3>Variables and Literals</h3><p>Variables take the form <strong>'$&lt;number&gt;'</strong>, where
<strong>&lt;number&gt;</strong> is an integer between 0 and
100,000,000 (1e+8). The behavior if the number is outside these limits
is <em>undefined</em>. In the <strong>MatchHead</strong> part, the
special variable <strong>'_'</strong> matches anything, and never gets
bound (like <strong>_</strong> in Erlang).</p><ul><li> <p>In the <strong>MatchCondition/MatchBody</strong> parts,
no unbound variables are allowed, so <strong>'_'</strong> is
interpreted as itself (an atom). Variables can only be bound in the
<strong>MatchHead</strong> part.</p> </li><li> <p>In the <strong>MatchBody</strong> and
<strong>MatchCondition</strong> parts, only variables bound
previously can be used.</p> </li><li> <p>As a special case, the following apply in the
<strong>MatchCondition/MatchBody</strong> parts:</p> <ul><li> <p>The variable <strong>'$_'</strong> expands to the whole
<a href="#match_target">match target</a> term.
</p> </li><li> <p>The variable <strong>'$$'</strong> expands to a list of the
values of all bound variables in order (that is,
<strong>['$1','$2', ...]</strong>).</p> </li></ul> </li></ul><p>In the <strong>MatchHead</strong> part, all literals (except the
variables above) are interpreted "as is".</p><p>In the <strong>MatchCondition/MatchBody</strong> parts, the
interpretation is in some ways different. Literals in these parts
can either be written "as is", which works for all literals except
tuples, or by using the special form <strong>{const, T}</strong>,
where <strong>T</strong> is any Erlang term.</p><p>For tuple literals in the match specification, double tuple parentheses
can also be used, that is, construct them as a tuple of
arity one containing a single tuple, which is the one to be
constructed. The "double tuple parenthesis" syntax is useful to
construct tuples from already bound variables, like in
<strong>{{'$1', [a,b,'$2']}}</strong>. Examples:</p><table class="table table-bordered table-hover table-striped"><caption>Literals in MatchCondition/MatchBody Parts of a Match
        Specification</caption><tbody><tr><td><em>Expression</em></td><td><em>Variable Bindings</em></td><td><em>Result</em></td></tr><tr><td>{{'$1','$2'}}</td><td>'$1' = a, '$2' = b</td><td>{a,b}</td></tr><tr><td>{const, {'$1', '$2'}}</td><td>Irrelevant</td><td>{'$1', '$2'}</td></tr><tr><td>a</td><td>Irrelevant</td><td>a</td></tr><tr><td>'$1'</td><td>'$1' = []</td><td>[]</td></tr><tr><td>['$1']</td><td>'$1' = []</td><td>[[]]</td></tr><tr><td>[{{a}}]</td><td>Irrelevant</td><td>[{a}]</td></tr><tr><td>42</td><td>Irrelevant</td><td>42</td></tr><tr><td>"hello"</td><td>Irrelevant</td><td>"hello"</td></tr><tr><td>$1</td><td>Irrelevant</td><td>49 (the ASCII value for character '1')</td></tr></tbody></table><h3>Execution of the Match</h3><p>The execution of the match expression, when the runtime system
decides whether a trace message is to be sent, is as follows:</p><p>For each tuple in the <strong>MatchExpression</strong> list and while
no match has succeeded:</p><ul><li> <p>Match the <strong>MatchHead</strong> part against the match target
term, binding the <strong>'$&lt;number&gt;'</strong> variables
(much like in <strong>ets:match/2</strong>). If the
<strong>MatchHead</strong> part cannot match the arguments, the
match fails.</p> </li><li> <p>Evaluate each <strong>MatchCondition</strong> (where only
<strong>'$&lt;number&gt;'</strong> variables previously bound in the
<strong>MatchHead</strong> part can occur) and expect it to return
the atom <strong>true</strong>. When a condition does not evaluate
to <strong>true</strong>, the match fails. If any BIF call
generates an exception, the match also fails.</p> </li><li> <p>Two cases can occur:</p> <ul><li> <p>If the match specification is executing when tracing:</p> <p>Evaluate each <strong>ActionTerm</strong> in the same way as
the <strong>MatchConditions</strong>, but ignore the return
values. Regardless of what happens in this part, the match has
succeeded.</p> </li><li> <p>If the match specification is executed when selecting objects
from an ETS table:</p> <p>Evaluate the expressions in order and return the value of
the last expression (typically there is only one expression
in this context).</p> </li></ul> </li></ul><a name="differences_ets_tracing"></a><h3>Differences between Match Specifications in ETS and Tracing</h3><p>ETS match specifications produce a return value.
Usually the <strong>MatchBody</strong> contains one single
<strong>ConditionExpression</strong> that defines the return value
without any side effects. Calls with side effects are not allowed in
the ETS context.</p><p>When tracing there is no return value to produce, the
match specification either matches or does not. The effect when the
expression matches is a trace message rather than a returned
term. The <strong>ActionTerm</strong>s are executed as in an imperative
language, that is, for their side effects. Functions with side effects
are also allowed when tracing.</p><h3>Tracing Examples</h3><p>Match an argument list of three, where the first and third arguments
are equal:</p><pre><code class="">
[{['$1', '_', '$1'],
  [],
  []}]
    </code></pre><p>Match an argument list of three, where the second argument is
a number &gt; 3:</p><pre><code class="">
[{['_', '$1', '_'],
  [{ '&gt;', '$1', 3}],
  []}]
    </code></pre><p>Match an argument list of three, where the third argument is
either a tuple containing argument one and two, <em>or</em> a list
beginning with argument one and two (that is,
<strong>[a,b,[a,b,c]]</strong> or <strong>[a,b,{a,b}]</strong>):</p><pre><code class="">
[{['$1', '$2', '$3'],
  [{'orelse', 
      {'=:=', '$3', {{'$1','$2'}}},
      {'and', 
        {'=:=', '$1', {hd, '$3'}},
        {'=:=', '$2', {hd, {tl, '$3'}}}}}],
  []}]
    </code></pre><p>The above problem can also be solved as follows:</p><pre><code class="">
[{['$1', '$2', {'$1', '$2}], [], []},
 {['$1', '$2', ['$1', '$2' | '_']], [], []}]
    </code></pre><p>Match two arguments, where the first is a tuple beginning with
a list that in turn begins with the second argument times
two (that is, <strong>[{[4,x],y},2]</strong> or <strong>[{[8], y, z},4])</strong>:</p><pre><code class="">
[{['$1', '$2'],[{'=:=', {'*', 2, '$2'}, {hd, {element, 1, '$1'}}}],
  []}]
    </code></pre><p>Match three arguments. When all three are equal and are
numbers, append the process dump to the trace message, otherwise
let the trace message be "as is", but set the sequential trace
token label to 4711:</p><pre><code class="">
[{['$1', '$1', '$1'],
  [{is_number, '$1'}],
  [{message, {process_dump}}]},
 {'_', [], [{set_seq_token, label, 4711}]}]
    </code></pre><p>As can be noted above, the parameter list can be matched against a
single <strong>MatchVariable</strong> or an <strong>'_'</strong>.
To replace the whole parameter list with a single variable is a special
case. In all other cases the <strong>MatchHead</strong> must be a
<em>proper</em> list.</p><p>Generate a trace message only if the trace control word is set to 1:</p><pre><code class="">
[{'_',
  [{'==',{get_tcw},{const, 1}}],
  []}]
    </code></pre><p>Generate a trace message only if there is a <strong>seq_trace</strong> token:</p><pre><code class="">
[{'_',
  [{'==',{is_seq_trace},{const, 1}}],
  []}]
    </code></pre><p>Remove the <strong>'silent'</strong> trace flag when the first argument is
<strong>'verbose'</strong>, and add it when it is <strong>'silent':</strong></p><pre><code class="">
[{'$1',
  [{'==',{hd, '$1'},verbose}],
  [{trace, [silent],[]}]},
 {'$1',
  [{'==',{hd, '$1'},silent}],
  [{trace, [],[silent]}]}]
    </code></pre><p>Add a <strong>return_trace</strong> message if the function is of arity 3:</p><pre><code class="">
[{'$1',
  [{'==',{length, '$1'},3}],
  [{return_trace}]},
 {'_',[],[]}]
    </code></pre><p>Generate a trace message only if the function is of arity 3 and the
first argument is <strong>'trace'</strong>:</p><pre><code class="">
[{['trace','$2','$3'],
  [],
  []},
 {'_',[],[]}]
    </code></pre><h3>ETS Examples</h3><p>Match all objects in an ETS table, where the first element is
the atom <strong>'strider'</strong> and the tuple arity is 3, and return the whole
object:</p><pre><code class="">
[{{strider,'_','_'},
  [],
  ['$_']}]
    </code></pre><p>Match all objects in an ETS table with arity &gt; 1 and the first
element is 'gandalf', and return element 2:</p><pre><code class="">
[{'$1',
  [{'==', gandalf, {element, 1, '$1'}},{'&gt;=',{size, '$1'},2}],
  [{element,2,'$1'}]}]
    </code></pre><p>In this example, if the first element had been the key, it is
much more efficient to match that key in the <strong>MatchHead</strong>
part than in the <strong>MatchConditions</strong> part.
The search space of the tables is restricted with regards to the
<strong>MatchHead</strong> so
that only objects with the matching key are searched.</p><p>Match tuples of three elements, where the second element is either
<strong>'merry'</strong> or <strong>'pippin'</strong>, and return the whole objects:</p><pre><code class="">
[{{'_',merry,'_'},
  [],
  ['$_']},
 {{'_',pippin,'_'},
  [],
  ['$_']}]
    </code></pre><p>Function <a href="../stdlib/ets#test_ms/2">stdlib/ets#test_ms/2</a>
can be useful for testing complicated ETS matches.</p><p>This section describes the <strong>erl_crash.dump</strong> file
generated upon abnormal exit of the Erlang runtime system.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The Erlang crash dump had a major facelift in Erlang/OTP R9C. The
information in this section is therefore not directly applicable for
older dumps. However, if you use <a href="./crashdump_viewer">observer/crashdump_viewer</a> on older dumps,
the crash dumps are translated into a format similar to this.</p></div><p>The system writes the crash dump in the current directory of
the emulator or in the file pointed out by the environment variable
(whatever that means on the current operating system)
<strong>ERL_CRASH_DUMP</strong>. For a crash dump to be written, a
writable file system must be mounted.</p><p>Crash dumps are written mainly for one of two reasons: either the
built-in function <strong>erlang:halt/1</strong> is called explicitly
with a string argument from running Erlang code, or the runtime
system has detected an error that cannot be handled. The most
usual reason that the system cannot handle the error is that the
cause is external limitations, such as running out of memory. A
crash dump caused by an internal error can be caused by the system
reaching limits in the emulator itself (like the number of atoms
in the system, or too many simultaneous ETS tables). Usually the
emulator or the operating system can be reconfigured to avoid the
crash, which is why interpreting the crash dump correctly is
important.</p><p>On systems that support OS signals, it is also possible to stop
the runtime system and generate a crash dump by sending the <strong>SIGUSR1</strong>
signal.</p><p>The Erlang crash dump is a readable text file, but it can be difficult
to read. Using the Crashdump Viewer tool in the
<strong>Observer</strong> application simplifies the task. This is a
wx-widget-based tool for browsing Erlang crash dumps.</p><a name="general_info"></a><h3>General Information</h3><p>The first part of the crash dump shows the following:</p><ul><li>The creation time for the dump</li><li>A slogan indicating the reason for the dump</li><li>The system version of the node from which the dump originates</li><li>The compile time of the emulator running the originating node</li><li>The number of atoms in the atom table</li><li>The runtime system thread that caused the crash dump</li></ul><h3>Reasons for Crash Dumps (Slogan)</h3><p>The reason for the dump is shown in the beginning of the file as:</p><pre>
Slogan: &lt;reason&gt;</pre><p>If the system is halted by the BIF
<strong>erlang:halt/1</strong>, the slogan is the string parameter
passed to the BIF, otherwise it is a description generated by
the emulator or the (Erlang) kernel. Normally the message
is enough to understand the problem, but
some messages are described here. Notice that the
suggested reasons for the crash are <em>only suggestions</em>.
The exact reasons for the errors can vary
depending on the local applications and the underlying
operating system.</p><dl><dt><em>&lt;A&gt;: Cannot allocate &lt;N&gt; bytes of memory (of type "&lt;T&gt;")</em></dt><dd> <p>The system has run out of memory. &lt;A&gt; is the allocator that
failed to allocate memory, &lt;N&gt; is the number of bytes that
&lt;A&gt; tried to allocate, and &lt;T&gt; is the memory block
type that the memory was needed for. The most common case is
that a process stores huge amounts of data. In this case
&lt;T&gt; is most often <strong>heap</strong>,
<strong>old_heap</strong>, <strong>heap_frag</strong>, or
<strong>binary</strong>. For more information on allocators, see
<a href="erts_alloc">erts_alloc</a>.</p> </dd><dt><em>&lt;A&gt;: Cannot reallocate &lt;N&gt; bytes of memory (of type "&lt;T&gt;")</em></dt><dd> <p>Same as above except that memory was reallocated
instead of allocated when the system ran out of memory.</p> </dd><dt><em>Unexpected op code &lt;N&gt;</em></dt><dd> <p>Error in compiled code, <strong>beam</strong> file damaged, or
error in the compiler.</p> </dd><dt><em>Module &lt;Name&gt; undefined | Function &lt;Name&gt; undefined | No function &lt;Name&gt;:&lt;Name&gt;/1 | No function &lt;Name&gt;:start/2</em></dt><dd> <p>The Kernel/STDLIB applications are
damaged or the start script is damaged.</p> </dd><dt><em>Driver_select called with too large file descriptor N</em></dt><dd> <p>The number of file descriptors for sockets
exceeds 1024 (Unix only). The limit on file descriptors in
some Unix flavors can be set to over 1024, but only 1024
sockets/pipes can be used simultaneously by Erlang (because of
limitations in the Unix <strong>select</strong> call). The number
of open regular files is not affected by this.</p> </dd><dt><em>Received SIGUSR1</em></dt><dd> <p>Sending the <strong>SIGUSR1</strong> signal to an Erlang machine (Unix only)
forces a crash dump. This slogan reflects that the Erlang machine
crash-dumped because of receiving that signal.</p> </dd><dt><em>Kernel pid terminated (&lt;Who&gt;) (&lt;Exit reason&gt;)</em></dt><dd> <p>The kernel supervisor has detected a failure, usually that the
<strong>application_controller</strong> has shut down
(<strong>Who</strong> = <strong>application_controller</strong>,
<strong>Why</strong> = <strong>shutdown</strong>).
The application controller
can have shut down for many reasons, the most usual
is that the node name of the distributed Erlang node is
already in use. A complete supervisor tree "crash" (that is,
the top supervisors have exited) gives about the same
result. This message comes from the Erlang code and not from
the virtual machine itself. It is always because of some
failure in an application, either within OTP or a
"user-written" one. Looking at the error log for your
application is probably the first step to take.</p> </dd><dt><em>Init terminating in do_boot ()</em></dt><dd> <p>The primitive Erlang boot sequence was terminated, most probably
because the boot script has errors or cannot be read. This is
usually a configuration error; the system can have been started
with a faulty <strong>-boot</strong> parameter or with a boot
script from the wrong OTP version.</p> </dd><dt><em>Could not start kernel pid (&lt;Who&gt;) ()</em></dt><dd> <p>One of the kernel processes could not start. This is probably
because of faulty arguments (like errors in a
<strong>-config</strong> argument)
or faulty configuration files. Check that all files are in
their correct location and that the configuration files (if
any) are not damaged. Usually messages are also
written to the controlling terminal and/or the error log
explaining what is wrong.</p> </dd></dl><p>Other errors than these can occur, as the
<strong>erlang:halt/1</strong> BIF can generate any message. If the
message is not generated by the BIF and does not occur in the
list above, it can be because of an error in the emulator. There
can however be unusual messages, not mentioned here, which
are still connected to an application failure. There is much
more information available, so a thorough reading of the
crash dump can reveal the crash reason. The size of processes,
the number of ETS tables, and the Erlang data on each process
stack can be useful to find the problem.</p><h3>Number of Atoms</h3><p>The number of atoms in the system at the time of the crash is
shown as <em>Atoms: &lt;number&gt;</em>. Some ten thousands atoms is
perfectly normal, but more can indicate that the BIF
<strong>erlang:list_to_atom/1</strong> is used to generate many
<em>different</em> atoms dynamically, which is never a good idea.</p><a name="scheduler"></a><h3>Scheduler Information</h3><p>Under the tag <em>=scheduler</em> is shown information about the current
state and statistics of the schedulers in the runtime system. On
operating systems that allow suspension of other threads, the
data within this section reflects what the runtime system looks like
when a crash occurs.</p><p>The following fields can exist for a process:</p><dl><dt><em>=scheduler:id</em></dt><dd> <p>Heading. States the scheduler identifier.</p> </dd><dt><em>Scheduler Sleep Info Flags</em></dt><dd> <p>If empty, the scheduler was doing some work.
If not empty, the scheduler is either in some state of sleep,
or suspended. This entry is only present in an SMP-enabled
emulator.</p> </dd><dt><em>Scheduler Sleep Info Aux Work</em></dt><dd> <p>If not empty, a scheduler internal auxiliary work is scheduled
to be done.</p> </dd><dt><em>Current Port</em></dt><dd> <p>The port identifier of the port that is currently
executed by the scheduler.</p> </dd><dt><em>Current Process</em></dt><dd> <p>The process identifier of the process that is currently
executed by the scheduler. If there is such a process, this entry is
followed by the <em>State</em>, <em>Internal State</em>,
<em>Program Counter</em>, and <em>CP</em> of that same process.
The entries are described in section
<a href="#processes">Process Information</a>.</p> <p>Notice that this is a snapshot of what the entries are exactly when
the crash dump is starting to be generated. Therefore they are most
likely different (and more telling) than the entries for the same
processes found in the <em>=proc</em> section. If there is no
currently running process, only the <em>Current Process</em> entry is
shown.</p> </dd><dt><em>Current Process Limited Stack Trace</em></dt><dd> <p>This entry is shown only if there is a current process. It is
similar to <a href="#proc_data">proc_data</a>, except that only the function frames
are shown (that is, the stack variables are omitted).
Also, only the top and bottom part of the stack are shown. If the
stack is small (&lt; 512 slots), the entire stack is shown. Otherwise
the entry <em>skipping ## slots</em> is shown, where <strong>##</strong>
is replaced by the number of slots that has been skipped.</p> </dd><dt><em>Run Queue</em></dt><dd> <p>Shows statistics about how many processes and ports
of different priorities are scheduled on this scheduler.</p> </dd><dt><em>** crashed **</em></dt><dd> <p>This entry is normally not shown. It signifies that getting the rest
of the information about this scheduler failed for some reason.</p> </dd></dl><a name="memory"></a><h3>Memory Information</h3><p>Under the tag <em>=memory</em> is shown information similar
to what can be obtainted on a living node with
<a href="../erts/erlang#memory/0">erts/erlang#memory/0</a>.</p><a name="internal_tables"></a><h3>Internal Table Information</h3><p>Under the tags <em>=hash_table:&lt;table_name&gt;</em> and
<em>=index_table:&lt;table_name&gt;</em> is shown internal
tables. These are mostly of interest for runtime system developers.</p><a name="allocated_areas"></a><h3>Allocated Areas</h3><p>Under the tag <em>=allocated_areas</em> is shown information
similar to what can be obtained on a living node with
<a href="../erts/erlang#system_info_allocated_areas">erts/erlang#system_info_allocated_areas</a>.</p><a name="allocator"></a><h3>Allocator</h3><p>Under the tag <em>=allocator:&lt;A&gt;</em> is shown
various information about allocator &lt;A&gt;. The information
is similar to what can be obtained on a living node with
<a href="../erts/erlang#system_info_allocator_tuple">erts/erlang#system_info_allocator_tuple</a>.
For more information, see also
<a href="erts_alloc">erts_alloc</a>.</p><a name="processes"></a><h3>Process Information</h3><p>The Erlang crashdump contains a listing of each living Erlang
process in the system. The following fields can exist for a process:</p><dl><dt><em>=proc:&lt;pid&gt;</em></dt><dd> <p>Heading. States the process identifier.</p> </dd><dt><em>State</em></dt><dd> <p>The state of the process. This can be one of the following:</p> <dl><dt><em>Scheduled</em></dt><dd>The process was scheduled to run but is currently not running ("in the run queue").</dd><dt><em>Waiting</em></dt><dd>The process was waiting for something (in <strong>receive</strong>).</dd><dt><em>Running</em></dt><dd>The process was currently running. If the BIF <strong>erlang:halt/1</strong> was called, this was the process calling it.</dd><dt><em>Exiting</em></dt><dd>The process was on its way to exit.</dd><dt><em>Garbing</em></dt><dd>This is bad luck, the process was garbage collecting when the crash dump was written. The rest of the information for this process is limited.</dd><dt><em>Suspended</em></dt><dd>The process is suspended, either by the BIF <strong>erlang:suspend_process/1</strong> or because it tries to write to a busy port.</dd></dl> </dd><dt><em>Registered name</em></dt><dd> <p>The registered name of the process, if any.</p> </dd><dt><em>Spawned as</em></dt><dd> <p>The entry point of the process, that is, what function was
referenced in the <strong>spawn</strong> or
<strong>spawn_link</strong> call that
started the process.</p> </dd><dt><em>Last scheduled in for | Current call</em></dt><dd> <p>The current function of the process. These fields do not
always exist.</p> </dd><dt><em>Spawned by</em></dt><dd> <p>The parent of the process, that is, the process that executed
<strong>spawn</strong> or <strong>spawn_link</strong>.</p> </dd><dt><em>Started</em></dt><dd> <p>The date and time when the process was started.</p> </dd><dt><em>Message queue length</em></dt><dd> <p>The number of messages in the process' message queue.</p> </dd><dt><em>Number of heap fragments</em></dt><dd> <p>The number of allocated heap fragments.</p> </dd><dt><em>Heap fragment data</em></dt><dd> <p>Size of fragmented heap data. This is data either created by
messages sent to the process or by the Erlang BIFs. This
amount depends on so many things that this field is utterly
uninteresting.</p> </dd><dt><em>Link list</em></dt><dd> <p>Process IDs of processes linked to this one. Can also contain
ports. If process monitoring is used, this field also tells in
which direction the monitoring is in effect. That is, a link
"to" a process tells you that the "current" process was
monitoring the other, and a link "from" a process tells you
that the other process was monitoring the current one.</p> </dd><dt><em>Reductions</em></dt><dd> <p>The number of reductions consumed by the process.</p> </dd><dt><em>Stack+heap</em></dt><dd> <p>The size of the stack and heap (they share memory segment).</p> </dd><dt><em>OldHeap</em></dt><dd> <p>The size of the "old heap". The Erlang virtual machine uses
generational garbage collection with two generations. There is
one heap for new data items and one for the data that has
survived two garbage collections. The assumption (which is
almost always correct) is that data surviving two garbage
collections can be "tenured" to a heap more seldom garbage
collected, as they will live for a long period. This is a
usual technique in virtual machines. The sum of the
heaps and stack together constitute most of the
allocated memory of the process.</p> </dd><dt><em>Heap unused, OldHeap unused</em></dt><dd> <p>The amount of unused memory on each heap. This information is
usually useless.</p> </dd><dt><em>Memory</em></dt><dd> <p>The total memory used by this process. This includes call stack,
heap, and internal structures. Same as
<a href="./erlang#process_info-2">erlang#process_info-2</a>.</p> </dd><dt><em>Program counter</em></dt><dd> <p>The current instruction pointer. This is only of interest for
runtime system developers. The function into which the program
counter points is the current function of the process.</p> </dd><dt><em>CP</em></dt><dd> <p>The continuation pointer, that is, the return address for the
current call. Usually useless for other than runtime system
developers. This can be followed by the function into which
the CP points, which is the function calling the current
function.</p> </dd><dt><em>Arity</em></dt><dd> <p>The number of live argument registers. The argument registers
if any are live will follow. These can contain the arguments
of the function if they are not yet moved to the stack.</p> </dd><dt><em>Internal State</em></dt><dd> <p>A more detailed internal representation of the state of
this process.</p> </dd></dl><p>See also section <a href="#proc_data">Process Data</a>.</p><a name="ports"></a><h3>Port Information</h3><p>This section lists the open ports, their owners, any linked
processes, and the name of their driver or external process.</p><a name="ets_tables"></a><h3>ETS Tables</h3><p>This section contains information about all the ETS tables in
the system. The following fields are of interest for each table:</p><dl><dt><em>=ets:&lt;owner&gt;</em></dt><dd> <p>Heading. States the table owner (a process identifier).</p> </dd><dt><em>Table</em></dt><dd> <p>The identifier for the table. If the table is a
<strong>named_table</strong>, this is the name.</p> </dd><dt><em>Name</em></dt><dd> <p>The table name, regardless of if it is a
<strong>named_table</strong> or not.</p> </dd><dt><em>Hash table, Buckets</em></dt><dd> <p>If the table is a hash table, that is, if it is not an
<strong>ordered_set</strong>.</p> </dd><dt><em>Hash table, Chain Length</em></dt><dd> <p>If the table is a hash table. Contains statistics about the
table, such as the maximum, minimum, and average chain length.
Having a maximum much larger than the average, and a standard
deviation much larger than the expected standard deviation is
a sign that the hashing of the terms
behaves badly for some reason.</p> </dd><dt><em>Ordered set (AVL tree), Elements</em></dt><dd> <p>If the table is an <strong>ordered_set</strong>. (The
number of elements is the same as the number of objects in the
table.)</p> </dd><dt><em>Fixed</em></dt><dd> <p>If the table is fixed using
<a href="../stdlib/ets#safe_fixtable/2">stdlib/ets#safe_fixtable/2</a> or some internal mechanism.</p> </dd><dt><em>Objects</em></dt><dd> <p>The number of objects in the table.</p> </dd><dt><em>Words</em></dt><dd> <p>The number of words (usually 4 bytes/word) allocated to data
in the table.</p> </dd><dt><em>Type</em></dt><dd> <p>The table type, that is, <strong>set</strong>, <strong>bag</strong>,
<strong>dublicate_bag</strong>, or <strong>ordered_set</strong>.</p> </dd><dt><em>Compressed</em></dt><dd> <p>If the table was compressed.</p> </dd><dt><em>Protection</em></dt><dd> <p>The protection of the table.</p> </dd><dt><em>Write Concurrency</em></dt><dd> <p>If <strong>write_concurrency</strong> was enabled for the table.</p> </dd><dt><em>Read Concurrency</em></dt><dd> <p>If <strong>read_concurrency</strong> was enabled for the table.</p> </dd></dl><a name="timers"></a><h3>Timers</h3><p>This section contains information about all the timers started
with the BIFs <strong>erlang:start_timer/3</strong> and
<strong>erlang:send_after/3</strong>. The following fields exist
for each timer:</p><dl><dt><em>=timer:&lt;owner&gt;</em></dt><dd> <p>Heading. States the timer owner (a process identifier),
that is, the process to receive the message when the timer
expires.</p> </dd><dt><em>Message</em></dt><dd> <p>The message to be sent.</p> </dd><dt><em>Time left</em></dt><dd> <p>Number of milliseconds left until the message would have been
sent.</p> </dd></dl><a name="distribution_info"></a><h3>Distribution Information</h3><p>If the Erlang node was alive, that is, set up for communicating
with other nodes, this section lists the connections that were
active. The following fields can exist:</p><dl><dt><em>=node:&lt;node_name&gt;</em></dt><dd> <p>The node name.</p> </dd><dt><em>no_distribution</em></dt><dd> <p>If the node was not distributed.</p> </dd><dt><em>=visible_node:&lt;channel&gt;</em></dt><dd> <p>Heading for a visible node, that is, an alive node with a
connection to the node that crashed. States the channel number
for the node.</p> </dd><dt><em>=hidden_node:&lt;channel&gt;</em></dt><dd> <p>Heading for a hidden node. A hidden node is the same as a
visible node, except that it is started with the <strong>"-hidden"</strong>
flag. States the channel number for the node.</p> </dd><dt><em>=not_connected:&lt;channel&gt;</em></dt><dd> <p>Heading for a node that was connected to the crashed
node earlier. References (that is, process or port identifiers)
to the not connected node existed at the time of the crash.
States the channel number for the node.</p> </dd><dt><em>Name</em></dt><dd> <p>The name of the remote node.</p> </dd><dt><em>Controller</em></dt><dd> <p>The port controlling communication with the remote node.</p> </dd><dt><em>Creation</em></dt><dd> <p>An integer (1-3) that together with the node name identifies
a specific instance of the node.</p> </dd><dt><em>Remote monitoring: &lt;local_proc&gt;  &lt;remote_proc&gt;</em> </dt><dd> <p>The local process was monitoring the remote process at the
time of the crash.</p> </dd><dt><em>Remotely monitored by: &lt;local_proc&gt; &lt;remote_proc&gt;</em></dt><dd> <p>The remote process was monitoring the local process at the
time of the crash.</p> </dd><dt><em>Remote link: &lt;local_proc&gt; &lt;remote_proc&gt;</em></dt><dd> <p>A link existed between the local process and the remote
process at the time of the crash.</p> </dd></dl><a name="loaded_modules"></a><h3>Loaded Module Information</h3><p>This section contains information about all loaded modules.</p><p>First, the memory use by the loaded code is summarized:</p><dl><dt><em>Current code</em></dt><dd> <p>Code that is the current latest version of the modules.</p> </dd><dt><em>Old code</em></dt><dd> <p>Code where there exists a newer version in the
system, but the old version is not yet purged.</p> </dd></dl><p>The memory use is in bytes.</p><p>Then, all loaded modules are listed. The following fields exist:</p><dl><dt><em>=mod:&lt;module_name&gt;</em></dt><dd> <p>Heading. States the module name.</p> </dd><dt><em>Current size</em></dt><dd> <p>Memory use for the loaded code, in bytes.</p> </dd><dt><em>Old size</em></dt><dd> <p>Memory use for the old code, if any.</p> </dd><dt><em>Current attributes</em></dt><dd> <p>Module attributes for the current code. This field is decoded
when looked at by the Crashdump Viewer tool.</p> </dd><dt><em>Old attributes</em></dt><dd> <p>Module attributes for the old code, if any. This field is
decoded when looked at by the Crashdump Viewer tool.</p> </dd><dt><em>Current compilation info</em></dt><dd> <p>Compilation information (options) for the current code. This
field is decoded when looked at by the Crashdump Viewer tool.</p> </dd><dt><em>Old compilation info</em></dt><dd> <p>Compilation information (options) for the old code, if
any. This field is decoded when looked at by the Crashdump
Viewer tool.</p> </dd></dl><a name="funs"></a><h3>Fun Information</h3><p>This section lists all funs. The following fields exist for each fun:</p><dl><dt><em>=fun</em></dt><dd> <p>Heading.</p> </dd><dt><em>Module</em></dt><dd> <p>The name of the module where the fun was defined.</p> </dd><dt><em>Uniq, Index</em></dt><dd> <p>Identifiers.</p> </dd><dt><em>Address</em></dt><dd> <p>The address of the fun's code.</p> </dd><dt><em>Native_address</em></dt><dd> <p>The address of the fun's code when HiPE is enabled.</p> </dd><dt><em>Refc</em></dt><dd> <p>The number of references to the fun.</p> </dd></dl><a name="proc_data"></a><h3>Process Data</h3><p>For each process there is at least one <em>=proc_stack</em>
and one <em>=proc_heap</em> tag, followed by the raw memory
information for the stack and heap of the process.</p><p>For each process there is also a <em>=proc_messages</em>
tag if the process message queue is non-empty, and a
<em>=proc_dictionary</em> tag if the process dictionary (the
<strong>put/2</strong> and <strong>get/1</strong> thing) is
non-empty.</p><p>The raw memory information can be decoded by the Crashdump
Viewer tool. You can then see the stack dump, the
message queue (if any), and the dictionary (if any).</p><p>The stack dump is a dump of the Erlang process stack. Most of
the live data (that is, variables currently in use) are placed on
the stack; thus this can be interesting. One has to
"guess" what is what, but as the information is symbolic,
thorough reading of this information can be useful. As an
example, we can find the state variable of the Erlang primitive
loader online <strong>(5)</strong> and <strong>(6)</strong>
in the following example:</p><pre><code class="">
(1)  3cac44   Return addr 0x13BF58 (&lt;terminate process normally&gt;)
(2)  y(0)     ["/view/siri_r10_dev/clearcase/otp/erts/lib/kernel/ebin",
(3)            "/view/siri_r10_dev/clearcase/otp/erts/lib/stdlib/ebin"]
(4)  y(1)     &lt;0.1.0&gt;
(5)  y(2)     {state,[],none,#Fun&lt;erl_prim_loader.6.7085890&gt;,undefined,#Fun&lt;erl_prim_loader.7.9000327&gt;,
(6)            #Fun&lt;erl_prim_loader.8.116480692&gt;,#Port&lt;0.2&gt;,infinity,#Fun&lt;erl_prim_loader.9.10708760&gt;}
(7)  y(3)     infinity    </code></pre><p>When interpreting the data for a process, it is helpful to know
that anonymous function objects (funs) are given the following:</p><ul><li>A name constructed from the name of the function in which they are created </li><li>A number (starting with 0) indicating the number of that fun within that function </li></ul><a name="atoms"></a><h3>Atoms</h3><p>This section presents all the atoms in the system. This is only
of interest if one suspects that dynamic generation of atoms can
be a problem, otherwise this section can be ignored.</p><p>Notice that the last created atom is shown first.</p><h3>Disclaimer</h3><p>The format of the crash dump evolves between OTP releases.
Some information described here may not apply to your
version. A description like this will never be complete; it is meant as
an explanation of the crash dump in general and as a help
when trying to find application errors, not as a complete
specification.</p><p>This section describes how to implement an alternative carrier
protocol for the Erlang distribution. The distribution is normally
carried by TCP/IP. Here is explained a method for replacing TCP/IP
with another protocol.</p><p>The section is a step-by-step explanation of the
<strong>uds_dist</strong> example application (in the
Kernel application <strong>examples</strong> directory). The
<strong>uds_dist</strong> application implements distribution over Unix
domain sockets and is written for the Sun Solaris 2 operating environment.
The mechanisms are however general and apply to any operating system Erlang
runs on. The reason the C code is not made portable, is simply
readability.</p><h3>Introduction</h3><p>To implement a new carrier for the Erlang distribution, the main
steps are as follows.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
As of ERTS version 10.0 support for distribution controller
processes has been introduced. That is, the traffic over a
distribution channel can be managed by a process instead of
only by a port. This makes it possible to implement large
parts of the logic in Erlang code, and you perhaps do not
even need a new driver for the protocol. One example could
be Erlang distribution over UDP using <strong>gen_udp</strong> (your
Erlang code will of course have to take care of retransmissions,
etc in this example). That is, depending on what you want
to do you perhaps do not need to implement a driver at all
and can then skip the driver related sections below.
The <strong>gen_tcp_dist</strong> example described in the
<a href="#distribution_module">Distribution Module</a> section utilize distribution controller
processes and can be worth having a look at if you want to
use distribution controller processes.
</p></div><h3>Writing an Erlang Driver</h3><p>First, the protocol must be available to the Erlang machine, which
involves writing an Erlang driver. A port program cannot be used,
an Erlang driver is required. Erlang drivers can be:</p><ul><li> <p>Statically linked to the emulator, which can be an alternative
when using the open source distribution of Erlang, or</p> </li><li> <p>Dynamically loaded into the Erlang machines address space,
which is the only alternative if a precompiled version of 
Erlang is to be used</p> </li></ul><p>Writing an Erlang driver is not easy. The driver is written
as some callback functions called by the Erlang emulator when
data is sent to the driver, or the driver has any data available on
a file descriptor. As the driver callback routines execute in the main
thread of the Erlang machine, the callback functions can perform
no blocking activity whatsoever. The callbacks are only to set up
file descriptors for waiting and/or read/write available data. All
I/O must be non-blocking. Driver callbacks are however executed
in sequence, why a global state can safely be updated within the
routines.</p><h3>Writing an Erlang Interface for the Driver</h3><p>When the driver is implemented, one would preferably write an
Erlang interface for the driver to be able to test the
functionality of the driver separately. This interface can then
be used by the distribution module, which will cover the details of
the protocol from the <strong>net_kernel</strong>.</p><p>The easiest path
is to mimic the <strong>inet</strong> and <strong>inet_tcp</strong>
interfaces, but not much
functionality in those modules needs to be implemented. In the
example application, only a few of the usual interfaces are
implemented, and they are much simplified.</p><h3>Writing a Distribution Module</h3><p>When the protocol is available to Erlang through a driver and an
Erlang interface module, a distribution module can be written.
The distribution module is a module with well-defined callbacks,
much like a <strong>gen_server</strong> (there is no compiler support
for checking the callbacks, though). This module implements:</p><ul><li>The details of finding other nodes (that is, talking to <strong>epmd</strong> or something similar)</li><li>Creating a listen port (or similar)</li><li>Connecting to other nodes</li><li>Performing the handshakes/cookie verification</li></ul><p>There is however a utility module, <strong>dist_util</strong>, which
does most of the hard work of handling handshakes, cookies, timers,
and ticking. Using <strong>dist_util</strong> makes implementing a
distribution module much easier and that is done in
the example application.</p><h3>Creating Boot Scripts</h3><p>The last step is to create boot scripts to make the protocol
implementation available at boot time. The implementation can be
debugged by starting the distribution when all the system is
running, but in a real system the distribution is to start very
early, why a boot script and some command-line parameters are
necessary.</p><p>This step also implies that the Erlang code in the
interface and distribution modules is written in such a way that
it can be run in the startup phase. In particular, there can be no
calls to the <strong>application</strong> module or to any modules
not loaded at boot time. That is, only <strong>Kernel</strong>,
<strong>STDLIB</strong>, and the application itself can be used.</p><a name="distribution_module"></a><h3>Distribution Module</h3><p>
The distribution module expose an API that <strong>net_kernel</strong> call
in order to manage connections to other nodes. The module name
should have the suffix <strong>_dist</strong>.
</p><p>
The module needs to create some kind of listening entity (process
or port) and an acceptor process that accepts incoming connections
using the listening entity. For each connection, the module at least
needs to create one connection supervisor process, which also is
responsible for the handshake when setting up the connection, and
a distribution controller (process or port) responsible for
transport of data over the connection. The distribution controller
and the connection supervisor process should be linked together
so both of them are cleaned up when the connection is taken down.
</p><p>
Note that there need to be exactly one distribution controller
per connection. A process or port can only be distribution
controller for one connection. The registration as distribution
controller cannot be undone. It will stick until the distribution
controller terminates. The distribution controller should not
ignore exit signals. It is allowed to trap exits, but it should
then voluntarily terminate when an exit signal is received.
</p><p>
An example implementation of a distribution module can be found
in
<a href="gen_tcp_dist.erl">$ERL_TOP/lib/kernel/examples/gen_tcp_dist/src/gen_tcp_dist.erl</a>.
It implements the distribution over TCP/IP using the <strong>gen_tcp</strong>
API with distribution controllers implemented by processes. This
instead of using port distribution controllers as the ordinary TCP/IP
distribution uses.
</p><a name="distribution_module_exported_callback_functions"></a><h3>Exported Callback Functions</h3><p>
The following functions are mandatory:
</p><dl><dt><a name="listen"></a><strong>listen(Name) -&gt;</strong><br/>Â Â <strong>{ok, {Listen, Address, Creation}} | {error, Error} </strong></dt><dd> <p>
<strong>listen/1</strong> is called once in order to listen for incoming
connection requests. The call is made when the distribution is brought
up. The argument <strong>Name</strong> is the part of the node name before
the <strong>@</strong> sign in the full node name. It can be either an atom or a
string.
</p> <p>
The return value consists of a <strong>Listen</strong> handle (which is
later passed to the <a href="#accept">accept</a>
callback), <strong>Address</strong> which is a <strong>#net_address{}</strong> record
with information about the address for the node (the
<strong>#net_address{}</strong> record is defined in
<strong>kernel/include/net_address.hrl</strong>), and <strong>Creation</strong> which
(currently) is an integer <strong>1</strong>, <strong>2</strong>, or <strong>3</strong>.
</p> <p>
If <a href="./epmd">erts/epmd</a> is to be used 
for node discovery, you typically want to use the (unfortunately
undocumented) <strong>erl_epmd</strong> module (part of the <strong>kernel</strong>
application) in order to register the listen port with <strong>epmd</strong>
and retrieve <strong>Creation</strong> to use.
</p> </dd><dt><a name="accept"></a><strong>accept(Listen) -&gt;</strong><br/>Â Â <strong>AcceptorPid</strong></dt><dd> <p>
<strong>accept/1</strong> should spawn a process that accepts connections. This
process should preferably execute on <strong>max</strong> priority. The process
identifier of this process should be returned.
</p> <p>
The <strong>Listen</strong> argument will be the same as the <strong>Listen</strong> handle
part of the return value of the
<a href="#listen">listen</a> callback above.
<strong>accept/1</strong> is called only once when the distribution protocol is
started.
</p> <p>
The caller of this function is a representative for <strong>net_kernel</strong>
(this may or may not be the process registered as <strong>net_kernel</strong>)
and is in this document identified as <strong>Kernel</strong>.
When a connection has been accepted by the acceptor process, it needs
to inform <strong>Kernel</strong> about the accepted connection. This is done by
passing a message on the form:
</p> <pre><code class="">Kernel ! {accept, AcceptorPid, DistController, Family, Proto}</code></pre> <p>
<strong>DistController</strong> is either the process or port identifier
of the distribution controller for the connection. The
distribution controller should be created by the acceptor
processes when a new connection is accepted. Its job is to
dispatch traffic on the connection.
</p> <strong>Kernel</strong> responds with one of the following messages: <dl><dt><strong>{Kernel, controller, SupervisorPid}</strong></dt><dd> <p>
The request was accepted and <strong>SupervisorPid</strong> is the
process identifier of the connection supervisor process
(which is created in the
<a href="#accept_connection">accept_connection</a>
callback).
</p> </dd><dt><strong>{Kernel, unsupported_protocol}</strong></dt><dd> <p>
The request was rejected. This is a fatal error. The acceptor
process should terminate.
</p> </dd></dl> <p>
When an accept sequence has been completed the acceptor process
is expected to continue accepting further requests.
</p> </dd><dt><a name="accept_connection"></a><strong>accept_connection(AcceptorPid, DistCtrl, MyNode, Allowed, SetupTime) -&gt;</strong><br/>Â Â <strong>ConnectionSupervisorPid</strong></dt><dd> <p>
<strong>accept_connection/5</strong> should spawn a process that will
perform the Erlang distribution handshake for the connection.
If the handshake successfully completes it should continue to
function as a connection supervisor. This process
should preferably execute on <strong>max</strong> priority.
</p> <p>The arguments:</p> <dl><dt><strong>AcceptorPid</strong></dt><dd> <p>
Process identifier of the process created by the
<a href="#accept">accept</a>
callback.
</p> </dd><dt><strong>DistCtrl</strong></dt><dd> <p>The identifier of the distribution controller identifier
created by the acceptor process. To be passed along to
<strong>dist_util:handshake_other_started(HsData)</strong>.
</p> </dd><dt><strong>MyNode</strong></dt><dd> <p>
Node name of this node. To be passed along to
<strong>dist_util:handshake_other_started(HsData)</strong>.
</p> </dd><dt><strong>Allowed</strong></dt><dd> <p>
To be passed along to
<strong>dist_util:handshake_other_started(HsData)</strong>.
</p> </dd><dt><strong>SetupTime</strong></dt><dd> <p>
Time used for creating a setup timer by a
call to <strong>dist_util:start_timer(SetupTime)</strong>.
The timer should be passed along to
<strong>dist_util:handshake_other_started(HsData)</strong>.
</p> </dd></dl> <p>
The created process should provide callbacks and other
information needed for the handshake in a
<a href="#hs_data_record">hs_data_record</a>
record and call <strong>dist_util:handshake_other_started(HsData)</strong>
with this record.
</p> <p>
<strong>dist_util:handshake_other_started(HsData)</strong> will perform
the handshake and if the handshake successfully completes this
process will then continue in a connection supervisor loop
as long as the connection is up.
</p> </dd><dt><a name="setup"></a><strong>setup(Node, Type, MyNode, LongOrShortNames, SetupTime) -&gt;</strong><br/>Â Â <strong>ConnectionSupervisorPid</strong></dt><dd> <p>
<strong>setup/5</strong> should spawn a process that connects to
<strong>Node</strong>. When connection has been established it should
perform the Erlang distribution handshake for the connection.
If the handshake successfully completes it should continue to
function as a connection supervisor. This process
should preferably execute on <strong>max</strong> priority.
</p> <p>The arguments:</p> <dl><dt><strong>Node</strong></dt><dd> <p>
Node name of remote node. To be passed along to
<strong>dist_util:handshake_we_started(HsData)</strong>.
</p> </dd><dt><strong>Type</strong></dt><dd> <p>
Connection type. To be passed along to
<strong>dist_util:handshake_we_started(HsData)</strong>.
</p> </dd><dt><strong>MyNode</strong></dt><dd> <p>
Node name of this node. To be passed along to
<strong>dist_util:handshake_we_started(HsData)</strong>.
</p> </dd><dt><strong>LongOrShortNames</strong></dt><dd> <p>
Either the atom <strong>longnames</strong> or
the atom <strong>shortnames</strong> indicating
whether long or short names is used.
</p> </dd><dt><strong>SetupTime</strong></dt><dd> <p>
Time used for creating a setup timer by a
call to <strong>dist_util:start_timer(SetupTime)</strong>.
The timer should be passed along to
<strong>dist_util:handshake_we_started(HsData)</strong>.
</p> </dd></dl> <p>
The caller of this function is a representative for <strong>net_kernel</strong>
(this may or may not be the process registered as <strong>net_kernel</strong>)
and is in this document identified as <strong>Kernel</strong>. 
</p> <p>
This function should, besides spawning the connection supervisor,
also create a distribution controller. The distribution
controller is either a process or a port which is responsible
for dispatching traffic.
</p> <p>
The created process should provide callbacks and other
information needed for the handshake in a
<a href="#hs_data_record">hs_data_record</a>
record and call <strong>dist_util:handshake_we_started(HsData)</strong>
with this record.
</p> <p>
<strong>dist_util:handshake_we_started(HsData)</strong> will perform
the handshake and the handshake successfully completes this
process will then continue in a connection supervisor loop
as long as the connection is up.
</p> </dd><dt><a name="close"></a><strong>close(Listen) -&gt;</strong><br/>Â Â <strong>void()</strong></dt><dd><p>
Called in order to close the <strong>Listen</strong> handle
that originally was passed from the
<a href="#listen">listen</a> callback.
</p></dd><dt><a name="select"></a><strong>select(NodeName) -&gt;</strong><br/>Â Â <strong>boolean()</strong></dt><dd> <p>Return <strong>true</strong> if the host name part
of the <strong>NodeName</strong> is valid for use
with this protocol; otherwise, <strong>false</strong>.
</p> </dd></dl><p>
There are also two optional functions that may be
exported:
</p><dl><dt><a name="select"></a><strong>setopts(Listen, Opts) -&gt;</strong><br/>Â Â <strong>ok | {error, Error}</strong></dt><dd> <p>
The argument <strong>Listen</strong> is the handle originally passed
from the
<a href="#listen">listen</a> callback.
The argument <strong>Opts</strong> is a list of options to set on future
connections.
</p> </dd><dt><a name="select"></a><strong>getopts(Listen, Opts) -&gt;</strong><br/>Â Â <strong>{ok, OptionValues} | {error, Error}</strong></dt><dd> <p>
The argument <strong>Listen</strong> is the handle originally passed
from the
<a href="#listen">listen</a> callback.
The argument <strong>Opts</strong> is a list of options to read for future
connections.
</p> </dd></dl><a name="hs_data_record"></a><h3>The #hs_data{} Record</h3><p>
The <strong>dist_util:handshake_we_started/1</strong> and
<strong>dist_util:handshake_other_started/1</strong> functions
takes a <strong>#hs_data{}</strong> record as argument. There
are quite a lot of fields in this record that you
need to set. The record is defined in
<strong>kernel/include/dist_util.hrl</strong>. Not documented
fields should not be set, i.e., should be left as
<strong>undefined</strong>.
</p><p>
The following <strong>#hs_data{}</strong> record fields need
to be set unless otherwise stated:</p><dl><dt><a name="hs_data_kernel_pid"></a><strong>kernel_pid</strong></dt><dd> <p>
Process identifier of the <strong>Kernel</strong> process. That is,
the process that called either
<a href="#setup">setup</a> or
<a href="#accept_connection">accept_connection</a>.
</p> </dd><dt><a name="hs_data_other_node"></a><strong>other_node</strong></dt><dd> <p>Name of the other node. This field is only
mandatory when this node initiates the connection.
That is, when connection is set up via
<a href="#setup">setup</a>.
</p> </dd><dt><a name="hs_data_this_node"></a><strong>this_node</strong></dt><dd> <p>
The node name of this node.
</p> </dd><dt><a name="hs_data_socket"></a><strong>socket</strong></dt><dd> <p>
The identifier of the distribution controller.
</p> </dd><dt><a name="hs_data_timer"></a><strong>timer</strong></dt><dd> <p>
The timer created using <strong>dist_util:start_timer/1</strong>.
</p> </dd><dt><a name="hs_data_allowed"></a><strong>allowed</strong></dt><dd> <p>Information passed as <strong>Allowed</strong> to
<strong>accept_connection/5</strong>. This field is only
mandatory when the remote node initiated the
connection. That is, when the connection is set
up via
<a href="#accept_connection">accept_connection</a>.
</p> </dd><dt><a name="hs_data_f_send"></a><strong>f_send</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr, Data) -&gt; ok | {error, Error}</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier of
the distribution controller and <strong>Data</strong>
is io data to pass to the other side.
</p> <p>Only used during handshake phase.</p> </dd><dt><a name="hs_data_f_recv"></a><strong>f_recv</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr, Length) -&gt; {ok, Packet} | {error, Reason}</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier of the distribution
controller.
If <strong>Length</strong> is <strong>0</strong>, all available bytes should be
returned. If <strong>Length &gt; 0</strong>, exactly <strong>Length</strong> bytes
should be returned, or an error; possibly discarding less
than <strong>Length</strong> bytes of data when the connection is
closed from the other side.
It is used for passive receive of data from the
other end.
</p> <p>Only used during handshake phase.</p> </dd><dt><a name="hs_data_f_setopts_pre_nodeup"></a><strong>f_setopts_pre_nodeup</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr) -&gt; ok | {error, Error}</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier of
the distribution controller. Called just
before the distribution channel is taken up
for normal traffic.
</p> <p>Only used during handshake phase.</p> </dd><dt><a name="hs_data_f_setopts_post_nodeup"></a><strong>f_setopts_post_nodeup</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr) -&gt; ok | {error, Error}</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier of
the distribution controller. Called just
after distribution channel has been taken
up for normal traffic.
</p> <p>Only used during handshake phase.</p> </dd><dt><a name="hs_data_f_getll"></a><strong>f_getll</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr) -&gt; ID</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier of
the distribution controller and <strong>ID</strong> is
the identifier of the low level entity that
handles the connection (often <strong>DistCtrlr</strong>
itself).
</p> <p>Only used during handshake phase.</p> </dd><dt><a name="hs_data_f_address"></a><strong>f_address</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr, Node) -&gt; NetAddress</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier of
the distribution controller, <strong>Node</strong>
is the node name of the node on the other end,
and <strong>NetAddress</strong> is a <strong>#net_address{}</strong>
record with information about the address
for the <strong>Node</strong> on the other end of the
connection. The <strong>#net_address{}</strong> record
is defined in
<strong>kernel/include/net_address.hrl</strong>.
</p> <p>Only used during handshake phase.</p> </dd><dt><a name="hs_data_mf_tick"></a><strong>mf_tick</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr) -&gt; void()</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier
of the distribution controller. This
function should send information over
the connection that is not interpreted
by the other end while increasing the
statistics of received packets on the
other end. This is usually implemented by
sending an empty packet.
</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
It is of vital importance that this operation
does not block the caller for a long time.
This since it is called from the connection
supervisor.
</p></div> <p>Used when connection is up.</p> </dd><dt><a name="hs_data_mf_getstat"></a><strong>mf_getstat</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr) -&gt; {ok, Received, Sent, PendSend}</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier
of the distribution controller, <strong>Received</strong>
is received packets, <strong>Sent</strong> is
sent packets, and <strong>PendSend</strong> is
amount of packets in queue to be sent
or a <strong>boolean()</strong> indicating whether
there are packets in queue to be sent.
</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
It is of vital importance that this operation
does not block the caller for a long time.
This since it is called from the connection
supervisor.
</p></div> <p>Used when connection is up.</p> </dd><dt><a name="hs_data_request_type"></a><strong>request_type</strong></dt><dd> <p>
The request <strong>Type</strong> as passed to
<a href="#setup">setup</a>.
This is only mandatory when the connection has
been initiated by this node. That is, the connection
is set up via <strong>setup/5</strong>.
</p> </dd><dt><a name="hs_data_mf_setopts"></a><strong>mf_setopts</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrl, Opts) -&gt; ok | {error, Error}</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier
of the distribution controller and <strong>Opts</strong>
is a list of options to set on the connection.
</p> <p>This function is optional. Used when connection is up.</p> </dd><dt><a name="hs_data_mf_getopts"></a><strong>mf_getopts</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrl, Opts) -&gt; {ok, OptionValues} | {error, Error}</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier
of the distribution controller and <strong>Opts</strong>
is a list of options to read for the connection.
</p> <p>This function is optional. Used when connection is up.</p> </dd><dt><a name="hs_data_f_handshake_complete"></a><strong>f_handshake_complete</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr, Node, DHandle) -&gt; void()</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier
of the distribution controller, <strong>Node</strong> is
the node name of the node connected at the other
end, and <strong>DHandle</strong> is a distribution handle
needed by a distribution controller process when
calling the following BIFs:
</p> <ul><li><p><a href="../erts/erlang#dist_ctrl_get_data/1">erts/erlang#dist_ctrl_get_data/1</a></p></li><li><p><a href="../erts/erlang#dist_ctrl_get_data_notification/1">erts/erlang#dist_ctrl_get_data_notification/1</a></p></li><li><p><a href="../erts/erlang#dist_ctrl_input_handler/2">erts/erlang#dist_ctrl_input_handler/2</a></p></li><li><p><a href="../erts/erlang#dist_ctrl_put_data/2">erts/erlang#dist_ctrl_put_data/2</a></p></li></ul> <p>
This function is called when the handshake has
completed and the distribution channel is up.
The distribution controller can begin dispatching
traffic over the channel. This function is optional.
</p> <p>Only used during handshake phase.</p> </dd><dt><a name="hs_data_add_flags"></a><strong>add_flags</strong></dt><dd> <p>
<a href="./erl_dist_protocol#dflags">Distribution flags</a>
to add to the connection. Currently all (non obsolete) flags will
automatically be enabled.
</p> <p>
This flag field is optional.
</p> </dd><dt><a name="hs_data_reject_flags"></a><strong>reject_flags</strong></dt><dd> <p>
<a href="./erl_dist_protocol#dflags">Distribution flags</a>
to reject. Currently the following distribution flags can be rejected:
</p> <dl><dt><strong>DFLAG_DIST_HDR_ATOM_CACHE</strong></dt><dd>Do not use atom cache over this connection.</dd></dl> <p>Use function <strong>dist_util:strict_order_flags/0</strong> to get all flags
for features that require strict order delivery.</p> <p>
This flag field is optional.
</p> </dd><dt><a name="hs_data_require_flags"></a><strong>require_flags</strong></dt><dd> <p>
Require these <a href="./erl_dist_protocol#dflags">distribution flags</a> to be used. The connection will be aborted during the
handshake if the other end does not use them.
</p> <p>
This flag field is optional.
</p> </dd></dl><a name="distribution_data_delivery"></a><h3>Distribution Data Delivery</h3><p>
When using the default configuration, the data to pass
over a connection needs to be delivered as is
to the node on the receiving end in the <em>exact same order</em>, with no loss of data what so ever, as sent
from the sending node.
</p><p>
The data delivery order can be relaxed by disabling
features that require strict ordering. This is done by
passing the
<a href="./erl_dist_protocol#dflags">distribution	flags</a>
returned by <strong>dist_util:strict_order_flags/0</strong> in the
<a href="./alt_dist#hs_data_reject_flags">alt_dist#hs_data_reject_flags</a>
field of the <a href="#hs_data_record">hs_data_record</a>
record used when setting up the connection. When relaxed
ordering is used, only the order of signals with the same
sender/receiver pair has to be preserved.
However, note that disabling the features that require
strict ordering may have a negative impact on performance,
throughput, and/or latency. 
</p><a name="enable_your_distribution_module"></a><h3>Enable Your Distribution Module</h3><p>For <strong>net_kernel</strong> to find out which distribution module to use,
the <strong>erl</strong> command-line argument <strong>-proto_dist</strong> is used. It
is followed by one or more distribution module names, with suffix
"_dist" removed. That is, <strong>gen_tcp_dist</strong> as a distribution module
is specified as <strong>-proto_dist gen_tcp</strong>.</p><p>If no <strong>epmd</strong> (TCP port mapper daemon) is used, also command-line
option <strong>-no_epmd</strong> is to be specified, which makes
Erlang skip the <strong>epmd</strong> startup, both as an OS process and as an
Erlang ditto.</p><h3>The Driver</h3><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This section was written a long time ago. Most of it is still
valid, but some things have changed since then. Some updates have
been made to the documentation of the driver presented here,
but more can be done and is planned for the future.
The reader is encouraged to read the
<a href="erl_driver">erl_driver</a> and
<a href="driver_entry">driver_entry</a>
documentation also.</p></div><p>Although Erlang drivers in general can be beyond the scope of this
section, a brief introduction seems to be in place.</p><h3>Drivers in General</h3><p>An Erlang driver is a native code module written in C (or
assembler), which serves as an interface for some special operating
system service. This is a general mechanism that is used
throughout the Erlang emulator for all kinds of I/O. An Erlang
driver can be dynamically linked (or loaded) to the Erlang
emulator at runtime by using the <strong>erl_ddll</strong> Erlang
module. Some of the drivers in OTP are however statically linked
to the runtime system, but that is more an optimization than a
necessity.</p><p>The driver data types and the functions available to the driver
writer are defined in header file <strong>erl_driver.h</strong>
seated in Erlang's include directory. See the
<a href="./erl_driver">erl_driver</a> documentation
for details of which functions are available.</p><p>When writing a driver to make a communications protocol available
to Erlang, one should know just about everything worth knowing
about that particular protocol. All operation must be
non-blocking and all possible situations are to be accounted for in
the driver. A non-stable driver will affect and/or crash the
whole Erlang runtime system.</p><p>The emulator calls the driver in the following situations:</p><ul><li> <p>When the driver is loaded. This callback must have a special
name and inform the emulator of what callbacks are to be used 
by returning a pointer to a <strong>ErlDrvEntry</strong> struct,
which is to be properly filled in (see below).</p> </li><li> <p>When a port to the driver is opened (by a
<strong>open_port</strong> call from Erlang). This routine is to
set up internal data structures and return an opaque data entity of
the type <strong>ErlDrvData</strong>, which is a data type large
enough to hold a pointer.
The pointer returned by this function is the first
argument to all other callbacks concerning this particular
port. It is usually called the port handle. The emulator only
stores the handle and does never try to interpret it, why it can
be virtually anything (anything not larger than a pointer
that is) and can point to anything if it is a pointer. Usually
this pointer refers to a structure holding information about
the particular port, as it does in the example.</p> </li><li> <p>When an Erlang process sends data to the port. The data
arrives as a buffer of bytes, the interpretation is not defined,
but is up to the implementor. This callback returns nothing to the
caller, answers are sent to the caller as messages (using a
routine called <strong>driver_output</strong> available to all
drivers). There is also a way to talk in a synchronous way to
drivers, described below. There can be an additional callback
function for handling data that is fragmented (sent in a deep
io-list). That interface gets the data in a form suitable for
Unix <strong>writev</strong> rather than in a single buffer.
There is no need for a distribution driver to implement such a
callback, so we will not.</p> </li><li> <p>When a file descriptor is signaled for input. This callback
is called when the emulator detects input on a file descriptor
that the driver has marked for monitoring by using the interface
<strong>driver_select</strong>. The mechanism of driver select
makes it possible to read non-blocking from file descriptors by
calling <strong>driver_select</strong> when reading is needed, and
then do the reading in this callback (when reading is possible).
The typical scenario is that <strong>driver_select</strong> is
called when an Erlang process orders a read operation, and that
this routine sends the answer when data is available on the file
descriptor.</p> </li><li> <p>When a file descriptor is signaled for output. This callback
is called in a similar way as the previous, but when writing to a
file descriptor is possible. The usual scenario is that Erlang
orders writing on a file descriptor and that the driver calls
<strong>driver_select</strong>. When the descriptor is ready for
output, this callback is called and the driver can try to send the
output. Queuing can be involved in such operations, and there are
convenient queue routines available to the driver writer to use.</p> </li><li> <p>When a port is closed, either by an Erlang process or by the
driver calling one of the <strong>driver_failure_XXX</strong>
routines. This routine is to clean up everything connected to one
particular port. When other callbacks call a
<strong>driver_failure_XXX</strong> routine, this routine is
immediately called. The callback routine issuing the error can
make no more use of the data structures for the port, as this
routine surely has freed all associated data and closed all file
descriptors. If the queue utility available to driver writer is
used, this routine is however <em>not</em> called until the
queue is empty.</p> </li><li> <p>When an Erlang process calls
<a href="./erlang#port_control/3">erlang#port_control/3</a>,
which is a synchronous interface to drivers. The control interface
is used to set driver options, change states of ports, and so on.
This interface is used a lot in the example.</p> </li><li> <p>When a timer expires. The driver can set timers with the function
<strong>driver_set_timer</strong>. When such timers expire, a
specific callback function is called. No timers are used in
the example.</p> </li><li> <p>When the whole driver is unloaded. Every resource allocated
by the driver is to be freed.</p> </li></ul><h3>The Data Structures of the Distribution Driver</h3><p>The driver used for Erlang distribution is to implement a
reliable, order maintaining, variable length packet-oriented
protocol. All error correction, resending and such need to be
implemented in the driver or by the underlying communications
protocol. If the protocol is stream-oriented (as is the case with
both TCP/IP and our streamed Unix domain sockets), some mechanism
for packaging is needed. We will use the simple method of having a
header of four bytes containing the length of the package in a
big-endian 32-bit integer. As Unix domain sockets only can be used
between processes on the same machine, we do not need to
code the integer in some special endianess, but we will do it anyway
because in most situation you need to do it. Unix domain
sockets are reliable and order maintaining, so we do not need to
implement resends and such in the driver.</p><p>We start writing the example Unix domain sockets driver by
declaring prototypes and filling in a static <strong>ErlDrvEntry</strong>
structure:</p><pre><code class="">
( 1) #include &lt;stdio.h&gt;
( 2) #include &lt;stdlib.h&gt;
( 3) #include &lt;string.h&gt;
( 4) #include &lt;unistd.h&gt;
( 5) #include &lt;errno.h&gt;
( 6) #include &lt;sys/types.h&gt;
( 7) #include &lt;sys/stat.h&gt;
( 8) #include &lt;sys/socket.h&gt;
( 9) #include &lt;sys/un.h&gt;
(10) #include &lt;fcntl.h&gt;

(11) #define HAVE_UIO_H
(12) #include "erl_driver.h"

(13) /*
(14) ** Interface routines
(15) */
(16) static ErlDrvData uds_start(ErlDrvPort port, char *buff);
(17) static void uds_stop(ErlDrvData handle);
(18) static void uds_command(ErlDrvData handle, char *buff, int bufflen);
(19) static void uds_input(ErlDrvData handle, ErlDrvEvent event);
(20) static void uds_output(ErlDrvData handle, ErlDrvEvent event);
(21) static void uds_finish(void);
(22) static int uds_control(ErlDrvData handle, unsigned int command, 
(23)                        char* buf, int count, char** res, int res_size);

(24) /* The driver entry */
(25) static ErlDrvEntry uds_driver_entry = {
(26)     NULL,                            /* init, N/A */
(27)     uds_start,                       /* start, called when port is opened */
(28)     uds_stop,                        /* stop, called when port is closed */
(29)     uds_command,                     /* output, called when erlang has sent */
(30)     uds_input,                       /* ready_input, called when input
(31)                                         descriptor ready */
(32)     uds_output,                      /* ready_output, called when output 
(33)                                         descriptor ready */
(34)     "uds_drv",                       /* char *driver_name, the argument 
(35)                                         to open_port */
(36)     uds_finish,                      /* finish, called when unloaded */
(37)     NULL,                            /* void * that is not used (BC) */
(38)     uds_control,                     /* control, port_control callback */
(39)     NULL,                            /* timeout, called on timeouts */
(40)     NULL,                            /* outputv, vector output interface */
(41)     NULL,                            /* ready_async callback */
(42)     NULL,                            /* flush callback */
(43)     NULL,                            /* call callback */
(44)     NULL,                            /* event callback */
(45)     ERL_DRV_EXTENDED_MARKER,         /* Extended driver interface marker */
(46)     ERL_DRV_EXTENDED_MAJOR_VERSION,  /* Major version number */
(47)     ERL_DRV_EXTENDED_MINOR_VERSION,  /* Minor version number */
(48)     ERL_DRV_FLAG_SOFT_BUSY,          /* Driver flags. Soft busy flag is
(49)                                         required for distribution drivers */
(50)     NULL,                            /* Reserved for internal use */
(51)     NULL,                            /* process_exit callback */
(52)     NULL                             /* stop_select callback */
(53) };</code></pre><p>On line 1-10 the OS headers needed for the driver are included.
As this driver is written for Solaris, we know that the
header <strong>uio.h</strong> exists. So the preprocessor variable
<strong>HAVE_UIO_H</strong> can be defined before
<strong>erl_driver.h</strong> is included on line 12.
The definition of <strong>HAVE_UIO_H</strong> will make the
I/O vectors used in Erlang's driver queues to correspond to the
operating systems ditto, which is very convenient.</p><p>On line 16-23 the different callback functions are declared ("forward
declarations").</p><p>The driver structure is similar for statically linked-in
drivers and dynamically loaded. However, some of the fields
are to be left empty (that is, initialized to NULL) in the
different types of drivers. The first field (the <strong>init</strong>
function pointer) is always left blank in a dynamically loaded
driver, see line 26. <strong>NULL</strong> on line 37
is always to be there, the field is no longer used and is
retained for backward compatibility. No timers are used in this
driver, why no callback for timers is needed. The <strong>outputv</strong> field
(line 40) can be used to implement an interface similar to
Unix <strong>writev</strong> for output. The Erlang runtime
system could previously not use <strong>outputv</strong> for the
distribution, but it can as from ERTS 5.7.2.
As this driver was written before ERTS 5.7.2 it does
not use the <strong>outputv</strong> callback. Using the <strong>outputv</strong>
callback is preferred, as it reduces copying of data. (We
will however use scatter/gather I/O internally in the driver.)</p><p>As from ERTS 5.5.3 the driver interface was extended with
version control and the possibility to pass capability information.
Capability flags are present on line 48. As from ERTS 5.7.4 flag
<a href="./driver_entry#driver_flags">driver_entry#driver_flags</a> is required for drivers that
are to be used by the distribution. The soft busy flag implies that the
driver can handle calls to the <strong>output</strong> and <strong>outputv</strong>
callbacks although it has marked itself as busy. This has always been a
requirement on drivers used by the distribution, but no capability
information has been available about this previously. For more
information. see <a href="./erl_driver#set_busy_port">erl_driver#set_busy_port</a>).</p><p>This driver was written before the runtime system had SMP support.
The driver will still function in the runtime system with SMP support,
but performance will suffer from lock contention on the driver lock
used for the driver. This can be alleviated by reviewing and perhaps
rewriting the code so that each instance of the driver safely can
execute in parallel. When instances safely can execute in parallel, it
is safe to enable instance-specific locking on the driver. This is done
by passing <a href="./driver_entry#driver_flags">driver_entry#driver_flags</a> as a driver flag. This
is left as an exercise for the reader.</p><p>Thus, the defined callbacks are as follows:</p><dl><dt><strong>uds_start</strong></dt><dd> <p>Must initiate data for a port. We do not create any sockets
here, only initialize data structures.</p> </dd><dt><strong>uds_stop</strong></dt><dd> <p>Called when a port is closed.</p> </dd><dt><strong>uds_command</strong></dt><dd> <p>Handles messages from Erlang. The
messages can either be plain data to be sent or more subtle
instructions to the driver. This function is here mostly for
data pumping.</p> </dd><dt><strong>uds_input</strong></dt><dd> <p>Called when there is something to read from a socket.</p> </dd><dt><strong>uds_output</strong></dt><dd> <p>Called when it is possible to write to a socket.</p> </dd><dt><strong>uds_finish</strong></dt><dd> <p>Called when the driver is unloaded. A distribution driver will
never be unloaded, but we include this for completeness. To be
able to clean up after oneself is always a good thing.</p> </dd><dt><strong>uds_control</strong></dt><dd> <p>The <a href="./erlang#port_control/3">erlang#port_control/3</a> callback, which is
used a lot in this implementation.</p> </dd></dl><p>The ports implemented by this driver operate in two major modes,
named <strong>command</strong> and <strong>data</strong>. In <strong>command</strong> mode,
only passive reading and writing (like
<strong>gen_tcp:recv</strong>/<strong>gen_tcp:send</strong>) can be done. The port is in
this mode during the distribution handshake. When the connection is up,
the port is switched to <strong>data</strong> mode and all data is immediately
read and passed further to the Erlang emulator. In <strong>data</strong>
mode, no data arriving to <strong>uds_command</strong> is interpreted, only
packaged and sent out on the socket. The <strong>uds_control</strong> callback
does the switching between those two modes.</p><p>While <strong>net_kernel</strong> informs different subsystems
that the connection is coming up, the port is to accept data to send.
However, the port should not receive any data, to avoid that data
arrives from another node before every kernel subsystem is prepared
to handle it. A third mode, named <strong>intermediate</strong>, is used for this
intermediate stage.</p><p>An enum is defined for the different types of ports:</p><pre><code class="">
( 1) typedef enum { 
( 2)     portTypeUnknown,      /* An uninitialized port */
( 3)     portTypeListener,     /* A listening port/socket */
( 4)     portTypeAcceptor,     /* An intermediate stage when accepting
( 5)                              on a listen port */
( 6)     portTypeConnector,    /* An intermediate stage when connecting */
( 7)     portTypeCommand,      /* A connected open port in command mode */
( 8)     portTypeIntermediate, /* A connected open port in special
( 9)                              half active mode */
(10)     portTypeData          /* A connected open port in data mode */ 
(11) } PortType;      </code></pre><p>The different types are as follows:</p><dl><dt><strong>portTypeUnknown</strong></dt><dd> <p>The type a port has when it is opened, but
not bound to any file descriptor.</p> </dd><dt><strong>portTypeListener</strong></dt><dd> <p>A port that is connected to a listen socket. This port does not
do much, no data pumping is done on this socket, but read data is
available when one is trying to do an accept on the port.</p> </dd><dt><strong>portTypeAcceptor</strong></dt><dd> <p>This port is to represent the result of an accept operation. It is
created when one wants to accept from a listen socket, and it is
converted to a <strong>portTypeCommand</strong> when the accept succeeds.</p> </dd><dt><strong>portTypeConnector</strong></dt><dd> <p>Very similar to <strong>portTypeAcceptor</strong>, an
intermediate stage between the request for a connect operation and
that the socket is connected to an accepting ditto in the
other end. When the sockets are connected, the port
switches type to <strong>portTypeCommand</strong>.</p> </dd><dt><strong>portTypeCommand</strong></dt><dd> <p>A connected socket (or accepted socket) in <strong>command</strong> mode
mentioned earlier.</p> </dd><dt><strong>portTypeIntermediate</strong></dt><dd> <p>The intermediate stage for a connected socket.
There is to be no processing of input for this socket.</p> </dd><dt><strong>portTypeData</strong></dt><dd> <p>The mode where data is pumped through the port and the
<strong>uds_command</strong> routine regards every call as a call where
sending is wanted. In this mode, all input available is read and
sent to Erlang when it arrives on the socket, much like in the
active mode of a <strong>gen_tcp</strong> socket.</p> </dd></dl><p>We study the state that is needed for the ports. Notice
that not all fields are used for all types of ports. Some space
could be saved by using unions, but that would clutter the
code with multiple indirections, so here is used one struct for
all types of ports, for readability:</p><pre><code class="">
( 1) typedef unsigned char Byte;
( 2) typedef unsigned int Word;

( 3) typedef struct uds_data {
( 4)     int fd;                   /* File descriptor */
( 5)     ErlDrvPort port;          /* The port identifier */
( 6)     int lockfd;               /* The file descriptor for a lock file in 
( 7)                                  case of listen sockets */
( 8)     Byte creation;            /* The creation serial derived from the 
( 9)                                  lock file */
(10)     PortType type;            /* Type of port */
(11)     char *name;               /* Short name of socket for unlink */
(12)     Word sent;                /* Bytes sent */
(13)     Word received;            /* Bytes received */
(14)     struct uds_data *partner; /* The partner in an accept/listen pair */
(15)     struct uds_data *next;    /* Next structure in list */
(16)     /* The input buffer and its data */
(17)     int buffer_size;          /* The allocated size of the input buffer */
(18)     int buffer_pos;           /* Current position in input buffer */
(19)     int header_pos;           /* Where the current header is in the 
(20)                                  input buffer */
(21)     Byte *buffer;             /* The actual input buffer */
(22) } UdsData;      </code></pre><p>This structure is used for all types of ports although some
fields are useless for some types. The least memory consuming
solution would be to arrange this structure as a union of
structures. However, the multiple indirections in the code to
access a field in such a structure would clutter the code too
much for an example.</p><p>The fields in the structure are as follows:</p><dl><dt><strong>fd</strong></dt><dd> <p>The file descriptor of the socket associated with the port.</p> </dd><dt><strong>port</strong></dt><dd> <p>The port identifier for the port that this structure
corresponds to. It is needed for most <strong>driver_XXX</strong>
calls from the driver back to the emulator.</p> </dd><dt><strong>lockfd</strong></dt><dd> <p>If the socket is a listen socket, we use a separate
(regular) file for two purposes:</p> <ul><li> <p>We want a locking mechanism that gives no race
conditions, to be sure if another Erlang
node uses the listen socket name we require or if the
file is only left there from a previous (crashed) session.</p> </li><li> <p>We store the <strong>creation</strong> serial number in the
file. The <strong>creation</strong> is a number that is to
change between different instances of different Erlang
emulators with the same name, so that process
identifiers from one emulator do not become valid when sent
to a new emulator with the same distribution name. The
creation can be from 0 through 3 (two bits) and is stored
in every process identifier sent to another node.</p> <p>In a system with TCP-based distribution, this data is
kept in the <em>Erlang port mapper daemon</em>
(<strong>epmd</strong>), which is contacted when a distributed
node starts. The lock file and a convention for the UDS
listen socket's name remove the need for
<strong>epmd</strong> when using this distribution module. UDS
is always restricted to one host, why avoiding a port
mapper is easy.</p> </li></ul> </dd><dt><strong>creation</strong></dt><dd> <p>The creation number for a listen socket, which is
calculated as (the value found in the lock-file + 1) rem 4.
This creation value is also written back into the
lock file, so that the next invocation of the emulator
finds our value in the file.</p> </dd><dt><strong>type</strong></dt><dd> <p>The current type/state of the port, which can be one
of the values declared above.</p> </dd><dt><strong>name</strong></dt><dd> <p>The name of the socket file (the path prefix removed),
which allows for deletion (<strong>unlink</strong>) when the
socket is closed.</p> </dd><dt><strong>sent</strong></dt><dd> <p>How many bytes that have been sent over the
socket. This can wrap, but that is no problem for the
distribution, as the Erlang distribution is only interested in
if this value has changed. (The Erlang
<strong>net_kernel</strong> <strong>ticker</strong> uses this value by calling the
driver to fetch it, which is done through the
<a href="./erlang#port_control/3">erlang#port_control/3</a> routine.)</p> </dd><dt><strong>received</strong></dt><dd> <p>How many bytes that are read (received) from the
socket, used in similar ways as <strong>sent</strong>.</p> </dd><dt><strong>partner</strong></dt><dd> <p>A pointer to another port structure, which is
either the listen port from which this port is accepting a
connection or conversely. The "partner relation"
is always bidirectional.</p> </dd><dt><strong>next</strong></dt><dd> <p>Pointer to next structure in a linked list of all
port structures. This list is used when accepting
connections and when the driver is unloaded.</p> </dd><dt><strong>buffer_size</strong>, <strong>buffer_pos</strong>, <strong>header_pos</strong>, <strong>buffer</strong></dt><dd> <p>Data for input buffering. For details about the input buffering,
see the source code in directory <strong>kernel/examples</strong>. That
certainly goes beyond the scope of this section.</p> </dd></dl><h3>Selected Parts of the Distribution Driver Implementation</h3><p>The implemenation of the distribution driver is not completely
covered here, details about buffering and other things
unrelated to driver writing are not explained. Likewise are
some peculiarities of the UDS protocol not explained in
detail. The chosen protocol is not important.</p><p>Prototypes for the driver callback routines can be found in
the <strong>erl_driver.h</strong> header file.</p><p>The driver initialization routine is (usually) declared with a
macro to make the driver easier to port between different
operating systems (and flavors of systems). This is the only
routine that must have a well-defined name. All other
callbacks are reached through the driver structure. The macro
to use is named <strong>DRIVER_INIT</strong> and takes the driver name
as parameter:</p><pre><code class="">
(1) /* Beginning of linked list of ports */
(2) static UdsData *first_data;

(3) DRIVER_INIT(uds_drv)
(4) {
(5)     first_data = NULL;
(6)     return &amp;uds_driver_entry;
(7) }      </code></pre><p>The routine initializes the single global data structure and
returns a pointer to the driver entry. The routine is called
when <strong>erl_ddll:load_driver</strong> is called from Erlang.</p><p>The <strong>uds_start</strong> routine is called when a port is
opened from Erlang. In this case, we only allocate a structure and
initialize it. Creating the actual socket is left to the
<strong>uds_command</strong> routine.</p><pre><code class="">
( 1) static ErlDrvData uds_start(ErlDrvPort port, char *buff)
( 2) {
( 3)     UdsData *ud;
( 4)     
( 5)     ud = ALLOC(sizeof(UdsData));
( 6)     ud-&gt;fd = -1;
( 7)     ud-&gt;lockfd = -1;
( 8)     ud-&gt;creation = 0;
( 9)     ud-&gt;port = port;
(10)     ud-&gt;type = portTypeUnknown;
(11)     ud-&gt;name = NULL;
(12)     ud-&gt;buffer_size = 0;
(13)     ud-&gt;buffer_pos = 0;
(14)     ud-&gt;header_pos = 0;
(15)     ud-&gt;buffer = NULL;
(16)     ud-&gt;sent = 0;
(17)     ud-&gt;received = 0;
(18)     ud-&gt;partner = NULL;
(19)     ud-&gt;next = first_data;
(20)     first_data = ud;
(21)     
(22)     return((ErlDrvData) ud);
(23) }      </code></pre><p>Every data item is initialized, so that no problems arise
when a newly created port is closed (without there being any
corresponding socket). This routine is called when
<strong>open_port({spawn, "uds_drv"},[])</strong> is called from
Erlang.</p><p>The <strong>uds_command</strong> routine is the routine called when
an Erlang process sends data to the port. This routine handles all
asynchronous commands when the port is in <strong>command</strong> mode and
the sending of all data when the port is in <strong>data</strong> mode:</p><pre><code class="">
( 1) static void uds_command(ErlDrvData handle, char *buff, int bufflen)
( 2) {
( 3)     UdsData *ud = (UdsData *) handle;

( 4)     if (ud-&gt;type == portTypeData || ud-&gt;type == portTypeIntermediate) {
( 5)         DEBUGF(("Passive do_send %d",bufflen));
( 6)         do_send(ud, buff + 1, bufflen - 1); /* XXX */
( 7)         return;
( 8)     } 
( 9)     if (bufflen == 0) {
(10)         return;
(11)     }
(12)     switch (*buff) {
(13)     case 'L':
(14)         if (ud-&gt;type != portTypeUnknown) {
(15)             driver_failure_posix(ud-&gt;port, ENOTSUP);
(16)             return;
(17)         }
(18)         uds_command_listen(ud,buff,bufflen);
(19)         return;
(20)     case 'A':
(21)         if (ud-&gt;type != portTypeUnknown) {
(22)             driver_failure_posix(ud-&gt;port, ENOTSUP);
(23)             return;
(24)         }
(25)         uds_command_accept(ud,buff,bufflen);
(26)         return;
(27)     case 'C':
(28)         if (ud-&gt;type != portTypeUnknown) {
(29)             driver_failure_posix(ud-&gt;port, ENOTSUP);
(30)             return;
(31)         }
(32)         uds_command_connect(ud,buff,bufflen);
(33)         return;
(34)     case 'S':
(35)         if (ud-&gt;type != portTypeCommand) {
(36)             driver_failure_posix(ud-&gt;port, ENOTSUP);
(37)             return;
(38)         }
(39)         do_send(ud, buff + 1, bufflen - 1);
(40)         return;
(41)     case 'R':
(42)         if (ud-&gt;type != portTypeCommand) {
(43)             driver_failure_posix(ud-&gt;port, ENOTSUP);
(44)             return;
(45)         }
(46)         do_recv(ud);
(47)         return;
(48)     default:
(49)         return;
(50)     }
(51) }      </code></pre><p>The command routine takes three parameters; the handle returned for
the port by <strong>uds_start</strong>, which is a pointer
to the internal port structure, the data buffer, and the length
of the data buffer. The buffer is the data sent from Erlang
(a list of bytes) converted to an C array (of bytes).</p><p>If Erlang sends, for example, the list <strong>[$a,$b,$c]</strong>
to the port, the <strong>bufflen</strong> variable is
<strong>3</strong> and the <strong>buff</strong> variable contains
<strong>{'a','b','c'}</strong> (no
<strong>NULL</strong> termination). Usually the first byte is used as an
opcode, which is the case in this driver too (at least when the
port is in <strong>command</strong> mode). The opcodes are defined as follows:</p><dl><dt><strong>'L'&lt;socket name&gt;</strong></dt><dd> <p>Creates and listens on socket with the specified name.</p> </dd><dt><strong>'A'&lt;listen number as 32-bit big-endian&gt;</strong></dt><dd> <p>Accepts from the listen socket identified by the specified
identification number. The identification number is retrieved with
the <strong>uds_control</strong> routine.</p> </dd><dt><strong>'C'&lt;socket name&gt;</strong></dt><dd> <p>Connects to the socket named &lt;socket name&gt;.</p> </dd><dt><strong>'S'&lt;data&gt;</strong></dt><dd> <p>Sends the data &lt;data&gt; on the
connected/accepted socket (in <strong>command</strong> mode). The sending is
acknowledged when the data has left this process.</p> </dd><dt><strong>'R'</strong></dt><dd> <p>Receives one packet of data.</p> </dd></dl><p>"One packet of data" in command <strong>'R'</strong> can be explained
as follows. This driver always sends data packaged with a 4
byte header containing a big-endian 32-bit integer that
represents the length of the data in the packet. There is no
need for different packet sizes or some kind of streamed
mode, as this driver is for the distribution only.
Why is the header word coded explicitly in big-endian when a UDS
socket is local to the host? It is good practice when writing a
distribution driver, as distribution in practice usually crosses
the host boundaries.</p><p>On line 4-8 is handled the case where the port is in <strong>data</strong> mode
or <strong>intermediate</strong> mode and the remaining routine handles the
different commands. The routine uses the
<strong>driver_failure_posix()</strong> routine to report errors
(see, for example, line 15). Notice that the failure routines make
a call to the <strong>uds_stop</strong> routine, which will
remove the internal port data. The handle (and the casted handle
<strong>ud</strong>) is therefore <em>invalid pointers</em> after a
<strong>driver_failure</strong> call and we should <em>return immediately</em>. The runtime system will send exit signals to all
linked processes.</p><p>The <strong>uds_input</strong> routine is called when data is available on a
file descriptor previously passed to the
<strong>driver_select</strong> routine. This occurs typically when
a read command is issued and no data is available. The
<strong>do_recv</strong> routine is as follows:</p><pre><code class="">
( 1) static void do_recv(UdsData *ud)
( 2) {
( 3)     int res;
( 4)     char *ibuf;
( 5)     for(;;) {
( 6)         if ((res = buffered_read_package(ud,&amp;ibuf)) &lt; 0) {
( 7)             if (res == NORMAL_READ_FAILURE) {
( 8)                 driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ, 1);
( 9)             } else {
(10)                 driver_failure_eof(ud-&gt;port);
(11)             }
(12)             return;
(13)         }
(14)         /* Got a package */
(15)         if (ud-&gt;type == portTypeCommand) {
(16)             ibuf[-1] = 'R'; /* There is always room for a single byte 
(17)                                opcode before the actual buffer 
(18)                                (where the packet header was) */
(19)             driver_output(ud-&gt;port,ibuf - 1, res + 1);
(20)             driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ,0);
(21)             return;
(22)         } else {
(23)             ibuf[-1] = DIST_MAGIC_RECV_TAG; /* XXX */
(24)             driver_output(ud-&gt;port,ibuf - 1, res + 1);
(25)             driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ,1);
(26)         }
(27)     }
(28) }      </code></pre><p>The routine tries to read data until a packet is read or the
<strong>buffered_read_package</strong> routine returns a
<strong>NORMAL_READ_FAILURE</strong> (an internally defined constant
for the module, which means that the read operation resulted in an
<strong>EWOULDBLOCK</strong>). If the port is in <strong>command</strong> mode,
the reading stops when one package is read. If the port is in
<strong>data</strong> mode, the reading continues until the socket buffer is empty
(read failure). If no more data can be read and more is wanted (which
is always the case when the socket is in <strong>data</strong> mode),
<strong>driver_select</strong> is called to make the <strong>uds_input</strong>
callback be called when more data is available for reading.</p><p>When the port is in <strong>data</strong> mode, all data is sent to Erlang in a
format that suits the distribution. In fact, the raw data will
never reach any Erlang process, but will be
translated/interpreted by the emulator itself and then
delivered in the correct format to the correct processes. In
the current emulator version, received data is to be tagged
with a single byte of 100. That is what the macro
<strong>DIST_MAGIC_RECV_TAG</strong> is defined to. The tagging of
data in the distribution can be changed in the future.</p><p>The <strong>uds_input</strong> routine handles other input events
(like non-blocking <strong>accept</strong>), but most importantly
handle
data arriving at the socket by calling <strong>do_recv</strong>:</p><pre><code class="">
( 1) static void uds_input(ErlDrvData handle, ErlDrvEvent event)
( 2) {
( 3)     UdsData *ud = (UdsData *) handle;

( 4)     if (ud-&gt;type == portTypeListener) {
( 5)         UdsData *ad = ud-&gt;partner;
( 6)         struct sockaddr_un peer;
( 7)         int pl = sizeof(struct sockaddr_un);
( 8)         int fd;

( 9)         if ((fd = accept(ud-&gt;fd, (struct sockaddr *) &amp;peer, &amp;pl)) &lt; 0) {
(10)             if (errno != EWOULDBLOCK) {
(11)                 driver_failure_posix(ud-&gt;port, errno);
(12)                 return;
(13)             }
(14)             return;
(15)         }
(16)         SET_NONBLOCKING(fd);
(17)         ad-&gt;fd = fd;
(18)         ad-&gt;partner = NULL;
(19)         ad-&gt;type = portTypeCommand;
(20)         ud-&gt;partner = NULL;
(21)         driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ, 0);
(22)         driver_output(ad-&gt;port, "Aok",3);
(23)         return;
(24)     }
(25)     do_recv(ud);
(26) }      </code></pre><p>The important line is the last line in the function: the
<strong>do_read</strong> routine is called to handle new input.
The remaining function handles input on a listen socket, which means
that it is to be possible to do an accept on the
socket, which is also recognized as a read event.</p><p>The output mechanisms are similar to the input.
The <strong>do_send</strong> routine is as follows:</p><pre><code class="">
( 1) static void do_send(UdsData *ud, char *buff, int bufflen) 
( 2) {
( 3)     char header[4];
( 4)     int written;
( 5)     SysIOVec iov[2];
( 6)     ErlIOVec eio;
( 7)     ErlDrvBinary *binv[] = {NULL,NULL};

( 8)     put_packet_length(header, bufflen);
( 9)     iov[0].iov_base = (char *) header;
(10)     iov[0].iov_len = 4;
(11)     iov[1].iov_base = buff;
(12)     iov[1].iov_len = bufflen;
(13)     eio.iov = iov;
(14)     eio.binv = binv;
(15)     eio.vsize = 2;
(16)     eio.size = bufflen + 4;
(17)     written = 0;
(18)     if (driver_sizeq(ud-&gt;port) == 0) {
(19)         if ((written = writev(ud-&gt;fd, iov, 2)) == eio.size) {
(20)             ud-&gt;sent += written;
(21)             if (ud-&gt;type == portTypeCommand) {
(22)                 driver_output(ud-&gt;port, "Sok", 3);
(23)             }
(24)             return;
(25)         } else if (written &lt; 0) {
(26)             if (errno != EWOULDBLOCK) {
(27)                 driver_failure_eof(ud-&gt;port);
(28)                 return;
(29)             } else {
(30)                 written = 0;
(31)             }
(32)         } else {
(33)             ud-&gt;sent += written;
(34)         }
(35)         /* Enqueue remaining */
(36)     }
(37)     driver_enqv(ud-&gt;port, &amp;eio, written);
(38)     send_out_queue(ud);
(39) }      </code></pre><p>This driver uses the <strong>writev</strong> system call to send data
onto the socket. A combination of <strong>writev</strong> and the driver output
queues is very convenient. An <strong>ErlIOVec</strong> structure
contains a <strong>SysIOVec</strong> (which is equivalent to the
<strong>struct iovec</strong> structure defined in
<strong>uio.h</strong>. The
<strong>ErlIOVec</strong> also contains an array of <strong>ErlDrvBinary</strong>
pointers, of the same length as the number of buffers in the
I/O vector itself. One can use this to allocate the binaries
for the queue "manually" in the driver, but here
the binary array is filled with <strong>NULL</strong> values (line 7).
The runtime system then allocates its own buffers when
<strong>driver_enqv</strong> is called (line 37).</p><p>The routine builds an I/O vector containing the header bytes
and the buffer (the opcode has been removed and the buffer
length decreased by the output routine). If the queue is
empty, we write the data directly to the socket (or at
least try to). If any data is left, it is stored in the queue
and then we try to send the queue (line 38). An acknowledgement
is sent when the message is delivered completely (line 22). The
<strong>send_out_queue</strong> sends acknowledgements if the sending
is completed there. If the port is in <strong>command</strong> mode, the Erlang
code serializes the send operations so that only one packet
can be waiting for delivery at a time. Therefore the acknowledgement
can be sent whenever the queue is empty.</p><p>The <strong>send_out_queue</strong> routine is as follows:</p><pre><code class="">
( 1) static int send_out_queue(UdsData *ud)
( 2) {
( 3)     for(;;) {
( 4)         int vlen;
( 5)         SysIOVec *tmp = driver_peekq(ud-&gt;port, &amp;vlen);
( 6)         int wrote;
( 7)         if (tmp == NULL) {
( 8)             driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_WRITE, 0);
( 9)             if (ud-&gt;type == portTypeCommand) {
(10)                 driver_output(ud-&gt;port, "Sok", 3);
(11)             }
(12)             return 0;
(13)         }
(14)         if (vlen &gt; IO_VECTOR_MAX) {
(15)             vlen = IO_VECTOR_MAX;
(16)         } 
(17)         if ((wrote = writev(ud-&gt;fd, tmp, vlen)) &lt; 0) {
(18)             if (errno == EWOULDBLOCK) {
(19)                 driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, 
(20)                               DO_WRITE, 1);
(21)                 return 0;
(22)             } else {
(23)                 driver_failure_eof(ud-&gt;port);
(24)                 return -1;
(25)             }
(26)         }
(27)         driver_deq(ud-&gt;port, wrote);
(28)         ud-&gt;sent += wrote;
(29)     }
(30) }      </code></pre><p>We simply pick out an I/O vector from the queue
(which is the whole queue as a <strong>SysIOVec</strong>). If the I/O
vector is too long (<strong>IO_VECTOR_MAX</strong> is defined to 16), the vector
length is decreased (line 15), otherwise the <strong>writev</strong>
call (line 17) fails. Writing is tried and anything written is dequeued
(line 27).
If the write fails with <strong>EWOULDBLOCK</strong> (notice that all
sockets are in non-blocking mode), <strong>driver_select</strong> is
called to make the <strong>uds_output</strong> routine be called when
there is space to write again.</p><p>We continue trying to write until the queue is empty or
the writing blocks.</p><p>The routine above is called from the <strong>uds_output</strong>
routine:</p><pre><code class="">
( 1) static void uds_output(ErlDrvData handle, ErlDrvEvent event)
( 2) {
( 3)    UdsData *ud = (UdsData *) handle;
( 4)    if (ud-&gt;type == portTypeConnector) {
( 5)        ud-&gt;type = portTypeCommand;
( 6)        driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_WRITE, 0);
( 7)        driver_output(ud-&gt;port, "Cok",3);
( 8)        return;
( 9)    }
(10)    send_out_queue(ud);
(11) }      </code></pre><p>The routine is simple: it first handles the fact that the
output select will concern a socket in the business of
connecting (and the connecting blocked). If the socket is in
a connected state, it simply sends the output queue. This
routine is called when it is possible to write to a socket
where we have an output queue, so there is no question what to
do.</p><p>The driver implements a control interface, which is a
synchronous interface called when Erlang calls
<a href="./erlang#port_control/3">erlang#port_control/3</a>. Only this interface
can control the driver when it is in <strong>data</strong> mode. It can
be called with the following opcodes:</p><dl><dt><strong>'C'</strong></dt><dd> <p>Sets port in <strong>command</strong> mode.</p> </dd><dt><strong>'I'</strong></dt><dd> <p>Sets port in <strong>intermediate</strong> mode.</p> </dd><dt><strong>'D'</strong></dt><dd> <p>Sets port in <strong>data</strong> mode.</p> </dd><dt><strong>'N'</strong></dt><dd> <p>Gets identification number for listen port. This
identification number is used in an accept command to the
driver. It is returned as a big-endian 32-bit integer, which
is the file identifier for the listen socket.</p> </dd><dt><strong>'S'</strong></dt><dd> <p>Gets statistics, which is the number of bytes received,
the number of bytes sent, and the number of bytes pending in
the output queue. This data is used when the distribution
checks that a connection is alive (ticking). The statistics
is returned as three 32-bit big-endian integers.</p> </dd><dt><strong>'T'</strong></dt><dd> <p>Sends a tick message, which is a packet of length 0.
Ticking is done when the port is in <strong>data</strong> mode, so the
command for sending data cannot be used (besides it ignores
zero length packages in <strong>command</strong> mode). This is used by the
ticker to send dummy data when no other traffic is present.</p> <p><em>Note:</em> It is important that the interface for
sending ticks is not blocking. This implementation uses
<a href="./erlang#port_control/3">erlang#port_control/3</a>, which does not block the
caller. If <strong>erlang:port_command</strong> is used, use
<a href="./erlang#port_command/3">erlang#port_command/3</a> and pass <strong>[force]</strong> as
option list; otherwise the caller can be blocked indefinitely
on a busy port and prevent the system from taking down a
connection that is not functioning.</p> </dd><dt><strong>'R'</strong></dt><dd> <p>Gets creation number of a listen socket, which is used to
dig out the number stored in the lock file to differentiate
between invocations of Erlang nodes with the same name.</p> </dd></dl><p>The control interface gets a buffer to return its value in,
but is free to allocate its own buffer if the provided one is
too small. The <strong>uds_control</strong> code is as follows:</p><pre><code class="">
( 1) static int uds_control(ErlDrvData handle, unsigned int command, 
( 2)                        char* buf, int count, char** res, int res_size)
( 3) {
( 4) /* Local macro to ensure large enough buffer. */
( 5) #define ENSURE(N)                               \
( 6)    do {                                         \
( 7)        if (res_size &lt; N) {                      \
( 8)            *res = ALLOC(N);                     \
( 9)        }                                        \
(10)    } while(0)

(11)    UdsData *ud = (UdsData *) handle;

(12)    switch (command) {
(13)    case 'S':
(14)        {
(15)            ENSURE(13);
(16)            **res = 0;
(17)            put_packet_length((*res) + 1, ud-&gt;received);
(18)            put_packet_length((*res) + 5, ud-&gt;sent);
(19)            put_packet_length((*res) + 9, driver_sizeq(ud-&gt;port));
(20)            return 13;
(21)        }
(22)    case 'C':
(23)        if (ud-&gt;type &lt; portTypeCommand) {
(24)            return report_control_error(res, res_size, "einval");
(25)        }
(26)        ud-&gt;type = portTypeCommand;
(27)        driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ, 0);
(28)        ENSURE(1);
(29)        **res = 0;
(30)        return 1;
(31)    case 'I':
(32)        if (ud-&gt;type &lt; portTypeCommand) {
(33)            return report_control_error(res, res_size, "einval");
(34)        }
(35)        ud-&gt;type = portTypeIntermediate;
(36)        driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ, 0);
(37)        ENSURE(1);
(38)        **res = 0;
(39)        return 1;
(40)    case 'D':
(41)        if (ud-&gt;type &lt; portTypeCommand) {
(42)            return report_control_error(res, res_size, "einval");
(43)        }
(44)        ud-&gt;type = portTypeData;
(45)        do_recv(ud);
(46)        ENSURE(1);
(47)        **res = 0;
(48)        return 1;
(49)    case 'N':
(50)        if (ud-&gt;type != portTypeListener) {
(51)            return report_control_error(res, res_size, "einval");
(52)        }
(53)        ENSURE(5);
(54)        (*res)[0] = 0;
(55)        put_packet_length((*res) + 1, ud-&gt;fd);
(56)        return 5;
(57)    case 'T': /* tick */
(58)        if (ud-&gt;type != portTypeData) {
(59)            return report_control_error(res, res_size, "einval");
(60)        }
(61)        do_send(ud,"",0);
(62)        ENSURE(1);
(63)        **res = 0;
(64)        return 1;
(65)    case 'R':
(66)        if (ud-&gt;type != portTypeListener) {
(67)            return report_control_error(res, res_size, "einval");
(68)        }
(69)        ENSURE(2);
(70)        (*res)[0] = 0;
(71)        (*res)[1] = ud-&gt;creation;
(72)        return 2;
(73)    default:
(74)        return report_control_error(res, res_size, "einval");
(75)    }
(76) #undef ENSURE
(77) }      </code></pre><p>The macro <strong>ENSURE</strong> (line 5-10) is used to ensure that
the buffer is large enough for the answer. We switch on the command and
take actions. We always have read select active on a port in <strong>data</strong>
mode (achieved by calling <strong>do_recv</strong> on line 45), but
we turn off read selection in <strong>intermediate</strong> and <strong>command</strong>
modes (line 27 and 36).</p><p>The rest of the driver is more or less UDS-specific and not of
general interest.</p><h3>Putting It All Together</h3><p>To test the distribution, the <strong>net_kernel:start/1</strong>
function can be used. It is useful, as it starts the distribution on a
running system, where tracing/debugging can be performed.
The <strong>net_kernel:start/1</strong> routine takes a
list as its single argument. The list first element in the list is to be
the node name (without the "@hostname") as an atom. The second (and
last) element is to be one of the atoms <strong>shortnames</strong> or 
<strong>longnames</strong>. In the example case,
<strong>shortnames</strong> is preferred.</p><p>For <strong>net_kernel</strong> to find out which distribution module to use,
command-line argument <strong>-proto_dist</strong> is used. It
is followed by one or more distribution module names, with suffix
"_dist" removed, that is, <strong>uds_dist</strong> as a distribution module
is specified as <strong>-proto_dist uds</strong>.</p><p>If no <strong>epmd</strong> (TCP port mapper daemon) is used, also command-line
option <strong>-no_epmd</strong> is to be specified, which makes
Erlang skip the <strong>epmd</strong> startup, both as an OS process and as an
Erlang ditto.</p><p>The path to the directory where the distribution modules reside
must be known at boot. This can be achieved either by
specifying <strong>-pa &lt;path&gt;</strong> on the command line or by
building a boot script containing the applications used for your
distribution protocol. (In the <strong>uds_dist</strong> protocol, only the
<strong>uds_dist</strong> application needs to be added to the script.)</p><p>The distribution starts at boot if all the above is
specified and an <strong>-sname &lt;name&gt;</strong> flag is present at the
command line.</p><p><em>Example 1:</em></p><pre>
$ <span class="input">erl -pa $ERL_TOP/lib/kernel/examples/uds_dist/ebin -proto_dist uds -no_epmd</span>
Erlang (BEAM) emulator version 5.0 
 
Eshell V5.0  (abort with ^G)
1&gt; <span class="input">net_kernel:start([bing,shortnames]).</span>
{ok,&lt;0.30.0&gt;}
(bing@hador)2&gt;</pre><p><em>Example 2:</em></p><pre>
$ <span class="input">erl -pa $ERL_TOP/lib/kernel/examples/uds_dist/ebin -proto_dist uds \ </span>
<span class="input">      -no_epmd -sname bong</span>
Erlang (BEAM) emulator version 5.0 
 
Eshell V5.0  (abort with ^G)
(bong@hador)1&gt;</pre><p>The <strong>ERL_FLAGS</strong> environment variable can be used to store the
complicated parameters in:</p><pre>
$ <span class="input">ERL_FLAGS=-pa $ERL_TOP/lib/kernel/examples/uds_dist/ebin \ </span>
<span class="input">      -proto_dist uds -no_epmd</span>
$ <span class="input">export ERL_FLAGS</span>
$ <span class="input">erl -sname bang</span>
Erlang (BEAM) emulator version 5.0 
 
Eshell V5.0  (abort with ^G)
(bang@hador)1&gt;</pre><p><strong>ERL_FLAGS</strong> should not include the node name.</p><p>
This section describes how to implement an alternative discovery mechanism
for Erlang distribution. Discovery is normally done using DNS and the
Erlang Port Mapper Daemon (EPMD) for port discovery.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Support for alternative service discovery mechanisms was added in Erlang/OTP
21.
</p></div><h3>Introduction</h3><p>To implement your own service discovery module you have to write your own
EPMD module. The <a href="./erl_epmd">EPMD module</a> is
responsible for providing the location of another node. The distribution
modules (<strong>inet_tcp_dist</strong>/<strong>inet_tls_dist</strong>) call the EPMD module to
get the IP address and port of the other node. The EPMD module that is part
of Erlang/OTP will resolve the hostname using DNS and uses the EPMD unix
process to get the port of another node. The EPMD unix process does this by
connecting to the other node on a well-known port, port 4369.</p><h3>Discovery module</h3><p>The discovery module needs to implement the same API as the regular
<a href="./erl_epmd">EPMD module</a>. However, instead of
communicating with EPMD you can connect to any service to find out
connection details of other nodes. A discovery module is enabled
by setting <a href="./erl">-epmd_module</a>
when starting erlang. The discovery module must implement the following
callbacks:</p><dl><dt><a href="../kernel/erl_epmd#start_link/0">start_link/0</a></dt><dd>Start any processes needed by the discovery module.</dd><dt><a href="../kernel/erl_epmd#names/1">names/1</a></dt><dd>Return node names held by the registrar for the given host.</dd><dt><a href="../kernel/erl_epmd#register_node/2">register_node/2</a></dt><dd>Register the given node name with the registrar.</dd><dt><a href="../kernel/erl_epmd#port_please/3">port_please/3</a></dt><dd>Return the distribution port used by the given node.</dd></dl><p>The discovery module may implement the following callback:</p><dl><dt><a href="../kernel/erl_epmd#address_please/3">address_please/3</a></dt><dd><p>Return the address of the given node.
If not implemented, <a href="../kernel/inet#gethostbyname/1"> inet:gethostbyname/1</a> will be used instead</p> <p>This callback may also return the port of the given node. In that case
<a href="../kernel/erl_epmd#port_please/3">port_please/3</a>
may be omitted.</p></dd></dl><p>This section describes the standard representation of parse trees for Erlang
programs as Erlang terms. This representation is known as the <em>abstract format</em>. Functions dealing with such parse trees are
<a href="../compiler/compile#forms/1">compiler/compile#forms/1</a> and functions in the following
modules:</p><ul><li><a href="./epp">stdlib/epp</a></li><li><a href="./erl_eval">stdlib/erl_eval</a></li><li><a href="./erl_lint">stdlib/erl_lint</a></li><li><a href="./erl_parse">stdlib/erl_parse</a></li><li><a href="./erl_pp">stdlib/erl_pp</a></li><li><a href="./io">stdlib/io</a></li></ul><p>The functions are also used as input and output for parse transforms, see
the <a href="./compile">compiler/compile</a>
module.</p><p>We use the function <strong>Rep</strong> to denote the mapping from an Erlang source
construct <strong>C</strong> to its abstract format representation <strong>R</strong>, and write
<strong>R = Rep(C)</strong>.</p><p>The word <strong>LINE</strong> in this section represents an integer, and denotes the
number of the line in the source file where the construction occurred.
Several instances of <strong>LINE</strong> in the same construction can denote
different lines.</p><p>As operators are not terms in their own right, when operators are
mentioned below, the representation of an operator is to be taken to
be the atom with a printname consisting of the same characters as the
operator.</p><h3>Module Declarations and Forms</h3><p>A module declaration consists of a sequence of forms, which are either
function declarations or attributes.</p><ul><li> <p>If D is a module declaration consisting of the forms
<strong>F_1</strong>, ..., <strong>F_k</strong>, then
Rep(D) = <strong>[Rep(F_1), ..., Rep(F_k)]</strong>.</p> </li><li> <p>If F is an attribute <strong>-export([Fun_1/A_1, ..., Fun_k/A_k])</strong>,
then Rep(F) =
<strong>{attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}</strong>.</p> </li><li> <p>If F is an attribute <strong>-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])</strong>,
then Rep(F) =
<strong>{attribute,LINE,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}</strong>.</p> </li><li> <p>If F is an attribute <strong>-module(Mod)</strong>, then
Rep(F) = <strong>{attribute,LINE,module,Mod}</strong>.</p> </li><li> <p>If F is an attribute <strong>-file(File,Line)</strong>, then
Rep(F) = <strong>{attribute,LINE,file,{File,Line}}</strong>.</p> </li><li> <p>If F is a function declaration <strong>Name Fc_1 ; ... ; Name Fc_k</strong>,
where each <strong>Fc_i</strong> is a function clause with a pattern sequence of
the same length <strong>Arity</strong>, then Rep(F) =
<strong>{function,LINE,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}</strong>.</p> </li><li> <p>If F is a function specification <strong>-Spec Name Ft_1; ...; Ft_k</strong>,
where <strong>Spec</strong> is either the atom <strong>spec</strong> or the atom
<strong>callback</strong>, and each <strong>Ft_i</strong> is a possibly constrained
function type with an argument sequence of the same length
<strong>Arity</strong>, then Rep(F) =
<strong>{attribute,Line,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}</strong>.</p> </li><li> <p>If F is a function specification
<strong>-spec Mod:Name Ft_1; ...; Ft_k</strong>, where each <strong>Ft_i</strong> is a
possibly constrained function type with an argument sequence of the
same length <strong>Arity</strong>, then Rep(F) =
<strong>{attribute,Line,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}</strong>.</p> </li><li> <p>If F is a record declaration <strong>-record(Name,{V_1, ..., V_k})</strong>,
where each <strong>V_i</strong> is a record field, then Rep(F) =
<strong>{attribute,LINE,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}</strong>.
For Rep(V), see below.</p> </li><li> <p>If F is a type declaration <strong>-Type Name(V_1, ..., V_k) :: T</strong>,
where <strong>Type</strong> is either the atom <strong>type</strong> or the atom
<strong>opaque</strong>, each <strong>V_i</strong> is a variable, and <strong>T</strong> is a type,
then Rep(F) =
<strong>{attribute,LINE,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}</strong>.</p> </li><li> <p>If F is a wild attribute <strong>-A(T)</strong>, then
Rep(F) = <strong>{attribute,LINE,A,T}</strong>.</p> </li></ul><h3>Record Fields</h3><p>Each field in a record declaration can have an optional,
explicit, default initializer expression, and an
optional type.</p><ul><li> <p>If V is <strong>A</strong>, then
Rep(V) = <strong>{record_field,LINE,Rep(A)}</strong>.</p> </li><li> <p>If V is <strong>A = E</strong>, where <strong>E</strong> is an expression, then
Rep(V) = <strong>{record_field,LINE,Rep(A),Rep(E)}</strong>.</p> </li><li> <p>If V is <strong>A :: T</strong>, where <strong>T</strong> is a type, then Rep(V) =
<strong>{typed_record_field,{record_field,LINE,Rep(A)},Rep(T)}</strong>.</p> </li><li> <p>If V is <strong>A = E :: T</strong>, where
<strong>E</strong> is an expression and <strong>T</strong> is a type, then Rep(V) =
<strong>{typed_record_field,{record_field,LINE,Rep(A),Rep(E)},Rep(T)}</strong>.
</p> </li></ul><h3>Representation of Parse Errors and End-of-File</h3><p>In addition to the representations of forms, the list that represents
a module declaration (as returned by functions in
<a href="./epp">stdlib/epp</a> and
<a href="./erl_parse">stdlib/erl_parse</a>)
can contain the following:</p><ul><li> <p>Tuples <strong>{error,E}</strong> and <strong>{warning,W}</strong>, denoting
syntactically incorrect forms and warnings.
</p> </li><li> <p><strong>{eof,LOCATION}</strong>, denoting an end-of-stream
encountered before a complete form had been parsed.
The word <strong>LOCATION</strong> represents an integer, and denotes the
number of the last line in the source file.
</p> </li></ul><h3>Atomic Literals</h3><p>There are five kinds of atomic literals, which are represented in the
same way in patterns, expressions, and guards:</p><ul><li> <p>If L is an atom literal, then Rep(L) = <strong>{atom,LINE,L}</strong>.</p> </li><li> <p>If L is a character literal, then Rep(L) = <strong>{char,LINE,L}</strong>.</p> </li><li> <p>If L is a float literal, then Rep(L) = <strong>{float,LINE,L}</strong>.</p> </li><li> <p>If L is an integer literal, then
Rep(L) = <strong>{integer,LINE,L}</strong>.</p> </li><li> <p>If L is a string literal consisting of the characters
<strong>C_1</strong>, ..., <strong>C_k</strong>, then
Rep(L) = <strong>{string,LINE,[C_1, ..., C_k]}</strong>.</p> </li></ul><p>Notice that negative integer and float literals do not occur as such;
they are parsed as an application of the unary negation operator.</p><h3>Patterns</h3><p>If Ps is a sequence of patterns <strong>P_1, ..., P_k</strong>, then
Rep(Ps) = <strong>[Rep(P_1), ..., Rep(P_k)]</strong>. Such sequences occur as the
list of arguments to a function or fun.</p><p>Individual patterns are represented as follows:</p><ul><li> <p>If P is an atomic literal <strong>L</strong>, then Rep(P) = Rep(L).</p> </li><li> <p>If P is a bitstring pattern
<strong>&lt;&lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&gt;&gt;</strong>, where each
<strong>Size_i</strong> is an expression that can be evaluated to an integer,
and each <strong>TSL_i</strong> is a type specificer list, then Rep(P) =
<strong>{bin,LINE,[{bin_element,LINE,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}</strong>.
For Rep(TSL), see below.
An omitted <strong>Size_i</strong> is represented by <strong>default</strong>.
An omitted <strong>TSL_i</strong> is represented by <strong>default</strong>.</p> </li><li> <p>If P is a compound pattern <strong>P_1 = P_2</strong>, then Rep(P) =
<strong>{match,LINE,Rep(P_1),Rep(P_2)}</strong>.</p> </li><li> <p>If P is a cons pattern <strong>[P_h | P_t]</strong>, then Rep(P) =
<strong>{cons,LINE,Rep(P_h),Rep(P_t)}</strong>.</p> </li><li> <p>If P is a map pattern <strong>#{A_1, ..., A_k}</strong>, where each
<strong>A_i</strong> is an association <strong>P_i_1 := P_i_2</strong>, then Rep(P) =
<strong>{map,LINE,[Rep(A_1), ..., Rep(A_k)]}</strong>.
For Rep(A), see below.</p> </li><li> <p>If P is a nil pattern <strong>[]</strong>, then Rep(P) =
<strong>{nil,LINE}</strong>.</p> </li><li> <p>If P is an operator pattern <strong>P_1 Op P_2</strong>, where <strong>Op</strong> is a
binary operator (this is either an occurrence of <strong>++</strong> applied to
a literal string or character list, or an occurrence of an expression
that can be evaluated to a number at compile time), then Rep(P) =
<strong>{op,LINE,Op,Rep(P_1),Rep(P_2)}</strong>.</p> </li><li> <p>If P is an operator pattern <strong>Op P_0</strong>, where <strong>Op</strong> is a
unary operator (this is an occurrence of an expression that can be
evaluated to a number at compile time), then Rep(P) =
<strong>{op,LINE,Op,Rep(P_0)}</strong>.</p> </li><li> <p>If P is a parenthesized pattern <strong>( P_0 )</strong>, then Rep(P) =
<strong>Rep(P_0)</strong>, that is, parenthesized patterns cannot be
distinguished from their bodies.</p> </li><li> <p>If P is a record field index pattern <strong>#Name.Field</strong>,
where <strong>Field</strong> is an atom, then Rep(P) =
<strong>{record_index,LINE,Name,Rep(Field)}</strong>.</p> </li><li> <p>If P is a record pattern <strong>#Name{Field_1=P_1, ..., Field_k=P_k}</strong>,
where each <strong>Field_i</strong> is an atom or <strong>_</strong>, then Rep(P) =
<strong>{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(P_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(P_k)}]}</strong>.</p> </li><li> <p>If P is a tuple pattern <strong>{P_1, ..., P_k}</strong>, then Rep(P) =
<strong>{tuple,LINE,[Rep(P_1), ..., Rep(P_k)]}</strong>.</p> </li><li> <p>If P is a universal pattern <strong>_</strong>, then Rep(P) =
<strong>{var,LINE,'_'}</strong>.</p></li><li> <p>If P is a variable pattern <strong>V</strong>, then Rep(P) =
<strong>{var,LINE,A}</strong>, where A is an atom with a printname consisting
of the same characters as <strong>V</strong>.</p> </li></ul><p>Notice that every pattern has the same source form as some expression,
and is represented in the same way as the corresponding expression.</p><h3>Expressions</h3><p>A body B is a non-empty sequence of expressions <strong>E_1, ..., E_k</strong>,
and Rep(B) = <strong>[Rep(E_1), ..., Rep(E_k)]</strong>.</p><p>An expression E is one of the following:</p><ul><li> <p>If E is an atomic literal <strong>L</strong>, then Rep(E) = Rep(L).</p> </li><li> <p>If E is a bitstring comprehension
<strong>&lt;&lt;E_0 || Q_1, ..., Q_k&gt;&gt;</strong>,
where each <strong>Q_i</strong> is a qualifier, then Rep(E) =
<strong>{bc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}</strong>.
For Rep(Q), see below.</p> </li><li> <p>If E is a bitstring constructor
<strong>&lt;&lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&gt;&gt;</strong>,
where each <strong>Size_i</strong> is an expression and each
<strong>TSL_i</strong> is a type specificer list, then Rep(E) =
<strong>{bin,LINE,[{bin_element,LINE,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}</strong>.
For Rep(TSL), see below.
An omitted <strong>Size_i</strong> is represented by <strong>default</strong>.
An omitted <strong>TSL_i</strong> is represented by <strong>default</strong>.</p> </li><li> <p>If E is a block expression <strong>begin B end</strong>,
where <strong>B</strong> is a body, then Rep(E) =
<strong>{block,LINE,Rep(B)}</strong>.</p> </li><li> <p>If E is a case expression <strong>case E_0 of Cc_1 ; ... ; Cc_k end</strong>,
where <strong>E_0</strong> is an expression and each <strong>Cc_i</strong> is a
case clause, then Rep(E) =
<strong>{'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}</strong>.</p> </li><li> <p>If E is a catch expression <strong>catch E_0</strong>, then Rep(E) =
<strong>{'catch',LINE,Rep(E_0)}</strong>.</p> </li><li> <p>If E is a cons skeleton <strong>[E_h | E_t]</strong>, then Rep(E) =
<strong>{cons,LINE,Rep(E_h),Rep(E_t)}</strong>.</p> </li><li> <p>If E is a fun expression <strong>fun Name/Arity</strong>, then Rep(E) =
<strong>{'fun',LINE,{function,Name,Arity}}</strong>.</p> </li><li> <p>If E is a fun expression <strong>fun Module:Name/Arity</strong>, then Rep(E) =
<strong>{'fun',LINE,{function,Rep(Module),Rep(Name),Rep(Arity)}}</strong>.
(Before Erlang/OTP R15: Rep(E) =
<strong>{'fun',LINE,{function,Module,Name,Arity}}</strong>.)</p> </li><li> <p>If E is a fun expression <strong>fun Fc_1 ; ... ; Fc_k end</strong>,
where each <strong>Fc_i</strong> is a function clause, then Rep(E) =
<strong>{'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}</strong>.</p> </li><li> <p>If E is a fun expression <strong>fun Name Fc_1 ; ... ; Name Fc_k end</strong>,
where <strong>Name</strong> is a variable and each
<strong>Fc_i</strong> is a function clause, then Rep(E) =
<strong>{named_fun,LINE,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}</strong>.</p> </li><li> <p>If E is a function call <strong>E_0(E_1, ..., E_k)</strong>, then Rep(E) =
<strong>{call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}</strong>.</p> </li><li> <p>If E is a function call <strong>E_m:E_0(E_1, ..., E_k)</strong>, then Rep(E) =
<strong>{call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}</strong>.</p> </li><li> <p>If E is an if expression <strong>if Ic_1 ; ... ; Ic_k  end</strong>,
where each <strong>Ic_i</strong> is an if clause, then Rep(E) =
<strong>{'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}</strong>.</p> </li><li> <p>If E is a list comprehension <strong>[E_0 || Q_1, ..., Q_k]</strong>,
where each <strong>Q_i</strong> is a qualifier, then Rep(E) =
<strong>{lc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}</strong>.
For Rep(Q), see below.</p> </li><li> <p>If E is a map creation <strong>#{A_1, ..., A_k}</strong>,
where each <strong>A_i</strong> is an association <strong>E_i_1 =&gt; E_i_2</strong>,
then Rep(E) = <strong>{map,LINE,[Rep(A_1), ..., Rep(A_k)]}</strong>.
For Rep(A), see below.</p> </li><li> <p>If E is a map update <strong>E_0#{A_1, ..., A_k}</strong>,
where each <strong>A_i</strong> is an association <strong>E_i_1 =&gt; E_i_2</strong>
or <strong>E_i_1 := E_i_2</strong>, then Rep(E) =
<strong>{map,LINE,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}</strong>.
For Rep(A), see below.</p> </li><li> <p>If E is a match operator expression <strong>P = E_0</strong>,
where <strong>P</strong> is a pattern, then Rep(E) =
<strong>{match,LINE,Rep(P),Rep(E_0)}</strong>.</p> </li><li> <p>If E is nil, <strong>[]</strong>, then Rep(E) = <strong>{nil,LINE}</strong>.</p> </li><li> <p>If E is an operator expression <strong>E_1 Op E_2</strong>,
where <strong>Op</strong> is a binary operator other than match operator
<strong>=</strong>, then Rep(E) =
<strong>{op,LINE,Op,Rep(E_1),Rep(E_2)}</strong>.</p> </li><li> <p>If E is an operator expression <strong>Op E_0</strong>,
where <strong>Op</strong> is a unary operator, then Rep(E) =
<strong>{op,LINE,Op,Rep(E_0)}</strong>.</p> </li><li> <p>If E is a parenthesized expression <strong>( E_0 )</strong>, then Rep(E) =
<strong>Rep(E_0)</strong>, that is, parenthesized expressions cannot be
distinguished from their bodies.</p> </li><li> <p>If E is a receive expression <strong>receive Cc_1 ; ... ; Cc_k end</strong>,
where each <strong>Cc_i</strong> is a case clause, then Rep(E) =
<strong>{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)]}</strong>.</p> </li><li> <p>If E is a receive expression
<strong>receive Cc_1 ; ... ; Cc_k after E_0 -&gt; B_t end</strong>,
where each <strong>Cc_i</strong> is a case clause, <strong>E_0</strong> is an expression,
and <strong>B_t</strong> is a body, then Rep(E) =
<strong>{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}</strong>.</p> </li><li> <p>If E is a record creation
<strong>#Name{Field_1=E_1, ..., Field_k=E_k}</strong>,
where each <strong>Field_i</strong> is an atom or <strong>_</strong>, then Rep(E) =
<strong>{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}</strong>.</p> </li><li> <p>If E is a record field access <strong>E_0#Name.Field</strong>,
where <strong>Field</strong> is an atom, then Rep(E) =
<strong>{record_field,LINE,Rep(E_0),Name,Rep(Field)}</strong>.</p> </li><li> <p>If E is a record field index <strong>#Name.Field</strong>,
where <strong>Field</strong> is an atom, then Rep(E) =
<strong>{record_index,LINE,Name,Rep(Field)}</strong>.</p></li><li> <p>If E is a record update
<strong>E_0#Name{Field_1=E_1, ..., Field_k=E_k}</strong>,
where each <strong>Field_i</strong> is an atom, then Rep(E) =
<strong>{record,LINE,Rep(E_0),Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}</strong>.</p> </li><li> <p>If E is a tuple skeleton <strong>{E_1, ..., E_k}</strong>, then Rep(E) =
<strong>{tuple,LINE,[Rep(E_1), ..., Rep(E_k)]}</strong>.</p> </li><li> <p>If E is a try expression <strong>try B catch Tc_1 ; ... ; Tc_k end</strong>,
where <strong>B</strong> is a body and each <strong>Tc_i</strong> is a catch clause,
then Rep(E) =
<strong>{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}</strong>.</p> </li><li> <p>If E is a try expression
<strong>try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end</strong>,
where <strong>B</strong> is a body, each <strong>Cc_i</strong> is a case clause, and
each <strong>Tc_j</strong> is a catch clause, then Rep(E) =
<strong>{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}</strong>.</p> </li><li> <p>If E is a try expression <strong>try B after A end</strong>,
where <strong>B</strong> and <strong>A</strong> are bodies, then Rep(E) =
<strong>{'try',LINE,Rep(B),[],[],Rep(A)}</strong>.</p> </li><li> <p>If E is a try expression
<strong>try B of Cc_1 ; ... ; Cc_k after A end</strong>,
where <strong>B</strong> and <strong>A</strong> are a bodies,
and each <strong>Cc_i</strong> is a case clause, then Rep(E) =
<strong>{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}</strong>.</p> </li><li> <p>If E is a try expression
<strong>try B catch Tc_1 ; ... ; Tc_k after A end</strong>,
where <strong>B</strong> and <strong>A</strong> are bodies,
and each <strong>Tc_i</strong> is a catch clause, then Rep(E) =
<strong>{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}</strong>.</p> </li><li> <p>If E is a try expression
<strong>try B of Cc_1 ; ... ; Cc_k  catch Tc_1 ; ... ; Tc_n after A end</strong>, where <strong>B</strong> and <strong>A</strong> are a bodies,
each <strong>Cc_i</strong> is a case clause,
and each <strong>Tc_j</strong> is a catch clause, then Rep(E) =
<strong>{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}</strong>.</p> </li><li> <p>If E is a variable <strong>V</strong>, then Rep(E) = <strong>{var,LINE,A}</strong>,
where <strong>A</strong> is an atom with a printname consisting of the same
characters as <strong>V</strong>.</p> </li></ul><h3>Qualifiers</h3><p>A qualifier Q is one of the following:</p><ul><li> <p>If Q is a filter <strong>E</strong>, where <strong>E</strong> is an expression, then
Rep(Q) = <strong>Rep(E)</strong>.</p> </li><li> <p>If Q is a generator <strong>P &lt;- E</strong>, where <strong>P</strong> is
a pattern and <strong>E</strong> is an expression, then Rep(Q) =
<strong>{generate,LINE,Rep(P),Rep(E)}</strong>.</p> </li><li> <p>If Q is a bitstring generator <strong>P &lt;= E</strong>, where <strong>P</strong> is
a pattern and <strong>E</strong> is an expression, then Rep(Q) =
<strong>{b_generate,LINE,Rep(P),Rep(E)}</strong>.</p> </li></ul><h3>Bitstring Element Type Specifiers</h3><p>A type specifier list TSL for a bitstring element is a sequence
of type specifiers <strong>TS_1 - ... - TS_k</strong>, and
Rep(TSL) = <strong>[Rep(TS_1), ..., Rep(TS_k)]</strong>.</p><ul><li> <p>If TS is a type specifier <strong>A</strong>, where <strong>A</strong> is an atom,
then Rep(TS) = <strong>A</strong>.</p> </li><li> <p>If TS is a type specifier <strong>A:Value</strong>,
where <strong>A</strong> is an atom and <strong>Value</strong> is an integer,
then Rep(TS) = <strong>{A,Value}</strong>.</p> </li></ul><h3>Associations</h3><p>An association A is one of the following:</p><ul><li> <p>If A is an association <strong>K =&gt; V</strong>,
then Rep(A) = <strong>{map_field_assoc,LINE,Rep(K),Rep(V)}</strong>.</p> </li><li> <p>If A is an association <strong>K := V</strong>,
then Rep(A) = <strong>{map_field_exact,LINE,Rep(K),Rep(V)}</strong>.</p> </li></ul><h3>Clauses</h3><p>There are function clauses, if clauses, case clauses,
and catch clauses.</p><p>A clause C is one of the following:</p><ul><li> <p>If C is a case clause <strong>P -&gt; B</strong>,
where <strong>P</strong> is a pattern and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,[Rep(P)],[],Rep(B)}</strong>.</p> </li><li> <p>If C is a case clause <strong>P when Gs -&gt; B</strong>,
where <strong>P</strong> is a pattern,
<strong>Gs</strong> is a guard sequence, and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,[Rep(P)],Rep(Gs),Rep(B)}</strong>.</p> </li><li> <p>If C is a catch clause <strong>P -&gt; B</strong>,
where <strong>P</strong> is a pattern and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,[Rep({throw,P,_})],[],Rep(B)}</strong>,
that is, a catch clause with an explicit exception class
<strong>throw</strong> and with or without an explicit stacktrace
variable <strong>_</strong> cannot be distinguished from a catch clause
without an explicit exception class and without an explicit
stacktrace variable.</p> </li><li> <p>If C is a catch clause <strong>X : P -&gt; B</strong>,
where <strong>X</strong> is an atomic literal or a variable pattern,
<strong>P</strong> is a pattern, and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,[Rep({X,P,_})],[],Rep(B)}</strong>,
that is, a catch clause with an explicit exception class and
with an explicit stacktrace variable <strong>_</strong> cannot be
distinguished from a catch clause with an explicit exception
class and without an explicit stacktrace variable.</p> </li><li> <p>If C is a catch clause <strong>X : P : S -&gt; B</strong>,
where <strong>X</strong> is an atomic literal or a variable pattern,
<strong>P</strong> is a pattern, <strong>S</strong> is a variable, and <strong>B</strong>
is a body, then
Rep(C) = <strong>{clause,LINE,[Rep({X,P,S})],[],Rep(B)}</strong>.</p> </li><li> <p>If C is a catch clause <strong>P when Gs -&gt; B</strong>,
where <strong>P</strong> is a pattern, <strong>Gs</strong> is a guard sequence,
and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,[Rep({throw,P,_})],Rep(Gs),Rep(B)}</strong>,
that is, a catch clause with an explicit exception class
<strong>throw</strong> and with or without an explicit stacktrace
variable <strong>_</strong> cannot be distinguished from a catch clause
without an explicit exception class and without an explicit
stacktrace variable.</p> </li><li> <p>If C is a catch clause <strong>X : P when Gs -&gt; B</strong>,
where <strong>X</strong> is an atomic literal or a variable pattern,
<strong>P</strong> is a pattern, <strong>Gs</strong> is a guard sequence,
and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,[Rep({X,P,_})],Rep(Gs),Rep(B)}</strong>,
that is, a catch clause with an explicit exception class and
with an explicit stacktrace variable <strong>_</strong> cannot be
distinguished from a catch clause with an explicit exception
class and without an explicit stacktrace variable.</p> </li><li> <p>If C is a catch clause <strong>X : P : S when Gs -&gt; B</strong>,
where <strong>X</strong> is an atomic literal or a variable pattern,
<strong>P</strong> is a pattern, <strong>Gs</strong> is a guard sequence,
<strong>S</strong> is a variable, and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,[Rep({X,P,S})],Rep(Gs),Rep(B)}</strong>.</p> </li><li> <p>If C is a function clause <strong>( Ps ) -&gt; B</strong>,
where <strong>Ps</strong> is a pattern sequence and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,Rep(Ps),[],Rep(B)}</strong>.</p> </li><li> <p>If C is a function clause <strong>( Ps ) when Gs -&gt; B</strong>,
where <strong>Ps</strong> is a pattern sequence,
<strong>Gs</strong> is a guard sequence and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,Rep(Ps),Rep(Gs),Rep(B)}</strong>.</p> </li><li> <p>If C is an if clause <strong>Gs -&gt; B</strong>,
where <strong>Gs</strong> is a guard sequence and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,[],Rep(Gs),Rep(B)}</strong>.</p> </li></ul><h3>Guards</h3><p>A guard sequence Gs is a sequence of guards <strong>G_1; ...; G_k</strong>, and
Rep(Gs) = <strong>[Rep(G_1), ..., Rep(G_k)]</strong>. If the guard sequence is
empty, then Rep(Gs) = <strong>[]</strong>.</p><p>A guard G is a non-empty sequence of guard tests
<strong>Gt_1, ..., Gt_k</strong>, and Rep(G) =
<strong>[Rep(Gt_1), ..., Rep(Gt_k)]</strong>.</p><p>A guard test Gt is one of the following:</p><ul><li> <p>If Gt is an atomic literal <strong>L</strong>, then Rep(Gt) = Rep(L).</p> </li><li> <p>If Gt is a bitstring constructor
<strong>&lt;&lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&gt;&gt;</strong>,
where each <strong>Size_i</strong> is a guard test and each
<strong>TSL_i</strong> is a type specificer list, then Rep(Gt) =
<strong>{bin,LINE,[{bin_element,LINE,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}</strong>.
For Rep(TSL), see above.
An omitted <strong>Size_i</strong> is represented by <strong>default</strong>.
An omitted <strong>TSL_i</strong> is represented by <strong>default</strong>.</p> </li><li> <p>If Gt is a cons skeleton <strong>[Gt_h | Gt_t]</strong>, then Rep(Gt) =
<strong>{cons,LINE,Rep(Gt_h),Rep(Gt_t)}</strong>.</p> </li><li> <p>If Gt is a function call <strong>A(Gt_1, ..., Gt_k)</strong>,
where <strong>A</strong> is an atom, then Rep(Gt) =
<strong>{call,LINE,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}</strong>.</p> </li><li> <p>If Gt is a function call <strong>A_m:A(Gt_1, ..., Gt_k)</strong>,
where <strong>A_m</strong> is the atom <strong>erlang</strong> and <strong>A</strong> is
an atom or an operator, then Rep(Gt) =
<strong>{call,LINE,{remote,LINE,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}</strong>.</p> </li><li> <p>If Gt is a map creation <strong>#{A_1, ..., A_k}</strong>,
where each <strong>A_i</strong> is an association <strong>Gt_i_1 =&gt; Gt_i_2</strong>,
then Rep(Gt) = <strong>{map,LINE,[Rep(A_1), ..., Rep(A_k)]}</strong>.
For Rep(A), see above.</p> </li><li> <p>If Gt is a map update <strong>Gt_0#{A_1, ..., A_k}</strong>,
where each <strong>A_i</strong> is an association <strong>Gt_i_1 =&gt; Gt_i_2</strong>
or <strong>Gt_i_1 := Gt_i_2</strong>, then Rep(Gt) =
<strong>{map,LINE,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}</strong>.
For Rep(A), see above.</p> </li><li> <p>If Gt is nil, <strong>[]</strong>, then Rep(Gt) = <strong>{nil,LINE}</strong>.</p> </li><li> <p>If Gt is an operator guard test <strong>Gt_1 Op Gt_2</strong>,
where <strong>Op</strong> is a binary operator other than match
operator <strong>=</strong>, then Rep(Gt) =
<strong>{op,LINE,Op,Rep(Gt_1),Rep(Gt_2)}</strong>.</p> </li><li> <p>If Gt is an operator guard test <strong>Op Gt_0</strong>,
where <strong>Op</strong> is a unary operator, then Rep(Gt) =
<strong>{op,LINE,Op,Rep(Gt_0)}</strong>.</p> </li><li> <p>If Gt is a parenthesized guard test <strong>( Gt_0 )</strong>, then Rep(Gt) =
<strong>Rep(Gt_0)</strong>, that is, parenthesized
guard tests cannot be distinguished from their bodies.</p> </li><li> <p>If Gt is a record creation
<strong>#Name{Field_1=Gt_1, ..., Field_k=Gt_k}</strong>,
where each <strong>Field_i</strong> is an atom or <strong>_</strong>, then Rep(Gt) =
<strong>{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(Gt_k)}]}</strong>.</p> </li><li> <p>If Gt is  a record field access <strong>Gt_0#Name.Field</strong>,
where <strong>Field</strong> is an atom, then Rep(Gt) =
<strong>{record_field,LINE,Rep(Gt_0),Name,Rep(Field)}</strong>.</p> </li><li> <p>If Gt is a record field index <strong>#Name.Field</strong>,
where <strong>Field</strong> is an atom, then Rep(Gt) =
<strong>{record_index,LINE,Name,Rep(Field)}</strong>.</p> </li><li> <p>If Gt is a tuple skeleton <strong>{Gt_1, ..., Gt_k}</strong>, then Rep(Gt) =
<strong>{tuple,LINE,[Rep(Gt_1), ..., Rep(Gt_k)]}</strong>.</p> </li><li> <p>If Gt is a variable pattern <strong>V</strong>, then Rep(Gt) =
<strong>{var,LINE,A}</strong>, where A is an atom with
a printname consisting of the same characters as <strong>V</strong>.</p> </li></ul><p>Notice that every guard test has the same source form as some expression,
and is represented in the same way as the corresponding expression.</p><h3>Types</h3><ul><li> <p>If T is an annotated type <strong>A :: T_0</strong>,
where <strong>A</strong> is a variable, then Rep(T) =
<strong>{ann_type,LINE,[Rep(A),Rep(T_0)]}</strong>.</p> </li><li> <p>If T is an atom, a character, or an integer literal L,
then Rep(T) = Rep(L).</p> </li><li> <p>If T is a bitstring type <strong>&lt;&lt;_:M,_:_*N&gt;&gt;</strong>,
where <strong>M</strong> and <strong>N</strong> are singleton integer types, then Rep(T) =
<strong>{type,LINE,binary,[Rep(M),Rep(N)]}</strong>.</p> </li><li> <p>If T is the empty list type <strong>[]</strong>, then Rep(T) =
<strong>{type,Line,nil,[]}</strong>, that is, the empty list type
<strong>[]</strong> cannot be distinguished from the predefined type
<strong>nil()</strong>.</p> </li><li> <p>If T is a fun type <strong>fun()</strong>, then Rep(T) =
<strong>{type,LINE,'fun',[]}</strong>.</p> </li><li> <p>If T is a fun type <strong>fun((...) -&gt; T_0)</strong>, then Rep(T) =
<strong>{type,LINE,'fun',[{type,LINE,any},Rep(T_0)]}</strong>.</p> </li><li> <p>If T is a fun type <strong>fun(Ft)</strong>, where
<strong>Ft</strong> is a function type, then Rep(T) = <strong>Rep(Ft)</strong>.
For Rep(Ft), see below.</p> </li><li> <p>If T is an integer range type <strong>L .. H</strong>,
where <strong>L</strong> and <strong>H</strong> are singleton integer types, then Rep(T) =
<strong>{type,LINE,range,[Rep(L),Rep(H)]}</strong>.</p> </li><li> <p>If T is a map type <strong>map()</strong>, then Rep(T) =
<strong>{type,LINE,map,any}</strong>.</p> </li><li> <p>If T is a map type <strong>#{A_1, ..., A_k}</strong>, where each
<strong>A_i</strong> is an association type, then Rep(T) =
<strong>{type,LINE,map,[Rep(A_1), ..., Rep(A_k)]}</strong>.
For Rep(A), see below.</p> </li><li> <p>If T is an operator type <strong>T_1 Op T_2</strong>,
where <strong>Op</strong> is a binary operator (this is an occurrence of
an expression that can be evaluated to an integer at compile
time), then Rep(T) =
<strong>{op,LINE,Op,Rep(T_1),Rep(T_2)}</strong>.</p> </li><li> <p>If T is an operator type <strong>Op T_0</strong>, where <strong>Op</strong> is a
unary operator (this is an occurrence of an expression that can
be evaluated to an integer at compile time), then Rep(T) =
<strong>{op,LINE,Op,Rep(T_0)}</strong>.</p> </li><li> <p>If T is <strong>( T_0 )</strong>, then Rep(T) = <strong>Rep(T_0)</strong>, that is,
parenthesized types cannot be distinguished from their bodies.</p> </li><li> <p>If T is a predefined (or built-in) type <strong>N(T_1, ..., T_k)</strong>,
then Rep(T) = <strong>{type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}</strong>.</p> </li><li> <p>If T is a record type <strong>#Name{F_1, ..., F_k}</strong>,
where each <strong>F_i</strong> is a record field type, then Rep(T) =
<strong>{type,LINE,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}</strong>.
For Rep(F), see below.</p> </li><li> <p>If T is a remote type <strong>M:N(T_1, ..., T_k)</strong>, then Rep(T) =
<strong>{remote_type,LINE,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}</strong>.</p> </li><li> <p>If T is a tuple type <strong>tuple()</strong>, then Rep(T) =
<strong>{type,LINE,tuple,any}</strong>.</p> </li><li> <p>If T is a tuple type <strong>{T_1, ..., T_k}</strong>, then Rep(T) =
<strong>{type,LINE,tuple,[Rep(T_1), ..., Rep(T_k)]}</strong>.</p> </li><li> <p>If T is a type union <strong>T_1 | ... | T_k</strong>, then Rep(T) =
<strong>{type,LINE,union,[Rep(T_1), ..., Rep(T_k)]}</strong>.</p> </li><li> <p>If T is a type variable <strong>V</strong>, then Rep(T) =
<strong>{var,LINE,A}</strong>, where <strong>A</strong> is an atom with a printname
consisting of the same characters as <strong>V</strong>. A type variable
is any variable except underscore (<strong>_</strong>).</p> </li><li> <p>If T is a user-defined type <strong>N(T_1, ..., T_k)</strong>, then Rep(T) =
<strong>{user_type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}</strong>.</p> </li></ul><h3>Function Types</h3><p>A function type Ft is one of the following:</p><ul><li> <p>If Ft is a constrained function type <strong>Ft_1 when Fc</strong>,
where <strong>Ft_1</strong> is a function type and
<strong>Fc</strong> is a function constraint, then Rep(T) =
<strong>{type,LINE,bounded_fun,[Rep(Ft_1),Rep(Fc)]}</strong>.
For Rep(Fc), see below.</p> </li><li> <p>If Ft is a function type <strong>(T_1, ..., T_n) -&gt; T_0</strong>,
where each <strong>T_i</strong> is a type, then Rep(Ft) =
<strong>{type,LINE,'fun',[{type,LINE,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}</strong>.</p> </li></ul><h3>Function Constraints</h3><p>A function constraint Fc is a non-empty sequence of constraints
<strong>C_1, ..., C_k</strong>, and
Rep(Fc) = <strong>[Rep(C_1), ..., Rep(C_k)]</strong>.</p><ul><li>If C is a constraint <strong>V :: T</strong>, where <strong>V</strong> is a type variable and <strong>T</strong> is a type, then Rep(C) = <strong>{type,LINE,constraint,[{atom,LINE,is_subtype},[Rep(V),Rep(T)]]}</strong>. </li></ul><h3>Association Types</h3><ul><li> <p>If A is an association type <strong>K =&gt; V</strong>,
where <strong>K</strong> and <strong>V</strong> are types, then Rep(A) =
<strong>{type,LINE,map_field_assoc,[Rep(K),Rep(V)]}</strong>.</p> </li><li> <p>If A is an association type <strong>K := V</strong>,
where <strong>K</strong> and <strong>V</strong> are types, then Rep(A) =
<strong>{type,LINE,map_field_exact,[Rep(K),Rep(V)]}</strong>.</p> </li></ul><h3>Record Field Types</h3><ul><li>If F is a record field type <strong>Name :: Type</strong>, where <strong>Type</strong> is a type, then Rep(F) = <strong>{type,LINE,field_type,[Rep(Name),Rep(Type)]}</strong>. </li></ul><h3>The Abstract Format after Preprocessing</h3><p>The compilation option <strong>debug_info</strong> can be specified to the
compiler to have the abstract code stored in
the <strong>abstract_code</strong> chunk in the Beam file
(for debugging purposes).</p><p>As from Erlang/OTP R9C, the <strong>abstract_code</strong> chunk contains
<strong>{raw_abstract_v1,AbstractCode}</strong>, where <strong>AbstractCode</strong> is the
abstract code as described in this section.</p><p>In OTP releases before R9C, the abstract code after some more
processing was stored in the Beam file. The first element of the
tuple would be either <strong>abstract_v1</strong> (in OTP R7B) or
<strong>abstract_v2</strong> (in OTP R8B).</p><p><strong>tty</strong> is a simple command-line interface program where
keystrokes are collected and interpreted. Completed lines are sent to the
shell for interpretation. A simple history mechanism saves previous lines,
which can be edited before sending them to the shell. <strong>tty</strong>
is started when Erlang is started with the following command:</p><pre>
erl</pre><p><strong>tty</strong> operates in one of two modes:</p><ul><li> <p>Normal mode, in which text lines can be edited and sent to the
shell.</p> </li><li> <p>Shell break mode, which allows the user to kill the current shell,
start multiple shells, and so on.</p> </li></ul><h3>Normal Mode</h3><p>In normal mode keystrokes from the user are collected and interpreted by
<strong>tty</strong>. Most of the <em>Emacs</em> line-editing commands
are supported. The following is a complete list of the supported
line-editing commands.</p><p>Typographic conventions:</p><ul><li><strong>C-a</strong> means pressing the <em>Ctrl</em> key and the letter <strong>a</strong> simultaneously.</li><li><strong>M-f</strong> means pressing the <em>Esc</em> key and the letter <strong>f</strong> in sequence.</li><li><strong>Home</strong> and <strong>End</strong> represent the keys with the same name on the keyboard.</li><li><strong>Left</strong> and <strong>Right</strong> represent the corresponding arrow keys.</li></ul><table class="table table-bordered table-hover table-striped"><caption>tty Text Editing</caption><tbody><tr><td><em>Key Sequence</em></td><td><em>Function</em></td></tr><tr><td>Home</td><td>Beginning of line</td></tr><tr><td>C-a</td><td>Beginning of line</td></tr><tr><td>C-b</td><td>Backward character</td></tr><tr><td>C-Left</td><td>Backward word</td></tr><tr><td>M-b</td><td>Backward word</td></tr><tr><td>C-d</td><td>Delete character</td></tr><tr><td>M-d</td><td>Delete word</td></tr><tr><td>End</td><td>End of line</td></tr><tr><td>C-e</td><td>End of line</td></tr><tr><td>C-f</td><td>Forward character</td></tr><tr><td>C-Right</td><td>Forward word</td></tr><tr><td>M-f</td><td>Forward word</td></tr><tr><td>C-g</td><td>Enter shell break mode</td></tr><tr><td>C-k</td><td>Kill line</td></tr><tr><td>C-u</td><td>Backward kill line</td></tr><tr><td>C-l</td><td>Redraw line</td></tr><tr><td>C-n</td><td>Fetch next line from the history buffer</td></tr><tr><td>C-p</td><td>Fetch previous line from the history buffer</td></tr><tr><td>C-t</td><td>Transpose characters</td></tr><tr><td>C-w</td><td>Backward kill word</td></tr><tr><td>C-y</td><td>Insert previously killed text</td></tr><tr><td>C-]</td><td>Insert matching closing bracket</td></tr></tbody></table><h3>Shell Break Mode</h3><p>In this mode the following can be done:</p><ul><li>Kill or suspend the current shell</li><li>Connect to a suspended shell</li><li>Start a new shell</li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This section was written a long time ago. Most of it is still
valid, as it explains important concepts, but this was
written for an older driver interface so the examples do not
work anymore. The reader is encouraged to read the
<a href="erl_driver">erl_driver</a> and
<a href="driver_entry">driver_entry</a>
documentation also.</p></div><h3>Introduction</h3><p>This section describes how to build your own driver for Erlang.</p><p>A driver in Erlang is a library written in C, which is linked to
the Erlang emulator and called from Erlang. Drivers can be used
when C is more suitable than Erlang, to speed up things, or to
provide access to OS resources not directly accessible from Erlang.</p><p>A driver can be dynamically loaded, as a shared library (known as
a DLL on Windows), or statically loaded, linked with the emulator
when it is compiled and linked. Only dynamically loaded drivers
are described here, statically linked drivers are beyond the scope
of this section.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>When a driver is loaded it is executed in the context of the
emulator, shares the same memory and the same thread. This means
that all operations in the driver must be non-blocking, and that
any crash in the driver brings the whole emulator down. In short,
be careful.</p></div><h3>Sample Driver</h3><p>This section describes a simple driver for accessing a postgres
database using the libpq C client library. Postgres
is used because it is free and open source. For information on postgres,
see <a href="http://www.postgres.org">www.postgres.org</a>.</p><p>The driver is synchronous, it uses the synchronous calls of
the client library. This is only for simplicity, but not good, as it
halts the emulator while waiting for the database.
This is improved below with an asynchronous sample driver.</p><p>The code is straightforward: all
communication between Erlang and the driver
is done with <strong>port_control/3</strong>, and the
driver returns data back using the <strong>rbuf</strong>.</p><p>An Erlang driver only exports one function: the driver
entry function. This is defined with a macro,
<strong>DRIVER_INIT</strong>, which returns a pointer to a
C <strong>struct</strong> containing the entry points that are
called from the emulator. The <strong>struct</strong> defines the
entries that the emulator calls to call the driver, with
a <strong>NULL</strong> pointer for entries that are not defined
and used by the driver.</p><p>The <strong>start</strong> entry is called when the driver
is opened as a port with <strong>open_port/2</strong>. Here
we allocate memory for a user data structure.
This user data is passed every time the emulator
calls us. First we store the driver handle, as it
is needed in later calls. We allocate memory for
the connection handle that is used by LibPQ. We also
set the port to return allocated driver binaries, by
setting flag <strong>PORT_CONTROL_FLAG_BINARY</strong>, calling
<strong>set_port_control_flags</strong>. (This is because
we do not know if our data will fit in the
result buffer of <strong>control</strong>, which has a default size,
64 bytes, set up by the emulator.)</p><p>An entry <strong>init</strong> is called when
the driver is loaded. However, we do not use this, as
it is executed only once, and we want to have the
possibility of several instances of the driver.</p><p>The <strong>stop</strong> entry is called when the port
is closed.</p><p>The <strong>control</strong> entry is called from the emulator
when the Erlang code calls <strong>port_control/3</strong>,
to do the actual work. We have defined a simple set of
commands: <strong>connect</strong> to log in to the database,
<strong>disconnect</strong> to log out, and <strong>select</strong>
to send a SQL-query and get the result.
All results are returned through <strong>rbuf</strong>.
The library <strong>ei</strong> in <strong>erl_interface</strong> is
used to encode data in binary term format. The result is returned
to the emulator as binary terms, so <strong>binary_to_term</strong>
is called in Erlang to convert the result to term form.</p><p>The code is available in <strong>pg_sync.c</strong> in the
<strong>sample</strong> directory of <strong>erts</strong>.</p><p>The driver entry contains the functions that
will be called by the emulator. In this example,
only <strong>start</strong>, <strong>stop</strong>,
and <strong>control</strong> are provided:</p><pre><code class="">
/* Driver interface declarations */
static ErlDrvData start(ErlDrvPort port, char *command);
static void stop(ErlDrvData drv_data);
static int control(ErlDrvData drv_data, unsigned int command, char *buf, 
                   int len, char **rbuf, int rlen); 

static ErlDrvEntry pq_driver_entry = {
    NULL,                        /* init */
    start,
    stop,
    NULL,                        /* output */
    NULL,                        /* ready_input */
    NULL,                        /* ready_output */
    "pg_sync",                   /* the name of the driver */
    NULL,                        /* finish */
    NULL,                        /* handle */
    control,
    NULL,                        /* timeout */
    NULL,                        /* outputv */
    NULL,                        /* ready_async */
    NULL,                        /* flush */
    NULL,                        /* call */
    NULL                         /* event */
};
    </code></pre><p>We have a structure to store state needed by the driver,
in this case we only need to keep the database connection:</p><pre><code class="">
typedef struct our_data_s {
    PGconn* conn;
} our_data_t;
    </code></pre><p>The control codes that we have defined are as follows:</p><pre><code class="">
/* Keep the following definitions in alignment with the
 * defines in erl_pq_sync.erl
 */

#define DRV_CONNECT             'C'
#define DRV_DISCONNECT          'D'
#define DRV_SELECT              'S'
    </code></pre><p>This returns the driver structure. The macro
<strong>DRIVER_INIT</strong> defines the only exported function.
All the other functions are static, and will not be exported
from the library.</p><pre><code class="">
/* INITIALIZATION AFTER LOADING */

/* 
 * This is the init function called after this driver has been loaded.
 * It must *not* be declared static. Must return the address to 
 * the driver entry.
 */

DRIVER_INIT(pq_drv)
{
    return &amp;pq_driver_entry;
}
    </code></pre><p>Here some initialization is done, <strong>start</strong> is called from
<strong>open_port</strong>. The data will be passed to
<strong>control</strong> and <strong>stop</strong>.</p><pre><code class="">
/* DRIVER INTERFACE */
static ErlDrvData start(ErlDrvPort port, char *command)
{ 
    our_data_t* data;

    data = (our_data_t*)driver_alloc(sizeof(our_data_t));
    data-&gt;conn = NULL;
    set_port_control_flags(port, PORT_CONTROL_FLAG_BINARY);
    return (ErlDrvData)data;
}
    </code></pre><p>We call disconnect to log out from the database.
(This should have been done from Erlang, but just in case.)</p><pre><code class="">
static int do_disconnect(our_data_t* data, ei_x_buff* x);

static void stop(ErlDrvData drv_data)
{
    our_data_t* data = (our_data_t*)drv_data;

    do_disconnect(data, NULL);
    driver_free(data);
}
    </code></pre><p>We use the binary format only to return data to the emulator;
input data is a string parameter for <strong>connect</strong> and
<strong>select</strong>. The returned data consists of Erlang terms.</p><p>The functions <strong>get_s</strong> and
<strong>ei_x_to_new_binary</strong> are utilities that are used to
make the code shorter. <strong>get_s</strong>
duplicates the string and zero-terminates it, as the
postgres client library wants that. <strong>ei_x_to_new_binary</strong>
takes an <strong>ei_x_buff</strong> buffer, allocates a binary, and
copies the data there. This binary is returned in
<strong>*rbuf</strong>.
(Notice that this binary is freed by the emulator, not by us.)</p><pre><code class="">
static char* get_s(const char* buf, int len);
static int do_connect(const char *s, our_data_t* data, ei_x_buff* x);
static int do_select(const char* s, our_data_t* data, ei_x_buff* x);

/* As we are operating in binary mode, the return value from control
 * is irrelevant, as long as it is not negative.
 */
static int control(ErlDrvData drv_data, unsigned int command, char *buf, 
                   int len, char **rbuf, int rlen)
{
    int r;
    ei_x_buff x;
    our_data_t* data = (our_data_t*)drv_data;
    char* s = get_s(buf, len);
    ei_x_new_with_version(&amp;x);
    switch (command) {
        case DRV_CONNECT:    r = do_connect(s, data, &amp;x);  break;
        case DRV_DISCONNECT: r = do_disconnect(data, &amp;x);  break;
        case DRV_SELECT:     r = do_select(s, data, &amp;x);   break;
        default:             r = -1;        break;
    }
    *rbuf = (char*)ei_x_to_new_binary(&amp;x);
    ei_x_free(&amp;x);
    driver_free(s);
    return r;
}
    </code></pre><p><strong>do_connect</strong> is where we log in to the database. If the
connection was successful, we store the connection handle in the driver
data, and return <strong>'ok'</strong>. Otherwise, we return the error message
from postgres and store <strong>NULL</strong> in the driver data.</p><pre><code class="">
static int do_connect(const char *s, our_data_t* data, ei_x_buff* x)
{
    PGconn* conn = PQconnectdb(s);
    if (PQstatus(conn) != CONNECTION_OK) {
        encode_error(x, conn);
        PQfinish(conn);
        conn = NULL;
    } else {
        encode_ok(x);
    }
    data-&gt;conn = conn;
    return 0;
}
    </code></pre><p>If we are connected (and if the connection handle is not
<strong>NULL</strong>),
we log out from the database. We need to check if we should
encode an <strong>'ok'</strong>, as we can get here from function
<strong>stop</strong>, which does not return data to the emulator:</p><pre><code class="">
static int do_disconnect(our_data_t* data, ei_x_buff* x)
{
    if (data-&gt;conn == NULL)
        return 0;
    PQfinish(data-&gt;conn);
    data-&gt;conn = NULL;
    if (x != NULL)
        encode_ok(x);
    return 0;
}
    </code></pre><p>We execute a query and encode the result. Encoding is done in
another C module, <strong>pg_encode.c</strong>, which is also provided
as sample code.</p><pre><code class="">
static int do_select(const char* s, our_data_t* data, ei_x_buff* x)
{
   PGresult* res = PQexec(data-&gt;conn, s);
    encode_result(x, res, data-&gt;conn);
    PQclear(res);
    return 0;
}
    </code></pre><p>Here we check the result from postgres.
If it is data, we encode it as lists of lists with
column data. Everything from postgres is C strings,
so we use <strong>ei_x_encode_string</strong> to send
the result as strings to Erlang. (The head of the list
contains the column names.)</p><pre><code class="">
void encode_result(ei_x_buff* x, PGresult* res, PGconn* conn)
{
    int row, n_rows, col, n_cols;
    switch (PQresultStatus(res)) {
    case PGRES_TUPLES_OK: 
        n_rows = PQntuples(res); 
        n_cols = PQnfields(res); 
        ei_x_encode_tuple_header(x, 2);
        encode_ok(x);
        ei_x_encode_list_header(x, n_rows+1);
        ei_x_encode_list_header(x, n_cols);
        for (col = 0; col &lt; n_cols; ++col) {
            ei_x_encode_string(x, PQfname(res, col));
        }
        ei_x_encode_empty_list(x); 
        for (row = 0; row &lt; n_rows; ++row) {
            ei_x_encode_list_header(x, n_cols);
            for (col = 0; col &lt; n_cols; ++col) {
                ei_x_encode_string(x, PQgetvalue(res, row, col));
            }
            ei_x_encode_empty_list(x);
        }
        ei_x_encode_empty_list(x); 
        break; 
    case PGRES_COMMAND_OK:
        ei_x_encode_tuple_header(x, 2);
        encode_ok(x);
        ei_x_encode_string(x, PQcmdTuples(res));
        break;
    default:
        encode_error(x, conn);
        break;
    }
}
    </code></pre><h3>Compiling and Linking the Sample Driver</h3><p>The driver is to be compiled and linked to a shared
library (DLL on Windows). With gcc, this is done with
link flags <strong>-shared</strong> and <strong>-fpic</strong>.
As we use the <strong>ei</strong> library, we should include
it too. There are several versions of <strong>ei</strong>, compiled
for debug or non-debug and multi-threaded or single-threaded.
In the makefile for the samples, the <strong>obj</strong> directory
is used for the <strong>ei</strong> library, meaning that we use
the non-debug, single-threaded version.</p><h3>Calling a Driver as a Port in Erlang</h3><p>Before a driver can be called from Erlang, it must be
loaded and opened. Loading is done using the <strong>erl_ddll</strong>
module (the <strong>erl_ddll</strong> driver that loads dynamic
driver is actually a driver itself). If loading is successfull,
the port can be opened with <strong>open_port/2</strong>. The port
name must match the name of the shared library and
the name in the driver entry structure.</p><p>When the port has been opened, the driver can be called. In
the <strong>pg_sync</strong> example, we do not have any data from
the port, only the return value from the
<strong>port_control</strong>.</p><p>The following code is the Erlang part of the synchronous
postgres driver, <strong>pg_sync.erl</strong>:</p><pre><code class="">
-module(pg_sync).

-define(DRV_CONNECT, 1).
-define(DRV_DISCONNECT, 2).
-define(DRV_SELECT, 3).

-export([connect/1, disconnect/1, select/2]).

connect(ConnectStr) -&gt;
    case erl_ddll:load_driver(".", "pg_sync") of
        ok -&gt; ok;
        {error, already_loaded} -&gt; ok;
        E -&gt; exit({error, E})
    end,
    Port = open_port({spawn, ?MODULE}, []),
    case binary_to_term(port_control(Port, ?DRV_CONNECT, ConnectStr)) of
        ok -&gt; {ok, Port};
        Error -&gt; Error
    end.

disconnect(Port) -&gt;
    R = binary_to_term(port_control(Port, ?DRV_DISCONNECT, "")),
    port_close(Port),
    R.

select(Port, Query) -&gt;
    binary_to_term(port_control(Port, ?DRV_SELECT, Query)).
    </code></pre><p>The API is simple:</p><ul><li> <p><strong>connect/1</strong> loads the driver, opens it,
and logs on to the database, returning the Erlang port
if successful.</p> </li><li> <p><strong>select/2</strong> sends a query to the driver
and returns the result.</p> </li><li> <p><strong>disconnect/1</strong> closes the database
connection and the driver. (However, it does not unload it.)</p> </li></ul><p>The connection string is to be a connection string for postgres.</p><p>The driver is loaded with <strong>erl_ddll:load_driver/2</strong>.
If this is successful, or if it is already loaded,
it is opened. This will call the <strong>start</strong> function
in the driver.</p><p>We use the <strong>port_control/3</strong> function for all
calls into the driver. The result from the driver is
returned immediately and converted to terms by calling
<strong>binary_to_term/1</strong>. (We trust that the terms returned
from the driver are well-formed, otherwise the
<strong>binary_to_term</strong> calls could be contained in a
<strong>catch</strong>.)</p><h3>Sample Asynchronous Driver</h3><p>Sometimes database queries can take a long time to
complete, in our <strong>pg_sync</strong> driver, the emulator
halts while the driver is doing its job. This is
often not acceptable, as no other Erlang process
gets a chance to do anything. To improve on our
postgres driver, we re-implement it using the asynchronous
calls in LibPQ.</p><p>The asynchronous version of the driver is in the sample files
<strong>pg_async.c</strong> and <strong>pg_asyng.erl</strong>.</p><pre><code class="">
/* Driver interface declarations */
static ErlDrvData start(ErlDrvPort port, char *command);
static void stop(ErlDrvData drv_data);
static int control(ErlDrvData drv_data, unsigned int command, char *buf, 
                   int len, char **rbuf, int rlen); 
static void ready_io(ErlDrvData drv_data, ErlDrvEvent event);

static ErlDrvEntry pq_driver_entry = {
    NULL,                     /* init */
    start, 
    stop, 
    NULL,                     /* output */
    ready_io,                 /* ready_input */
    ready_io,                 /* ready_output */ 
    "pg_async",               /* the name of the driver */
    NULL,                     /* finish */
    NULL,                     /* handle */
    control, 
    NULL,                     /* timeout */
    NULL,                     /* outputv */
    NULL,                     /* ready_async */
    NULL,                     /* flush */
    NULL,                     /* call */
    NULL                      /* event */
};

typedef struct our_data_t {
    PGconn* conn;
    ErlDrvPort port;
    int socket;
    int connecting;
} our_data_t;
    </code></pre><p>Some things have changed from <strong>pg_sync.c</strong>: we use
the entry <strong>ready_io</strong> for <strong>ready_input</strong>
and <strong>ready_output</strong>, which is called from the emulator
only when there is input to be read from the socket. (Actually, the
socket is used in a <strong>select</strong> function inside
the emulator, and when the socket is signaled,
indicating there is data to read, the <strong>ready_input</strong>
entry is called. More about this below.)</p><p>Our driver data is also extended, we keep track of the
socket used for communication with postgres, and also
the port, which is needed when we send data to the port with
<strong>driver_output</strong>. We have a flag
<strong>connecting</strong> to tell
whether the driver is waiting for a connection or waiting
for the result of a query. (This is needed, as the entry
<strong>ready_io</strong> is called both when connecting and
when there is a query result.)</p><pre><code class="">
static int do_connect(const char *s, our_data_t* data)
{
    PGconn* conn = PQconnectStart(s);
    if (PQstatus(conn) == CONNECTION_BAD) {
        ei_x_buff x;
        ei_x_new_with_version(&amp;x);
        encode_error(&amp;x, conn);
        PQfinish(conn);
        conn = NULL;
        driver_output(data-&gt;port, x.buff, x.index);
        ei_x_free(&amp;x);
    }
    PQconnectPoll(conn);
    int socket = PQsocket(conn);
    data-&gt;socket = socket;
    driver_select(data-&gt;port, (ErlDrvEvent)socket, DO_READ, 1);
    driver_select(data-&gt;port, (ErlDrvEvent)socket, DO_WRITE, 1);
    data-&gt;conn = conn;
    data-&gt;connecting = 1;
    return 0;
}
    </code></pre><p>The <strong>connect</strong> function looks a bit different too. We
connect using the asynchronous <strong>PQconnectStart</strong> function.
After the connection is started, we retrieve the socket for the connection
with <strong>PQsocket</strong>. This socket is used with the
<strong>driver_select</strong> function to wait for connection. When
the socket is ready for input or for output, the
<strong>ready_io</strong> function is called.</p><p>Notice that we only return data (with <strong>driver_output</strong>)
if there
is an error here, otherwise we wait for the connection to be completed,
in which case our <strong>ready_io</strong> function is called.</p><pre><code class="">
static int do_select(const char* s, our_data_t* data)
{
    data-&gt;connecting = 0;
    PGconn* conn = data-&gt;conn;
    /* if there's an error return it now */
    if (PQsendQuery(conn, s) == 0) {
        ei_x_buff x;
        ei_x_new_with_version(&amp;x);
        encode_error(&amp;x, conn);
        driver_output(data-&gt;port, x.buff, x.index);
        ei_x_free(&amp;x);
    }
    /* else wait for ready_output to get results */
    return 0;
}
    </code></pre><p>The <strong>do_select</strong> function initiates a select, and returns
if there is no immediate error. The result is returned
when <strong>ready_io</strong> is called.</p><pre><code class="">
static void ready_io(ErlDrvData drv_data, ErlDrvEvent event)
{
    PGresult* res = NULL;
    our_data_t* data = (our_data_t*)drv_data;
    PGconn* conn = data-&gt;conn;
    ei_x_buff x;
    ei_x_new_with_version(&amp;x);
    if (data-&gt;connecting) {
        ConnStatusType status;
        PQconnectPoll(conn);
        status = PQstatus(conn);
        if (status == CONNECTION_OK)
            encode_ok(&amp;x);
        else if (status == CONNECTION_BAD)
            encode_error(&amp;x, conn);
    } else {
        PQconsumeInput(conn);
        if (PQisBusy(conn))
            return;
        res = PQgetResult(conn);
        encode_result(&amp;x, res, conn);
        PQclear(res);
        for (;;) {
            res = PQgetResult(conn);
            if (res == NULL)
                break;
            PQclear(res);
        }
    }
    if (x.index &gt; 1) {
        driver_output(data-&gt;port, x.buff, x.index);
        if (data-&gt;connecting) 
            driver_select(data-&gt;port, (ErlDrvEvent)data-&gt;socket, DO_WRITE, 0);
    }
    ei_x_free(&amp;x);
}
    </code></pre><p>The <strong>ready_io</strong> function is called when the socket
we got from postgres is ready for input or output. Here
we first check if we are connecting to the database. In that
case, we check connection status and return OK if the 
connection is successful, or error if it is not. If the
connection is not yet established, we simply return;
<strong>ready_io</strong> is called again.</p><p>If we have a result from a connect, indicated by having data in
the <strong>x</strong> buffer, we no longer need to select on
output (<strong>ready_output</strong>), so we remove this by calling
<strong>driver_select</strong>.</p><p>If we are not connecting, we wait for results from a
<strong>PQsendQuery</strong>, so we get the result and return it. The
encoding is done with the same functions as in the earlier
example.</p><p>Error handling is to be added here, for example, checking
that the socket is still open, but this is only a simple example.</p><p>The Erlang part of the asynchronous driver consists of the
sample file <strong>pg_async.erl</strong>.</p><pre><code class="">
-module(pg_async).

-define(DRV_CONNECT, $C).
-define(DRV_DISCONNECT, $D).
-define(DRV_SELECT, $S).

-export([connect/1, disconnect/1, select/2]).

connect(ConnectStr) -&gt;
    case erl_ddll:load_driver(".", "pg_async") of
        ok -&gt; ok;
        {error, already_loaded} -&gt; ok;
        _ -&gt; exit({error, could_not_load_driver})
    end,
    Port = open_port({spawn, ?MODULE}, [binary]),
    port_control(Port, ?DRV_CONNECT, ConnectStr),
    case return_port_data(Port) of
        ok -&gt; 
            {ok, Port};
        Error -&gt;
            Error
    end.    

disconnect(Port) -&gt;
    port_control(Port, ?DRV_DISCONNECT, ""),
    R = return_port_data(Port),
    port_close(Port),
    R.

select(Port, Query) -&gt;
    port_control(Port, ?DRV_SELECT, Query),
    return_port_data(Port).

return_port_data(Port) -&gt;
    receive
        {Port, {data, Data}} -&gt;
            binary_to_term(Data)
    end.
    </code></pre><p>The Erlang code is slightly different, as we do not
return the result synchronously from <strong>port_control</strong>,
instead we get it from <strong>driver_output</strong> as data in the
message queue. The function <strong>return_port_data</strong> above
receives data from the port. As the data is in
binary format, we use <strong>binary_to_term/1</strong> to convert
it to an Erlang term. Notice that the driver is opened in
binary mode (<strong>open_port/2</strong> is called with option
<strong>[binary]</strong>). This means that data sent from the driver
to the emulator is sent as binaries. Without option
<strong>binary</strong>, they would have been lists of integers.</p><h3>An Asynchronous Driver Using driver_async</h3><p>As a final example we demonstrate the use of
<strong>driver_async</strong>.
We also use the driver term interface. The driver is written
in C++. This enables us to use an algorithm from STL. We use
the <strong>next_permutation</strong> algorithm to get the next
permutation of a list of integers. For large lists (&gt; 100,000
elements), this takes some time, so we perform this
as an asynchronous task.</p><p>The asynchronous API for drivers is complicated. First,
the work must be prepared. In the example, this is done in
<strong>output</strong>. We could have used <strong>control</strong>,
but we want some variation in the examples. In our driver, we allocate
a structure that contains anything that is needed for the asynchronous
task to do the work. This is done in the main emulator thread.
Then the asynchronous function is called from a driver thread,
separate from the main emulator thread. Notice that the driver functions
are not re-entrant, so they are not to be used.
Finally, after the function is completed, the driver callback
<strong>ready_async</strong> is called from the main emulator thread,
this is where we return the result to Erlang. (We cannot
return the result from within the asynchronous function, as
we cannot call the driver functions.)</p><p>The following code is from the sample file
<strong>next_perm.cc</strong>. The driver entry looks like before,
but also contains the callback <strong>ready_async</strong>.</p><pre><code class="">
static ErlDrvEntry next_perm_driver_entry = {
    NULL,                        /* init */
    start,
    NULL,                        /* stop */
    output,
    NULL,                        /* ready_input */
    NULL,                        /* ready_output */ 
    "next_perm",                 /* the name of the driver */
    NULL,                        /* finish */
    NULL,                        /* handle */
    NULL,                        /* control */
    NULL,                        /* timeout */
    NULL,                        /* outputv */
    ready_async,
    NULL,                        /* flush */
    NULL,                        /* call */
    NULL                         /* event */
};
    </code></pre><p>The <strong>output</strong> function allocates the work area of the
asynchronous function. As we use C++, we use a struct,
and stuff the data in it. We must copy the original data,
it is not valid after we have returned from the <strong>output</strong>
function, and the <strong>do_perm</strong> function is called
later, and from another thread. We return no data here, instead it
is sent later from the <strong>ready_async</strong> callback.</p><p>The <strong>async_data</strong> is passed to the
<strong>do_perm</strong> function. We do not use a
<strong>async_free</strong> function (the last argument to
<strong>driver_async</strong>), it is only used if the task is cancelled
programmatically.</p><pre><code class="">
struct our_async_data {
    bool prev;
    vector&lt;int&gt; data;
    our_async_data(ErlDrvPort p, int command, const char* buf, int len);
};

our_async_data::our_async_data(ErlDrvPort p, int command,
                               const char* buf, int len)
    : prev(command == 2),
      data((int*)buf, (int*)buf + len / sizeof(int))
{
}

static void do_perm(void* async_data);

static void output(ErlDrvData drv_data, char *buf, int len)
{
    if (*buf &lt; 1 || *buf &gt; 2) return;
    ErlDrvPort port = reinterpret_cast&lt;ErlDrvPort&gt;(drv_data);
    void* async_data = new our_async_data(port, *buf, buf+1, len);
    driver_async(port, NULL, do_perm, async_data, do_free);
}
    </code></pre><p>In the <strong>do_perm</strong> we do the work, operating
on the structure that was allocated in <strong>output</strong>.</p><pre><code class="">
static void do_perm(void* async_data)
{
    our_async_data* d = reinterpret_cast&lt;our_async_data*&gt;(async_data);
    if (d-&gt;prev)
        prev_permutation(d-&gt;data.begin(), d-&gt;data.end());
    else
        next_permutation(d-&gt;data.begin(), d-&gt;data.end());
}
    </code></pre><p>In the <strong>ready_async</strong> function the output is sent back
to the
emulator. We use the driver term format instead of <strong>ei</strong>.
This is the only way to send Erlang terms directly to a driver, without
having the Erlang code to call <strong>binary_to_term/1</strong>. In
the simple example this works well, and we do not need to use
<strong>ei</strong> to handle the binary term format.</p><p>When the data is returned, we deallocate our data.</p><pre><code class="">
static void ready_async(ErlDrvData drv_data, ErlDrvThreadData async_data)
{
    ErlDrvPort port = reinterpret_cast&lt;ErlDrvPort&gt;(drv_data);
    our_async_data* d = reinterpret_cast&lt;our_async_data*&gt;(async_data);
    int n = d-&gt;data.size(), result_n = n*2 + 3;
    ErlDrvTermData *result = new ErlDrvTermData[result_n], *rp = result;
    for (vector&lt;int&gt;::iterator i = d-&gt;data.begin();
         i != d-&gt;data.end(); ++i) {
        *rp++ = ERL_DRV_INT;
        *rp++ = *i;
    }
    *rp++ = ERL_DRV_NIL;
    *rp++ = ERL_DRV_LIST;
    *rp++ = n+1;
    driver_output_term(port, result, result_n);    
    delete[] result;
    delete d;
}
    </code></pre><p>This driver is called like the others from Erlang. However, as
we use <strong>driver_output_term</strong>, there is no need to call
<strong>binary_to_term</strong>. The Erlang code is in the sample file
<strong>next_perm.erl</strong>.</p><p>The input is changed into a list of integers and sent to
the driver.</p><pre><code class="">
-module(next_perm).

-export([next_perm/1, prev_perm/1, load/0, all_perm/1]).

load() -&gt;
    case whereis(next_perm) of
        undefined -&gt;
            case erl_ddll:load_driver(".", "next_perm") of
                ok -&gt; ok;
                {error, already_loaded} -&gt; ok;
                E -&gt; exit(E)
            end,
            Port = open_port({spawn, "next_perm"}, []),
            register(next_perm, Port);
        _ -&gt;
            ok
    end.

list_to_integer_binaries(L) -&gt;
    [&lt;&lt;I:32/integer-native&gt;&gt; || I &lt;- L].

next_perm(L) -&gt;
    next_perm(L, 1).

prev_perm(L) -&gt;
    next_perm(L, 2).

next_perm(L, Nxt) -&gt;
    load(),
    B = list_to_integer_binaries(L),
    port_control(next_perm, Nxt, B),
    receive
        Result -&gt;
            Result
    end.

all_perm(L) -&gt;
    New = prev_perm(L),
    all_perm(New, L, [New]).

all_perm(L, L, Acc) -&gt;
    Acc;
all_perm(L, Orig, Acc) -&gt;
    New = prev_perm(L),
    all_perm(New, Orig, [New | Acc]).
    </code></pre><h3>Introduction</h3><p>This section describes how the Erlang runtime system is configured
for IP communication. It also explains how you can configure it
for your needs by a configuration file.
The information is primarily intended for users with special
configuration needs or problems. There is normally no need
for specific settings for Erlang to function properly on a correctly
IP-configured platform.</p><p>When Erlang starts up it reads the Kernel variable
<strong>inetrc</strong>, which, if defined, is to specify the location
and name of a user configuration file. Example:</p><pre><code class="">
% erl -kernel inetrc '"./cfg_files/erl_inetrc"'</code></pre><p>Notice that the use of an <strong>.inetrc</strong> file, which was
supported in earlier Erlang/OTP versions, is now obsolete.</p><p>A second way to specify the configuration file is to set
environment variable <strong>ERL_INETRC</strong> to the full name of
the file. Example (bash):</p><pre><code class="">
% export ERL_INETRC=./cfg_files/erl_inetrc</code></pre><p>Notice that the Kernel variable <strong>inetrc</strong>
overrides this environment variable.</p><p>If no user configuration file is specified and Erlang is started
in non-distributed or short name distributed mode, Erlang uses
default configuration settings and a native lookup method that
works correctly under most circumstances. Erlang reads no
information from system <strong>inet</strong> configuration files (such as 
<strong>/etc/host.conf</strong> and <strong>/etc/nsswitch.conf</strong>) in these modes,
except for <strong>/etc/resolv.conf</strong> and <strong>/etc/hosts</strong> that is read and
monitored for changes on Unix platforms for the internal DNS client
<a href="./inet_res">kernel/inet_res</a>.</p><p>If Erlang is started in long name distributed mode, it needs to
get the domain name from somewhere and reads system <strong>inet</strong>
configuration files for this information. Any hosts and resolver
information found is also recorded, but not
used as long as Erlang is configured for native lookups. The
information becomes useful if the lookup method is changed to 
<strong>'file'</strong> or <strong>'dns'</strong>, see below.</p><p>Native lookup (system calls) is always the default resolver method.
This is true for all platforms, except VxWorks and OSE Delta where
<strong>'file'</strong> or <strong>'dns'</strong> is used (in that
priority order).</p><p>On Windows platforms, Erlang searches the system registry rather than
looks for configuration files when started in long name distributed
mode.</p><h3>Configuration Data</h3><p>Erlang records the following data in a local database if found in system 
<strong>inet</strong> configuration files (or system registry):</p><ul><li>Hostnames and host addresses</li><li>Domain name</li><li>Nameservers</li><li>Search domains</li><li>Lookup method</li></ul><p>This data can also be specified explicitly in the user
configuration file. This file is to contain lines
of configuration parameters (each terminated with a full stop).
Some parameters add data to the configuration (such as host
and nameserver), others overwrite any previous settings
(such as domain and lookup). The user configuration file is always
examined last in the configuration process, making it possible
for the user to override any default values or previously made
settings. Call <strong>inet:get_rc()</strong> to view the state of the
<strong>inet</strong> configuration database.</p><p>The valid configuration parameters are as follows:</p><dl><dt><strong>{file, Format, File}.</strong></dt><dd> <p><strong>Format = atom()</strong></p> <p><strong>File = string()</strong></p> <p>Specify a system file that Erlang is to read configuration data from.
<strong>Format</strong> tells the parser how the file is to be
interpreted:</p> <ul><li><strong>resolv</strong> (Unix resolv.conf)</li><li><strong>host_conf_freebsd</strong> (FreeBSD host.conf)</li><li><strong>host_conf_bsdos</strong> (BSDOS host.conf)</li><li><strong>host_conf_linux</strong> (Linux host.conf)</li><li><strong>nsswitch_conf</strong> (Unix nsswitch.conf)</li><li><strong>hosts</strong> (Unix hosts)</li></ul> <p><strong>File</strong> is to specify the filename with full
path.</p> </dd><dt><strong>{resolv_conf, File}.</strong></dt><dd> <p><strong>File = string()</strong></p> <p>Specify a system file that Erlang is to read resolver
configuration from for the internal DNS client
<a href="./inet_res">kernel/inet_res</a>,
and monitor for changes, even if it does not exist.
The path must be absolute.</p> <p>This can override the configuration parameters
<strong>nameserver</strong> and
<strong>search</strong> depending on the contents
of the specified file. They can also change any time in the future
reflecting the file contents.</p> <p>If the file is specified as an empty string <strong>""</strong>,
no file is read or monitored in the future. This emulates
the old behavior of not configuring the DNS client when
the node is started in short name distributed mode.</p> <p>If this parameter is not specified, it defaults to
<strong>/etc/resolv.conf</strong> unless environment variable
<strong>ERL_INET_ETC_DIR</strong> is set, which defines
the directory for this file to some maybe other than
<strong>/etc</strong>.</p> </dd><dt><strong>{hosts_file, File}.</strong></dt><dd> <p><strong>File = string()</strong></p> <p>Specify a system file that Erlang is to read resolver
configuration from for the internal hosts file resolver,
and monitor for changes, even if it does not exist.
The path must be absolute.</p> <p>These host entries are searched after all added with
<strong>{file, hosts, File}</strong> above or
<strong>{host, IP, Aliases}</strong> below when lookup option
<strong>file</strong> is used.</p> <p>If the file is specified as an empty string <strong>""</strong>,
no file is read or monitored in the future. This emulates
the old behavior of not configuring the DNS client when
the node is started in short name distributed mode.</p> <p>If this parameter is not specified, it defaults to
<strong>/etc/hosts</strong> unless environment variable
<strong>ERL_INET_ETC_DIR</strong> is set, which defines
the directory for this file to some maybe other than
<strong>/etc</strong>.</p> </dd><dt><strong>{registry, Type}.</strong></dt><dd> <p><strong>Type = atom()</strong></p> <p>Specify a system registry that Erlang is to read configuration
data from. <strong>win32</strong> is the only valid option.</p> </dd><dt><strong>{host, IP, Aliases}.</strong></dt><dd> <p><strong>IP = tuple()</strong></p> <p><strong>Aliases = [string()]</strong></p> <p>Add host entry to the hosts table.</p> </dd><dt><strong>{domain, Domain}.</strong></dt><dd> <p><strong>Domain = string()</strong></p> <p>Set domain name.</p> </dd><dt><strong>{nameserver, IP [,Port]}.</strong></dt><dd> <p><strong>IP = tuple()</strong></p> <p><strong>Port = integer()</strong></p> <p>Add address (and port, if other than default) of the primary
nameserver to use for
<a href="./inet_res">kernel/inet_res</a>.
</p> </dd><dt><strong>{alt_nameserver, IP [,Port]}.</strong></dt><dd> <p><strong>IP = tuple()</strong></p> <p><strong>Port = integer()</strong></p> <p>Add address (and port, if other than default) of the secondary
nameserver for
<a href="./inet_res">kernel/inet_res</a>.
</p> </dd><dt><strong>{search, Domains}.</strong></dt><dd> <p><strong>Domains = [string()]</strong></p> <p>Add search domains for
<a href="./inet_res">kernel/inet_res</a>.
</p> </dd><dt><strong>{lookup, Methods}.</strong></dt><dd> <p><strong>Methods = [atom()]</strong></p> <p>Specify lookup methods and in which order to try them.
The valid methods are as follows:</p> <ul><li><strong>native</strong> (use system calls)</li><li><strong>file</strong> (use host data retrieved from system configuration files and/or the user configuration file)</li><li><strong>dns</strong> (use the Erlang DNS client <a href="./inet_res">kernel/inet_res</a> for nameserver queries)</li></ul> <p>The lookup method <strong>string</strong> tries to
parse the hostname as an IPv4 or IPv6 string and return
the resulting IP address. It is automatically tried
first when <strong>native</strong> is <em>not</em>
in the <strong>Methods</strong> list. To skip it in this case,
the pseudo lookup method <strong>nostring</strong> can be
inserted anywhere in the <strong>Methods</strong> list.</p> </dd><dt><strong>{cache_size, Size}.</strong></dt><dd> <p><strong>Size = integer()</strong></p> <p>Set the resolver cache size. Defaults to 100 DNS records.</p> </dd><dt><strong>{cache_refresh, Time}.</strong></dt><dd> <p><strong>Time = integer()</strong></p> <p>Set how often (in milliseconds) the resolver cache for
<a href="./inet_res">kernel/inet_res</a>
is refreshed (that is, expired DNS records are deleted).
Defaults to 1 hour.</p> </dd><dt><strong>{timeout, Time}.</strong></dt><dd> <p><strong>Time = integer()</strong></p> <p>Set the time to wait until retry (in milliseconds) for DNS queries
made by
<a href="./inet_res">kernel/inet_res</a>.
Defaults to 2 seconds.</p> </dd><dt><strong>{retry, N}.</strong></dt><dd> <p><strong>N = integer()</strong></p> <p>Set the number of DNS queries
<a href="./inet_res">kernel/inet_res</a>
will try before giving up. Defaults to 3.</p> </dd><dt><strong>{inet6, Bool}.</strong></dt><dd> <p><strong>Bool = true | false</strong></p> <p>Tells the DNS client
<a href="./inet_res">kernel/inet_res</a>
to look up IPv6 addresses. Defaults to <strong>false</strong>.</p> </dd><dt><strong>{usevc, Bool}.</strong></dt><dd> <p><strong>Bool = true | false</strong></p> <p>Tells the DNS client
<a href="./inet_res">kernel/inet_res</a>
to use TCP (Virtual Circuit) instead of UDP. Defaults to
<strong>false</strong>.</p> </dd><dt><strong>{edns, Version}.</strong></dt><dd> <p><strong>Version = false | 0</strong></p> <p>Sets the EDNS version that
<a href="./inet_res">kernel/inet_res</a>
will use. The only allowed version is zero. Defaults to <strong>false</strong>,
which means not to use EDNS.</p> </dd><dt><strong>{udp_payload_size, Size}.</strong></dt><dd> <p><strong>N = integer()</strong></p> <p>Sets the allowed UDP payload size
<a href="./inet_res">kernel/inet_res</a>
will advertise in EDNS queries. Also sets the limit
when the DNS query will be deemed too large for UDP
forcing a TCP query instead; this  is not entirely
correct, as the advertised UDP payload size of the
individual nameserver is what is to be used,
but this simple strategy will do until a more intelligent
(probing, caching) algorithm needs to be implemented.
Default to 1280, which stems from the standard Ethernet MTU size.</p> </dd><dt><strong>{udp, Module}.</strong></dt><dd> <p><strong>Module = atom()</strong></p> <p>Tell Erlang to use another primitive UDP module than
<strong>inet_udp</strong>.</p> </dd><dt><strong>{tcp, Module}.</strong></dt><dd> <p><strong>Module = atom()</strong></p> <p>Tell Erlang to use another primitive TCP module than
<strong>inet_tcp</strong>.</p> </dd><dt><strong>clear_hosts.</strong></dt><dd> <p>Clear the hosts table.</p> </dd><dt><strong>clear_ns.</strong></dt><dd> <p>Clear the list of recorded nameservers (primary and secondary).</p> </dd><dt><strong>clear_search.</strong></dt><dd> <p>Clear the list of search domains.</p> </dd></dl><h3>User Configuration Example</h3><p>Assume that a user does not want Erlang to use the native lookup method,
but wants Erlang to read all information necessary from start and use
that for resolving names and addresses. If lookup fails, Erlang
is to request the data from a nameserver (using the Erlang
DNS client, set to use EDNS allowing larger responses).
The resolver configuration is updated when
its configuration file changes. Also, DNS records
are never to be cached. The user configuration file
(in this example named <strong>erl_inetrc</strong>, stored
in directory <strong>./cfg_files</strong>) can then look as follows
(Unix):</p><pre>
%% -- ERLANG INET CONFIGURATION FILE --
%% read the hosts file
{file, hosts, "/etc/hosts"}.
%% add a particular host
{host, {134,138,177,105}, ["finwe"]}.
%% do not monitor the hosts file
{hosts_file, ""}.
%% read and monitor nameserver config from here
{resolv_conf, "/usr/local/etc/resolv.conf"}.
%% enable EDNS
{edns,0}.
%% disable caching
{cache_size, 0}.
%% specify lookup method
{lookup, [file, dns]}.</pre><p>And Erlang can, for example, be started as follows:</p><pre><code class="">
% erl -sname my_node -kernel inetrc '"./cfg_files/erl_inetrc"'</code></pre><h3>Introduction</h3><p>The socket interface (module) is basically an "thin" layer on top of
the OS socket interface. It is assumed that, unless you have special needs,
gen_[tcp|udp|sctp] should be sufficent. </p><p>Note that just because we have a documented and described option,
it does <em>not</em> mean that the OS supports it. So its recommended
that the user reads the platform specific documentation for the
option used. </p><a name="socket_options"></a><h3>Socket Options</h3><p>Options for level <strong>otp</strong>: </p><table class="table table-bordered table-hover table-striped"><caption>option levels</caption><tbody><tr><td><em>Option Name</em></td><td><em>Value Type</em></td><td><em>Set</em></td><td><em>Get</em></td><td><em>Other Requirements and comments</em></td></tr><tr><td>assoc_id</td><td>integer()</td><td>no</td><td>yes</td><td>type = seqpacket, protocol = sctp, is an association</td></tr><tr><td>debug</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>iow</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>controlling_process</td><td>pid()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>rcvbuf</td><td>default | pos_integer() | {pos_integer(), pos_ineteger()}</td><td>yes</td><td>yes</td><td>'default' only valid for set. The tuple form is only valid for type 'stream' and protocol 'tcp'.</td></tr><tr><td>rcvctrlbuf</td><td>default | pos_integer()</td><td>yes</td><td>yes</td><td>default only valid for set</td></tr><tr><td>sndctrlbuf</td><td>default | pos_integer()</td><td>yes</td><td>yes</td><td>default only valid for set</td></tr><tr><td>fd</td><td>integer()</td><td>no</td><td>yes</td><td>none</td></tr></tbody></table><p>Options for level <strong>socket</strong>: </p><table class="table table-bordered table-hover table-striped"><caption>socket options</caption><tbody><tr><td><em>Option Name</em></td><td><em>Value Type</em></td><td><em>Set</em></td><td><em>Get</em></td><td><em>Other Requirements and comments</em></td></tr><tr><td>acceptcon</td><td>boolean()</td><td>no</td><td>yes</td><td>none</td></tr><tr><td>bindtodevice</td><td>string()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>broadcast</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram</td></tr><tr><td>debug</td><td>integer()</td><td>yes</td><td>yes</td><td>requires admin capability</td></tr><tr><td>domain</td><td>domain()</td><td>no</td><td>yes</td><td><em>Not</em> on FreeBSD (for instance)</td></tr><tr><td>dontroute</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>keepalive</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>linger</td><td>abort | linger()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>oobinline</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>peek_off</td><td>integer()</td><td>yes</td><td>yes</td><td>domain = local (unix)</td></tr><tr><td>priority</td><td>integer()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>protocol</td><td>protocol()</td><td>no</td><td>yes</td><td>none</td></tr><tr><td>rcvbuf</td><td>non_neg_integer()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>rcvlowat</td><td>non_neg_integer()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>rcvtimeo</td><td>timeval()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>reuseaddr</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>reuseport</td><td>boolean()</td><td>yes</td><td>yes</td><td>domain = inet | inet6</td></tr><tr><td>sndbuf</td><td>non_neg_integer()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>sndlowat</td><td>non_neg_integer()</td><td>yes</td><td>yes</td><td>not changeable on Linux</td></tr><tr><td>sndtimeo</td><td>timeval()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>timestamp</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>type</td><td>type()</td><td>no</td><td>yes</td><td>none</td></tr></tbody></table><p>Options for level <strong>ip</strong>: </p><table class="table table-bordered table-hover table-striped"><caption>ip options</caption><tbody><tr><td><em>Option Name</em></td><td><em>Value Type</em></td><td><em>Set</em></td><td><em>Get</em></td><td><em>Other Requirements and comments</em></td></tr><tr><td>add_membership</td><td>ip_mreq()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>add_source_membership</td><td>ip_mreq_source()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>block_source</td><td>ip_mreq_source()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>drop_membership</td><td>ip_mreq()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>drop_source_membership</td><td>ip_mreq_source()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>freebind</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>hdrincl</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = raw</td></tr><tr><td>minttl</td><td>integer()</td><td>yes</td><td>yes</td><td>type = raw</td></tr><tr><td>msfilter</td><td>null | ip_msfilter()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>mtu</td><td>integer()</td><td>no</td><td>yes</td><td>type = raw</td></tr><tr><td>mtu_discover</td><td>ip_pmtudisc()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>multicast_all</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>multicast_if</td><td>any | ip4_address()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>multicast_loop</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>multicast_ttl</td><td>uint8()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>nodefrag</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = raw</td></tr><tr><td>pktinfo</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram</td></tr><tr><td>recvdstaddr</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram</td></tr><tr><td>recverr</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>recvif</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram | raw</td></tr><tr><td>recvopts</td><td>boolean()</td><td>yes</td><td>yes</td><td>type =/= stream</td></tr><tr><td>recvorigdstaddr</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>recvttl</td><td>boolean()</td><td>yes</td><td>yes</td><td>type =/= stream</td></tr><tr><td>retopts</td><td>boolean()</td><td>yes</td><td>yes</td><td>type =/= stream</td></tr><tr><td>router_alert</td><td>integer()</td><td>yes</td><td>yes</td><td>type = raw</td></tr><tr><td>sendsrcaddr</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>tos</td><td>ip_tos()</td><td>yes</td><td>yes</td><td>some high-priority levels may require superuser capability</td></tr><tr><td>transparent</td><td>boolean()</td><td>yes</td><td>yes</td><td>requires admin capability</td></tr><tr><td>ttl</td><td>integer()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>unblock_source</td><td>ip_mreq_source()</td><td>yes</td><td>no</td><td>none</td></tr></tbody></table><p>Options for level <strong>ipv6</strong>: </p><table class="table table-bordered table-hover table-striped"><caption>ipv6 options</caption><tbody><tr><td><em>Option Name</em></td><td><em>Value Type</em></td><td><em>Set</em></td><td><em>Get</em></td><td><em>Other Requirements and comments</em></td></tr><tr><td>addrform</td><td>inet</td><td>yes</td><td>no</td><td>allowed only for IPv6 sockets that are connected and bound to a v4-mapped-on-v6 address</td></tr><tr><td>add_membership</td><td>ipv6_mreq()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>authhdr</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram | raw, obsolete?</td></tr><tr><td>drop_membership</td><td>ipv6_mreq()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>dstopts</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram | raw, requires superuser privileges to update</td></tr><tr><td>flowinfo</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram | raw, requires superuser privileges to update</td></tr><tr><td>hoplimit</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram | raw, requires superuser privileges to update</td></tr><tr><td>hopopts</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram | raw, requires superuser privileges to update</td></tr><tr><td>mtu</td><td>boolean()</td><td>yes</td><td>yes</td><td>Get: Only after the socket has been connected</td></tr><tr><td>mtu_discover</td><td>ipv6_pmtudisc()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>multicast_hops</td><td>default | uint8()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>multicast_if</td><td>integer()</td><td>yes</td><td>yes</td><td>type = dgram | raw</td></tr><tr><td>multicast_loop</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>recverr</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>recvpktinfo | pktinfo</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram | raw</td></tr><tr><td>router_alert</td><td>integer()</td><td>yes</td><td>yes</td><td>type = raw</td></tr><tr><td>rthdr</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram | raw, requires superuser privileges to update</td></tr><tr><td>unicast_hops</td><td>default | uint8()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>v6only</td><td>boolean()</td><td>yes</td><td>no</td><td>none</td></tr></tbody></table><p>Options for level <strong>tcp</strong>: </p><table class="table table-bordered table-hover table-striped"><caption>tcp options</caption><tbody><tr><td><em>Option Name</em></td><td><em>Value Type</em></td><td><em>Set</em></td><td><em>Get</em></td><td><em>Other Requirements and comments</em></td></tr><tr><td>congestion</td><td>string()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>maxseg</td><td>integer()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>nodelay</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr></tbody></table><p>Options for level <strong>udp</strong>: </p><table class="table table-bordered table-hover table-striped"><caption>udp options</caption><tbody><tr><td><em>Option Name</em></td><td><em>Value Type</em></td><td><em>Set</em></td><td><em>Get</em></td><td><em>Other Requirements and comments</em></td></tr><tr><td>cork</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr></tbody></table><p>Options for level <strong>sctp</strong>: </p><table class="table table-bordered table-hover table-striped"><caption>sctp options</caption><tbody><tr><td><em>Option Name</em></td><td><em>Value Type</em></td><td><em>Set</em></td><td><em>Get</em></td><td><em>Other Requirements and comments</em></td></tr><tr><td>associnfo</td><td>sctp_assocparams()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>autoclose</td><td>non_neg_integer()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>disable_fragments</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>events</td><td>sctp_event_subscribe()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>initmsg</td><td>sctp_initmsg()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>maxseg</td><td>non_neg_integer()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>nodelay</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>rtoinfo</td><td>sctp_rtoinfo()</td><td>yes</td><td>yes</td><td>none</td></tr></tbody></table><h3>Introduction</h3><p>
The external term format is mainly used in the distribution
mechanism of Erlang.
</p><p>
As Erlang has a fixed number of types, there is no need for a
programmer to define a specification for the external format used
within some application.
All Erlang terms have an external representation and the interpretation
of the different terms is application-specific.
</p><p>
In Erlang the BIF <a href="../erts/erlang#term_to_binary/1">erts/erlang#term_to_binary/1</a> is used to convert a
term into the external format.
To convert binary data encoding to a term, the BIF
<a href="../erts/erlang#binary_to_term/1">erts/erlang#binary_to_term/1</a> is used.
</p><p>
The distribution does this implicitly when sending messages across
node boundaries.
</p><a name="overall_format"></a><p>
The overall format of the term format is as follows:
</p><table class="table table-bordered table-hover table-striped"><caption>Term Format</caption><tbody><tr><td>1</td><td>1</td><td>N</td></tr><tr><td><strong>131</strong></td><td><strong>Tag</strong></td><td><strong>Data</strong></td></tr></tbody></table><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
When messages are
<a href="./erl_dist_protocol#connected_nodes">passed between connected nodes</a> and a
<a href="#distribution_header">distribution header</a> is used, the first byte containing the version
number (131) is omitted from the terms that follow the distribution
header. This is because the version number is implied by the version
number in the distribution header.
</p></div><p>
The compressed term format is as follows:
</p><table class="table table-bordered table-hover table-striped"><caption>Compressed Term Format</caption><tbody><tr><td>1</td><td>1</td><td>4</td><td>N</td></tr><tr><td><strong>131</strong></td><td><strong>80</strong></td><td><strong>UncompressedSize</strong></td><td><strong>Zlib-compressedData</strong></td></tr></tbody></table><p>
Uncompressed size (unsigned 32-bit integer in big-endian byte order)
is the size of the data before it was compressed.
The compressed data has the following format when it has been expanded:
</p><table class="table table-bordered table-hover table-striped"><caption>Compressed Data Format when Expanded</caption><tbody><tr><td>1</td><td>Uncompressed Size</td></tr><tr><td><strong>Tag</strong></td><td><strong>Data</strong></td></tr></tbody></table><a name="utf8_atoms"></a><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from ERTS 9.0 (OTP 20), atoms may contain any Unicode
characters and are always encoded using the UTF-8 external formats
<a href="#ATOM_UTF8_EXT">ATOM_UTF8_EXT</a>
or <a href="#SMALL_ATOM_UTF8_EXT">SMALL_ATOM_UTF8_EXT</a>.
The old Latin-1 formats <a href="#ATOM_EXT">ATOM_EXT</a>
and <a href="#SMALL_ATOM_EXT">SMALL_ATOM_EXT</a>
are deprecated and are only kept for backward
compatibility when decoding terms encoded by older nodes.</p><p>Support for UTF-8 encoded atoms in the external format has been
available since ERTS 5.10 (OTP R16). This abillity allows such old nodes
to decode, store and encode any Unicode atoms received from a new OTP 20
node.</p><p>The maximum number of allowed characters in an atom is 255. In the
UTF-8 case, each character can need 4 bytes to be encoded.</p></div><a name="distribution_header"></a><h3>Distribution Header</h3><p>
The distribution header is sent by the erlang distribution to
carry metadata about the coming
<a href="./erl_dist_protocol#control_message">control message</a>
and potential payload. It is primarily used to handle the atom cache
in the Erlang distribution. Since OTP-22 it is also used to fragment
large distribution messages into multiple smaller fragments.
For more information about how the distribution uses the distribution header,
see the documentation of the
<a href="./erl_dist_protocol#connected_nodes">protocol between connected nodes</a> in the
<a href="erl_dist_protocol">distribution protocol</a>
documentation.
</p><p>
Any <a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a>
entries with corresponding <strong>AtomCacheReferenceIndex</strong> in terms
encoded on the external format following a distribution header refer
to the atom cache references made in the distribution header. The range
is 0 &lt;= <strong>AtomCacheReferenceIndex</strong> &lt; 255, that is, at most 255
different atom cache references from the following terms can be made.
</p><h3>Normal Distribution Header</h3><p>
The non-fragmented distribution header format is as follows:
</p><table class="table table-bordered table-hover table-striped"><caption>Normal Distribution Header Format</caption><tbody><tr><td>1</td><td>1</td><td>1</td><td>NumberOfAtomCacheRefs/2+1 | 0</td><td>N | 0</td></tr><tr><td><strong>131</strong></td><td><strong>68</strong></td><td><strong>NumberOfAtomCacheRefs</strong></td><td><strong>Flags</strong></td><td><strong>AtomCacheRefs</strong></td></tr></tbody></table><p>
<strong>Flags</strong> consist of <strong>NumberOfAtomCacheRefs/2+1</strong> bytes,
unless <strong>NumberOfAtomCacheRefs</strong> is <strong>0</strong>. If
<strong>NumberOfAtomCacheRefs</strong> is <strong>0</strong>, <strong>Flags</strong> and
<strong>AtomCacheRefs</strong> are omitted. Each atom cache reference has
a half byte flag field. Flags corresponding to a specific
<strong>AtomCacheReferenceIndex</strong> are located in flag byte number
<strong>AtomCacheReferenceIndex/2</strong>. Flag byte 0 is the first byte
after the <strong>NumberOfAtomCacheRefs</strong> byte. Flags for an even
<strong>AtomCacheReferenceIndex</strong> are located in the least significant
half byte and flags for an odd <strong>AtomCacheReferenceIndex</strong> are
located in the most significant half byte.
</p><p>
The flag field of an atom cache reference has the following
format:
</p><table class="table table-bordered table-hover table-striped"><tbody><tr><td>1 bit</td><td>3 bits</td></tr><tr><td><strong>NewCacheEntryFlag</strong></td><td><strong>SegmentIndex</strong></td></tr></tbody></table><p>
The most significant bit is the <strong>NewCacheEntryFlag</strong>. If set,
the corresponding cache reference is new. The three least
significant bits are the <strong>SegmentIndex</strong> of the corresponding
atom cache entry. An atom cache consists of 8 segments, each of size
256, that is, an atom cache can contain 2048 entries.
</p><p>
After flag fields for atom cache references, another half byte flag
field is located with the following format:
</p><table class="table table-bordered table-hover table-striped"><tbody><tr><td>3 bits</td><td>1 bit</td></tr><tr><td><strong>CurrentlyUnused</strong></td><td><strong>LongAtoms</strong></td></tr></tbody></table><p>
The least significant bit in that half byte is flag <strong>LongAtoms</strong>.
If it is set, 2 bytes are used for atom lengths instead of
1 byte in the distribution header.
</p><p>
After the <strong>Flags</strong> field follow the <strong>AtomCacheRefs</strong>. The
first <strong>AtomCacheRef</strong> is the one corresponding to
<strong>AtomCacheReferenceIndex</strong> 0. Higher indices follow
in sequence up to index <strong>NumberOfAtomCacheRefs - 1</strong>.
</p><p>
If the <strong>NewCacheEntryFlag</strong> for the next <strong>AtomCacheRef</strong> has
been set, a <strong>NewAtomCacheRef</strong> on the following format follows:
</p><table class="table table-bordered table-hover table-striped"><tbody><tr><td>1</td><td>1 | 2</td><td>Length</td></tr><tr><td><strong>InternalSegmentIndex</strong></td><td><strong>Length</strong></td><td><strong>AtomText</strong></td></tr></tbody></table><p>
<strong>InternalSegmentIndex</strong> together with the <strong>SegmentIndex</strong>
completely identify the location of an atom cache entry in the
atom cache. <strong>Length</strong> is the number of bytes that <strong>AtomText</strong>
consists of. Length is a 2 byte big-endian integer
if flag <strong>LongAtoms</strong> has been set, otherwise a 1 byte
integer. When distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been exchanged between both nodes in the
<a href="./erl_dist_protocol#distribution_handshake"> distribution handshake</a>,
characters in <strong>AtomText</strong> are encoded in UTF-8, otherwise
in Latin-1. The following <strong>CachedAtomRef</strong>s with the same
<strong>SegmentIndex</strong> and <strong>InternalSegmentIndex</strong> as this
<strong>NewAtomCacheRef</strong> refer to this atom until a new
<strong>NewAtomCacheRef</strong> with the same <strong>SegmentIndex</strong>
and <strong>InternalSegmentIndex</strong> appear.
</p><p>
For more information on encoding of atoms, see the
<a href="#utf8_atoms">note on UTF-8 encoded atoms</a>
in the beginning of this section.
</p><p>
If the <strong>NewCacheEntryFlag</strong> for the next <strong>AtomCacheRef</strong>
has not been set, a <strong>CachedAtomRef</strong> on the following format
follows:
</p><table class="table table-bordered table-hover table-striped"><tbody><tr><td>1</td></tr><tr><td><strong>InternalSegmentIndex</strong></td></tr></tbody></table><p>
<strong>InternalSegmentIndex</strong> together with the <strong>SegmentIndex</strong>
identify the location of the atom cache entry in the atom cache.
The atom corresponding to this <strong>CachedAtomRef</strong> is the
latest <strong>NewAtomCacheRef</strong> preceding this <strong>CachedAtomRef</strong>
in another previously passed distribution header.
</p><a name="fragments"></a><h3>Distribution Header for fragmented messages</h3><p>Messages sent between Erlang nodes can sometimes be
quite large. Since OTP-22 it is possible to split large messages
into smaller fragments in order to allow smaller messages to be interleaved
between larges messages. It is only the <strong>message</strong> part of each
<a href="./erl_dist_protocol#connected_nodes">distributed message</a>
that may be split using fragmentation. Therefore it is recommended to use the
<a href="./erl_dist_protocol#new-ctrlmessages-for-erlang-otp-22"> PAYLOAD control messages</a> introduced in OTP-22.
</p><p>Fragmented distribution messages are only used if the receiving node
signals that it supports them via the
<a href="./erl_dist_protocol#dflags">DFLAG_FRAGMENTS</a> distribution
flag.</p><p>A process must complete the sending of a fragmented message before it
can start sending any other message on the same distribution channel.</p><p>The start of a sequence of fragmented messages looks like this:</p><table class="table table-bordered table-hover table-striped"><caption>Starting Fragmented Distribution Header Format</caption><tbody><tr><td>1</td><td>1</td><td>8</td><td>8</td><td>1</td><td>NumberOfAtomCacheRefs/2+1 | 0</td><td>N | 0</td></tr><tr><td><strong>131</strong></td><td><strong>69</strong></td><td><strong>SequenceId</strong></td><td><strong>FragmentId</strong></td><td><strong>NumberOfAtomCacheRefs</strong></td><td><strong>Flags</strong></td><td><strong>AtomCacheRefs</strong></td></tr></tbody></table><p>The continuation of a sequence of fragmented messages looks like this:</p><table class="table table-bordered table-hover table-striped"><caption>Continuing Fragmented Distribution Header Format</caption><tbody><tr><td>1</td><td>1</td><td>8</td><td>8</td></tr><tr><td><strong>131</strong></td><td><strong>70</strong></td><td><strong>SequenceId</strong></td><td><strong>FragmentId</strong></td></tr></tbody></table><p>
The starting distribution header is very similar to a non-fragmented distribution
header. The atom cache works the same as for normal distribution header and
is the same for the entire sequence. The additional fields added are the
sequence id and fragment id.
</p><dl><dt>Sequence ID</dt><dd> <p>
The sequence id is used to uniquely identify a fragmented message sent
from one process to another on the same distributed connection. This is used
to identify which sequence a fragment is a part of as the same process can
be in the process of receiving multiple sequences at the same time.
</p> <p>
As one process can only be sending one fragmented message at once,
it can be convenient to use the local PID as the sequence id.
</p> </dd><dt>Fragments ID</dt><dd> <p>
The Fragment ID is used to number the fragments in a sequence.
The id starts at the total number of fragments and then decrements to 1
(which is the final fragment). So if a sequence consists of 3 fragments
the fragment id in the starting header will be 3, and then fragments 2 and 1
are sent.
</p> <p>
The fragments must be delivered in the correct order, so if an unordered
distribution carrier is used, they must be ordered before delivered to the
Erlang run-time.
</p> </dd></dl><h3>Example:</h3><p>
As an example, let say that we want to send
<strong>{call, &lt;0.245.2&gt;, {set_get_state, &lt;&lt;0:1024&gt;&gt;}}</strong> to
registered process <strong>reg</strong> using a fragment size of 128. To send
this message we need a distribution header, atom cache updates,
the control message (which would be <strong>{6, &lt;0.245.2&gt;, [], reg}</strong> in this case)
and finally the actual message. This would all be encoded into:
</p><pre><code class="">
131,69,0,0,2,168,0,0,5,83,0,0,0,0,0,0,0,2,               %% Header with seq and frag id
5,4,137,9,10,5,236,3,114,101,103,9,4,99,97,108,108,      %% Atom cache updates
238,13,115,101,116,95,103,101,116,95,115,116,97,116,101,
104,4,97,6,103,82,0,0,0,0,85,0,0,0,0,2,82,1,82,2,        %% Control message
104,3,82,3,103,82,0,0,0,0,245,0,0,0,2,2,                 %% Actual message using cached atoms
104,2,82,4,109,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

131,70,0,0,2,168,0,0,5,83,0,0,0,0,0,0,0,1,               %% Cont Header with seq and frag id
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,               %% Rest of payload
0,0,0,0</code></pre><p>
Let us break that apart into its components. First we have the
distribution header tags together with the sequence id and
a fragment id of 2.
</p><pre><code class="">
131,69,                   %% Start fragment header
0,0,2,168,0,0,5,83,       %% The sequence ID
0,0,0,0,0,0,0,2,           %% The fragment ID
</code></pre><p>Then we have the updates to the atom cache:</p><pre><code class="">
5,4,137,9,  %% 5 atoms and their flags
10,5,       %% The already cached atom ids
236,3,114,101,103,  %% The atom 'reg'
9,4,99,97,108,108,  %% The atom 'call'
238,13,115,101,116,95,103,101,116,95,115,116,97,116,101, %% The atom 'set_get_state'
       </code></pre><p>
The first byte says that we have 5 atoms that are part
of the cache. Then follows three bytes that are the
atom cache ref flags. Each of the flags uses 4 bits so
they are a bit hard to read in decimal byte form. In
binary half-byte form they look like this:
</p><pre><code class="">0000, 0100, 1000, 1001, 1001</code></pre><p>
As the high bit of the first two atoms in the
cache are not set we know that they are already in the cache,
so they do not have to be sent again (this is the node name of the
receiving and sending node). Then follows the atoms that have to be sent,
together with their segment ids.
</p><p>
Then the listing of the atoms comes, starting with 10 and 5
which are the atom refs of the already cached atoms. Then the
new atoms are sent.
</p><p>
When the atom cache is setup correctly the control message is sent.
</p><pre><code class="">104,4,97,6,103,82,0,0,0,0,85,0,0,0,0,2,82,1,82,2,</code></pre><p>
Note that up until here it is not allowed to fragments the message.
The entire atom cache and control message has to be part of the
starting fragment. After the control message the payload of the message
is sent using 128 bytes:
</p><pre><code class="">
104,3,82,3,103,82,0,0,0,0,245,0,0,0,2,2,
104,2,82,4,109,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       </code></pre><p>
Since the payload is larger than 128-bytes it is split into two
fragments. The second fragment does not have any atom cache update
instructions so it is a lot simpler:
</p><pre><code class="">
131,70,0,0,2,168,0,0,5,83,0,0,0,0,0,0,0,1, %% Continuation dist header 70 with seq and frag id
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, %% remaining payload
0,0,0,0
       </code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
The fragment size of 128 is only used as an example.
Any fragments size may be used when sending fragmented messages.
</p></div><a name="ATOM_CACHE_REF"></a><h3>ATOM_CACHE_REF</h3><table class="table table-bordered table-hover table-striped"><caption>ATOM_CACHE_REF</caption><tbody><tr><td>1</td><td>1</td></tr><tr><td><strong>82</strong></td><td><strong>AtomCacheReferenceIndex</strong></td></tr></tbody></table><p>
Refers to the atom with <strong>AtomCacheReferenceIndex</strong> in the
<a href="#distribution_header">distribution header</a>.
</p><a name="SMALL_INTEGER_EXT"></a><h3>SMALL_INTEGER_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>SMALL_INTEGER_EXT</caption><tbody><tr><td>1</td><td>1</td></tr><tr><td><strong>97</strong></td><td><strong>Int</strong></td></tr></tbody></table><p>
Unsigned 8-bit integer.
</p><a name="INTEGER_EXT"></a><h3>INTEGER_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>INTEGER_EXT</caption><tbody><tr><td>1</td><td>4</td></tr><tr><td><strong>98</strong></td><td><strong>Int</strong></td></tr></tbody></table><p>
Signed 32-bit integer in big-endian format.
</p><a name="FLOAT_EXT"></a><h3>FLOAT_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>FLOAT_EXT</caption><tbody><tr><td>1</td><td>31</td></tr><tr><td><strong>99</strong></td><td><strong>Float string</strong></td></tr></tbody></table><p>
A finite float (i.e. not inf, -inf or NaN) is stored in
string format. The format used in sprintf to format the
float is "%.20e"
(there are more bytes allocated than necessary).
To unpack the float, use sscanf with format "%lf".
</p><p>
This term is used in minor version 0 of the external format;
it has been superseded by
<a href="#NEW_FLOAT_EXT">NEW_FLOAT_EXT</a>.
</p><a name="PORT_EXT"></a><h3>PORT_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>PORT_EXT</caption><tbody><tr><td>1</td><td>N</td><td>4</td><td>1</td></tr><tr><td><strong>102</strong></td><td><strong>Node</strong></td><td><strong>ID</strong></td><td><strong>Creation</strong></td></tr></tbody></table><p>
Same as <a href="#NEW_PORT_EXT">NEW_PORT_EXT</a>
except the <strong>Creation</strong> field is only one byte and only two
bits are significant, the rest are to be 0.
</p><a name="NEW_PORT_EXT"></a><h3>NEW_PORT_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>NEW_PORT_EXT</caption><tbody><tr><td>1</td><td>N</td><td>4</td><td>4</td></tr><tr><td><strong>89</strong></td><td><strong>Node</strong></td><td><strong>ID</strong></td><td><strong>Creation</strong></td></tr></tbody></table><p>
Encodes a port identifier (obtained from
<a href="./erlang#open_port/2">erlang#open_port/2</a>).
<strong>Node</strong> is an encoded atom, that is,
<a href="#ATOM_UTF8_EXT">ATOM_UTF8_EXT</a>,
<a href="#SMALL_ATOM_UTF8_EXT">SMALL_ATOM_UTF8_EXT</a>
or <a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a>.
<strong>ID</strong> is a 32-bit big endian unsigned integer. Only 28 bits are
significant; the rest are to be 0. The <strong>Creation</strong> works just like in
<a href="#NEW_PID_EXT">NEW_PID_EXT</a>.
Port operations are not allowed across node boundaries.
</p><p>Introduced in OTP 19, but only to be decoded and echoed back. Not
encoded for local ports. Planned to supersede <a href="#PORT_EXT">PORT_EXT</a> in OTP 23 when
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
becomes mandatory.
</p><a name="PID_EXT"></a><h3>PID_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>PID_EXT</caption><tbody><tr><td>1</td><td>N</td><td>4</td><td>4</td><td>1</td></tr><tr><td><strong>103</strong></td><td><strong>Node</strong></td><td><strong>ID</strong></td><td><strong>Serial</strong></td><td><strong>Creation</strong></td></tr></tbody></table><p>
Same as <a href="#NEW_PID_EXT">NEW_PID_EXT</a>
except the <strong>Creation</strong> field is only one byte and only two
bits are significant, the rest are to be 0.
</p><a name="NEW_PID_EXT"></a><h3>NEW_PID_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>NEW_PID_EXT</caption><tbody><tr><td>1</td><td>N</td><td>4</td><td>4</td><td>4</td></tr><tr><td><strong>88</strong></td><td><strong>Node</strong></td><td><strong>ID</strong></td><td><strong>Serial</strong></td><td><strong>Creation</strong></td></tr></tbody></table><p>
Encodes an Erlang process identifier object.
</p><dl><dt><strong>Node</strong></dt><dd><p>The name of the originating node, encoded using
<a href="#ATOM_UTF8_EXT">ATOM_UTF8_EXT</a>,
<a href="#SMALL_ATOM_UTF8_EXT">SMALL_ATOM_UTF8_EXT</a>
or <a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a>.</p> </dd><dt><strong>ID</strong></dt><dd><p>A 32-bit big endian unsigned integer. Only 15 bits are
significant; the rest are to be 0.</p> </dd><dt><strong>Serial</strong></dt><dd><p>A 32-bit big endian unsigned integer. Only 13 bits are
significant; the rest are to be 0.</p> </dd><dt><strong>Creation</strong></dt><dd><p>A 32-bit big endian unsigned integer. All identifiers
originating from the same node incarnation must have identical <strong>Creation</strong>
values. This makes it possible to separate identifiers from old
(crashed) nodes from a new one. The value zero should be avoided for
normal operations as it is used as a wild card for debug purpose
(like a pid returned by <a href="../erts/erlang#list_to_pid/1"> erlang:list_to_pid/1</a>).</p> </dd></dl><p>Introduced in OTP 19, but only to be decoded and echoed back. Not
encoded for local processes. Planned to supersede <a href="#PID_EXT">PID_EXT</a> in OTP 23 when
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
becomes mandatory.
</p><a name="SMALL_TUPLE_EXT"></a><h3>SMALL_TUPLE_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>SMALL_TUPLE_EXT</caption><tbody><tr><td>1</td><td>1</td><td>N</td></tr><tr><td><strong>104</strong></td><td><strong>Arity</strong></td><td><strong>Elements</strong></td></tr></tbody></table><p>
Encodes a tuple. The <strong>Arity</strong>
field is an unsigned byte that determines how many elements
that follows in section <strong>Elements</strong>.
</p><a name="LARGE_TUPLE_EXT"></a><h3>LARGE_TUPLE_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>LARGE_TUPLE_EXT</caption><tbody><tr><td>1</td><td>4</td><td>N</td></tr><tr><td><strong>105</strong></td><td><strong>Arity</strong></td><td><strong>Elements</strong></td></tr></tbody></table><p>
Same as
<a href="#SMALL_TUPLE_EXT">SMALL_TUPLE_EXT</a>
except that <strong>Arity</strong> is an
unsigned 4 byte integer in big-endian format.
</p><a name="MAP_EXT"></a><h3>MAP_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>MAP_EXT</caption><tbody><tr><td>1</td><td>4</td><td>N</td></tr><tr><td><strong>116</strong></td><td><strong>Arity</strong></td><td><strong>Pairs</strong></td></tr></tbody></table><p>
Encodes a map. The <strong>Arity</strong> field is an unsigned
4 byte integer in big-endian format that determines the number of
key-value pairs in the map. Key and value pairs (<strong>Ki =&gt; Vi</strong>)
are encoded in section <strong>Pairs</strong> in the following order:
<strong>K1, V1, K2, V2,..., Kn, Vn</strong>.
Duplicate keys are <em>not allowed</em> within the same map.
</p><p><em>As from </em>Erlang/OTP 17.0</p><a name="NIL_EXT"></a><h3>NIL_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>NIL_EXT</caption><tbody><tr><td>1</td></tr><tr><td><strong>106</strong></td></tr></tbody></table><p>
The representation for an empty list, that is, the Erlang syntax
<strong>[]</strong>.
</p><a name="STRING_EXT"></a><h3>STRING_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>STRING_EXT</caption><tbody><tr><td>1</td><td>2</td><td>Len</td></tr><tr><td><strong>107</strong></td><td><strong>Length</strong></td><td><strong>Characters</strong></td></tr></tbody></table><p>
String does <em>not</em> have a corresponding Erlang representation,
but is an optimization for sending lists of bytes (integer in
the range 0-255) more efficiently over the distribution.
As field <strong>Length</strong> is an unsigned 2 byte integer
(big-endian), implementations must ensure that lists longer than
65535 elements are encoded as
<a href="#LIST_EXT">LIST_EXT</a>.
</p><a name="LIST_EXT"></a><h3>LIST_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>LIST_EXT</caption><tbody><tr><td>1</td><td>4</td><td>Â </td><td>Â </td></tr><tr><td><strong>108</strong></td><td><strong>Length</strong></td><td><strong>Elements</strong></td><td><strong>Tail</strong></td></tr></tbody></table><p>
<strong>Length</strong> is the number of elements that follows in section
<strong>Elements</strong>. <strong>Tail</strong> is the final tail of the list; it is
<a href="#NIL_EXT">NIL_EXT</a>
for a proper list, but can be any type if the list is
improper (for example, <strong>[a|b]</strong>).
</p><a name="BINARY_EXT"></a><h3>BINARY_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>BINARY_EXT</caption><tbody><tr><td>1</td><td>4</td><td>Len</td></tr><tr><td><strong>109</strong></td><td><strong>Len</strong></td><td><strong>Data</strong></td></tr></tbody></table><p>
Binaries are generated with bit syntax expression or with
<a href="../erts/erlang#list_to_binary/1">erts/erlang#list_to_binary/1</a>,
<a href="../erts/erlang#term_to_binary/1">erts/erlang#term_to_binary/1</a>,
or as input from binary ports.
The <strong>Len</strong> length field is an unsigned 4 byte integer
(big-endian).
</p><a name="SMALL_BIG_EXT"></a><h3>SMALL_BIG_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>SMALL_BIG_EXT</caption><tbody><tr><td>1</td><td>1</td><td>1</td><td>n</td></tr><tr><td><strong>110</strong></td><td><strong>n</strong></td><td><strong>Sign</strong></td><td><strong>d(0)</strong> ... <strong>d(n-1)</strong></td></tr></tbody></table><p>
Bignums are stored in unary form with a <strong>Sign</strong> byte,
that is, 0 if the binum is positive and 1 if it is negative. The
digits are stored with the least significant byte stored first. To
calculate the integer, the following formula can be used:
</p><p><strong>B</strong> = 256<br/>
<strong>(d0*B^0 + d1*B^1 + d2*B^2 + ... d(N-1)*B^(n-1))</strong>
</p><a name="LARGE_BIG_EXT"></a><h3>LARGE_BIG_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>LARGE_BIG_EXT</caption><tbody><tr><td>1</td><td>4</td><td>1</td><td>n</td></tr><tr><td><strong>111</strong></td><td><strong>n</strong></td><td><strong>Sign</strong></td><td><strong>d(0)</strong> ... <strong>d(n-1)</strong></td></tr></tbody></table><p>
Same as <a href="#SMALL_BIG_EXT">SMALL_BIG_EXT</a> 
except that the length field is an unsigned 4 byte integer.
</p><a name="REFERENCE_EXT"></a><h3>REFERENCE_EXT (deprecated)</h3><table class="table table-bordered table-hover table-striped"><caption>REFERENCE_EXT</caption><tbody><tr><td>1</td><td>N</td><td>4</td><td>1</td></tr><tr><td><strong>101</strong></td><td><strong>Node</strong></td><td><strong>ID</strong></td><td><strong>Creation</strong></td></tr></tbody></table><p>
The same as <a href="#NEW_REFERENCE_EXT">NEW_REFERENCE_EXT</a> except <strong>ID</strong> is only one word
(<strong>Len</strong> = 1).
</p><a name="NEW_REFERENCE_EXT"></a><h3>NEW_REFERENCE_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>NEW_REFERENCE_EXT</caption><tbody><tr><td>1</td><td>2</td><td>N</td><td>1</td><td>N'</td></tr><tr><td><strong>114</strong></td><td><strong>Len</strong></td><td><strong>Node</strong></td><td><strong>Creation</strong></td><td><strong>ID ...</strong></td></tr></tbody></table><p>
The same as <a href="#NEWER_REFERENCE_EXT">NEWER_REFERENCE_EXT</a> <em>except</em>:
</p><dl><dt><strong>ID</strong></dt><dd><p>In the first word (4 bytes) of <strong>ID</strong>, only 18 bits are
significant, the rest must be 0.</p> </dd><dt><strong>Creation</strong></dt><dd><p>Only one byte long and only two bits are significant, the rest must be 0.</p> </dd></dl><a name="NEWER_REFERENCE_EXT"></a><h3>NEWER_REFERENCE_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>NEWER_REFERENCE_EXT</caption><tbody><tr><td>1</td><td>2</td><td>N</td><td>4</td><td>N'</td></tr><tr><td><strong>90</strong></td><td><strong>Len</strong></td><td><strong>Node</strong></td><td><strong>Creation</strong></td><td><strong>ID ...</strong></td></tr></tbody></table><p>
Encodes a reference term generated with
<a href="../erts/erlang#make_ref/0">erlang:make_ref/0</a>.
</p><dl><dt><strong>Node</strong></dt><dd><p>The name of the originating node, encoded using
<a href="#ATOM_UTF8_EXT">ATOM_UTF8_EXT</a>,
<a href="#SMALL_ATOM_UTF8_EXT">SMALL_ATOM_UTF8_EXT</a>
or <a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a>.</p> </dd><dt><strong>Len</strong></dt><dd><p>A 16-bit big endian unsigned integer not larger than 3.</p> </dd><dt><strong>ID</strong></dt><dd><p>A sequence of <strong>Len</strong> big-endian unsigned integers
(4 bytes each, so <strong>N'</strong>Â =Â 4Â *Â <strong>Len</strong>),
but is to be regarded as uninterpreted data.</p> </dd><dt><strong>Creation</strong></dt><dd><p>Works just like in
<a href="#NEW_PID_EXT">NEW_PID_EXT</a>.</p> </dd></dl><p>Introduced in OTP 19, but only to be decoded and echoed back. Not
encoded for local references. Planned to supersede <a href="#NEW_REFERENCE_EXT">NEW_REFERENCE_EXT</a> in OTP 23 when
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
becomes mandatory.
</p><a name="FUN_EXT"></a><h3>FUN_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>FUN_EXT</caption><tbody><tr><td>1</td><td>4</td><td>N1</td><td>N2</td><td>N3</td><td>N4</td><td>N5</td></tr><tr><td><strong>117</strong></td><td><strong>NumFree</strong></td><td><strong>Pid</strong></td><td><strong>Module</strong></td><td><strong>Index</strong></td><td><strong>Uniq</strong></td><td><strong>Free vars ...</strong></td></tr></tbody></table><dl><dt><strong>Pid</strong></dt><dd> <p>A process identifier as in
<a href="#PID_EXT">PID_EXT</a>.
Represents the process in which the fun was created.
</p> </dd><dt><strong>Module</strong></dt><dd> <p>Encoded as an atom, using
<a href="#ATOM_UTF8_EXT">ATOM_UTF8_EXT</a>,
<a href="#SMALL_ATOM_UTF8_EXT">SMALL_ATOM_UTF8_EXT</a>,
or <a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a>.
This is the module that the fun is implemented in.
</p> </dd><dt><strong>Index</strong></dt><dd> <p>An integer encoded using
<a href="#SMALL_INTEGER_EXT">SMALL_INTEGER_EXT</a> 
or <a href="#INTEGER_EXT">INTEGER_EXT</a>.
It is typically a small index into the module's fun table.
</p> </dd><dt><strong>Uniq</strong></dt><dd> <p>An integer encoded using
<a href="#SMALL_INTEGER_EXT">SMALL_INTEGER_EXT</a> or 
<a href="#INTEGER_EXT">INTEGER_EXT</a>.
<strong>Uniq</strong> is the hash value of the parse for the fun.
</p> </dd><dt><strong>Free vars</strong></dt><dd> <p><strong>NumFree</strong> number of terms, each one encoded according
to its type.
</p> </dd></dl><a name="NEW_FUN_EXT"></a><h3>NEW_FUN_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>NEW_FUN_EXT</caption><tbody><tr><td>1</td><td>4</td><td>1</td><td>16</td><td>4</td><td>4</td><td>N1</td><td>N2</td><td>N3</td><td>N4</td><td>N5</td></tr><tr><td><strong>112</strong></td><td><strong>Size</strong></td><td><strong>Arity</strong></td><td><strong>Uniq</strong></td><td><strong>Index</strong></td><td><strong>NumFree</strong></td><td><strong>Module</strong></td><td><strong>OldIndex</strong></td><td><strong>OldUniq</strong></td><td><strong>Pid</strong></td><td><strong>Free Vars</strong></td></tr></tbody></table><p>
This is the new encoding of internal funs: <strong>fun F/A</strong> and
<strong>fun(Arg1,..) -&gt; ... end</strong>.
</p><dl><dt><strong>Size</strong></dt><dd> <p>The total number of bytes, including field <strong>Size</strong>.</p> </dd><dt><strong>Arity</strong></dt><dd> <p>The arity of the function implementing the fun.</p> </dd><dt><strong>Uniq</strong></dt><dd> <p>The 16 bytes MD5 of the significant parts of the Beam file.</p> </dd><dt><strong>Index</strong></dt><dd> <p>An index number. Each fun within a module has an unique
index. <strong>Index</strong> is stored in big-endian byte order.
</p> </dd><dt><strong>NumFree</strong></dt><dd> <p>The number of free variables.</p> </dd><dt><strong>Module</strong></dt><dd> <p>Encoded as an atom, using
<a href="#ATOM_EXT">ATOM_EXT</a>, 
<a href="#SMALL_ATOM_EXT">SMALL_ATOM_EXT</a>,
or <a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a>. 
Is the module that the fun is implemented in.
</p> </dd><dt><strong>OldIndex</strong></dt><dd> <p>An integer encoded using
<a href="#SMALL_INTEGER_EXT">SMALL_INTEGER_EXT</a> or
<a href="#INTEGER_EXT">INTEGER_EXT</a>.
Is typically a small index into the module's fun table.
</p> </dd><dt><strong>OldUniq</strong></dt><dd> <p>An integer encoded using
<a href="#SMALL_INTEGER_EXT">SMALL_INTEGER_EXT</a> or 
<a href="#INTEGER_EXT">INTEGER_EXT</a>.
<strong>Uniq</strong> is the hash value of the parse tree for the fun.
</p> </dd><dt><strong>Pid</strong></dt><dd> <p>A process identifier as in
<a href="#PID_EXT">PID_EXT</a>.
Represents the process in which the fun was created.
</p> </dd><dt><strong>Free vars</strong></dt><dd> <p><strong>NumFree</strong> number of terms, each one encoded according
to its type.
</p> </dd></dl><a name="EXPORT_EXT"></a><h3>EXPORT_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>EXPORT_EXT</caption><tbody><tr><td>1</td><td>N1</td><td>N2</td><td>N3</td></tr><tr><td><strong>113</strong></td><td><strong>Module</strong></td><td><strong>Function</strong></td><td><strong>Arity</strong></td></tr></tbody></table><p>
This term is the encoding for external funs: <strong>fun M:F/A</strong>.
</p><p>
<strong>Module</strong> and <strong>Function</strong> are atoms
(encoded using <a href="#ATOM_EXT">ATOM_EXT</a>, 
<a href="#SMALL_ATOM_EXT">SMALL_ATOM_EXT</a>, or
<a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a>).
</p><p>
<strong>Arity</strong> is an integer encoded using
<a href="#SMALL_INTEGER_EXT">SMALL_INTEGER_EXT</a>.
</p><a name="BIT_BINARY_EXT"></a><h3>BIT_BINARY_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>BIT_BINARY_EXT</caption><tbody><tr><td>1</td><td>4</td><td>1</td><td>Len</td></tr><tr><td><strong>77</strong></td><td><strong>Len</strong></td><td><strong>Bits</strong></td><td><strong>Data</strong></td></tr></tbody></table><p>
This term represents a bitstring whose length in bits does
not have to be a multiple of 8.
The <strong>Len</strong> field is an unsigned 4 byte integer (big-endian).
The <strong>Bits</strong> field is the number of bits (1-8) that are used
in the last byte in the data field,
counting from the most significant bit to the least significant.
</p><a name="NEW_FLOAT_EXT"></a><h3>NEW_FLOAT_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>NEW_FLOAT_EXT</caption><tbody><tr><td>1</td><td>8</td></tr><tr><td><strong>70</strong></td><td><strong>IEEE float</strong></td></tr></tbody></table><p>
A finite float (i.e. not inf, -inf or NaN) is stored as 8 bytes
in big-endian IEEE format.
</p><p>
This term is used in minor version 1 of the external format.
</p><a name="ATOM_UTF8_EXT"></a><h3>ATOM_UTF8_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>ATOM_UTF8_EXT</caption><tbody><tr><td>1</td><td>2</td><td>Len</td></tr><tr><td><strong>118</strong></td><td><strong>Len</strong></td><td><strong>AtomName</strong></td></tr></tbody></table><p>
An atom is stored with a 2 byte unsigned length in big-endian order,
followed by <strong>Len</strong> bytes containing the <strong>AtomName</strong> encoded
in UTF-8.
</p><p>
For more information on encoding of atoms, see the
<a href="#utf8_atoms">note on UTF-8 encoded atoms</a>
in the beginning of this section.
</p><a name="SMALL_ATOM_UTF8_EXT"></a><h3>SMALL_ATOM_UTF8_EXT</h3><table class="table table-bordered table-hover table-striped"><caption>SMALL_ATOM_UTF8_EXT</caption><tbody><tr><td>1</td><td>1</td><td>Len</td></tr><tr><td><strong>119</strong></td><td><strong>Len</strong></td><td><strong>AtomName</strong></td></tr></tbody></table><p>
An atom is stored with a 1 byte unsigned length,
followed by <strong>Len</strong> bytes containing the <strong>AtomName</strong> encoded
in UTF-8. Longer atoms encoded in UTF-8 can be represented using
<a href="#ATOM_UTF8_EXT">ATOM_UTF8_EXT</a>.
</p><p>
For more information on encoding of atoms, see the
<a href="#utf8_atoms">note on UTF-8 encoded atoms</a>
in the beginning of this section.
</p><a name="ATOM_EXT"></a><h3>ATOM_EXT (deprecated)</h3><table class="table table-bordered table-hover table-striped"><caption>ATOM_EXT</caption><tbody><tr><td>1</td><td>2</td><td>Len</td></tr><tr><td><strong>100</strong></td><td><strong>Len</strong></td><td><strong>AtomName</strong></td></tr></tbody></table><p>
An atom is stored with a 2 byte unsigned length in big-endian order,
followed by <strong>Len</strong> numbers of 8-bit Latin-1 characters that forms
the <strong>AtomName</strong>. The maximum allowed value for <strong>Len</strong> is 255.
</p><a name="SMALL_ATOM_EXT"></a><h3>SMALL_ATOM_EXT (deprecated)</h3><table class="table table-bordered table-hover table-striped"><caption>SMALL_ATOM_EXT</caption><tbody><tr><td>1</td><td>1</td><td>Len</td></tr><tr><td><strong>115</strong></td><td><strong>Len</strong></td><td><strong>AtomName</strong></td></tr></tbody></table><p>
An atom is stored with a 1 byte unsigned length,
followed by <strong>Len</strong> numbers of 8-bit Latin-1 characters that
forms the <strong>AtomName</strong>.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
<strong>SMALL_ATOM_EXT</strong> was introduced in ERTS 5.7.2 and
require an exchange of distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a> in the
<a href="./erl_dist_protocol#distribution_handshake"> distribution handshake</a>.
</p></div><p>This description is far from complete. It will be updated if the
protocol is updated. However, the protocols, both from Erlang
nodes to the Erlang Port Mapper Daemon (EPMD) and between Erlang nodes
are stable since many years.</p><p>The distribution protocol can be divided into four parts:</p><ul><li> <p>Low-level socket connection (1)</p> </li><li> <p>Handshake, interchange node name, and authenticate (2)</p> </li><li> <p>Authentication (done by <a href="./net_kernel">kernel/net_kernel</a>) (3)</p> </li><li> <p>Connected (4)</p>  </li></ul><p>A node fetches the port number of another node through the EPMD (at the
other host) to initiate a connection request.</p><p>For each host, where a distributed Erlang node is running, also an EPMD
is to be running. The EPMD can be started explicitly or automatically
as a result of the Erlang node startup.</p><p>By default the EPMD listens on port 4369.</p><p>(3) and (4) above are performed at the same level but the <strong>net_kernel</strong>
disconnects the other node if it communicates using an invalid cookie (after
1 second).</p><p>The integers in all multibyte fields are in big-endian order.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>
The Erlang Distribution protocol is not by itself secure and does not
aim to be so. In order to get secure distribution the distributed nodes
should be configured to use distribution over tls.
See the <a href="./ssl_distribution"> Using SSL for Erlang Distribution</a> User's Guide
for details on how to setup a secure distributed node.
</p></div><h3>EPMD Protocol</h3><p>The requests served by the EPMD are summarized in the following
figure.</p><img src="erl_ext_fig.gif" title="Summary of EPMD Requests"></img><p>Each request <strong>*_REQ</strong> is preceded by a 2 byte length field.
Thus, the overall request format is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>Request Format</caption><tbody><tr><td>2</td><td>n</td></tr><tr><td><strong>Length</strong></td><td><strong>Request</strong></td></tr></tbody></table><h3>Register a Node in EPMD</h3><p>When a distributed node is started it registers itself in the EPMD.
The message <strong>ALIVE2_REQ</strong> described below is sent from the node to
the EPMD. The response from the EPMD is <strong>ALIVE2_RESP</strong>.</p><table class="table table-bordered table-hover table-striped"><caption>ALIVE2_REQ (120)</caption><tbody><tr><td>1</td><td>2</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>Nlen</td><td>2</td><td>Elen</td></tr><tr><td><strong>120</strong></td><td><strong>PortNo</strong></td><td><strong>NodeType</strong></td><td><strong>Protocol</strong></td><td><strong>HighestVersion</strong></td><td><strong>LowestVersion</strong></td><td><strong>Nlen</strong></td><td><strong>NodeName</strong></td><td><strong>Elen</strong></td><td><strong>Extra</strong></td></tr></tbody></table><dl><dt><strong>PortNo</strong></dt><dd> <p>The port number on which the node accept connection requests.</p> </dd><dt><strong>NodeType</strong></dt><dd> <p>77 = normal Erlang node, 72 = hidden node (C-node), ...</p> </dd><dt><strong>Protocol</strong></dt><dd> <p>0 = TCP/IPv4, ...</p> </dd><dt><strong>HighestVersion</strong></dt><dd> <p>The highest distribution version that this node can handle.
The value in Erlang/OTP R6B and later is 5.</p> </dd><dt><strong>LowestVersion</strong></dt><dd> <p>The lowest distribution version that this node can handle.
The value in Erlang/OTP R6B and later is 5.</p> </dd><dt><strong>Nlen</strong></dt><dd> <p>The length (in bytes) of field <strong>NodeName</strong>.</p> </dd><dt><strong>NodeName</strong></dt><dd> <p>The node name as an UTF-8 encoded string of <strong>Nlen</strong> bytes.</p> </dd><dt><strong>Elen</strong></dt><dd> <p>The length of field <strong>Extra</strong>.</p> </dd><dt><strong>Extra</strong></dt><dd> <p>Extra field of <strong>Elen</strong> bytes.</p> </dd></dl><p>The connection created to the EPMD must be kept as long as the
node is a distributed node. When the connection is closed,
the node is automatically unregistered from the EPMD.</p><p>The response message <strong>ALIVE2_RESP</strong> is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>ALIVE2_RESP (121)</caption><tbody><tr><td>1</td><td>1</td><td>2</td></tr><tr><td><strong>121</strong></td><td><strong>Result</strong></td><td><strong>Creation</strong></td></tr></tbody></table><p>Result = 0 -&gt; ok, result &gt; 0 -&gt; error.</p><h3>Unregister a Node from EPMD</h3><p>A node unregisters itself from the EPMD by closing the TCP
connection to EPMD established when the node was registered.</p><h3>Get the Distribution Port of Another Node</h3><p>When one node wants to connect to another node it starts with
a <strong>PORT_PLEASE2_REQ</strong> request to the EPMD on the host where the
node resides to get the distribution port that the node listens to.</p><table class="table table-bordered table-hover table-striped"><caption>PORT_PLEASE2_REQ (122)</caption><tbody><tr><td>1</td><td>N</td></tr><tr><td><strong>122</strong></td><td><strong>NodeName</strong></td></tr></tbody></table><p>where N = <strong>Length</strong> - 1.</p><table class="table table-bordered table-hover table-striped"><caption>PORT2_RESP (119) Response Indicating Error, Result > 0
</caption><tbody><tr><td>1</td><td>1</td></tr><tr><td><strong>119</strong></td><td><strong>Result</strong></td></tr></tbody></table><p>or</p><table class="table table-bordered table-hover table-striped"><caption>PORT2_RESP, Result = 0</caption><tbody><tr><td>1</td><td>1</td><td>2</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>Nlen</td><td>2</td><td>Elen</td></tr><tr><td><strong>119</strong></td><td><strong>Result</strong></td><td><strong>PortNo</strong></td><td><strong>NodeType</strong></td><td><strong>Protocol</strong></td><td><strong>HighestVersion</strong></td><td><strong>LowestVersion</strong></td><td><strong>Nlen</strong></td><td><strong>NodeName</strong></td><td><strong>Elen</strong></td><td>&gt;<strong>Extra</strong></td></tr></tbody></table><p>If <strong>Result</strong> &gt; 0, the packet only consists of
<strong>[119, Result]</strong>.</p><p>The EPMD closes the socket when it has sent the information.</p><h3>Get All Registered Names from EPMD</h3><p>This request is used through the Erlang function
<a href="../kernel/net_adm#names/1,2">kernel/net_adm#names/1,2</a>. A TCP connection is opened
to the  EPMD and this request is sent.</p><table class="table table-bordered table-hover table-striped"><caption>NAMES_REQ (110)</caption><tbody><tr><td>1</td></tr><tr><td><strong>110</strong></td></tr></tbody></table><p>The response for a <strong>NAMES_REQ</strong> is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>NAMES_RESP</caption><tbody><tr><td>4</td><td>Â </td></tr><tr><td><strong>EPMDPortNo</strong></td><td><strong>NodeInfo*</strong></td></tr></tbody></table><p><strong>NodeInfo</strong> is a string written for each active node.
When all <strong>NodeInfo</strong> has been written the connection is
closed by the EPMD.</p><p><strong>NodeInfo</strong> is, as expressed in Erlang:</p><pre><code class="">
io:format("name ~ts at port ~p~n", [NodeName, Port]).</code></pre><h3>Dump All Data from EPMD</h3><p>This request is not really used, it is to be regarded as a debug
feature.</p><table class="table table-bordered table-hover table-striped"><caption>DUMP_REQ</caption><tbody><tr><td>1</td></tr><tr><td><strong>100</strong></td></tr></tbody></table><p>The response for a <strong>DUMP_REQ</strong> is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>DUMP_RESP</caption><tbody><tr><td>4</td><td>Â </td></tr><tr><td><strong>EPMDPortNo</strong></td><td><strong>NodeInfo*</strong></td></tr></tbody></table><p><strong>NodeInfo</strong> is a string written for each node kept in the EPMD.
When all <strong>NodeInfo</strong> has been written the connection is
closed by the EPMD.</p><p><strong>NodeInfo</strong> is, as expressed in Erlang:</p><pre><code class="">
io:format("active name     ~ts at port ~p, fd = ~p~n",
          [NodeName, Port, Fd]).</code></pre><p>or</p><pre><code class="">
io:format("old/unused name ~ts at port ~p, fd = ~p ~n",
          [NodeName, Port, Fd]).</code></pre><h3>Kill EPMD</h3><p>This request kills the running EPMD. It is almost never used.</p><table class="table table-bordered table-hover table-striped"><caption>KILL_REQ</caption><tbody><tr><td>1</td></tr><tr><td><strong>107</strong></td></tr></tbody></table><p>The response for a <strong>KILL_REQ</strong> is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>KILL_RESP</caption><tbody><tr><td>2</td></tr><tr><td><strong>OKString</strong></td></tr></tbody></table><p>where <strong>OKString</strong> is "OK".</p><h3>STOP_REQ  (Not Used)</h3><table class="table table-bordered table-hover table-striped"><caption>STOP_REQ</caption><tbody><tr><td>1</td><td>n</td></tr><tr><td><strong>115</strong></td><td><strong>NodeName</strong></td></tr></tbody></table><p>where n = <strong>Length</strong> - 1.</p><p>The current implementation of Erlang does not care if the connection
to the EPMD is broken.</p><p>The response for a <strong>STOP_REQ</strong> is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>STOP_RESP</caption><tbody><tr><td>7</td></tr><tr><td><strong>OKString</strong></td></tr></tbody></table><p>where <strong>OKString</strong> is "STOPPED".</p><p>A negative response can look as follows:</p><table class="table table-bordered table-hover table-striped"><caption>STOP_NOTOK_RESP</caption><tbody><tr><td>7</td></tr><tr><td><strong>NOKString</strong></td></tr></tbody></table><p>where <strong>NOKString</strong> is "NOEXIST".</p><a name="distribution_handshake"></a><h3>Distribution Handshake</h3><p>This section describes the distribution handshake protocol introduced
in Erlang/OTP R6. The handshake has remained almost the same since then.</p><h3>General</h3><p>The TCP/IP distribution uses a handshake that expects a
connection-based protocol, that is, the protocol does not include any
authentication after the handshake procedure.</p><p>This is not entirely safe, as it is vulnerable against takeover
attacks, but it is a tradeoff between fair safety and performance.</p><p>The cookies are never sent in cleartext and the handshake procedure
expects the client (called <strong>A</strong>) to be the first one to prove that
it can generate a sufficient digest. The digest is generated with the
MD5 message digest algorithm and the challenges are expected to be
random numbers.</p><h3>Definitions</h3><p>A challenge is a 32-bit integer in big-endian order. Below the function
<strong>gen_challenge()</strong> returns a random 32-bit integer used as a
challenge.</p><p>A digest is a (16 bytes) MD5 hash of the challenge (as text)
concatenated with the cookie (as text). Below, the function
<strong>gen_digest(Challenge, Cookie)</strong> generates a digest as described
above.</p><p>An <strong>out_cookie</strong> is the cookie used in outgoing communication to a
certain node, so that <strong>A</strong>'s <strong>out_cookie</strong> for <strong>B</strong> is to
correspond with <strong>B</strong>'s <strong>in_cookie</strong> for <strong>A</strong> and conversely.
<strong>A</strong>'s <strong>out_cookie</strong> for <strong>B</strong> and <strong>A</strong>'s
<strong>in_cookie</strong> for <strong>B</strong> need <em>not</em> be the same. Below the
function <strong>out_cookie(Node)</strong> returns the current node's
<strong>out_cookie</strong> for <strong>Node</strong>.</p><p>An <strong>in_cookie</strong> is the cookie expected to be used by another node
when communicating with us, so that <strong>A</strong>'s <strong>in_cookie</strong> for
<strong>B</strong> corresponds with <strong>B</strong>'s <strong>out_cookie</strong> for <strong>A</strong>.
Below the function <strong>in_cookie(Node)</strong> returns the current node's
<strong>in_cookie</strong> for <strong>Node</strong>.</p><p>The cookies are text strings that can be viewed as passwords.</p><p>Every message in the handshake starts with a 16-bit big-endian integer,
which contains the message length (not counting the two initial bytes).
In Erlang this corresponds to option <strong>{packet, 2}</strong> in
<a href="./gen_tcp">kernel/gen_tcp</a>.
Notice that after the handshake, the distribution switches to 4 byte
packet headers.</p><h3>The Handshake in Detail</h3><p>Imagine two nodes, <strong>A</strong> that initiates the handshake and <strong>B</strong>
that accepts the connection.</p><dl><dt>1) connect/accept</dt><dd> <p><strong>A</strong> connects to <strong>B</strong> through TCP/IP and <strong>B</strong> accepts
the connection.</p> </dd><dt>2) <strong>send_name</strong>/<strong>receive_name</strong></dt><dd> <p><strong>A</strong> sends an initial identification to <strong>B</strong>, which
receives the message. The message looks as follows (every "square"
is one byte and the packet header is removed):</p> <pre>
+---+--------+--------+-----+-----+-----+-----+-----+-----+-...-+-----+
|'n'|Version0|Version1|Flag0|Flag1|Flag2|Flag3|Name0|Name1| ... |NameN|
+---+--------+--------+-----+-----+-----+-----+-----+-----+-... +-----+</pre> <p>'n' is the message tag. 'Version0' and 'Version1' is the
distribution version selected by <strong>A</strong>, based on information
from the EPMD. (16-bit big-endian) 'Flag0' ... 'Flag3' are
capability flags, the capabilities are defined in
<strong>$ERL_TOP/lib/kernel/include/dist.hrl</strong>. (32-bit big-endian)
'Name0' ... 'NameN' is the full node name of <strong>A</strong>, as a string
of bytes (the packet length denotes how long it is).</p> </dd><dt>3) <strong>recv_status</strong>/<strong>send_status</strong></dt><dd> <p><strong>B</strong> sends a status message to <strong>A</strong>, which indicates if the
connection is allowed. The following status codes are defined:</p> <dl><dt><strong>ok</strong></dt><dd> <p>The handshake will continue.</p> </dd><dt><strong>ok_simultaneous</strong></dt><dd> <p>The handshake will continue, but <strong>A</strong> is informed that
<strong>B</strong> has another ongoing connection attempt that will be
shut down (simultaneous connect where <strong>A</strong>'s name is
greater than <strong>B</strong>'s name, compared literally).</p> </dd><dt><strong>nok</strong></dt><dd> <p>The handshake will not continue, as <strong>B</strong> already has an
ongoing handshake, which it itself has initiated (simultaneous
connect where <strong>B</strong>'s name is greater than <strong>A</strong>'s).</p> </dd><dt><strong>not_allowed</strong></dt><dd> <p>The connection is disallowed for some (unspecified) security
reason.</p> </dd><dt><strong>alive</strong></dt><dd> <p>A connection to the node is already active, which either means
that node <strong>A</strong> is confused or that the TCP connection
breakdown of a previous node with this name has not yet reached
node <strong>B</strong>. See step 3B below.</p> </dd></dl> <p>The format of the status message is as follows:</p> <pre>
+---+-------+-------+-...-+-------+
|'s'|Status0|Status1| ... |StatusN|
+---+-------+-------+-...-+-------+</pre> <p>'s' is the message tag. 'Status0' ... 'StatusN' is the status as a
string (not terminated).</p> </dd><dt>3B) <strong>send_status</strong>/<strong>recv_status</strong></dt><dd> <p>If status was <strong>alive</strong>, node <strong>A</strong> answers with another
status message containing either <strong>true</strong>, which means that the
connection is to continue (the old connection from this node is
broken), or <strong>false</strong>, which means that the connection is to be
closed (the connection attempt was a mistake.</p> </dd><dt>4) <strong>recv_challenge</strong>/<strong>send_challenge</strong></dt><dd> <p>If the status was <strong>ok</strong> or <strong>ok_simultaneous</strong>, the
handshake continues with <strong>B</strong> sending <strong>A</strong> another message,
the challenge. The challenge contains the same type of information
as the "name" message initially sent from <strong>A</strong> to <strong>B</strong>, plus
a 32-bit challenge:</p> <pre>
+---+--------+--------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-...-+-----+
|'n'|Version0|Version1|Flag0|Flag1|Flag2|Flag3|Chal0|Chal1|Chal2|Chal3|Name0|Name1| ... |NameN|
+---+--------+--------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-... +-----+</pre> <p>'Chal0' ... 'Chal3' is the challenge as a 32-bit big-endian integer
and the other fields are <strong>B</strong>'s version, flags, and full node
name.</p> </dd><dt>5) <strong>send_challenge_reply</strong>/<strong>recv_challenge_reply</strong></dt><dd> <p>Now <strong>A</strong> has generated a digest and its own challenge. Those
are sent together in a package to <strong>B</strong>:</p> <pre>
+---+-----+-----+-----+-----+-----+-----+-----+-----+-...-+------+
|'r'|Chal0|Chal1|Chal2|Chal3|Dige0|Dige1|Dige2|Dige3| ... |Dige15|
+---+-----+-----+-----+-----+-----+-----+-----+-----+-...-+------+</pre> <p>'r' is the tag. 'Chal0' ... 'Chal3' is <strong>A</strong>'s challenge for
<strong>B</strong> to handle. 'Dige0' ... 'Dige15' is the digest that <strong>A</strong>
constructed from the challenge <strong>B</strong> sent in the previous
step.</p> </dd><dt>6) <strong>recv_challenge_ack</strong>/<strong>send_challenge_ack</strong></dt><dd> <p><strong>B</strong> checks that the digest received from <strong>A</strong> is correct
and generates a digest from the challenge received from <strong>A</strong>.
The digest is then sent to <strong>A</strong>. The message is as follows:</p> <pre>
+---+-----+-----+-----+-----+-...-+------+
|'a'|Dige0|Dige1|Dige2|Dige3| ... |Dige15|
+---+-----+-----+-----+-----+-...-+------+</pre> <p>'a' is the tag. 'Dige0' ... 'Dige15' is the digest calculated by
<strong>B</strong> for <strong>A</strong>'s challenge.</p> </dd><dt>7) check</dt><dd> <p><strong>A</strong> checks the digest from <strong>B</strong> and the connection is
up.</p> </dd></dl><h3>Semigraphic View</h3><pre>
A (initiator)                                      B (acceptor)

TCP connect ------------------------------------&gt;
                                                   TCP accept

send_name --------------------------------------&gt;
                                                   recv_name

  &lt;---------------------------------------------- send_status
recv_status
(if status was 'alive'
 send_status - - - - - - - - - - - - - - - - - -&gt;
                                                   recv_status)
                                                   ChB = gen_challenge()
                          (ChB)
  &lt;---------------------------------------------- send_challenge
recv_challenge
ChA = gen_challenge(),
OCA = out_cookie(B),
DiA = gen_digest(ChB, OCA)
                          (ChA, DiA)
send_challenge_reply ---------------------------&gt;
                                                   recv_challenge_reply
                                                   ICB = in_cookie(A),
                                                   check:
                                                   DiA == gen_digest (ChB, ICB)?
                                                   - if OK:
                                                    OCB = out_cookie(A),
                                                    DiB = gen_digest (ChA, OCB)
                          (DiB)
  &lt;----------------------------------------------- send_challenge_ack
recv_challenge_ack                                  DONE
ICA = in_cookie(B),                                - else:
check:                                              CLOSE
DiB == gen_digest(ChA, ICA)?
- if OK:
 DONE
- else:
 CLOSE</pre><a name="dflags"></a><h3>Distribution Flags</h3><p>The following capability flags are defined:</p><dl><dt><strong>-define(DFLAG_PUBLISHED,16#1).</strong></dt><dd> <p>The node is to be published and part of the global namespace.</p> </dd><dt><strong>-define(DFLAG_ATOM_CACHE,16#2).</strong></dt><dd> <p>The node implements an atom cache (obsolete).</p> </dd><dt><strong>-define(DFLAG_EXTENDED_REFERENCES,16#4).</strong></dt><dd> <p>The node implements extended (3 Ã 32 bits) references. This
is required today. If not present, the  connection is refused.</p> </dd><dt><strong>-define(DFLAG_DIST_MONITOR,16#8).</strong></dt><dd> <p>The node implements distributed process monitoring.</p> </dd><dt><strong>-define(DFLAG_FUN_TAGS,16#10).</strong></dt><dd> <p>The node uses separate tag for funs (lambdas) in the distribution
protocol.</p> </dd><dt><strong>-define(DFLAG_DIST_MONITOR_NAME,16#20).</strong></dt><dd> <p>The node implements distributed named process monitoring.</p> </dd><dt><strong>-define(DFLAG_HIDDEN_ATOM_CACHE,16#40).</strong></dt><dd> <p>The (hidden) node implements atom cache (obsolete).</p> </dd><dt><strong>-define(DFLAG_NEW_FUN_TAGS,16#80).</strong></dt><dd> <p>The node understand new fun tags.</p> </dd><dt><strong>-define(DFLAG_EXTENDED_PIDS_PORTS,16#100).</strong></dt><dd> <p>The node can handle extended pids and ports. This is required
today. If not present, the connection is refused.</p> </dd><dt><strong>-define(DFLAG_EXPORT_PTR_TAG,16#200).</strong></dt><dd> </dd><dt><strong>-define(DFLAG_BIT_BINARIES,16#400).</strong></dt><dd> </dd><dt><strong>-define(DFLAG_NEW_FLOATS,16#800).</strong></dt><dd> <p>The node understands new float format.</p> </dd><dt><strong>-define(DFLAG_UNICODE_IO,16#1000).</strong></dt><dd> </dd><dt><strong>-define(DFLAG_DIST_HDR_ATOM_CACHE,16#2000).</strong></dt><dd> <p>The node implements atom cache in distribution header.</p> </dd><dt><strong>-define(DFLAG_SMALL_ATOM_TAGS, 16#4000).</strong></dt><dd> <p>The node understand the <strong>SMALL_ATOM_EXT</strong> tag.</p> </dd><dt><strong>-define(DFLAG_UTF8_ATOMS, 16#10000).</strong></dt><dd> <p>The node understand UTF-8 encoded atoms.</p> </dd><dt><strong>-define(DFLAG_MAP_TAG, 16#20000).</strong></dt><dd> <p>The node understand the map tag.</p> </dd><dt><strong>-define(DFLAG_BIG_CREATION, 16#40000).</strong></dt><dd> <p>The node understand big node creation.</p> </dd><dt><strong>-define(DFLAG_SEND_SENDER, 16#80000).</strong></dt><dd> <p>
Use the <strong>SEND_SENDER</strong>
<a href="#control_message">control message</a>
instead of the <strong>SEND</strong> control message and use the
<strong>SEND_SENDER_TT</strong> control message instead
of the <strong>SEND_TT</strong> control message.
</p> </dd><dt><strong>-define(DFLAG_BIG_SEQTRACE_LABELS, 16#100000).</strong></dt><dd> <p>The node understands any term as the seqtrace label.</p> </dd><dt><strong>-define(DFLAG_EXIT_PAYLOAD, 16#400000).</strong></dt><dd> <p>Use the <strong>PAYLOAD_EXIT</strong>, <strong>PAYLOAD_EXIT_TT</strong>,
<strong>PAYLOAD_EXIT2</strong>, <strong>PAYLOAD_EXIT2_TT</strong>
and <strong>PAYLOAD_MONITOR_P_EXIT</strong>
<a href="#control_message">control message</a>s
instead of the non-PAYLOAD variants.</p> </dd><dt><strong>-define(DFLAG_FRAGMENTS, 16#800000).</strong></dt><dd> <p>Use <a href="./erl_ext_dist#fragments">fragmented</a>
distribution messages to send large messages.</p> </dd></dl><p>
There is also function <strong>dist_util:strict_order_flags/0</strong>
returning all flags (bitwise or:ed together) corresponding to features
that require strict ordering of data over distribution channels.
</p><a name="connected_nodes"></a><h3>Protocol between Connected Nodes</h3><p>Since ERTS 5.7.2 (OTP R13B) the runtime system passes a distribution flag
in the handshake stage that enables the use of a
<a href="./erl_ext_dist#distribution_header">distribution header </a> on all messages passed. Messages passed between nodes have in
this case the following format:</p><table class="table table-bordered table-hover table-striped"><caption>Format of Messages Passed between Nodes (as from ERTS 5.7.2 (OTP R13B))
</caption><tbody><tr><td>4</td><td>d</td><td>n</td><td>m</td></tr><tr><td><strong>Length</strong></td><td><strong>DistributionHeader</strong></td><td><strong>ControlMessage</strong></td><td><strong>Message</strong></td></tr></tbody></table><dl><dt><strong>Length</strong></dt><dd> <p>Equal to d + n + m.</p> </dd><dt><strong>DistributionHeader</strong></dt><dd> <p>
<a href="./erl_ext_dist#distribution_header">Distribution header describing the atom cache and fragmented distribution messages. </a>
</p> </dd><dt><strong>ControlMessage</strong></dt><dd> <p>A tuple passed using the external format of Erlang.</p> </dd><dt><strong>Message</strong></dt><dd> <p>The message sent to another node using the '!'
or the reason for a EXIT, EXIT2 or DOWN signal using
the external term format.</p> </dd></dl><p>Notice that <a href="./erl_ext_dist#overall_format">the version number is omitted from the terms that follow a distribution header </a>.</p><p>Nodes with an ERTS version earlier than 5.7.2 (OTP R13B) does not pass the
distribution flag that enables the distribution header. Messages passed
between nodes have in this case the following format:</p><table class="table table-bordered table-hover table-striped"><caption>Format of Messages Passed between Nodes (before ERTS 5.7.2 (OTP R13B))
</caption><tbody><tr><td>4</td><td>1</td><td>n</td><td>m</td></tr><tr><td><strong>Length</strong></td><td><strong>Type</strong></td><td><strong>ControlMessage</strong></td><td><strong>Message</strong></td></tr></tbody></table><dl><dt><strong>Length</strong></dt><dd> <p>Equal to 1 + n + m.</p> </dd><dt><strong>Type</strong></dt><dd> <p>Equal to <strong>112</strong> (pass through).</p> </dd><dt><strong>ControlMessage</strong></dt><dd> <p>A tuple passed using the external format of Erlang.</p> </dd><dt><strong>Message</strong></dt><dd> <p>The message sent to another node using the '!' (in external format).
Notice that <strong>Message</strong> is only passed in combination with a
<strong>ControlMessage</strong> encoding a send ('!').</p> </dd></dl><a name="control_message"></a><p>The <strong>ControlMessage</strong> is a tuple, where the first element indicates
which distributed operation it encodes:</p><dl><dt><strong>LINK</strong></dt><dd> <p><strong>{1, FromPid, ToPid}</strong></p> </dd><dt><strong>SEND</strong></dt><dd> <p><strong>{2, Unused, ToPid}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p><strong>Unused</strong> is kept for backward compatibility.</p> </dd><dt><strong>EXIT</strong></dt><dd> <p><strong>{3, FromPid, ToPid, Reason}</strong></p> <p>This signal is sent when a link has been broken</p> </dd><dt><strong>UNLINK</strong></dt><dd> <p><strong>{4, FromPid, ToPid}</strong></p> </dd><dt><strong>NODE_LINK</strong></dt><dd> <p><strong>{5}</strong></p> </dd><dt><strong>REG_SEND</strong></dt><dd> <p><strong>{6, FromPid, Unused, ToName}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p><strong>Unused</strong> is kept for backward compatibility.</p> </dd><dt><strong>GROUP_LEADER</strong></dt><dd> <p><strong>{7, FromPid, ToPid}</strong></p> </dd><dt><strong>EXIT2</strong></dt><dd> <p><strong>{8, FromPid, ToPid, Reason}</strong></p> <p>This signal is sent by a call to the erlang:exit/2 bif</p> </dd></dl><h3>New Ctrlmessages for distrvsn = 1 (Erlang/OTP R4)</h3><dl><dt><strong>SEND_TT</strong></dt><dd> <p><strong>{12, Unused, ToPid, TraceToken}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p><strong>Unused</strong> is kept for backward compatibility.</p> </dd><dt><strong>EXIT_TT</strong></dt><dd> <p><strong>{13, FromPid, ToPid, TraceToken, Reason}</strong></p> </dd><dt><strong>REG_SEND_TT</strong></dt><dd> <p><strong>{16, FromPid, Unused, ToName, TraceToken}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p><strong>Unused</strong> is kept for backward compatibility.</p> </dd><dt><strong>EXIT2_TT</strong></dt><dd> <p><strong>{18, FromPid, ToPid, TraceToken, Reason}</strong></p> </dd></dl><h3>New Ctrlmessages for distrvsn = 2</h3><p><strong>distrvsn</strong> 2 was never used.</p><h3>New Ctrlmessages for distrvsn = 3 (Erlang/OTP R5C)</h3><p>None, but the version number was increased anyway.</p><h3>New Ctrlmessages for distrvsn = 4 (Erlang/OTP R6)</h3><p>These are only recognized by Erlang nodes, not by hidden nodes.</p><dl><dt><strong>MONITOR_P</strong></dt><dd> <p><strong>{19, FromPid, ToProc, Ref}</strong>, where
<strong>FromPid</strong> = monitoring process and
<strong>ToProc</strong> = monitored process pid or name (atom)</p> </dd><dt><strong>DEMONITOR_P</strong></dt><dd> <p><strong>{20, FromPid, ToProc, Ref}</strong>, where
<strong>FromPid</strong> = monitoring process and
<strong>ToProc</strong> = monitored process pid or name (atom)</p> <p>We include <strong>FromPid</strong> just in case we want to trace this.</p> </dd><dt><strong>MONITOR_P_EXIT</strong></dt><dd> <p><strong>{21, FromProc, ToPid, Ref, Reason}</strong>, where
<strong>FromProc</strong> = monitored process pid or name (atom),
<strong>ToPid</strong> = monitoring process, and
<strong>Reason</strong> = exit reason for the monitored process</p> </dd></dl><h3>New Ctrlmessages for Erlang/OTP 21</h3><dl><dt><strong>SEND_SENDER</strong></dt><dd> <p><strong>{22, FromPid, ToPid}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p>
This control message replaces the <strong>SEND</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Messages encoded before the connection has
been set up may still use the <strong>SEND</strong> control
message. However, once a <strong>SEND_SENDER</strong> or <strong>SEND_SENDER_TT</strong>
control message has been sent, no more <strong>SEND</strong>
control messages will be sent in the same direction
on the connection.
</p></div> </dd><dt><strong>SEND_SENDER_TT</strong></dt><dd> <p><strong>{23, FromPid, ToPid, TraceToken}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p>
This control message replaces the <strong>SEND_TT</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Messages encoded before the connection has
been set up may still use the <strong>SEND_TT</strong> control
message. However, once a <strong>SEND_SENDER</strong> or <strong>SEND_SENDER_TT</strong>
control message has been sent, no more <strong>SEND_TT</strong>
control messages will be sent in the same direction
on the connection.
</p></div> </dd></dl><h3>New Ctrlmessages for Erlang/OTP 22</h3><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Messages encoded before the connection has
been set up may still use the non-PAYLOAD variant.
However, once a PAYLOAD control message has been sent,
no more non-PAYLOAD control messages will be sent in
the same direction on the connection.
</p></div><dl><dt><strong>PAYLOAD_EXIT</strong></dt><dd> <p><strong>{24, FromPid, ToPid}</strong></p> <p>Followed by <strong>Reason</strong>.</p> <p>
This control message replaces the <strong>EXIT</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> </dd><dt><strong>PAYLOAD_EXIT_TT</strong></dt><dd> <p><strong>{25, FromPid, ToPid}</strong></p> <p>Followed by <strong>Reason</strong>.</p> <p>
This control message replaces the <strong>EXIT_TT</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> </dd><dt><strong>PAYLOAD_EXIT2</strong></dt><dd> <p><strong>{26, FromPid, ToPid}</strong></p> <p>Followed by <strong>Reason</strong>.</p> <p>
This control message replaces the <strong>EXIT2</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> </dd><dt><strong>PAYLOAD_EXIT2_TT</strong></dt><dd> <p><strong>{27, FromPid, ToPid}</strong></p> <p>Followed by <strong>Reason</strong>.</p> <p>
This control message replaces the <strong>EXIT2_TT</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> </dd><dt><strong>PAYLOAD_MONITOR_P_EXIT</strong></dt><dd> <p><strong>{28, FromPid, ToPid, Ref}</strong></p> <p>Followed by <strong>Reason</strong>.</p> <p>
This control message replaces the <strong>MONITOR_P_EXIT</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> </dd></dl></body></html>