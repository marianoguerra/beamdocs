<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Erlang Run-Time System Application (ERTS)</h1><h1>Erlang Run-Time System Application (ERTS)</h1><h4>Scope</h4><p>The Erlang Runtime System Application, ERTS, contains
functionality necessary to run the Erlang system.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>By default, <strong>ERTS</strong> is only guaranteed to be
compatible with other Erlang/OTP components from the same release as
<strong>ERTS</strong> itself.</p><p>For information on how to communicate with Erlang/OTP components
from earlier releases, see the documentation of system flag
<a href="./erl#compat_rel">erl#compat_rel</a> in <strong>erl(1)</strong>.
</p></div><h4>Prerequisites</h4><p>It is assumed that the reader is familiar with the Erlang programming
language.</p><p>Communication in Erlang is conceptually performed using
asynchronous signaling. All different executing entities,
such as processes and ports, communicate through asynchronous
signals. The most commonly used signal is a message. Other
common signals are exit, link, unlink, monitor, and demonitor
signals.</p><h4>Passing of Signals</h4><p>The amount of time that passes between a signal is sent
and the arrival of the signal at the destination is unspecified
but positive. If the receiver has terminated, the signal does
not arrive, but it can trigger another signal.
For example, a link signal sent to a non-existing process
triggers an exit signal, which is sent back to where the link
signal originated from. When communicating over the distribution,
signals can be lost if the distribution channel goes down.</p><p>The only signal ordering guarantee given is the following: if
an entity sends multiple signals to the same destination entity,
the order is preserved; that is, if <strong>A</strong> sends
a signal <strong>S1</strong> to <strong>B</strong>, and later sends
signal <strong>S2</strong> to <strong>B</strong>, <strong>S1</strong> is guaranteed not to
arrive after <strong>S2</strong>.</p><h4>Synchronous Communication</h4><p>Some communication is synchronous. If broken down into pieces,
a synchronous communication operation consists of two asynchronous
signals; one request signal and one reply signal. An example of
such a synchronous communication is a call to
<a href="./erlang#process_info/2">erlang#process_info/2</a>
when the first argument is not <strong>self()</strong>. The caller sends
an asynchronous signal requesting information, and then
waits for the reply signal containing the requested information. When
the request signal reaches its destination, the destination process
replies with the requested information.</p><h4>Implementation</h4><p>The implementation of different asynchronous signals in the virtual
machine can vary over time, but the behavior always respects this
concept of asynchronous signals being passed between entities
as described above.</p><p>By inspecting the implementation, you might notice that some
specific signal gives a stricter guarantee than described
above. It is of vital importance that such knowledge about the
implementation is <em>not</em> used by Erlang code, as the
implementation can change at any time without prior notice.</p><p>Examples of major implementation changes:</p><ul><li>As from ERTS 5.5.2 exit signals to processes are truly asynchronously delivered.</li><li>As from ERTS 5.10 all signals from processes to ports are truly asynchronously delivered.</li></ul><h4>New Extended Time Functionality</h4><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from Erlang/OTP 18 (ERTS 7.0) the time functionality
has been extended. This includes a
<a href="#The_New_Time_API">new API</a>
for time and
<a href="#Time_Warp_Modes">time warp modes</a> that change the system behavior when
system time changes.</p><p>The <a href="#No_Time_Warp_Mode">default time warp mode</a> has the same behavior as before, and the
old API still works. Thus, you are not required to change
anything unless you want to. However, <em>you are strongly encouraged to use the new API</em> instead of the old API based
on <a href="./erlang#now/0">erlang#now/0</a>.
<strong>erlang:now/0</strong> is deprecated, as it is and
will be a scalability bottleneck.</p><p>By using the new API, you
automatically get scalability and performance improvements. This
also enables you to use the
<a href="#Multi_Time_Warp_Mode">multi-time warp mode</a>
that improves accuracy and precision of time measurements.</p></div><h4>Terminology</h4><p>To make it easier to understand this section, some terms
are defined. This is a mix of our own terminology
(Erlang/OS system time, Erlang/OS monotonic time, time warp)
and globally accepted terminology.</p><a name="Monotonically_Increasing"></a><h4>Monotonically Increasing</h4><p>In a monotonically increasing sequence of values, all values
that have a predecessor are either larger than or equal to its
predecessor.</p><a name="Strictly_Monotonically_Increasing"></a><h4>Strictly Monotonically Increasing</h4><p>In a strictly monotonically increasing sequence of values,
all values that have a predecessor are larger than its
predecessor.</p><a name="UT1"></a><h4>UT1</h4><p>Universal Time. UT1 is based on the rotation of the earth
and conceptually means solar time at 0Â° longitude.</p><a name="UTC"></a><h4>UTC</h4><p>Coordinated Universal Time. UTC almost aligns with
<a href="#UT1">UT1</a>. However, UTC uses the
SI definition of a second, which has not exactly the same length
as the second used by UT1. This means that UTC slowly drifts from
UT1. To keep UTC relatively in sync with UT1, leap seconds
are inserted, and potentially also deleted. That is, an UTC day can
be 86400, 86401, or 86399 seconds long.</p><a name="POSIX_Time"></a><h4>POSIX Time</h4><p>Time since
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap03.html#tag_21_03_00_17"> Epoch</a>.
Epoch is defined to be 00:00:00 <a href="#UTC">UTC</a>,
1970-01-01.
<a href="http://pubs.opengroup.org/onlinepubs/009604499/basedefs/xbd_chap04.html#tag_04_14"> A day in POSIX time</a>
is defined to be exactly 86400 seconds long. Strangely enough,
Epoch is defined to be a time in UTC, and UTC has another
definition of how long a day is. Quoting the Open Group
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_15"> "POSIX time is therefore not necessarily UTC, despite its appearance"</a>.
The effect of this is that when an UTC leap second is
inserted, POSIX time either stops for a second, or repeats the
last second. If an UTC leap second would be deleted (which has not
happened yet), POSIX time would make a one second leap forward.</p><a name="Time_Resolution"></a><h4>Time Resolution</h4><p>The shortest time interval that can be distinguished when
reading time values.</p><a name="Time_Precision"></a><h4>Time Precision</h4><p>The shortest time interval that can be distinguished
repeatedly and reliably when reading time values. Precision
is limited by the
<a href="#Time_Resolution">resolution</a>, but
resolution and precision can differ significantly.</p><a name="Time_Accuracy"></a><h4>Time Accuracy</h4><p>The correctness of time values.</p><a name="Time_Warp"></a><h4>Time Warp</h4><p>A time warp is a leap forwards or backwards in time. That
is, the difference of time values taken before and after the
time warp does not correspond to the actual elapsed time.</p><a name="OS_System_Time"></a><h4>OS System Time</h4><p>The operating systems view of
<a href="#POSIX_Time">POSIX time</a>. To
retrieve it, call
<a href="../kernel/os#system_time/0">kernel/os#system_time/0</a>.
This may or may not be an accurate view of POSIX time. This time
may typically be adjusted both backwards and forwards without
limitation. That is, <a href="#Time_Warp">time warps</a>
may be observed.</p><p>To get information about the Erlang runtime
system's source of OS system time, call
<a href="./erlang#system_info_os_system_time_source">erlang#system_info_os_system_time_source</a>.</p><a name="OS_Monotonic_Time"></a><h4>OS Monotonic Time</h4><p>A monotonically increasing time provided by the OS.
This time does not leap and has a relatively steady
frequency although not completely correct. However, it is not
uncommon that OS monotonic time stops if the system is
suspended. This time typically increases since some
unspecified point in time that is not connected to
<a href="#OS_System_Time">OS system time</a>.
This type of time is not necessarily provided by all OSs.</p><p>To get information about the Erlang
runtime system's source of OS monotonic time, call
<a href="./erlang#system_info_os_monotonic_time_source">erlang#system_info_os_monotonic_time_source</a>.</p><a name="Erlang_System_Time"></a><h4>Erlang System Time</h4><p>The Erlang runtime systems view of
<a href="#POSIX_Time">POSIX time</a>. To
retrieve it, call
<a href="./erlang#system_time/0">erlang#system_time/0</a>.</p><p>This time may or may not be an accurate view of POSIX time,
and may
or may not align with <a href="#OS_System_Time">OS system time</a>. The runtime system works towards aligning the two
system times. Depending on the
<a href="#Time_Warp_Modes">time warp mode</a> used,
this can be achieved by letting Erlang
system time perform a <a href="#Time_Warp">time warp</a>.</p><a name="Erlang_Monotonic_Time"></a><h4>Erlang Monotonic Time</h4><p>A monotonically increasing time provided by the
Erlang runtime system. Erlang monotonic time increases since
some unspecified point in time. To retrieve it, call
<a href="./erlang#monotonic_time/0">erlang#monotonic_time/0</a>.</p><p>The <a href="#Time_Accuracy">accuracy</a> and
<a href="#Time_Precision">precision</a> of Erlang
monotonic time heavily depends on the following:</p><ul><li>Accuracy and precision of <a href="#OS_Monotonic_Time">OS monotonic time</a> </li><li>Accuracy and precision of <a href="#OS_System_Time">OS system time</a> </li><li><a href="#Time_Warp_Modes"> time warp mode</a> used </li></ul><p>On a system without OS monotonic time, Erlang monotonic
time guarantees monotonicity, but cannot give
other guarantees. The frequency adjustments made to
Erlang monotonic time depend on the time warp mode used.</p><p>Internally in the runtime system, Erlang monotonic
time is the "time engine" that is used for more or less
everything that has anything to do with time. All timers,
regardless of it is a <strong>receive ... after</strong> timer, BIF timer,
or a timer in the
<a href="./timer">stdlib/timer</a>
module, are triggered relative Erlang monotonic time. Even
<a href="#Erlang_System_Time">Erlang system time</a> is based on Erlang monotonic time.
By adding current Erlang monotonic time with current time
offset, you get current Erlang system time.</p><p>To retrieve the current time offset, call
<a href="./erlang#time_offset/0">erlang#time_offset/0</a>.</p><h4>Introduction</h4><p>Time is vital to an Erlang program and, more importantly, <em>correct</em>
time is vital to an Erlang program. As Erlang is a language with
soft real-time properties and we can express
time in our programs, the Virtual Machine and the language must be
careful about what is considered a correct time and in
how time functions behave.</p><p>When Erlang was designed, it was assumed that the wall
clock time in the system showed a monotonic time moving forward at
exactly the same pace as the definition of time. This more or less meant
that an atomic clock (or better time source) was expected to be attached
to your hardware and that the hardware was then expected to be
locked away from any human tinkering forever. While this can be a
compelling thought, it is simply never the case.</p><p>A "normal" modern computer cannot keep time, not on itself and
not unless you have a chip-level atomic clock wired to it. Time,
as perceived by your computer, must normally be corrected. Hence
the Network Time Protocol (NTP) protocol, together with the <strong>ntpd</strong>
process, does its best to keep your computer time in sync with
the correct time. Between NTP corrections, usually a
less potent time-keeper than an atomic clock is used.</p><p>However, NTP is not fail-safe. The NTP server can be unavailable,
<strong>ntp.conf</strong> can be wrongly configured, or your computer can
sometimes be disconnected from Internet. Furthermore, you can have a
user (or even system administrator) who thinks the correct
way to handle Daylight Saving Time is to adjust the clock one
hour two times a year (which is the incorrect way to do it).
To complicate things further, this user fetched your
software from Internet and has not considered what
the correct time is as perceived by a computer. The user does
not care about keeping the wall clock in sync with the correct
time. The user expects your program to have unlimited knowledge
about the time.</p><p>Most programmers also expect time to be reliable, at least until
they realize that the wall clock time on their workstation is off by
a minute. Then they set it to the correct time, but most probably
not in a smooth way.</p><p>The number of problems that arise when you always expect the wall clock
time on the system to be correct can be immense. Erlang therefore
introduced the "corrected estimate of time", or the "time
correction", many years ago. The time correction relies on the fact
that most operating systems have some kind of monotonic clock,
either a real-time extension or some built-in "tick counter" that is
independent of the wall clock settings. This counter can have
microsecond resolution or much less, but it has a drift that cannot
be ignored.</p><a name="Time_Correction"></a><h4>Time Correction</h4><p>If time correction is enabled, the Erlang runtime system
makes use of both
<a href="#OS_System_Time">OS system time</a>
and <a href="#OS_Monotonic_Time">OS monotonic time</a>,
to adjust the frequency of the Erlang
monotonic clock. Time correction ensures that
<a href="#Erlang_Monotonic_Time">Erlang monotonic time</a>
does not warp and that the frequency is relatively accurate.
The type of frequency adjustments depends on the time warp mode used.
Section <a href="#Time_Warp_Modes">Time Warp Modes</a>
provides more details.</p><p>By default time correction is enabled if support for
it exists on the specific platform. Support for it includes
both OS monotonic time, provided by the OS, and an
implementation in the Erlang runtime system using
OS monotonic time. To check if your system has support
for OS monotonic time, call
<a href="./erlang#system_info_os_monotonic_time_source">erlang#system_info_os_monotonic_time_source</a>.
To check if time correction is enabled on your system, call
<a href="./erlang#system_info_time_correction">erlang#system_info_time_correction</a>.</p><p>To enable or disable time correction, pass command-line argument
<a href="./erl#+c">erl#+c</a> to
<a href="erl">erl</a>.</p><p>If time correction is disabled, Erlang monotonic time
can warp forwards or stop, or even freeze for extended
periods of time. There are then no guarantees that the frequency
of the Erlang monotonic clock is accurate or stable.</p><p><em>You typically never want to disable time correction</em>.
Previously a performance penalty was associated with time
correction, but nowadays it is usually the other way around.
If time correction is disabled, you probably get bad scalability,
bad performance, and bad time measurements.</p><a name="Time_Warp_Safe_Code"></a><h4>Time Warp Safe Code</h4><p>Time warp safe code can handle
a <a href="#Time_Warp">time warp</a> of
<a href="#Erlang_System_Time">Erlang system time</a>.</p><p><a href="./erlang#now/0">erlang#now/0</a>
behaves bad when Erlang system time warps. When Erlang
system time does a time warp backwards, the values returned
from <strong>erlang:now/0</strong> freeze (if you disregard the
microsecond increments made because of the actual call) until
OS system time reaches the point of the last value returned by
<strong>erlang:now/0</strong>. This freeze can continue for a long time. It
can take years, decades, and even longer until the freeze stops.</p><p>All uses of <strong>erlang:now/0</strong> are not necessarily
time warp unsafe. If you do not use it to get time, it
is time warp safe. However, <em>all uses of erlang:now/0 are suboptimal</em> from a performance
and scalability perspective. So you really want to replace
the use of it with other functionality. For examples
of how to replace the use of <strong>erlang:now/0</strong>, see section
<a href="#Dos_and_Donts">How to Work with the New API</a>.</p><h4>Time Warp Modes</h4><a name="Time_Warp_Modes"></a><p>Current <a href="#Erlang_System_Time">Erlang system time</a> is determined by adding the current
<a href="./erlang#monotonic_time/0">Erlang monotonic time</a>
with current
<a href="./erlang#time_offset/0">time offset</a>. The
time offset is managed differently depending on which time
warp mode you use.</p><p>To set the time warp mode, pass command-line argument
<a href="./erl#+C_">erl#+C_</a> to
<a href="erl">erl</a>.</p><a name="No_Time_Warp_Mode"></a><h4>No Time Warp Mode</h4><p>The time offset is determined at runtime system start
and does not change later. This is the default behavior, but
not because it is the best mode (which it is not). It is
default <em>only</em> because this is how the runtime system
behaved until ERTS 7.0.
Ensure that your Erlang code that can execute during a time
warp is <a href="#Time_Warp_Safe_Code">time warp safe</a> before enabling other modes.</p><p>As the time offset is not allowed to change, time
correction must adjust the frequency of the Erlang
monotonic clock to align Erlang system time with OS
system time smoothly. A significant downside of this approach
is that we on purpose will use a faulty frequency on the
Erlang monotonic clock if adjustments are needed. This
error can be as large as 1%. This error will show up in all
time measurements in the runtime system.</p><p>If time correction is not enabled, Erlang monotonic
time freezes when OS system time leaps backwards.
The freeze of monotonic time continues until
OS system time catches up. The freeze can continue for
a long time. When OS system time leaps forwards,
Erlang monotonic time also leaps forward.</p><a name="Single_Time_Warp_Mode"></a><h4>Single Time Warp Mode</h4><p>This mode is more or less a backward compatibility mode
as from its introduction.</p><p>On an embedded system it is not uncommon that the system
has no power supply, not even a battery, when it is
shut off. The system clock on such a system is typically
way off when the system boots. If
<a href="#No_Time_Warp_Mode">no time warp mode</a>
is used, and the Erlang runtime system is started before
OS system time has been corrected, Erlang system time
can be wrong for a long time, centuries or even longer.</p><p>If you need to use Erlang code that is not
<a href="#Time_Warp_Safe_Code">time warp safe</a>,
and you need to start the Erlang runtime system before OS
system time has been corrected, you may want to use the single
time warp mode.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>There are limitations to when you can
execute time warp unsafe code using this mode. If it is possible
to use time warp safe code only, it is <em>much</em> better
to use the <a href="#Multi_Time_Warp_Mode">multi-time warp mode</a> instead.</p></div><p>Using the single time warp mode, the time offset is
handled in two phases:</p><dl><dt>Preliminary Phase</dt><dd> <p>This phase starts when the runtime
system starts. A preliminary time offset based on
current OS system time is determined. This offset is from
now on to be fixed during the whole preliminary phase.</p> <p>If time correction is enabled, adjustments to the
Erlang monotonic clock are made to keep its
frequency as correct as possible. However, <em>no</em>
adjustments are made trying to align Erlang system
time and OS system time. That is, during the preliminary phase
Erlang system time and OS system time can diverge
from each other, and no attempt is made to prevent this.</p> <p>If time correction is disabled, changes in OS system
time affects the monotonic clock the same way as
when the <a href="#No_Time_Warp_Mode">no time warp mode</a> is used.</p> </dd><dt>Final Phase</dt><dd> <p>This phase begins when the user finalizes the time
offset by calling
<a href="./erlang#system_flag_time_offset">erlang#system_flag_time_offset</a>.
The finalization can only be performed once.</p> <p>During finalization, the time offset is adjusted and
fixed so that current Erlang system time aligns with the
current OS system time. As the time offset can
change during the finalization, Erlang system time
can do a time warp at this point. The time offset is
from now on fixed until the runtime system terminates.
If time correction has been enabled, the time
correction from now on also makes adjustments
to align Erlang system time with OS system
time. When the system is in the final phase, it behaves
exactly as in <a href="#No_Time_Warp_Mode">no time warp mode</a>.</p> </dd></dl><p>In order for this to work properly, the user must ensure
that the following two requirements are satisfied:</p><dl><dt>Forward Time Warp</dt><dd><p>The time warp made when finalizing the time offset
can only be done forwards without encountering problems.
This implies that the user must ensure that OS
system time is set to a time earlier or equal to actual
POSIX time before starting the Erlang runtime system.</p> <p>If you are not sure that OS system time is correct,
set it to a time that is guaranteed to be earlier than
actual POSIX time before starting the Erlang runtime
system, just to be safe.</p> </dd><dt>Finalize Correct OS System Time</dt><dd><p>OS system time must be correct when
the user finalizes the time offset.</p> </dd></dl><p>If these requirements are not fulfilled, the system
may behave very bad.</p><p>Assuming that these requirements are fulfilled,
time correction is enabled, and OS system time
is adjusted using a time adjustment protocol such as NTP,
only small adjustments of Erlang monotonic
time are needed to keep system times
aligned after finalization. As long as the system is not
suspended, the largest adjustments needed are for
inserted (or deleted) leap seconds.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>To use this mode, ensure that
all Erlang code that will execute in both phases is
<a href="#Time_Warp_Safe_Code">time warp safe</a>.</p><p>Code executing only in the final phase does not have
to be able to cope with the time warp.</p></div><a name="Multi_Time_Warp_Mode"></a><h4>Multi-Time Warp Mode</h4><p><em>Multi-time warp mode in combination with time correction is the preferred configuration</em>. This as
the Erlang runtime system have better performance, scale
better, and behave better on almost all platforms.
Also, the accuracy and precision of time measurements
are better. Only Erlang runtime systems executing on
ancient platforms benefit from another configuration.</p><p>The time offset can change at any time without limitations.
That is, Erlang system time can perform time warps both
forwards and backwards at <em>any</em> time. As we align
Erlang system time with OS system time by changing
the time offset, we can enable a time correction that tries
to adjust the frequency of the Erlang monotonic clock to be as
correct as possible. This makes time measurements using
Erlang monotonic time more accurate and precise.</p><p>If time correction is disabled, Erlang monotonic time
leaps forward if OS system time leaps forward. If
OS system time leaps backwards, Erlang monotonic time
stops briefly, but it does not freeze for extended periods
of time. This as the time offset is changed to
align Erlang system time with OS system time.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>To use this mode, ensure that all
Erlang code that will execute on the runtime system is
<a href="#Time_Warp_Safe_Code">time warp safe</a>.</p></div><h4>New Time API</h4><a name="The_New_Time_API"></a><p>The old time API is based on
<a href="./erlang#now/0">erlang#now/0</a>.
<strong>erlang:now/0</strong> was intended to be used for many unrelated
things. This tied these unrelated operations together and
caused issues with performance, scalability, accuracy, and
precision for operations that did not need to have
such issues. To improve this, the new API spreads different
functionality over multiple functions.</p><p>To be backward compatible, <strong>erlang:now/0</strong>
remains "as is", but <em>you are strongly discouraged from using it</em>. Many use cases of <strong>erlang:now/0</strong>
prevents you from using the new
<a href="#Multi_Time_Warp_Mode">multi-time warp mode</a>, which is an important part of this
new time functionality improvement.</p><p>Some of the new BIFs on some systems, perhaps surprisingly,
return negative integer values on a newly started runtime
system. This is not a bug, but a memory use optimization.</p><p>The new API consists of the following new BIFs:</p><ul><li><p><a href="./erlang#convert_time_unit/3">erlang#convert_time_unit/3</a></p></li><li><p><a href="./erlang#monotonic_time/0">erlang#monotonic_time/0</a></p></li><li><p><a href="./erlang#monotonic_time/1">erlang#monotonic_time/1</a></p></li><li><p><a href="./erlang#system_time/0">erlang#system_time/0</a></p></li><li><p><a href="./erlang#system_time/1">erlang#system_time/1</a></p></li><li><p><a href="./erlang#time_offset/0">erlang#time_offset/0</a></p></li><li><p><a href="./erlang#time_offset/1">erlang#time_offset/1</a></p></li><li><p><a href="./erlang#timestamp/0">erlang#timestamp/0</a></p></li><li><p><a href="./erlang#unique_integer/0">erlang#unique_integer/0</a></p></li><li><p><a href="./erlang#unique_integer/1">erlang#unique_integer/1</a></p></li><li><p><a href="../kernel/os#system_time/0">kernel/os#system_time/0</a></p></li><li><p><a href="../kernel/os#system_time/1">kernel/os#system_time/1</a></p></li></ul><p>The new API also consists of extensions of the following existing BIFs:
</p><ul><li><p><a href="./erlang#monitor/2">erlang#monitor/2</a></p></li><li><p><a href="./erlang#system_flag_time_offset">erlang#system_flag_time_offset</a></p></li><li><p><a href="./erlang#system_info_os_monotonic_time_source">erlang#system_info_os_monotonic_time_source</a></p></li><li><p><a href="./erlang#system_info_os_system_time_source">erlang#system_info_os_system_time_source</a></p></li><li><p><a href="./erlang#system_info_time_offset">erlang#system_info_time_offset</a></p></li><li><p><a href="./erlang#system_info_time_warp_mode">erlang#system_info_time_warp_mode</a></p></li><li><p><a href="./erlang#system_info_time_correction">erlang#system_info_time_correction</a></p></li><li><p><a href="./erlang#system_info_start_time">erlang#system_info_start_time</a></p></li><li><p><a href="./erlang#system_info_end_time">erlang#system_info_end_time</a></p></li></ul><a name="The_New_Erlang_Monotonic_Time"></a><h4>New Erlang Monotonic Time</h4><p>Erlang monotonic time as such is new as from ERTS 7.0.
It is introduced to detach time measurements, such as elapsed
time from calendar time. In many use cases there is a need to
measure elapsed time or specify a time relative to another point
in time without the need to know the involved times in UTC or
any other globally defined time scale. By introducing a time
scale with a local definition of where it starts, time that do
not concern calendar time can be managed on that time
scale. Erlang monotonic time uses such a time scale with a
locally defined start.</p><p>The introduction of Erlang monotonic time allows
us to adjust the two Erlang times (Erlang
monotonic time and Erlang system time) separately. By
doing this, the accuracy of elapsed time does not have to
suffer just because the system time happened to be
wrong at some point in time. Separate adjustments
of the two times are only performed in the time warp
modes, and only fully separated in the
<a href="#Multi_Time_Warp_Mode">multi-time warp mode</a>. All other modes than the
multi-time warp mode are for backward
compatibility reasons. When using these modes, the
accuracy of Erlang monotonic time suffer, as
the adjustments of Erlang monotonic time in these
modes are more or less tied to Erlang system time.</p><p>The adjustment of system time could have been made
smother than using a time warp approach, but we think
that would be a bad choice. As we can
express and measure time that is not connected to
calendar time by the use of Erlang monotonic time, it
is better to expose the change in Erlang system time
immediately. This as the Erlang applications
executing on the system can react on the change in
system time as soon as possible. This is also more or
less exactly how most operating systems handle this
(OS monotonic time and OS system time). By adjusting
system time smoothly, we would just hide the fact that
system time changed and make it harder for the Erlang
applications to react to the change in a sensible way.</p><p>To be able to react to a change in Erlang
system time, you must be able to detect that it
happened. The change in Erlang system time occurs when the
current time offset is changed. We have therefore
introduced the possibility to monitor the time offset using
<a href="./erlang#monitor/2">erlang#monitor/2</a>.
A process monitoring the time
offset is sent a message on the following format
when the time offset is changed:</p><pre><code class="">
{'CHANGE', MonitorReference, time_offset, clock_service, NewTimeOffset}</code></pre><a name="Unique_Values"></a><h4>Unique Values</h4><p>Besides reporting time, <strong>erlang:now/0</strong> also
produces unique and strictly monotonically increasing
values. To detach this functionality from
time measurements, we have introduced
<a href="./erlang#unique_integer/1">erlang#unique_integer/1</a>.</p><a name="Dos_and_Donts"></a><h4>How to Work with the New API</h4><p>Previously <strong>erlang:now/0</strong> was the only option for doing
many things. This section deals with some things that
<strong>erlang:now/0</strong> can be used for, and how you use the new API.</p><a name="Dos_and_Donts_Retrieve_Erlang_System_Time"></a><h4>Retrieve Erlang System Time</h4><div class="alert alert-danger"><h4 class="alert-heading">Don't</h4><p>
Use <strong>erlang:now/0</strong> to retrieve the current Erlang system time.
</p></div><div class="alert alert-success"><h4 class="alert-heading">Do</h4><p>
Use
<a href="./erlang#system_time/1">erlang#system_time/1</a>
to retrieve the current Erlang system time on the
<a href="./erlang#type_time_unit">time unit</a>
of your choice.</p><p>If you want the same format as returned by <strong>erlang:now/0</strong>,
use <a href="./erlang#timestamp/0">erlang#timestamp/0</a>.
</p></div><a name="Dos_and_Donts_Measure_Elapsed_Time"></a><h4>Measure Elapsed Time</h4><div class="alert alert-danger"><h4 class="alert-heading">Don't</h4><p>
Take time stamps with <strong>erlang:now/0</strong> and calculate
the difference in time with
<a href="../stdlib/timer#now_diff/2">stdlib/timer#now_diff/2</a>.
</p></div><div class="alert alert-success"><h4 class="alert-heading">Do</h4><p>
Take time stamps with
<a href="./erlang#monotonic_time/0">erlang#monotonic_time/0</a>
and calculate the time difference using ordinary subtraction.
The result is in <strong>native</strong>
<a href="./erlang#type_time_unit">time unit</a>.
If you want to convert the
result to another time unit, you can use
<a href="./erlang#convert_time_unit/3">erlang#convert_time_unit/3</a>.
</p><p>An easier way to do this is to use
<a href="./erlang#monotonic_time/1">erlang#monotonic_time/1</a>
with the desired time unit. However, you can then lose accuracy
and precision.
</p></div><a name="Dos_and_Donts_Determine_Order_of_Events"></a><h4>Determine Order of Events</h4><div class="alert alert-danger"><h4 class="alert-heading">Don't</h4><p>
Determine the order of events by saving a time stamp
with <strong>erlang:now/0</strong> when the event occurs.
</p></div><div class="alert alert-success"><h4 class="alert-heading">Do</h4><p>
Determine the order of events by saving the integer
returned by
<a href="./erlang#unique_integer/1">erlang#unique_integer/1</a>
when the event occurs. These integers are strictly
monotonically ordered on current runtime system instance
corresponding to creation time.
</p></div><a name="Dos_and_Donts_Determine_Order_of_Events_With_Time_of_the_Event"></a><h4>Determine Order of Events with Time of the Event</h4><div class="alert alert-danger"><h4 class="alert-heading">Don't</h4><p>
Determine the order of events by saving a time stamp
with <strong>erlang:now/0</strong> when the event occurs.
</p></div><div class="alert alert-success"><h4 class="alert-heading">Do</h4><p>
Determine the order of events by saving a tuple containing
<a href="./erlang#monotonic_time/0">monotonic time</a>
and a <a href="./erlang#unique_integer/1">strictly monotonically increasing integer</a> as follows:</p><pre><code class="">
Time = erlang:monotonic_time(),
UMI = erlang:unique_integer([monotonic]),
EventTag = {Time, UMI}</code></pre><p>These tuples are strictly monotonically ordered
on the current runtime system instance according to
creation time. It is important that the
monotonic time is in the first element (the most
significant element when comparing two-tuples). Using
the monotonic time in the tuples, you can calculate time
between events.</p><p>If you are interested in Erlang system time at the
time when the event occurred, you can also save the time
offset before or after saving the events using
<a href="./erlang#time_offset/0">erlang#time_offset/0</a>.
Erlang monotonic time added with the time
offset corresponds to Erlang system time.</p><p>If you are executing in a mode where time offset
can change, and you want to get the actual
Erlang system time when the event occurred, you can
save the time offset as a third element in the tuple
(the least significant element when comparing three-tuples).</p></div><a name="Dos_and_Donts_Create_a_Unique_Name"></a><h4>Create a Unique Name</h4><div class="alert alert-danger"><h4 class="alert-heading">Don't</h4><p>
Use the values returned from <strong>erlang:now/0</strong>
to create a name unique on the current runtime system instance.
</p></div><div class="alert alert-success"><h4 class="alert-heading">Do</h4><p>
Use the value returned from
<a href="./erlang#unique_integer/0">erlang#unique_integer/0</a>
to create a name unique on the current runtime system
instance. If you only want positive integers, you can use
<a href="./erlang#unique_integer/1">erlang#unique_integer/1</a>.
</p></div><a name="Dos_and_Donts_Seed_Random_Number_Generation_With_a_Unique_Value"></a><h4>Seed Random Number Generation with a Unique Value</h4><div class="alert alert-danger"><h4 class="alert-heading">Don't</h4><p>
Seed random number generation using <strong>erlang:now()</strong>.
</p></div><div class="alert alert-success"><h4 class="alert-heading">Do</h4><p>
Seed random number generation using a combination of
<a href="./erlang#monotonic_time/0">erlang#monotonic_time/0</a>,
<a href="./erlang#time_offset/0">erlang#time_offset/0</a>,
<a href="./erlang#unique_integer/0">erlang#unique_integer/0</a>,
and other functionality.
</p></div><p>To sum up this section: <em>Do not use erlang:now/0.</em></p><a name="Supporting_Both_New_and_Old_OTP_Releases"></a><h4>Support of Both New and Old OTP Releases</h4><p>It can be required that your code must run on a variety
of OTP installations of different OTP releases. If so, you
cannot use the new API out of the box, as it will
not be available on releases before OTP 18. The solution
is <em>not</em> to avoid using the new API, as your
code would then not benefit from the scalability
and accuracy improvements made. Instead, use the
new API when available, and fall back on <strong>erlang:now/0</strong>
when the new API is unavailable.</p><p>Fortunately most of the new API can easily be
implemented using existing primitives, except for:</p><ul><li> <a href="./erlang#system_info_start_time">erlang#system_info_start_time</a> </li><li> <a href="./erlang#system_info_end_time">erlang#system_info_end_time</a> </li><li> <a href="./erlang#system_info_os_monotonic_time_source">erlang#system_info_os_monotonic_time_source</a> </li><li> <a href="./erlang#system_info_os_system_time_source">erlang#system_info_os_system_time_source</a> </li></ul><p>By wrapping the API with functions that fall back on
<strong>erlang:now/0</strong> when the new API is unavailable,
and using these wrappers instead of using the API directly,
the problem is solved. These wrappers can, for example,
be implemented as in
<a href="time_compat.erl">$ERL_TOP/erts/example/time_compat.erl</a>.</p><p>A "match specification" (<strong>match_spec</strong>) is an Erlang term describing a
small "program" that tries to match something. It can be used
to either control tracing with
<a href="./erlang#trace_pattern/3">erlang:trace_pattern/3</a>
or to search for objects in an ETS table with for example
<a href="../stdlib/ets#select/2">ets:select/2</a>.
The match specification in many ways works like a small function in Erlang,
but is interpreted/compiled by the Erlang runtime system to something much more
efficient than calling an Erlang function. The match specification is also
very limited compared to the expressiveness of real Erlang functions.</p><p>The most notable difference between a match specification and an Erlang
fun is the syntax. Match specifications are Erlang terms, not Erlang code.
Also, a match specification has a strange concept of exceptions:</p><ul><li> <p>An exception (such as <strong>badarg</strong>) in the
<strong>MatchCondition</strong> part, which resembles an Erlang guard,
generates immediate failure.</p> </li><li> <p>An exception in the <strong>MatchBody</strong> part, which resembles
the body of an Erlang function, is implicitly caught and results in the
single atom <strong>'EXIT'</strong>.</p> </li></ul><h4>Grammar</h4><p>A match specification used in tracing can be described in the following
<em>informal</em> grammar:</p><ul><li>MatchExpression ::= [ MatchFunction, ... ] </li><li>MatchFunction ::= { MatchHead, MatchConditions, MatchBody } </li><li>MatchHead ::=  MatchVariable | <strong>'_'</strong> | [ MatchHeadPart, ... ] </li><li>MatchHeadPart ::= term() | MatchVariable | <strong>'_'</strong> </li><li>MatchVariable ::= '$&lt;number&gt;' </li><li>MatchConditions ::= [ MatchCondition, ...] | <strong>[]</strong> </li><li>MatchCondition ::= { GuardFunction } | { GuardFunction, ConditionExpression, ... } </li><li>BoolFunction ::= <strong>is_atom</strong> | <strong>is_float</strong> | <strong>is_integer</strong> | <strong>is_list</strong> | <strong>is_number</strong> | <strong>is_pid</strong> | <strong>is_port</strong> | <strong>is_reference</strong> | <strong>is_tuple</strong> | <strong>is_map</strong> | <strong>is_map_key</strong> | <strong>is_binary</strong> | <strong>is_function</strong> | <strong>is_record</strong> | <strong>is_seq_trace</strong> | <strong>'and'</strong> | <strong>'or'</strong> | <strong>'not'</strong> | <strong>'xor'</strong> | <strong>'andalso'</strong> | <strong>'orelse'</strong> </li><li>ConditionExpression ::= ExprMatchVariable | { GuardFunction } | { GuardFunction, ConditionExpression, ... } | TermConstruct </li><li>ExprMatchVariable ::= MatchVariable (bound in the MatchHead) | <strong>'$_'</strong> | <strong>'$$'</strong> </li><li>TermConstruct = {{}} | {{ ConditionExpression, ... }} | <strong>[]</strong> | [ConditionExpression, ...] | <strong>#{}</strong> | #{term() =&gt; ConditionExpression, ...} | NonCompositeTerm | Constant </li><li>NonCompositeTerm ::= term() (not list or tuple or map) </li><li>Constant ::= {<strong>const</strong>, term()} </li><li>GuardFunction ::= BoolFunction | <strong>abs</strong> | <strong>element</strong> | <strong>hd</strong> | <strong>length</strong> | <strong>map_get</strong> | <strong>map_size</strong> | <strong>node</strong> | <strong>round</strong> | <strong>size</strong> | <strong>bit_size</strong> | <strong>tl</strong> | <strong>trunc</strong> | <strong>'+'</strong> | <strong>'-'</strong> | <strong>'*'</strong> | <strong>'div'</strong> | <strong>'rem'</strong> | <strong>'band'</strong> | <strong>'bor'</strong> | <strong>'bxor'</strong> | <strong>'bnot'</strong> | <strong>'bsl'</strong> | <strong>'bsr'</strong> | <strong>'&gt;'</strong> | <strong>'&gt;='</strong> | <strong>'&lt;'</strong> | <strong>'=&lt;'</strong> | <strong>'=:='</strong> | <strong>'=='</strong> | <strong>'=/='</strong> | <strong>'/='</strong> | <strong>self</strong> | <strong>get_tcw</strong> </li><li>MatchBody ::= [ ActionTerm ] </li><li>ActionTerm ::= ConditionExpression | ActionCall </li><li>ActionCall ::= {ActionFunction} | {ActionFunction, ActionTerm, ...} </li><li>ActionFunction ::= <strong>set_seq_token</strong> | <strong>get_seq_token</strong> | <strong>message</strong> | <strong>return_trace</strong> | <strong>exception_trace</strong> | <strong>process_dump</strong> | <strong>enable_trace</strong> | <strong>disable_trace</strong> | <strong>trace</strong> | <strong>display</strong> | <strong>caller</strong> | <strong>set_tcw</strong> | <strong>silent</strong> </li></ul><p>A match specification  used in
<a href="./ets">stdlib/ets</a>
can be described in the following <em>informal</em> grammar:</p><ul><li>MatchExpression ::= [ MatchFunction, ... ] </li><li>MatchFunction ::= { MatchHead, MatchConditions, MatchBody } </li><li>MatchHead ::=  MatchVariable | <strong>'_'</strong> | { MatchHeadPart, ... } </li><li>MatchHeadPart ::= term() | MatchVariable | <strong>'_'</strong> </li><li>MatchVariable ::= '$&lt;number&gt;' </li><li>MatchConditions ::= [ MatchCondition, ...] | <strong>[]</strong> </li><li>MatchCondition ::= { GuardFunction } | { GuardFunction, ConditionExpression, ... } </li><li>BoolFunction ::= <strong>is_atom</strong> | <strong>is_float</strong> | <strong>is_integer</strong> | <strong>is_list</strong> | <strong>is_number</strong> | <strong>is_pid</strong> | <strong>is_port</strong> | <strong>is_reference</strong> | <strong>is_tuple</strong> | <strong>is_map</strong> | <strong>map_is_key</strong> | <strong>is_binary</strong> | <strong>is_function</strong> | <strong>is_record</strong> | <strong>'and'</strong> | <strong>'or'</strong> | <strong>'not'</strong> | <strong>'xor'</strong> | <strong>'andalso'</strong> | <strong>'orelse'</strong> </li><li>ConditionExpression ::= ExprMatchVariable | { GuardFunction } | { GuardFunction, ConditionExpression, ... } | TermConstruct </li><li>ExprMatchVariable ::= MatchVariable (bound in the MatchHead) | <strong>'$_'</strong> | <strong>'$$'</strong> </li><li>TermConstruct = {{}} | {{ ConditionExpression, ... }} | <strong>[]</strong> | [ConditionExpression, ...] | #{} | #{term() =&gt; ConditionExpression, ...} | NonCompositeTerm | Constant </li><li>NonCompositeTerm ::= term() (not list or tuple or map) </li><li>Constant ::= {<strong>const</strong>, term()} </li><li>GuardFunction ::= BoolFunction | <strong>abs</strong> | <strong>element</strong> | <strong>hd</strong> | <strong>length</strong> | <strong>map_get</strong> | <strong>map_size</strong> | <strong>node</strong> | <strong>round</strong> | <strong>size</strong> | <strong>bit_size</strong> | <strong>tl</strong> | <strong>trunc</strong> | <strong>'+'</strong> | <strong>'-'</strong> | <strong>'*'</strong> | <strong>'div'</strong> | <strong>'rem'</strong> | <strong>'band'</strong> | <strong>'bor'</strong> | <strong>'bxor'</strong> | <strong>'bnot'</strong> | <strong>'bsl'</strong> | <strong>'bsr'</strong> | <strong>'&gt;'</strong> | <strong>'&gt;='</strong> | <strong>'&lt;'</strong> | <strong>'=&lt;'</strong> | <strong>'=:='</strong> | <strong>'=='</strong> | <strong>'=/='</strong> | <strong>'/='</strong> | <strong>self</strong> </li><li>MatchBody ::= [ ConditionExpression, ... ] </li></ul><h4>Function Descriptions</h4><h4>Functions Allowed in All Types of Match Specifications</h4><p>The functions allowed in <strong>match_spec</strong> work as
follows:</p><dl><dt><strong>is_atom</strong>, <strong>is_float</strong>, <strong>is_integer</strong>, <strong>is_list</strong>, <strong>is_number</strong>, <strong>is_pid</strong>, <strong>is_port</strong>, <strong>is_reference</strong>, <strong>is_tuple</strong>, <strong>is_map</strong>, <strong>is_binary</strong>, <strong>is_function</strong> </dt><dd> <p>Same as the corresponding guard tests in Erlang, return
<strong>true</strong> or <strong>false</strong>.</p> </dd><dt><strong>is_record</strong></dt><dd> <p>Takes an additional parameter, which <em>must</em> be the result
of <strong>record_info(size, &lt;record_type&gt;)</strong>, like in
<strong>{is_record, '$1', rectype, record_info(size, rectype)}</strong>.</p> </dd><dt><strong>'not'</strong></dt><dd> <p>Negates its single argument (anything other
than <strong>false</strong> gives <strong>false</strong>).</p> </dd><dt><strong>'and'</strong></dt><dd> <p>Returns <strong>true</strong> if all its arguments (variable
length argument list) evaluate to <strong>true</strong>, otherwise
<strong>false</strong>. Evaluation order is undefined.</p> </dd><dt><strong>'or'</strong></dt><dd> <p>Returns <strong>true</strong> if any of its arguments
evaluates to <strong>true</strong>. Variable length argument
list. Evaluation order is undefined.</p> </dd><dt><strong>'andalso'</strong></dt><dd> <p>Works as <strong>'and'</strong>, but quits evaluating its
arguments when one argument evaluates to something else
than <strong>true</strong>. Arguments are evaluated left to right.</p> </dd><dt><strong>'orelse'</strong></dt><dd> <p>Works as <strong>'or'</strong>, but quits evaluating as soon
as one of its arguments evaluates to <strong>true</strong>.
Arguments are evaluated left to right.</p> </dd><dt><strong>'xor'</strong></dt><dd> <p>Only two arguments, of which one must be <strong>true</strong> and the
other <strong>false</strong> to return <strong>true</strong>; otherwise
<strong>'xor'</strong> returns false.</p> </dd><dt><strong>abs</strong>, <strong>element</strong>, <strong>hd</strong>, <strong>length</strong>, <strong>map_get</strong>, <strong>map_size</strong>, <strong>node</strong>, <strong>round</strong>, <strong>size</strong>, <strong>bit_size</strong>, <strong>tl</strong>, <strong>trunc</strong>, <strong>'+'</strong>, <strong>'-'</strong>, <strong>'*'</strong>, <strong>'div'</strong>, <strong>'rem'</strong>, <strong>'band'</strong>, <strong>'bor'</strong>, <strong>'bxor'</strong>, <strong>'bnot'</strong>, <strong>'bsl'</strong>, <strong>'bsr'</strong>, <strong>'&gt;'</strong>, <strong>'&gt;='</strong>, <strong>'&lt;'</strong>, <strong>'=&lt;'</strong>, <strong>'=:='</strong>, <strong>'=='</strong>, <strong>'=/='</strong>, <strong>'/='</strong>, <strong>self</strong></dt><dd> <p>Same as the corresponding Erlang BIFs (or operators). In case of
bad arguments, the result depends on the context. In the
<strong>MatchConditions</strong> part of the expression, the test
fails immediately (like in an Erlang guard). In the
<strong>MatchBody</strong> part, exceptions are implicitly caught
and the call results in the atom <strong>'EXIT'</strong>.</p> </dd></dl><h4>Functions Allowed Only for Tracing</h4><p>The functions allowed only for tracing work as follows:</p><dl><dt><strong>is_seq_trace</strong></dt><dd> <p>Returns <strong>true</strong> if a sequential trace token is set
for the current process, otherwise <strong>false</strong>.</p> </dd><dt><strong>set_seq_token</strong></dt><dd> <p>Works as <strong>seq_trace:set_token/2</strong>, but returns
<strong>true</strong> on success, and <strong>'EXIT'</strong>
on error or bad argument. Only allowed in the
<strong>MatchBody</strong> part and only allowed when tracing.</p> </dd><dt><strong>get_seq_token</strong></dt><dd> <p>Same as <strong>seq_trace:get_token/0</strong> and only
allowed in the <strong>MatchBody</strong> part when tracing.</p> </dd><dt><strong>message</strong></dt><dd> <p>Sets an additional message appended to the
trace message sent. One can only set one additional message in
the body. Later calls replace the appended message.</p> <p>As a special case, <strong>{message, false}</strong> disables
sending of trace messages ('call' and 'return_to') for this function
call, just like if the match specification had not matched.
This can be useful if only the side effects of 
the <strong>MatchBody</strong> part are desired.</p> <p>Another special case is <strong>{message, true}</strong>, which
sets the default behavior, as if the function had no match
specification; trace message is sent with no extra information
(if no other calls to <strong>message</strong> are placed before
<strong>{message, true}</strong>, it is in fact a "noop").</p> <p>Takes one argument: the message. Returns <strong>true</strong>
and can only be used in the <strong>MatchBody</strong> part and
when tracing.</p> </dd><dt><strong>return_trace</strong></dt><dd> <p>Causes a <strong>return_from</strong> trace message to be sent
upon return from the current function. Takes no arguments, returns
<strong>true</strong> and can only be used in the
<strong>MatchBody</strong> part when tracing.
If the process trace flag <strong>silent</strong> is active, the
<strong>return_from</strong> trace message is inhibited.</p> <p><em>Warning:</em> If the traced function is tail-recursive, this
match specification function destroys that property. Hence, if a
match specification executing this function is used on a
perpetual server process, it can only be active for a limited
period of time, or the emulator will eventually use all memory in
the host machine and crash. If this match specification function is
inhibited using process trace flag <strong>silent</strong>,
tail-recursiveness still remains.</p> </dd><dt><strong>exception_trace</strong></dt><dd> <p>Works as <strong>return_trace</strong> plus; if the traced function exits
because of an exception,
an <strong>exception_from</strong> trace message is generated,
regardless of the exception is caught or not.</p> </dd><dt><strong>process_dump</strong></dt><dd> <p>Returns some textual information about
the current process as a binary. Takes no arguments and is only
allowed in the <strong>MatchBody</strong> part when tracing.</p> </dd><dt><strong>enable_trace</strong></dt><dd> <p>With one parameter this function turns on tracing like the Erlang
call <strong>erlang:trace(self(), true, [P2])</strong>, where
<strong>P2</strong> is the parameter to
<strong>enable_trace</strong>.</p> <p>With two parameters, the first parameter is to be either a process
identifier or the registered name of a process. In this case tracing
is turned on for the designated process in the same way as in the
Erlang call <strong>erlang:trace(P1, true, [P2])</strong>, where
<strong>P1</strong> is the first and <strong>P2</strong> is the second argument. The
process <strong>P1</strong> gets its trace messages sent to the
same tracer as the process executing the statement uses.
<strong>P1</strong> <em>cannot</em> be one of the atoms
<strong>all</strong>, <strong>new</strong> or 
<strong>existing</strong> (unless they are registered names).
<strong>P2</strong> <em>cannot</em> be
<strong>cpu_timestamp</strong> or <strong>tracer</strong>.</p> <p>Returns <strong>true</strong> and can only be used in
the <strong>MatchBody</strong> part when tracing.</p> </dd><dt><strong>disable_trace</strong></dt><dd> <p>With one parameter this function disables tracing like the Erlang
call <strong>erlang:trace(self(), false, [P2])</strong>, where
<strong>P2</strong> is the parameter to
<strong>disable_trace</strong>.</p> <p>With two parameters this function works as the Erlang call
<strong>erlang:trace(P1, false, [P2])</strong>, where <strong>P1</strong>
can be either a process identifier or a registered name and is
specified as the first argument to the match specification function.
<strong>P2</strong> <em>cannot</em> be
<strong>cpu_timestamp</strong> or <strong>tracer</strong>.</p> <p>Returns <strong>true</strong> and can only be used in the
<strong>MatchBody</strong> part when tracing.</p> </dd><dt><strong>trace</strong></dt><dd> <p>With two parameters this function takes a list
of trace flags to disable as first parameter and a list
of trace flags to enable as second parameter. Logically, the
disable list is applied first, but effectively all changes
are applied atomically. The trace flags
are the same as for <strong>erlang:trace/3</strong>,
not including <strong>cpu_timestamp</strong>, but including
<strong>tracer</strong>.</p> <p>If a tracer is specified in both lists, the tracer in the
enable list takes precedence. If no tracer is specified, the same
tracer as the process executing the match specification is used (not the meta tracer).
If that process doesn't have tracer either, then trace flags are ignored.</p> <p>When using a <a href="erl_tracer">tracer module</a>,
the module must be loaded before the match specification is
executed. If it is not loaded, the match fails.</p> <p>With three parameters to this function, the first is
either a process identifier or the registered name of a
process to set trace flags on, the second is the disable
list, and the third is the enable list.</p> <p>Returns <strong>true</strong> if any trace property was changed
for the trace target process, otherwise <strong>false</strong>.
Can only be used in the <strong>MatchBody</strong> part when
tracing.</p> </dd><dt><strong>caller</strong></dt><dd> <p>Returns the calling function as a tuple <strong>{Module, Function, Arity}</strong> or the atom <strong>undefined</strong> if the calling
function cannot be determined. Can only be used in the
<strong>MatchBody</strong> part when tracing.</p> <p>Notice that if a "technically built in function" (that is, a
function not written in Erlang) is traced, the
<strong>caller</strong> function sometimes returns the atom
<strong>undefined</strong>. The calling
Erlang function is not available during such calls.</p> </dd><dt><strong>display</strong></dt><dd> <p>For debugging purposes only. Displays the single argument as an
Erlang term on <strong>stdout</strong>, which is seldom what is wanted.
Returns <strong>true</strong> and can only be used in the
<strong>MatchBody</strong> part when tracing.</p> </dd><dt><a name="get_tcw"></a><strong>get_tcw</strong></dt><dd> <p>Takes no argument and returns the value of the node's trace
control word. The same is done by
<strong>erlang:system_info(trace_control_word)</strong>.</p> <p>The trace control word is a 32-bit unsigned integer intended for
generic trace control. The trace control word can be tested and
set both from within trace match specifications and with BIFs.
This call is only allowed when tracing.</p> </dd><dt><a name="set_tcw"></a><strong>set_tcw</strong></dt><dd> <p>Takes one unsigned integer argument, sets the value of
the node's trace control word to the value of the argument,
and returns the previous value. The same is done by
<strong>erlang:system_flag(trace_control_word, Value)</strong>.
It is only allowed to use <strong>set_tcw</strong> in the
<strong>MatchBody</strong> part when tracing.</p> </dd><dt><strong>silent</strong></dt><dd> <p>Takes one argument. If the argument is <strong>true</strong>,
the call trace message mode for the current process is set to
silent for this call and all later calls, that is, call trace
messages are inhibited even if
<strong>{message, true}</strong> is called in the
<strong>MatchBody</strong> part for a traced function.</p> <p>This mode can also be activated with flag
<strong>silent</strong> to
<strong>erlang:trace/3</strong>.</p> <p>If the argument is <strong>false</strong>, the call trace
message mode for the current process is set to normal
(non-silent) for this call and all later calls.</p> <p>If the argument is not <strong>true</strong> or
<strong>false</strong>, the call trace message mode is
unaffected.</p> </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>All "function calls" must be tuples, even if they take no arguments.
The value of <strong>self</strong> is the atom()
<strong>self</strong>, but the value of <strong>{self}</strong> is
the pid() of the current process.</p></div><a name="match_target"></a><h4>Match target</h4><p>Each execution of a match specification is done against
a match target term. The format and content of the target term
depends on the context in which the match is done. The match
target for ETS is always a full table tuple. The match target
for call trace is always a list of all function arguments. The
match target for event trace depends on the event type, see
table below.</p><table class="table table-bordered table-hover table-striped"><caption>Match target depending on context</caption><tbody><tr><td>Context</td><td>Type</td><td>Match target</td><td>Description</td></tr><tr><td>ETS</td><td></td><td>{Key, Value1, Value2, ...}</td><td>A table object</td></tr><tr><td>Trace</td><td>call</td><td>[Arg1, Arg2, ...]</td><td>Function arguments</td></tr><tr><td>Trace</td><td>send</td><td>[Receiver, Message]</td><td>Receiving process/port and message term</td></tr><tr><td>Trace</td><td>'receive'</td><td>[Node, Sender, Message]</td><td>Sending node, process/port and message term</td></tr></tbody></table><h4>Variables and Literals</h4><p>Variables take the form <strong>'$&lt;number&gt;'</strong>, where
<strong>&lt;number&gt;</strong> is an integer between 0 and
100,000,000 (1e+8). The behavior if the number is outside these limits
is <em>undefined</em>. In the <strong>MatchHead</strong> part, the
special variable <strong>'_'</strong> matches anything, and never gets
bound (like <strong>_</strong> in Erlang).</p><ul><li> <p>In the <strong>MatchCondition/MatchBody</strong> parts,
no unbound variables are allowed, so <strong>'_'</strong> is
interpreted as itself (an atom). Variables can only be bound in the
<strong>MatchHead</strong> part.</p> </li><li> <p>In the <strong>MatchBody</strong> and
<strong>MatchCondition</strong> parts, only variables bound
previously can be used.</p> </li><li> <p>As a special case, the following apply in the
<strong>MatchCondition/MatchBody</strong> parts:</p> <ul><li> <p>The variable <strong>'$_'</strong> expands to the whole
<a href="#match_target">match target</a> term.
</p> </li><li> <p>The variable <strong>'$$'</strong> expands to a list of the
values of all bound variables in order (that is,
<strong>['$1','$2', ...]</strong>).</p> </li></ul> </li></ul><p>In the <strong>MatchHead</strong> part, all literals (except the
variables above) are interpreted "as is".</p><p>In the <strong>MatchCondition/MatchBody</strong> parts, the
interpretation is in some ways different. Literals in these parts
can either be written "as is", which works for all literals except
tuples, or by using the special form <strong>{const, T}</strong>,
where <strong>T</strong> is any Erlang term.</p><p>For tuple literals in the match specification, double tuple parentheses
can also be used, that is, construct them as a tuple of
arity one containing a single tuple, which is the one to be
constructed. The "double tuple parenthesis" syntax is useful to
construct tuples from already bound variables, like in
<strong>{{'$1', [a,b,'$2']}}</strong>. Examples:</p><table class="table table-bordered table-hover table-striped"><caption>Literals in MatchCondition/MatchBody Parts of a Match
        Specification</caption><tbody><tr><td><em>Expression</em></td><td><em>Variable Bindings</em></td><td><em>Result</em></td></tr><tr><td>{{'$1','$2'}}</td><td>'$1' = a, '$2' = b</td><td>{a,b}</td></tr><tr><td>{const, {'$1', '$2'}}</td><td>Irrelevant</td><td>{'$1', '$2'}</td></tr><tr><td>a</td><td>Irrelevant</td><td>a</td></tr><tr><td>'$1'</td><td>'$1' = []</td><td>[]</td></tr><tr><td>['$1']</td><td>'$1' = []</td><td>[[]]</td></tr><tr><td>[{{a}}]</td><td>Irrelevant</td><td>[{a}]</td></tr><tr><td>42</td><td>Irrelevant</td><td>42</td></tr><tr><td>"hello"</td><td>Irrelevant</td><td>"hello"</td></tr><tr><td>$1</td><td>Irrelevant</td><td>49 (the ASCII value for character '1')</td></tr></tbody></table><h4>Execution of the Match</h4><p>The execution of the match expression, when the runtime system
decides whether a trace message is to be sent, is as follows:</p><p>For each tuple in the <strong>MatchExpression</strong> list and while
no match has succeeded:</p><ul><li> <p>Match the <strong>MatchHead</strong> part against the match target
term, binding the <strong>'$&lt;number&gt;'</strong> variables
(much like in <strong>ets:match/2</strong>). If the
<strong>MatchHead</strong> part cannot match the arguments, the
match fails.</p> </li><li> <p>Evaluate each <strong>MatchCondition</strong> (where only
<strong>'$&lt;number&gt;'</strong> variables previously bound in the
<strong>MatchHead</strong> part can occur) and expect it to return
the atom <strong>true</strong>. When a condition does not evaluate
to <strong>true</strong>, the match fails. If any BIF call
generates an exception, the match also fails.</p> </li><li> <p>Two cases can occur:</p> <ul><li> <p>If the match specification is executing when tracing:</p> <p>Evaluate each <strong>ActionTerm</strong> in the same way as
the <strong>MatchConditions</strong>, but ignore the return
values. Regardless of what happens in this part, the match has
succeeded.</p> </li><li> <p>If the match specification is executed when selecting objects
from an ETS table:</p> <p>Evaluate the expressions in order and return the value of
the last expression (typically there is only one expression
in this context).</p> </li></ul> </li></ul><a name="differences_ets_tracing"></a><h4>Differences between Match Specifications in ETS and Tracing</h4><p>ETS match specifications produce a return value.
Usually the <strong>MatchBody</strong> contains one single
<strong>ConditionExpression</strong> that defines the return value
without any side effects. Calls with side effects are not allowed in
the ETS context.</p><p>When tracing there is no return value to produce, the
match specification either matches or does not. The effect when the
expression matches is a trace message rather than a returned
term. The <strong>ActionTerm</strong>s are executed as in an imperative
language, that is, for their side effects. Functions with side effects
are also allowed when tracing.</p><h4>Tracing Examples</h4><p>Match an argument list of three, where the first and third arguments
are equal:</p><pre><code class="">
[{['$1', '_', '$1'],
  [],
  []}]
    </code></pre><p>Match an argument list of three, where the second argument is
a number &gt; 3:</p><pre><code class="">
[{['_', '$1', '_'],
  [{ '&gt;', '$1', 3}],
  []}]
    </code></pre><p>Match an argument list of three, where the third argument is
either a tuple containing argument one and two, <em>or</em> a list
beginning with argument one and two (that is,
<strong>[a,b,[a,b,c]]</strong> or <strong>[a,b,{a,b}]</strong>):</p><pre><code class="">
[{['$1', '$2', '$3'],
  [{'orelse', 
      {'=:=', '$3', {{'$1','$2'}}},
      {'and', 
        {'=:=', '$1', {hd, '$3'}},
        {'=:=', '$2', {hd, {tl, '$3'}}}}}],
  []}]
    </code></pre><p>The above problem can also be solved as follows:</p><pre><code class="">
[{['$1', '$2', {'$1', '$2}], [], []},
 {['$1', '$2', ['$1', '$2' | '_']], [], []}]
    </code></pre><p>Match two arguments, where the first is a tuple beginning with
a list that in turn begins with the second argument times
two (that is, <strong>[{[4,x],y},2]</strong> or <strong>[{[8], y, z},4])</strong>:</p><pre><code class="">
[{['$1', '$2'],[{'=:=', {'*', 2, '$2'}, {hd, {element, 1, '$1'}}}],
  []}]
    </code></pre><p>Match three arguments. When all three are equal and are
numbers, append the process dump to the trace message, otherwise
let the trace message be "as is", but set the sequential trace
token label to 4711:</p><pre><code class="">
[{['$1', '$1', '$1'],
  [{is_number, '$1'}],
  [{message, {process_dump}}]},
 {'_', [], [{set_seq_token, label, 4711}]}]
    </code></pre><p>As can be noted above, the parameter list can be matched against a
single <strong>MatchVariable</strong> or an <strong>'_'</strong>.
To replace the whole parameter list with a single variable is a special
case. In all other cases the <strong>MatchHead</strong> must be a
<em>proper</em> list.</p><p>Generate a trace message only if the trace control word is set to 1:</p><pre><code class="">
[{'_',
  [{'==',{get_tcw},{const, 1}}],
  []}]
    </code></pre><p>Generate a trace message only if there is a <strong>seq_trace</strong> token:</p><pre><code class="">
[{'_',
  [{'==',{is_seq_trace},{const, 1}}],
  []}]
    </code></pre><p>Remove the <strong>'silent'</strong> trace flag when the first argument is
<strong>'verbose'</strong>, and add it when it is <strong>'silent':</strong></p><pre><code class="">
[{'$1',
  [{'==',{hd, '$1'},verbose}],
  [{trace, [silent],[]}]},
 {'$1',
  [{'==',{hd, '$1'},silent}],
  [{trace, [],[silent]}]}]
    </code></pre><p>Add a <strong>return_trace</strong> message if the function is of arity 3:</p><pre><code class="">
[{'$1',
  [{'==',{length, '$1'},3}],
  [{return_trace}]},
 {'_',[],[]}]
    </code></pre><p>Generate a trace message only if the function is of arity 3 and the
first argument is <strong>'trace'</strong>:</p><pre><code class="">
[{['trace','$2','$3'],
  [],
  []},
 {'_',[],[]}]
    </code></pre><h4>ETS Examples</h4><p>Match all objects in an ETS table, where the first element is
the atom <strong>'strider'</strong> and the tuple arity is 3, and return the whole
object:</p><pre><code class="">
[{{strider,'_','_'},
  [],
  ['$_']}]
    </code></pre><p>Match all objects in an ETS table with arity &gt; 1 and the first
element is 'gandalf', and return element 2:</p><pre><code class="">
[{'$1',
  [{'==', gandalf, {element, 1, '$1'}},{'&gt;=',{size, '$1'},2}],
  [{element,2,'$1'}]}]
    </code></pre><p>In this example, if the first element had been the key, it is
much more efficient to match that key in the <strong>MatchHead</strong>
part than in the <strong>MatchConditions</strong> part.
The search space of the tables is restricted with regards to the
<strong>MatchHead</strong> so
that only objects with the matching key are searched.</p><p>Match tuples of three elements, where the second element is either
<strong>'merry'</strong> or <strong>'pippin'</strong>, and return the whole objects:</p><pre><code class="">
[{{'_',merry,'_'},
  [],
  ['$_']},
 {{'_',pippin,'_'},
  [],
  ['$_']}]
    </code></pre><p>Function <a href="../stdlib/ets#test_ms/2">stdlib/ets#test_ms/2</a>
can be useful for testing complicated ETS matches.</p><p>This section describes the <strong>erl_crash.dump</strong> file
generated upon abnormal exit of the Erlang runtime system.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The Erlang crash dump had a major facelift in Erlang/OTP R9C. The
information in this section is therefore not directly applicable for
older dumps. However, if you use <a href="./crashdump_viewer">observer/crashdump_viewer</a> on older dumps,
the crash dumps are translated into a format similar to this.</p></div><p>The system writes the crash dump in the current directory of
the emulator or in the file pointed out by the environment variable
(whatever that means on the current operating system)
<strong>ERL_CRASH_DUMP</strong>. For a crash dump to be written, a
writable file system must be mounted.</p><p>Crash dumps are written mainly for one of two reasons: either the
built-in function <strong>erlang:halt/1</strong> is called explicitly
with a string argument from running Erlang code, or the runtime
system has detected an error that cannot be handled. The most
usual reason that the system cannot handle the error is that the
cause is external limitations, such as running out of memory. A
crash dump caused by an internal error can be caused by the system
reaching limits in the emulator itself (like the number of atoms
in the system, or too many simultaneous ETS tables). Usually the
emulator or the operating system can be reconfigured to avoid the
crash, which is why interpreting the crash dump correctly is
important.</p><p>On systems that support OS signals, it is also possible to stop
the runtime system and generate a crash dump by sending the <strong>SIGUSR1</strong>
signal.</p><p>The Erlang crash dump is a readable text file, but it can be difficult
to read. Using the Crashdump Viewer tool in the
<strong>Observer</strong> application simplifies the task. This is a
wx-widget-based tool for browsing Erlang crash dumps.</p><a name="general_info"></a><h4>General Information</h4><p>The first part of the crash dump shows the following:</p><ul><li>The creation time for the dump</li><li>A slogan indicating the reason for the dump</li><li>The system version of the node from which the dump originates</li><li>The compile time of the emulator running the originating node</li><li>The number of atoms in the atom table</li><li>The runtime system thread that caused the crash dump</li></ul><h4>Reasons for Crash Dumps (Slogan)</h4><p>The reason for the dump is shown in the beginning of the file as:</p><pre>
Slogan: &lt;reason&gt;</pre><p>If the system is halted by the BIF
<strong>erlang:halt/1</strong>, the slogan is the string parameter
passed to the BIF, otherwise it is a description generated by
the emulator or the (Erlang) kernel. Normally the message
is enough to understand the problem, but
some messages are described here. Notice that the
suggested reasons for the crash are <em>only suggestions</em>.
The exact reasons for the errors can vary
depending on the local applications and the underlying
operating system.</p><dl><dt><em>&lt;A&gt;: Cannot allocate &lt;N&gt; bytes of memory (of type "&lt;T&gt;")</em></dt><dd> <p>The system has run out of memory. &lt;A&gt; is the allocator that
failed to allocate memory, &lt;N&gt; is the number of bytes that
&lt;A&gt; tried to allocate, and &lt;T&gt; is the memory block
type that the memory was needed for. The most common case is
that a process stores huge amounts of data. In this case
&lt;T&gt; is most often <strong>heap</strong>,
<strong>old_heap</strong>, <strong>heap_frag</strong>, or
<strong>binary</strong>. For more information on allocators, see
<a href="erts_alloc">erts_alloc</a>.</p> </dd><dt><em>&lt;A&gt;: Cannot reallocate &lt;N&gt; bytes of memory (of type "&lt;T&gt;")</em></dt><dd> <p>Same as above except that memory was reallocated
instead of allocated when the system ran out of memory.</p> </dd><dt><em>Unexpected op code &lt;N&gt;</em></dt><dd> <p>Error in compiled code, <strong>beam</strong> file damaged, or
error in the compiler.</p> </dd><dt><em>Module &lt;Name&gt; undefined | Function &lt;Name&gt; undefined | No function &lt;Name&gt;:&lt;Name&gt;/1 | No function &lt;Name&gt;:start/2</em></dt><dd> <p>The Kernel/STDLIB applications are
damaged or the start script is damaged.</p> </dd><dt><em>Driver_select called with too large file descriptor N</em></dt><dd> <p>The number of file descriptors for sockets
exceeds 1024 (Unix only). The limit on file descriptors in
some Unix flavors can be set to over 1024, but only 1024
sockets/pipes can be used simultaneously by Erlang (because of
limitations in the Unix <strong>select</strong> call). The number
of open regular files is not affected by this.</p> </dd><dt><em>Received SIGUSR1</em></dt><dd> <p>Sending the <strong>SIGUSR1</strong> signal to an Erlang machine (Unix only)
forces a crash dump. This slogan reflects that the Erlang machine
crash-dumped because of receiving that signal.</p> </dd><dt><em>Kernel pid terminated (&lt;Who&gt;) (&lt;Exit reason&gt;)</em></dt><dd> <p>The kernel supervisor has detected a failure, usually that the
<strong>application_controller</strong> has shut down
(<strong>Who</strong> = <strong>application_controller</strong>,
<strong>Why</strong> = <strong>shutdown</strong>).
The application controller
can have shut down for many reasons, the most usual
is that the node name of the distributed Erlang node is
already in use. A complete supervisor tree "crash" (that is,
the top supervisors have exited) gives about the same
result. This message comes from the Erlang code and not from
the virtual machine itself. It is always because of some
failure in an application, either within OTP or a
"user-written" one. Looking at the error log for your
application is probably the first step to take.</p> </dd><dt><em>Init terminating in do_boot ()</em></dt><dd> <p>The primitive Erlang boot sequence was terminated, most probably
because the boot script has errors or cannot be read. This is
usually a configuration error; the system can have been started
with a faulty <strong>-boot</strong> parameter or with a boot
script from the wrong OTP version.</p> </dd><dt><em>Could not start kernel pid (&lt;Who&gt;) ()</em></dt><dd> <p>One of the kernel processes could not start. This is probably
because of faulty arguments (like errors in a
<strong>-config</strong> argument)
or faulty configuration files. Check that all files are in
their correct location and that the configuration files (if
any) are not damaged. Usually messages are also
written to the controlling terminal and/or the error log
explaining what is wrong.</p> </dd></dl><p>Other errors than these can occur, as the
<strong>erlang:halt/1</strong> BIF can generate any message. If the
message is not generated by the BIF and does not occur in the
list above, it can be because of an error in the emulator. There
can however be unusual messages, not mentioned here, which
are still connected to an application failure. There is much
more information available, so a thorough reading of the
crash dump can reveal the crash reason. The size of processes,
the number of ETS tables, and the Erlang data on each process
stack can be useful to find the problem.</p><h4>Number of Atoms</h4><p>The number of atoms in the system at the time of the crash is
shown as <em>Atoms: &lt;number&gt;</em>. Some ten thousands atoms is
perfectly normal, but more can indicate that the BIF
<strong>erlang:list_to_atom/1</strong> is used to generate many
<em>different</em> atoms dynamically, which is never a good idea.</p><a name="scheduler"></a><h4>Scheduler Information</h4><p>Under the tag <em>=scheduler</em> is shown information about the current
state and statistics of the schedulers in the runtime system. On
operating systems that allow suspension of other threads, the
data within this section reflects what the runtime system looks like
when a crash occurs.</p><p>The following fields can exist for a process:</p><dl><dt><em>=scheduler:id</em></dt><dd> <p>Heading. States the scheduler identifier.</p> </dd><dt><em>Scheduler Sleep Info Flags</em></dt><dd> <p>If empty, the scheduler was doing some work.
If not empty, the scheduler is either in some state of sleep,
or suspended. This entry is only present in an SMP-enabled
emulator.</p> </dd><dt><em>Scheduler Sleep Info Aux Work</em></dt><dd> <p>If not empty, a scheduler internal auxiliary work is scheduled
to be done.</p> </dd><dt><em>Current Port</em></dt><dd> <p>The port identifier of the port that is currently
executed by the scheduler.</p> </dd><dt><em>Current Process</em></dt><dd> <p>The process identifier of the process that is currently
executed by the scheduler. If there is such a process, this entry is
followed by the <em>State</em>, <em>Internal State</em>,
<em>Program Counter</em>, and <em>CP</em> of that same process.
The entries are described in section
<a href="#processes">Process Information</a>.</p> <p>Notice that this is a snapshot of what the entries are exactly when
the crash dump is starting to be generated. Therefore they are most
likely different (and more telling) than the entries for the same
processes found in the <em>=proc</em> section. If there is no
currently running process, only the <em>Current Process</em> entry is
shown.</p> </dd><dt><em>Current Process Limited Stack Trace</em></dt><dd> <p>This entry is shown only if there is a current process. It is
similar to <a href="#proc_data">proc_data</a>, except that only the function frames
are shown (that is, the stack variables are omitted).
Also, only the top and bottom part of the stack are shown. If the
stack is small (&lt; 512 slots), the entire stack is shown. Otherwise
the entry <em>skipping ## slots</em> is shown, where <strong>##</strong>
is replaced by the number of slots that has been skipped.</p> </dd><dt><em>Run Queue</em></dt><dd> <p>Shows statistics about how many processes and ports
of different priorities are scheduled on this scheduler.</p> </dd><dt><em>** crashed **</em></dt><dd> <p>This entry is normally not shown. It signifies that getting the rest
of the information about this scheduler failed for some reason.</p> </dd></dl><a name="memory"></a><h4>Memory Information</h4><p>Under the tag <em>=memory</em> is shown information similar
to what can be obtainted on a living node with
<a href="../erts/erlang#memory/0">erts/erlang#memory/0</a>.</p><a name="internal_tables"></a><h4>Internal Table Information</h4><p>Under the tags <em>=hash_table:&lt;table_name&gt;</em> and
<em>=index_table:&lt;table_name&gt;</em> is shown internal
tables. These are mostly of interest for runtime system developers.</p><a name="allocated_areas"></a><h4>Allocated Areas</h4><p>Under the tag <em>=allocated_areas</em> is shown information
similar to what can be obtained on a living node with
<a href="../erts/erlang#system_info_allocated_areas">erts/erlang#system_info_allocated_areas</a>.</p><a name="allocator"></a><h4>Allocator</h4><p>Under the tag <em>=allocator:&lt;A&gt;</em> is shown
various information about allocator &lt;A&gt;. The information
is similar to what can be obtained on a living node with
<a href="../erts/erlang#system_info_allocator_tuple">erts/erlang#system_info_allocator_tuple</a>.
For more information, see also
<a href="erts_alloc">erts_alloc</a>.</p><a name="processes"></a><h4>Process Information</h4><p>The Erlang crashdump contains a listing of each living Erlang
process in the system. The following fields can exist for a process:</p><dl><dt><em>=proc:&lt;pid&gt;</em></dt><dd> <p>Heading. States the process identifier.</p> </dd><dt><em>State</em></dt><dd> <p>The state of the process. This can be one of the following:</p> <dl><dt><em>Scheduled</em></dt><dd>The process was scheduled to run but is currently not running ("in the run queue").</dd><dt><em>Waiting</em></dt><dd>The process was waiting for something (in <strong>receive</strong>).</dd><dt><em>Running</em></dt><dd>The process was currently running. If the BIF <strong>erlang:halt/1</strong> was called, this was the process calling it.</dd><dt><em>Exiting</em></dt><dd>The process was on its way to exit.</dd><dt><em>Garbing</em></dt><dd>This is bad luck, the process was garbage collecting when the crash dump was written. The rest of the information for this process is limited.</dd><dt><em>Suspended</em></dt><dd>The process is suspended, either by the BIF <strong>erlang:suspend_process/1</strong> or because it tries to write to a busy port.</dd></dl> </dd><dt><em>Registered name</em></dt><dd> <p>The registered name of the process, if any.</p> </dd><dt><em>Spawned as</em></dt><dd> <p>The entry point of the process, that is, what function was
referenced in the <strong>spawn</strong> or
<strong>spawn_link</strong> call that
started the process.</p> </dd><dt><em>Last scheduled in for | Current call</em></dt><dd> <p>The current function of the process. These fields do not
always exist.</p> </dd><dt><em>Spawned by</em></dt><dd> <p>The parent of the process, that is, the process that executed
<strong>spawn</strong> or <strong>spawn_link</strong>.</p> </dd><dt><em>Started</em></dt><dd> <p>The date and time when the process was started.</p> </dd><dt><em>Message queue length</em></dt><dd> <p>The number of messages in the process' message queue.</p> </dd><dt><em>Number of heap fragments</em></dt><dd> <p>The number of allocated heap fragments.</p> </dd><dt><em>Heap fragment data</em></dt><dd> <p>Size of fragmented heap data. This is data either created by
messages sent to the process or by the Erlang BIFs. This
amount depends on so many things that this field is utterly
uninteresting.</p> </dd><dt><em>Link list</em></dt><dd> <p>Process IDs of processes linked to this one. Can also contain
ports. If process monitoring is used, this field also tells in
which direction the monitoring is in effect. That is, a link
"to" a process tells you that the "current" process was
monitoring the other, and a link "from" a process tells you
that the other process was monitoring the current one.</p> </dd><dt><em>Reductions</em></dt><dd> <p>The number of reductions consumed by the process.</p> </dd><dt><em>Stack+heap</em></dt><dd> <p>The size of the stack and heap (they share memory segment).</p> </dd><dt><em>OldHeap</em></dt><dd> <p>The size of the "old heap". The Erlang virtual machine uses
generational garbage collection with two generations. There is
one heap for new data items and one for the data that has
survived two garbage collections. The assumption (which is
almost always correct) is that data surviving two garbage
collections can be "tenured" to a heap more seldom garbage
collected, as they will live for a long period. This is a
usual technique in virtual machines. The sum of the
heaps and stack together constitute most of the
allocated memory of the process.</p> </dd><dt><em>Heap unused, OldHeap unused</em></dt><dd> <p>The amount of unused memory on each heap. This information is
usually useless.</p> </dd><dt><em>Memory</em></dt><dd> <p>The total memory used by this process. This includes call stack,
heap, and internal structures. Same as
<a href="./erlang#process_info-2">erlang#process_info-2</a>.</p> </dd><dt><em>Program counter</em></dt><dd> <p>The current instruction pointer. This is only of interest for
runtime system developers. The function into which the program
counter points is the current function of the process.</p> </dd><dt><em>CP</em></dt><dd> <p>The continuation pointer, that is, the return address for the
current call. Usually useless for other than runtime system
developers. This can be followed by the function into which
the CP points, which is the function calling the current
function.</p> </dd><dt><em>Arity</em></dt><dd> <p>The number of live argument registers. The argument registers
if any are live will follow. These can contain the arguments
of the function if they are not yet moved to the stack.</p> </dd><dt><em>Internal State</em></dt><dd> <p>A more detailed internal representation of the state of
this process.</p> </dd></dl><p>See also section <a href="#proc_data">Process Data</a>.</p><a name="ports"></a><h4>Port Information</h4><p>This section lists the open ports, their owners, any linked
processes, and the name of their driver or external process.</p><a name="ets_tables"></a><h4>ETS Tables</h4><p>This section contains information about all the ETS tables in
the system. The following fields are of interest for each table:</p><dl><dt><em>=ets:&lt;owner&gt;</em></dt><dd> <p>Heading. States the table owner (a process identifier).</p> </dd><dt><em>Table</em></dt><dd> <p>The identifier for the table. If the table is a
<strong>named_table</strong>, this is the name.</p> </dd><dt><em>Name</em></dt><dd> <p>The table name, regardless of if it is a
<strong>named_table</strong> or not.</p> </dd><dt><em>Hash table, Buckets</em></dt><dd> <p>If the table is a hash table, that is, if it is not an
<strong>ordered_set</strong>.</p> </dd><dt><em>Hash table, Chain Length</em></dt><dd> <p>If the table is a hash table. Contains statistics about the
table, such as the maximum, minimum, and average chain length.
Having a maximum much larger than the average, and a standard
deviation much larger than the expected standard deviation is
a sign that the hashing of the terms
behaves badly for some reason.</p> </dd><dt><em>Ordered set (AVL tree), Elements</em></dt><dd> <p>If the table is an <strong>ordered_set</strong>. (The
number of elements is the same as the number of objects in the
table.)</p> </dd><dt><em>Fixed</em></dt><dd> <p>If the table is fixed using
<a href="../stdlib/ets#safe_fixtable/2">stdlib/ets#safe_fixtable/2</a> or some internal mechanism.</p> </dd><dt><em>Objects</em></dt><dd> <p>The number of objects in the table.</p> </dd><dt><em>Words</em></dt><dd> <p>The number of words (usually 4 bytes/word) allocated to data
in the table.</p> </dd><dt><em>Type</em></dt><dd> <p>The table type, that is, <strong>set</strong>, <strong>bag</strong>,
<strong>dublicate_bag</strong>, or <strong>ordered_set</strong>.</p> </dd><dt><em>Compressed</em></dt><dd> <p>If the table was compressed.</p> </dd><dt><em>Protection</em></dt><dd> <p>The protection of the table.</p> </dd><dt><em>Write Concurrency</em></dt><dd> <p>If <strong>write_concurrency</strong> was enabled for the table.</p> </dd><dt><em>Read Concurrency</em></dt><dd> <p>If <strong>read_concurrency</strong> was enabled for the table.</p> </dd></dl><a name="timers"></a><h4>Timers</h4><p>This section contains information about all the timers started
with the BIFs <strong>erlang:start_timer/3</strong> and
<strong>erlang:send_after/3</strong>. The following fields exist
for each timer:</p><dl><dt><em>=timer:&lt;owner&gt;</em></dt><dd> <p>Heading. States the timer owner (a process identifier),
that is, the process to receive the message when the timer
expires.</p> </dd><dt><em>Message</em></dt><dd> <p>The message to be sent.</p> </dd><dt><em>Time left</em></dt><dd> <p>Number of milliseconds left until the message would have been
sent.</p> </dd></dl><a name="distribution_info"></a><h4>Distribution Information</h4><p>If the Erlang node was alive, that is, set up for communicating
with other nodes, this section lists the connections that were
active. The following fields can exist:</p><dl><dt><em>=node:&lt;node_name&gt;</em></dt><dd> <p>The node name.</p> </dd><dt><em>no_distribution</em></dt><dd> <p>If the node was not distributed.</p> </dd><dt><em>=visible_node:&lt;channel&gt;</em></dt><dd> <p>Heading for a visible node, that is, an alive node with a
connection to the node that crashed. States the channel number
for the node.</p> </dd><dt><em>=hidden_node:&lt;channel&gt;</em></dt><dd> <p>Heading for a hidden node. A hidden node is the same as a
visible node, except that it is started with the <strong>"-hidden"</strong>
flag. States the channel number for the node.</p> </dd><dt><em>=not_connected:&lt;channel&gt;</em></dt><dd> <p>Heading for a node that was connected to the crashed
node earlier. References (that is, process or port identifiers)
to the not connected node existed at the time of the crash.
States the channel number for the node.</p> </dd><dt><em>Name</em></dt><dd> <p>The name of the remote node.</p> </dd><dt><em>Controller</em></dt><dd> <p>The port controlling communication with the remote node.</p> </dd><dt><em>Creation</em></dt><dd> <p>An integer (1-3) that together with the node name identifies
a specific instance of the node.</p> </dd><dt><em>Remote monitoring: &lt;local_proc&gt;  &lt;remote_proc&gt;</em> </dt><dd> <p>The local process was monitoring the remote process at the
time of the crash.</p> </dd><dt><em>Remotely monitored by: &lt;local_proc&gt; &lt;remote_proc&gt;</em></dt><dd> <p>The remote process was monitoring the local process at the
time of the crash.</p> </dd><dt><em>Remote link: &lt;local_proc&gt; &lt;remote_proc&gt;</em></dt><dd> <p>A link existed between the local process and the remote
process at the time of the crash.</p> </dd></dl><a name="loaded_modules"></a><h4>Loaded Module Information</h4><p>This section contains information about all loaded modules.</p><p>First, the memory use by the loaded code is summarized:</p><dl><dt><em>Current code</em></dt><dd> <p>Code that is the current latest version of the modules.</p> </dd><dt><em>Old code</em></dt><dd> <p>Code where there exists a newer version in the
system, but the old version is not yet purged.</p> </dd></dl><p>The memory use is in bytes.</p><p>Then, all loaded modules are listed. The following fields exist:</p><dl><dt><em>=mod:&lt;module_name&gt;</em></dt><dd> <p>Heading. States the module name.</p> </dd><dt><em>Current size</em></dt><dd> <p>Memory use for the loaded code, in bytes.</p> </dd><dt><em>Old size</em></dt><dd> <p>Memory use for the old code, if any.</p> </dd><dt><em>Current attributes</em></dt><dd> <p>Module attributes for the current code. This field is decoded
when looked at by the Crashdump Viewer tool.</p> </dd><dt><em>Old attributes</em></dt><dd> <p>Module attributes for the old code, if any. This field is
decoded when looked at by the Crashdump Viewer tool.</p> </dd><dt><em>Current compilation info</em></dt><dd> <p>Compilation information (options) for the current code. This
field is decoded when looked at by the Crashdump Viewer tool.</p> </dd><dt><em>Old compilation info</em></dt><dd> <p>Compilation information (options) for the old code, if
any. This field is decoded when looked at by the Crashdump
Viewer tool.</p> </dd></dl><a name="funs"></a><h4>Fun Information</h4><p>This section lists all funs. The following fields exist for each fun:</p><dl><dt><em>=fun</em></dt><dd> <p>Heading.</p> </dd><dt><em>Module</em></dt><dd> <p>The name of the module where the fun was defined.</p> </dd><dt><em>Uniq, Index</em></dt><dd> <p>Identifiers.</p> </dd><dt><em>Address</em></dt><dd> <p>The address of the fun's code.</p> </dd><dt><em>Native_address</em></dt><dd> <p>The address of the fun's code when HiPE is enabled.</p> </dd><dt><em>Refc</em></dt><dd> <p>The number of references to the fun.</p> </dd></dl><a name="proc_data"></a><h4>Process Data</h4><p>For each process there is at least one <em>=proc_stack</em>
and one <em>=proc_heap</em> tag, followed by the raw memory
information for the stack and heap of the process.</p><p>For each process there is also a <em>=proc_messages</em>
tag if the process message queue is non-empty, and a
<em>=proc_dictionary</em> tag if the process dictionary (the
<strong>put/2</strong> and <strong>get/1</strong> thing) is
non-empty.</p><p>The raw memory information can be decoded by the Crashdump
Viewer tool. You can then see the stack dump, the
message queue (if any), and the dictionary (if any).</p><p>The stack dump is a dump of the Erlang process stack. Most of
the live data (that is, variables currently in use) are placed on
the stack; thus this can be interesting. One has to
"guess" what is what, but as the information is symbolic,
thorough reading of this information can be useful. As an
example, we can find the state variable of the Erlang primitive
loader online <strong>(5)</strong> and <strong>(6)</strong>
in the following example:</p><pre><code class="">
(1)  3cac44   Return addr 0x13BF58 (&lt;terminate process normally&gt;)
(2)  y(0)     ["/view/siri_r10_dev/clearcase/otp/erts/lib/kernel/ebin",
(3)            "/view/siri_r10_dev/clearcase/otp/erts/lib/stdlib/ebin"]
(4)  y(1)     &lt;0.1.0&gt;
(5)  y(2)     {state,[],none,#Fun&lt;erl_prim_loader.6.7085890&gt;,undefined,#Fun&lt;erl_prim_loader.7.9000327&gt;,
(6)            #Fun&lt;erl_prim_loader.8.116480692&gt;,#Port&lt;0.2&gt;,infinity,#Fun&lt;erl_prim_loader.9.10708760&gt;}
(7)  y(3)     infinity    </code></pre><p>When interpreting the data for a process, it is helpful to know
that anonymous function objects (funs) are given the following:</p><ul><li>A name constructed from the name of the function in which they are created </li><li>A number (starting with 0) indicating the number of that fun within that function </li></ul><a name="atoms"></a><h4>Atoms</h4><p>This section presents all the atoms in the system. This is only
of interest if one suspects that dynamic generation of atoms can
be a problem, otherwise this section can be ignored.</p><p>Notice that the last created atom is shown first.</p><h4>Disclaimer</h4><p>The format of the crash dump evolves between OTP releases.
Some information described here may not apply to your
version. A description like this will never be complete; it is meant as
an explanation of the crash dump in general and as a help
when trying to find application errors, not as a complete
specification.</p><p>This section describes how to implement an alternative carrier
protocol for the Erlang distribution. The distribution is normally
carried by TCP/IP. Here is explained a method for replacing TCP/IP
with another protocol.</p><p>The section is a step-by-step explanation of the
<strong>uds_dist</strong> example application (in the
Kernel application <strong>examples</strong> directory). The
<strong>uds_dist</strong> application implements distribution over Unix
domain sockets and is written for the Sun Solaris 2 operating environment.
The mechanisms are however general and apply to any operating system Erlang
runs on. The reason the C code is not made portable, is simply
readability.</p><h4>Introduction</h4><p>To implement a new carrier for the Erlang distribution, the main
steps are as follows.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
As of ERTS version 10.0 support for distribution controller
processes has been introduced. That is, the traffic over a
distribution channel can be managed by a process instead of
only by a port. This makes it possible to implement large
parts of the logic in Erlang code, and you perhaps do not
even need a new driver for the protocol. One example could
be Erlang distribution over UDP using <strong>gen_udp</strong> (your
Erlang code will of course have to take care of retransmissions,
etc in this example). That is, depending on what you want
to do you perhaps do not need to implement a driver at all
and can then skip the driver related sections below.
The <strong>gen_tcp_dist</strong> example described in the
<a href="#distribution_module">Distribution Module</a> section utilize distribution controller
processes and can be worth having a look at if you want to
use distribution controller processes.
</p></div><h4>Writing an Erlang Driver</h4><p>First, the protocol must be available to the Erlang machine, which
involves writing an Erlang driver. A port program cannot be used,
an Erlang driver is required. Erlang drivers can be:</p><ul><li> <p>Statically linked to the emulator, which can be an alternative
when using the open source distribution of Erlang, or</p> </li><li> <p>Dynamically loaded into the Erlang machines address space,
which is the only alternative if a precompiled version of 
Erlang is to be used</p> </li></ul><p>Writing an Erlang driver is not easy. The driver is written
as some callback functions called by the Erlang emulator when
data is sent to the driver, or the driver has any data available on
a file descriptor. As the driver callback routines execute in the main
thread of the Erlang machine, the callback functions can perform
no blocking activity whatsoever. The callbacks are only to set up
file descriptors for waiting and/or read/write available data. All
I/O must be non-blocking. Driver callbacks are however executed
in sequence, why a global state can safely be updated within the
routines.</p><h4>Writing an Erlang Interface for the Driver</h4><p>When the driver is implemented, one would preferably write an
Erlang interface for the driver to be able to test the
functionality of the driver separately. This interface can then
be used by the distribution module, which will cover the details of
the protocol from the <strong>net_kernel</strong>.</p><p>The easiest path
is to mimic the <strong>inet</strong> and <strong>inet_tcp</strong>
interfaces, but not much
functionality in those modules needs to be implemented. In the
example application, only a few of the usual interfaces are
implemented, and they are much simplified.</p><h4>Writing a Distribution Module</h4><p>When the protocol is available to Erlang through a driver and an
Erlang interface module, a distribution module can be written.
The distribution module is a module with well-defined callbacks,
much like a <strong>gen_server</strong> (there is no compiler support
for checking the callbacks, though). This module implements:</p><ul><li>The details of finding other nodes (that is, talking to <strong>epmd</strong> or something similar)</li><li>Creating a listen port (or similar)</li><li>Connecting to other nodes</li><li>Performing the handshakes/cookie verification</li></ul><p>There is however a utility module, <strong>dist_util</strong>, which
does most of the hard work of handling handshakes, cookies, timers,
and ticking. Using <strong>dist_util</strong> makes implementing a
distribution module much easier and that is done in
the example application.</p><h4>Creating Boot Scripts</h4><p>The last step is to create boot scripts to make the protocol
implementation available at boot time. The implementation can be
debugged by starting the distribution when all the system is
running, but in a real system the distribution is to start very
early, why a boot script and some command-line parameters are
necessary.</p><p>This step also implies that the Erlang code in the
interface and distribution modules is written in such a way that
it can be run in the startup phase. In particular, there can be no
calls to the <strong>application</strong> module or to any modules
not loaded at boot time. That is, only <strong>Kernel</strong>,
<strong>STDLIB</strong>, and the application itself can be used.</p><a name="distribution_module"></a><h4>Distribution Module</h4><p>
The distribution module expose an API that <strong>net_kernel</strong> call
in order to manage connections to other nodes. The module name
should have the suffix <strong>_dist</strong>.
</p><p>
The module needs to create some kind of listening entity (process
or port) and an acceptor process that accepts incoming connections
using the listening entity. For each connection, the module at least
needs to create one connection supervisor process, which also is
responsible for the handshake when setting up the connection, and
a distribution controller (process or port) responsible for
transport of data over the connection. The distribution controller
and the connection supervisor process should be linked together
so both of them are cleaned up when the connection is taken down.
</p><p>
Note that there need to be exactly one distribution controller
per connection. A process or port can only be distribution
controller for one connection. The registration as distribution
controller cannot be undone. It will stick until the distribution
controller terminates. The distribution controller should not
ignore exit signals. It is allowed to trap exits, but it should
then voluntarily terminate when an exit signal is received.
</p><p>
An example implementation of a distribution module can be found
in
<a href="gen_tcp_dist.erl">$ERL_TOP/lib/kernel/examples/gen_tcp_dist/src/gen_tcp_dist.erl</a>.
It implements the distribution over TCP/IP using the <strong>gen_tcp</strong>
API with distribution controllers implemented by processes. This
instead of using port distribution controllers as the ordinary TCP/IP
distribution uses.
</p><a name="distribution_module_exported_callback_functions"></a><h4>Exported Callback Functions</h4><p>
The following functions are mandatory:
</p><dl><dt><a name="listen"></a><strong>listen(Name) -&gt;</strong><br/>Â Â <strong>{ok, {Listen, Address, Creation}} | {error, Error} </strong></dt><dd> <p>
<strong>listen/1</strong> is called once in order to listen for incoming
connection requests. The call is made when the distribution is brought
up. The argument <strong>Name</strong> is the part of the node name before
the <strong>@</strong> sign in the full node name. It can be either an atom or a
string.
</p> <p>
The return value consists of a <strong>Listen</strong> handle (which is
later passed to the <a href="#accept">accept</a>
callback), <strong>Address</strong> which is a <strong>#net_address{}</strong> record
with information about the address for the node (the
<strong>#net_address{}</strong> record is defined in
<strong>kernel/include/net_address.hrl</strong>), and <strong>Creation</strong> which
(currently) is an integer <strong>1</strong>, <strong>2</strong>, or <strong>3</strong>.
</p> <p>
If <a href="./epmd">erts/epmd</a> is to be used 
for node discovery, you typically want to use the (unfortunately
undocumented) <strong>erl_epmd</strong> module (part of the <strong>kernel</strong>
application) in order to register the listen port with <strong>epmd</strong>
and retrieve <strong>Creation</strong> to use.
</p> </dd><dt><a name="accept"></a><strong>accept(Listen) -&gt;</strong><br/>Â Â <strong>AcceptorPid</strong></dt><dd> <p>
<strong>accept/1</strong> should spawn a process that accepts connections. This
process should preferably execute on <strong>max</strong> priority. The process
identifier of this process should be returned.
</p> <p>
The <strong>Listen</strong> argument will be the same as the <strong>Listen</strong> handle
part of the return value of the
<a href="#listen">listen</a> callback above.
<strong>accept/1</strong> is called only once when the distribution protocol is
started.
</p> <p>
The caller of this function is a representative for <strong>net_kernel</strong>
(this may or may not be the process registered as <strong>net_kernel</strong>)
and is in this document identified as <strong>Kernel</strong>.
When a connection has been accepted by the acceptor process, it needs
to inform <strong>Kernel</strong> about the accepted connection. This is done by
passing a message on the form:
</p> <pre><code class="">Kernel ! {accept, AcceptorPid, DistController, Family, Proto}</code></pre> <p>
<strong>DistController</strong> is either the process or port identifier
of the distribution controller for the connection. The
distribution controller should be created by the acceptor
processes when a new connection is accepted. Its job is to
dispatch traffic on the connection.
</p> <strong>Kernel</strong> responds with one of the following messages: <dl><dt><strong>{Kernel, controller, SupervisorPid}</strong></dt><dd> <p>
The request was accepted and <strong>SupervisorPid</strong> is the
process identifier of the connection supervisor process
(which is created in the
<a href="#accept_connection">accept_connection</a>
callback).
</p> </dd><dt><strong>{Kernel, unsupported_protocol}</strong></dt><dd> <p>
The request was rejected. This is a fatal error. The acceptor
process should terminate.
</p> </dd></dl> <p>
When an accept sequence has been completed the acceptor process
is expected to continue accepting further requests.
</p> </dd><dt><a name="accept_connection"></a><strong>accept_connection(AcceptorPid, DistCtrl, MyNode, Allowed, SetupTime) -&gt;</strong><br/>Â Â <strong>ConnectionSupervisorPid</strong></dt><dd> <p>
<strong>accept_connection/5</strong> should spawn a process that will
perform the Erlang distribution handshake for the connection.
If the handshake successfully completes it should continue to
function as a connection supervisor. This process
should preferably execute on <strong>max</strong> priority.
</p> <p>The arguments:</p> <dl><dt><strong>AcceptorPid</strong></dt><dd> <p>
Process identifier of the process created by the
<a href="#accept">accept</a>
callback.
</p> </dd><dt><strong>DistCtrl</strong></dt><dd> <p>The identifier of the distribution controller identifier
created by the acceptor process. To be passed along to
<strong>dist_util:handshake_other_started(HsData)</strong>.
</p> </dd><dt><strong>MyNode</strong></dt><dd> <p>
Node name of this node. To be passed along to
<strong>dist_util:handshake_other_started(HsData)</strong>.
</p> </dd><dt><strong>Allowed</strong></dt><dd> <p>
To be passed along to
<strong>dist_util:handshake_other_started(HsData)</strong>.
</p> </dd><dt><strong>SetupTime</strong></dt><dd> <p>
Time used for creating a setup timer by a
call to <strong>dist_util:start_timer(SetupTime)</strong>.
The timer should be passed along to
<strong>dist_util:handshake_other_started(HsData)</strong>.
</p> </dd></dl> <p>
The created process should provide callbacks and other
information needed for the handshake in a
<a href="#hs_data_record">hs_data_record</a>
record and call <strong>dist_util:handshake_other_started(HsData)</strong>
with this record.
</p> <p>
<strong>dist_util:handshake_other_started(HsData)</strong> will perform
the handshake and if the handshake successfully completes this
process will then continue in a connection supervisor loop
as long as the connection is up.
</p> </dd><dt><a name="setup"></a><strong>setup(Node, Type, MyNode, LongOrShortNames, SetupTime) -&gt;</strong><br/>Â Â <strong>ConnectionSupervisorPid</strong></dt><dd> <p>
<strong>setup/5</strong> should spawn a process that connects to
<strong>Node</strong>. When connection has been established it should
perform the Erlang distribution handshake for the connection.
If the handshake successfully completes it should continue to
function as a connection supervisor. This process
should preferably execute on <strong>max</strong> priority.
</p> <p>The arguments:</p> <dl><dt><strong>Node</strong></dt><dd> <p>
Node name of remote node. To be passed along to
<strong>dist_util:handshake_we_started(HsData)</strong>.
</p> </dd><dt><strong>Type</strong></dt><dd> <p>
Connection type. To be passed along to
<strong>dist_util:handshake_we_started(HsData)</strong>.
</p> </dd><dt><strong>MyNode</strong></dt><dd> <p>
Node name of this node. To be passed along to
<strong>dist_util:handshake_we_started(HsData)</strong>.
</p> </dd><dt><strong>LongOrShortNames</strong></dt><dd> <p>
Either the atom <strong>longnames</strong> or
the atom <strong>shortnames</strong> indicating
whether long or short names is used.
</p> </dd><dt><strong>SetupTime</strong></dt><dd> <p>
Time used for creating a setup timer by a
call to <strong>dist_util:start_timer(SetupTime)</strong>.
The timer should be passed along to
<strong>dist_util:handshake_we_started(HsData)</strong>.
</p> </dd></dl> <p>
The caller of this function is a representative for <strong>net_kernel</strong>
(this may or may not be the process registered as <strong>net_kernel</strong>)
and is in this document identified as <strong>Kernel</strong>. 
</p> <p>
This function should, besides spawning the connection supervisor,
also create a distribution controller. The distribution
controller is either a process or a port which is responsible
for dispatching traffic.
</p> <p>
The created process should provide callbacks and other
information needed for the handshake in a
<a href="#hs_data_record">hs_data_record</a>
record and call <strong>dist_util:handshake_we_started(HsData)</strong>
with this record.
</p> <p>
<strong>dist_util:handshake_we_started(HsData)</strong> will perform
the handshake and the handshake successfully completes this
process will then continue in a connection supervisor loop
as long as the connection is up.
</p> </dd><dt><a name="close"></a><strong>close(Listen) -&gt;</strong><br/>Â Â <strong>void()</strong></dt><dd><p>
Called in order to close the <strong>Listen</strong> handle
that originally was passed from the
<a href="#listen">listen</a> callback.
</p></dd><dt><a name="select"></a><strong>select(NodeName) -&gt;</strong><br/>Â Â <strong>boolean()</strong></dt><dd> <p>Return <strong>true</strong> if the host name part
of the <strong>NodeName</strong> is valid for use
with this protocol; otherwise, <strong>false</strong>.
</p> </dd></dl><p>
There are also two optional functions that may be
exported:
</p><dl><dt><a name="select"></a><strong>setopts(Listen, Opts) -&gt;</strong><br/>Â Â <strong>ok | {error, Error}</strong></dt><dd> <p>
The argument <strong>Listen</strong> is the handle originally passed
from the
<a href="#listen">listen</a> callback.
The argument <strong>Opts</strong> is a list of options to set on future
connections.
</p> </dd><dt><a name="select"></a><strong>getopts(Listen, Opts) -&gt;</strong><br/>Â Â <strong>{ok, OptionValues} | {error, Error}</strong></dt><dd> <p>
The argument <strong>Listen</strong> is the handle originally passed
from the
<a href="#listen">listen</a> callback.
The argument <strong>Opts</strong> is a list of options to read for future
connections.
</p> </dd></dl><a name="hs_data_record"></a><h4>The #hs_data{} Record</h4><p>
The <strong>dist_util:handshake_we_started/1</strong> and
<strong>dist_util:handshake_other_started/1</strong> functions
takes a <strong>#hs_data{}</strong> record as argument. There
are quite a lot of fields in this record that you
need to set. The record is defined in
<strong>kernel/include/dist_util.hrl</strong>. Not documented
fields should not be set, i.e., should be left as
<strong>undefined</strong>.
</p><p>
The following <strong>#hs_data{}</strong> record fields need
to be set unless otherwise stated:</p><dl><dt><a name="hs_data_kernel_pid"></a><strong>kernel_pid</strong></dt><dd> <p>
Process identifier of the <strong>Kernel</strong> process. That is,
the process that called either
<a href="#setup">setup</a> or
<a href="#accept_connection">accept_connection</a>.
</p> </dd><dt><a name="hs_data_other_node"></a><strong>other_node</strong></dt><dd> <p>Name of the other node. This field is only
mandatory when this node initiates the connection.
That is, when connection is set up via
<a href="#setup">setup</a>.
</p> </dd><dt><a name="hs_data_this_node"></a><strong>this_node</strong></dt><dd> <p>
The node name of this node.
</p> </dd><dt><a name="hs_data_socket"></a><strong>socket</strong></dt><dd> <p>
The identifier of the distribution controller.
</p> </dd><dt><a name="hs_data_timer"></a><strong>timer</strong></dt><dd> <p>
The timer created using <strong>dist_util:start_timer/1</strong>.
</p> </dd><dt><a name="hs_data_allowed"></a><strong>allowed</strong></dt><dd> <p>Information passed as <strong>Allowed</strong> to
<strong>accept_connection/5</strong>. This field is only
mandatory when the remote node initiated the
connection. That is, when the connection is set
up via
<a href="#accept_connection">accept_connection</a>.
</p> </dd><dt><a name="hs_data_f_send"></a><strong>f_send</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr, Data) -&gt; ok | {error, Error}</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier of
the distribution controller and <strong>Data</strong>
is io data to pass to the other side.
</p> <p>Only used during handshake phase.</p> </dd><dt><a name="hs_data_f_recv"></a><strong>f_recv</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr, Length) -&gt; {ok, Packet} | {error, Reason}</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier of the distribution
controller.
If <strong>Length</strong> is <strong>0</strong>, all available bytes should be
returned. If <strong>Length &gt; 0</strong>, exactly <strong>Length</strong> bytes
should be returned, or an error; possibly discarding less
than <strong>Length</strong> bytes of data when the connection is
closed from the other side.
It is used for passive receive of data from the
other end.
</p> <p>Only used during handshake phase.</p> </dd><dt><a name="hs_data_f_setopts_pre_nodeup"></a><strong>f_setopts_pre_nodeup</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr) -&gt; ok | {error, Error}</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier of
the distribution controller. Called just
before the distribution channel is taken up
for normal traffic.
</p> <p>Only used during handshake phase.</p> </dd><dt><a name="hs_data_f_setopts_post_nodeup"></a><strong>f_setopts_post_nodeup</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr) -&gt; ok | {error, Error}</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier of
the distribution controller. Called just
after distribution channel has been taken
up for normal traffic.
</p> <p>Only used during handshake phase.</p> </dd><dt><a name="hs_data_f_getll"></a><strong>f_getll</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr) -&gt; ID</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier of
the distribution controller and <strong>ID</strong> is
the identifier of the low level entity that
handles the connection (often <strong>DistCtrlr</strong>
itself).
</p> <p>Only used during handshake phase.</p> </dd><dt><a name="hs_data_f_address"></a><strong>f_address</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr, Node) -&gt; NetAddress</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier of
the distribution controller, <strong>Node</strong>
is the node name of the node on the other end,
and <strong>NetAddress</strong> is a <strong>#net_address{}</strong>
record with information about the address
for the <strong>Node</strong> on the other end of the
connection. The <strong>#net_address{}</strong> record
is defined in
<strong>kernel/include/net_address.hrl</strong>.
</p> <p>Only used during handshake phase.</p> </dd><dt><a name="hs_data_mf_tick"></a><strong>mf_tick</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr) -&gt; void()</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier
of the distribution controller. This
function should send information over
the connection that is not interpreted
by the other end while increasing the
statistics of received packets on the
other end. This is usually implemented by
sending an empty packet.
</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
It is of vital importance that this operation
does not block the caller for a long time.
This since it is called from the connection
supervisor.
</p></div> <p>Used when connection is up.</p> </dd><dt><a name="hs_data_mf_getstat"></a><strong>mf_getstat</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr) -&gt; {ok, Received, Sent, PendSend}</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier
of the distribution controller, <strong>Received</strong>
is received packets, <strong>Sent</strong> is
sent packets, and <strong>PendSend</strong> is
amount of packets in queue to be sent
or a <strong>boolean()</strong> indicating whether
there are packets in queue to be sent.
</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
It is of vital importance that this operation
does not block the caller for a long time.
This since it is called from the connection
supervisor.
</p></div> <p>Used when connection is up.</p> </dd><dt><a name="hs_data_request_type"></a><strong>request_type</strong></dt><dd> <p>
The request <strong>Type</strong> as passed to
<a href="#setup">setup</a>.
This is only mandatory when the connection has
been initiated by this node. That is, the connection
is set up via <strong>setup/5</strong>.
</p> </dd><dt><a name="hs_data_mf_setopts"></a><strong>mf_setopts</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrl, Opts) -&gt; ok | {error, Error}</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier
of the distribution controller and <strong>Opts</strong>
is a list of options to set on the connection.
</p> <p>This function is optional. Used when connection is up.</p> </dd><dt><a name="hs_data_mf_getopts"></a><strong>mf_getopts</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrl, Opts) -&gt; {ok, OptionValues} | {error, Error}</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier
of the distribution controller and <strong>Opts</strong>
is a list of options to read for the connection.
</p> <p>This function is optional. Used when connection is up.</p> </dd><dt><a name="hs_data_f_handshake_complete"></a><strong>f_handshake_complete</strong></dt><dd> <p>
A fun with the following signature:
</p> <pre><code class="">fun (DistCtrlr, Node, DHandle) -&gt; void()</code></pre> <p>
where <strong>DistCtrlr</strong> is the identifier
of the distribution controller, <strong>Node</strong> is
the node name of the node connected at the other
end, and <strong>DHandle</strong> is a distribution handle
needed by a distribution controller process when
calling the following BIFs:
</p> <ul><li><p><a href="../erts/erlang#dist_ctrl_get_data/1">erts/erlang#dist_ctrl_get_data/1</a></p></li><li><p><a href="../erts/erlang#dist_ctrl_get_data_notification/1">erts/erlang#dist_ctrl_get_data_notification/1</a></p></li><li><p><a href="../erts/erlang#dist_ctrl_input_handler/2">erts/erlang#dist_ctrl_input_handler/2</a></p></li><li><p><a href="../erts/erlang#dist_ctrl_put_data/2">erts/erlang#dist_ctrl_put_data/2</a></p></li></ul> <p>
This function is called when the handshake has
completed and the distribution channel is up.
The distribution controller can begin dispatching
traffic over the channel. This function is optional.
</p> <p>Only used during handshake phase.</p> </dd><dt><a name="hs_data_add_flags"></a><strong>add_flags</strong></dt><dd> <p>
<a href="./erl_dist_protocol#dflags">Distribution flags</a>
to add to the connection. Currently all (non obsolete) flags will
automatically be enabled.
</p> <p>
This flag field is optional.
</p> </dd><dt><a name="hs_data_reject_flags"></a><strong>reject_flags</strong></dt><dd> <p>
<a href="./erl_dist_protocol#dflags">Distribution flags</a>
to reject. Currently the following distribution flags can be rejected:
</p> <dl><dt><strong>DFLAG_DIST_HDR_ATOM_CACHE</strong></dt><dd>Do not use atom cache over this connection.</dd></dl> <p>Use function <strong>dist_util:strict_order_flags/0</strong> to get all flags
for features that require strict order delivery.</p> <p>
This flag field is optional.
</p> </dd><dt><a name="hs_data_require_flags"></a><strong>require_flags</strong></dt><dd> <p>
Require these <a href="./erl_dist_protocol#dflags">distribution flags</a> to be used. The connection will be aborted during the
handshake if the other end does not use them.
</p> <p>
This flag field is optional.
</p> </dd></dl><a name="distribution_data_delivery"></a><h4>Distribution Data Delivery</h4><p>
When using the default configuration, the data to pass
over a connection needs to be delivered as is
to the node on the receiving end in the <em>exact same order</em>, with no loss of data what so ever, as sent
from the sending node.
</p><p>
The data delivery order can be relaxed by disabling
features that require strict ordering. This is done by
passing the
<a href="./erl_dist_protocol#dflags">distribution	flags</a>
returned by <strong>dist_util:strict_order_flags/0</strong> in the
<a href="./alt_dist#hs_data_reject_flags">alt_dist#hs_data_reject_flags</a>
field of the <a href="#hs_data_record">hs_data_record</a>
record used when setting up the connection. When relaxed
ordering is used, only the order of signals with the same
sender/receiver pair has to be preserved.
However, note that disabling the features that require
strict ordering may have a negative impact on performance,
throughput, and/or latency. 
</p><a name="enable_your_distribution_module"></a><h4>Enable Your Distribution Module</h4><p>For <strong>net_kernel</strong> to find out which distribution module to use,
the <strong>erl</strong> command-line argument <strong>-proto_dist</strong> is used. It
is followed by one or more distribution module names, with suffix
"_dist" removed. That is, <strong>gen_tcp_dist</strong> as a distribution module
is specified as <strong>-proto_dist gen_tcp</strong>.</p><p>If no <strong>epmd</strong> (TCP port mapper daemon) is used, also command-line
option <strong>-no_epmd</strong> is to be specified, which makes
Erlang skip the <strong>epmd</strong> startup, both as an OS process and as an
Erlang ditto.</p><h4>The Driver</h4><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This section was written a long time ago. Most of it is still
valid, but some things have changed since then. Some updates have
been made to the documentation of the driver presented here,
but more can be done and is planned for the future.
The reader is encouraged to read the
<a href="erl_driver">erl_driver</a> and
<a href="driver_entry">driver_entry</a>
documentation also.</p></div><p>Although Erlang drivers in general can be beyond the scope of this
section, a brief introduction seems to be in place.</p><h4>Drivers in General</h4><p>An Erlang driver is a native code module written in C (or
assembler), which serves as an interface for some special operating
system service. This is a general mechanism that is used
throughout the Erlang emulator for all kinds of I/O. An Erlang
driver can be dynamically linked (or loaded) to the Erlang
emulator at runtime by using the <strong>erl_ddll</strong> Erlang
module. Some of the drivers in OTP are however statically linked
to the runtime system, but that is more an optimization than a
necessity.</p><p>The driver data types and the functions available to the driver
writer are defined in header file <strong>erl_driver.h</strong>
seated in Erlang's include directory. See the
<a href="./erl_driver">erl_driver</a> documentation
for details of which functions are available.</p><p>When writing a driver to make a communications protocol available
to Erlang, one should know just about everything worth knowing
about that particular protocol. All operation must be
non-blocking and all possible situations are to be accounted for in
the driver. A non-stable driver will affect and/or crash the
whole Erlang runtime system.</p><p>The emulator calls the driver in the following situations:</p><ul><li> <p>When the driver is loaded. This callback must have a special
name and inform the emulator of what callbacks are to be used 
by returning a pointer to a <strong>ErlDrvEntry</strong> struct,
which is to be properly filled in (see below).</p> </li><li> <p>When a port to the driver is opened (by a
<strong>open_port</strong> call from Erlang). This routine is to
set up internal data structures and return an opaque data entity of
the type <strong>ErlDrvData</strong>, which is a data type large
enough to hold a pointer.
The pointer returned by this function is the first
argument to all other callbacks concerning this particular
port. It is usually called the port handle. The emulator only
stores the handle and does never try to interpret it, why it can
be virtually anything (anything not larger than a pointer
that is) and can point to anything if it is a pointer. Usually
this pointer refers to a structure holding information about
the particular port, as it does in the example.</p> </li><li> <p>When an Erlang process sends data to the port. The data
arrives as a buffer of bytes, the interpretation is not defined,
but is up to the implementor. This callback returns nothing to the
caller, answers are sent to the caller as messages (using a
routine called <strong>driver_output</strong> available to all
drivers). There is also a way to talk in a synchronous way to
drivers, described below. There can be an additional callback
function for handling data that is fragmented (sent in a deep
io-list). That interface gets the data in a form suitable for
Unix <strong>writev</strong> rather than in a single buffer.
There is no need for a distribution driver to implement such a
callback, so we will not.</p> </li><li> <p>When a file descriptor is signaled for input. This callback
is called when the emulator detects input on a file descriptor
that the driver has marked for monitoring by using the interface
<strong>driver_select</strong>. The mechanism of driver select
makes it possible to read non-blocking from file descriptors by
calling <strong>driver_select</strong> when reading is needed, and
then do the reading in this callback (when reading is possible).
The typical scenario is that <strong>driver_select</strong> is
called when an Erlang process orders a read operation, and that
this routine sends the answer when data is available on the file
descriptor.</p> </li><li> <p>When a file descriptor is signaled for output. This callback
is called in a similar way as the previous, but when writing to a
file descriptor is possible. The usual scenario is that Erlang
orders writing on a file descriptor and that the driver calls
<strong>driver_select</strong>. When the descriptor is ready for
output, this callback is called and the driver can try to send the
output. Queuing can be involved in such operations, and there are
convenient queue routines available to the driver writer to use.</p> </li><li> <p>When a port is closed, either by an Erlang process or by the
driver calling one of the <strong>driver_failure_XXX</strong>
routines. This routine is to clean up everything connected to one
particular port. When other callbacks call a
<strong>driver_failure_XXX</strong> routine, this routine is
immediately called. The callback routine issuing the error can
make no more use of the data structures for the port, as this
routine surely has freed all associated data and closed all file
descriptors. If the queue utility available to driver writer is
used, this routine is however <em>not</em> called until the
queue is empty.</p> </li><li> <p>When an Erlang process calls
<a href="./erlang#port_control/3">erlang#port_control/3</a>,
which is a synchronous interface to drivers. The control interface
is used to set driver options, change states of ports, and so on.
This interface is used a lot in the example.</p> </li><li> <p>When a timer expires. The driver can set timers with the function
<strong>driver_set_timer</strong>. When such timers expire, a
specific callback function is called. No timers are used in
the example.</p> </li><li> <p>When the whole driver is unloaded. Every resource allocated
by the driver is to be freed.</p> </li></ul><h4>The Data Structures of the Distribution Driver</h4><p>The driver used for Erlang distribution is to implement a
reliable, order maintaining, variable length packet-oriented
protocol. All error correction, resending and such need to be
implemented in the driver or by the underlying communications
protocol. If the protocol is stream-oriented (as is the case with
both TCP/IP and our streamed Unix domain sockets), some mechanism
for packaging is needed. We will use the simple method of having a
header of four bytes containing the length of the package in a
big-endian 32-bit integer. As Unix domain sockets only can be used
between processes on the same machine, we do not need to
code the integer in some special endianess, but we will do it anyway
because in most situation you need to do it. Unix domain
sockets are reliable and order maintaining, so we do not need to
implement resends and such in the driver.</p><p>We start writing the example Unix domain sockets driver by
declaring prototypes and filling in a static <strong>ErlDrvEntry</strong>
structure:</p><pre><code class="">
( 1) #include &lt;stdio.h&gt;
( 2) #include &lt;stdlib.h&gt;
( 3) #include &lt;string.h&gt;
( 4) #include &lt;unistd.h&gt;
( 5) #include &lt;errno.h&gt;
( 6) #include &lt;sys/types.h&gt;
( 7) #include &lt;sys/stat.h&gt;
( 8) #include &lt;sys/socket.h&gt;
( 9) #include &lt;sys/un.h&gt;
(10) #include &lt;fcntl.h&gt;

(11) #define HAVE_UIO_H
(12) #include "erl_driver.h"

(13) /*
(14) ** Interface routines
(15) */
(16) static ErlDrvData uds_start(ErlDrvPort port, char *buff);
(17) static void uds_stop(ErlDrvData handle);
(18) static void uds_command(ErlDrvData handle, char *buff, int bufflen);
(19) static void uds_input(ErlDrvData handle, ErlDrvEvent event);
(20) static void uds_output(ErlDrvData handle, ErlDrvEvent event);
(21) static void uds_finish(void);
(22) static int uds_control(ErlDrvData handle, unsigned int command, 
(23)                        char* buf, int count, char** res, int res_size);

(24) /* The driver entry */
(25) static ErlDrvEntry uds_driver_entry = {
(26)     NULL,                            /* init, N/A */
(27)     uds_start,                       /* start, called when port is opened */
(28)     uds_stop,                        /* stop, called when port is closed */
(29)     uds_command,                     /* output, called when erlang has sent */
(30)     uds_input,                       /* ready_input, called when input
(31)                                         descriptor ready */
(32)     uds_output,                      /* ready_output, called when output 
(33)                                         descriptor ready */
(34)     "uds_drv",                       /* char *driver_name, the argument 
(35)                                         to open_port */
(36)     uds_finish,                      /* finish, called when unloaded */
(37)     NULL,                            /* void * that is not used (BC) */
(38)     uds_control,                     /* control, port_control callback */
(39)     NULL,                            /* timeout, called on timeouts */
(40)     NULL,                            /* outputv, vector output interface */
(41)     NULL,                            /* ready_async callback */
(42)     NULL,                            /* flush callback */
(43)     NULL,                            /* call callback */
(44)     NULL,                            /* event callback */
(45)     ERL_DRV_EXTENDED_MARKER,         /* Extended driver interface marker */
(46)     ERL_DRV_EXTENDED_MAJOR_VERSION,  /* Major version number */
(47)     ERL_DRV_EXTENDED_MINOR_VERSION,  /* Minor version number */
(48)     ERL_DRV_FLAG_SOFT_BUSY,          /* Driver flags. Soft busy flag is
(49)                                         required for distribution drivers */
(50)     NULL,                            /* Reserved for internal use */
(51)     NULL,                            /* process_exit callback */
(52)     NULL                             /* stop_select callback */
(53) };</code></pre><p>On line 1-10 the OS headers needed for the driver are included.
As this driver is written for Solaris, we know that the
header <strong>uio.h</strong> exists. So the preprocessor variable
<strong>HAVE_UIO_H</strong> can be defined before
<strong>erl_driver.h</strong> is included on line 12.
The definition of <strong>HAVE_UIO_H</strong> will make the
I/O vectors used in Erlang's driver queues to correspond to the
operating systems ditto, which is very convenient.</p><p>On line 16-23 the different callback functions are declared ("forward
declarations").</p><p>The driver structure is similar for statically linked-in
drivers and dynamically loaded. However, some of the fields
are to be left empty (that is, initialized to NULL) in the
different types of drivers. The first field (the <strong>init</strong>
function pointer) is always left blank in a dynamically loaded
driver, see line 26. <strong>NULL</strong> on line 37
is always to be there, the field is no longer used and is
retained for backward compatibility. No timers are used in this
driver, why no callback for timers is needed. The <strong>outputv</strong> field
(line 40) can be used to implement an interface similar to
Unix <strong>writev</strong> for output. The Erlang runtime
system could previously not use <strong>outputv</strong> for the
distribution, but it can as from ERTS 5.7.2.
As this driver was written before ERTS 5.7.2 it does
not use the <strong>outputv</strong> callback. Using the <strong>outputv</strong>
callback is preferred, as it reduces copying of data. (We
will however use scatter/gather I/O internally in the driver.)</p><p>As from ERTS 5.5.3 the driver interface was extended with
version control and the possibility to pass capability information.
Capability flags are present on line 48. As from ERTS 5.7.4 flag
<a href="./driver_entry#driver_flags">driver_entry#driver_flags</a> is required for drivers that
are to be used by the distribution. The soft busy flag implies that the
driver can handle calls to the <strong>output</strong> and <strong>outputv</strong>
callbacks although it has marked itself as busy. This has always been a
requirement on drivers used by the distribution, but no capability
information has been available about this previously. For more
information. see <a href="./erl_driver#set_busy_port">erl_driver#set_busy_port</a>).</p><p>This driver was written before the runtime system had SMP support.
The driver will still function in the runtime system with SMP support,
but performance will suffer from lock contention on the driver lock
used for the driver. This can be alleviated by reviewing and perhaps
rewriting the code so that each instance of the driver safely can
execute in parallel. When instances safely can execute in parallel, it
is safe to enable instance-specific locking on the driver. This is done
by passing <a href="./driver_entry#driver_flags">driver_entry#driver_flags</a> as a driver flag. This
is left as an exercise for the reader.</p><p>Thus, the defined callbacks are as follows:</p><dl><dt><strong>uds_start</strong></dt><dd> <p>Must initiate data for a port. We do not create any sockets
here, only initialize data structures.</p> </dd><dt><strong>uds_stop</strong></dt><dd> <p>Called when a port is closed.</p> </dd><dt><strong>uds_command</strong></dt><dd> <p>Handles messages from Erlang. The
messages can either be plain data to be sent or more subtle
instructions to the driver. This function is here mostly for
data pumping.</p> </dd><dt><strong>uds_input</strong></dt><dd> <p>Called when there is something to read from a socket.</p> </dd><dt><strong>uds_output</strong></dt><dd> <p>Called when it is possible to write to a socket.</p> </dd><dt><strong>uds_finish</strong></dt><dd> <p>Called when the driver is unloaded. A distribution driver will
never be unloaded, but we include this for completeness. To be
able to clean up after oneself is always a good thing.</p> </dd><dt><strong>uds_control</strong></dt><dd> <p>The <a href="./erlang#port_control/3">erlang#port_control/3</a> callback, which is
used a lot in this implementation.</p> </dd></dl><p>The ports implemented by this driver operate in two major modes,
named <strong>command</strong> and <strong>data</strong>. In <strong>command</strong> mode,
only passive reading and writing (like
<strong>gen_tcp:recv</strong>/<strong>gen_tcp:send</strong>) can be done. The port is in
this mode during the distribution handshake. When the connection is up,
the port is switched to <strong>data</strong> mode and all data is immediately
read and passed further to the Erlang emulator. In <strong>data</strong>
mode, no data arriving to <strong>uds_command</strong> is interpreted, only
packaged and sent out on the socket. The <strong>uds_control</strong> callback
does the switching between those two modes.</p><p>While <strong>net_kernel</strong> informs different subsystems
that the connection is coming up, the port is to accept data to send.
However, the port should not receive any data, to avoid that data
arrives from another node before every kernel subsystem is prepared
to handle it. A third mode, named <strong>intermediate</strong>, is used for this
intermediate stage.</p><p>An enum is defined for the different types of ports:</p><pre><code class="">
( 1) typedef enum { 
( 2)     portTypeUnknown,      /* An uninitialized port */
( 3)     portTypeListener,     /* A listening port/socket */
( 4)     portTypeAcceptor,     /* An intermediate stage when accepting
( 5)                              on a listen port */
( 6)     portTypeConnector,    /* An intermediate stage when connecting */
( 7)     portTypeCommand,      /* A connected open port in command mode */
( 8)     portTypeIntermediate, /* A connected open port in special
( 9)                              half active mode */
(10)     portTypeData          /* A connected open port in data mode */ 
(11) } PortType;      </code></pre><p>The different types are as follows:</p><dl><dt><strong>portTypeUnknown</strong></dt><dd> <p>The type a port has when it is opened, but
not bound to any file descriptor.</p> </dd><dt><strong>portTypeListener</strong></dt><dd> <p>A port that is connected to a listen socket. This port does not
do much, no data pumping is done on this socket, but read data is
available when one is trying to do an accept on the port.</p> </dd><dt><strong>portTypeAcceptor</strong></dt><dd> <p>This port is to represent the result of an accept operation. It is
created when one wants to accept from a listen socket, and it is
converted to a <strong>portTypeCommand</strong> when the accept succeeds.</p> </dd><dt><strong>portTypeConnector</strong></dt><dd> <p>Very similar to <strong>portTypeAcceptor</strong>, an
intermediate stage between the request for a connect operation and
that the socket is connected to an accepting ditto in the
other end. When the sockets are connected, the port
switches type to <strong>portTypeCommand</strong>.</p> </dd><dt><strong>portTypeCommand</strong></dt><dd> <p>A connected socket (or accepted socket) in <strong>command</strong> mode
mentioned earlier.</p> </dd><dt><strong>portTypeIntermediate</strong></dt><dd> <p>The intermediate stage for a connected socket.
There is to be no processing of input for this socket.</p> </dd><dt><strong>portTypeData</strong></dt><dd> <p>The mode where data is pumped through the port and the
<strong>uds_command</strong> routine regards every call as a call where
sending is wanted. In this mode, all input available is read and
sent to Erlang when it arrives on the socket, much like in the
active mode of a <strong>gen_tcp</strong> socket.</p> </dd></dl><p>We study the state that is needed for the ports. Notice
that not all fields are used for all types of ports. Some space
could be saved by using unions, but that would clutter the
code with multiple indirections, so here is used one struct for
all types of ports, for readability:</p><pre><code class="">
( 1) typedef unsigned char Byte;
( 2) typedef unsigned int Word;

( 3) typedef struct uds_data {
( 4)     int fd;                   /* File descriptor */
( 5)     ErlDrvPort port;          /* The port identifier */
( 6)     int lockfd;               /* The file descriptor for a lock file in 
( 7)                                  case of listen sockets */
( 8)     Byte creation;            /* The creation serial derived from the 
( 9)                                  lock file */
(10)     PortType type;            /* Type of port */
(11)     char *name;               /* Short name of socket for unlink */
(12)     Word sent;                /* Bytes sent */
(13)     Word received;            /* Bytes received */
(14)     struct uds_data *partner; /* The partner in an accept/listen pair */
(15)     struct uds_data *next;    /* Next structure in list */
(16)     /* The input buffer and its data */
(17)     int buffer_size;          /* The allocated size of the input buffer */
(18)     int buffer_pos;           /* Current position in input buffer */
(19)     int header_pos;           /* Where the current header is in the 
(20)                                  input buffer */
(21)     Byte *buffer;             /* The actual input buffer */
(22) } UdsData;      </code></pre><p>This structure is used for all types of ports although some
fields are useless for some types. The least memory consuming
solution would be to arrange this structure as a union of
structures. However, the multiple indirections in the code to
access a field in such a structure would clutter the code too
much for an example.</p><p>The fields in the structure are as follows:</p><dl><dt><strong>fd</strong></dt><dd> <p>The file descriptor of the socket associated with the port.</p> </dd><dt><strong>port</strong></dt><dd> <p>The port identifier for the port that this structure
corresponds to. It is needed for most <strong>driver_XXX</strong>
calls from the driver back to the emulator.</p> </dd><dt><strong>lockfd</strong></dt><dd> <p>If the socket is a listen socket, we use a separate
(regular) file for two purposes:</p> <ul><li> <p>We want a locking mechanism that gives no race
conditions, to be sure if another Erlang
node uses the listen socket name we require or if the
file is only left there from a previous (crashed) session.</p> </li><li> <p>We store the <strong>creation</strong> serial number in the
file. The <strong>creation</strong> is a number that is to
change between different instances of different Erlang
emulators with the same name, so that process
identifiers from one emulator do not become valid when sent
to a new emulator with the same distribution name. The
creation can be from 0 through 3 (two bits) and is stored
in every process identifier sent to another node.</p> <p>In a system with TCP-based distribution, this data is
kept in the <em>Erlang port mapper daemon</em>
(<strong>epmd</strong>), which is contacted when a distributed
node starts. The lock file and a convention for the UDS
listen socket's name remove the need for
<strong>epmd</strong> when using this distribution module. UDS
is always restricted to one host, why avoiding a port
mapper is easy.</p> </li></ul> </dd><dt><strong>creation</strong></dt><dd> <p>The creation number for a listen socket, which is
calculated as (the value found in the lock-file + 1) rem 4.
This creation value is also written back into the
lock file, so that the next invocation of the emulator
finds our value in the file.</p> </dd><dt><strong>type</strong></dt><dd> <p>The current type/state of the port, which can be one
of the values declared above.</p> </dd><dt><strong>name</strong></dt><dd> <p>The name of the socket file (the path prefix removed),
which allows for deletion (<strong>unlink</strong>) when the
socket is closed.</p> </dd><dt><strong>sent</strong></dt><dd> <p>How many bytes that have been sent over the
socket. This can wrap, but that is no problem for the
distribution, as the Erlang distribution is only interested in
if this value has changed. (The Erlang
<strong>net_kernel</strong> <strong>ticker</strong> uses this value by calling the
driver to fetch it, which is done through the
<a href="./erlang#port_control/3">erlang#port_control/3</a> routine.)</p> </dd><dt><strong>received</strong></dt><dd> <p>How many bytes that are read (received) from the
socket, used in similar ways as <strong>sent</strong>.</p> </dd><dt><strong>partner</strong></dt><dd> <p>A pointer to another port structure, which is
either the listen port from which this port is accepting a
connection or conversely. The "partner relation"
is always bidirectional.</p> </dd><dt><strong>next</strong></dt><dd> <p>Pointer to next structure in a linked list of all
port structures. This list is used when accepting
connections and when the driver is unloaded.</p> </dd><dt><strong>buffer_size</strong>, <strong>buffer_pos</strong>, <strong>header_pos</strong>, <strong>buffer</strong></dt><dd> <p>Data for input buffering. For details about the input buffering,
see the source code in directory <strong>kernel/examples</strong>. That
certainly goes beyond the scope of this section.</p> </dd></dl><h4>Selected Parts of the Distribution Driver Implementation</h4><p>The implemenation of the distribution driver is not completely
covered here, details about buffering and other things
unrelated to driver writing are not explained. Likewise are
some peculiarities of the UDS protocol not explained in
detail. The chosen protocol is not important.</p><p>Prototypes for the driver callback routines can be found in
the <strong>erl_driver.h</strong> header file.</p><p>The driver initialization routine is (usually) declared with a
macro to make the driver easier to port between different
operating systems (and flavors of systems). This is the only
routine that must have a well-defined name. All other
callbacks are reached through the driver structure. The macro
to use is named <strong>DRIVER_INIT</strong> and takes the driver name
as parameter:</p><pre><code class="">
(1) /* Beginning of linked list of ports */
(2) static UdsData *first_data;

(3) DRIVER_INIT(uds_drv)
(4) {
(5)     first_data = NULL;
(6)     return &amp;uds_driver_entry;
(7) }      </code></pre><p>The routine initializes the single global data structure and
returns a pointer to the driver entry. The routine is called
when <strong>erl_ddll:load_driver</strong> is called from Erlang.</p><p>The <strong>uds_start</strong> routine is called when a port is
opened from Erlang. In this case, we only allocate a structure and
initialize it. Creating the actual socket is left to the
<strong>uds_command</strong> routine.</p><pre><code class="">
( 1) static ErlDrvData uds_start(ErlDrvPort port, char *buff)
( 2) {
( 3)     UdsData *ud;
( 4)     
( 5)     ud = ALLOC(sizeof(UdsData));
( 6)     ud-&gt;fd = -1;
( 7)     ud-&gt;lockfd = -1;
( 8)     ud-&gt;creation = 0;
( 9)     ud-&gt;port = port;
(10)     ud-&gt;type = portTypeUnknown;
(11)     ud-&gt;name = NULL;
(12)     ud-&gt;buffer_size = 0;
(13)     ud-&gt;buffer_pos = 0;
(14)     ud-&gt;header_pos = 0;
(15)     ud-&gt;buffer = NULL;
(16)     ud-&gt;sent = 0;
(17)     ud-&gt;received = 0;
(18)     ud-&gt;partner = NULL;
(19)     ud-&gt;next = first_data;
(20)     first_data = ud;
(21)     
(22)     return((ErlDrvData) ud);
(23) }      </code></pre><p>Every data item is initialized, so that no problems arise
when a newly created port is closed (without there being any
corresponding socket). This routine is called when
<strong>open_port({spawn, "uds_drv"},[])</strong> is called from
Erlang.</p><p>The <strong>uds_command</strong> routine is the routine called when
an Erlang process sends data to the port. This routine handles all
asynchronous commands when the port is in <strong>command</strong> mode and
the sending of all data when the port is in <strong>data</strong> mode:</p><pre><code class="">
( 1) static void uds_command(ErlDrvData handle, char *buff, int bufflen)
( 2) {
( 3)     UdsData *ud = (UdsData *) handle;

( 4)     if (ud-&gt;type == portTypeData || ud-&gt;type == portTypeIntermediate) {
( 5)         DEBUGF(("Passive do_send %d",bufflen));
( 6)         do_send(ud, buff + 1, bufflen - 1); /* XXX */
( 7)         return;
( 8)     } 
( 9)     if (bufflen == 0) {
(10)         return;
(11)     }
(12)     switch (*buff) {
(13)     case 'L':
(14)         if (ud-&gt;type != portTypeUnknown) {
(15)             driver_failure_posix(ud-&gt;port, ENOTSUP);
(16)             return;
(17)         }
(18)         uds_command_listen(ud,buff,bufflen);
(19)         return;
(20)     case 'A':
(21)         if (ud-&gt;type != portTypeUnknown) {
(22)             driver_failure_posix(ud-&gt;port, ENOTSUP);
(23)             return;
(24)         }
(25)         uds_command_accept(ud,buff,bufflen);
(26)         return;
(27)     case 'C':
(28)         if (ud-&gt;type != portTypeUnknown) {
(29)             driver_failure_posix(ud-&gt;port, ENOTSUP);
(30)             return;
(31)         }
(32)         uds_command_connect(ud,buff,bufflen);
(33)         return;
(34)     case 'S':
(35)         if (ud-&gt;type != portTypeCommand) {
(36)             driver_failure_posix(ud-&gt;port, ENOTSUP);
(37)             return;
(38)         }
(39)         do_send(ud, buff + 1, bufflen - 1);
(40)         return;
(41)     case 'R':
(42)         if (ud-&gt;type != portTypeCommand) {
(43)             driver_failure_posix(ud-&gt;port, ENOTSUP);
(44)             return;
(45)         }
(46)         do_recv(ud);
(47)         return;
(48)     default:
(49)         return;
(50)     }
(51) }      </code></pre><p>The command routine takes three parameters; the handle returned for
the port by <strong>uds_start</strong>, which is a pointer
to the internal port structure, the data buffer, and the length
of the data buffer. The buffer is the data sent from Erlang
(a list of bytes) converted to an C array (of bytes).</p><p>If Erlang sends, for example, the list <strong>[$a,$b,$c]</strong>
to the port, the <strong>bufflen</strong> variable is
<strong>3</strong> and the <strong>buff</strong> variable contains
<strong>{'a','b','c'}</strong> (no
<strong>NULL</strong> termination). Usually the first byte is used as an
opcode, which is the case in this driver too (at least when the
port is in <strong>command</strong> mode). The opcodes are defined as follows:</p><dl><dt><strong>'L'&lt;socket name&gt;</strong></dt><dd> <p>Creates and listens on socket with the specified name.</p> </dd><dt><strong>'A'&lt;listen number as 32-bit big-endian&gt;</strong></dt><dd> <p>Accepts from the listen socket identified by the specified
identification number. The identification number is retrieved with
the <strong>uds_control</strong> routine.</p> </dd><dt><strong>'C'&lt;socket name&gt;</strong></dt><dd> <p>Connects to the socket named &lt;socket name&gt;.</p> </dd><dt><strong>'S'&lt;data&gt;</strong></dt><dd> <p>Sends the data &lt;data&gt; on the
connected/accepted socket (in <strong>command</strong> mode). The sending is
acknowledged when the data has left this process.</p> </dd><dt><strong>'R'</strong></dt><dd> <p>Receives one packet of data.</p> </dd></dl><p>"One packet of data" in command <strong>'R'</strong> can be explained
as follows. This driver always sends data packaged with a 4
byte header containing a big-endian 32-bit integer that
represents the length of the data in the packet. There is no
need for different packet sizes or some kind of streamed
mode, as this driver is for the distribution only.
Why is the header word coded explicitly in big-endian when a UDS
socket is local to the host? It is good practice when writing a
distribution driver, as distribution in practice usually crosses
the host boundaries.</p><p>On line 4-8 is handled the case where the port is in <strong>data</strong> mode
or <strong>intermediate</strong> mode and the remaining routine handles the
different commands. The routine uses the
<strong>driver_failure_posix()</strong> routine to report errors
(see, for example, line 15). Notice that the failure routines make
a call to the <strong>uds_stop</strong> routine, which will
remove the internal port data. The handle (and the casted handle
<strong>ud</strong>) is therefore <em>invalid pointers</em> after a
<strong>driver_failure</strong> call and we should <em>return immediately</em>. The runtime system will send exit signals to all
linked processes.</p><p>The <strong>uds_input</strong> routine is called when data is available on a
file descriptor previously passed to the
<strong>driver_select</strong> routine. This occurs typically when
a read command is issued and no data is available. The
<strong>do_recv</strong> routine is as follows:</p><pre><code class="">
( 1) static void do_recv(UdsData *ud)
( 2) {
( 3)     int res;
( 4)     char *ibuf;
( 5)     for(;;) {
( 6)         if ((res = buffered_read_package(ud,&amp;ibuf)) &lt; 0) {
( 7)             if (res == NORMAL_READ_FAILURE) {
( 8)                 driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ, 1);
( 9)             } else {
(10)                 driver_failure_eof(ud-&gt;port);
(11)             }
(12)             return;
(13)         }
(14)         /* Got a package */
(15)         if (ud-&gt;type == portTypeCommand) {
(16)             ibuf[-1] = 'R'; /* There is always room for a single byte 
(17)                                opcode before the actual buffer 
(18)                                (where the packet header was) */
(19)             driver_output(ud-&gt;port,ibuf - 1, res + 1);
(20)             driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ,0);
(21)             return;
(22)         } else {
(23)             ibuf[-1] = DIST_MAGIC_RECV_TAG; /* XXX */
(24)             driver_output(ud-&gt;port,ibuf - 1, res + 1);
(25)             driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ,1);
(26)         }
(27)     }
(28) }      </code></pre><p>The routine tries to read data until a packet is read or the
<strong>buffered_read_package</strong> routine returns a
<strong>NORMAL_READ_FAILURE</strong> (an internally defined constant
for the module, which means that the read operation resulted in an
<strong>EWOULDBLOCK</strong>). If the port is in <strong>command</strong> mode,
the reading stops when one package is read. If the port is in
<strong>data</strong> mode, the reading continues until the socket buffer is empty
(read failure). If no more data can be read and more is wanted (which
is always the case when the socket is in <strong>data</strong> mode),
<strong>driver_select</strong> is called to make the <strong>uds_input</strong>
callback be called when more data is available for reading.</p><p>When the port is in <strong>data</strong> mode, all data is sent to Erlang in a
format that suits the distribution. In fact, the raw data will
never reach any Erlang process, but will be
translated/interpreted by the emulator itself and then
delivered in the correct format to the correct processes. In
the current emulator version, received data is to be tagged
with a single byte of 100. That is what the macro
<strong>DIST_MAGIC_RECV_TAG</strong> is defined to. The tagging of
data in the distribution can be changed in the future.</p><p>The <strong>uds_input</strong> routine handles other input events
(like non-blocking <strong>accept</strong>), but most importantly
handle
data arriving at the socket by calling <strong>do_recv</strong>:</p><pre><code class="">
( 1) static void uds_input(ErlDrvData handle, ErlDrvEvent event)
( 2) {
( 3)     UdsData *ud = (UdsData *) handle;

( 4)     if (ud-&gt;type == portTypeListener) {
( 5)         UdsData *ad = ud-&gt;partner;
( 6)         struct sockaddr_un peer;
( 7)         int pl = sizeof(struct sockaddr_un);
( 8)         int fd;

( 9)         if ((fd = accept(ud-&gt;fd, (struct sockaddr *) &amp;peer, &amp;pl)) &lt; 0) {
(10)             if (errno != EWOULDBLOCK) {
(11)                 driver_failure_posix(ud-&gt;port, errno);
(12)                 return;
(13)             }
(14)             return;
(15)         }
(16)         SET_NONBLOCKING(fd);
(17)         ad-&gt;fd = fd;
(18)         ad-&gt;partner = NULL;
(19)         ad-&gt;type = portTypeCommand;
(20)         ud-&gt;partner = NULL;
(21)         driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ, 0);
(22)         driver_output(ad-&gt;port, "Aok",3);
(23)         return;
(24)     }
(25)     do_recv(ud);
(26) }      </code></pre><p>The important line is the last line in the function: the
<strong>do_read</strong> routine is called to handle new input.
The remaining function handles input on a listen socket, which means
that it is to be possible to do an accept on the
socket, which is also recognized as a read event.</p><p>The output mechanisms are similar to the input.
The <strong>do_send</strong> routine is as follows:</p><pre><code class="">
( 1) static void do_send(UdsData *ud, char *buff, int bufflen) 
( 2) {
( 3)     char header[4];
( 4)     int written;
( 5)     SysIOVec iov[2];
( 6)     ErlIOVec eio;
( 7)     ErlDrvBinary *binv[] = {NULL,NULL};

( 8)     put_packet_length(header, bufflen);
( 9)     iov[0].iov_base = (char *) header;
(10)     iov[0].iov_len = 4;
(11)     iov[1].iov_base = buff;
(12)     iov[1].iov_len = bufflen;
(13)     eio.iov = iov;
(14)     eio.binv = binv;
(15)     eio.vsize = 2;
(16)     eio.size = bufflen + 4;
(17)     written = 0;
(18)     if (driver_sizeq(ud-&gt;port) == 0) {
(19)         if ((written = writev(ud-&gt;fd, iov, 2)) == eio.size) {
(20)             ud-&gt;sent += written;
(21)             if (ud-&gt;type == portTypeCommand) {
(22)                 driver_output(ud-&gt;port, "Sok", 3);
(23)             }
(24)             return;
(25)         } else if (written &lt; 0) {
(26)             if (errno != EWOULDBLOCK) {
(27)                 driver_failure_eof(ud-&gt;port);
(28)                 return;
(29)             } else {
(30)                 written = 0;
(31)             }
(32)         } else {
(33)             ud-&gt;sent += written;
(34)         }
(35)         /* Enqueue remaining */
(36)     }
(37)     driver_enqv(ud-&gt;port, &amp;eio, written);
(38)     send_out_queue(ud);
(39) }      </code></pre><p>This driver uses the <strong>writev</strong> system call to send data
onto the socket. A combination of <strong>writev</strong> and the driver output
queues is very convenient. An <strong>ErlIOVec</strong> structure
contains a <strong>SysIOVec</strong> (which is equivalent to the
<strong>struct iovec</strong> structure defined in
<strong>uio.h</strong>. The
<strong>ErlIOVec</strong> also contains an array of <strong>ErlDrvBinary</strong>
pointers, of the same length as the number of buffers in the
I/O vector itself. One can use this to allocate the binaries
for the queue "manually" in the driver, but here
the binary array is filled with <strong>NULL</strong> values (line 7).
The runtime system then allocates its own buffers when
<strong>driver_enqv</strong> is called (line 37).</p><p>The routine builds an I/O vector containing the header bytes
and the buffer (the opcode has been removed and the buffer
length decreased by the output routine). If the queue is
empty, we write the data directly to the socket (or at
least try to). If any data is left, it is stored in the queue
and then we try to send the queue (line 38). An acknowledgement
is sent when the message is delivered completely (line 22). The
<strong>send_out_queue</strong> sends acknowledgements if the sending
is completed there. If the port is in <strong>command</strong> mode, the Erlang
code serializes the send operations so that only one packet
can be waiting for delivery at a time. Therefore the acknowledgement
can be sent whenever the queue is empty.</p><p>The <strong>send_out_queue</strong> routine is as follows:</p><pre><code class="">
( 1) static int send_out_queue(UdsData *ud)
( 2) {
( 3)     for(;;) {
( 4)         int vlen;
( 5)         SysIOVec *tmp = driver_peekq(ud-&gt;port, &amp;vlen);
( 6)         int wrote;
( 7)         if (tmp == NULL) {
( 8)             driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_WRITE, 0);
( 9)             if (ud-&gt;type == portTypeCommand) {
(10)                 driver_output(ud-&gt;port, "Sok", 3);
(11)             }
(12)             return 0;
(13)         }
(14)         if (vlen &gt; IO_VECTOR_MAX) {
(15)             vlen = IO_VECTOR_MAX;
(16)         } 
(17)         if ((wrote = writev(ud-&gt;fd, tmp, vlen)) &lt; 0) {
(18)             if (errno == EWOULDBLOCK) {
(19)                 driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, 
(20)                               DO_WRITE, 1);
(21)                 return 0;
(22)             } else {
(23)                 driver_failure_eof(ud-&gt;port);
(24)                 return -1;
(25)             }
(26)         }
(27)         driver_deq(ud-&gt;port, wrote);
(28)         ud-&gt;sent += wrote;
(29)     }
(30) }      </code></pre><p>We simply pick out an I/O vector from the queue
(which is the whole queue as a <strong>SysIOVec</strong>). If the I/O
vector is too long (<strong>IO_VECTOR_MAX</strong> is defined to 16), the vector
length is decreased (line 15), otherwise the <strong>writev</strong>
call (line 17) fails. Writing is tried and anything written is dequeued
(line 27).
If the write fails with <strong>EWOULDBLOCK</strong> (notice that all
sockets are in non-blocking mode), <strong>driver_select</strong> is
called to make the <strong>uds_output</strong> routine be called when
there is space to write again.</p><p>We continue trying to write until the queue is empty or
the writing blocks.</p><p>The routine above is called from the <strong>uds_output</strong>
routine:</p><pre><code class="">
( 1) static void uds_output(ErlDrvData handle, ErlDrvEvent event)
( 2) {
( 3)    UdsData *ud = (UdsData *) handle;
( 4)    if (ud-&gt;type == portTypeConnector) {
( 5)        ud-&gt;type = portTypeCommand;
( 6)        driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_WRITE, 0);
( 7)        driver_output(ud-&gt;port, "Cok",3);
( 8)        return;
( 9)    }
(10)    send_out_queue(ud);
(11) }      </code></pre><p>The routine is simple: it first handles the fact that the
output select will concern a socket in the business of
connecting (and the connecting blocked). If the socket is in
a connected state, it simply sends the output queue. This
routine is called when it is possible to write to a socket
where we have an output queue, so there is no question what to
do.</p><p>The driver implements a control interface, which is a
synchronous interface called when Erlang calls
<a href="./erlang#port_control/3">erlang#port_control/3</a>. Only this interface
can control the driver when it is in <strong>data</strong> mode. It can
be called with the following opcodes:</p><dl><dt><strong>'C'</strong></dt><dd> <p>Sets port in <strong>command</strong> mode.</p> </dd><dt><strong>'I'</strong></dt><dd> <p>Sets port in <strong>intermediate</strong> mode.</p> </dd><dt><strong>'D'</strong></dt><dd> <p>Sets port in <strong>data</strong> mode.</p> </dd><dt><strong>'N'</strong></dt><dd> <p>Gets identification number for listen port. This
identification number is used in an accept command to the
driver. It is returned as a big-endian 32-bit integer, which
is the file identifier for the listen socket.</p> </dd><dt><strong>'S'</strong></dt><dd> <p>Gets statistics, which is the number of bytes received,
the number of bytes sent, and the number of bytes pending in
the output queue. This data is used when the distribution
checks that a connection is alive (ticking). The statistics
is returned as three 32-bit big-endian integers.</p> </dd><dt><strong>'T'</strong></dt><dd> <p>Sends a tick message, which is a packet of length 0.
Ticking is done when the port is in <strong>data</strong> mode, so the
command for sending data cannot be used (besides it ignores
zero length packages in <strong>command</strong> mode). This is used by the
ticker to send dummy data when no other traffic is present.</p> <p><em>Note:</em> It is important that the interface for
sending ticks is not blocking. This implementation uses
<a href="./erlang#port_control/3">erlang#port_control/3</a>, which does not block the
caller. If <strong>erlang:port_command</strong> is used, use
<a href="./erlang#port_command/3">erlang#port_command/3</a> and pass <strong>[force]</strong> as
option list; otherwise the caller can be blocked indefinitely
on a busy port and prevent the system from taking down a
connection that is not functioning.</p> </dd><dt><strong>'R'</strong></dt><dd> <p>Gets creation number of a listen socket, which is used to
dig out the number stored in the lock file to differentiate
between invocations of Erlang nodes with the same name.</p> </dd></dl><p>The control interface gets a buffer to return its value in,
but is free to allocate its own buffer if the provided one is
too small. The <strong>uds_control</strong> code is as follows:</p><pre><code class="">
( 1) static int uds_control(ErlDrvData handle, unsigned int command, 
( 2)                        char* buf, int count, char** res, int res_size)
( 3) {
( 4) /* Local macro to ensure large enough buffer. */
( 5) #define ENSURE(N)                               \
( 6)    do {                                         \
( 7)        if (res_size &lt; N) {                      \
( 8)            *res = ALLOC(N);                     \
( 9)        }                                        \
(10)    } while(0)

(11)    UdsData *ud = (UdsData *) handle;

(12)    switch (command) {
(13)    case 'S':
(14)        {
(15)            ENSURE(13);
(16)            **res = 0;
(17)            put_packet_length((*res) + 1, ud-&gt;received);
(18)            put_packet_length((*res) + 5, ud-&gt;sent);
(19)            put_packet_length((*res) + 9, driver_sizeq(ud-&gt;port));
(20)            return 13;
(21)        }
(22)    case 'C':
(23)        if (ud-&gt;type &lt; portTypeCommand) {
(24)            return report_control_error(res, res_size, "einval");
(25)        }
(26)        ud-&gt;type = portTypeCommand;
(27)        driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ, 0);
(28)        ENSURE(1);
(29)        **res = 0;
(30)        return 1;
(31)    case 'I':
(32)        if (ud-&gt;type &lt; portTypeCommand) {
(33)            return report_control_error(res, res_size, "einval");
(34)        }
(35)        ud-&gt;type = portTypeIntermediate;
(36)        driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ, 0);
(37)        ENSURE(1);
(38)        **res = 0;
(39)        return 1;
(40)    case 'D':
(41)        if (ud-&gt;type &lt; portTypeCommand) {
(42)            return report_control_error(res, res_size, "einval");
(43)        }
(44)        ud-&gt;type = portTypeData;
(45)        do_recv(ud);
(46)        ENSURE(1);
(47)        **res = 0;
(48)        return 1;
(49)    case 'N':
(50)        if (ud-&gt;type != portTypeListener) {
(51)            return report_control_error(res, res_size, "einval");
(52)        }
(53)        ENSURE(5);
(54)        (*res)[0] = 0;
(55)        put_packet_length((*res) + 1, ud-&gt;fd);
(56)        return 5;
(57)    case 'T': /* tick */
(58)        if (ud-&gt;type != portTypeData) {
(59)            return report_control_error(res, res_size, "einval");
(60)        }
(61)        do_send(ud,"",0);
(62)        ENSURE(1);
(63)        **res = 0;
(64)        return 1;
(65)    case 'R':
(66)        if (ud-&gt;type != portTypeListener) {
(67)            return report_control_error(res, res_size, "einval");
(68)        }
(69)        ENSURE(2);
(70)        (*res)[0] = 0;
(71)        (*res)[1] = ud-&gt;creation;
(72)        return 2;
(73)    default:
(74)        return report_control_error(res, res_size, "einval");
(75)    }
(76) #undef ENSURE
(77) }      </code></pre><p>The macro <strong>ENSURE</strong> (line 5-10) is used to ensure that
the buffer is large enough for the answer. We switch on the command and
take actions. We always have read select active on a port in <strong>data</strong>
mode (achieved by calling <strong>do_recv</strong> on line 45), but
we turn off read selection in <strong>intermediate</strong> and <strong>command</strong>
modes (line 27 and 36).</p><p>The rest of the driver is more or less UDS-specific and not of
general interest.</p><h4>Putting It All Together</h4><p>To test the distribution, the <strong>net_kernel:start/1</strong>
function can be used. It is useful, as it starts the distribution on a
running system, where tracing/debugging can be performed.
The <strong>net_kernel:start/1</strong> routine takes a
list as its single argument. The list first element in the list is to be
the node name (without the "@hostname") as an atom. The second (and
last) element is to be one of the atoms <strong>shortnames</strong> or 
<strong>longnames</strong>. In the example case,
<strong>shortnames</strong> is preferred.</p><p>For <strong>net_kernel</strong> to find out which distribution module to use,
command-line argument <strong>-proto_dist</strong> is used. It
is followed by one or more distribution module names, with suffix
"_dist" removed, that is, <strong>uds_dist</strong> as a distribution module
is specified as <strong>-proto_dist uds</strong>.</p><p>If no <strong>epmd</strong> (TCP port mapper daemon) is used, also command-line
option <strong>-no_epmd</strong> is to be specified, which makes
Erlang skip the <strong>epmd</strong> startup, both as an OS process and as an
Erlang ditto.</p><p>The path to the directory where the distribution modules reside
must be known at boot. This can be achieved either by
specifying <strong>-pa &lt;path&gt;</strong> on the command line or by
building a boot script containing the applications used for your
distribution protocol. (In the <strong>uds_dist</strong> protocol, only the
<strong>uds_dist</strong> application needs to be added to the script.)</p><p>The distribution starts at boot if all the above is
specified and an <strong>-sname &lt;name&gt;</strong> flag is present at the
command line.</p><p><em>Example 1:</em></p><pre>
$ <span class="input">erl -pa $ERL_TOP/lib/kernel/examples/uds_dist/ebin -proto_dist uds -no_epmd</span>
Erlang (BEAM) emulator version 5.0 
 
Eshell V5.0  (abort with ^G)
1&gt; <span class="input">net_kernel:start([bing,shortnames]).</span>
{ok,&lt;0.30.0&gt;}
(bing@hador)2&gt;</pre><p><em>Example 2:</em></p><pre>
$ <span class="input">erl -pa $ERL_TOP/lib/kernel/examples/uds_dist/ebin -proto_dist uds \ </span>
<span class="input">      -no_epmd -sname bong</span>
Erlang (BEAM) emulator version 5.0 
 
Eshell V5.0  (abort with ^G)
(bong@hador)1&gt;</pre><p>The <strong>ERL_FLAGS</strong> environment variable can be used to store the
complicated parameters in:</p><pre>
$ <span class="input">ERL_FLAGS=-pa $ERL_TOP/lib/kernel/examples/uds_dist/ebin \ </span>
<span class="input">      -proto_dist uds -no_epmd</span>
$ <span class="input">export ERL_FLAGS</span>
$ <span class="input">erl -sname bang</span>
Erlang (BEAM) emulator version 5.0 
 
Eshell V5.0  (abort with ^G)
(bang@hador)1&gt;</pre><p><strong>ERL_FLAGS</strong> should not include the node name.</p><p>
This section describes how to implement an alternative discovery mechanism
for Erlang distribution. Discovery is normally done using DNS and the
Erlang Port Mapper Daemon (EPMD) for port discovery.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Support for alternative service discovery mechanisms was added in Erlang/OTP
21.
</p></div><h4>Introduction</h4><p>To implement your own service discovery module you have to write your own
EPMD module. The <a href="./erl_epmd">EPMD module</a> is
responsible for providing the location of another node. The distribution
modules (<strong>inet_tcp_dist</strong>/<strong>inet_tls_dist</strong>) call the EPMD module to
get the IP address and port of the other node. The EPMD module that is part
of Erlang/OTP will resolve the hostname using DNS and uses the EPMD unix
process to get the port of another node. The EPMD unix process does this by
connecting to the other node on a well-known port, port 4369.</p><h4>Discovery module</h4><p>The discovery module needs to implement the same API as the regular
<a href="./erl_epmd">EPMD module</a>. However, instead of
communicating with EPMD you can connect to any service to find out
connection details of other nodes. A discovery module is enabled
by setting <a href="./erl">-epmd_module</a>
when starting erlang. The discovery module must implement the following
callbacks:</p><dl><dt><a href="../kernel/erl_epmd#start_link/0">start_link/0</a></dt><dd>Start any processes needed by the discovery module.</dd><dt><a href="../kernel/erl_epmd#names/1">names/1</a></dt><dd>Return node names held by the registrar for the given host.</dd><dt><a href="../kernel/erl_epmd#register_node/2">register_node/2</a></dt><dd>Register the given node name with the registrar.</dd><dt><a href="../kernel/erl_epmd#port_please/3">port_please/3</a></dt><dd>Return the distribution port used by the given node.</dd></dl><p>The discovery module may implement the following callback:</p><dl><dt><a href="../kernel/erl_epmd#address_please/3">address_please/3</a></dt><dd><p>Return the address of the given node.
If not implemented, <a href="../kernel/inet#gethostbyname/1"> inet:gethostbyname/1</a> will be used instead</p> <p>This callback may also return the port of the given node. In that case
<a href="../kernel/erl_epmd#port_please/3">port_please/3</a>
may be omitted.</p></dd></dl><p>This section describes the standard representation of parse trees for Erlang
programs as Erlang terms. This representation is known as the <em>abstract format</em>. Functions dealing with such parse trees are
<a href="../compiler/compile#forms/1">compiler/compile#forms/1</a> and functions in the following
modules:</p><ul><li><a href="./epp">stdlib/epp</a></li><li><a href="./erl_eval">stdlib/erl_eval</a></li><li><a href="./erl_lint">stdlib/erl_lint</a></li><li><a href="./erl_parse">stdlib/erl_parse</a></li><li><a href="./erl_pp">stdlib/erl_pp</a></li><li><a href="./io">stdlib/io</a></li></ul><p>The functions are also used as input and output for parse transforms, see
the <a href="./compile">compiler/compile</a>
module.</p><p>We use the function <strong>Rep</strong> to denote the mapping from an Erlang source
construct <strong>C</strong> to its abstract format representation <strong>R</strong>, and write
<strong>R = Rep(C)</strong>.</p><p>The word <strong>LINE</strong> in this section represents an integer, and denotes the
number of the line in the source file where the construction occurred.
Several instances of <strong>LINE</strong> in the same construction can denote
different lines.</p><p>As operators are not terms in their own right, when operators are
mentioned below, the representation of an operator is to be taken to
be the atom with a printname consisting of the same characters as the
operator.</p><h4>Module Declarations and Forms</h4><p>A module declaration consists of a sequence of forms, which are either
function declarations or attributes.</p><ul><li> <p>If D is a module declaration consisting of the forms
<strong>F_1</strong>, ..., <strong>F_k</strong>, then
Rep(D) = <strong>[Rep(F_1), ..., Rep(F_k)]</strong>.</p> </li><li> <p>If F is an attribute <strong>-export([Fun_1/A_1, ..., Fun_k/A_k])</strong>,
then Rep(F) =
<strong>{attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}</strong>.</p> </li><li> <p>If F is an attribute <strong>-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])</strong>,
then Rep(F) =
<strong>{attribute,LINE,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}</strong>.</p> </li><li> <p>If F is an attribute <strong>-module(Mod)</strong>, then
Rep(F) = <strong>{attribute,LINE,module,Mod}</strong>.</p> </li><li> <p>If F is an attribute <strong>-file(File,Line)</strong>, then
Rep(F) = <strong>{attribute,LINE,file,{File,Line}}</strong>.</p> </li><li> <p>If F is a function declaration <strong>Name Fc_1 ; ... ; Name Fc_k</strong>,
where each <strong>Fc_i</strong> is a function clause with a pattern sequence of
the same length <strong>Arity</strong>, then Rep(F) =
<strong>{function,LINE,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}</strong>.</p> </li><li> <p>If F is a function specification <strong>-Spec Name Ft_1; ...; Ft_k</strong>,
where <strong>Spec</strong> is either the atom <strong>spec</strong> or the atom
<strong>callback</strong>, and each <strong>Ft_i</strong> is a possibly constrained
function type with an argument sequence of the same length
<strong>Arity</strong>, then Rep(F) =
<strong>{attribute,Line,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}</strong>.</p> </li><li> <p>If F is a function specification
<strong>-spec Mod:Name Ft_1; ...; Ft_k</strong>, where each <strong>Ft_i</strong> is a
possibly constrained function type with an argument sequence of the
same length <strong>Arity</strong>, then Rep(F) =
<strong>{attribute,Line,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}</strong>.</p> </li><li> <p>If F is a record declaration <strong>-record(Name,{V_1, ..., V_k})</strong>,
where each <strong>V_i</strong> is a record field, then Rep(F) =
<strong>{attribute,LINE,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}</strong>.
For Rep(V), see below.</p> </li><li> <p>If F is a type declaration <strong>-Type Name(V_1, ..., V_k) :: T</strong>,
where <strong>Type</strong> is either the atom <strong>type</strong> or the atom
<strong>opaque</strong>, each <strong>V_i</strong> is a variable, and <strong>T</strong> is a type,
then Rep(F) =
<strong>{attribute,LINE,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}</strong>.</p> </li><li> <p>If F is a wild attribute <strong>-A(T)</strong>, then
Rep(F) = <strong>{attribute,LINE,A,T}</strong>.</p> </li></ul><h4>Record Fields</h4><p>Each field in a record declaration can have an optional,
explicit, default initializer expression, and an
optional type.</p><ul><li> <p>If V is <strong>A</strong>, then
Rep(V) = <strong>{record_field,LINE,Rep(A)}</strong>.</p> </li><li> <p>If V is <strong>A = E</strong>, where <strong>E</strong> is an expression, then
Rep(V) = <strong>{record_field,LINE,Rep(A),Rep(E)}</strong>.</p> </li><li> <p>If V is <strong>A :: T</strong>, where <strong>T</strong> is a type, then Rep(V) =
<strong>{typed_record_field,{record_field,LINE,Rep(A)},Rep(T)}</strong>.</p> </li><li> <p>If V is <strong>A = E :: T</strong>, where
<strong>E</strong> is an expression and <strong>T</strong> is a type, then Rep(V) =
<strong>{typed_record_field,{record_field,LINE,Rep(A),Rep(E)},Rep(T)}</strong>.
</p> </li></ul><h4>Representation of Parse Errors and End-of-File</h4><p>In addition to the representations of forms, the list that represents
a module declaration (as returned by functions in
<a href="./epp">stdlib/epp</a> and
<a href="./erl_parse">stdlib/erl_parse</a>)
can contain the following:</p><ul><li> <p>Tuples <strong>{error,E}</strong> and <strong>{warning,W}</strong>, denoting
syntactically incorrect forms and warnings.
</p> </li><li> <p><strong>{eof,LOCATION}</strong>, denoting an end-of-stream
encountered before a complete form had been parsed.
The word <strong>LOCATION</strong> represents an integer, and denotes the
number of the last line in the source file.
</p> </li></ul><h4>Atomic Literals</h4><p>There are five kinds of atomic literals, which are represented in the
same way in patterns, expressions, and guards:</p><ul><li> <p>If L is an atom literal, then Rep(L) = <strong>{atom,LINE,L}</strong>.</p> </li><li> <p>If L is a character literal, then Rep(L) = <strong>{char,LINE,L}</strong>.</p> </li><li> <p>If L is a float literal, then Rep(L) = <strong>{float,LINE,L}</strong>.</p> </li><li> <p>If L is an integer literal, then
Rep(L) = <strong>{integer,LINE,L}</strong>.</p> </li><li> <p>If L is a string literal consisting of the characters
<strong>C_1</strong>, ..., <strong>C_k</strong>, then
Rep(L) = <strong>{string,LINE,[C_1, ..., C_k]}</strong>.</p> </li></ul><p>Notice that negative integer and float literals do not occur as such;
they are parsed as an application of the unary negation operator.</p><h4>Patterns</h4><p>If Ps is a sequence of patterns <strong>P_1, ..., P_k</strong>, then
Rep(Ps) = <strong>[Rep(P_1), ..., Rep(P_k)]</strong>. Such sequences occur as the
list of arguments to a function or fun.</p><p>Individual patterns are represented as follows:</p><ul><li> <p>If P is an atomic literal <strong>L</strong>, then Rep(P) = Rep(L).</p> </li><li> <p>If P is a bitstring pattern
<strong>&lt;&lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&gt;&gt;</strong>, where each
<strong>Size_i</strong> is an expression that can be evaluated to an integer,
and each <strong>TSL_i</strong> is a type specificer list, then Rep(P) =
<strong>{bin,LINE,[{bin_element,LINE,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}</strong>.
For Rep(TSL), see below.
An omitted <strong>Size_i</strong> is represented by <strong>default</strong>.
An omitted <strong>TSL_i</strong> is represented by <strong>default</strong>.</p> </li><li> <p>If P is a compound pattern <strong>P_1 = P_2</strong>, then Rep(P) =
<strong>{match,LINE,Rep(P_1),Rep(P_2)}</strong>.</p> </li><li> <p>If P is a cons pattern <strong>[P_h | P_t]</strong>, then Rep(P) =
<strong>{cons,LINE,Rep(P_h),Rep(P_t)}</strong>.</p> </li><li> <p>If P is a map pattern <strong>#{A_1, ..., A_k}</strong>, where each
<strong>A_i</strong> is an association <strong>P_i_1 := P_i_2</strong>, then Rep(P) =
<strong>{map,LINE,[Rep(A_1), ..., Rep(A_k)]}</strong>.
For Rep(A), see below.</p> </li><li> <p>If P is a nil pattern <strong>[]</strong>, then Rep(P) =
<strong>{nil,LINE}</strong>.</p> </li><li> <p>If P is an operator pattern <strong>P_1 Op P_2</strong>, where <strong>Op</strong> is a
binary operator (this is either an occurrence of <strong>++</strong> applied to
a literal string or character list, or an occurrence of an expression
that can be evaluated to a number at compile time), then Rep(P) =
<strong>{op,LINE,Op,Rep(P_1),Rep(P_2)}</strong>.</p> </li><li> <p>If P is an operator pattern <strong>Op P_0</strong>, where <strong>Op</strong> is a
unary operator (this is an occurrence of an expression that can be
evaluated to a number at compile time), then Rep(P) =
<strong>{op,LINE,Op,Rep(P_0)}</strong>.</p> </li><li> <p>If P is a parenthesized pattern <strong>( P_0 )</strong>, then Rep(P) =
<strong>Rep(P_0)</strong>, that is, parenthesized patterns cannot be
distinguished from their bodies.</p> </li><li> <p>If P is a record field index pattern <strong>#Name.Field</strong>,
where <strong>Field</strong> is an atom, then Rep(P) =
<strong>{record_index,LINE,Name,Rep(Field)}</strong>.</p> </li><li> <p>If P is a record pattern <strong>#Name{Field_1=P_1, ..., Field_k=P_k}</strong>,
where each <strong>Field_i</strong> is an atom or <strong>_</strong>, then Rep(P) =
<strong>{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(P_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(P_k)}]}</strong>.</p> </li><li> <p>If P is a tuple pattern <strong>{P_1, ..., P_k}</strong>, then Rep(P) =
<strong>{tuple,LINE,[Rep(P_1), ..., Rep(P_k)]}</strong>.</p> </li><li> <p>If P is a universal pattern <strong>_</strong>, then Rep(P) =
<strong>{var,LINE,'_'}</strong>.</p></li><li> <p>If P is a variable pattern <strong>V</strong>, then Rep(P) =
<strong>{var,LINE,A}</strong>, where A is an atom with a printname consisting
of the same characters as <strong>V</strong>.</p> </li></ul><p>Notice that every pattern has the same source form as some expression,
and is represented in the same way as the corresponding expression.</p><h4>Expressions</h4><p>A body B is a non-empty sequence of expressions <strong>E_1, ..., E_k</strong>,
and Rep(B) = <strong>[Rep(E_1), ..., Rep(E_k)]</strong>.</p><p>An expression E is one of the following:</p><ul><li> <p>If E is an atomic literal <strong>L</strong>, then Rep(E) = Rep(L).</p> </li><li> <p>If E is a bitstring comprehension
<strong>&lt;&lt;E_0 || Q_1, ..., Q_k&gt;&gt;</strong>,
where each <strong>Q_i</strong> is a qualifier, then Rep(E) =
<strong>{bc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}</strong>.
For Rep(Q), see below.</p> </li><li> <p>If E is a bitstring constructor
<strong>&lt;&lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&gt;&gt;</strong>,
where each <strong>Size_i</strong> is an expression and each
<strong>TSL_i</strong> is a type specificer list, then Rep(E) =
<strong>{bin,LINE,[{bin_element,LINE,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}</strong>.
For Rep(TSL), see below.
An omitted <strong>Size_i</strong> is represented by <strong>default</strong>.
An omitted <strong>TSL_i</strong> is represented by <strong>default</strong>.</p> </li><li> <p>If E is a block expression <strong>begin B end</strong>,
where <strong>B</strong> is a body, then Rep(E) =
<strong>{block,LINE,Rep(B)}</strong>.</p> </li><li> <p>If E is a case expression <strong>case E_0 of Cc_1 ; ... ; Cc_k end</strong>,
where <strong>E_0</strong> is an expression and each <strong>Cc_i</strong> is a
case clause, then Rep(E) =
<strong>{'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}</strong>.</p> </li><li> <p>If E is a catch expression <strong>catch E_0</strong>, then Rep(E) =
<strong>{'catch',LINE,Rep(E_0)}</strong>.</p> </li><li> <p>If E is a cons skeleton <strong>[E_h | E_t]</strong>, then Rep(E) =
<strong>{cons,LINE,Rep(E_h),Rep(E_t)}</strong>.</p> </li><li> <p>If E is a fun expression <strong>fun Name/Arity</strong>, then Rep(E) =
<strong>{'fun',LINE,{function,Name,Arity}}</strong>.</p> </li><li> <p>If E is a fun expression <strong>fun Module:Name/Arity</strong>, then Rep(E) =
<strong>{'fun',LINE,{function,Rep(Module),Rep(Name),Rep(Arity)}}</strong>.
(Before Erlang/OTP R15: Rep(E) =
<strong>{'fun',LINE,{function,Module,Name,Arity}}</strong>.)</p> </li><li> <p>If E is a fun expression <strong>fun Fc_1 ; ... ; Fc_k end</strong>,
where each <strong>Fc_i</strong> is a function clause, then Rep(E) =
<strong>{'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}</strong>.</p> </li><li> <p>If E is a fun expression <strong>fun Name Fc_1 ; ... ; Name Fc_k end</strong>,
where <strong>Name</strong> is a variable and each
<strong>Fc_i</strong> is a function clause, then Rep(E) =
<strong>{named_fun,LINE,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}</strong>.</p> </li><li> <p>If E is a function call <strong>E_0(E_1, ..., E_k)</strong>, then Rep(E) =
<strong>{call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}</strong>.</p> </li><li> <p>If E is a function call <strong>E_m:E_0(E_1, ..., E_k)</strong>, then Rep(E) =
<strong>{call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}</strong>.</p> </li><li> <p>If E is an if expression <strong>if Ic_1 ; ... ; Ic_k  end</strong>,
where each <strong>Ic_i</strong> is an if clause, then Rep(E) =
<strong>{'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}</strong>.</p> </li><li> <p>If E is a list comprehension <strong>[E_0 || Q_1, ..., Q_k]</strong>,
where each <strong>Q_i</strong> is a qualifier, then Rep(E) =
<strong>{lc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}</strong>.
For Rep(Q), see below.</p> </li><li> <p>If E is a map creation <strong>#{A_1, ..., A_k}</strong>,
where each <strong>A_i</strong> is an association <strong>E_i_1 =&gt; E_i_2</strong>,
then Rep(E) = <strong>{map,LINE,[Rep(A_1), ..., Rep(A_k)]}</strong>.
For Rep(A), see below.</p> </li><li> <p>If E is a map update <strong>E_0#{A_1, ..., A_k}</strong>,
where each <strong>A_i</strong> is an association <strong>E_i_1 =&gt; E_i_2</strong>
or <strong>E_i_1 := E_i_2</strong>, then Rep(E) =
<strong>{map,LINE,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}</strong>.
For Rep(A), see below.</p> </li><li> <p>If E is a match operator expression <strong>P = E_0</strong>,
where <strong>P</strong> is a pattern, then Rep(E) =
<strong>{match,LINE,Rep(P),Rep(E_0)}</strong>.</p> </li><li> <p>If E is nil, <strong>[]</strong>, then Rep(E) = <strong>{nil,LINE}</strong>.</p> </li><li> <p>If E is an operator expression <strong>E_1 Op E_2</strong>,
where <strong>Op</strong> is a binary operator other than match operator
<strong>=</strong>, then Rep(E) =
<strong>{op,LINE,Op,Rep(E_1),Rep(E_2)}</strong>.</p> </li><li> <p>If E is an operator expression <strong>Op E_0</strong>,
where <strong>Op</strong> is a unary operator, then Rep(E) =
<strong>{op,LINE,Op,Rep(E_0)}</strong>.</p> </li><li> <p>If E is a parenthesized expression <strong>( E_0 )</strong>, then Rep(E) =
<strong>Rep(E_0)</strong>, that is, parenthesized expressions cannot be
distinguished from their bodies.</p> </li><li> <p>If E is a receive expression <strong>receive Cc_1 ; ... ; Cc_k end</strong>,
where each <strong>Cc_i</strong> is a case clause, then Rep(E) =
<strong>{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)]}</strong>.</p> </li><li> <p>If E is a receive expression
<strong>receive Cc_1 ; ... ; Cc_k after E_0 -&gt; B_t end</strong>,
where each <strong>Cc_i</strong> is a case clause, <strong>E_0</strong> is an expression,
and <strong>B_t</strong> is a body, then Rep(E) =
<strong>{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}</strong>.</p> </li><li> <p>If E is a record creation
<strong>#Name{Field_1=E_1, ..., Field_k=E_k}</strong>,
where each <strong>Field_i</strong> is an atom or <strong>_</strong>, then Rep(E) =
<strong>{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}</strong>.</p> </li><li> <p>If E is a record field access <strong>E_0#Name.Field</strong>,
where <strong>Field</strong> is an atom, then Rep(E) =
<strong>{record_field,LINE,Rep(E_0),Name,Rep(Field)}</strong>.</p> </li><li> <p>If E is a record field index <strong>#Name.Field</strong>,
where <strong>Field</strong> is an atom, then Rep(E) =
<strong>{record_index,LINE,Name,Rep(Field)}</strong>.</p></li><li> <p>If E is a record update
<strong>E_0#Name{Field_1=E_1, ..., Field_k=E_k}</strong>,
where each <strong>Field_i</strong> is an atom, then Rep(E) =
<strong>{record,LINE,Rep(E_0),Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}</strong>.</p> </li><li> <p>If E is a tuple skeleton <strong>{E_1, ..., E_k}</strong>, then Rep(E) =
<strong>{tuple,LINE,[Rep(E_1), ..., Rep(E_k)]}</strong>.</p> </li><li> <p>If E is a try expression <strong>try B catch Tc_1 ; ... ; Tc_k end</strong>,
where <strong>B</strong> is a body and each <strong>Tc_i</strong> is a catch clause,
then Rep(E) =
<strong>{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}</strong>.</p> </li><li> <p>If E is a try expression
<strong>try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end</strong>,
where <strong>B</strong> is a body, each <strong>Cc_i</strong> is a case clause, and
each <strong>Tc_j</strong> is a catch clause, then Rep(E) =
<strong>{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}</strong>.</p> </li><li> <p>If E is a try expression <strong>try B after A end</strong>,
where <strong>B</strong> and <strong>A</strong> are bodies, then Rep(E) =
<strong>{'try',LINE,Rep(B),[],[],Rep(A)}</strong>.</p> </li><li> <p>If E is a try expression
<strong>try B of Cc_1 ; ... ; Cc_k after A end</strong>,
where <strong>B</strong> and <strong>A</strong> are a bodies,
and each <strong>Cc_i</strong> is a case clause, then Rep(E) =
<strong>{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}</strong>.</p> </li><li> <p>If E is a try expression
<strong>try B catch Tc_1 ; ... ; Tc_k after A end</strong>,
where <strong>B</strong> and <strong>A</strong> are bodies,
and each <strong>Tc_i</strong> is a catch clause, then Rep(E) =
<strong>{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}</strong>.</p> </li><li> <p>If E is a try expression
<strong>try B of Cc_1 ; ... ; Cc_k  catch Tc_1 ; ... ; Tc_n after A end</strong>, where <strong>B</strong> and <strong>A</strong> are a bodies,
each <strong>Cc_i</strong> is a case clause,
and each <strong>Tc_j</strong> is a catch clause, then Rep(E) =
<strong>{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}</strong>.</p> </li><li> <p>If E is a variable <strong>V</strong>, then Rep(E) = <strong>{var,LINE,A}</strong>,
where <strong>A</strong> is an atom with a printname consisting of the same
characters as <strong>V</strong>.</p> </li></ul><h4>Qualifiers</h4><p>A qualifier Q is one of the following:</p><ul><li> <p>If Q is a filter <strong>E</strong>, where <strong>E</strong> is an expression, then
Rep(Q) = <strong>Rep(E)</strong>.</p> </li><li> <p>If Q is a generator <strong>P &lt;- E</strong>, where <strong>P</strong> is
a pattern and <strong>E</strong> is an expression, then Rep(Q) =
<strong>{generate,LINE,Rep(P),Rep(E)}</strong>.</p> </li><li> <p>If Q is a bitstring generator <strong>P &lt;= E</strong>, where <strong>P</strong> is
a pattern and <strong>E</strong> is an expression, then Rep(Q) =
<strong>{b_generate,LINE,Rep(P),Rep(E)}</strong>.</p> </li></ul><h4>Bitstring Element Type Specifiers</h4><p>A type specifier list TSL for a bitstring element is a sequence
of type specifiers <strong>TS_1 - ... - TS_k</strong>, and
Rep(TSL) = <strong>[Rep(TS_1), ..., Rep(TS_k)]</strong>.</p><ul><li> <p>If TS is a type specifier <strong>A</strong>, where <strong>A</strong> is an atom,
then Rep(TS) = <strong>A</strong>.</p> </li><li> <p>If TS is a type specifier <strong>A:Value</strong>,
where <strong>A</strong> is an atom and <strong>Value</strong> is an integer,
then Rep(TS) = <strong>{A,Value}</strong>.</p> </li></ul><h4>Associations</h4><p>An association A is one of the following:</p><ul><li> <p>If A is an association <strong>K =&gt; V</strong>,
then Rep(A) = <strong>{map_field_assoc,LINE,Rep(K),Rep(V)}</strong>.</p> </li><li> <p>If A is an association <strong>K := V</strong>,
then Rep(A) = <strong>{map_field_exact,LINE,Rep(K),Rep(V)}</strong>.</p> </li></ul><h4>Clauses</h4><p>There are function clauses, if clauses, case clauses,
and catch clauses.</p><p>A clause C is one of the following:</p><ul><li> <p>If C is a case clause <strong>P -&gt; B</strong>,
where <strong>P</strong> is a pattern and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,[Rep(P)],[],Rep(B)}</strong>.</p> </li><li> <p>If C is a case clause <strong>P when Gs -&gt; B</strong>,
where <strong>P</strong> is a pattern,
<strong>Gs</strong> is a guard sequence, and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,[Rep(P)],Rep(Gs),Rep(B)}</strong>.</p> </li><li> <p>If C is a catch clause <strong>P -&gt; B</strong>,
where <strong>P</strong> is a pattern and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,[Rep({throw,P,_})],[],Rep(B)}</strong>,
that is, a catch clause with an explicit exception class
<strong>throw</strong> and with or without an explicit stacktrace
variable <strong>_</strong> cannot be distinguished from a catch clause
without an explicit exception class and without an explicit
stacktrace variable.</p> </li><li> <p>If C is a catch clause <strong>X : P -&gt; B</strong>,
where <strong>X</strong> is an atomic literal or a variable pattern,
<strong>P</strong> is a pattern, and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,[Rep({X,P,_})],[],Rep(B)}</strong>,
that is, a catch clause with an explicit exception class and
with an explicit stacktrace variable <strong>_</strong> cannot be
distinguished from a catch clause with an explicit exception
class and without an explicit stacktrace variable.</p> </li><li> <p>If C is a catch clause <strong>X : P : S -&gt; B</strong>,
where <strong>X</strong> is an atomic literal or a variable pattern,
<strong>P</strong> is a pattern, <strong>S</strong> is a variable, and <strong>B</strong>
is a body, then
Rep(C) = <strong>{clause,LINE,[Rep({X,P,S})],[],Rep(B)}</strong>.</p> </li><li> <p>If C is a catch clause <strong>P when Gs -&gt; B</strong>,
where <strong>P</strong> is a pattern, <strong>Gs</strong> is a guard sequence,
and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,[Rep({throw,P,_})],Rep(Gs),Rep(B)}</strong>,
that is, a catch clause with an explicit exception class
<strong>throw</strong> and with or without an explicit stacktrace
variable <strong>_</strong> cannot be distinguished from a catch clause
without an explicit exception class and without an explicit
stacktrace variable.</p> </li><li> <p>If C is a catch clause <strong>X : P when Gs -&gt; B</strong>,
where <strong>X</strong> is an atomic literal or a variable pattern,
<strong>P</strong> is a pattern, <strong>Gs</strong> is a guard sequence,
and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,[Rep({X,P,_})],Rep(Gs),Rep(B)}</strong>,
that is, a catch clause with an explicit exception class and
with an explicit stacktrace variable <strong>_</strong> cannot be
distinguished from a catch clause with an explicit exception
class and without an explicit stacktrace variable.</p> </li><li> <p>If C is a catch clause <strong>X : P : S when Gs -&gt; B</strong>,
where <strong>X</strong> is an atomic literal or a variable pattern,
<strong>P</strong> is a pattern, <strong>Gs</strong> is a guard sequence,
<strong>S</strong> is a variable, and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,[Rep({X,P,S})],Rep(Gs),Rep(B)}</strong>.</p> </li><li> <p>If C is a function clause <strong>( Ps ) -&gt; B</strong>,
where <strong>Ps</strong> is a pattern sequence and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,Rep(Ps),[],Rep(B)}</strong>.</p> </li><li> <p>If C is a function clause <strong>( Ps ) when Gs -&gt; B</strong>,
where <strong>Ps</strong> is a pattern sequence,
<strong>Gs</strong> is a guard sequence and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,Rep(Ps),Rep(Gs),Rep(B)}</strong>.</p> </li><li> <p>If C is an if clause <strong>Gs -&gt; B</strong>,
where <strong>Gs</strong> is a guard sequence and <strong>B</strong> is a body, then
Rep(C) = <strong>{clause,LINE,[],Rep(Gs),Rep(B)}</strong>.</p> </li></ul><h4>Guards</h4><p>A guard sequence Gs is a sequence of guards <strong>G_1; ...; G_k</strong>, and
Rep(Gs) = <strong>[Rep(G_1), ..., Rep(G_k)]</strong>. If the guard sequence is
empty, then Rep(Gs) = <strong>[]</strong>.</p><p>A guard G is a non-empty sequence of guard tests
<strong>Gt_1, ..., Gt_k</strong>, and Rep(G) =
<strong>[Rep(Gt_1), ..., Rep(Gt_k)]</strong>.</p><p>A guard test Gt is one of the following:</p><ul><li> <p>If Gt is an atomic literal <strong>L</strong>, then Rep(Gt) = Rep(L).</p> </li><li> <p>If Gt is a bitstring constructor
<strong>&lt;&lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&gt;&gt;</strong>,
where each <strong>Size_i</strong> is a guard test and each
<strong>TSL_i</strong> is a type specificer list, then Rep(Gt) =
<strong>{bin,LINE,[{bin_element,LINE,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}</strong>.
For Rep(TSL), see above.
An omitted <strong>Size_i</strong> is represented by <strong>default</strong>.
An omitted <strong>TSL_i</strong> is represented by <strong>default</strong>.</p> </li><li> <p>If Gt is a cons skeleton <strong>[Gt_h | Gt_t]</strong>, then Rep(Gt) =
<strong>{cons,LINE,Rep(Gt_h),Rep(Gt_t)}</strong>.</p> </li><li> <p>If Gt is a function call <strong>A(Gt_1, ..., Gt_k)</strong>,
where <strong>A</strong> is an atom, then Rep(Gt) =
<strong>{call,LINE,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}</strong>.</p> </li><li> <p>If Gt is a function call <strong>A_m:A(Gt_1, ..., Gt_k)</strong>,
where <strong>A_m</strong> is the atom <strong>erlang</strong> and <strong>A</strong> is
an atom or an operator, then Rep(Gt) =
<strong>{call,LINE,{remote,LINE,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}</strong>.</p> </li><li> <p>If Gt is a map creation <strong>#{A_1, ..., A_k}</strong>,
where each <strong>A_i</strong> is an association <strong>Gt_i_1 =&gt; Gt_i_2</strong>,
then Rep(Gt) = <strong>{map,LINE,[Rep(A_1), ..., Rep(A_k)]}</strong>.
For Rep(A), see above.</p> </li><li> <p>If Gt is a map update <strong>Gt_0#{A_1, ..., A_k}</strong>,
where each <strong>A_i</strong> is an association <strong>Gt_i_1 =&gt; Gt_i_2</strong>
or <strong>Gt_i_1 := Gt_i_2</strong>, then Rep(Gt) =
<strong>{map,LINE,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}</strong>.
For Rep(A), see above.</p> </li><li> <p>If Gt is nil, <strong>[]</strong>, then Rep(Gt) = <strong>{nil,LINE}</strong>.</p> </li><li> <p>If Gt is an operator guard test <strong>Gt_1 Op Gt_2</strong>,
where <strong>Op</strong> is a binary operator other than match
operator <strong>=</strong>, then Rep(Gt) =
<strong>{op,LINE,Op,Rep(Gt_1),Rep(Gt_2)}</strong>.</p> </li><li> <p>If Gt is an operator guard test <strong>Op Gt_0</strong>,
where <strong>Op</strong> is a unary operator, then Rep(Gt) =
<strong>{op,LINE,Op,Rep(Gt_0)}</strong>.</p> </li><li> <p>If Gt is a parenthesized guard test <strong>( Gt_0 )</strong>, then Rep(Gt) =
<strong>Rep(Gt_0)</strong>, that is, parenthesized
guard tests cannot be distinguished from their bodies.</p> </li><li> <p>If Gt is a record creation
<strong>#Name{Field_1=Gt_1, ..., Field_k=Gt_k}</strong>,
where each <strong>Field_i</strong> is an atom or <strong>_</strong>, then Rep(Gt) =
<strong>{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(Gt_k)}]}</strong>.</p> </li><li> <p>If Gt is  a record field access <strong>Gt_0#Name.Field</strong>,
where <strong>Field</strong> is an atom, then Rep(Gt) =
<strong>{record_field,LINE,Rep(Gt_0),Name,Rep(Field)}</strong>.</p> </li><li> <p>If Gt is a record field index <strong>#Name.Field</strong>,
where <strong>Field</strong> is an atom, then Rep(Gt) =
<strong>{record_index,LINE,Name,Rep(Field)}</strong>.</p> </li><li> <p>If Gt is a tuple skeleton <strong>{Gt_1, ..., Gt_k}</strong>, then Rep(Gt) =
<strong>{tuple,LINE,[Rep(Gt_1), ..., Rep(Gt_k)]}</strong>.</p> </li><li> <p>If Gt is a variable pattern <strong>V</strong>, then Rep(Gt) =
<strong>{var,LINE,A}</strong>, where A is an atom with
a printname consisting of the same characters as <strong>V</strong>.</p> </li></ul><p>Notice that every guard test has the same source form as some expression,
and is represented in the same way as the corresponding expression.</p><h4>Types</h4><ul><li> <p>If T is an annotated type <strong>A :: T_0</strong>,
where <strong>A</strong> is a variable, then Rep(T) =
<strong>{ann_type,LINE,[Rep(A),Rep(T_0)]}</strong>.</p> </li><li> <p>If T is an atom, a character, or an integer literal L,
then Rep(T) = Rep(L).</p> </li><li> <p>If T is a bitstring type <strong>&lt;&lt;_:M,_:_*N&gt;&gt;</strong>,
where <strong>M</strong> and <strong>N</strong> are singleton integer types, then Rep(T) =
<strong>{type,LINE,binary,[Rep(M),Rep(N)]}</strong>.</p> </li><li> <p>If T is the empty list type <strong>[]</strong>, then Rep(T) =
<strong>{type,Line,nil,[]}</strong>, that is, the empty list type
<strong>[]</strong> cannot be distinguished from the predefined type
<strong>nil()</strong>.</p> </li><li> <p>If T is a fun type <strong>fun()</strong>, then Rep(T) =
<strong>{type,LINE,'fun',[]}</strong>.</p> </li><li> <p>If T is a fun type <strong>fun((...) -&gt; T_0)</strong>, then Rep(T) =
<strong>{type,LINE,'fun',[{type,LINE,any},Rep(T_0)]}</strong>.</p> </li><li> <p>If T is a fun type <strong>fun(Ft)</strong>, where
<strong>Ft</strong> is a function type, then Rep(T) = <strong>Rep(Ft)</strong>.
For Rep(Ft), see below.</p> </li><li> <p>If T is an integer range type <strong>L .. H</strong>,
where <strong>L</strong> and <strong>H</strong> are singleton integer types, then Rep(T) =
<strong>{type,LINE,range,[Rep(L),Rep(H)]}</strong>.</p> </li><li> <p>If T is a map type <strong>map()</strong>, then Rep(T) =
<strong>{type,LINE,map,any}</strong>.</p> </li><li> <p>If T is a map type <strong>#{A_1, ..., A_k}</strong>, where each
<strong>A_i</strong> is an association type, then Rep(T) =
<strong>{type,LINE,map,[Rep(A_1), ..., Rep(A_k)]}</strong>.
For Rep(A), see below.</p> </li><li> <p>If T is an operator type <strong>T_1 Op T_2</strong>,
where <strong>Op</strong> is a binary operator (this is an occurrence of
an expression that can be evaluated to an integer at compile
time), then Rep(T) =
<strong>{op,LINE,Op,Rep(T_1),Rep(T_2)}</strong>.</p> </li><li> <p>If T is an operator type <strong>Op T_0</strong>, where <strong>Op</strong> is a
unary operator (this is an occurrence of an expression that can
be evaluated to an integer at compile time), then Rep(T) =
<strong>{op,LINE,Op,Rep(T_0)}</strong>.</p> </li><li> <p>If T is <strong>( T_0 )</strong>, then Rep(T) = <strong>Rep(T_0)</strong>, that is,
parenthesized types cannot be distinguished from their bodies.</p> </li><li> <p>If T is a predefined (or built-in) type <strong>N(T_1, ..., T_k)</strong>,
then Rep(T) = <strong>{type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}</strong>.</p> </li><li> <p>If T is a record type <strong>#Name{F_1, ..., F_k}</strong>,
where each <strong>F_i</strong> is a record field type, then Rep(T) =
<strong>{type,LINE,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}</strong>.
For Rep(F), see below.</p> </li><li> <p>If T is a remote type <strong>M:N(T_1, ..., T_k)</strong>, then Rep(T) =
<strong>{remote_type,LINE,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}</strong>.</p> </li><li> <p>If T is a tuple type <strong>tuple()</strong>, then Rep(T) =
<strong>{type,LINE,tuple,any}</strong>.</p> </li><li> <p>If T is a tuple type <strong>{T_1, ..., T_k}</strong>, then Rep(T) =
<strong>{type,LINE,tuple,[Rep(T_1), ..., Rep(T_k)]}</strong>.</p> </li><li> <p>If T is a type union <strong>T_1 | ... | T_k</strong>, then Rep(T) =
<strong>{type,LINE,union,[Rep(T_1), ..., Rep(T_k)]}</strong>.</p> </li><li> <p>If T is a type variable <strong>V</strong>, then Rep(T) =
<strong>{var,LINE,A}</strong>, where <strong>A</strong> is an atom with a printname
consisting of the same characters as <strong>V</strong>. A type variable
is any variable except underscore (<strong>_</strong>).</p> </li><li> <p>If T is a user-defined type <strong>N(T_1, ..., T_k)</strong>, then Rep(T) =
<strong>{user_type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}</strong>.</p> </li></ul><h4>Function Types</h4><p>A function type Ft is one of the following:</p><ul><li> <p>If Ft is a constrained function type <strong>Ft_1 when Fc</strong>,
where <strong>Ft_1</strong> is a function type and
<strong>Fc</strong> is a function constraint, then Rep(T) =
<strong>{type,LINE,bounded_fun,[Rep(Ft_1),Rep(Fc)]}</strong>.
For Rep(Fc), see below.</p> </li><li> <p>If Ft is a function type <strong>(T_1, ..., T_n) -&gt; T_0</strong>,
where each <strong>T_i</strong> is a type, then Rep(Ft) =
<strong>{type,LINE,'fun',[{type,LINE,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}</strong>.</p> </li></ul><h4>Function Constraints</h4><p>A function constraint Fc is a non-empty sequence of constraints
<strong>C_1, ..., C_k</strong>, and
Rep(Fc) = <strong>[Rep(C_1), ..., Rep(C_k)]</strong>.</p><ul><li>If C is a constraint <strong>V :: T</strong>, where <strong>V</strong> is a type variable and <strong>T</strong> is a type, then Rep(C) = <strong>{type,LINE,constraint,[{atom,LINE,is_subtype},[Rep(V),Rep(T)]]}</strong>. </li></ul><h4>Association Types</h4><ul><li> <p>If A is an association type <strong>K =&gt; V</strong>,
where <strong>K</strong> and <strong>V</strong> are types, then Rep(A) =
<strong>{type,LINE,map_field_assoc,[Rep(K),Rep(V)]}</strong>.</p> </li><li> <p>If A is an association type <strong>K := V</strong>,
where <strong>K</strong> and <strong>V</strong> are types, then Rep(A) =
<strong>{type,LINE,map_field_exact,[Rep(K),Rep(V)]}</strong>.</p> </li></ul><h4>Record Field Types</h4><ul><li>If F is a record field type <strong>Name :: Type</strong>, where <strong>Type</strong> is a type, then Rep(F) = <strong>{type,LINE,field_type,[Rep(Name),Rep(Type)]}</strong>. </li></ul><h4>The Abstract Format after Preprocessing</h4><p>The compilation option <strong>debug_info</strong> can be specified to the
compiler to have the abstract code stored in
the <strong>abstract_code</strong> chunk in the Beam file
(for debugging purposes).</p><p>As from Erlang/OTP R9C, the <strong>abstract_code</strong> chunk contains
<strong>{raw_abstract_v1,AbstractCode}</strong>, where <strong>AbstractCode</strong> is the
abstract code as described in this section.</p><p>In OTP releases before R9C, the abstract code after some more
processing was stored in the Beam file. The first element of the
tuple would be either <strong>abstract_v1</strong> (in OTP R7B) or
<strong>abstract_v2</strong> (in OTP R8B).</p><p><strong>tty</strong> is a simple command-line interface program where
keystrokes are collected and interpreted. Completed lines are sent to the
shell for interpretation. A simple history mechanism saves previous lines,
which can be edited before sending them to the shell. <strong>tty</strong>
is started when Erlang is started with the following command:</p><pre>
erl</pre><p><strong>tty</strong> operates in one of two modes:</p><ul><li> <p>Normal mode, in which text lines can be edited and sent to the
shell.</p> </li><li> <p>Shell break mode, which allows the user to kill the current shell,
start multiple shells, and so on.</p> </li></ul><h4>Normal Mode</h4><p>In normal mode keystrokes from the user are collected and interpreted by
<strong>tty</strong>. Most of the <em>Emacs</em> line-editing commands
are supported. The following is a complete list of the supported
line-editing commands.</p><p>Typographic conventions:</p><ul><li><strong>C-a</strong> means pressing the <em>Ctrl</em> key and the letter <strong>a</strong> simultaneously.</li><li><strong>M-f</strong> means pressing the <em>Esc</em> key and the letter <strong>f</strong> in sequence.</li><li><strong>Home</strong> and <strong>End</strong> represent the keys with the same name on the keyboard.</li><li><strong>Left</strong> and <strong>Right</strong> represent the corresponding arrow keys.</li></ul><table class="table table-bordered table-hover table-striped"><caption>tty Text Editing</caption><tbody><tr><td><em>Key Sequence</em></td><td><em>Function</em></td></tr><tr><td>Home</td><td>Beginning of line</td></tr><tr><td>C-a</td><td>Beginning of line</td></tr><tr><td>C-b</td><td>Backward character</td></tr><tr><td>C-Left</td><td>Backward word</td></tr><tr><td>M-b</td><td>Backward word</td></tr><tr><td>C-d</td><td>Delete character</td></tr><tr><td>M-d</td><td>Delete word</td></tr><tr><td>End</td><td>End of line</td></tr><tr><td>C-e</td><td>End of line</td></tr><tr><td>C-f</td><td>Forward character</td></tr><tr><td>C-Right</td><td>Forward word</td></tr><tr><td>M-f</td><td>Forward word</td></tr><tr><td>C-g</td><td>Enter shell break mode</td></tr><tr><td>C-k</td><td>Kill line</td></tr><tr><td>C-u</td><td>Backward kill line</td></tr><tr><td>C-l</td><td>Redraw line</td></tr><tr><td>C-n</td><td>Fetch next line from the history buffer</td></tr><tr><td>C-p</td><td>Fetch previous line from the history buffer</td></tr><tr><td>C-t</td><td>Transpose characters</td></tr><tr><td>C-w</td><td>Backward kill word</td></tr><tr><td>C-y</td><td>Insert previously killed text</td></tr><tr><td>C-]</td><td>Insert matching closing bracket</td></tr></tbody></table><h4>Shell Break Mode</h4><p>In this mode the following can be done:</p><ul><li>Kill or suspend the current shell</li><li>Connect to a suspended shell</li><li>Start a new shell</li></ul><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This section was written a long time ago. Most of it is still
valid, as it explains important concepts, but this was
written for an older driver interface so the examples do not
work anymore. The reader is encouraged to read the
<a href="erl_driver">erl_driver</a> and
<a href="driver_entry">driver_entry</a>
documentation also.</p></div><h4>Introduction</h4><p>This section describes how to build your own driver for Erlang.</p><p>A driver in Erlang is a library written in C, which is linked to
the Erlang emulator and called from Erlang. Drivers can be used
when C is more suitable than Erlang, to speed up things, or to
provide access to OS resources not directly accessible from Erlang.</p><p>A driver can be dynamically loaded, as a shared library (known as
a DLL on Windows), or statically loaded, linked with the emulator
when it is compiled and linked. Only dynamically loaded drivers
are described here, statically linked drivers are beyond the scope
of this section.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>When a driver is loaded it is executed in the context of the
emulator, shares the same memory and the same thread. This means
that all operations in the driver must be non-blocking, and that
any crash in the driver brings the whole emulator down. In short,
be careful.</p></div><h4>Sample Driver</h4><p>This section describes a simple driver for accessing a postgres
database using the libpq C client library. Postgres
is used because it is free and open source. For information on postgres,
see <a href="http://www.postgres.org">www.postgres.org</a>.</p><p>The driver is synchronous, it uses the synchronous calls of
the client library. This is only for simplicity, but not good, as it
halts the emulator while waiting for the database.
This is improved below with an asynchronous sample driver.</p><p>The code is straightforward: all
communication between Erlang and the driver
is done with <strong>port_control/3</strong>, and the
driver returns data back using the <strong>rbuf</strong>.</p><p>An Erlang driver only exports one function: the driver
entry function. This is defined with a macro,
<strong>DRIVER_INIT</strong>, which returns a pointer to a
C <strong>struct</strong> containing the entry points that are
called from the emulator. The <strong>struct</strong> defines the
entries that the emulator calls to call the driver, with
a <strong>NULL</strong> pointer for entries that are not defined
and used by the driver.</p><p>The <strong>start</strong> entry is called when the driver
is opened as a port with <strong>open_port/2</strong>. Here
we allocate memory for a user data structure.
This user data is passed every time the emulator
calls us. First we store the driver handle, as it
is needed in later calls. We allocate memory for
the connection handle that is used by LibPQ. We also
set the port to return allocated driver binaries, by
setting flag <strong>PORT_CONTROL_FLAG_BINARY</strong>, calling
<strong>set_port_control_flags</strong>. (This is because
we do not know if our data will fit in the
result buffer of <strong>control</strong>, which has a default size,
64 bytes, set up by the emulator.)</p><p>An entry <strong>init</strong> is called when
the driver is loaded. However, we do not use this, as
it is executed only once, and we want to have the
possibility of several instances of the driver.</p><p>The <strong>stop</strong> entry is called when the port
is closed.</p><p>The <strong>control</strong> entry is called from the emulator
when the Erlang code calls <strong>port_control/3</strong>,
to do the actual work. We have defined a simple set of
commands: <strong>connect</strong> to log in to the database,
<strong>disconnect</strong> to log out, and <strong>select</strong>
to send a SQL-query and get the result.
All results are returned through <strong>rbuf</strong>.
The library <strong>ei</strong> in <strong>erl_interface</strong> is
used to encode data in binary term format. The result is returned
to the emulator as binary terms, so <strong>binary_to_term</strong>
is called in Erlang to convert the result to term form.</p><p>The code is available in <strong>pg_sync.c</strong> in the
<strong>sample</strong> directory of <strong>erts</strong>.</p><p>The driver entry contains the functions that
will be called by the emulator. In this example,
only <strong>start</strong>, <strong>stop</strong>,
and <strong>control</strong> are provided:</p><pre><code class="">
/* Driver interface declarations */
static ErlDrvData start(ErlDrvPort port, char *command);
static void stop(ErlDrvData drv_data);
static int control(ErlDrvData drv_data, unsigned int command, char *buf, 
                   int len, char **rbuf, int rlen); 

static ErlDrvEntry pq_driver_entry = {
    NULL,                        /* init */
    start,
    stop,
    NULL,                        /* output */
    NULL,                        /* ready_input */
    NULL,                        /* ready_output */
    "pg_sync",                   /* the name of the driver */
    NULL,                        /* finish */
    NULL,                        /* handle */
    control,
    NULL,                        /* timeout */
    NULL,                        /* outputv */
    NULL,                        /* ready_async */
    NULL,                        /* flush */
    NULL,                        /* call */
    NULL                         /* event */
};
    </code></pre><p>We have a structure to store state needed by the driver,
in this case we only need to keep the database connection:</p><pre><code class="">
typedef struct our_data_s {
    PGconn* conn;
} our_data_t;
    </code></pre><p>The control codes that we have defined are as follows:</p><pre><code class="">
/* Keep the following definitions in alignment with the
 * defines in erl_pq_sync.erl
 */

#define DRV_CONNECT             'C'
#define DRV_DISCONNECT          'D'
#define DRV_SELECT              'S'
    </code></pre><p>This returns the driver structure. The macro
<strong>DRIVER_INIT</strong> defines the only exported function.
All the other functions are static, and will not be exported
from the library.</p><pre><code class="">
/* INITIALIZATION AFTER LOADING */

/* 
 * This is the init function called after this driver has been loaded.
 * It must *not* be declared static. Must return the address to 
 * the driver entry.
 */

DRIVER_INIT(pq_drv)
{
    return &amp;pq_driver_entry;
}
    </code></pre><p>Here some initialization is done, <strong>start</strong> is called from
<strong>open_port</strong>. The data will be passed to
<strong>control</strong> and <strong>stop</strong>.</p><pre><code class="">
/* DRIVER INTERFACE */
static ErlDrvData start(ErlDrvPort port, char *command)
{ 
    our_data_t* data;

    data = (our_data_t*)driver_alloc(sizeof(our_data_t));
    data-&gt;conn = NULL;
    set_port_control_flags(port, PORT_CONTROL_FLAG_BINARY);
    return (ErlDrvData)data;
}
    </code></pre><p>We call disconnect to log out from the database.
(This should have been done from Erlang, but just in case.)</p><pre><code class="">
static int do_disconnect(our_data_t* data, ei_x_buff* x);

static void stop(ErlDrvData drv_data)
{
    our_data_t* data = (our_data_t*)drv_data;

    do_disconnect(data, NULL);
    driver_free(data);
}
    </code></pre><p>We use the binary format only to return data to the emulator;
input data is a string parameter for <strong>connect</strong> and
<strong>select</strong>. The returned data consists of Erlang terms.</p><p>The functions <strong>get_s</strong> and
<strong>ei_x_to_new_binary</strong> are utilities that are used to
make the code shorter. <strong>get_s</strong>
duplicates the string and zero-terminates it, as the
postgres client library wants that. <strong>ei_x_to_new_binary</strong>
takes an <strong>ei_x_buff</strong> buffer, allocates a binary, and
copies the data there. This binary is returned in
<strong>*rbuf</strong>.
(Notice that this binary is freed by the emulator, not by us.)</p><pre><code class="">
static char* get_s(const char* buf, int len);
static int do_connect(const char *s, our_data_t* data, ei_x_buff* x);
static int do_select(const char* s, our_data_t* data, ei_x_buff* x);

/* As we are operating in binary mode, the return value from control
 * is irrelevant, as long as it is not negative.
 */
static int control(ErlDrvData drv_data, unsigned int command, char *buf, 
                   int len, char **rbuf, int rlen)
{
    int r;
    ei_x_buff x;
    our_data_t* data = (our_data_t*)drv_data;
    char* s = get_s(buf, len);
    ei_x_new_with_version(&amp;x);
    switch (command) {
        case DRV_CONNECT:    r = do_connect(s, data, &amp;x);  break;
        case DRV_DISCONNECT: r = do_disconnect(data, &amp;x);  break;
        case DRV_SELECT:     r = do_select(s, data, &amp;x);   break;
        default:             r = -1;        break;
    }
    *rbuf = (char*)ei_x_to_new_binary(&amp;x);
    ei_x_free(&amp;x);
    driver_free(s);
    return r;
}
    </code></pre><p><strong>do_connect</strong> is where we log in to the database. If the
connection was successful, we store the connection handle in the driver
data, and return <strong>'ok'</strong>. Otherwise, we return the error message
from postgres and store <strong>NULL</strong> in the driver data.</p><pre><code class="">
static int do_connect(const char *s, our_data_t* data, ei_x_buff* x)
{
    PGconn* conn = PQconnectdb(s);
    if (PQstatus(conn) != CONNECTION_OK) {
        encode_error(x, conn);
        PQfinish(conn);
        conn = NULL;
    } else {
        encode_ok(x);
    }
    data-&gt;conn = conn;
    return 0;
}
    </code></pre><p>If we are connected (and if the connection handle is not
<strong>NULL</strong>),
we log out from the database. We need to check if we should
encode an <strong>'ok'</strong>, as we can get here from function
<strong>stop</strong>, which does not return data to the emulator:</p><pre><code class="">
static int do_disconnect(our_data_t* data, ei_x_buff* x)
{
    if (data-&gt;conn == NULL)
        return 0;
    PQfinish(data-&gt;conn);
    data-&gt;conn = NULL;
    if (x != NULL)
        encode_ok(x);
    return 0;
}
    </code></pre><p>We execute a query and encode the result. Encoding is done in
another C module, <strong>pg_encode.c</strong>, which is also provided
as sample code.</p><pre><code class="">
static int do_select(const char* s, our_data_t* data, ei_x_buff* x)
{
   PGresult* res = PQexec(data-&gt;conn, s);
    encode_result(x, res, data-&gt;conn);
    PQclear(res);
    return 0;
}
    </code></pre><p>Here we check the result from postgres.
If it is data, we encode it as lists of lists with
column data. Everything from postgres is C strings,
so we use <strong>ei_x_encode_string</strong> to send
the result as strings to Erlang. (The head of the list
contains the column names.)</p><pre><code class="">
void encode_result(ei_x_buff* x, PGresult* res, PGconn* conn)
{
    int row, n_rows, col, n_cols;
    switch (PQresultStatus(res)) {
    case PGRES_TUPLES_OK: 
        n_rows = PQntuples(res); 
        n_cols = PQnfields(res); 
        ei_x_encode_tuple_header(x, 2);
        encode_ok(x);
        ei_x_encode_list_header(x, n_rows+1);
        ei_x_encode_list_header(x, n_cols);
        for (col = 0; col &lt; n_cols; ++col) {
            ei_x_encode_string(x, PQfname(res, col));
        }
        ei_x_encode_empty_list(x); 
        for (row = 0; row &lt; n_rows; ++row) {
            ei_x_encode_list_header(x, n_cols);
            for (col = 0; col &lt; n_cols; ++col) {
                ei_x_encode_string(x, PQgetvalue(res, row, col));
            }
            ei_x_encode_empty_list(x);
        }
        ei_x_encode_empty_list(x); 
        break; 
    case PGRES_COMMAND_OK:
        ei_x_encode_tuple_header(x, 2);
        encode_ok(x);
        ei_x_encode_string(x, PQcmdTuples(res));
        break;
    default:
        encode_error(x, conn);
        break;
    }
}
    </code></pre><h4>Compiling and Linking the Sample Driver</h4><p>The driver is to be compiled and linked to a shared
library (DLL on Windows). With gcc, this is done with
link flags <strong>-shared</strong> and <strong>-fpic</strong>.
As we use the <strong>ei</strong> library, we should include
it too. There are several versions of <strong>ei</strong>, compiled
for debug or non-debug and multi-threaded or single-threaded.
In the makefile for the samples, the <strong>obj</strong> directory
is used for the <strong>ei</strong> library, meaning that we use
the non-debug, single-threaded version.</p><h4>Calling a Driver as a Port in Erlang</h4><p>Before a driver can be called from Erlang, it must be
loaded and opened. Loading is done using the <strong>erl_ddll</strong>
module (the <strong>erl_ddll</strong> driver that loads dynamic
driver is actually a driver itself). If loading is successfull,
the port can be opened with <strong>open_port/2</strong>. The port
name must match the name of the shared library and
the name in the driver entry structure.</p><p>When the port has been opened, the driver can be called. In
the <strong>pg_sync</strong> example, we do not have any data from
the port, only the return value from the
<strong>port_control</strong>.</p><p>The following code is the Erlang part of the synchronous
postgres driver, <strong>pg_sync.erl</strong>:</p><pre><code class="">
-module(pg_sync).

-define(DRV_CONNECT, 1).
-define(DRV_DISCONNECT, 2).
-define(DRV_SELECT, 3).

-export([connect/1, disconnect/1, select/2]).

connect(ConnectStr) -&gt;
    case erl_ddll:load_driver(".", "pg_sync") of
        ok -&gt; ok;
        {error, already_loaded} -&gt; ok;
        E -&gt; exit({error, E})
    end,
    Port = open_port({spawn, ?MODULE}, []),
    case binary_to_term(port_control(Port, ?DRV_CONNECT, ConnectStr)) of
        ok -&gt; {ok, Port};
        Error -&gt; Error
    end.

disconnect(Port) -&gt;
    R = binary_to_term(port_control(Port, ?DRV_DISCONNECT, "")),
    port_close(Port),
    R.

select(Port, Query) -&gt;
    binary_to_term(port_control(Port, ?DRV_SELECT, Query)).
    </code></pre><p>The API is simple:</p><ul><li> <p><strong>connect/1</strong> loads the driver, opens it,
and logs on to the database, returning the Erlang port
if successful.</p> </li><li> <p><strong>select/2</strong> sends a query to the driver
and returns the result.</p> </li><li> <p><strong>disconnect/1</strong> closes the database
connection and the driver. (However, it does not unload it.)</p> </li></ul><p>The connection string is to be a connection string for postgres.</p><p>The driver is loaded with <strong>erl_ddll:load_driver/2</strong>.
If this is successful, or if it is already loaded,
it is opened. This will call the <strong>start</strong> function
in the driver.</p><p>We use the <strong>port_control/3</strong> function for all
calls into the driver. The result from the driver is
returned immediately and converted to terms by calling
<strong>binary_to_term/1</strong>. (We trust that the terms returned
from the driver are well-formed, otherwise the
<strong>binary_to_term</strong> calls could be contained in a
<strong>catch</strong>.)</p><h4>Sample Asynchronous Driver</h4><p>Sometimes database queries can take a long time to
complete, in our <strong>pg_sync</strong> driver, the emulator
halts while the driver is doing its job. This is
often not acceptable, as no other Erlang process
gets a chance to do anything. To improve on our
postgres driver, we re-implement it using the asynchronous
calls in LibPQ.</p><p>The asynchronous version of the driver is in the sample files
<strong>pg_async.c</strong> and <strong>pg_asyng.erl</strong>.</p><pre><code class="">
/* Driver interface declarations */
static ErlDrvData start(ErlDrvPort port, char *command);
static void stop(ErlDrvData drv_data);
static int control(ErlDrvData drv_data, unsigned int command, char *buf, 
                   int len, char **rbuf, int rlen); 
static void ready_io(ErlDrvData drv_data, ErlDrvEvent event);

static ErlDrvEntry pq_driver_entry = {
    NULL,                     /* init */
    start, 
    stop, 
    NULL,                     /* output */
    ready_io,                 /* ready_input */
    ready_io,                 /* ready_output */ 
    "pg_async",               /* the name of the driver */
    NULL,                     /* finish */
    NULL,                     /* handle */
    control, 
    NULL,                     /* timeout */
    NULL,                     /* outputv */
    NULL,                     /* ready_async */
    NULL,                     /* flush */
    NULL,                     /* call */
    NULL                      /* event */
};

typedef struct our_data_t {
    PGconn* conn;
    ErlDrvPort port;
    int socket;
    int connecting;
} our_data_t;
    </code></pre><p>Some things have changed from <strong>pg_sync.c</strong>: we use
the entry <strong>ready_io</strong> for <strong>ready_input</strong>
and <strong>ready_output</strong>, which is called from the emulator
only when there is input to be read from the socket. (Actually, the
socket is used in a <strong>select</strong> function inside
the emulator, and when the socket is signaled,
indicating there is data to read, the <strong>ready_input</strong>
entry is called. More about this below.)</p><p>Our driver data is also extended, we keep track of the
socket used for communication with postgres, and also
the port, which is needed when we send data to the port with
<strong>driver_output</strong>. We have a flag
<strong>connecting</strong> to tell
whether the driver is waiting for a connection or waiting
for the result of a query. (This is needed, as the entry
<strong>ready_io</strong> is called both when connecting and
when there is a query result.)</p><pre><code class="">
static int do_connect(const char *s, our_data_t* data)
{
    PGconn* conn = PQconnectStart(s);
    if (PQstatus(conn) == CONNECTION_BAD) {
        ei_x_buff x;
        ei_x_new_with_version(&amp;x);
        encode_error(&amp;x, conn);
        PQfinish(conn);
        conn = NULL;
        driver_output(data-&gt;port, x.buff, x.index);
        ei_x_free(&amp;x);
    }
    PQconnectPoll(conn);
    int socket = PQsocket(conn);
    data-&gt;socket = socket;
    driver_select(data-&gt;port, (ErlDrvEvent)socket, DO_READ, 1);
    driver_select(data-&gt;port, (ErlDrvEvent)socket, DO_WRITE, 1);
    data-&gt;conn = conn;
    data-&gt;connecting = 1;
    return 0;
}
    </code></pre><p>The <strong>connect</strong> function looks a bit different too. We
connect using the asynchronous <strong>PQconnectStart</strong> function.
After the connection is started, we retrieve the socket for the connection
with <strong>PQsocket</strong>. This socket is used with the
<strong>driver_select</strong> function to wait for connection. When
the socket is ready for input or for output, the
<strong>ready_io</strong> function is called.</p><p>Notice that we only return data (with <strong>driver_output</strong>)
if there
is an error here, otherwise we wait for the connection to be completed,
in which case our <strong>ready_io</strong> function is called.</p><pre><code class="">
static int do_select(const char* s, our_data_t* data)
{
    data-&gt;connecting = 0;
    PGconn* conn = data-&gt;conn;
    /* if there's an error return it now */
    if (PQsendQuery(conn, s) == 0) {
        ei_x_buff x;
        ei_x_new_with_version(&amp;x);
        encode_error(&amp;x, conn);
        driver_output(data-&gt;port, x.buff, x.index);
        ei_x_free(&amp;x);
    }
    /* else wait for ready_output to get results */
    return 0;
}
    </code></pre><p>The <strong>do_select</strong> function initiates a select, and returns
if there is no immediate error. The result is returned
when <strong>ready_io</strong> is called.</p><pre><code class="">
static void ready_io(ErlDrvData drv_data, ErlDrvEvent event)
{
    PGresult* res = NULL;
    our_data_t* data = (our_data_t*)drv_data;
    PGconn* conn = data-&gt;conn;
    ei_x_buff x;
    ei_x_new_with_version(&amp;x);
    if (data-&gt;connecting) {
        ConnStatusType status;
        PQconnectPoll(conn);
        status = PQstatus(conn);
        if (status == CONNECTION_OK)
            encode_ok(&amp;x);
        else if (status == CONNECTION_BAD)
            encode_error(&amp;x, conn);
    } else {
        PQconsumeInput(conn);
        if (PQisBusy(conn))
            return;
        res = PQgetResult(conn);
        encode_result(&amp;x, res, conn);
        PQclear(res);
        for (;;) {
            res = PQgetResult(conn);
            if (res == NULL)
                break;
            PQclear(res);
        }
    }
    if (x.index &gt; 1) {
        driver_output(data-&gt;port, x.buff, x.index);
        if (data-&gt;connecting) 
            driver_select(data-&gt;port, (ErlDrvEvent)data-&gt;socket, DO_WRITE, 0);
    }
    ei_x_free(&amp;x);
}
    </code></pre><p>The <strong>ready_io</strong> function is called when the socket
we got from postgres is ready for input or output. Here
we first check if we are connecting to the database. In that
case, we check connection status and return OK if the 
connection is successful, or error if it is not. If the
connection is not yet established, we simply return;
<strong>ready_io</strong> is called again.</p><p>If we have a result from a connect, indicated by having data in
the <strong>x</strong> buffer, we no longer need to select on
output (<strong>ready_output</strong>), so we remove this by calling
<strong>driver_select</strong>.</p><p>If we are not connecting, we wait for results from a
<strong>PQsendQuery</strong>, so we get the result and return it. The
encoding is done with the same functions as in the earlier
example.</p><p>Error handling is to be added here, for example, checking
that the socket is still open, but this is only a simple example.</p><p>The Erlang part of the asynchronous driver consists of the
sample file <strong>pg_async.erl</strong>.</p><pre><code class="">
-module(pg_async).

-define(DRV_CONNECT, $C).
-define(DRV_DISCONNECT, $D).
-define(DRV_SELECT, $S).

-export([connect/1, disconnect/1, select/2]).

connect(ConnectStr) -&gt;
    case erl_ddll:load_driver(".", "pg_async") of
        ok -&gt; ok;
        {error, already_loaded} -&gt; ok;
        _ -&gt; exit({error, could_not_load_driver})
    end,
    Port = open_port({spawn, ?MODULE}, [binary]),
    port_control(Port, ?DRV_CONNECT, ConnectStr),
    case return_port_data(Port) of
        ok -&gt; 
            {ok, Port};
        Error -&gt;
            Error
    end.    

disconnect(Port) -&gt;
    port_control(Port, ?DRV_DISCONNECT, ""),
    R = return_port_data(Port),
    port_close(Port),
    R.

select(Port, Query) -&gt;
    port_control(Port, ?DRV_SELECT, Query),
    return_port_data(Port).

return_port_data(Port) -&gt;
    receive
        {Port, {data, Data}} -&gt;
            binary_to_term(Data)
    end.
    </code></pre><p>The Erlang code is slightly different, as we do not
return the result synchronously from <strong>port_control</strong>,
instead we get it from <strong>driver_output</strong> as data in the
message queue. The function <strong>return_port_data</strong> above
receives data from the port. As the data is in
binary format, we use <strong>binary_to_term/1</strong> to convert
it to an Erlang term. Notice that the driver is opened in
binary mode (<strong>open_port/2</strong> is called with option
<strong>[binary]</strong>). This means that data sent from the driver
to the emulator is sent as binaries. Without option
<strong>binary</strong>, they would have been lists of integers.</p><h4>An Asynchronous Driver Using driver_async</h4><p>As a final example we demonstrate the use of
<strong>driver_async</strong>.
We also use the driver term interface. The driver is written
in C++. This enables us to use an algorithm from STL. We use
the <strong>next_permutation</strong> algorithm to get the next
permutation of a list of integers. For large lists (&gt; 100,000
elements), this takes some time, so we perform this
as an asynchronous task.</p><p>The asynchronous API for drivers is complicated. First,
the work must be prepared. In the example, this is done in
<strong>output</strong>. We could have used <strong>control</strong>,
but we want some variation in the examples. In our driver, we allocate
a structure that contains anything that is needed for the asynchronous
task to do the work. This is done in the main emulator thread.
Then the asynchronous function is called from a driver thread,
separate from the main emulator thread. Notice that the driver functions
are not re-entrant, so they are not to be used.
Finally, after the function is completed, the driver callback
<strong>ready_async</strong> is called from the main emulator thread,
this is where we return the result to Erlang. (We cannot
return the result from within the asynchronous function, as
we cannot call the driver functions.)</p><p>The following code is from the sample file
<strong>next_perm.cc</strong>. The driver entry looks like before,
but also contains the callback <strong>ready_async</strong>.</p><pre><code class="">
static ErlDrvEntry next_perm_driver_entry = {
    NULL,                        /* init */
    start,
    NULL,                        /* stop */
    output,
    NULL,                        /* ready_input */
    NULL,                        /* ready_output */ 
    "next_perm",                 /* the name of the driver */
    NULL,                        /* finish */
    NULL,                        /* handle */
    NULL,                        /* control */
    NULL,                        /* timeout */
    NULL,                        /* outputv */
    ready_async,
    NULL,                        /* flush */
    NULL,                        /* call */
    NULL                         /* event */
};
    </code></pre><p>The <strong>output</strong> function allocates the work area of the
asynchronous function. As we use C++, we use a struct,
and stuff the data in it. We must copy the original data,
it is not valid after we have returned from the <strong>output</strong>
function, and the <strong>do_perm</strong> function is called
later, and from another thread. We return no data here, instead it
is sent later from the <strong>ready_async</strong> callback.</p><p>The <strong>async_data</strong> is passed to the
<strong>do_perm</strong> function. We do not use a
<strong>async_free</strong> function (the last argument to
<strong>driver_async</strong>), it is only used if the task is cancelled
programmatically.</p><pre><code class="">
struct our_async_data {
    bool prev;
    vector&lt;int&gt; data;
    our_async_data(ErlDrvPort p, int command, const char* buf, int len);
};

our_async_data::our_async_data(ErlDrvPort p, int command,
                               const char* buf, int len)
    : prev(command == 2),
      data((int*)buf, (int*)buf + len / sizeof(int))
{
}

static void do_perm(void* async_data);

static void output(ErlDrvData drv_data, char *buf, int len)
{
    if (*buf &lt; 1 || *buf &gt; 2) return;
    ErlDrvPort port = reinterpret_cast&lt;ErlDrvPort&gt;(drv_data);
    void* async_data = new our_async_data(port, *buf, buf+1, len);
    driver_async(port, NULL, do_perm, async_data, do_free);
}
    </code></pre><p>In the <strong>do_perm</strong> we do the work, operating
on the structure that was allocated in <strong>output</strong>.</p><pre><code class="">
static void do_perm(void* async_data)
{
    our_async_data* d = reinterpret_cast&lt;our_async_data*&gt;(async_data);
    if (d-&gt;prev)
        prev_permutation(d-&gt;data.begin(), d-&gt;data.end());
    else
        next_permutation(d-&gt;data.begin(), d-&gt;data.end());
}
    </code></pre><p>In the <strong>ready_async</strong> function the output is sent back
to the
emulator. We use the driver term format instead of <strong>ei</strong>.
This is the only way to send Erlang terms directly to a driver, without
having the Erlang code to call <strong>binary_to_term/1</strong>. In
the simple example this works well, and we do not need to use
<strong>ei</strong> to handle the binary term format.</p><p>When the data is returned, we deallocate our data.</p><pre><code class="">
static void ready_async(ErlDrvData drv_data, ErlDrvThreadData async_data)
{
    ErlDrvPort port = reinterpret_cast&lt;ErlDrvPort&gt;(drv_data);
    our_async_data* d = reinterpret_cast&lt;our_async_data*&gt;(async_data);
    int n = d-&gt;data.size(), result_n = n*2 + 3;
    ErlDrvTermData *result = new ErlDrvTermData[result_n], *rp = result;
    for (vector&lt;int&gt;::iterator i = d-&gt;data.begin();
         i != d-&gt;data.end(); ++i) {
        *rp++ = ERL_DRV_INT;
        *rp++ = *i;
    }
    *rp++ = ERL_DRV_NIL;
    *rp++ = ERL_DRV_LIST;
    *rp++ = n+1;
    driver_output_term(port, result, result_n);    
    delete[] result;
    delete d;
}
    </code></pre><p>This driver is called like the others from Erlang. However, as
we use <strong>driver_output_term</strong>, there is no need to call
<strong>binary_to_term</strong>. The Erlang code is in the sample file
<strong>next_perm.erl</strong>.</p><p>The input is changed into a list of integers and sent to
the driver.</p><pre><code class="">
-module(next_perm).

-export([next_perm/1, prev_perm/1, load/0, all_perm/1]).

load() -&gt;
    case whereis(next_perm) of
        undefined -&gt;
            case erl_ddll:load_driver(".", "next_perm") of
                ok -&gt; ok;
                {error, already_loaded} -&gt; ok;
                E -&gt; exit(E)
            end,
            Port = open_port({spawn, "next_perm"}, []),
            register(next_perm, Port);
        _ -&gt;
            ok
    end.

list_to_integer_binaries(L) -&gt;
    [&lt;&lt;I:32/integer-native&gt;&gt; || I &lt;- L].

next_perm(L) -&gt;
    next_perm(L, 1).

prev_perm(L) -&gt;
    next_perm(L, 2).

next_perm(L, Nxt) -&gt;
    load(),
    B = list_to_integer_binaries(L),
    port_control(next_perm, Nxt, B),
    receive
        Result -&gt;
            Result
    end.

all_perm(L) -&gt;
    New = prev_perm(L),
    all_perm(New, L, [New]).

all_perm(L, L, Acc) -&gt;
    Acc;
all_perm(L, Orig, Acc) -&gt;
    New = prev_perm(L),
    all_perm(New, Orig, [New | Acc]).
    </code></pre><h4>Introduction</h4><p>This section describes how the Erlang runtime system is configured
for IP communication. It also explains how you can configure it
for your needs by a configuration file.
The information is primarily intended for users with special
configuration needs or problems. There is normally no need
for specific settings for Erlang to function properly on a correctly
IP-configured platform.</p><p>When Erlang starts up it reads the Kernel variable
<strong>inetrc</strong>, which, if defined, is to specify the location
and name of a user configuration file. Example:</p><pre><code class="">
% erl -kernel inetrc '"./cfg_files/erl_inetrc"'</code></pre><p>Notice that the use of an <strong>.inetrc</strong> file, which was
supported in earlier Erlang/OTP versions, is now obsolete.</p><p>A second way to specify the configuration file is to set
environment variable <strong>ERL_INETRC</strong> to the full name of
the file. Example (bash):</p><pre><code class="">
% export ERL_INETRC=./cfg_files/erl_inetrc</code></pre><p>Notice that the Kernel variable <strong>inetrc</strong>
overrides this environment variable.</p><p>If no user configuration file is specified and Erlang is started
in non-distributed or short name distributed mode, Erlang uses
default configuration settings and a native lookup method that
works correctly under most circumstances. Erlang reads no
information from system <strong>inet</strong> configuration files (such as 
<strong>/etc/host.conf</strong> and <strong>/etc/nsswitch.conf</strong>) in these modes,
except for <strong>/etc/resolv.conf</strong> and <strong>/etc/hosts</strong> that is read and
monitored for changes on Unix platforms for the internal DNS client
<a href="./inet_res">kernel/inet_res</a>.</p><p>If Erlang is started in long name distributed mode, it needs to
get the domain name from somewhere and reads system <strong>inet</strong>
configuration files for this information. Any hosts and resolver
information found is also recorded, but not
used as long as Erlang is configured for native lookups. The
information becomes useful if the lookup method is changed to 
<strong>'file'</strong> or <strong>'dns'</strong>, see below.</p><p>Native lookup (system calls) is always the default resolver method.
This is true for all platforms, except VxWorks and OSE Delta where
<strong>'file'</strong> or <strong>'dns'</strong> is used (in that
priority order).</p><p>On Windows platforms, Erlang searches the system registry rather than
looks for configuration files when started in long name distributed
mode.</p><h4>Configuration Data</h4><p>Erlang records the following data in a local database if found in system 
<strong>inet</strong> configuration files (or system registry):</p><ul><li>Hostnames and host addresses</li><li>Domain name</li><li>Nameservers</li><li>Search domains</li><li>Lookup method</li></ul><p>This data can also be specified explicitly in the user
configuration file. This file is to contain lines
of configuration parameters (each terminated with a full stop).
Some parameters add data to the configuration (such as host
and nameserver), others overwrite any previous settings
(such as domain and lookup). The user configuration file is always
examined last in the configuration process, making it possible
for the user to override any default values or previously made
settings. Call <strong>inet:get_rc()</strong> to view the state of the
<strong>inet</strong> configuration database.</p><p>The valid configuration parameters are as follows:</p><dl><dt><strong>{file, Format, File}.</strong></dt><dd> <p><strong>Format = atom()</strong></p> <p><strong>File = string()</strong></p> <p>Specify a system file that Erlang is to read configuration data from.
<strong>Format</strong> tells the parser how the file is to be
interpreted:</p> <ul><li><strong>resolv</strong> (Unix resolv.conf)</li><li><strong>host_conf_freebsd</strong> (FreeBSD host.conf)</li><li><strong>host_conf_bsdos</strong> (BSDOS host.conf)</li><li><strong>host_conf_linux</strong> (Linux host.conf)</li><li><strong>nsswitch_conf</strong> (Unix nsswitch.conf)</li><li><strong>hosts</strong> (Unix hosts)</li></ul> <p><strong>File</strong> is to specify the filename with full
path.</p> </dd><dt><strong>{resolv_conf, File}.</strong></dt><dd> <p><strong>File = string()</strong></p> <p>Specify a system file that Erlang is to read resolver
configuration from for the internal DNS client
<a href="./inet_res">kernel/inet_res</a>,
and monitor for changes, even if it does not exist.
The path must be absolute.</p> <p>This can override the configuration parameters
<strong>nameserver</strong> and
<strong>search</strong> depending on the contents
of the specified file. They can also change any time in the future
reflecting the file contents.</p> <p>If the file is specified as an empty string <strong>""</strong>,
no file is read or monitored in the future. This emulates
the old behavior of not configuring the DNS client when
the node is started in short name distributed mode.</p> <p>If this parameter is not specified, it defaults to
<strong>/etc/resolv.conf</strong> unless environment variable
<strong>ERL_INET_ETC_DIR</strong> is set, which defines
the directory for this file to some maybe other than
<strong>/etc</strong>.</p> </dd><dt><strong>{hosts_file, File}.</strong></dt><dd> <p><strong>File = string()</strong></p> <p>Specify a system file that Erlang is to read resolver
configuration from for the internal hosts file resolver,
and monitor for changes, even if it does not exist.
The path must be absolute.</p> <p>These host entries are searched after all added with
<strong>{file, hosts, File}</strong> above or
<strong>{host, IP, Aliases}</strong> below when lookup option
<strong>file</strong> is used.</p> <p>If the file is specified as an empty string <strong>""</strong>,
no file is read or monitored in the future. This emulates
the old behavior of not configuring the DNS client when
the node is started in short name distributed mode.</p> <p>If this parameter is not specified, it defaults to
<strong>/etc/hosts</strong> unless environment variable
<strong>ERL_INET_ETC_DIR</strong> is set, which defines
the directory for this file to some maybe other than
<strong>/etc</strong>.</p> </dd><dt><strong>{registry, Type}.</strong></dt><dd> <p><strong>Type = atom()</strong></p> <p>Specify a system registry that Erlang is to read configuration
data from. <strong>win32</strong> is the only valid option.</p> </dd><dt><strong>{host, IP, Aliases}.</strong></dt><dd> <p><strong>IP = tuple()</strong></p> <p><strong>Aliases = [string()]</strong></p> <p>Add host entry to the hosts table.</p> </dd><dt><strong>{domain, Domain}.</strong></dt><dd> <p><strong>Domain = string()</strong></p> <p>Set domain name.</p> </dd><dt><strong>{nameserver, IP [,Port]}.</strong></dt><dd> <p><strong>IP = tuple()</strong></p> <p><strong>Port = integer()</strong></p> <p>Add address (and port, if other than default) of the primary
nameserver to use for
<a href="./inet_res">kernel/inet_res</a>.
</p> </dd><dt><strong>{alt_nameserver, IP [,Port]}.</strong></dt><dd> <p><strong>IP = tuple()</strong></p> <p><strong>Port = integer()</strong></p> <p>Add address (and port, if other than default) of the secondary
nameserver for
<a href="./inet_res">kernel/inet_res</a>.
</p> </dd><dt><strong>{search, Domains}.</strong></dt><dd> <p><strong>Domains = [string()]</strong></p> <p>Add search domains for
<a href="./inet_res">kernel/inet_res</a>.
</p> </dd><dt><strong>{lookup, Methods}.</strong></dt><dd> <p><strong>Methods = [atom()]</strong></p> <p>Specify lookup methods and in which order to try them.
The valid methods are as follows:</p> <ul><li><strong>native</strong> (use system calls)</li><li><strong>file</strong> (use host data retrieved from system configuration files and/or the user configuration file)</li><li><strong>dns</strong> (use the Erlang DNS client <a href="./inet_res">kernel/inet_res</a> for nameserver queries)</li></ul> <p>The lookup method <strong>string</strong> tries to
parse the hostname as an IPv4 or IPv6 string and return
the resulting IP address. It is automatically tried
first when <strong>native</strong> is <em>not</em>
in the <strong>Methods</strong> list. To skip it in this case,
the pseudo lookup method <strong>nostring</strong> can be
inserted anywhere in the <strong>Methods</strong> list.</p> </dd><dt><strong>{cache_size, Size}.</strong></dt><dd> <p><strong>Size = integer()</strong></p> <p>Set the resolver cache size. Defaults to 100 DNS records.</p> </dd><dt><strong>{cache_refresh, Time}.</strong></dt><dd> <p><strong>Time = integer()</strong></p> <p>Set how often (in milliseconds) the resolver cache for
<a href="./inet_res">kernel/inet_res</a>
is refreshed (that is, expired DNS records are deleted).
Defaults to 1 hour.</p> </dd><dt><strong>{timeout, Time}.</strong></dt><dd> <p><strong>Time = integer()</strong></p> <p>Set the time to wait until retry (in milliseconds) for DNS queries
made by
<a href="./inet_res">kernel/inet_res</a>.
Defaults to 2 seconds.</p> </dd><dt><strong>{retry, N}.</strong></dt><dd> <p><strong>N = integer()</strong></p> <p>Set the number of DNS queries
<a href="./inet_res">kernel/inet_res</a>
will try before giving up. Defaults to 3.</p> </dd><dt><strong>{inet6, Bool}.</strong></dt><dd> <p><strong>Bool = true | false</strong></p> <p>Tells the DNS client
<a href="./inet_res">kernel/inet_res</a>
to look up IPv6 addresses. Defaults to <strong>false</strong>.</p> </dd><dt><strong>{usevc, Bool}.</strong></dt><dd> <p><strong>Bool = true | false</strong></p> <p>Tells the DNS client
<a href="./inet_res">kernel/inet_res</a>
to use TCP (Virtual Circuit) instead of UDP. Defaults to
<strong>false</strong>.</p> </dd><dt><strong>{edns, Version}.</strong></dt><dd> <p><strong>Version = false | 0</strong></p> <p>Sets the EDNS version that
<a href="./inet_res">kernel/inet_res</a>
will use. The only allowed version is zero. Defaults to <strong>false</strong>,
which means not to use EDNS.</p> </dd><dt><strong>{udp_payload_size, Size}.</strong></dt><dd> <p><strong>N = integer()</strong></p> <p>Sets the allowed UDP payload size
<a href="./inet_res">kernel/inet_res</a>
will advertise in EDNS queries. Also sets the limit
when the DNS query will be deemed too large for UDP
forcing a TCP query instead; this  is not entirely
correct, as the advertised UDP payload size of the
individual nameserver is what is to be used,
but this simple strategy will do until a more intelligent
(probing, caching) algorithm needs to be implemented.
Default to 1280, which stems from the standard Ethernet MTU size.</p> </dd><dt><strong>{udp, Module}.</strong></dt><dd> <p><strong>Module = atom()</strong></p> <p>Tell Erlang to use another primitive UDP module than
<strong>inet_udp</strong>.</p> </dd><dt><strong>{tcp, Module}.</strong></dt><dd> <p><strong>Module = atom()</strong></p> <p>Tell Erlang to use another primitive TCP module than
<strong>inet_tcp</strong>.</p> </dd><dt><strong>clear_hosts.</strong></dt><dd> <p>Clear the hosts table.</p> </dd><dt><strong>clear_ns.</strong></dt><dd> <p>Clear the list of recorded nameservers (primary and secondary).</p> </dd><dt><strong>clear_search.</strong></dt><dd> <p>Clear the list of search domains.</p> </dd></dl><h4>User Configuration Example</h4><p>Assume that a user does not want Erlang to use the native lookup method,
but wants Erlang to read all information necessary from start and use
that for resolving names and addresses. If lookup fails, Erlang
is to request the data from a nameserver (using the Erlang
DNS client, set to use EDNS allowing larger responses).
The resolver configuration is updated when
its configuration file changes. Also, DNS records
are never to be cached. The user configuration file
(in this example named <strong>erl_inetrc</strong>, stored
in directory <strong>./cfg_files</strong>) can then look as follows
(Unix):</p><pre>
%% -- ERLANG INET CONFIGURATION FILE --
%% read the hosts file
{file, hosts, "/etc/hosts"}.
%% add a particular host
{host, {134,138,177,105}, ["finwe"]}.
%% do not monitor the hosts file
{hosts_file, ""}.
%% read and monitor nameserver config from here
{resolv_conf, "/usr/local/etc/resolv.conf"}.
%% enable EDNS
{edns,0}.
%% disable caching
{cache_size, 0}.
%% specify lookup method
{lookup, [file, dns]}.</pre><p>And Erlang can, for example, be started as follows:</p><pre><code class="">
% erl -sname my_node -kernel inetrc '"./cfg_files/erl_inetrc"'</code></pre><h4>Introduction</h4><p>The socket interface (module) is basically an "thin" layer on top of
the OS socket interface. It is assumed that, unless you have special needs,
gen_[tcp|udp|sctp] should be sufficent. </p><p>Note that just because we have a documented and described option,
it does <em>not</em> mean that the OS supports it. So its recommended
that the user reads the platform specific documentation for the
option used. </p><a name="socket_options"></a><h4>Socket Options</h4><p>Options for level <strong>otp</strong>: </p><table class="table table-bordered table-hover table-striped"><caption>option levels</caption><tbody><tr><td><em>Option Name</em></td><td><em>Value Type</em></td><td><em>Set</em></td><td><em>Get</em></td><td><em>Other Requirements and comments</em></td></tr><tr><td>assoc_id</td><td>integer()</td><td>no</td><td>yes</td><td>type = seqpacket, protocol = sctp, is an association</td></tr><tr><td>debug</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>iow</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>controlling_process</td><td>pid()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>rcvbuf</td><td>default | pos_integer() | {pos_integer(), pos_ineteger()}</td><td>yes</td><td>yes</td><td>'default' only valid for set. The tuple form is only valid for type 'stream' and protocol 'tcp'.</td></tr><tr><td>rcvctrlbuf</td><td>default | pos_integer()</td><td>yes</td><td>yes</td><td>default only valid for set</td></tr><tr><td>sndctrlbuf</td><td>default | pos_integer()</td><td>yes</td><td>yes</td><td>default only valid for set</td></tr><tr><td>fd</td><td>integer()</td><td>no</td><td>yes</td><td>none</td></tr></tbody></table><p>Options for level <strong>socket</strong>: </p><table class="table table-bordered table-hover table-striped"><caption>socket options</caption><tbody><tr><td><em>Option Name</em></td><td><em>Value Type</em></td><td><em>Set</em></td><td><em>Get</em></td><td><em>Other Requirements and comments</em></td></tr><tr><td>acceptcon</td><td>boolean()</td><td>no</td><td>yes</td><td>none</td></tr><tr><td>bindtodevice</td><td>string()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>broadcast</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram</td></tr><tr><td>debug</td><td>integer()</td><td>yes</td><td>yes</td><td>requires admin capability</td></tr><tr><td>domain</td><td>domain()</td><td>no</td><td>yes</td><td><em>Not</em> on FreeBSD (for instance)</td></tr><tr><td>dontroute</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>keepalive</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>linger</td><td>abort | linger()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>oobinline</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>peek_off</td><td>integer()</td><td>yes</td><td>yes</td><td>domain = local (unix)</td></tr><tr><td>priority</td><td>integer()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>protocol</td><td>protocol()</td><td>no</td><td>yes</td><td>none</td></tr><tr><td>rcvbuf</td><td>non_neg_integer()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>rcvlowat</td><td>non_neg_integer()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>rcvtimeo</td><td>timeval()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>reuseaddr</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>reuseport</td><td>boolean()</td><td>yes</td><td>yes</td><td>domain = inet | inet6</td></tr><tr><td>sndbuf</td><td>non_neg_integer()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>sndlowat</td><td>non_neg_integer()</td><td>yes</td><td>yes</td><td>not changeable on Linux</td></tr><tr><td>sndtimeo</td><td>timeval()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>timestamp</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>type</td><td>type()</td><td>no</td><td>yes</td><td>none</td></tr></tbody></table><p>Options for level <strong>ip</strong>: </p><table class="table table-bordered table-hover table-striped"><caption>ip options</caption><tbody><tr><td><em>Option Name</em></td><td><em>Value Type</em></td><td><em>Set</em></td><td><em>Get</em></td><td><em>Other Requirements and comments</em></td></tr><tr><td>add_membership</td><td>ip_mreq()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>add_source_membership</td><td>ip_mreq_source()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>block_source</td><td>ip_mreq_source()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>drop_membership</td><td>ip_mreq()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>drop_source_membership</td><td>ip_mreq_source()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>freebind</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>hdrincl</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = raw</td></tr><tr><td>minttl</td><td>integer()</td><td>yes</td><td>yes</td><td>type = raw</td></tr><tr><td>msfilter</td><td>null | ip_msfilter()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>mtu</td><td>integer()</td><td>no</td><td>yes</td><td>type = raw</td></tr><tr><td>mtu_discover</td><td>ip_pmtudisc()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>multicast_all</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>multicast_if</td><td>any | ip4_address()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>multicast_loop</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>multicast_ttl</td><td>uint8()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>nodefrag</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = raw</td></tr><tr><td>pktinfo</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram</td></tr><tr><td>recvdstaddr</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram</td></tr><tr><td>recverr</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>recvif</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram | raw</td></tr><tr><td>recvopts</td><td>boolean()</td><td>yes</td><td>yes</td><td>type =/= stream</td></tr><tr><td>recvorigdstaddr</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>recvttl</td><td>boolean()</td><td>yes</td><td>yes</td><td>type =/= stream</td></tr><tr><td>retopts</td><td>boolean()</td><td>yes</td><td>yes</td><td>type =/= stream</td></tr><tr><td>router_alert</td><td>integer()</td><td>yes</td><td>yes</td><td>type = raw</td></tr><tr><td>sendsrcaddr</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>tos</td><td>ip_tos()</td><td>yes</td><td>yes</td><td>some high-priority levels may require superuser capability</td></tr><tr><td>transparent</td><td>boolean()</td><td>yes</td><td>yes</td><td>requires admin capability</td></tr><tr><td>ttl</td><td>integer()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>unblock_source</td><td>ip_mreq_source()</td><td>yes</td><td>no</td><td>none</td></tr></tbody></table><p>Options for level <strong>ipv6</strong>: </p><table class="table table-bordered table-hover table-striped"><caption>ipv6 options</caption><tbody><tr><td><em>Option Name</em></td><td><em>Value Type</em></td><td><em>Set</em></td><td><em>Get</em></td><td><em>Other Requirements and comments</em></td></tr><tr><td>addrform</td><td>inet</td><td>yes</td><td>no</td><td>allowed only for IPv6 sockets that are connected and bound to a v4-mapped-on-v6 address</td></tr><tr><td>add_membership</td><td>ipv6_mreq()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>authhdr</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram | raw, obsolete?</td></tr><tr><td>drop_membership</td><td>ipv6_mreq()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>dstopts</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram | raw, requires superuser privileges to update</td></tr><tr><td>flowinfo</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram | raw, requires superuser privileges to update</td></tr><tr><td>hoplimit</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram | raw, requires superuser privileges to update</td></tr><tr><td>hopopts</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram | raw, requires superuser privileges to update</td></tr><tr><td>mtu</td><td>boolean()</td><td>yes</td><td>yes</td><td>Get: Only after the socket has been connected</td></tr><tr><td>mtu_discover</td><td>ipv6_pmtudisc()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>multicast_hops</td><td>default | uint8()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>multicast_if</td><td>integer()</td><td>yes</td><td>yes</td><td>type = dgram | raw</td></tr><tr><td>multicast_loop</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>recverr</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>recvpktinfo | pktinfo</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram | raw</td></tr><tr><td>router_alert</td><td>integer()</td><td>yes</td><td>yes</td><td>type = raw</td></tr><tr><td>rthdr</td><td>boolean()</td><td>yes</td><td>yes</td><td>type = dgram | raw, requires superuser privileges to update</td></tr><tr><td>unicast_hops</td><td>default | uint8()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>v6only</td><td>boolean()</td><td>yes</td><td>no</td><td>none</td></tr></tbody></table><p>Options for level <strong>tcp</strong>: </p><table class="table table-bordered table-hover table-striped"><caption>tcp options</caption><tbody><tr><td><em>Option Name</em></td><td><em>Value Type</em></td><td><em>Set</em></td><td><em>Get</em></td><td><em>Other Requirements and comments</em></td></tr><tr><td>congestion</td><td>string()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>maxseg</td><td>integer()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>nodelay</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr></tbody></table><p>Options for level <strong>udp</strong>: </p><table class="table table-bordered table-hover table-striped"><caption>udp options</caption><tbody><tr><td><em>Option Name</em></td><td><em>Value Type</em></td><td><em>Set</em></td><td><em>Get</em></td><td><em>Other Requirements and comments</em></td></tr><tr><td>cork</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr></tbody></table><p>Options for level <strong>sctp</strong>: </p><table class="table table-bordered table-hover table-striped"><caption>sctp options</caption><tbody><tr><td><em>Option Name</em></td><td><em>Value Type</em></td><td><em>Set</em></td><td><em>Get</em></td><td><em>Other Requirements and comments</em></td></tr><tr><td>associnfo</td><td>sctp_assocparams()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>autoclose</td><td>non_neg_integer()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>disable_fragments</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>events</td><td>sctp_event_subscribe()</td><td>yes</td><td>no</td><td>none</td></tr><tr><td>initmsg</td><td>sctp_initmsg()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>maxseg</td><td>non_neg_integer()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>nodelay</td><td>boolean()</td><td>yes</td><td>yes</td><td>none</td></tr><tr><td>rtoinfo</td><td>sctp_rtoinfo()</td><td>yes</td><td>yes</td><td>none</td></tr></tbody></table><h4>Introduction</h4><p>
The external term format is mainly used in the distribution
mechanism of Erlang.
</p><p>
As Erlang has a fixed number of types, there is no need for a
programmer to define a specification for the external format used
within some application.
All Erlang terms have an external representation and the interpretation
of the different terms is application-specific.
</p><p>
In Erlang the BIF <a href="../erts/erlang#term_to_binary/1">erts/erlang#term_to_binary/1</a> is used to convert a
term into the external format.
To convert binary data encoding to a term, the BIF
<a href="../erts/erlang#binary_to_term/1">erts/erlang#binary_to_term/1</a> is used.
</p><p>
The distribution does this implicitly when sending messages across
node boundaries.
</p><a name="overall_format"></a><p>
The overall format of the term format is as follows:
</p><table class="table table-bordered table-hover table-striped"><caption>Term Format</caption><tbody><tr><td>1</td><td>1</td><td>N</td></tr><tr><td><strong>131</strong></td><td><strong>Tag</strong></td><td><strong>Data</strong></td></tr></tbody></table><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
When messages are
<a href="./erl_dist_protocol#connected_nodes">passed between connected nodes</a> and a
<a href="#distribution_header">distribution header</a> is used, the first byte containing the version
number (131) is omitted from the terms that follow the distribution
header. This is because the version number is implied by the version
number in the distribution header.
</p></div><p>
The compressed term format is as follows:
</p><table class="table table-bordered table-hover table-striped"><caption>Compressed Term Format</caption><tbody><tr><td>1</td><td>1</td><td>4</td><td>N</td></tr><tr><td><strong>131</strong></td><td><strong>80</strong></td><td><strong>UncompressedSize</strong></td><td><strong>Zlib-compressedData</strong></td></tr></tbody></table><p>
Uncompressed size (unsigned 32-bit integer in big-endian byte order)
is the size of the data before it was compressed.
The compressed data has the following format when it has been expanded:
</p><table class="table table-bordered table-hover table-striped"><caption>Compressed Data Format when Expanded</caption><tbody><tr><td>1</td><td>Uncompressed Size</td></tr><tr><td><strong>Tag</strong></td><td><strong>Data</strong></td></tr></tbody></table><a name="utf8_atoms"></a><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from ERTS 9.0 (OTP 20), atoms may contain any Unicode
characters and are always encoded using the UTF-8 external formats
<a href="#ATOM_UTF8_EXT">ATOM_UTF8_EXT</a>
or <a href="#SMALL_ATOM_UTF8_EXT">SMALL_ATOM_UTF8_EXT</a>.
The old Latin-1 formats <a href="#ATOM_EXT">ATOM_EXT</a>
and <a href="#SMALL_ATOM_EXT">SMALL_ATOM_EXT</a>
are deprecated and are only kept for backward
compatibility when decoding terms encoded by older nodes.</p><p>Support for UTF-8 encoded atoms in the external format has been
available since ERTS 5.10 (OTP R16). This abillity allows such old nodes
to decode, store and encode any Unicode atoms received from a new OTP 20
node.</p><p>The maximum number of allowed characters in an atom is 255. In the
UTF-8 case, each character can need 4 bytes to be encoded.</p></div><a name="distribution_header"></a><h4>Distribution Header</h4><p>
The distribution header is sent by the erlang distribution to
carry metadata about the coming
<a href="./erl_dist_protocol#control_message">control message</a>
and potential payload. It is primarily used to handle the atom cache
in the Erlang distribution. Since OTP-22 it is also used to fragment
large distribution messages into multiple smaller fragments.
For more information about how the distribution uses the distribution header,
see the documentation of the
<a href="./erl_dist_protocol#connected_nodes">protocol between connected nodes</a> in the
<a href="erl_dist_protocol">distribution protocol</a>
documentation.
</p><p>
Any <a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a>
entries with corresponding <strong>AtomCacheReferenceIndex</strong> in terms
encoded on the external format following a distribution header refer
to the atom cache references made in the distribution header. The range
is 0 &lt;= <strong>AtomCacheReferenceIndex</strong> &lt; 255, that is, at most 255
different atom cache references from the following terms can be made.
</p><h4>Normal Distribution Header</h4><p>
The non-fragmented distribution header format is as follows:
</p><table class="table table-bordered table-hover table-striped"><caption>Normal Distribution Header Format</caption><tbody><tr><td>1</td><td>1</td><td>1</td><td>NumberOfAtomCacheRefs/2+1 | 0</td><td>N | 0</td></tr><tr><td><strong>131</strong></td><td><strong>68</strong></td><td><strong>NumberOfAtomCacheRefs</strong></td><td><strong>Flags</strong></td><td><strong>AtomCacheRefs</strong></td></tr></tbody></table><p>
<strong>Flags</strong> consist of <strong>NumberOfAtomCacheRefs/2+1</strong> bytes,
unless <strong>NumberOfAtomCacheRefs</strong> is <strong>0</strong>. If
<strong>NumberOfAtomCacheRefs</strong> is <strong>0</strong>, <strong>Flags</strong> and
<strong>AtomCacheRefs</strong> are omitted. Each atom cache reference has
a half byte flag field. Flags corresponding to a specific
<strong>AtomCacheReferenceIndex</strong> are located in flag byte number
<strong>AtomCacheReferenceIndex/2</strong>. Flag byte 0 is the first byte
after the <strong>NumberOfAtomCacheRefs</strong> byte. Flags for an even
<strong>AtomCacheReferenceIndex</strong> are located in the least significant
half byte and flags for an odd <strong>AtomCacheReferenceIndex</strong> are
located in the most significant half byte.
</p><p>
The flag field of an atom cache reference has the following
format:
</p><table class="table table-bordered table-hover table-striped"><tbody><tr><td>1 bit</td><td>3 bits</td></tr><tr><td><strong>NewCacheEntryFlag</strong></td><td><strong>SegmentIndex</strong></td></tr></tbody></table><p>
The most significant bit is the <strong>NewCacheEntryFlag</strong>. If set,
the corresponding cache reference is new. The three least
significant bits are the <strong>SegmentIndex</strong> of the corresponding
atom cache entry. An atom cache consists of 8 segments, each of size
256, that is, an atom cache can contain 2048 entries.
</p><p>
After flag fields for atom cache references, another half byte flag
field is located with the following format:
</p><table class="table table-bordered table-hover table-striped"><tbody><tr><td>3 bits</td><td>1 bit</td></tr><tr><td><strong>CurrentlyUnused</strong></td><td><strong>LongAtoms</strong></td></tr></tbody></table><p>
The least significant bit in that half byte is flag <strong>LongAtoms</strong>.
If it is set, 2 bytes are used for atom lengths instead of
1 byte in the distribution header.
</p><p>
After the <strong>Flags</strong> field follow the <strong>AtomCacheRefs</strong>. The
first <strong>AtomCacheRef</strong> is the one corresponding to
<strong>AtomCacheReferenceIndex</strong> 0. Higher indices follow
in sequence up to index <strong>NumberOfAtomCacheRefs - 1</strong>.
</p><p>
If the <strong>NewCacheEntryFlag</strong> for the next <strong>AtomCacheRef</strong> has
been set, a <strong>NewAtomCacheRef</strong> on the following format follows:
</p><table class="table table-bordered table-hover table-striped"><tbody><tr><td>1</td><td>1 | 2</td><td>Length</td></tr><tr><td><strong>InternalSegmentIndex</strong></td><td><strong>Length</strong></td><td><strong>AtomText</strong></td></tr></tbody></table><p>
<strong>InternalSegmentIndex</strong> together with the <strong>SegmentIndex</strong>
completely identify the location of an atom cache entry in the
atom cache. <strong>Length</strong> is the number of bytes that <strong>AtomText</strong>
consists of. Length is a 2 byte big-endian integer
if flag <strong>LongAtoms</strong> has been set, otherwise a 1 byte
integer. When distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been exchanged between both nodes in the
<a href="./erl_dist_protocol#distribution_handshake"> distribution handshake</a>,
characters in <strong>AtomText</strong> are encoded in UTF-8, otherwise
in Latin-1. The following <strong>CachedAtomRef</strong>s with the same
<strong>SegmentIndex</strong> and <strong>InternalSegmentIndex</strong> as this
<strong>NewAtomCacheRef</strong> refer to this atom until a new
<strong>NewAtomCacheRef</strong> with the same <strong>SegmentIndex</strong>
and <strong>InternalSegmentIndex</strong> appear.
</p><p>
For more information on encoding of atoms, see the
<a href="#utf8_atoms">note on UTF-8 encoded atoms</a>
in the beginning of this section.
</p><p>
If the <strong>NewCacheEntryFlag</strong> for the next <strong>AtomCacheRef</strong>
has not been set, a <strong>CachedAtomRef</strong> on the following format
follows:
</p><table class="table table-bordered table-hover table-striped"><tbody><tr><td>1</td></tr><tr><td><strong>InternalSegmentIndex</strong></td></tr></tbody></table><p>
<strong>InternalSegmentIndex</strong> together with the <strong>SegmentIndex</strong>
identify the location of the atom cache entry in the atom cache.
The atom corresponding to this <strong>CachedAtomRef</strong> is the
latest <strong>NewAtomCacheRef</strong> preceding this <strong>CachedAtomRef</strong>
in another previously passed distribution header.
</p><a name="fragments"></a><h4>Distribution Header for fragmented messages</h4><p>Messages sent between Erlang nodes can sometimes be
quite large. Since OTP-22 it is possible to split large messages
into smaller fragments in order to allow smaller messages to be interleaved
between larges messages. It is only the <strong>message</strong> part of each
<a href="./erl_dist_protocol#connected_nodes">distributed message</a>
that may be split using fragmentation. Therefore it is recommended to use the
<a href="./erl_dist_protocol#new-ctrlmessages-for-erlang-otp-22"> PAYLOAD control messages</a> introduced in OTP-22.
</p><p>Fragmented distribution messages are only used if the receiving node
signals that it supports them via the
<a href="./erl_dist_protocol#dflags">DFLAG_FRAGMENTS</a> distribution
flag.</p><p>A process must complete the sending of a fragmented message before it
can start sending any other message on the same distribution channel.</p><p>The start of a sequence of fragmented messages looks like this:</p><table class="table table-bordered table-hover table-striped"><caption>Starting Fragmented Distribution Header Format</caption><tbody><tr><td>1</td><td>1</td><td>8</td><td>8</td><td>1</td><td>NumberOfAtomCacheRefs/2+1 | 0</td><td>N | 0</td></tr><tr><td><strong>131</strong></td><td><strong>69</strong></td><td><strong>SequenceId</strong></td><td><strong>FragmentId</strong></td><td><strong>NumberOfAtomCacheRefs</strong></td><td><strong>Flags</strong></td><td><strong>AtomCacheRefs</strong></td></tr></tbody></table><p>The continuation of a sequence of fragmented messages looks like this:</p><table class="table table-bordered table-hover table-striped"><caption>Continuing Fragmented Distribution Header Format</caption><tbody><tr><td>1</td><td>1</td><td>8</td><td>8</td></tr><tr><td><strong>131</strong></td><td><strong>70</strong></td><td><strong>SequenceId</strong></td><td><strong>FragmentId</strong></td></tr></tbody></table><p>
The starting distribution header is very similar to a non-fragmented distribution
header. The atom cache works the same as for normal distribution header and
is the same for the entire sequence. The additional fields added are the
sequence id and fragment id.
</p><dl><dt>Sequence ID</dt><dd> <p>
The sequence id is used to uniquely identify a fragmented message sent
from one process to another on the same distributed connection. This is used
to identify which sequence a fragment is a part of as the same process can
be in the process of receiving multiple sequences at the same time.
</p> <p>
As one process can only be sending one fragmented message at once,
it can be convenient to use the local PID as the sequence id.
</p> </dd><dt>Fragments ID</dt><dd> <p>
The Fragment ID is used to number the fragments in a sequence.
The id starts at the total number of fragments and then decrements to 1
(which is the final fragment). So if a sequence consists of 3 fragments
the fragment id in the starting header will be 3, and then fragments 2 and 1
are sent.
</p> <p>
The fragments must be delivered in the correct order, so if an unordered
distribution carrier is used, they must be ordered before delivered to the
Erlang run-time.
</p> </dd></dl><h4>Example:</h4><p>
As an example, let say that we want to send
<strong>{call, &lt;0.245.2&gt;, {set_get_state, &lt;&lt;0:1024&gt;&gt;}}</strong> to
registered process <strong>reg</strong> using a fragment size of 128. To send
this message we need a distribution header, atom cache updates,
the control message (which would be <strong>{6, &lt;0.245.2&gt;, [], reg}</strong> in this case)
and finally the actual message. This would all be encoded into:
</p><pre><code class="">
131,69,0,0,2,168,0,0,5,83,0,0,0,0,0,0,0,2,               %% Header with seq and frag id
5,4,137,9,10,5,236,3,114,101,103,9,4,99,97,108,108,      %% Atom cache updates
238,13,115,101,116,95,103,101,116,95,115,116,97,116,101,
104,4,97,6,103,82,0,0,0,0,85,0,0,0,0,2,82,1,82,2,        %% Control message
104,3,82,3,103,82,0,0,0,0,245,0,0,0,2,2,                 %% Actual message using cached atoms
104,2,82,4,109,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

131,70,0,0,2,168,0,0,5,83,0,0,0,0,0,0,0,1,               %% Cont Header with seq and frag id
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,               %% Rest of payload
0,0,0,0</code></pre><p>
Let us break that apart into its components. First we have the
distribution header tags together with the sequence id and
a fragment id of 2.
</p><pre><code class="">
131,69,                   %% Start fragment header
0,0,2,168,0,0,5,83,       %% The sequence ID
0,0,0,0,0,0,0,2,           %% The fragment ID
</code></pre><p>Then we have the updates to the atom cache:</p><pre><code class="">
5,4,137,9,  %% 5 atoms and their flags
10,5,       %% The already cached atom ids
236,3,114,101,103,  %% The atom 'reg'
9,4,99,97,108,108,  %% The atom 'call'
238,13,115,101,116,95,103,101,116,95,115,116,97,116,101, %% The atom 'set_get_state'
       </code></pre><p>
The first byte says that we have 5 atoms that are part
of the cache. Then follows three bytes that are the
atom cache ref flags. Each of the flags uses 4 bits so
they are a bit hard to read in decimal byte form. In
binary half-byte form they look like this:
</p><pre><code class="">0000, 0100, 1000, 1001, 1001</code></pre><p>
As the high bit of the first two atoms in the
cache are not set we know that they are already in the cache,
so they do not have to be sent again (this is the node name of the
receiving and sending node). Then follows the atoms that have to be sent,
together with their segment ids.
</p><p>
Then the listing of the atoms comes, starting with 10 and 5
which are the atom refs of the already cached atoms. Then the
new atoms are sent.
</p><p>
When the atom cache is setup correctly the control message is sent.
</p><pre><code class="">104,4,97,6,103,82,0,0,0,0,85,0,0,0,0,2,82,1,82,2,</code></pre><p>
Note that up until here it is not allowed to fragments the message.
The entire atom cache and control message has to be part of the
starting fragment. After the control message the payload of the message
is sent using 128 bytes:
</p><pre><code class="">
104,3,82,3,103,82,0,0,0,0,245,0,0,0,2,2,
104,2,82,4,109,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       </code></pre><p>
Since the payload is larger than 128-bytes it is split into two
fragments. The second fragment does not have any atom cache update
instructions so it is a lot simpler:
</p><pre><code class="">
131,70,0,0,2,168,0,0,5,83,0,0,0,0,0,0,0,1, %% Continuation dist header 70 with seq and frag id
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, %% remaining payload
0,0,0,0
       </code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
The fragment size of 128 is only used as an example.
Any fragments size may be used when sending fragmented messages.
</p></div><a name="ATOM_CACHE_REF"></a><h4>ATOM_CACHE_REF</h4><table class="table table-bordered table-hover table-striped"><caption>ATOM_CACHE_REF</caption><tbody><tr><td>1</td><td>1</td></tr><tr><td><strong>82</strong></td><td><strong>AtomCacheReferenceIndex</strong></td></tr></tbody></table><p>
Refers to the atom with <strong>AtomCacheReferenceIndex</strong> in the
<a href="#distribution_header">distribution header</a>.
</p><a name="SMALL_INTEGER_EXT"></a><h4>SMALL_INTEGER_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>SMALL_INTEGER_EXT</caption><tbody><tr><td>1</td><td>1</td></tr><tr><td><strong>97</strong></td><td><strong>Int</strong></td></tr></tbody></table><p>
Unsigned 8-bit integer.
</p><a name="INTEGER_EXT"></a><h4>INTEGER_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>INTEGER_EXT</caption><tbody><tr><td>1</td><td>4</td></tr><tr><td><strong>98</strong></td><td><strong>Int</strong></td></tr></tbody></table><p>
Signed 32-bit integer in big-endian format.
</p><a name="FLOAT_EXT"></a><h4>FLOAT_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>FLOAT_EXT</caption><tbody><tr><td>1</td><td>31</td></tr><tr><td><strong>99</strong></td><td><strong>Float string</strong></td></tr></tbody></table><p>
A finite float (i.e. not inf, -inf or NaN) is stored in
string format. The format used in sprintf to format the
float is "%.20e"
(there are more bytes allocated than necessary).
To unpack the float, use sscanf with format "%lf".
</p><p>
This term is used in minor version 0 of the external format;
it has been superseded by
<a href="#NEW_FLOAT_EXT">NEW_FLOAT_EXT</a>.
</p><a name="PORT_EXT"></a><h4>PORT_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>PORT_EXT</caption><tbody><tr><td>1</td><td>N</td><td>4</td><td>1</td></tr><tr><td><strong>102</strong></td><td><strong>Node</strong></td><td><strong>ID</strong></td><td><strong>Creation</strong></td></tr></tbody></table><p>
Same as <a href="#NEW_PORT_EXT">NEW_PORT_EXT</a>
except the <strong>Creation</strong> field is only one byte and only two
bits are significant, the rest are to be 0.
</p><a name="NEW_PORT_EXT"></a><h4>NEW_PORT_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>NEW_PORT_EXT</caption><tbody><tr><td>1</td><td>N</td><td>4</td><td>4</td></tr><tr><td><strong>89</strong></td><td><strong>Node</strong></td><td><strong>ID</strong></td><td><strong>Creation</strong></td></tr></tbody></table><p>
Encodes a port identifier (obtained from
<a href="./erlang#open_port/2">erlang#open_port/2</a>).
<strong>Node</strong> is an encoded atom, that is,
<a href="#ATOM_UTF8_EXT">ATOM_UTF8_EXT</a>,
<a href="#SMALL_ATOM_UTF8_EXT">SMALL_ATOM_UTF8_EXT</a>
or <a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a>.
<strong>ID</strong> is a 32-bit big endian unsigned integer. Only 28 bits are
significant; the rest are to be 0. The <strong>Creation</strong> works just like in
<a href="#NEW_PID_EXT">NEW_PID_EXT</a>.
Port operations are not allowed across node boundaries.
</p><p>Introduced in OTP 19, but only to be decoded and echoed back. Not
encoded for local ports. Planned to supersede <a href="#PORT_EXT">PORT_EXT</a> in OTP 23 when
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
becomes mandatory.
</p><a name="PID_EXT"></a><h4>PID_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>PID_EXT</caption><tbody><tr><td>1</td><td>N</td><td>4</td><td>4</td><td>1</td></tr><tr><td><strong>103</strong></td><td><strong>Node</strong></td><td><strong>ID</strong></td><td><strong>Serial</strong></td><td><strong>Creation</strong></td></tr></tbody></table><p>
Same as <a href="#NEW_PID_EXT">NEW_PID_EXT</a>
except the <strong>Creation</strong> field is only one byte and only two
bits are significant, the rest are to be 0.
</p><a name="NEW_PID_EXT"></a><h4>NEW_PID_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>NEW_PID_EXT</caption><tbody><tr><td>1</td><td>N</td><td>4</td><td>4</td><td>4</td></tr><tr><td><strong>88</strong></td><td><strong>Node</strong></td><td><strong>ID</strong></td><td><strong>Serial</strong></td><td><strong>Creation</strong></td></tr></tbody></table><p>
Encodes an Erlang process identifier object.
</p><dl><dt><strong>Node</strong></dt><dd><p>The name of the originating node, encoded using
<a href="#ATOM_UTF8_EXT">ATOM_UTF8_EXT</a>,
<a href="#SMALL_ATOM_UTF8_EXT">SMALL_ATOM_UTF8_EXT</a>
or <a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a>.</p> </dd><dt><strong>ID</strong></dt><dd><p>A 32-bit big endian unsigned integer. Only 15 bits are
significant; the rest are to be 0.</p> </dd><dt><strong>Serial</strong></dt><dd><p>A 32-bit big endian unsigned integer. Only 13 bits are
significant; the rest are to be 0.</p> </dd><dt><strong>Creation</strong></dt><dd><p>A 32-bit big endian unsigned integer. All identifiers
originating from the same node incarnation must have identical <strong>Creation</strong>
values. This makes it possible to separate identifiers from old
(crashed) nodes from a new one. The value zero should be avoided for
normal operations as it is used as a wild card for debug purpose
(like a pid returned by <a href="../erts/erlang#list_to_pid/1"> erlang:list_to_pid/1</a>).</p> </dd></dl><p>Introduced in OTP 19, but only to be decoded and echoed back. Not
encoded for local processes. Planned to supersede <a href="#PID_EXT">PID_EXT</a> in OTP 23 when
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
becomes mandatory.
</p><a name="SMALL_TUPLE_EXT"></a><h4>SMALL_TUPLE_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>SMALL_TUPLE_EXT</caption><tbody><tr><td>1</td><td>1</td><td>N</td></tr><tr><td><strong>104</strong></td><td><strong>Arity</strong></td><td><strong>Elements</strong></td></tr></tbody></table><p>
Encodes a tuple. The <strong>Arity</strong>
field is an unsigned byte that determines how many elements
that follows in section <strong>Elements</strong>.
</p><a name="LARGE_TUPLE_EXT"></a><h4>LARGE_TUPLE_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>LARGE_TUPLE_EXT</caption><tbody><tr><td>1</td><td>4</td><td>N</td></tr><tr><td><strong>105</strong></td><td><strong>Arity</strong></td><td><strong>Elements</strong></td></tr></tbody></table><p>
Same as
<a href="#SMALL_TUPLE_EXT">SMALL_TUPLE_EXT</a>
except that <strong>Arity</strong> is an
unsigned 4 byte integer in big-endian format.
</p><a name="MAP_EXT"></a><h4>MAP_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>MAP_EXT</caption><tbody><tr><td>1</td><td>4</td><td>N</td></tr><tr><td><strong>116</strong></td><td><strong>Arity</strong></td><td><strong>Pairs</strong></td></tr></tbody></table><p>
Encodes a map. The <strong>Arity</strong> field is an unsigned
4 byte integer in big-endian format that determines the number of
key-value pairs in the map. Key and value pairs (<strong>Ki =&gt; Vi</strong>)
are encoded in section <strong>Pairs</strong> in the following order:
<strong>K1, V1, K2, V2,..., Kn, Vn</strong>.
Duplicate keys are <em>not allowed</em> within the same map.
</p><p><em>As from </em>Erlang/OTP 17.0</p><a name="NIL_EXT"></a><h4>NIL_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>NIL_EXT</caption><tbody><tr><td>1</td></tr><tr><td><strong>106</strong></td></tr></tbody></table><p>
The representation for an empty list, that is, the Erlang syntax
<strong>[]</strong>.
</p><a name="STRING_EXT"></a><h4>STRING_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>STRING_EXT</caption><tbody><tr><td>1</td><td>2</td><td>Len</td></tr><tr><td><strong>107</strong></td><td><strong>Length</strong></td><td><strong>Characters</strong></td></tr></tbody></table><p>
String does <em>not</em> have a corresponding Erlang representation,
but is an optimization for sending lists of bytes (integer in
the range 0-255) more efficiently over the distribution.
As field <strong>Length</strong> is an unsigned 2 byte integer
(big-endian), implementations must ensure that lists longer than
65535 elements are encoded as
<a href="#LIST_EXT">LIST_EXT</a>.
</p><a name="LIST_EXT"></a><h4>LIST_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>LIST_EXT</caption><tbody><tr><td>1</td><td>4</td><td>Â </td><td>Â </td></tr><tr><td><strong>108</strong></td><td><strong>Length</strong></td><td><strong>Elements</strong></td><td><strong>Tail</strong></td></tr></tbody></table><p>
<strong>Length</strong> is the number of elements that follows in section
<strong>Elements</strong>. <strong>Tail</strong> is the final tail of the list; it is
<a href="#NIL_EXT">NIL_EXT</a>
for a proper list, but can be any type if the list is
improper (for example, <strong>[a|b]</strong>).
</p><a name="BINARY_EXT"></a><h4>BINARY_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>BINARY_EXT</caption><tbody><tr><td>1</td><td>4</td><td>Len</td></tr><tr><td><strong>109</strong></td><td><strong>Len</strong></td><td><strong>Data</strong></td></tr></tbody></table><p>
Binaries are generated with bit syntax expression or with
<a href="../erts/erlang#list_to_binary/1">erts/erlang#list_to_binary/1</a>,
<a href="../erts/erlang#term_to_binary/1">erts/erlang#term_to_binary/1</a>,
or as input from binary ports.
The <strong>Len</strong> length field is an unsigned 4 byte integer
(big-endian).
</p><a name="SMALL_BIG_EXT"></a><h4>SMALL_BIG_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>SMALL_BIG_EXT</caption><tbody><tr><td>1</td><td>1</td><td>1</td><td>n</td></tr><tr><td><strong>110</strong></td><td><strong>n</strong></td><td><strong>Sign</strong></td><td><strong>d(0)</strong> ... <strong>d(n-1)</strong></td></tr></tbody></table><p>
Bignums are stored in unary form with a <strong>Sign</strong> byte,
that is, 0 if the binum is positive and 1 if it is negative. The
digits are stored with the least significant byte stored first. To
calculate the integer, the following formula can be used:
</p><p><strong>B</strong> = 256<br/>
<strong>(d0*B^0 + d1*B^1 + d2*B^2 + ... d(N-1)*B^(n-1))</strong>
</p><a name="LARGE_BIG_EXT"></a><h4>LARGE_BIG_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>LARGE_BIG_EXT</caption><tbody><tr><td>1</td><td>4</td><td>1</td><td>n</td></tr><tr><td><strong>111</strong></td><td><strong>n</strong></td><td><strong>Sign</strong></td><td><strong>d(0)</strong> ... <strong>d(n-1)</strong></td></tr></tbody></table><p>
Same as <a href="#SMALL_BIG_EXT">SMALL_BIG_EXT</a> 
except that the length field is an unsigned 4 byte integer.
</p><a name="REFERENCE_EXT"></a><h4>REFERENCE_EXT (deprecated)</h4><table class="table table-bordered table-hover table-striped"><caption>REFERENCE_EXT</caption><tbody><tr><td>1</td><td>N</td><td>4</td><td>1</td></tr><tr><td><strong>101</strong></td><td><strong>Node</strong></td><td><strong>ID</strong></td><td><strong>Creation</strong></td></tr></tbody></table><p>
The same as <a href="#NEW_REFERENCE_EXT">NEW_REFERENCE_EXT</a> except <strong>ID</strong> is only one word
(<strong>Len</strong> = 1).
</p><a name="NEW_REFERENCE_EXT"></a><h4>NEW_REFERENCE_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>NEW_REFERENCE_EXT</caption><tbody><tr><td>1</td><td>2</td><td>N</td><td>1</td><td>N'</td></tr><tr><td><strong>114</strong></td><td><strong>Len</strong></td><td><strong>Node</strong></td><td><strong>Creation</strong></td><td><strong>ID ...</strong></td></tr></tbody></table><p>
The same as <a href="#NEWER_REFERENCE_EXT">NEWER_REFERENCE_EXT</a> <em>except</em>:
</p><dl><dt><strong>ID</strong></dt><dd><p>In the first word (4 bytes) of <strong>ID</strong>, only 18 bits are
significant, the rest must be 0.</p> </dd><dt><strong>Creation</strong></dt><dd><p>Only one byte long and only two bits are significant, the rest must be 0.</p> </dd></dl><a name="NEWER_REFERENCE_EXT"></a><h4>NEWER_REFERENCE_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>NEWER_REFERENCE_EXT</caption><tbody><tr><td>1</td><td>2</td><td>N</td><td>4</td><td>N'</td></tr><tr><td><strong>90</strong></td><td><strong>Len</strong></td><td><strong>Node</strong></td><td><strong>Creation</strong></td><td><strong>ID ...</strong></td></tr></tbody></table><p>
Encodes a reference term generated with
<a href="../erts/erlang#make_ref/0">erlang:make_ref/0</a>.
</p><dl><dt><strong>Node</strong></dt><dd><p>The name of the originating node, encoded using
<a href="#ATOM_UTF8_EXT">ATOM_UTF8_EXT</a>,
<a href="#SMALL_ATOM_UTF8_EXT">SMALL_ATOM_UTF8_EXT</a>
or <a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a>.</p> </dd><dt><strong>Len</strong></dt><dd><p>A 16-bit big endian unsigned integer not larger than 3.</p> </dd><dt><strong>ID</strong></dt><dd><p>A sequence of <strong>Len</strong> big-endian unsigned integers
(4 bytes each, so <strong>N'</strong>Â =Â 4Â *Â <strong>Len</strong>),
but is to be regarded as uninterpreted data.</p> </dd><dt><strong>Creation</strong></dt><dd><p>Works just like in
<a href="#NEW_PID_EXT">NEW_PID_EXT</a>.</p> </dd></dl><p>Introduced in OTP 19, but only to be decoded and echoed back. Not
encoded for local references. Planned to supersede <a href="#NEW_REFERENCE_EXT">NEW_REFERENCE_EXT</a> in OTP 23 when
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
becomes mandatory.
</p><a name="FUN_EXT"></a><h4>FUN_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>FUN_EXT</caption><tbody><tr><td>1</td><td>4</td><td>N1</td><td>N2</td><td>N3</td><td>N4</td><td>N5</td></tr><tr><td><strong>117</strong></td><td><strong>NumFree</strong></td><td><strong>Pid</strong></td><td><strong>Module</strong></td><td><strong>Index</strong></td><td><strong>Uniq</strong></td><td><strong>Free vars ...</strong></td></tr></tbody></table><dl><dt><strong>Pid</strong></dt><dd> <p>A process identifier as in
<a href="#PID_EXT">PID_EXT</a>.
Represents the process in which the fun was created.
</p> </dd><dt><strong>Module</strong></dt><dd> <p>Encoded as an atom, using
<a href="#ATOM_UTF8_EXT">ATOM_UTF8_EXT</a>,
<a href="#SMALL_ATOM_UTF8_EXT">SMALL_ATOM_UTF8_EXT</a>,
or <a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a>.
This is the module that the fun is implemented in.
</p> </dd><dt><strong>Index</strong></dt><dd> <p>An integer encoded using
<a href="#SMALL_INTEGER_EXT">SMALL_INTEGER_EXT</a> 
or <a href="#INTEGER_EXT">INTEGER_EXT</a>.
It is typically a small index into the module's fun table.
</p> </dd><dt><strong>Uniq</strong></dt><dd> <p>An integer encoded using
<a href="#SMALL_INTEGER_EXT">SMALL_INTEGER_EXT</a> or 
<a href="#INTEGER_EXT">INTEGER_EXT</a>.
<strong>Uniq</strong> is the hash value of the parse for the fun.
</p> </dd><dt><strong>Free vars</strong></dt><dd> <p><strong>NumFree</strong> number of terms, each one encoded according
to its type.
</p> </dd></dl><a name="NEW_FUN_EXT"></a><h4>NEW_FUN_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>NEW_FUN_EXT</caption><tbody><tr><td>1</td><td>4</td><td>1</td><td>16</td><td>4</td><td>4</td><td>N1</td><td>N2</td><td>N3</td><td>N4</td><td>N5</td></tr><tr><td><strong>112</strong></td><td><strong>Size</strong></td><td><strong>Arity</strong></td><td><strong>Uniq</strong></td><td><strong>Index</strong></td><td><strong>NumFree</strong></td><td><strong>Module</strong></td><td><strong>OldIndex</strong></td><td><strong>OldUniq</strong></td><td><strong>Pid</strong></td><td><strong>Free Vars</strong></td></tr></tbody></table><p>
This is the new encoding of internal funs: <strong>fun F/A</strong> and
<strong>fun(Arg1,..) -&gt; ... end</strong>.
</p><dl><dt><strong>Size</strong></dt><dd> <p>The total number of bytes, including field <strong>Size</strong>.</p> </dd><dt><strong>Arity</strong></dt><dd> <p>The arity of the function implementing the fun.</p> </dd><dt><strong>Uniq</strong></dt><dd> <p>The 16 bytes MD5 of the significant parts of the Beam file.</p> </dd><dt><strong>Index</strong></dt><dd> <p>An index number. Each fun within a module has an unique
index. <strong>Index</strong> is stored in big-endian byte order.
</p> </dd><dt><strong>NumFree</strong></dt><dd> <p>The number of free variables.</p> </dd><dt><strong>Module</strong></dt><dd> <p>Encoded as an atom, using
<a href="#ATOM_EXT">ATOM_EXT</a>, 
<a href="#SMALL_ATOM_EXT">SMALL_ATOM_EXT</a>,
or <a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a>. 
Is the module that the fun is implemented in.
</p> </dd><dt><strong>OldIndex</strong></dt><dd> <p>An integer encoded using
<a href="#SMALL_INTEGER_EXT">SMALL_INTEGER_EXT</a> or
<a href="#INTEGER_EXT">INTEGER_EXT</a>.
Is typically a small index into the module's fun table.
</p> </dd><dt><strong>OldUniq</strong></dt><dd> <p>An integer encoded using
<a href="#SMALL_INTEGER_EXT">SMALL_INTEGER_EXT</a> or 
<a href="#INTEGER_EXT">INTEGER_EXT</a>.
<strong>Uniq</strong> is the hash value of the parse tree for the fun.
</p> </dd><dt><strong>Pid</strong></dt><dd> <p>A process identifier as in
<a href="#PID_EXT">PID_EXT</a>.
Represents the process in which the fun was created.
</p> </dd><dt><strong>Free vars</strong></dt><dd> <p><strong>NumFree</strong> number of terms, each one encoded according
to its type.
</p> </dd></dl><a name="EXPORT_EXT"></a><h4>EXPORT_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>EXPORT_EXT</caption><tbody><tr><td>1</td><td>N1</td><td>N2</td><td>N3</td></tr><tr><td><strong>113</strong></td><td><strong>Module</strong></td><td><strong>Function</strong></td><td><strong>Arity</strong></td></tr></tbody></table><p>
This term is the encoding for external funs: <strong>fun M:F/A</strong>.
</p><p>
<strong>Module</strong> and <strong>Function</strong> are atoms
(encoded using <a href="#ATOM_EXT">ATOM_EXT</a>, 
<a href="#SMALL_ATOM_EXT">SMALL_ATOM_EXT</a>, or
<a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a>).
</p><p>
<strong>Arity</strong> is an integer encoded using
<a href="#SMALL_INTEGER_EXT">SMALL_INTEGER_EXT</a>.
</p><a name="BIT_BINARY_EXT"></a><h4>BIT_BINARY_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>BIT_BINARY_EXT</caption><tbody><tr><td>1</td><td>4</td><td>1</td><td>Len</td></tr><tr><td><strong>77</strong></td><td><strong>Len</strong></td><td><strong>Bits</strong></td><td><strong>Data</strong></td></tr></tbody></table><p>
This term represents a bitstring whose length in bits does
not have to be a multiple of 8.
The <strong>Len</strong> field is an unsigned 4 byte integer (big-endian).
The <strong>Bits</strong> field is the number of bits (1-8) that are used
in the last byte in the data field,
counting from the most significant bit to the least significant.
</p><a name="NEW_FLOAT_EXT"></a><h4>NEW_FLOAT_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>NEW_FLOAT_EXT</caption><tbody><tr><td>1</td><td>8</td></tr><tr><td><strong>70</strong></td><td><strong>IEEE float</strong></td></tr></tbody></table><p>
A finite float (i.e. not inf, -inf or NaN) is stored as 8 bytes
in big-endian IEEE format.
</p><p>
This term is used in minor version 1 of the external format.
</p><a name="ATOM_UTF8_EXT"></a><h4>ATOM_UTF8_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>ATOM_UTF8_EXT</caption><tbody><tr><td>1</td><td>2</td><td>Len</td></tr><tr><td><strong>118</strong></td><td><strong>Len</strong></td><td><strong>AtomName</strong></td></tr></tbody></table><p>
An atom is stored with a 2 byte unsigned length in big-endian order,
followed by <strong>Len</strong> bytes containing the <strong>AtomName</strong> encoded
in UTF-8.
</p><p>
For more information on encoding of atoms, see the
<a href="#utf8_atoms">note on UTF-8 encoded atoms</a>
in the beginning of this section.
</p><a name="SMALL_ATOM_UTF8_EXT"></a><h4>SMALL_ATOM_UTF8_EXT</h4><table class="table table-bordered table-hover table-striped"><caption>SMALL_ATOM_UTF8_EXT</caption><tbody><tr><td>1</td><td>1</td><td>Len</td></tr><tr><td><strong>119</strong></td><td><strong>Len</strong></td><td><strong>AtomName</strong></td></tr></tbody></table><p>
An atom is stored with a 1 byte unsigned length,
followed by <strong>Len</strong> bytes containing the <strong>AtomName</strong> encoded
in UTF-8. Longer atoms encoded in UTF-8 can be represented using
<a href="#ATOM_UTF8_EXT">ATOM_UTF8_EXT</a>.
</p><p>
For more information on encoding of atoms, see the
<a href="#utf8_atoms">note on UTF-8 encoded atoms</a>
in the beginning of this section.
</p><a name="ATOM_EXT"></a><h4>ATOM_EXT (deprecated)</h4><table class="table table-bordered table-hover table-striped"><caption>ATOM_EXT</caption><tbody><tr><td>1</td><td>2</td><td>Len</td></tr><tr><td><strong>100</strong></td><td><strong>Len</strong></td><td><strong>AtomName</strong></td></tr></tbody></table><p>
An atom is stored with a 2 byte unsigned length in big-endian order,
followed by <strong>Len</strong> numbers of 8-bit Latin-1 characters that forms
the <strong>AtomName</strong>. The maximum allowed value for <strong>Len</strong> is 255.
</p><a name="SMALL_ATOM_EXT"></a><h4>SMALL_ATOM_EXT (deprecated)</h4><table class="table table-bordered table-hover table-striped"><caption>SMALL_ATOM_EXT</caption><tbody><tr><td>1</td><td>1</td><td>Len</td></tr><tr><td><strong>115</strong></td><td><strong>Len</strong></td><td><strong>AtomName</strong></td></tr></tbody></table><p>
An atom is stored with a 1 byte unsigned length,
followed by <strong>Len</strong> numbers of 8-bit Latin-1 characters that
forms the <strong>AtomName</strong>.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
<strong>SMALL_ATOM_EXT</strong> was introduced in ERTS 5.7.2 and
require an exchange of distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a> in the
<a href="./erl_dist_protocol#distribution_handshake"> distribution handshake</a>.
</p></div><p>This description is far from complete. It will be updated if the
protocol is updated. However, the protocols, both from Erlang
nodes to the Erlang Port Mapper Daemon (EPMD) and between Erlang nodes
are stable since many years.</p><p>The distribution protocol can be divided into four parts:</p><ul><li> <p>Low-level socket connection (1)</p> </li><li> <p>Handshake, interchange node name, and authenticate (2)</p> </li><li> <p>Authentication (done by <a href="./net_kernel">kernel/net_kernel</a>) (3)</p> </li><li> <p>Connected (4)</p>  </li></ul><p>A node fetches the port number of another node through the EPMD (at the
other host) to initiate a connection request.</p><p>For each host, where a distributed Erlang node is running, also an EPMD
is to be running. The EPMD can be started explicitly or automatically
as a result of the Erlang node startup.</p><p>By default the EPMD listens on port 4369.</p><p>(3) and (4) above are performed at the same level but the <strong>net_kernel</strong>
disconnects the other node if it communicates using an invalid cookie (after
1 second).</p><p>The integers in all multibyte fields are in big-endian order.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>
The Erlang Distribution protocol is not by itself secure and does not
aim to be so. In order to get secure distribution the distributed nodes
should be configured to use distribution over tls.
See the <a href="./ssl_distribution"> Using SSL for Erlang Distribution</a> User's Guide
for details on how to setup a secure distributed node.
</p></div><h4>EPMD Protocol</h4><p>The requests served by the EPMD are summarized in the following
figure.</p><img src="erl_ext_fig.gif" title="Summary of EPMD Requests"></img><p>Each request <strong>*_REQ</strong> is preceded by a 2 byte length field.
Thus, the overall request format is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>Request Format</caption><tbody><tr><td>2</td><td>n</td></tr><tr><td><strong>Length</strong></td><td><strong>Request</strong></td></tr></tbody></table><h4>Register a Node in EPMD</h4><p>When a distributed node is started it registers itself in the EPMD.
The message <strong>ALIVE2_REQ</strong> described below is sent from the node to
the EPMD. The response from the EPMD is <strong>ALIVE2_RESP</strong>.</p><table class="table table-bordered table-hover table-striped"><caption>ALIVE2_REQ (120)</caption><tbody><tr><td>1</td><td>2</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>Nlen</td><td>2</td><td>Elen</td></tr><tr><td><strong>120</strong></td><td><strong>PortNo</strong></td><td><strong>NodeType</strong></td><td><strong>Protocol</strong></td><td><strong>HighestVersion</strong></td><td><strong>LowestVersion</strong></td><td><strong>Nlen</strong></td><td><strong>NodeName</strong></td><td><strong>Elen</strong></td><td><strong>Extra</strong></td></tr></tbody></table><dl><dt><strong>PortNo</strong></dt><dd> <p>The port number on which the node accept connection requests.</p> </dd><dt><strong>NodeType</strong></dt><dd> <p>77 = normal Erlang node, 72 = hidden node (C-node), ...</p> </dd><dt><strong>Protocol</strong></dt><dd> <p>0 = TCP/IPv4, ...</p> </dd><dt><strong>HighestVersion</strong></dt><dd> <p>The highest distribution version that this node can handle.
The value in Erlang/OTP R6B and later is 5.</p> </dd><dt><strong>LowestVersion</strong></dt><dd> <p>The lowest distribution version that this node can handle.
The value in Erlang/OTP R6B and later is 5.</p> </dd><dt><strong>Nlen</strong></dt><dd> <p>The length (in bytes) of field <strong>NodeName</strong>.</p> </dd><dt><strong>NodeName</strong></dt><dd> <p>The node name as an UTF-8 encoded string of <strong>Nlen</strong> bytes.</p> </dd><dt><strong>Elen</strong></dt><dd> <p>The length of field <strong>Extra</strong>.</p> </dd><dt><strong>Extra</strong></dt><dd> <p>Extra field of <strong>Elen</strong> bytes.</p> </dd></dl><p>The connection created to the EPMD must be kept as long as the
node is a distributed node. When the connection is closed,
the node is automatically unregistered from the EPMD.</p><p>The response message <strong>ALIVE2_RESP</strong> is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>ALIVE2_RESP (121)</caption><tbody><tr><td>1</td><td>1</td><td>2</td></tr><tr><td><strong>121</strong></td><td><strong>Result</strong></td><td><strong>Creation</strong></td></tr></tbody></table><p>Result = 0 -&gt; ok, result &gt; 0 -&gt; error.</p><h4>Unregister a Node from EPMD</h4><p>A node unregisters itself from the EPMD by closing the TCP
connection to EPMD established when the node was registered.</p><h4>Get the Distribution Port of Another Node</h4><p>When one node wants to connect to another node it starts with
a <strong>PORT_PLEASE2_REQ</strong> request to the EPMD on the host where the
node resides to get the distribution port that the node listens to.</p><table class="table table-bordered table-hover table-striped"><caption>PORT_PLEASE2_REQ (122)</caption><tbody><tr><td>1</td><td>N</td></tr><tr><td><strong>122</strong></td><td><strong>NodeName</strong></td></tr></tbody></table><p>where N = <strong>Length</strong> - 1.</p><table class="table table-bordered table-hover table-striped"><caption>PORT2_RESP (119) Response Indicating Error, Result > 0
</caption><tbody><tr><td>1</td><td>1</td></tr><tr><td><strong>119</strong></td><td><strong>Result</strong></td></tr></tbody></table><p>or</p><table class="table table-bordered table-hover table-striped"><caption>PORT2_RESP, Result = 0</caption><tbody><tr><td>1</td><td>1</td><td>2</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>Nlen</td><td>2</td><td>Elen</td></tr><tr><td><strong>119</strong></td><td><strong>Result</strong></td><td><strong>PortNo</strong></td><td><strong>NodeType</strong></td><td><strong>Protocol</strong></td><td><strong>HighestVersion</strong></td><td><strong>LowestVersion</strong></td><td><strong>Nlen</strong></td><td><strong>NodeName</strong></td><td><strong>Elen</strong></td><td>&gt;<strong>Extra</strong></td></tr></tbody></table><p>If <strong>Result</strong> &gt; 0, the packet only consists of
<strong>[119, Result]</strong>.</p><p>The EPMD closes the socket when it has sent the information.</p><h4>Get All Registered Names from EPMD</h4><p>This request is used through the Erlang function
<a href="../kernel/net_adm#names/1,2">kernel/net_adm#names/1,2</a>. A TCP connection is opened
to the  EPMD and this request is sent.</p><table class="table table-bordered table-hover table-striped"><caption>NAMES_REQ (110)</caption><tbody><tr><td>1</td></tr><tr><td><strong>110</strong></td></tr></tbody></table><p>The response for a <strong>NAMES_REQ</strong> is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>NAMES_RESP</caption><tbody><tr><td>4</td><td>Â </td></tr><tr><td><strong>EPMDPortNo</strong></td><td><strong>NodeInfo*</strong></td></tr></tbody></table><p><strong>NodeInfo</strong> is a string written for each active node.
When all <strong>NodeInfo</strong> has been written the connection is
closed by the EPMD.</p><p><strong>NodeInfo</strong> is, as expressed in Erlang:</p><pre><code class="">
io:format("name ~ts at port ~p~n", [NodeName, Port]).</code></pre><h4>Dump All Data from EPMD</h4><p>This request is not really used, it is to be regarded as a debug
feature.</p><table class="table table-bordered table-hover table-striped"><caption>DUMP_REQ</caption><tbody><tr><td>1</td></tr><tr><td><strong>100</strong></td></tr></tbody></table><p>The response for a <strong>DUMP_REQ</strong> is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>DUMP_RESP</caption><tbody><tr><td>4</td><td>Â </td></tr><tr><td><strong>EPMDPortNo</strong></td><td><strong>NodeInfo*</strong></td></tr></tbody></table><p><strong>NodeInfo</strong> is a string written for each node kept in the EPMD.
When all <strong>NodeInfo</strong> has been written the connection is
closed by the EPMD.</p><p><strong>NodeInfo</strong> is, as expressed in Erlang:</p><pre><code class="">
io:format("active name     ~ts at port ~p, fd = ~p~n",
          [NodeName, Port, Fd]).</code></pre><p>or</p><pre><code class="">
io:format("old/unused name ~ts at port ~p, fd = ~p ~n",
          [NodeName, Port, Fd]).</code></pre><h4>Kill EPMD</h4><p>This request kills the running EPMD. It is almost never used.</p><table class="table table-bordered table-hover table-striped"><caption>KILL_REQ</caption><tbody><tr><td>1</td></tr><tr><td><strong>107</strong></td></tr></tbody></table><p>The response for a <strong>KILL_REQ</strong> is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>KILL_RESP</caption><tbody><tr><td>2</td></tr><tr><td><strong>OKString</strong></td></tr></tbody></table><p>where <strong>OKString</strong> is "OK".</p><h4>STOP_REQ  (Not Used)</h4><table class="table table-bordered table-hover table-striped"><caption>STOP_REQ</caption><tbody><tr><td>1</td><td>n</td></tr><tr><td><strong>115</strong></td><td><strong>NodeName</strong></td></tr></tbody></table><p>where n = <strong>Length</strong> - 1.</p><p>The current implementation of Erlang does not care if the connection
to the EPMD is broken.</p><p>The response for a <strong>STOP_REQ</strong> is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>STOP_RESP</caption><tbody><tr><td>7</td></tr><tr><td><strong>OKString</strong></td></tr></tbody></table><p>where <strong>OKString</strong> is "STOPPED".</p><p>A negative response can look as follows:</p><table class="table table-bordered table-hover table-striped"><caption>STOP_NOTOK_RESP</caption><tbody><tr><td>7</td></tr><tr><td><strong>NOKString</strong></td></tr></tbody></table><p>where <strong>NOKString</strong> is "NOEXIST".</p><a name="distribution_handshake"></a><h4>Distribution Handshake</h4><p>This section describes the distribution handshake protocol introduced
in Erlang/OTP R6. The handshake has remained almost the same since then.</p><h4>General</h4><p>The TCP/IP distribution uses a handshake that expects a
connection-based protocol, that is, the protocol does not include any
authentication after the handshake procedure.</p><p>This is not entirely safe, as it is vulnerable against takeover
attacks, but it is a tradeoff between fair safety and performance.</p><p>The cookies are never sent in cleartext and the handshake procedure
expects the client (called <strong>A</strong>) to be the first one to prove that
it can generate a sufficient digest. The digest is generated with the
MD5 message digest algorithm and the challenges are expected to be
random numbers.</p><h4>Definitions</h4><p>A challenge is a 32-bit integer in big-endian order. Below the function
<strong>gen_challenge()</strong> returns a random 32-bit integer used as a
challenge.</p><p>A digest is a (16 bytes) MD5 hash of the challenge (as text)
concatenated with the cookie (as text). Below, the function
<strong>gen_digest(Challenge, Cookie)</strong> generates a digest as described
above.</p><p>An <strong>out_cookie</strong> is the cookie used in outgoing communication to a
certain node, so that <strong>A</strong>'s <strong>out_cookie</strong> for <strong>B</strong> is to
correspond with <strong>B</strong>'s <strong>in_cookie</strong> for <strong>A</strong> and conversely.
<strong>A</strong>'s <strong>out_cookie</strong> for <strong>B</strong> and <strong>A</strong>'s
<strong>in_cookie</strong> for <strong>B</strong> need <em>not</em> be the same. Below the
function <strong>out_cookie(Node)</strong> returns the current node's
<strong>out_cookie</strong> for <strong>Node</strong>.</p><p>An <strong>in_cookie</strong> is the cookie expected to be used by another node
when communicating with us, so that <strong>A</strong>'s <strong>in_cookie</strong> for
<strong>B</strong> corresponds with <strong>B</strong>'s <strong>out_cookie</strong> for <strong>A</strong>.
Below the function <strong>in_cookie(Node)</strong> returns the current node's
<strong>in_cookie</strong> for <strong>Node</strong>.</p><p>The cookies are text strings that can be viewed as passwords.</p><p>Every message in the handshake starts with a 16-bit big-endian integer,
which contains the message length (not counting the two initial bytes).
In Erlang this corresponds to option <strong>{packet, 2}</strong> in
<a href="./gen_tcp">kernel/gen_tcp</a>.
Notice that after the handshake, the distribution switches to 4 byte
packet headers.</p><h4>The Handshake in Detail</h4><p>Imagine two nodes, <strong>A</strong> that initiates the handshake and <strong>B</strong>
that accepts the connection.</p><dl><dt>1) connect/accept</dt><dd> <p><strong>A</strong> connects to <strong>B</strong> through TCP/IP and <strong>B</strong> accepts
the connection.</p> </dd><dt>2) <strong>send_name</strong>/<strong>receive_name</strong></dt><dd> <p><strong>A</strong> sends an initial identification to <strong>B</strong>, which
receives the message. The message looks as follows (every "square"
is one byte and the packet header is removed):</p> <pre>
+---+--------+--------+-----+-----+-----+-----+-----+-----+-...-+-----+
|'n'|Version0|Version1|Flag0|Flag1|Flag2|Flag3|Name0|Name1| ... |NameN|
+---+--------+--------+-----+-----+-----+-----+-----+-----+-... +-----+</pre> <p>'n' is the message tag. 'Version0' and 'Version1' is the
distribution version selected by <strong>A</strong>, based on information
from the EPMD. (16-bit big-endian) 'Flag0' ... 'Flag3' are
capability flags, the capabilities are defined in
<strong>$ERL_TOP/lib/kernel/include/dist.hrl</strong>. (32-bit big-endian)
'Name0' ... 'NameN' is the full node name of <strong>A</strong>, as a string
of bytes (the packet length denotes how long it is).</p> </dd><dt>3) <strong>recv_status</strong>/<strong>send_status</strong></dt><dd> <p><strong>B</strong> sends a status message to <strong>A</strong>, which indicates if the
connection is allowed. The following status codes are defined:</p> <dl><dt><strong>ok</strong></dt><dd> <p>The handshake will continue.</p> </dd><dt><strong>ok_simultaneous</strong></dt><dd> <p>The handshake will continue, but <strong>A</strong> is informed that
<strong>B</strong> has another ongoing connection attempt that will be
shut down (simultaneous connect where <strong>A</strong>'s name is
greater than <strong>B</strong>'s name, compared literally).</p> </dd><dt><strong>nok</strong></dt><dd> <p>The handshake will not continue, as <strong>B</strong> already has an
ongoing handshake, which it itself has initiated (simultaneous
connect where <strong>B</strong>'s name is greater than <strong>A</strong>'s).</p> </dd><dt><strong>not_allowed</strong></dt><dd> <p>The connection is disallowed for some (unspecified) security
reason.</p> </dd><dt><strong>alive</strong></dt><dd> <p>A connection to the node is already active, which either means
that node <strong>A</strong> is confused or that the TCP connection
breakdown of a previous node with this name has not yet reached
node <strong>B</strong>. See step 3B below.</p> </dd></dl> <p>The format of the status message is as follows:</p> <pre>
+---+-------+-------+-...-+-------+
|'s'|Status0|Status1| ... |StatusN|
+---+-------+-------+-...-+-------+</pre> <p>'s' is the message tag. 'Status0' ... 'StatusN' is the status as a
string (not terminated).</p> </dd><dt>3B) <strong>send_status</strong>/<strong>recv_status</strong></dt><dd> <p>If status was <strong>alive</strong>, node <strong>A</strong> answers with another
status message containing either <strong>true</strong>, which means that the
connection is to continue (the old connection from this node is
broken), or <strong>false</strong>, which means that the connection is to be
closed (the connection attempt was a mistake.</p> </dd><dt>4) <strong>recv_challenge</strong>/<strong>send_challenge</strong></dt><dd> <p>If the status was <strong>ok</strong> or <strong>ok_simultaneous</strong>, the
handshake continues with <strong>B</strong> sending <strong>A</strong> another message,
the challenge. The challenge contains the same type of information
as the "name" message initially sent from <strong>A</strong> to <strong>B</strong>, plus
a 32-bit challenge:</p> <pre>
+---+--------+--------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-...-+-----+
|'n'|Version0|Version1|Flag0|Flag1|Flag2|Flag3|Chal0|Chal1|Chal2|Chal3|Name0|Name1| ... |NameN|
+---+--------+--------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-... +-----+</pre> <p>'Chal0' ... 'Chal3' is the challenge as a 32-bit big-endian integer
and the other fields are <strong>B</strong>'s version, flags, and full node
name.</p> </dd><dt>5) <strong>send_challenge_reply</strong>/<strong>recv_challenge_reply</strong></dt><dd> <p>Now <strong>A</strong> has generated a digest and its own challenge. Those
are sent together in a package to <strong>B</strong>:</p> <pre>
+---+-----+-----+-----+-----+-----+-----+-----+-----+-...-+------+
|'r'|Chal0|Chal1|Chal2|Chal3|Dige0|Dige1|Dige2|Dige3| ... |Dige15|
+---+-----+-----+-----+-----+-----+-----+-----+-----+-...-+------+</pre> <p>'r' is the tag. 'Chal0' ... 'Chal3' is <strong>A</strong>'s challenge for
<strong>B</strong> to handle. 'Dige0' ... 'Dige15' is the digest that <strong>A</strong>
constructed from the challenge <strong>B</strong> sent in the previous
step.</p> </dd><dt>6) <strong>recv_challenge_ack</strong>/<strong>send_challenge_ack</strong></dt><dd> <p><strong>B</strong> checks that the digest received from <strong>A</strong> is correct
and generates a digest from the challenge received from <strong>A</strong>.
The digest is then sent to <strong>A</strong>. The message is as follows:</p> <pre>
+---+-----+-----+-----+-----+-...-+------+
|'a'|Dige0|Dige1|Dige2|Dige3| ... |Dige15|
+---+-----+-----+-----+-----+-...-+------+</pre> <p>'a' is the tag. 'Dige0' ... 'Dige15' is the digest calculated by
<strong>B</strong> for <strong>A</strong>'s challenge.</p> </dd><dt>7) check</dt><dd> <p><strong>A</strong> checks the digest from <strong>B</strong> and the connection is
up.</p> </dd></dl><h4>Semigraphic View</h4><pre>
A (initiator)                                      B (acceptor)

TCP connect ------------------------------------&gt;
                                                   TCP accept

send_name --------------------------------------&gt;
                                                   recv_name

  &lt;---------------------------------------------- send_status
recv_status
(if status was 'alive'
 send_status - - - - - - - - - - - - - - - - - -&gt;
                                                   recv_status)
                                                   ChB = gen_challenge()
                          (ChB)
  &lt;---------------------------------------------- send_challenge
recv_challenge
ChA = gen_challenge(),
OCA = out_cookie(B),
DiA = gen_digest(ChB, OCA)
                          (ChA, DiA)
send_challenge_reply ---------------------------&gt;
                                                   recv_challenge_reply
                                                   ICB = in_cookie(A),
                                                   check:
                                                   DiA == gen_digest (ChB, ICB)?
                                                   - if OK:
                                                    OCB = out_cookie(A),
                                                    DiB = gen_digest (ChA, OCB)
                          (DiB)
  &lt;----------------------------------------------- send_challenge_ack
recv_challenge_ack                                  DONE
ICA = in_cookie(B),                                - else:
check:                                              CLOSE
DiB == gen_digest(ChA, ICA)?
- if OK:
 DONE
- else:
 CLOSE</pre><a name="dflags"></a><h4>Distribution Flags</h4><p>The following capability flags are defined:</p><dl><dt><strong>-define(DFLAG_PUBLISHED,16#1).</strong></dt><dd> <p>The node is to be published and part of the global namespace.</p> </dd><dt><strong>-define(DFLAG_ATOM_CACHE,16#2).</strong></dt><dd> <p>The node implements an atom cache (obsolete).</p> </dd><dt><strong>-define(DFLAG_EXTENDED_REFERENCES,16#4).</strong></dt><dd> <p>The node implements extended (3 Ã 32 bits) references. This
is required today. If not present, the  connection is refused.</p> </dd><dt><strong>-define(DFLAG_DIST_MONITOR,16#8).</strong></dt><dd> <p>The node implements distributed process monitoring.</p> </dd><dt><strong>-define(DFLAG_FUN_TAGS,16#10).</strong></dt><dd> <p>The node uses separate tag for funs (lambdas) in the distribution
protocol.</p> </dd><dt><strong>-define(DFLAG_DIST_MONITOR_NAME,16#20).</strong></dt><dd> <p>The node implements distributed named process monitoring.</p> </dd><dt><strong>-define(DFLAG_HIDDEN_ATOM_CACHE,16#40).</strong></dt><dd> <p>The (hidden) node implements atom cache (obsolete).</p> </dd><dt><strong>-define(DFLAG_NEW_FUN_TAGS,16#80).</strong></dt><dd> <p>The node understand new fun tags.</p> </dd><dt><strong>-define(DFLAG_EXTENDED_PIDS_PORTS,16#100).</strong></dt><dd> <p>The node can handle extended pids and ports. This is required
today. If not present, the connection is refused.</p> </dd><dt><strong>-define(DFLAG_EXPORT_PTR_TAG,16#200).</strong></dt><dd> </dd><dt><strong>-define(DFLAG_BIT_BINARIES,16#400).</strong></dt><dd> </dd><dt><strong>-define(DFLAG_NEW_FLOATS,16#800).</strong></dt><dd> <p>The node understands new float format.</p> </dd><dt><strong>-define(DFLAG_UNICODE_IO,16#1000).</strong></dt><dd> </dd><dt><strong>-define(DFLAG_DIST_HDR_ATOM_CACHE,16#2000).</strong></dt><dd> <p>The node implements atom cache in distribution header.</p> </dd><dt><strong>-define(DFLAG_SMALL_ATOM_TAGS, 16#4000).</strong></dt><dd> <p>The node understand the <strong>SMALL_ATOM_EXT</strong> tag.</p> </dd><dt><strong>-define(DFLAG_UTF8_ATOMS, 16#10000).</strong></dt><dd> <p>The node understand UTF-8 encoded atoms.</p> </dd><dt><strong>-define(DFLAG_MAP_TAG, 16#20000).</strong></dt><dd> <p>The node understand the map tag.</p> </dd><dt><strong>-define(DFLAG_BIG_CREATION, 16#40000).</strong></dt><dd> <p>The node understand big node creation.</p> </dd><dt><strong>-define(DFLAG_SEND_SENDER, 16#80000).</strong></dt><dd> <p>
Use the <strong>SEND_SENDER</strong>
<a href="#control_message">control message</a>
instead of the <strong>SEND</strong> control message and use the
<strong>SEND_SENDER_TT</strong> control message instead
of the <strong>SEND_TT</strong> control message.
</p> </dd><dt><strong>-define(DFLAG_BIG_SEQTRACE_LABELS, 16#100000).</strong></dt><dd> <p>The node understands any term as the seqtrace label.</p> </dd><dt><strong>-define(DFLAG_EXIT_PAYLOAD, 16#400000).</strong></dt><dd> <p>Use the <strong>PAYLOAD_EXIT</strong>, <strong>PAYLOAD_EXIT_TT</strong>,
<strong>PAYLOAD_EXIT2</strong>, <strong>PAYLOAD_EXIT2_TT</strong>
and <strong>PAYLOAD_MONITOR_P_EXIT</strong>
<a href="#control_message">control message</a>s
instead of the non-PAYLOAD variants.</p> </dd><dt><strong>-define(DFLAG_FRAGMENTS, 16#800000).</strong></dt><dd> <p>Use <a href="./erl_ext_dist#fragments">fragmented</a>
distribution messages to send large messages.</p> </dd></dl><p>
There is also function <strong>dist_util:strict_order_flags/0</strong>
returning all flags (bitwise or:ed together) corresponding to features
that require strict ordering of data over distribution channels.
</p><a name="connected_nodes"></a><h4>Protocol between Connected Nodes</h4><p>Since ERTS 5.7.2 (OTP R13B) the runtime system passes a distribution flag
in the handshake stage that enables the use of a
<a href="./erl_ext_dist#distribution_header">distribution header </a> on all messages passed. Messages passed between nodes have in
this case the following format:</p><table class="table table-bordered table-hover table-striped"><caption>Format of Messages Passed between Nodes (as from ERTS 5.7.2 (OTP R13B))
</caption><tbody><tr><td>4</td><td>d</td><td>n</td><td>m</td></tr><tr><td><strong>Length</strong></td><td><strong>DistributionHeader</strong></td><td><strong>ControlMessage</strong></td><td><strong>Message</strong></td></tr></tbody></table><dl><dt><strong>Length</strong></dt><dd> <p>Equal to d + n + m.</p> </dd><dt><strong>DistributionHeader</strong></dt><dd> <p>
<a href="./erl_ext_dist#distribution_header">Distribution header describing the atom cache and fragmented distribution messages. </a>
</p> </dd><dt><strong>ControlMessage</strong></dt><dd> <p>A tuple passed using the external format of Erlang.</p> </dd><dt><strong>Message</strong></dt><dd> <p>The message sent to another node using the '!'
or the reason for a EXIT, EXIT2 or DOWN signal using
the external term format.</p> </dd></dl><p>Notice that <a href="./erl_ext_dist#overall_format">the version number is omitted from the terms that follow a distribution header </a>.</p><p>Nodes with an ERTS version earlier than 5.7.2 (OTP R13B) does not pass the
distribution flag that enables the distribution header. Messages passed
between nodes have in this case the following format:</p><table class="table table-bordered table-hover table-striped"><caption>Format of Messages Passed between Nodes (before ERTS 5.7.2 (OTP R13B))
</caption><tbody><tr><td>4</td><td>1</td><td>n</td><td>m</td></tr><tr><td><strong>Length</strong></td><td><strong>Type</strong></td><td><strong>ControlMessage</strong></td><td><strong>Message</strong></td></tr></tbody></table><dl><dt><strong>Length</strong></dt><dd> <p>Equal to 1 + n + m.</p> </dd><dt><strong>Type</strong></dt><dd> <p>Equal to <strong>112</strong> (pass through).</p> </dd><dt><strong>ControlMessage</strong></dt><dd> <p>A tuple passed using the external format of Erlang.</p> </dd><dt><strong>Message</strong></dt><dd> <p>The message sent to another node using the '!' (in external format).
Notice that <strong>Message</strong> is only passed in combination with a
<strong>ControlMessage</strong> encoding a send ('!').</p> </dd></dl><a name="control_message"></a><p>The <strong>ControlMessage</strong> is a tuple, where the first element indicates
which distributed operation it encodes:</p><dl><dt><strong>LINK</strong></dt><dd> <p><strong>{1, FromPid, ToPid}</strong></p> </dd><dt><strong>SEND</strong></dt><dd> <p><strong>{2, Unused, ToPid}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p><strong>Unused</strong> is kept for backward compatibility.</p> </dd><dt><strong>EXIT</strong></dt><dd> <p><strong>{3, FromPid, ToPid, Reason}</strong></p> <p>This signal is sent when a link has been broken</p> </dd><dt><strong>UNLINK</strong></dt><dd> <p><strong>{4, FromPid, ToPid}</strong></p> </dd><dt><strong>NODE_LINK</strong></dt><dd> <p><strong>{5}</strong></p> </dd><dt><strong>REG_SEND</strong></dt><dd> <p><strong>{6, FromPid, Unused, ToName}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p><strong>Unused</strong> is kept for backward compatibility.</p> </dd><dt><strong>GROUP_LEADER</strong></dt><dd> <p><strong>{7, FromPid, ToPid}</strong></p> </dd><dt><strong>EXIT2</strong></dt><dd> <p><strong>{8, FromPid, ToPid, Reason}</strong></p> <p>This signal is sent by a call to the erlang:exit/2 bif</p> </dd></dl><h4>New Ctrlmessages for distrvsn = 1 (Erlang/OTP R4)</h4><dl><dt><strong>SEND_TT</strong></dt><dd> <p><strong>{12, Unused, ToPid, TraceToken}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p><strong>Unused</strong> is kept for backward compatibility.</p> </dd><dt><strong>EXIT_TT</strong></dt><dd> <p><strong>{13, FromPid, ToPid, TraceToken, Reason}</strong></p> </dd><dt><strong>REG_SEND_TT</strong></dt><dd> <p><strong>{16, FromPid, Unused, ToName, TraceToken}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p><strong>Unused</strong> is kept for backward compatibility.</p> </dd><dt><strong>EXIT2_TT</strong></dt><dd> <p><strong>{18, FromPid, ToPid, TraceToken, Reason}</strong></p> </dd></dl><h4>New Ctrlmessages for distrvsn = 2</h4><p><strong>distrvsn</strong> 2 was never used.</p><h4>New Ctrlmessages for distrvsn = 3 (Erlang/OTP R5C)</h4><p>None, but the version number was increased anyway.</p><h4>New Ctrlmessages for distrvsn = 4 (Erlang/OTP R6)</h4><p>These are only recognized by Erlang nodes, not by hidden nodes.</p><dl><dt><strong>MONITOR_P</strong></dt><dd> <p><strong>{19, FromPid, ToProc, Ref}</strong>, where
<strong>FromPid</strong> = monitoring process and
<strong>ToProc</strong> = monitored process pid or name (atom)</p> </dd><dt><strong>DEMONITOR_P</strong></dt><dd> <p><strong>{20, FromPid, ToProc, Ref}</strong>, where
<strong>FromPid</strong> = monitoring process and
<strong>ToProc</strong> = monitored process pid or name (atom)</p> <p>We include <strong>FromPid</strong> just in case we want to trace this.</p> </dd><dt><strong>MONITOR_P_EXIT</strong></dt><dd> <p><strong>{21, FromProc, ToPid, Ref, Reason}</strong>, where
<strong>FromProc</strong> = monitored process pid or name (atom),
<strong>ToPid</strong> = monitoring process, and
<strong>Reason</strong> = exit reason for the monitored process</p> </dd></dl><h4>New Ctrlmessages for Erlang/OTP 21</h4><dl><dt><strong>SEND_SENDER</strong></dt><dd> <p><strong>{22, FromPid, ToPid}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p>
This control message replaces the <strong>SEND</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Messages encoded before the connection has
been set up may still use the <strong>SEND</strong> control
message. However, once a <strong>SEND_SENDER</strong> or <strong>SEND_SENDER_TT</strong>
control message has been sent, no more <strong>SEND</strong>
control messages will be sent in the same direction
on the connection.
</p></div> </dd><dt><strong>SEND_SENDER_TT</strong></dt><dd> <p><strong>{23, FromPid, ToPid, TraceToken}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p>
This control message replaces the <strong>SEND_TT</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Messages encoded before the connection has
been set up may still use the <strong>SEND_TT</strong> control
message. However, once a <strong>SEND_SENDER</strong> or <strong>SEND_SENDER_TT</strong>
control message has been sent, no more <strong>SEND_TT</strong>
control messages will be sent in the same direction
on the connection.
</p></div> </dd></dl><h4>New Ctrlmessages for Erlang/OTP 22</h4><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Messages encoded before the connection has
been set up may still use the non-PAYLOAD variant.
However, once a PAYLOAD control message has been sent,
no more non-PAYLOAD control messages will be sent in
the same direction on the connection.
</p></div><dl><dt><strong>PAYLOAD_EXIT</strong></dt><dd> <p><strong>{24, FromPid, ToPid}</strong></p> <p>Followed by <strong>Reason</strong>.</p> <p>
This control message replaces the <strong>EXIT</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> </dd><dt><strong>PAYLOAD_EXIT_TT</strong></dt><dd> <p><strong>{25, FromPid, ToPid}</strong></p> <p>Followed by <strong>Reason</strong>.</p> <p>
This control message replaces the <strong>EXIT_TT</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> </dd><dt><strong>PAYLOAD_EXIT2</strong></dt><dd> <p><strong>{26, FromPid, ToPid}</strong></p> <p>Followed by <strong>Reason</strong>.</p> <p>
This control message replaces the <strong>EXIT2</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> </dd><dt><strong>PAYLOAD_EXIT2_TT</strong></dt><dd> <p><strong>{27, FromPid, ToPid}</strong></p> <p>Followed by <strong>Reason</strong>.</p> <p>
This control message replaces the <strong>EXIT2_TT</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> </dd><dt><strong>PAYLOAD_MONITOR_P_EXIT</strong></dt><dd> <p><strong>{28, FromPid, ToPid, Ref}</strong></p> <p>Followed by <strong>Reason</strong>.</p> <p>
This control message replaces the <strong>MONITOR_P_EXIT</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> </dd></dl><h3>atomics</h3><p>Atomic Functions</p><p>This module provides a set of functions to do atomic operations towards
mutable atomic variables. The implementation utilizes only
atomic hardware instructions without any software level locking, which makes
it very efficient for concurrent access. The atomics are organized into
arrays with the following semantics:<ul><li> <p>Atomics are 64 bit integers.</p> </li><li> <p>Atomics can be represented as either signed or unsigned.</p> </li><li> <p>Atomics wrap around at overflow and underflow operations.</p> </li><li> <p>All operations guarantee atomicity. No intermediate results can be
seen. The result of one mutation can only be the input to one
following mutation.</p> </li><li> <p>All atomic operations are mutually ordered. If atomic B is updated
<em>after</em> atomic A, then that is how it will appear to any
concurrent readers. No one can read the new value of B and then read the
old value of A.</p> </li><li> <p>Indexes into atomic arrays are one-based. An atomic array of
arity N contains N atomics with index from 1 to N.</p> </li></ul></p><h3>Data Types</h3><span class="name">atomics_ref</span><p>Identifies an atomic array returned from
<a href="#new/2">new/2</a>.</p><h3>Functions</h3><h4>new/2</h4><p>Create atomic array</p><p>Create a new atomic array of <strong><span class="anno">Arity</span></strong> atomics.</p><p>Argument <strong><span class="anno">Opts</span></strong> is a list of the following possible
options:</p><dl><dt><strong>{signed, boolean()}</strong></dt><dd><p>Indicate if the elements of the array will be treated
as signed or unsigned integers. Default is <strong>true</strong> (signed).</p> <p>The integer interval for signed atomics are from <strong>-(1 bsl 63)</strong>
to <strong>(1 bsl 63)-1</strong> and for unsigned atomics from <strong>0</strong> to <strong>(1 bsl 64)-1</strong>.</p> </dd></dl><p>Atomics are not tied to the current process and are automatically
garbage collected when they are no longer referenced.</p><h4>put/3</h4><p>Set atomic value</p><p>Set atomic to <strong><span class="anno">Value</span></strong>.</p><h4>get/2</h4><p>Read atomic value</p><p>Read atomic value.</p><h4>add/3</h4><p>Add to atomic</p><p>Add <strong><span class="anno">Incr</span></strong> to atomic.</p><h4>add_get/3</h4><p>Atomic add and get</p><p>Atomic addition and return of the result.</p><h4>sub/3</h4><p>Subtract from atomic</p><p>Subtract <strong><span class="anno">Decr</span></strong> from atomic.</p><h4>sub_get/3</h4><p>Atomic sub and get</p><p>Atomic subtraction and return of the result.</p><h4>exchange/3</h4><p>Atomic exchange.</p><p>Atomically replaces the value of the atomic with
<strong><span class="anno">Desired</span></strong> and returns the value it held
previously.</p><h4>compare_exchange/4</h4><p>Atomic compare and exchange.</p><p>Atomically compares the atomic with <strong><span class="anno">Expected</span></strong>,
and if those are equal, set atomic to <strong><span class="anno">Desired</span></strong>.
Returns <strong>ok</strong> if <strong><span class="anno">Desired</span></strong> was written. Returns
the actual atomic value if not equal to <strong><span class="anno">Expected</span></strong>.</p><h4>info/1</h4><p>Get information about atomic array.</p><p>Return information about an atomic array in a map. The map
has the following keys:</p><dl><dt><strong>size</strong></dt><dd><p>The number of atomics in the array.</p></dd><dt><strong>max</strong></dt><dd><p>The highest possible value an atomic in this array can
hold.</p></dd><dt><strong>min</strong></dt><dd><p>The lowest possible value an atomic in this array can
hold.</p></dd><dt><strong>memory</strong></dt><dd><p>Approximate memory consumption for the array in
bytes.</p></dd></dl><h3>counters</h3><p>Counter Functions</p><p>This module provides a set of functions to do operations towards
shared mutable counter variables. The implementation does not utilize any
software level locking, which makes it very efficient for concurrent
access. The counters are organized into arrays with the following
semantics:<ul><li> <p>Counters are 64 bit signed integers.</p> </li><li> <p>Counters wrap around at overflow and underflow operations.</p> </li><li><p>Counters are initialized to zero and can then only be written to
by adding or subtracting.</p> </li><li> <p>Write operations guarantee atomicity. No intermediate results can be
seen from a single write operation.</p> </li><li> <p>Two types of counter arrays can be created with options <strong>atomics</strong> or
<strong>write_concurrency</strong>. The <strong>atomics</strong> counters have good allround
performance with nice consistent semantics while
<strong>write_concurrency</strong> counters offers even better concurrent
write performance at the expense of some potential read
inconsistencies. See <a href="#new/2">new/2</a>.</p> </li><li> <p>Indexes into counter arrays are one-based. A counter array of
size N contains N counters with index from 1 to N.</p> </li></ul></p><h3>Data Types</h3><span class="name">counters_ref</span><p>Identifies a counter array returned from
<a href="#new/2">new/2</a>.</p><h3>Functions</h3><h4>new/2</h4><p>Create counter array</p><p>Create a new counter array of <strong><span class="anno">Size</span></strong> counters.</p><p>Argument <strong><span class="anno">Opts</span></strong> is a list of the following possible
options:</p><dl><dt><strong>atomics</strong> (Default)</dt><dd><p>Counters will be sequentially consistent. If write
operation A is done sequentially before write operation B, then a concurrent reader
may see none of them, only A, or both A and B. It cannot see only B.</p> </dd><dt><strong>write_concurrency</strong></dt><dd><p>This is an optimization to achieve very efficient concurrent
<a href="#add/3">add/3</a> and <a href="#sub/3">sub/3</a> operations at the expense of potential read
inconsistency and memory consumption per counter.</p> <p>Read operations may see sequentially inconsistent results with
regard to concurrent write operations. Even if write operation A is done
sequentially before write operation B, a concurrent reader may see any
combination of A and B, including only B. A read operation is only
guaranteed to see all writes done sequentially before the read. No writes
are ever lost, but will eventually all be seen.</p> <p>The typical use case for <strong>write_concurrency</strong> is when
concurrent calls to <a href="#add/3">add/3</a> and
<a href="#sub/3">sub/3</a> toward the same counters
are very frequent, while calls to <a href="#get/2">get/2</a> and <a href="#put/3">put/3</a> are much
less frequent. The lack of absolute read consistency must also be
acceptable.</p> </dd></dl><p>Counters are not tied to the current process and are automatically
garbage collected when they are no longer referenced.</p><h4>get/2</h4><p>Read counter value</p><p>Read counter value.</p><h4>add/3</h4><p>Add to counter</p><p>Add <strong><span class="anno">Incr</span></strong> to counter at index
<strong><span class="anno">Ix</span></strong>.</p><h4>sub/3</h4><p>Subtract from counter</p><p>Subtract <strong><span class="anno">Decr</span></strong> from counter at index
<strong><span class="anno">Ix</span></strong>.</p><h4>put/3</h4><p>Set counter to value</p><p>Write <strong><span class="anno">Value</span></strong> to counter at index
<strong><span class="anno">Ix</span></strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Despite its name, the <strong>write_concurrency</strong> optimization does not
improve <strong>put</strong>. A call to <strong>put</strong> is a relatively heavy
operation compared to the very lightweight and scalable <a href="#add/3">add/3</a> and <a href="#sub/3">sub/3</a>. The cost for a <strong>put</strong> with
<strong>write_concurrency</strong> is like a <a href="#get/2">get/2</a> plus a <strong>put</strong> without <strong>write_concurrency</strong>.</p></div><h4>info/1</h4><p>Get information about counter array.</p><p>Return information about a counter array in a map. The map
has the following keys (at least):</p><dl><dt><strong>size</strong></dt><dd><p>The number of counters in the array.</p></dd><dt><strong>memory</strong></dt><dd><p>Approximate memory consumption for the array in
bytes.</p></dd></dl><h3>driver_entry</h3><p>The driver-entry structure used by Erlang drivers.</p><p><a name="WARNING"></a>As from ERTS 5.9 (Erlang/OTP R15B) the driver interface
has been changed with larger types for the callbacks
<a href="#output">output</a>,
<a href="#control">control</a>, and
<a href="#call">call</a>.
See driver <a href="./erl_driver#version_management"> version management</a> in
<a href="erl_driver">erl_driver</a>.The <strong>driver_entry</strong> structure is a C struct that all Erlang
drivers define. It contains entry points for the Erlang driver,
which are called by the Erlang emulator when Erlang code accesses
the driver.<a name="emulator"></a>
The <a href="erl_driver">erl_driver</a> driver
API functions need a port handle
that identifies the driver instance (and the port in the
emulator). This is only passed to the <strong>start</strong> function, but
not to the other functions. The <strong>start</strong> function returns a
driver-defined handle that is passed to the other functions. A
common practice is to have the <strong>start</strong> function allocate
some application-defined structure and stash the <strong>port</strong>
handle in it, to use it later with the driver API functions.The driver callback functions are called synchronously from the
Erlang emulator. If they take too long before completing, they
can cause time-outs in the emulator. Use the queue or
asynchronous calls if necessary, as the emulator must be
responsive.The driver structure contains the driver name and some
15 function pointers, which are called at different
times by the emulator.The only exported function from the driver is
<strong>driver_init</strong>. This function returns the <strong>driver_entry</strong>
structure that points to the other functions in the driver. The
<strong>driver_init</strong> function is declared with a macro,
<strong>DRIVER_INIT(drivername)</strong>. (This is because different
operating systems have different names for it.)When writing a driver in C++, the driver entry is to be of
<strong>"C"</strong> linkage. One way to do this is to put the
following line somewhere before the driver entry:<pre>
extern "C" DRIVER_INIT(drivername);</pre>When the driver has passed the <strong>driver_entry</strong> over to
the emulator, the driver is <em>not</em> allowed to modify the
<strong>driver_entry</strong>.If compiling a driver for static inclusion through
<strong>--enable-static-drivers</strong>, you must define
<strong>STATIC_ERLANG_DRIVER</strong> before the <strong>DRIVER_INIT</strong> declaration.</p><h4>Data Types</h4><p><strong>ErlDrvEntry</strong></p><pre><code class="">
typedef struct erl_drv_entry {
    int (*init)(void);          /* Called at system startup for statically
                                   linked drivers, and after loading for
                                   dynamically loaded drivers */
#ifndef ERL_SYS_DRV
    ErlDrvData (*start)(ErlDrvPort port, char *command);
                                /* Called when open_port/2 is invoked,
                                   return value -1 means failure */
#else
    ErlDrvData (*start)(ErlDrvPort port, char *command, SysDriverOpts* opts);
                                /* Special options, only for system driver */
#endif
    void (*stop)(ErlDrvData drv_data);
                                /* Called when port is closed, and when the
                                   emulator is halted */
    void (*output)(ErlDrvData drv_data, char *buf, ErlDrvSizeT len);
                                /* Called when we have output from Erlang to
                                   the port */
    void (*ready_input)(ErlDrvData drv_data, ErlDrvEvent event); 
                                /* Called when we have input from one of
                                   the driver's handles */
    void (*ready_output)(ErlDrvData drv_data, ErlDrvEvent event);  
                                /* Called when output is possible to one of
                                   the driver's handles */
    char *driver_name;          /* Name supplied as command in
                                   erlang:open_port/2 */
    void (*finish)(void);       /* Called before unloading the driver -
                                   dynamic drivers only */
    void *handle;               /* Reserved, used by emulator internally */
    ErlDrvSSizeT (*control)(ErlDrvData drv_data, unsigned int command,
                            char *buf, ErlDrvSizeT len,
			    char **rbuf, ErlDrvSizeT rlen);
                                /* "ioctl" for drivers - invoked by
                                   port_control/3 */
    void (*timeout)(ErlDrvData drv_data);
                                /* Handling of time-out in driver */
    void (*outputv)(ErlDrvData drv_data, ErlIOVec *ev);
                                /* Called when we have output from Erlang
                                   to the port */
    void (*ready_async)(ErlDrvData drv_data, ErlDrvThreadData thread_data);
    void (*flush)(ErlDrvData drv_data);
                                /* Called when the port is about to be
                                   closed, and there is data in the
                                   driver queue that must be flushed
                                   before 'stop' can be called */
    ErlDrvSSizeT (*call)(ErlDrvData drv_data, unsigned int command,
                         char *buf, ErlDrvSizeT len,
			 char **rbuf, ErlDrvSizeT rlen, unsigned int *flags);
                                /* Works mostly like 'control', a synchronous
                                   call into the driver */
    void* unused_event_callback;
    int extended_marker;        /* ERL_DRV_EXTENDED_MARKER */
    int major_version;          /* ERL_DRV_EXTENDED_MAJOR_VERSION */
    int minor_version;          /* ERL_DRV_EXTENDED_MINOR_VERSION */
    int driver_flags;           /* ERL_DRV_FLAGs */
    void *handle2;              /* Reserved, used by emulator internally */
    void (*process_exit)(ErlDrvData drv_data, ErlDrvMonitor *monitor);
                                /* Called when a process monitor fires */
    void (*stop_select)(ErlDrvEvent event, void* reserved);
                                /* Called to close an event object */
 } ErlDrvEntry;</code></pre><dl><dt><a name="init"></a><strong>int (*init)(void)</strong></dt><dd>        <p>Called directly after the driver has been loaded by
<a href="../kernel/erl_ddll#load_driver/2">kernel/erl_ddll#load_driver/2</a> (actually when the driver is
added to the driver list). The driver is to return <strong>0</strong>, or, if
the driver cannot initialize, <strong>-1</strong>.</p> </dd><dt><a name="start"></a> <strong>ErlDrvData (*start)(ErlDrvPort port, char* command)</strong></dt><dd> <p>Called when the driver is instantiated, when
<a href="./erlang#open_port/2">erlang#open_port/2</a> is called.
The driver is to return a number &gt;= 0 or a pointer, or, if the
driver cannot be started, one of three error codes:</p> <dl><dt><strong>ERL_DRV_ERROR_GENERAL</strong></dt><dd>General error, no error code</dd><dt><strong>ERL_DRV_ERROR_ERRNO</strong></dt><dd>Error with error code in <strong>errno</strong></dd><dt><strong>ERL_DRV_ERROR_BADARG</strong></dt><dd>Error, <strong>badarg</strong></dd></dl> <p>If an error code is returned, the port is not started.</p> </dd><dt><a name="stop"></a><strong>void (*stop)(ErlDrvData drv_data)</strong></dt><dd> <p>Called when the port is closed, with
<a href="./erlang#port_close/1">erlang#port_close/1</a> or <strong>Port ! {self(), close}</strong>.
Notice that terminating the port owner process also closes the
port. If <strong>drv_data</strong> is a pointer to memory allocated in
<strong>start</strong>, then <strong>stop</strong> is the place to deallocate that
memory.</p> </dd><dt><a name="output"></a> <strong>void (*output)(ErlDrvData drv_data, char *buf, ErlDrvSizeT len)</strong> </dt><dd> <p>Called when an Erlang process has sent data to the port. The data is
pointed to by <strong>buf</strong>, and is <strong>len</strong> bytes. Data is sent to
the port with <strong>Port ! {self(), {command, Data}}</strong> or with
<strong>erlang:port_command/2</strong>. Depending on how the port was
opened, it is to be either a list of integers <strong>0...255</strong> or a
binary. See <a href="./erlang#open_port/2">erlang#open_port/2</a> and
<a href="./erlang#port_command/2">erlang#port_command/2</a>.</p> </dd><dt><a name="ready_input"></a> <strong>void (*ready_input)(ErlDrvData drv_data, ErlDrvEvent event)</strong> </dt><dd></dd><dt><a name="ready_output"></a> <strong>void (*ready_output)(ErlDrvData drv_data, ErlDrvEvent event)</strong> </dt><dd> <p>Called when a driver event (specified in parameter
<strong>event</strong>) is signaled. This is used to help
asynchronous drivers "wake up" when something occurs.</p> <p>On Unix the <strong>event</strong> is a pipe or socket handle (or
something that the <strong>select</strong> system call understands).</p> <p>On Windows the <strong>event</strong> is an <strong>Event</strong> or <strong>Semaphore</strong>
(or something that the <strong>WaitForMultipleObjects</strong> API
function understands). (Some trickery in the emulator allows
more than the built-in limit of 64 <strong>Events</strong> to be used.)</p> <p>To use this with threads and asynchronous routines, create a
pipe on Unix and an <strong>Event</strong> on Windows. When the routine
completes, write to the pipe (use <strong>SetEvent</strong> on
Windows), this makes the emulator call
<strong>ready_input</strong> or <strong>ready_output</strong>.</p> <p>False events can occur. That is, calls to <strong>ready_input</strong>
or <strong>ready_output</strong> although no real events are signaled. In
reality, it is rare (and OS-dependant), but a robust driver
must nevertheless be able to handle such cases.</p> </dd><dt><a name="driver_name"></a><strong>char *driver_name</strong></dt><dd> <p>The driver name. It must correspond to the atom used in
<a href="./erlang#open_port/2">erlang#open_port/2</a>, and the name of the driver
library file (without the extension).</p> </dd><dt><a name="finish"></a><strong>void (*finish)(void)</strong></dt><dd> <p>Called by the <strong>erl_ddll</strong> driver when the
driver is unloaded. (It is only called in dynamic drivers.)</p> <p>The driver is only unloaded as a result of calling
<a href="../kernel/erl_ddll#unload_driver/1">kernel/erl_ddll#unload_driver/1</a>,
or when the emulator halts.</p> </dd><dt><strong>void *handle</strong></dt><dd> <p>This field is reserved for the emulator's internal use. The
emulator will modify this field, so it is important
that the <strong>driver_entry</strong> is not declared <strong>const</strong>.</p>  </dd><dt><a name="control"></a> <strong>ErlDrvSSizeT (*control)(ErlDrvData drv_data, unsigned int command, char *buf, ErlDrvSizeT len, char **rbuf, ErlDrvSizeT rlen)</strong></dt><dd> <p>A special routine invoked with
<a href="./erlang#port_control/3">erlang#port_control/3</a>.
It works a little like an "ioctl" for
Erlang drivers. The data specified to <strong>port_control/3</strong>
arrives in <strong>buf</strong> and <strong>len</strong>. The driver can send
data back, using <strong>*rbuf</strong> and <strong>rlen</strong>.</p> <p>This is the fastest way of calling a driver and get a
response. It makes no context switch in the Erlang
emulator and requires no message passing. It is suitable
for calling C function to get faster execution, when Erlang
is too slow.</p> <p>If the driver wants to return data, it is to return it in
<strong>rbuf</strong>. When <strong>control</strong> is called,
<strong>*rbuf</strong> points to a default buffer of <strong>rlen</strong> bytes, which
can be used to return data. Data is returned differently depending on
the port control flags (those that are set with
<a href="./erl_driver#set_port_control_flags">erl_driver#set_port_control_flags</a>).</p> <p>If the flag is set to <strong>PORT_CONTROL_FLAG_BINARY</strong>,
a binary is returned. Small binaries can be returned by writing
the raw data into the default buffer. A binary can also be
returned by setting <strong>*rbuf</strong> to point to a binary allocated with
<a href="./erl_driver#driver_alloc_binary">erl_driver#driver_alloc_binary</a>.
This binary is freed automatically after <strong>control</strong> has returned.
The driver can retain the binary for <em>read only</em> access with
<a href="./erl_driver#driver_binary_inc_refc">erl_driver#driver_binary_inc_refc</a> to be freed later
with <a href="./erl_driver#driver_free_binary">erl_driver#driver_free_binary</a>.
It is never allowed to change the binary after <strong>control</strong> has
returned. If <strong>*rbuf</strong> is set to <strong>NULL</strong>, an empty list is
returned.</p> <p>If the flag is set to <strong>0</strong>, data is returned as a
list of integers. Either use the default buffer or set
<strong>*rbuf</strong> to point to a larger buffer allocated with
<a href="./erl_driver#driver_alloc">erl_driver#driver_alloc</a>. The
buffer is freed automatically after <strong>control</strong> has returned.</p> <p>Using binaries is faster if more than a few bytes are returned.</p> <p>The return value is the number of bytes returned in <strong>*rbuf</strong>.</p> </dd><dt><a name="timeout"></a><strong>void (*timeout)(ErlDrvData drv_data)</strong> </dt><dd> <p>Called any time after the driver's timer reaches <strong>0</strong>.
The timer is activated with
<a href="./erl_driver#driver_set_timer">erl_driver#driver_set_timer</a>. No priorities or
ordering exist among drivers, so if several drivers time out at
the same time, anyone of them is called first.</p> </dd><dt><a name="outputv"></a> <strong>void (*outputv)(ErlDrvData drv_data, ErlIOVec *ev)</strong></dt><dd> <p>Called whenever the port is written to. If
it is <strong>NULL</strong>, the <strong>output</strong> function is called
instead. This function is faster than <strong>output</strong>, as
it takes an <strong>ErlIOVec</strong> directly, which requires no
copying of the data. The port is to be in binary mode, see
<a href="./erlang#open_port/2">erlang#open_port/2</a>.</p> <p><strong>ErlIOVec</strong> contains both a <strong>SysIOVec</strong>,
suitable for <strong>writev</strong>, and one or more binaries. If
these binaries are to be retained when the driver returns
from <strong>outputv</strong>, they can be queued (using, for example,
<a href="./erl_driver#driver_enq_bin">erl_driver#driver_enq_bin</a>)
or, if they are kept in a static or global
variable, the reference counter can be incremented.</p> </dd><dt><a name="ready_async"></a> <strong>void (*ready_async)(ErlDrvData drv_data, ErlDrvThreadData thread_data)</strong></dt><dd> <p>Called after an asynchronous call has completed.
The asynchronous call is started with
<a href="./erl_driver#driver_async">erl_driver#driver_async</a>.
This function is called from the Erlang emulator thread, as
opposed to the asynchronous function, which is called in
some thread (if multi-threading is enabled).</p> </dd><dt><strong>void (*flush)(ErlDrvData drv_data)</strong></dt><dd> <p>Called when the port is about to be closed,
and there is data in the driver queue that must be flushed
before 'stop' can be called.</p> </dd><dt><a name="call"></a><strong>ErlDrvSSizeT (*call)(ErlDrvData drv_data, unsigned int command, char *buf, ErlDrvSizeT len, char **rbuf, ErlDrvSizeT rlen, unsigned int *flags)</strong></dt><dd> <p>Called from <a href="./erlang#port_call/3">erlang#port_call/3</a>.
It works a lot like the <strong>control</strong> callback, but uses the
external term format for input and output.</p> <p><strong>command</strong> is an integer, obtained from the call from
Erlang (the second argument to <strong>erlang:port_call/3</strong>).</p> <p><strong>buf</strong> and <strong>len</strong> provide the arguments to the call
(the third argument to <strong>erlang:port_call/3</strong>). They can
be decoded using <strong>ei</strong> functions.</p> <p><strong>rbuf</strong> points to a return buffer, <strong>rlen</strong> bytes
long. The return data is to be a valid Erlang term in the
external (binary) format. This is converted to an Erlang
term and returned by <strong>erlang:port_call/3</strong> to the
caller. If more space than <strong>rlen</strong> bytes is needed to
return data, <strong>*rbuf</strong> can be set to memory allocated with
<a href="./erl_driver#driver_alloc">erl_driver#driver_alloc</a>.
This memory is freed automatically after <strong>call</strong> has returned.</p> <p>The return value is the number of bytes returned in
<strong>*rbuf</strong>. If <strong>ERL_DRV_ERROR_GENERAL</strong> is returned
(or in fact, anything &lt; 0), <strong>erlang:port_call/3</strong>
throws a <strong>BAD_ARG</strong>.</p> </dd><dt><strong>void (*event)(ErlDrvData drv_data, ErlDrvEvent event, ErlDrvEventData event_data)</strong></dt><dd> <p>Intentionally left undocumented.</p> </dd><dt><a name="extended_marker"></a><strong>int extended_marker</strong></dt><dd> <p>This field is either to be equal to <strong>ERL_DRV_EXTENDED_MARKER</strong>
or <strong>0</strong>. An old driver (not aware of the extended driver
interface) is to set this field to <strong>0</strong>. If this field is
<strong>0</strong>, all the following fields <em>must</em> also be <strong>0</strong>,
or <strong>NULL</strong> if it is a pointer field.</p> </dd><dt><strong>int major_version</strong></dt><dd> <p>This field is to equal <strong>ERL_DRV_EXTENDED_MAJOR_VERSION</strong> if
field <strong>extended_marker</strong> equals
<strong>ERL_DRV_EXTENDED_MARKER</strong>.</p>  </dd><dt><strong>int minor_version</strong></dt><dd> <p>This field is to equal <strong>ERL_DRV_EXTENDED_MINOR_VERSION</strong> if
field <strong>extended_marker</strong> equals
<strong>ERL_DRV_EXTENDED_MARKER</strong>.</p> </dd><dt><a name="driver_flags"></a><strong>int driver_flags</strong></dt><dd> <p>This field is used to pass driver capability and other
information to the runtime system. If
field <strong>extended_marker</strong> equals <strong>ERL_DRV_EXTENDED_MARKER</strong>,
it is to contain <strong>0</strong> or driver flags (<strong>ERL_DRV_FLAG_*</strong>)
OR'ed bitwise. The following driver flags exist:</p> <dl><dt><strong>ERL_DRV_FLAG_USE_PORT_LOCKING</strong></dt><dd> <p>The runtime system uses port-level locking on
all ports executing this driver instead of driver-level
locking when the driver is run in a runtime
system with SMP support. For more information, see
<a href="./erl_driver#smp_support">erl_driver#smp_support</a>.</p> </dd><dt><strong>ERL_DRV_FLAG_SOFT_BUSY</strong></dt><dd> <p>Marks that driver instances can handle being called
in the <a href="#output">output</a> and/or
<a href="#outputv">outputv</a> callbacks
although a driver instance has marked itself as busy (see
<a href="./erl_driver#set_busy_port">erl_driver#set_busy_port</a>).
As from ERTS 5.7.4 this flag is required for drivers used
by the Erlang distribution (the behavior has always been
required by drivers used by the distribution).</p> </dd><dt><strong>ERL_DRV_FLAG_NO_BUSY_MSGQ</strong></dt><dd> <p>Disables busy port message queue functionality. For
more information, see
<a href="./erl_driver#erl_drv_busy_msgq_limits">erl_driver#erl_drv_busy_msgq_limits</a>.</p> </dd><dt><strong>ERL_DRV_FLAG_USE_INIT_ACK</strong></dt><dd> <p>When this flag is specified, the linked-in driver must manually
acknowledge that the port has been successfully started using
<a href="./erl_driver#erl_drv_init_ack">erl_driver#erl_drv_init_ack</a>.
This allows the implementor to make the
<strong>erlang:open_port</strong> exit with <strong>badarg</strong> after some
initial asynchronous initialization has been done.</p> </dd></dl> </dd><dt><strong>void *handle2</strong></dt><dd> <p>This field is reserved for the emulator's internal use. The
emulator modifies this field, so it is important
that the <strong>driver_entry</strong> is not declared <strong>const</strong>.</p> </dd><dt><a name="process_exit"></a> <strong>void (*process_exit)(ErlDrvData drv_data, ErlDrvMonitor *monitor)</strong> </dt><dd> <p>Called when a monitored process exits. The
<strong>drv_data</strong> is the data associated with the port for which
the process is monitored (using
<a href="./erl_driver#driver_monitor_process">erl_driver#driver_monitor_process</a>)
and the <strong>monitor</strong> corresponds to the <strong>ErlDrvMonitor</strong>
structure filled
in when creating the monitor. The driver interface function
<a href="./erl_driver#driver_get_monitored_process">erl_driver#driver_get_monitored_process</a>
can be used to retrieve the process ID of the exiting process as
an <strong>ErlDrvTermData</strong>.</p> </dd><dt><a name="stop_select"></a> <strong>void (*stop_select)(ErlDrvEvent event, void* reserved)</strong></dt><dd> <p>Called on behalf of
<a href="./erl_driver#driver_select">erl_driver#driver_select</a>
when it is safe to close an event object.</p> <p>A typical implementation on Unix is to do
<strong>close((int)event)</strong>.</p> <p>Argument <strong>reserved</strong> is intended for future use and is to be
ignored.</p> <p>In contrast to most of the other callback functions,
<strong>stop_select</strong> is called independent of any port. No
<strong>ErlDrvData</strong> argument is passed to the function. No
driver lock or port lock is guaranteed to be held. The port that
called <strong>driver_select</strong> can even be closed at the
time <strong>stop_select</strong> is called. But it can also be
the case that <strong>stop_select</strong> is called directly by
<strong>erl_driver:driver_select</strong>.</p> <p>It is not allowed to call any functions in the
<a href="erl_driver">driver API</a> from
<strong>stop_select</strong>. This strict limitation is because the
volatile context that <strong>stop_select</strong> can be called.</p> </dd></dl><h4>See Also</h4><p><a href="erl_driver">erl_driver</a>,
<a href="erlang">erlang</a>,
<a href="./erl_ddll">kernel/erl_ddll</a></p><h3>epmd</h3><p>Erlang Port Mapper Daemon</p><p><dl><dt><strong>epmd [-d|-debug] [DbgExtra...] [-address Addresses] [-port No] [-daemon] [-relaxed_command_check]</strong></dt><dd> <p>Starts the port mapper daemon.</p> </dd><dt><strong>epmd [-d|-debug] [-port No] [-names|-kill|-stop Name]</strong></dt><dd> <p>Communicates with a running port mapper daemon.</p> </dd></dl>This daemon acts as a name server on all hosts involved in
distributed Erlang computations. When an Erlang node starts,
the node has a name and it obtains an address from the host
OS kernel. The name and address are sent to the
<strong>epmd</strong> daemon running on the local host.
In a TCP/IP environment, the address consists
of the IP address and a port number. The node name is
an atom on the form of <strong>Name@Node</strong>.
The job of the <strong>epmd</strong> daemon is to keep track of which
node name listens on which address. Hence, <strong>epmd</strong> maps
symbolic node names to machine addresses.The TCP/IP <strong>epmd</strong> daemon only keeps track of
the <strong>Name</strong> (first) part of an Erlang node name. The <strong>Host</strong>
part (whatever is after the <strong>@</strong>) is implicit in the
node name where the <strong>epmd</strong> daemon was contacted,
as is the IP address where the Erlang node can be
reached. Consistent and correct TCP naming services are
therefore required for an Erlang network to function
correctly.<dl><dt>Starting the port mapper daemon</dt><dd> <p>The daemon is started automatically by command
<a href="erl">erl</a>
if the node is to be distributed and no running
instance is present. If automatically launched
environment variables must be used to change the behavior
of the daemon; see section
<a href="#environment_variables">Environment Variables</a>.</p> <p>If argument <strong>-daemon</strong> is not specified,
<strong>epmd</strong> runs as a normal program with the
controlling terminal of the shell in which it is
started. Normally, it is to be run as a daemon.</p> <p>Regular startup options are described in section
<a href="#daemon_flags">Regular Options</a>.</p> <p>The <strong>DbgExtra</strong> options are described in section
<a href="#debug_flags">DbgExtra Options</a>.</p> </dd><dt>Communicating with a running port mapper daemon</dt><dd> <p>Communicating with the running <strong>epmd</strong> daemon by the
<strong>epmd</strong> program is done primarily for debugging purposes.</p> <p>The different queries are described in section <a href="#interactive_flags">Interactive options</a>.</p> </dd></dl></p><a name="daemon_flags"></a><h4>Regular Options</h4><p>These options are available when starting the name server. The name
server is normally started automatically by command
<a href="erl">erl</a> (if not already available),
but it can also be started at system startup.</p><dl><dt><strong>-address List</strong></dt><dd> <p>Lets this instance of <strong>epmd</strong> listen only on the
comma-separated list of IP addresses and on the loopback address
(which is implicitly added to the list if it has not been
specified). This can also be set using environment variable
<strong>ERL_EPMD_ADDRESS</strong>; see section <a href="#environment_variables">Environment Variables</a>.</p> </dd><dt><strong>-port No</strong></dt><dd> <p>Lets this instance of <strong>epmd</strong> listen to another TCP port than
default 4369. This can also be set using environment variable
<strong>ERL_EPMD_PORT</strong>; see section <a href="#environment_variables">Environment Variables</a>.</p> </dd><dt><strong>-d | -debug</strong></dt><dd> <p>Enables debug output. The more <strong>-d</strong> flags specified, the more
debug output you will get (to a certain limit). This option is  most
useful when the <strong>epmd</strong> daemon is not started as a daemon.</p> </dd><dt><strong>-daemon</strong></dt><dd> <p>Starts <strong>epmd</strong> detached from the controlling terminal. Logging
ends up in syslog when available and correctly configured. If the
<strong>epmd</strong> daemon is started at boot, this option is definitely
to be used. It is also used when command <strong>erl</strong> automatically
starts <strong>epmd</strong>.</p> </dd><dt><strong>-relaxed_command_check</strong></dt><dd> <p>Starts the <strong>epmd</strong> program with relaxed command checking
(mostly for backward compatibility). This affects the following:</p> <ul><li> <p>With relaxed command checking, the <strong>epmd</strong> daemon can be
killed from the local host with, for example, command
<strong>epmd -kill</strong> even if active nodes are registered. Normally
only daemons with an empty node database can be killed with
<strong>epmd -kill</strong>.</p> </li><li> <p>Command <strong>epmd -stop</strong> (and the corresponding messages to
<strong>epmd</strong>, as can be specified using <a href="./ei">erl_interface/ei</a>) is
normally always ignored. This because it can cause a strange
situation where two nodes of the same name can be alive at the
same time. A node unregisters itself by only closing the
connection to <strong>epmd</strong>, which is why command <strong>stop</strong>
was only intended for use in debugging situations.</p> <p>With relaxed command checking enabled, you can forcibly
unregister live nodes.</p> </li></ul> <p>Relaxed command checking can also be enabled by setting environment
variable <strong>ERL_EPMD_RELAXED_COMMAND_CHECK</strong> before starting
<strong>epmd</strong>.</p> <p>Use relaxed command checking only on systems with very limited
interactive usage.</p> </dd></dl><a name="debug_flags"></a><h4>DbgExtra Options</h4><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>These options are only for debugging and testing <strong>epmd</strong> clients.
They are not to be used in normal operation.</p></div><dl><dt><strong>-packet_timeout Seconds</strong></dt><dd> <p>Sets the number of seconds a connection can be
inactive before <strong>epmd</strong> times out and closes the
connection. Defaults to 60.</p> </dd><dt><strong>-delay_accept Seconds</strong></dt><dd> <p>To simulate a busy server, you can insert a delay between when
<strong>epmd</strong> gets notified that a new connection is requested and
when the connection gets accepted.</p> </dd><dt><strong>-delay_write Seconds</strong></dt><dd> <p>Also a simulation of a busy server. Inserts
a delay before a reply is sent.</p> </dd></dl><a name="interactive_flags"></a><h4>Interactive Options</h4><p>These options make <strong>epmd</strong> run as an interactive command,
displaying the results of sending queries to an already running
instance of <strong>epmd</strong>. The <strong>epmd</strong> contacted is always on the
local node, but option <strong>-port</strong> can be used to select between
instances if several are running using different ports on the host.</p><dl><dt><strong>-port No</strong></dt><dd> <p>Contacts the <strong>epmd</strong> listening on the specified TCP port
number (default 4369). This can also be set using environment
variable <strong>ERL_EPMD_PORT</strong>; see section <a href="#environment_variables">Environment Variables</a>.</p> </dd><dt><strong>-names</strong></dt><dd> <p>Lists names registered with the currently running <strong>epmd</strong>.</p> </dd><dt><strong>-kill</strong></dt><dd> <p>Kills the currently running <strong>epmd</strong>.</p> <p>Killing the running <strong>epmd</strong> is only allowed if
<strong>epmd -names</strong> shows an empty database or if
<strong>-relaxed_command_check</strong> was specified when the running
instance of <strong>epmd</strong> was started.</p> <p>Notice that <strong>-relaxed_command_check</strong> is specified when
starting the daemon that is to accept killing when it has live
nodes registered. When running <strong>epmd</strong> interactively,
<strong>-relaxed_command_check</strong> has no effect. A daemon that is
started without relaxed command checking must be killed using,
for example, signals or some other OS-specific method if it has
active clients registered.</p> </dd><dt><strong>-stop Name</strong></dt><dd> <p>Forcibly unregisters a live node from the <strong>epmd</strong> database.</p> <p>This command can only be used when contacting <strong>epmd</strong>
instances started with flag <strong>-relaxed_command_check</strong>.</p> <p>Notice that relaxed command checking must enabled for the
<strong>epmd</strong> daemon contacted. When running <strong>epmd</strong>
interactively, <strong>-relaxed_command_check</strong> has no effect.</p> </dd></dl><a name="environment_variables"></a><h4>Environment Variables</h4><dl><dt><strong>ERL_EPMD_ADDRESS</strong></dt><dd> <p>Can be set to a comma-separated
list of IP addresses, in which case the <strong>epmd</strong> daemon
will listen only on the specified address(es) and on the
loopback address (which is implicitly added to the list if it
has not been specified). The default behavior is to listen on
all available IP addresses.</p> </dd><dt><strong>ERL_EPMD_PORT</strong></dt><dd> <p>Can contain the port number <strong>epmd</strong> will use.
The default port will work fine in most cases. A different port can
be specified to allow several instances of <strong>epmd</strong>, representing
independent clusters of nodes, to co-exist on the same host.
All nodes in a cluster must use the same <strong>epmd</strong> port number.</p> </dd><dt><strong>ERL_EPMD_RELAXED_COMMAND_CHECK</strong></dt><dd> <p>If set before start, the <strong>epmd</strong> daemon behaves
as if option <strong>-relaxed_command_check</strong> was specified at
startup. Consequently, if this option is set before starting
the Erlang virtual machine, the automatically started
<strong>epmd</strong> accepts the <strong>-kill</strong> and <strong>-stop</strong>
commands without restrictions.</p> </dd></dl><h4>Logging</h4><p>On some operating systems <em>syslog</em> will be used for
error reporting when <strong>epmd</strong> runs as a daemon. To enable
the error logging, you must edit the
<span class="path">/etc/syslog.conf</span> file and add an
entry:</p><pre><code class="">
  !epmd
  *.*&lt;TABs&gt;/var/log/epmd.log
</code></pre><p>where <strong>&lt;TABs&gt;</strong> are at least one real tab character.
Spaces are silently ignored.</p><h4>Access Restrictions</h4><p>The <strong>epmd</strong> daemon accepts messages from both the local host and
remote hosts. However, only the query commands are answered (and
acted upon) if the query comes from a remote host. It is always an
error to try to register a node name if the client is not a process
on the same host as the <strong>epmd</strong> instance is running on. Such
requests are considered hostile and the connection is closed
immediately.</p><p>The following queries are accepted from remote nodes:</p><ul><li> <p>Port queries, that is, on which port the node with a specified
name listens</p> </li><li> <p>Name listing, that is, gives a list of all names registered on
the host</p> </li></ul><p>To restrict access further, firewall software must be used.</p><h3>erl</h3><p>The Erlang emulator.</p><p>The <strong>erl</strong> program starts an Erlang runtime system.
The exact details (for example, whether <strong>erl</strong> is a
script or a program and which other programs it calls) are
system-dependent.Windows users probably want to use the <strong>werl</strong> program
instead, which runs in its own window with scrollbars and supports
command-line editing. The <strong>erl</strong> program on Windows
provides no line editing in its shell, and on Windows 95 there is no way
to scroll back to text that has scrolled off the screen. The
<strong>erl</strong> program must be used, however, in pipelines or if
you want to redirect standard input or output.</p><h3>Functions</h3><h4>erl &lt;arguments&gt;</h4><p>Start an Erlang runtime system.</p><p>Starts an Erlang runtime system.</p><p>The arguments can be divided into <em>emulator flags</em>,
<em>flags</em>, and <em>plain arguments</em>:</p><ul><li> <p>Any argument starting with character <strong>+</strong> is
interpreted as an
<a href="#emu_flags">emulator flag</a>.</p> <p>As indicated by the name, emulator flags control
the behavior of the emulator.</p> </li><li> <p>Any argument starting with character <strong>-</strong>
(hyphen) is interpreted as a
<a href="#init_flags">flag</a>, which is to
be passed to the Erlang part of the runtime system, more
specifically to the <strong>init</strong> system process, see
<a href="init">init</a>.</p> <p>The <strong>init</strong> process itself interprets some of
these flags, the <em>init flags</em>. It also stores any
remaining flags, the <em>user flags</em>. The latter can be
retrieved by calling <strong>init:get_argument/1</strong>.</p> <p>A small number of "-" flags exist, which now actually are
emulator flags, see the description below.</p> </li><li> <p>Plain arguments are not interpreted in any way. They are also
stored by the <strong>init</strong> process and can be retrieved
by calling <strong>init:get_plain_arguments/0</strong>.
Plain arguments can occur before the first flag, or after a
<strong>--</strong> flag. Also, the <strong>-extra</strong>
flag causes everything that follows to become plain arguments.</p> </li></ul><p><em>Examples:</em></p><pre>
% <span class="input">erl +W w -sname arnie +R 9 -s my_init -extra +bertie</span>
(arnie@host)1&gt; <span class="input">init:get_argument(sname).</span>
{ok,[["arnie"]]}
(arnie@host)2&gt; <span class="input">init:get_plain_arguments().</span>
["+bertie"]</pre><p>Here <strong>+W w</strong> and <strong>+R 9</strong> are
emulator flags. <strong>-s my_init</strong> is an init flag,
interpreted by <strong>init</strong>.
<strong>-sname arnie</strong> is a user flag, stored by
<strong>init</strong>. It is read by Kernel and causes the
Erlang runtime system to become distributed. Finally, everything after
<strong>-extra</strong> (that is, <strong>+bertie</strong>) is
considered as plain arguments.</p><pre>
% <span class="input">erl -myflag 1</span>
1&gt; <span class="input">init:get_argument(myflag).</span>
{ok,[["1"]]}
2&gt; <span class="input">init:get_plain_arguments().</span>
[]</pre><p>Here the user flag <strong>-myflag 1</strong> is passed to and
stored by the <strong>init</strong> process. It is a user-defined
flag, presumably used by some user-defined application.</p><a name="init_flags"></a><h4>Flags</h4><p>In the following list, init flags are marked "(init flag)".
Unless otherwise specified, all other flags are user flags, for
which the values can be retrieved by calling
<strong>init:get_argument/1</strong>. Notice that the list of user
flags is not exhaustive, there can be more application-specific
flags that instead are described in the corresponding
application documentation.</p><dl><dt><strong>--</strong> (init flag)</dt><dd> <p>Everything following <strong>--</strong> up to the next flag
(<strong>-flag</strong> or <strong>+flag</strong>) is considered
plain arguments and can be retrieved using
<strong>init:get_plain_arguments/0</strong>.</p> </dd><dt><strong>-Application Par Val</strong></dt><dd> <p>Sets the application configuration parameter <strong>Par</strong>
to the value <strong>Val</strong> for the application
<strong>Application</strong>; see
<a href="./app">kernel/app</a> and
<a href="./application">kernel/application</a>.</p> </dd><dt><a name="args_file"></a><strong>-args_file FileName</strong></dt><dd> <p>Command-line arguments are read from the file
<strong>FileName</strong>. The arguments read from the file replace
flag '<strong>-args_file FileName</strong>' on the resulting
command line.</p> <p>The file <strong>FileName</strong> is to be a plain text file and
can contain comments and command-line arguments. A comment begins
with a <strong>#</strong> character and continues until the next end of line
character. Backslash (\\) is used as quoting character. All
command-line arguments accepted by <strong>erl</strong> are allowed,
also flag <strong>-args_file FileName</strong>. Be careful not to
cause circular dependencies between files containing flag
<strong>-args_file</strong>, though.</p> <p>The flag <strong>-extra</strong> is treated in special way. Its
scope ends at the end of the file. Arguments following an
<strong>-extra</strong> flag are moved on the command line into the
<strong>-extra</strong> section, that is, the end of the command
line following after an <strong>-extra</strong> flag.</p> </dd><dt><strong>-async_shell_start</strong></dt><dd> <p>The initial Erlang shell does not read user input until
the system boot procedure has been completed (Erlang/OTP 5.4 and
later). This flag disables the start synchronization feature
and lets the shell start in parallel with the rest of
the system.</p> </dd><dt><strong>-boot File</strong></dt><dd> <p>Specifies the name of the boot file, <strong>File.boot</strong>,
which is used to start the system; see
<a href="init">init</a>. Unless
<strong>File</strong> contains an absolute path, the system searches
for <strong>File.boot</strong> in the current and 
<strong>$ROOT/bin</strong> directories.</p> <p>Defaults to <strong>$ROOT/bin/start.boot</strong>.</p> </dd><dt><strong>-boot_var Var Dir</strong></dt><dd> <p>If the boot script contains a path variable <strong>Var</strong>
other than <strong>$ROOT</strong>, this variable is expanded to
<strong>Dir</strong>. Used when applications are installed in
another directory than <strong>$ROOT/lib</strong>; see
<a href="../sasl/systools#make_script/1">sasl/systools#make_script/1</a> in SASL.</p> </dd><dt><strong>-code_path_cache</strong></dt><dd> <p>Enables the code path cache of the code server; see
<a href="./code">kernel/code</a>.</p> </dd><dt><strong>-compile Mod1 Mod2 ...</strong></dt><dd> <p>Compiles the specified modules and then terminates (with
non-zero exit code if the compilation of some file did not
succeed). Implies <strong>-noinput</strong>.</p> <p>Not recommended; use <a href="erlc">erlc</a>
instead.</p> </dd><dt><strong>-config Config</strong></dt><dd> <p>Specifies the name of a configuration file,
<strong>Config.config</strong>, which is used to configure
applications; see
<a href="./app">kernel/app</a> and
<a href="./application">kernel/application</a>.</p> </dd><dt><a name="connect_all"></a><strong>-connect_all false</strong></dt><dd> <p>If this flag is present, <strong>global</strong> does not maintain
a fully connected network of distributed Erlang nodes, and then
global name registration cannot be used; see
<a href="./global">kernel/global</a>.</p> </dd><dt><strong>-cookie Cookie</strong></dt><dd> <p>Obsolete flag without any effect and common misspelling for
<strong>-setcookie</strong>. Use <strong>-setcookie</strong>
instead.</p> </dd><dt><strong>-detached</strong></dt><dd> <p>Starts the Erlang runtime system detached from the system
console. Useful for running daemons and backgrounds processes. Implies
<strong>-noinput</strong>.</p> </dd><dt><strong>-emu_args</strong></dt><dd> <p>Useful for debugging. Prints the arguments sent to the emulator.</p> </dd><dt><strong>-emu_type Type</strong></dt><dd> <p>Start an emulator of a different type. For example, to start
the lock-counter emualator, use <strong>-emu_type lcnt</strong>. (The emulator
must already be built. Use the <strong>configure</strong> option
<strong>--enable-lock-counter</strong> to build the lock-counter emulator.)</p> </dd><dt><strong>-env Variable Value</strong></dt><dd> <p>Sets the host OS environment variable <strong>Variable</strong> to
the value <strong>Value</strong> for the Erlang runtime system.
Example:</p> <pre>
% <span class="input">erl -env DISPLAY gin:0</span></pre> <p>In this example, an Erlang runtime system is started with
environment variable <strong>DISPLAY</strong> set to
<strong>gin:0</strong>.</p> </dd><dt><strong>-epmd_module Module</strong> (init flag)</dt><dd> <p>Configures the module responsible to communicate to
<a href="epmd">epmd</a>. Defaults to <strong>erl_epmd</strong>.</p> </dd><dt><strong>-eval Expr</strong> (init flag)</dt><dd> <p>Makes <strong>init</strong> evaluate the expression
<strong>Expr</strong>; see
<a href="init">init</a>.</p> </dd><dt><strong>-extra</strong> (init flag)</dt><dd> <p>Everything following <strong>-extra</strong> is considered plain
arguments and can be retrieved using
<strong>init:get_plain_arguments/0</strong>.</p> </dd><dt><strong>-heart</strong></dt><dd> <p>Starts heartbeat monitoring of the Erlang runtime system;
see <a href="./heart">kernel/heart</a>.</p> </dd><dt><strong>-hidden</strong></dt><dd> <p>Starts the Erlang runtime system as a hidden node, if it is
run as a distributed node. Hidden nodes always establish
hidden connections to all other nodes except for nodes in the
same global group. Hidden connections are not published on
any of the connected nodes, that is, none of the connected
nodes are part of the result from <strong>nodes/0</strong> on the
other node. See also hidden global groups;
<a href="./global_group">kernel/global_group</a>.</p> </dd><dt><strong>-hosts Hosts</strong></dt><dd> <p>Specifies the IP addresses for the hosts on which Erlang boot servers
are running, see <a href="./erl_boot_server">kernel/erl_boot_server</a>. This flag
is mandatory if flag <strong>-loader inet</strong> is present.</p> <p>The IP addresses must be specified in the standard form (four
decimal numbers separated by periods, for example,
<strong>"150.236.20.74"</strong>. Hosts names are not acceptable,
but a broadcast address (preferably limited to the local network)
is.</p> </dd><dt><strong>-id Id</strong></dt><dd> <p>Specifies the identity of the Erlang runtime system. If it is
run as a distributed node, <strong>Id</strong> must be identical to
the name supplied together with flag <strong>-sname</strong> or
<strong>-name</strong>.</p> </dd><dt><strong>-init_debug</strong></dt><dd> <p>Makes <strong>init</strong> write some debug information while
interpreting the boot script.</p> </dd><dt><a name="instr"></a><strong>-instr</strong> (emulator flag)</dt><dd> <p>Selects an instrumented Erlang runtime system (virtual
machine) to run, instead of the ordinary one. When running an
instrumented runtime system, some resource usage data can be
obtained and analyzed using the <strong>instrument</strong> module.
Functionally, it behaves exactly like an ordinary Erlang
runtime system.</p> </dd><dt><strong>-loader Loader</strong></dt><dd> <p>Specifies the method used by <strong>erl_prim_loader</strong> to
load Erlang modules into the system; see
<a href="erl_prim_loader">erl_prim_loader</a>.
Two <strong>Loader</strong> methods are supported:</p> <ul><li> <p><strong>efile</strong>, which means use the local file system,
this is the default.</p> </li><li> <p><strong>inet</strong>, which means use a boot server on
another machine. The flags <strong>-id</strong>,
<strong>-hosts</strong> and <strong>-setcookie</strong> must
also be specified.</p> </li></ul> <p>If <strong>Loader</strong> is something else, the user-supplied
<strong>Loader</strong> port program is started.</p> </dd><dt><strong>-make</strong></dt><dd> <p>Makes the Erlang runtime system invoke <strong>make:all()</strong>
in the current working directory and then terminate; see
<a href="./make">tools/make</a>. Implies
<strong>-noinput</strong>.</p> </dd><dt><strong>-man Module</strong></dt><dd> <p>Displays the manual page for the Erlang module
<strong>Module</strong>. Only supported on Unix.</p> </dd><dt><strong>-mode interactive | embedded</strong></dt><dd> <p>Modules are auto loaded when they are first referenced if the
runtime system runs in <strong>interactive</strong> mode, which is
the default. In <strong>embedded</strong> mode modules are not auto
loaded. The latter is recommended when the boot script preloads all
modules, as conventionally happens in OTP releases. See
<a href="./code">kernel/code</a></p>. </dd><dt><strong>-name Name</strong></dt><dd> <p>Makes the Erlang runtime system into a distributed node.
This flag invokes all network servers necessary for a node to
become distributed; see <a href="./net_kernel">kernel/net_kernel</a>. It is also ensured that
<strong>epmd</strong> runs on the current host before Erlang is
started; see <a href="epmd">epmd</a>.and the
<a href="#start_epmd">start_epmd</a> option.</p> <p>The node name will be <strong>Name@Host</strong>, where
<strong>Host</strong> is the fully qualified host name of the
current host. For short names, use flag <strong>-sname</strong>
instead.</p> <div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>
Starting a distributed node without also specifying
<a href="#proto_dist">proto_dist</a>
will expose the node to attacks that may give the attacker
complete access to the node and in extension the cluster.
When using un-secure distributed nodes, make sure that the
network is configured to keep potential attackers out.
</p></div> </dd><dt><strong>-noinput</strong></dt><dd> <p>Ensures that the Erlang runtime system never tries to read
any input. Implies <strong>-noshell</strong>.</p> </dd><dt><strong>-noshell</strong></dt><dd> <p>Starts an Erlang runtime system with no shell. This flag
makes it possible to have the Erlang runtime system as a
component in a series of Unix pipes.</p> </dd><dt><strong>-nostick</strong></dt><dd> <p>Disables the sticky directory facility of the Erlang code
server; see
<a href="./code">kernel/code</a>.</p> </dd><dt><strong>-oldshell</strong></dt><dd> <p>Invokes the old Erlang shell from Erlang/OTP 3.3. The old shell
can still be used.</p> </dd><dt><strong>-pa Dir1 Dir2 ...</strong></dt><dd> <p>Adds the specified directories to the beginning of the code
path, similar to <a href="../kernel/code#add_pathsa/1">kernel/code#add_pathsa/1</a>. Note that the
order of the given directories will be reversed in the
resulting path.</p> <p>As an alternative to <strong>-pa</strong>, if several directories are
to be prepended to the code path and the directories have a
common parent directory, that parent directory can be
specified in environment variable <strong>ERL_LIBS</strong>; see
<a href="./code">kernel/code</a>.</p> </dd><dt><strong>-pz Dir1 Dir2 ...</strong></dt><dd> <p>Adds the specified directories to the end of the code path,
similar to <strong>code:add_pathsz/1</strong>; see
<a href="./code">kernel/code</a>.</p> </dd><dt><strong>-path Dir1 Dir2 ...</strong></dt><dd> <p>Replaces the path specified in the boot script; see
<a href="./script">sasl/script</a>.</p> </dd><dt><strong>-proto_dist Proto</strong></dt><dd> <a name="proto_dist"></a> <p>Specifies a protocol for Erlang distribution:</p> <dl><dt><strong>inet_tcp</strong></dt><dd>TCP over IPv4 (the default)</dd><dt><strong>inet_tls</strong></dt><dd>Distribution over TLS/SSL, See the <a href="./ssl_distribution"> Using SSL for Erlang Distribution</a> User's Guide for details on how to setup a secure distributed node. </dd><dt><strong>inet6_tcp</strong></dt><dd>TCP over IPv6</dd></dl> <p>For example, to start up IPv6 distributed nodes:</p> <pre>
% <span class="input">erl -name test@ipv6node.example.com -proto_dist inet6_tcp</span></pre> </dd><dt><strong>-remsh Node</strong></dt><dd> <p>Starts Erlang with a remote shell connected to
<strong>Node</strong>. Requires either <strong>-name</strong>
or <strong>-sname</strong> to be given. If <strong>Node</strong>
does not contain a hostname, one is automatically taken from
<strong>-name</strong> or <strong>-sname</strong></p> </dd><dt><strong>-rsh Program</strong></dt><dd> <p>Specifies an alternative to <strong>ssh</strong> for starting a
slave node on a remote host; see
<a href="./slave">stdlib/slave</a>.</p> </dd><dt><strong>-run Mod [Func [Arg1, Arg2, ...]]</strong> (init flag)</dt><dd> <p>Makes <strong>init</strong> call the specified function.
<strong>Func</strong> defaults to <strong>start</strong>.
If no arguments are provided, the function is assumed to be of
arity 0. Otherwise it is assumed to be of arity 1, taking the list
<strong>[Arg1,Arg2,...]</strong> as argument. All arguments are
passed as strings. See <a href="init">init</a>.</p> </dd><dt><strong>-s Mod [Func [Arg1, Arg2, ...]]</strong> (init flag)</dt><dd> <p>Makes <strong>init</strong> call the specified function.
<strong>Func</strong> defaults to <strong>start</strong>.
If no arguments are provided, the function is assumed to be of
arity 0. Otherwise it is assumed to be of arity 1, taking the list
<strong>[Arg1,Arg2,...]</strong> as argument. All arguments are
passed as atoms. See <a href="init">init</a>.</p> </dd><dt><strong>-setcookie Cookie</strong></dt><dd> <p>Sets the magic cookie of the node to <strong>Cookie</strong>; see
<a href="./erlang#set_cookie/2">erlang#set_cookie/2</a>.</p> </dd><dt><strong>-shutdown_time Time</strong></dt><dd> <p>Specifies how long time (in milliseconds) the <strong>init</strong>
process is allowed to spend shutting down the system. If
<strong>Time</strong> milliseconds have elapsed, all processes still
existing are killed. Defaults to <strong>infinity</strong>.</p> </dd><dt><strong>-sname Name</strong></dt><dd> <p>Makes the Erlang runtime system into a distributed node, similar to
<strong>-name</strong>, but the host name portion of the node
name <strong>Name@Host</strong> will be the short name, not fully
qualified.</p> <p>This is sometimes the only way to run distributed Erlang if
the Domain Name System (DNS) is not running. No communication can
exist between nodes running with flag <strong>-sname</strong>
and those running with flag <strong>-name</strong>, as node
names must be unique in distributed Erlang systems.</p> <div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>
Starting a distributed node without also specifying
<a href="#proto_dist">proto_dist</a>
will expose the node to attacks that may give the attacker
complete access to the node and in extension the cluster.
When using un-secure distributed nodes, make sure that the
network is configured to keep potential attackers out.
</p></div> </dd><dt><a name="start_epmd"></a><strong>-start_epmd true | false</strong></dt><dd> <p>Specifies whether Erlang should start
<a href="epmd">epmd</a> on startup. By default
this is <strong>true</strong>, but if you prefer to start epmd
manually, set this to <strong>false</strong>.</p> <p>This only applies if Erlang is started as a distributed node,
i.e. if <strong>-name</strong> or <strong>-sname</strong> is specified. Otherwise,
epmd is not started even if <strong>-start_epmd true</strong> is given.</p> <p>Note that a distributed node will fail to start if epmd is
not running.</p> </dd><dt><strong>-version</strong> (emulator flag)</dt><dd> <p>Makes the emulator print its version number. The same
as <strong>erl +V</strong>.</p> </dd></dl><a name="emu_flags"></a><h4>Emulator Flags</h4><p><strong>erl</strong> invokes the code for the Erlang emulator (virtual
machine), which supports the following flags:</p><dl><dt><a name="async_thread_stack_size"></a> <strong>+a size</strong></dt><dd> <p>Suggested stack size, in kilowords, for threads in the
async thread pool. Valid range is 16-8192 kilowords. The
default suggested stack size is 16 kilowords, that is, 64
kilobyte on 32-bit architectures. This small default size
has been chosen because the number of async threads can
be large. The default size is enough for drivers
delivered with Erlang/OTP, but might not be large
enough for other dynamically linked-in drivers that use the
<a href="./erl_driver#driver_async">erl_driver#driver_async</a> functionality.
Notice that the value passed is only a suggestion,
and it can even be ignored on some platforms.</p> </dd><dt><a name="async_thread_pool_size"></a><strong>+A size</strong></dt><dd> <p>Sets the number of threads in async thread pool. Valid range
is 0-1024. Defaults to 1.</p> </dd><dt><strong>+B [c | d | i]</strong></dt><dd> <p>Option <strong>c</strong> makes <strong>Ctrl-C</strong>
interrupt the current shell instead of invoking the emulator break
handler. Option <strong>d</strong> (same as specifying
<strong>+B</strong> without an extra option) disables the break
handler. Option <strong>i</strong> makes the emulator ignore any
break signal.</p> <p>If option <strong>c</strong> is used with
<strong>oldshell</strong> on Unix, <strong>Ctrl-C</strong> will
restart the shell process rather than interrupt it.</p> <p>Notice that on Windows, this flag is only applicable for
<strong>werl</strong>, not <strong>erl</strong>
(<strong>oldshell</strong>). Notice also that
<strong>Ctrl-Break</strong> is used instead of
<strong>Ctrl-C</strong> on Windows.</p> </dd><dt><a name="+c"></a><strong>+c true | false</strong></dt><dd> <p>Enables or disables
<a href="./time_correction#Time_Correction">time correction</a>:</p> <dl><dt><strong>true</strong></dt><dd>Enables time correction. This is the default if time correction is supported on the specific platform.</dd><dt><strong>false</strong></dt><dd>Disables time correction.</dd></dl> <p>For backward compatibility, the boolean value can be omitted.
This is interpreted as <strong>+c false</strong>.</p> </dd><dt><a name="+C_"></a><strong>+C no_time_warp | single_time_warp | multi_time_warp</strong></dt><dd> <p>Sets <a href="./time_correction#Time_Warp_Modes">time warp mode</a>:</p> <dl><dt><strong>no_time_warp</strong></dt><dd><a href="./time_correction#No_Time_Warp_Mode"> No time warp mode</a> (the default)</dd><dt><strong>single_time_warp</strong></dt><dd><a href="./time_correction#Single_Time_Warp_Mode"> Single time warp mode</a></dd><dt><strong>multi_time_warp</strong></dt><dd><a href="./time_correction#Multi_Time_Warp_Mode"> Multi-time warp mode</a></dd></dl> </dd><dt><strong>+d</strong></dt><dd> <p>If the emulator detects an internal error (or runs out of memory),
it, by default, generates both a crash dump and a core dump.
The core dump is, however, not very useful as the content
of process heaps is destroyed by the crash dump generation.</p> <p>Option <strong>+d</strong> instructs the emulator to produce only a
core dump and no crash dump if an internal error is detected.</p> <p>Calling <a href="./erlang#halt/1">erlang#halt/1</a> with a string argument still
produces a crash dump. On Unix systems, sending an emulator process
a <strong>SIGUSR1</strong> signal also forces a crash dump.</p> </dd><dt><a name="+dcg"></a><strong>+rg DecentralizedCounterGroupsLimit</strong></dt><dd> <p>Limits the number of decentralized counter groups used by
decentralized counters optimized for update operations in the
Erlang runtime system. By default, the limit is 256.</p> <p>When the number of schedulers is less than or equal to the
limit, each scheduler has its own group. When the
number of schedulers is larger than the groups limit,
schedulers share groups. Shared groups degrade
the performance for updating counters while many reader groups
degrade the performance for reading counters. So, the limit is a tradeoff
between performance for update operations and performance for
read operations. Each group consumes 64 bytes in each
counter.</p> <p>Notice that a runtime system using decentralized
counter groups benefits from <a href="#+sbt">binding schedulers to logical processors</a>, as the groups are
distributed better between schedulers with this option.</p> <p>This option only affects decentralized counters used for
the counters that are keeping track of the memory consumption
and the number of terms in ETS tables of type ordered_set with
the write_concurrency option activated.</p> </dd><dt><a name="+e"></a><strong>+e Number</strong></dt><dd> <p>Sets the maximum number of ETS tables. This limit is
<a href="../stdlib/ets#max_ets_tables">partially obsolete</a>.
</p> </dd><dt><strong>+ec</strong></dt><dd> <p>Forces option <strong>compressed</strong> on all ETS tables.
Only intended for test and evaluation.</p> </dd><dt><a name="file_name_encoding"></a> <strong>+fnl</strong></dt><dd> <p>The virtual machine works with filenames as if they are encoded
using the ISO Latin-1 encoding, disallowing Unicode characters with
code points &gt; 255.</p> <p>For more information about Unicode filenames, see section
<a href="../stdlib/unicode_usage#unicode_file_names">Unicode Filenames</a> in the STDLIB User's Guide. Notice that
this value also applies to command-line parameters and environment
variables (see section <a href="../stdlib/unicode_usage#unicode_in_environment_and_parameters"> Unicode in Environment and Parameters</a> in the STDLIB
User's Guide).</p> </dd><dt><strong>+fnu[{w|i|e}]</strong></dt><dd> <p>The virtual machine works with filenames as if they are encoded
using UTF-8 (or some other system-specific Unicode encoding). This is
the default on operating systems that enforce Unicode encoding, that
is, Windows and MacOS X.</p> <p>The <strong>+fnu</strong> switch can be followed by <strong>w</strong>, <strong>i</strong>, or
<strong>e</strong> to control how wrongly encoded filenames are to be
reported:</p> <ul><li> <p><strong>w</strong> means that a warning is sent to the <strong>error_logger</strong>
whenever a wrongly encoded filename is "skipped" in directory
listings. This is the default.</p> </li><li> <p><strong>i</strong> means that those wrongly encoded filenames are silently
ignored.</p> </li><li> <p><strong>e</strong> means that the API function returns an error whenever a
wrongly encoded filename (or directory name) is encountered.</p> </li></ul> <p>Notice that <a href="../kernel/file#read_link/1">kernel/file#read_link/1</a> always returns an error if the link
points to an invalid filename.</p> <p>For more information about Unicode filenames, see section
<a href="../stdlib/unicode_usage#unicode_file_names">Unicode Filenames</a> in the STDLIB User's Guide. Notice that
this value also applies to command-line parameters and environment
variables (see section <a href="../stdlib/unicode_usage#unicode_in_environment_and_parameters"> Unicode in Environment and Parameters</a> in the STDLIB
User's Guide).</p> </dd><dt><strong>+fna[{w|i|e}]</strong></dt><dd> <p>Selection between <strong>+fnl</strong> and <strong>+fnu</strong> is done based
on the current locale settings in the OS. This means that if you
have set your terminal for UTF-8 encoding, the filesystem is
expected to use the same encoding for filenames. This is
default on all operating systems, except MacOS X and Windows.</p> <p>The <strong>+fna</strong> switch can be followed by <strong>w</strong>, <strong>i</strong>, or
<strong>e</strong>. This has effect if the locale settings cause the behavior
of <strong>+fnu</strong> to be selected; see the description of <strong>+fnu</strong>
above. If the locale settings cause the behavior of <strong>+fnl</strong> to be
selected, then <strong>w</strong>, <strong>i</strong>, or <strong>e</strong> have no effect.</p> <p>For more information about Unicode filenames, see section
<a href="../stdlib/unicode_usage#unicode_file_names">Unicode Filenames</a> in the STDLIB User's Guide. Notice that
this value also applies to command-line parameters and environment
variables (see section <a href="../stdlib/unicode_usage#unicode_in_environment_and_parameters"> Unicode in Environment and Parameters</a> in the STDLIB
User's Guide).</p> </dd><dt><strong>+hms Size</strong></dt><dd> <p>Sets the default heap size of processes to the size
<strong>Size</strong>.</p> </dd><dt><strong>+hmbs Size</strong></dt><dd> <p>Sets the default binary virtual heap size of processes to the size
<strong>Size</strong>.</p> </dd><dt><a name="+hmax"></a><strong>+hmax Size</strong></dt><dd> <p>Sets the default maximum heap size of processes to the size
<strong>Size</strong>. Defaults to <strong>0</strong>, which means that no
maximum heap size is used. For more information, see
<a href="./erlang#process_flag_max_heap_size">erlang#process_flag_max_heap_size</a>.</p> </dd><dt><a name="+hmaxel"></a><strong>+hmaxel true|false</strong></dt><dd> <p>Sets whether to send an error logger message or not for processes
reaching the maximum heap size. Defaults to <strong>true</strong>.
For more information, see
<a href="./erlang#process_flag_max_heap_size">erlang#process_flag_max_heap_size</a>.</p> </dd><dt><a name="+hmaxk"></a><strong>+hmaxk true|false</strong></dt><dd> <p>Sets whether to kill processes reaching the maximum heap size or not.
Default to <strong>true</strong>. For more information, see
<a href="./erlang#process_flag_max_heap_size">erlang#process_flag_max_heap_size</a>.</p> </dd><dt><strong>+hpds Size</strong></dt><dd> <p>Sets the initial process dictionary size of processes to the size
<strong>Size</strong>.</p> </dd><dt><a name="+hmqd"></a><strong>+hmqd off_heap|on_heap</strong></dt><dd> <p>Sets the default value for process flag <strong>message_queue_data</strong>.
Defaults to <strong>on_heap</strong>. If <strong>+hmqd</strong> is not
passed, <strong>on_heap</strong> will be the default. For more information, see
<a href="./erlang#process_flag_message_queue_data">erlang#process_flag_message_queue_data</a>.</p> </dd><dt><a name="+IOp"></a><strong>+IOp PollSets</strong></dt><dd> <p>Sets the number of IO pollsets to use when polling for I/O.
This option is only used on platforms that support concurrent
updates of a pollset, otherwise the same number of pollsets
are used as IO poll threads.
The default is 1.
</p> </dd><dt><a name="+IOt"></a><strong>+IOt PollThreads</strong></dt><dd> <p>Sets the number of IO poll threads to use when polling for I/O.
The maximum number of poll threads allowed is 1024. The default is 1.
</p> <p>A good way to check if more IO poll threads are needed is to use
<a href="./msacc">microstate accounting</a>
and see what the load of the IO poll thread is. If it is high it could
be a good idea to add more threads.</p> </dd><dt><a name="+IOPp"></a><strong>+IOPp PollSetsPercentage</strong></dt><dd> <p>Similar to <a href="#+IOp">+IOp</a> but uses
percentages to set the number of IO pollsets to create, based on the
number of poll threads configured. If both <strong>+IOPp</strong> and <strong>+IOp</strong>
are used, <strong>+IOPp</strong> is ignored.
</p> </dd><dt><a name="+IOPt"></a><strong>+IOPt PollThreadsPercentage</strong></dt><dd> <p>Similar to <a href="#+IOt">+IOt</a> but uses
percentages to set the number of IO poll threads to create, based on
the number of schedulers configured. If both <strong>+IOPt</strong> and
<strong>+IOt</strong> are used, <strong>+IOPt</strong> is ignored.
</p> </dd><dt><strong>+l</strong></dt><dd> <p>Enables autoload tracing, displaying information while loading
code.</p> </dd><dt><strong>+L</strong></dt><dd> <p>Prevents loading information about source filenames and line
numbers. This saves some memory, but exceptions do not contain
information about the filenames and line numbers.</p> </dd><dt><a name="erts_alloc"></a><strong>+MFlag Value</strong></dt><dd> <p>Memory allocator-specific flags. For more information, see
<a href="erts_alloc">erts_alloc</a>.</p> </dd><dt><a name="+pc"></a><a name="printable_character_range"></a> <strong>+pc Range</strong></dt><dd> <p>Sets the range of characters that the system considers printable in
heuristic detection of strings. This typically affects the shell,
debugger, and <strong>io:format</strong> functions (when <strong>~tp</strong> is used in
the format string).</p>  <p>Two values are supported for <strong>Range</strong>:</p> <dl><dt><strong>latin1</strong></dt><dd>The default. Only characters in the ISO Latin-1 range can be considered printable. This means that a character with a code point &gt; 255 is never considered printable and that lists containing such characters are displayed as lists of integers rather than text strings by tools.</dd><dt><strong>unicode</strong></dt><dd>All printable Unicode characters are considered when determining if a list of integers is to be displayed in string syntax. This can give unexpected results if, for example, your font does not cover all Unicode characters.</dd></dl> <p>See also <a href="../stdlib/io#printable_range/0">stdlib/io#printable_range/0</a> in STDLIB.</p> </dd><dt><a name="+P"></a><a name="max_processes"></a><strong>+P Number</strong></dt><dd> <p>Sets the maximum number of simultaneously existing processes for this
system if a <strong>Number</strong> is passed as value. Valid range for
<strong>Number</strong> is <strong>[1024-134217727]</strong></p> <p><em>NOTE</em>: The actual maximum chosen may be much larger than
the <strong>Number</strong> passed. Currently the runtime system often,
but not always, chooses a value that is a power of 2. This might,
however, be changed in the future. The actual value chosen can be
checked by calling
<a href="./erlang#system_info_process_limit">erlang:system_info(process_limit)</a>.</p> <p>The default value is <strong>262144</strong></p> </dd><dt><a name="+Q"></a><a name="max_ports"></a><strong>+Q Number</strong></dt><dd> <p>Sets the maximum number of simultaneously existing ports for this
system if a Number is passed as value. Valid range for <strong>Number</strong>
is <strong>[1024-134217727]</strong></p> <p><em>NOTE</em>: The actual maximum chosen may be much larger than
the actual <strong>Number</strong> passed. Currently the runtime system often,
but not always, chooses a value that is a power of 2. This might,
however, be changed in the future. The actual value chosen can be
checked by calling
<a href="./erlang#system_info_port_limit">erlang:system_info(port_limit)</a>.</p> <p>The default value used is normally <strong>65536</strong>. However, if
the runtime system is able to determine maximum amount of file
descriptors that it is allowed to open and this value is larger
than <strong>65536</strong>, the chosen value will increased to a value
larger or equal to the maximum amount of file descriptors that
can be opened.</p> <p>On Windows the default value is set to <strong>8196</strong> because the
normal OS limitations are set higher than most machines can handle.</p> </dd><dt><a name="compat_rel"></a><strong>+R ReleaseNumber</strong></dt><dd> <p>Sets the compatibility mode.</p> <p>The distribution mechanism is not backward compatible by
default. This flag sets the emulator in compatibility mode
with an earlier Erlang/OTP release <strong>ReleaseNumber</strong>.
The release number must be in the range
<strong>&lt;current release&gt;-2..&lt;current release&gt;</strong>. This
limits the emulator, making it possible for it to communicate
with Erlang nodes (as well as C- and Java nodes) running that
earlier release.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Ensure that all nodes (Erlang-,  C-, and Java nodes) of
a distributed Erlang system is of the same Erlang/OTP release,
or from two different Erlang/OTP releases X and Y, where
<em>all</em> Y nodes have compatibility mode X.</p></div> </dd><dt><strong>+r</strong></dt><dd> <p>Forces ETS memory block to be moved on realloc.</p> </dd><dt><a name="+rg"></a><strong>+rg ReaderGroupsLimit</strong></dt><dd> <p>Limits the number of reader groups used by read/write locks
optimized for read operations in the Erlang runtime system. By
default the reader groups limit is 64.</p> <p>When the number of schedulers is less than or equal to the reader
groups limit, each scheduler has its own reader group. When the
number of schedulers is larger than the reader groups limit,
schedulers share reader groups. Shared reader groups degrade
read lock and read unlock performance while many
reader groups degrade write lock performance. So, the limit is a
tradeoff between performance for read operations and performance
for write operations. Each reader group consumes 64 byte
in each read/write lock.</p> <p>Notice that a runtime system using shared reader groups benefits from
<a href="#+sbt">binding schedulers to logical processors</a>, as the reader groups are distributed better
between schedulers.</p> </dd><dt><a name="+S"></a> <strong>+S Schedulers:SchedulerOnline</strong></dt><dd> <p>Sets the number of scheduler threads to create and scheduler threads
to set online. The maximum for both
values is 1024. If the Erlang runtime system is able to determine the
number of logical processors configured and logical processors
available, <strong>Schedulers</strong> defaults to logical processors
configured, and <strong>SchedulersOnline</strong> defaults to logical processors
available; otherwise the default values are 1. <strong>Schedulers</strong> can
be omitted if <strong>:SchedulerOnline</strong> is not and conversely. The
number of schedulers online can be changed at runtime through
<a href="./erlang#system_flag_schedulers_online">erlang#system_flag_schedulers_online</a>.</p> <p>If <strong>Schedulers</strong> or <strong>SchedulersOnline</strong> is specified as a
negative number, the value is subtracted from the default number of
logical processors configured or logical processors available,
respectively.</p> <p>Specifying value <strong>0</strong> for <strong>Schedulers</strong> or
<strong>SchedulersOnline</strong> resets the number of scheduler threads or
scheduler threads online, respectively, to its default value.</p> </dd><dt><a name="+SP"></a><strong>+SP SchedulersPercentage:SchedulersOnlinePercentage</strong></dt><dd> <p>Similar to <a href="#+S">+S</a> but uses
percentages to set the number of scheduler threads to create, based
on logical processors configured, and scheduler threads to set online,
based on logical processors available.
Specified values must be &gt; 0. For example,
<strong>+SP 50:25</strong> sets the number of scheduler threads to 50% of the
logical processors configured, and the number of scheduler threads
online to 25% of the logical processors available.
<strong>SchedulersPercentage</strong> can be omitted if
<strong>:SchedulersOnlinePercentage</strong> is not and conversely. The number
of schedulers online can be changed at runtime through
<a href="./erlang#system_flag_schedulers_online">erlang#system_flag_schedulers_online</a>.</p> <p>This option interacts with <a href="#+S">+S</a>
settings. For example, on a system with 8 logical cores configured
and 8 logical cores available, the combination of the options
<strong>+S 4:4 +SP 50:25</strong> (in either order) results in 2 scheduler
threads (50% of 4) and 1 scheduler thread online (25% of 4).</p> </dd><dt><a name="+SDcpu"></a><strong>+SDcpu DirtyCPUSchedulers:DirtyCPUSchedulersOnline</strong></dt><dd> <p>Sets the number of dirty CPU scheduler threads to create and dirty
CPU scheduler threads to set online.
The maximum for both values is 1024, and each value is
further limited by the settings for normal schedulers:</p> <ul><li>The number of dirty CPU scheduler threads created cannot exceed the number of normal scheduler threads created.</li><li>The number of dirty CPU scheduler threads online cannot exceed the number of normal scheduler threads online.</li></ul> <p>For details, see the <a href="#+S">+S</a> and
<a href="#+SP">+SP</a>. By default, the number
of dirty CPU scheduler threads created equals the number of normal
scheduler threads created, and the number of dirty CPU scheduler
threads online equals the number of normal scheduler threads online.
<strong>DirtyCPUSchedulers</strong> can be omitted if
<strong>:DirtyCPUSchedulersOnline</strong> is not and conversely. The number of
dirty CPU schedulers online can be changed at runtime through
<a href="./erlang#system_flag_dirty_cpu_schedulers_online">erlang#system_flag_dirty_cpu_schedulers_online</a>.</p> <p>The amount of dirty CPU schedulers is limited by the amount of
normal schedulers in order to limit the effect on processes
executing on ordinary schedulers. If the amount of dirty CPU
schedulers was allowed to be unlimited, dirty CPU bound jobs would
potentially starve normal jobs.</p> </dd><dt><a name="+SDPcpu"></a><strong>+SDPcpu DirtyCPUSchedulersPercentage:DirtyCPUSchedulersOnlinePercentage</strong></dt><dd> <p>Similar to <a href="#+SDcpu">+SDcpu</a> but
uses percentages to set the number of dirty CPU scheduler threads to
create and the number of dirty CPU scheduler threads to set online.
Specified values must be
&gt; 0. For example, <strong>+SDPcpu 50:25</strong> sets the number of dirty
CPU scheduler threads to 50% of the logical processors configured
and the number of dirty CPU scheduler threads online to 25% of the
logical processors available. <strong>DirtyCPUSchedulersPercentage</strong> can
be omitted if <strong>:DirtyCPUSchedulersOnlinePercentage</strong> is not and
conversely. The number of dirty CPU schedulers online can be changed
at runtime through
<a href="./erlang#system_flag_dirty_cpu_schedulers_online">erlang#system_flag_dirty_cpu_schedulers_online</a>.</p> <p>This option interacts with <a href="#+SDcpu">+SDcpu</a> settings. For example, on a
system with 8 logical cores configured and 8 logical cores available,
the combination of the options <strong>+SDcpu 4:4 +SDPcpu 50:25</strong> (in
either order) results in 2 dirty CPU scheduler threads (50% of 4) and
1 dirty CPU scheduler thread online (25% of 4).</p> </dd><dt><a name="+SDio"></a><strong>+SDio DirtyIOSchedulers</strong></dt><dd> <p>Sets the number of dirty I/O scheduler threads to create.
Valid range is 0-1024. By
default, the number of dirty I/O scheduler threads created is 10,
same as the default number of threads in the <a href="#async_thread_pool_size">async thread pool</a>.</p> <p>The amount of dirty IO schedulers is not limited by the amount of
normal schedulers <a href="#+SDcpu">like the amount of dirty CPU schedulers</a>. This since only I/O bound work is
expected to execute on dirty I/O schedulers. If the user should schedule CPU
bound jobs on dirty I/O schedulers, these jobs might starve ordinary
jobs executing on ordinary schedulers.</p> </dd><dt><strong>+sFlag Value</strong></dt><dd> <p>Scheduling specific flags.</p> <dl><dt><a name="+sbt"></a><strong>+sbt BindType</strong></dt><dd> <p>Sets scheduler bind type.</p> <p>Schedulers can also be bound using flag
<a href="#+stbt">+stbt</a>. The only
difference between these two flags is how the following errors
are handled:</p> <ul><li>Binding of schedulers is not supported on the specific platform.</li><li>No available CPU topology. That is, the runtime system was not able to detect the CPU topology automatically, and no <a href="#+sct">user-defined CPU topology</a> was set.</li></ul> <p>If any of these errors occur when <strong>+sbt</strong> has been passed,
the runtime system prints an error message, and refuses to
start. If any of these errors occur when <strong>+stbt</strong> has been
passed, the runtime system silently ignores the error, and
start up using unbound schedulers.</p> <p>Valid <strong>BindType</strong>s:</p> <dl><dt><strong>u</strong></dt><dd><strong>unbound</strong> - Schedulers are not bound to logical processors, that is, the operating system decides where the scheduler threads execute, and when to migrate them. This is the default. </dd><dt><strong>ns</strong></dt><dd><strong>no_spread</strong> - Schedulers with close scheduler identifiers are bound as close as possible in hardware. </dd><dt><strong>ts</strong></dt><dd><strong>thread_spread</strong> - Thread refers to hardware threads (such as Intel's hyper-threads). Schedulers with low scheduler identifiers, are bound to the first hardware thread of each core, then schedulers with higher scheduler identifiers are bound to the second hardware thread of each core,and so on. </dd><dt><strong>ps</strong></dt><dd><strong>processor_spread</strong> - Schedulers are spread like <strong>thread_spread</strong>, but also over physical processor chips. </dd><dt><strong>s</strong></dt><dd><strong>spread</strong> - Schedulers are spread as much as possible. </dd><dt><strong>nnts</strong></dt><dd><strong>no_node_thread_spread</strong> - Like <strong>thread_spread</strong>, but if multiple Non-Uniform Memory Access (NUMA) nodes exist, schedulers are spread over one NUMA node at a time, that is, all logical processors of one NUMA node are bound to schedulers in sequence. </dd><dt><strong>nnps</strong></dt><dd><strong>no_node_processor_spread</strong> - Like <strong>processor_spread</strong>, but if multiple NUMA nodes exist, schedulers are spread over one NUMA node at a time, that is, all logical processors of one NUMA node are bound to schedulers in sequence. </dd><dt><strong>tnnps</strong></dt><dd><strong>thread_no_node_processor_spread</strong> - A combination of <strong>thread_spread</strong>, and <strong>no_node_processor_spread</strong>. Schedulers are spread over hardware threads across NUMA nodes, but schedulers are only spread over processors internally in one NUMA node at a time. </dd><dt><strong>db</strong></dt><dd><strong>default_bind</strong> - Binds schedulers the default way. Defaults to <strong>thread_no_node_processor_spread</strong> (which can change in the future). </dd></dl> <p>Binding of schedulers is only supported on newer
Linux, Solaris, FreeBSD, and Windows systems.</p> <p>If no CPU topology is available when flag <strong>+sbt</strong>
is processed and <strong>BindType</strong> is any other type than
<strong>u</strong>, the runtime system fails to start. CPU
topology can be defined using flag
<a href="#+sct">+sct</a>. Notice
that flag <strong>+sct</strong> can have to be passed before flag
<strong>+sbt</strong> on the command line (if no CPU topology
has been automatically detected).</p> <p>The runtime system does by default <em>not</em> bind schedulers
to logical processors.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If the Erlang runtime system is the only operating system
process that binds threads to logical processors, this
improves the performance of the runtime system. However,
if other operating system processes (for example
another Erlang runtime system) also bind threads to
logical processors, there can be a performance penalty
instead. This performance penalty can sometimes be
severe. If so, you are advised not to
bind the schedulers.</p></div> <p>How schedulers are bound matters. For example, in
situations when there are fewer running processes than
schedulers online, the runtime system tries to migrate
processes to schedulers with low scheduler identifiers.
The more the schedulers are spread over the hardware,
the more resources are available to the runtime
system in such situations.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If a scheduler fails to bind, this is
often silently ignored, as it is not always
possible to verify valid logical processor identifiers. If
an error is reported, it is reported to the
<strong>error_logger</strong>. If you want to verify that the
schedulers have bound as requested, call
<a href="./erlang#system_info_scheduler_bindings">erlang#system_info_scheduler_bindings</a>.</p></div> </dd><dt><a name="+sbwt"></a> <strong>+sbwt none|very_short|short|medium|long|very_long</strong></dt><dd> <p>Sets scheduler busy wait threshold. Defaults to <strong>medium</strong>.
The threshold determines how long schedulers are to busy
wait when running out of work before going to sleep.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag can be removed or changed at any time
without prior notice.</p></div> </dd><dt><a name="+sbwtdcpu"></a> <strong>+sbwtdcpu none|very_short|short|medium|long|very_long</strong></dt><dd> <p>As <a href="#+sbwt">+sbwt</a> but affects
dirty CPU schedulers. Defaults to <strong>short</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag can be removed or changed at any time
without prior notice.</p></div> </dd><dt><a name="+sbwtdio"></a> <strong>+sbwtdio none|very_short|short|medium|long|very_long</strong></dt><dd> <p>As <a href="#+sbwt">+sbwt</a> but affects
dirty IO schedulers. Defaults to <strong>short</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag can be removed or changed at any time
without prior notice.</p></div> </dd><dt><a name="+scl"></a><strong>+scl true|false</strong></dt><dd> <p>Enables or disables scheduler compaction of load. By default
scheduler compaction of load is enabled. When enabled, load
balancing strives for a load distribution, which causes
as many scheduler threads as possible to be fully loaded (that is,
not run out of work). This is accomplished by migrating load
(for example, runnable processes) into a smaller set of schedulers
when schedulers frequently run out of work. When disabled,
the frequency with which schedulers run out of work is
not taken into account by the load balancing logic.</p> <p><strong>+scl false</strong> is similar to
<a href="#+sub">+sub</a>, but
<strong>+sub true</strong> also balances scheduler utilization
between schedulers.</p> </dd><dt><a name="+sct"></a><strong>+sct CpuTopology</strong></dt><dd> <ul><li><strong>&lt;Id&gt; = integer(); when 0 =&lt; &lt;Id&gt; =&lt; 65535</strong> </li><li><strong>&lt;IdRange&gt; = &lt;Id&gt;-&lt;Id&gt;</strong></li><li><strong>&lt;IdOrIdRange&gt; = &lt;Id&gt; | &lt;IdRange&gt;</strong></li><li><strong>&lt;IdList&gt; = &lt;IdOrIdRange&gt;,&lt;IdOrIdRange&gt; | &lt;IdOrIdRange&gt;</strong></li><li><strong>&lt;LogicalIds&gt; = L&lt;IdList&gt;</strong></li><li><strong>&lt;ThreadIds&gt; = T&lt;IdList&gt; | t&lt;IdList&gt;</strong> </li><li><strong>&lt;CoreIds&gt; = C&lt;IdList&gt; | c&lt;IdList&gt;</strong></li><li><strong>&lt;ProcessorIds&gt; = P&lt;IdList&gt; | p&lt;IdList&gt;</strong> </li><li><strong>&lt;NodeIds&gt; = N&lt;IdList&gt; | n&lt;IdList&gt;</strong></li><li><strong>&lt;IdDefs&gt; = &lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;ProcessorIds&gt;&lt;NodeIds&gt; | &lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;NodeIds&gt;&lt;ProcessorIds&gt;</strong> </li><li><strong>CpuTopology = &lt;IdDefs&gt;:&lt;IdDefs&gt; | &lt;IdDefs&gt;</strong></li></ul> <p>Sets a user-defined CPU topology. The user-defined
CPU topology overrides any automatically detected
CPU topology. The CPU topology is used when
<a href="#+sbt">binding schedulers to logical processors</a>.</p> <p>Uppercase letters signify real identifiers and lowercase
letters signify fake identifiers only used for description
of the topology. Identifiers passed as real identifiers can
be used by the runtime system when trying to access specific
hardware; if they are incorrect the behavior is
undefined. Faked logical CPU identifiers are not accepted,
as there is no point in defining the CPU topology without
real logical CPU identifiers. Thread, core, processor, and
node identifiers can be omitted. If omitted, the thread ID
defaults to <strong>t0</strong>, the core ID defaults to <strong>c0</strong>,
the processor ID defaults to <strong>p0</strong>, and the node ID is
left undefined. Either each logical processor must 
belong to only one NUMA node, or no logical
processors must belong to any NUMA nodes.</p> <p>Both increasing and decreasing <strong>&lt;IdRange&gt;</strong>s
are allowed.</p> <p>NUMA node identifiers are system wide. That is, each NUMA
node on the system must have a unique identifier. Processor
identifiers are also system wide. Core identifiers are
processor wide. Thread identifiers are core wide.</p> <p>The order of the identifier types implies the hierarchy of the
CPU topology. The valid orders are as follows:</p> <ul><li> <p><strong>&lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;ProcessorIds&gt;&lt;NodeIds&gt;</strong>,
that is, thread is part of a core that is part of a processor,
which is part of a NUMA node.</p> </li><li> <p><strong>&lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;NodeIds&gt;&lt;ProcessorIds&gt;</strong>,
that is, thread is part of a core that is part of a NUMA node,
which is part of a processor.</p> </li></ul> <p>A CPU topology can consist of both processor external, and
processor internal NUMA nodes as long as each logical processor
belongs to only one NUMA node. If
<strong>&lt;ProcessorIds&gt;</strong> is omitted, its default position
is before <strong>&lt;NodeIds&gt;</strong>. That is, the default is
processor external NUMA nodes.</p> <p>If a list of identifiers is used in an
<strong>&lt;IdDefs&gt;</strong>:</p> <ul><li><strong>&lt;LogicalIds&gt;</strong> must be a list of identifiers.</li><li>At least one other identifier type besides <strong>&lt;LogicalIds&gt;</strong> must also have a list of identifiers.</li><li>All lists of identifiers must produce the same number of identifiers.</li></ul> <p>A simple example. A single quad core processor can be
described as follows:</p> <pre>
% <span class="input">erl +sct L0-3c0-3</span>
1&gt; <span class="input">erlang:system_info(cpu_topology).</span>
[{processor,[{core,{logical,0}},
             {core,{logical,1}},
             {core,{logical,2}},
             {core,{logical,3}}]}]</pre> <p>A more complicated example with two quad core
processors, each processor in its own NUMA node.
The ordering of logical processors is a bit weird.
This to give a better example of identifier lists:</p> <pre>
% <span class="input">erl +sct L0-1,3-2c0-3p0N0:L7,4,6-5c0-3p1N1</span>
1&gt; <span class="input">erlang:system_info(cpu_topology).</span>
[{node,[{processor,[{core,{logical,0}},
                    {core,{logical,1}},
                    {core,{logical,3}},
                    {core,{logical,2}}]}]},
 {node,[{processor,[{core,{logical,7}},
                    {core,{logical,4}},
                    {core,{logical,6}},
                    {core,{logical,5}}]}]}]</pre> <p>As long as real identifiers are correct, it is OK
to pass a CPU topology that is not a correct
description of the CPU topology. When used with
care this can be very useful. This
to trick the emulator to bind its schedulers
as you want. For example, if you want to run multiple
Erlang runtime systems on the same machine, you
want to reduce the number of schedulers used and
manipulate the CPU topology so that they bind to
different logical CPUs. An example, with two Erlang
runtime systems on a quad core machine:</p> <pre>
% <span class="input">erl +sct L0-3c0-3 +sbt db +S3:2 -detached -noinput -noshell -sname one</span>
% <span class="input">erl +sct L3-0c0-3 +sbt db +S3:2 -detached -noinput -noshell -sname two</span></pre> <p>In this example, each runtime system have two
schedulers each online, and all schedulers online
will run on different cores. If we change to one
scheduler online on one runtime system, and three
schedulers online on the other, all schedulers
online will still run on different cores.</p> <p>Notice that a faked CPU topology that does not reflect
how the real CPU topology looks like is likely to
decrease the performance of the runtime system.</p> <p>For more information, see
<a href="./erlang#system_info_cpu_topology">erlang#system_info_cpu_topology</a>.</p> </dd><dt><a name="+sfwi"></a><strong>+sfwi Interval</strong></dt><dd> <p>Sets scheduler-forced wakeup interval. All run queues are
scanned each <strong>Interval</strong> milliseconds. While there are
sleeping schedulers in the system, one scheduler is woken
for each non-empty run queue found. <strong>Interval</strong> default
to <strong>0</strong>, meaning this feature is disabled.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This feature has been introduced as a temporary workaround
for long-executing native code, and native code that does not
bump reductions properly in OTP. When these bugs have be fixed,
this flag will be removed.</p></div> </dd><dt><a name="+spp"></a><strong>+spp Bool</strong></dt><dd> <p>Sets default scheduler hint for port parallelism. If set to
<strong>true</strong>, the virtual machine schedules port tasks when it
improves parallelism in the system. If set to <strong>false</strong>, the
virtual machine tries to perform port tasks immediately,
improving latency at the expense of parallelism. Default to
<strong>false</strong>. The default used can be inspected in runtime by
calling <a href="./erlang#system_info_port_parallelism">erlang#system_info_port_parallelism</a>.
The default can be overridden on port creation by passing option
<a href="./erlang#open_port_parallelism">erlang#open_port_parallelism</a> to
<a href="./erlang#open_port/2">erlang#open_port/2</a></p>. </dd><dt><a name="sched_thread_stack_size"></a> <strong>+sss size</strong></dt><dd> <p>Suggested stack size, in kilowords, for scheduler threads.
Valid range is 20-8192 kilowords. The default suggested
stack size is 128 kilowords.</p> </dd><dt><a name="dcpu_sched_thread_stack_size"></a> <strong>+sssdcpu size</strong></dt><dd> <p>Suggested stack size, in kilowords, for dirty CPU scheduler
threads. Valid range is 20-8192 kilowords. The default
suggested stack size is 40 kilowords.</p> </dd><dt><a name="dio_sched_thread_stack_size"></a> <strong>+sssdio size</strong></dt><dd> <p>Suggested stack size, in kilowords, for dirty IO scheduler
threads. Valid range is 20-8192 kilowords. The default
suggested stack size is 40 kilowords.</p> </dd><dt><a name="+stbt"></a><strong>+stbt BindType</strong></dt><dd> <p>Tries to set the scheduler bind type. The same as flag
<a href="#+sbt">+sbt</a> except
how some errors are handled. For more information, see
<a href="#+sbt">+sbt</a>.</p> </dd><dt><a name="+sub"></a><strong>+sub true|false</strong></dt><dd> <p>Enables or disables
<a href="../erts/erlang#statistics_scheduler_wall_time"> scheduler utilization</a> balancing of load. By default
scheduler utilization balancing is disabled and instead scheduler
compaction of load is enabled, which strives for a load
distribution that causes as many scheduler threads as possible
to be fully loaded (that is, not run out of work). When scheduler
utilization balancing is enabled, the system instead tries to
balance scheduler utilization between schedulers. That is,
strive for equal scheduler utilization on all schedulers.</p> <p><strong>+sub true</strong> is only supported on systems where the runtime
system detects and uses a monotonically increasing high-resolution
clock. On other systems, the runtime system fails to start.</p> <p><strong>+sub true</strong> implies <a href="#+scl">+scl</a>. The difference between
<strong>+sub true</strong> and <strong>+scl false</strong> is that <strong>+scl false</strong>
does not try to balance the scheduler utilization.</p> </dd><dt><a name="+swct"></a> <strong>+swct very_eager|eager|medium|lazy|very_lazy</strong></dt><dd> <p>Sets scheduler wake cleanup threshold. Defaults to <strong>medium</strong>.
Controls how eager schedulers are to be requesting
wakeup because of certain cleanup operations. When a lazy setting
is used, more outstanding cleanup operations can be left undone
while a scheduler is idling. When an eager setting is used,
schedulers are more frequently woken, potentially increasing
CPU-utilization.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag can be removed or changed at any time without prior
notice.</p></div> </dd><dt><a name="+sws"></a><strong>+sws default|legacy</strong></dt><dd> <p>Sets scheduler wakeup strategy. Default strategy changed in
ERTS 5.10 (Erlang/OTP R16A). This strategy was known as
<strong>proposal</strong> in Erlang/OTP R15. The <strong>legacy</strong> strategy
was used as default from R13 up to and including R15.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag can be removed or changed at any time without prior
notice.</p></div> </dd><dt><a name="+swt"></a> <strong>+swt very_low|low|medium|high|very_high</strong></dt><dd> <p>Sets scheduler wakeup threshold. Defaults to <strong>medium</strong>.
The threshold determines when to wake up sleeping schedulers
when more work than can be handled by currently awake schedulers
exists. A low threshold causes earlier wakeups, and a high
threshold causes later wakeups. Early wakeups distribute work
over multiple schedulers faster, but work does more easily bounce
between schedulers.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag can be removed or changed at any time without prior
notice.</p></div> </dd><dt><a name="+swtdcpu"></a> <strong>+swtdcpu very_low|low|medium|high|very_high</strong></dt><dd> <p>As <a href="#+swt">+swt</a> but
affects dirty CPU schedulers. Defaults to <strong>medium</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag can be removed or changed at any time
without prior notice.</p></div> </dd><dt><a name="+swtdio"></a> <strong>+swtdio very_low|low|medium|high|very_high</strong></dt><dd> <p>As <a href="#+swt">+swt</a> but affects
dirty IO schedulers. Defaults to <strong>medium</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag can be removed or changed at any time
without prior notice.</p></div> </dd></dl> </dd><dt><a name="+t"></a><strong>+t size</strong></dt><dd> <p>Sets the maximum number of atoms the virtual machine can handle.
Defaults to 1,048,576.</p> </dd><dt><a name="+T"></a><strong>+T Level</strong></dt><dd> <p>Enables modified timing and sets the modified timing level. Valid
range is 0-9. The timing of the runtime system is changed. A high
level usually means a greater change than a low level. Changing the
timing can be very useful for finding timing-related bugs.</p> <p>Modified timing affects the following:</p> <dl><dt>Process spawning</dt><dd>A process calling <strong>spawn</strong>, <strong>spawn_link</strong>, <strong>spawn_monitor</strong>, or <strong>spawn_opt</strong> is scheduled out immediately after completing the call. When higher modified timing levels are used, the caller also sleeps for a while after it is scheduled out. </dd><dt>Context reductions</dt><dd>The number of reductions a process is allowed to use before it is scheduled out is increased or reduced. </dd><dt>Input reductions</dt><dd>The number of reductions performed before checking I/O is increased or reduced. </dd></dl> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Performance suffers when modified timing is enabled. This flag is
<em>only</em> intended for testing and debugging.</p><p><strong>return_to</strong> and <strong>return_from</strong>
trace messages are lost when tracing on the spawn BIFs.</p><p>This flag can be removed or changed at any time without prior
notice.</p></div> </dd><dt><strong>+v</strong></dt><dd> <p>Verbose.</p> </dd><dt><strong>+V</strong></dt><dd> <p>Makes the emulator print its version number.</p> </dd><dt><strong>+W w | i | e</strong></dt><dd> <p>Sets the mapping of warning messages for
<strong>error_logger</strong>. Messages sent to the error logger
using one of the warning routines can be mapped to errors
(<strong>+W e</strong>), warnings (<strong>+W w</strong>), or
information reports (<strong>+W i</strong>). Defaults to warnings.
The current mapping can be retrieved using
<strong>error_logger:warning_map/0</strong>. For more information,
see <a href="../kernel/error_logger#warning_map/0">kernel/error_logger#warning_map/0</a> in Kernel.</p> </dd><dt><strong>+zFlag Value</strong></dt><dd> <p>Miscellaneous flags:</p> <dl><dt><a name="+zdbbl"></a><strong>+zdbbl size</strong></dt><dd> <p>Sets the distribution buffer busy limit
(<a href="./erlang#system_info_dist_buf_busy_limit">erlang#system_info_dist_buf_busy_limit</a>)
in kilobytes. Valid range is 1-2097151. Defaults to 1024.</p> <p>A larger buffer limit allows processes to buffer
more outgoing messages over the distribution. When the
buffer limit has been reached, sending processes will be
suspended until the buffer size has shrunk. The buffer
limit is per distribution channel. A higher limit
gives lower latency and higher throughput at the expense
of higher memory use.</p> </dd><dt><a name="+zdntgc"></a><strong>+zdntgc time</strong></dt><dd> <p>Sets the delayed node table garbage collection time
(<a href="./erlang#system_info_delayed_node_table_gc">erlang#system_info_delayed_node_table_gc</a>)
in seconds. Valid values are either <strong>infinity</strong> or
an integer in the range 0-100000000. Defaults to 60.</p> <p>Node table entries that are not referred linger
in the table for at least the amount of time that this
parameter determines. The lingering prevents repeated
deletions and insertions in the tables from occurring.</p> </dd></dl> </dd></dl><a name="environment_variables"></a><h4>Environment Variables</h4><dl><dt><strong>ERL_CRASH_DUMP</strong></dt><dd> <p>If the emulator needs to write a crash dump, the value of this
variable is the filename of the crash dump file.
If the variable is not set, the name of the crash dump file is
<strong>erl_crash.dump</strong> in the current directory.</p> </dd><dt><strong>ERL_CRASH_DUMP_NICE</strong></dt><dd> <p><em>Unix systems</em>: If the emulator needs to write a crash dump,
it uses the value of this variable to set the nice value
for the process, thus lowering its priority. Valid range is
1-39 (higher values are replaced with 39). The highest
value, 39, gives the process the lowest priority.</p> </dd><dt><strong>ERL_CRASH_DUMP_SECONDS</strong></dt><dd> <p><em>Unix systems</em>: This variable gives the number of seconds
that the emulator is allowed to spend writing a crash dump. When the
given number of seconds have elapsed, the emulator is terminated.</p> <dl><dt><strong>ERL_CRASH_DUMP_SECONDS=0</strong></dt><dd>If the variable is set to <strong>0</strong> seconds, the runtime system does not even attempt to write the crash dump file. It only terminates. This is the default if option <strong>-heart</strong> is passed to <strong>erl</strong> and <strong>ERL_CRASH_DUMP_SECONDS</strong> is not set. </dd><dt><strong>ERL_CRASH_DUMP_SECONDS=S</strong></dt><dd>If the variable is set to a positive value <strong>S</strong>, wait for <strong>S</strong> seconds to complete the crash dump file and then terminates the runtime system with a <strong>SIGALRM</strong> signal. </dd><dt><strong>ERL_CRASH_DUMP_SECONDS=-1</strong></dt><dd>A negative value causes the termination of the runtime system to wait indefinitely until the crash dump file has been completly written. This is the default if option <strong>-heart</strong> is <em>not</em> passed to <strong>erl</strong> and <strong>ERL_CRASH_DUMP_SECONDS</strong> is not set. </dd></dl> <p>See also <a href="./heart">kernel/heart</a>.</p> </dd><dt><strong>ERL_CRASH_DUMP_BYTES</strong></dt><dd> <p>This variable sets the maximum size of a crash dump file in bytes.
The crash dump will be truncated if this limit is exceeded. If the
variable is not set, no size limit is enforced by default. If the
variable is set to <strong>0</strong>, the runtime system does not even attempt
to write a crash dump file.</p> <p>Introduced in ERTS 8.1.2 (Erlang/OTP 19.2).</p> </dd><dt><a name="ERL_AFLAGS"></a><strong>ERL_AFLAGS</strong></dt><dd> <p>The content of this variable is added to the beginning of the
command line for <strong>erl</strong>.</p> <p>Flag <strong>-extra</strong> is treated in a special way. Its
scope ends at the end of the environment variable content. Arguments
following an <strong>-extra</strong> flag are moved on the command
line into section <strong>-extra</strong>, that is, the end of the
command line following an <strong>-extra</strong> flag.</p> </dd><dt><a name="ERL_ZFLAGS"></a><strong>ERL_ZFLAGS</strong> and <a name="ERL_FLAGS"></a><strong>ERL_FLAGS</strong></dt><dd> <p>The content of these variables are added to the end of the command
line for <strong>erl</strong>.</p> <p>Flag <strong>-extra</strong> is treated in a special way. Its
scope ends at the end of the environment variable content. Arguments
following an <strong>-extra</strong> flag are moved on the command
line into section <strong>-extra</strong>, that is, the end of the
command line following an <strong>-extra</strong> flag.</p> </dd><dt><strong>ERL_LIBS</strong></dt><dd> <p>Contains a list of additional library directories that the code
server searches for applications and adds to the code path; see
<a href="./code">kernel/code</a>.</p> </dd><dt><strong>ERL_EPMD_ADDRESS</strong></dt><dd> <p>Can be set to a comma-separated list of IP addresses, in which case
the <a href="epmd">epmd</a> daemon listens only
on the specified address(es) and on the loopback address (which is
implicitly added to the list if it has not been specified).</p> </dd><dt><strong>ERL_EPMD_PORT</strong></dt><dd> <p>Can contain the port number to use when communicating with
<a href="epmd">epmd</a>. The default port works
fine in most cases. A different port can be specified
to allow nodes of independent clusters to co-exist on the same host.
All nodes in a cluster must use the same <strong>epmd</strong> port number.</p> </dd></dl><a name="signals"></a><h4>Signals</h4><p>On Unix systems, the Erlang runtime will interpret two types of signals.</p><dl><dt><strong>SIGUSR1</strong></dt><dd> <p>A <strong>SIGUSR1</strong> signal forces a crash dump.</p> </dd><dt><strong>SIGTERM</strong></dt><dd> <p>A <strong>SIGTERM</strong> will produce a <strong>stop</strong> message to the <strong>init</strong> process.
This is equivalent to a <strong>init:stop/0</strong> call.</p> <p>Introduced in ERTS 8.3 (Erlang/OTP 19.3)</p> </dd></dl><p>The signal <strong>SIGUSR2</strong> is reserved for internal usage. No other signals are handled.</p><a name="configuration"></a><h4>Configuration</h4><p>The standard Erlang/OTP system can be reconfigured to change the default
behavior on startup.</p><dl><dt>The <strong>.erlang</strong> startup file</dt><dd> <p>When Erlang/OTP is started, the system searches for a file named
<strong>.erlang</strong> in the user's home directory.</p> <p>If an <strong>.erlang</strong> file is found, it is assumed to contain valid
Erlang expressions. These expressions are evaluated as if they were
input to the shell.</p> <p>A typical <strong>.erlang</strong> file contains a set of search paths, for
example:</p> <pre><code class="">
io:format("executing user profile in HOME/.erlang\n",[]).
code:add_path("/home/calvin/test/ebin").
code:add_path("/home/hobbes/bigappl-1.2/ebin").
io:format(".erlang rc finished\n",[]).    </code></pre> </dd><dt>user_default and shell_default</dt><dd> <p>Functions in the shell that are not prefixed by a module name are
assumed to be functional objects (funs), built-in functions (BIFs),
or belong to the module <strong>user_default</strong> or
<strong>shell_default</strong>.</p> <p>To include private shell commands, define them in a module
<strong>user_default</strong> and add the following argument as the first line
in the <strong>.erlang</strong> file:</p> <pre><code class="">
code:load_abs("..../user_default").    </code></pre> </dd><dt>erl</dt><dd> <p>If the contents of <strong>.erlang</strong> are changed and a private version
of <strong>user_default</strong> is defined, the Erlang/OTP environment can be
customized. More powerful changes can be made by supplying
command-line arguments in the startup script <strong>erl</strong>. For more
information, see <a href="init">init</a>.</p> </dd></dl><h4>See Also</h4><p><a href="epmd">epmd</a>,
<a href="erl_prim_loader">erl_prim_loader</a>,
<a href="erts_alloc">erts_alloc</a>,
<a href="init">init</a>,
<a href="./application">kernel/application</a>,
<a href="./auth">kernel/auth</a>,
<a href="./code">kernel/code</a>,
<a href="./erl_boot_server">kernel/erl_boot_server</a>,
<a href="./heart">kernel/heart</a>,
<a href="./net_kernel">kernel/net_kernel</a>,
<a href="./make">tools/make</a></p><h3>erlang</h3><p>The Erlang BIFs.</p><p>By convention, most Built-In Functions (BIFs) are included
in this module. Some of the BIFs are viewed more
or less as part of the Erlang programming language and are
<em>auto-imported</em>. Thus, it is not necessary to specify the
module name. For example, the calls <strong>atom_to_list(erlang)</strong>
and <strong>erlang:atom_to_list(erlang)</strong> are identical.Auto-imported BIFs are listed without module prefix.
BIFs listed with module prefix are not auto-imported.BIFs can fail for various reasons. All BIFs fail with
reason <strong>badarg</strong> if they are called with arguments of an
incorrect type. The other reasons are described in the
description of each individual BIF.Some BIFs can be used in guard tests and are marked with
"Allowed in guard tests".</p><h3>Data Types</h3><span class="name">ext_binary</span><p>A binary data object, structured according to
the Erlang external term format.</p><span class="name">iovec</span><p>A list of binaries. This datatype is useful to use
together with <a href="./erl_nif#enif_inspect_iovec">erl_nif#enif_inspect_iovec</a>.</p><span class="name">message_queue_data</span><p>See <a href="#process_flag_message_queue_data">process_flag_message_queue_data</a>.</p><span class="name">timestamp</span><p>See <a href="#timestamp/0">timestamp/0</a>.</p><span class="name">time_unit</span><a name="type_time_unit"></a><p>Supported time unit representations:</p><dl><dt><strong>PartsPerSecond :: integer() &gt;= 1</strong></dt><dd> <p>Time unit expressed in parts per second. That is,
the time unit equals <strong>1/PartsPerSecond</strong> second.</p> </dd><dt><strong>second</strong></dt><dd> <p>Symbolic representation of the time unit
represented by the integer <strong>1</strong>.</p> </dd><dt><strong>millisecond</strong></dt><dd> <p>Symbolic representation of the time unit
represented by the integer <strong>1000</strong>.</p> </dd><dt><strong>microsecond</strong></dt><dd> <p>Symbolic representation of the time unit
represented by the integer <strong>1000000</strong>.</p> </dd><dt><strong>nanosecond</strong></dt><dd> <p>Symbolic representation of the time unit
represented by the integer <strong>1000000000</strong>.</p> </dd><dt><strong>native</strong></dt><dd> <p>Symbolic representation of the native time unit
used by the Erlang runtime system.</p> <p>The <strong>native</strong> time unit is determined at
runtime system start, and remains the same until
the runtime system terminates. If a runtime system
is stopped and then started again (even on the same
machine), the <strong>native</strong> time unit of the new
runtime system instance can differ from the
<strong>native</strong> time unit of the old runtime system
instance.</p> <p>One can get an approximation of the <strong>native</strong>
time unit by calling
<a href="#convert_time_unit/3">convert_time_unit/3</a>.
The result equals the number
of whole <strong>native</strong> time units per second. If
the number of <strong>native</strong> time units per second does not
add up to a whole number, the result is rounded downwards.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The value of the <strong>native</strong> time unit gives
you more or less no information about the
quality of time values. It sets a limit for the
<a href="./time_correction#Time_Resolution"> resolution</a> and for the
<a href="./time_correction#Time_Precision"> precision</a> of time values,
but it gives no information about the
<a href="./time_correction#Time_Accuracy"> accuracy</a> of time values. The resolution of
the <strong>native</strong> time unit and the resolution of time
values can differ significantly.</p></div> </dd><dt><strong>perf_counter</strong></dt><dd> <p>Symbolic representation of the performance counter
time unit used by the Erlang runtime system.</p> <p>The <strong>perf_counter</strong> time unit behaves much in the same way
as the <strong>native</strong> time unit. That is, it can differ between
runtime restarts. To get values of this type, call
<a href="../kernel/os#perf_counter/0">kernel/os#perf_counter/0</a>.</p> </dd><dt><a href="#type_deprecated_time_unit">type_deprecated_time_unit</a></dt><dd><p>
Deprecated symbolic representations kept for backwards-compatibility.
</p></dd></dl><p>The <strong>time_unit/0</strong> type can be extended.
To convert time values between time units, use
<a href="#convert_time_unit/3">convert_time_unit/3</a>.</p><span class="name">deprecated_time_unit</span><a name="type_deprecated_time_unit"></a><p>The <a href="#type_time_unit">type_time_unit</a>
type also consist of the following <em>deprecated</em> symbolic
time units:</p><dl><dt><strong>seconds</strong></dt><dd><p>Same as <a href="#type_time_unit">type_time_unit</a>.</p></dd><dt><strong>milli_seconds</strong></dt><dd><p>Same as <a href="#type_time_unit">type_time_unit</a>.</p></dd><dt><strong>micro_seconds</strong></dt><dd><p>Same as <a href="#type_time_unit">type_time_unit</a>.</p></dd><dt><strong>nano_seconds</strong></dt><dd><p>Same as <a href="#type_time_unit">type_time_unit</a>.</p></dd></dl><span class="name">dist_handle</span><p>An opaque handle identifing a distribution channel.</p><span class="name">nif_resource</span><p>An opaque handle identifing a
<a href="./erl_nif#resource_objects">NIF resource object </a>.</p><h3>Functions</h3><h4>abs/1</h4><h4>abs/1</h4><p>Arithmetical absolute value.</p><p>Returns an integer or float that is the arithmetical
absolute value of <strong><span class="anno">Float</span></strong> or
<strong><span class="anno">Int</span></strong>, for example:</p><pre>
&gt; <span class="input">abs(-3.33).</span>
3.33
&gt; <span class="input">abs(-3).</span>
3</pre><p>Allowed in guard tests.</p><h4>adler32/1</h4><p>Compute adler32 checksum.</p><p>Computes and returns the adler32 checksum for
<strong><span class="anno">Data</span></strong>.</p><h4>adler32/2</h4><p>Compute adler32 checksum.</p><p>Continues computing the adler32 checksum by combining 
the previous checksum, <strong><span class="anno">OldAdler</span></strong>, with
the checksum of <strong><span class="anno">Data</span></strong>.</p><p>The following code:</p><pre><code class="">
X = erlang:adler32(Data1),
Y = erlang:adler32(X,Data2).</code></pre><p>assigns the same value to <strong>Y</strong> as this:</p><pre><code class="">
Y = erlang:adler32([Data1,Data2]).</code></pre><h4>adler32_combine/3</h4><p>Combine two adler32 checksums.</p><p>Combines two previously computed adler32 checksums.
This computation requires the size of the data object for
the second checksum to be known.</p><p>The following code:</p><pre><code class="">
Y = erlang:adler32(Data1),
Z = erlang:adler32(Y,Data2).</code></pre><p>assigns the same value to <strong>Z</strong> as this:</p><pre><code class="">
X = erlang:adler32(Data1),
Y = erlang:adler32(Data2),
Z = erlang:adler32_combine(X,Y,iolist_size(Data2)).</code></pre><h4>append_element/2</h4><p>Append an extra element to a tuple.</p><p>Returns a new tuple that has one element more than
<strong><span class="anno">Tuple1</span></strong>, and contains the elements in
<strong><span class="anno">Tuple1</span></strong>
followed by <strong><span class="anno">Term</span></strong> as the last element.
Semantically equivalent to
<strong>list_to_tuple(tuple_to_list(<span class="anno">Tuple1</span>) ++ [<span class="anno">Term</span>])</strong>, but much faster. Example:</p><pre>
&gt; <span class="input">erlang:append_element({one, two}, three).</span>
{one,two,three}</pre><h4>apply/2</h4><p>Apply a function to an argument list.</p><p>Calls a fun, passing the elements in <strong><span class="anno">Args</span></strong>
as arguments.</p><p>If the number of elements in the arguments are known at
compile time, the call is better written as
<strong><span class="anno">Fun</span>(Arg1, Arg2, ... ArgN)</strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Earlier, <strong><span class="anno">Fun</span></strong> could also be specified as
<strong>{Module, Function}</strong>, equivalent to
<strong>apply(Module, Function, Args)</strong>. <em>This use is deprecated and will stop working in a future release.</em></p></div><h4>apply/3</h4><p>Apply a function to an argument list.</p><p>Returns the result of applying <strong>Function</strong> in
<strong><span class="anno">Module</span></strong> to <strong><span class="anno">Args</span></strong>.
The applied function must
be exported from <strong>Module</strong>. The arity of the function is
the length of <strong>Args</strong>. Example:</p><pre>
&gt; <span class="input">apply(lists, reverse, [[a, b, c]]).</span>
[c,b,a]
&gt; <span class="input">apply(erlang, atom_to_list, ['Erlang']).</span>
"Erlang"</pre><p>If the number of arguments are known at compile time,
the call is better written as
<strong><span class="anno">Module</span>:<span class="anno">Function</span>(Arg1, Arg2, ..., ArgN)</strong>.</p><p>Failure: <a href="../kernel/error_handler#undefined_function/3">kernel/error_handler#undefined_function/3</a> is called
if the applied function is not exported. The error handler
can be redefined (see
<a href="#process_flag/2">process_flag/2</a>).
If <strong>error_handler</strong> is undefined, or if the user has
redefined the default <strong>error_handler</strong> so the replacement
module is undefined, an error with reason <strong>undef</strong>
is generated.</p><h4>atom_to_binary/2</h4><p>Return the binary representation of an atom.</p><p>Returns a binary corresponding to the text
representation of <strong><span class="anno">Atom</span></strong>.
If <strong><span class="anno">Encoding</span></strong>
is <strong>latin1</strong>, one byte exists for each character
in the text representation. If <strong><span class="anno">Encoding</span></strong> is
<strong>utf8</strong> or
<strong>unicode</strong>, the characters are encoded using UTF-8 where
characters may require multiple bytes.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from Erlang/OTP 20, atoms can contain any Unicode character
and <strong>atom_to_binary(<span class="anno">Atom</span>, latin1)</strong> may fail if the
text representation for <strong><span class="anno">Atom</span></strong> contains a Unicode
character &gt; 255.</p></div><p>Example:</p><pre>
&gt; <span class="input">atom_to_binary('Erlang', latin1).</span>
&lt;&lt;"Erlang"&gt;&gt;</pre><h4>atom_to_list/1</h4><p>Text representation of an atom.</p><p>Returns a string corresponding to the text
representation of <strong><span class="anno">Atom</span></strong>, for example:</p><pre>
&gt; <span class="input">atom_to_list('Erlang').</span>
"Erlang"</pre><h4>binary_part/2</h4><p>Extract a part of a binary.</p><p>Extracts the part of the binary described by
<strong><span class="anno">PosLen</span></strong>.</p><p>Negative length can be used to extract bytes at the end
of a binary, for example:</p><pre><code class="">
1&gt; Bin = &lt;&lt;1,2,3,4,5,6,7,8,9,10&gt;&gt;.
2&gt; binary_part(Bin,{byte_size(Bin), -5}).
&lt;&lt;6,7,8,9,10&gt;&gt;</code></pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">PosLen</span></strong> in any way
references outside the binary.</p><p><strong><span class="anno">Start</span></strong> is zero-based, that is:</p><pre><code class="">
1&gt; Bin = &lt;&lt;1,2,3&gt;&gt;
2&gt; binary_part(Bin,{0,2}).
&lt;&lt;1,2&gt;&gt;</code></pre><p>For details about the <strong><span class="anno">PosLen</span></strong> semantics, see
<a href="./binary">stdlib/binary</a>.</p><p>Allowed in guard tests.</p><h4>binary_part/3</h4><p>Extract a part of a binary.</p><p>The same as <strong>binary_part(<span class="anno">Subject</span>, {<span class="anno">Start</span>, <span class="anno">Length</span>})</strong>.</p><p>Allowed in guard tests.</p><h4>binary_to_atom/2</h4><p>Convert from text representation to an atom.</p><p>Returns the atom whose text representation is
<strong><span class="anno">Binary</span></strong>.
If <strong><span class="anno">Encoding</span></strong> is <strong>latin1</strong>, no
translation of bytes in the binary is done.
If <strong><span class="anno">Encoding</span></strong>
is <strong>utf8</strong> or <strong>unicode</strong>, the binary must contain
valid UTF-8 sequences.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from Erlang/OTP 20, <strong>binary_to_atom(<span class="anno">Binary</span>, utf8)</strong>
is capable of encoding any Unicode character. Earlier versions would
fail if the binary contained Unicode characters &gt; 255.
For more information about Unicode support in atoms, see the
<a href="./erl_ext_dist#utf8_atoms">note on UTF-8 encoded atoms</a>
in section "External Term Format" in the User's Guide.</p></div><p>Examples:</p><pre>
&gt; <span class="input">binary_to_atom(&lt;&lt;"Erlang"&gt;&gt;, latin1).</span>
'Erlang'
&gt; <span class="input">binary_to_atom(&lt;&lt;1024/utf8&gt;&gt;, utf8).</span>
'Ð'</pre><h4>binary_to_existing_atom/2</h4><p>Convert from text representation to an atom.</p><p>As
<a href="#binary_to_atom/2">binary_to_atom/2</a>,
but the atom must exist.</p><p>Failure: <strong>badarg</strong> if the atom does not exist.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that the compiler may optimize away atoms. For
example, the compiler will rewrite
<strong>atom_to_list(some_atom)</strong> to <strong>"some_atom"</strong>. If
that expression is the only mention of the atom
<strong>some_atom</strong> in the containing module, the atom will not
be created when the module is loaded, and a subsequent call
to <strong>binary_to_existing_atom(&lt;&lt;"some_atom"&gt;&gt;, utf8)</strong>
will fail.</p></div><h4>binary_to_float/1</h4><p>Convert from text representation to a float.</p><p>Returns the float whose text representation is
<strong><span class="anno">Binary</span></strong>, for example:</p><pre>
&gt; <span class="input">binary_to_float(&lt;&lt;"2.2017764e+0"&gt;&gt;).</span>
2.2017764</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Binary</span></strong> contains a bad
representation of a float.</p><h4>binary_to_integer/1</h4><p>Convert from text representation to an integer.</p><p>Returns an integer whose text representation is
<strong><span class="anno">Binary</span></strong>, for example:</p><pre>
&gt; <span class="input">binary_to_integer(&lt;&lt;"123"&gt;&gt;).</span>
123</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Binary</span></strong> contains a bad
representation of an integer.</p><h4>binary_to_integer/2</h4><p>Convert from text representation to an integer.</p><p>Returns an integer whose text representation in base
<strong><span class="anno">Base</span></strong> is <strong><span class="anno">Binary</span></strong>, for
example:</p><pre>
&gt; <span class="input">binary_to_integer(&lt;&lt;"3FF"&gt;&gt;, 16).</span>
1023</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Binary</span></strong> contains a bad
representation of an integer.</p><h4>binary_to_list/1</h4><p>Convert a binary to a list.</p><p>Returns a list of integers corresponding to the bytes of
<strong><span class="anno">Binary</span></strong>.</p><h4>binary_to_list/3</h4><p>Convert part of a binary to a list.</p><dl><dt>Start</dt><dd>1..byte_size(<strong><span class="anno">Binary</span></strong>) </dd></dl><p>As <strong>binary_to_list/1</strong>, but returns a list of integers
corresponding to the bytes from position <strong><span class="anno">Start</span></strong> to
position <strong><span class="anno">Stop</span></strong> in <strong><span class="anno">Binary</span></strong>.
The positions in the
binary are numbered starting from 1.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><em>The one-based indexing for binaries used by this function is deprecated.</em> New code is to use
<a href="../stdlib/binary#bin_to_list/3">stdlib/binary#bin_to_list/3</a>
in STDLIB instead. All functions in module
<strong>binary</strong> consistently use zero-based indexing.</p></div><h4>binary_to_term/1</h4><p>Decode an Erlang external term format binary.</p><p>Returns an Erlang term that is the result of decoding
binary object <strong><span class="anno">Binary</span></strong>, which must be encoded
according to the <a href="./erl_ext_dist"> Erlang external term format</a>.</p><pre>
&gt; <span class="input">Bin = term_to_binary(hello).</span>
&lt;&lt;131,100,0,5,104,101,108,108,111&gt;&gt;
&gt; <span class="input">hello = binary_to_term(Bin).</span>
hello
</pre><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>When decoding binaries from untrusted sources,
consider using <strong>binary_to_term/2</strong> to prevent Denial
of Service attacks.</p></div><p>See also
<a href="#term_to_binary/1">term_to_binary/1</a>
and <a href="#binary_to_term/2">binary_to_term/2</a>.</p><h4>binary_to_term/2</h4><p>Decode an Erlang external term format binary.</p><p>As <strong>binary_to_term/1</strong>, but takes these options:</p><dl><dt><strong>safe</strong></dt><dd> <p>Use this option when receiving binaries from an untrusted
source.</p> <p>When enabled, it prevents decoding data that can be used to
attack the Erlang system. In the event of receiving unsafe
data, decoding fails with a <strong>badarg</strong> error.</p> <p>This prevents creation of new atoms directly,
creation of new atoms indirectly (as they are embedded in
certain structures, such as process identifiers,
refs, and funs), and
creation of new external function references.
None of those resources are garbage collected, so unchecked
creation of them can exhaust available memory.</p> <pre>
&gt; <span class="input">binary_to_term(&lt;&lt;131,100,0,5,"hello"&gt;&gt;, [safe]).</span>
** exception error: bad argument
&gt; <span class="input">hello.</span>
hello
&gt; <span class="input">binary_to_term(&lt;&lt;131,100,0,5,"hello"&gt;&gt;, [safe]).</span>
hello
</pre> </dd><dt><strong>used</strong></dt><dd> <p>Changes the return value to <strong>{Term, Used}</strong> where <strong>Used</strong>
is the number of bytes actually read from <strong>Binary</strong>.</p> <pre>
&gt; <span class="input">Input = &lt;&lt;131,100,0,5,"hello","world"&gt;&gt;.</span>
&lt;&lt;131,100,0,5,104,101,108,108,111,119,111,114,108,100&gt;&gt;
&gt; <span class="input">{Term, Used} = binary_to_term(Input, [used]).</span>
{hello, 9}
&gt; <span class="input">split_binary(Input, Used).</span>
{&lt;&lt;131,100,0,5,104,101,108,108,111&gt;&gt;, &lt;&lt;"world"&gt;&gt;}
</pre> </dd></dl><p>Failure: <strong>badarg</strong> if <strong>safe</strong> is specified and unsafe
data is decoded.</p><p>See also
<a href="#term_to_binary/1">term_to_binary/1</a>,
<a href="#binary_to_term/1">binary_to_term/1</a>, and
<a href="#list_to_existing_atom/1">list_to_existing_atom/1</a>.</p><h4>bit_size/1</h4><p>Return the size of a bitstring.</p><p>Returns an integer that is the size in bits of
<strong><span class="anno">Bitstring</span></strong>, for example:</p><pre>
&gt; <span class="input">bit_size(&lt;&lt;433:16,3:3&gt;&gt;).</span>
19
&gt; <span class="input">bit_size(&lt;&lt;1,2,3&gt;&gt;).</span>
24</pre><p>Allowed in guard tests.</p><h4>bitstring_to_list/1</h4><p>Convert a bitstring to a list.</p><p>Returns a list of integers corresponding to the bytes of
<strong><span class="anno">Bitstring</span></strong>. If the number of bits in the binary
is not divisible by 8, the last element of the list is a bitstring
containing the remaining 1-7 bits.</p><h4>bump_reductions/1</h4><p>Increment the reduction counter.</p><p>This implementation-dependent function increments
the reduction counter for the calling process. In the Beam
emulator, the reduction counter is normally incremented by
one for each function and BIF call. A context switch is
forced when the counter reaches the maximum number of
reductions for a process (2000 reductions in Erlang/OTP R12B).</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF can be removed in a future version of the Beam
machine without prior warning. It is unlikely to be
implemented in other Erlang implementations.</p></div><h4>byte_size/1</h4><p>Return the size of a bitstring (or binary).</p><p>Returns an integer that is the number of bytes needed to
contain <strong><span class="anno">Bitstring</span></strong>. That is, if the number of bits
in <strong><span class="anno">Bitstring</span></strong> is not divisible by 8, the resulting
number of bytes is rounded <em>up</em>. Examples:</p><pre>
&gt; <span class="input">byte_size(&lt;&lt;433:16,3:3&gt;&gt;).</span>
3
&gt; <span class="input">byte_size(&lt;&lt;1,2,3&gt;&gt;).</span>
3</pre><p>Allowed in guard tests.</p><h4>cancel_timer/1</h4><p>Cancel a timer.</p><p>Cancels a timer. The same as calling
<a href="#cancel_timer/2">cancel_timer/2</a>.</p><h4>cancel_timer/2</h4><p>Cancel a timer.</p><p>Cancels a timer that has been created by
<a href="#start_timer/4">start_timer/4</a> or
<a href="#send_after/4">send_after/4</a>.
<strong><span class="anno">TimerRef</span></strong> identifies the timer, and
was returned by the BIF that created the timer.</p><p><strong><span class="anno">Option</span></strong>s:</p><dl><dt><strong>{async, Async}</strong></dt><dd> <p>Asynchronous request for cancellation. <strong>Async</strong>
defaults to <strong>false</strong>, which causes the
cancellation to be performed synchronously. When
<strong>Async</strong> is set to <strong>true</strong>, the cancel
operation is performed asynchronously. That is,
<strong>cancel_timer()</strong> sends an asynchronous
request for cancellation to the timer service that
manages the timer, and then returns <strong>ok</strong>.</p> </dd><dt><strong>{info, Info}</strong></dt><dd> <p>Requests information about the <strong><span class="anno">Result</span></strong>
of the cancellation. <strong>Info</strong> defaults to <strong>true</strong>,
which means the <strong><span class="anno">Result</span></strong> is
given. When <strong>Info</strong> is set to <strong>false</strong>, no
information about the result of the cancellation
is given.</p> <ul><li> <p>When <strong>Async</strong> is <strong>false</strong>:
if <strong>Info</strong> is <strong>true</strong>, the <strong>Result</strong> is
returned by <strong>erlang:cancel_timer()</strong>. otherwise
<strong>ok</strong> is returned.</p> </li><li> <p>When <strong>Async</strong> is <strong>true</strong>:
if <strong>Info</strong> is <strong>true</strong>, a message on the form
<strong>{cancel_timer, <span class="anno">TimerRef</span>, <span class="anno">Result</span>}</strong> is sent to the
caller of <strong>erlang:cancel_timer()</strong> when the
cancellation operation has been performed, otherwise
no message is sent.</p> </li></ul> </dd></dl><p>More <strong><span class="anno">Option</span></strong>s may be added in the future.</p><p>If <strong><span class="anno">Result</span></strong> is an integer, it represents
the time in milliseconds left until the canceled timer would
have expired.</p><p>If <strong><span class="anno">Result</span></strong> is <strong>false</strong>, a
timer corresponding to <strong><span class="anno">TimerRef</span></strong> could not
be found. This can be either because the timer had expired,
already had been canceled, or because <strong><span class="anno">TimerRef</span></strong>
never corresponded to a timer. Even if the timer had expired,
it does not tell you if the time-out message has
arrived at its destination yet.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The timer service that manages the timer can be co-located
with another scheduler than the scheduler that the calling
process is executing on. If so, communication
with the timer service takes much longer time than if it
is located locally. If the calling process is in critical
path, and can do other things while waiting for the result
of this operation, or is not interested in the result of
the operation, you want to use option <strong>{async, true}</strong>.
If using option <strong>{async, false}</strong>, the calling
process blocks until the operation has been performed.</p></div><p>See also
<a href="#send_after/4">send_after/4</a>,
<a href="#start_timer/4">start_timer/4</a>, and
<a href="#read_timer/2">read_timer/2</a>.</p><h4>ceil/1</h4><p>Returns the smallest integer not less than the argument</p><p>Returns the smallest integer not less than
<strong><span class="anno">Number</span></strong>.
For example:</p><pre>
&gt; <span class="input">ceil(5.5).</span>
6</pre><p>Allowed in guard tests.</p><h4>check_old_code/1</h4><p>Check if a module has old code.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Module</span></strong> has old code,
otherwise <strong>false</strong>.</p><p>See also <a href="./code">kernel/code</a>.</p><h4>check_process_code/2</h4><p>Check if a process executes old code for a module.</p><p>The same as
<a href="#check_process_code/3">check_process_code/3</a>.</p><h4>check_process_code/3</h4><p>Check if a process executes old code for a module.</p><p>Checks if the node local process identified by
<strong><span class="anno">Pid</span></strong>
executes old code for <strong><span class="anno">Module</span></strong>.</p><p><strong><span class="anno">Option</span></strong>s:</p><dl><dt><strong>{allow_gc, boolean()}</strong></dt><dd> <p>Determines if garbage collection is allowed when performing
the operation. If <strong>{allow_gc, false}</strong> is passed, and
a garbage collection is needed to determine the
result of the operation, the operation is aborted (see
information on <strong><span class="anno">CheckResult</span></strong> below).
The default is to allow garbage collection, that is,
<strong>{allow_gc, true}</strong>.</p> </dd><dt><strong>{async, RequestId}</strong></dt><dd> <p>The function <strong>check_process_code/3</strong> returns
the value <strong>async</strong> immediately after the request
has been sent. When the request has been processed, the
process that called this function is passed a
message on the form <strong>{check_process_code, <span class="anno">RequestId</span>, <span class="anno">CheckResult</span>}</strong>.</p> </dd></dl><p>If <strong><span class="anno">Pid</span></strong> equals <strong>self()</strong>, and
no <strong>async</strong> option has been passed, the operation
is performed at once. Otherwise a request for
the operation is sent to the process identified by
<strong><span class="anno">Pid</span></strong>, and is handled when
appropriate. If no <strong>async</strong> option has been passed,
the caller blocks until <strong><span class="anno">CheckResult</span></strong>
is available and can be returned.</p><p><strong><span class="anno">CheckResult</span></strong> informs about the result of
the request as follows:</p><dl><dt><strong>true</strong></dt><dd> <p>The process identified by <strong><span class="anno">Pid</span></strong>
executes old code for <strong><span class="anno">Module</span></strong>.
That is, the current call of the process executes old
code for this module, or the process has references
to old code for this module, or the process contains
funs that references old code for this module.</p> </dd><dt><strong>false</strong></dt><dd> <p>The process identified by <strong><span class="anno">Pid</span></strong> does
not execute old code for <strong><span class="anno">Module</span></strong>.</p> </dd><dt><strong>aborted</strong></dt><dd> <p>The operation was aborted, as the process needed to
be garbage collected to determine the operation result,
and the operation was requested
by passing option <strong>{allow_gc, false}</strong>.</p> </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Up until ERTS version 8.*, the check process code operation
checks for all types of references to the old code. That is,
direct references (e.g. return addresses on the process
stack), indirect references (<strong>fun</strong>s in process
context), and references to literals in the code.
</p><p>
As of ERTS version 9.0, the check process code operation
only checks for direct references to the code. Indirect
references via <strong>fun</strong>s will be ignored. If such
<strong>fun</strong>s exist and are used after a purge of the old
code, an exception will be raised upon usage (same as
the case when the <strong>fun</strong> is received by the process
after the purge). Literals will be taken care of (copied)
at a  later stage. This behavior can as of ERTS version
8.1 be enabled when
<a href="../doc/installation_guide/INSTALL#Advanced-configuration-and-build-of-ErlangOTP_Configuring">building OTP</a>,
and will automatically be enabled if dirty scheduler
support is enabled.
</p></div><p>See also <a href="./code">kernel/code</a>.</p><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">Pid</span></strong> is not a node local process identifier. </dd><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">Module</span></strong> is not an atom. </dd><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">OptionList</span></strong> is an invalid list of options. </dd></dl><h4>convert_time_unit/3</h4><p>Convert time unit of a time value.</p><p>Converts the <strong><span class="anno">Time</span></strong> value of time unit
<strong><span class="anno">FromUnit</span></strong> to the corresponding
<strong><span class="anno">ConvertedTime</span></strong> value of time unit
<strong><span class="anno">ToUnit</span></strong>. The result is rounded
using the floor function.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>You can lose accuracy and precision when converting
between time units. To minimize such loss, collect all
data at <strong>native</strong> time unit and do the conversion on the end
result.</p></div><h4>crc32/1</h4><p>Compute crc32 (IEEE 802.3) checksum.</p><p>Computes and returns the crc32 (IEEE 802.3 style) checksum
for <strong><span class="anno">Data</span></strong>.</p><h4>crc32/2</h4><p>Compute crc32 (IEEE 802.3) checksum.</p><p>Continues computing the crc32 checksum by combining
the previous checksum, <strong><span class="anno">OldCrc</span></strong>, with the checksum
of <strong><span class="anno">Data</span></strong>.</p><p>The following code:</p><pre><code class="">
X = erlang:crc32(Data1),
Y = erlang:crc32(X,Data2).</code></pre><p>assigns the same value to <strong>Y</strong> as this:</p><pre><code class="">
Y = erlang:crc32([Data1,Data2]).</code></pre><h4>crc32_combine/3</h4><p>Combine two crc32 (IEEE 802.3) checksums.</p><p>Combines two previously computed crc32 checksums.
This computation requires the size of the data object for
the second checksum to be known.</p><p>The following code:</p><pre><code class="">
Y = erlang:crc32(Data1),
Z = erlang:crc32(Y,Data2).</code></pre><p>assigns the same value to <strong>Z</strong> as this:</p><pre><code class="">
X = erlang:crc32(Data1),
Y = erlang:crc32(Data2),
Z = erlang:crc32_combine(X,Y,iolist_size(Data2)).</code></pre><h4>date/0</h4><p>Current date.</p><p>Returns the current date as <strong>{Year, Month, Day}</strong>.</p><p>The time zone and Daylight Saving Time correction depend on
the underlying OS. Example:</p><pre>
&gt; <span class="input">date().</span>
{1995,2,19}</pre><h4>decode_packet/3</h4><p>Extract a protocol packet from a binary.</p><p>Decodes the binary <strong><span class="anno">Bin</span></strong> according to the packet
protocol specified by <strong><span class="anno">Type</span></strong>. Similar to the packet
handling done by sockets with option
<strong>{packet,<span class="anno">Type</span>}.</strong></p><p>If an entire packet is contained in <strong><span class="anno">Bin</span></strong>, it is
returned together with the remainder of the binary as
<strong>{ok,<span class="anno">Packet</span>,<span class="anno">Rest</span>}</strong>.</p><p>If <strong><span class="anno">Bin</span></strong> does not contain the entire packet,
<strong>{more,<span class="anno">Length</span>}</strong> is returned.
<strong><span class="anno">Length</span></strong> is either the
expected <em>total size</em> of the packet, or <strong>undefined</strong>
if the expected packet size is unknown. <strong>decode_packet</strong>
can then be called again with more data added.</p><p>If the packet does not conform to the protocol format,
<strong>{error,<span class="anno">Reason</span>}</strong> is returned.</p><p><strong>Type</strong>s:</p><dl><dt><strong>raw | 0</strong></dt><dd> <p>No packet handling is done. The entire binary is
returned unless it is empty.</p> </dd><dt><strong>1 | 2 | 4</strong></dt><dd> <p>Packets consist of a header specifying the number of
bytes in the packet, followed by that number of bytes.
The length of the header can be one, two, or four bytes;
the order of the bytes is big-endian. The header
is stripped off when the packet is returned.</p> </dd><dt><strong>line</strong></dt><dd> <p>A packet is a line-terminated by a delimiter byte,
default is the latin-1 newline character. The delimiter
byte is included in the returned packet unless the line
was truncated according to option <strong>line_length</strong>.</p> </dd><dt><strong>asn1 | cdr | sunrm | fcgi | tpkt</strong></dt><dd> <p>The header is <em>not</em> stripped off.</p> <p>The meanings of the packet types are as follows:</p> <dl><dt><strong>asn1</strong> - ASN.1 BER</dt><dd></dd><dt><strong>sunrm</strong> - Sun's RPC encoding</dt><dd></dd><dt><strong>cdr</strong> - CORBA (GIOP 1.1)</dt><dd></dd><dt><strong>fcgi</strong> - Fast CGI</dt><dd></dd><dt><strong>tpkt</strong> - TPKT format [RFC1006]</dt><dd></dd></dl> </dd><dt><strong>http | httph | http_bin | httph_bin</strong></dt><dd> <p>The Hypertext Transfer Protocol. The packets
are returned with the format according to
<strong><span class="anno">HttpPacket</span></strong> described earlier.
A packet is either a
request, a response, a header, or an end of header
mark. Invalid lines are returned as
<strong><span class="anno">HttpError</span></strong>.</p> <p>Recognized request methods and header fields are returned
as atoms. Others are returned as strings. Strings of
unrecognized header fields are formatted with only
capital letters first and after hyphen characters, for
example, <strong>"Sec-Websocket-Key"</strong>.</p> <p>The protocol type <strong>http</strong> is only to be used for
the first line when an <strong><span class="anno">HttpRequest</span></strong> or an
<strong><span class="anno">HttpResponse</span></strong> is expected.
The following calls are to use <strong>httph</strong> to get
<strong><span class="anno">HttpHeader</span></strong>s until
<strong>http_eoh</strong> is returned, which marks the end of the
headers and the beginning of any following message body.</p>  <p>The variants <strong>http_bin</strong> and <strong>httph_bin</strong> return
strings (<strong>HttpString</strong>) as binaries instead of lists.</p> </dd></dl><p>Options:</p><dl><dt><strong>{packet_size, integer() &gt;= 0}</strong></dt><dd><p>Sets the maximum allowed size of the packet body.
If the packet header indicates that the length of the
packet is longer than the maximum allowed length, the
packet is considered invalid. Defaults to 0, which means
no size limit.</p> </dd><dt><strong>{line_length, integer() &gt;= 0}</strong></dt><dd> <p>For packet type <strong>line</strong>, lines longer than
the indicated length are truncated.</p> <p>Option <strong>line_length</strong> also applies to <strong>http*</strong>
packet types as an alias for option <strong>packet_size</strong>
if <strong>packet_size</strong> itself is not set. This use is
only intended for backward compatibility.</p> </dd><dt><strong>{line_delimiter, 0 =&lt; byte() =&lt; 255}</strong></dt><dd><p>For packet type <strong>line</strong>, sets the delimiting byte.
Default is the latin-1 character <strong>$\n</strong>.</p> </dd></dl><p>Examples:</p><pre>
&gt; <span class="input">erlang:decode_packet(1,&lt;&lt;3,"abcd"&gt;&gt;,[]).</span>
{ok,&lt;&lt;"abc"&gt;&gt;,&lt;&lt;"d"&gt;&gt;}
&gt; <span class="input">erlang:decode_packet(1,&lt;&lt;5,"abcd"&gt;&gt;,[]).</span>
{more,6}</pre><h4>delete_element/2</h4><p>Delete element at index in a tuple.</p><dl><dt>Index</dt><dd>1..tuple_size(<span class="anno">Tuple1</span>)</dd></dl><p>Returns a new tuple with element at <strong><span class="anno">Index</span></strong>
removed from tuple <strong><span class="anno">Tuple1</span></strong>, for example:</p><pre>
&gt; <span class="input">erlang:delete_element(2, {one, two, three}).</span>
{one,three}</pre><h4>delete_module/1</h4><p>Make the current code for a module old.</p><p>Makes the current code for <strong><span class="anno">Module</span></strong> become old
code and deletes all references for this module from the export table.
Returns <strong>undefined</strong> if the module does not exist,
otherwise <strong>true</strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for the code server (see
<a href="./code">kernel/code</a>)
and is not to be used elsewhere.</p></div><p>Failure: <strong>badarg</strong> if there already is an old version of
<strong>Module</strong>.</p><h4>demonitor/1</h4><p>Stop monitoring.</p><p>If <strong><span class="anno">MonitorRef</span></strong> is a reference that the
calling process obtained by calling
<a href="#monitor/2">monitor/2</a>,
this monitoring is turned off. If the monitoring is already
turned off, nothing happens.</p><p>Once <strong>demonitor(<span class="anno">MonitorRef</span>)</strong> has returned, it is
guaranteed that no <strong>{'DOWN', <span class="anno">MonitorRef</span>, _, _, _}</strong> message,
because of the monitor, will be placed in the caller message queue
in the future. However, a <strong>{'DOWN', <span class="anno">MonitorRef</span>, _, _, _}</strong> message
can have been placed in the caller message queue before
the call. It is therefore usually advisable
to remove such a <strong>'DOWN'</strong> message from the message queue
after monitoring has been stopped.
<a href="#demonitor/2">demonitor/2</a>
can be used instead of <strong>demonitor(<span class="anno">MonitorRef</span>)</strong>
if this cleanup is wanted.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Before Erlang/OTP R11B (ERTS 5.5) <strong>demonitor/1</strong>
behaved completely asynchronously, that is, the monitor was active
until the "demonitor signal" reached the monitored entity. This
had one undesirable effect. You could never know when
you were guaranteed <em>not</em> to receive a <strong>DOWN</strong> message
because of the monitor.</p><p>The current behavior can be viewed as two combined operations:
asynchronously send a "demonitor signal" to the monitored entity
and ignore any future results of the monitor.</p></div><p>Failure: It is an error if <strong><span class="anno">MonitorRef</span></strong> refers to a
monitoring started by another process. Not all such cases are
cheap to check. If checking is cheap, the call fails with
<strong>badarg</strong>, for example if <strong><span class="anno">MonitorRef</span></strong> is a
remote reference.</p><h4>demonitor/2</h4><p>Stop monitoring.</p><p>The returned value is <strong>true</strong> unless <strong>info</strong> is part
of <strong><span class="anno">OptionList</span></strong>.</p><p><strong>demonitor(<span class="anno">MonitorRef</span>, [])</strong> is equivalent to
<a href="#demonitor/1">demonitor/1</a>.</p><p><strong><span class="anno">Option</span></strong>s:</p><dl><dt><strong>flush</strong></dt><dd> <p>Removes (one) <strong>{_, <span class="anno">MonitorRef</span>, _, _, _}</strong> message,
if there is one, from the caller message queue after
monitoring has been stopped.</p> <p>Calling <strong>demonitor(<span class="anno">MonitorRef</span>, [flush])</strong>
is equivalent to the following, but more efficient:</p> <pre><code class="">
demonitor(MonitorRef),
receive
    {_, MonitorRef, _, _, _} -&gt;
        true
after 0 -&gt;
        true
end</code></pre> </dd><dt><strong>info</strong></dt><dd> <p>The returned value is one of the following:</p> <dl><dt><strong>true</strong></dt><dd><p>The monitor was found and removed. In this case,
no <strong>'DOWN'</strong> message corresponding to this
monitor has been delivered and will not be delivered.</p> </dd><dt><strong>false</strong></dt><dd><p>The monitor was not found and could not be removed.
This probably because someone already has placed a
<strong>'DOWN'</strong> message corresponding to this monitor
in the caller message queue.</p> </dd></dl> <p>If option <strong>info</strong> is combined with option <strong>flush</strong>,
<strong>false</strong> is returned if a flush was needed,
otherwise <strong>true</strong>.</p> </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>More options can be added in a future release.</p></div><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">OptionList</span></strong> is not a list. </dd><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">Option</span></strong> is an invalid option. </dd><dt><strong>badarg</strong></dt><dd>The same failure as for <a href="#demonitor/1">demonitor/1</a>. </dd></dl><h4>disconnect_node/1</h4><p>Force the disconnection of a node.</p><p>Forces the disconnection of a node. This appears to
the node <strong><span class="anno">Node</span></strong> as if the local node has crashed.
This BIF is mainly used in the Erlang network authentication
protocols.</p><p>Returns <strong>true</strong> if disconnection succeeds,
otherwise <strong>false</strong>. If the local node is not alive,
<strong>ignored</strong> is returned.</p><h4>display/1</h4><p>Print a term on standard output.</p><p>Prints a text representation of <strong><span class="anno">Term</span></strong> on the
standard output.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for debugging only.</p></div><h4>dist_ctrl_get_data/1</h4><p>Get distribution channel data to pass to another node.</p><p>
Get distribution channel data from the local node that is
to be passed to the remote node. The distribution channel
is identified by <strong><span class="anno">DHandle</span></strong>. If no data
is available, the atom <strong>none</strong> is returned. One
can request to be informed by a message when more
data is available by calling
<a href="./erlang#dist_ctrl_get_data_notification/1">erlang#dist_ctrl_get_data_notification/1</a>.
</p><p>The returned value when there are data available depends
on the value of the <strong>get_size</strong> option configured on the
distribution channel identified by <strong><span class="anno">DHandle</span></strong>.
For more information see the documentation of the <strong>get_size</strong>
option for the
<a href="#dist_ctrl_set_opt/3">dist_ctrl_set_opt/3</a>
function.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Only the process registered as distribution
controller for the distribution channel identified by
<strong><span class="anno">DHandle</span></strong> is allowed to call this
function.
</p></div><p>
This function is used when implementing an alternative
distribution carrier using processes as distribution
controllers. <strong><span class="anno">DHandle</span></strong> is retrived
via the callback
<a href="../erts/alt_dist#hs_data_f_handshake_complete">erts/alt_dist#hs_data_f_handshake_complete</a>.
More information can be found in the documentation of
<a href="../erts/alt_dist#distribution_module">ERTS User's Guide â How to implement an Alternative Carrier for the Erlang Distribution â Distribution Module</a>.
</p><h4>dist_ctrl_get_opt/2</h4><p>Get value of the get_size option on a distribution channel</p><p>Returns the value of the <strong>get_size</strong> option on the distribution channel
identified by <strong><span class="anno">DHandle</span></strong>. For more information see the
documentation of the <strong>get_size</strong> option for the
<a href="#dist_ctrl_set_opt/3">dist_ctrl_set_opt/3</a>
function.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Only the process registered as distribution
controller for the distribution channel identified by
<strong><span class="anno">DHandle</span></strong> is allowed to call this
function.
</p></div><p>
This function is used when implementing an alternative
distribution carrier using processes as distribution
controllers. <strong><span class="anno">DHandle</span></strong> is retrived
via the callback
<a href="../erts/alt_dist#hs_data_f_handshake_complete">erts/alt_dist#hs_data_f_handshake_complete</a>.
More information can be found in the documentation of
<a href="../erts/alt_dist#distribution_module">ERTS User's Guide â How to implement an Alternative Carrier for the Erlang Distribution â Distribution Module</a>.
</p><h4>dist_ctrl_get_data_notification/1</h4><p>Request notification about available outgoing distribution channel data.</p><p>
Request notification when more data is available to
fetch using
<a href="./erlang#dist_ctrl_get_data/1">erlang#dist_ctrl_get_data/1</a>
for the distribution channel identified by
<strong><span class="anno">DHandle</span></strong>. When more data is present,
the caller will be sent the message <strong>dist_data</strong>.
Once a <strong>dist_data</strong> messages has been sent, no
more <strong>dist_data</strong> messages will be sent until
the <strong>dist_ctrl_get_data_notification/1</strong> function has been called
again.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Only the process registered as distribution
controller for the distribution channel identified by
<strong><span class="anno">DHandle</span></strong> is allowed to call this
function.
</p></div><p>
This function is used when implementing an alternative
distribution carrier using processes as distribution
controllers. <strong><span class="anno">DHandle</span></strong> is retrived
via the callback
<a href="../erts/alt_dist#hs_data_f_handshake_complete">erts/alt_dist#hs_data_f_handshake_complete</a>.
More information can be found in the documentation of
<a href="../erts/alt_dist#distribution_module">ERTS User's Guide â How to implement an Alternative Carrier for the Erlang Distribution â Distribution Module</a>.
</p><h4>dist_ctrl_input_handler/2</h4><p>Register distribution channel input handler process.</p><p>
Register an alternate input handler process for the
distribution channel identified by <strong><span class="anno">DHandle</span></strong>.
Once this function has been called, <strong><span class="anno">InputHandler</span></strong>
is the only process allowed to call
<a href="./erlang#dist_ctrl_put_data/2">erlang#dist_ctrl_put_data/2</a>
with the <strong><span class="anno">DHandle</span></strong> identifing this distribution
channel.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Only the process registered as distribution
controller for the distribution channel identified by
<strong><span class="anno">DHandle</span></strong> is allowed to call this
function.
</p></div><p>
This function is used when implementing an alternative
distribution carrier using processes as distribution
controllers. <strong><span class="anno">DHandle</span></strong> is retrived
via the callback
<a href="../erts/alt_dist#hs_data_f_handshake_complete">erts/alt_dist#hs_data_f_handshake_complete</a>.
More information can be found in the documentation of
<a href="../erts/alt_dist#distribution_module">ERTS User's Guide â How to implement an Alternative Carrier for the Erlang Distribution â Distribution Module</a>.
</p><h4>dist_ctrl_put_data/2</h4><p>Pass data into the VM from a distribution channel.</p><p>
Deliver distribution channel data from a remote node to the
local node.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Only the process registered as distribution
controller for the distribution channel identified by
<strong><span class="anno">DHandle</span></strong> is allowed to call this
function unless an alternate input handler process
has been registered using
<a href="./erlang#dist_ctrl_input_handler/2">erlang#dist_ctrl_input_handler/2</a>.
If an alternate input handler has been registered, only
the registered input handler process is allowed to call
this function.
</p></div><p>
This function is used when implementing an alternative
distribution carrier using processes as distribution
controllers. <strong><span class="anno">DHandle</span></strong> is retrived
via the callback
<a href="../erts/alt_dist#hs_data_f_handshake_complete">erts/alt_dist#hs_data_f_handshake_complete</a>.
More information can be found in the documentation of
<a href="../erts/alt_dist#distribution_module">ERTS User's Guide â How to implement an Alternative Carrier for the Erlang Distribution â Distribution Module</a>.
</p><h4>dist_ctrl_set_opt/3</h4><p>Set value of the get_size option on a distribution channel</p><p>Sets the value of the <strong>get_size</strong> option on the distribution channel
identified by <strong><span class="anno">DHandle</span></strong>. This option controls the return
value of calls to
<a href="#dist_ctrl_get_data/1">erlang:dist_ctrl_get_data()</a>
where <strong><span class="anno">DHandle</span></strong> equals <strong><span class="anno">DHandle</span></strong> used
when setting this option.
When the <strong>get_size</strong> option is:</p><dl><dt><strong>false</strong></dt><dd> and there are distribution data available, a call to <strong>erlang:dist_ctrl_get_data(<span class="anno">DHandle</span>)</strong> will just return <strong>Data</strong> to pass over the channel. This is the default value of the <strong>get_size</strong> option. </dd><dt><strong>true</strong></dt><dd> and there are distribution data available, a call to <strong>erlang:dist_ctrl_get_data(<span class="anno">DHandle</span>)</strong> will return <strong>Data</strong> to pass over the channel as well as the <strong>Size</strong> of <strong>Data</strong> in bytes. This is returned as a tuple on the form <strong>{Size, Data}</strong>. </dd></dl><p>All options are set to default when a channel is closed.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Only the process registered as distribution
controller for the distribution channel identified by
<strong><span class="anno">DHandle</span></strong> is allowed to call this
function.
</p></div><p>
This function is used when implementing an alternative
distribution carrier using processes as distribution
controllers. <strong><span class="anno">DHandle</span></strong> is retrived
via the callback
<a href="../erts/alt_dist#hs_data_f_handshake_complete">erts/alt_dist#hs_data_f_handshake_complete</a>.
More information can be found in the documentation of
<a href="../erts/alt_dist#distribution_module">ERTS User's Guide â How to implement an Alternative Carrier for the Erlang Distribution â Distribution Module</a>.
</p><h4>element/2</h4><p>Return the Nth element of a tuple.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns the <strong><span class="anno">N</span></strong>th element (numbering from 1) of
<strong><span class="anno">Tuple</span></strong>, for example:</p><pre>
&gt; <span class="input">element(2, {a, b, c}).</span>
b</pre><p>Allowed in guard tests.</p><h4>erase/0</h4><p>Return and delete the process dictionary.</p><p>Returns the process dictionary and deletes it, for
example:</p><pre>
&gt; <span class="input">put(key1, {1, 2, 3}),</span>
<span class="input">put(key2, [a, b, c]),</span>
<span class="input">erase().</span>
[{key1,{1,2,3}},{key2,[a,b,c]}]</pre><h4>erase/1</h4><p>Return and delete a value from the process dictionary. </p><p>Returns the value <strong><span class="anno">Val</span></strong> associated with
<strong><span class="anno">Key</span></strong> and deletes it from the process dictionary.
Returns <strong>undefined</strong> if no value is associated with
<strong><span class="anno">Key</span></strong>. Example:</p><pre>
&gt; <span class="input">put(key1, {merry, lambs, are, playing}),</span>
<span class="input">X = erase(key1),</span>
<span class="input">{X, erase(key1)}.</span>
{{merry,lambs,are,playing},undefined}</pre><h4>error/1</h4><p>Stop execution with a specified reason.</p><p>Stops the execution of the calling process with the reason
<strong><span class="anno">Reason</span></strong>, where <strong><span class="anno">Reason</span></strong>
is any term. The exit reason is
<strong>{<span class="anno">Reason</span>, Where}</strong>, where <strong>Where</strong>
is a list of the functions most recently called (the current
function first). As evaluating this function causes
the process to terminate, it has no return value. Example:</p><pre>
&gt; <span class="input">catch error(foobar).</span>
{'EXIT',{foobar,[{shell,apply_fun,3,
                        [{file,"shell.erl"},{line,906}]},
                 {erl_eval,do_apply,6,[{file,"erl_eval.erl"},{line,677}]},
                 {erl_eval,expr,5,[{file,"erl_eval.erl"},{line,430}]},
                 {shell,exprs,7,[{file,"shell.erl"},{line,687}]},
                 {shell,eval_exprs,7,[{file,"shell.erl"},{line,642}]},
                 {shell,eval_loop,3,[{file,"shell.erl"},{line,627}]}]}}
</pre><h4>error/2</h4><p>Stop execution with a specified reason.</p><p>Stops the execution of the calling process with the reason
<strong><span class="anno">Reason</span></strong>, where <strong><span class="anno">Reason</span></strong>
is any term. The exit reason is
<strong>{<span class="anno">Reason</span>, Where}</strong>, where <strong>Where</strong>
is a list of the functions most recently called (the current
function first). <strong><span class="anno">Args</span></strong> is expected to be the
list of arguments for the current function; in Beam it is used
to provide the arguments for the current function in
the term <strong>Where</strong>. As evaluating this function causes
the process to terminate, it has no return value.</p><h4>exit/1</h4><p>Stop execution with a specified reason.</p><p>Stops the execution of the calling process with exit reason
<strong><span class="anno">Reason</span></strong>, where <strong><span class="anno">Reason</span></strong>
is any term. As
evaluating this function causes the process to terminate, it
has no return value. Example:</p><pre>
&gt; <span class="input">exit(foobar).</span>
** exception exit: foobar
&gt; <span class="input">catch exit(foobar).</span>
{'EXIT',foobar}</pre><h4>exit/2</h4><p>Send an exit signal to a process or a port.</p><p>Sends an exit signal with exit reason <strong><span class="anno">Reason</span></strong> to
the process or port identified by <strong><span class="anno">Pid</span></strong>.</p><p>The following behavior applies if <strong><span class="anno">Reason</span></strong>
is any term, except <strong>normal</strong> or <strong>kill</strong>:</p><ul><li><p>If <strong><span class="anno">Pid</span></strong> is not trapping exits,
<strong><span class="anno">Pid</span></strong>
itself exits with exit reason <strong><span class="anno">Reason</span></strong>.</p> </li><li><p>If <strong><span class="anno">Pid</span></strong> is trapping exits, the exit
signal is transformed into a message
<strong>{'EXIT', From, <span class="anno">Reason</span>}</strong>
and delivered to the message queue of <strong><span class="anno">Pid</span></strong>.</p> </li><li><p><strong>From</strong> is the process identifier of the process
that sent the exit signal. See also
<a href="#process_flag/2">process_flag/2</a>.</p> </li></ul><p>If <strong><span class="anno">Reason</span></strong> is the atom <strong>normal</strong>,
<strong><span class="anno">Pid</span></strong>
does not exit. If it is trapping exits, the exit signal is
transformed into a message <strong>{'EXIT', From, normal}</strong>
and delivered to its message queue.</p><p>If <strong><span class="anno">Reason</span></strong> is the atom <strong>kill</strong>,
that is, if <strong>exit(<span class="anno">Pid</span>, kill)</strong> is called,
an untrappable exit signal is sent to <strong><span class="anno">Pid</span></strong>,
which unconditionally exits with exit reason <strong>killed</strong>.</p><h4>external_size/1</h4><p>Calculate the maximum size for a term encoded in the Erlang external term format.</p><p>Calculates, without doing the encoding, the maximum byte size for
a term encoded in the Erlang external term format. The following
condition applies always:</p><pre>
&gt; <span class="input">Size1 = byte_size(term_to_binary()),</span>
&gt; <span class="input">Size2 = erlang:external_size(),</span>
&gt; <span class="input">true = Size1 =&lt; Size2.</span>
true</pre><p>This is equivalent to a call to:</p><pre><code class="">
erlang:external_size(<span class="anno">Term</span>, [])</code></pre><h4>external_size/2</h4><p>Calculate the maximum size for a term encoded in the Erlang external term format.</p><p>Calculates, without doing the encoding, the maximum byte size for
a term encoded in the Erlang external term format. The following
condition applies always:</p><pre>
&gt; <span class="input">Size1 = byte_size(term_to_binary(, )),</span>
&gt; <span class="input">Size2 = erlang:external_size(, ),</span>
&gt; <span class="input">true = Size1 =&lt; Size2.</span>
true</pre><p>Option <strong>{minor_version, <span class="anno">Version</span>}</strong> specifies how
floats are encoded. For a detailed description, see
<a href="#term_to_binary/2">term_to_binary/2</a>.</p><h4>float/1</h4><p>Convert a number to a float.</p><p>Returns a float by converting <strong><span class="anno">Number</span></strong> to a float,
for example:</p><pre>
&gt; <span class="input">float(55).</span>
55.0</pre><p>Allowed in guard tests.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If used on the top level in a guard, it tests whether the
argument is a floating point number; for clarity, use
<a href="#is_float/1">is_float/1</a>
instead.</p><p>When <strong>float/1</strong> is used in an expression in a guard,
such as '<strong>float(A) == 4.0</strong>', it converts a number as
described earlier.</p></div><h4>float_to_binary/1</h4><p>Text representation of a float.</p><p>The same as
<strong>float_to_binary(<span class="anno">Float</span>,[{scientific,20}])</strong>.</p><h4>float_to_binary/2</h4><p>Text representation of a float formatted using specified options.</p><p>Returns a binary corresponding to the text
representation of <strong><span class="anno">Float</span></strong> using fixed decimal 
point formatting. <strong><span class="anno">Options</span></strong> behaves in the same
way as <a href="#float_to_list/2">float_to_list/2</a>. Examples:</p><pre>
&gt; <span class="input">float_to_binary(7.12, [{decimals, 4}]).</span>
&lt;&lt;"7.1200"&gt;&gt;
&gt; <span class="input">float_to_binary(7.12, [{decimals, 4}, compact]).</span>
&lt;&lt;"7.12"&gt;&gt;</pre><h4>float_to_list/1</h4><p>Text representation of a float.</p><p>The same as
<strong>float_to_list(<span class="anno">Float</span>,[{scientific,20}])</strong>.</p><h4>float_to_list/2</h4><p>Text representation of a float formatted using specified options.</p><p>Returns a string corresponding to the text representation
of <strong>Float</strong> using fixed decimal point formatting.</p><p>Available options:</p><ul><li><p>If option <strong>decimals</strong> is specified, the returned value
contains at most <strong>Decimals</strong> number of digits past the
decimal point. If the number does not fit in the internal
static buffer of 256 bytes, the function throws <strong>badarg</strong>.</p> </li><li><p>If option <strong>compact</strong> is specified, the trailing zeros
at the end of the list are truncated. This option is only
meaningful together with option <strong>decimals</strong>.</p> </li><li><p>If option <strong>scientific</strong> is specified, the float is
formatted using scientific notation with <strong>Decimals</strong>
digits of precision.</p> </li><li><p>If <strong>Options</strong> is <strong>[]</strong>, the function behaves as
<a href="#float_to_list/1">float_to_list/1</a>.</p> </li></ul><p>Examples:</p><pre>
&gt; <span class="input">float_to_list(7.12, [{decimals, 4}]).</span>
"7.1200"
&gt; <span class="input">float_to_list(7.12, [{decimals, 4}, compact]).</span>
"7.12"</pre><h4>floor/1</h4><p>Returns the largest integer not greater than the argument</p><p>Returns the largest integer not greater than
<strong><span class="anno">Number</span></strong>.
For example:</p><pre>
&gt; <span class="input">floor(-10.5).</span>
-11</pre><p>Allowed in guard tests.</p><h4>fun_info/1</h4><p>Information about a fun.</p><p>Returns a list with information about the fun
<strong><span class="anno">Fun</span></strong>. Each list element is a tuple. The order
of the tuples is undefined, and more tuples can be added in a
future release.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is mainly intended for debugging, but it can
sometimes be useful in library functions that need
to verify, for example, the arity of a fun.</p></div><p>Two types of funs have slightly different semantics:</p><ul><li><p>A fun created by <strong>fun M:F/A</strong> is called an
<em>external</em> fun. Calling it will always call the
function <strong>F</strong> with arity <strong>A</strong> in the latest code for
module <strong>M</strong>. Notice that module <strong>M</strong> does not even
need to be loaded when the fun <strong>fun M:F/A</strong> is created.</p> </li><li><p>All other funs are called <em>local</em>. When a local fun
is called, the same version of the code that created the fun
is called (even if a newer version of the module has been
loaded).</p> </li></ul><p>The following elements are always present in the list
for both local and external funs:</p><dl><dt><strong>{type, Type}</strong></dt><dd> <p><strong>Type</strong> is <strong>local</strong> or <strong>external</strong>.</p> </dd><dt><strong>{module, Module}</strong></dt><dd> <p><strong>Module</strong> (an atom) is the module name.</p> <p>If <strong>Fun</strong> is a local fun, <strong>Module</strong> is the module
in which the fun is defined.</p> <p>If <strong>Fun</strong> is an external fun, <strong>Module</strong> is the
module that the fun refers to.</p> </dd><dt><strong>{name, Name}</strong></dt><dd> <p><strong>Name</strong> (an atom) is a function name.</p> <p>If <strong>Fun</strong> is a local fun, <strong>Name</strong> is the name
of the local function that implements the fun.
(This name was generated by the compiler, and is
only of informational use. As it is a local function, it
cannot be called directly.)
If no code is currently loaded for the fun, <strong>[]</strong>
is returned instead of an atom.</p> <p>If <strong>Fun</strong> is an external fun, <strong>Name</strong> is the name
of the exported function that the fun refers to.</p> </dd><dt><strong>{arity, Arity}</strong></dt><dd> <p><strong>Arity</strong> is the number of arguments that the fun
is to be called with.</p> </dd><dt><strong>{env, Env}</strong></dt><dd> <p><strong>Env</strong> (a list) is the environment or free variables
for the fun. For external funs, the returned list is
always empty.</p> </dd></dl><p>The following elements are only present in the list if
<strong>Fun</strong> is local:</p><dl><dt><strong>{pid, Pid}</strong></dt><dd> <p><strong>Pid</strong> is the process identifier of the process
that originally created the fun.</p> <p>It might point to the <strong>init</strong> process if the
<strong>Fun</strong> was statically allocated when module was
loaded (this optimisation is performed for local
functions that do not capture the enviornment).</p> </dd><dt><strong>{index, Index}</strong></dt><dd> <p><strong>Index</strong> (an integer) is an index into the module
fun table.</p> </dd><dt><strong>{new_index, Index}</strong></dt><dd> <p><strong>Index</strong> (an integer) is an index into the module
fun table.</p> </dd><dt><strong>{new_uniq, Uniq}</strong></dt><dd> <p><strong>Uniq</strong> (a binary) is a unique value for this fun. It
is calculated from the compiled code for the entire module.</p> </dd><dt><strong>{uniq, Uniq}</strong></dt><dd> <p><strong>Uniq</strong> (an integer) is a unique value for this fun.
As from Erlang/OTP R15, this integer is calculated from the
compiled code for the entire module. Before Erlang/OTP R15, this
integer was based on only the body of the fun.</p> </dd></dl><h4>fun_info/2</h4><p>Information about a fun.</p><ul><li>fun_info_item</li></ul><p>Returns information about <strong><span class="anno">Fun</span></strong> as specified by
<strong><span class="anno">Item</span></strong>, in the form
<strong>{<span class="anno">Item</span>,<span class="anno">Info</span>}</strong>.</p><p>For any fun, <strong><span class="anno">Item</span></strong> can be any of the atoms
<strong>module</strong>, <strong>name</strong>, <strong>arity</strong>, <strong>env</strong>, or
<strong>type</strong>.</p><p>For a local fun, <strong><span class="anno">Item</span></strong> can also be any of the
atoms <strong>index</strong>, <strong>new_index</strong>, <strong>new_uniq</strong>,
<strong>uniq</strong>, and <strong>pid</strong>. For an external fun, the value
of any of these items is always the atom <strong>undefined</strong>.</p><p>See
<a href="#fun_info/1">fun_info/1</a>.</p><h4>fun_to_list/1</h4><p>Text representation of a fun.</p><p>Returns a string corresponding to the text
representation of <strong><span class="anno">Fun</span></strong>.</p><h4>function_exported/3</h4><p>Check if a function is exported and loaded.</p><p>Returns <strong>true</strong> if the module <strong><span class="anno">Module</span></strong> is
loaded and contains an exported function
<strong><span class="anno">Function</span>/<span class="anno">Arity</span></strong>,
or if there is a BIF (a built-in function implemented in C)
with the specified name, otherwise returns <strong>false</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function used to return <strong>false</strong> for BIFs
before Erlang/OTP 18.0.</p></div><h4>garbage_collect/0</h4><p>Force an immediate garbage collection of the calling process. </p><p>Forces an immediate garbage collection of the
executing process. The function is not to be used unless
it has been noticed (or there are good reasons to suspect)
that the spontaneous garbage collection will occur too late
or not at all.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Improper use can seriously degrade system performance.</p></div><h4>garbage_collect/1</h4><p>Garbage collect a process.</p><p>The same as
<a href="#garbage_collect/2">garbage_collect/2</a>.</p><h4>garbage_collect/2</h4><p>Garbage collect a process.</p><p>Garbage collects the node local process identified by
<strong><span class="anno">Pid</span></strong>.</p><p><strong><span class="anno">Option</span></strong>:</p><dl><dt><strong>{async, RequestId}</strong></dt><dd>The function <strong>garbage_collect/2</strong> returns the value <strong>async</strong> immediately after the request has been sent. When the request has been processed, the process that called this function is passed a message on the form <strong>{garbage_collect, <span class="anno">RequestId</span>, <span class="anno">GCResult</span>}</strong>. </dd><dt><strong>{type, 'major' | 'minor'}</strong></dt><dd>Triggers garbage collection of requested type. Default value is <strong>'major'</strong>, which would trigger a fullsweep GC. The option <strong>'minor'</strong> is considered a hint and may lead to either minor or major GC run.</dd></dl><p>If <strong><span class="anno">Pid</span></strong> equals <strong>self()</strong>, and
no <strong>async</strong> option has been passed, the garbage
collection is performed at once, that is, the same as calling
<a href="#garbage_collect/0">garbage_collect/0</a>.
Otherwise a request for garbage collection
is sent to the process identified by <strong><span class="anno">Pid</span></strong>,
and will be handled when appropriate. If no <strong>async</strong>
option has been passed, the caller blocks until
<strong><span class="anno">GCResult</span></strong> is available and can be returned.</p><p><strong><span class="anno">GCResult</span></strong> informs about the result of
the garbage collection request as follows:</p><dl><dt><strong>true</strong></dt><dd> The process identified by <strong><span class="anno">Pid</span></strong> has been garbage collected. </dd><dt><strong>false</strong></dt><dd> No garbage collection was performed, as the process identified by <strong><span class="anno">Pid</span></strong> terminated before the request could be satisfied. </dd></dl><p>Notice that the same caveats apply as for
<a href="#garbage_collect/0">garbage_collect/0</a>.</p><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Pid</span></strong> is not a node local process identifier. </dd><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">OptionList</span></strong> is an invalid list of options. </dd></dl><h4>get/0</h4><p>Return the process dictionary.</p><p>Returns the process dictionary as a list of
<strong>{<span class="anno">Key</span>, <span class="anno">Val</span>}</strong> tuples, for example:</p><pre>
&gt; <span class="input">put(key1, merry),</span>
<span class="input">put(key2, lambs),</span>
<span class="input">put(key3, {are, playing}),</span>
<span class="input">get().</span>
[{key1,merry},{key2,lambs},{key3,{are,playing}}]</pre><h4>get/1</h4><p>Return a value from the process dictionary.</p><p>Returns the value <strong><span class="anno">Val</span></strong> associated with
<strong><span class="anno">Key</span></strong> in the process dictionary, or <strong>undefined</strong>
if <strong><span class="anno">Key</span></strong> does not exist. Example:</p><pre>
&gt; <span class="input">put(key1, merry),</span>
<span class="input">put(key2, lambs),</span>
<span class="input">put({any, [valid, term]}, {are, playing}),</span>
<span class="input">get({any, [valid, term]}).</span>
{are,playing}</pre><h4>get_cookie/0</h4><p>Get the magic cookie of the local node.</p><p>Returns the magic cookie of the local node if the node is
alive, otherwise the atom <strong>nocookie</strong>.</p><h4>get_keys/0</h4><p>Return a list of all keys from the process dictionary. </p><p>Returns a list of all keys present in the process dictionary,
for example:</p><pre>
&gt; <span class="input">put(dog, {animal,1}),</span>
<span class="input">put(cow, {animal,2}),</span>
<span class="input">put(lamb, {animal,3}),</span>
<span class="input">get_keys().</span>
[dog,cow,lamb]</pre><h4>get_keys/1</h4><p>Return a list of keys from the process dictionary.</p><p>Returns a list of keys that are associated with the value
<strong><span class="anno">Val</span></strong> in the process dictionary, for example:</p><pre>
&gt; <span class="input">put(mary, {1, 2}),</span>
<span class="input">put(had, {1, 2}),</span>
<span class="input">put(a, {1, 2}),</span>
<span class="input">put(little, {1, 2}),</span>
<span class="input">put(dog, {1, 3}),</span>
<span class="input">put(lamb, {1, 2}),</span>
<span class="input">get_keys({1, 2}).</span>
[mary,had,a,little,lamb]</pre><h4>get_stacktrace/0</h4><p>Get the call stack back-trace of the last exception.</p><ul><li>stack_item</li></ul><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p><strong>erlang:get_stacktrace/0</strong> is deprecated and will stop working
in a future release.</p></div><p>Instead of using <strong>erlang:get_stacktrace/0</strong> to retrieve
the call stack back-trace, use the following syntax:</p><pre>
try Expr
catch
  Class:Reason:Stacktrace -&gt;
   {Class,Reason,Stacktrace}
end</pre><p><strong>erlang:get_stacktrace/0</strong> retrieves the call stack back-trace
(<em>stacktrace</em>) for an exception that has just been
caught in the calling process as a list of
<strong>{<span class="anno">Module</span>,<span class="anno">Function</span>,<span class="anno">Arity</span>,<span class="anno">Location</span>}</strong>
tuples. Field <strong><span class="anno">Arity</span></strong> in the first tuple can
be the argument list of that function call instead of an arity
integer, depending on the exception.</p><p>If there has not been any exceptions in a process, the
stacktrace is <strong>[]</strong>. After a code change for the process,
the stacktrace can also be reset to <strong>[]</strong>.</p><p>The stacktrace is the same data as operator <strong>catch</strong>
returns, for example:</p><pre>
{'EXIT',{badarg,Stacktrace}} = catch abs(x)</pre><p><strong><span class="anno">Location</span></strong> is a (possibly empty) list
of two-tuples that
can indicate the location in the source code of the function.
The first element is an atom describing the type of
information in the second element. The following
items can occur:</p><dl><dt><strong>file</strong></dt><dd>The second element of the tuple is a string (list of characters) representing the filename of the source file of the function. </dd><dt><strong>line</strong></dt><dd>The second element of the tuple is the line number (an integer &gt; 0) in the source file where the exception occurred or the function was called. </dd></dl><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Developers should rely on stacktrace entries only for
debugging purposes.</p><p>The VM performs tail call optimization, which
does not add new entries to the stacktrace, and also limits stacktraces
to a certain depth. Furthermore, compiler options, optimizations and
future changes may add or remove stacktrace entries, causing any code
that expects the stacktrace to be in a certain order or contain specific
items to fail.</p><p>The only exception to this rule is <strong>error:undef</strong> which
guarantees to include the <span class="anno">Module</span>, <span class="anno">Function</span> and <span class="anno">Arity</span>
of the attempted function as the first stacktrace entry.</p></div><p>See also
<a href="#error/1">error/1</a> and
<a href="#error/2">error/2</a>.</p><h4>group_leader/0</h4><p>Get the group leader for the calling process.</p><p>Returns the process identifier of the group leader for the
process evaluating the function.</p><p>Every process is a member of some process group and all
groups have a <em>group leader</em>. All I/O from the group
is channeled to the group leader. When a new process is
spawned, it gets the same group leader as the spawning
process. Initially, at system startup, <strong>init</strong> is both
its own group leader and the group leader of all processes.</p><h4>group_leader/2</h4><p>Set the group leader for a process.</p><p>Sets the group leader of <strong><span class="anno">Pid</span></strong>
to <strong><span class="anno">GroupLeader</span></strong>.
Typically, this is used when a process started from a
certain shell is to have another group leader than
<strong>init</strong>.</p><p>The group leader should be rarely changed in
applications with a supervision tree, because OTP
assumes the group leader of their processes is
their application master.</p><p>See also
<a href="#group_leader/0">group_leader/0</a>
and <a href="../doc/design_principles/applications#stopping">OTP design principles</a> related to starting and stopping
applications.</p><h4>halt/0</h4><p>Halt the Erlang runtime system and indicate normal exit to the calling environment.</p><p>The same as
<a href="#halt/2">halt/2</a>. Example:</p><pre>
&gt; <span class="input">halt().</span>
os_prompt%</pre><h4>halt/1</h4><p>Halt the Erlang runtime system.</p><p>The same as <a href="#halt/2">halt/2</a>. Example:</p><pre>
&gt; <span class="input">halt(17).</span>
os_prompt% <span class="input">echo $?</span>
17
os_prompt%</pre><h4>halt/2</h4><p>Halt the Erlang runtime system.</p><p><strong><span class="anno">Status</span></strong> must be a non-negative integer, a string,
or the atom <strong>abort</strong>.
Halts the Erlang runtime system. Has no return value.
Depending on <strong><span class="anno">Status</span></strong>, the following occurs:</p><dl><dt>integer()</dt><dd>The runtime system exits with integer value <strong><span class="anno">Status</span></strong> as status code to the calling environment (OS). <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>On many platforms, the OS supports only status
codes 0-255. A too large status code is truncated by clearing
the high bits.</p></div> </dd><dt>string()</dt><dd>An Erlang crash dump is produced with <strong><span class="anno">Status</span></strong> as slogan. Then the runtime system exits with status code <strong>1</strong>. The string will be truncated if longer than 200 characters. <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Before ERTS 9.1 (OTP-20.1) only code points in the range 0-255
was accepted in the string. Now any unicode string is valid.</p></div> </dd><dt><strong>abort</strong></dt><dd>The runtime system aborts producing a core dump, if that is enabled in the OS. </dd></dl><p>For integer <strong><span class="anno">Status</span></strong>, the Erlang runtime system
closes all ports and allows async threads to finish their
operations before exiting. To exit without such flushing, use
<strong><span class="anno">Option</span></strong> as <strong>{flush,false}</strong>.</p><p>For statuses <strong>string()</strong> and <strong>abort</strong>, option
<strong>flush</strong> is ignored and flushing is <em>not</em> done.</p><h4>hd/1</h4><p>Head of a list.</p><p>Returns the head of <strong><span class="anno">List</span></strong>, that is,
the first element, for example:</p><pre>
&gt; <span class="input">hd([1,2,3,4,5]).</span>
1</pre><p>Allowed in guard tests.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">List</span></strong> is the empty
list <strong>[]</strong>.</p><h4>hibernate/3</h4><p>Hibernate a process until a message is sent to it.</p><p>Puts the calling process into a wait state where its memory
allocation has been reduced as much as possible. This is
useful if the process does not expect to receive any messages
soon.</p><p>The process is awaken when a message is sent to it, and control
resumes in <strong><span class="anno">Module</span>:<span class="anno">Function</span></strong> with
the arguments specified by <strong><span class="anno">Args</span></strong> with the call
stack emptied, meaning that the process terminates when that
function returns. Thus <strong>erlang:hibernate/3</strong> never
returns to its caller.</p><p>If the process has any message in its message queue,
the process is awakened immediately in the same way as
described earlier.</p><p>In more technical terms, <strong>erlang:hibernate/3</strong>
discards the call stack for the process,
and then garbage collects the process. After this,
all live data is in one continuous heap. The heap
is then shrunken to the exact same size as the live data
that it holds (even if that size is less than the minimum
heap size for the process).</p><p>If the size of the live data in the process is less than
the minimum heap size, the first garbage collection occurring
after the process is awakened ensures that the heap
size is changed to a size not smaller than the minimum heap
size.</p><p>Notice that emptying the call stack means that any surrounding
<strong>catch</strong> is removed and must be re-inserted after
hibernation. One effect of this is that processes started
using <strong>proc_lib</strong> (also indirectly, such as
<strong>gen_server</strong> processes), are to use
<a href="../stdlib/proc_lib#hibernate/3">stdlib/proc_lib#hibernate/3</a>
instead, to ensure that the exception handler continues to work
when the process wakes up.</p><h4>insert_element/3</h4><p>Insert an element at index in a tuple.</p><dl><dt>Index</dt><dd>1..tuple_size(<span class="anno">Tuple1</span>) + 1</dd></dl><p>Returns a new tuple with element <strong><span class="anno">Term</span></strong>
inserted at position
<strong><span class="anno">Index</span></strong> in tuple <strong><span class="anno">Tuple1</span></strong>.
All elements from position <strong><span class="anno">Index</span></strong> and upwards are
pushed one step higher in the new tuple <strong><span class="anno">Tuple2</span></strong>.
Example:</p><pre>
&gt; <span class="input">erlang:insert_element(2, {one, two, three}, new).</span>
{one,new,two,three}</pre><h4>integer_to_binary/1</h4><p>Text representation of an integer.</p><p>Returns a binary corresponding to the text
representation of <strong><span class="anno">Integer</span></strong>, for example:</p><pre>
&gt; <span class="input">integer_to_binary(77).</span>
&lt;&lt;"77"&gt;&gt;</pre><h4>integer_to_binary/2</h4><p>Text representation of an integer.</p><p>Returns a binary corresponding to the text
representation of <strong><span class="anno">Integer</span></strong> in base
<strong><span class="anno">Base</span></strong>, for example:</p><pre>
&gt; <span class="input">integer_to_binary(1023, 16).</span>
&lt;&lt;"3FF"&gt;&gt;</pre><h4>integer_to_list/1</h4><p>Text representation of an integer.</p><p>Returns a string corresponding to the text
representation of <strong><span class="anno">Integer</span></strong>, for example:</p><pre>
&gt; <span class="input">integer_to_list(77).</span>
"77"</pre><h4>integer_to_list/2</h4><p>Text representation of an integer.</p><p>Returns a string corresponding to the text
representation of <strong><span class="anno">Integer</span></strong> in base
<strong><span class="anno">Base</span></strong>, for example:</p><pre>
&gt; <span class="input">integer_to_list(1023, 16).</span>
"3FF"</pre><h4>iolist_size/1</h4><p>Size of an iolist.</p><p>Returns an integer, that is the size in bytes,
of the binary that would be the result of
<strong>iolist_to_binary(<span class="anno">Item</span>)</strong>, for example:</p><pre>
&gt; <span class="input">iolist_size([1,2|&lt;&lt;3,4&gt;&gt;]).</span>
4</pre><h4>iolist_to_binary/1</h4><p>Convert an iolist to a binary.</p><p>Returns a binary that is made from the integers and
binaries in <strong><span class="anno">IoListOrBinary</span></strong>, for example:</p><pre>
&gt; <span class="input">Bin1 = &lt;&lt;1,2,3&gt;&gt;.</span>
&lt;&lt;1,2,3&gt;&gt;
&gt; <span class="input">Bin2 = &lt;&lt;4,5&gt;&gt;.</span>
&lt;&lt;4,5&gt;&gt;
&gt; <span class="input">Bin3 = &lt;&lt;6&gt;&gt;.</span>
&lt;&lt;6&gt;&gt;
&gt; <span class="input">iolist_to_binary([Bin1,1,[2,3,Bin2],4|Bin3]).</span>
&lt;&lt;1,2,3,1,2,3,4,5,4,6&gt;&gt;</pre><h4>iolist_to_iovec/1</h4><p>Converts an iolist to a iovec.</p><p>Returns an iovec that is made from the integers and binaries in
<strong><span class="anno">IoListOrBinary</span></strong>.</p><h4>is_alive/0</h4><p>Check whether the local node is alive.</p><p>Returns <strong>true</strong> if the local node is alive (that is, if
the node can be part of a distributed system), otherwise
<strong>false</strong>.</p><h4>is_atom/1</h4><p>Check whether a term is an atom.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is an atom,
otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h4>is_binary/1</h4><p>Check whether a term is a binary.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a binary,
otherwise <strong>false</strong>.</p><p>A binary always contains a complete number of bytes.</p><p>Allowed in guard tests.</p><h4>is_bitstring/1</h4><p>Check whether a term is a bitstring.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a
bitstring (including a binary), otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h4>is_boolean/1</h4><p>Check whether a term is a boolean.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is the
atom <strong>true</strong> or the atom <strong>false</strong> (that is, a boolean).
Otherwise returns <strong>false</strong>.</p><p>Allowed in guard tests.</p><h4>is_builtin/3</h4><p>Check if a function is a BIF implemented in C.</p><p>This BIF is useful for builders of cross-reference tools.</p><p>Returns <strong>true</strong> if
<strong><span class="anno">Module</span>:<span class="anno">Function</span>/<span class="anno">Arity</span></strong>
is a BIF implemented in C, otherwise <strong>false</strong>.</p><h4>is_float/1</h4><p>Check whether a term is a float.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a floating point
number, otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h4>is_function/1</h4><p>Check whether a term is a fun.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a fun, otherwise
<strong>false</strong>.</p><p>Allowed in guard tests.</p><h4>is_function/2</h4><p>Check whether a term is a fun with a specified given arity. </p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a fun that can be
applied with <strong><span class="anno">Arity</span></strong> number of arguments, otherwise
<strong>false</strong>.</p><p>Allowed in guard tests.</p><h4>is_integer/1</h4><p>Check whether a term is an integer.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is an integer,
otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h4>is_list/1</h4><p>Check whether a term is a list.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a list with
zero or more elements, otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h4>is_map/1</h4><p>Check whether a term is a map.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a map,
otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h4>is_map_key/2</h4><p>Returns <strong>true</strong> if map <strong><span class="anno">Map</span></strong> contains
<strong><span class="anno">Key</span></strong> and returns <strong>false</strong> if it does not
contain the <strong><span class="anno">Key</span></strong>.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">Map</span></strong> is not a map.</p><p><em>Example:</em></p><pre><code class="">
&gt; Map = #{"42" =&gt; value}.
#{"42" =&gt; value}
&gt; is_map_key("42",Map).
true
&gt; is_map_key(value,Map).
false</code></pre><h4>is_number/1</h4><p>Check whether a term is a number.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is an integer or a
floating point number. Otherwise returns <strong>false</strong>.</p><p>Allowed in guard tests.</p><h4>is_pid/1</h4><p>Check whether a term is a process identifier.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a process
identifier, otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h4>is_port/1</h4><p>Check whether a term is a port.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a port identifier,
otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h4>is_process_alive/1</h4><p>Check whether a process is alive.</p><p><strong><span class="anno">Pid</span></strong> must refer to a process at the local
node.</p><p>Returns <strong>true</strong> if the process exists and is alive, that
is, is not exiting and has not exited. Otherwise returns
<strong>false</strong>.</p><h4>is_record/2</h4><p>Check whether a term appears to be a record.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a tuple and its
first element is <strong><span class="anno">RecordTag</span></strong>.
Otherwise returns <strong>false</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Normally the compiler treats calls to <strong>is_record/2</strong>
especially. It emits code to verify that <strong><span class="anno">Term</span></strong>
is a tuple, that its first element is
<strong><span class="anno">RecordTag</span></strong>, and that the
size is correct. However, if <strong><span class="anno">RecordTag</span></strong> is
not a literal atom, the BIF <strong>is_record/2</strong> is called
instead and the size of the tuple is not verified.</p></div><p>Allowed in guard tests, if <strong><span class="anno">RecordTag</span></strong> is
a literal atom.</p><h4>is_record/3</h4><p>Check whether a term appears to be a record.</p><p><strong><span class="anno">RecordTag</span></strong> must be an atom.</p><p>Returns <strong>true</strong> if
<strong><span class="anno">Term</span></strong> is a tuple,
its first element is <strong><span class="anno">RecordTag</span></strong>,
and its size is <strong><span class="anno">Size</span></strong>.
Otherwise returns <strong>false</strong>.</p><p>Allowed in guard tests if <strong><span class="anno">RecordTag</span></strong> is
a literal atom and <strong>Size</strong> is a literal integer.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This BIF is documented for completeness. Usually
<strong>is_record/2</strong> is to be used.</p></div><h4>is_reference/1</h4><p>Check whether a term is a reference.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a reference,
otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h4>is_tuple/1</h4><p>Check whether a term is a tuple.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a tuple,
otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h4>length/1</h4><p>Length of a list.</p><p>Returns the length of <strong><span class="anno">List</span></strong>, for example:</p><pre>
&gt; <span class="input">length([1,2,3,4,5,6,7,8,9]).</span>
9</pre><p>Allowed in guard tests.</p><h4>link/1</h4><p>Create a link to another process (or port).</p><p>Creates a link between the calling process and another
process (or port) <strong><span class="anno">PidOrPort</span></strong>, if there is
not such a link
already. If a process attempts to create a link to itself,
nothing is done. Returns <strong>true</strong>.</p><p>If <strong><span class="anno">PidOrPort</span></strong> does not exist, the behavior
of the BIF
depends on if the calling process is trapping exits or not (see
<a href="#process_flag/2">process_flag/2</a>):</p><ul><li><p>If the calling process is not trapping exits, and
checking <strong><span class="anno">PidOrPort</span></strong> is cheap
(that is, if <strong><span class="anno">PidOrPort</span></strong>
is local), <strong>link/1</strong> fails with reason <strong>noproc</strong>.</p></li><li><p>Otherwise, if the calling process is trapping exits,
and/or <strong><span class="anno">PidOrPort</span></strong> is remote, <strong>link/1</strong>
returns <strong>true</strong>, but an exit signal with reason <strong>noproc</strong>
is sent to the calling process.</p></li></ul><h4>list_to_atom/1</h4><p>Convert from text representation to an atom.</p><p>Returns the atom whose text representation is
<strong><span class="anno">String</span></strong>.</p><p>As from Erlang/OTP 20, <strong><span class="anno">String</span></strong> may contain
any Unicode character. Earlier versions allowed only ISO-latin-1
characters as the implementation did not allow Unicode characters
above 255. For more information on Unicode support in atoms, see
<a href="./erl_ext_dist#utf8_atoms">note on UTF-8 encoded atoms</a>
in section "External Term Format" in the User's Guide.</p><p>Example:</p><pre>
&gt; <span class="input">list_to_atom("Erlang").</span>
'Erlang'</pre><h4>list_to_binary/1</h4><p>Convert a list to a binary.</p><p>Returns a binary that is made from the integers and
binaries in <strong><span class="anno">IoList</span></strong>, for example:</p><pre>
&gt; <span class="input">Bin1 = &lt;&lt;1,2,3&gt;&gt;.</span>
&lt;&lt;1,2,3&gt;&gt;
&gt; <span class="input">Bin2 = &lt;&lt;4,5&gt;&gt;.</span>
&lt;&lt;4,5&gt;&gt;
&gt; <span class="input">Bin3 = &lt;&lt;6&gt;&gt;.</span>
&lt;&lt;6&gt;&gt;
&gt; <span class="input">list_to_binary([Bin1,1,[2,3,Bin2],4|Bin3]).</span>
&lt;&lt;1,2,3,1,2,3,4,5,4,6&gt;&gt;</pre><h4>list_to_bitstring/1</h4><p>Convert a list to a bitstring.</p><ul><li>bitstring_list</li></ul><p>Returns a bitstring that is made from the integers and
bitstrings in <strong><span class="anno">BitstringList</span></strong>. (The last tail in
<strong><span class="anno">BitstringList</span></strong> is allowed to be a bitstring.)
Example:</p><pre>
&gt; <span class="input">Bin1 = &lt;&lt;1,2,3&gt;&gt;.</span>
&lt;&lt;1,2,3&gt;&gt;
&gt; <span class="input">Bin2 = &lt;&lt;4,5&gt;&gt;.</span>
&lt;&lt;4,5&gt;&gt;
&gt; <span class="input">Bin3 = &lt;&lt;6,7:4&gt;&gt;.</span>
&lt;&lt;6,7:4&gt;&gt;
&gt; <span class="input">list_to_bitstring([Bin1,1,[2,3,Bin2],4|Bin3]).</span>
&lt;&lt;1,2,3,1,2,3,4,5,4,6,7:4&gt;&gt;</pre><h4>list_to_existing_atom/1</h4><p>Convert from text representation to an atom.</p><p>Returns the atom whose text representation is
<strong><span class="anno">String</span></strong>,
but only if there already exists such atom.</p><p>Failure: <strong>badarg</strong> if there does not already exist an atom
whose text representation is <strong><span class="anno">String</span></strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that the compiler may optimize away atoms. For
example, the compiler will rewrite
<strong>atom_to_list(some_atom)</strong> to <strong>"some_atom"</strong>. If
that expression is the only mention of the atom
<strong>some_atom</strong> in the containing module, the atom will not
be created when the module is loaded, and a subsequent call
to <strong>list_to_existing_atom("some_atom")</strong> will fail.</p></div><h4>list_to_float/1</h4><p>Convert from text representation to a float.</p><p>Returns the float whose text representation is
<strong><span class="anno">String</span></strong>, for example:</p><pre>
&gt; <span class="input">list_to_float("2.2017764e+0").</span>
2.2017764</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">String</span></strong> contains a bad
representation of a float.</p><h4>list_to_integer/1</h4><p>Convert from text representation to an integer.</p><p>Returns an integer whose text representation is
<strong><span class="anno">String</span></strong>, for example:</p><pre>
&gt; <span class="input">list_to_integer("123").</span>
123</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">String</span></strong> contains a bad
representation of an integer.</p><h4>list_to_integer/2</h4><p>Convert from text representation to an integer.</p><p>Returns an integer whose text representation in base
<strong><span class="anno">Base</span></strong> is <strong><span class="anno">String</span></strong>,
for example:</p><pre>
&gt; <span class="input">list_to_integer("3FF", 16).</span>
1023</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">String</span></strong> contains a bad
representation of an integer.</p><h4>list_to_pid/1</h4><p>Convert from text representation to a pid.</p><p>Returns a process identifier whose text representation is a 
<strong><span class="anno">String</span></strong>, for example:</p><pre>
&gt; <span class="input">list_to_pid("&lt;0.4.1&gt;").</span>
&lt;0.4.1&gt;</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">String</span></strong> contains a bad
representation of a process identifier.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for debugging and is not to be used
in application programs.</p></div><h4>list_to_port/1</h4><p>Convert from text representation to a port.</p><p>Returns a port identifier whose text representation is a
<strong><span class="anno">String</span></strong>, for example:</p><pre>
&gt; <span class="input">list_to_port("#Port&lt;0.4&gt;").</span>
#Port&lt;0.4&gt;</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">String</span></strong> contains a bad
representation of a port identifier.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for debugging and is not to be used
in application programs.</p></div><h4>list_to_ref/1</h4><p>Convert from text representation to a ref.</p><p>Returns a reference whose text representation is a
<strong><span class="anno">String</span></strong>, for example:</p><pre>
&gt; <span class="input">list_to_ref("#Ref&lt;0.4192537678.4073193475.71181&gt;").</span>
#Ref&lt;0.4192537678.4073193475.71181&gt;</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">String</span></strong> contains a bad
representation of a reference.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for debugging and is not to be used
in application programs.</p></div><h4>list_to_tuple/1</h4><p>Convert a list to a tuple.</p><p>Returns a tuple corresponding to <strong><span class="anno">List</span></strong>,
for example</p><pre>
&gt; <span class="input">list_to_tuple([share, ['Ericsson_B', 163]]).</span>
{share, ['Ericsson_B', 163]}</pre><p><strong><span class="anno">List</span></strong> can contain any Erlang terms.</p><h4>load_module/2</h4><p>Load object code for a module.</p><p>If <strong><span class="anno">Binary</span></strong> contains the object code for module
<strong><span class="anno">Module</span></strong>, this BIF loads that object code. If
the code for module <strong><span class="anno">Module</span></strong> already exists, all
export references are replaced so they point to the newly
loaded code. The previously loaded code is kept in the system
as old code, as there can still be processes executing
that code.</p><p>Returns either <strong>{module, <span class="anno">Module</span>}</strong>, or
<strong>{error, <span class="anno">Reason</span>}</strong> if loading fails.
<strong><span class="anno">Reason</span></strong> is one of the following:</p><dl><dt><strong>badfile</strong></dt><dd>The object code in <strong><span class="anno">Binary</span></strong> has an incorrect format <em>or</em> the object code contains code for another module than <strong><span class="anno">Module</span></strong>. </dd><dt><strong>not_purged</strong></dt><dd><strong><span class="anno">Binary</span></strong> contains a module that cannot be loaded because old code for this module already exists. </dd></dl><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for the code server (see
<a href="./code">kernel/code</a>)
and is not to be used elsewhere.</p></div><h4>load_nif/2</h4><p>Load NIF library.</p><p>Loads and links a dynamic library containing native
implemented functions (NIFs) for a module. <strong><span class="anno">Path</span></strong>
is a file path to the shareable object/dynamic library file minus
the OS-dependent file extension (<strong>.so</strong> for Unix and
<strong>.dll</strong> for Windows). Notice that on most OSs the library has
to have a different name on disc when an upgrade of the nif is
done. If the name is the same, but the contents differ, the
old library may be loaded instead. For information on how to
implement a NIF library, see
<a href="erl_nif">erl_nif</a>.</p><p><strong><span class="anno">LoadInfo</span></strong> can be any term. It is passed on to
the library as part of the initialization. A good practice is
to include a module version number to support future code
upgrade scenarios.</p><p>The call to <strong>load_nif/2</strong> must be made
<em>directly</em> from the Erlang code of the module that the
NIF library belongs to. It returns either <strong>ok</strong>, or
<strong>{error,{<span class="anno">Reason</span>,Text}}</strong> if loading fails.
<strong><span class="anno">Reason</span></strong> is one of the following atoms
while <strong><span class="anno">Text</span></strong> is a human readable string that
can give more information about the failure:</p><dl><dt><strong>load_failed</strong></dt><dd>The OS failed to load the NIF library. </dd><dt><strong>bad_lib</strong></dt><dd>The library did not fulfill the requirements as a NIF library of the calling module. </dd><dt><strong>load | upgrade</strong></dt><dd>The corresponding library callback was unsuccessful. </dd><dt><strong>reload</strong></dt><dd>A NIF library is already loaded for this module instance. The previously deprecated <strong>reload</strong> feature was removed in OTP 20. </dd><dt><strong>old_code</strong></dt><dd>The call to <strong>load_nif/2</strong> was made from the old code of a module that has been upgraded; this is not allowed. </dd><dt><strong>notsup</strong></dt><dd>Lack of support. Such as loading NIF library for a HiPE compiled module. </dd></dl><h4>loaded/0</h4><p>List all loaded modules.</p><p>Returns a list of all loaded Erlang modules (current and
old code), including preloaded modules.</p><p>See also <a href="./code">kernel/code</a>.</p><h4>localtime/0</h4><p>Current local date and time.</p><p>Returns the current local date and time,
<strong>{{Year, Month, Day}, {Hour, Minute, Second}}</strong>,
for example:</p><pre>
&gt; <span class="input">erlang:localtime().</span>
{{1996,11,6},{14,45,17}}</pre><p>The time zone and Daylight Saving Time correction depend
on the underlying OS.</p><h4>localtime_to_universaltime/1</h4><p>Convert from local to Universal Time Coordinated (UTC) date and time.</p><p>Converts local date and time to Universal Time Coordinated
(UTC), if supported by the underlying OS. Otherwise
no conversion is done and <strong><span class="anno">Localtime</span></strong>
is returned. Example:</p><pre>
&gt; <span class="input">erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}).</span>
{{1996,11,6},{13,45,17}}</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Localtime</span></strong> denotes an
invalid date and time.</p><h4>localtime_to_universaltime/2</h4><p>Convert from local to Universal Time Coordinated (UTC) date and time.</p><p>Converts local date and time to Universal Time Coordinated
(UTC) as <strong>erlang:localtime_to_universaltime/1</strong>,
but the caller decides if Daylight Saving Time is active.</p><p>If <strong><span class="anno">IsDst</span> == true</strong>, <strong><span class="anno">Localtime</span></strong>
is during Daylight Saving Time, if <strong><span class="anno">IsDst</span> == false</strong>
it is not. If <strong><span class="anno">IsDst</span> == undefined</strong>, the underlying
OS can guess, which is the same as calling
<strong>erlang:localtime_to_universaltime(<span class="anno">Localtime</span>)</strong>.</p><p>Examples:</p><pre>
&gt; <span class="input">erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, true).</span>
{{1996,11,6},{12,45,17}}
&gt; <span class="input">erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, false).</span>
{{1996,11,6},{13,45,17}}
&gt; <span class="input">erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, undefined).</span>
{{1996,11,6},{13,45,17}}</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Localtime</span></strong> denotes an
invalid date and time.</p><h4>make_ref/0</h4><p>Return a unique reference.</p><p>Returns a
<a href="../doc/efficiency_guide/advanced#unique_references"> unique reference</a>. The reference is unique among
connected nodes.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Known issue: When a node is restarted multiple
times with the same node name, references created
on a newer node can be mistaken for a reference
created on an older node with the same node name.</p></div><h4>make_tuple/2</h4><p>Create a new tuple of a specified arity.</p><p>Creates a new tuple of the specified <strong><span class="anno">Arity</span></strong>, where
all elements are <strong><span class="anno">InitialValue</span></strong>, for example:</p><pre>
&gt; <span class="input">erlang:make_tuple(4, []).</span>
{[],[],[],[]}</pre><h4>make_tuple/3</h4><p>Create a new tuple with specifed arity and contents.</p><p>Creates a tuple of size <strong><span class="anno">Arity</span></strong>, where each element
has value <strong><span class="anno">DefaultValue</span></strong>, and then fills in
values from <strong><span class="anno">InitList</span></strong>.
Each list element in <strong><span class="anno">InitList</span></strong>
must be a two-tuple, where the first element is a position in the
newly created tuple and the second element is any term. If a
position occurs more than once in the list, the term corresponding
to the last occurrence is used. Example:</p><pre>
&gt; <span class="input">erlang:make_tuple(5, [], [{2,ignored},{5,zz},{2,aa}]).</span>
{[],aa,[],[],zz}</pre><h4>map_get/2</h4><p>Extract a value from a map</p><p>Returns value <strong><span class="anno">Value</span></strong> associated with
<strong><span class="anno">Key</span></strong> if <strong><span class="anno">Map</span></strong> contains
<strong><span class="anno">Key</span></strong>.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">Map</span></strong> is not a map, or with a <strong>{badkey,Key}</strong>
exception if no value is associated with <strong><span class="anno">Key</span></strong>.</p><p><em>Example:</em></p><pre><code class="">
&gt; Key = 1337,
  Map = #{42 =&gt; value_two,1337 =&gt; "value one","a" =&gt; 1},
  map_get(Key,Map).
"value one"</code></pre><h4>map_size/1</h4><p>Return the size of a map.</p><p>Returns an integer, which is the number of key-value pairs
in <strong><span class="anno">Map</span></strong>, for example:</p><pre>
&gt; <span class="input">map_size(#{a=&gt;1, b=&gt;2, c=&gt;3}).</span>
3</pre><p>Allowed in guard tests.</p><h4>match_spec_test/3</h4><p>Test that a match specification works.</p><p>Tests a match specification used in calls to
<a href="../stdlib/ets#select/2">stdlib/ets#select/2</a>
and <a href="#trace_pattern/3">trace_pattern/3</a>.
The function tests both a match specification for "syntactic"
correctness and runs the match specification against the object. If
the match specification contains errors, the tuple <strong>{error, Errors}</strong> is returned, where <strong>Errors</strong> is a list of natural
language descriptions of what was wrong with the match
specification.</p><p>If <strong><span class="anno">Type</span></strong> is <strong>table</strong>, the object to match
against is to be a tuple. The function then returns
<strong>{ok,Result,[],Warnings}</strong>, where <strong>Result</strong> is what would
have been the result in a real <strong>ets:select/2</strong> call, or
<strong>false</strong> if the match specification does not match the object
tuple.</p><p>If <strong><span class="anno">Type</span></strong> is <strong>trace</strong>, the object to match
against is to be a list. The function returns
<strong>{ok, Result, Flags, Warnings}</strong>, where <strong>Result</strong> is one of
the following:</p><ul><li><strong>true</strong> if a trace message is to be emitted</li><li><strong>false</strong> if a trace message is not to be emitted</li><li>The message term to be appended to the trace message</li></ul><p><strong>Flags</strong> is a list containing all the trace flags to be enabled,
currently this is only <strong>return_trace</strong>.</p><p>This is a useful debugging and test tool, especially when writing
complicated match specifications.</p><p>See also
<a href="../stdlib/ets#test_ms/2">stdlib/ets#test_ms/2</a>.</p><h4>max/2</h4><p>Return the largest of two terms.</p><p>Returns the largest of <strong><span class="anno">Term1</span></strong> and
<strong><span class="anno">Term2</span></strong>.
If the terms are equal, <strong><span class="anno">Term1</span></strong> is returned.</p><h4>md5/1</h4><p>Compute an MD5 message digest.</p><p>Computes an MD5 message digest from <strong><span class="anno">Data</span></strong>, where
the length of the digest is 128 bits (16 bytes).
<strong><span class="anno">Data</span></strong>
is a binary or a list of small integers and binaries.</p><p>For more information about MD5, see
<a href="https://www.ietf.org/rfc/rfc1321.txt"> RFC 1321 - The MD5 Message-Digest Algorithm</a>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>The MD5 Message-Digest Algorithm is <em>not</em> considered
safe for code-signing or software-integrity purposes.</p></div><h4>md5_final/1</h4><p>Finish the update of an MD5 context and return the computed MD5 message digest.</p><p>Finishes the update of an MD5 <strong><span class="anno">Context</span></strong> and returns
the computed <strong>MD5</strong> message digest.</p><h4>md5_init/0</h4><p>Create an MD5 context.</p><p>Creates an MD5 context, to be used in the following calls to
<strong>md5_update/2</strong>.</p><h4>md5_update/2</h4><p>Update an MD5 context with data and return a new context. </p><p>Update an MD5 <strong><span class="anno">Context</span></strong> with
<strong><span class="anno">Data</span></strong> and returns a
<strong><span class="anno">NewContext</span></strong>.</p><h4>memory/0</h4><p>Information about dynamically allocated memory.</p><ul><li>memory_type</li></ul><p>Returns a list with information about memory
dynamically allocated by the Erlang emulator. Each list
element is a tuple <strong>{Type, Size}</strong>. The first element
<strong><span class="anno">Type</span></strong> is an atom describing memory type. The second
element <strong><span class="anno">Size</span></strong> is the memory size in bytes.</p><p>Memory types:</p><dl><dt><strong>total</strong></dt><dd> <p>The total amount of memory currently allocated. This is
the same as the sum of the memory size for <strong>processes</strong>
and <strong>system</strong>.</p> </dd><dt><strong>processes</strong></dt><dd> <p>The total amount of memory currently allocated for
the Erlang processes.</p> </dd><dt><strong>processes_used</strong></dt><dd> <p>The total amount of memory currently used by the Erlang
processes. This is part of the memory presented as
<strong>processes</strong> memory.</p> </dd><dt><strong>system</strong></dt><dd> <p>The total amount of memory currently allocated for
the emulator that is not directly related to any Erlang
process. Memory presented as <strong>processes</strong> is not
included in this memory. <a href="./instrument">tools/instrument</a> can be used to
get a more detailed breakdown of what memory is part
of this type.</p> </dd><dt><strong>atom</strong></dt><dd> <p>The total amount of memory currently allocated for atoms.
This memory is part of the memory presented as
<strong>system</strong> memory.</p> </dd><dt><strong>atom_used</strong></dt><dd> <p>The total amount of memory currently used for atoms.
This memory is part of the memory presented as
<strong>atom</strong> memory.</p> </dd><dt><strong>binary</strong></dt><dd> <p>The total amount of memory currently allocated for
binaries. This memory is part of the memory presented
as <strong>system</strong> memory.</p> </dd><dt><strong>code</strong></dt><dd> <p>The total amount of memory currently allocated for
Erlang code. This memory is part of the memory presented
as <strong>system</strong> memory.</p> </dd><dt><strong>ets</strong></dt><dd> <p>The total amount of memory currently allocated for ETS
tables. This memory is part of the memory presented as
<strong>system</strong> memory.</p> </dd><dt><strong>low</strong></dt><dd> <p>Only on 64-bit halfword emulator.
The total amount of memory allocated in low memory areas
that are restricted to &lt; 4 GB, although
the system can have more memory.</p> <p>Can be removed in a future release of the halfword
emulator.</p> </dd><dt><strong>maximum</strong></dt><dd> <p>The maximum total amount of memory allocated since
the emulator was started. This tuple is only present
when the emulator is run with instrumentation.</p> <p>For information on how to run the emulator with
instrumentation, see
<a href="./instrument">tools/instrument</a>
and/or <a href="erl">erl</a>.</p> </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The <strong>system</strong> value is not complete. Some allocated
memory that is to be part of this value is not.</p><p>When the emulator is run with instrumentation,
the <strong>system</strong> value is more accurate, but memory
directly allocated for <strong>malloc</strong> (and friends) is still
not part of the <strong>system</strong> value. Direct calls to
<strong>malloc</strong> are only done from OS-specific runtime
libraries and perhaps from user-implemented Erlang drivers
that do not use the memory allocation functions in
the driver interface.</p><p>As the <strong>total</strong> value is the sum of <strong>processes</strong>
and <strong>system</strong>, the error in <strong>system</strong> propagates
to the <strong>total</strong> value.</p><p>The different amounts of memory that are summed are
<em>not</em> gathered atomically, which introduces
an error in the result.</p></div><p>The different values have the following relation to each
other. Values beginning with an uppercase letter is not part
of the result.</p><pre><code class="">
total      = processes + system
processes  = processes_used + ProcessesNotUsed
system     = atom + binary + code + ets + OtherSystem
atom       = atom_used + AtomNotUsed
RealTotal  = processes + RealSystem
RealSystem = system + MissedSystem</code></pre><p>More tuples in the returned list can be added in a
future release.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The <strong>total</strong> value is supposed to be the total amount
of memory dynamically allocated by the emulator. Shared
libraries, the code of the emulator itself, and
the emulator stacks are not supposed to be included. That
is, the <strong>total</strong> value is <em>not</em> supposed to be
equal to the total size of all pages mapped to the emulator.</p><p>Also, because of fragmentation and prereservation of
memory areas, the size of the memory segments containing
the dynamically allocated memory blocks can be much
larger than the total size of the dynamically allocated
memory blocks.</p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from ERTS 5.6.4, <strong>erlang:memory/0</strong> requires that
all <a href="./erts_alloc">erts/erts_alloc</a>
allocators are enabled (default behavior).</p></div><p>Failure: <strong>notsup</strong> if an
<a href="./erts_alloc">erts/erts_alloc</a>
allocator has been disabled.</p><h4>memory/1</h4><h4>memory/1</h4><p>Information about dynamically allocated memory.</p><ul><li>memory_type</li></ul><p>Returns the memory size in bytes allocated for memory of type
<strong><span class="anno">Type</span></strong>. The argument can also be specified as a list
of <strong>memory_type()</strong> atoms, in which case a corresponding list of
<strong>{memory_type(), Size :: integer &gt;= 0}</strong> tuples is returned.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from ERTS 5.6.4,
<strong>erlang:memory/1</strong> requires that
all <a href="erts_alloc">erts_alloc</a>
allocators are enabled (default behavior).</p></div><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Type</span></strong> is not one of the memory types listed in the description of <a href="#memory/0">memory/0</a>. </dd><dt><strong>badarg</strong></dt><dd> If <strong>maximum</strong> is passed as <strong><span class="anno">Type</span></strong> and the emulator is not run in instrumented mode. </dd><dt><strong>notsup</strong></dt><dd> If an <a href="erts_alloc">erts_alloc</a> allocator has been disabled. </dd></dl><p>See also
<a href="#memory/0">memory/0</a>.</p><h4>min/2</h4><p>Return the smallest of two terms.</p><p>Returns the smallest of <strong><span class="anno">Term1</span></strong> and
<strong><span class="anno">Term2</span></strong>.
If the terms are equal, <strong><span class="anno">Term1</span></strong> is returned.</p><h4>module_loaded/1</h4><p>Check if a module is loaded.</p><p>Returns <strong>true</strong> if the module <strong><span class="anno">Module</span></strong>
is loaded, otherwise <strong>false</strong>. It does not attempt to load
the module.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for the code server (see
<a href="./code">kernel/code</a>)
and is not to be used elsewhere.</p></div><h4>monitor/2</h4><h4>monitor/2</h4><h4>monitor/2</h4><p>Start monitoring.</p><ul><li>registered_name</li></ul><ul><li>registered_process_identifier</li></ul><ul><li>monitor_process_identifier</li></ul><ul><li>monitor_port_identifier</li></ul><p>Sends a monitor request of type <strong><span class="anno">Type</span></strong> to the
entity identified by <strong><span class="anno">Item</span></strong>. If the monitored entity
does not exist or it changes monitored state, the caller of
<strong>monitor/2</strong> is notified by a message on the following format:</p><pre><code class="">
{Tag, <span class="anno">MonitorRef</span>, <span class="anno">Type</span>, Object, Info}</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The monitor request is an asynchronous signal. That is, it
takes time before the signal reaches its destination.</p></div><p><strong><span class="anno">Type</span></strong> can be one of the following atoms:
<strong>process</strong>, <strong>port</strong> or <strong>time_offset</strong>.</p><p>A <strong>process</strong> or <strong>port</strong> monitor is triggered only once,
after that it is removed from both monitoring process and
the monitored entity. Monitors are fired when the monitored process
or port terminates, does not exist at the moment of creation,
or if the connection to it is lost. If the connection to it is lost,
we do not know if it still exists. The monitoring is also turned off
when <a href="#demonitor/1">demonitor/1</a> is
called.</p><p>A <strong>process</strong> or <strong>port</strong> monitor by name
resolves the <strong>RegisteredName</strong> to <strong>pid()</strong> or <strong>port()</strong>
only once at the moment of monitor instantiation, later changes to
the name registration will not affect the existing monitor.</p><p>When a <strong>process</strong> or <strong>port</strong> monitor is triggered,
a <strong>'DOWN'</strong> message is sent that has the following pattern:</p><pre><code class="">
{'DOWN', MonitorRef, Type, Object, Info}</code></pre><p>In the monitor message <strong>MonitorRef</strong> and <strong>Type</strong> are the
same as described earlier, and:</p><dl><dt><strong>Object</strong></dt><dd> <p>The monitored entity, which triggered the event. When monitoring
a local process or port, <strong>Object</strong> will be equal to the
<strong>pid()</strong> or <strong>port()</strong> that was being monitored. When
monitoring process or port by name, <strong>Object</strong> will have format
<strong>{RegisteredName, Node}</strong> where <strong>RegisteredName</strong> is the
name which has been used with <strong>monitor/2</strong> call and
<strong>Node</strong> is local or remote node name (for ports monitored by
name, <strong>Node</strong> is always local node name).</p> </dd><dt><strong>Info</strong></dt><dd> <p>Either the exit reason of the process, <strong>noproc</strong>
(process or port did not exist at the time of monitor creation),
or <strong>noconnection</strong> (no connection to the node where the
monitored process resides). </p></dd></dl><dl><dt>Monitoring a <a name="monitor_process"></a><strong>process</strong></dt><dd> <p>Creates monitor between the current process and another
process identified by <strong><span class="anno">Item</span></strong>, which can be a
<strong>pid()</strong> (local or remote), an atom <strong>RegisteredName</strong> or
a tuple <strong>{RegisteredName, Node}</strong> for a registered process,
located elsewhere.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Before ERTS 10.0 (OTP 21.0), monitoring a process could fail with
<strong>badarg</strong> if the monitored process resided on a primitive node
(such as erl_interface or jinterface), where remote process monitoring
is not implemented.</p><p>Now, such a call to <strong>monitor</strong> will instead succeed and a
monitor is created. But the monitor will only supervise the
connection. That is, a <strong>{'DOWN', _, process, _, noconnection}</strong> is
the only message that may be received, as the primitive node have no
way of reporting the status of the monitored process.</p></div> </dd><dt>Monitoring a <a name="monitor_port"></a><strong>port</strong></dt><dd> <p>Creates monitor between the current process and a port
identified by <strong><span class="anno">Item</span></strong>, which can be a
<strong>port()</strong> (only local), an atom <strong>RegisteredName</strong> or
a tuple <strong>{RegisteredName, Node}</strong> for a registered port,
located on this node. Note, that attempt to monitor a remote port
will result in <strong>badarg</strong>.</p> </dd><dt>Monitoring a <a name="monitor_time_offset"></a><strong>time_offset</strong></dt><dd> <p>Monitors changes in
<a href="#time_offset/0">time_offset/0</a>
between
<a href="./time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a> and
<a href="./time_correction#Erlang_System_Time">Erlang system time</a>. One valid <strong><span class="anno">Item</span></strong>
exists in combination with the
<strong>time_offset <span class="anno">Type</span></strong>, namely the atom
<strong>clock_service</strong>. Notice that the atom <strong>clock_service</strong> is
<em>not</em> the registered name of a process. In this
case it serves as an identifier of the runtime system internal
clock service at current runtime system instance.</p> <p>The monitor is triggered when the time offset is changed.
This either if the time offset value is changed, or if the
offset is changed from preliminary to final during
<a href="#system_flag_time_offset">finalization of the time offset</a> when the
<a href="./time_correction#Single_Time_Warp_Mode">single time warp mode</a> is used. When a change from preliminary
to final time offset is made, the monitor is triggered once
regardless of whether the time offset value was changed
or not.</p> <p>If the runtime system is in
<a href="./time_correction#Multi_Time_Warp_Mode">multi time warp mode</a>, the time offset is changed when
the runtime system detects that the
<a href="./time_correction#OS_System_Time">OS system time</a> has changed. The runtime system does, however,
not detect this immediately when it occurs. A task checking
the time offset is scheduled to execute at least once a minute,
so under normal operation this is to be detected within a
minute, but during heavy load it can take longer time.</p> <p>The monitor is <em>not</em> automatically removed
after it has been triggered. That is, repeated changes of
the time offset trigger the monitor repeatedly.</p> <p>When the monitor is triggered a <strong>'CHANGE'</strong> message is
sent to the monitoring process. A <strong>'CHANGE'</strong> message has
the following pattern:</p> <pre><code class="">
{'CHANGE', MonitorRef, Type, Item, NewTimeOffset}</code></pre> <p>where <strong>MonitorRef</strong>, <strong><span class="anno">Type</span></strong>, and
<strong><span class="anno">Item</span></strong> are the same as described above, and
<strong>NewTimeOffset</strong> is the new time offset.</p> <p>When the <strong>'CHANGE'</strong> message has been received you are
guaranteed not to retrieve the old time offset when calling
<a href="#time_offset/0">time_offset/0</a>.
Notice that you can observe the change of the time offset
when calling <strong>erlang:time_offset()</strong> before you
get the <strong>'CHANGE'</strong> message.</p> </dd></dl><p>Making several calls to <strong>monitor/2</strong> for the same
<strong><span class="anno">Item</span></strong> and/or <strong><span class="anno">Type</span></strong> is not
an error; it results in as many independent monitoring instances.</p><p>The monitor functionality is expected to be extended. That is,
other <strong><span class="anno">Type</span></strong>s and <strong><span class="anno">Item</span></strong>s
are expected to be supported in a future release.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If or when <strong>monitor/2</strong> is extended, other
possible values for <strong>Tag</strong>, <strong>Object</strong>, and
<strong>Info</strong> in the monitor message will be introduced.</p></div><h4>monitor_node/2</h4><p>Monitor the status of a node.</p><p>Monitor the status of the node <strong><span class="anno">Node</span></strong>.
If <strong><span class="anno">Flag</span></strong>
is <strong>true</strong>, monitoring is turned on. If <strong><span class="anno">Flag</span></strong>
is <strong>false</strong>, monitoring is turned off.</p><p>Making several calls to <strong>monitor_node(Node, true)</strong> for
the same <strong><span class="anno">Node</span></strong> is not an error; it results
in as many independent monitoring instances.</p><p>If <strong><span class="anno">Node</span></strong> fails or does not exist, the message
<strong>{nodedown, Node}</strong> is delivered to the process. If a
process has made two calls to <strong>monitor_node(Node, true)</strong>
and <strong><span class="anno">Node</span></strong> terminates, two <strong>nodedown</strong> messages
are delivered to the process. If there is no connection to
<strong><span class="anno">Node</span></strong>, an attempt is made to create one.
If this fails, a <strong>nodedown</strong> message is delivered.</p><p>Nodes connected through hidden connections can be monitored
as any other nodes.</p><p>Failure: <strong>badarg</strong> if the local node is not alive.</p><h4>monitor_node/3</h4><p>Monitor the status of a node.</p><p>Behaves as
<a href="#monitor_node/2">monitor_node/2</a>
except that it allows an
extra option to be specified, namely <strong>allow_passive_connect</strong>.
This option allows the BIF to wait the normal network connection
time-out for the <em>monitored node</em> to connect itself,
even if it cannot be actively connected from this node
(that is, it is blocked). The state where this can be useful
can only be achieved by using the Kernel option
<strong>dist_auto_connect once</strong>. If that option is not
used, option <strong>allow_passive_connect</strong> has no effect.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Option <strong>allow_passive_connect</strong> is used
internally and is seldom needed in applications where the
network topology and the Kernel options in effect
are known in advance.</p></div><p>Failure: <strong>badarg</strong> if the local node is not alive or the
option list is malformed.</p><h4>monotonic_time/0</h4><p>Current Erlang monotonic time.</p><p>Returns the current
<a href="./time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a> in <strong>native</strong>
<a href="#type_time_unit">time unit</a>. This
is a monotonically increasing time since some unspecified point in
time.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This is a
<a href="./time_correction#Monotonically_Increasing"> monotonically increasing</a> time, but <em>not</em> a
<a href="./time_correction#Strictly_Monotonically_Increasing"> strictly monotonically increasing</a>
time. That is, consecutive calls to
<strong>erlang:monotonic_time/0</strong> can produce the same result.</p><p>Different runtime system instances will use different unspecified
points in time as base for their Erlang monotonic clocks.
That is, it is <em>pointless</em> comparing monotonic times from
different runtime system instances. Different runtime system
instances can also place this unspecified point in time different
relative runtime system start. It can be placed in the future (time
at start is a negative value), the past (time at start is a
positive value), or the runtime system start (time at start is
zero). The monotonic time at runtime system start can be
retrieved by calling
<a href="#system_info_start_time">system_info_start_time</a>.</p></div><h4>monotonic_time/1</h4><p>Current Erlang monotonic time.</p><p>Returns the current
<a href="./time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a> converted
into the <strong><span class="anno">Unit</span></strong> passed as argument.</p><p>Same as calling
<a href="#convert_time_unit/3">convert_time_unit/3</a><strong>(</strong><a href="#monotonic_time/0">monotonic_time/0</a><strong>, native, <span class="anno">Unit</span>)</strong>,
however optimized for commonly used <strong><span class="anno">Unit</span></strong>s.</p><h4>nif_error/1</h4><p>Stop execution with a specified reason.</p><p>Works exactly like
<a href="#error/1">error/1</a>, but
Dialyzer thinks that this BIF will return an arbitrary
term. When used in a stub function for a NIF to generate an
exception when the NIF library is not loaded, Dialyzer
does not generate false warnings.</p><h4>nif_error/2</h4><p>Stop execution with a specified reason.</p><p>Works exactly like
<a href="#error/2">error/2</a>, but
Dialyzer thinks that this BIF will return an arbitrary
term. When used in a stub function for a NIF to generate an
exception when the NIF library is not loaded, Dialyzer
does not generate false warnings.</p><h4>node/0</h4><p>Name of the local node.</p><p>Returns the name of the local node. If the node is not alive,
<strong>nonode@nohost</strong> is returned instead.</p><p>Allowed in guard tests.</p><h4>node/1</h4><p>At which node a pid, port, or reference originates.</p><p>Returns the node where <strong><span class="anno">Arg</span></strong> originates.
<strong><span class="anno">Arg</span></strong> can
be a process identifier, a reference, or a port.
If the local node is not
alive, <strong>nonode@nohost</strong> is returned.</p><p>Allowed in guard tests.</p><h4>nodes/0</h4><p>All visible nodes in the system.</p><p>Returns a list of all visible nodes in the system, except
the local node. Same as <strong>nodes(visible)</strong>.</p><h4>nodes/1</h4><p>All nodes of a certain type in the system.</p><p>Returns a list of nodes according to the argument specified.
The returned result, when the argument is a list, is the list
of nodes satisfying the disjunction(s) of the list elements.</p><p><strong><span class="anno">NodeType</span></strong>s:</p><dl><dt><strong>visible</strong></dt><dd> <p>Nodes connected to this node through normal connections.</p> </dd><dt><strong>hidden</strong></dt><dd> <p>Nodes connected to this node through hidden connections.</p> </dd><dt><strong>connected</strong></dt><dd> <p>All nodes connected to this node.</p> </dd><dt><strong>this</strong></dt><dd> <p>This node.</p> </dd><dt><strong>known</strong></dt><dd> <p>Nodes that are known to this node. That is, connected
nodes and nodes referred to by process identifiers, port
identifiers, and references located on this node.
The set of known nodes is garbage collected. Notice that
this garbage collection can be delayed. For more
information, see
<a href="./erlang#system_info_delayed_node_table_gc">erlang#system_info_delayed_node_table_gc</a>.</p> </dd></dl><p>Some equalities: <strong>[node()] = nodes(this)</strong>,
<strong>nodes(connected) = nodes([visible, hidden])</strong>, and
<strong>nodes() = nodes(visible)</strong>.</p><h4>now/0</h4><p>Elapsed time since 00:00 GMT.</p><ul><li>timestamp</li></ul><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p><em>This function is deprecated. Do not use it.</em></p><p>For more information, see section
<a href="time_correction">Time and Time Correction</a>
in the User's Guide. Specifically, section
<a href="./time_correction#Dos_and_Donts"> Dos and Dont's</a> describes what to use instead of
<strong>erlang:now/0</strong>.</p></div><p>Returns the tuple <strong>{MegaSecs, Secs, MicroSecs}</strong>, which is
the elapsed time since 00:00 GMT, January 1, 1970 (zero hour),
if provided by the underlying OS.
Otherwise some other point in time is chosen. It is also
guaranteed that the following calls to this BIF return
continuously increasing values. Hence, the return value from
<strong>erlang:now/0</strong> can be used to generate unique time stamps.
If it is called in a tight loop on a fast machine,
the time of the node can become skewed.</p><p>Can only be used to check the local time of day if
the time-zone information of the underlying OS is
properly configured.</p><h4>open_port/2</h4><p>Open a port.</p><p>Returns a port identifier as the result of opening a
new Erlang port. A port can be seen as an external Erlang
process.</p><p>The name of the executable as well as the arguments
specifed in <strong>cd</strong>, <strong>env</strong>, <strong>args</strong>, and <strong>arg0</strong> are
subject to Unicode filename translation if the system is running
in Unicode filename mode. To avoid
translation or to force, for example UTF-8, supply the executable
and/or arguments as a binary in the correct
encoding. For details, see the module
<a href="./file">kernel/file</a>, the
function <a href="../kernel/file#native_name_encoding/0">kernel/file#native_name_encoding/0</a> in Kernel, and
the <a href="./unicode_usage">stdlib/unicode_usage</a> User's Guide.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The characters in the name (if specified as a list) can
only be &gt; 255 if the Erlang virtual machine is started
in Unicode filename translation mode. Otherwise the name
of the executable is limited to the ISO Latin-1
character set.</p></div><p><strong><span class="anno">PortName</span></strong>s:</p><dl><dt><strong>{spawn, <span class="anno">Command</span>}</strong></dt><dd> <p>Starts an external program. <strong><span class="anno">Command</span></strong>
is the name of the external program to be run.
<strong><span class="anno">Command</span></strong>
runs outside the Erlang work space unless an Erlang
driver with the name <strong><span class="anno">Command</span></strong> is found.
If found, that driver is started. A driver runs in the Erlang
work space, which means that it is linked with the Erlang
runtime system.</p> <p>For external programs, <strong>PATH</strong> is searched
(or an equivalent method is used to find programs,
depending on the OS). This is done by invoking
the shell on certain platforms. The first space-separated
token of the command is considered as the
name of the executable (or driver). This (among other
things) makes this option unsuitable for running
programs with spaces in filenames or directory names.
If spaces in executable filenames are desired, use
<strong>{spawn_executable, <span class="anno">Command</span>}</strong> instead.</p> </dd><dt><strong>{spawn_driver, <span class="anno">Command</span>}</strong></dt><dd> <p>Works like <strong>{spawn, <span class="anno">Command</span>}</strong>, but demands
the first (space-separated) token of the command to be the name
of a loaded driver. If no driver with that name is loaded, a
<strong>badarg</strong> error is raised.</p> </dd><dt><strong>{spawn_executable, <span class="anno">FileName</span>}</strong></dt><dd> <p>Works like <strong>{spawn, <span class="anno">FileName</span>}</strong>, but only runs
external executables. <strong><span class="anno">FileName</span></strong> in its whole
is used as the name of the executable, including any spaces.
If arguments are to be passed, the
<strong><span class="anno">PortSettings</span></strong>
<strong>args</strong> and <strong>arg0</strong> can be used.</p> <p>The shell is usually not invoked to start the
program, it is executed directly. <strong>PATH</strong> (or
equivalent) is not searched. To find a program
in <strong>PATH</strong> to execute, use
<a href="../kernel/os#find_executable/1">kernel/os#find_executable/1</a>.</p> <p>Only if a shell script or <strong>.bat</strong> file is
executed, the appropriate command interpreter is
invoked implicitly, but there is still no
command-argument expansion or implicit <strong>PATH</strong> search.</p> <p>If <strong><span class="anno">FileName</span></strong> cannot be run, an error
exception is raised, with the POSIX error code as the reason.
The error reason can differ between OSs.
Typically the error <strong>enoent</strong> is raised when an
attempt is made to run a program that is not found and
<strong>eacces</strong> is raised when the specified file is not
executable.</p> </dd><dt><strong>{fd, <span class="anno">In</span>, <span class="anno">Out</span>}</strong></dt><dd> <p>Allows an Erlang process to access any currently opened
file descriptors used by Erlang. The file descriptor
<strong><span class="anno">In</span></strong> can be used for standard input, and the
file descriptor <strong><span class="anno">Out</span></strong> for standard output.
It is only used for various servers in the Erlang OS (<strong>shell</strong>
and <strong>user</strong>). Hence, its use is limited.</p> </dd></dl><p><strong><span class="anno">PortSettings</span></strong> is a list of settings for the port.
The valid settings are as follows:</p><dl><dt><strong>{packet, <span class="anno">N</span>}</strong></dt><dd> <p>Messages are preceded by their length, sent in
<strong><span class="anno">N</span></strong>
bytes, with the most significant byte first. The valid values
for <strong>N</strong> are 1, 2, and 4.</p> </dd><dt><strong>stream</strong></dt><dd> <p>Output messages are sent without packet lengths. A
user-defined protocol must be used between the Erlang
process and the external object.</p> </dd><dt><strong>{line, <span class="anno">L</span>}</strong></dt><dd> <p>Messages are delivered on a per line basis. Each line
(delimited by the OS-dependent newline sequence) is
delivered in a single message. The message data format
is <strong>{Flag, Line}</strong>, where <strong>Flag</strong> is
<strong>eol</strong> or <strong>noeol</strong>, and <strong>Line</strong> is the
data delivered (without the newline sequence).</p> <p><strong><span class="anno">L</span></strong> specifies the maximum line length in bytes.
Lines longer than this are delivered in more than one
message, with <strong>Flag</strong> set to <strong>noeol</strong> for all
but the last message. If end of file is encountered
anywhere else than immediately following a newline
sequence, the last line is also delivered with
<strong>Flag</strong> set to <strong>noeol</strong>. Otherwise
lines are delivered with <strong>Flag</strong> set to <strong>eol</strong>.</p> <p>The <strong>{packet, <span class="anno">N</span>}</strong> and <strong>{line, <span class="anno">L</span>}</strong> settings are mutually exclusive.</p> </dd><dt><strong>{cd, <span class="anno">Dir</span>}</strong></dt><dd> <p>Only valid for <strong>{spawn, <span class="anno">Command</span>}</strong> and
<strong>{spawn_executable, <span class="anno">FileName</span>}</strong>.
The external program starts using <strong><span class="anno">Dir</span></strong> as its
working directory. <strong><span class="anno">Dir</span></strong> must be a string.</p> </dd><dt><strong>{env, <span class="anno">Env</span>}</strong></dt><dd> <p>
Types:<br/>
Â Â <strong><span class="anno">Name</span> = </strong><a href="../kernel/os#type-env_var_name">kernel/os#type-env_var_name</a><br/>
Â Â <strong><span class="anno">Val</span> = </strong><a href="../kernel/os#type-env_var_value">kernel/os#type-env_var_value</a><strong> | false</strong><br/>
Â Â <strong>Env = [{<span class="anno">Name</span>, <span class="anno">Val</span>}]</strong>
</p> <p>Only valid for <strong>{spawn, <span class="anno">Command</span>}</strong>, and
<strong>{spawn_executable, <span class="anno">FileName</span>}</strong>.
The environment of the started process is extended using
the environment specifications in <strong><span class="anno">Env</span></strong>.</p> <p><strong><span class="anno">Env</span></strong> is to be a list of tuples
<strong>{<span class="anno">Name</span>, <span class="anno">Val</span>}</strong>,
where <strong><span class="anno">Name</span></strong> is the name of an
environment variable, and <strong><span class="anno">Val</span></strong> is the
value it is to have in the spawned
port process. Both <strong><span class="anno">Name</span></strong> and
<strong><span class="anno">Val</span></strong> must be strings. The one
exception is <strong><span class="anno">Val</span></strong> being the atom
<strong>false</strong> (in analogy with
<a href="../kernel/os#getenv/1">kernel/os#getenv/1</a>,
which removes the environment variable.
</p> <p>
For information about encoding requirements, see documentation
of the types for <strong><span class="anno">Name</span></strong> and
<strong><span class="anno">Val</span></strong>.
</p> </dd><dt><strong>{args, [ string() | binary() ]}</strong></dt><dd> <p>Only valid for <strong>{spawn_executable, <span class="anno">FileName</span>}</strong>
and specifies arguments to the executable. Each argument
is specified as a separate string and (on Unix) eventually
ends up as one element each in the argument vector. On
other platforms, a similar behavior is mimicked.</p> <p>The arguments are not expanded by the shell before
they are supplied to the executable. Most notably this
means that file wildcard expansion does not occur.
To expand wildcards for the arguments, use
<a href="../stdlib/filelib#wildcard/1">stdlib/filelib#wildcard/1</a>.
Notice that even if
the program is a Unix shell script, meaning that the
shell ultimately is invoked, wildcard expansion
does not occur, and the script is provided with the
untouched arguments. On Windows, wildcard expansion
is always up to the program itself, therefore this is
not an issue.</p> <p>The executable name (also known as <strong>argv[0]</strong>)
is not to be specified in this list. The proper executable name
is automatically used as <strong>argv[0]</strong>, where applicable.</p> <p>If you explicitly want to set the
program name in the argument vector, option <strong>arg0</strong>
can be used.</p> </dd><dt><strong>{arg0, string() | binary()}</strong></dt><dd> <p>Only valid for <strong>{spawn_executable, <span class="anno">FileName</span>}</strong>
and explicitly specifies the program name argument when
running an executable. This can in some circumstances,
on some OSs, be desirable. How the program
responds to this is highly system-dependent and no specific
effect is guaranteed.</p> </dd><dt><strong>exit_status</strong></dt><dd> <p>Only valid for <strong>{spawn, <span class="anno">Command</span>}</strong>, where
<strong><span class="anno">Command</span></strong> refers to an external program, and
for <strong>{spawn_executable, <span class="anno">FileName</span>}</strong>.</p> <p>When the external process connected to the port exits, a
message of the form <strong>{Port,{exit_status,Status}}</strong> is
sent to the connected process, where <strong>Status</strong> is the
exit status of the external process. If the program
aborts on Unix, the same convention is used as the shells
do (that is, 128+signal).</p> <p>If option <strong>eof</strong> is specified also, the messages <strong>eof</strong>
and <strong>exit_status</strong> appear in an unspecified order.</p> <p>If the port program closes its <strong>stdout</strong> without exiting,
option <strong>exit_status</strong> does not work.</p> </dd><dt><strong>use_stdio</strong></dt><dd> <p>Only valid for <strong>{spawn, <span class="anno">Command</span>}</strong> and
<strong>{spawn_executable, <span class="anno">FileName</span>}</strong>. It
allows the standard input and output (file descriptors 0
and 1) of the spawned (Unix) process for communication
with Erlang.</p> </dd><dt><strong>nouse_stdio</strong></dt><dd> <p>The opposite of <strong>use_stdio</strong>. It uses file descriptors
3 and 4 for communication with Erlang.</p> </dd><dt><strong>stderr_to_stdout</strong></dt><dd> <p>Affects ports to external programs. The executed program
gets its standard error file redirected to its standard
output file. <strong>stderr_to_stdout</strong> and
<strong>nouse_stdio</strong> are mutually exclusive.</p> </dd><dt><strong>overlapped_io</strong></dt><dd> <p>Affects ports to external programs on Windows only. The
standard input and standard output handles of the port program
are, if this option is supplied, opened with flag
<strong>FILE_FLAG_OVERLAPPED</strong>, so that the port program can
(and must) do
overlapped I/O on its standard handles. This is not normally
the case for simple port programs, but an option of value for the
experienced Windows programmer. <em>On all other platforms, this option is silently discarded.</em></p> </dd><dt><strong>in</strong></dt><dd> <p>The port can only be used for input.</p> </dd><dt><strong>out</strong></dt><dd> <p>The port can only be used for output.</p> </dd><dt><strong>binary</strong></dt><dd> <p>All I/O from the port is binary data objects as opposed
to lists of bytes.</p> </dd><dt><strong>eof</strong></dt><dd> <p>The port is not closed at the end of the file and does not
produce an exit signal. Instead, it remains open and
a <strong>{Port, eof}</strong> message is sent to the process
holding the port.</p> </dd><dt><strong>hide</strong></dt><dd> <p>When running on Windows, suppresses creation of a new
console window when spawning the port program.
(This option has no effect on other platforms.)</p> </dd><dt><strong>{parallelism, Boolean}</strong></dt><dd> <a name="open_port_parallelism"></a> <p>Sets scheduler hint for port parallelism. If set to
<strong>true</strong>, the virtual machine schedules port tasks;
when doing so, it improves parallelism in the system. If set
to <strong>false</strong>, the virtual machine tries to
perform port tasks immediately, improving latency at the
expense of parallelism. The default can be set at system startup
by passing command-line argument
<a href="./erl#+spp">erl#+spp</a> to
<strong>erl(1)</strong>.</p> </dd></dl><p>Default is <strong>stream</strong> for all port types and
<strong>use_stdio</strong> for spawned ports.</p><p>Failure: if the port cannot be opened, the exit reason is
<strong>badarg</strong>, <strong>system_limit</strong>, or the POSIX error code that
most closely describes the error, or <strong>einval</strong> if no POSIX
code is appropriate:</p><dl><dt><strong>badarg</strong></dt><dd>Bad input arguments to <strong>open_port</strong>. </dd><dt><strong>system_limit</strong></dt><dd>All available ports in the Erlang emulator are in use. </dd><dt><strong>enomem</strong></dt><dd>Not enough memory to create the port. </dd><dt><strong>eagain</strong></dt><dd>No more available OS processes. </dd><dt><strong>enametoolong</strong></dt><dd>Too long external command. </dd><dt><strong>emfile</strong></dt><dd>No more available file descriptors (for the OS process that the Erlang emulator runs in). </dd><dt><strong>enfile</strong></dt><dd>Full file table (for the entire OS). </dd><dt><strong>eacces</strong></dt><dd><strong>Command</strong> specified in <strong>{spawn_executable, Command}</strong> does not point out an executable file. </dd><dt><strong>enoent</strong></dt><dd><strong><span class="anno">FileName</span></strong> specified in <strong>{spawn_executable, <span class="anno">FileName</span>}</strong> does not point out an existing file. </dd></dl><p>During use of a port opened using <strong>{spawn, Name}</strong>,
<strong>{spawn_driver, Name}</strong>, or <strong>{spawn_executable, Name}</strong>,
errors arising when sending messages to it are reported to
the owning process using signals of the form
<strong>{'EXIT', Port, PosixCode}</strong>. For the possible values of
<strong>PosixCode</strong>, see
<a href="./file">kernel/file</a>.</p><p>The maximum number of ports that can be open at the same
time can be configured by passing command-line flag
<a href="./erl#max_ports">erl#max_ports</a> to
<strong>erl(1)</strong>.</p><h4>phash/2</h4><p>Portable hash function.</p><dl><dt>Range</dt><dd>Range = 1..2^32, Hash = 1..Range</dd></dl><p>Portable hash function that gives the same hash for
the same Erlang term regardless of machine architecture and
ERTS version (the BIF was introduced in ERTS 4.9.1.1).
The function returns a hash value for
<strong><span class="anno">Term</span></strong> within the range
<strong>1..<span class="anno">Range</span></strong>. The maximum value for
<strong><span class="anno">Range</span></strong> is 2^32.</p><h4>phash2/1</h4><h4>phash2/2</h4><p>Portable hash function.</p><dl><dt>Range</dt><dd>1..2^32</dd></dl><dl><dt>Hash</dt><dd>0..Range-1</dd></dl><p>Portable hash function that gives the same hash for
the same Erlang term regardless of machine architecture and
ERTS version (the BIF was introduced in ERTS 5.2).
The function returns a hash value for
<strong><span class="anno">Term</span></strong> within the range
<strong>0..<span class="anno">Range</span>-1</strong>. The maximum value for
<strong><span class="anno">Range</span></strong> is 2^32. When without argument
<strong><span class="anno">Range</span></strong>, a value in the range
0..2^27-1 is returned.</p><p>This BIF is always to be used for hashing terms. It
distributes small integers better than <strong>phash/2</strong>, and
it is faster for bignums and binaries.</p><p>Notice that the range <strong>0..<span class="anno">Range</span>-1</strong> is
different from the range of <strong>phash/2</strong>, which is
<strong>1..<span class="anno">Range</span></strong>.</p><h4>pid_to_list/1</h4><p>Text representation of a pid.</p><p>Returns a string corresponding to the text
representation of <strong><span class="anno">Pid</span></strong>.</p><h4>port_call/3</h4><p>Perform a synchronous call to a port with term data.</p><p>Performs a synchronous call to a port. The meaning of
<strong><span class="anno">Operation</span></strong> and <strong><span class="anno">Data</span></strong>
depends on the port, that is,
on the port driver. Not all port drivers support this feature.</p><p><strong><span class="anno">Port</span></strong> is a port identifier,
referring to a driver.</p><p><strong><span class="anno">Operation</span></strong> is an integer, which is passed on to
the driver.</p><p><strong><span class="anno">Data</span></strong> is any Erlang term. This data is converted
to binary term format and sent to the port.</p><p>Returns a term from the driver. The meaning of the returned
data also depends on the port driver.</p><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Port</span></strong> is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by <strong><span class="anno">Port</span></strong>, the exit signal from the port is guaranteed to be delivered before this <strong>badarg</strong> exception occurs. </dd><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Operation</span></strong> does not fit in a 32-bit integer. </dd><dt><strong>badarg</strong></dt><dd> If the port driver does not support synchronous control operations. </dd><dt><strong>badarg</strong></dt><dd> <p>If the port driver so decides for any reason (probably
something wrong with <strong><span class="anno">Operation</span></strong>
or <strong><span class="anno">Data</span></strong>).</p> <div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Do not call <strong>port_call</strong> with an unknown
<strong><span class="anno">Port</span></strong> identifier and expect <strong>badarg</strong>
exception. Any undefined behavior is possible (including node
crash) depending on how the port driver interprets the supplied
arguments.</p></div> </dd></dl><h4>port_close/1</h4><p>Close an open port.</p><p>Closes an open port. Roughly the same as <strong><span class="anno">Port</span> ! {self(), close}</strong> except for the error behavior
(see below), being synchronous, and that the port does
<em>not</em> reply with <strong>{Port, closed}</strong>. Any process can
close a port with <strong>port_close/1</strong>, not only the port owner
(the connected process). If the calling process is linked to
the port identified by <strong><span class="anno">Port</span></strong>, the exit
signal from the port is guaranteed to be delivered before
<strong>port_close/1</strong> returns.</p><p>For comparison: <strong><span class="anno">Port</span> ! {self(), close}</strong>
only fails with <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> does
not refer to a port or a process. If <strong><span class="anno">Port</span></strong>
is a closed port, nothing happens. If <strong><span class="anno">Port</span></strong>
is an open port and the calling process is the port owner,
the port replies with <strong>{Port, closed}</strong> when all buffers
have been flushed and the port really closes. If the calling
process is not the port owner, the <em>port owner</em> fails
with <strong>badsig</strong>.</p><p>Notice that any process can close a port using
<strong><span class="anno">Port</span> ! {PortOwner, close}</strong> as if it itself was
the port owner, but the reply always goes to the port owner.</p><p>As from Erlang/OTP R16,
<strong><span class="anno">Port</span> ! {PortOwner, close}</strong> is truly
asynchronous. Notice that this operation has always been
documented as an asynchronous operation, while the underlying
implementation has been synchronous. <strong>port_close/1</strong> is
however still fully synchronous because of its error behavior.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not an
identifier of an open port, or the registered name of an open port.
If the calling process was previously linked to the closed
port, identified by <strong><span class="anno">Port</span></strong>, the exit
signal from the port is guaranteed to be delivered before
this <strong>badarg</strong> exception occurs.</p><h4>port_command/2</h4><p>Send data to a port.</p><p>Sends data to a port. Same as
<strong><span class="anno">Port</span> ! {PortOwner, {command, Data}}</strong> except for
the error behavior and being synchronous (see below). Any process
can send data to a port with <strong>port_command/2</strong>, not only the
port owner (the connected process).</p><p>For comparison: <strong><span class="anno">Port</span> ! {PortOwner, {command, Data}}</strong> only fails with <strong>badarg</strong> if <strong><span class="anno">Port</span></strong>
does not refer to a port or a process. If <strong><span class="anno">Port</span></strong> is
a closed port, the data message disappears 
without a sound. If <strong><span class="anno">Port</span></strong> is open and the calling
process is not the port owner, the <em>port owner</em> fails
with <strong>badsig</strong>. The port owner fails with <strong>badsig</strong>
also if <strong><span class="anno">Data</span></strong> is an invalid I/O list.</p><p>Notice that any process can send to a port using
<strong><span class="anno">Port</span> ! {PortOwner, {command, <span class="anno">Data</span>}}</strong>
as if it itself was the port owner.</p><p>If the port is busy, the calling process is suspended
until the port is not busy any more.</p><p>As from Erlang/OTP R16,
<strong><span class="anno">Port</span> ! {PortOwner, {command, Data}}</strong>
is truly asynchronous. Notice that this operation has always been
documented as an asynchronous operation, while the underlying
implementation has been synchronous. <strong>port_command/2</strong> is
however still fully synchronous because of its error behavior.</p><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> <p>If <strong><span class="anno">Port</span></strong> is not an identifier of an open
port, or the registered name of an open port. If the
calling process was previously linked to the closed port,
identified by <strong><span class="anno">Port</span></strong>, the exit signal
from the port is guaranteed to be delivered before this
<strong>badarg</strong> exception occurs.</p> </dd><dt><strong>badarg</strong></dt><dd> <p>If <strong><span class="anno">Data</span></strong> is an invalid I/O list.</p> </dd></dl><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Do not send data to an unknown port. Any undefined behavior is
possible (including node crash) depending on how the port driver
interprets the data.</p></div><h4>port_command/3</h4><p>Send data to a port.</p><p>Sends data to a port. <strong>port_command(Port, Data, [])</strong>
equals <strong>port_command(Port, Data)</strong>.</p><p>If the port command is aborted, <strong>false</strong> is returned,
otherwise <strong>true</strong>.</p><p>If the port is busy, the calling process is suspended
until the port is not busy anymore.</p><p><strong><span class="anno">Option</span></strong>s:</p><dl><dt><strong>force</strong></dt><dd>The calling process is not suspended if the port is busy, instead the port command is forced through. The call fails with a <strong>notsup</strong> exception if the driver of the port does not support this. For more information, see driver flag <a href="./driver_entry#driver_flags">driver_entry#driver_flags</a>. </dd><dt><strong>nosuspend</strong></dt><dd>The calling process is not suspended if the port is busy, instead the port command is aborted and <strong>false</strong> is returned.  </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>More options can be added in a future release.</p></div><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Port</span></strong> is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by <strong><span class="anno">Port</span></strong>, the exit signal from the port is guaranteed to be delivered before this <strong>badarg</strong> exception occurs. </dd><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Data</span></strong> is an invalid I/O list. </dd><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">OptionList</span></strong> is an invalid option list. </dd><dt><strong>notsup</strong></dt><dd> If option <strong>force</strong> has been passed, but the driver of the port does not allow forcing through a busy port. </dd></dl><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Do not send data to an unknown port. Any undefined behavior is
possible (including node crash) depending on how the port driver
interprets the data.</p></div><h4>port_connect/2</h4><p>Set the owner of a port.</p><p>Sets the port owner (the connected port) to <strong><span class="anno">Pid</span></strong>.
Roughly the same as
<strong><span class="anno">Port</span> ! {Owner, {connect, <span class="anno">Pid</span>}}</strong>
except for the following:</p><ul><li> <p>The error behavior differs, see below.</p> </li><li> <p>The port does <em>not</em> reply with
<strong>{Port,connected}</strong>.</p> </li><li> <p><strong>port_connect/1</strong> is synchronous, see below.</p> </li><li> <p>The new port owner gets linked to the port.</p> </li></ul><p>The old port owner stays linked to the port and must call
<strong>unlink(Port)</strong> if this is not desired. Any process can
set the port owner to be any process with
<strong>port_connect/2</strong>.</p><p>For comparison:
<strong><span class="anno">Port</span> ! {self(), {connect, <span class="anno">Pid</span>}}</strong>
only fails with <strong>badarg</strong> if <strong><span class="anno">Port</span></strong>
does not refer to a port or a process. If
<strong><span class="anno">Port</span></strong> is a closed port, nothing happens.
If <strong><span class="anno">Port</span></strong>
is an open port and the calling process is the port owner,
the port replies with <strong>{Port, connected}</strong> to the old
port owner. Notice that the old port owner is still linked to
the port, while the new is not. If <strong><span class="anno">Port</span></strong> is an open
port and the calling process is not the port owner,
the <em>port owner</em> fails with <strong>badsig</strong>. The port
owner fails with <strong>badsig</strong> also if <strong><span class="anno">Pid</span></strong> is not
an existing local process identifier.</p><p>Notice that any process can set the port owner using
<strong><span class="anno">Port</span> ! {PortOwner, {connect, <span class="anno">Pid</span>}}</strong>
as if it itself was the port owner, but the reply always goes to
the port owner.</p><p>As from Erlang/OTP R16,
<strong><span class="anno">Port</span> ! {PortOwner, {connect, <span class="anno">Pid</span>}}</strong>
is truly asynchronous. Notice that this operation has always been
documented as an asynchronous operation, while the underlying
implementation has been synchronous. <strong>port_connect/2</strong> is
however still fully synchronous because of its error behavior.</p><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Port</span></strong> is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by <strong><span class="anno">Port</span></strong>, the exit signal from the port is guaranteed to be delivered before this <strong>badarg</strong> exception occurs. </dd><dt><strong>badarg</strong></dt><dd>If the process identified by <strong>Pid</strong> is not an existing local process.</dd></dl><h4>port_control/3</h4><p>Perform a synchronous control operation on a port.</p><p>Performs a synchronous control operation on a port.
The meaning of <strong><span class="anno">Operation</span></strong> and
<strong><span class="anno">Data</span></strong> depends on
the port, that is, on the port driver. Not all port drivers
support this control feature.</p><p>Returns a list of integers in the range 0..255, or a
binary, depending on the port driver. The meaning of
the returned data also depends on the port driver.</p><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Port</span></strong> is not an open port or the registered name of an open port. </dd><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Operation</span></strong> cannot fit in a 32-bit integer. </dd><dt><strong>badarg</strong></dt><dd> If the port driver does not support synchronous control operations. </dd><dt><strong>badarg</strong></dt><dd> If the port driver so decides for any reason (probably something wrong with <strong><span class="anno">Operation</span></strong> or <strong><span class="anno">Data</span></strong>). <div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Do not call <strong>port_control/3</strong> with an unknown
<strong><span class="anno">Port</span></strong> identifier and expect <strong>badarg</strong>
exception. Any undefined behavior is possible (including node
crash) depending on how the port driver interprets the supplied
arguments.</p></div> </dd></dl><h4>port_info/1</h4><p>Information about a port.</p><p>Returns a list containing tuples with information about
<strong><span class="anno">Port</span></strong>, or <strong>undefined</strong> if the port is not open.
The order of the tuples is undefined, and all the
tuples are not mandatory.
If the port is closed and the calling process
was previously linked to the port, the exit signal from the
port is guaranteed to be delivered before <strong>port_info/1</strong>
returns <strong>undefined</strong>.</p><p>The result contains information about the following
<strong>Item</strong>s:</p><ul><li><strong>registered_name</strong> (if the port has a registered name)</li><li><strong>id</strong></li><li><strong>connected</strong></li><li><strong>links</strong></li><li><strong>name</strong></li><li><strong>input</strong></li><li><strong>output</strong></li></ul><p>For more information about the different <strong>Item</strong>s, see
<a href="#port_info/2">port_info/2</a>.</p><p>Failure: <strong>badarg</strong> if <strong>Port</strong> is not a local port
identifier, or an atom.</p><h4>port_info/2</h4><p>Information about the connected process of a port.</p><p><strong><span class="anno">Pid</span></strong> is the process identifier of the process
connected to the port.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h4>port_info/2</h4><p>Information about the internal index of a port.</p><p><strong><span class="anno">Index</span></strong> is the internal index of the port. This
index can be used to separate ports.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h4>port_info/2</h4><p>Information about the input of a port.</p><p><strong><span class="anno">Bytes</span></strong> is the total number of bytes
read from the port.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h4>port_info/2</h4><p>Information about the links of a port.</p><p><strong><span class="anno">Pids</span></strong> is a list of the process identifiers
of the processes that the port is linked to.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h4>port_info/2</h4><p>Information about the locking of a port.</p><p><strong><span class="anno">Locking</span></strong> is one of the following:</p><ul><li><strong>port_level</strong> (port-specific locking)</li><li><strong>driver_level</strong> (driver-specific locking)</li></ul><p>Notice that these results are highly implementation-specific
and can change in a future release.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h4>port_info/2</h4><p>Information about the memory size of a port.</p><a name="port_info_memory"></a><p><strong><span class="anno">Bytes</span></strong> is the total number of
bytes allocated for this port by the runtime system. The
port itself can have allocated memory that is not
included in <strong><span class="anno">Bytes</span></strong>.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h4>port_info/2</h4><p>Information about the monitors of a port.</p><p><strong><span class="anno">Monitors</span></strong> represent processes monitored by
this port.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h4>port_info/2</h4><p>Which processes are monitoring this port.</p><p>Returns list of pids that are monitoring given port at the
moment.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h4>port_info/2</h4><p>Information about the name of a port.</p><p><strong><span class="anno">Name</span></strong> is the command name set by
<a href="#open_port/2">open_port/2</a>.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h4>port_info/2</h4><p>Information about the OS pid of a port.</p><p><strong><span class="anno">OsPid</span></strong> is the process identifier (or equivalent)
of an OS process created with
<a href="#open_port/2">open_port/2</a>. If the port is not the result of
spawning an OS process, the value is <strong>undefined</strong>.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h4>port_info/2</h4><p>Information about the output of a port.</p><p><strong><span class="anno">Bytes</span></strong> is the total number of bytes written
to the port from Erlang processes using
<a href="#port_command/2">port_command/2</a>,
<a href="#port_command/3">port_command/3</a>,
or <strong><span class="anno">Port</span> ! {Owner, {command, Data}</strong>.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h4>port_info/2</h4><p>Information about the parallelism hint of a port.</p><p><strong><span class="anno">Boolean</span></strong> corresponds to the port parallelism
hint used by this port. For more information, see option
<a href="#open_port_parallelism">open_port_parallelism</a>
of <a href="#open_port/2">open_port/2</a>.</p><h4>port_info/2</h4><p>Information about the queue size of a port.</p><p><strong><span class="anno">Bytes</span></strong> is the total number
of bytes queued by the port using the ERTS driver queue
implementation.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h4>port_info/2</h4><p>Information about the registered name of a port.</p><p><strong><span class="anno">RegisteredName</span></strong> is the registered name of
the port. If the port has no registered name, <strong>[]</strong> is
returned.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h4>port_to_list/1</h4><p>Text representation of a port identifier.</p><p>Returns a string corresponding to the text
representation of the port identifier <strong><span class="anno">Port</span></strong>.</p><h4>ports/0</h4><p>List all existing ports.</p><p>Returns a list of port identifiers corresponding to all the
ports existing on the local node.</p><p>Notice that an exiting port exists, but is not open.</p><h4>pre_loaded/0</h4><p>List all preloaded modules.</p><p>Returns a list of Erlang modules that are preloaded in
the system. As all loading of code is done through the file
system, the file system must have been loaded previously.
Hence, at least the module <strong>init</strong> must be preloaded.</p><h4>process_display/2</h4><p>Write information about a local process on standard error. </p><p>Writes information about the local process <strong><span class="anno">Pid</span></strong> on
standard error. The only allowed value for the atom
<strong><span class="anno">Type</span></strong> is <strong>backtrace</strong>, which shows the contents
of the call stack, including information about the call chain, with
the current function printed first. The format of the output
is not further defined.</p><h4>process_flag/2</h4><p>Set process flag trap_exit for the calling process.</p><p>When <strong>trap_exit</strong> is set to <strong>true</strong>, exit signals
arriving to a process are converted to <strong>{'EXIT', From, Reason}</strong>
messages, which can be received as ordinary
messages. If <strong>trap_exit</strong> is set to <strong>false</strong>, the
process exits if it receives an exit signal other than
<strong>normal</strong> and the exit signal is propagated to its
linked processes. Application processes are normally
not to trap exits.</p><p>Returns the old value of the flag.</p><p>See also <a href="#exit/2">exit/2</a>.</p><h4>process_flag/2</h4><p>Set process flag error_handler for the calling process. </p><p>Used by a process to redefine the error handler
for undefined function calls and undefined registered
processes. Inexperienced users are not to use this flag,
as code auto-loading depends on the correct
operation of the error handling module.</p><p>Returns the old value of the flag.</p><h4>process_flag/2</h4><p>Set process flag min_heap_size for the calling process. </p><p>Changes the minimum heap size for the calling process.</p><p>Returns the old value of the flag.</p><h4>process_flag/2</h4><p>Set process flag min_bin_vheap_size for the calling process. </p><p>Changes the minimum binary virtual heap size for the calling
process.</p><p>Returns the old value of the flag.</p><h4>process_flag/2</h4><p>Set process flag max_heap_size for the calling process. </p><ul><li>max_heap_size</li></ul><p>This flag sets the maximum heap size for the calling process.
If <strong><span class="anno">MaxHeapSize</span></strong> is an integer, the system default
values for <strong>kill</strong> and <strong>error_logger</strong> are used.
</p><dl><dt><strong>size</strong></dt><dd> <p>The maximum size in words of the process. If set to zero, the
heap size limit is disabled. <strong>badarg</strong> is be thrown if the
value is smaller than <a href="#process_flag_min_heap_size">process_flag_min_heap_size</a>. The size check is only done when
a garbage collection is triggered.</p> <p><strong>size</strong> is the entire heap of the process when garbage collection
is triggered. This includes all generational heaps, the process stack, 
any <a href="#process_flag_message_queue_data"> messages that are considered to be part of the heap</a>, and any
extra memory that the garbage collector needs during collection.</p> <p><strong>size</strong> is the same as can be retrieved using
<a href="#process_info_total_heap_size">process_info_total_heap_size</a>,
or by adding <strong>heap_block_size</strong>, <strong>old_heap_block_size</strong>
and <strong>mbuf_size</strong> from <a href="#process_info_garbage_collection_info">process_info_garbage_collection_info</a>.</p> </dd><dt><strong>kill</strong></dt><dd> <p>When set to <strong>true</strong>, the runtime system sends an
untrappable exit signal with reason <strong>kill</strong> to the process
if the maximum heap size is reached. The garbage collection
that triggered the <strong>kill</strong> is not completed, instead the
process exits as soon as possible. When set to <strong>false</strong>,
no exit signal is sent to the process, instead it continues
executing.</p> <p>If <strong>kill</strong> is not defined in the map,
the system default will be used. The default system default
is <strong>true</strong>. It can be changed by either option
<a href="./erl#+hmaxk">+hmaxk</a> in <strong>erl(1)</strong>,
or <a href="#system_flag_max_heap_size">system_flag_max_heap_size</a>.</p> </dd><dt><strong>error_logger</strong></dt><dd> <p>When set to <strong>true</strong>, the runtime system logs an
error event via <a href="./logger">kernel/logger</a>,
containing details about the process when the maximum
heap size is reached. One log event is sent
each time the limit is reached.</p> <p>If <strong>error_logger</strong> is not defined in the map, the system
default is used. The default system default is <strong>true</strong>.
It can be changed by either the option
<a href="./erl#+hmaxel">+hmaxel</a> int <strong>erl(1)</strong>,
or <a href="#system_flag_max_heap_size">system_flag_max_heap_size</a>.</p> </dd></dl><p>The heap size of a process is quite hard to predict, especially the
amount of memory that is used during the garbage collection. When
contemplating using this option, it is recommended to first run
it in production with <strong>kill</strong> set to <strong>false</strong> and inspect
the log events to see what the normal peak sizes
of the processes in the system is and then tune the value
accordingly.
</p><h4>process_flag/2</h4><p>Set process flag message_queue_data for the calling process. </p><ul><li>message_queue_data</li></ul><p>This flag determines how messages in the message queue
are stored, as follows:</p><dl><dt><strong>off_heap</strong></dt><dd> <p><em>All</em> messages in the message queue will be stored
outside of the process heap. This implies that <em>no</em>
messages in the message queue will be part of a garbage
collection of the process.</p> </dd><dt><strong>on_heap</strong></dt><dd> <p>All messages in the message queue will eventually be
placed on heap. They can however temporarily be stored
off heap. This is how messages always have been stored
up until ERTS 8.0.</p> </dd></dl><p>The default <strong>message_queue_data</strong> process flag is determined
by command-line argument <a href="./erl#+hmqd">erl#+hmqd</a> in <strong>erl(1)</strong>.</p><p>If the process potentially can get many messages in its queue,
you are advised to set the flag to <strong>off_heap</strong>. This
because a garbage collection with many messages placed on
the heap can become extremely expensive and the process can
consume large amounts of memory. Performance of the
actual message passing is however generally better when not
using flag <strong>off_heap</strong>.</p><p>When changing this flag messages will be moved. This work
has been initiated but not completed when this function
call returns.</p><p>Returns the old value of the flag.</p><h4>process_flag/2</h4><p>Set process flag priority for the calling process.</p><ul><li>priority_level</li></ul><p>
Sets the process priority. <strong><span class="anno">Level</span></strong> is an atom.
Four priority levels exist: <strong>low</strong>,
<strong>normal</strong>, <strong>high</strong>, and <strong>max</strong>. Default
is <strong>normal</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Priority level <strong>max</strong> is reserved for internal use in
the Erlang runtime system, and is <em>not</em> to be used
by others.</p></div><p>Internally in each priority level, processes are scheduled
in a round robin fashion.</p><p>Execution of processes on priority <strong>normal</strong> and
<strong>low</strong> are interleaved. Processes on priority
<strong>low</strong> are selected for execution less
frequently than processes on priority <strong>normal</strong>.</p><p>When runnable processes on priority <strong>high</strong> exist,
no processes on priority <strong>low</strong> or <strong>normal</strong> are
selected for execution. Notice however that this does
<em>not</em> mean that no processes on priority <strong>low</strong>
or <strong>normal</strong> can run when processes
are running on priority <strong>high</strong>. When using multiple
schedulers, more processes can be running
in parallel than processes on priority <strong>high</strong>. That is,
a <strong>low</strong> and a <strong>high</strong> priority process can
execute at the same time.</p><p>When runnable processes on priority <strong>max</strong> exist,
no processes on priority <strong>low</strong>, <strong>normal</strong>, or
<strong>high</strong> are selected for execution. As with priority
<strong>high</strong>, processes on lower priorities can
execute in parallel with processes on priority <strong>max</strong>.</p><p>Scheduling is pre-emptive. Regardless of priority, a process
is pre-empted when it has consumed more than a certain number
of reductions since the last time it was selected for
execution.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Do not depend on the scheduling
to remain exactly as it is today. Scheduling is likely to be
changed in a future release to use available processor cores better.</p></div><p>There is <em>no</em> automatic mechanism for
avoiding priority inversion, such as priority inheritance
or priority ceilings. When using priorities,
take this into account and handle such scenarios by
yourself.</p><p>Making calls from a <strong>high</strong> priority process into code
that you has no control over can cause the <strong>high</strong>
priority process to wait for a process with lower
priority. That is, effectively decreasing the priority of the
<strong>high</strong> priority process during the call. Even if this
is not the case with one version of the code that you have no
control over, it can be the case in a future
version of it. This can, for example, occur if a
<strong>high</strong> priority process triggers code loading, as
the code server runs on priority <strong>normal</strong>.</p><p>Other priorities than <strong>normal</strong> are normally not needed.
When other priorities are used, use them with care,
<em>especially</em> priority <strong>high</strong>. A
process on priority <strong>high</strong> is only
to perform work for short periods. Busy looping for
long periods in a <strong>high</strong> priority process causes
most likely problems, as important OTP servers
run on priority <strong>normal</strong>.</p><p>Returns the old value of the flag.</p><h4>process_flag/2</h4><p>Set process flag save_calls for the calling process.</p><p><strong><span class="anno">N</span></strong> must be an integer in the interval 0..10000.
If <strong><span class="anno">N</span></strong> &gt; 0, call saving is made
active for the
process. This means that information about the <strong><span class="anno">N</span></strong>
most recent global function calls, BIF calls, sends, and
receives made by the process are saved in a list, which
can be retrieved with
<strong>process_info(Pid, last_calls)</strong>. A global function
call is one in which the module of the function is
explicitly mentioned. Only a fixed amount of information
is saved, as follows:</p><ul><li><p>A tuple <strong>{Module, Function, Arity}</strong> for
function calls</p></li><li><p>The atoms <strong>send</strong>, <strong>'receive'</strong>, and
<strong>timeout</strong> for sends and receives (<strong>'receive'</strong>
when a message is received and <strong>timeout</strong> when a
receive times out)</p></li></ul><p>If <strong>N</strong> = 0,
call saving is disabled for the process, which is the
default. Whenever the size of the call saving list is set,
its contents are reset.</p><p>Returns the old value of the flag.</p><h4>process_flag/2</h4><p>Set process flag sensitive for the calling process.</p><p>Sets or clears flag <strong>sensitive</strong> for the current process.
When a process has been marked as sensitive by calling
<strong>process_flag(sensitive, true)</strong>, features in the runtime
system that can be used for examining the data or inner working
of the process are silently disabled.</p><p>Features that are disabled include (but are not limited to)
the following:</p><ul><li><p>Tracing. Trace flags can still be set for the process,
but no trace messages of any kind are generated. (If flag
<strong>sensitive</strong> is turned off, trace messages are again
generated if any trace flags are set.)</p></li><li><p>Sequential tracing. The sequential trace token is
propagated as usual, but no sequential trace messages are
generated.</p></li></ul><p><strong>process_info/1,2</strong> cannot be used to read out the
message queue or the process dictionary (both are returned
as empty lists).</p><p>Stack back-traces cannot be displayed for the process.</p><p>In crash dumps, the stack, messages, and the process dictionary
are omitted.</p><p>If <strong>{save_calls,N}</strong> has been set for the process, no
function calls are saved to the call saving list.
(The call saving list is not cleared. Also, send, receive,
and time-out events are still added to the list.)</p><p>Returns the old value of the flag.</p><h4>process_flag/3</h4><p>Set process flags for a process.</p><p>Sets certain flags for the process <strong><span class="anno">Pid</span></strong>,
in the same manner as
<a href="#process_flag/2">process_flag/2</a>.
Returns the old value of the flag. The valid values for
<strong><span class="anno">Flag</span></strong> are only a subset of those allowed in
<strong>process_flag/2</strong>, namely <strong>save_calls</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Pid</span></strong>
is not a local process.</p><h4>process_info/1</h4><p>Information about a process.</p><ul><li>process_info_result_item</li></ul><ul><li>priority_level</li></ul><ul><li>stack_item</li></ul><ul><li>max_heap_size</li></ul><ul><li>message_queue_data</li></ul><p>Returns a list containing <strong><span class="anno">InfoTuple</span></strong>s with
miscellaneous information about the process identified by
<strong>Pid</strong>, or <strong>undefined</strong> if the process is not alive.</p><p>The order of the <strong><span class="anno">InfoTuple</span></strong>s is undefined and
all <strong><span class="anno">InfoTuple</span></strong>s are not mandatory.
The <strong><span class="anno">InfoTuple</span></strong>s
part of the result can be changed without prior notice.</p><p>The <strong><span class="anno">InfoTuple</span></strong>s with the following items
are part of the result:</p><ul><li><strong>current_function</strong></li><li><strong>initial_call</strong></li><li><strong>status</strong></li><li><strong>message_queue_len</strong></li><li><strong>links</strong></li><li><strong>dictionary</strong></li><li><strong>trap_exit</strong></li><li><strong>error_handler</strong></li><li><strong>priority</strong></li><li><strong>group_leader</strong></li><li><strong>total_heap_size</strong></li><li><strong>heap_size</strong></li><li><strong>stack_size</strong></li><li><strong>reductions</strong></li><li><strong>garbage_collection</strong></li></ul><p>If the process identified by <strong><span class="anno">Pid</span></strong> has a
registered name,
also an <strong><span class="anno">InfoTuple</span></strong> with item <strong>registered_name</strong>
is included.</p><p>For information about specific <strong><span class="anno">InfoTuple</span></strong>s, see
<a href="#process_info/2">process_info/2</a>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for <em>debugging only</em>. For
all other purposes, use <a href="#process_info/2">process_info/2</a>.</p></div><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Pid</span></strong> is not a
local process.</p><h4>process_info/2</h4><h4>process_info/2</h4><p>Information about a process.</p><ul><li>process_info_item</li></ul><ul><li>process_info_result_item</li></ul><ul><li>stack_item</li></ul><ul><li>priority_level</li></ul><ul><li>max_heap_size</li></ul><ul><li>message_queue_data</li></ul><p>Returns information about the process identified by
<strong><span class="anno">Pid</span></strong>, as specified by
<strong><span class="anno">Item</span></strong> or <strong><span class="anno">ItemList</span></strong>.
Returns <strong>undefined</strong> if the process is not alive.</p><p>If the process is alive and a single <strong><span class="anno">Item</span></strong>
is specified, the returned value is the corresponding
<strong><span class="anno">InfoTuple</span></strong>, unless <strong>Item =:= registered_name</strong>
and the process has no registered name. In this case,
<strong>[]</strong> is returned. This strange behavior is because of
historical reasons, and is kept for backward compatibility.</p><p>If <strong><span class="anno">ItemList</span></strong> is specified, the result is
<strong><span class="anno">InfoTupleList</span></strong>.
The <strong><span class="anno">InfoTuple</span></strong>s in
<strong><span class="anno">InfoTupleList</span></strong> are included with the corresponding
<strong><span class="anno">Item</span></strong>s in the same order as the
<strong><span class="anno">Item</span></strong>s were included
in <strong><span class="anno">ItemList</span></strong>. Valid <strong><span class="anno">Item</span></strong>s can
be included multiple times in <strong><span class="anno">ItemList</span></strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If <strong>registered_name</strong> is part of <strong><span class="anno">ItemList</span></strong>
and the process has no name registered, a
<strong>{registered_name, []}</strong>, <strong><span class="anno">InfoTuple</span></strong>
<em>will</em> be included in the resulting
<strong><span class="anno">InfoTupleList</span></strong>. This
behavior is different when a single
<strong>Item =:= registered_name</strong> is specified, and when
<strong>process_info/1</strong> is used.</p></div><p>Valid <strong><span class="anno">InfoTuple</span></strong>s with corresponding
<strong><span class="anno">Item</span></strong>s:</p><dl><dt><strong>{backtrace, <span class="anno">Bin</span>}</strong></dt><dd> <p>Binary <strong><span class="anno">Bin</span></strong> contains the same information
as the output from
<strong>erlang:process_display(<span class="anno">Pid</span>, backtrace)</strong>. Use
<strong>binary_to_list/1</strong> to obtain the string of characters
from the binary.</p> </dd><dt><strong>{binary, <span class="anno">BinInfo</span>}</strong></dt><dd> <p><strong><span class="anno">BinInfo</span></strong> is a list containing miscellaneous
information about binaries on the heap of this
process.
This <strong><span class="anno">InfoTuple</span></strong> can be changed or
removed without prior notice. In the current implementation
<strong><span class="anno">BinInfo</span></strong> is a list of tuples. The tuples
contain; <strong>BinaryId</strong>, <strong>BinarySize</strong>, <strong>BinaryRefcCount</strong>.</p> <p>The message queue is on the heap depending on the
process flag <a href="#process_flag_message_queue_data">process_flag_message_queue_data</a>.</p> </dd><dt><strong>{catchlevel, <span class="anno">CatchLevel</span>}</strong></dt><dd> <p><strong><span class="anno">CatchLevel</span></strong> is the number of currently active
catches in this process. This <strong><span class="anno">InfoTuple</span></strong> can be
changed or removed without prior notice.</p> </dd><dt><strong>{current_function, {<span class="anno">Module</span>, <span class="anno">Function</span>, Arity} | undefined}</strong></dt><dd> <p><strong><span class="anno">Module</span></strong>, <strong><span class="anno">Function</span></strong>,
<strong><span class="anno">Arity</span></strong> is
the current function call of the process. The value
<strong>undefined</strong> can be returned if the process is
currently executing native compiled code.</p> </dd><dt><strong>{current_location, {<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Arity</span>, <span class="anno">Location</span>}}</strong></dt><dd> <p><strong><span class="anno">Module</span></strong>, <strong><span class="anno">Function</span></strong>,
<strong><span class="anno">Arity</span></strong> is
the current function call of the process.
<strong><span class="anno">Location</span></strong> is a list of two-tuples describing
the location in the source code.</p> </dd><dt><strong>{current_stacktrace, <span class="anno">Stack</span>}</strong></dt><dd> <p>Returns the current call stack back-trace (<em>stacktrace</em>)
of the process. The stack has the same format as returned by
<a href="#get_stacktrace/0">get_stacktrace/0</a>. The depth of the
stacktrace is truncated according to the <strong>backtrace_depth</strong>
system flag setting.</p> </dd><dt><strong>{dictionary, <span class="anno">Dictionary</span>}</strong></dt><dd> <p><strong><span class="anno">Dictionary</span></strong> is the process dictionary.</p> </dd><dt><strong>{error_handler, <span class="anno">Module</span>}</strong></dt><dd> <p><strong><span class="anno">Module</span></strong> is the error handler module used by
the process (for undefined function calls, for example).</p> </dd><dt><strong>{garbage_collection, <span class="anno">GCInfo</span>}</strong></dt><dd> <p><strong><span class="anno">GCInfo</span></strong> is a list containing miscellaneous
information about garbage collection for this process.
The content of <strong><span class="anno">GCInfo</span></strong> can be changed without
prior notice.</p> </dd><dt> <a name="process_info_garbage_collection_info"></a> <strong>{garbage_collection_info, <span class="anno">GCInfo</span>}</strong> </dt><dd> <p><strong><span class="anno">GCInfo</span></strong> is a list containing miscellaneous
detailed information about garbage collection for this process.
The content of <strong><span class="anno">GCInfo</span></strong> can be changed without
prior notice. For details about the meaning of each item, see
<a href="#gc_minor_start">gc_minor_start</a>
in <a href="#trace/3">trace/3</a>.</p> </dd><dt><strong>{group_leader, <span class="anno">GroupLeader</span>}</strong></dt><dd> <p><strong><span class="anno">GroupLeader</span></strong> is the group leader for the I/O
of the process.</p> </dd><dt><strong>{heap_size, <span class="anno">Size</span>}</strong></dt><dd> <p><strong><span class="anno">Size</span></strong> is the size in words of the youngest
heap generation of the process. This generation includes
the process stack. This information is highly
implementation-dependent, and can change if the
implementation changes.</p> </dd><dt><strong>{initial_call, {<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Arity</span>}}</strong></dt><dd> <p><strong><span class="anno">Module</span></strong>, <strong><span class="anno">Function</span></strong>,
<strong><span class="anno">Arity</span></strong> is
the initial function call with which the process was
spawned.</p> </dd><dt><strong>{links, <span class="anno">PidsAndPorts</span>}</strong></dt><dd> <p><strong><span class="anno">PidsAndPorts</span></strong> is a list of process identifiers
and port identifiers, with processes or ports to which the process
has a link.</p> </dd><dt><strong>{last_calls, false|Calls}</strong></dt><dd> <p>The value is <strong>false</strong> if call saving is not active
for the process (see <a href="#process_flag/3">process_flag/3</a>).
If call saving is active, a list is returned, in which
the last element is the most recent called.</p> </dd><dt><strong>{memory, <span class="anno">Size</span>}</strong></dt><dd> <a name="process_info_memory"></a> <p><strong><span class="anno">Size</span></strong> is the size in bytes of the process.
This includes call stack, heap, and internal structures.</p> </dd><dt><strong>{message_queue_len, <span class="anno">MessageQueueLen</span>}</strong></dt><dd> <p><strong><span class="anno">MessageQueueLen</span></strong> is the number of messages
currently in the message queue of the process. This is the
length of the list <strong><span class="anno">MessageQueue</span></strong> returned as
the information item <strong>messages</strong> (see below).</p> </dd><dt><strong>{messages, <span class="anno">MessageQueue</span>}</strong></dt><dd> <p><strong><span class="anno">MessageQueue</span></strong> is a list of the messages to
the process, which have not yet been processed.</p> </dd><dt><strong>{min_heap_size, <span class="anno">MinHeapSize</span>}</strong></dt><dd> <p><strong><span class="anno">MinHeapSize</span></strong> is the minimum heap size
for the process.</p> </dd><dt><strong>{min_bin_vheap_size, <span class="anno">MinBinVHeapSize</span>}</strong></dt><dd> <p><strong><span class="anno">MinBinVHeapSize</span></strong> is the minimum binary virtual
heap size for the process.</p> </dd><dt><strong>{monitored_by, <span class="anno">MonitoredBy</span>}</strong></dt><dd> <p>A list of identifiers for all the processes, ports and NIF
resources, that are monitoring the process.</p> </dd><dt><strong>{monitors, <span class="anno">Monitors</span>}</strong></dt><dd> <p>A list of monitors (started by <strong>monitor/2</strong>)
that are active for the process. For a local process
monitor or a remote process monitor by a process
identifier, the list consists of:</p> <dl><dt><strong>{process, <span class="anno">Pid</span>}</strong></dt><dd>Process is monitored by pid.</dd><dt><strong>{process, {<span class="anno">RegName</span>, <span class="anno">Node</span>}}</strong></dt><dd>Local or remote process is monitored by name.</dd><dt><strong>{port, PortId}</strong></dt><dd>Local port is monitored by port id.</dd><dt><strong>{port, {<span class="anno">RegName</span>, <span class="anno">Node</span>}}</strong></dt><dd>Local port is monitored by name. Please note, that remote port monitors are not supported, so <strong>Node</strong> will always be the local node name.</dd></dl> </dd><dt><strong>{message_queue_data, <span class="anno">MQD</span>}</strong></dt><dd> <p>Returns the current state of process flag
<strong>message_queue_data</strong>. <strong><span class="anno">MQD</span></strong> is either
<strong>off_heap</strong> or <strong>on_heap</strong>. For more
information, see the documentation of
<a href="#process_flag_message_queue_data">process_flag_message_queue_data</a>.</p> </dd><dt><strong>{priority, <span class="anno">Level</span>}</strong></dt><dd> <p><strong><span class="anno">Level</span></strong> is the current priority level for
the process. For more information on priorities, see
<a href="#process_flag_priority">process_flag_priority</a>.</p> </dd><dt><strong>{reductions, <span class="anno">Number</span>}</strong></dt><dd> <p><strong><span class="anno">Number</span></strong> is the number of reductions executed
by the process.</p> </dd><dt><strong>{registered_name, <span class="anno">Atom</span>}</strong></dt><dd> <p><strong><span class="anno">Atom</span></strong> is the registered process name.
If the process has no registered name, this tuple is not
present in the list.</p> </dd><dt><strong>{sequential_trace_token, [] | <span class="anno">SequentialTraceToken</span>}</strong></dt><dd> <p><strong><span class="anno">SequentialTraceToken</span></strong> is the sequential trace
token for the process. This <strong><span class="anno">InfoTuple</span></strong> can be
changed or removed without prior notice.</p> </dd><dt><strong>{stack_size, <span class="anno">Size</span>}</strong></dt><dd> <p><strong><span class="anno">Size</span></strong> is the stack size, in words,
of the process.</p> </dd><dt><strong>{status, <span class="anno">Status</span>}</strong></dt><dd> <p><strong><span class="anno">Status</span></strong> is the status of the process and is
one of the following:</p> <ul><li><strong>exiting</strong></li><li><strong>garbage_collecting</strong></li><li><strong>waiting</strong> (for a message)</li><li><strong>running</strong></li><li><strong>runnable</strong> (ready to run, but another process is running)</li><li><strong>suspended</strong> (suspended on a "busy" port or by the BIF <strong>erlang:suspend_process/1,2</strong>)</li></ul> </dd><dt><strong>{suspending, <span class="anno">SuspendeeList</span>}</strong></dt><dd> <p><strong><span class="anno">SuspendeeList</span></strong> is a list of
<strong>{<span class="anno">Suspendee</span>, <span class="anno">ActiveSuspendCount</span>, <span class="anno">OutstandingSuspendCount</span>}</strong> tuples.
<strong><span class="anno">Suspendee</span></strong> is the process identifier of a
process that has been, or is to be,
suspended by the process identified by <strong><span class="anno">Pid</span></strong>
through the BIF <a href="#suspend_process/2">suspend_process/2</a> or
<a href="#suspend_process/1">suspend_process/1</a>.</p> <p><strong><span class="anno">ActiveSuspendCount</span></strong> is the number of
times <strong><span class="anno">Suspendee</span></strong> has been suspended by
<strong><span class="anno">Pid</span></strong>.
<strong><span class="anno">OutstandingSuspendCount</span></strong> is the number of not
yet completed suspend requests sent by <strong><span class="anno">Pid</span></strong>,
that is:</p> <ul><li> <p>If <strong><span class="anno">ActiveSuspendCount</span> =/= 0</strong>,
<strong><span class="anno">Suspendee</span></strong> is
currently in the suspended state.</p> </li><li> <p>If <strong><span class="anno">OutstandingSuspendCount</span> =/= 0</strong>,
option <strong>asynchronous</strong> of <strong>erlang:suspend_process/2</strong>
has been used and the suspendee has not yet been
suspended by <strong><span class="anno">Pid</span></strong>.</p> </li></ul> <p>Notice that <strong><span class="anno">ActiveSuspendCount</span></strong> and
<strong><span class="anno">OutstandingSuspendCount</span></strong> are not the
total suspend count on <strong><span class="anno">Suspendee</span></strong>,
only the parts contributed by <strong><span class="anno">Pid</span></strong>.</p> </dd><dt> <a name="process_info_total_heap_size"></a> <strong>{total_heap_size, <span class="anno">Size</span>}</strong> </dt><dd> <p><strong><span class="anno">Size</span></strong> is the total size, in words, of all heap
fragments of the process. This includes the process stack and
any unreceived messages that are considered to be part of the
heap.</p> </dd><dt><strong>{trace, <span class="anno">InternalTraceFlags</span>}</strong></dt><dd> <p><strong><span class="anno">InternalTraceFlags</span></strong> is an integer
representing the internal trace flag for this process.
This <strong><span class="anno">InfoTuple</span></strong>
can be changed or removed without prior notice.</p> </dd><dt><strong>{trap_exit, <span class="anno">Boolean</span>}</strong></dt><dd> <p><strong><span class="anno">Boolean</span></strong> is <strong>true</strong> if the process
is trapping exits, otherwise <strong>false</strong>.</p> </dd></dl><p>Notice that not all implementations support all
these <strong><span class="anno">Item</span></strong>s.</p><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">Pid</span></strong> is not a local process.</dd><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">Item</span></strong> is an invalid item.</dd></dl><h4>processes/0</h4><p>All processes.</p><p>Returns a list of process identifiers corresponding to
all the processes currently existing on the local node.</p><p>Notice that an exiting process exists, but is not alive.
That is, <strong>is_process_alive/1</strong> returns <strong>false</strong>
for an exiting process, but its process identifier is part
of the result returned from <strong>processes/0</strong>.</p><p>Example:</p><pre>
&gt; <span class="input">processes().</span>
[&lt;0.0.0&gt;,&lt;0.2.0&gt;,&lt;0.4.0&gt;,&lt;0.5.0&gt;,&lt;0.7.0&gt;,&lt;0.8.0&gt;]</pre><h4>purge_module/1</h4><p>Remove old code for a module.</p><p>Removes old code for <strong><span class="anno">Module</span></strong>.
Before this BIF is used,
<a href="#check_process_code/2">check_process_code/2</a>is to be called to check
that no processes execute old code in the module.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for the code server (see
<a href="./code">kernel/code</a>)
and is not to be used elsewhere.</p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from ERTS 8.0 (Erlang/OTP 19), any lingering processes
that still execute the old code is killed by this function.
In earlier versions, such incorrect use could cause much
more fatal failures, like emulator crash.</p></div><p>Failure: <strong>badarg</strong> if there is no old code for
<strong><span class="anno">Module</span></strong>.</p><h4>put/2</h4><p>Add a new value to the process dictionary.</p><p>Adds a new <strong><span class="anno">Key</span></strong> to the process dictionary,
associated with the value <strong><span class="anno">Val</span></strong>, and returns
<strong>undefined</strong>. If <strong><span class="anno">Key</span></strong> exists, the old
value is deleted and replaced by <strong><span class="anno">Val</span></strong>, and
the function returns the old value. Example:</p><pre>
&gt; <span class="input">X = put(name, walrus), Y = put(name, carpenter),</span>
<span class="input">Z = get(name),</span>
<span class="input">{X, Y, Z}.</span>
{undefined,walrus,carpenter}</pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The values stored when <strong>put</strong> is evaluated within
the scope of a <strong>catch</strong> are not retracted if a
<strong>throw</strong> is evaluated, or if an error occurs.</p></div><h4>raise/3</h4><p>Stop execution with an exception of specified class, reason, and call stack backtrace.</p><ul><li>raise_stacktrace</li></ul><p>Stops the execution of the calling process with an
exception of the specified class, reason, and call stack backtrace
(<em>stacktrace</em>).</p><p><strong><span class="anno">Class</span></strong> is <strong>error</strong>, <strong>exit</strong>, or
<strong>throw</strong>. So, if it were not for the stacktrace,
<strong>erlang:raise(<span class="anno">Class</span>, <span class="anno">Reason</span>, <span class="anno">Stacktrace</span>)</strong> is equivalent to
<strong>erlang:<span class="anno">Class</span>(<span class="anno">Reason</span>)</strong>.</p><p><strong><span class="anno">Reason</span></strong> is any term.
<strong><span class="anno">Stacktrace</span></strong> is a list as
returned from <strong>get_stacktrace()</strong>, that is, a list of
four-tuples <strong>{Module, Function, Arity | Args, Location}</strong>, where <strong>Module</strong> and <strong>Function</strong>
are atoms, and the third element is an integer arity or an
argument list. The stacktrace can also contain <strong>{Fun, Args, Location}</strong> tuples, where <strong>Fun</strong> is a local
fun and <strong>Args</strong> is an argument list.</p><p>Element <strong>Location</strong> at the end is optional.
Omitting it is equivalent to specifying an empty list.</p><p>The stacktrace is used as the exception stacktrace for the
calling process; it is truncated to the current
maximum stacktrace depth.</p><p>As evaluating this function causes the process to
terminate, it has no return value unless the arguments are
invalid, in which case the function <em>returns the error reason</em> <strong>badarg</strong>. If you want to be
sure not to return, you can call
<strong>error(erlang:raise(<span class="anno">Class</span>, <span class="anno">Reason</span>, <span class="anno">Stacktrace</span>))</strong>
and hope to distinguish exceptions later.</p><h4>read_timer/1</h4><p>Read the state of a timer.</p><p>Reads the state of a timer. The same as calling
<a href="#read_timer/2">read_timer/2</a>.</p><h4>read_timer/2</h4><p>Read the state of a timer.</p><p>Reads the state of a timer that has been created by either
<a href="#start_timer/4">start_timer/4</a>
or <a href="#send_after/4">send_after/4</a>.
<strong><span class="anno">TimerRef</span></strong> identifies the timer, and
was returned by the BIF that created the timer.</p><p><strong><span class="anno">Option</span>s</strong>:</p><dl><dt><strong>{async, Async}</strong></dt><dd> <p>Asynchronous request for state information. <strong>Async</strong>
defaults to <strong>false</strong>, which causes the operation
to be performed synchronously. In this case, the <strong>Result</strong>
is returned by <strong>erlang:read_timer</strong>. When
<strong>Async</strong> is <strong>true</strong>, <strong>erlang:read_timer</strong>
sends an asynchronous request for the state information
to the timer service that manages the timer, and then returns
<strong>ok</strong>. A message on the format <strong>{read_timer, <span class="anno">TimerRef</span>, <span class="anno">Result</span>}</strong> is
sent to the caller of <strong>erlang:read_timer</strong> when the
operation has been processed.</p> </dd></dl><p>More <strong><span class="anno">Option</span></strong>s can be added in the future.</p><p>If <strong><span class="anno">Result</span></strong> is an integer, it represents the
time in milliseconds left until the timer expires.</p><p>If <strong><span class="anno">Result</span></strong> is <strong>false</strong>, a
timer corresponding to <strong><span class="anno">TimerRef</span></strong> could not
be found. This because the timer had expired,
or been canceled, or because <strong><span class="anno">TimerRef</span></strong>
never has corresponded to a timer. Even if the timer has expired,
it does not tell you whether or not the time-out message has
arrived at its destination yet.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The timer service that manages the timer can be co-located
with another scheduler than the scheduler that the calling
process is executing on. If so, communication
with the timer service takes much longer time than if it
is located locally. If the calling process is in a critical
path, and can do other things while waiting for the result
of this operation, you want to use option <strong>{async, true}</strong>.
If using option <strong>{async, false}</strong>, the calling
process is blocked until the operation has been performed.</p></div><p>See also 
<a href="#send_after/4">send_after/4</a>,
<a href="#start_timer/4">start_timer/4</a>, and
<a href="#cancel_timer/2">cancel_timer/2</a>.</p><h4>ref_to_list/1</h4><p>Text representation of a reference.</p><p>Returns a string corresponding to the text
representation of <strong><span class="anno">Ref</span></strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for debugging and is not to be used
in application programs.</p></div><h4>register/2</h4><p>Register a name for a pid (or port).</p><p>Associates the name <strong><span class="anno">RegName</span></strong> with a process
identifier (pid) or a port identifier.
<strong><span class="anno">RegName</span></strong>, which must be an atom, can be used
instead of the pid or port identifier in send operator
(<strong><span class="anno">RegName</span> ! Message</strong>). Example:</p><pre>
&gt; <span class="input">register(db, Pid).</span>
true</pre><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">PidOrPort</span></strong> is not an existing local process or port.</dd><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">RegName</span></strong> is already in use.</dd><dt><strong>badarg</strong></dt><dd>If the process or port is already registered (already has a name).</dd><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">RegName</span></strong> is the atom <strong>undefined</strong>.</dd></dl><h4>registered/0</h4><p>All registered names.</p><p>Returns a list of names that have been registered using
<a href="#register/2">register/2</a>, for
example:</p><pre>
&gt; <span class="input">registered().</span>
[code_server, file_server, init, user, my_db]</pre><h4>resume_process/1</h4><p>Resume a suspended process.</p><p>Decreases the suspend count on the process identified by
<strong><span class="anno">Suspendee</span></strong>. <strong><span class="anno">Suspendee</span></strong>
is previously to have been suspended through
<a href="#suspend_process/2">suspend_process/2</a> or
<a href="#suspend_process/1">suspend_process/1</a>
by the process calling
<strong>erlang:resume_process(<span class="anno">Suspendee</span>)</strong>. When the
suspend count on <strong><span class="anno">Suspendee</span></strong> reaches zero,
<strong><span class="anno">Suspendee</span></strong> is resumed, that is, its state
is changed from suspended into the state it had before it was
suspended.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for debugging only.</p></div><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Suspendee</span></strong> is not a process identifier. </dd><dt><strong>badarg</strong></dt><dd> If the process calling <strong>erlang:resume_process/1</strong> had not previously increased the suspend count on the process identified by <strong><span class="anno">Suspendee</span></strong>. </dd><dt><strong>badarg</strong></dt><dd> If the process identified by <strong><span class="anno">Suspendee</span></strong> is not alive. </dd></dl><h4>round/1</h4><p>Return an integer by rounding a number.</p><p>Returns an integer by rounding <strong><span class="anno">Number</span></strong>,
for example:</p><pre>
<span class="input">round(5.5).</span>
6</pre><p>Allowed in guard tests.</p><h4>self/0</h4><p>Return pid of the calling process.</p><p>Returns the process identifier of the calling process, for
example:</p><pre>
&gt; <span class="input">self().</span>
&lt;0.26.0&gt;</pre><p>Allowed in guard tests.</p><h4>send/2</h4><p>Send a message.</p><ul><li>dst</li></ul><p>Sends a message and returns <strong><span class="anno">Msg</span></strong>. This
is the same as using the <a href="../doc/reference_manual/expressions#send"> send operator</a>:
<strong><span class="anno">Dest</span> ! <span class="anno">Msg</span></strong>.</p><p><strong><span class="anno">Dest</span></strong> can be a remote or local process identifier,
a (local) port, a locally registered name, or a tuple
<strong>{<span class="anno">RegName</span>, <span class="anno">Node</span>}</strong>
for a registered name at another node.</p><p>The function fails with a <strong>badarg</strong> run-time error if
<strong><span class="anno">Dest</span></strong> is an atom name, but this name is not
registered. This is the only case when <strong>send</strong> fails for an
unreachable destination <strong><span class="anno">Dest</span></strong> (of correct type).</p><h4>send/3</h4><p>Send a message conditionally.</p><ul><li>dst</li></ul><p>Either sends a message and returns <strong>ok</strong>, or does not send
the message but returns something else (see below).
Otherwise the same as
<a href="#send/2">send/2</a>.
For more detailed explanation and warnings, see
<a href="#send_nosuspend/2">send_nosuspend/2</a>.</p><p>Options:</p><dl><dt><strong>nosuspend</strong></dt><dd>If the sender would have to be suspended to do the send, <strong>nosuspend</strong> is returned instead. </dd><dt><strong>noconnect</strong></dt><dd> If the destination node would have to be auto-connected to do the send, <strong>noconnect</strong> is returned instead. </dd></dl><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>As with <strong>erlang:send_nosuspend/2,3</strong>: use with extreme
care.</p></div><h4>send_after/3</h4><p>Start a timer.</p><p>Starts a timer. The same as calling
<a href="#send_after/4">send_after/4</a>.</p><h4>send_after/4</h4><p>Start a timer.</p><p>Starts a timer. When the timer expires, the message
<strong><span class="anno">Msg</span></strong> is sent to the process
identified by <strong><span class="anno">Dest</span></strong>. Apart from
the format of the time-out message, this function works exactly as
<a href="#start_timer/4">start_timer/4</a>.</p><h4>send_nosuspend/2</h4><p>Try to send a message without ever blocking.</p><ul><li>dst</li></ul><p>The same as
<a href="#send/3">send/3</a>,
but returns <strong>true</strong> if
the message was sent and <strong>false</strong> if the message was not
sent because the sender would have had to be suspended.</p><p>This function is intended for send operations to an
unreliable remote node without ever blocking the sending
(Erlang) process. If the connection to the remote node
(usually not a real Erlang node, but a node written in C or
Java) is overloaded, this function <em>does not send the message</em>
and returns <strong>false</strong>.</p><p>The same occurs if <strong><span class="anno">Dest</span></strong> refers to a local port
that is busy. For all other destinations (allowed for the ordinary
send operator <strong>'!'</strong>), this function sends the message and
returns <strong>true</strong>.</p><p>This function is only to be used in rare circumstances
where a process communicates with Erlang nodes that can
disappear without any trace, causing the TCP buffers and
the drivers queue to be over-full before the node is
shut down (because of tick time-outs) by <strong>net_kernel</strong>.
The normal reaction to take when this occurs is some kind of
premature shutdown of the other node.</p><p>Notice that ignoring the return value from this function would
result in an <em>unreliable</em> message passing, which is
contradictory to the Erlang programming model. The message is
<em>not</em> sent if this function returns <strong>false</strong>.</p><p>In many systems, transient states of
overloaded queues are normal. Although this function
returns <strong>false</strong> does not mean that the other
node is guaranteed to be non-responsive, it could be a
temporary overload. Also, a return value of <strong>true</strong> does
only mean that the message can be sent on the (TCP) channel
without blocking; the message is not guaranteed to
arrive at the remote node. For a disconnected
non-responsive node, the return value is <strong>true</strong> (mimics
the behavior of operator <strong>!</strong>). The expected
behavior and the actions to take when the function
returns <strong>false</strong> are application- and hardware-specific.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Use with extreme care.</p></div><h4>send_nosuspend/3</h4><p>Try to send a message without ever blocking.</p><ul><li>dst</li></ul><p>The same as
<a href="#send/3">send/3</a>,
but with a Boolean return value.</p><p>This function behaves like
<a href="#send_nosuspend/2">send_nosuspend/2</a>,
but takes a third parameter, a list of options.
The only option is <strong>noconnect</strong>, which
makes the function return <strong>false</strong> if
the remote node is not currently reachable by the local
node. The normal behavior is to try to connect to the node,
which can stall the process during a short period. The use of
option <strong>noconnect</strong> makes it possible to be
sure not to get the slightest delay when
sending to a remote process. This is especially useful when
communicating with nodes that expect to always be
the connecting part (that is, nodes written in C or Java).</p><p>Whenever the function returns <strong>false</strong> (either when a
suspend would occur or when <strong>noconnect</strong> was specified and
the node was not already connected), the message is guaranteed
<em>not</em> to have been sent.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Use with extreme care.</p></div><h4>set_cookie/2</h4><p>Set the magic cookie of a node.</p><p>Sets the magic cookie of <strong><span class="anno">Node</span></strong> to the atom
<strong><span class="anno">Cookie</span></strong>. If <strong><span class="anno">Node</span></strong> is the
local node, the function
also sets the cookie of all other unknown nodes to
<strong><span class="anno">Cookie</span></strong> (see section
<a href="./distributed"> Distributed Erlang</a>
in the Erlang Reference Manual in System Documentation).</p><p>Failure: <strong>function_clause</strong> if the local node is not
alive.</p><h4>setelement/3</h4><p>Set the Nth element of a tuple.</p><dl><dt>Index</dt><dd>1..tuple_size(<span class="anno">Tuple1</span></dd></dl><p>Returns a tuple that is a copy of argument
<strong><span class="anno">Tuple1</span></strong>
with the element specified by integer argument
<strong><span class="anno">Index</span></strong>
(the first element is the element with index 1) replaced by
argument <strong><span class="anno">Value</span></strong>, for example:</p><pre>
&gt; <span class="input">setelement(2, {10, green, bottles}, red).</span>
{10,red,bottles}</pre><h4>size/1</h4><p>Size of a tuple or binary.</p><p>Returns the number of elements in a tuple or the number of
bytes in a binary or bitstring, for example:</p><pre>
&gt; <span class="input">size({morni, mulle, bwange}).</span>
3
&gt; <span class="input">size(&lt;&lt;11, 22, 33&gt;&gt;).</span>
3</pre><p>For bitstrings, the number of whole bytes is returned.
That is, if the number of bits
in the bitstring is not divisible by 8, the resulting
number of bytes is rounded <em>down</em>.</p><p>Allowed in guard tests.</p><p>See also
<a href="#tuple_size/1">tuple_size/1</a>,
<a href="#byte_size/1">byte_size/1</a>, and
<a href="#bit_size/1">bit_size/1</a>.</p><h4>spawn/1</h4><p>Create a new process with a fun as entry point.</p><p>Returns the process identifier of a new process started by the
application of <strong><span class="anno">Fun</span></strong> to the empty list
<strong>[]</strong>. Otherwise
works like <a href="#spawn/3">spawn/3</a>.</p><h4>spawn/2</h4><p>Create a new process with a fun as entry point on a specified node.</p><p>Returns the process identifier of a new process started
by the application of <strong><span class="anno">Fun</span></strong> to the
empty list <strong>[]</strong> on <strong><span class="anno">Node</span></strong>. If
<strong><span class="anno">Node</span></strong> does not exist, a useless pid is
returned. Otherwise works like
<a href="#spawn/3">spawn/3</a>.</p><h4>spawn/3</h4><p>Create a new process with a function as entry point.</p><p>Returns the process identifier of a new process started by
the application of <strong><span class="anno">Module</span>:<span class="anno">Function</span></strong>
to <strong><span class="anno">Args</span></strong>.</p><p><strong>error_handler:undefined_function(<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Args</span>)</strong>
is evaluated by the new process if
<strong><span class="anno">Module</span>:<span class="anno">Function</span>/Arity</strong>
does not exist (where <strong>Arity</strong> is the length of
<strong><span class="anno">Args</span></strong>). The error handler
can be redefined (see
<a href="#process_flag/2">process_flag/2</a>).
If <strong>error_handler</strong> is undefined, or the user has
redefined the default <strong>error_handler</strong> and its replacement is
undefined, a failure with reason <strong>undef</strong> occurs.</p><p>Example:</p><pre>
&gt; <span class="input">spawn(speed, regulator, [high_speed, thin_cut]).</span>
&lt;0.13.1&gt;</pre><h4>spawn/4</h4><p>Create a new process with a function as entry point on a specified node.</p><p>Returns the process identifier (pid) of a new process started
by the application
of <strong><span class="anno">Module</span>:<span class="anno">Function</span></strong>
to <strong><span class="anno">Args</span></strong> on <strong><span class="anno">Node</span></strong>. If
<strong><span class="anno">Node</span></strong> does not exist, a useless pid is returned.
Otherwise works like
<a href="#spawn/3">spawn/3</a>.</p><h4>spawn_link/1</h4><p>Create and link to a new process with a fun as entry point. </p><p>Returns the process identifier of a new process started by
the application of <strong><span class="anno">Fun</span></strong> to the empty list
<strong>[]</strong>. A link is created between
the calling process and the new process, atomically.
Otherwise works like
<a href="#spawn/3">spawn/3</a>.</p><h4>spawn_link/2</h4><p>Create and link to a new process with a fun as entry point on a specified node.</p><p>Returns the process identifier (pid) of a new process started
by the application of <strong><span class="anno">Fun</span></strong> to the empty
list <strong>[]</strong> on <strong><span class="anno">Node</span></strong>. A link is
created between the calling process and the new process,
atomically. If <strong><span class="anno">Node</span></strong> does not exist,
a useless pid is returned and an exit signal with
reason <strong>noconnection</strong> is sent to the calling
process. Otherwise works like <a href="#spawn/3">spawn/3</a>.</p><h4>spawn_link/3</h4><p>Create and link to a new process with a function as entry point. </p><p>Returns the process identifier of a new process started by
the application of <strong><span class="anno">Module</span>:<span class="anno">Function</span></strong>
to <strong><span class="anno">Args</span></strong>. A link is created
between the calling process and the new process, atomically.
Otherwise works like
<a href="#spawn/3">spawn/3</a>.</p><h4>spawn_link/4</h4><p>Create and link to a new process with a function as entry point on a specified node.</p><p>Returns the process identifier (pid) of a new process
started by the application
of <strong><span class="anno">Module</span>:<span class="anno">Function</span></strong>
to <strong><span class="anno">Args</span></strong> on <strong><span class="anno">Node</span></strong>. A
link is created between the calling process and the new
process, atomically. If <strong><span class="anno">Node</span></strong> does
not exist, a useless pid is returned and an exit signal with
reason <strong>noconnection</strong> is sent to the calling
process. Otherwise works like <a href="#spawn/3">spawn/3</a>.</p><h4>spawn_monitor/1</h4><p>Create and monitor a new process with a fun as entry point. </p><p>Returns the process identifier of a new process, started by
the application of <strong><span class="anno">Fun</span></strong> to the empty list
<strong>[]</strong>,
and a reference for a monitor created to the new process.
Otherwise works like
<a href="#spawn/3">spawn/3</a>.</p><h4>spawn_monitor/3</h4><p>Create and monitor a new process with a function as entry point. </p><p>A new process is started by the application
of <strong><span class="anno">Module</span>:<span class="anno">Function</span></strong>
to <strong><span class="anno">Args</span></strong>. The process is
monitored at the same time. Returns the process identifier
and a reference for the monitor. Otherwise works like
<a href="#spawn/3">spawn/3</a>.</p><h4>spawn_opt/2</h4><p>Create a new process with a fun as entry point.</p><ul><li>priority_level</li></ul><ul><li>max_heap_size</li></ul><ul><li>message_queue_data</li></ul><ul><li>spawn_opt_option</li></ul><p>Returns the process identifier (pid) of a new process
started by the application of <strong><span class="anno">Fun</span></strong>
to the empty list <strong>[]</strong>. Otherwise works like
<a href="#spawn_opt/4">spawn_opt/4</a>.</p><p>If option <strong>monitor</strong> is specified, the newly created
process is monitored, and both the pid and reference for
the monitor are returned.</p><h4>spawn_opt/3</h4><p>Create a new process with a fun as entry point on a specified node.</p><ul><li>priority_level</li></ul><ul><li>max_heap_size</li></ul><ul><li>message_queue_data</li></ul><ul><li>spawn_opt_option</li></ul><p>Returns the process identifier (pid) of a new process started
by the application of <strong><span class="anno">Fun</span></strong> to the
empty list <strong>[]</strong> on <strong><span class="anno">Node</span></strong>. If
<strong><span class="anno">Node</span></strong> does not exist, a useless pid is
returned. Otherwise works like
<a href="#spawn_opt/4">spawn_opt/4</a>.</p><h4>spawn_opt/4</h4><p>Create a new process with a function as entry point.</p><ul><li>priority_level</li></ul><ul><li>max_heap_size</li></ul><ul><li>message_queue_data</li></ul><ul><li>spawn_opt_option</li></ul><p>Works as
<a href="#spawn/3">spawn/3</a>, except that an
extra option list is specified when creating the process.</p><p>If option <strong>monitor</strong> is specified, the newly created
process is monitored, and both the pid and reference for
the monitor are returned.</p><p>Options:</p><dl><dt><strong>link</strong></dt><dd> <p>Sets a link to the parent process (like
<a href="#spawn_link/3">spawn_link/3</a>
does).</p> </dd><dt><strong>monitor</strong></dt><dd> <p>Monitors the new process (like
<a href="#monitor/2">monitor/2</a> does).</p> </dd><dt><strong>{priority, <span class="anno">Level</span>}</strong></dt><dd> <p>Sets the priority of the new process. Equivalent to
executing <a href="#process_flag_priority">process_flag_priority</a>
in the start function of the new process,
except that the priority is set before the process is
selected for execution for the first time. For more
information on priorities, see
<a href="#process_flag_priority">process_flag_priority</a>.</p> </dd><dt><strong>{fullsweep_after, <span class="anno">Number</span>}</strong></dt><dd> <p>Useful only for performance tuning. Do not use this
option unless you
know that there is problem with execution times or
memory consumption, and ensure
that the option improves matters.</p> <p>The Erlang runtime system uses a generational garbage
collection scheme, using an "old heap" for data that has
survived at least one garbage collection. When there is
no more room on the old heap, a fullsweep garbage
collection is done.</p> <p>Option <strong>fullsweep_after</strong> makes it possible to
specify the maximum number of generational collections
before forcing a fullsweep, even if there is room on
the old heap. Setting the number to zero
disables the general collection algorithm, that is,
all live data is copied at every garbage collection.</p> <p>A few cases when it can be useful to change
<strong>fullsweep_after</strong>:</p> <ul><li><p>If binaries that are no longer used are to be
thrown away as soon as possible. (Set
<strong><span class="anno">Number</span></strong> to zero.)</p> </li><li><p>A process that mostly have short-lived data is
fullsweeped seldom or never, that is, the old heap
contains mostly garbage. To ensure a fullsweep
occasionally, set <strong><span class="anno">Number</span></strong> to a
suitable value, such as 10 or 20.</p> </li><li>In embedded systems with a limited amount of RAM and no virtual memory, you might want to preserve memory by setting <strong><span class="anno">Number</span></strong> to zero. (The value can be set globally, see <a href="#system_flag/2">system_flag/2</a>.) </li></ul> </dd><dt><strong>{min_heap_size, <span class="anno">Size</span>}</strong></dt><dd> <p>Useful only for performance tuning. Do not use this
option unless you know that there is problem with
execution times or memory consumption, and
ensure that the option improves matters.</p> <p>Gives a minimum heap size, in words. Setting this value
higher than the system default can speed up some
processes because less garbage collection is done.
However, setting a too high value can waste memory and
slow down the system because of worse data locality.
Therefore, use this option only for
fine-tuning an application and to measure the execution
time with various <strong><span class="anno">Size</span></strong> values.</p> </dd><dt><strong>{min_bin_vheap_size, <span class="anno">VSize</span>}</strong></dt><dd> <p>Useful only for performance tuning. Do not use this
option unless you know that there is problem with
execution times or memory consumption, and
ensure that the option improves matters.</p> <p>Gives a minimum binary virtual heap size, in words.
Setting this value
higher than the system default can speed up some
processes because less garbage collection is done.
However, setting a too high value can waste memory.
Therefore, use this option only for
fine-tuning an application and to measure the execution
time with various <strong><span class="anno">VSize</span></strong> values.</p> </dd><dt><strong>{max_heap_size, <span class="anno">Size</span>}</strong></dt><dd> <p>Sets the <strong>max_heap_size</strong> process flag. The default
<strong>max_heap_size</strong> is determined by command-line argument
<a href="./erl#+hmax">erl#+hmax</a>
in <strong>erl(1)</strong>. For more information, see the
documentation of <a href="#process_flag_max_heap_size">process_flag_max_heap_size</a>.
</p> </dd><dt><strong>{message_queue_data, <span class="anno">MQD</span>}</strong></dt><dd> <p>Sets the state of the <strong>message_queue_data</strong> process
flag. <strong><span class="anno">MQD</span></strong> is to be either <strong>off_heap</strong>
or <strong>on_heap</strong>. The default
<strong>message_queue_data</strong> process flag is determined by
command-line argument <a href="./erl#+hmqd">erl#+hmqd</a> in <strong>erl(1)</strong>.
For more information, see the documentation of
<a href="#process_flag_message_queue_data">process_flag_message_queue_data</a>.</p> </dd></dl><h4>spawn_opt/5</h4><p>Create a new process with a function as entry point on a specified node.</p><ul><li>priority_level</li></ul><ul><li>max_heap_size</li></ul><ul><li>message_queue_data</li></ul><ul><li>spawn_opt_option</li></ul><p>Returns the process identifier (pid) of a new process started
by the application
of <strong><span class="anno">Module</span>:<span class="anno">Function</span></strong> to
<strong><span class="anno">Args</span></strong> on <strong><span class="anno">Node</span></strong>. If
<strong><span class="anno">Node</span></strong> does not exist, a useless pid is returned.
Otherwise works like
<a href="#spawn_opt/4">spawn_opt/4</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Option <strong>monitor</strong> is not supported by
<strong>spawn_opt/5</strong>.</p></div><h4>split_binary/2</h4><p>Split a binary into two.</p><dl><dt>Pos</dt><dd>0..byte_size(Bin)</dd></dl><p>Returns a tuple containing the binaries that are the result
of splitting <strong><span class="anno">Bin</span></strong> into two parts at
position <strong><span class="anno">Pos</span></strong>.
This is not a destructive operation. After the operation,
there are three binaries altogether. Example:</p><pre>
&gt; <span class="input">B = list_to_binary("0123456789").</span>
&lt;&lt;"0123456789"&gt;&gt;
&gt; <span class="input">byte_size(B).</span>
10
&gt; <span class="input">{B1, B2} = split_binary(B,3).</span>
{&lt;&lt;"012"&gt;&gt;,&lt;&lt;"3456789"&gt;&gt;}
&gt; <span class="input">byte_size(B1).</span>
3
&gt; <span class="input">byte_size(B2).</span>
7</pre><h4>start_timer/3</h4><p>Start a timer.</p><p>Starts a timer. The same as calling
<a href="#start_timer/4">start_timer/4</a>.</p><h4>start_timer/4</h4><p>Start a timer.</p><p>Starts a timer. When the timer expires, the message
<strong>{timeout, <span class="anno">TimerRef</span>, <span class="anno">Msg</span>}</strong>
is sent to the process identified by <strong><span class="anno">Dest</span></strong>.</p><p><strong><span class="anno">Option</span></strong>s:</p><dl><dt><strong>{abs, false}</strong></dt><dd> <p>This is the default. It means the
<strong><span class="anno">Time</span></strong> value is interpreted
as a time in milliseconds <em>relative</em> current
<a href="./time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a>.</p> </dd><dt><strong>{abs, true}</strong></dt><dd> <p>Absolute <strong><span class="anno">Time</span></strong> value. The
<strong><span class="anno">Time</span></strong> value is interpreted as an
absolute Erlang monotonic time in milliseconds.</p> </dd></dl><p>More <strong><span class="anno">Option</span></strong>s can be added in the future.</p><p>The absolute point in time, the timer is set to expire on,
must be in the interval
<strong>[</strong><a href="#system_info_start_time">system_info_start_time</a><strong>, </strong><a href="#system_info_end_time">system_info_end_time</a><strong>]</strong>.
If a relative time is specified, the <strong><span class="anno">Time</span></strong>
value is not allowed to be negative.</p><p>If <strong><span class="anno">Dest</span></strong> is a <strong>pid()</strong>, it must
be a <strong>pid()</strong> of a process created on the current
runtime system instance. This process has either terminated
or not. If <strong><span class="anno">Dest</span></strong> is an
<strong>atom()</strong>, it is interpreted as the name of a
locally registered process. The process referred to by the
name is looked up at the time of timer expiration. No error
is returned if the name does not refer to a process.</p><p>If <strong><span class="anno">Dest</span></strong> is a <strong>pid()</strong>, the timer is
automatically canceled if the process referred to by the
<strong>pid()</strong> is not alive, or if the process exits. This
feature was introduced in ERTS 5.4.11. Notice that
timers are not automatically canceled when
<strong><span class="anno">Dest</span></strong> is an <strong>atom()</strong>.</p><p>See also
<a href="#send_after/4">send_after/4</a>,
<a href="#cancel_timer/2">cancel_timer/2</a>, and
<a href="#read_timer/2">read_timer/2</a>.</p><p>Failure: <strong>badarg</strong> if the arguments do not satisfy
the requirements specified here.</p><h4>statistics/1</h4><p>Information about active processes and ports.</p><p>Returns the same as
<a href="#statistics_active_tasks_all">statistics_active_tasks_all</a>
with the exception that no information about the dirty
IO run queue and its associated schedulers is part of
the result. That is, only tasks that are expected to be
CPU bound are part of the result.</p><h4>statistics/1</h4><p>Information about active processes and ports.</p><p>Returns a list where each element represents the amount
of active processes and ports on each run queue and its
associated schedulers. That is, the number of processes and
ports that are ready to run, or are currently running.
Values for normal run queues and their associated schedulers
are located first in the resulting list. The first element
corresponds to scheduler number 1 and so on. If support for
dirty schedulers exist, an element with the value for the
dirty CPU run queue and its associated dirty CPU schedulers
follow and then as last element the value for the the dirty
IO run queue and its associated dirty IO schedulers follow.
The information is <em>not</em> gathered atomically. That is,
the result is not necessarily a consistent snapshot of the
state, but instead quite efficiently gathered.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Each normal scheduler has one run queue that it
manages. If dirty schedulers schedulers are supported, all
dirty CPU schedulers share one run queue, and all dirty IO
schedulers share one run queue. That is, we have multiple
normal run queues, one dirty CPU run queue and one dirty
IO run queue. Work can <em>not</em> migrate between the
different types of run queues. Only work in normal run
queues can migrate to other normal run queues. This has
to be taken into account when evaluating the result.</p></div><p>See also
<a href="#statistics_total_active_tasks">statistics_total_active_tasks</a>,
<a href="#statistics_run_queue_lengths">statistics_run_queue_lengths</a>,
<a href="#statistics_run_queue_lengths_all">statistics_run_queue_lengths_all</a>,
<a href="#statistics_total_run_queue_lengths">statistics_total_run_queue_lengths</a>, and
<a href="#statistics_total_run_queue_lengths_all">statistics_total_run_queue_lengths_all</a>.</p><h4>statistics/1</h4><p>Information about context switches.</p><p>Returns the total number of context switches since the
system started.</p><h4>statistics/1</h4><p>Information about exact reductions.</p><p>Returns the number of exact reductions.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><strong>statistics(exact_reductions)</strong> is
a more expensive operation than
<a href="#statistics_reductions"> statistics(reductions)</a>.</p></div><h4>statistics/1</h4><p>Information about garbage collection.</p><p>Returns information about garbage collection, for example:</p><pre>
&gt; <span class="input">statistics(garbage_collection).</span>
{85,23961,0}</pre><p>This information can be invalid for some implementations.</p><h4>statistics/1</h4><p>Information about I/O.</p><p>Returns <strong><span class="anno">Input</span></strong>,
which is the total number of bytes
received through ports, and <strong><span class="anno">Output</span></strong>,
which is the total number of bytes output to ports.</p><h4>statistics/1</h4><p>Information about microstate accounting.</p><p>Microstate accounting can be used to measure how much time the Erlang
runtime system spends doing various tasks. It is designed to be as
lightweight as possible, but some overhead exists when this
is enabled. Microstate accounting is meant to be a profiling tool
to help finding performance bottlenecks.
To <strong>start</strong>/<strong>stop</strong>/<strong>reset</strong> microstate accounting, use
system flag <a href="#system_flag_microstate_accounting">system_flag_microstate_accounting</a>.</p><p><strong>statistics(microstate_accounting)</strong> returns a list of maps
representing some of the OS threads within ERTS. Each map
contains <strong>type</strong> and <strong>id</strong> fields that can be used to
identify what
thread it is, and also a counters field that contains data about how
much time has been spent in the various states.</p><p>Example:</p><pre>
&gt; <span class="input">erlang:statistics(microstate_accounting).</span>
[#{counters =&gt; #{aux =&gt; 1899182914,
                 check_io =&gt; 2605863602,
                 emulator =&gt; 45731880463,
                 gc =&gt; 1512206910,
                 other =&gt; 5421338456,
                 port =&gt; 221631,
                 sleep =&gt; 5150294100},
   id =&gt; 1,
   type =&gt; scheduler}|...]</pre><p>The time unit is the same as returned by
<a href="../kernel/os#perf_counter/0">kernel/os#perf_counter/0</a>.
So, to convert it to milliseconds, you can do something like this:</p><pre>
lists:map(
  fun(#{ counters := Cnt } = M) -&gt;
          MsCnt = maps:map(fun(_K, PerfCount) -&gt;
                                   erlang:convert_time_unit(PerfCount, perf_counter, 1000)
                           end, Cnt),
         M#{ counters := MsCnt }
  end, erlang:statistics(microstate_accounting)).</pre><p>Notice that these values are not guaranteed to be
the exact time spent in each state. This is because of various
optimisation done to keep the overhead as small as possible.</p><p><strong><span class="anno">MSAcc_Thread_Type</span></strong>s:</p><dl><dt><strong>scheduler</strong></dt><dd>The main execution threads that do most of the work. See <a href="../erts/erl#+S">erl +S</a> for more details.</dd><dt><strong>dirty_cpu_scheduler</strong></dt><dd>The threads for long running cpu intensive work. See <a href="../erts/erl#+SDcpu">erl +SDcpu</a> for more details.</dd><dt><strong>dirty_io_scheduler</strong></dt><dd>The threads for long running I/O work. See <a href="../erts/erl#+SDio">erl +SDio</a> for more details.</dd><dt><strong>async</strong></dt><dd>Async threads are used by various linked-in drivers (mainly the file drivers) do offload non-CPU intensive work. See <a href="../erts/erl#async_thread_pool_size">erl +A</a> for more details.</dd><dt><strong>aux</strong></dt><dd>Takes care of any work that is not specifically assigned to a scheduler.</dd><dt><strong>poll</strong></dt><dd>Does the IO polling for the emulator. See <a href="../erts/erl#+IOt">erl +IOt</a> for more details.</dd></dl><p>The following <strong><span class="anno">MSAcc_Thread_State</span></strong>s are available.
All states are exclusive, meaning that a thread cannot be in two
states at once. So, if you add the numbers of all counters in a
thread, you get the total runtime for that thread.</p><dl><dt><strong>aux</strong></dt><dd>Time spent handling auxiliary jobs.</dd><dt><strong>check_io</strong></dt><dd>Time spent checking for new I/O events.</dd><dt><strong>emulator</strong></dt><dd>Time spent executing Erlang processes.</dd><dt><strong>gc</strong></dt><dd>Time spent doing garbage collection. When extra states are enabled this is the time spent doing non-fullsweep garbage collections.</dd><dt><strong>other</strong></dt><dd>Time spent doing unaccounted things.</dd><dt><strong>port</strong></dt><dd>Time spent executing ports.</dd><dt><strong>sleep</strong></dt><dd>Time spent sleeping.</dd></dl><p>More fine-grained <strong><span class="anno">MSAcc_Thread_State</span></strong>s can
be added through configure (such as
<strong>./configure --with-microstate-accounting=extra</strong>).
Enabling these states causes performance degradation when
microstate accounting is turned off and increases the overhead when
it is turned on.</p><dl><dt><strong>alloc</strong></dt><dd>Time spent managing memory. Without extra states this time is spread out over all other states.</dd><dt><strong>bif</strong></dt><dd>Time spent in BIFs. Without extra states this time is part of the <strong>emulator</strong> state.</dd><dt><strong>busy_wait</strong></dt><dd>Time spent busy waiting. This is also the state where a scheduler no longer reports that it is active when using <a href="#statistics_scheduler_wall_time">statistics_scheduler_wall_time</a>. So, if you add all other states but this and sleep, and then divide that by all time in the thread, you should get something very similar to the <strong>scheduler_wall_time</strong> fraction. Without extra states this time is part of the <strong>other</strong> state.</dd><dt><strong>ets</strong></dt><dd>Time spent executing ETS BIFs. Without extra states this time is part of the <strong>emulator</strong> state.</dd><dt><strong>gc_full</strong></dt><dd>Time spent doing fullsweep garbage collection. Without extra states this time is part of the <strong>gc</strong> state.</dd><dt><strong>nif</strong></dt><dd>Time spent in NIFs. Without extra states this time is part of the <strong>emulator</strong> state.</dd><dt><strong>send</strong></dt><dd>Time spent sending messages (processes only). Without extra states this time is part of the <strong>emulator</strong> state.</dd><dt><strong>timers</strong></dt><dd>Time spent managing timers. Without extra states this time is part of the <strong>other</strong> state.</dd></dl><p>The utility module
<a href="./msacc">runtime_tools/msacc</a>
can be used to more easily analyse these statistics.</p><p>Returns <strong>undefined</strong> if system flag
<a href="#system_flag_microstate_accounting">system_flag_microstate_accounting</a> is turned off.</p><p>The list of thread information is unsorted and can appear in
different order between calls.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The threads and states are subject to change without any
prior notice.</p></div><h4>statistics/1</h4><p>Information about reductions.</p><p>Returns information about reductions, for example:</p><pre>
&gt; <span class="input">statistics(reductions).</span>
{2046,11}</pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from ERTS 5.5 (Erlang/OTP R11B),
this value does not include reductions performed in current
time slices of currently scheduled processes. If an
exact value is wanted, use
<a href="#statistics_exact_reductions">statistics_exact_reductions</a>.</p></div><h4>statistics/1</h4><p>Information about the run-queues.</p><p>Returns the total length of all normal run-queues. That is, the number
of processes and ports that are ready to run on all available
normal run-queues. Dirty run queues are not part of the
result. The information is gathered atomically. That
is, the result is a consistent snapshot of the state, but
this operation is much more expensive compared to
<a href="#statistics_total_run_queue_lengths">statistics_total_run_queue_lengths</a>,
especially when a large amount of schedulers is used.</p><h4>statistics/1</h4><p>Information about the run-queue lengths.</p><p>Returns the same as
<a href="#statistics_run_queue_lengths_all">statistics_run_queue_lengths_all</a>
with the exception that no information about the dirty
IO run queue is part of the result. That is, only
run queues with work that is expected to be CPU bound
is part of the result.</p><h4>statistics/1</h4><p>Information about the run-queue lengths.</p><p>Returns a list where each element represents the amount
of processes and ports ready to run for each run queue.
Values for normal run queues are located first in the
resulting list. The first element corresponds to the
normal run queue of scheduler number 1 and so on. If
support for dirty schedulers exist, values for the dirty
CPU run queue and the dirty IO run queue follow (in that
order) at the end. The information is <em>not</em>
gathered atomically. That is, the result is not
necessarily a consistent snapshot of the state, but
instead quite efficiently gathered.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Each normal scheduler has one run queue that it
manages. If dirty schedulers schedulers are supported, all
dirty CPU schedulers share one run queue, and all dirty IO
schedulers share one run queue. That is, we have multiple
normal run queues, one dirty CPU run queue and one dirty
IO run queue. Work can <em>not</em> migrate between the
different types of run queues. Only work in normal run
queues can migrate to other normal run queues. This has
to be taken into account when evaluating the result.</p></div><p>See also
<a href="#statistics_run_queue_lengths">statistics_run_queue_lengths</a>,
<a href="#statistics_total_run_queue_lengths_all">statistics_total_run_queue_lengths_all</a>,
<a href="#statistics_total_run_queue_lengths">statistics_total_run_queue_lengths</a>,
<a href="#statistics_active_tasks">statistics_active_tasks</a>,
<a href="#statistics_active_tasks_all">statistics_active_tasks_all</a>, and
<a href="#statistics_total_active_tasks">statistics_total_active_tasks</a>,
<a href="#statistics_total_active_tasks_all">statistics_total_active_tasks_all</a>.</p><h4>statistics/1</h4><p>Information about runtime.</p><p>Returns information about runtime, in milliseconds.</p><p>This is the sum of the runtime for all threads
in the Erlang runtime system and can therefore be greater
than the wall clock time.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This value might wrap due to limitations in the
underlying functionality provided by the operating system
that is used.</p></div><p>Example:</p><pre>
&gt; <span class="input">statistics(runtime).</span>
{1690,1620}</pre><h4>statistics/1</h4><p>Information about each schedulers work time.</p><p>Returns a list of tuples with
<strong>{<span class="anno">SchedulerId</span>, <span class="anno">ActiveTime</span>, <span class="anno">TotalTime</span>}</strong>, where
<strong><span class="anno">SchedulerId</span></strong> is an integer ID of the scheduler,
<strong><span class="anno">ActiveTime</span></strong> is
the duration the scheduler has been busy, and
<strong><span class="anno">TotalTime</span></strong> is the total time duration since
<a href="#system_flag_scheduler_wall_time">system_flag_scheduler_wall_time</a>
activation for the specific scheduler. Note that
activation time can differ significantly between
schedulers. Currently dirty schedulers are activated
at system start while normal schedulers are activated
some time after the <strong>scheduler_wall_time</strong>
functionality is enabled. The time unit is undefined
and can be subject to change between releases, OSs,
and system restarts. <strong>scheduler_wall_time</strong> is only
to be used to calculate relative values for scheduler
utilization. <strong><span class="anno">ActiveTime</span></strong> can never
exceed <strong><span class="anno">TotalTime</span></strong>.</p><p>The definition of a busy scheduler is when it is not idle
and is not scheduling (selecting) a process or port,
that is:</p><ul><li>Executing process code</li><li>Executing linked-in driver or NIF code</li><li>Executing BIFs, or any other runtime handling</li><li>Garbage collecting</li><li>Handling any other memory management</li></ul><p>Notice that a scheduler can also be busy even if the
OS has scheduled out the scheduler thread.</p><p>Returns <strong>undefined</strong> if system flag
<a href="#system_flag_scheduler_wall_time">system_flag_scheduler_wall_time</a> is turned off.</p><p>The list of scheduler information is unsorted and can
appear in different order between calls.</p><p>As of ERTS version 9.0, also dirty CPU schedulers will
be included in the result. That is, all scheduler threads
that are expected to handle CPU bound work. If you also
want information about dirty I/O schedulers, use
<a href="#statistics_scheduler_wall_time_all">statistics_scheduler_wall_time_all</a>
instead.</p><p>Normal schedulers will have scheduler identifiers in
the range <strong>1 =&lt; <span class="anno">SchedulerId</span> =&lt; </strong><a href="#system_info_schedulers">system_info_schedulers</a>.
Dirty CPU schedulers will have scheduler identifiers in
the range <strong>erlang:system_info(schedulers) &lt; <span class="anno">SchedulerId</span> =&lt; erlang:system_info(schedulers) + </strong><a href="#system_info_dirty_cpu_schedulers">system_info_dirty_cpu_schedulers</a>.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The different types of schedulers handle
specific types of jobs. Every job is assigned to a specific
scheduler type. Jobs can migrate between different schedulers
of the same type, but never between schedulers of different
types. This fact has to be taken under consideration when
evaluating the result returned.</p></div><p>Using <strong>scheduler_wall_time</strong> to calculate
scheduler utilization:</p><pre>
&gt; <span class="input">erlang:system_flag(scheduler_wall_time, true).</span>
false
&gt; <span class="input">Ts0 = lists:sort(erlang:statistics(scheduler_wall_time)), ok.</span>
ok</pre><p>Some time later the user takes another snapshot and calculates
scheduler utilization per scheduler, for example:</p><pre>
&gt; <span class="input">Ts1 = lists:sort(erlang:statistics(scheduler_wall_time)), ok.</span>
ok
&gt; <span class="input">lists:map(fun({{I, A0, T0}, {I, A1, T1}}) -&gt; {I, (A1 - A0)/(T1 - T0)} end, lists:zip(Ts0,Ts1)).</span>
[{1,0.9743474730177548},
 {2,0.9744843782751444},
 {3,0.9995902361669045},
 {4,0.9738012596572161},
 {5,0.9717956667018103},
 {6,0.9739235846420741},
 {7,0.973237033077876},
 {8,0.9741297293248656}]</pre><p>Using the same snapshots to calculate a total
scheduler utilization:</p><pre>
&gt; <span class="input">{A, T} = lists:foldl(fun({{_, A0, T0}, {_, A1, T1}}, {Ai,Ti}) -&gt; {Ai + (A1 - A0), Ti + (T1 - T0)} end, {0, 0}, lists:zip(Ts0,Ts1)), TotalSchedulerUtilization = A/T.</span>
0.9769136803764825</pre><p>Total scheduler utilization will equal <strong>1.0</strong> when
all schedulers have been active all the time between the
two measurements.</p><p>Another (probably more) useful value is to calculate
total scheduler utilization weighted against maximum amount
of available CPU time:</p><pre>
&gt; <span class="input">WeightedSchedulerUtilization = (TotalSchedulerUtilization * (erlang:system_info(schedulers) + erlang:system_info(dirty_cpu_schedulers))) / erlang:system_info(logical_processors_available).</span>
0.9769136803764825</pre><p>This weighted scheduler utilization will reach <strong>1.0</strong>
when schedulers are active the same amount of time as
maximum available CPU time. If more schedulers exist
than available logical processors, this value may
be greater than <strong>1.0</strong>.</p><p>As of ERTS version 9.0, the Erlang runtime system
will as default have more schedulers than logical processors.
This due to the dirty schedulers.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><strong>scheduler_wall_time</strong> is by default disabled. To
enable it, use
<strong>erlang:system_flag(scheduler_wall_time, true)</strong>.</p></div><h4>statistics/1</h4><p>Information about each schedulers work time.</p><p>The same as
<a href="#statistics_scheduler_wall_time">statistics_scheduler_wall_time</a>,
except that it also include information about all dirty I/O
schedulers.</p><p>Dirty IO schedulers will have scheduler identifiers in
the range
<a href="#system_info_schedulers">system_info_schedulers</a><strong> + </strong><a href="#system_info_dirty_cpu_schedulers">system_info_dirty_cpu_schedulers</a><strong> &lt; <span class="anno">SchedulerId</span> =&lt; erlang:system_info(schedulers) + erlang:system_info(dirty_cpu_schedulers) + </strong><a href="#system_info_dirty_io_schedulers">system_info_dirty_io_schedulers</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that work executing on dirty I/O schedulers
are expected to mainly wait for I/O. That is, when you
get high scheduler utilization on dirty I/O schedulers,
CPU utilization is <em>not</em> expected to be high due to
this work.</p></div><h4>statistics/1</h4><p>Information about active processes and ports.</p><p>The same as calling
<strong>lists:sum(</strong><a href="#statistics_active_tasks">statistics_active_tasks</a><strong>)</strong>,
but more efficient.</p><h4>statistics/1</h4><p>Information about active processes and ports.</p><p>The same as calling
<strong>lists:sum(</strong><a href="#statistics_active_tasks_all">statistics_active_tasks_all</a><strong>)</strong>,
but more efficient.</p><h4>statistics/1</h4><p>Information about the run-queue lengths.</p><p>The same as calling
<strong>lists:sum(</strong><a href="#statistics_run_queue_lengths">statistics_run_queue_lengths</a><strong>)</strong>,
but more efficient.</p><h4>statistics/1</h4><p>Information about the run-queue lengths.</p><p>The same as calling
<strong>lists:sum(</strong><a href="#statistics_run_queue_lengths_all">statistics_run_queue_lengths_all</a><strong>)</strong>,
but more efficient.</p><h4>statistics/1</h4><p>Information about wall clock.</p><p>Returns information about wall clock. <strong>wall_clock</strong> can
be used in the same manner as
<strong>runtime</strong>, except that real time is measured as
opposed to runtime or CPU time.</p><h4>suspend_process/1</h4><p>Suspend a process.</p><p>Suspends the process identified by
<strong><span class="anno">Suspendee</span></strong>. The same as calling
<a href="#suspend_process/2">suspend_process/2</a>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for debugging only.</p></div><h4>suspend_process/2</h4><p>Suspend a process.</p><p>Increases the suspend count on the process identified by
<strong><span class="anno">Suspendee</span></strong> and puts it in the suspended
state if it is not
already in that state. A suspended process is not
scheduled for execution until the process has been resumed.</p><p>A process can be suspended by multiple processes and can
be suspended multiple times by a single process. A suspended
process does not leave the suspended state until its suspend 
count reaches zero. The suspend count of
<strong><span class="anno">Suspendee</span></strong> is decreased when
<a href="#resume_process/1">resume_process/1</a>
is called by the same process that called
<strong>erlang:suspend_process(<span class="anno">Suspendee</span>)</strong>.
All increased suspend
counts on other processes acquired by a process are automatically
decreased when the process terminates.</p><p>Options (<strong><span class="anno">Opt</span></strong>s):</p><dl><dt><strong>asynchronous</strong></dt><dd> <p>A suspend request is sent to the process identified by
<strong><span class="anno">Suspendee</span></strong>. <strong><span class="anno">Suspendee</span></strong>
eventually suspends
unless it is resumed before it could suspend. The caller
of <strong>erlang:suspend_process/2</strong> returns immediately,
regardless of whether <strong><span class="anno">Suspendee</span></strong> has
suspended yet or not. The point in time when
<strong><span class="anno">Suspendee</span></strong> suspends cannot be deduced
from other events in the system. It is only guaranteed that
<strong><span class="anno">Suspendee</span></strong> <em>eventually</em> suspends
(unless it
is resumed). If no <strong>asynchronous</strong> options has
been passed, the caller of <strong>erlang:suspend_process/2</strong> is
blocked until <strong><span class="anno">Suspendee</span></strong> has suspended.</p> </dd><dt><strong>{asynchronous, ReplyTag}</strong></dt><dd> <p>A suspend request is sent to the process identified by
<strong><span class="anno">Suspendee</span></strong>. When the suspend request
has been processed, a reply message is sent to the caller
of this function. The reply is on the form <strong>{ReplyTag, State}</strong> where <strong>State</strong> is either:</p> <dl><dt><strong>exited</strong></dt><dd> <p>
<strong><span class="anno">Suspendee</span></strong> has exited.
</p> </dd><dt><strong>suspended</strong></dt><dd> <p>
<strong><span class="anno">Suspendee</span></strong> is now suspended.
</p> </dd><dt><strong>not_suspended</strong></dt><dd> <p>
<strong><span class="anno">Suspendee</span></strong> is not suspended.
This can only happen when the process that
issued this request, have called
<strong>resume_process(<span class="anno">Suspendee</span>)</strong>
before getting the reply.
</p> </dd></dl> <p>
Appart from the reply message, the <strong>{asynchronous, ReplyTag}</strong> option behaves exactly the same as the
<strong>asynchronous</strong> option without reply tag.
</p> </dd><dt><strong>unless_suspending</strong></dt><dd> <p>The process identified by <strong><span class="anno">Suspendee</span></strong> is
suspended unless the calling process already is suspending
<strong><span class="anno">Suspendee</span></strong>.
If <strong>unless_suspending</strong> is combined
with option <strong>asynchronous</strong>, a suspend request is
sent unless the calling process already is suspending
<strong><span class="anno">Suspendee</span></strong> or if a suspend request
already has been sent and is in transit. If the calling
process already is suspending <strong><span class="anno">Suspendee</span></strong>,
or if combined with option <strong>asynchronous</strong>
and a send request already is in transit,
<strong>false</strong> is returned and the suspend count on
<strong><span class="anno">Suspendee</span></strong> remains unchanged.</p> </dd></dl><p>If the suspend count on the process identified by
<strong><span class="anno">Suspendee</span></strong> is increased, <strong>true</strong>
is returned, otherwise <strong>false</strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for debugging only.</p></div><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>You can easily create deadlocks if processes suspends
each other (directly or in circles). In ERTS versions prior
to ERTS version 10.0, the runtime system prevented such
deadlocks, but this prevention has now been removed due
to performance reasons.</p></div><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Suspendee</span></strong> is not a process identifier. </dd><dt><strong>badarg</strong></dt><dd> If the process identified by <strong><span class="anno">Suspendee</span></strong> is the same process as the process calling <strong>erlang:suspend_process/2</strong>. </dd><dt><strong>badarg</strong></dt><dd> If the process identified by <strong><span class="anno">Suspendee</span></strong> is not alive. </dd><dt><strong>badarg</strong></dt><dd> If the process identified by <strong><span class="anno">Suspendee</span></strong> resides on another node. </dd><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">OptList</span></strong> is not a proper list of valid <strong><span class="anno">Opt</span></strong>s. </dd><dt><strong>system_limit</strong></dt><dd> If the process identified by <strong><span class="anno">Suspendee</span></strong> has been suspended more times by the calling process than can be represented by the currently used internal data structures. The system limit is &gt; 2,000,000,000 suspends and will never be lower. </dd></dl><h4>system_flag/2</h4><p>Set system flag <strong>backtrace_depth</strong>.</p><p>Sets the maximum depth of call stack back-traces in the
exit reason element of <strong>'EXIT'</strong> tuples. The flag
also limits the stacktrace depth returned by <strong>process_info</strong>
item <strong>current_stacktrace.</strong></p><p>Returns the old value of the flag.</p><h4>system_flag/2</h4><p>Set system flag <strong>cpu_topology</strong>.</p><ul><li>cpu_topology</li></ul><ul><li>level_entry</li></ul><ul><li>level_tag</li></ul><ul><li>sub_level</li></ul><ul><li>info_list</li></ul><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>
<em>This argument is deprecated.</em>
Instead of using this argument, use command-line argument
<a href="../erts/erl#+sct">erts/erl#+sct</a> in
<strong>erl(1)</strong>.</p><p>When this argument is removed, a final CPU topology
to use is determined at emulator boot time.</p></div><p>Sets the user-defined <strong><span class="anno">CpuTopology</span></strong>.
The user-defined
CPU topology overrides any automatically detected
CPU topology. By passing <strong>undefined</strong> as
<strong><span class="anno">CpuTopology</span></strong>,
the system reverts to the CPU topology automatically
detected. The returned value equals the value returned
from <strong>erlang:system_info(cpu_topology)</strong> before the
change was made.</p><p>Returns the old value of the flag.</p><p>The CPU topology is used when binding schedulers to logical
processors. If schedulers are already bound when the CPU
topology is changed, the schedulers are sent a request
to rebind according to the new CPU topology.</p><p>The user-defined CPU topology can also be set by passing
command-line argument
<a href="../erts/erl#+sct">erts/erl#+sct</a> to
<strong>erl(1)</strong>.</p><p>For information on type <strong><span class="anno">CpuTopology</span></strong>
and more, see
<a href="#system_info_cpu_topology">system_info_cpu_topology</a>
as well as command-line flags
<a href="../erts/erl#+sct">erts/erl#+sct</a> and
<a href="../erts/erl#+sbt">erts/erl#+sbt</a> in
<strong>erl(1)</strong>.</p><h4>system_flag/2</h4><p>Set system_flag_dirty_cpu_schedulers_online.</p><p>
Sets the number of dirty CPU schedulers online. Range is
<strong>1 &lt;= DirtyCPUSchedulersOnline &lt;= N</strong>, where <strong>N</strong>
is the smallest of the return values of
<strong>erlang:system_info(dirty_cpu_schedulers)</strong> and
<strong>erlang:system_info(schedulers_online)</strong>.</p><p>Returns the old value of the flag.</p><p>The number of dirty CPU schedulers online can change if the
number of schedulers online changes. For example, if 12
schedulers and 6 dirty CPU schedulers are online, and
<strong>system_flag/2</strong> is used to set the number of
schedulers online to 6, then the number of dirty CPU
schedulers online is automatically decreased by half as well,
down to 3. Similarly, the number of dirty CPU schedulers
online increases proportionally to increases in the number of
schedulers online.</p><p>For more information, see
<a href="#system_info_dirty_cpu_schedulers">system_info_dirty_cpu_schedulers</a> and
<a href="#system_info_dirty_cpu_schedulers_online">system_info_dirty_cpu_schedulers_online</a>.</p><h4>system_flag/2</h4><p>Set system flag for erts_alloc.</p><p>Sets system flags for
<a href="./erts_alloc">erts/erts_alloc</a>.
<strong><span class="anno">Alloc</span></strong> is the allocator to affect, for example
<strong>binary_alloc</strong>. <strong><span class="anno">F</span></strong> is the flag to change and
<strong><span class="anno">V</span></strong> is the new value.</p><p>Only a subset of all <strong>erts_alloc</strong> flags can be changed
at run time. This subset is currently only the flag
<a href="../erts/erts_alloc#M_sbct">erts/erts_alloc#M_sbct</a>.</p><p>Returns <strong>ok</strong> if the flag was set or <strong>notsup</strong> if not
supported by <strong>erts_alloc</strong>.</p><h4>system_flag/2</h4><p>Set system flag fullsweep_after.</p><p>Sets system flag <strong>fullsweep_after</strong>.
<strong><span class="anno">Number</span></strong> is a non-negative integer indicating
how many times generational garbage collections can be
done without forcing a fullsweep collection. The value
applies to new processes, while processes already running are
not affected.</p><p>Returns the old value of the flag.</p><p>In low-memory systems (especially without virtual
memory), setting the value to <strong>0</strong> can help to conserve
memory.</p><p>This value can also be set through (OS)
environment variable <strong>ERL_FULLSWEEP_AFTER</strong>.</p><h4>system_flag/2</h4><p>Set system flag microstate_accounting.</p><p>
Turns on/off microstate accounting measurements. When passing reset,
all counters are reset to 0.</p><p>For more information see
<a href="#statistics_microstate_accounting">statistics_microstate_accounting</a>.</p><h4>system_flag/2</h4><p>Set system flag min_heap_size.</p><p>Sets the default minimum heap size for processes. The size
is specified in words. The new <strong>min_heap_size</strong> effects
only processes spawned after the change of
<strong>min_heap_size</strong> has been made. <strong>min_heap_size</strong>
can be set for individual processes by using
<a href="#spawn_opt/4">spawn_opt/4</a> or
<a href="#process_flag/2">process_flag/2</a>.</p><p>Returns the old value of the flag.</p><h4>system_flag/2</h4><p>Set system flag min_bin_vheap_size.</p><p>Sets the default minimum binary virtual heap size for
processes. The size is specified in words.
The new <strong>min_bin_vhheap_size</strong> effects only
processes spawned after the change of
<strong>min_bin_vheap_size</strong> has been made.
<strong>min_bin_vheap_size</strong> can be set for individual
processes by using
<a href="#spawn_opt/4">spawn_opt/4</a> or
<a href="#process_flag/2">process_flag/2</a>.</p><p>Returns the old value of the flag.</p><h4>system_flag/2</h4><p>Set system flag max_heap_size.</p><ul><li>max_heap_size</li></ul><p>
Sets the default maximum heap size settings for processes.
The size is specified in words. The new <strong>max_heap_size</strong>
effects only processes spawned efter the change has been made.
<strong>max_heap_size</strong> can be set for individual processes using
<a href="#spawn_opt/4">spawn_opt/4</a> or
<a href="#process_flag_max_heap_size">process_flag_max_heap_size</a>.</p><p>Returns the old value of the flag.</p><h4>system_flag/2</h4><p>Set system flag multi_scheduling.</p><p>
If multi-scheduling is enabled, more than one scheduler
thread is used by the emulator. Multi-scheduling can be
blocked in two different ways. Either all schedulers but
one is blocked, or all <em>normal</em> schedulers but
one is blocked. When only normal schedulers are blocked,
dirty schedulers are free to continue to schedule
processes.</p><p>If <strong><span class="anno">BlockState</span> =:= block</strong>, multi-scheduling is
blocked. That is, one and only one scheduler thread will
execute. If <strong><span class="anno">BlockState</span> =:= unblock</strong> and no one
else blocks multi-scheduling, and this process has
blocked only once, multi-scheduling is unblocked.</p><p>If <strong><span class="anno">BlockState</span> =:= block_normal</strong>, normal
multi-scheduling is blocked. That is, only one normal scheduler
thread will execute, but multiple dirty schedulers can execute.
If <strong><span class="anno">BlockState</span> =:= unblock_normal</strong> and no one
else blocks normal multi-scheduling, and this process has
blocked only once, normal multi-scheduling is unblocked.</p><p>One process can block multi-scheduling and normal
multi-scheduling multiple times. If a process has blocked
multiple times, it must unblock exactly as many times as it
has blocked before it has released its multi-scheduling
block. If a process that has blocked multi-scheduling or normal
multi-scheduling exits, it automatically releases its blocking
of multi-scheduling and normal multi-scheduling.</p><p>The return values are <strong>disabled</strong>, <strong>blocked</strong>,
<strong>blocked_normal</strong>, or <strong>enabled</strong>. The returned value
describes the state just after the call to
<strong>erlang:system_flag(multi_scheduling, <span class="anno">BlockState</span>)</strong>
has been made. For information about the return values, see
<a href="#system_info_multi_scheduling">system_info_multi_scheduling</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Blocking of multi-scheduling and normal multi-scheduling
is normally not needed. If you feel that you need to use these
features, consider it a few more times again. Blocking
multi-scheduling is only to be used as a last resort, as it is
most likely a <em>very inefficient</em> way to solve the problem.</p></div><p>See also
<a href="#system_info_multi_scheduling">system_info_multi_scheduling</a>,
<a href="#system_info_normal_multi_scheduling_blockers">system_info_normal_multi_scheduling_blockers</a>,
<a href="#system_info_multi_scheduling_blockers">system_info_multi_scheduling_blockers</a>, and
<a href="#system_info_schedulers">system_info_schedulers</a>.</p><h4>system_flag/2</h4><p>Set system flag scheduler_bind_type.</p><ul><li>scheduler_bind_type</li></ul><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>
<em>This argument is deprecated.</em>
Instead of using this argument, use command-line argument
<a href="../erts/erl#+sbt">erts/erl#+sbt</a> in
<strong>erl(1)</strong>. When this argument is removed, a final scheduler bind
type to use is determined at emulator boot time.</p></div><p>Controls if and how schedulers are bound to logical
processors.</p><p>When <strong>erlang:system_flag(scheduler_bind_type, <span class="anno">How</span>)</strong>
is called, an asynchronous signal is sent to all schedulers
online, causing them to try to bind or unbind as requested.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If a scheduler fails to bind, this is often silently
ignored, as it is not always possible to verify valid
logical processor identifiers. If an error is reported,
an error event is logged. To verify that the
schedulers have bound as requested, call
<a href="#system_info_scheduler_bindings">system_info_scheduler_bindings</a>.</p></div><p>Schedulers can be bound on newer Linux,
Solaris, FreeBSD, and Windows systems, but more systems will be
supported in future releases.</p><p>In order for the runtime system to be able to bind schedulers,
the CPU topology must be known. If the runtime system fails
to detect the CPU topology automatically, it can be defined.
For more information on how to define the CPU topology, see
command-line flag <a href="../erts/erl#+sct">erts/erl#+sct</a> in <strong>erl(1)</strong>.</p><p>The runtime system does by default <em>not</em> bind schedulers
to logical processors.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If the Erlang runtime system is the only OS
process binding threads to logical processors, this
improves the performance of the runtime system. However,
if other OS processes (for example, another Erlang
runtime system) also bind threads to logical processors,
there can be a performance penalty instead. Sometimes this
performance penalty can be severe. If so, it is recommended
to not bind the schedulers.</p></div><p>Schedulers can be bound in different ways. Argument
<strong><span class="anno">How</span></strong> determines how schedulers are
bound and can be any of the following:</p><dl><dt><strong>unbound</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd><dt><strong>no_spread</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd><dt><strong>thread_spread</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd><dt><strong>processor_spread</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd><dt><strong>spread</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd><dt><strong>no_node_thread_spread</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd><dt><strong>no_node_processor_spread</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd><dt><strong>thread_no_node_processor_spread</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd><dt><strong>default_bind</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd></dl><p>The returned value equals <strong><span class="anno">How</span></strong> before flag
<strong>scheduler_bind_type</strong> was changed.</p><p>Failures:</p><dl><dt><strong>notsup</strong></dt><dd>If binding of schedulers is not supported. </dd><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">How</span></strong> is not one of the documented alternatives. </dd><dt><strong>badarg</strong></dt><dd>If CPU topology information is unavailable. </dd></dl><p>The scheduler bind type can also be set by passing command-line
argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> to <strong>erl(1)</strong>.</p><p>For more information, see
<a href="#system_info_scheduler_bind_type">system_info_scheduler_bind_type</a>,
<a href="#system_info_scheduler_bindings">system_info_scheduler_bindings</a>,
as well as command-line flags
<a href="../erts/erl#+sbt">erts/erl#+sbt</a>
and <a href="../erts/erl#+sct">erts/erl#+sct</a>
in <strong>erl(1)</strong>.</p><h4>system_flag/2</h4><p>Set system flag scheduler_wall_time.</p><p>
Turns on or off scheduler wall time measurements.</p><p>For more information, see
<a href="#statistics_scheduler_wall_time">statistics_scheduler_wall_time</a>.</p><h4>system_flag/2</h4><p>Set system flag schedulers_online.</p><p>
Sets the number of schedulers online. Range is
<strong>1 &lt;= SchedulersOnline &lt;= erlang:system_info(schedulers)</strong>.</p><p>Returns the old value of the flag.</p><p>If the emulator was built with support for
<a href="#system_flag_dirty_cpu_schedulers_online"> dirty schedulers</a>,
changing the number of schedulers online can also change the
number of dirty CPU schedulers online. For example, if 12
schedulers and 6 dirty CPU schedulers are online, and
<strong>system_flag/2</strong> is used to set the number of schedulers
online to 6, then the number of dirty CPU schedulers online
is automatically decreased by half as well, down to 3.
Similarly, the number of dirty CPU schedulers online increases
proportionally to increases in the number of schedulers online.</p><p>For more information, see
<a href="#system_info_schedulers">system_info_schedulers</a> and
<a href="#system_info_schedulers_online">system_info_schedulers_online</a>.</p><h4>system_flag/2</h4><p>Set system logger process.</p><p>Sets the process that will receive the logging
messages generated by ERTS. If set to <strong>undefined</strong>,
all logging messages generated by ERTS will be dropped.
The messages will be in the format:</p><pre><code class="">
{log,Level,Format,ArgList,Metadata} where

Level = atom(),
Format = string(),
ArgList = list(term()),
Metadata = #{ pid =&gt; pid(),
   group_leader =&gt; pid(),
   time := logger:timestamp(),
   error_logger := #{ emulator := true, tag := atom() }
        </code></pre><p>If the <strong>system_logger</strong> process dies,
this flag will be reset to <strong>logger</strong>.</p><p>The default is the process named <strong>logger</strong>.</p><p>Returns the old value of the flag.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is designed to be used by the
KERNEL <a href="./logger">kernel/logger</a>.
Be careful if you change it to something else as
log messages may be lost. If you want to intercept
emulator log messages, do it by adding a specialized handler
to the KERNEL logger.</p></div><h4>system_flag/2</h4><p>Set system flag trace_control_word.</p><p>Sets the value of the node trace control word to
<strong><span class="anno">TCW</span></strong>, which is to be an unsigned integer.
For more information, see function
<a href="../erts/match_spec#set_tcw">erts/match_spec#set_tcw</a>
in section "Match Specifications in Erlang" in the
User's Guide.</p><p>Returns the old value of the flag.</p><h4>system_flag/2</h4><p>Finalize the time offset.</p><p>
Finalizes the <a href="#time_offset/0">time offset</a>
when <a href="./time_correction#Single_Time_Warp_Mode">single time warp mode</a> is used. If another time warp mode
is used, the time offset state is left unchanged.</p><p>Returns the old state identifier, that is:</p><ul><li><p>If <strong>preliminary</strong> is returned, finalization was
performed and the time offset is now final.</p> </li><li><p>If <strong>final</strong> is returned, the time offset was
already in the final state. This either because another
<strong>erlang:system_flag(time_offset, finalize)</strong> call or
because <a href="./time_correction#No_Time_Warp_Mode">no time warp mode</a> is used.</p> </li><li><p>If <strong>volatile</strong> is returned, the time offset
cannot be finalized because
<a href="./time_correction#Multi_Time_Warp_Mode">multi-time warp mode</a> is used.</p> </li></ul><h4>system_info/1</h4><p>System info overview.</p><p>Returns information about the current system.
The documentation of this function is broken into the following
sections in order to make it easier to navigate.</p><dl><dt><a href="#system_info_allocator">system_info_allocator</a></dt><dd> <p>
<a href="#system_info_allocated_areas">system_info_allocated_areas</a>,
<a href="#system_info_allocator">system_info_allocator</a>,
<a href="#system_info_alloc_util_allocators">system_info_alloc_util_allocators</a>,
<a href="#system_info_allocator_sizes">system_info_allocator_sizes</a>,
<a href="#system_info_elib_malloc">system_info_elib_malloc</a>
</p> </dd><dt><a href="#system_info_cpu_topology">system_info_cpu_topology</a></dt><dd> <p>
<a href="#system_info_cpu_topology">system_info_cpu_topology</a>,
<a href="#system_info_logical_processors">system_info_logical_processors</a>,
<a href="#system_info_update_cpu_info">system_info_update_cpu_info</a>
</p> </dd><dt><a href="#system_info_process">system_info_process</a></dt><dd> <p>
<a href="#system_info_fullsweep_after">system_info_fullsweep_after</a>,
<a href="#system_info_garbage_collection">system_info_garbage_collection</a>,
<a href="#system_info_heap_sizes">system_info_heap_sizes</a>,
<a href="#system_info_heap_type">system_info_heap_type</a>,
<a href="#system_info_max_heap_size">system_info_max_heap_size</a>,
<a href="#system_info_message_queue_data">system_info_message_queue_data</a>,
<a href="#system_info_min_heap_size">system_info_min_heap_size</a>,
<a href="#system_info_min_bin_vheap_size">system_info_min_bin_vheap_size</a>,
<a href="#system_info_procs">system_info_procs</a>
</p> </dd><dt><a href="#system_info_limits">system_info_limits</a></dt><dd> <p>
<a href="#system_info_atom_count">system_info_atom_count</a>,
<a href="#system_info_atom_limit">system_info_atom_limit</a>,
<a href="#system_info_ets_count">system_info_ets_count</a>,
<a href="#system_info_ets_limit">system_info_ets_limit</a>,
<a href="#system_info_port_count">system_info_port_count</a>,
<a href="#system_info_port_limit">system_info_port_limit</a>,
<a href="#system_info_process_count">system_info_process_count</a>,
<a href="#system_info_process_limit">system_info_process_limit</a>
</p> </dd><dt><a href="#system_info_time">system_info_time</a></dt><dd> <p>
<a href="#system_info_end_time">system_info_end_time</a>,
<a href="#system_info_os_monotonic_time_source">system_info_os_monotonic_time_source</a>,
<a href="#system_info_os_system_time_source">system_info_os_system_time_source</a>,
<a href="#system_info_start_time">system_info_start_time</a>,
<a href="#system_info_time_correction">system_info_time_correction</a>,
<a href="#system_info_time_offset">system_info_time_offset</a>,
<a href="#system_info_time_warp_mode">system_info_time_warp_mode</a>,
<a href="#system_info_tolerant_timeofday">system_info_tolerant_timeofday</a>
</p> </dd><dt><a href="#system_info_scheduler">system_info_scheduler</a></dt><dd> <p>
<a href="#system_info_dirty_cpu_schedulers">system_info_dirty_cpu_schedulers</a>,
<a href="#system_info_dirty_cpu_schedulers_online">system_info_dirty_cpu_schedulers_online</a>,
<a href="#system_info_dirty_io_schedulers">system_info_dirty_io_schedulers</a>,
<a href="#system_info_multi_scheduling">system_info_multi_scheduling</a>,
<a href="#system_info_multi_scheduling_blockers">system_info_multi_scheduling_blockers</a>,
<a href="#system_info_normal_multi_scheduling_blockers">system_info_normal_multi_scheduling_blockers</a>,
<a href="#system_info_scheduler_bind_type">system_info_scheduler_bind_type</a>,
<a href="#system_info_scheduler_bindings">system_info_scheduler_bindings</a>,
<a href="#system_info_scheduler_id">system_info_scheduler_id</a>,
<a href="#system_info_schedulers">system_info_schedulers</a>,
<a href="#system_info_smp_support">system_info_smp_support</a>,
<a href="#system_info_threads">system_info_threads</a>,
<a href="#system_info_thread_pool_size">system_info_thread_pool_size</a>
</p> </dd><dt><a href="#system_info_dist">system_info_dist</a></dt><dd> <p>
<a href="#system_info_creation">system_info_creation</a>,
<a href="#system_info_delayed_node_table_gc">system_info_delayed_node_table_gc</a>,
<a href="#system_info_dist">system_info_dist</a>,
<a href="#system_info_dist_buf_busy_limit">system_info_dist_buf_busy_limit</a>,
<a href="#system_info_dist_ctrl">system_info_dist_ctrl</a>
</p> </dd><dt><a href="#system_info_misc">system_info_misc</a></dt><dd> <p>
<a href="#system_info_build_type">system_info_build_type</a>,
<a href="#system_info_c_compiler_used">system_info_c_compiler_used</a>,
<a href="#system_info_check_io">system_info_check_io</a>,
<a href="#system_info_compat_rel">system_info_compat_rel</a>,
<a href="#system_info_debug_compiled">system_info_debug_compiled</a>,
<a href="#system_info_driver_version">system_info_driver_version</a>,
<a href="#system_info_dynamic_trace">system_info_dynamic_trace</a>,
<a href="#system_info_dynamic_trace_probes">system_info_dynamic_trace_probes</a>,
<a href="#system_info_info">system_info_info</a>,
<a href="#system_info_kernel_poll">system_info_kernel_poll</a>,
<a href="#system_info_loaded">system_info_loaded</a>,
<a href="#system_info_machine">system_info_machine</a>,
<a href="#system_info_modified_timing_level">system_info_modified_timing_level</a>,
<a href="#system_info_nif_version">system_info_nif_version</a>,
<a href="#system_info_otp_release">system_info_otp_release</a>,
<a href="#system_info_port_parallelism">system_info_port_parallelism</a>,
<a href="#system_info_system_architecture">system_info_system_architecture</a>,
<a href="#system_info_system_logger">system_info_system_logger</a>,
<a href="#system_info_system_version">system_info_system_version</a>,
<a href="#system_info_trace_control_word">system_info_trace_control_word</a>,
<a href="#system_info_version">system_info_version</a>,
<a href="#system_info_wordsize">system_info_wordsize</a>
</p> </dd></dl><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><p>Information about the system allocators.</p><ul><li>Allocator</li></ul><ul><li>Version</li></ul><ul><li>Features</li></ul><ul><li>Settings</li></ul><ul><li>Alloc</li></ul><a name="system_info_allocator_tags"></a><p>Returns various information about the memory allocators
of the current system (emulator) as specified by
<strong><span class="anno">Item</span></strong>:</p><a name="system_info_allocated_areas"></a><dl><dt><a name="system_info_allocated_areas"></a> <strong>allocated_areas</strong></dt><dd> <p>Returns a list of tuples with information about
miscellaneous allocated memory areas.</p> <p>Each tuple contains an atom describing the type of
memory as first element and the amount of allocated
memory in bytes as second element. When information
about allocated and used memory is present, also a
third element is present, containing the amount of
used memory in bytes.</p> <p><strong>erlang:system_info(allocated_areas)</strong> is intended
for debugging, and the content is highly
implementation-dependent. The content of the results
therefore changes when needed without prior notice.</p> <p>Notice that the sum of these values is <em>not</em>
the total amount of memory allocated by the emulator.
Some values are part of other values, and some memory
areas are not part of the result. For information about
the total amount of memory allocated by the emulator, see
<a href="#memory/0">memory/0</a>.</p> </dd><dt><a name="system_info_allocator"></a> <strong>allocator</strong></dt><dd> <p>Returns <strong>{<span class="anno">Allocator</span>, <span class="anno">Version</span>, <span class="anno">Features</span>, <span class="anno">Settings</span></strong>, where:</p> <ul><li> <p><strong><span class="anno">Allocator</span></strong> corresponds to the
<strong>malloc()</strong> implementation used. If
<strong><span class="anno">Allocator</span></strong> equals
<strong>undefined</strong>, the <strong>malloc()</strong> implementation
used cannot be identified. <strong>glibc</strong> can be
identified.</p> </li><li> <p><strong><span class="anno">Version</span></strong> is a list of integers
(but not a string) representing the version of
the <strong>malloc()</strong> implementation used.</p> </li><li> <p><strong><span class="anno">Features</span></strong> is a list of atoms
representing the allocation features used.</p> </li><li> <p><strong><span class="anno">Settings</span></strong> is a list of subsystems,
their configurable parameters, and used values. Settings
can differ between different combinations of
platforms, allocators, and allocation features.
Memory sizes are given in bytes.</p> </li></ul> <p>See also "System Flags Effecting erts_alloc" in
<a href="../erts/erts_alloc#flags">erts/erts_alloc#flags</a>.</p> </dd><dt><a name="system_info_allocator_tuple"></a> <strong>{allocator, <span class="anno">Alloc</span>}</strong></dt><dd> <p>Returns information about the specified allocator.
As from ERTS 5.6.1, the return value is a list
of <strong>{instance, InstanceNo, InstanceInfo}</strong> tuples,
where <strong>InstanceInfo</strong> contains information about
a specific instance of the allocator.
If <strong><span class="anno">Alloc</span></strong> is not a
recognized allocator, <strong>undefined</strong> is returned.
If <strong><span class="anno">Alloc</span></strong> is disabled,
<strong>false</strong> is returned.</p> <p>Notice that the information returned is highly
implementation-dependent and can be changed or removed
at any time without prior notice. It was initially
intended as a tool when developing new allocators, but
as it can be of interest for others it has been
briefly documented.</p> <p>The recognized allocators are listed in
<a href="./erts_alloc">erts/erts_alloc</a>.
Information about super carriers can be obtained from
ERTS 8.0 with <strong>{allocator, erts_mmap}</strong> or from
ERTS 5.10.4; the returned list when calling with
<strong>{allocator, mseg_alloc}</strong> also includes an
<strong>{erts_mmap, _}</strong> tuple as one element in the list.</p> <p>After reading the <strong>erts_alloc(3)</strong> documentation,
the returned information
more or less speaks for itself, but it can be worth
explaining some things. Call counts are presented by two
values, the first value is giga calls, and the second
value is calls. <strong>mbcs</strong> and <strong>sbcs</strong> denote
multi-block carriers, and single-block carriers,
respectively. Sizes are presented in bytes. When a
size is not presented, it is the amount of something.
Sizes and amounts are often presented by three values:</p> <ul><li>The first is the current value.</li><li>The second is the maximum value since the last call to <strong>erlang:system_info({allocator, Alloc})</strong>.</li><li>The third is the maximum value since the emulator was started.</li></ul> <p>If only one value is present, it is the current value.
<strong>fix_alloc</strong> memory block types are presented by two
values. The first value is the memory pool size and
the second value is the used memory size.</p> </dd><dt><a name="system_info_alloc_util_allocators"></a> <strong>alloc_util_allocators</strong></dt><dd> <p>Returns a list of the names of all allocators using
the ERTS internal <strong>alloc_util</strong> framework
as atoms. For more information, see section
<a href="../erts/erts_alloc#alloc_util">The alloc_util framework</a>
in <strong>erts_alloc(3)</strong>.</p> </dd><dt><a name="system_info_allocator_sizes"></a> <strong>{allocator_sizes, <span class="anno">Alloc</span>}</strong></dt><dd> <p>Returns various size information for the specified
allocator. The information returned is a subset of the
information returned by
<a href="#system_info_allocator_tuple">system_info_allocator_tuple</a>.</p> </dd><dt><a name="system_info_elib_malloc"></a> <strong>elib_malloc</strong></dt><dd> <p>This option will be removed in a future release.
The return value will always be <strong>false</strong>, as the
<strong>elib_malloc</strong> allocator has been removed.</p> </dd></dl><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><p>Information about the CPU topology of the system.</p><ul><li>cpu_topology</li></ul><ul><li>level_entry</li></ul> All <strong><span class="anno">LevelEntry</span></strong>s of a list must contain the same <strong><span class="anno">LevelTag</span></strong>, except on the top level where both <strong>node</strong> and <strong>processor</strong> <strong><span class="anno">LevelTag</span></strong>s can coexist.  <strong>{<span class="anno">LevelTag</span>, <span class="anno">SubLevel</span>} == {<span class="anno">LevelTag</span>, [], <span class="anno">SubLevel</span>}</strong> <ul><li>level_tag</li></ul> More <strong><span class="anno">LevelTag</span></strong>s can be introduced in a future release. <ul><li>sub_level</li></ul><ul><li>info_list</li></ul> The <strong>info_list()</strong> can be extended in a future release. <a name="system_info_cpu_topology_tags"></a><p>Returns various information about the CPU topology of
the current system (emulator) as specified by
<strong><span class="anno">Item</span></strong>:</p><dl><dt><a name="system_info_cpu_topology"></a> <strong>cpu_topology</strong></dt><dd> <p>Returns the <strong><span class="anno">CpuTopology</span></strong> currently used by
the emulator. The CPU topology is used when binding schedulers
to logical processors. The CPU topology used is the
<a href="./erlang#system_info_cpu_topology_defined"> user-defined CPU topology</a>,
if such exists, otherwise the
<a href="./erlang#system_info_cpu_topology_detected"> automatically detected CPU topology</a>,
if such exists. If no CPU topology
exists, <strong>undefined</strong> is returned.</p> <p><strong>node</strong> refers to Non-Uniform Memory Access (NUMA)
nodes. <strong>thread</strong> refers to hardware threads
(for example, Intel hyper-threads).</p> <p>A level in term <strong><span class="anno">CpuTopology</span></strong> can be
omitted if only one entry exists and
<strong><span class="anno">InfoList</span></strong> is empty.</p> <p><strong>thread</strong> can only be a sublevel to <strong>core</strong>.
<strong>core</strong> can be a sublevel to <strong>processor</strong>
or <strong>node</strong>. <strong>processor</strong> can be on the
top level or a sublevel to <strong>node</strong>. <strong>node</strong>
can be on the top level or a sublevel to
<strong>processor</strong>. That is, NUMA nodes can be processor
internal or processor external. A CPU topology can
consist of a mix of processor internal and external
NUMA nodes, as long as each logical CPU belongs to
<em>one</em> NUMA node. Cache hierarchy is not part of
the <strong><span class="anno">CpuTopology</span></strong> type, but will be in a
future release. Other things can also make it into the CPU
topology in a future release. So, expect the
<strong><span class="anno">CpuTopology</span></strong> type to change.</p> </dd><dt><strong>{cpu_topology, defined}</strong></dt><dd> <a name="system_info_cpu_topology_defined"></a> <p>Returns the user-defined <strong><span class="anno">CpuTopology</span></strong>.
For more information, see command-line flag
<a href="../erts/erl#+sct">erts/erl#+sct</a> in
<strong>erl(1)</strong> and argument
<a href="#system_info_cpu_topology">system_info_cpu_topology</a>.</p> </dd><dt><strong>{cpu_topology, detected}</strong></dt><dd> <a name="system_info_cpu_topology_detected"></a> <p>Returns the automatically detected
<strong><span class="anno">CpuTopology</span>y</strong>. The
emulator detects the CPU topology on some newer
Linux, Solaris, FreeBSD, and Windows systems.
On Windows system with more than 32 logical processors,
the CPU topology is not detected.</p> <p>For more information, see argument
<a href="#system_info_cpu_topology">system_info_cpu_topology</a>.</p> </dd><dt><strong>{cpu_topology, used}</strong></dt><dd> <p>Returns <strong><span class="anno">CpuTopology</span></strong> used by the emulator.
For more information, see argument
<a href="#system_info_cpu_topology">system_info_cpu_topology</a>.</p> </dd><dt><a name="system_info_logical_processors"></a> <strong>logical_processors</strong></dt><dd> <p>Returns the detected number of logical processors configured
in the system. The return value is either an integer, or
the atom <strong>unknown</strong> if the emulator cannot
detect the configured logical processors.</p> </dd><dt><a name="system_info_logical_processors_available"></a> <strong>logical_processors_available</strong></dt><dd> <p>Returns the detected number of logical processors available
to the Erlang runtime system. The return value is either an
integer, or the atom <strong>unknown</strong> if the emulator
cannot detect the available logical processors. The number
of available logical processors is less than or equal to
the number of <a href="#system_info_logical_processors_online"> logical processors online</a>.</p> </dd><dt><a name="system_info_logical_processors_online"></a> <strong>logical_processors_online</strong></dt><dd> <p>Returns the detected number of logical processors online on
the system. The return value is either an integer,
or the atom <strong>unknown</strong> if the emulator cannot
detect logical processors online. The number of logical
processors online is less than or equal to the number of
<a href="#system_info_logical_processors">logical processors configured</a>.</p> </dd><dt><a name="system_info_update_cpu_info"></a> <strong>update_cpu_info</strong></dt><dd> <p>The runtime system rereads the CPU information available
and updates its internally stored information about the
<a href="#system_info_cpu_topology_detected">detected CPU topology</a> and the number of logical processors
<a href="#system_info_logical_processors">configured</a>,
<a href="#system_info_logical_processors_online">online</a>,
and <a href="#system_info_logical_processors_available"> available</a>.</p> <p>If the CPU information has changed since the last time
it was read, the atom <strong>changed</strong> is returned, otherwise
the atom <strong>unchanged</strong>. If the CPU information has changed,
you probably want to
<a href="#system_flag_schedulers_online">adjust the number of schedulers online</a>. You typically want
to have as many schedulers online as
<a href="#system_info_logical_processors_available">logical processors available</a>.</p> </dd></dl><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><p>Information about the default process heap settings.</p><ul><li>message_queue_data</li></ul><ul><li>max_heap_size</li></ul><a name="system_info_process_tags"></a><p>Returns information about the default process heap settings:</p><dl><dt><a name="system_info_fullsweep_after"></a> <strong>fullsweep_after</strong></dt><dd> <p>Returns <strong>{fullsweep_after, integer() &gt;= 0}</strong>, which is
the <strong>fullsweep_after</strong> garbage collection setting used
by default. For more information, see
<strong>garbage_collection</strong> described below.</p> </dd><dt><a name="system_info_garbage_collection"></a> <strong>garbage_collection</strong></dt><dd> <p>Returns a list describing the default garbage collection
settings. A process spawned on the local node by a
<strong>spawn</strong> or <strong>spawn_link</strong> uses these
garbage collection settings. The default settings can be
changed by using
<a href="#system_flag/2">system_flag/2</a>.
<a href="#spawn_opt/4">spawn_opt/4</a>
can spawn a process that does not use the default
settings.</p> </dd><dt><a name="system_info_heap_sizes"></a> <strong>heap_sizes</strong></dt><dd> <p>Returns a list of integers representing valid heap sizes 
in words. All Erlang heaps are sized from sizes in this
list.</p> </dd><dt><a name="system_info_heap_type"></a> <strong>heap_type</strong></dt><dd> <p>Returns the heap type used by the current emulator. One
heap type exists:</p> <dl><dt><strong>private</strong></dt><dd> Each process has a heap reserved for its use and no references between heaps of different processes are allowed. Messages passed between processes are copied between heaps. </dd></dl> </dd><dt><a name="system_info_max_heap_size"></a> <strong>max_heap_size</strong></dt><dd> <p>Returns <strong>{max_heap_size, <span class="anno">MaxHeapSize</span>}</strong>,
where <strong><span class="anno">MaxHeapSize</span></strong> is the current
system-wide maximum heap size settings for spawned processes.
This setting can be set using the command-line flags
<a href="./erl#+hmax">erl#+hmax</a>,
<a href="./erl#+hmaxk">erl#+hmaxk</a> and
<a href="./erl#+hmaxel">erl#+hmaxel</a> in
<strong>erl(1)</strong>. It can also be changed at runtime using
<a href="#system_flag_max_heap_size">system_flag_max_heap_size</a>.
For more details about the <strong>max_heap_size</strong> process flag,
see <a href="#process_flag_max_heap_size">process_flag_max_heap_size</a>.</p> </dd><dt><a name="system_info_message_queue_data"></a> <strong>message_queue_data</strong></dt><dd> <p>Returns the default value of the <strong>message_queue_data</strong>
process flag, which is either <strong>off_heap</strong> or <strong>on_heap</strong>.
This default is set by command-line argument
<a href="./erl#+hmqd">erl#+hmqd</a> in
<strong>erl(1)</strong>. For more information on the
<strong>message_queue_data</strong> process flag, see documentation of
<a href="#process_flag_message_queue_data">process_flag_message_queue_data</a>.</p> </dd><dt><a name="system_info_min_heap_size"></a> <strong>min_heap_size</strong></dt><dd> <p>Returns <strong>{min_heap_size, <span class="anno">MinHeapSize</span>}</strong>,
where <strong><span class="anno">MinHeapSize</span></strong> is the current
system-wide minimum heap size for spawned processes.</p> </dd><dt><a name="system_info_min_bin_vheap_size"></a> <strong>min_bin_vheap_size</strong></dt><dd> <p>Returns <strong>{min_bin_vheap_size, <span class="anno">MinBinVHeapSize</span>}</strong>, where
<strong><span class="anno">MinBinVHeapSize</span></strong> is the current system-wide
minimum binary virtual heap size for spawned processes.</p> </dd><dt><a name="system_info_procs"></a> <strong>procs</strong></dt><dd> <p>Returns a binary containing a string of process and port
information formatted as in Erlang crash dumps. For more
information, see section <a href="./crash_dump"> How to interpret the Erlang crash dumps</a>
in the User's Guide.</p> </dd></dl><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><p>Information about various system limits.</p><a name="system_info_limits"></a><p>Returns information about the current system
(emulator) limits as specified by <strong><span class="anno">Item</span></strong>:</p><dl><dt><a name="system_info_atom_count"></a> <strong>atom_count</strong></dt><dd> <p>Returns the number of atoms currently existing at the
local node. The value is given as an integer.</p> </dd><dt><a name="system_info_atom_limit"></a> <strong>atom_limit</strong></dt><dd> <p>Returns the maximum number of atoms allowed.
This limit can be increased at startup by passing
command-line flag
<a href="../erts/erl#+t">erts/erl#+t</a> to
<strong>erl(1)</strong>.
</p> </dd><dt><a name="system_info_ets_count"></a> <strong>ets_count</strong></dt><dd> <p>Returns the number of ETS tables currently existing at the
local node.</p> </dd><dt><a name="system_info_ets_limit"></a> <strong>ets_limit</strong></dt><dd> <p>Returns the limit for number of ETS tables. This limit is
<a href="../stdlib/ets#max_ets_tables">partially obsolete</a>
and number of tables are only limited by available memory.</p> </dd><dt><a name="system_info_port_count"></a><strong>port_count</strong></dt><dd> <p>Returns the number of ports currently existing at the
local node. The value is given as an integer. This is
the same value as returned by
<strong>length(erlang:ports())</strong>, but more efficient.</p> </dd><dt><a name="system_info_port_limit"></a> <strong>port_limit</strong></dt><dd> <p>Returns the maximum number of simultaneously existing
ports at the local node as an integer. This limit can be
configured at startup by using command-line flag
<a href="./erl#+Q">erl#+Q</a> in <strong>erl(1)</strong>.</p> </dd><dt><a name="system_info_process_count"></a> <strong>process_count</strong></dt><dd> <p>Returns the number of processes currently existing at the
local node. The value is given as an integer. This is
the same value as returned by
<strong>length(processes())</strong>, but more efficient.</p> </dd><dt><a name="system_info_process_limit"></a> <strong>process_limit</strong></dt><dd> <p>Returns the maximum number of simultaneously existing
processes at the local node. The value is given as an
integer. This limit can be configured at startup by using
command-line flag <a href="./erl#+P">erl#+P</a>
in <strong>erl(1)</strong>.</p> </dd></dl><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><p>Information about system time.</p><a name="system_info_time_tags"></a><p>Returns information about the current system
(emulator) time as specified by <strong><span class="anno">Item</span></strong>:</p><dl><dt><a name="system_info_end_time"></a><strong>end_time</strong></dt><dd> <p>The last <a href="#monotonic_time/0">Erlang monotonic time</a> in <strong>native</strong>
<a href="#type_time_unit">time unit</a> that
can be represented internally in the current Erlang runtime system
instance. The time between the
<a href="#system_info_start_time">start time</a> and
the end time is at least a quarter of a millennium.</p> </dd><dt><a name="system_info_os_monotonic_time_source"></a> <strong>os_monotonic_time_source</strong></dt><dd> <p>Returns a list containing information about the source of
<a href="../erts/time_correction#OS_Monotonic_Time">OS monotonic time</a> that is used by the runtime system.</p> <p>If <strong>[]</strong> is returned, no OS monotonic time is
available. The list contains two-tuples with <strong>Key</strong>s
as first element, and <strong>Value</strong>s as second element. The
order of these tuples is undefined. The following
tuples can be part of the list, but more tuples can be
introduced in the future:</p> <dl><dt><strong>{function, Function}</strong></dt><dd><p><strong>Function</strong> is the name of the function
used. This tuple always exists if OS monotonic time is
available to the runtime system.</p> </dd><dt><strong>{clock_id, ClockId}</strong></dt><dd><p>This tuple only exists if <strong>Function</strong>
can be used with different clocks. <strong>ClockId</strong>
corresponds to the clock identifier used when calling
<strong>Function</strong>.</p> </dd><dt><strong>{resolution, OsMonotonicTimeResolution}</strong></dt><dd><p>Highest possible
<a href="./time_correction#Time_Resolution"> resolution</a>
of current OS monotonic time source as parts per
second. If no resolution information can be retrieved
from the OS, <strong>OsMonotonicTimeResolution</strong> is
set to the resolution of the time unit of
<strong>Function</strong>s return value. That is, the actual
resolution can be lower than
<strong>OsMonotonicTimeResolution</strong>. Notice that
the resolution does not say anything about the
<a href="./time_correction#Time_Accuracy"> accuracy</a> or whether the
<a href="./time_correction#Time_Precision"> precision</a> aligns with the resolution. You do,
however, know that the precision is not better than
<strong>OsMonotonicTimeResolution</strong>.</p> </dd><dt><strong>{extended, Extended}</strong></dt><dd><p><strong>Extended</strong> equals <strong>yes</strong> if
the range of time values has been extended;
otherwise <strong>Extended</strong> equals <strong>no</strong>. The
range must be extended if <strong>Function</strong>
returns values that wrap fast. This typically
is the case when the return value is a 32-bit value.</p> </dd><dt><strong>{parallel, Parallel}</strong></dt><dd><p><strong>Parallel</strong> equals <strong>yes</strong> if
<strong>Function</strong> is called in parallel from multiple
threads. If it is not called in parallel, because
calls must be serialized, <strong>Parallel</strong> equals
<strong>no</strong>.</p> </dd><dt><strong>{time, OsMonotonicTime}</strong></dt><dd><p><strong>OsMonotonicTime</strong> equals current OS
monotonic time in <strong>native</strong>
<a href="#type_time_unit">time unit</a>.</p> </dd></dl> </dd><dt><a name="system_info_os_system_time_source"></a> <strong>os_system_time_source</strong></dt><dd> <p>Returns a list containing information about the source of
<a href="../erts/time_correction#OS_System_Time">OS system time</a> that is used by the runtime system.</p> <p>The list contains two-tuples with <strong>Key</strong>s
as first element, and <strong>Value</strong>s as second element. The
order of these tuples is undefined. The following
tuples can be part of the list, but more tuples can be
introduced in the future:</p> <dl><dt><strong>{function, Function}</strong></dt><dd><p><strong>Function</strong> is the name of the funcion used.</p> </dd><dt><strong>{clock_id, ClockId}</strong></dt><dd><p>Exists only if <strong>Function</strong>
can be used with different clocks. <strong>ClockId</strong>
corresponds to the clock identifier used when calling
<strong>Function</strong>.</p> </dd><dt><strong>{resolution, OsSystemTimeResolution}</strong></dt><dd><p>Highest possible
<a href="./time_correction#Time_Resolution"> resolution</a>
of current OS system time source as parts per
second. If no resolution information can be retrieved
from the OS, <strong>OsSystemTimeResolution</strong> is
set to the resolution of the time unit of
<strong>Function</strong>s return value. That is, the actual
resolution can be lower than
<strong>OsSystemTimeResolution</strong>. Notice that
the resolution does not say anything about the
<a href="./time_correction#Time_Accuracy"> accuracy</a> or whether the
<a href="./time_correction#Time_Precision"> precision</a> do align with the resolution. You do,
however, know that the precision is not better than
<strong>OsSystemTimeResolution</strong>.</p> </dd><dt><strong>{parallel, Parallel}</strong></dt><dd><p><strong>Parallel</strong> equals <strong>yes</strong> if
<strong>Function</strong> is called in parallel from multiple
threads. If it is not called in parallel, because
calls needs to be serialized, <strong>Parallel</strong> equals
<strong>no</strong>.</p> </dd><dt><strong>{time, OsSystemTime}</strong></dt><dd><p><strong>OsSystemTime</strong> equals current OS
system time in <strong>native</strong>
<a href="#type_time_unit">time unit</a>.</p> </dd></dl> </dd><dt><a name="system_info_start_time"></a><strong>start_time</strong></dt><dd> <p>The <a href="#monotonic_time/0">Erlang monotonic time</a> in <strong>native</strong>
<a href="#type_time_unit">time unit</a> at the
time when current Erlang runtime system instance started.</p> <p>See also <a href="#system_info_end_time">system_info_end_time</a>.</p> </dd><dt><a name="system_info_time_correction"></a> <strong>time_correction</strong></dt><dd> <p>Returns a boolean value indicating whether
<a href="./time_correction#Time_Correction"> time correction</a> is enabled or not.</p> </dd><dt><a name="system_info_time_offset"></a> <strong>time_offset</strong></dt><dd> <p>Returns the state of the time offset:</p> <dl><dt><strong>preliminary</strong></dt><dd> <p>The time offset is preliminary, and will be changed
and finalized later. The preliminary time offset
is used during the preliminary phase of the
<a href="./time_correction#Single_Time_Warp_Mode"> single time warp mode</a>.</p> </dd><dt><strong>final</strong></dt><dd> <p>The time offset is final. This either because
<a href="./time_correction#No_Time_Warp_Mode"> no time warp mode</a> is used, or because the time
offset have been finalized when
<a href="./time_correction#Single_Time_Warp_Mode"> single time warp mode</a> is used.</p> </dd><dt><strong>volatile</strong></dt><dd> <p>The time offset is volatile. That is, it can
change at any time. This is because
<a href="./time_correction#Multi_Time_Warp_Mode"> multi-time warp mode</a> is used.</p> </dd></dl> </dd><dt><a name="system_info_time_warp_mode"></a> <strong>time_warp_mode</strong></dt><dd> <p>Returns a value identifying the
<a href="./time_correction#Time_Warp_Modes"> time warp mode</a> that is used:</p> <dl><dt><strong>no_time_warp</strong></dt><dd>The <a href="./time_correction#No_Time_Warp_Mode"> no time warp mode</a> is used. </dd><dt><strong>single_time_warp</strong></dt><dd>The <a href="./time_correction#Single_Time_Warp_Mode"> single time warp mode</a> is used. </dd><dt><strong>multi_time_warp</strong></dt><dd>The <a href="./time_correction#Multi_Time_Warp_Mode"> multi-time warp mode</a> is used. </dd></dl> </dd><dt><a name="system_info_tolerant_timeofday"></a> <strong>tolerant_timeofday</strong></dt><dd> <p>Returns whether a pre ERTS 7.0 backwards compatible
compensation for sudden changes of system time is <strong>enabled</strong>
or <strong>disabled</strong>. Such compensation is <strong>enabled</strong> when the
<a href="#system_info_time_offset">time offset</a>
is <strong>final</strong>, and
<a href="#system_info_time_correction"> time correction</a> is enabled.</p> </dd></dl><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><p>Information about system schedulers.</p><a name="system_info_scheduler_tags"></a><p>Returns information about schedulers, scheduling and threads in the
current system as specified by <strong><span class="anno">Item</span></strong>:</p><dl><dt><a name="system_info_dirty_cpu_schedulers"></a> <strong>dirty_cpu_schedulers</strong></dt><dd> <p>Returns the number of dirty CPU scheduler threads used by
the emulator. Dirty CPU schedulers execute CPU-bound
native functions, such as NIFs, linked-in driver code,
and BIFs that cannot be managed cleanly by the normal
emulator schedulers.</p> <p>The number of dirty CPU scheduler threads is determined
at emulator boot time and cannot be changed after that.
However, the number of dirty CPU scheduler threads online
can be changed at any time. The number of dirty CPU
schedulers can be set at startup by passing
command-line flag
<a href="../erts/erl#+SDcpu">erts/erl#+SDcpu</a> or
<a href="../erts/erl#+SDPcpu">erts/erl#+SDPcpu</a> in
<strong>erl(1)</strong>.</p> <p>See also
<a href="#system_flag_dirty_cpu_schedulers_online">system_flag_dirty_cpu_schedulers_online</a>,
<a href="#system_info_dirty_cpu_schedulers_online">system_info_dirty_cpu_schedulers_online</a>,
<a href="#system_info_dirty_io_schedulers">system_info_dirty_io_schedulers</a>,
<a href="#system_info_schedulers">system_info_schedulers</a>,
<a href="#system_info_schedulers_online">system_info_schedulers_online</a>, and
<a href="#system_flag_schedulers_online">system_flag_schedulers_online</a>.</p> </dd><dt><a name="system_info_dirty_cpu_schedulers_online"></a> <strong>dirty_cpu_schedulers_online</strong></dt><dd> <p>Returns the number of dirty CPU schedulers online.
The return value satisfies
<strong>1 &lt;= DirtyCPUSchedulersOnline &lt;= N</strong>,
where <strong>N</strong> is the smallest of the return values of
<strong>erlang:system_info(dirty_cpu_schedulers)</strong> and
<strong>erlang:system_info(schedulers_online)</strong>.</p> <p>The number of dirty CPU schedulers online can be set at
startup by passing command-line flag
<a href="../erts/erl#+SDcpu">erts/erl#+SDcpu</a> in
<strong>erl(1)</strong>.</p> <p>For more information, see
<a href="#system_info_dirty_cpu_schedulers">system_info_dirty_cpu_schedulers</a>,
<a href="#system_info_dirty_io_schedulers">system_info_dirty_io_schedulers</a>,
<a href="#system_info_schedulers_online">system_info_schedulers_online</a>, and
<a href="#system_flag_dirty_cpu_schedulers_online">system_flag_dirty_cpu_schedulers_online</a>.</p> </dd><dt><a name="system_info_dirty_io_schedulers"></a> <strong>dirty_io_schedulers</strong></dt><dd> <p>Returns the number of dirty I/O schedulers as an integer.
Dirty I/O schedulers execute I/O-bound native functions,
such as NIFs and linked-in driver code, which cannot be
managed cleanly by the normal emulator schedulers.</p> <p>This value can be set at startup by passing command-line
argument <a href="../erts/erl#+SDio">erts/erl#+SDio</a>
in <strong>erl(1)</strong>.</p> <p>For more information, see
<a href="#system_info_dirty_cpu_schedulers">system_info_dirty_cpu_schedulers</a>,
<a href="#system_info_dirty_cpu_schedulers_online">system_info_dirty_cpu_schedulers_online</a>,
and <a href="#system_flag_dirty_cpu_schedulers_online">system_flag_dirty_cpu_schedulers_online</a>.</p> </dd><dt><a name="system_info_multi_scheduling"></a> <strong>multi_scheduling</strong></dt><dd> <p>Returns one of the following:</p> <dl><dt><strong>disabled</strong></dt><dd> <p>The emulator has been started with only one scheduler thread.</p> </dd><dt><strong>blocked</strong></dt><dd> <p>The emulator has more than one scheduler thread,
but all scheduler threads except one are blocked.
That is, only one scheduler thread schedules
Erlang processes and executes Erlang code.</p> </dd><dt><strong>blocked_normal</strong></dt><dd> <p>The emulator has more than one scheduler thread,
but all normal scheduler threads except one are
blocked. Notice that dirty schedulers are not
blocked, and can schedule Erlang processes and
execute native code.</p> </dd><dt><strong>enabled</strong></dt><dd> <p>The emulator has more than one scheduler thread,
and no scheduler threads are blocked. That is,
all available scheduler threads schedule
Erlang processes and execute Erlang code.</p> </dd></dl> <p>See also
<a href="#system_flag_multi_scheduling">system_flag_multi_scheduling</a>,
<a href="#system_info_multi_scheduling_blockers">system_info_multi_scheduling_blockers</a>,
<a href="#system_info_normal_multi_scheduling_blockers">system_info_normal_multi_scheduling_blockers</a>,
and <a href="#system_info_schedulers">system_info_schedulers</a>.</p> </dd><dt><a name="system_info_multi_scheduling_blockers"></a> <strong>multi_scheduling_blockers</strong></dt><dd> <p>Returns a list of <strong><span class="anno">Pid</span></strong>s when
multi-scheduling is blocked, otherwise the empty list is
returned. The <strong><span class="anno">Pid</span></strong>s in the list
represent all the processes currently
blocking multi-scheduling. A <strong><span class="anno">Pid</span></strong> occurs
only once in the list, even if the corresponding
process has blocked multiple times.</p> <p>See also
<a href="#system_flag_multi_scheduling">system_flag_multi_scheduling</a>,
<a href="#system_info_multi_scheduling">system_info_multi_scheduling</a>,
<a href="#system_info_normal_multi_scheduling_blockers">system_info_normal_multi_scheduling_blockers</a>,
and <a href="#system_info_schedulers">system_info_schedulers</a>.</p> </dd><dt><a name="system_info_normal_multi_scheduling_blockers"></a> <strong>normal_multi_scheduling_blockers</strong></dt><dd> <p>Returns a list of <strong><span class="anno">Pid</span></strong>s when
normal multi-scheduling is blocked (that is, all normal schedulers
but one is blocked), otherwise the empty list is returned.
The <strong><span class="anno">Pid</span></strong>s in the list represent all the
processes currently blocking normal multi-scheduling.
A <strong><span class="anno">Pid</span></strong> occurs only once in the list, even if
the corresponding process has blocked multiple times.</p> <p>See also
<a href="#system_flag_multi_scheduling">system_flag_multi_scheduling</a>,
<a href="#system_info_multi_scheduling">system_info_multi_scheduling</a>,
<a href="#system_info_multi_scheduling_blockers">system_info_multi_scheduling_blockers</a>,
and <a href="#system_info_schedulers">system_info_schedulers</a>.</p> </dd><dt><a name="system_info_scheduler_bind_type"></a> <strong>scheduler_bind_type</strong></dt><dd> <p>Returns information about how the user has requested
schedulers to be bound or not bound.</p> <p>Notice that although a user has requested
schedulers to be bound, they can silently have failed
to bind. To inspect the scheduler bindings, call
<a href="#system_info_scheduler_bindings">system_info_scheduler_bindings</a>.</p> <p>For more information, see command-line argument
<a href="../erts/erl#+sbt">erts/erl#+sbt</a>
in <strong>erl(1)</strong> and
<a href="#system_info_scheduler_bindings">system_info_scheduler_bindings</a>.</p> </dd><dt><a name="system_info_scheduler_bindings"></a> <strong>scheduler_bindings</strong></dt><dd> <p>Returns information about the currently used scheduler
bindings.</p> <p>A tuple of a size equal to
<a href="#system_info_schedulers">system_info_schedulers</a>
is returned. The tuple elements are integers
or the atom <strong>unbound</strong>. Logical processor identifiers
are represented as integers. The <strong>N</strong>th
element of the tuple equals the current binding for
the scheduler with the scheduler identifier equal to
<strong>N</strong>. For example, if the schedulers are bound,
<strong>element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))</strong> returns
the identifier of the logical processor that the calling
process is executing on.</p> <p>Notice that only schedulers online can be bound to logical
processors.</p> <p>For more information, see command-line argument
<a href="../erts/erl#+sbt">erts/erl#+sbt</a>
in <strong>erl(1)</strong> and
<a href="#system_info_schedulers_online">system_info_schedulers_online</a>.</p> </dd><dt><a name="system_info_scheduler_id"></a> <strong>scheduler_id</strong></dt><dd> <p>Returns the scheduler ID (<strong>SchedulerId</strong>) of the
scheduler thread that the calling process is executing
on. <strong><span class="anno">SchedulerId</span></strong> is a positive integer,
where <strong>1 &lt;= SchedulerId &lt;= erlang:system_info(schedulers)</strong>.</p> <p>See also
<a href="#system_info_schedulers">system_info_schedulers</a>.</p> </dd><dt><a name="system_info_schedulers"></a> <strong>schedulers</strong></dt><dd> <p>Returns the number of scheduler threads used by
the emulator. Scheduler threads online schedules Erlang
processes and Erlang ports, and execute Erlang code
and Erlang linked-in driver code.</p> <p>The number of scheduler threads is determined at
emulator boot time and cannot be changed later.
However, the number of schedulers online can
be changed at any time.</p> <p>See also
<a href="#system_flag_schedulers_online">system_flag_schedulers_online</a>,
<a href="#system_info_schedulers_online">system_info_schedulers_online</a>,
<a href="#system_info_scheduler_id">system_info_scheduler_id</a>,
<a href="#system_flag_multi_scheduling">system_flag_multi_scheduling</a>,
<a href="#system_info_multi_scheduling">system_info_multi_scheduling</a>,
<a href="#system_info_normal_multi_scheduling_blockers">system_info_normal_multi_scheduling_blockers</a>
and <a href="#system_info_multi_scheduling_blockers">system_info_multi_scheduling_blockers</a>.
</p> </dd><dt><a name="system_info_schedulers_online"></a> <strong>schedulers_online</strong></dt><dd> <p>Returns the number of schedulers online. The scheduler
identifiers of schedulers online satisfy the relationship
<strong>1 &lt;= SchedulerId &lt;= erlang:system_info(schedulers_online)</strong>.</p> <p>For more information, see
<a href="#system_info_schedulers">system_info_schedulers</a> and
<a href="#system_flag_schedulers_online">system_flag_schedulers_online</a>.</p> </dd><dt><a name="system_info_smp_support"></a> <strong>smp_support</strong></dt><dd> <p>Returns <strong>true</strong>.</p> </dd><dt><a name="system_info_threads"></a> <strong>threads</strong></dt><dd> <p>Returns <strong>true</strong>.</p> </dd><dt><a name="system_info_thread_pool_size"></a> <strong>thread_pool_size</strong></dt><dd> <a name="system_info_thread_pool_size"></a> <p>Returns the number of async threads in the async thread
pool used for asynchronous driver calls
(<a href="../erts/erl_driver#driver_async">erts/erl_driver#driver_async</a>).
The value is given as an integer.</p> </dd></dl><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><p>Information about erlang distribution.</p><a name="system_info_dist_tags"></a><p>Returns information about Erlang Distribution in the
current system as specified by <strong><span class="anno">Item</span></strong>:</p><dl><dt><a name="system_info_creation"></a> <strong>creation</strong></dt><dd> <p>Returns the creation of the local node as an integer.
The creation is changed when a node is restarted. The
creation of a node is stored in process identifiers, port
identifiers, and references. This makes it (to some
extent) possible to distinguish between identifiers from
different incarnations of a node. The valid
creations are integers in the range 1..3, but this will
probably change in a future release. If the node is not
alive, <strong>0</strong> is returned.</p> </dd><dt><a name="system_info_delayed_node_table_gc"></a> <strong>delayed_node_table_gc</strong></dt><dd> <p>Returns the amount of time in seconds garbage collection
of an entry in a node table is delayed. This limit can be set
on startup by passing command-line flag
<a href="../erts/erl#+zdntgc">erts/erl#+zdntgc</a>
to <strong>erl(1)</strong>. For more information, see the documentation of
the command-line flag.</p> </dd><dt><a name="system_info_dist"></a> <strong>dist</strong></dt><dd> <p>Returns a binary containing a string of distribution
information formatted as in Erlang crash dumps. For more
information, see section <a href="./crash_dump"> How to interpret the Erlang crash dumps</a>
in the User's Guide.</p> </dd><dt><a name="system_info_dist_buf_busy_limit"></a> <strong>dist_buf_busy_limit</strong></dt><dd> <p>Returns the value of the distribution buffer busy limit
in bytes. This limit can be set at startup by passing
command-line flag
<a href="../erts/erl#+zdbbl">erts/erl#+zdbbl</a>
to <strong>erl(1)</strong>.</p> </dd><dt><a name="system_info_dist_ctrl"></a> <strong>dist_ctrl</strong></dt><dd> <p>Returns a list of tuples
<strong>{<span class="anno">Node</span>, <span class="anno">ControllingEntity</span>}</strong>,
one entry for each connected remote node.
<strong><span class="anno">Node</span></strong> is the node name
and <strong><span class="anno">ControllingEntity</span></strong> is the port or process
identifier responsible for the communication to that node.
More specifically, <strong><span class="anno">ControllingEntity</span></strong> for
nodes connected through TCP/IP (the normal case) is the socket
used in communication with the specific node.</p> </dd></dl><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><h4>system_info/1</h4><p>Information about the system.</p><a name="system_info_misc_tags"></a><p>Returns various information about the current system
(emulator) as specified by <strong><span class="anno">Item</span></strong>:</p><dl><dt><a name="system_info_build_type"></a> <strong>build_type</strong></dt><dd> <p>Returns an atom describing the build type of the runtime
system. This is normally the atom <strong>opt</strong> for optimized.
Other possible return values are <strong>debug</strong>, <strong>purify</strong>,
<strong>quantify</strong>, <strong>purecov</strong>, <strong>gcov</strong>, <strong>valgrind</strong>,
<strong>gprof</strong>, and <strong>lcnt</strong>. Possible return values
can be added or removed at any time without prior notice.</p> </dd><dt><a name="system_info_c_compiler_used"></a> <strong>c_compiler_used</strong></dt><dd> <p>Returns a two-tuple describing the C compiler used when
compiling the runtime system. The first element is an
atom describing the name of the compiler, or <strong>undefined</strong>
if unknown. The second element is a term describing the
version of the compiler, or <strong>undefined</strong> if unknown.</p> </dd><dt><a name="system_info_check_io"></a> <strong>check_io</strong></dt><dd> <p>Returns a list containing miscellaneous information
about the emulators internal I/O checking. Notice that
the content of the returned list can vary between
platforms and over time. It is only guaranteed
that a list is returned.</p> </dd><dt><a name="system_info_compat_rel"></a> <strong>compat_rel</strong></dt><dd> <p>Returns the compatibility mode of the local node as
an integer. The integer returned represents the
Erlang/OTP release that the current emulator has been
set to be backward compatible with. The compatibility
mode can be configured at startup by using command-line flag
<a href="../erts/erl#compat_rel">erts/erl#compat_rel</a> in
<strong>erl(1)</strong>.</p> </dd><dt><a name="system_info_debug_compiled"></a> <strong>debug_compiled</strong></dt><dd> <p>Returns <strong>true</strong> if the emulator has been
debug-compiled, otherwise <strong>false</strong>.</p> </dd><dt><a name="system_info_driver_version"></a> <strong>driver_version</strong></dt><dd> <p>Returns a string containing the Erlang driver version
used by the runtime system. It has the form
<a href="../erts/erl_driver#version_management"> "&lt;major ver&gt;.&lt;minor ver&gt;"</a>.</p> </dd><dt><a name="system_info_dynamic_trace"></a> <strong>dynamic_trace</strong></dt><dd> <p>Returns an atom describing the dynamic trace framework
compiled into the virtual machine. It can be
<strong>dtrace</strong>, <strong>systemtap</strong>, or <strong>none</strong>. For a
commercial or standard build, it is always <strong>none</strong>.
The other return values indicate a custom configuration
(for example, <strong>./configure --with-dynamic-trace=dtrace</strong>).
For more information about dynamic tracing, see
<a href="./dyntrace">runtime_tools/dyntrace</a> manual page and the
<strong>README.dtrace</strong>/<strong>README.systemtap</strong> files in the
Erlang source code top directory.</p> </dd><dt><a name="system_info_dynamic_trace_probes"></a> <strong>dynamic_trace_probes</strong></dt><dd> <p>Returns a <strong>boolean()</strong> indicating if dynamic trace
probes (<strong>dtrace</strong> or <strong>systemtap</strong>) are built into
the emulator. This can only be <strong>true</strong> if the virtual
machine was built for dynamic tracing (that is,
<strong>system_info(dynamic_trace)</strong> returns
<strong>dtrace</strong> or <strong>systemtap</strong>).</p> </dd><dt><a name="system_info_info"></a> <strong>info</strong></dt><dd> <p>Returns a binary containing a string of miscellaneous
system information formatted as in Erlang crash dumps.
For more information, see section
<a href="./crash_dump"> How to interpret the Erlang crash dumps</a>
in the User's Guide.</p> </dd><dt><a name="system_info_kernel_poll"></a> <strong>kernel_poll</strong></dt><dd> <p>Returns <strong>true</strong> if the emulator uses some kind of
kernel-poll implementation, otherwise <strong>false</strong>.</p> </dd><dt><a name="system_info_loaded"></a> <strong>loaded</strong></dt><dd> <p>Returns a binary containing a string of loaded module
information formatted as in Erlang crash dumps. For more
information, see section
<a href="./crash_dump">How to interpret the Erlang crash dumps</a> in the User's Guide.</p> </dd><dt><a name="system_info_machine"></a> <strong>machine</strong></dt><dd> <p>Returns a string containing the Erlang machine name.</p> </dd><dt><a name="system_info_modified_timing_level"></a> <strong>modified_timing_level</strong></dt><dd> <p>Returns the modified timing-level (an integer) if
modified timing is enabled, otherwise <strong>undefined</strong>.
For more information about modified timing, see
command-line flag
<a href="../erts/erl#+T">erts/erl#+T</a>
in <strong>erl(1)</strong></p> </dd><dt><a name="system_info_nif_version"></a> <strong>nif_version</strong></dt><dd> <p>Returns a string containing the version of the Erlang NIF
interface used by the runtime system. It is on the form
"&lt;major ver&gt;.&lt;minor ver&gt;".</p> </dd><dt><a name="system_info_otp_release"></a> <strong>otp_release</strong></dt><dd> <a name="system_info_otp_release"></a> <p>Returns a string containing the OTP release number of the
OTP release that the currently executing ERTS application
is part of.</p> <p>As from Erlang/OTP 17, the OTP release number corresponds to
the major OTP version number. No
<strong>erlang:system_info()</strong> argument gives the exact OTP
version. This is because the exact OTP version in the general case
is difficult to determine. For more information, see the
description of versions in
<a href="./versions"> System principles</a> in System Documentation.</p> </dd><dt><a name="system_info_port_parallelism"></a> <strong>port_parallelism</strong></dt><dd> <p>Returns the default port parallelism scheduling hint used.
For more information, see command-line argument
<a href="./erl#+spp">erl#+spp</a>
in <strong>erl(1)</strong>.</p> </dd><dt><a name="system_info_system_architecture"></a> <strong>system_architecture</strong></dt><dd> <p>Returns a string containing the processor and OS
architecture the emulator is built for.</p> </dd><dt><a name="system_info_system_logger"></a> <strong>system_logger</strong></dt><dd> <p>Returns the current <strong>system_logger</strong> as set by
<a href="#system_flag/2">system_flag/2</a>.</p> </dd><dt><a name="system_info_system_version"></a> <strong>system_version</strong></dt><dd> <p>Returns a string containing version number and
some important properties, such as the number of schedulers.</p> </dd><dt><a name="system_info_trace_control_word"></a> <strong>trace_control_word</strong></dt><dd> <p>Returns the value of the node trace control word. For
more information, see function <strong>get_tcw</strong> in section
<a href="../erts/match_spec#get_tcw"> Match Specifications in Erlang</a> in the User's Guide.</p> </dd><dt><a name="system_info_version"></a> <strong>version</strong></dt><dd> <p>Returns a string containing the version number of the
emulator.</p> </dd><dt><a name="system_info_wordsize"></a> <strong>wordsize</strong></dt><dd> <p>Same as <strong>{wordsize, internal}</strong>.</p> </dd><dt><strong>{wordsize, internal}</strong></dt><dd> <p>Returns the size of Erlang term words in bytes as an
integer, that is, 4 is returned on a 32-bit architecture,
and 8 is returned on a pure 64-bit architecture. On a
halfword 64-bit emulator, 4 is returned, as the Erlang
terms are stored using a virtual word size of half the
system word size.</p> </dd><dt><strong>{wordsize, external}</strong></dt><dd> <p>Returns the true word size of the emulator, that is,
the size of a pointer. The value is given in bytes
as an integer. On a pure 32-bit architecture, 4 is
returned. On both a half word and on a pure
64-bit architecture, 8 is returned.</p> </dd></dl><h4>system_monitor/0</h4><p>Current system performance monitoring settings.</p><ul><li>system_monitor_option</li></ul><p>Returns the current system monitoring settings set by
<a href="#system_monitor/2">system_monitor/2</a>
as <strong>{<span class="anno">MonitorPid</span>, <span class="anno">Options</span>}</strong>,
or <strong>undefined</strong> if no settings exist. The order of the
options can be different from the one that was set.</p><h4>system_monitor/1</h4><p>Set or clear system performance monitoring options.</p><ul><li>system_monitor_option</li></ul><p>When called with argument <strong>undefined</strong>, all
system performance monitoring settings are cleared.</p><p>Calling the function with <strong>{<span class="anno">MonitorPid</span>, <span class="anno">Options</span>}</strong> as argument is the same as calling
<a href="#system_monitor/2">system_monitor/2</a>.</p><p>Returns the previous system monitor settings just like
<a href="#system_monitor/0">system_monitor/0</a>.</p><h4>system_monitor/2</h4><p>Set system performance monitoring options.</p><ul><li>system_monitor_option</li></ul><p>Sets the system performance monitoring options.
<strong><span class="anno">MonitorPid</span></strong> is a local process identifier (pid)
receiving system monitor messages. The
second argument is a list of monitoring options:</p><dl><dt><strong>{long_gc, Time}</strong></dt><dd> <p>If a garbage collection in the system takes at least
<strong>Time</strong> wall clock milliseconds, a message
<strong>{monitor, GcPid, long_gc, Info}</strong> is sent to
<strong><span class="anno">MonitorPid</span></strong>. <strong>GcPid</strong> is the pid that
was garbage collected. <strong>Info</strong> is a list of two-element
tuples describing the result of the garbage collection.</p> <p>One of the tuples is <strong>{timeout, GcTime}</strong>, where
<strong>GcTime</strong> is the time for the garbage
collection in milliseconds. The other tuples are
tagged with <strong>heap_size</strong>, <strong>heap_block_size</strong>,
<strong>stack_size</strong>, <strong>mbuf_size</strong>, <strong>old_heap_size</strong>,
and <strong>old_heap_block_size</strong>. These tuples are
explained in the description of trace message
<a href="#gc_minor_start">gc_minor_start</a>
(see <a href="#trace/3">trace/3</a>).
New tuples can be added, and the order of the tuples in
the <strong>Info</strong> list can be changed at any time without
prior notice.</p> </dd><dt><strong>{long_schedule, Time}</strong></dt><dd> <p>If a process or port in the system runs uninterrupted
for at least <strong>Time</strong> wall clock milliseconds, a
message <strong>{monitor, PidOrPort, long_schedule, Info}</strong>
is sent to <strong>MonitorPid</strong>. <strong>PidOrPort</strong> is the
process or port that was running. <strong>Info</strong> is a
list of two-element tuples describing the event.</p> <p>If a <strong>pid()</strong>, the tuples <strong>{timeout, Millis}</strong>,
<strong>{in, Location}</strong>, and <strong>{out, Location}</strong> are
present, where <strong>Location</strong> is either an MFA
(<strong>{Module, Function, Arity}</strong>) describing the
function where the process was scheduled in/out, or the
atom <strong>undefined</strong>.</p> <p>If a <strong>port()</strong>, the
tuples <strong>{timeout, Millis}</strong> and <strong>{port_op,Op}</strong>
are present. <strong>Op</strong> is one of <strong>proc_sig</strong>,
<strong>timeout</strong>, <strong>input</strong>, <strong>output</strong>,
<strong>event</strong>, or <strong>dist_cmd</strong>, depending on which
driver callback was executing.</p> <p><strong>proc_sig</strong> is an
internal operation and is never to appear, while the
others represent the corresponding driver callbacks
<strong>timeout</strong>, <strong>ready_input</strong>, <strong>ready_output</strong>,
<strong>event</strong>, and <strong>outputv</strong> (when the port
is used by distribution). Value <strong>Millis</strong> in
tuple <strong>timeout</strong> informs about the
uninterrupted execution time of the process or port, which
always is equal to or higher than the <strong>Time</strong> value
supplied when starting the trace. New tuples can be
added to the <strong>Info</strong> list in a future release. The
order of the tuples in the list can be changed at any
time without prior notice.</p> <p>This can be used to detect problems with NIFs or
drivers that take too long to execute. 1 ms is
considered a good maximum time for a driver callback
or a NIF. However, a time-sharing system is usually to
consider everything &lt; 100 ms as "possible" and
fairly "normal". However, longer schedule times can
indicate swapping or a misbehaving NIF/driver.
Misbehaving NIFs and drivers can cause bad resource
utilization and bad overall system performance.</p> </dd><dt><strong>{large_heap, Size}</strong></dt><dd> <p>If a garbage collection in the system results in
the allocated size of a heap being at least <strong>Size</strong>
words, a message <strong>{monitor, GcPid, large_heap, Info}</strong>
is sent to <strong><span class="anno">MonitorPid</span></strong>.
<strong>GcPid</strong> and <strong>Info</strong>
are the same as for <strong>long_gc</strong> earlier, except that
the tuple tagged with <strong>timeout</strong> is not present.</p> <p>The monitor message is sent if the sum of the sizes of
all memory blocks allocated for all heap generations after
a garbage collection is equal to or higher than <strong>Size</strong>.</p> <p>When a process is killed by
<a href="#process_flag_max_heap_size">process_flag_max_heap_size</a>, it is killed before the
garbage collection is complete and thus no large heap message
is sent.</p> </dd><dt><strong>busy_port</strong></dt><dd> <p>If a process in the system gets suspended because it
sends to a busy port, a message
<strong>{monitor, SusPid, busy_port, Port}</strong> is sent to
<strong><span class="anno">MonitorPid</span></strong>. <strong>SusPid</strong> is the pid
that got suspended when sending to <strong>Port</strong>.</p> </dd><dt><strong>busy_dist_port</strong></dt><dd> <p>If a process in the system gets suspended because it
sends to a process on a remote node whose inter-node
communication was handled by a busy port, a message
<strong>{monitor, SusPid, busy_dist_port, Port}</strong> is sent to
<strong><span class="anno">MonitorPid</span></strong>. <strong>SusPid</strong> is the pid
that got suspended when sending through the inter-node
communication port <strong>Port</strong>.</p> </dd></dl><p>Returns the previous system monitor settings just like
<a href="#system_monitor/0">system_monitor/0</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If a monitoring process gets so large that it itself
starts to cause system monitor messages when garbage
collecting, the messages enlarge the process
message queue and probably make the problem worse.</p><p>Keep the monitoring process neat and do not set the system
monitor limits too tight.</p></div><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">MonitorPid</span></strong> does not exist.</dd><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">MonitorPid</span></strong> is not a local process.</dd></dl><h4>system_profile/0</h4><p>Current system profiling settings.</p><ul><li>system_profile_option</li></ul><p>Returns the current system profiling settings set by
<a href="#system_profile/2">system_profile/2</a>
as <strong>{<span class="anno">ProfilerPid</span>, <span class="anno">Options</span>}</strong>,
or <strong>undefined</strong> if there
are no settings. The order of the options can be different
from the one that was set.</p><h4>system_profile/2</h4><p>Current system profiling settings.</p><ul><li>system_profile_option</li></ul><p>Sets system profiler options. <strong><span class="anno">ProfilerPid</span></strong>
is a local process identifier (pid) or port receiving profiling
messages. The receiver is excluded from all profiling.
The second argument is a list of profiling options:</p><dl><dt><strong>exclusive</strong></dt><dd> <p>If a synchronous call to a port from a process is done, the
calling process is considered not runnable during the call
runtime to the port. The calling process is notified as
<strong>inactive</strong>, and later <strong>active</strong> when the port
callback returns.</p> </dd><dt><strong>monotonic_timestamp</strong></dt><dd> <p>Time stamps in profile messages use
<a href="./time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a>. The time stamp (Ts) has the same
format and value as produced by
<strong>erlang:monotonic_time(nanosecond)</strong>.</p> </dd><dt><strong>runnable_procs</strong></dt><dd> <p>If a process is put into or removed from the run queue, a
message, <strong>{profile, Pid, State, Mfa, Ts}</strong>, is sent to
<strong><span class="anno">ProfilerPid</span></strong>. Running processes that
are reinserted into the run queue after having been
pre-empted do not trigger this message.</p> </dd><dt><strong>runnable_ports</strong></dt><dd> <p>If a port is put into or removed from the run queue, a 
message, <strong>{profile, Port, State, 0, Ts}</strong>, is sent to
<strong><span class="anno">ProfilerPid</span></strong>.</p> </dd><dt><strong>scheduler</strong></dt><dd> <p>If a scheduler is put to sleep or awoken, a message,
<strong>{profile, scheduler, Id, State, NoScheds, Ts}</strong>, is
sent to <strong><span class="anno">ProfilerPid</span></strong>.</p> </dd><dt><strong>strict_monotonic_timestamp</strong></dt><dd> <p>Time stamps in profile messages consist of
<a href="./time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a> and a monotonically increasing
integer. The time stamp (Ts) has the same format and value
as produced by <strong>{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}</strong>.</p> </dd><dt><strong>timestamp</strong></dt><dd> <p>Time stamps in profile messages include a
time stamp (Ts) that has the same form as returned by
<strong>erlang:now()</strong>. This is also the default if no
time stamp flag is specified. If <strong>cpu_timestamp</strong> has
been enabled through
<a href="#trace/3">trace/3</a>,
this also effects the time stamp produced in profiling messages
when flag <strong>timestamp</strong> is enabled.</p> </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><strong>erlang:system_profile</strong> behavior can change
in a future release.</p></div><h4>system_time/0</h4><p>Current Erlang system time.</p><p>Returns current
<a href="./time_correction#Erlang_System_Time"> Erlang system time</a> in <strong>native</strong>
<a href="#type_time_unit">time unit</a>.</p><p>Calling <strong>erlang:system_time()</strong> is equivalent to
<a href="#monotonic_time/0">monotonic_time/0</a><strong> + </strong><a href="#time_offset/0">time_offset/0</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This time is <em>not</em> a monotonically increasing time
in the general case. For more information, see the documentation of
<a href="./time_correction#Time_Warp_Modes"> time warp modes</a> in the User's Guide.</p></div><h4>system_time/1</h4><p>Current Erlang system time.</p><p>Returns current
<a href="./time_correction#Erlang_System_Time"> Erlang system time</a>
converted into the <strong><span class="anno">Unit</span></strong> passed as argument.</p><p>Calling <strong>erlang:system_time(<span class="anno">Unit</span>)</strong> is equivalent
to <a href="#convert_time_unit/3">convert_time_unit/3</a><strong>(</strong><a href="#system_time/0">system_time/0</a><strong>, native, <span class="anno">Unit</span>)</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This time is <em>not</em> a monotonically increasing time
in the general case. For more information, see the documentation of
<a href="./time_correction#Time_Warp_Modes"> time warp modes</a> in the User's Guide.</p></div><h4>term_to_binary/1</h4><p>Encode a term to an Erlang external term format binary. </p><p>Returns a binary data object that is the result of encoding
<strong><span class="anno">Term</span></strong> according to the
<a href="./erl_ext_dist">Erlang external term format.</a></p><p>This can be used for various purposes, for example,
writing a term to a file in an efficient way, or sending an
Erlang term to some type of communications channel not
supported by distributed Erlang.</p><pre>
&gt; <span class="input">Bin = term_to_binary(hello).</span>
&lt;&lt;131,100,0,5,104,101,108,108,111&gt;&gt;
&gt; <span class="input">hello = binary_to_term(Bin).</span>
hello
</pre><p>See also <a href="#binary_to_term/1">binary_to_term/1</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>There is no guarantee that this function will return
the same encoded representation for the same term.</p></div><h4>term_to_binary/2</h4><p>Encode a term to en Erlang external term format binary. </p><p>Returns a binary data object that is the result of encoding
<strong><span class="anno">Term</span></strong> according to the Erlang external
term format.</p><p>If option <strong>compressed</strong> is provided, the external term
format is compressed. The compressed format is automatically
recognized by <strong>binary_to_term/1</strong> as from Erlang/OTP R7B.</p><p>A compression level can be specified by giving option
<strong>{compressed, <span class="anno">Level</span>}</strong>.
<strong><span class="anno">Level</span></strong> is an integer
with range 0..9, where:</p><ul><li><p><strong>0</strong> - No compression is done (it is the same as
giving no <strong>compressed</strong> option).</p></li><li><p><strong>1</strong> - Takes least time but may not compress
as well as the higher levels.</p></li><li><p><strong>6</strong> - Default level when option <strong>compressed</strong>
is provided.</p></li><li><p><strong>9</strong> - Takes most time and tries to produce a smaller
result. Notice "tries" in the preceding sentence; depending
on the input term, level 9 compression either does or does
not produce a smaller result than level 1 compression.</p></li></ul><p>Option <strong>{minor_version, <span class="anno">Version</span>}</strong>
can be used to control some
encoding details. This option was introduced in Erlang/OTP R11B-4.
The valid values for <strong><span class="anno">Version</span></strong> are:</p><dl><dt><strong>0</strong></dt><dd> <p>Floats are encoded using a textual representation.
This option is useful to ensure that releases before Erlang/OTP
R11B-4 can decode resulting binary.</p> <p>This version encode atoms that can be represented by a
latin1 string using latin1 encoding while only atoms that
cannot be represented by latin1 are encoded using utf8.</p> </dd><dt><strong>1</strong></dt><dd> <p>This is as of Erlang/OTP 17.0 the default. It forces any floats
in the term to be encoded in a more space-efficient and exact way
(namely in the 64-bit IEEE format, rather than converted to a
textual representation). As from Erlang/OTP R11B-4,
<strong>binary_to_term/1</strong> can decode this representation.</p> <p>This version encode atoms that can be represented by a
latin1 string using latin1 encoding while only atoms that
cannot be represented by latin1 are encoded using utf8.</p> </dd><dt><strong>2</strong></dt><dd> <p>Drops usage of the latin1 atom encoding and unconditionally
use utf8 encoding for all atoms. This will be changed to the
default in a future major release of Erlang/OTP. Erlang/OTP
systems as of R16B can decode this representation.</p> </dd></dl><p>See also <a href="#binary_to_term/1">binary_to_term/1</a>.</p><h4>throw/1</h4><p>Throw an exception.</p><p>A non-local return from a function. If evaluated within a
<strong>catch</strong>, <strong>catch</strong> returns value <strong><span class="anno">Any</span></strong>.
Example:</p><pre>
&gt; <span class="input">catch throw({hello, there}).</span>
{hello,there}</pre><p>Failure: <strong>nocatch</strong> if not evaluated within a catch.</p><h4>time/0</h4><p>Current time.</p><p>Returns the current time as <strong>{Hour, Minute, Second}</strong>.</p><p>The time zone and Daylight Saving Time correction depend on
the underlying OS. Example:</p><pre>
&gt; <span class="input">time().</span>
{9,42,44}</pre><h4>time_offset/0</h4><p>Current time offset.</p><p>Returns the current time offset between
<a href="./time_correction#Erlang_Monotonic_Time"> Erlang monotonic time</a> and
<a href="./time_correction#Erlang_System_Time"> Erlang system time</a> in
<strong>native</strong> <a href="#type_time_unit">time unit</a>.
Current time offset added to an Erlang monotonic time gives
corresponding Erlang system time.</p><p>The time offset may or may not change during operation depending
on the <a href="./time_correction#Time_Warp_Modes">time warp mode</a> used.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>A change in time offset can be observed at slightly
different points in time by different processes.</p><p>If the runtime system is in
<a href="./time_correction#Multi_Time_Warp_Mode">multi-time warp mode</a>, the time offset is changed when
the runtime system detects that the
<a href="./time_correction#OS_System_Time">OS system time</a> has changed. The runtime system will, however,
not detect this immediately when it occurs. A task checking
the time offset is scheduled to execute at least once a minute;
so, under normal operation this is to be detected within a
minute, but during heavy load it can take longer time.</p></div><h4>time_offset/1</h4><p>Current time offset.</p><p>Returns the current time offset between
<a href="./time_correction#Erlang_Monotonic_Time"> Erlang monotonic time</a> and
<a href="./time_correction#Erlang_System_Time"> Erlang system time</a>
converted into the <strong><span class="anno">Unit</span></strong> passed as argument.</p><p>Same as calling
<a href="#convert_time_unit/3">convert_time_unit/3</a><strong>(</strong><a href="#time_offset/0">time_offset/0</a><strong>, native, <span class="anno">Unit</span>)</strong>
however optimized for commonly used <strong><span class="anno">Unit</span></strong>s.</p><h4>timestamp/0</h4><p>Current Erlang System time.</p><ul><li>timestamp</li></ul><p>Returns current
<a href="./time_correction#Erlang_System_Time"> Erlang system time</a>
on the format <strong>{MegaSecs, Secs, MicroSecs}</strong>. This format is 
the same as <a href="../kernel/os#timestamp/0">kernel/os#timestamp/0</a>
and the deprecated <a href="#now/0">now/0</a>
use. The reason for the existence of <strong>erlang:timestamp()</strong> is
purely to simplify use for existing code that assumes this time stamp
format. Current Erlang system time can more efficiently be retrieved
in the time unit of your choice using
<a href="#system_time/1">system_time/1</a>.</p><p>The <strong>erlang:timestamp()</strong> BIF is equivalent to:</p><pre><code class="">
timestamp() -&gt;
    ErlangSystemTime = erlang:system_time(microsecond),
    MegaSecs = ErlangSystemTime div 1000000000000,
    Secs = ErlangSystemTime div 1000000 - MegaSecs*1000000,
    MicroSecs = ErlangSystemTime rem 1000000,
    {MegaSecs, Secs, MicroSecs}.</code></pre><p>It, however, uses a native implementation that does
not build garbage on the heap and with slightly better
performance.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This time is <em>not</em> a monotonically increasing time
in the general case. For more information, see the documentation of
<a href="./time_correction#Time_Warp_Modes"> time warp modes</a> in the User's Guide.</p></div><h4>tl/1</h4><p>Tail of a list.</p><p>Returns the tail of <strong><span class="anno">List</span></strong>, that is,
the list minus the first element, for example:</p><pre>
&gt; <span class="input">tl([geesties, guilies, beasties]).</span>
[guilies, beasties]</pre><p>Allowed in guard tests.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">List</span></strong>
is the empty list <strong>[]</strong>.</p><h4>trace/3</h4><p>Set trace flags for a process or processes.</p><ul><li>trace_flag</li></ul><p>Turns on (if <strong><span class="anno">How</span> == true</strong>) or off (if
<strong><span class="anno">How</span> == false</strong>) the trace flags in
<strong><span class="anno">FlagList</span></strong> for
the process or processes represented by
<strong><span class="anno">PidPortSpec</span></strong>.</p><p><strong><span class="anno">PidPortSpec</span></strong> is either a process identifier
(pid) for a local process, a port identifier,
or one of the following atoms:</p><dl><dt><strong>all</strong></dt><dd>All currently existing processes and ports and all that will be created in the future. </dd><dt><strong>processes</strong></dt><dd>All currently existing processes and all that will be created in the future. </dd><dt><strong>ports</strong></dt><dd>All currently existing ports and all that will be created in the future. </dd><dt><strong>existing</strong></dt><dd>All currently existing processes and ports. </dd><dt><strong>existing_processes</strong></dt><dd>All currently existing processes. </dd><dt><strong>existing_ports</strong></dt><dd>All currently existing ports. </dd><dt><strong>new</strong></dt><dd>All processes and ports that will be created in the future. </dd><dt><strong>new_processes</strong></dt><dd>All processes that will be created in the future. </dd><dt><strong>new_ports</strong></dt><dd>All ports that will be created in the future. </dd></dl><p><strong><span class="anno">FlagList</span></strong> can contain any number of the
following flags (the "message tags" refers to the list of
<a href="#trace_3_trace_messages">trace_3_trace_messages</a>):</p><dl><dt><strong>all</strong></dt><dd> <p>Sets all trace flags except <strong>tracer</strong> and
<strong>cpu_timestamp</strong>, which are in their nature different
than the others.</p> </dd><dt><strong>send</strong></dt><dd> <p>Traces sending of messages.</p> <p>Message tags:
<a href="#trace_3_trace_messages_send">trace_3_trace_messages_send</a> and
<a href="#trace_3_trace_messages_send_to_non_existing_process">trace_3_trace_messages_send_to_non_existing_process</a>.</p> </dd><dt><strong>'receive'</strong></dt><dd> <p>Traces receiving of messages.</p> <p>Message tags:
<a href="#trace_3_trace_messages_receive">trace_3_trace_messages_receive</a>.</p> </dd><dt><strong>call</strong></dt><dd> <p>Traces certain function calls. Specify which function
calls to trace by calling <a href="#trace_pattern/3">trace_pattern/3</a>.</p> <p>Message tags:
<a href="#trace_3_trace_messages_call">trace_3_trace_messages_call</a> and
<a href="#trace_3_trace_messages_return_from">trace_3_trace_messages_return_from</a>.</p> </dd><dt><strong>silent</strong></dt><dd> <p>Used with the <strong>call</strong> trace flag.
The <strong>call</strong>, <strong>return_from</strong>, and <strong>return_to</strong>
trace messages are inhibited if this flag is set, but they
are executed as normal if there are match specifications.</p> <p>Silent mode is inhibited by executing
<strong>erlang:trace(_, false, [silent|_])</strong>,
or by a match specification executing the function
<strong>{silent, false}</strong>.</p> <p>The <strong>silent</strong> trace flag facilitates setting up
a trace on many or even all processes in the system.
The trace can then be activated and deactivated using the match
specification function <strong>{silent,Bool}</strong>, giving
a high degree of control of which functions with which 
arguments that trigger the trace.</p> <p>Message tags:
<a href="#trace_3_trace_messages_call">trace_3_trace_messages_call</a>,
<a href="#trace_3_trace_messages_return_from">trace_3_trace_messages_return_from</a>, and
<a href="#trace_3_trace_messages_return_to">trace_3_trace_messages_return_to</a>. Or rather, the absence of.</p> </dd><dt><strong>return_to</strong></dt><dd> <p>Used with the <strong>call</strong> trace flag.
Traces the return from a traced function back to
its caller. Only works for functions traced with
option <strong>local</strong> to <a href="#trace_pattern/3">trace_pattern/3</a>.</p> <p>The semantics is that a trace message is sent when a
call traced function returns, that is, when a
chain of tail recursive calls ends. Only one trace
message is sent per chain of tail recursive calls,
so the properties of tail recursiveness for
function calls are kept while tracing with this flag.
Using <strong>call</strong> and <strong>return_to</strong> trace together
makes it possible to know exactly in which function a
process executes at any time.</p> <p>To get trace messages containing return values from
functions, use the <strong>{return_trace}</strong> match
specification action instead.</p> <p>Message tags:
<a href="#trace_3_trace_messages_return_to">trace_3_trace_messages_return_to</a>.</p> </dd><dt><strong>procs</strong></dt><dd> <p>Traces process-related events.</p> <p>Message tags:
<a href="#trace_3_trace_messages_spawn">trace_3_trace_messages_spawn</a>,
<a href="#trace_3_trace_messages_spawned">trace_3_trace_messages_spawned</a>,
<a href="#trace_3_trace_messages_exit">trace_3_trace_messages_exit</a>,
<a href="#trace_3_trace_messages_register">trace_3_trace_messages_register</a>,
<a href="#trace_3_trace_messages_unregister">trace_3_trace_messages_unregister</a>,
<a href="#trace_3_trace_messages_link">trace_3_trace_messages_link</a>,
<a href="#trace_3_trace_messages_unlink">trace_3_trace_messages_unlink</a>,
<a href="#trace_3_trace_messages_getting_linked">trace_3_trace_messages_getting_linked</a>, and
<a href="#trace_3_trace_messages_getting_unlinked">trace_3_trace_messages_getting_unlinked</a>.</p> </dd><dt><strong>ports</strong></dt><dd> <p>Traces port-related events.</p> <p>Message tags:
<a href="#trace_3_trace_messages_open">trace_3_trace_messages_open</a>,
<a href="#trace_3_trace_messages_closed">trace_3_trace_messages_closed</a>,
<a href="#trace_3_trace_messages_register">trace_3_trace_messages_register</a>,
<a href="#trace_3_trace_messages_unregister">trace_3_trace_messages_unregister</a>,
<a href="#trace_3_trace_messages_getting_linked">trace_3_trace_messages_getting_linked</a>, and
<a href="#trace_3_trace_messages_getting_unlinked">trace_3_trace_messages_getting_unlinked</a>.</p> </dd><dt><strong>running</strong></dt><dd> <p>Traces scheduling of processes.</p> <p>Message tags:
<a href="#trace_3_trace_messages_in_proc">trace_3_trace_messages_in_proc</a> and
<a href="#trace_3_trace_messages_out_proc">trace_3_trace_messages_out_proc</a>.</p> </dd><dt><strong>exiting</strong></dt><dd> <p>Traces scheduling of exiting processes.</p> <p>Message tags:
<a href="#trace_3_trace_messages_in_exiting_proc">trace_3_trace_messages_in_exiting_proc</a>,
<a href="#trace_3_trace_messages_out_exiting_proc">trace_3_trace_messages_out_exiting_proc</a>, and
<a href="#trace_3_trace_messages_out_exited_proc">trace_3_trace_messages_out_exited_proc</a>.</p> </dd><dt><strong>running_procs</strong></dt><dd> <p>Traces scheduling of processes just like <strong>running</strong>.
However, this option also includes schedule events when the
process executes within the context of a port without
being scheduled out itself.</p> <p>Message tags:
<a href="#trace_3_trace_messages_in_proc">trace_3_trace_messages_in_proc</a> and
<a href="#trace_3_trace_messages_out_proc">trace_3_trace_messages_out_proc</a>.</p> </dd><dt><strong>running_ports</strong></dt><dd> <p>Traces scheduling of ports.</p> <p>Message tags:
<a href="#trace_3_trace_messages_in_port">trace_3_trace_messages_in_port</a> and
<a href="#trace_3_trace_messages_out_port">trace_3_trace_messages_out_port</a>.</p> </dd><dt><strong>garbage_collection</strong></dt><dd> <p>Traces garbage collections of processes.</p> <p>Message tags:
<a href="#trace_3_trace_messages_gc_minor_start">trace_3_trace_messages_gc_minor_start</a>,
<a href="#trace_3_trace_messages_gc_max_heap_size">trace_3_trace_messages_gc_max_heap_size</a>, and
<a href="#trace_3_trace_messages_gc_minor_end">trace_3_trace_messages_gc_minor_end</a>.</p> </dd><dt><strong>timestamp</strong></dt><dd> <p>Includes a time stamp in all trace messages. The
time stamp (Ts) has the same form as returned by
<strong>erlang:now()</strong>.</p> </dd><dt><strong>cpu_timestamp</strong></dt><dd> <p>A global trace flag for the Erlang node that makes all
trace time stamps using flag <strong>timestamp</strong> to be
in CPU time, not wall clock time. That is, <strong>cpu_timestamp</strong>
is not be used if <strong>monotonic_timestamp</strong> or
<strong>strict_monotonic_timestamp</strong> is enabled.
Only allowed with <strong><span class="anno">PidPortSpec</span>==all</strong>. If the
host machine OS does not support high-resolution
CPU time measurements, <strong>trace/3</strong> exits with
<strong>badarg</strong>. Notice that most OS do
not synchronize this value across cores, so be prepared
that time can seem to go backwards when using this option.</p> </dd><dt><strong>monotonic_timestamp</strong></dt><dd> <p>Includes an
<a href="./time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a> time stamp in all trace messages. The
time stamp (Ts) has the same format and value as produced by
<a href="#monotonic_time-1">monotonic_time-1</a>.
This flag overrides flag <strong>cpu_timestamp</strong>.</p> </dd><dt><strong>strict_monotonic_timestamp</strong></dt><dd> <p>Includes an time stamp consisting of
<a href="./time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a> and a monotonically increasing
integer in all trace messages. The time stamp (Ts) has the
same format and value as produced by <strong>{</strong>
<a href="#monotonic_time-1">monotonic_time-1</a><strong>,</strong>
<a href="#unique_integer-1">unique_integer-1</a><strong>}</strong>.
This flag overrides flag <strong>cpu_timestamp</strong>.</p> </dd><dt><strong>arity</strong></dt><dd> <p>Used with the <strong>call</strong> trace flag.
<strong>{M, F, Arity}</strong> is specified instead of
<strong>{M, F, Args}</strong> in call trace messages.</p> </dd><dt><strong>set_on_spawn</strong></dt><dd> <p>Makes any process created by a traced process inherit
its trace flags, including flag <strong>set_on_spawn</strong>.</p> </dd><dt><strong>set_on_first_spawn</strong></dt><dd> <p>Makes the first process created by a traced process
inherit its trace flags, excluding flag
<strong>set_on_first_spawn</strong>.</p> </dd><dt><strong>set_on_link</strong></dt><dd> <p>Makes any process linked by a traced process inherit its
trace flags, including flag <strong>set_on_link</strong>.</p> </dd><dt><strong>set_on_first_link</strong></dt><dd> <p>Makes the first process linked to by a traced process
inherit its trace flags, excluding flag
<strong>set_on_first_link</strong>.</p> </dd><dt><strong>{tracer, Tracer}</strong></dt><dd> <p>Specifies where to send the trace messages. <strong>Tracer</strong>
must be the process identifier of a local process
or the port identifier of a local port.</p> </dd><dt><strong>{tracer, TracerModule, TracerState}</strong></dt><dd> <p>Specifies that a tracer module is to be called
instead of sending a trace message. The tracer module
can then ignore or change the trace message. For more details
on how to write a tracer module, see
<a href="./erl_tracer">erts/erl_tracer</a>.</p> </dd></dl><p>If no <strong>tracer</strong> is specified, the calling process
receives all the trace messages.</p><p>The effect of combining <strong>set_on_first_link</strong> with
<strong>set_on_link</strong> is the same as
<strong>set_on_first_link</strong> alone. Likewise for
<strong>set_on_spawn</strong> and <strong>set_on_first_spawn</strong>.</p><p>The tracing process receives the <em>trace messages</em> described
in the following list. <strong>Pid</strong> is the process identifier of the
traced process in which the traced event has occurred. The
third tuple element is the message tag.</p><p>If flag <strong>timestamp</strong>, <strong>strict_monotonic_timestamp</strong>, or
<strong>monotonic_timestamp</strong> is specified, the first tuple
element is <strong>trace_ts</strong> instead, and the time stamp
is added as an extra element last in the message tuple. If
multiple time stamp flags are passed, <strong>timestamp</strong> has
precedence over <strong>strict_monotonic_timestamp</strong>, which
in turn has precedence over <strong>monotonic_timestamp</strong>. All
time stamp flags are remembered, so if two are passed
and the one with highest precedence later is disabled,
the other one becomes active.</p><p>Trace messages:</p><a name="trace_3_trace_messages"></a><dl><dt> <a name="trace_3_trace_messages_send"></a> <strong>{trace, PidPort, send, Msg, To}</strong> </dt><dd> <p>When <strong>PidPort</strong> sends message <strong>Msg</strong> to
process <strong>To</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_send_to_non_existing_process"></a> <strong>{trace, PidPort, send_to_non_existing_process, Msg, To}</strong> </dt><dd> <p>When <strong>PidPort</strong> sends message <strong>Msg</strong> to
the non-existing process <strong>To</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_receive"></a> <strong>{trace, PidPort, 'receive', Msg}</strong> </dt><dd> <p>When <strong>PidPort</strong> receives message <strong>Msg</strong>.
If <strong>Msg</strong> is set to time-out, a receive
statement can have timed out, or the process received
a message with the payload <strong>timeout</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_call"></a> <strong>{trace, Pid, call, {M, F, Args}}</strong> </dt><dd> <p>When <strong>Pid</strong> calls a traced function. The return
values of calls are never supplied, only the call and its
arguments.</p> <p>Trace flag <strong>arity</strong> can be used to
change the contents of this message, so that <strong>Arity</strong>
is specified instead of <strong>Args</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_return_to"></a> <strong>{trace, Pid, return_to, {M, F, Arity}}</strong> </dt><dd> <p>When <strong>Pid</strong> returns <em>to</em> the specified
function. This trace message is sent if both
the flags <strong>call</strong> and <strong>return_to</strong> are set,
and the function is set to be traced on <em>local</em>
function calls. The message is only sent when returning
from a chain of tail recursive function calls, where at
least one call generated a <strong>call</strong> trace message
(that is, the functions match specification matched, and
<strong>{message, false}</strong> was not an action).</p> </dd><dt> <a name="trace_3_trace_messages_return_from"></a> <strong>{trace, Pid, return_from, {M, F, Arity}, ReturnValue}</strong> </dt><dd> <p>When <strong>Pid</strong> returns <em>from</em> the specified
function. This trace message is sent if flag <strong>call</strong>
is set, and the function has a match specification
with a <strong>return_trace</strong> or <strong>exception_trace</strong> action.</p> </dd><dt> <a name="trace_3_trace_messages_exception_from"></a> <strong>{trace, Pid, exception_from, {M, F, Arity}, {Class, Value}}</strong> </dt><dd> <p>When <strong>Pid</strong> exits <em>from</em> the specified
function because of an exception. This trace message is
sent if flag <strong>call</strong> is set, and the function has 
a match specification with an <strong>exception_trace</strong> action.</p> </dd><dt> <a name="trace_3_trace_messages_spawn"></a> <strong>{trace, Pid, spawn, Pid2, {M, F, Args}}</strong> </dt><dd> <p>When <strong>Pid</strong> spawns a new process <strong>Pid2</strong> with
the specified function call as entry point.</p> <p><strong>Args</strong> is supposed to be the argument list,
but can be any term if the spawn is erroneous.</p> </dd><dt> <a name="trace_3_trace_messages_spawned"></a> <strong>{trace, Pid, spawned, Pid2, {M, F, Args}}</strong> </dt><dd> <p>When <strong>Pid</strong> is spawned by process <strong>Pid2</strong> with
the specified function call as entry point.</p> <p><strong>Args</strong> is supposed to be the argument list,
but can be any term if the spawn is erroneous.</p> </dd><dt> <a name="trace_3_trace_messages_exit"></a> <strong>{trace, Pid, exit, Reason}</strong> </dt><dd> <p>When <strong>Pid</strong> exits with reason <strong>Reason</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_register"></a> <strong>{trace, PidPort, register, RegName}</strong> </dt><dd> <p>When <strong>PidPort</strong> gets the name <strong>RegName</strong> registered.</p> </dd><dt> <a name="trace_3_trace_messages_unregister"></a> <strong>{trace, PidPort, unregister, RegName}</strong> </dt><dd> <p>When <strong>PidPort</strong> gets the name <strong>RegName</strong> unregistered.
This is done automatically when a registered
process or port exits.</p> </dd><dt> <a name="trace_3_trace_messages_link"></a> <strong>{trace, Pid, link, Pid2}</strong> </dt><dd> <p>When <strong>Pid</strong> links to a process <strong>Pid2</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_unlink"></a> <strong>{trace, Pid, unlink, Pid2}</strong> </dt><dd> <p>When <strong>Pid</strong> removes the link from a process
<strong>Pid2</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_getting_linked"></a> <strong>{trace, PidPort, getting_linked, Pid2}</strong> </dt><dd> <p>When <strong>PidPort</strong> gets linked to a process <strong>Pid2</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_getting_unlinked"></a> <strong>{trace, PidPort, getting_unlinked, Pid2}</strong> </dt><dd> <p>When <strong>PidPort</strong> gets unlinked from a process <strong>Pid2</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_exit"></a> <strong>{trace, Pid, exit, Reason}</strong> </dt><dd> <p>When <strong>Pid</strong> exits with reason <strong>Reason</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_open"></a> <strong>{trace, Port, open, Pid, Driver}</strong> </dt><dd> <p>When <strong>Pid</strong> opens a new port <strong>Port</strong> with
the running <strong>Driver</strong>.</p> <p><strong>Driver</strong> is the name of the driver as an atom.</p> </dd><dt> <a name="trace_3_trace_messages_closed"></a> <strong>{trace, Port, closed, Reason}</strong> </dt><dd> <p>When <strong>Port</strong> closes with <strong>Reason</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_in_proc"></a> <a name="trace_3_trace_messages_in_exiting_proc"></a> <strong>{trace, Pid, in | in_exiting, {M, F, Arity} | 0}</strong> </dt><dd> <p>When <strong>Pid</strong> is scheduled to run. The process
runs in function <strong>{M, F, Arity}</strong>. On some rare
occasions, the current function cannot be determined,
then the last element is <strong>0</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_out_proc"></a> <a name="trace_3_trace_messages_out_exiting_proc"></a> <a name="trace_3_trace_messages_out_exited_proc"></a> <strong>{trace, Pid, out | out_exiting | out_exited, {M, F, Arity} | 0}</strong> </dt><dd> <p>When <strong>Pid</strong> is scheduled out. The process was
running in function {M, F, Arity}. On some rare occasions,
the current function cannot be determined, then the last
element is <strong>0</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_in_port"></a> <strong>{trace, Port, in, Command | 0}</strong> </dt><dd> <p>When <strong>Port</strong> is scheduled to run. <strong>Command</strong> is the
first thing the port will execute, it can however run several
commands before being scheduled out. On some rare
occasions, the current function cannot be determined,
then the last element is <strong>0</strong>.</p> <p>The possible commands are <strong>call</strong>, <strong>close</strong>,
<strong>command</strong>, <strong>connect</strong>, <strong>control</strong>, <strong>flush</strong>,
<strong>info</strong>, <strong>link</strong>, <strong>open</strong>, and <strong>unlink</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_out_port"></a> <strong>{trace, Port, out, Command | 0}</strong> </dt><dd> <p>When <strong>Port</strong> is scheduled out. The last command run
was <strong>Command</strong>. On some rare occasions,
the current function cannot be determined, then the last
element is <strong>0</strong>. <strong>Command</strong> can contain the same
commands as <strong>in</strong></p> </dd><dt> <a name="trace_3_trace_messages_gc_minor_start"></a> <strong>{trace, Pid, gc_minor_start, Info}</strong> </dt><dd> <a name="gc_minor_start"></a> <p>Sent when a young garbage collection is about to be started.
<strong>Info</strong> is a list of two-element tuples, where
the first element is a key, and the second is the value.
Do not depend on any order of the tuples.
The following keys are defined:</p> <dl><dt><strong>heap_size</strong></dt><dd>The size of the used part of the heap.</dd><dt><strong>heap_block_size</strong></dt><dd>The size of the memory block used for storing the heap and the stack.</dd><dt><strong>old_heap_size</strong></dt><dd>The size of the used part of the old heap.</dd><dt><strong>old_heap_block_size</strong></dt><dd>The size of the memory block used for storing the old heap.</dd><dt><strong>stack_size</strong></dt><dd>The size of the stack.</dd><dt><strong>recent_size</strong></dt><dd>The size of the data that survived the previous garbage collection.</dd><dt><strong>mbuf_size</strong></dt><dd>The combined size of message buffers associated with the process.</dd><dt><strong>bin_vheap_size</strong></dt><dd>The total size of unique off-heap binaries referenced from the process heap.</dd><dt><strong>bin_vheap_block_size</strong></dt><dd>The total size of binaries allowed in the virtual heap in the process before doing a garbage collection.</dd><dt><strong>bin_old_vheap_size</strong></dt><dd>The total size of unique off-heap binaries referenced from the process old heap.</dd><dt><strong>bin_old_vheap_block_size</strong></dt><dd>The total size of binaries allowed in the virtual old heap in the process before doing a garbage collection.</dd></dl> <p>All sizes are in words.</p> </dd><dt> <a name="trace_3_trace_messages_gc_max_heap_size"></a> <strong>{trace, Pid, gc_max_heap_size, Info}</strong> </dt><dd> <p>Sent when the <a href="#process_flag_max_heap_size">process_flag_max_heap_size</a>
is reached during garbage collection. <strong>Info</strong> contains the
same kind of list as in message <strong>gc_start</strong>,
but the sizes reflect the sizes that triggered
<strong>max_heap_size</strong> to be reached.</p> </dd><dt> <a name="trace_3_trace_messages_gc_minor_end"></a> <strong>{trace, Pid, gc_minor_end, Info}</strong> </dt><dd> <p>Sent when young garbage collection is finished. <strong>Info</strong>
contains the same kind of list as in message
<strong>gc_minor_start</strong>,
but the sizes reflect the new sizes after
garbage collection.</p> </dd><dt> <a name="trace_3_trace_messages_gc_major_start"></a> <strong>{trace, Pid, gc_major_start, Info}</strong> </dt><dd> <p>Sent when fullsweep garbage collection is about to be started.
<strong>Info</strong> contains the same kind of list as in message
<strong>gc_minor_start</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_gc_major_end"></a> <strong>{trace, Pid, gc_major_end, Info}</strong> </dt><dd> <p>Sent when fullsweep garbage collection is finished. <strong>Info</strong>
contains the same kind of list as in message
<strong>gc_minor_start</strong>, but the sizes reflect the new sizes after
a fullsweep garbage collection.</p> </dd></dl><p>If the tracing process/port dies or the tracer module returns
<strong>remove</strong>, the flags are silently removed.</p><p>Each process can only be traced by one tracer. Therefore,
attempts to trace an already traced process fail.</p><p>Returns a number indicating the number of processes that
matched <strong><span class="anno">PidPortSpec</span></strong>.
If <strong><span class="anno">PidPortSpec</span></strong> is a process
identifier, the return value is <strong>1</strong>.
If <strong><span class="anno">PidPortSpec</span></strong>
is <strong>all</strong> or <strong>existing</strong>, the return value is
the number of processes running.
If <strong><span class="anno">PidPortSpec</span></strong> is <strong>new</strong>, the return value is
<strong>0</strong>.</p><p>Failure: <strong>badarg</strong> if the specified arguments are
not supported. For example, <strong>cpu_timestamp</strong> is not
supported on all platforms.</p><h4>trace_delivered/1</h4><p>Notification when trace has been delivered.</p><p>The delivery of trace messages (generated by
<a href="#trace/3">trace/3</a>,
<a href="./seq_trace">kernel/seq_trace</a>,
or <a href="#system_profile/2">system_profile/2</a>)
is dislocated on the time-line
compared to other events in the system. If you know that
<strong><span class="anno">Tracee</span></strong> has passed some specific point
in its execution,
and you want to know when at least all trace messages
corresponding to events up to this point have reached the
tracer, use <strong>erlang:trace_delivered(<span class="anno">Tracee</span>)</strong>.</p><p>When it is guaranteed that all trace messages are delivered to
the tracer up to the point that <strong><span class="anno">Tracee</span></strong> reached
at the time of the call to
<strong>erlang:trace_delivered(<span class="anno">Tracee</span>)</strong>, then a
<strong>{trace_delivered, <span class="anno">Tracee</span>, <span class="anno">Ref</span>}</strong>
message is sent to the caller of
<strong>erlang:trace_delivered(<span class="anno">Tracee</span>)</strong> .</p><p>Notice that message <strong>trace_delivered</strong> does <em>not</em>
imply that trace messages have been delivered.
Instead it implies that all trace messages that
<em>are to be delivered</em> have been delivered.
It is not an error if <strong><span class="anno">Tracee</span></strong> is not, and
has not been traced by someone, but if this is the case,
<em>no</em> trace messages have been delivered when the
<strong>trace_delivered</strong> message arrives.</p><p>Notice that <strong><span class="anno">Tracee</span></strong> must refer
to a process currently
or previously existing on the same node as the caller of
<strong>erlang:trace_delivered(<span class="anno">Tracee</span>)</strong> resides on.
The special <strong><span class="anno">Tracee</span></strong> atom <strong>all</strong>
denotes all processes that currently are traced in the node.</p><p>When used together with a <a href="./erl_tracer"> Tracer Module</a>, any message sent in the trace callback
is guaranteed to have reached its recipient before the
<strong>trace_delivered</strong> message is sent.</p><p>Example: Process <strong>A</strong> is <strong><span class="anno">Tracee</span></strong>,
port <strong>B</strong> is tracer, and process <strong>C</strong> is the port
owner of <strong>B</strong>. <strong>C</strong> wants to close <strong>B</strong> when
<strong>A</strong> exits. To ensure that the trace is not truncated,
<strong>C</strong> can call <strong>erlang:trace_delivered(A)</strong> when
<strong>A</strong> exits, and wait for message <strong>{trace_delivered, A, <span class="anno">Ref</span>}</strong> before closing <strong>B</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Tracee</span></strong>
does not refer to a
process (dead or alive) on the same node as the caller of
<strong>erlang:trace_delivered(<span class="anno">Tracee</span>)</strong> resides on.</p><h4>trace_info/2</h4><p>Trace information about a process or function.</p><ul><li>trace_info_return</li></ul><ul><li>trace_info_item_result</li></ul><ul><li>trace_info_flag</li></ul><ul><li>trace_match_spec</li></ul><ul><li>match_variable</li></ul> Approximation of '$1' | '$2' | '$3' | ... <p>Returns trace information about a port, process, function, or
event.</p><p><em>To get information about a port or process</em>,
<strong><span class="anno">PidPortFuncEvent</span></strong> is to
be a process identifier (pid), port identifier, or one of
the atoms <strong>new</strong>, <strong>new_processes</strong>, or <strong>new_ports</strong>. The
atom <strong>new</strong> or <strong>new_processes</strong> means that the default trace
state for processes to be created is returned. The atom
<strong>new_ports</strong> means that the default trace state for ports to be
created is returned.</p><p>Valid <strong>Item</strong>s for ports and processes:</p><dl><dt><strong>flags</strong></dt><dd> <p>Returns a list of atoms indicating what kind of traces is
enabled for the process. The list is empty if no
traces are enabled, and one or more of the followings
atoms if traces are enabled: <strong>send</strong>,
<strong>'receive'</strong>, <strong>set_on_spawn</strong>, <strong>call</strong>,
<strong>return_to</strong>, <strong>procs</strong>, <strong>ports</strong>,
<strong>set_on_first_spawn</strong>,
<strong>set_on_link</strong>, <strong>running</strong>, <strong>running_procs</strong>,
<strong>running_ports</strong>, <strong>silent</strong>, <strong>exiting</strong>,
<strong>monotonic_timestamp</strong>, <strong>strict_monotonic_timestamp</strong>,
<strong>garbage_collection</strong>, <strong>timestamp</strong>, and
<strong>arity</strong>. The order is arbitrary.</p> </dd><dt><strong>tracer</strong></dt><dd> <p>Returns the identifier for process, port, or a tuple containing
the tracer module and tracer state tracing this
process. If this process is not traced, the return
value is <strong>[]</strong>.</p> </dd></dl><p><em>To get information about a function</em>,
<strong><span class="anno">PidPortFuncEvent</span></strong> is to
be the three-element tuple <strong>{Module, Function, Arity}</strong> or
the atom <strong>on_load</strong>. No wildcards are allowed. Returns
<strong>undefined</strong> if the function does not exist, or
<strong>false</strong> if the function is not traced.
If <strong><span class="anno">PidPortFuncEvent</span></strong>
is <strong>on_load</strong>, the information returned refers to
the default value for code that will be loaded.</p><p>Valid <strong>Item</strong>s for functions:</p><dl><dt><strong>traced</strong></dt><dd> <p>Returns <strong>global</strong> if this function is traced on
global function calls, <strong>local</strong> if this function is
traced on local function calls (that is, local and global
function calls), and <strong>false</strong> if local or
global function calls are not traced.</p> </dd><dt><strong>match_spec</strong></dt><dd> <p>Returns the match specification for this function, if it
has one. If the function is locally or globally traced but
has no match specification defined, the returned value
is <strong>[]</strong>.</p> </dd><dt><strong>meta</strong></dt><dd> <p>Returns the meta-trace tracer process, port, or trace module
for this function, if it has one. If the function is not
meta-traced, the returned value is <strong>false</strong>. If
the function is meta-traced but has once detected that
the tracer process is invalid, the returned value is
<strong>[]</strong>.</p> </dd><dt><strong>meta_match_spec</strong></dt><dd> <p>Returns the meta-trace match specification for this
function, if it has one. If the function is meta-traced
but has no match specification defined, the returned
value is <strong>[]</strong>.</p> </dd><dt><strong>call_count</strong></dt><dd> <p>Returns the call count value for this function or
<strong>true</strong> for the pseudo function <strong>on_load</strong> if call
count tracing is active. Otherwise <strong>false</strong> is returned.</p> <p>See also <a href="#trace_pattern/3">trace_pattern/3</a>.</p> </dd><dt><strong>call_time</strong></dt><dd> <p>Returns the call time values for this function or
<strong>true</strong> for the pseudo function <strong>on_load</strong> if call
time tracing is active. Otherwise <strong>false</strong> is returned.
The call time values returned, <strong>[{Pid, Count, S, Us}]</strong>,
is a list of each process that executed the function
and its specific counters.</p> <p>See also
<a href="#trace_pattern/3">trace_pattern/3</a>.</p> </dd><dt><strong>all</strong></dt><dd> <p>Returns a list containing the
<strong>{<span class="anno">Item</span>, Value}</strong> tuples
for all other items, or returns <strong>false</strong> if no tracing
is active for this function.</p> </dd></dl><p><em>To get information about an event</em>,
<strong><span class="anno">PidPortFuncEvent</span></strong> is to
be one of the atoms <strong>send</strong> or <strong>'receive'</strong>.</p><p>One valid <strong>Item</strong> for events exists:</p><dl><dt><strong>match_spec</strong></dt><dd> <p>Returns the match specification for this event, if it
has one, or <strong>true</strong> if no match specification has been
set.</p> </dd></dl><p>The return value is <strong>{<span class="anno">Item</span>, Value}</strong>, where
<strong>Value</strong> is the requested information as described earlier.
If a pid for a dead process was specified, or the name of a
non-existing function, <strong>Value</strong> is <strong>undefined</strong>.</p><h4>trace_pattern/2</h4><p>Set trace patterns for call, send, or 'receive' tracing. </p><ul><li>trace_pattern_mfa</li></ul><ul><li>trace_match_spec</li></ul> Approximation of '$1' | '$2' | '$3' | ... <ul><li>match_variable</li></ul><p>The same as
<a href="#trace_pattern/3">trace_pattern/3</a>,
retained for backward compatibility.</p><h4>trace_pattern/3</h4><p>Set trace pattern for message sending.</p><ul><li>trace_match_spec</li></ul><ul><li>match_variable</li></ul> Approximation of '$1' | '$2' | '$3' | ... <p>Sets trace pattern for <em>message sending</em>.
Must be combined with
<a href="#trace/3">trace/3</a>
to set the <strong>send</strong> trace flag for one or more processes.
By default all messages sent from <strong>send</strong> traced processes
are traced. To limit
traced send events based on the message content, the sender
and/or the receiver, use <strong>erlang:trace_pattern/3</strong>.</p><p>Argument <strong><span class="anno">MatchSpec</span></strong> can take the
following forms:</p><dl><dt><strong><span class="anno">MatchSpecList</span></strong></dt><dd> <p>A list of match specifications. The matching is done
on the list <strong>[Receiver, Msg]</strong>. <strong>Receiver</strong>
is the process or port identity of the receiver and
<strong>Msg</strong> is the message term. The pid of the sending
process can be accessed with the guard function
<strong>self/0</strong>. An empty list is the same as <strong>true</strong>.
For more information, see section
<a href="./match_spec"> Match Specifications in Erlang</a> in the User's Guide.</p> </dd><dt><strong>true</strong></dt><dd> <p>Enables tracing for all sent messages (from <strong>send</strong>
traced processes). Any match specification is
removed. <em>This is the default</em>.</p> </dd><dt><strong>false</strong></dt><dd> <p>Disables tracing for all sent messages.
Any match specification is removed.</p> </dd></dl><p>Argument <strong><span class="anno">FlagList</span></strong> must be <strong>[]</strong>
for send tracing.</p><p>The return value is always <strong>1</strong>.</p><p>Examples:</p><p>Only trace messages to a specific process <strong>Pid</strong>:</p><pre>
&gt; <span class="input">erlang:trace_pattern(send, [{[Pid, '_'],[],[]}], []).</span>
1</pre><p>Only trace messages matching <strong>{reply, _}</strong>:</p><pre>
&gt; <span class="input">erlang:trace_pattern(send, [{['_', {reply,'_'}],[],[]}], []).</span>
1</pre><p>Only trace messages sent to the sender itself:</p><pre>
&gt; <span class="input">erlang:trace_pattern(send, [{['$1', '_'],[{'=:=','$1',{self}}],[]}], []).</span>
1</pre><p>Only trace messages sent to other nodes:</p><pre>
&gt; <span class="input">erlang:trace_pattern(send, [{['$1', '_'],[{'=/=',{node,'$1'},{node}}],[]}], []).</span>
1</pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>A match specification for <strong>send</strong> trace can use
all guard and body functions except <strong>caller</strong>.</p></div><h4>trace_pattern/3</h4><p>Set trace pattern for tracing of message receiving.</p><ul><li>trace_match_spec</li></ul><ul><li>match_variable</li></ul> Approximation of '$1' | '$2' | '$3' | ... <p>Sets trace pattern for <em>message receiving</em>.
Must be combined with
<a href="#trace/3">trace/3</a>
to set the <strong>'receive'</strong> trace flag for one or more processes.
By default all messages received by <strong>'receive'</strong> traced
processes are traced. To limit
traced receive events based on the message content, the sender
and/or the receiver, use <strong>erlang:trace_pattern/3</strong>.</p><p>Argument <strong><span class="anno">MatchSpec</span></strong> can take the
following forms:</p><dl><dt><strong><span class="anno">MatchSpecList</span></strong></dt><dd> <p>A list of match specifications. The matching is done
on the list <strong>[Node, Sender, Msg]</strong>. <strong>Node</strong>
is the node name of the sender. <strong>Sender</strong> is the
process or port identity of the sender, or the atom
<strong>undefined</strong> if the sender is not known (which can
be the case for remote senders). <strong>Msg</strong> is the
message term. The pid of the receiving process can be
accessed with the guard function <strong>self/0</strong>. An empty
list is the same as <strong>true</strong>. For more information, see
section <a href="./match_spec"> Match Specifications in Erlang</a> in the User's Guide.</p> </dd><dt><strong>true</strong></dt><dd> <p>Enables tracing for all received messages (to <strong>'receive'</strong>
traced processes). Any match specification is
removed. <em>This is the default</em>.</p> </dd><dt><strong>false</strong></dt><dd> <p>Disables tracing for all received messages.
Any match specification is removed.</p> </dd></dl><p>Argument <strong><span class="anno">FlagList</span></strong> must be <strong>[]</strong>
for receive tracing.</p><p>The return value is always <strong>1</strong>.</p><p>Examples:</p><p>Only trace messages from a specific process <strong>Pid</strong>:</p><pre>
&gt; <span class="input">erlang:trace_pattern('receive', [{['_',Pid, '_'],[],[]}], []).</span>
1</pre><p>Only trace messages matching <strong>{reply, _}</strong>:</p><pre>
&gt; <span class="input">erlang:trace_pattern('receive', [{['_','_', {reply,'_'}],[],[]}], []).</span>
1</pre><p>Only trace messages from other nodes:</p><pre>
&gt; <span class="input">erlang:trace_pattern('receive', [{['$1', '_', '_'],[{'=/=','$1',{node}}],[]}], []).</span>
1</pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>A match specification for <strong>'receive'</strong> trace can
use all guard and body functions except <strong>caller</strong>,
<strong>is_seq_trace</strong>, <strong>get_seq_token</strong>, <strong>set_seq_token</strong>,
<strong>enable_trace</strong>, <strong>disable_trace</strong>, <strong>trace</strong>,
<strong>silent</strong>, and <strong>process_dump</strong>.</p></div><h4>trace_pattern/3</h4><p>Set trace patterns for tracing of function calls.</p><ul><li>trace_pattern_mfa</li></ul><ul><li>trace_match_spec</li></ul><ul><li>trace_pattern_flag</li></ul><ul><li>match_variable</li></ul> Approximation of '$1' | '$2' | '$3' | ... <p>Enables or disables <em>call tracing</em> for one or more functions.
Must be combined with
<a href="#trace/3">trace/3</a>
to set the <strong>call</strong> trace flag
for one or more processes.</p><p>Conceptually, call tracing works as follows. Inside
the Erlang virtual machine, a set of processes and
a set of functions are to be traced. If a traced process
calls a traced function, the trace action is taken.
Otherwise, nothing happens.</p><p>To add or remove one or more processes to the set of traced
processes, use
<a href="#trace/3">trace/3</a>.</p><p>To add or remove functions to the set of traced
functions, use <strong>erlang:trace_pattern/3</strong>.</p><p>The BIF <strong>erlang:trace_pattern/3</strong> can also add match
specifications to a function. A match specification
comprises a pattern that the function arguments must
match, a guard expression that must evaluate to <strong>true</strong>,
and an action to be performed. The default action is to send a
trace message. If the pattern does not match or the guard
fails, the action is not executed.</p><p>Argument <strong><span class="anno">MFA</span></strong> is to be a tuple, such as
<strong>{Module, Function, Arity}</strong>, or the atom <strong>on_load</strong>
(described below). It can be the module, function,
and arity for a function (or a BIF in any module).
The atom <strong>'_'</strong> can be used as a wildcard in any of the
following ways:</p><dl><dt><strong>{Module,Function,'_'}</strong></dt><dd> <p>All functions of any arity named <strong>Function</strong>
in module <strong>Module</strong>.</p> </dd><dt><strong>{Module,'_','_'}</strong></dt><dd> <p>All functions in module <strong>Module</strong>.</p> </dd><dt><strong>{'_','_','_'}</strong></dt><dd> <p>All functions in all loaded modules.</p> </dd></dl><p>Other combinations, such as <strong>{Module,'_',Arity}</strong>, are
not allowed. Local functions match wildcards only if
option <strong>local</strong> is in <strong><span class="anno">FlagList</span></strong>.</p><p>If argument <strong><span class="anno">MFA</span></strong> is the atom <strong>on_load</strong>,
the match specification and flag list are used on all
modules that are newly loaded.</p><p>Argument <strong><span class="anno">MatchSpec</span></strong> can take the
following forms:</p><dl><dt><strong>false</strong></dt><dd> <p>Disables tracing for the matching functions.
Any match specification is removed.</p> </dd><dt><strong>true</strong></dt><dd> <p>Enables tracing for the matching functions.
Any match specification is removed.</p> </dd><dt><strong><span class="anno">MatchSpecList</span></strong></dt><dd> <p>A list of match specifications. An empty list is
equivalent to <strong>true</strong>. For a description of match
specifications, see section <a href="./match_spec"> Match Specifications in Erlang</a> in the User's Guide.</p> </dd><dt><strong>restart</strong></dt><dd> <p>For the <strong><span class="anno">FlagList</span></strong> options <strong>call_count</strong>
and <strong>call_time</strong>: restarts
the existing counters. The behavior is undefined
for other <strong><span class="anno">FlagList</span></strong> options.</p> </dd><dt><strong>pause</strong></dt><dd> <p>For the <strong><span class="anno">FlagList</span></strong> options
<strong>call_count</strong> and <strong>call_time</strong>: pauses
the existing counters. The behavior is undefined for
other <strong><span class="anno">FlagList</span></strong> options.</p> </dd></dl><p>Parameter <strong><span class="anno">FlagList</span></strong> is a list of options.
The following are the valid options:</p><dl><dt><strong>global</strong></dt><dd> <p>Turns on or off call tracing for global function calls
(that is, calls specifying the module explicitly). Only
exported functions match and only global calls
generate trace messages. <em>This is the default</em>.</p> </dd><dt><strong>local</strong></dt><dd> <p>Turns on or off call tracing for all types of function
calls. Trace messages are sent whenever any of
the specified functions are called, regardless of how they
are called. If flag <strong>return_to</strong> is set for
the process, a <strong>return_to</strong> message is also sent
when this function returns to its caller.</p> </dd><dt><strong>meta | {meta, <span class="anno">Pid</span>} | {meta, <span class="anno">TracerModule</span>, <span class="anno">TracerState</span>}</strong> </dt><dd> <p>Turns on or off meta-tracing for all types of function
calls. Trace messages are sent to the tracer whenever any of
the specified functions are called. If no tracer is specified,
<strong>self()</strong> is used as a default tracer process.</p> <p>Meta-tracing traces all processes and does not care
about the process trace flags set by <strong>erlang:trace/3</strong>,
the trace flags are instead fixed to
<strong>[call, timestamp]</strong>.</p> <p>The match specification function <strong>{return_trace}</strong>
works with meta-trace and sends its trace message to the
same tracer.</p> </dd><dt><strong>call_count</strong></dt><dd> <p>Starts (<strong><span class="anno">MatchSpec</span> == true</strong>) or stops
(<strong><span class="anno">MatchSpec</span> == false</strong>)
call count tracing for all
types of function calls. For every function, a counter is
incremented when the function is called, in any process.
No process trace flags need to be activated.</p> <p>If call count tracing is started while already running,
the count is restarted from zero. To pause running
counters, use <strong><span class="anno">MatchSpec</span> == pause</strong>.
Paused and running counters can be restarted from zero with
<strong><span class="anno">MatchSpec</span> == restart</strong>.</p> <p>To read the counter value, use
<a href="#trace_info/2">trace_info/2</a>.</p> </dd><dt><strong>call_time</strong></dt><dd> <p>Starts (<strong><span class="anno">MatchSpec</span> == true</strong>) or stops
(<strong><span class="anno">MatchSpec</span> == false</strong>) call time
tracing for all
types of function calls. For every function, a counter is
incremented when the function is called.
Time spent in the function is accumulated in
two other counters, seconds and microseconds.
The counters are stored for each call traced process.</p> <p>If call time tracing is started while already running,
the count and time restart from zero. To pause
running counters, use <strong><span class="anno">MatchSpec</span> == pause</strong>.
Paused and running counters can be restarted from zero with
<strong><span class="anno">MatchSpec</span> == restart</strong>.</p> <p>To read the counter value, use
<a href="#trace_info/2">trace_info/2</a>.</p> </dd></dl><p>The options <strong>global</strong> and <strong>local</strong> are mutually
exclusive, and <strong>global</strong> is the default (if no options are
specified). The options <strong>call_count</strong> and <strong>meta</strong>
perform a kind of local tracing, and cannot be combined
with <strong>global</strong>. A function can be globally or
locally traced. If global tracing is specified for a
set of functions, then local, meta, call time, and call count
tracing for the matching set of local functions is
disabled, and conversely.</p><p>When disabling trace, the option must match the type of trace
set on the function. That is, local tracing must be
disabled with option <strong>local</strong> and global tracing with
option <strong>global</strong> (or no option), and so on.</p><p>Part of a match specification list cannot be changed directly.
If a function has a match specification, it can be replaced
with a new one. To change an existing match specification,
use the BIF
<a href="#trace_info/2">trace_info/2</a>
to retrieve the existing match specification.</p><p>Returns the number of functions matching
argument <strong><span class="anno">MFA</span></strong>. This is zero if none matched.</p><h4>trunc/1</h4><p>Return an integer by truncating a number.</p><p>Returns an integer by truncating <strong><span class="anno">Number</span></strong>,
for example:</p><pre>
&gt; <span class="input">trunc(5.5).</span>
5</pre><p>Allowed in guard tests.</p><h4>tuple_size/1</h4><p>Return the size of a tuple.</p><p>Returns an integer that is the number of elements in
<strong><span class="anno">Tuple</span></strong>, for example:</p><pre>
&gt; <span class="input">tuple_size({morni, mulle, bwange}).</span>
3</pre><p>Allowed in guard tests.</p><h4>tuple_to_list/1</h4><p>Convert a tuple to a list.</p><p>Returns a list corresponding to <strong><span class="anno">Tuple</span></strong>.
<strong><span class="anno">Tuple</span></strong> can contain any Erlang terms.
Example:</p><pre>
&gt; <span class="input">tuple_to_list({share, {'Ericsson_B', 163}}).</span>
[share,{'Ericsson_B',163}]</pre><h4>unique_integer/0</h4><p>Get a unique integer value.</p><p>Generates and returns an
<a href="../doc/efficiency_guide/advanced#unique_integers"> integer unique on current runtime system instance</a>.
The same as calling
<a href="#unique_integer/1">unique_integer/1</a>.</p><h4>unique_integer/1</h4><p>Get a unique integer value.</p><p>Generates and returns an
<a href="../doc/efficiency_guide/advanced#unique_integers"> integer unique on current runtime system instance</a>. The integer is unique in the
sense that this BIF, using the same set of
modifiers, does not return the same integer more
than once on the current runtime system instance.
Each integer value can of course be constructed
by other means.</p><p>By default, when <strong>[]</strong> is passed as
<strong><span class="anno">ModifierList</span></strong>, both negative and
positive integers can be returned. This
to use the range of integers that do
not need heap memory allocation as much as possible.
By default the returned integers are also only
guaranteed to be unique, that is, any returned integer
can be smaller or larger than previously
returned integers.</p><p><strong><span class="anno">Modifier</span></strong>s:</p><dl><dt>positive</dt><dd> <p>Returns only positive integers.</p> <p>Notice that by passing the <strong>positive</strong> modifier
you will get heap allocated integers (bignums) quicker.</p> </dd><dt>monotonic</dt><dd> <p>Returns <a href="./time_correction#Strictly_Monotonically_Increasing"> strictly monotonically increasing</a> integers
corresponding to creation time. That is, the integer
returned is always larger than previously
returned integers on the current runtime system
instance.</p> <p>These values can be used to determine order between events
on the runtime system instance. That is, if both
<strong>X = erlang:unique_integer([monotonic])</strong> and
<strong>Y = erlang:unique_integer([monotonic])</strong> are
executed by different processes (or the same
process) on the same runtime system instance and
<strong>X &lt; Y</strong>, we know that <strong>X</strong> was created
before <strong>Y</strong>.</p> <div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Strictly monotonically increasing values
are inherently quite expensive to generate and scales
poorly. This is because the values need to be synchronized
between CPU cores. That is, do not pass the <strong>monotonic</strong>
modifier unless you really need strictly monotonically
increasing values.</p></div> </dd></dl><p>All valid <strong><span class="anno">Modifier</span></strong>s
can be combined. Repeated (valid)
<strong><span class="anno">Modifier</span></strong>s in the <strong>ModifierList</strong>
are ignored.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The set of integers returned by
<strong>erlang:unique_integer/1</strong> using different sets of
<strong><span class="anno">Modifier</span></strong>s <em>will overlap</em>.
For example, by calling <strong>unique_integer([monotonic])</strong>,
and <strong>unique_integer([positive, monotonic])</strong>
repeatedly, you will eventually see some integers that are
returned by both calls.</p></div><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd>if <strong><span class="anno">ModifierList</span></strong> is not a proper list.</dd><dt><strong>badarg</strong></dt><dd>if <strong><span class="anno">Modifier</span></strong> is not a valid modifier.</dd></dl><h4>universaltime/0</h4><p>Current date and time according to Universal Time Coordinated (UTC).</p><p>Returns the current date and time according to Universal
Time Coordinated (UTC) in the form
<strong>{{Year, Month, Day}, {Hour, Minute, Second}}</strong> if
supported by the underlying OS.
Otherwise <strong>erlang:universaltime()</strong> is equivalent to
<strong>erlang:localtime()</strong>. Example:</p><pre>
&gt; <span class="input">erlang:universaltime().</span>
{{1996,11,6},{14,18,43}}</pre><h4>universaltime_to_localtime/1</h4><p>Convert from Universal Time Coordinated (UTC) to local date and time.</p><p>Converts Universal Time Coordinated (UTC) date and time to
local date and time in the form
<strong>{{Year, Month, Day}, {Hour, Minute, Second}}</strong> if
supported by the underlying OS.
Otherwise no conversion is done, and
<strong><span class="anno">Universaltime</span></strong> is returned. Example:</p><pre>
&gt; <span class="input">erlang:universaltime_to_localtime({{1996,11,6},{14,18,43}}).</span>
{{1996,11,7},{15,18,43}}</pre><p>Failure: <strong>badarg</strong> if <strong>Universaltime</strong> denotes
an invalid date and time.</p><h4>unlink/1</h4><p>Remove a link to another process or port.</p><p>Removes the link, if there is one, between the calling
process and the process or port referred to by
<strong><span class="anno">Id</span></strong>.</p><p>Returns <strong>true</strong> and does not fail, even if there is no
link to <strong><span class="anno">Id</span></strong>, or if <strong><span class="anno">Id</span></strong>
does not exist.</p><p>Once <strong>unlink(<span class="anno">Id</span>)</strong> has returned,
it is guaranteed that
the link between the caller and the entity referred to by
<strong><span class="anno">Id</span></strong> has no effect on the caller
in the future (unless
the link is setup again). If the caller is trapping exits, an
<strong>{'EXIT', <span class="anno">Id</span>, _}</strong> message from the link
can have been placed in the caller's message queue before
the call.</p><p>Notice that the <strong>{'EXIT', <span class="anno">Id</span>, _}</strong>
message can be the
result of the link, but can also be the result of <strong>Id</strong>
calling <strong>exit/2</strong>. Therefore, it <em>can</em> be
appropriate to clean up the message queue when trapping exits
after the call to <strong>unlink(<span class="anno">Id</span>)</strong>, as follows:</p><pre><code class="">
unlink(Id),
receive
    {'EXIT', Id, _} -&gt;
        true
after 0 -&gt;
        true
end</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Before Erlang/OTP R11B (ERTS 5.5) <strong>unlink/1</strong>
behaved completely asynchronously, that is, the link was active
until the "unlink signal" reached the linked entity. This
had an undesirable effect, as you could never know when
you were guaranteed <em>not</em> to be effected by the link.</p><p>The current behavior can be viewed as two combined operations:
asynchronously send an "unlink signal" to the linked entity
and ignore any future results of the link.</p></div><h4>unregister/1</h4><p>Remove the registered name for a process (or port).</p><p>Removes the registered name <strong><span class="anno">RegName</span></strong>
associated with a
process identifier or a port identifier, for example:</p><pre>
&gt; <span class="input">unregister(db).</span>
true</pre><p>Users are advised not to unregister system processes.</p><p>Failure: <strong>badarg</strong> if <strong>RegName</strong> is not a registered
name.</p><h4>whereis/1</h4><p>Get the pid (or port) with a specified registered name. </p><p>Returns the process identifier or port identifier with
the registered name <strong>RegName</strong>. Returns <strong>undefined</strong>
if the name is not registered. Example:</p><pre>
&gt; <span class="input">whereis(db).</span>
&lt;0.43.0&gt;</pre><h4>yield/0</h4><p>Let other processes get a chance to execute.</p><p>Voluntarily lets other processes (if any) get a chance to
execute. Using this function is similar to
<strong>receive after 1 -&gt; ok end</strong>, except that <strong>yield()</strong>
is faster.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>There is seldom or never any need to use this BIF
as other processes have a chance to run in another scheduler
thread anyway.
Using this BIF without a thorough grasp of how the scheduler
works can cause performance degradation.</p></div><h3>erlc</h3><p>Compiler</p><p>The <strong>erlc</strong> program provides a common way to run
all compilers in the Erlang system.
Depending on the extension of each input file, <strong>erlc</strong>
invokes the appropriate compiler.
Regardless of which compiler is used, the same flags are used to provide
parameters, such as include paths and output directory.The current working directory, <strong>"."</strong>, is not included
in the code path when running the compiler. This to avoid loading
Beam files from the current working directory that could potentially
be in conflict with the compiler or the Erlang/OTP system used by the
compiler.</p><h3>Functions</h3><h4>erlc flags file1.ext file2.ext...</h4><p>Compile files.</p><p>Compiles one or more files. The files must include the extension,
for example, <strong>.erl</strong> for Erlang source code, or
<strong>.yrl</strong> for Yecc source code.
<strong>Erlc</strong> uses the extension to invoke the correct
compiler.</p><h4>Generally Useful Flags</h4><p>The following flags are supported:</p><dl><dt><strong>-I &lt;Directory&gt;</strong></dt><dd> <p>Instructs the compiler to search for include files in
the <strong>Directory</strong>. When encountering an
<strong>-include</strong> or <strong>-include_lib</strong>
directive, the compiler searches for header files in the following
directories:</p> <ul><li> <p><strong>"."</strong>, the current working directory of the
file server</p> </li><li> <p>The base name of the compiled file</p> </li><li> <p>The directories specified using option <strong>-I</strong>;
the directory specified last is searched first</p> </li></ul> </dd><dt><strong>-o &lt;Directory&gt;</strong></dt><dd> <p>The directory where the compiler is to place the output files.
Defaults to the current working directory.</p> </dd><dt><strong>-D&lt;Name&gt;</strong></dt><dd> <p>Defines a macro.</p> </dd><dt><strong>-D&lt;Name&gt;=&lt;Value&gt;</strong></dt><dd> <p>Defines a macro with the specified value.
The value can be any Erlang term.
Depending on the platform, the value may need to be
quoted if the shell itself interprets certain characters.
On Unix, terms containing tuples and lists
must be quoted. Terms containing spaces
must be quoted on all platforms.</p> </dd><dt><strong>-W&lt;Error&gt;</strong></dt><dd> <p>Makes all warnings into errors.</p> </dd><dt><strong>-W&lt;Number&gt;</strong></dt><dd> <p>Sets warning level to <strong>Number</strong>. Defaults to
<strong>1</strong>. To turn off warnings,
use <strong>-W0</strong>.</p> </dd><dt><strong>-W</strong></dt><dd> <p>Same as <strong>-W1</strong>. Default.</p> </dd><dt><strong>-v</strong></dt><dd> <p>Enables verbose output.</p> </dd><dt><strong>-b &lt;Output_type&gt;</strong></dt><dd> <p>Specifies the type of output file.
<strong>Output_type</strong> is the same as the file extension
of the output file, but without the period.
This option is ignored by compilers that have
a single output format.</p> </dd><dt><strong>-smp</strong></dt><dd> <p>Compiles using the SMP emulator. This is mainly useful
for compiling native code, which must be compiled with the same
runtime system that it is to be run on.</p> </dd><dt><strong>-M</strong></dt><dd> <p>Produces a Makefile rule to track header dependencies. The
rule is sent to <strong>stdout</strong>. No object file is produced.</p> </dd><dt><strong>-MMD</strong></dt><dd> <p>Generate dependencies as a side-effect. The object file
will be produced as normal. This option overrides the
option <strong>-M</strong>.</p> </dd><dt><strong>-MF &lt;Makefile&gt;</strong></dt><dd> <p>As option <strong>-M</strong>, except that the
Makefile is written to <strong>Makefile</strong>. No object
file is produced.</p> </dd><dt><strong>-MD</strong></dt><dd> <p>Same as <strong>-M -MF &lt;File&gt;.Pbeam</strong>.</p> </dd><dt><strong>-MT &lt;Target&gt;</strong></dt><dd> <p>In conjunction with option <strong>-M</strong> or
<strong>-MF</strong>, changes the name of the rule emitted
to <strong>Target</strong>.</p> </dd><dt><strong>-MQ &lt;Target&gt;</strong></dt><dd> <p>As option <strong>-MT</strong>, except that characters special to
<strong>make/1</strong> are quoted.</p> </dd><dt><strong>-MP</strong></dt><dd> <p>In conjunction with option <strong>-M</strong> or
<strong>-MF</strong>, adds a phony target for each dependency.</p> </dd><dt><strong>-MG</strong></dt><dd> <p>In conjunction with option <strong>-M</strong> or
<strong>-MF</strong>, considers missing headers as generated
files and adds them to the dependencies.</p> </dd><dt><strong>--</strong></dt><dd> <p>Signals that no more options will follow.
The rest of the arguments is treated as filenames,
even if they start with hyphens.</p> </dd><dt><strong>+&lt;Term&gt;</strong></dt><dd> <p>A flag starting with a plus (<strong>+</strong>) rather than a hyphen
is converted to an Erlang term and passed unchanged to
the compiler.
For example, option <strong>export_all</strong> for the Erlang
compiler can be specified as follows:</p> <pre>
erlc +export_all file.erl</pre> <p>Depending on the platform, the value may need to be
quoted if the shell itself interprets certain characters.
On Unix, terms containing tuples and lists
must be quoted. Terms containing spaces
must be quoted on all platforms.</p> </dd></dl><h4>Special Flags</h4><p>The following flags are useful in special situations,
such as rebuilding the OTP system:</p><dl><dt><strong>-pa &lt;Directory&gt;</strong></dt><dd> <p>Appends <strong>Directory</strong> to the front of the code path in
the invoked Erlang emulator.
This can be used to invoke another
compiler than the default one.</p> </dd><dt><strong>-pz &lt;Directory&gt;</strong></dt><dd> <p>Appends <strong>Directory</strong> to the code path in
the invoked Erlang emulator.</p> </dd></dl><h4>Supported Compilers</h4><p>The following compilers are supported:</p><dl><dt><strong>.erl</strong></dt><dd> <p>Erlang source code. It generates a <strong>.beam</strong> file.</p> <p>Options <strong>-P</strong>, <strong>-E</strong>, and <strong>-S</strong> are equivalent to
<strong>+'P'</strong>, <strong>+'E'</strong>, and <strong>+'S'</strong>, except that it is not
necessary to include the single quotes to protect them from the
shell.</p> <p>Supported options: <strong>-I</strong>, <strong>-o</strong>, <strong>-D</strong>, <strong>-v</strong>,
<strong>-W</strong>, <strong>-b</strong>.</p> </dd><dt><strong>.S</strong></dt><dd> <p>Erlang assembler source code. It generates a <strong>.beam</strong>
file.</p> <p>Supported options: same as for <strong>.erl</strong>.</p> </dd><dt><strong>.core</strong></dt><dd> <p>Erlang core source code. It generates a <strong>.beam</strong>
file.</p> <p>Supported options: same as for <strong>.erl</strong>.</p> </dd><dt><strong>.yrl</strong></dt><dd> <p>Yecc source code. It generates an <strong>.erl</strong> file.</p> <p>Use option <strong>-I</strong> with the name of a file to use that file
as a customized prologue file (option
<strong>includefile</strong>).</p> <p>Supported options: <strong>-o</strong>, <strong>-v</strong>, <strong>-I</strong>, <strong>-W</strong>.</p> </dd><dt><strong>.mib</strong></dt><dd> <p>MIB for SNMP. It generates a <strong>.bin</strong> file.</p> <p>Supported options: <strong>-I</strong>, <strong>-o</strong>, <strong>-W</strong>.</p> </dd><dt><strong>.bin</strong></dt><dd> <p>A compiled MIB for SNMP. It generates a <strong>.hrl</strong>
file.</p> <p>Supported options: <strong>-o</strong>, <strong>-v</strong>.</p> </dd><dt><strong>.rel</strong></dt><dd> <p>Script file. It generates a boot file.</p> <p>Use option <strong>-I</strong> to name directories to be searched for
application files (equivalent to the <strong>path</strong> in the
option list for <strong>systools:make_script/2</strong>).</p> <p>Supported option: <strong>-o</strong>.</p> </dd><dt><strong>.asn1</strong></dt><dd> <p>ASN1 file. It creates an <strong>.erl</strong>,
<strong>.hrl</strong>, and <strong>.asn1db</strong> file from
an <strong>.asn1</strong> file. Also compiles the
<strong>.erl</strong> using the Erlang compiler unless option
<strong>+noobj</strong> is specified.</p> <p>Supported options: <strong>-I</strong>, <strong>-o</strong>, <strong>-b</strong>, <strong>-W</strong>.</p> </dd><dt><strong>.idl</strong></dt><dd> <p>IC file. It runs the IDL compiler.</p> <p>Supported options: <strong>-I</strong>, <strong>-o</strong>.</p> </dd></dl><h4>Environment Variables</h4><dl><dt><strong>ERLC_EMULATOR</strong></dt><dd>The command for starting the emulator. Defaults to <strong>erl</strong> in the same directory as the <strong>erlc</strong> program itself, or, if it does not exist, <strong>erl</strong> in any of the directories specified in environment variable <strong>PATH</strong>.</dd></dl><h4>See Also</h4><p><a href="erl">erl</a>,
<a href="./compile">compiler/compile</a>,
<a href="./yecc">parsetools/yecc</a>,
<a href="./snmp">snmp/snmp</a></p><h3>erl_driver</h3><p>API functions for an Erlang driver.</p><p>An Erlang driver is a library containing a set of native driver
callback functions that the Erlang Virtual Machine calls when certain
events occur. There can be multiple instances of a driver, each
instance is associated with an Erlang port.<a name="WARNING"></a>As from ERTS 5.5.3 the driver interface has been extended
(see <a href="./driver_entry#extended_marker">driver_entry#extended_marker</a>). The extended interface introduces
<a href="#version_management">version management</a>,
the possibility to pass capability flags (see
<a href="./driver_entry#driver_flags">driver_entry#driver_flags</a>) to the runtime system at driver
initialization, and some new driver API functions.The driver calls back to the emulator, using the API
functions declared in <strong>erl_driver.h</strong>. They are used for
outputting data from the driver, using timers, and so on.Each driver instance is associated with a port. Every port
has a port owner process. Communication with the port is normally
done through the port owner process. Most of the functions take
the <strong>port</strong> handle as an argument. This identifies the driver
instance. Notice that this port handle must be stored by the driver,
it is not given when the driver is called from the emulator (see
<a href="./driver_entry#emulator">driver_entry#emulator</a>).Some of the functions take a parameter of type
<strong>ErlDrvBinary</strong>, a driver binary. It is to be both
allocated and freed by the caller. Using a binary directly avoids
one extra copying of data.Many of the output functions have a "header buffer", with
<strong>hbuf</strong> and <strong>hlen</strong> parameters. This buffer is sent as a
list before the binary (or list, depending on port mode) that is
sent. This is convenient when matching on messages received from
the port. (Although in the latest Erlang versions there is
the binary syntax, which enables you to match on the beginning of
a binary.)<a name="smp_support"></a>In the runtime system with
SMP support, drivers are locked either on driver level
or port level (driver instance level). By default
driver level locking will be used, that is, only one emulator thread
will execute code in the driver at a time. If port level locking
is used, multiple emulator threads can execute code in the driver
at the same time. Only one thread at a time will call
driver callbacks corresponding to the same port, though.
To enable port level locking, set the <strong>ERL_DRV_FLAG_USE_PORT_LOCKING</strong>
<a href="./driver_entry#driver_flags">driver flag</a> in
the <a href="driver_entry">driver_entry</a>
used by the driver. When port level locking is used,
the driver writer is responsible for synchronizing all accesses
to data shared by the ports (driver instances).Most drivers written before the runtime system with SMP
support existed can run in the runtime system
with SMP support, without being rewritten, if driver
level locking is used.Previously, in the runtime system without SMP support,
specific driver callbacks were always called from the same
thread. This is <em>not</em> the case in the runtime system
with SMP support. Regardless of locking scheme used, calls
to driver callbacks can be made from different threads. For example,
two consecutive calls to exactly the same callback for exactly
the same port can be made from two different threads. This
is for <em>most</em> drivers not a problem, but it can be.
Drivers that depend on all callbacks that are called in the
same thread, <em>must</em> be rewritten before they are used
in the runtime system with SMP support.Most functions in this API are <em>not</em> thread-safe, that is,
they <em>cannot</em> be called from arbitrary threads. Functions
that are not documented as thread-safe can only be called from
driver callbacks or function calls descending from a driver
callback call. Notice that driver callbacks can be called from
different threads. This, however, is not a problem for any
function in this API, as the emulator has control over
these threads.<a name="lengthy_work"></a>
As mentioned in the <a href="#WARNING">warning</a> text at
the beginning of this section, it is of vital importance that a driver
callback returns relatively fast. It is difficult to give an exact
maximum amount of time that a driver callback is allowed to work, but
usually a well-behaving driver callback is to return within 1 millisecond.
This can be achieved using different approaches.
If you have full control over the code to execute in the driver
callback, the best approach is to divide the work into multiple chunks of
work, and trigger multiple calls to the
<a href="./driver_entry#timeout">time-out callback</a> using
zero time-outs. Function <a href="#erl_drv_consume_timeslice">erl_drv_consume_timeslice</a> can be useful to
determine when to trigger such time-out callback calls. However, sometimes
it cannot be implemented this way, for example when calling
third-party libraries. In this case, you typically want to dispatch the
work to another thread. Information about thread primitives is provided
below.</p><h4>Functionality</h4><p>All functions that a driver needs to do with Erlang are
performed through driver API functions. Functions exist
for the following functionality:</p><dl><dt>Timer functions</dt><dd> <p>Control the timer that a driver can use. The timer has the
emulator call the <a href="./driver_entry#timeout">driver_entry#timeout</a> entry function after a specified time.
Only one timer is available for each driver instance.</p> </dd><dt>Queue handling</dt><dd> <p>Every driver instance has an associated queue. This queue is a
<strong>SysIOVec</strong>, which works as a buffer. It is mostly used for
the driver to buffer data that is to be written to a device,
it is a byte stream. If the port owner process closes the
driver, and the queue is not empty, the driver is not
closed. This enables the driver to flush its buffers before
closing.</p> <p>The queue can be manipulated from any threads if
a port data lock is used. For more information, see
<a href="#ErlDrvPDL">ErlDrvPDL</a>.</p> </dd><dt>Output functions</dt><dd> <p>With these functions, the driver sends data back to the emulator.
The data is received as messages by the port owner process, see
<a href="./erlang#open_port/2">erlang#open_port/2</a>. The vector function and the
function taking a driver binary are faster, as they avoid
copying the data buffer. There is also a fast way of sending
terms from the driver, without going through the binary term
format.</p></dd><dt>Failure</dt><dd> <p>The driver can exit and signal errors up to Erlang. This is
only for severe errors, when the driver cannot possibly keep
open.</p> </dd><dt>Asynchronous calls</dt><dd> <p>Erlang/OTP R7B and later versions have provision for
asynchronous function calls, using a thread pool provided by
Erlang. There is also a select call, which can be used for
asynchronous drivers.</p> </dd><dt><a name="multi_threading"></a>Multi-threading</dt><dd> <p>A POSIX thread like API for multi-threading is provided. The
Erlang driver thread API only provides a subset of the functionality
provided by the POSIX thread API. The subset provided is
more or less the basic functionality needed for multi-threaded
programming:</p> <ul><li><a href="#ErlDrvTid">Threads</a></li><li><a href="#ErlDrvMutex">Mutexes</a></li><li><a href="#ErlDrvCond"> Condition variables</a></li><li><a href="#ErlDrvRWLock"> Read/write locks</a></li><li><a href="#ErlDrvTSDKey"> Thread-specific data</a></li></ul> <p>The Erlang driver thread API can be used in conjunction with
the POSIX thread API on UN-ices and with the Windows native thread
API on Windows. The Erlang driver thread API has the advantage of
being portable, but there can exist situations where you want to
use functionality from the POSIX thread API or the Windows
native thread API.</p> <p>The Erlang driver thread API only returns error codes when it is
reasonable to recover from an error condition. If it is not reasonable
to recover from an error condition, the whole runtime system is
terminated. For example, if a create mutex operation fails, an error
code is returned, but if a lock operation on a mutex fails, the
whole runtime system is terminated.</p> <p>Notice that there is no "condition variable wait with time-out" in
the Erlang driver thread API. This because of issues with
<strong>pthread_cond_timedwait</strong>. When the system clock suddenly
is changed, it is not always guaranteed that you will wake up from
the call as expected. An Erlang runtime system must be able to
cope with sudden changes of the system clock. Therefore, we have
omitted it from the Erlang driver thread API. In the Erlang driver
case, time-outs can and are to be handled with the timer functionality
of the Erlang driver API.</p> <p>In order for the Erlang driver thread API to function, thread
support must be enabled in the runtime system. An Erlang driver
can check if thread support is enabled by use of
<a href="#driver_system_info">driver_system_info</a>.
Notice that some functions in the Erlang driver API are thread-safe
only when the runtime system has SMP support, also this
information can be retrieved through
<a href="#driver_system_info">driver_system_info</a>.
Also notice that many functions in the Erlang driver API are
<em>not</em> thread-safe, regardless of whether SMP support is
enabled or not. If a function is not documented as thread-safe, it
is <em>not</em> thread-safe.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>When executing in an emulator thread, it is
<em>very important</em> that you unlock <em>all</em> locks you
have locked before letting the thread out of your control;
otherwise you are <em>very likely</em> to deadlock the whole
emulator.</p><p>If you need to use thread-specific data in an emulator
thread, only have the thread-specific data set while the thread is
under your control, and clear the thread-specific data before
you let the thread out of your control.</p></div> <p>In the future, debug functionality will probably be
integrated with the Erlang driver thread API. All functions
that create entities take a <strong>name</strong> argument. Currently
the <strong>name</strong> argument is unused, but it will be used when
the debug functionality is implemented. If you name all
entities created well, the debug functionality will be able
to give you better error reports.</p> </dd><dt>Adding/removing drivers</dt><dd> <p>A driver can add and later remove drivers.</p> </dd><dt>Monitoring processes</dt><dd> <p>A driver can monitor a process that does not own a port.</p> </dd><dt><a name="version_management"></a>Version management</dt><dd> <p>Version management is enabled for drivers that have set the
<a href="./driver_entry#extended_marker">driver_entry#extended_marker</a> field of their
<a href="driver_entry">driver_entry</a>
to <strong>ERL_DRV_EXTENDED_MARKER</strong>. <strong>erl_driver.h</strong> defines:</p> <ul><li> <p><strong>ERL_DRV_EXTENDED_MARKER</strong></p> </li><li> <p><strong>ERL_DRV_EXTENDED_MAJOR_VERSION</strong>, which is incremented when
driver incompatible changes are made to the Erlang runtime
system. Normally it suffices to recompile drivers when
<strong>ERL_DRV_EXTENDED_MAJOR_VERSION</strong> has changed, but it
can, under rare circumstances, mean that drivers must
be slightly modified. If so, this will of course be
documented.</p> </li><li> <p><strong>ERL_DRV_EXTENDED_MINOR_VERSION</strong>, which is incremented when
new features are added. The runtime system uses the minor version
of the driver to determine what features to use.</p> </li></ul> <p>The runtime system normally refuses to load a driver if the major
versions differ, or if the major versions are equal and the
minor version used by the driver is greater than the one used
by the runtime system. Old drivers with lower major versions
are however allowed after a bump of the major version during
a transition period of two major releases. Such old drivers can,
however, fail if deprecated features are used.</p> <p>The emulator refuses to load a driver that does not use
the extended driver interface, to allow for 64-bit capable drivers,
as incompatible type changes for the callbacks
<a href="./driver_entry#output">driver_entry#output</a>,
<a href="./driver_entry#control">driver_entry#control</a>, and
<a href="./driver_entry#call">driver_entry#call</a>
were introduced in Erlang/OTP R15B. A driver written
with the old types would compile with warnings and when
called return garbage sizes to the emulator, causing it
to read random memory and create huge incorrect result blobs.</p> <p>Therefore it is not enough to only recompile drivers written with
version management for pre R15B types; the types must be changed
in the driver suggesting other rewrites, especially regarding size
variables. <em>Investigate all warnings when recompiling.</em></p> <p>Also, the API driver functions <strong>driver_output*</strong> and
<strong>driver_vec_to_buf</strong>, <strong>driver_alloc/realloc*</strong>, and the
<strong>driver_*</strong> queue functions were changed to have
larger length arguments and return values. This is a
lesser problem, as code that passes smaller types
gets them auto-converted in the calls, and as long as
the driver does not handle sizes that overflow an <strong>int</strong>,
all will work as before.</p> </dd><dt><a name="time_measurement"></a>Time measurement</dt><dd> <p>Support for time measurement in drivers:</p> <ul><li><a href="#ErlDrvTime">ErlDrvTime</a></li><li><a href="#ErlDrvTimeUnit">ErlDrvTimeUnit</a></li><li><a href="#erl_drv_monotonic_time">erl_drv_monotonic_time</a></li><li><a href="#erl_drv_time_offset">erl_drv_time_offset</a></li><li><a href="#erl_drv_convert_time_unit">erl_drv_convert_time_unit</a></li></ul> </dd></dl><a name="rewrites_for_64_bits"></a><h4>Rewrites for 64-Bit Driver Interface</h4><p>ERTS 5.9 introduced two new integer types,
<a href="#ErlDrvSizeT">ErlDrvSizeT</a> and
<a href="#ErlDrvSSizeT">ErlDrvSSizeT</a>,
which can hold 64-bit sizes if necessary.</p><p>To not update a driver and only recompile, it probably works
when building for a 32-bit machine creating a false sense of security.
Hopefully that will generate many important warnings.
But when recompiling the same driver later on for a 64-bit machine,
there <em>will</em> be warnings and almost certainly crashes.
So it is a <em>bad</em> idea to postpone updating the driver and
not fixing the warnings.</p><p>When recompiling with <strong>gcc</strong>, use flag <strong>-Wstrict-prototypes</strong>
to get better warnings. Try to find a similar flag if you use
another compiler.</p><p>The following is a checklist for rewriting a pre ERTS 5.9 driver,
most important first:</p><dl><dt>Return types for driver callbacks</dt><dd> <p>Rewrite driver callback
<a href="./driver_entry#control">driver_entry#control</a>
to use return type <strong>ErlDrvSSizeT</strong> instead of <strong>int</strong>.</p> <p>Rewrite driver callback
<a href="./driver_entry#call">driver_entry#call</a>
to use return type <strong>ErlDrvSSizeT</strong> instead of <strong>int</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>These changes are essential not to crash the emulator
or worse cause malfunction.
Without them a driver can return garbage in the high 32 bits
to the emulator, causing it to build a huge result from random
bytes, either crashing on memory allocation or succeeding with
a random result from the driver call.</p></div> </dd><dt>Arguments to driver callbacks</dt><dd> <p>Driver callback
<a href="./driver_entry#output">driver_entry#output</a>
now gets <strong>ErlDrvSizeT</strong> as 3rd argument instead
of previously <strong>int</strong>.</p> <p>Driver callback
<a href="./driver_entry#control">driver_entry#control</a>
now gets <strong>ErlDrvSizeT</strong> as 4th and 6th arguments instead
of previously <strong>int</strong>.</p> <p>Driver callback
<a href="./driver_entry#call">driver_entry#call</a>
now gets <strong>ErlDrvSizeT</strong> as 4th and 6th arguments instead
of previously <strong>int</strong>.</p> <p>Sane compiler's calling conventions probably make these changes
necessary only for a driver to handle data chunks that require
64-bit size fields (mostly larger than 2 GB, as that is what
an <strong>int</strong> of 32 bits can hold). But it is possible to think
of non-sane calling conventions that would make the driver
callbacks mix up the arguments causing malfunction.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The argument type change is from signed to unsigned. This
can cause problems for, for example, loop termination conditions or
error conditions if you only change the types all over the place.
</p></div> </dd><dt>Larger <strong>size</strong> field in <strong>ErlIOVec</strong></dt><dd> <p>The <strong>size</strong> field in
<a href="#ErlIOVec">ErlIOVec</a>
has been changed to <strong>ErlDrvSizeT</strong> from <strong>int</strong>.
Check all code that use that field.</p> <p>Automatic type-casting probably makes these changes necessary only
for a driver that encounters sizes &gt; 32 bits.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The <strong>size</strong> field changed from signed to unsigned. This
can cause problems for, for example, loop termination conditions or
error conditions if you only change the types all over the place.
</p></div> </dd><dt>Arguments and return values in the driver API</dt><dd> <p>Many driver API functions have changed argument type
and/or return value to <strong>ErlDrvSizeT</strong> from mostly <strong>int</strong>.
Automatic type-casting probably makes these changes necessary only
for a driver that encounters sizes &gt; 32 bits.</p> <dl><dt><a href="#driver_output">driver_output</a></dt><dd>3rd argument</dd><dt><a href="#driver_output2">driver_output2</a></dt><dd>3rd and 5th arguments</dd><dt><a href="#driver_output_binary">driver_output_binary</a></dt><dd>3rd, 5th, and 6th arguments</dd><dt><a href="#driver_outputv">driver_outputv</a></dt><dd>3rd and 5th arguments</dd><dt><a href="#driver_vec_to_buf">driver_vec_to_buf</a></dt><dd>3rd argument and return value</dd><dt><a href="#driver_alloc">driver_alloc</a></dt><dd>1st argument</dd><dt><a href="#driver_realloc">driver_realloc</a></dt><dd>2nd argument</dd><dt><a href="#driver_alloc_binary">driver_alloc_binary</a></dt><dd>1st argument</dd><dt><a href="#driver_realloc_binary">driver_realloc_binary</a></dt><dd>2nd argument</dd><dt><a href="#driver_enq">driver_enq</a></dt><dd>3rd argument</dd><dt><a href="#driver_pushq">driver_pushq</a></dt><dd>3rd argument</dd><dt><a href="#driver_deq">driver_deq</a></dt><dd>2nd argument and return value</dd><dt><a href="#driver_sizeq">driver_sizeq</a></dt><dd>Return value</dd><dt><a href="#driver_enq_bin">driver_enq_bin</a></dt><dd>3rd and 4th arguments</dd><dt><a href="#driver_pushq_bin">driver_pushq_bin</a></dt><dd>3rd and 4th arguments</dd><dt><a href="#driver_enqv">driver_enqv</a></dt><dd>3rd argument</dd><dt><a href="#driver_pushqv">driver_pushqv</a></dt><dd>3rd argument</dd><dt><a href="#driver_peekqv">driver_peekqv</a></dt><dd>Return value</dd></dl> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This is a change from signed to unsigned. This can cause
problems for, for example, loop termination conditions and error
conditions if you only change the types all over the place.</p></div> </dd></dl><h4>Data Types</h4><dl><dt><a name="ErlDrvSizeT"></a><strong>ErlDrvSizeT</strong></dt><dd> <p>An unsigned integer type to be used as <strong>size_t</strong>.</p> </dd><dt><a name="ErlDrvSSizeT"></a><strong>ErlDrvSSizeT</strong></dt><dd> <p>A signed integer type, the size of <strong>ErlDrvSizeT</strong>.</p> </dd><dt><a name="ErlDrvSysInfo"></a><strong>ErlDrvSysInfo</strong></dt><dd> <pre><code class="">
typedef struct ErlDrvSysInfo {
   int driver_major_version;
   int driver_minor_version;
   char *erts_version;
   char *otp_release;
   int thread_support;
   int smp_support;
   int async_threads;
   int scheduler_threads;
   int nif_major_version;
   int nif_minor_version;
   int dirty_scheduler_support;
} ErlDrvSysInfo;</code></pre> <p>The <strong>ErlDrvSysInfo</strong> structure is used for storage of
information about the Erlang runtime system.
<a href="#driver_system_info">driver_system_info</a>
writes the system information when passed a reference to
a <strong>ErlDrvSysInfo</strong> structure. The fields in the structure
are as follows:</p> <dl><dt><strong>driver_major_version</strong></dt><dd> <p>The value of <a href="#version_management">version_management</a>
when the runtime system was compiled. This value is the same
as the value of <a href="#version_management">version_management</a>
used when compiling the driver; otherwise the runtime system
would have refused to load the driver.</p> </dd><dt><strong>driver_minor_version</strong></dt><dd> <p>The value of <a href="#version_management">version_management</a>
when the runtime system was compiled. This value can differ
from the value of <a href="#version_management">version_management</a>
used when compiling the driver.</p> </dd><dt><strong>erts_version</strong></dt><dd> <p>A string containing the version number of the runtime system
(the same as returned by
<a href="./erlang#system_info_version">erlang#system_info_version</a>).</p> </dd><dt><strong>otp_release</strong></dt><dd> <p>A string containing the OTP release number
(the same as returned by
<a href="./erlang#system_info_otp_release">erlang#system_info_otp_release</a>).</p> </dd><dt><strong>thread_support</strong></dt><dd> <p>A value <strong>!= 0</strong> if the runtime system has thread support;
otherwise <strong>0</strong>.</p> </dd><dt><strong>smp_support</strong></dt><dd> <p>A value <strong>!= 0</strong> if the runtime system has SMP support;
otherwise <strong>0</strong>.</p> </dd><dt><strong>async_threads</strong></dt><dd> <p>The number of async threads in the async thread pool used by
<a href="#driver_async">driver_async</a>
(the same as returned by
<a href="./erlang#system_info_thread_pool_size">erlang#system_info_thread_pool_size</a>).</p> </dd><dt><strong>scheduler_threads</strong></dt><dd> <p>The number of scheduler threads used by the runtime system
(the same as returned by
<a href="./erlang#system_info_schedulers">erlang#system_info_schedulers</a>).</p> </dd><dt><strong>nif_major_version</strong></dt><dd> <p>The value of <strong>ERL_NIF_MAJOR_VERSION</strong> when the runtime
system was compiled.</p> </dd><dt><strong>nif_minor_version</strong></dt><dd> <p>The value of <strong>ERL_NIF_MINOR_VERSION</strong> when the runtime
system was compiled.</p> </dd><dt><strong>dirty_scheduler_support</strong></dt><dd> <p>A value <strong>!= 0</strong> if the runtime system has support for dirty
scheduler threads; otherwise <strong>0</strong>.</p> </dd></dl> </dd><dt><a name="ErlDrvBinary"></a><strong>ErlDrvBinary</strong></dt><dd> <pre><code class="">
typedef struct ErlDrvBinary {
   ErlDrvSint orig_size;
   char orig_bytes[];
} ErlDrvBinary;</code></pre> <p>The <strong>ErlDrvBinary</strong> structure is a binary, as sent
between the emulator and the driver. All binaries are
reference counted; when <strong>driver_binary_free</strong> is called,
the reference count is decremented, when it reaches zero,
the binary is deallocated. <strong>orig_size</strong> is the binary size
and <strong>orig_bytes</strong> is the buffer.
<strong>ErlDrvBinary</strong> has not a fixed size, its size is
<strong>orig_size + 2 * sizeof(int)</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The <strong>refc</strong> field has been removed. The reference count of
an <strong>ErlDrvBinary</strong> is now stored elsewhere. The
reference count of an <strong>ErlDrvBinary</strong> can be accessed through
<a href="#driver_binary_get_refc">driver_binary_get_refc</a>,
<a href="#driver_binary_inc_refc">driver_binary_inc_refc</a>, and
<a href="#driver_binary_dec_refc">driver_binary_dec_refc</a>.</p></div> <p>Some driver calls, such as <strong>driver_enq_binary</strong>,
increment the driver reference count, and others, such as
<strong>driver_deq</strong> decrement it.</p> <p>Using a driver binary instead of a normal buffer is often
faster, as the emulator needs not to copy the data,
only the pointer is used.</p> <p>A driver binary allocated in the driver, with
<strong>driver_alloc_binary</strong>, is to be freed in the driver
(unless otherwise stated)
with <strong>driver_free_binary</strong>. (Notice that this does not
necessarily deallocate it, if the driver is still referred
in the emulator, the ref-count will not go to zero.)</p> <p>Driver binaries are used in the <strong>driver_output2</strong> and
<strong>driver_outputv</strong> calls, and in the queue. Also the
driver callback <a href="./driver_entry#outputv">driver_entry#outputv</a> uses driver binaries.</p> <p>If the driver for some reason wants to keep a
driver binary around, for example in a static variable, the
reference count is to be incremented, and the binary can later
be freed in the <a href="./driver_entry#stop">driver_entry#stop</a> callback, with <strong>driver_free_binary</strong>.</p> <p>Notice that as a driver binary is shared by the driver and
the emulator. A binary received from the emulator or sent to
the emulator must not be changed by the driver.</p> <p>Since ERTS 5.5 (Erlang/OTP R11B), <strong>orig_bytes</strong> is
guaranteed to be properly aligned for storage of an array of
doubles (usually 8-byte aligned).</p> </dd><dt><strong>ErlDrvData</strong></dt><dd> <p>A handle to driver-specific data,
passed to the driver callbacks. It is a pointer, and is
most often type cast to a specific pointer in the driver.</p> </dd><dt><strong>SysIOVec</strong></dt><dd> <p>A system I/O vector, as used by <strong>writev</strong> on
Unix and <strong>WSASend</strong> on Win32. It is used in
<strong>ErlIOVec</strong>.</p> </dd><dt><a name="ErlIOVec"></a><strong>ErlIOVec</strong></dt><dd> <pre><code class="">
typedef struct ErlIOVec {
  int vsize;
  ErlDrvSizeT size;
  SysIOVec* iov;
  ErlDrvBinary** binv;
} ErlIOVec;</code></pre> <p>The I/O vector used by the emulator and drivers is a list
of binaries, with a <strong>SysIOVec</strong> pointing to the buffers
of the binaries. It is used in <strong>driver_outputv</strong> and the
<a href="./driver_entry#outputv">driver_entry#outputv</a>
driver callback. Also, the driver queue is an
<strong>ErlIOVec</strong>.</p> </dd><dt><strong>ErlDrvMonitor</strong></dt><dd> <p>When a driver creates a monitor for a process, a
<strong>ErlDrvMonitor</strong> is filled in. This is an opaque
data type that can be assigned to, but not compared without
using the supplied compare function (that is, it behaves like
a struct).</p> <p>The driver writer is to provide the memory for storing the
monitor when calling <a href="#driver_monitor_process">driver_monitor_process</a>. The
address of the data is not stored outside of the driver, so
<strong>ErlDrvMonitor</strong> can be used as any other data, it
can be copied, moved in memory, forgotten, and so on.</p> </dd><dt><a name="ErlDrvNowData"></a><strong>ErlDrvNowData</strong></dt><dd> <p>The <strong>ErlDrvNowData</strong> structure holds a time stamp
consisting of three values measured from some arbitrary
point in the past. The three structure members are:</p> <dl><dt><strong>megasecs</strong></dt><dd>The number of whole megaseconds elapsed since the arbitrary point in time</dd><dt><strong>secs</strong></dt><dd>The number of whole seconds elapsed since the arbitrary point in time</dd><dt><strong>microsecs</strong></dt><dd>The number of whole microseconds elapsed since the arbitrary point in time</dd></dl> </dd><dt><a name="ErlDrvPDL"></a><strong>ErlDrvPDL</strong></dt><dd> <p>If certain port-specific data must be accessed from other
threads than those calling the driver callbacks, a port data lock
can be used to synchronize the operations on the data.
Currently, the only port-specific data that the emulator
associates with the port data lock is the driver queue.</p> <p>Normally a driver instance has no port data lock. If
the driver instance wants to use a port data lock, it must
create the port data lock by calling
<a href="#driver_pdl_create">driver_pdl_create</a>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Once the port data lock has been created, every
access to data associated with the port data lock must be done
while the port data lock is locked. The port data lock is
locked and unlocked by
<a href="#driver_pdl_lock">driver_pdl_lock</a>, and
<a href="#driver_pdl_unlock">driver_pdl_unlock</a>, respectively.</p></div> <p>A port data lock is reference counted, and when the reference
count reaches zero, it is destroyed. The emulator at
least increments the reference count once when the lock is
created and decrements it once the port associated with
the lock terminates. The emulator also increments the
reference count when an async job is enqueued and decrements
it when an async job has been invoked.
Also, the driver is responsible for ensuring that
the reference count does not reach zero before the last use
of the lock by the driver has been made. The reference count
can be read, incremented, and decremented by
<a href="#driver_pdl_get_refc">driver_pdl_get_refc</a>,
<a href="#driver_pdl_inc_refc">driver_pdl_inc_refc</a>, and
<a href="#driver_pdl_dec_refc">driver_pdl_dec_refc</a>, respectively.</p> </dd><dt><a name="ErlDrvTid"></a><strong>ErlDrvTid</strong></dt><dd> <p>Thread identifier.</p> <p>See also <a href="#erl_drv_thread_create">erl_drv_thread_create</a>,
<a href="#erl_drv_thread_exit">erl_drv_thread_exit</a>,
<a href="#erl_drv_thread_join">erl_drv_thread_join</a>,
<a href="#erl_drv_thread_self">erl_drv_thread_self</a>, and
<a href="#erl_drv_equal_tids">erl_drv_equal_tids</a>.</p> </dd><dt><a name="ErlDrvThreadOpts"></a><strong>ErlDrvThreadOpts</strong></dt><dd> <pre><code class="">
int suggested_stack_size;</code></pre> <p>Thread options structure passed to
<a href="#erl_drv_thread_create">erl_drv_thread_create</a>.
The following field exists:</p> <dl><dt><strong>suggested_stack_size</strong></dt><dd>A suggestion, in kilowords, on how large a stack to use. A value &lt; 0 means default size. </dd></dl> <p>See also <a href="#erl_drv_thread_opts_create">erl_drv_thread_opts_create</a>,
<a href="#erl_drv_thread_opts_destroy">erl_drv_thread_opts_destroy</a>, and
<a href="#erl_drv_thread_create">erl_drv_thread_create</a>.</p> </dd><dt><a name="ErlDrvMutex"></a><strong>ErlDrvMutex</strong></dt><dd> <p>Mutual exclusion lock. Used for synchronizing access to shared data.
Only one thread at a time can lock a mutex.</p> <p>See also <a href="#erl_drv_mutex_create">erl_drv_mutex_create</a>,
<a href="#erl_drv_mutex_destroy">erl_drv_mutex_destroy</a>,
<a href="#erl_drv_mutex_lock">erl_drv_mutex_lock</a>,
<a href="#erl_drv_mutex_trylock">erl_drv_mutex_trylock</a>, and
<a href="#erl_drv_mutex_unlock">erl_drv_mutex_unlock</a>.</p> </dd><dt><a name="ErlDrvCond"></a><strong>ErlDrvCond</strong></dt><dd> <p>Condition variable. Used when threads must wait for a specific
condition to appear before continuing execution. Condition variables
must be used with associated mutexes.</p> <p>See also <a href="#erl_drv_cond_create">erl_drv_cond_create</a>,
<a href="#erl_drv_cond_destroy">erl_drv_cond_destroy</a>,
<a href="#erl_drv_cond_signal">erl_drv_cond_signal</a>,
<a href="#erl_drv_cond_broadcast">erl_drv_cond_broadcast</a>, and
<a href="#erl_drv_cond_wait">erl_drv_cond_wait</a>.</p> </dd><dt><a name="ErlDrvRWLock"></a><strong>ErlDrvRWLock</strong></dt><dd> <p>Read/write lock. Used to allow multiple threads to read shared data
while only allowing one thread to write the same data. Multiple
threads can read lock an rwlock at the same time, while only
one thread can read/write lock an rwlock at a time.</p> <p>See also <a href="#erl_drv_rwlock_create">erl_drv_rwlock_create</a>,
<a href="#erl_drv_rwlock_destroy">erl_drv_rwlock_destroy</a>,
<a href="#erl_drv_rwlock_rlock">erl_drv_rwlock_rlock</a>,
<a href="#erl_drv_rwlock_tryrlock">erl_drv_rwlock_tryrlock</a>,
<a href="#erl_drv_rwlock_runlock">erl_drv_rwlock_runlock</a>,
<a href="#erl_drv_rwlock_rwlock">erl_drv_rwlock_rwlock</a>,
<a href="#erl_drv_rwlock_tryrwlock">erl_drv_rwlock_tryrwlock</a>, and
<a href="#erl_drv_rwlock_rwunlock">erl_drv_rwlock_rwunlock</a>.</p> </dd><dt><a name="ErlDrvTSDKey"></a><strong>ErlDrvTSDKey</strong></dt><dd> <p>Key that thread-specific data can be associated with.</p> <p>See also <a href="#erl_drv_tsd_key_create">erl_drv_tsd_key_create</a>,
<a href="#erl_drv_tsd_key_destroy">erl_drv_tsd_key_destroy</a>,
<a href="#erl_drv_tsd_set">erl_drv_tsd_set</a>, and
<a href="#erl_drv_tsd_get">erl_drv_tsd_get</a>.</p> </dd><dt><a name="ErlDrvTime"></a><strong>ErlDrvTime</strong></dt><dd> <p>A signed 64-bit integer type for time representation.</p> </dd><dt><a name="ErlDrvTimeUnit"></a><strong>ErlDrvTimeUnit</strong></dt><dd> <p>An enumeration of time units supported by the driver API:</p> <dl><dt><strong>ERL_DRV_SEC</strong></dt><dd>Seconds</dd><dt><strong>ERL_DRV_MSEC</strong></dt><dd>Milliseconds</dd><dt><strong>ERL_DRV_USEC</strong></dt><dd>Microseconds</dd><dt><strong>ERL_DRV_NSEC</strong></dt><dd>Nanoseconds</dd></dl> </dd></dl><h3>Functions</h3><h4>add_driver_entry(ErlDrvEntry
        *de):void</h4><p>Add a driver entry.</p><a name="add_driver_entry"></a><p>Adds a driver entry to the list of drivers known by Erlang.
The <a href="./driver_entry#init">driver_entry#init</a>
function of parameter <strong>de</strong> is called.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>To use this function for adding drivers residing in
dynamically loaded code is dangerous. If the driver code
for the added driver resides in the same dynamically
loaded module (that is, <strong>.so</strong> file) as a normal
dynamically loaded driver (loaded with the <strong>erl_ddll</strong>
interface), the caller is to call
<a href="#driver_lock_driver">driver_lock_driver</a> before
adding driver entries.</p><p><em>Use of this function is generally deprecated.</em></p></div><h4>driver_alloc(ErlDrvSizeT size):void *</h4><p>Allocate memory.</p><a name="driver_alloc"></a><p>Allocates a memory block of the size specified
in <strong>size</strong>, and returns it. This fails only on out of
memory, in which case <strong>NULL</strong> is returned. (This is most
often a wrapper for <strong>malloc</strong>).</p><p>Memory allocated must be explicitly freed with a corresponding
call to <a href="#driver_free">driver_free</a>
(unless otherwise stated).</p><p>This function is thread-safe.</p><h4>driver_alloc_binary(ErlDrvSizeT size):ErlDrvBinary *</h4><p>Allocate a driver binary.</p><a name="driver_alloc_binary"></a><p>Allocates a driver binary with a memory block
of at least <strong>size</strong> bytes, and returns a pointer to it,
or <strong>NULL</strong> on failure (out of memory). When a driver binary has
been sent to the emulator, it must not be changed. Every
allocated binary is to be freed by a corresponding call to
<a href="#driver_free_binary">driver_free_binary</a> (unless otherwise stated).</p><p>Notice that a driver binary has an internal reference counter.
This means that calling <strong>driver_free_binary</strong>, it may not
actually dispose of it. If it is sent to the emulator, it can
be referenced there.</p><p>The driver binary has a field, <strong>orig_bytes</strong>, which
marks the start of the data in the binary.</p><p>This function is thread-safe.</p><h4>driver_async(ErlDrvPort port, unsigned
        int* key, void (*async_invoke)(void*), void* async_data, void
        (*async_free)(void*)):long</h4><p>Perform an asynchronous call within a driver.</p><a name="driver_async"></a><p>Performs an asynchronous call. The function
<strong>async_invoke</strong> is invoked in a thread separate from the
emulator thread. This enables the driver to perform
time-consuming, blocking operations without blocking the
emulator.</p><p>The async thread pool size can be set with command-line argument
<a href="./erl#async_thread_pool_size">erl#async_thread_pool_size</a>
in <a href="erl">erl</a>.
If an async thread pool is unavailable, the call is made
synchronously in the thread calling <strong>driver_async</strong>. The
current number of async threads in the async thread pool can be
retrieved through <a href="#driver_system_info">driver_system_info</a>.</p><p>If a thread pool is available, a thread is used.
If argument <strong>key</strong> is <strong>NULL</strong>, the threads from the
pool are used in a round-robin way, each call to
<strong>driver_async</strong> uses the next thread in the pool. With
argument <strong>key</strong> set, this behavior is changed. The two
same values of <strong>*key</strong> always get the same thread.</p><p>To ensure that a driver instance always uses the same
thread, the following call can be used:</p><pre><code class="">
unsigned int myKey = driver_async_port_key(myPort);

r = driver_async(myPort, &amp;myKey, myData, myFunc);    </code></pre><p>It is enough to initialize <strong>myKey</strong> once for each
driver instance.</p><p>If a thread is already working, the calls are
queued up and executed in order. Using the same thread for
each driver instance ensures that the calls are made in sequence.</p><p>The <strong>async_data</strong> is the argument to the functions
<strong>async_invoke</strong> and <strong>async_free</strong>. It is typically a
pointer to a structure containing a pipe or event that
can be used to signal that the async operation completed.
The data is to be freed in <strong>async_free</strong>.</p><p>When the async operation is done,
<a href="./driver_entry#ready_async">driver_entry#ready_async</a> driver
entry function is called. If <strong>ready_async</strong> is <strong>NULL</strong> in
the driver entry, the <strong>async_free</strong> function is called
instead.</p><p>The return value is <strong>-1</strong> if the <strong>driver_async</strong> call
fails.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from ERTS 5.5.4.3 the default stack size for
threads in the async-thread pool is 16 kilowords,
that is, 64 kilobyte on 32-bit architectures.
This small default size has been chosen because the
amount of async-threads can be quite large. The
default stack size is enough for drivers delivered
with Erlang/OTP, but is possibly not sufficiently large
for other dynamically linked-in drivers that use the
<strong>driver_async</strong> functionality. A suggested stack size
for threads in the async-thread pool can be configured
through command-line argument
<a href="./erl#async_thread_stack_size">erl#async_thread_stack_size</a>
in <a href="erl">erl</a>.</p></div><h4>driver_async_port_key(ErlDrvPort
        port):unsigned int</h4><p>Calculate an async key from an ErlDrvPort.</p><a name="driver_async_port_key"></a><p>Calculates a key for later use in <a href="#driver_async">driver_async</a>. The keys are
evenly distributed so that a fair mapping between port IDs
and async thread IDs is achieved.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Before Erlang/OTP R16, the port ID could be used as a key
with proper casting, but after the rewrite of the port
subsystem, this is no longer the case. With this function, you
can achieve the same distribution based on port IDs as before
Erlang/OTP R16.</p></div><h4>driver_binary_dec_refc(ErlDrvBinary *bin):long</h4><p>Decrement the reference count of a driver binary.</p><a name="driver_binary_dec_refc"></a><p>Decrements the reference count on <strong>bin</strong> and returns
the reference count reached after the decrement.</p><p>This function is thread-safe.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The reference count of driver binary is normally to be decremented
by calling <a href="#driver_free_binary">driver_free_binary</a>.</p><p><strong>driver_binary_dec_refc</strong> does <em>not</em> free
the binary if the reference count reaches zero. <em>Only</em>
use <strong>driver_binary_dec_refc</strong> when you are sure
<em>not</em> to reach a reference count of zero.</p></div><h4>driver_binary_get_refc(ErlDrvBinary *bin):long</h4><p>Get the reference count of a driver binary.</p><a name="driver_binary_get_refc"></a><p>Returns the current reference count on <strong>bin</strong>.</p><p>This function is thread-safe.</p><h4>driver_binary_inc_refc(ErlDrvBinary *bin):long</h4><p>Increment the reference count of a driver binary.</p><a name="driver_binary_inc_refc"></a><p>Increments the reference count on <strong>bin</strong> and returns
the reference count reached after the increment.</p><p>This function is thread-safe.</p><h4>driver_caller(ErlDrvPort
        port):ErlDrvTermData</h4><p>Return the process making the driver call.</p><a name="driver_caller"></a><p>Returns the process ID of the process that
made the current call to the driver. The process ID can be used with
<a href="#driver_send_term">driver_send_term</a>
to send back data to the caller.
<strong>driver_caller</strong> only returns valid data
when currently executing in one of the following driver callbacks:</p><dl><dt><a href="./driver_entry#start">driver_entry#start</a></dt><dd>Called from <a href="./erlang#open_port/2">erlang#open_port/2</a>.</dd><dt><a href="./driver_entry#output">driver_entry#output</a></dt><dd>Called from <a href="./erlang#send/2">erlang#send/2</a> and <a href="./erlang#port_command/2">erlang#port_command/2</a>.</dd><dt><a href="./driver_entry#outputv">driver_entry#outputv</a></dt><dd>Called from <a href="./erlang#send/2">erlang#send/2</a> and <a href="./erlang#port_command/2">erlang#port_command/2</a>.</dd><dt><a href="./driver_entry#control">driver_entry#control</a></dt><dd>Called from <a href="./erlang#port_control/3">erlang#port_control/3</a>.</dd><dt><a href="./driver_entry#call">driver_entry#call</a></dt><dd>Called from <a href="./erlang#port_call/3">erlang#port_call/3</a>.</dd></dl><p>Notice that this function is <em>not</em> thread-safe, not
even when the emulator with SMP support is used.</p><h4>driver_cancel_timer(ErlDrvPort port):int</h4><p>Cancel a previously set timer.</p><a name="driver_cancel_timer"></a><p>Cancels a timer set with
<a href="#driver_set_timer">driver_set_timer</a>.</p><p>The return value is <strong>0</strong>.</p><h4>driver_compare_monitors(const ErlDrvMonitor
        *monitor1, const ErlDrvMonitor *monitor2):int</h4><p>Compare two monitors.</p><a name="driver_compare_monitors"></a><p>Compares two <strong>ErlDrvMonitor</strong>s.
Can also be used to imply some artificial order on monitors,
for whatever reason.</p><p>Returns <strong>0</strong> if <strong>monitor1</strong> and <strong>monitor2</strong> are equal,
&lt; <strong>0</strong> if <strong>monitor1</strong> &lt; <strong>monitor2</strong>, and
&gt; <strong>0</strong> if <strong>monitor1</strong> &gt; <strong>monitor2</strong>.</p><h4>driver_connected(ErlDrvPort
        port):ErlDrvTermData</h4><p>Return the port owner process.</p><a name="driver_connected"></a><p>Returns the port owner process.</p><p>Notice that this function is <em>not</em> thread-safe, not
even when the emulator with SMP support is used.</p><h4>driver_create_port(ErlDrvPort port,
        ErlDrvTermData owner_pid, char* name,
        ErlDrvData drv_data):ErlDrvPort</h4><p>Create a new port (driver instance).</p><p>Creates a new port executing the same driver
code as the port creating the new port.</p><dl><dt><strong>port</strong></dt><dd>The port handle of the port (driver instance) creating the new port.</dd><dt><strong>owner_pid</strong></dt><dd>The process ID of the Erlang process to become owner of the new port. This process will be linked to the new port. You usually want to use <strong>driver_caller(port)</strong> as <strong>owner_pid</strong>.</dd><dt><strong>name</strong></dt><dd>The port name of the new port. You usually want to use the same port name as the driver name (<a href="./driver_entry#driver_name">driver_entry#driver_name</a> field of the <a href="driver_entry">driver_entry</a>). </dd><dt><strong>drv_data</strong></dt><dd>The driver-defined handle that is passed in later calls to driver callbacks. Notice that the <a href="./driver_entry#start">driver start callback</a> is not called for this new driver instance. The driver-defined handle is normally created in the <a href="./driver_entry#start">driver start callback</a> when a port is created through <a href="./erlang#open_port/2">erlang#open_port/2</a>. </dd></dl><p>The caller of <strong>driver_create_port</strong> is allowed to
manipulate the newly created port when <strong>driver_create_port</strong>
has returned. When
<a href="#smp_support">port level locking</a>
is used, the creating port is only allowed to
manipulate the newly created port until the current driver
callback, which was called by the emulator, returns.</p><h4>driver_demonitor_process(ErlDrvPort port,
        const ErlDrvMonitor *monitor):int</h4><p>Stop monitoring a process from a driver.</p><a name="driver_demonitor_process"></a><p>Cancels a monitor created earlier.</p><p>Returns <strong>0</strong> if a monitor was removed and &gt; 0 if the monitor
no longer exists.</p><h4>driver_deq(ErlDrvPort port,
        ErlDrvSizeT size):ErlDrvSizeT</h4><p>Dequeue data from the head of the driver queue.</p><a name="driver_deq"></a><p>Dequeues data by moving the head pointer
forward in the driver queue by <strong>size</strong> bytes. The data
in the queue is deallocated.</p><p>Returns the number of bytes remaining in the queue on success,
otherwise <strong>-1</strong>.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><h4>driver_enq(ErlDrvPort port, char* buf,
        ErlDrvSizeT len):int</h4><p>Enqueue data in the driver queue.</p><a name="driver_enq"></a><p>Enqueues data in the driver queue. The data in
<strong>buf</strong> is copied (<strong>len</strong> bytes) and placed at the
end of the driver queue. The driver queue is normally used
in a FIFO way.</p><p>The driver queue is available to queue output from the
emulator to the driver (data from the driver to the emulator
is queued by the emulator in normal Erlang message
queues). This can be useful if the driver must wait for
slow devices, and so on, and wants to yield back to the
emulator. The driver queue is implemented as an <strong>ErlIOVec</strong>.</p><p>When the queue contains data, the driver does not close until
the queue is empty.</p><p>The return value is <strong>0</strong>.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><h4>driver_enq_bin(ErlDrvPort port,
        ErlDrvBinary *bin, ErlDrvSizeT offset, ErlDrvSizeT len):int</h4><p>Enqueue binary in the driver queue.</p><a name="driver_enq_bin"></a><p>Enqueues a driver binary in the driver
queue. The data in <strong>bin</strong> at <strong>offset</strong> with length
<strong>len</strong> is placed at the end of the queue. This function
is most often faster than
<a href="#driver_enq">driver_enq</a>,
because no data must be copied.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><p>The return value is <strong>0</strong>.</p><h4>driver_enqv(ErlDrvPort port, ErlIOVec *ev,
        ErlDrvSizeT skip):int</h4><p>Enqueue vector in the driver queue.</p><a name="driver_enqv"></a><p>Enqueues the data in <strong>ev</strong>, skipping the
first <strong>skip</strong> bytes of it, at the end of the driver
queue. It is faster than
<a href="#driver_enq">driver_enq</a>,
because no data must be copied.</p><p>The return value is <strong>0</strong>.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><h4>driver_failure(ErlDrvPort port, int
        error):int</h4><h4>driver_failure_atom(ErlDrvPort port, char
        *string):int</h4><h4>driver_failure_posix(ErlDrvPort port, int
        error):int</h4><p>Fail with error.</p><a name="driver_failure_atom"></a><a name="driver_failure_posix"></a><a name="driver_failure"></a><p>Signals to Erlang that the driver has
encountered an error and is to be closed. The port is
closed and the tuple <strong>{'EXIT', error, Err}</strong> is sent to
the port owner process, where error is an error atom
(<strong>driver_failure_atom</strong> and
<strong>driver_failure_posix</strong>) or an integer
(<strong>driver_failure</strong>).</p><p>The driver is to fail only when in severe error situations,
when the driver cannot possibly keep open, for example,
buffer allocation gets out of memory. For normal errors
it is more appropriate to send error codes with
<a href="#driver_output">driver_output</a>.</p><p>The return value is <strong>0</strong>.</p><h4>driver_failure_eof(ErlDrvPort
        port):int</h4><p>Fail with EOF.</p><a name="driver_failure_eof"></a><p>Signals to Erlang that the driver has
encountered an EOF and is to be closed, unless the port was
opened with option <strong>eof</strong>, in which case <strong>eof</strong> is sent
to the port. Otherwise the port is closed and an
<strong>'EXIT'</strong> message is sent to the port owner process.</p><p>The return value is <strong>0</strong>.</p><h4>driver_free(void *ptr):void</h4><p>Free an allocated memory block.</p><a name="driver_free"></a><p>Frees the memory pointed to by <strong>ptr</strong>. The
memory is to have been allocated with
<strong>driver_alloc</strong>. All allocated memory is to be
deallocated, only once. There is no garbage collection in
drivers.</p><p>This function is thread-safe.</p><h4>driver_free_binary(ErlDrvBinary *bin):void</h4><p>Free a driver binary.</p><a name="driver_free_binary"></a><p>Frees a driver binary <strong>bin</strong>, allocated previously with
<a href="#driver_alloc_binary">driver_alloc_binary</a>. As binaries
in Erlang are reference counted, the binary can still be around.</p><p>This function is thread-safe.</p><h4>driver_get_monitored_process(ErlDrvPort port, const
        ErlDrvMonitor *monitor):ErlDrvTermData</h4><p>Retrieve the process ID from a monitor.</p><a name="driver_get_monitored_process"></a><p>Returns the process ID associated with a living
monitor. It can be used in the
<a href="./driver_entry#process_exit">driver_entry#process_exit</a> callback to
get the process identification for the exiting process.</p><p>Returns <strong>driver_term_nil</strong> if the monitor no longer exists.</p><h4>driver_get_now(ErlDrvNowData *now):int</h4><p>Read a system time stamp.</p><a name="driver_get_now"></a><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p><em>This function is deprecated. Do not use it.</em> Use
<a href="#erl_drv_monotonic_time">erl_drv_monotonic_time</a> (perhaps in combination with
<a href="#erl_drv_time_offset">erl_drv_time_offset</a>) instead.</p></div><p>Reads a time stamp into the memory pointed to by
parameter <strong>now</strong>. For information about specific fields, see
<a href="#ErlDrvNowData">ErlDrvNowData</a>.</p><p>The return value is <strong>0</strong>, unless the <strong>now</strong> pointer is
invalid, in which case it is &lt; <strong>0</strong>.</p><h4>driver_lock_driver(ErlDrvPort
        port):int</h4><p>Ensure the driver is never unloaded.</p><a name="driver_lock_driver"></a><p>Locks the driver used by the port <strong>port</strong>
in memory for the rest of the emulator process'
lifetime. After this call, the driver behaves as one of Erlang's
statically linked-in drivers.</p><h4>driver_mk_atom(char*
        string):ErlDrvTermData</h4><p>Make an atom from a name.</p><a name="driver_mk_atom"></a><p>Returns an atom given a name
<strong>string</strong>. The atom is created and does not change, so the
return value can be saved and reused, which is faster than
looking up the atom several times.</p><p>Notice that this function is <em>not</em> thread-safe, not
even when the emulator with SMP support is used.</p><h4>driver_mk_port(ErlDrvPort
        port):ErlDrvTermData</h4><p>Make an Erlang term port from a port.</p><a name="driver_mk_port"></a><p>Converts a port handle to the Erlang term format, usable in
<a href="#erl_drv_output_term">erl_drv_output_term</a> and 
<a href="#erl_drv_send_term">erl_drv_send_term</a>.</p><p>Notice that this function is <em>not</em> thread-safe, not
even when the emulator with SMP support is used.</p><h4>driver_monitor_process(ErlDrvPort port,
        ErlDrvTermData process, ErlDrvMonitor *monitor):int</h4><p>Monitor a process from a driver.</p><a name="driver_monitor_process"></a><p>Starts monitoring a process from a driver. When a process is
monitored, a process exit results in a call to the provided
<a href="./driver_entry#process_exit">driver_entry#process_exit</a> callback
in the <a href="driver_entry">driver_entry</a>
structure. The <strong>ErlDrvMonitor</strong> structure is filled in, for later
removal or compare.</p><p>Parameter <strong>process</strong> is to be the return value of an
earlier call to <a href="#driver_caller">driver_caller</a> or
<a href="#driver_connected">driver_connected</a>
call.</p><p>Returns <strong>0</strong> on success, &lt; 0 if no callback is
provided, and &gt; 0 if the process is no longer alive.</p><h4>driver_output(ErlDrvPort port, char *buf,
        ErlDrvSizeT len):int</h4><p>Send data from driver to port owner.</p><a name="driver_output"></a><p>Sends data from the driver up to the emulator. The data is received
as terms or binary data, depending on how the driver port was
opened.</p><p>The data is queued in the port owner process' message
queue. Notice that this does not yield to the emulator (as
the driver and the emulator run in the same thread).</p><p>Parameter <strong>buf</strong> points to the data to send, and
<strong>len</strong> is the number of bytes.</p><p>The return value for all output functions is <strong>0</strong> for normal use.
If the driver is used for distribution, it can fail and return
<strong>-1</strong>.</p><h4>driver_output_binary(ErlDrvPort port, char
        *hbuf, ErlDrvSizeT hlen, ErlDrvBinary* bin, ErlDrvSizeT offset,
        ErlDrvSizeT len):int</h4><p>Send data from a driver binary to port owner.</p><a name="driver_output_binary"></a><p>Sends data to a port owner process from a
driver binary. It has a header buffer (<strong>hbuf</strong>
and <strong>hlen</strong>) just like
<a href="#driver_output2">driver_output2</a>.
Parameter <strong>hbuf</strong> can be <strong>NULL</strong>.</p><p>Parameter <strong>offset</strong> is an offset into the binary and
<strong>len</strong> is the number of bytes to send.</p><p>Driver binaries are created with
<a href="#driver_alloc_binary">driver_alloc_binary</a>.</p><p>The data in the header is sent as a list and the binary as
an Erlang binary in the tail of the list.</p><p>For example, if <strong>hlen</strong> is <strong>2</strong>, the port owner process
receives <strong>[H1, H2 | &lt;&lt;T&gt;&gt;]</strong>.</p><p>The return value is <strong>0</strong> for normal use.</p><p>Notice that, using the binary syntax in Erlang, the driver
application can match the header directly from the binary,
so the header can be put in the binary, and <strong>hlen</strong> can be set
to <strong>0</strong>.</p><h4>driver_output_term(ErlDrvPort port,
        ErlDrvTermData* term, int n):int</h4><p>Send term data from driver to port owner.</p><a name="driver_output_term"></a><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p><em>This function is deprecated.</em>
Use <a href="#erl_drv_send_term">erl_drv_send_term</a>instead.</p></div><p>Parameters <strong>term</strong> and <strong>n</strong> work as in
<a href="#erl_drv_output_term">erl_drv_output_term</a>.</p><p>Notice that this function is <em>not</em> thread-safe, not
even when the emulator with SMP support is used.</p><h4>driver_output2(ErlDrvPort port, char *hbuf,
        ErlDrvSizeT hlen, char *buf, ErlDrvSizeT len):int</h4><p>Send data and binary data to port owner.</p><a name="driver_output2"></a><p>First sends <strong>hbuf</strong>
(length in <strong>hlen</strong>) data as a list, regardless of port
settings. Then sends <strong>buf</strong> as a binary or list.
For example, if <strong>hlen</strong> is <strong>3</strong>, the port owner process
receives <strong>[H1, H2, H3 | T]</strong>.</p><p>The point of sending data as a list header, is to facilitate
matching on the data received.</p><p>The return value is <strong>0</strong> for normal use.</p><h4>driver_outputv(ErlDrvPort port, char* hbuf,
        ErlDrvSizeT hlen, ErlIOVec *ev, ErlDrvSizeT skip):int</h4><p>Send vectorized data to port owner.</p><a name="driver_outputv"></a><p>Sends data from an I/O vector, <strong>ev</strong>, to
the port owner process. It has a header buffer (<strong>hbuf</strong>
and <strong>hlen</strong>), just like <a href="#driver_output2">driver_output2</a>.</p><p>Parameter <strong>skip</strong> is a number of bytes to skip of
the <strong>ev</strong> vector from the head.</p><p>You get vectors of <strong>ErlIOVec</strong> type from the driver
queue (see below), and the
<a href="./driver_entry#outputv">driver_entry#outputv</a>
driver entry function. You can also make them yourself, if you want to
send several <strong>ErlDrvBinary</strong> buffers at once. Often
it is faster to use
<a href="#driver_output">driver_output</a> or
<a href="#driver_output_binary">driver_output_binary</a>.</p><p>For example, if <strong>hlen</strong> is <strong>2</strong> and <strong>ev</strong> points to an
array of three binaries, the port owner process receives
<strong>[H1, H2, &lt;&lt;B1&gt;&gt;, &lt;&lt;B2&gt;&gt; | &lt;&lt;B3&gt;&gt;]</strong>.</p><p>The return value is <strong>0</strong> for normal use.</p><p>The comment for <strong>driver_output_binary</strong> also applies for
<strong>driver_outputv</strong>.</p><h4>driver_pdl_create(ErlDrvPort port):ErlDrvPDL</h4><p>Create a port data lock.</p><a name="driver_pdl_create"></a><p>Creates a port data lock associated with the <strong>port</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Once a port data lock has been created, it must be locked during
all operations on the driver queue of the <strong>port</strong>.</p></div><p>Returns a newly created port data lock on success,
otherwise <strong>NULL</strong>. The function fails
if <strong>port</strong> is invalid or if a port data lock already has
been associated with the <strong>port</strong>.</p><h4>driver_pdl_dec_refc(ErlDrvPDL
        pdl):long</h4><a name="driver_pdl_dec_refc"></a><p>Decrements the reference count of
the port data lock passed as argument (<strong>pdl</strong>).</p><p>The current reference count after the decrement has
been performed is returned.</p><p>This function is thread-safe.</p><h4>driver_pdl_get_refc(ErlDrvPDL pdl):long</h4><a name="driver_pdl_get_refc"></a><p>Returns the current reference count of
the port data lock passed as argument (<strong>pdl</strong>).</p><p>This function is thread-safe.</p><h4>driver_pdl_inc_refc(ErlDrvPDL pdl):long</h4><a name="driver_pdl_inc_refc"></a><p>Increments the reference count of
the port data lock passed as argument (<strong>pdl</strong>).</p><p>The current reference count after the increment has
been performed is returned.</p><p>This function is thread-safe.</p><h4>driver_pdl_lock(ErlDrvPDL pdl):void</h4><p>Lock port data lock.</p><a name="driver_pdl_lock"></a><p>Locks the port data lock passed as argument (<strong>pdl</strong>).</p><p>This function is thread-safe.</p><h4>driver_pdl_unlock(ErlDrvPDL pdl):void</h4><p>Unlock port data lock.</p><a name="driver_pdl_unlock"></a><p>Unlocks the port data lock passed as argument (<strong>pdl</strong>).</p><p>This function is thread-safe.</p><h4>driver_peekq(ErlDrvPort port, int
        *vlen):SysIOVec *</h4><p>Get the driver queue as a vector.</p><a name="driver_peekq"></a><p>Retrieves the driver queue as a pointer to an
array of <strong>SysIOVec</strong>s. It also returns the number of
elements in <strong>vlen</strong>. This is one of two ways to get data
out of the queue.</p><p>Nothing is removed from the queue by this function, that must be done
with <a href="#driver_deq">driver_deq</a>.</p><p>The returned array is suitable to use with the Unix system
call <strong>writev</strong>.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><h4>driver_peekqv(ErlDrvPort port,
        ErlIOVec *ev):ErlDrvSizeT</h4><p>Get the driver queue as an I/O vector.</p><a name="driver_peekqv"></a><p>Retrieves the driver queue into a supplied
<strong>ErlIOVec</strong> <strong>ev</strong>. It also returns the queue size.
This is one of two ways to get data out of the queue.</p><p>If <strong>ev</strong> is <strong>NULL</strong>, all ones that is <strong>-1</strong> type cast to
<strong>ErlDrvSizeT</strong> are returned.</p><p>Nothing is removed from the queue by this function, that must be done
with <a href="#driver_deq">driver_deq</a>.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><h4>driver_pushq(ErlDrvPort port, char* buf,
        ErlDrvSizeT len):int</h4><p>Push data at the head of the driver queue.</p><a name="driver_pushq"></a><p>Puts data at the head of the driver queue. The
data in <strong>buf</strong> is copied (<strong>len</strong> bytes) and placed
at the beginning of the queue.</p><p>The return value is <strong>0</strong>.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><h4>driver_pushq_bin(ErlDrvPort port,
        ErlDrvBinary *bin, ErlDrvSizeT offset, ErlDrvSizeT len):int</h4><p>Push binary at the head of the driver queue.</p><a name="driver_pushq_bin"></a><p>Puts data in the binary <strong>bin</strong>, at
<strong>offset</strong> with length <strong>len</strong> at the head of the
driver queue. It is most often faster than
<a href="#driver_pushq">driver_pushq</a>,
because no data must be copied.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><p>The return value is <strong>0</strong>.</p><h4>driver_pushqv(ErlDrvPort port, ErlIOVec
        *ev, ErlDrvSizeT skip):int</h4><p>Push vector at the head of the driver queue.</p><a name="driver_pushqv"></a><p>Puts the data in <strong>ev</strong>, skipping the first
<strong>skip</strong> bytes of it, at the head of the driver queue.
It is faster than
<a href="#driver_pushq">driver_pushq</a>,
because no data must be copied.</p><p>The return value is <strong>0</strong>.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><h4>driver_read_timer(ErlDrvPort port, unsigned
        long *time_left):int</h4><p>Read the time left before time-out.</p><a name="driver_read_timer"></a><p>Reads the current time of a timer, and places
the result in <strong>time_left</strong>. This is the time in
milliseconds, before the time-out occurs.</p><p>The return value is <strong>0</strong>.</p><h4>driver_realloc(void *ptr, ErlDrvSizeT size):void *</h4><p>Resize an allocated memory block.</p><a name="driver_realloc"></a><p>Resizes a memory block, either in place, or by
allocating a new block, copying the data, and freeing the old
block. A pointer is returned to the reallocated memory. On
failure (out of memory), <strong>NULL</strong> is returned. (This is
most often a wrapper for <strong>realloc</strong>.)</p><p>This function is thread-safe.</p><h4>driver_realloc_binary(ErlDrvBinary *bin, ErlDrvSizeT size)
:ErlDrvBinary *</h4><p>Resize a driver binary.</p><a name="driver_realloc_binary"></a><p>Resizes a driver binary, while keeping the data.</p><p>Returns the resized driver binary on success. Returns <strong>NULL</strong>
on failure (out of memory).</p><p>This function is thread-safe.</p><h4>driver_select(ErlDrvPort port, ErlDrvEvent
        event, int mode, int on):int</h4><p>Provides an event for having the emulator call the driver. </p><a name="driver_select"></a><p>This function is used by drivers to provide the emulator with
events to check for. This enables the emulator to call the driver
when something has occurred asynchronously.</p><p>Parameter <strong>event</strong> identifies an OS-specific event object.
On Unix systems, the functions <strong>select</strong>/<strong>poll</strong> are used.
The event object must be a socket or pipe (or other object that
<strong>select</strong>/<strong>poll</strong> can use).
On Windows, the Win32 API function <strong>WaitForMultipleObjects</strong>
is used. This places other restrictions on the event object;
see the Win32 SDK documentation.</p><p>Parameter <strong>on</strong> is to be <strong>1</strong> for setting events
and <strong>0</strong> for clearing them.</p><p>Parameter <strong>mode</strong> is a bitwise OR combination of
<strong>ERL_DRV_READ</strong>, <strong>ERL_DRV_WRITE</strong>, and <strong>ERL_DRV_USE</strong>.
The first two specify whether to wait for read events and/or write
events. A fired read event calls
<a href="./driver_entry#ready_input">driver_entry#ready_input</a> and a fired write event calls
<a href="./driver_entry#ready_output">driver_entry#ready_output</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Some OS (Windows) do not differentiate between read and write
events. The callback for a fired event then only depends on the
value of <strong>mode</strong>.</p></div><p><strong>ERL_DRV_USE</strong> specifies if we are using the event object or
if we want to close it.
On an emulator with SMP support, it is not safe to clear all events
and then close the event object after <strong>driver_select</strong> has
returned. Another thread can still be using the event object
internally. To safely close an event object, call
<strong>driver_select</strong> with <strong>ERL_DRV_USE</strong> and <strong>on==0</strong>, which
clears all events and then either calls
<a href="./driver_entry#stop_select">driver_entry#stop_select</a>
or schedules it to be called when it is safe to close the event
object. <strong>ERL_DRV_USE</strong> is to be set together with the first event
for an event object. It is harmless to set <strong>ERL_DRV_USE</strong>
even if it already has been done. Clearing all events but keeping
<strong>ERL_DRV_USE</strong> set indicates that we are using the event
object and probably will set events for it again.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><strong>ERL_DRV_USE</strong> was added in Erlang/OTP R13. Old drivers still
work as before, but it is recommended to update them to use
<strong>ERL_DRV_USE</strong> and <strong>stop_select</strong> to ensure that event
objects are closed in a safe way.</p></div><p>The return value is <strong>0</strong>, unless
<strong>ready_input</strong>/<strong>ready_output</strong> is <strong>NULL</strong>, in which case
it is <strong>-1</strong>.</p><h4>driver_send_term(ErlDrvPort port,
        ErlDrvTermData receiver, ErlDrvTermData* term, int n):int</h4><p>Send term data to other process than port owner process. </p><a name="driver_send_term"></a><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p><em>This function is deprecated.</em>
Use <a href="#erl_drv_send_term">erl_drv_send_term</a> instead.</p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The parameters of this function
cannot be properly checked by the runtime system when
executed by arbitrary threads. This can cause the
function not to fail when it should.</p></div><p>Parameters <strong>term</strong> and <strong>n</strong> work as in
<a href="#erl_drv_output_term">erl_drv_output_term</a>.</p><p>This function is only thread-safe when the emulator with SMP
support is used.</p><h4>driver_set_timer(ErlDrvPort port, unsigned
        long time):int</h4><p>Set a timer to call the driver.</p><a name="driver_set_timer"></a><p>Sets a timer on the driver, which will count
down and call the driver when it is timed out. Parameter
<strong>time</strong> is the time in milliseconds before the timer expires.</p><p>When the timer reaches <strong>0</strong> and expires, the driver entry
function <a href="./driver_entry#timeout">driver_entry#timeout</a> is called.</p><p>Notice that only one timer exists on each driver instance;
setting a new timer replaces an older one.</p><p>Return value is <strong>0</strong>, unless the <strong>timeout</strong>
driver function is <strong>NULL</strong>, in which case it is <strong>-1</strong>.</p><h4>driver_sizeq(ErlDrvPort port):ErlDrvSizeT</h4><p>Return the size of the driver queue.</p><a name="driver_sizeq"></a><p>Returns the number of bytes currently in the driver queue.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><h4>driver_system_info(ErlDrvSysInfo
        *sys_info_ptr, size_t size):void</h4><p>Get information about the Erlang runtime system.</p><a name="driver_system_info"></a><p>Writes information about the Erlang runtime system into the
<a href="#ErlDrvSysInfo">ErlDrvSysInfo</a>
structure referred to by the first argument. The second
argument is to be the size of the
<a href="#ErlDrvSysInfo">ErlDrvSysInfo</a>
structure, that is, <strong>sizeof(ErlDrvSysInfo)</strong>.</p><p>For information about specific fields, see
<a href="#ErlDrvSysInfo">ErlDrvSysInfo</a>.</p><h4>driver_vec_to_buf(ErlIOVec *ev,
        char *buf, ErlDrvSizeT len):ErlDrvSizeT</h4><p>Collect data segments into a buffer.</p><a name="driver_vec_to_buf"></a><p>Collects several segments of data, referenced
by <strong>ev</strong>, by copying them in order to the buffer
<strong>buf</strong>, of the size <strong>len</strong>.</p><p>If the data is to be sent from the driver to the port owner
process, it is faster to use
<a href="#driver_outputv">driver_outputv</a>.</p><p>The return value is the space left in the buffer, that is, if
<strong>ev</strong> contains less than <strong>len</strong> bytes it is the
difference, and if <strong>ev</strong> contains <strong>len</strong> bytes or more,
it is <strong>0</strong>. This is faster if there is more than one header byte,
as the binary syntax can construct integers directly from
the binary.</p><h4>erl_drv_busy_msgq_limits(ErlDrvPort port,
        ErlDrvSizeT *low, ErlDrvSizeT *high):void</h4><p>Set and get limits for busy port message queue.</p><a name="erl_drv_busy_msgq_limits"></a><p>Sets and gets limits that will be used for controlling the
busy state of the port message queue.</p><p>The port message queue is set into a busy
state when the amount of command data queued on the
message queue reaches the <strong>high</strong> limit. The port
message queue is set into a not busy state when the
amount of command data queued on the message queue falls
below the <strong>low</strong> limit. Command data is in this
context data passed to the port using either
<strong>Port ! {Owner, {command, Data}}</strong> or
<strong>port_command/[2,3]</strong>. Notice that these limits
only concerns command data that have not yet reached the
port. The <a href="#set_busy_port">busy port</a>
feature can be used for data that has reached the port.</p><p>Valid limits are values in the range
<strong>[ERL_DRV_BUSY_MSGQ_LIM_MIN, ERL_DRV_BUSY_MSGQ_LIM_MAX]</strong>.
Limits are automatically adjusted to be sane. That is,
the system adjusts values so that the low limit used is
lower than or equal to the high limit used. By default the high
limit is 8 kB and the low limit is 4 kB.</p><p>By passing a pointer to an integer variable containing
the value <strong>ERL_DRV_BUSY_MSGQ_READ_ONLY</strong>, the currently used
limit is read and written back to the integer variable.
A new limit can be set by passing a pointer to an integer
variable containing a valid limit. The passed value is
written to the internal limit. The internal limit is then
adjusted. After this the adjusted limit is written
back to the integer variable from which the new value was
read. Values are in bytes.</p><p>The busy message queue feature can be disabled either
by setting the <strong>ERL_DRV_FLAG_NO_BUSY_MSGQ</strong>
<a href="./driver_entry#driver_flags">driver flag</a>
in the <a href="driver_entry">driver_entry</a>
used by the driver, or by calling this function with
<strong>ERL_DRV_BUSY_MSGQ_DISABLED</strong> as a limit (either low or
high). When this feature has been disabled, it cannot be
enabled again. When reading the limits, both are
<strong>ERL_DRV_BUSY_MSGQ_DISABLED</strong> if this
feature has been disabled.</p><p>Processes sending command data to the port are suspended
if either the port is busy or if the port message queue is
busy. Suspended processes are resumed when neither the
port or the port message queue is busy.</p><p>For information about busy port functionality, see
<a href="#set_busy_port">set_busy_port</a>.</p><h4>erl_drv_cond_broadcast(ErlDrvCond
        *cnd):void</h4><p>Broadcast on a condition variable.</p><a name="erl_drv_cond_broadcast"></a><p>Broadcasts on a condition variable. That is, if
other threads are waiting on the condition variable being
broadcast on, <em>all</em> of them are woken.</p><p><strong>cnd</strong> is a pointer to a condition variable to broadcast on.</p><p>This function is thread-safe.</p><h4>erl_drv_cond_create(char
        *name):ErlDrvCond *</h4><p>Create a condition variable.</p><a name="erl_drv_cond_create"></a><p>Creates a condition variable and returns a pointer to it.</p><p><strong>name</strong> is a string identifying the created condition variable.
It is used to identify the condition variable in planned
future debug functionality.</p><p>Returns <strong>NULL</strong> on failure. The driver
creating the condition variable is responsible for
destroying it before the driver is unloaded.</p><p>This function is thread-safe.</p><h4>erl_drv_cond_destroy(ErlDrvCond
        *cnd):void</h4><p>Destroy a condition variable.</p><a name="erl_drv_cond_destroy"></a><p>Destroys a condition variable previously created by
<a href="#erl_drv_cond_create">erl_drv_cond_create</a>.</p><p><strong>cnd</strong> is a pointer to a condition variable to destroy.</p><p>This function is thread-safe.</p><h4>erl_drv_cond_name(ErlDrvCond
        *cnd):char *</h4><p>Get name of driver mutex.</p><a name="erl_drv_cnd_name"></a><p>Returns a pointer to the name of the condition.</p><p><strong>cnd</strong> is a  pointer to an initialized condition.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is intended for debugging purposes only.</p></div><h4>erl_drv_cond_signal(ErlDrvCond
        *cnd):void</h4><p>Signal on a condition variable.</p><a name="erl_drv_cond_signal"></a><p>Signals on a condition variable. That is, if
other threads are waiting on the condition variable being
signaled, <em>one</em> of them is woken.</p><p><strong>cnd</strong> is a pointer to a condition variable to signal on.</p><p>This function is thread-safe.</p><h4>erl_drv_cond_wait(ErlDrvCond *cnd,
        ErlDrvMutex *mtx):void</h4><p>Wait on a condition variable.</p><a name="erl_drv_cond_wait"></a><p>Waits on a condition variable. The calling
thread is blocked until another thread wakes it by signaling
or broadcasting on the condition variable. Before the calling
thread is blocked, it unlocks the mutex passed as argument.
When the calling thread is woken, it locks the same mutex before
returning. That is, the mutex currently must be locked by
the calling thread when calling this function.</p><p><strong>cnd</strong> is a pointer to a condition variable to wait on.
<strong>mtx</strong> is a pointer to a mutex to unlock while waiting.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><strong>erl_drv_cond_wait</strong> can return even if
no one has signaled or broadcast on the condition
variable. Code calling <strong>erl_drv_cond_wait</strong> is
always to be prepared for <strong>erl_drv_cond_wait</strong>
returning even if the condition that the thread was
waiting for has not occurred. That is, when returning from
<strong>erl_drv_cond_wait</strong>, always check if the condition
has occurred, and if not call <strong>erl_drv_cond_wait</strong>  again.</p></div><p>This function is thread-safe.</p><h4>erl_drv_consume_timeslice(ErlDrvPort port,
        int percent):int</h4><p>Give the runtime system a hint about how much CPU time the current driver callback call has consumed.</p><a name="erl_drv_consume_timeslice"></a><p>Gives the runtime system a hint about how much CPU time the current
driver callback call has consumed since the last hint, or since the
the start of the callback if no previous hint has been given.</p><dl><dt><strong>port</strong></dt><dd>Port handle of the executing port.</dd><dt><strong>percent</strong></dt><dd>Approximate consumed fraction of a full time-slice in percent.</dd></dl><p>The time is specified as a fraction, in percent, of a full time-slice
that a port is allowed to execute before it is to surrender the
CPU to other runnable ports or processes. Valid range is
<strong>[1, 100]</strong>. The scheduling time-slice is not an exact entity,
but can usually be approximated to about 1 millisecond.</p><p>Notice that it is up to the runtime system to determine if and
how to use this information. Implementations on some platforms
can use other means to determine the consumed fraction
of the time-slice. Lengthy driver callbacks should, regardless of
this, frequently call this function to determine if it is allowed
to continue execution or not.</p><p>This function returns a non-zero value
if the time-slice has been exhausted, and zero if the callback is
allowed to continue execution. If a non-zero value is
returned, the driver callback is to return as soon as possible in
order for the port to be able to yield.</p><p>This function is provided to better support co-operative scheduling,
improve system responsiveness, and to make it easier to prevent
misbehaviors of the VM because of a port monopolizing a scheduler
thread. It can be used when dividing lengthy work into some repeated
driver callback calls, without the need to use threads.</p><p>See also the important <a href="#WARNING">warning</a>
text at the beginning of this manual page.</p><h4>erl_drv_convert_time_unit(ErlDrvTime
        val, ErlDrvTimeUnit from, ErlDrvTimeUnit to):ErlDrvTime</h4><p>Convert time unit of a time value.</p><a name="erl_drv_convert_time_unit"></a><p>Converts the <strong>val</strong> value of time unit <strong>from</strong> to
the corresponding value of time unit <strong>to</strong>. The result is
rounded using the floor function.</p><dl><dt><strong>val</strong></dt><dd>Value to convert time unit for.</dd><dt><strong>from</strong></dt><dd>Time unit of <strong>val</strong>.</dd><dt><strong>to</strong></dt><dd>Time unit of returned value.</dd></dl><p>Returns <strong>ERL_DRV_TIME_ERROR</strong> if called with an invalid
time unit argument.</p><p>See also <a href="#ErlDrvTime">ErlDrvTime</a> and
<a href="#ErlDrvTimeUnit">ErlDrvTimeUnit</a>.</p><h4>erl_drv_equal_tids(ErlDrvTid tid1,
        ErlDrvTid tid2):int</h4><p>Compare thread identifiers for equality.</p><a name="erl_drv_equal_tids"></a><p>Compares two thread identifiers, <strong>tid1</strong> and <strong>tid2</strong>,
for equality.</p><p>Returns <strong>0</strong> it they are not equal, and a value not equal to
<strong>0</strong> if they are equal.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>A thread identifier can be reused very quickly after
a thread has terminated. Therefore, if a thread
corresponding to one of the involved thread identifiers
has terminated since the thread identifier was saved,
the result of <strong>erl_drv_equal_tids</strong> does possibly not give
the expected result.</p></div><p>This function is thread-safe.</p><h4>erl_drv_getenv(const char *key, char
        *value, size_t *value_size):int</h4><p>Get the value of an environment variable.</p><a name="erl_drv_getenv"></a><p>Retrieves the value of an environment variable.</p><dl><dt><strong>key</strong></dt><dd>A <strong>NULL</strong>-terminated string containing the name of the environment variable.</dd><dt><strong>value</strong></dt><dd>A pointer to an output buffer.</dd><dt><strong>value_size</strong></dt><dd>A pointer to an integer. The integer is used both for passing input and output sizes (see below).</dd></dl><p>When this function is called, <strong>*value_size</strong> is to contain the
size of the <strong>value</strong> buffer.</p><p>On success, <strong>0</strong> is returned,
the value of the environment variable has been written to
the <strong>value</strong> buffer, and <strong>*value_size</strong> contains the
string length (excluding the terminating <strong>NULL</strong> character) of
the value written to the <strong>value</strong> buffer.</p><p>On failure, that is, no such environment variable was found,
a value &lt; <strong>0</strong> is returned. When the size of the <strong>value</strong>
buffer is too small, a value &gt; <strong>0</strong> is returned and
<strong>*value_size</strong> has been set to the buffer size needed.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function reads the emulated environment used by
<a href="../kernel/os#getenv/1">kernel/os#getenv/1</a> and not
the environment used by libc's <strong>getenv(3)</strong> or similar. Drivers
that <em>require</em> that these are in sync will need to do so
themselves, but keep in mind that they are segregated for a reason;
<strong>getenv(3)</strong> and its friends are <em>not thread-safe</em> and
may cause unrelated code to misbehave or crash the emulator.</p></div><p>This function is thread-safe.</p><h4>erl_drv_init_ack(ErlDrvPort port,
        ErlDrvData res):void</h4><p>Acknowledge the start of the port.</p><a name="erl_drv_init_ack"></a><p>Acknowledges the start of the port.</p><dl><dt><strong>port</strong></dt><dd>The port handle of the port (driver instance) doing the acknowledgment. </dd><dt><strong>res</strong></dt><dd>The result of the port initialization. Can be the same values as the return value of <a href="./driver_entry#start">driver_entry#start</a>, that is, any of the error codes or the <strong>ErlDrvData</strong> that is to be used for this port. </dd></dl><p>When this function is called the initiating <strong>erlang:open_port</strong>
call is returned as if the <a href="./driver_entry#start">driver_entry#start</a> function had just been called. It can only be
used when flag <a href="./driver_entry#driver_flags">driver_entry#driver_flags</a>
has been set on the linked-in driver.</p><h4>erl_drv_monotonic_time(ErlDrvTimeUnit time_unit):ErlDrvTime</h4><p>Get Erlang monotonic time.</p><a name="erl_drv_monotonic_time"></a><p>Returns <a href="./time_correction#Erlang_Monotonic_Time"> Erlang monotonic time</a>. Notice that negative values are
not uncommon.</p><p><strong>time_unit</strong> is time unit of returned value.</p><p>Returns <strong>ERL_DRV_TIME_ERROR</strong> if called with an invalid
time unit argument, or if called from a thread that is not a
scheduler thread.</p><p>See also <a href="#ErlDrvTime">ErlDrvTime</a>
and <a href="#ErlDrvTimeUnit">ErlDrvTimeUnit</a>.</p><h4>erl_drv_mutex_create(char
        *name):ErlDrvMutex *</h4><p>Create a mutex.</p><a name="erl_drv_mutex_create"></a><p>Creates a mutex and returns a pointer to it.</p><p><strong>name</strong> is a string identifying the created mutex. It is used
to identify the mutex in planned future debug functionality.</p><p>Returns <strong>NULL</strong> on failure. The driver creating the mutex is
responsible for destroying it before the driver is unloaded.</p><p>This function is thread-safe.</p><h4>erl_drv_mutex_destroy(ErlDrvMutex
        *mtx):void</h4><p>Destroy a mutex.</p><a name="erl_drv_mutex_destroy"></a><p>Destroys a mutex previously created by
<a href="#erl_drv_mutex_create">erl_drv_mutex_create</a>.
The mutex must be in an unlocked state before it is destroyed.</p><p><strong>mtx</strong> is a pointer to a mutex to destroy.</p><p>This function is thread-safe.</p><h4>erl_drv_mutex_lock(ErlDrvMutex
        *mtx):void</h4><p>Lock a mutex.</p><a name="erl_drv_mutex_lock"></a><p>Locks a mutex. The calling thread is blocked until the mutex has
been locked. A thread that has currently locked the mutex
<em>cannot</em> lock the same mutex again.</p><p><strong>mtx</strong> is a pointer to a mutex to lock.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If you leave a mutex locked in an emulator thread
when you let the thread out of your control, you will
<em>very likely</em> deadlock the whole emulator.</p></div><p>This function is thread-safe.</p><h4>erl_drv_mutex_name(ErlDrvMutex
        *mtx):char *</h4><p>Get name of driver mutex.</p><a name="erl_drv_mutex_name"></a><p>Returns a pointer to the mutex name.</p><p><strong>mtx</strong> is a pointer to an initialized mutex.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is intended for debugging purposes only.</p></div><h4>erl_drv_mutex_trylock(ErlDrvMutex
        *mtx):int</h4><p>Try lock a mutex.</p><a name="erl_drv_mutex_trylock"></a><p>Tries to lock a mutex. A thread that has currently locked the mutex
<em>cannot</em> try to lock the same mutex again.</p><p><strong>mtx</strong> is a pointer to a mutex to try to lock.</p><p>Returns <strong>0</strong> on success, otherwise <strong>EBUSY</strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If you leave a mutex locked in an emulator thread
when you let the thread out of your control, you will
<em>very likely</em> deadlock the whole emulator.</p></div><p>This function is thread-safe.</p><h4>erl_drv_mutex_unlock(ErlDrvMutex
        *mtx):void</h4><p>Unlock a mutex.</p><a name="erl_drv_mutex_unlock"></a><p>Unlocks a mutex. The mutex currently must be
locked by the calling thread.</p><p><strong>mtx</strong> is a pointer to a mutex to unlock.</p><p>This function is thread-safe.</p><h4>erl_drv_output_term(ErlDrvTermData port,
        ErlDrvTermData* term, int n):int</h4><p>Send term data from driver to port owner.</p><a name="erl_drv_output_term"></a><p>Sends data in the special driver term
format to the port owner process. This is a fast way to
deliver term data from a driver. It needs no binary
conversion, so the port owner process receives data as
normal Erlang terms. The <a href="#erl_drv_send_term">erl_drv_send_term</a>
functions can be used for sending to any process
on the local node.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Parameter <strong>port</strong> is <em>not</em>
an ordinary port handle, but a port handle converted using
<a href="#driver_mk_port">driver_mk_port</a>.</p></div><p>Parameter <strong>term</strong> points to an array of
<strong>ErlDrvTermData</strong> with <strong>n</strong> elements. This array
contains terms described in the driver term format. Every
term consists of 1-4 elements in the array. The
first term has a term type and then arguments.
Parameter <strong>port</strong> specifies the sending port.</p><p>Tuples, maps, and lists (except strings, see below)
are built in reverse polish notation, so that to build a
tuple, the elements are specified first, and then the tuple
term, with a count. Likewise for lists and maps.</p><ul><li> <p>A tuple must be specified with the number of elements. (The
elements precede the <strong>ERL_DRV_TUPLE</strong> term.)</p> </li><li> <p>A map must be specified with the number of key-value pairs
<strong>N</strong>. The key-value pairs must precede the <strong>ERL_DRV_MAP</strong>
in this order: <strong>key1,value1,key2,value2,...,keyN,valueN</strong>.
Duplicate keys are not allowed.</p> </li><li> <p>A list must be specified with the number of elements,
including the tail, which is the last term preceding
<strong>ERL_DRV_LIST</strong>.</p> </li></ul><p>The special term <strong>ERL_DRV_STRING_CONS</strong> is used to
"splice" in a string in a list, a string specified this way is
not a list in itself, but the elements are elements of the
surrounding list.</p><pre>
Term type            Arguments
---------            ---------
ERL_DRV_NIL
ERL_DRV_ATOM         ErlDrvTermData atom (from driver_mk_atom(char *string))
ERL_DRV_INT          ErlDrvSInt integer
ERL_DRV_UINT         ErlDrvUInt integer
ERL_DRV_INT64        ErlDrvSInt64 *integer_ptr
ERL_DRV_UINT64       ErlDrvUInt64 *integer_ptr
ERL_DRV_PORT         ErlDrvTermData port (from driver_mk_port(ErlDrvPort port))
ERL_DRV_BINARY       ErlDrvBinary *bin, ErlDrvUInt len, ErlDrvUInt offset
ERL_DRV_BUF2BINARY   char *buf, ErlDrvUInt len
ERL_DRV_STRING       char *str, int len
ERL_DRV_TUPLE        int sz
ERL_DRV_LIST         int sz
ERL_DRV_PID          ErlDrvTermData pid (from driver_connected(ErlDrvPort port)
                     or driver_caller(ErlDrvPort port))
ERL_DRV_STRING_CONS  char *str, int len
ERL_DRV_FLOAT        double *dbl
ERL_DRV_EXT2TERM     char *buf, ErlDrvUInt len
ERL_DRV_MAP          int sz</pre><p>The unsigned integer data type <strong>ErlDrvUInt</strong> and the
signed integer data type <strong>ErlDrvSInt</strong> are 64 bits wide
on a 64-bit runtime system and 32 bits wide on a 32-bit
runtime system. They were introduced in ERTS 5.6
and replaced some of the <strong>int</strong> arguments in the list above.</p><p>The unsigned integer data type <strong>ErlDrvUInt64</strong> and the
signed integer data type <strong>ErlDrvSInt64</strong> are always 64 bits
wide. They were introduced in ERTS 5.7.4.</p><p>To build the tuple <strong>{tcp, Port, [100 | Binary]}</strong>, the
following call can be made.</p><pre><code class="">
ErlDrvBinary* bin = ...
ErlDrvPort port = ...
ErlDrvTermData spec[] = {
    ERL_DRV_ATOM, driver_mk_atom("tcp"),
    ERL_DRV_PORT, driver_mk_port(drvport),
        ERL_DRV_INT, 100,
        ERL_DRV_BINARY, bin, 50, 0,
        ERL_DRV_LIST, 2,
    ERL_DRV_TUPLE, 3,
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));    </code></pre><p>Here <strong>bin</strong> is a driver binary of length at least 50 and
<strong>drvport</strong> is a port handle. Notice that <strong>ERL_DRV_LIST</strong>
comes after the elements of the list, likewise
<strong>ERL_DRV_TUPLE</strong>.</p><p>The <strong>ERL_DRV_STRING_CONS</strong> term is a way to construct
strings. It works differently from how <strong>ERL_DRV_STRING</strong>
works. <strong>ERL_DRV_STRING_CONS</strong> builds a string list in
reverse order (as opposed to how <strong>ERL_DRV_LIST</strong>
works), concatenating the strings added to a list. The tail
must be specified before <strong>ERL_DRV_STRING_CONS</strong>.</p><p><strong>ERL_DRV_STRING</strong> constructs a string, and ends
it. (So it is the same as <strong>ERL_DRV_NIL</strong> followed by
<strong>ERL_DRV_STRING_CONS</strong>.)</p><pre><code class="">
/* to send [x, "abc", y] to the port: */
ErlDrvTermData spec[] = {
    ERL_DRV_ATOM, driver_mk_atom("x"),
    ERL_DRV_STRING, (ErlDrvTermData)"abc", 3,
    ERL_DRV_ATOM, driver_mk_atom("y"),
    ERL_DRV_NIL,
    ERL_DRV_LIST, 4
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));    </code></pre><pre><code class="">
/* to send "abc123" to the port: */
ErlDrvTermData spec[] = {
    ERL_DRV_NIL,        /* with STRING_CONS, the tail comes first */
    ERL_DRV_STRING_CONS, (ErlDrvTermData)"123", 3,
    ERL_DRV_STRING_CONS, (ErlDrvTermData)"abc", 3,
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));    </code></pre><p>The <strong>ERL_DRV_EXT2TERM</strong> term type is used for passing a
term encoded with the
<a href="erl_ext_dist">external format</a>,
that is, a term that has been encoded by
<a href="./erlang#term_to_binary/2">erlang#term_to_binary/2</a>,
<a href="./ei">erl_interface/ei</a>,
and so on.
For example, if <strong>binp</strong> is a pointer to an <strong>ErlDrvBinary</strong>
that contains term <strong>{17, 4711}</strong> encoded with the
<a href="erl_ext_dist">external format</a>,
and you want to wrap it in a two-tuple with the tag <strong>my_tag</strong>,
that is, <strong>{my_tag, {17, 4711}}</strong>, you can do as follows:</p><pre><code class="">
ErlDrvTermData spec[] = {
        ERL_DRV_ATOM, driver_mk_atom("my_tag"),
        ERL_DRV_EXT2TERM, (ErlDrvTermData) binp-&gt;orig_bytes, binp-&gt;orig_size
    ERL_DRV_TUPLE, 2,
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));    </code></pre><p>To build the map <strong>#{key1 =&gt; 100, key2 =&gt; {200, 300}}</strong>, the
following call can be made.</p><pre><code class="">
ErlDrvPort port = ...
ErlDrvTermData spec[] = {
    ERL_DRV_ATOM, driver_mk_atom("key1"),
        ERL_DRV_INT, 100,
    ERL_DRV_ATOM, driver_mk_atom("key2"),
        ERL_DRV_INT, 200,
        ERL_DRV_INT, 300,
    ERL_DRV_TUPLE, 2,
    ERL_DRV_MAP, 2
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));    </code></pre><p>If you want to pass a binary and do not already have the content
of the binary in an <strong>ErlDrvBinary</strong>, you can benefit from using
<strong>ERL_DRV_BUF2BINARY</strong> instead of creating an <strong>ErlDrvBinary</strong>
through <a href="#driver_alloc_binary">driver_alloc_binary</a> and then pass the binary through
<strong>ERL_DRV_BINARY</strong>. The runtime system often allocates
binaries smarter if <strong>ERL_DRV_BUF2BINARY</strong> is used.
However, if the content of the binary to pass already resides in
an <strong>ErlDrvBinary</strong>, it is normally better to pass the binary using
<strong>ERL_DRV_BINARY</strong> and the <strong>ErlDrvBinary</strong> in question.</p><p>The <strong>ERL_DRV_UINT</strong>, <strong>ERL_DRV_BUF2BINARY</strong>, and
<strong>ERL_DRV_EXT2TERM</strong> term types were introduced in
ERTS 5.6.</p><p>This function is only thread-safe when the emulator with SMP
support is used.</p><h4>erl_drv_putenv(const char *key, char
        *value):int</h4><p>Set the value of an environment variable.</p><a name="erl_drv_putenv"></a><p>Sets the value of an environment variable.</p><p><strong>key</strong> is a <strong>NULL</strong>-terminated string containing the
name of the environment variable.</p><p><strong>value</strong> is a <strong>NULL</strong>-terminated string containing the
new value of the environment variable.</p><p>Returns <strong>0</strong> on success, otherwise a value <strong>!= 0</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The result of passing the empty string (<strong>""</strong>) as a value
is platform-dependent. On some platforms the variable value
is set to the empty string, on others the
environment variable is removed.</p></div><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function modifies the emulated environment used by
<a href="../kernel/os#putenv/2">kernel/os#putenv/2</a> and not
the environment used by libc's <strong>putenv(3)</strong> or similar. Drivers
that <em>require</em> that these are in sync will need to do so
themselves, but keep in mind that they are segregated for a reason;
<strong>putenv(3)</strong> and its friends are <em>not thread-safe</em> and
may cause unrelated code to misbehave or crash the emulator.</p></div><p>This function is thread-safe.</p><h4>erl_drv_rwlock_create(char
        *name):ErlDrvRWLock *</h4><p>Create an rwlock.</p><a name="erl_drv_rwlock_create"></a><p>Creates an rwlock and returns a pointer to it.</p><p><strong>name</strong> is a string identifying the created rwlock.
It is used to identify the rwlock in planned future
debug functionality.</p><p>Returns <strong>NULL</strong> on failure. The driver creating the rwlock
is responsible for destroying it before the driver is unloaded.</p><p>This function is thread-safe.</p><h4>erl_drv_rwlock_destroy(ErlDrvRWLock
        *rwlck):void</h4><p>Destroy an rwlock.</p><a name="erl_drv_rwlock_destroy"></a><p>Destroys an rwlock previously created by
<a href="#erl_drv_rwlock_create">erl_drv_rwlock_create</a>.
The rwlock must be in an unlocked state before it is destroyed.</p><p><strong>rwlck</strong> is a pointer to an rwlock to destroy.</p><p>This function is thread-safe.</p><h4>erl_drv_rwlock_name(ErlDrvRWLock
        *rwlck):char *</h4><p>Get name of driver mutex.</p><a name="erl_drv_rwlock_name"></a><p>Returns a pointer to the name of the rwlock.</p><p><strong>rwlck</strong> is a pointer to an initialized rwlock.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is intended for debugging purposes only.</p></div><h4>erl_drv_rwlock_rlock(ErlDrvRWLock
        *rwlck):void</h4><p>Read lock an rwlock.</p><a name="erl_drv_rwlock_rlock"></a><p>Read locks an rwlock. The calling thread is
blocked until the rwlock has been read locked. A thread
that currently has read or read/write locked the rwlock
<em>cannot</em> lock the same rwlock again.</p><p><strong>rwlck</strong> is a pointer to the rwlock to read lock.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If you leave an rwlock locked in an emulator thread
when you let the thread out of your control, you will
<em>very likely</em> deadlock the whole emulator.</p></div><p>This function is thread-safe.</p><h4>erl_drv_rwlock_runlock(ErlDrvRWLock
        *rwlck):void</h4><p>Read unlock an rwlock.</p><a name="erl_drv_rwlock_runlock"></a><p>Read unlocks an rwlock. The rwlock currently must
be read locked by the calling thread.</p><p><strong>rwlck</strong> is a pointer to an rwlock to read unlock.</p><p>This function is thread-safe.</p><h4>erl_drv_rwlock_rwlock(ErlDrvRWLock
        *rwlck):void</h4><p>Read/write lock an rwlock.</p><a name="erl_drv_rwlock_rwlock"></a><p>Read/write locks an rwlock. The calling thread
is blocked until the rwlock has been read/write locked.
A thread that currently has read or read/write locked the
rwlock <em>cannot</em> lock the same rwlock again.</p><p><strong>rwlck</strong> is a pointer to an rwlock to read/write lock.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If you leave an rwlock locked in an emulator thread
when you let the thread out of your control, you will
<em>very likely</em> deadlock the whole emulator.</p></div><p>This function is thread-safe.</p><h4>erl_drv_rwlock_rwunlock(ErlDrvRWLock
        *rwlck):void</h4><p>Read/write unlock an rwlock.</p><a name="erl_drv_rwlock_rwunlock"></a><p>Read/write unlocks an rwlock. The rwlock currently must be
read/write locked by the calling thread.</p><p><strong>rwlck</strong> is a pointer to an rwlock to read/write unlock.</p><p>This function is thread-safe.</p><h4>erl_drv_rwlock_tryrlock(ErlDrvRWLock
        *rwlck):int</h4><p>Try to read lock an rwlock.</p><a name="erl_drv_rwlock_tryrlock"></a><p>Tries to read lock an rwlock.</p><p><strong>rwlck</strong> is a pointer to an rwlock to try to read lock.</p><p>Returns <strong>0</strong> on success, otherwise <strong>EBUSY</strong>.
A thread that currently has read or read/write locked the
rwlock <em>cannot</em> try to lock the same rwlock again.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If you leave an rwlock locked in an emulator thread
when you let the thread out of your control, you will
<em>very likely</em> deadlock the whole emulator.</p></div><p>This function is thread-safe.</p><h4>erl_drv_rwlock_tryrwlock(ErlDrvRWLock
        *rwlck):int</h4><p>Try to read/write lock an rwlock.</p><a name="erl_drv_rwlock_tryrwlock"></a><p>Tries to read/write lock an rwlock.
A thread that currently has read or read/write locked the
rwlock <em>cannot</em> try to lock the same rwlock again.</p><p><strong>rwlck</strong>is pointer to an rwlock to try to read/write lock.</p><p>Returns <strong>0</strong> on success, otherwise <strong>EBUSY</strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If you leave an rwlock locked in an emulator thread
when you let the thread out of your control, you will
<em>very likely</em> deadlock the whole emulator.</p></div><p>This function is thread-safe.</p><h4>erl_drv_send_term(ErlDrvTermData port,
        ErlDrvTermData receiver, ErlDrvTermData* term, int n):int</h4><p>Send term data to other process than port owner process. </p><a name="erl_drv_send_term"></a><p>This function is the only way for a driver to send data to
<em>other</em> processes than the port owner process. Parameter
<strong>receiver</strong> specifies the process to receive the data.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Parameter <strong>port</strong> is <em>not</em> an ordinary port handle, but
a port handle converted using
<a href="#driver_mk_port">driver_mk_port</a>.</p></div><p>Parameters <strong>port</strong>, <strong>term</strong>, and <strong>n</strong> work as in
<a href="#erl_drv_output_term">erl_drv_output_term</a>.</p><p>This function is only thread-safe when the emulator with SMP
support is used.</p><h4>erl_drv_set_os_pid(ErlDrvPort port,
        ErlDrvSInt pid):void</h4><p>Set the os_pid for the port.</p><a name="erl_drv_set_os_pid"></a><p>Sets the <strong>os_pid</strong> seen when doing
<a href="./erlang#port_info/2">erlang#port_info/2</a> on this port.</p><p><strong>port</strong> is the port handle of the port (driver instance) to set
the pid on. <strong>pid</strong>is the pid to set.</p><h4>erl_drv_thread_create(char *name, ErlDrvTid
        *tid, void * (*func)(void *), void *arg, ErlDrvThreadOpts
        *opts):int</h4><p>Create a thread.</p><a name="erl_drv_thread_create"></a><p>Creates a new thread.</p><dl><dt><strong>name</strong></dt><dd>A string identifying the created thread. It is used to identify the thread in planned future debug functionality. </dd><dt><strong>tid</strong></dt><dd>A pointer to a thread identifier variable.</dd><dt><strong>func</strong></dt><dd>A pointer to a function to execute in the created thread.</dd><dt><strong>arg</strong></dt><dd>A pointer to argument to the <strong>func</strong> function.</dd><dt><strong>opts</strong></dt><dd>A pointer to thread options to use or <strong>NULL</strong>.</dd></dl><p>Returns <strong>0</strong> on success,
otherwise an <strong>errno</strong> value is returned to indicate the error.
The newly created thread begins executing in the function pointed
to by <strong>func</strong>, and <strong>func</strong> is passed <strong>arg</strong> as
argument. When <strong>erl_drv_thread_create</strong> returns, the thread
identifier of the newly created thread is available in
<strong>*tid</strong>. <strong>opts</strong> can be either a <strong>NULL</strong> pointer, or a
pointer to an
<a href="#ErlDrvThreadOpts">ErlDrvThreadOpts</a>
structure. If <strong>opts</strong> is a <strong>NULL</strong> pointer, default options
are used, otherwise the passed options are used.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>You are not allowed to allocate the
<a href="#ErlDrvThreadOpts">ErlDrvThreadOpts</a> structure by yourself.
It must be allocated and initialized by
<a href="#erl_drv_thread_opts_create">erl_drv_thread_opts_create</a>.</p></div><p>The created thread terminates either when <strong>func</strong> returns or if
<a href="#erl_drv_thread_exit">erl_drv_thread_exit</a>
is called by the thread. The exit value of the thread is either
returned from <strong>func</strong> or passed as argument to
<a href="#erl_drv_thread_exit">erl_drv_thread_exit</a>.
The driver creating the thread is responsible for joining the
thread, through <a href="#erl_drv_thread_join">erl_drv_thread_join</a>,
before the driver is unloaded. "Detached" threads cannot be created,
that is, threads that do not need to be joined.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>All created threads must be joined by the driver before
it is unloaded. If the driver fails to join all threads
created before it is unloaded, the runtime system
most likely crashes when the driver code is unloaded.</p></div><p>This function is thread-safe.</p><h4>erl_drv_thread_exit(void
        *exit_value):void</h4><p>Terminate calling thread.</p><a name="erl_drv_thread_exit"></a><p>Terminates the calling thread with the exit value passed as
argument. <strong>exit_value</strong> is a pointer to an exit value or
<strong>NULL</strong>.</p><p>You are only allowed to terminate threads created with
<a href="#erl_drv_thread_create">erl_drv_thread_create</a>.</p><p>The exit value can later be retrieved by another thread through
<a href="#erl_drv_thread_join">erl_drv_thread_join</a>.</p><p>This function is thread-safe.</p><h4>erl_drv_thread_join(ErlDrvTid tid, void
        **exit_value):int</h4><p>Join with another thread.</p><a name="erl_drv_thread_join"></a><p>Joins the calling thread with another thread, that is,
the calling thread is blocked until the thread identified by
<strong>tid</strong> has terminated.</p><p><strong>tid</strong> is the thread identifier of the thread to join.
<strong>exit_value</strong> is a pointer to a pointer to an exit value,
or <strong>NULL</strong>.</p><p>Returns <strong>0</strong> on success, otherwise an <strong>errno</strong>
value is returned to indicate the error.</p><p>A thread can only be joined once. The behavior of joining
more than once is undefined, an emulator crash is likely. If
<strong>exit_value == NULL</strong>, the exit value of the terminated thread
is ignored, otherwise the exit value of the terminated thread
is stored at <strong>*exit_value</strong>.</p><p>This function is thread-safe.</p><h4>erl_drv_thread_name(ErlDrvTid
        tid):char *</h4><p>Get name of driver mutex.</p><a name="erl_drv_rwlock_name"></a><p>Returns a pointer to the name of the thread.</p><p><strong>tid</strong> is a thread identifier.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is intended for debugging purposes only.</p></div><h4>erl_drv_thread_opts_create(char *name):ErlDrvThreadOpts *</h4><p>Create thread options.</p><a name="erl_drv_thread_opts_create"></a><p>Allocates and initializes a thread option structure.</p><p><strong>name</strong> is a string identifying the created thread options.
It is used to identify the thread options in planned future debug
functionality.</p><p>Returns <strong>NULL</strong> on failure. A thread option
structure is used for passing options to
<a href="#erl_drv_thread_create">erl_drv_thread_create</a>.
If the structure is not modified before it is passed to
<a href="#erl_drv_thread_create">erl_drv_thread_create</a>,
the default values are used.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>You are not allowed to allocate the
<a href="#ErlDrvThreadOpts">ErlDrvThreadOpts</a>
structure by yourself. It must be allocated and initialized by
<strong>erl_drv_thread_opts_create</strong>.</p></div><p>This function is thread-safe.</p><h4>erl_drv_thread_opts_destroy(ErlDrvThreadOpts *opts):void</h4><p>Destroy thread options.</p><a name="erl_drv_thread_opts_destroy"></a><p>Destroys thread options previously created by
<a href="#erl_drv_thread_opts_create">erl_drv_thread_opts_create</a>.</p><p><strong>opts</strong> is a pointer to thread options to destroy.</p><p>This function is thread-safe.</p><h4>erl_drv_thread_self(void):ErlDrvTid</h4><p>Get the thread identifier of the current thread.</p><a name="erl_drv_thread_self"></a><p>Returns the thread identifier of the calling thread.</p><p>This function is thread-safe.</p><h4>erl_drv_time_offset(ErlDrvTimeUnit
        time_unit):ErlDrvTime</h4><p>Get current time offset.</p><a name="erl_drv_time_offset"></a><p>Returns the current time offset between
<a href="./time_correction#Erlang_Monotonic_Time"> Erlang monotonic time</a> and
<a href="./time_correction#Erlang_System_Time"> Erlang system time</a>
converted into the <strong>time_unit</strong> passed as argument.</p><p><strong>time_unit</strong> is time unit of returned value.</p><p>Returns <strong>ERL_DRV_TIME_ERROR</strong> if called with an invalid
time unit argument, or if called from a thread that is not a
scheduler thread.</p><p>See also <a href="#ErlDrvTime">ErlDrvTime</a> and
<a href="#ErlDrvTimeUnit">ErlDrvTimeUnit</a>.</p><h4>erl_drv_tsd_get(ErlDrvTSDKey
        key):void *</h4><p>Get thread-specific data.</p><a name="erl_drv_tsd_get"></a><p>Returns the thread-specific data
associated with <strong>key</strong> for the calling thread.</p><p><strong>key</strong> is a thread-specific data key.</p><p>Returns <strong>NULL</strong> if no data has been associated
with <strong>key</strong> for the calling thread.</p><p>This function is thread-safe.</p><h4>erl_drv_tsd_key_create(char *name,
        ErlDrvTSDKey *key):int</h4><p>Create a thread-specific data key.</p><a name="erl_drv_tsd_key_create"></a><p>Creates a thread-specific data key.</p><p><strong>name</strong> is a string identifying the created key. It is used
to identify the key in planned future debug functionality.</p><p><strong>key</strong> is a pointer to a thread-specific data key variable.</p><p>Returns <strong>0</strong> on success, otherwise an <strong>errno</strong> value is
returned to indicate the error. The driver creating the key is
responsible for destroying it before the driver is unloaded.</p><p>This function is thread-safe.</p><h4>erl_drv_tsd_key_destroy(ErlDrvTSDKey
        key):void</h4><p>Destroy a thread-specific data key.</p><a name="erl_drv_tsd_key_destroy"></a><p>Destroys a thread-specific data key previously created by
<a href="#erl_drv_tsd_key_create">erl_drv_tsd_key_create</a>.
All thread-specific data using this key in all threads
must be cleared (see <a href="#erl_drv_tsd_set">erl_drv_tsd_set</a>)
before the call to <strong>erl_drv_tsd_key_destroy</strong>.</p><p><strong>key</strong> is a thread-specific data key to destroy.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>A destroyed key is very likely to be reused soon.
Therefore, if you fail to clear the thread-specific
data using this key in a thread before destroying
the key, you will <em>very likely</em> get unexpected
errors in other parts of the system.</p></div><p>This function is thread-safe.</p><h4>erl_drv_tsd_set(ErlDrvTSDKey key, void
        *data):void</h4><p>Set thread-specific data.</p><a name="erl_drv_tsd_set"></a><p>Sets thread-specific data associated with
<strong>key</strong> for the calling thread. You are only allowed to set
thread-specific data for threads while they are fully under your
control. For example, if you set thread-specific data in a thread
calling a driver callback function, it must be cleared, that is,
set to <strong>NULL</strong>, before returning from the driver callback
function.</p><p><strong>key</strong> is a thread-specific data key.</p><p><strong>data</strong> is a pointer to data to associate with <strong>key</strong>
in the calling thread.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If you fail to clear thread-specific data in an
emulator thread before letting it out of your control,
you might never be able to clear this data with
later unexpected errors in other parts of the system as
a result.</p></div><p>This function is thread-safe.</p><h4>erl_errno_id(int error):char *</h4><p>Get Erlang error atom name from error number.</p><a name="erl_errno_id"></a><p>Returns the atom name of the Erlang error,
given the error number in <strong>error</strong>. The error atoms are
<strong>einval</strong>, <strong>enoent</strong>, and so on. It can be used to make
error terms from the driver.</p><h4>remove_driver_entry(ErlDrvEntry
        *de):int</h4><p>Remove a driver entry.</p><a name="remove_driver_entry"></a><p>Removes a driver entry <strong>de</strong> previously added with
<a href="#add_driver_entry">add_driver_entry</a>.</p><p>Driver entries added by the <strong>erl_ddll</strong> Erlang interface
cannot be removed by using this interface.</p><h4>set_busy_port(ErlDrvPort port, int
        on):void</h4><p>Signal or unsignal port as busy.</p><a name="set_busy_port"></a><p>Sets and unsets the busy state of the port. If
<strong>on</strong> is non-zero, the port is set to busy. If it is zero,
the port is set to not busy. You typically want to combine
this feature with the <a href="#erl_drv_busy_msgq_limits"> busy port message queue</a> functionality.</p><p>Processes sending command data to the port are suspended
if either the port or the port message queue
is busy. Suspended processes are resumed when neither the
port or the port message queue is busy. Command data
is in this context data passed to the port using either
<strong>Port ! {Owner, {command, Data}}</strong> or
<strong>port_command/[2,3]</strong>.</p><p>If the <a href="./driver_entry#driver_flags"> ERL_DRV_FLAG_SOFT_BUSY</a> has been set in the
<a href="driver_entry">driver_entry</a>,
data can be forced into the driver through
<a href="./erlang#port_command/3">erlang#port_command/3</a>
even if the driver has signaled that it is busy.</p><p>For information about busy port message queue functionality, see
<a href="#erl_drv_busy_msgq_limits">erl_drv_busy_msgq_limits</a>.</p><h4>set_port_control_flags(ErlDrvPort port,
        int flags):void</h4><p>Set flags on how to handle control entry function.</p><a name="set_port_control_flags"></a><p>Sets flags for how the <a href="./driver_entry#control">driver_entry#control</a> driver entry
function will return data to the port owner process.
(The <strong>control</strong> function is called from
<a href="./erlang#port_control/3">erlang#port_control/3</a>.)</p><p>Currently there are only two meaningful values for
<strong>flags</strong>: <strong>0</strong> means that data is returned in a list,
and <strong>PORT_CONTROL_FLAG_BINARY</strong> means data is returned as
a binary from <strong>control</strong>.</p><h4>See Also</h4><p><a href="driver_entry">driver_entry</a>,
<a href="erlang">erlang</a>,
<a href="./erl_ddll">kernel/erl_ddll</a>,
section <a href="alt_dist">How to Implement an Alternative Carrier for the Erlang Distribution</a> in the User's Guide</p><h3>erl_nif</h3><p>API functions for an Erlang NIF library.</p><p>A NIF library contains native implementation of some functions
of an Erlang module. The native implemented functions (NIFs) are
called like any other functions without any difference to the
caller. Each NIF must have an implementation in Erlang that
is invoked if the function is called before the NIF library
is successfully loaded. A typical such stub implementation
is to throw an exception. But it can also be used as a fallback
implementation if the NIF library is not implemented for some
architecture.A minimal example of a NIF library can look as follows:<pre><code class="">
/* niftest.c */
#include &lt;erl_nif.h&gt;

static ERL_NIF_TERM hello(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
    return enif_make_string(env, "Hello world!", ERL_NIF_LATIN1);
}

static ErlNifFunc nif_funcs[] =
{
    {"hello", 0, hello}
};

ERL_NIF_INIT(niftest,nif_funcs,NULL,NULL,NULL,NULL)</code></pre>The Erlang module can look as follows:<pre><code class="">
-module(niftest).

-export([init/0, hello/0]).

init() -&gt;
      erlang:load_nif("./niftest", 0).

hello() -&gt;
      "NIF library not loaded".</code></pre>Compile and test can look as follows (on Linux):<pre><code class="">
$&gt; gcc -fPIC -shared -o niftest.so niftest.c -I $ERL_ROOT/usr/include/
$&gt; erl

1&gt; c(niftest).
{ok,niftest}
2&gt; niftest:hello().
"NIF library not loaded"
3&gt; niftest:init().
ok
4&gt; niftest:hello().
"Hello world!"</code></pre>A better solution for a real module is to take advantage of the new
directive <strong>on_load</strong> (see section
<a href="../doc/reference_manual/code_loading#on_load">Running a Function When a Module is Loaded</a> in the Erlang Reference
Manual) to load the NIF library automatically when the module is
loaded.Once loaded, a NIF library is persistent. It will not be unloaded
until the module code version that it belongs to is purged.</p><h4>Functionality</h4><p>All interaction between NIF code and the Erlang runtime system is
performed by calling NIF API functions. Functions exist
for the following functionality:</p><dl><dt>Read and write Erlang terms</dt><dd> <p>Any Erlang terms can be passed to a NIF as function arguments and
be returned as function return values. The terms are of C-type
<a href="#ERL_NIF_TERM">ERL_NIF_TERM</a> and can
only be read or written using API functions. Most functions to read
the content of a term are prefixed <strong>enif_get_</strong> and usually return
<strong>true</strong> (or <strong>false</strong>) if the term is of the expected type (or
not). The functions to write terms are all prefixed <strong>enif_make_</strong>
and usually
return the created <strong>ERL_NIF_TERM</strong>. There are also some functions
to query terms, like <strong>enif_is_atom</strong>, <strong>enif_is_identical</strong>,
and <strong>enif_compare</strong>.</p> <p>All terms of type <strong>ERL_NIF_TERM</strong> belong to an environment of
type <a href="#ErlNifEnv">ErlNifEnv</a>. The
lifetime of a term is controlled by the lifetime of its environment
object. All API functions that read or write terms has the
environment that the term belongs to as the first function
argument.</p> </dd><dt>Binaries</dt><dd> <p>Terms of type binary are accessed with the help of struct type
<a href="#ErlNifBinary">ErlNifBinary</a>,
which contains a pointer (<strong>data</strong>) to the raw binary data and the
length (<strong>size</strong>) of the data in bytes. Both <strong>data</strong> and
<strong>size</strong> are read-only and are only to be written using calls to
API functions. Instances of <strong>ErlNifBinary</strong> are, however, always
allocated by the user (usually as local variables).</p> <p>The raw data pointed to by <strong>data</strong> is only mutable after a call
to <a href="#enif_alloc_binary">enif_alloc_binary</a> or
<a href="#enif_realloc_binary">enif_realloc_binary</a>. All other functions that
operate on a binary leave the data as read-only.
A mutable binary must in the end either be freed with
<a href="#enif_release_binary">enif_release_binary</a>
or made read-only by transferring it to an Erlang term with
<a href="#enif_make_binary">enif_make_binary</a>.
However, it does not have to occur in the same NIF call. Read-only
binaries do not have to be released.</p> <p><a href="#enif_make_new_binary">enif_make_new_binary</a> can be used as a shortcut to
allocate and return a binary in the same NIF call.</p> <p>Binaries are sequences of whole bytes. Bitstrings with an arbitrary
bit length have no support yet.</p> </dd><dt><a name="resource_objects"></a>Resource objects</dt><dd> <p>The use of resource objects is a safe way to return pointers to
native data structures from a NIF. A resource object is
only a block of memory allocated with
<a href="#enif_alloc_resource">enif_alloc_resource</a>.
A handle ("safe pointer") to this memory block can then be returned
to Erlang by the use of
<a href="#enif_make_resource">enif_make_resource</a>.
The term returned by <strong>enif_make_resource</strong> is opaque in nature.
It can be stored and passed between processes, but
the only real end usage is to pass it back as an argument to a NIF.
The NIF can then call <a href="#enif_get_resource">enif_get_resource</a> and get back a pointer to the
memory block, which is guaranteed to still be valid. A resource
object is not deallocated until the last handle term
is garbage collected by the VM and the resource is released with
<a href="#enif_release_resource">enif_release_resource</a>
(not necessarily in that order).</p> <p>All resource objects are created as instances of some <em>resource type</em>. This makes resources from different modules to be
distinguishable. A resource type is created by calling
<a href="#enif_open_resource_type">enif_open_resource_type</a> when a library is loaded.
Objects of that resource type can then later be allocated and
<strong>enif_get_resource</strong> verifies that the resource is of the
expected type. A resource type can have a user-supplied destructor
function, which is automatically called when resources of that type
are released (by either the garbage collector or
<strong>enif_release_resource</strong>). Resource types are uniquely identified
by a supplied name string and the name of the implementing module.</p> <a name="enif_resource_example"></a> <p>The following is a template example of how to create and return a
resource object.</p> <pre><code class="">
ERL_NIF_TERM term;
MyStruct* obj = enif_alloc_resource(my_resource_type, sizeof(MyStruct));

/* initialize struct ... */

term = enif_make_resource(env, obj);

if (keep_a_reference_of_our_own) {
    /* store 'obj' in static variable, private data or other resource object */
}
else {
    enif_release_resource(obj);
    /* resource now only owned by "Erlang" */
}
return term;</code></pre> <p>Notice that once <strong>enif_make_resource</strong> creates the term to
return to Erlang, the code can choose to either keep its own
native pointer to the allocated struct and release it later, or
release it immediately and rely only on the garbage collector
to deallocate the resource object eventually when it collects
the term.</p>  <p>Another use of resource objects is to create binary terms with
user-defined memory management.
<a href="#enif_make_resource_binary">enif_make_resource_binary</a>
creates a binary term that is connected to a resource object. The
destructor of the resource is called when the binary is garbage
collected, at which time the binary data can be released. An example
of this can be a binary term consisting of data from a <strong>mmap</strong>'ed
file. The destructor can then do <strong>munmap</strong> to release the memory
region.</p> <p>Resource types support upgrade in runtime by allowing a loaded NIF
library to take over an already existing resource type and by that
"inherit" all existing objects of that type. The destructor of the
new library is thereafter called for the inherited objects and the
library with the old destructor function can be safely unloaded.
Existing resource objects, of a module that is upgraded, must either
be deleted or taken over by the new NIF library. The unloading of a
library is postponed as long as there exist resource objects with a
destructor function in the library.</p> </dd><dt>Module upgrade and static data</dt><dd> <p>A loaded NIF library is tied to the Erlang module instance
that loaded it. If the module is upgraded, the new module instance
needs to load its own NIF library (or maybe choose not to). The new
module instance can, however, choose to load the exact same NIF library
as the old code if it wants to. Sharing the dynamic library means that
static data defined by the library is shared as well. To avoid
unintentionally shared static data between module instances, each Erlang
module version can keep its own private data. This private data can be
set when the NIF library is loaded and later retrieved by calling
<a href="#enif_priv_data">enif_priv_data</a>.</p> </dd><dt>Threads and concurrency</dt><dd> <p>A NIF is thread-safe without any explicit synchronization as
long as it acts as a pure function and only reads the supplied
arguments. When you write to a shared state either through
static variables or <a href="#enif_priv_data">enif_priv_data</a>, you need to supply your own explicit
synchronization. This includes terms in process independent
environments that are shared between threads. Resource objects also
require synchronization if you treat them as mutable.</p> <p>The library initialization callbacks <strong>load</strong> and
<strong>upgrade</strong> are thread-safe even for shared state data.</p> </dd><dt><a name="version_management"></a>Version Management</dt><dd> <p>When a NIF library is built, information about the NIF API version
is compiled into the library. When a NIF library is loaded, the
runtime system verifies that the library is of a compatible version.
<strong>erl_nif.h</strong> defines the following:</p> <dl><dt><strong>ERL_NIF_MAJOR_VERSION</strong></dt><dd> <p>Incremented when NIF library incompatible changes are made to the
Erlang runtime system. Normally it suffices to recompile the NIF
library when the <strong>ERL_NIF_MAJOR_VERSION</strong> has changed, but it
can, under rare circumstances, mean that NIF libraries must be
slightly modified. If so, this will of course be documented.</p> </dd><dt><strong>ERL_NIF_MINOR_VERSION</strong></dt><dd> <p>Incremented when new features are added. The runtime system uses
the minor version to determine what features to use.</p> </dd></dl> <p>The runtime system normally refuses to load a NIF library if
the major versions differ, or if the major versions are equal and
the minor version used by the NIF library is greater than the one
used by the runtime system. Old NIF libraries with lower major
versions are, however, allowed after a bump of the major version
during a transition period of two major releases. Such old NIF
libraries can however fail if deprecated features are used.</p> </dd><dt><a name="time_measurement"></a>Time Measurement</dt><dd> <p>Support for time measurement in NIF libraries:</p> <ul><li><a href="#ErlNifTime">ErlNifTime</a></li><li><a href="#ErlNifTimeUnit">ErlNifTimeUnit</a></li><li><a href="#enif_monotonic_time">enif_monotonic_time</a></li><li><a href="#enif_time_offset">enif_time_offset</a></li><li><a href="#enif_convert_time_unit">enif_convert_time_unit</a></li></ul> </dd><dt><a name="enif_ioq"></a>I/O Queues</dt><dd> <p>The Erlang nif library contains function for easily working
with I/O vectors as used by the unix system call <strong>writev</strong>.
The I/O Queue is not thread safe, so some other synchronization
mechanism has to be used.</p> <ul><li><a href="#SysIOVec">SysIOVec</a></li><li><a href="#ErlNifIOVec">ErlNifIOVec</a></li><li><a href="#enif_ioq_create">enif_ioq_create</a></li><li><a href="#enif_ioq_destroy">enif_ioq_destroy</a></li><li><a href="#enif_ioq_enq_binary">enif_ioq_enq_binary</a></li><li><a href="#enif_ioq_enqv">enif_ioq_enqv</a></li><li><a href="#enif_ioq_deq">enif_ioq_deq</a></li><li><a href="#enif_ioq_peek">enif_ioq_peek</a></li><li><a href="#enif_ioq_peek_head">enif_ioq_peek_head</a></li><li><a href="#enif_inspect_iovec">enif_inspect_iovec</a></li><li><a href="#enif_free_iovec">enif_free_iovec</a></li></ul> <p>Typical usage when writing to a file descriptor looks like this:</p> <pre><code class="">
int writeiovec(ErlNifEnv *env, ERL_NIF_TERM term, ERL_NIF_TERM *tail,
               ErlNifIOQueue *q, int fd) {

    ErlNifIOVec vec, *iovec = &amp;vec;
    SysIOVec *sysiovec;
    int saved_errno;
    int iovcnt, n;

    if (!enif_inspect_iovec(env, 64, term, tail, &amp;iovec))
        return -2;

    if (enif_ioq_size(q) &gt; 0) {
        /* If the I/O queue contains data we enqueue the iovec and
           then peek the data to write out of the queue. */
        if (!enif_ioq_enqv(q, iovec, 0))
            return -3;

        sysiovec = enif_ioq_peek(q, &amp;iovcnt);
    } else {
        /* If the I/O queue is empty we skip the trip through it. */
        iovcnt = iovec-&gt;iovcnt;
        sysiovec = iovec-&gt;iov;
    }

    /* Attempt to write the data */
    n = writev(fd, sysiovec, iovcnt);
    saved_errno = errno;

    if (enif_ioq_size(q) == 0) {
        /* If the I/O queue was initially empty we enqueue any
           remaining data into the queue for writing later. */
        if (n &gt;= 0 &amp;&amp; !enif_ioq_enqv(q, iovec, n))
            return -3;
    } else {
        /* Dequeue any data that was written from the queue. */
        if (n &gt; 0 &amp;&amp; !enif_ioq_deq(q, n, NULL))
            return -4;
    }

    /* return n, which is either number of bytes written or -1 if
       some error happened */
    errno = saved_errno;
    return n;
}</code></pre> </dd><dt><a name="lengthy_work"></a>Long-running NIFs</dt><dd> <p>As mentioned in the <a href="#WARNING">warning</a> text
at the beginning of this manual page, it is of <em>vital importance</em> that a native function returns relatively fast. It is
difficult to give an exact maximum amount of time that a native
function is allowed to work, but usually a well-behaving native
function is to return to its caller within 1 millisecond. This can be
achieved using different approaches. If you have full control over the
code to execute in the native function, the best approach is to
divide the work into multiple chunks of work and call the native
function multiple times. This is, however, not always possible, for
example when calling third-party libraries.</p> <p>The <a href="#enif_consume_timeslice">enif_consume_timeslice</a> function can be used to
inform the runtime system about the length of the NIF call.
It is typically always to be used unless the NIF executes very
fast.</p> <p>If the NIF call is too lengthy, this must be handled in one of
the following ways to avoid degraded responsiveness, scheduler load
balancing problems, and other strange behaviors:</p> <dl><dt>Yielding NIF</dt><dd> <p>If the functionality of a long-running NIF can be split so that
its work can be achieved through a series of shorter NIF calls,
the application has two options:</p> <ul><li> <p>Make that series of NIF calls from the Erlang level.</p> </li><li> <p>Call a NIF that first performs a chunk of the work, then
invokes the <a href="#enif_schedule_nif">enif_schedule_nif</a> function to schedule
another NIF call to perform the next chunk. The final call
scheduled in this manner can then return the overall
result.</p> </li></ul> <p>Breaking up a long-running function in this manner enables the
VM to regain control between calls to the NIFs.</p> <p>This approach is always preferred over the other alternatives
described below. This both from a performance perspective and
a system characteristics perspective.</p> </dd><dt>Threaded NIF</dt><dd> <p>This is accomplished by dispatching the work to another thread
managed by the NIF library, return from the NIF, and wait for
the result. The thread can send the result back to the Erlang
process using <a href="#enif_send">enif_send</a>.
Information about thread primitives is provided below.</p> </dd><dt><a name="dirty_nifs"></a>Dirty NIF</dt><dd> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Dirty NIF support is available only when the emulator is
configured with dirty scheduler support. As of ERTS version
9.0, dirty scheduler support is enabled by default on the
runtime system with SMP support. The Erlang runtime without
SMP support does <em>not</em> support dirty schedulers even
when the dirty scheduler support is explicitly enabled. To
check at runtime for the presence of dirty scheduler threads,
code can use the <a href="#enif_system_info">enif_system_info</a> API function.</p></div> <p>A NIF that cannot be split and cannot execute in a millisecond
or less is called a "dirty NIF", as it performs work that the
ordinary schedulers of the Erlang runtime system cannot handle cleanly.
Applications that make use of such functions must indicate to the
runtime that the functions are dirty so they can be handled 
specially. This is handled by executing dirty jobs on a separate
set of schedulers called dirty schedulers. A dirty NIF executing
on a dirty scheduler does not have the same duration restriction
as a normal NIF.
</p> <p>
It is important to classify the dirty job correct. An I/O bound
job should be classified as such, and a CPU bound job should be
classified as such. If you should classify CPU bound jobs
as I/O bound jobs, dirty I/O schedulers might starve ordinary
schedulers. I/O bound jobs are expected to either block waiting
for I/O, and/or spend a limited amount of time moving data.
</p> <p>
To schedule a dirty NIF for execution, the application has two options:</p> <ul><li> <p>Set the appropriate flags value for the dirty NIF in its
<a href="#ErlNifFunc">ErlNifFunc</a>
entry.</p> </li><li> <p>Call <a href="#enif_schedule_nif">enif_schedule_nif</a>, pass to it a pointer
to the dirty NIF to be executed, and indicate with argument
<strong>flags</strong> whether it expects the operation to be CPU-bound
or I/O-bound.</p> </li></ul> <p>A job that alternates between I/O bound and CPU bound can be
reclassified and rescheduled using <strong>enif_schedule_nif</strong> so
that it executes on the correct type of dirty scheduler at all
times. For more information see the documentation of the
<strong>erl(1)</strong> command line arguments
<a href="./erl#+SDcpu">erl#+SDcpu</a>,
and <a href="./erl#+SDio">erl#+SDio</a>.</p> <p>While a process executes a dirty NIF, some operations that
communicate with it can take a very long time to complete.
Suspend or garbage collection of a process executing a dirty
NIF cannot be done until the dirty NIF has returned. Thus, other
processes waiting for such operations to complete might
have to wait for a very long time. Blocking multi-scheduling, that
is, calling <a href="./erlang#system_flag_multi_scheduling">erlang#system_flag_multi_scheduling</a>, can
also take a very long time to complete. This is because all ongoing
dirty operations on all dirty schedulers must complete before
the block operation can complete.</p> <p>Many operations communicating with a process executing a
dirty NIF can, however, complete while it executes the
dirty NIF. For example, retrieving information about it through
<a href="./erlang#process_info/1">erlang#process_info/1</a>, setting its group leader,
register/unregister its name, and so on.</p> <p>Termination of a process executing a dirty NIF can only be
completed up to a certain point while it executes the dirty NIF.
All Erlang resources, such as its registered name and its ETS
tables, are released. All links and monitors are triggered. The
execution of the NIF is, however, <em>not</em> stopped. The NIF
can safely continue execution, allocate heap memory, and so on,
but it is of course better to stop executing as soon as possible.
The NIF can check whether a current process is alive using
<a href="#enif_is_current_process_alive">enif_is_current_process_alive</a>. Communication
using <a href="#enif_send">enif_send</a> and
<a href="#enif_port_command">enif_port_command</a> is also dropped when the
sending process is not alive. Deallocation of certain internal
resources, such as process heap and process control block, is
delayed until the dirty NIF has completed.</p> </dd></dl> </dd></dl><h4>Initialization</h4><dl><dt><a name="ERL_NIF_INIT"></a><strong>ERL_NIF_INIT(MODULE, ErlNifFunc funcs[], load, NULL, upgrade, unload)</strong></dt><dd> <p>This is the magic macro to initialize a NIF library. It
is to be evaluated in global file scope.</p> <p><strong>MODULE</strong> is the name of the Erlang module as an
identifier without string quotations. It is stringified by
the macro.</p> <p><strong>funcs</strong> is a static array of function descriptors for
all the implemented NIFs in this library.</p> <p><strong>load</strong>, <strong>upgrade</strong> and <strong>unload</strong>
are pointers to functions. One of <strong>load</strong> or
<strong>upgrade</strong> is called to initialize the library.
<strong>unload</strong> is called to release the library. All are
described individually below.</p> <p>The fourth argument <strong>NULL</strong> is ignored. It
was earlier used for the deprecated <strong>reload</strong> callback
which is no longer supported since OTP 20.</p> <p>If compiling a NIF for static inclusion through
<strong>--enable-static-nifs</strong>, you must define <strong>STATIC_ERLANG_NIF</strong>
before the <strong>ERL_NIF_INIT</strong> declaration.</p> </dd><dt><a name="load"></a><strong>int (*load)(ErlNifEnv* caller_env, void** priv_data, ERL_NIF_TERM load_info)</strong></dt><dd> <p><strong>load</strong> is called when the NIF library is loaded
and no previously loaded library exists for this module.</p> <p><strong>*priv_data</strong> can be set to point to some private data
if the library needs to keep a state between NIF
calls. <strong>enif_priv_data</strong> returns this pointer.
<strong>*priv_data</strong> is initialized to <strong>NULL</strong> when <strong>load</strong> is
called.</p>  <p><strong>load_info</strong> is the second argument to <a href="./erlang#load_nif-2">erlang#load_nif-2</a>.</p> <p>The library fails to load if <strong>load</strong> returns
anything other than <strong>0</strong>. <strong>load</strong> can be <strong>NULL</strong> if
initialization is not needed.</p>  </dd><dt><a name="upgrade"></a><strong>int (*upgrade)(ErlNifEnv* caller_env, void** priv_data, void** old_priv_data, ERL_NIF_TERM load_info)</strong></dt><dd> <p><strong>upgrade</strong> is called when the NIF library is loaded
and there is old code of this module with a loaded NIF library.</p> <p>Works as <strong>load</strong>, except that <strong>*old_priv_data</strong> already
contains the value set by the last call to <strong>load</strong> or
<strong>upgrade</strong> for the old module code. <strong>*priv_data</strong> is
initialized to <strong>NULL</strong> when <strong>upgrade</strong> is called. It is
allowed to write to both <strong>*priv_data</strong> and
<strong>*old_priv_data.</strong></p>  <p>The library fails to load if <strong>upgrade</strong> returns
anything other than <strong>0</strong> or if <strong>upgrade</strong> is <strong>NULL</strong>.</p> </dd><dt><a name="unload"></a><strong>void (*unload)(ErlNifEnv* caller_env, void* priv_data)</strong></dt><dd> <p><strong>unload</strong> is called when the module code that
the NIF library belongs to is purged as old. New code of the same
module may or may not exist.</p> </dd></dl><h4>Data Types</h4><dl><dt><a name="ERL_NIF_TERM"></a><strong>ERL_NIF_TERM</strong></dt><dd> <p>Variables of type <strong>ERL_NIF_TERM</strong> can refer to any Erlang term.
This is an opaque type and values of it can only by used either as
arguments to API functions or as return values from NIFs. All
<strong>ERL_NIF_TERM</strong>s belong to an environment
(<a href="#ErlNifEnv">ErlNifEnv</a>).
A term cannot be destructed individually, it is valid until its
environment is destructed.</p> </dd><dt><a name="ErlNifEnv"></a><strong>ErlNifEnv</strong></dt><dd> <p><strong>ErlNifEnv</strong> represents an environment that can host Erlang
terms. All terms in an environment are valid as long as the
environment is valid. <strong>ErlNifEnv</strong> is an opaque type; pointers to
it can only be passed on to API functions. Three types of environments
exist:</p> <dl><dt>Process bound environment</dt><dd> <p>Passed as the first argument to all NIFs. All function arguments
passed to a NIF belong to that environment. The return value from
a NIF must also be a term belonging to the same environment.</p> <p>A process bound environment contains transient information
about the calling Erlang process. The environment is only valid
in the thread where it was supplied as argument until the NIF
returns. It is thus useless and dangerous to store pointers to
process bound environments between NIF calls.</p> </dd><dt>Callback environment</dt><dd> <p>Passed as the first argument to all the non-NIF callback functions
(<a href="#load">load</a>,
<a href="#upgrade">upgrade</a>,
<a href="#unload">unload</a>,
<a href="#ErlNifResourceDtor">ErlNifResourceDtor</a>,
<a href="#ErlNifResourceDown">ErlNifResourceDown</a> and
<a href="#ErlNifResourceStop">ErlNifResourceStop</a>).
Works like a process bound environment but with a temporary
pseudo process that "terminates" when the callback has
returned. Terms may be created in this environment but they will
only be accessible during the callback.</p> </dd><dt>Process independent environment</dt><dd> <p>Created by calling <a href="#enif_alloc_env">enif_alloc_env</a>. This environment can be
used to store terms between NIF calls and to send terms with
<a href="#enif_send">enif_send</a>. A
process independent environment with all its terms is valid until
you explicitly invalidate it with
<a href="#enif_free_env">enif_free_env</a>
or <strong>enif_send</strong>.</p> </dd></dl> <p>All contained terms of a list/tuple/map must belong to the same
environment as the list/tuple/map itself. Terms can be copied between
environments with
<a href="#enif_make_copy">enif_make_copy</a>.</p> </dd><dt><a name="ErlNifFunc"></a><strong>ErlNifFunc</strong></dt><dd> <pre><code class="">
typedef struct {
    const char* name;
    unsigned arity;
    ERL_NIF_TERM (*fptr)(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);
    unsigned flags;
} ErlNifFunc;</code></pre> <p>Describes a NIF by its name, arity, and implementation.</p> <dl><dt><strong>fptr</strong></dt><dd> <p>A pointer to the function that implements the NIF.</p> </dd><dt><strong>argv</strong></dt><dd> <p>Contains the function arguments passed to the NIF.</p> </dd><dt><strong>argc</strong></dt><dd> <p>The array length, that is, the function arity. <strong>argv[N-1]</strong>
thus denotes the Nth argument to the NIF. Notice that the argument
<strong>argc</strong> allows for the same C function to implement several
Erlang functions with different arity (but probably with the same
name).</p> </dd><dt><strong>flags</strong></dt><dd> <p>Is <strong>0</strong> for a regular NIF (and so its value can be omitted
for statically initialized <strong>ErlNifFunc</strong> instances).</p> <p><strong>flags</strong> can be used to indicate that the NIF is a
<a href="#dirty_nifs">dirty NIF</a> that is to be
executed on a dirty scheduler thread.</p> <p>If the dirty NIF is expected to be CPU-bound, its <strong>flags</strong>
field is to be set to <strong>ERL_NIF_DIRTY_JOB_CPU_BOUND</strong> or
<strong>ERL_NIF_DIRTY_JOB_IO_BOUND</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If one of the <strong>ERL_NIF_DIRTY_JOB_*_BOUND</strong> flags is set,
and the runtime system has no support for dirty schedulers,
the runtime system refuses to load the NIF library.</p></div> </dd></dl> </dd><dt><a name="ErlNifBinary"></a><strong>ErlNifBinary</strong></dt><dd> <pre><code class="">
typedef struct {
    unsigned size;
    unsigned char* data;
} ErlNifBinary;</code></pre> <p><strong>ErlNifBinary</strong> contains transient information about an
inspected binary term. <strong>data</strong> is a pointer to a buffer
of <strong>size</strong> bytes with the raw content of the binary.</p> <p>Notice that <strong>ErlNifBinary</strong> is a semi-opaque type and you are
only allowed to read fields <strong>size</strong> and <strong>data</strong>.</p> </dd><dt><a name="ErlNifBinaryToTerm"></a><strong>ErlNifBinaryToTerm</strong></dt><dd> <p>An enumeration of the options that can be specified to
<a href="#enif_binary_to_term">enif_binary_to_term</a>.
For default behavior, use value <strong>0</strong>.</p> <p>When receiving data from untrusted sources, use option
<strong>ERL_NIF_BIN2TERM_SAFE</strong>.</p> </dd><dt><a name="ErlNifMonitor"></a><strong>ErlNifMonitor</strong></dt><dd> <p>This is an opaque data type that identifies a monitor.</p> <p>The nif writer is to provide the memory for storing the
monitor when calling <a href="#enif_monitor_process">enif_monitor_process</a>. The
address of the data is not stored by the runtime system, so
<strong>ErlNifMonitor</strong> can be used as any other data, it
can be copied, moved in memory, forgotten, and so on.
To compare two monitors, <a href="#enif_compare_monitors">enif_compare_monitors</a> must be used.</p> </dd><dt><a name="ErlNifPid"></a><strong>ErlNifPid</strong></dt><dd> <p>A process identifier (pid). In contrast to pid terms (instances of
<strong>ERL_NIF_TERM</strong>), <strong>ErlNifPid</strong>s are self-contained and not
bound to any <a href="#ErlNifEnv">environment</a>.
<strong>ErlNifPid</strong> is an opaque type. It can be copied, moved
in memory, forgotten, and so on.</p> </dd><dt><a name="ErlNifPort"></a><strong>ErlNifPort</strong></dt><dd> <p>A port identifier. In contrast to port ID terms (instances of
<strong>ERL_NIF_TERM</strong>), <strong>ErlNifPort</strong>s are self-contained and not
bound to any <a href="#ErlNifEnv">environment</a>.
<strong>ErlNifPort</strong> is an opaque type. It can be copied, moved
in memory, forgotten, and so on.</p> </dd><dt><a name="ErlNifResourceType"></a><strong>ErlNifResourceType</strong></dt><dd> <p>Each instance of <strong>ErlNifResourceType</strong> represents a class of
memory-managed resource objects that can be garbage collected.
Each resource type has a unique name and a destructor function that
is called when objects of its type are released.</p> </dd><dt><a name="ErlNifResourceTypeInit"></a><strong>ErlNifResourceTypeInit</strong></dt><dd> <pre><code class="">
typedef struct {
    ErlNifResourceDtor* dtor;
    ErlNifResourceStop* stop;
    ErlNifResourceDown* down;
} ErlNifResourceTypeInit;</code></pre> <p>Initialization structure read by <a href="#enif_open_resource_type_x"> enif_open_resource_type_x</a>.</p> </dd><dt><a name="ErlNifResourceDtor"></a><strong>ErlNifResourceDtor</strong></dt><dd> <pre><code class="">
typedef void ErlNifResourceDtor(ErlNifEnv* caller_env, void* obj);</code></pre> <p>The function prototype of a resource destructor function.</p> <p>The <strong>obj</strong> argument is a pointer to the resource. The only
allowed use for the resource in the destructor is to access its
user data one final time. The destructor is guaranteed to be the
last callback before the resource is deallocated.</p> </dd><dt><a name="ErlNifResourceDown"></a><strong>ErlNifResourceDown</strong></dt><dd> <pre><code class="">
typedef void ErlNifResourceDown(ErlNifEnv* caller_env, void* obj, ErlNifPid* pid, ErlNifMonitor* mon);</code></pre> <p>The function prototype of a resource down function,
called on the behalf of <a href="#enif_monitor_process"> enif_monitor_process</a>. <strong>obj</strong> is the resource, <strong>pid</strong>
is the identity of the monitored process that is exiting, and <strong>mon</strong>
is the identity of the monitor.
</p> </dd><dt><a name="ErlNifResourceStop"></a><strong>ErlNifResourceStop</strong></dt><dd> <pre><code class="">
typedef void ErlNifResourceStop(ErlNifEnv* caller_env, void* obj, ErlNifEvent event, int is_direct_call);</code></pre> <p>The function prototype of a resource stop function,
called on the behalf of <a href="#enif_select"> enif_select</a>. <strong>obj</strong> is the resource, <strong>event</strong> is OS event,
<strong>is_direct_call</strong> is true if the call is made directly from <strong>enif_select</strong>
or false if it is a scheduled call (potentially from another thread).</p> </dd><dt><a name="ErlNifCharEncoding"></a><strong>ErlNifCharEncoding</strong></dt><dd> <pre><code class="">
typedef enum {
    ERL_NIF_LATIN1
}ErlNifCharEncoding;</code></pre> <p>The character encoding used in strings and atoms. The only
supported encoding is <strong>ERL_NIF_LATIN1</strong> for
ISO Latin-1 (8-bit ASCII).</p> </dd><dt><a name="ErlNifSysInfo"></a><strong>ErlNifSysInfo</strong></dt><dd> <p>Used by <a href="#enif_system_info">enif_system_info</a> to return information about the
runtime system. Contains the same content as
<a href="./erl_driver#ErlDrvSysInfo">erl_driver#ErlDrvSysInfo</a>.</p> </dd><dt><a name="ErlNifSInt64"></a><strong>ErlNifSInt64</strong></dt><dd> <p>A native signed 64-bit integer type.</p> </dd><dt><a name="ErlNifUInt64"></a><strong>ErlNifUInt64</strong></dt><dd> <p>A native unsigned 64-bit integer type.</p> </dd><dt><a name="ErlNifTime"></a><strong>ErlNifTime</strong></dt><dd> <p>A signed 64-bit integer type for representation of time.</p> </dd><dt><a name="ErlNifTimeUnit"></a><strong>ErlNifTimeUnit</strong></dt><dd> <p>An enumeration of time units supported by the NIF API:</p> <dl><dt><strong>ERL_NIF_SEC</strong></dt><dd>Seconds</dd><dt><strong>ERL_NIF_MSEC</strong></dt><dd>Milliseconds</dd><dt><strong>ERL_NIF_USEC</strong></dt><dd>Microseconds</dd><dt><strong>ERL_NIF_NSEC</strong></dt><dd>Nanoseconds</dd></dl> </dd><dt><a name="ErlNifUniqueInteger"></a><strong>ErlNifUniqueInteger</strong></dt><dd> <p>An enumeration of the properties that can be requested from
<a href="#enif_make_unique_integer">enif_make_unique_integer</a>.
For default properties, use value <strong>0</strong>.</p> <dl><dt><strong>ERL_NIF_UNIQUE_POSITIVE</strong></dt><dd> <p>Return only positive integers.</p> </dd><dt><strong>ERL_NIF_UNIQUE_MONOTONIC</strong></dt><dd> <p>Return only <a href="./time_correction#Strictly_Monotonically_Increasing"> strictly monotonically increasing</a> integer corresponding
to creation time.</p> </dd></dl> </dd><dt><a name="ErlNifHash"></a><strong>ErlNifHash</strong></dt><dd> <p>An enumeration of the supported hash types that can be generated
using <a href="#enif_hash">enif_hash</a>.
</p> <dl><dt><strong>ERL_NIF_INTERNAL_HASH</strong></dt><dd> <p>Non-portable hash function that only guarantees the same hash
for the same term within one Erlang VM instance.</p> <p>It takes 32-bit salt values and generates hashes within <strong>0..2^32-1</strong>.</p> </dd><dt><strong>ERL_NIF_PHASH2</strong></dt><dd> <p>Portable hash function that gives the same hash for the
same Erlang term regardless of machine architecture and ERTS version.</p> <p><em>It ignores salt values</em> and generates hashes within <strong>0..2^27-1</strong>.</p> <p>Slower than <strong>ERL_NIF_INTERNAL_HASH.</strong>
It corresponds to <a href="./erlang#phash2-1">erlang#phash2-1</a>.
</p> </dd></dl> </dd><dt><a name="SysIOVec"></a><strong>SysIOVec</strong></dt><dd> <p>A system I/O vector, as used by <strong>writev</strong> on
Unix and <strong>WSASend</strong> on Win32. It is used in
<strong>ErlNifIOVec</strong> and by
<a href="#enif_ioq_peek">enif_ioq_peek</a>.</p> </dd><dt><a name="ErlNifIOVec"></a><strong>ErlNifIOVec</strong></dt><dd> <pre><code class="">
typedef struct {
  int iovcnt;
  size_t size;
  SysIOVec* iov;
} ErlNifIOVec;</code></pre> <p>An I/O vector containing <strong>iovcnt</strong> <strong>SysIOVec</strong>s
pointing to the data. It is used by
<a href="#enif_inspect_iovec">enif_inspect_iovec</a> and
<a href="#enif_ioq_enqv">enif_ioq_enqv</a>.</p> </dd><dt><a name="ErlNifIOQueueOpts"></a><strong>ErlNifIOQueueOpts</strong></dt><dd> Options to configure a <strong>ErlNifIOQueue</strong>. <dl><dt>ERL_NIF_IOQ_NORMAL</dt><dd><p>Create a normal I/O Queue</p></dd></dl> </dd></dl><h3>Functions</h3><h4>enif_alloc(size_t size):void *</h4><p>Allocate dynamic memory.</p><p>Allocates memory of <strong>size</strong> bytes.</p><p>Returns <strong>NULL</strong> if the allocation fails.</p><p>The returned pointer is suitably aligned for any built-in type that
fit in the allocated memory.</p><h4>enif_alloc_binary(size_t size, ErlNifBinary* bin):int</h4><p>Create a new binary.</p><p>Allocates a new binary of size <strong>size</strong> bytes.
Initializes the structure pointed to by <strong>bin</strong> to
refer to the allocated binary. The binary must either be released by
<a href="#enif_release_binary">enif_release_binary</a> 
or ownership transferred to an Erlang term with
<a href="#enif_make_binary">enif_make_binary</a>.
An allocated (and owned) <strong>ErlNifBinary</strong> can be kept between NIF
calls.</p><p>If you do not need to reallocate or keep the data alive across NIF
calls, consider using <a href="#enif_make_new_binary">enif_make_new_binary</a> instead as it will allocate
small binaries on the process heap when possible.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if allocation
fails.</p><h4>enif_alloc_env():ErlNifEnv *</h4><p>Create a new environment.</p><p>Allocates a new process independent environment. The environment can
be used to hold terms that are not bound to any process. Such terms
can later be copied to a process environment with
<a href="#enif_make_copy">enif_make_copy</a> or
be sent to a process as a message with <a href="#enif_send">enif_send</a>.</p><p>Returns pointer to the new environment.</p><h4>enif_alloc_resource(ErlNifResourceType*
        type, unsigned size):void *</h4><p>Allocate a memory-managed resource object.</p><p>Allocates a memory-managed resource object of type <strong>type</strong> and
size <strong>size</strong> bytes.</p><h4>enif_binary_to_term(ErlNifEnv *env,
        const unsigned char* data, size_t size, ERL_NIF_TERM *term,
        ErlNifBinaryToTerm opts):size_t</h4><p>Create a term from the external format.</p><p>Creates a term that is the result of decoding the binary data at
<strong>data</strong>, which must be encoded according to the Erlang external
term format. No more than <strong>size</strong> bytes are read from <strong>data</strong>.
Argument <strong>opts</strong> corresponds to the second argument to
<a href="./erlang#binary_to_term-2">erlang#binary_to_term-2</a> and must be either <strong>0</strong>
or <strong>ERL_NIF_BIN2TERM_SAFE</strong>.</p><p>On success, stores the resulting term at <strong>*term</strong> and returns
the number of bytes read. Returns <strong>0</strong> if decoding fails or if
<strong>opts</strong> is invalid.</p><p>See also <a href="#ErlNifBinaryToTerm">ErlNifBinaryToTerm</a>,
<a href="./erlang#binary_to_term-2">erlang#binary_to_term-2</a>, and
<a href="#enif_term_to_binary">enif_term_to_binary</a>.</p><h4>enif_clear_env(ErlNifEnv* env):void</h4><p>Clear an environment for reuse.</p><p>Frees all terms in an environment and clears it for reuse.
The environment must have been allocated with
<a href="#enif_alloc_env">enif_alloc_env</a>.</p><h4>enif_compare(ERL_NIF_TERM lhs, ERL_NIF_TERM rhs):int</h4><p>Compare two terms.</p><p>Returns an integer &lt; <strong>0</strong> if <strong>lhs</strong> &lt; <strong>rhs</strong>,
<strong>0</strong> if <strong>lhs</strong> = <strong>rhs</strong>, and &gt; <strong>0</strong> if
<strong>lhs</strong> &gt; <strong>rhs</strong>. Corresponds to the Erlang
operators <strong>==</strong>, <strong>/=</strong>, <strong>=&lt;</strong>, <strong>&lt;</strong>,
<strong>&gt;=</strong>, and <strong>&gt;</strong> (but <em>not</em> <strong>=:=</strong> or
<strong>=/=</strong>).</p><h4>enif_compare_monitors(const ErlNifMonitor
        *monitor1, const ErlNifMonitor *monitor2):int</h4><p>Compare two monitors.</p><a name="enif_compare_monitors"></a><p>Compares two <a href="#ErlNifMonitor">ErlNifMonitor</a>s.
Can also be used to imply some artificial order on monitors,
for whatever reason.</p><p>Returns <strong>0</strong> if <strong>monitor1</strong> and <strong>monitor2</strong> are equal,
&lt; <strong>0</strong> if <strong>monitor1</strong> &lt; <strong>monitor2</strong>, and
&gt; <strong>0</strong> if <strong>monitor1</strong> &gt; <strong>monitor2</strong>.</p><h4>enif_compare_pids(const ErlNifPid *pid1, const ErlNifPid *pid2)
:int</h4><p>Compare two pids.</p><p>Compares two <a href="#ErlNifPid">ErlNifPid</a>s according to term order.</p><p>Returns <strong>0</strong> if <strong>pid1</strong> and <strong>pid2</strong> are equal,
&lt; <strong>0</strong> if <strong>pid1</strong> &lt; <strong>pid2</strong>, and
&gt; <strong>0</strong> if <strong>pid1</strong> &gt; <strong>pid2</strong>.</p><h4>enif_cond_broadcast(ErlNifCond *cnd):void</h4><p>Same as <a href="./erl_driver#erl_drv_cond_broadcast">erl_driver#erl_drv_cond_broadcast</a>.</p><h4>enif_cond_create(char *name):ErlNifCond *</h4><p>Same as <a href="./erl_driver#erl_drv_cond_create">erl_driver#erl_drv_cond_create</a>.</p><h4>enif_cond_destroy(ErlNifCond *cnd):void</h4><p>Same as <a href="./erl_driver#erl_drv_cond_destroy">erl_driver#erl_drv_cond_destroy</a>.</p><h4>enif_cond_name(ErlNifCond* cnd):char*</h4><p>Same as <a href="./erl_driver#erl_drv_cond_name">erl_driver#erl_drv_cond_name</a>.</p><h4>enif_cond_signal(ErlNifCond *cnd):void</h4><p>Same as <a href="./erl_driver#erl_drv_cond_signal">erl_driver#erl_drv_cond_signal</a>.</p><h4>enif_cond_wait(ErlNifCond *cnd, ErlNifMutex *mtx):void</h4><p>Same as <a href="./erl_driver#erl_drv_cond_wait">erl_driver#erl_drv_cond_wait</a>.</p><h4>enif_consume_timeslice(ErlNifEnv *env, int percent):int</h4><p>Gives the runtime system a hint about how much CPU time the current
NIF call has consumed since the last hint, or since the start of the
NIF if no previous hint has been specified. The time is specified as a
percent of the timeslice that a process is allowed to execute
Erlang code until it can be suspended to give time for other runnable
processes. The scheduling timeslice is not an exact entity, but can
usually be approximated to about 1 millisecond.</p><p>Notice that it is up to the runtime system to determine if and how
to use this information. Implementations on some platforms can use
other means to determine consumed CPU time. Lengthy NIFs should
regardless of this frequently call <strong>enif_consume_timeslice</strong> to
determine if it is allowed to continue execution.</p><p>Argument <strong>percent</strong> must be an integer between 1 and 100. This
function must only be called from a NIF-calling thread, and argument
<strong>env</strong> must be the environment of the calling process.</p><p>Returns <strong>1</strong> if the timeslice is exhausted, otherwise <strong>0</strong>.
If <strong>1</strong> is returned, the NIF is to return as soon as possible in
order for the process to yield.</p><p>This function is provided to better support co-operative scheduling,
improve system responsiveness, and make it easier to prevent
misbehaviors of the VM because of a NIF monopolizing a scheduler
thread. It can be used to divide <a href="#lengthy_work"> length work</a> into a number of repeated NIF calls without the
need to create threads.</p><p>See also the <a href="#WARNING">warning</a> text at
the beginning of this manual page.</p><h4>enif_convert_time_unit(ErlNifTime
        val, ErlNifTimeUnit from, ErlNifTimeUnit to):ErlNifTime</h4><p>Convert time unit of a time value.</p><a name="enif_convert_time_unit"></a><p>Converts the <strong>val</strong> value of time unit <strong>from</strong> to
the corresponding value of time unit <strong>to</strong>. The result is
rounded using the floor function.</p><dl><dt><strong>val</strong></dt><dd>Value to convert time unit for.</dd><dt><strong>from</strong></dt><dd>Time unit of <strong>val</strong>.</dd><dt><strong>to</strong></dt><dd>Time unit of returned value.</dd></dl><p>Returns <strong>ERL_NIF_TIME_ERROR</strong> if called with an invalid
time unit argument.</p><p>See also <a href="#ErlNifTime">ErlNifTime</a>
and
<a href="#ErlNifTimeUnit">ErlNifTimeUnit</a>.</p><h4>enif_cpu_time(ErlNifEnv *):ERL_NIF_TERM</h4><p>Returns the CPU time in the same format as
<a href="./erlang#timestamp-0">erlang#timestamp-0</a>.
The CPU time is the time the current logical CPU has spent executing
since some arbitrary point in the past. If the OS does not support
fetching this value, <strong>enif_cpu_time</strong> invokes
<a href="#enif_make_badarg">enif_make_badarg</a>.</p><h4>enif_demonitor_process(ErlNifEnv* caller_env,
      void* obj, const ErlNifMonitor* mon):int</h4><p>Cancel a process monitor.</p><a name="enif_demonitor_process"></a><p>Cancels a monitor created earlier with <a href="#enif_monitor_process">enif_monitor_process</a>. Argument <strong>obj</strong> is a pointer
to the resource holding the monitor and	<strong>*mon</strong> identifies the
monitor.</p><p>Argument <strong>caller_env</strong> is the environment of the calling process
or callback. Must only be NULL if calling from a custom thread.</p><p>Returns <strong>0</strong> if the monitor was successfully identified and removed.
Returns	a non-zero value if the monitor could not be identified, which means
it was either</p><ul><li>never created for this resource</li><li>already cancelled</li><li>already triggered</li><li>just about to be triggered by a concurrent thread</li></ul><p>This function is only thread-safe when the emulator with SMP support
is used. It can only be used in a non-SMP emulator from a NIF-calling
thread.</p><h4>enif_equal_tids(ErlNifTid tid1, ErlNifTid tid2):int</h4><p>Same as <a href="./erl_driver#erl_drv_equal_tids">erl_driver#erl_drv_equal_tids</a>.</p><h4>enif_fprintf(FILE *stream, const char *format, ...):int</h4><p>Format strings and Erlang terms.</p><p>Similar to <strong>fprintf</strong> but this format string also accepts
<strong>"%T"</strong>, which formats Erlang terms of type
<a href="#ERL_NIF_TERM">ERL_NIF_TERM</a>.</p><p>This function is primarily intended for debugging purpose. It is not
recommended to print very large terms with <strong>%T</strong>. The function may
change <strong>errno</strong>, even if successful.</p><h4>enif_free(void* ptr):void</h4><p>Free dynamic memory.</p><p>Frees memory allocated by
<a href="#enif_alloc">enif_alloc</a>.</p><h4>enif_free_env(ErlNifEnv* env):void</h4><p>Free an environment allocated with enif_alloc_env.</p><p>Frees an environment allocated with
<a href="#enif_alloc_env">enif_alloc_env</a>.
All terms created in the environment are freed as well.</p><h4>enif_free_iovec(ErlNifIOvec* iov):void</h4><p>Free an ErlIOVec</p><p>Frees an io vector returned from
<a href="#enif_inspect_iovec">enif_inspect_iovec</a>.
This is needed only if a <strong>NULL</strong> environment is passed to
<a href="#enif_inspect_iovec">enif_inspect_iovec</a>.</p><pre><code class="">
ErlNifIOVec *iovec = NULL;
size_t max_elements = 128;
ERL_NIF_TERM tail;
if (!enif_inspect_iovec(NULL, max_elements, term, &amp;tail, &amp;iovec))
  return 0;

// Do things with the iovec

/* Free the iovector, possibly in another thread or nif function call */
enif_free_iovec(iovec);</code></pre><h4>enif_get_atom(ErlNifEnv* env, ERL_NIF_TERM
        term, char* buf, unsigned size, ErlNifCharEncoding encode):int</h4><p>Get the text representation of an atom term.</p><p>Writes a <strong>NULL</strong>-terminated string in the buffer pointed to by
<strong>buf</strong> of size <strong>size</strong>, consisting of the string
representation of the atom <strong>term</strong> with encoding
<a href="#ErlNifCharEncoding">encode</a>.</p><p>Returns the number of bytes written (including terminating
<strong>NULL</strong> character) or <strong>0</strong> if <strong>term</strong> is not an atom with
maximum length of <strong>size-1</strong>.</p><h4>enif_get_atom_length(ErlNifEnv* env,
        ERL_NIF_TERM term, unsigned* len, ErlNifCharEncoding encode):int</h4><p>Get the length of atom <strong>term</strong>.</p><p>Sets <strong>*len</strong> to the length (number of bytes excluding
terminating <strong>NULL</strong> character) of the atom <strong>term</strong> with
encoding <strong>encode</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is not
an atom.</p><h4>enif_get_double(ErlNifEnv* env,
        ERL_NIF_TERM term, double* dp):int</h4><p>Read a floating-point number term.</p><p>Sets <strong>*dp</strong> to the floating-point value of <strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is not
a float.</p><h4>enif_get_int(ErlNifEnv* env, ERL_NIF_TERM
        term, int* ip):int</h4><p>Read an integer term.</p><p>Sets <strong>*ip</strong> to the integer value of <strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is not
an integer or is outside the bounds of type <strong>int</strong>.</p><h4>enif_get_int64(ErlNifEnv* env, ERL_NIF_TERM
        term, ErlNifSInt64* ip):int</h4><p>Read a 64-bit integer term.</p><p>Sets <strong>*ip</strong> to the integer value of <strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is not
an integer or is outside the bounds of a signed 64-bit integer.</p><h4>enif_get_local_pid(ErlNifEnv* env,
        ERL_NIF_TERM term, ErlNifPid* pid):int</h4><p>Read a local pid term.</p><p>If <strong>term</strong> is the pid of a node local process, this function
initializes the pid variable <strong>*pid</strong> from it and returns
<strong>true</strong>. Otherwise returns <strong>false</strong>. No check is done to see
if the process is alive.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><strong>enif_get_local_pid</strong> will return false if argument
<strong>term</strong> is the atom <a href="#enif_make_pid">enif_make_pid</a>.</p></div><h4>enif_get_local_port(ErlNifEnv* env,
        ERL_NIF_TERM term, ErlNifPort* port_id):int</h4><p>Read a local port term.</p><p>If <strong>term</strong> identifies a node local port, this function
initializes the port variable <strong>*port_id</strong> from it and returns
<strong>true</strong>. Otherwise returns <strong>false</strong>. No check is done to see
if the port is alive.</p><h4>enif_get_list_cell(ErlNifEnv* env,
        ERL_NIF_TERM list, ERL_NIF_TERM* head, ERL_NIF_TERM* tail):int</h4><p>Get head and tail from a list.</p><p>Sets <strong>*head</strong> and <strong>*tail</strong> from list <strong>list</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if it is
not a list or the list is empty.</p><h4>enif_get_list_length(ErlNifEnv* env,
        ERL_NIF_TERM term, unsigned* len):int</h4><p>Get the length of list <strong>term</strong>.</p><p>Sets <strong>*len</strong> to the length of list <strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is
not a proper list.</p><h4>enif_get_long(ErlNifEnv* env, ERL_NIF_TERM
        term, long int* ip):int</h4><p>Read a long integer term.</p><p>Sets <strong>*ip</strong> to the long integer value of <strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is
not an integer or is outside the bounds of type <strong>long int</strong>.</p><h4>enif_get_map_size(ErlNifEnv* env,
        ERL_NIF_TERM term, size_t *size):int</h4><p>Read the size of a map term.</p><p>Sets <strong>*size</strong> to the number of key-value pairs in the map
<strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is
not a map.</p><h4>enif_get_map_value(ErlNifEnv* env,
        ERL_NIF_TERM map, ERL_NIF_TERM key, ERL_NIF_TERM* value):int</h4><p>Get the value of a key in a map.</p><p>Sets <strong>*value</strong> to the value associated with <strong>key</strong> in the
map <strong>map</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>map</strong> is not
a map or if <strong>map</strong> does not contain <strong>key</strong>.</p><h4>enif_get_resource(ErlNifEnv* env,
        ERL_NIF_TERM term, ErlNifResourceType* type, void** objp):int</h4><p>Get the pointer to a resource object.</p><p>Sets <strong>*objp</strong> to point to the resource object referred to by
<strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is
not a handle to a resource object of type <strong>type</strong>.</p><h4>enif_get_string(ErlNifEnv* env,
        ERL_NIF_TERM list, char* buf, unsigned size,
        ErlNifCharEncoding encode):int</h4><p>Get a C-string from a list.</p><p>Writes a <strong>NULL</strong>-terminated string in the buffer pointed to by
<strong>buf</strong> with size <strong>size</strong>, consisting of the characters
in the string <strong>list</strong>. The characters are written using encoding
<a href="#ErlNifCharEncoding">encode</a>.</p><p>Returns one of the following:</p><ul><li>The number of bytes written (including terminating <strong>NULL</strong> character)</li><li><strong>-size</strong> if the string was truncated because of buffer space</li><li><strong>0</strong> if <strong>list</strong> is not a string that can be encoded with <strong>encode</strong> or if <strong>size</strong> was &lt; <strong>1</strong>.</li></ul><p>The written string is always <strong>NULL</strong>-terminated, unless buffer
<strong>size</strong> is &lt; <strong>1</strong>.</p><h4>enif_get_tuple(ErlNifEnv* env, ERL_NIF_TERM
        term, int* arity, const ERL_NIF_TERM** array):int</h4><p>Inspect the elements of a tuple.</p><p>If <strong>term</strong> is a tuple, this function sets <strong>*array</strong> to point
to an array containing the elements of the tuple, and sets
<strong>*arity</strong> to the number of elements. Notice that the array
is read-only and <strong>(*array)[N-1]</strong> is the Nth element of
the tuple. <strong>*array</strong> is undefined if the arity of the tuple
is zero.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is
not a tuple.</p><h4>enif_get_uint(ErlNifEnv* env, ERL_NIF_TERM
        term, unsigned int* ip):int</h4><p>Read an unsigned integer term.</p><p>Sets <strong>*ip</strong> to the unsigned integer value of <strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is
not an unsigned integer or is outside the bounds of type
<strong>unsigned int</strong>.</p><h4>enif_get_uint64(ErlNifEnv* env,
        ERL_NIF_TERM term, ErlNifUInt64* ip):int</h4><p>Read an unsigned 64-bit integer term.</p><p>Sets <strong>*ip</strong> to the unsigned integer value of <strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is
not an unsigned integer or is outside the bounds of an unsigned
64-bit integer.</p><h4>enif_get_ulong(ErlNifEnv* env, ERL_NIF_TERM
        term, unsigned long* ip):int</h4><p>Read an unsigned integer term.</p><p>Sets <strong>*ip</strong> to the unsigned long integer value of
<strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is
not an unsigned integer or is outside the bounds of type
<strong>unsigned long</strong>.</p><h4>enif_getenv(const char* key, char* value,
        size_t *value_size):int</h4><p>Get the value of an environment variable.</p><p>Same as <a href="./erl_driver#erl_drv_getenv">erl_driver#erl_drv_getenv</a>.</p><h4>enif_has_pending_exception(ErlNifEnv* env,
        ERL_NIF_TERM* reason):int</h4><p>Check if an exception has been raised.</p><p>Returns <strong>true</strong> if a pending exception is associated with the
environment <strong>env</strong>. If <strong>reason</strong> is a <strong>NULL</strong> pointer,
ignore it. Otherwise, if a pending exception associated with
<strong>env</strong> exists, set <strong>*reason</strong> to the value of the exception
term. For example, if <a href="#enif_make_badarg">enif_make_badarg</a> is called to set a pending
<strong>badarg</strong> exception, a later call to
<strong>enif_has_pending_exception(env, &amp;reason)</strong> sets
<strong>*reason</strong> to the atom <strong>badarg</strong>, then return <strong>true</strong>.</p><p>See also <a href="#enif_make_badarg">enif_make_badarg</a> and
<a href="#enif_raise_exception">enif_raise_exception</a>.</p><h4>enif_hash(ErlNifHash type, ERL_NIF_TERM term, ErlNifUInt64 salt):ErlNifUInt64</h4><p>Hash terms.</p><p>Hashes <strong>term</strong> according to the specified
<a href="#ErlNifHash">ErlNifHash</a> <strong>type</strong>.</p><p>Ranges of taken salt (if any) and returned value depend on the hash type.</p><h4>enif_inspect_binary(ErlNifEnv* env,
        ERL_NIF_TERM bin_term, ErlNifBinary* bin):int</h4><p>Inspect the content of a binary.</p><p>Initializes the structure pointed to by <strong>bin</strong> with information
about binary term <strong>bin_term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>bin_term</strong>
is not a binary.</p><h4>enif_inspect_iolist_as_binary(ErlNifEnv*
        env, ERL_NIF_TERM term, ErlNifBinary* bin):int</h4><p>Inspect the content of an iolist.</p><p>Initializes the structure pointed to by <strong>bin</strong> with a
continuous buffer with the same byte content as <strong>iolist</strong>. As
with <strong>inspect_binary</strong>, the data pointed to by <strong>bin</strong> is
transient and does not need to be released.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>iolist</strong> is
not an iolist.</p><h4>enif_inspect_iovec(ErlNifEnv*
        env, size_t max_elements, ERL_NIF_TERM iovec_term, ERL_NIF_TERM* tail,
        ErlNifIOVec** iovec):int</h4><p>Inspect a list of binaries as an ErlNifIOVec.</p><p>Fills <strong>iovec</strong> with the list of binaries provided in
<strong>iovec_term</strong>. The number of elements handled in the call is
limited to <strong>max_elements</strong>, and <strong>tail</strong> is set to the
remainder of the list. Note that the output may be longer than
<strong>max_elements</strong> on some platforms.
</p><p>To create a list of binaries from an arbitrary iolist, use
<a href="../erts/erlang#iolist_to_iovec/1">erts/erlang#iolist_to_iovec/1</a>.</p><p>When calling this function, <strong>iovec</strong> should contain a pointer to
<strong>NULL</strong> or a ErlNifIOVec structure that should be used if
possible. e.g.
</p><pre><code class="">
/* Don't use a pre-allocated structure */
ErlNifIOVec *iovec = NULL;
enif_inspect_iovec(env, max_elements, term, &amp;tail, &amp;iovec);

/* Use a stack-allocated vector as an optimization for vectors with few elements */
ErlNifIOVec vec, *iovec = &amp;vec;
enif_inspect_iovec(env, max_elements, term, &amp;tail, &amp;iovec);
</code></pre><p>The contents of the <strong>iovec</strong> is valid until the called nif
function returns. If the <strong>iovec</strong> should be valid after the nif
call returns, it is possible to call this function with a
<strong>NULL</strong> environment. If no environment is given the <strong>iovec</strong>
owns the data in the vector and it has to be explicitly freed using
<a href="#enif_free_iovec">enif_free_iovec</a>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>iovec_term</strong>
not an iovec.</p><h4>enif_ioq_create(ErlNifIOQueueOpts opts):ErlNifIOQueue *</h4><p>Create a new IO Queue</p><p>Create a new I/O Queue that can be used to store data.
<strong>opts</strong> has to be set to <strong>ERL_NIF_IOQ_NORMAL</strong>.
</p><h4>enif_ioq_destroy(ErlNifIOQueue *q):void</h4><p>Destroy an IO Queue and free it's content</p><p>Destroy the I/O queue and free all of it's contents</p><h4>enif_ioq_deq(ErlNifIOQueue *q, size_t count, size_t *size):int</h4><p>Dequeue count bytes from the IO Queue</p><p>Dequeue <strong>count</strong> bytes from the I/O queue.
If <strong>size</strong> is not <strong>NULL</strong>, the new size of the queue
is placed there.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if the I/O does
not contain <strong>count</strong> bytes. On failure the queue is left un-altered.</p><h4>enif_ioq_enq_binary(ErlNifIOQueue *q, ErlNifBinary *bin, size_t skip):int</h4><p>Enqueue the binary into the IO Queue</p><p>Enqueue the <strong>bin</strong> into <strong>q</strong> skipping the first <strong>skip</strong> bytes.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>skip</strong> is greater
than the size of <strong>bin</strong>. Any ownership of the binary data is transferred
to the queue and <strong>bin</strong> is to be considered read-only for the rest of the NIF
call and then as released.</p><h4>enif_ioq_enqv(ErlNifIOQueue *q, ErlNifIOVec *iovec, size_t skip):int</h4><p>Enqueue the iovec into the IO Queue</p><p>Enqueue the <strong>iovec</strong> into <strong>q</strong> skipping the first <strong>skip</strong> bytes.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>skip</strong> is greater
than the size of <strong>iovec</strong>.</p><h4>enif_ioq_peek(ErlNifIOQueue *q, int *iovlen):SysIOVec *</h4><p>Peek inside the IO Queue</p><p>Get the I/O queue as a pointer to an array of <strong>SysIOVec</strong>s.
It also returns the number of elements in <strong>iovlen</strong>.</p><p>Nothing is removed from the queue by this function, that must be done
with <a href="#enif_ioq_deq">enif_ioq_deq</a>.</p><p>The returned array is suitable to use with the Unix system
call <strong>writev</strong>.</p><h4>enif_ioq_peek_head(ErlNifEnv *env, ErlNifIOQueue *q, size_t *size, ERL_NIF_TERM *bin_term):int</h4><p>Peek the head of the IO Queue.</p><p>Get the head of the IO Queue as a binary term.</p><p>If <strong>size</strong> is not <strong>NULL</strong>, the size of the head is placed
there.</p><p>Nothing is removed from the queue by this function, that must be done
with <a href="#enif_ioq_deq">enif_ioq_deq</a>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if the queue is
empty.</p><h4>enif_ioq_size(ErlNifIOQueue *q):size_t</h4><p>Get the current size of the IO Queue</p><p>Get the size of <strong>q</strong>.</p><h4>enif_is_atom(ErlNifEnv* env, ERL_NIF_TERM term):int</h4><p>Determine if a term is an atom.</p><p>Returns <strong>true</strong> if <strong>term</strong> is an atom.</p><h4>enif_is_binary(ErlNifEnv* env, ERL_NIF_TERM term):int</h4><p>Determine if a term is a binary.</p><p>Returns <strong>true</strong> if <strong>term</strong> is a binary.</p><h4>enif_is_current_process_alive(ErlNifEnv* env):int</h4><p>Determine if currently executing process is alive.</p><p>Returns <strong>true</strong> if the currently executing process is currently
alive, otherwise <strong>false</strong>.</p><p>This function can only be used from a NIF-calling thread, and with
an environment corresponding to currently executing processes.</p><h4>enif_is_empty_list(ErlNifEnv* env,
        ERL_NIF_TERM term):int</h4><p>Determine if a term is an empty list.</p><p>Returns <strong>true</strong> if <strong>term</strong> is an empty list.</p><h4>enif_is_exception(ErlNifEnv* env,
        ERL_NIF_TERM term):int</h4><p>Determine if a term is an exception.</p><a name="enif_is_exception"></a><p>Return true if <strong>term</strong> is an exception.</p><h4>enif_is_fun(ErlNifEnv* env, ERL_NIF_TERM
        term):int</h4><p>Determine if a term is a fun.</p><p>Returns <strong>true</strong> if <strong>term</strong> is a fun.</p><h4>enif_is_identical(ERL_NIF_TERM lhs,
        ERL_NIF_TERM rhs):int</h4><p>Erlang operator =:=.</p><p>Returns <strong>true</strong> if the two terms are identical. Corresponds to
the Erlang operators <strong>=:=</strong> and <strong>=/=</strong>.</p><h4>enif_is_list(ErlNifEnv* env, ERL_NIF_TERM term):int</h4><p>Determine if a term is a list.</p><p>Returns <strong>true</strong> if <strong>term</strong> is a list.</p><h4>enif_is_map(ErlNifEnv* env, ERL_NIF_TERM
        term):int</h4><p>Determine if a term is a map.</p><p>Returns <strong>true</strong> if <strong>term</strong> is a map, otherwise
<strong>false</strong>.</p><h4>enif_is_number(ErlNifEnv* env, ERL_NIF_TERM
        term):int</h4><p>Determine if a term is a number (integer or float).</p><p>Returns <strong>true</strong> if <strong>term</strong> is a number.</p><h4>enif_is_pid(ErlNifEnv* env, ERL_NIF_TERM term):int</h4><p>Determine if a term is a pid.</p><p>Returns <strong>true</strong> if <strong>term</strong> is a pid.</p><h4>enif_is_pid_undefined(const ErlNifPid* pid):int</h4><p>Determine if pid is undefined.</p><p>Returns <strong>true</strong> if <strong>pid</strong> has been set as undefined by
<a href="#enif_set_pid_undefined">enif_set_pid_undefined</a>.</p><h4>enif_is_port(ErlNifEnv* env, ERL_NIF_TERM term):int</h4><p>Determine if a term is a port.</p><p>Returns <strong>true</strong> if <strong>term</strong> is a port.</p><h4>enif_is_port_alive(ErlNifEnv* env,
        ErlNifPort *port_id):int</h4><p>Determine if a local port is alive.</p><p>Returns <strong>true</strong> if <strong>port_id</strong> is alive.</p><p>This function is only thread-safe when the emulator with SMP support
is used. It can only be used in a non-SMP emulator from a NIF-calling
thread.</p><h4>enif_is_process_alive(ErlNifEnv* env,
        ErlNifPid *pid):int</h4><p>Determine if a local process is alive.</p><p>Returns <strong>true</strong> if <strong>pid</strong> is alive.</p><p>This function is only thread-safe when the emulator with SMP support
is used. It can only be used in a non-SMP emulator from a NIF-calling
thread.</p><h4>enif_is_ref(ErlNifEnv* env, ERL_NIF_TERM term):int</h4><p>Determine if a term is a reference.</p><p>Returns <strong>true</strong> if <strong>term</strong> is a reference.</p><h4>enif_is_tuple(ErlNifEnv* env, ERL_NIF_TERM term):int</h4><p>Determine if a term is a tuple.</p><p>Returns <strong>true</strong> if <strong>term</strong> is a tuple.</p><h4>enif_keep_resource(void* obj):int</h4><p>Add a reference to a resource object.</p><p>Adds a reference to resource object <strong>obj</strong> obtained from
<a href="#enif_alloc_resource">enif_alloc_resource</a>. Each call to
<strong>enif_keep_resource</strong> for an object must be balanced by a call to
<a href="#enif_release_resource">enif_release_resource</a>
before the object is destructed.</p><h4>enif_make_atom(ErlNifEnv* env, const char* name):ERL_NIF_TERM</h4><p>Create an atom term.</p><p>Creates an atom term from the <strong>NULL</strong>-terminated C-string
<strong>name</strong> with ISO Latin-1 encoding. If the length of <strong>name</strong>
exceeds the maximum length allowed for an atom (255 characters),
<strong>enif_make_atom</strong> invokes <a href="#enif_make_badarg">enif_make_badarg</a>.</p><h4>enif_make_atom_len(ErlNifEnv* env,
        const char* name, size_t len):ERL_NIF_TERM</h4><p>Create an atom term.</p><p>Create an atom term from the string <strong>name</strong> with length
<strong>len</strong>. <strong>NULL</strong> characters are treated as any other
characters. If <strong>len</strong> exceeds the maximum length
allowed for an atom (255 characters), <strong>enif_make_atom</strong> invokes
<a href="#enif_make_badarg">enif_make_badarg</a>.</p><h4>enif_make_badarg(ErlNifEnv* env):ERL_NIF_TERM</h4><p>Make a badarg exception.</p><p>Makes a <strong>badarg</strong> exception to be returned from a NIF, and
associates it with environment <strong>env</strong>. Once a NIF or any function
it calls invokes <strong>enif_make_badarg</strong>, the runtime ensures that a
<strong>badarg</strong> exception is raised when the NIF returns, even if the
NIF attempts to return a non-exception term instead.</p><p>The return value from <strong>enif_make_badarg</strong> can be used only as
the return value from the NIF that invoked it (directly or indirectly)
or be passed to <a href="#enif_is_exception">enif_is_exception</a>, but not to any other NIF API
function.</p><p>See also <a href="#enif_has_pending_exception">enif_has_pending_exception</a> and
<a href="#enif_raise_exception">enif_raise_exception</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Before ERTS 7.0 (Erlang/OTP 18), the return value
from <strong>enif_make_badarg</strong> had to be returned from the NIF. This
requirement is now lifted as the return value from the NIF is
ignored if <strong>enif_make_badarg</strong> has been invoked.</p></div><h4>enif_make_binary(ErlNifEnv* env, ErlNifBinary* bin):ERL_NIF_TERM</h4><p>Make a binary term.</p><p>Makes a binary term from <strong>bin</strong>. Any ownership of
the binary data is transferred to the created term and
<strong>bin</strong> is to be considered read-only for the rest of the NIF
call and then as released.</p><h4>enif_make_copy(ErlNifEnv* dst_env,
        ERL_NIF_TERM src_term):ERL_NIF_TERM</h4><p>Make a copy of a term.</p><p>Makes a copy of term <strong>src_term</strong>. The copy is created in
environment <strong>dst_env</strong>. The source term can be located in any
environment.</p><h4>enif_make_double(ErlNifEnv* env, double d):ERL_NIF_TERM</h4><p>Create a floating-point term.</p><p>Creates a floating-point term from a <strong>double</strong>. If argument
<strong>double</strong> is not finite or is NaN, <strong>enif_make_double</strong>
invokes <a href="#enif_make_badarg">enif_make_badarg</a>.</p><h4>enif_make_existing_atom(ErlNifEnv* env,
        const char* name, ERL_NIF_TERM* atom, ErlNifCharEncoding
        encode):int</h4><p>Create an existing atom term.</p><p>Tries to create the term of an already existing atom from
the <strong>NULL</strong>-terminated C-string <strong>name</strong> with encoding
<a href="#ErlNifCharEncoding">encode</a>.</p><p>If the atom already exists, this function stores the term in
<strong>*atom</strong> and returns <strong>true</strong>, otherwise <strong>false</strong>.
Also returns <strong>false</strong> if the length of <strong>name</strong> exceeds the
maximum length allowed for an atom (255 characters).</p><h4>enif_make_existing_atom_len(ErlNifEnv* env,
        const char* name, size_t len, ERL_NIF_TERM* atom, ErlNifCharEncoding
        encoding):int</h4><p>Create an existing atom term.</p><p>Tries to create the term of an already existing atom from the
string <strong>name</strong> with length <strong>len</strong> and encoding
<a href="#ErlNifCharEncoding">encode</a>. <strong>NULL</strong>
characters are treated as any other characters.</p><p>If the atom already exists, this function stores the term in
<strong>*atom</strong> and returns <strong>true</strong>, otherwise <strong>false</strong>.
Also returns <strong>false</strong> if <strong>len</strong> exceeds the maximum length
allowed for an atom (255 characters).</p><h4>enif_make_int(ErlNifEnv* env, int i):ERL_NIF_TERM</h4><p>Create an integer term.</p><p>Creates an integer term.</p><h4>enif_make_int64(ErlNifEnv* env, ErlNifSInt64 i):ERL_NIF_TERM</h4><p>Create an integer term.</p><p>Creates an integer term from a signed 64-bit integer.</p><h4>enif_make_list(ErlNifEnv* env, unsigned cnt, ...):ERL_NIF_TERM</h4><p>Create a list term.</p><p>Creates an ordinary list term of length <strong>cnt</strong>. Expects
<strong>cnt</strong> number of arguments (after <strong>cnt</strong>) of type
<strong>ERL_NIF_TERM</strong> as the elements of the list.</p><p>Returns an empty list if <strong>cnt</strong> is 0.</p><h4>enif_make_list1(ErlNifEnv* env, ERL_NIF_TERM e1):ERL_NIF_TERM</h4><h4>enif_make_list2(ErlNifEnv* env,
        ERL_NIF_TERM e1, ERL_NIF_TERM e2):ERL_NIF_TERM</h4><h4>enif_make_list3(ErlNifEnv* env,
        ERL_NIF_TERM e1, ERL_NIF_TERM e2, ERL_NIF_TERM e3):ERL_NIF_TERM</h4><h4>enif_make_list4(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e4):ERL_NIF_TERM</h4><h4>enif_make_list5(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e5):ERL_NIF_TERM</h4><h4>enif_make_list6(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e6):ERL_NIF_TERM</h4><h4>enif_make_list7(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e7):ERL_NIF_TERM</h4><h4>enif_make_list8(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e8):ERL_NIF_TERM</h4><h4>enif_make_list9(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e9):ERL_NIF_TERM</h4><p>Create a list term.</p><p>Creates an ordinary list term with length indicated by the
function name. Prefer these functions (macros) over the variadic
<strong>enif_make_list</strong> to get a compile-time error if the number of
arguments does not match.</p><h4>enif_make_list_cell(ErlNifEnv*
        env, ERL_NIF_TERM head, ERL_NIF_TERM tail):ERL_NIF_TERM</h4><p>Create a list cell.</p><p>Creates a list cell <strong>[head | tail]</strong>.</p><h4>enif_make_list_from_array(ErlNifEnv* env, const ERL_NIF_TERM
          arr[], unsigned cnt):ERL_NIF_TERM</h4><p>Create a list term from an array.</p><p>Creates an ordinary list containing the elements of array <strong>arr</strong>
of length <strong>cnt</strong>.</p><p>Returns an empty list if <strong>cnt</strong> is 0.</p><h4>enif_make_long(ErlNifEnv* env, long int i):ERL_NIF_TERM</h4><p>Create an integer term from a long int.</p><p>Creates an integer term from a <strong>long int</strong>.</p><h4>enif_make_map_put(ErlNifEnv* env,
        ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM value,
        ERL_NIF_TERM* map_out):int</h4><p>Insert key-value pair in map.</p><p>Makes a copy of map <strong>map_in</strong> and inserts <strong>key</strong> with
<strong>value</strong>. If <strong>key</strong> already exists in <strong>map_in</strong>, the old
associated value is replaced by <strong>value</strong>.</p><p>If successful, this function sets <strong>*map_out</strong> to the new map and
returns <strong>true</strong>. Returns <strong>false</strong> if <strong>map_in</strong> is not a
map.</p><p>The <strong>map_in</strong> term must belong to environment <strong>env</strong>.</p><h4>enif_make_map_remove(ErlNifEnv* env,
        ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM* map_out):int</h4><p>Remove key from map.</p><p>If map <strong>map_in</strong> contains <strong>key</strong>, this function makes a copy
of <strong>map_in</strong> in <strong>*map_out</strong>, and removes <strong>key</strong> and the
associated value. If map <strong>map_in</strong> does not contain <strong>key</strong>,
<strong>*map_out</strong> is set to <strong>map_in</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>map_in</strong> is
not a map.</p><p>The <strong>map_in</strong> term must belong to environment <strong>env</strong>.</p><h4>enif_make_map_update(ErlNifEnv* env,
        ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM new_value,
        ERL_NIF_TERM* map_out):int</h4><p>Replace value for key in map.</p><p>Makes a copy of map <strong>map_in</strong> and replace the old associated
value for <strong>key</strong> with <strong>new_value</strong>.</p><p>If successful, this function sets <strong>*map_out</strong> to the new map and
returns <strong>true</strong>. Returns <strong>false</strong> if <strong>map_in</strong> is not a
map or if it does not contain <strong>key</strong>.</p><p>The <strong>map_in</strong> term must belong to environment <strong>env</strong>.</p><h4>enif_make_map_from_arrays(ErlNifEnv* env, ERL_NIF_TERM keys[],
        ERL_NIF_TERM values[], size_t cnt, ERL_NIF_TERM *map_out):int</h4><p>Make map term from the given keys and values.</p><p>Makes a map term from the given keys and values.</p><p>If successful, this function sets <strong>*map_out</strong> to the new map and
returns <strong>true</strong>. Returns <strong>false</strong> there are any duplicate
keys.</p><p>All keys and values must belong to <strong>env</strong>.</p><h4>enif_make_monitor_term(ErlNifEnv* env, const ErlNifMonitor* mon):ERL_NIF_TERM</h4><p>Make monitor term from the given monitor identifier.</p><p>Creates a term identifying the given monitor received from
<a href="#enif_monitor_process">enif_monitor_process</a>.</p><p>This function is primarily intended for debugging purpose.</p><h4>enif_make_new_binary(ErlNifEnv*
        env, size_t size, ERL_NIF_TERM* termp):unsigned char *</h4><p>Allocate and create a new binary term.</p><p>Allocates a binary of size <strong>size</strong> bytes and creates an owning
term. The binary data is mutable until the calling NIF returns.
This is a quick way to create a new binary without having to use
<a href="#ErlNifBinary">ErlNifBinary</a>.
The drawbacks are that the binary cannot be kept between NIF calls
and it cannot be reallocated.</p><p>Returns a pointer to the raw binary data and sets
<strong>*termp</strong> to the binary term.</p><h4>enif_make_new_map(ErlNifEnv* env):ERL_NIF_TERM</h4><p>Make an empty map term.</p><p>Makes an empty map term.</p><h4>enif_make_pid(ErlNifEnv* env, const ErlNifPid* pid):ERL_NIF_TERM</h4><p>Make a pid term.</p><p>Makes a pid term or the atom <a href="#enif_set_pid_undefined">enif_set_pid_undefined</a> from <strong>*pid</strong>.</p><h4>enif_make_ref(ErlNifEnv* env):ERL_NIF_TERM</h4><p>Create a reference.</p><p>Creates a reference like <a href="./erlang#make_ref-0">erlang#make_ref-0</a>.</p><h4>enif_make_resource(ErlNifEnv* env, void* obj):ERL_NIF_TERM</h4><p>Create an opaque handle to a resource object.</p><p>Creates an opaque handle to a memory-managed resource object
obtained by <a href="#enif_alloc_resource">enif_alloc_resource</a>. No ownership transfer is done,
as the resource object still needs to be released by
<a href="#enif_release_resource">enif_release_resource</a>. However, notice that the call
to <strong>enif_release_resource</strong> can occur immediately after obtaining
the term from <strong>enif_make_resource</strong>, in which case the resource
object is deallocated when the term is garbage collected. For more
details, see the <a href="#enif_resource_example">example of creating and returning a resource object</a> in the User's
Guide.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Since ERTS 9.0 (OTP-20.0), resource terms have a defined behavior
when compared and serialized through <strong>term_to_binary</strong> or passed
between nodes.</p><ul><li> <p>Two resource terms will compare equal if and only if they
would yield the same resource object pointer when passed to
<a href="#enif_get_resource">enif_get_resource</a>.</p> </li><li> <p>A resource term can be serialized with <strong>term_to_binary</strong> and later
be fully recreated if the resource object is still alive when
<strong>binary_to_term</strong> is called. A <em>stale</em> resource term will be
returned from <strong>binary_to_term</strong> if the resource object has
been deallocated. <a href="#enif_get_resource">enif_get_resource</a>
will return false for stale resource terms.</p> <p>The same principles of serialization apply when passing
resource terms in messages to remote nodes and back again. A
resource term will act stale on all nodes except the node where
its resource object is still alive in memory.</p> </li></ul><p>Before ERTS 9.0 (OTP-20.0), all resource terms did
compare equal to each other and to empty binaries (<strong>&lt;&lt;&gt;&gt;</strong>).
If serialized, they would be recreated as plain empty binaries.</p></div><h4>enif_make_resource_binary(ErlNifEnv* env, void* obj, const
        void* data, size_t size):ERL_NIF_TERM</h4><p>Create a custom binary term.</p><p>Creates a binary term that is memory-managed by a resource object
<strong>obj</strong> obtained by <a href="#enif_alloc_resource">enif_alloc_resource</a>. The returned binary term
consists of <strong>size</strong> bytes pointed to by <strong>data</strong>. This raw
binary data must be kept readable and unchanged until the destructor
of the resource is called. The binary data can be stored external to
the resource object, in which case the destructor is responsible
for releasing the data.</p><p>Several binary terms can be managed by the same resource object. The
destructor is not called until the last binary is garbage collected.
This can be useful to return different parts of a larger binary
buffer.</p><p>As with <a href="#enif_make_resource">enif_make_resource</a>, no ownership transfer is done.
The resource still needs to be released with
<a href="#enif_release_resource">enif_release_resource</a>.</p><h4>enif_make_reverse_list(ErlNifEnv* env, ERL_NIF_TERM list_in,
        ERL_NIF_TERM *list_out):int</h4><p>Create the reverse of a list.</p><p>Sets <strong>*list_out</strong> to the reverse list of the list <strong>list_in</strong>
and returns <strong>true</strong>, or returns <strong>false</strong> if <strong>list_in</strong> is
not a list.</p><p>This function is only to be used on short lists, as a copy is
created of the list, which is not released until after the NIF
returns.</p><p>The <strong>list_in</strong> term must belong to environment <strong>env</strong>.</p><h4>enif_make_string(ErlNifEnv* env,
        const char* string, ErlNifCharEncoding encoding):ERL_NIF_TERM</h4><p>Create a string.</p><p>Creates a list containing the characters of the
<strong>NULL</strong>-terminated string <strong>string</strong> with encoding
<a href="#ErlNifCharEncoding">encoding</a>.</p><h4>enif_make_string_len(ErlNifEnv*
        env, const char* string, size_t len, ErlNifCharEncoding
        encoding):ERL_NIF_TERM</h4><p>Create a string.</p><p>Creates a list containing the characters of the string <strong>string</strong>
with length <strong>len</strong> and encoding
<a href="#ErlNifCharEncoding">encoding</a>.
<strong>NULL</strong> characters are treated as any other characters.</p><h4>enif_make_sub_binary(ErlNifEnv*
        env, ERL_NIF_TERM bin_term, size_t pos, size_t size):ERL_NIF_TERM</h4><p>Make a subbinary term.</p><p>Makes a subbinary of binary <strong>bin_term</strong>, starting at
zero-based position <strong>pos</strong> with a length of <strong>size</strong> bytes.
<strong>bin_term</strong> must be a binary or bitstring. <strong>pos+size</strong> must
be less or equal to the number of whole bytes in <strong>bin_term</strong>.</p><h4>enif_make_tuple(ErlNifEnv* env,
        unsigned cnt, ...):ERL_NIF_TERM</h4><p>Creates a tuple term.</p><p>Creates a tuple term of arity <strong>cnt</strong>. Expects <strong>cnt</strong> number
of arguments (after <strong>cnt</strong>) of type <strong>ERL_NIF_TERM</strong> as the
elements of the tuple.</p><h4>enif_make_tuple1(ErlNifEnv* env,
        ERL_NIF_TERM e1):ERL_NIF_TERM</h4><h4>enif_make_tuple2(ErlNifEnv* env,
        ERL_NIF_TERM e1, ERL_NIF_TERM e2):ERL_NIF_TERM</h4><h4>enif_make_tuple3(ErlNifEnv* env,
        ERL_NIF_TERM e1, ERL_NIF_TERM e2, ERL_NIF_TERM e3):ERL_NIF_TERM</h4><h4>enif_make_tuple4(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e4):ERL_NIF_TERM</h4><h4>enif_make_tuple5(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e5):ERL_NIF_TERM</h4><h4>enif_make_tuple6(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e6):ERL_NIF_TERM</h4><h4>enif_make_tuple7(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e7):ERL_NIF_TERM</h4><h4>enif_make_tuple8(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e8):ERL_NIF_TERM</h4><h4>enif_make_tuple9(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e9):ERL_NIF_TERM</h4><p>Create a tuple term.</p><p>Creates a tuple term with length indicated by the
function name. Prefer these functions (macros) over the variadic
<strong>enif_make_tuple</strong> to get a compile-time error if the number of
arguments does not match.</p><h4>enif_make_tuple_from_array(ErlNifEnv* env, const ERL_NIF_TERM
        arr[], unsigned cnt):ERL_NIF_TERM</h4><p>Create a tuple term from an array.</p><p>Creates a tuple containing the elements of array <strong>arr</strong>
of length <strong>cnt</strong>.</p><h4>enif_make_uint(ErlNifEnv* env, unsigned int i):ERL_NIF_TERM</h4><p>Create an unsigned integer term.</p><p>Creates an integer term from an <strong>unsigned int</strong>.</p><h4>enif_make_uint64(ErlNifEnv* env, ErlNifUInt64 i):ERL_NIF_TERM</h4><p>Create an unsigned integer term.</p><p>Creates an integer term from an unsigned 64-bit integer.</p><h4>enif_make_ulong(ErlNifEnv* env, unsigned long i):ERL_NIF_TERM</h4><p>Create an integer term from an unsigned long int.</p><p>Creates an integer term from an <strong>unsigned long int</strong>.</p><h4>enif_make_unique_integer(ErlNifEnv
        *env, ErlNifUniqueInteger properties):ERL_NIF_TERM</h4><p>Returns a unique integer with the same properties as specified by
<a href="./erlang#unique_integer-1">erlang#unique_integer-1</a>.</p><p><strong>env</strong> is the environment to create the integer in.</p><p><strong>ERL_NIF_UNIQUE_POSITIVE</strong> and <strong>ERL_NIF_UNIQUE_MONOTONIC</strong>
can be passed as the second argument to change the properties of the
integer returned. They can be combined by OR:ing the two values
together.</p><p>See also <a href="#ErlNifUniqueInteger">ErlNifUniqueInteger</a>.</p><h4>enif_map_iterator_create(ErlNifEnv *env,
        ERL_NIF_TERM map, ErlNifMapIterator *iter, ErlNifMapIteratorEntry
        entry):int</h4><p>Create a map iterator.</p><p>Creates an iterator for the map <strong>map</strong> by initializing the
structure pointed to by <strong>iter</strong>. Argument <strong>entry</strong> determines
the start position of the iterator: <strong>ERL_NIF_MAP_ITERATOR_FIRST</strong>
or <strong>ERL_NIF_MAP_ITERATOR_LAST</strong>.</p><p>Returns <strong>true</strong> on success, or false if <strong>map</strong> is not a
map.</p><p>A map iterator is only useful during the lifetime of environment
<strong>env</strong> that the <strong>map</strong> belongs to. The iterator must be
destroyed by calling <a href="#enif_map_iterator_destroy">enif_map_iterator_destroy</a>:</p><pre><code class="">
ERL_NIF_TERM key, value;
ErlNifMapIterator iter;
enif_map_iterator_create(env, my_map, &amp;iter, ERL_NIF_MAP_ITERATOR_FIRST);

while (enif_map_iterator_get_pair(env, &amp;iter, &amp;key, &amp;value)) {
    do_something(key,value);
    enif_map_iterator_next(env, &amp;iter);
}
enif_map_iterator_destroy(env, &amp;iter);</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The key-value pairs of a map have no defined iteration order.
The only guarantee is that the iteration order of a single map
instance is preserved during the lifetime of the environment that
the map belongs to.</p></div><h4>enif_map_iterator_destroy(ErlNifEnv *env,
        ErlNifMapIterator *iter):void</h4><p>Destroy a map iterator.</p><p>Destroys a map iterator created by
<a href="#enif_map_iterator_create">enif_map_iterator_create</a>.</p><h4>enif_map_iterator_get_pair(ErlNifEnv *env,
        ErlNifMapIterator *iter, ERL_NIF_TERM *key, ERL_NIF_TERM
        *value):int</h4><p>Get key and value at current map iterator position.</p><p>Gets key and value terms at the current map iterator position.</p><p>On success, sets <strong>*key</strong> and <strong>*value</strong> and returns
<strong>true</strong>. Returns <strong>false</strong> if the iterator is positioned at
head (before first entry) or tail (beyond last entry).</p><h4>enif_map_iterator_is_head(ErlNifEnv *env,
        ErlNifMapIterator *iter):int</h4><p>Check if map iterator is positioned before first.</p><p>Returns <strong>true</strong> if map iterator <strong>iter</strong> is positioned
before the first entry.</p><h4>enif_map_iterator_is_tail(ErlNifEnv *env,
        ErlNifMapIterator *iter):int</h4><p>Check if map iterator is positioned after last.</p><p>Returns <strong>true</strong> if map iterator <strong>iter</strong> is positioned
after the last entry.</p><h4>enif_map_iterator_next(ErlNifEnv *env,
        ErlNifMapIterator *iter):int</h4><p>Increment map iterator to point to next entry.</p><p>Increments map iterator to point to the next key-value entry.</p><p>Returns <strong>true</strong> if the iterator is now positioned at a valid
key-value entry, or <strong>false</strong> if the iterator is positioned at
the tail (beyond the last entry).</p><h4>enif_map_iterator_prev(ErlNifEnv *env,
        ErlNifMapIterator *iter):int</h4><p>Decrement map iterator to point to previous entry.</p><p>Decrements map iterator to point to the previous key-value entry.</p><p>Returns <strong>true</strong> if the iterator is now positioned at a valid
key-value entry, or <strong>false</strong> if the iterator is positioned at
the head (before the first entry).</p><h4>enif_monitor_process(ErlNifEnv* caller_env,
      void* obj, const ErlNifPid* target_pid, ErlNifMonitor* mon):int</h4><p>Monitor a process from a resource.</p><a name="enif_monitor_process"></a><p>Starts monitoring a process from a resource. When a process is
monitored, a process exit results in a call to the provided
<a href="#ErlNifResourceDown">ErlNifResourceDown</a> callback associated with the resource type.</p><p>Argument <strong>obj</strong> is pointer to the resource to hold the monitor and
<strong>*target_pid</strong> identifies the local process to be monitored.</p><p>If <strong>mon</strong> is not <strong>NULL</strong>, a successful call stores the
identity of the monitor	in the
<a href="#ErlNifMonitor">ErlNifMonitor</a>
struct pointed to by <strong>mon</strong>. This identifier is used to refer to the
monitor for later removal with
<a href="#enif_demonitor_process">enif_demonitor_process</a>
or compare with
<a href="#enif_compare_monitors">enif_compare_monitors</a>.
A monitor is automatically removed when it triggers or when
the resource is deallocated.</p><p>Argument <strong>caller_env</strong> is the environment of the calling process
or callback. Must only be NULL if calling from a custom thread.</p><p>Returns <strong>0</strong> on success, &lt; 0 if no <strong>down</strong> callback is
provided, and &gt; 0 if the process is no longer alive or if
<strong>target_pid</strong> is <a href="#enif_set_pid_undefined"> undefined</a>.</p><p>This function is only thread-safe when the emulator with SMP support
is used. It can only be used in a non-SMP emulator from a NIF-calling
thread.</p><h4>enif_monotonic_time(ErlNifTimeUnit time_unit):ErlNifTime</h4><p>Get Erlang monotonic time.</p><a name="enif_monotonic_time"></a><p>Returns the current
<a href="./time_correction#Erlang_Monotonic_Time"> Erlang monotonic time</a>. Notice that it is not uncommon with
negative values.</p><p><strong>time_unit</strong> is the time unit of the returned value.</p><p>Returns <strong>ERL_NIF_TIME_ERROR</strong> if called with an invalid time
unit argument, or if called from a thread that is not a scheduler
thread.</p><p>See also <a href="#ErlNifTime">ErlNifTime</a>
and <a href="#ErlNifTimeUnit">ErlNifTimeUnit</a>.
</p><h4>enif_mutex_create(char *name):ErlNifMutex *</h4><p>Same as <a href="./erl_driver#erl_drv_mutex_create">erl_driver#erl_drv_mutex_create</a>.</p><h4>enif_mutex_destroy(ErlNifMutex *mtx):void</h4><p>Same as <a href="./erl_driver#erl_drv_mutex_destroy">erl_driver#erl_drv_mutex_destroy</a>.</p><h4>enif_mutex_lock(ErlNifMutex *mtx):void</h4><p>Same as <a href="./erl_driver#erl_drv_mutex_lock">erl_driver#erl_drv_mutex_lock</a>.</p><h4>enif_mutex_name(ErlNifMutex* mtx):char*</h4><p>Same as <a href="./erl_driver#erl_drv_mutex_name">erl_driver#erl_drv_mutex_name</a>.</p><h4>enif_mutex_trylock(ErlNifMutex *mtx):int</h4><p>Same as <a href="./erl_driver#erl_drv_mutex_trylock">erl_driver#erl_drv_mutex_trylock</a>.</p><h4>enif_mutex_unlock(ErlNifMutex *mtx):void</h4><p>Same as <a href="./erl_driver#erl_drv_mutex_unlock">erl_driver#erl_drv_mutex_unlock</a>.</p><h4>enif_now_time(ErlNifEnv *env):ERL_NIF_TERM</h4><p>Returns an <a href="./erlang#now-0">erlang#now-0</a> time stamp.</p><p><em>This function is deprecated.</em></p><h4>enif_open_resource_type(ErlNifEnv* env, const char*
        module_str, const char* name, ErlNifResourceDtor* dtor,
        ErlNifResourceFlags flags, ErlNifResourceFlags* tried):ErlNifResourceType *</h4><p>Create or takeover a resource type.</p><p>Creates or takes over a resource type identified by the string
<strong>name</strong> and gives it the destructor function pointed to by
<a href="#ErlNifResourceDtor">ErlNifResourceDtor</a>.
Argument <strong>flags</strong> can have the following values:</p><dl><dt><strong>ERL_NIF_RT_CREATE</strong></dt><dd>Creates a new resource type that does not already exist.</dd><dt><strong>ERL_NIF_RT_TAKEOVER</strong></dt><dd>Opens an existing resource type and takes over ownership of all its instances. The supplied destructor <strong>dtor</strong> is called both for existing instances and new instances not yet created by the calling NIF library.</dd></dl><p>The two flag values can be combined with bitwise OR. The resource
type name is local to the calling module. Argument <strong>module_str</strong>
is not (yet) used and must be <strong>NULL</strong>. <strong>dtor</strong> can be
<strong>NULL</strong> if no destructor is needed.</p><p>On success, the function returns a pointer to the resource type and
<strong>*tried</strong> is set to either <strong>ERL_NIF_RT_CREATE</strong> or
<strong>ERL_NIF_RT_TAKEOVER</strong> to indicate what was done. On failure,
returns <strong>NULL</strong> and sets <strong>*tried</strong> to <strong>flags</strong>.
It is allowed to set <strong>tried</strong> to <strong>NULL</strong>.</p><p>Notice that <strong>enif_open_resource_type</strong> is only allowed to be
called in the two callbacks
<a href="#load">load</a> and
<a href="#upgrade">upgrade</a>.</p><p>See also <a href="#enif_open_resource_type_x">enif_open_resource_type_x</a>.</p><h4>enif_open_resource_type_x(ErlNifEnv* env, const char* name,
	const ErlNifResourceTypeInit* init,
        ErlNifResourceFlags flags, ErlNifResourceFlags* tried):ErlNifResourceType *</h4><p>Create or takeover a resource type.</p><p>Same as <a href="#enif_open_resource_type">enif_open_resource_type</a>
except it accepts additional callback functions for resource types that are
used together with <a href="#enif_select">enif_select</a>
and <a href="#enif_monitor_process">enif_monitor_process</a>.</p><p>Argument <strong>init</strong> is a pointer to an
<a href="#ErlNifResourceTypeInit">ErlNifResourceTypeInit</a>
structure that contains the function pointers for destructor, down and stop callbacks
for the resource type.</p><h4>enif_port_command(ErlNifEnv* env, const
       ErlNifPort* to_port, ErlNifEnv *msg_env, ERL_NIF_TERM msg):int</h4><p>Send a port_command to to_port.</p><p>Works as <a href="./erlang#port_command-2">erlang#port_command-2</a>,
except that it is always completely asynchronous.</p><dl><dt><strong>env</strong></dt><dd>The environment of the calling process. Must not be <strong>NULL</strong>.</dd><dt><strong>*to_port</strong></dt><dd>The port ID of the receiving port. The port ID is to refer to a port on the local node.</dd><dt><strong>msg_env</strong></dt><dd>The environment of the message term. Can be a process independent environment allocated with <a href="#enif_alloc_env">enif_alloc_env</a> or <strong>NULL</strong>.</dd><dt><strong>msg</strong></dt><dd>The message term to send. The same limitations apply as on the payload to <a href="./erlang#port_command-2">erlang#port_command-2</a>.</dd></dl><p>Using a <strong>msg_env</strong> of <strong>NULL</strong> is an optimization, which
groups together calls to <strong>enif_alloc_env</strong>, <strong>enif_make_copy</strong>,
<strong>enif_port_command</strong>, and <strong>enif_free_env</strong> into one call.
This optimization is only useful when a majority of the terms are to
be copied from <strong>env</strong> to <strong>msg_env</strong>.</p><p>Returns <strong>true</strong> if the command is successfully sent. Returns
<strong>false</strong> if the command fails, for example:</p><ul><li><strong>*to_port</strong> does not refer to a local port.</li><li>The currently executing process (that is, the sender) is not alive.</li><li><strong>msg</strong> is invalid.</li></ul><p>See also <a href="#enif_get_local_port">enif_get_local_port</a>.</p><h4>enif_priv_data(ErlNifEnv* env):void *</h4><p>Get the private data of a NIF library.</p><p>Returns the pointer to the private data that was set by
<a href="#load">load</a> or
<a href="#upgrade">upgrade</a>.</p><h4>enif_raise_exception(ErlNifEnv*
        env, ERL_NIF_TERM reason):ERL_NIF_TERM</h4><p>Raise a NIF error exception.</p><p>Creates an error exception with the term <strong>reason</strong> to be
returned from a NIF, and associates it with environment <strong>env</strong>.
Once a NIF or any function it calls invokes
<strong>enif_raise_exception</strong>, the runtime ensures that the exception
it creates is raised when the NIF returns, even if the NIF attempts
to return a non-exception term instead.</p><p>The return value from <strong>enif_raise_exception</strong> can only be used
as the return value from the NIF that invoked it (directly or
indirectly) or be passed to <a href="#enif_is_exception">enif_is_exception</a>, but not to any other NIF API
function.</p><p>See also <a href="#enif_has_pending_exception">enif_has_pending_exception</a> and
<a href="#enif_make_badarg">enif_make_badarg</a>.</p><h4>enif_realloc(void* ptr, size_t size):void *</h4><p>Reallocate dynamic memory.</p><p>Reallocates memory allocated by
<a href="#enif_alloc">enif_alloc</a> to
<strong>size</strong> bytes.</p><p>Returns <strong>NULL</strong> if the reallocation fails.</p><p>The returned pointer is suitably aligned for any built-in type that
fit in the allocated memory.</p><h4>enif_realloc_binary(ErlNifBinary* bin, size_t size):int</h4><p>Change the size of a binary.</p><p>Changes the size of a binary <strong>bin</strong>. The source binary
can be read-only, in which case it is left untouched and
a mutable copy is allocated and assigned to <strong>*bin</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if memory allocation
failed.</p><h4>enif_release_binary(ErlNifBinary* bin):void</h4><p>Release a binary.</p><p>Releases a binary obtained from
<a href="#enif_alloc_binary">enif_alloc_binary</a>.</p><h4>enif_release_resource(void* obj):void</h4><p>Release a resource object.</p><p>Removes a reference to resource object <strong>obj</strong> obtained from
<a href="#enif_alloc_resource">enif_alloc_resource</a>.
The resource object is destructed when the last reference is removed.
Each call to <strong>enif_release_resource</strong> must correspond to a
previous call to <strong>enif_alloc_resource</strong> or
<a href="#enif_keep_resource">enif_keep_resource</a>.
References made by <a href="#enif_make_resource">enif_make_resource</a>
can only be removed by the garbage collector.</p><h4>enif_rwlock_create(char *name):ErlNifRWLock *</h4><p>Same as <a href="./erl_driver#erl_drv_rwlock_create">erl_driver#erl_drv_rwlock_create</a>.</p><h4>enif_rwlock_destroy(ErlNifRWLock *rwlck):void</h4><p>Same as <a href="./erl_driver#erl_drv_rwlock_destroy">erl_driver#erl_drv_rwlock_destroy</a>.</p><h4>enif_rwlock_name(ErlNifRWLock* rwlck):char*</h4><p>Same as <a href="./erl_driver#erl_drv_rwlock_name">erl_driver#erl_drv_rwlock_name</a>.</p><h4>enif_rwlock_rlock(ErlNifRWLock *rwlck):void</h4><p>Same as <a href="./erl_driver#erl_drv_rwlock_rlock">erl_driver#erl_drv_rwlock_rlock</a>.</p><h4>enif_rwlock_runlock(ErlNifRWLock *rwlck):void</h4><p>Same as <a href="./erl_driver#erl_drv_rwlock_runlock">erl_driver#erl_drv_rwlock_runlock</a>.</p><h4>enif_rwlock_rwlock(ErlNifRWLock *rwlck):void</h4><p>Same as <a href="./erl_driver#erl_drv_rwlock_rwlock">erl_driver#erl_drv_rwlock_rwlock</a>.</p><h4>enif_rwlock_rwunlock(ErlNifRWLock *rwlck):void</h4><p>Same as <a href="./erl_driver#erl_drv_rwlock_rwunlock">erl_driver#erl_drv_rwlock_rwunlock</a>.</p><h4>enif_rwlock_tryrlock(ErlNifRWLock *rwlck):int</h4><p>Same as <a href="./erl_driver#erl_drv_rwlock_tryrlock">erl_driver#erl_drv_rwlock_tryrlock</a>.</p><h4>enif_rwlock_tryrwlock(ErlNifRWLock *rwlck):int</h4><p>Same as <a href="./erl_driver#erl_drv_rwlock_tryrwlock">erl_driver#erl_drv_rwlock_tryrwlock</a>.</p><h4>enif_schedule_nif(ErlNifEnv* env,
        const char* fun_name, int flags, ERL_NIF_TERM (*fp)(ErlNifEnv* env, int
        argc, const ERL_NIF_TERM argv[]), int argc, const ERL_NIF_TERM
        argv[]):ERL_NIF_TERM</h4><p>Schedule a NIF for execution.</p><p>Schedules NIF <strong>fp</strong> to execute. This function allows an
application to break up long-running work into multiple regular NIF
calls or to schedule a <a href="#dirty_nifs"> dirty NIF</a> to execute on a dirty scheduler thread.</p><dl><dt><strong>fun_name</strong></dt><dd> <p>Provides a name for the NIF that is scheduled for execution.
If it cannot be converted to an atom, <strong>enif_schedule_nif</strong>
returns a <strong>badarg</strong> exception.</p> </dd><dt><strong>flags</strong></dt><dd> <p>Must be set to <strong>0</strong> for a regular NIF. If the emulator was
built with dirty scheduler support enabled,
<strong>flags</strong> can be set to either
<strong>ERL_NIF_DIRTY_JOB_CPU_BOUND</strong> if the job is expected to be
CPU-bound, or <strong>ERL_NIF_DIRTY_JOB_IO_BOUND</strong> for
jobs that will be I/O-bound. If dirty scheduler threads are not
available in the emulator, an attempt to schedule such a job
results in a <strong>notsup</strong> exception.</p> </dd><dt><strong>argc</strong> and <strong>argv</strong></dt><dd> <p>Can either be the originals passed into the calling NIF,
or can be values created by the calling NIF.</p> </dd></dl><p>The calling NIF must use the return value of
<strong>enif_schedule_nif</strong> as its own return value.</p><p>Be aware that <strong>enif_schedule_nif</strong>, as its name implies, only
schedules the NIF for future execution. The calling NIF does not
block waiting for the scheduled NIF to execute and return. This means
that the calling NIF cannot expect to receive the scheduled NIF
return value and use it for further operations.</p><h4>enif_select(ErlNifEnv* env, ErlNifEvent event, enum ErlNifSelectFlags mode,
	void* obj, const ErlNifPid* pid, ERL_NIF_TERM ref):int</h4><p>Manage subscription on IO event.</p><p>This function can be used to receive asynchronous notifications
when OS-specific event objects become ready for either read or write operations.</p><p>Argument <strong>event</strong> identifies the event object. On Unix
systems, the functions <strong>select</strong>/<strong>poll</strong> are used. The event
object must be a socket, pipe or other file descriptor object that
<strong>select</strong>/<strong>poll</strong> can use.</p><p>Argument <strong>mode</strong> describes the type of events to wait for. It can be
<strong>ERL_NIF_SELECT_READ</strong>, <strong>ERL_NIF_SELECT_WRITE</strong> or a bitwise
OR combination to wait for both. It can also be <strong>ERL_NIF_SELECT_STOP</strong>
or <strong>ERL_NIF_SELECT_CANCEL</strong> which are described further
below. When a read or write event is triggered,
a notification message like this is sent to the process identified by
<strong>pid</strong>:</p><pre><code class="">{select, Obj, Ref, ready_input | ready_output}</code></pre><p><strong>ready_input</strong> or <strong>ready_output</strong> indicates if the event object
is ready for reading or writing.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>For complete control over the message format use the newer functions
<a href="#enif_select_read">enif_select_read</a> or
<a href="#enif_select_write">enif_select_write</a>
introduced in erts-11.0 (OTP-22.0).</p></div><p>Argument <strong>pid</strong> may be <strong>NULL</strong> to indicate the calling
process. It must not be set as <a href="#enif_set_pid_undefined"> undefined</a>.</p><p>Argument <strong>obj</strong> is a resource object obtained from
<a href="#enif_alloc_resource">enif_alloc_resource</a>.
The purpose of the resource objects is as a container of the event object
to manage its state and lifetime. A handle to the resource is received
in the notification message as <strong>Obj</strong>.</p><p>Argument <strong>ref</strong> must be either a reference obtained from
<a href="./erlang#make_ref-0">erlang#make_ref-0</a>
or the atom <strong>undefined</strong>. It will be passed as <strong>Ref</strong> in the notifications.
If a selective <strong>receive</strong> statement is used to wait for the notification
then a reference created just before the <strong>receive</strong> will exploit a runtime
optimization that bypasses all earlier received messages in the
queue.</p><p>The notifications are one-shot only. To receive further notifications of the same
type (read or write), repeated calls to <strong>enif_select</strong> must be made
after receiving each notification.</p><p><strong>ERL_NIF_SELECT_CANCEL</strong> can be used to cancel previously
selected events. It must be used in a bitwise OR combination with
<strong>ERL_NIF_SELECT_READ</strong> and/or <strong>ERL_NIF_SELECT_WRITE</strong> to
indicate which type of event to cancel. Arguments <strong>pid</strong> and
<strong>ref</strong> are ignored when <strong>ERL_NIF_SELECT_CANCEL</strong> is specified.
The return value will tell if the event was actualy cancelled or if a
notification may already have been sent.</p><p>Use <strong>ERL_NIF_SELECT_STOP</strong> as <strong>mode</strong> in order to safely
close an event object that has been passed to <strong>enif_select</strong>. The
<a href="#ErlNifResourceStop">ErlNifResourceStop</a> callback
of the resource <strong>obj</strong> will be called when it is safe to close
the event object. This safe way of closing event objects must be used
even if all notifications have been received (or cancelled) and no
further calls to <strong>enif_select</strong> have been made.
<strong>ERL_NIF_SELECT_STOP</strong> will first cancel any selected events
before it calls or schedules the <strong>stop</strong> callback. Arguments
<strong>pid</strong> and <strong>ref</strong> are ignored when <strong>ERL_NIF_SELECT_STOP</strong>
is specified.</p><p>The first call to <strong>enif_select</strong> for a specific OS <strong>event</strong> will establish
a relation between the event object and the containing resource. All subsequent calls
for an <strong>event</strong> must pass its containing resource as argument
<strong>obj</strong>. The relation is dissolved when <strong>enif_select</strong> has
been called with <strong>mode</strong> as <strong>ERL_NIF_SELECT_STOP</strong> and the
corresponding <strong>stop</strong> callback has returned. A resource can contain
several event objects but one event object can only be contained within
one resource. A resource will not be destructed until all its contained relations
have been dissolved.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Use <a href="#enif_monitor_process">enif_monitor_process</a>
together with <strong>enif_select</strong> to detect failing Erlang
processes and prevent them from causing permanent leakage of resources
and their contained OS event objects.</p></div><p>Returns a non-negative value on success where the following bits can be set:</p><dl><dt><strong>ERL_NIF_SELECT_STOP_CALLED</strong></dt><dd>The stop callback was called directly by <strong>enif_select</strong>.</dd><dt><strong>ERL_NIF_SELECT_STOP_SCHEDULED</strong></dt><dd>The stop callback was scheduled to run on some other thread or later by this thread.</dd><dt><strong>ERL_NIF_SELECT_READ_CANCELLED</strong></dt><dd>A read event was cancelled by <strong>ERL_NIF_SELECT_CANCEL</strong> or <strong>ERL_NIF_SELECT_STOP</strong> and is guaranteed not to generate a <strong>ready_input</strong> notification message.</dd><dt><strong>ERL_NIF_SELECT_WRITE_CANCELLED</strong></dt><dd>A write event was cancelled by <strong>ERL_NIF_SELECT_CANCEL</strong> or <strong>ERL_NIF_SELECT_STOP</strong> and is guaranteed not to generate a <strong>ready_output</strong> notification message.</dd></dl><p>Returns a negative value if the call failed where the following bits can be set:</p><dl><dt><strong>ERL_NIF_SELECT_INVALID_EVENT</strong></dt><dd>Argument <strong>event</strong> is not a valid OS event object.</dd><dt><strong>ERL_NIF_SELECT_FAILED</strong></dt><dd>The system call failed to add the event object to the poll set.</dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Use bitwise AND to test for specific bits in the return value.
New significant bits may be added in future releases to give more detailed
information for both failed and successful calls. Do NOT use equality tests
like <strong>==</strong>, as that may cause your application to stop working.</p><p>Example:</p><pre><code class="">
retval = enif_select(env, fd, ERL_NIF_SELECT_STOP, resource, ref);
if (retval &lt; 0) {
    /* handle error */
}
/* Success! */
if (retval &amp; ERL_NIF_SELECT_STOP_CALLED) {
    /* ... */
}
</code></pre></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The mode flag <strong>ERL_NIF_SELECT_CANCEL</strong> and the return flags
<strong>ERL_NIF_SELECT_READ_CANCELLED</strong> and
<strong>ERL_NIF_SELECT_WRITE_CANCELLED</strong> were introduced in erts-11.0
(OTP-22.0).</p></div><h4>enif_select_read(ErlNifEnv* env, ErlNifEvent event, void* obj,
      const ErlNifPid* pid, ERL_NIF_TERM msg, ErlNifEnv* msg_env):int</h4><h4>enif_select_write(ErlNifEnv* env, ErlNifEvent event, void* obj,
      const ErlNifPid* pid, ERL_NIF_TERM msg, ErlNifEnv* msg_env):int</h4><p>Manage subscription on IO event.</p><p>These are variants of <a href="#enif_select">enif_select</a>
where you can supply your own message term <strong>msg</strong> that will be sent to
the process instead of the predefined tuple <strong>{select,_,_,_}.</strong></p><p>Argument <strong>msg_env</strong> must either be <strong>NULL</strong> or the environment of
<strong>msg</strong> allocated with <a href="#enif_alloc_env">enif_alloc_env</a>. If argument <strong>msg_env</strong> is
<strong>NULL</strong> the term <strong>msg</strong> will be copied, otherwise both
<strong>msg</strong> and <strong>msg_env</strong> will be invalidated by a successful call
to <strong>enif_select_read</strong> or <strong>enif_select_write</strong>. The environment
is then to either be freed with <a href="#enif_free_env">enif_free_env</a> or cleared for reuse with
<a href="#enif_clear_env">enif_clear_env</a>. An
unsuccessful call will leave <strong>msg</strong> and <strong>msg_env</strong> still valid.</p><p>Apart from the message format <strong>enif_select_read</strong> and
<strong>enif_select_write</strong> behaves exactly the same as <a href="#enif_select">enif_select</a> with argument <strong>mode</strong> as
either <strong>ERL_NIF_SELECT_READ</strong> or <strong>ERL_NIF_SELECT_WRITE</strong>. To
cancel or close events use <a href="#enif_select">enif_select</a>.</p><h4>enif_self(ErlNifEnv* caller_env, ErlNifPid* pid):ErlNifPid *</h4><p>Get the pid of the calling process.</p><p>Initializes the <a href="#ErlNifPid">ErlNifPid</a>
variable at <strong>*pid</strong> to represent the calling process.</p><p>Returns <strong>pid</strong> if successful, or NULL if <strong>caller_env</strong> is not
a <a href="#ErlNifEnv">process bound environment</a>.</p><h4>enif_send(ErlNifEnv* caller_env,
      ErlNifPid* to_pid, ErlNifEnv* msg_env, ERL_NIF_TERM msg):int</h4><p>Send a message to a process.</p><p>Sends a message to a process.</p><dl><dt><strong>caller_env</strong></dt><dd>The environment of the calling process or callback. Must be <strong>NULL</strong> only if calling from a custom thread not spawned by ERTS.</dd><dt><strong>*to_pid</strong></dt><dd>The pid of the receiving process. The pid is to refer to a process on the local node.</dd><dt><strong>msg_env</strong></dt><dd>The environment of the message term. Must be a process independent environment allocated with <a href="#enif_alloc_env">enif_alloc_env</a> or NULL.</dd><dt><strong>msg</strong></dt><dd>The message term to send.</dd></dl><p>Returns <strong>true</strong> if the message is successfully sent. Returns
<strong>false</strong> if the send operation fails, that is:</p><ul><li><strong>*to_pid</strong> does not refer to an alive local process.</li><li>The currently executing process (that is, the sender) is not alive.</li></ul><p>The message environment <strong>msg_env</strong> with all its terms (including
<strong>msg</strong>) is invalidated by a successful call to <strong>enif_send</strong>.
The environment is to either be freed with
<a href="#enif_free_env">enif_free_env</a> or cleared for reuse with
<a href="#enif_clear_env">enif_clear_env</a>. An
unsuccessful call will leave <strong>msg</strong> and <strong>msg_env</strong> still valid.</p><p>If <strong>msg_env</strong> is set to <strong>NULL</strong>, the <strong>msg</strong> term is
copied and the original term and its environment is still valid after
the call.</p><p>This function is only thread-safe when the emulator with SMP support
is used. It can only be used in a non-SMP emulator from a NIF-calling
thread.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Passing <strong>msg_env</strong> as <strong>NULL</strong> is only supported as from
ERTS 8.0 (Erlang/OTP 19).</p></div><h4>enif_set_pid_undefined(ErlNifPid* pid):void</h4><p>Set pid as undefined.</p><p>Sets an <a href="#ErlNifPid">ErlNifPid</a>
variable as undefined. See <a href="#enif_is_pid_undefined">enif_is_pid_undefined</a>.</p><h4>enif_sizeof_resource(void* obj):unsigned</h4><p>Get the byte size of a resource object.</p><p>Gets the byte size of resource object <strong>obj</strong> obtained by
<a href="#enif_alloc_resource">enif_alloc_resource</a>.</p><h4>enif_snprintf(char *str, size_t size, const
        char *format, ...):int</h4><p>Format strings and Erlang terms.</p><p>Similar to <strong>snprintf</strong> but this format string also accepts
<strong>"%T"</strong>, which formats Erlang terms of type
<a href="#ERL_NIF_TERM">ERL_NIF_TERM</a>.</p><p>This function is primarily intended for debugging purpose. It is not
recommended to print very large terms with <strong>%T</strong>. The function may
change <strong>errno</strong>, even if successful.</p><h4>enif_system_info(ErlNifSysInfo
        *sys_info_ptr, size_t size):void</h4><p>Get information about the Erlang runtime system.</p><p>Same as <a href="./erl_driver#driver_system_info">erl_driver#driver_system_info</a>.</p><h4>enif_term_to_binary(ErlNifEnv *env,
        ERL_NIF_TERM term, ErlNifBinary *bin):int</h4><p>Convert a term to the external format.</p><p>Allocates a new binary with <a href="#enif_alloc_binary">enif_alloc_binary</a> and stores the result of encoding
<strong>term</strong> according to the Erlang external term format.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if the allocation
fails.</p><p>See also <a href="./erlang#term_to_binary-1">erlang#term_to_binary-1</a> and
<a href="#enif_binary_to_term">enif_binary_to_term</a>.</p><h4>enif_term_type(ErlNifEnv *env, ERL_NIF_TERM term):ErlNifTermType</h4><p>Determine the type of a term.</p><p>Determines the type of the given term. The term must be an ordinary
Erlang term and not one of the special terms returned by
<a href="#enif_raise_exception">enif_raise_exception</a>,
<a href="#enif_schedule_nif">enif_schedule_nif</a>, or similar.</p><p>The following types are defined at the moment:</p><dl><dt><strong>ERL_NIF_TERM_TYPE_ATOM</strong></dt><dd></dd><dt><strong>ERL_NIF_TERM_TYPE_BITSTRING</strong></dt><dd><p>A bitstring or binary</p></dd><dt><strong>ERL_NIF_TERM_TYPE_FLOAT</strong></dt><dd></dd><dt><strong>ERL_NIF_TERM_TYPE_FUN</strong></dt><dd></dd><dt><strong>ERL_NIF_TERM_TYPE_INTEGER</strong></dt><dd></dd><dt><strong>ERL_NIF_TERM_TYPE_LIST</strong></dt><dd><p>A list, empty or not</p></dd><dt><strong>ERL_NIF_TERM_TYPE_MAP</strong></dt><dd></dd><dt><strong>ERL_NIF_TERM_TYPE_PID</strong></dt><dd></dd><dt><strong>ERL_NIF_TERM_TYPE_PORT</strong></dt><dd></dd><dt><strong>ERL_NIF_TERM_TYPE_REFERENCE</strong></dt><dd></dd><dt><strong>ERL_NIF_TERM_TYPE_TUPLE</strong></dt><dd></dd></dl><p>Note that new types may be added in the future, so the caller must
be prepared to handle unknown types.</p><h4>enif_thread_create(char *name,ErlNifTid
        *tid,void * (*func)(void *),void *args,ErlNifThreadOpts
        *opts):int</h4><p>Same as <a href="./erl_driver#erl_drv_thread_create">erl_driver#erl_drv_thread_create</a>.</p><h4>enif_thread_exit(void *resp):void</h4><p>Same as <a href="./erl_driver#erl_drv_thread_exit">erl_driver#erl_drv_thread_exit</a>.</p><h4>enif_thread_join(ErlNifTid, void **respp):int</h4><p>Same as <a href="./erl_driver#erl_drv_thread_join">erl_driver#erl_drv_thread_join</a>.</p><h4>enif_thread_name(ErlNifTid tid):char*</h4><p>Thread name</p><p>Same as <a href="./erl_driver#erl_drv_thread_name">erl_driver#erl_drv_thread_name</a>.</p><h4>enif_thread_opts_create(char *name):ErlNifThreadOpts *</h4><p>Same as <a href="./erl_driver#erl_drv_thread_opts_create">erl_driver#erl_drv_thread_opts_create</a>.</p><h4>enif_thread_opts_destroy(ErlNifThreadOpts *opts):void</h4><p>Same as <a href="./erl_driver#erl_drv_thread_opts_destroy">erl_driver#erl_drv_thread_opts_destroy</a>.</p><h4>enif_thread_self(void):ErlNifTid</h4><p>Same as <a href="./erl_driver#erl_drv_thread_self">erl_driver#erl_drv_thread_self</a>.</p><h4>enif_thread_type(void):int</h4><p>Determine type of current thread</p><p>Determine the type of currently executing thread. A positive value
indicates a scheduler thread while a negative value or zero indicates
another type of thread. Currently the following specific types exist
(which may be extended in the future):</p><dl><dt><strong>ERL_NIF_THR_UNDEFINED</strong></dt><dd><p>Undefined thread that is not a scheduler thread.</p></dd><dt><strong>ERL_NIF_THR_NORMAL_SCHEDULER</strong></dt><dd><p>A normal scheduler thread.</p></dd><dt><strong>ERL_NIF_THR_DIRTY_CPU_SCHEDULER</strong></dt><dd><p>A dirty CPU scheduler thread.</p></dd><dt><strong>ERL_NIF_THR_DIRTY_IO_SCHEDULER</strong></dt><dd><p>A dirty I/O scheduler thread.</p></dd></dl><h4>enif_time_offset(ErlNifTimeUnit time_unit):ErlNifTime</h4><p>Get current time offset.</p><a name="enif_time_offset"></a><p>Returns the current time offset between
<a href="./time_correction#Erlang_Monotonic_Time"> Erlang monotonic time</a> and
<a href="./time_correction#Erlang_System_Time"> Erlang system time</a>
converted into the <strong>time_unit</strong> passed as argument.</p><p><strong>time_unit</strong> is the time unit of the returned value.</p><p>Returns <strong>ERL_NIF_TIME_ERROR</strong> if called with an invalid
time unit argument or if called from a thread that is not a
scheduler thread.</p><p>See also <a href="#ErlNifTime">ErlNifTime</a>
and
<a href="#ErlNifTimeUnit">ErlNifTimeUnit</a>.</p><h4>enif_tsd_get(ErlNifTSDKey key):void *</h4><p>Same as <a href="./erl_driver#erl_drv_tsd_get">erl_driver#erl_drv_tsd_get</a>.</p><h4>enif_tsd_key_create(char *name, ErlNifTSDKey *key):int</h4><p>Same as <a href="./erl_driver#erl_drv_tsd_key_create">erl_driver#erl_drv_tsd_key_create</a>.</p><h4>enif_tsd_key_destroy(ErlNifTSDKey key):void</h4><p>Same as <a href="./erl_driver#erl_drv_tsd_key_destroy">erl_driver#erl_drv_tsd_key_destroy</a>.</p><h4>enif_tsd_set(ErlNifTSDKey key, void *data):void</h4><p>Same as <a href="./erl_driver#erl_drv_tsd_set">erl_driver#erl_drv_tsd_set</a>.</p><h4>enif_vfprintf(FILE *stream, const char *format, va_list ap)
:int</h4><p>Format strings and Erlang terms.</p><p>Equivalent to <a href="#enif_fprintf">enif_fprintf</a>
except that its called with a <strong>va_list</strong> instead of a variable number of
arguments.</p><h4>enif_vsnprintf(char *str, size_t size, const char *format, va_list ap)
:int</h4><p>Format strings and Erlang terms.</p><p>Equivalent to <a href="#enif_snprintf">enif_snprintf</a>
except that its called with a <strong>va_list</strong> instead of a variable number of
arguments.</p><h4>enif_whereis_pid(ErlNifEnv *env,
          ERL_NIF_TERM name, ErlNifPid *pid):int</h4><p>Looks up a process by its registered name.</p><p>Looks up a process by its registered name.</p><dl><dt><strong>env</strong></dt><dd>The environment of the calling process. Must be <strong>NULL</strong> only if calling from a created thread.</dd><dt><strong>name</strong></dt><dd>The name of a registered process, as an atom.</dd><dt><strong>*pid</strong></dt><dd>The <a href="#ErlNifPid">ErlNifPid</a> in which the resolved process id is stored.</dd></dl><p>On success, sets <strong>*pid</strong> to the local process registered with
<strong>name</strong> and returns <strong>true</strong>. If <strong>name</strong> is not a
registered process, or is not an atom, <strong>false</strong> is returned and
<strong>*pid</strong> is unchanged.</p><p>Works as <a href="./erlang#whereis-1">erlang#whereis-1</a>, but restricted to processes. See
<a href="#enif_whereis_port">enif_whereis_port</a>
to resolve registered ports.</p><h4>enif_whereis_port(ErlNifEnv *env,
          ERL_NIF_TERM name, ErlNifPort *port):int</h4><p>Looks up a port by its registered name.</p><p>Looks up a port by its registered name.</p><dl><dt><strong>env</strong></dt><dd>The environment of the calling process. Must be <strong>NULL</strong> only if calling from a created thread.</dd><dt><strong>name</strong></dt><dd>The name of a registered port, as an atom.</dd><dt><strong>*port</strong></dt><dd>The <a href="#ErlNifPort">ErlNifPort</a> in which the resolved port id is stored.</dd></dl><p>On success, sets <strong>*port</strong> to the port registered with
<strong>name</strong> and returns <strong>true</strong>. If <strong>name</strong> is not a
registered port, or is not an atom, <strong>false</strong> is returned and
<strong>*port</strong> is unchanged.</p><p>Works as <a href="./erlang#whereis-1">erlang#whereis-1</a>, but restricted to ports. See
<a href="#enif_whereis_pid">enif_whereis_pid</a>
to resolve registered processes.</p><h4>See Also</h4><p><a href="./erlang#load_nif-2">erlang#load_nif-2</a></p><h3>erl_prim_loader</h3><p>Low-level Erlang loader.</p><p>This module is used to load all Erlang modules into
the system. The start script is also fetched with this low-level
loader.<strong>erl_prim_loader</strong> knows about the environment and how to
fetch modules.Command-line flag <strong>-loader Loader</strong> can be used to
choose the method used by <strong>erl_prim_loader</strong>. Two
<strong>Loader</strong> methods are supported by the Erlang runtime system:
<strong>efile</strong> and <strong>inet</strong>.</p><h3>Functions</h3><h4>get_file/1</h4><p>Get a file.</p><p>Fetches a file using the low-level loader.
<strong><span class="anno">Filename</span></strong> is either an absolute filename or only
the name of the file, for example, <strong>"lists.beam"</strong>. If an internal
path is set to the loader, this path is used to find the file.
<strong><span class="anno">FullName</span></strong> is the complete name of the fetched file.
<strong><span class="anno">Bin</span></strong> is the contents of the file as a binary.</p><p><strong><span class="anno">Filename</span></strong> can also be a file in an archive,
for example,
<strong>$OTPROOT/lib/</strong><strong>mnesia-4.4.7.ez/mnesia-4.4.7/ebin/</strong><strong>mnesia.beam</strong>.
For information about archive files, see
<a href="./code">kernel/code</a>.</p><h4>get_path/0</h4><p>Get the path set in the loader.</p><p>Gets the path set in the loader. The path is
set by the <a href="init">init</a>
process according to information found in the start script.</p><h4>list_dir/1</h4><p>List files in a directory.</p><p>Lists all the files in a directory. Returns
<strong>{ok, <span class="anno">Filenames</span>}</strong> if successful, otherwise
<strong>error</strong>. <strong><span class="anno">Filenames</span></strong> is a list of
the names of all the files in the directory. The names are
not sorted.</p><p><strong><span class="anno">Dir</span></strong> can also be a directory in an archive,
for example,
<strong>$OTPROOT/lib/</strong><strong>mnesia-4.4.7.ez/mnesia-4.4.7/ebin</strong>.
For information about archive files, see
<a href="./code">kernel/code</a>.</p><h4>read_file_info/1</h4><p>Get information about a file.</p><p>Retrieves information about a file. Returns
<strong>{ok, <span class="anno">FileInfo</span>}</strong> if successful, otherwise
<strong>error</strong>. <strong><span class="anno">FileInfo</span></strong> is a record
<strong>file_info</strong>, defined in the Kernel include file
<strong>file.hrl</strong>. Include the following directive in the module
from which the function is called:</p><pre><code class="">
-include_lib("kernel/include/file.hrl").</code></pre><p>For more information about the record <strong>file_info</strong>, see
<a href="./file">kernel/file</a>.</p><p><strong><span class="anno">Filename</span></strong> can also be a file in an archive,
for example,
<strong>$OTPROOT/lib/</strong><strong>mnesia-4.4.7.ez/mnesia-4.4.7/ebin/</strong><strong>mnesia</strong>.
For information about archive files, see
<a href="./code">kernel/code</a>.</p><h4>read_link_info/1</h4><p>Get information about a link or file.</p><p>Works like
<a href="#read_file_info/1">read_file_info/1</a>
except that if <strong><span class="anno">Filename</span></strong> is a symbolic link,
information about the link is returned in the <strong>file_info</strong>
record and the <strong>type</strong> field of the record is set to
<strong>symlink</strong>.</p><p>If <strong><span class="anno">Filename</span></strong> is not a symbolic link, this function
returns exactly the same result as <strong>read_file_info/1</strong>.
On platforms that do not support symbolic links, this function
is always equivalent to <strong>read_file_info/1</strong>.</p><h4>set_path/1</h4><p>Set the path of the loader.</p><p>Sets the path of the loader if
<a href="init">init</a>
interprets a <strong>path</strong> command in the start script.</p><h4>Command-Line Flags</h4><p>The <strong>erl_prim_loader</strong> module interprets the following
command-line flags:</p><dl><dt><strong>-loader Loader</strong></dt><dd> <p>Specifies the name of the loader used by
<strong>erl_prim_loader</strong>. <strong>Loader</strong> can be <strong>efile</strong>
(use the local file system) or <strong>inet</strong> (load using
the <strong>boot_server</strong> on another Erlang node).</p> <p>If flag <strong>-loader</strong> is omitted, it defaults to
<strong>efile</strong>.</p> </dd><dt><strong>-loader_debug</strong></dt><dd> <p>Makes the <strong>efile</strong> loader write some debug information,
such as the reason for failures, while it handles files.</p> </dd><dt><strong>-hosts Hosts</strong></dt><dd> <p>Specifies which other Erlang nodes the <strong>inet</strong> loader
can use. This flag is mandatory if flag <strong>-loader inet</strong>
is present. On each host, there must be on Erlang node
with the <a href="./erl_boot_server">kernel/erl_boot_server</a>,
which handles the load requests.
<strong>Hosts</strong> is a list of IP addresses (hostnames
are not acceptable).</p> </dd><dt><strong>-setcookie Cookie</strong></dt><dd> <p>Specifies the cookie of the Erlang runtime system. This flag
is mandatory if flag <strong>-loader inet</strong> is present.</p> </dd></dl><h4>See Also</h4><p><a href="init">init</a>,
<a href="./erl_boot_server">kernel/erl_boot_server</a></p><h3>erlsrv</h3><p>Run the Erlang emulator as a service on Windows</p><p>This utility is specific to Windows NT/2000/XP (and later
versions of Windows). It allows Erlang
emulators to run as services on the Windows system, allowing embedded
systems to start without any user needing to log on. The
emulator started in this way can be manipulated through the
Windows services applet in a manner similar to other services.Notice that <strong>erlsrv</strong> is not a general service utility for Windows,
but designed for embedded Erlang systems.<strong>erlsrv</strong> also provides a command-line interface for registering,
changing, starting, and stopping services.To manipulate services, the logged on user is to have
administrator privileges on the machine. The Erlang machine
itself is (default) run as the local administrator. This can be
changed with the Services applet in Windows.The processes created by the service can, as opposed to normal
services, be "killed" with the task manager. Killing an emulator
that is started by a service triggers the "OnFail" action
specified for that service, which can be a reboot.The following parameters can be specified for each Erlang service:<dl><dt><strong>StopAction</strong></dt><dd> <p>Tells <strong>erlsrv</strong> how to stop
the Erlang emulator. Default is to kill it (Win32
TerminateProcess), but this action can specify any Erlang
shell command that will be executed in the emulator to make
it stop. The emulator is expected to stop within 30 seconds
after the command is issued in the shell. If the emulator is
not stopped, it reports a running state to the service
manager.</p> </dd><dt><strong>OnFail</strong></dt><dd> <p>Can be one of the following:</p> <dl><dt><strong>reboot</strong></dt><dd> <p>The Windows system is rebooted whenever the emulator stops
(a more simple form of watchdog). This can be useful for
less critical systems, otherwise use the heart functionality
to accomplish this.</p> </dd><dt><strong>restart</strong></dt><dd> <p>Makes the Erlang emulator be
restarted (with whatever parameters are registered for the
service at the occasion) when it stops. If the emulator
stops again within 10 seconds, it is not restarted to avoid
an infinite loop, which could hang the Windows system.</p> </dd><dt><strong>restart_always</strong></dt><dd> <p>Similar to <strong>restart</strong>, but does
not try to detect cyclic restarts; it is expected that
some other mechanism is present to avoid the problem.</p> </dd><dt><strong>ignore</strong> (the default)</dt><dd> <p>Reports the service as stopped to the service manager
whenever it fails; it must be manually restarted.</p> </dd></dl> <p>On a system where release handling is used,
this is always to be set to <strong>ignore</strong>. Use
<strong>heart</strong> to restart the service on failure
instead.</p> </dd><dt><strong>Machine</strong></dt><dd> <p>The location of the Erlang emulator.
The default is the <strong>erl.exe</strong> located in the same
directory as <strong>erlsrv.exe</strong>. Do not specify
<strong>werl.exe</strong> as this emulator, it will not work.</p> <p>If the system uses release handling, this is to be set to a
program similar to <strong>start_erl.exe</strong>.</p> </dd><dt><strong>Env</strong></dt><dd> <p>Specifies an <em>extra</em> environment
for the emulator. The environment variables specified
here are added to the system-wide environment block that is
normally present when a service starts up. Variables present
in both the system-wide environment and in the service
environment specification will be set to the value specified
in the service.</p> </dd><dt><strong>WorkDir</strong></dt><dd> <p>The working directory for the Erlang emulator.
Must be on a local drive (no network drives are mounted when a
service starts). Default working directory for services is
<strong>%SystemDrive%%SystemPath%</strong>.
Debug log files will be placed in this directory.</p> </dd><dt><strong>Priority</strong></dt><dd> <p>The process priority of the emulator. Can be one of the
following:</p> <dl><dt><strong>realtime</strong></dt><dd> <p>Not recommended, as the machine will possibly be
inaccessible to interactive users.</p> </dd><dt><strong>high</strong></dt><dd> <p>Can be used if two Erlang nodes are to reside on one dedicated
system and one is to have precedence over the other.</p> </dd><dt><strong>low</strong></dt><dd> <p>Can be used if interactive performance is not to be affected
by the emulator process.</p> </dd><dt><strong>default</strong> (the default&gt;</dt><dd> </dd></dl> </dd><dt><strong>SName or Name</strong></dt><dd> <p>Specifies the short or long
node name of the Erlang emulator. The Erlang services are
always distributed. Default is to use the service name as
(short) nodename.</p> </dd><dt><strong>DebugType</strong></dt><dd> <p>Specifies that output from the Erlang shell is to be
sent to a "debug log". The log file is named
&lt;servicename&gt;<strong>.debug</strong> or
&lt;servicename&gt;<strong>.debug.</strong>&lt;N&gt;,
where &lt;N&gt; is an integer from 1 through 99.
The log file is placed in the working directory of the
service (as specified in <strong>WorkDir</strong>).</p> <p>Can be one of the following:</p> <dl><dt><strong>new</strong></dt><dd> <p>Uses a separate log file for every invocation of the service
(&lt;servicename&gt;<strong>.debug.</strong>&lt;N&gt;).</p> </dd><dt><strong>reuse</strong></dt><dd> <p>Reuses the same log file
(&lt;servicename&gt;<strong>.debug</strong>).</p> </dd><dt><strong>console</strong></dt><dd> <p>Opens an interactive Windows console window for the Erlang
shell of the service. Automatically disables the
<strong>StopAction</strong>. A service started with an
interactive console window does not survive logouts.
<strong>OnFail</strong> actions do not work with
debug consoles either.</p> </dd><dt><strong>none</strong> (the default)</dt><dd> <p>The output of the Erlang shell is discarded.</p> </dd></dl> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The <strong>console</strong> option is <em>not</em> intended
for production. It is <em>only</em> a convenient way to debug
Erlang services during development.</p><p>The <strong>new</strong> and <strong>reuse</strong> options
might seem convenient in a production system, but consider that
the logs grow indefinitely during the system lifetime and cannot
be truncated, except if the service is restarted.</p><p>In short, the <strong>DebugType</strong> is
intended for debugging only. Logs during production are
better produced with the standard Erlang logging facilities.</p></div> </dd><dt><strong>Args</strong></dt><dd> <p>Passes extra arguments to the emulator startup program
<strong>erl.exe</strong> (or <strong>start_erl.exe</strong>).
Arguments that cannot be specified here are
<strong>-noinput</strong> (<strong>StopActions</strong> would not work),
<strong>-name</strong>, and <strong>-sname</strong> (they are
specified in any way). The most common use is for specifying cookies
and flags to be passed to <strong>init:boot()</strong>
(<strong>-s</strong>).</p> </dd><dt><strong>InternalServiceName</strong></dt><dd> <p>Specifies the Windows-internal service name (not the display name,
which is the one <strong>erlsrv</strong> uses to identify the service).</p> <p>This internal name cannot be changed, it is fixed even if the
service is renamed. <strong>erlsrv</strong> generates a unique internal name
when a service is created. It is recommended to keep to the default
if release handling is to be used for the application.</p> <p>The internal service name can be seen in the Windows service
manager if viewing <strong>Properties</strong> for an Erlang service.</p> </dd><dt><strong>Comment</strong></dt><dd> <p>A textual comment describing the service. Not mandatory, but shows
up as the service description in the Windows service manager.</p> </dd></dl><a name="001"></a>
The naming of the service in a system that
uses release handling must follow the convention
<em>NodeName</em>_<em>Release</em>, where <em>NodeName</em> is
the first part of the Erlang node name (up to, but not including
the "@") and <em>Release</em> is the current release of the
application.</p><h3>Functions</h3><h4>erlsrv {set | add} &lt;service-name&gt; [&lt;service options&gt;]</h4><p>Add or modify an Erlang service.</p><p>The <strong>set</strong> and <strong>add</strong> commands modifies or adds an Erlang
service, respectively. The simplest form of an <strong>add</strong> command is
without any options in which case all default values
(described above) apply. The service name is mandatory.</p><p>Every option can be specified without parameters, the
default value is then applied. Values to the options are
supplied <em>only</em> when the default is not to be used.
For example, <strong>erlsrv set myservice -prio -arg</strong>
sets the default priority and removes all arguments.</p><p>Service options:</p><dl><dt><strong>-st[opaction] [&lt;erlang shell command&gt;]</strong></dt><dd> <p>Defines the <strong>StopAction</strong>, the command given
to the Erlang shell when the service is stopped.
Default is none.</p> </dd><dt><strong>-on[fail] [{reboot | restart | restart_always}]</strong></dt><dd> <p>The action to take when the Erlang emulator
stops unexpectedly. Default is to ignore.</p> </dd><dt><strong>-m[achine] [&lt;erl-command&gt;]</strong></dt><dd> <p>The complete path to the Erlang emulator. Never use the
<strong>werl</strong> program for this. Defaults to the
<strong>erl.exe</strong> in the same directory as
<strong>erlsrv.exe</strong>. When release handling
is used, this is to be set to a program similar to
<strong>start_erl.exe</strong>.</p> </dd><dt><strong>-e[nv] [&lt;variable&gt;[=&lt;value&gt;]] ...</strong></dt><dd> <p>Edits the environment block for the service. Every
environment variable specified is added to the system
environment block. If a variable specified here has the same
name as a system-wide environment variable, the specified
value overrides the system-wide. Environment variables are
added to this list by specifying
&lt;variable&gt;=&lt;value&gt; and deleted from the list by
specifying &lt;variable&gt; alone. The environment block is
automatically sorted. Any number of <strong>-env</strong>
options can be specified in one command. Default is to use the
system environment block unmodified (except for two additions,
see section <a href="#002">Environment</a>
below).</p> </dd><dt><strong>-w[orkdir] [&lt;directory&gt;]</strong></dt><dd> <p>The initial working directory of the Erlang
emulator. Defaults to the system directory.</p> </dd><dt><strong>-p[riority] [{low|high|realtime}]</strong></dt><dd> <p>The priority of the Erlang emulator. Default to the
Windows default priority.</p> </dd><dt><strong>{-sn[ame] | -n[ame]} [&lt;node-name&gt;]</strong></dt><dd> <p>The node name of the Erlang machine. Distribution is mandatory.
Defaults to <strong>-sname &lt;service name&gt;</strong>.</p> </dd><dt><strong>-d[ebugtype] [{new|reuse|console}]</strong></dt><dd> <p>Specifies where shell output is to be sent.
Default is that shell output is discarded.
To be used only for debugging.</p> </dd><dt><strong>-ar[gs] [&lt;limited erl arguments&gt;]</strong></dt><dd> <p>Extra arguments to the Erlang emulator. Avoid
<strong>-noinput</strong>, <strong>-noshell</strong>, and
<strong>-sname</strong>/<strong>-name</strong>. Default is
no extra arguments. Remember that the services cookie file is not
necessarily the same as the interactive users. The service
runs as the local administrator. Specify all arguments
together in one string, use double quotes (") to specify an
argument string containing spaces, and use quoted quotes (\")
to specify a quote within the argument string if necessary.</p> </dd><dt><strong>-i[nternalservicename] [&lt;internal name&gt;]</strong></dt><dd> <p><em>Only</em> allowed for <strong>add</strong>. Specifies a
Windows-internal service name for the service, which by
default is set to something unique (prefixed with the
original service name) by <strong>erlsrv</strong> when adding a new
service. Specifying this is a purely cosmethic action and is
<em>not</em> recommended if release handling is to be
performed. The internal service name cannot be changed once
the service is created. The internal name is <em>not</em> to
be confused with the ordinary service name, which is the name
used to identify a service to <strong>erlsrv</strong>.</p> </dd><dt><strong>-c[omment] [&lt;short description&gt;]</strong></dt><dd> <p>Specifies a textual comment describing the
service. This comment shows up as the service description
in the Windows service manager.</p> </dd></dl><h4>erlsrv {start | start_disabled | stop | disable |
        enable} &lt;service-name&gt;</h4><p>Manipulate the current service status.</p><p>These commands are only added for convenience, the normal
way to manipulate the state of a service is through the
control panels services applet.</p><p>The <strong>start</strong> and
<strong>stop</strong> commands communicates
with the service manager for starting and stopping a
service. The commands wait until the service is
started or stopped. When disabling a service, it is not
stopped, the disabled state does not take effect until the
service is stopped. Enabling a service sets it in
automatic mode, which is started at boot. This command cannot
set the service to manual.</p><p>The <strong>start_disabled</strong> command operates on a service
regardless of if it is enabled/disabled or started/stopped. It
does this by first enabling it (regardless of if it is enabled
or not), then starting it (if not already started), and
then disabling it. The result is a disabled but started
service, regardless of its earlier state. This is useful for
starting services temporarily during a release upgrade. The
difference between using <strong>start_disabled</strong> and the
sequence <strong>enable</strong>, <strong>start</strong>, and <strong>disable</strong> is
that all other <strong>erlsrv</strong> commands are locked out during
the sequence of operations in <strong>start_disable</strong>, making the
operation atomic from an <strong>erlsrv</strong> user's point of view.</p><h4>erlsrv remove &lt;service-name&gt;</h4><p>Remove the service.</p><p>Removes the service completely with all its registered
options. It is stopped before it is removed.</p><h4>erlsrv list [&lt;service-name&gt;]</h4><p>List all Erlang services or all options for one service. </p><p>If no service name is specified, a brief listing of all Erlang
services is presented. If a service name is supplied, all options
for that service are presented.</p><h4>erlsrv help</h4><p>Display a brief help text.</p><p>Displays a brief help text.</p><h4>Environment</h4><p><a name="002"></a>
The environment of an Erlang machine started
as a service contains two special variables:</p><dl><dt><strong>ERLSRV_SERVICE_NAME</strong></dt><dd>The name of the service that started the machine.</dd><dt><strong>ERLSRV_EXECUTABLE</strong></dt><dd>The full path to the <strong>erlsrv.exe</strong>, which can be used to manipulate the service. This comes in handy when defining a heart command for your service.</dd></dl><p>A command file for restarting a service looks as follows:</p><pre><code class="">
@echo off
%ERLSRV_EXECUTABLE% stop %ERLSRV_SERVICE_NAME%
%ERLSRV_EXECUTABLE% start %ERLSRV_SERVICE_NAME%    </code></pre><p>This command file is then set as heart command.</p><p>The environment variables can also be used to detect that we
are running as a service and make port programs react correctly
to the control events generated on logout (see the next section).</p><h4>Port Programs</h4><p>When a program runs in
the service context, it must handle the control events that are
sent to every program in the system when the interactive user
logs off. This is done in different ways for programs running in
the console subsystem and programs running as window
applications. An application running in the console subsystem
(normal for port programs) uses the win32 function
<strong>SetConsoleCtrlHandler</strong> to register a control handler
that returns <strong>true</strong> in answer to the
<strong>CTRL_LOGOFF_EVENT</strong>
and <strong>CTRL_SHUTDOWN_EVENT</strong> events. Other applications
only forward <strong>WM_ENDSESSION</strong> and
<strong>WM_QUERYENDSESSION</strong> to the default window procedure.</p><p>A brief example in C of how to set the console control handler:</p><pre><code class="">
#include &lt;windows.h&gt;
/* 
** A Console control handler that ignores the log off events,
** and lets the default handler take care of other events.
*/   
BOOL WINAPI service_aware_handler(DWORD ctrl){
    if(ctrl == CTRL_LOGOFF_EVENT)
        return TRUE;
    if(ctrl == CTRL_SHUTDOWN_EVENT)
        return TRUE;
    return FALSE;
}

void initialize_handler(void){
    char buffer[2];
    /* 
     * We assume we are running as a service if this  
     * environment variable is defined.
     */
    if(GetEnvironmentVariable("ERLSRV_SERVICE_NAME",buffer,
                              (DWORD) 2)){
        /*
        ** Actually set the control handler
        */
        SetConsoleCtrlHandler(&amp;service_aware_handler, TRUE);
    }
}    </code></pre><h4>Notes</h4><p>Although the options are described in a Unix-like format, the case of
the options or commands is not relevant, and both character "/" and "-"
can be used for options.</p><p>Notice that the program resides in the emulator's <strong>bin</strong>
directory, not in the <strong>bin</strong> directory directly under
the Erlang root. The reasons for this are the subtle problem of
upgrading the emulator on a running system, where a new version of
the runtime system should not need to overwrite existing (and probably
used) executables.</p><p>To manipulate the Erlang services easily, put
the <strong>&lt;erlang_root&gt;\erts-&lt;version&gt;\bin</strong> directory in
the path instead of <strong>&lt;erlang_root&gt;\bin</strong>. The
<strong>erlsrv</strong> program can be found from inside Erlang by using the
<strong>os:find_executable/1</strong> Erlang function.</p><p>For release handling to work, use <strong>start_erl</strong> as the
Erlang machine. As stated <a href="#001">above</a>,
the service name is significant.</p><h4>See Also</h4><p><a href="start_erl">start_erl</a>,
<a href="./release_handler">sasl/release_handler</a></p><h3>erl_tracer</h3><p>Erlang tracer behavior.</p><p>This behavior module implements the back end of the Erlang
tracing system. The functions in this module are called whenever
a trace probe is triggered. Both the <strong>enabled</strong> and <strong>trace</strong>
functions are called in the context of the entity that triggered the
trace probe.
This means that the overhead by having the tracing enabled is
greatly effected by how much time is spent in these functions. So, do as
little work as possible in these functions.</p><h3>Data Types</h3><span class="name">trace_tag_call</span><span class="name">trace_tag_gc</span><span class="name">trace_tag_ports</span><span class="name">trace_tag_procs</span><span class="name">trace_tag_receive</span><span class="name">trace_tag_running_ports</span><span class="name">trace_tag_running_procs</span><span class="name">trace_tag_send</span><span class="name">trace_tag</span><p>The different trace tags that the tracer is called with.
Each trace tag is described in detail in
<a href="#Module:trace/5">Module:trace/5</a>.</p><span class="name">tracee</span><p>The process or port that the trace belongs to.</p><span class="name">trace_opts</span><p>The options for the tracee:</p><dl><dt><strong>timestamp</strong></dt><dd>If set the tracer has been requested to include a time stamp.</dd><dt><strong>extra</strong></dt><dd>If set the tracepoint has included additional data about the trace event. What the additional data is depends on which <strong>TraceTag</strong> has been triggered. The <strong>extra</strong> trace data corresponds to the fifth element in the trace tuples described in <a href="./erlang#trace_3_trace_messages"> erlang:trace/3</a>.</dd><dt><strong>match_spec_result</strong></dt><dd>If set the tracer has been requested to include the output of a match specification that was run.</dd><dt><strong>scheduler_id</strong></dt><dd>If set the scheduler id is to be included by the tracer.</dd></dl><span class="name">tracer_state</span><p>The state specified when calling
<a href="./erlang#trace-3">erlang#trace-3</a>.
The tracer state is an immutable value that is passed to
<strong>erl_tracer</strong> callbacks and is to
contain all the data that is needed to generate the trace event.</p><h4>Callback Functions</h4><p>The following functions are to be exported from an <strong>erl_tracer</strong>
callback module:</p><dl><dt><a href="#Module:enabled/3">Module:enabled/3</a></dt><dd>Mandatory</dd><dt><a href="#Module:trace/5">Module:trace/5</a></dt><dd>Mandatory</dd><dt><a href="#Module:enabled_call/3">Module:enabled_call/3</a></dt><dd>Optional</dd><dt><a href="#Module:trace_call/5">Module:trace_call/5</a></dt><dd>Optional</dd><dt><a href="#Module:enabled_garbage_collection/3">Module:enabled_garbage_collection/3</a></dt><dd>Optional</dd><dt><a href="#Module:trace_garbage_collection/5">Module:trace_garbage_collection/5</a></dt><dd>Optional</dd><dt><a href="#Module:enabled_ports/3">Module:enabled_ports/3</a></dt><dd>Optional</dd><dt><a href="#Module:trace_ports/5">Module:trace_ports/5</a></dt><dd>Optional</dd><dt><a href="#Module:enabled_procs/3">Module:enabled_procs/3</a></dt><dd>Optional</dd><dt><a href="#Module:trace_procs/5">Module:trace_procs/5</a></dt><dd>Optional</dd><dt><a href="#Module:enabled_receive/3">Module:enabled_receive/3</a></dt><dd>Optional</dd><dt><a href="#Module:trace_receive/5">Module:trace_receive/5</a></dt><dd>Optional</dd><dt><a href="#Module:enabled_running_ports/3">Module:enabled_running_ports/3</a></dt><dd>Optional</dd><dt><a href="#Module:trace_running_ports/5">Module:trace_running_ports/5</a></dt><dd>Optional</dd><dt><a href="#Module:enabled_running_procs/3">Module:enabled_running_procs/3</a></dt><dd>Optional</dd><dt><a href="#Module:trace_running_procs/5">Module:trace_running_procs/5</a></dt><dd>Optional</dd><dt><a href="#Module:enabled_send/3">Module:enabled_send/3</a></dt><dd>Optional</dd><dt><a href="#Module:trace_send/5">Module:trace_send/5</a></dt><dd>Optional</dd></dl><h3>Functions</h3><h4>Module:enabled(TraceTag, TracerState, Tracee) -&gt; Result</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag =  | trace_status</span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint is triggered. It
allows the tracer to decide whether a trace is to be generated or not.
This check is made as early as possible to limit the amount of
overhead associated with tracing. If <strong>trace</strong> is returned, the
necessary trace data is created and the trace callback of the tracer
is called. If <strong>discard</strong> is returned, this trace call is
discarded and no call to trace is done.</p><p><strong>trace_status</strong> is a special type of <strong>TraceTag</strong>, which is
used to check if the tracer is still to be active. It is called in
multiple scenarios, but most significantly it is used when tracing
is started using this tracer. If <strong>remove</strong> is returned when the
<strong>trace_status</strong> is checked, the tracer is removed from the
tracee.</p><p>This function can be called multiple times per tracepoint, so it
is important that it is both fast and without side effects.</p><h4>Module:enabled_call(TraceTag, TracerState, Tracee) -&gt; Result</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint with trace flag
<a href="./erlang#trace-3">erlang#trace-3</a>
is triggered.</p><p>If <strong>enabled_call/3</strong> is undefined,
<a href="#Module:enabled/3">Module:enabled/3</a>
is called instead.</p><h4>Module:enabled_garbage_collection(TraceTag, TracerState, Tracee) -&gt; Result</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint with trace flag
<a href="./erlang#trace-3">erlang#trace-3</a>
is triggered.</p><p>If <strong>enabled_garbage_collection/3</strong> is undefined,
<a href="#Module:enabled/3">Module:enabled/3</a>
is called instead.</p><h4>Module:enabled_ports(TraceTag, TracerState, Tracee) -&gt; Result</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint with trace flag
<a href="./erlang#trace-3">erlang#trace-3</a>
is triggered.</p><p>If <strong>enabled_ports/3</strong> is undefined,
<a href="#Module:enabled/3">Module:enabled/3</a>
is called instead.</p><h4>Module:enabled_procs(TraceTag, TracerState, Tracee) -&gt; Result</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint with trace flag
<a href="./erlang#trace-3">erlang#trace-3</a>
is triggered.</p><p>If <strong>enabled_procs/3</strong> is undefined,
<a href="#Module:enabled/3">Module:enabled/3</a>
is called instead.</p><h4>Module:enabled_receive(TraceTag, TracerState, Tracee) -&gt; Result
</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint with trace flag
<a href="./erlang#trace-3">erlang#trace-3</a>
is triggered.</p><p>If <strong>enabled_receive/3</strong> is undefined,
<a href="#Module:enabled/3">Module:enabled/3</a>
is called instead.</p><h4>Module:enabled_running_ports(TraceTag, TracerState, Tracee) -&gt;
        Result</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint with trace flag
<a href="./erlang#trace-3">erlang#trace-3</a>
is triggered.</p><p>If <strong>enabled_running_ports/3</strong> is undefined,
<a href="#Module:enabled/3">Module:enabled/3</a>
is called instead.</p><h4>Module:enabled_running_procs(TraceTag, TracerState, Tracee) -&gt;
        Result</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint with trace flag
<a href="./erlang#trace-3">erlang#trace-3</a>
is triggered.</p><p>If <strong>enabled_running_procs/3</strong> is undefined,
<a href="#Module:enabled/3">Module:enabled/3</a>
is called instead.</p><h4>Module:enabled_send(TraceTag, TracerState, Tracee) -&gt; Result</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint with trace flag
<a href="./erlang#trace-3">erlang#trace-3</a>
is triggered.</p><p>If <strong>enabled_send/3</strong> is undefined,
<a href="#Module:enabled/3">Module:enabled/3</a>
is called instead.</p><h4>Module:trace(TraceTag, TracerState, Tracee, TraceTerm,
        Opts) -&gt; Result</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled/3">Module:enabled/3</a>
callback returned <strong>trace</strong>. In it any side effects needed by
the tracer are to be done. The tracepoint payload is located in
the <strong>TraceTerm</strong>. The content of the <strong>TraceTerm</strong>
depends on which <strong>TraceTag</strong> is triggered.
<strong>TraceTerm</strong> corresponds to the
fourth element in the trace tuples described in
<a href="./erlang#trace_3_trace_messages">erlang#trace_3_trace_messages</a>.</p><p>If the trace tuple has five elements, the fifth element
will be sent as the <strong>extra</strong> value in the <strong>Opts</strong> maps.</p><h4>Module:trace(seq_trace, TracerState, Label,
        SeqTraceInfo, Opts) -&gt; Result</h4><p>Check if a sequence trace event is to be generated.</p><ul><li><span class="v">TracerState = term()</span></li><li><span class="v">Label = term()</span></li><li><span class="v">SeqTraceInfo = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>The <strong>TraceTag</strong> <strong>seq_trace</strong> is handled slightly
differently. There is no <strong>Tracee</strong> for <strong>seq_trace</strong>, instead
the <strong>Label</strong> associated with the <strong>seq_trace</strong> event is
specified.</p><p>For more information on what <strong>Label</strong> and <strong>SeqTraceInfo</strong>
can be, see <a href="./seq_trace">kernel/seq_trace</a>.</p><h4>Module:trace_call(TraceTag, TracerState, Tracee, TraceTerm,
          Opts) -&gt; Result</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled_call/3">Module:enabled_call/3</a>
callback returned <strong>trace</strong>.</p><p>If <strong>trace_call/5</strong> is undefined,
<a href="#Module:trace/5">Module:trace/5</a>
is called instead.</p><h4>Module:trace_garbage_collection(TraceTag, TracerState, Tracee,
        TraceTerm, Opts) -&gt; Result</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled_garbage_collection/3">Module:enabled_garbage_collection/3</a>
callback returned <strong>trace</strong>.</p><p>If <strong>trace_garbage_collection/5</strong> is undefined,
<a href="#Module:trace/5">Module:trace/5</a>
is called instead.</p><h4>Module:trace_ports(TraceTag, TracerState, Tracee, TraceTerm,
        Opts) -&gt; Result</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled_ports/3">Module:enabled_ports/3</a>
callback returned <strong>trace</strong>.</p><p>If <strong>trace_ports/5</strong> is undefined,
<a href="#Module:trace/5">Module:trace/5</a>
is called instead.</p><h4>Module:trace_procs(TraceTag, TracerState, Tracee, TraceTerm,
        Opts) -&gt; Result</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled_procs/3">Module:enabled_procs/3</a>
callback returned <strong>trace</strong>.</p><p>If <strong>trace_procs/5</strong> is undefined,
<a href="#Module:trace/5">Module:trace/5</a>
is called instead.</p><h4>Module:trace_receive(TraceTag, TracerState, Tracee, TraceTerm,
        Opts) -&gt; Result</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled_receive/3">Module:enabled_receive/3</a>
callback returned <strong>trace</strong>.</p><p>If <strong>trace_receive/5</strong> is undefined,
<a href="#Module:trace/5">Module:trace/5</a>
is called instead.</p><h4>Module:trace_running_ports(TraceTag, TracerState, Tracee,
        TraceTerm, Opts) -&gt; Result</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled_running_ports/3">Module:enabled_running_ports/3</a>
callback returned <strong>trace</strong>.</p><p>If <strong>trace_running_ports/5</strong> is undefined,
<a href="#Module:trace/5">Module:trace/5</a>
is called instead.</p><h4>Module:trace_running_procs(TraceTag, TracerState, Tracee,
        TraceTerm, Opts) -&gt; Result</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled_running_procs/3">Module:enabled_running_procs/3</a>
callback returned <strong>trace</strong>.</p><p>If <strong>trace_running_procs/5</strong> is undefined,
<a href="#Module:trace/5">Module:trace/5</a>
is called instead.</p><h4>Module:trace_send(TraceTag, TracerState, Tracee, TraceTerm,
        Opts) -&gt; Result</h4><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled_send/3">Module:enabled_send/3</a>
callback returned <strong>trace</strong>.</p><p>If <strong>trace_send/5</strong> is undefined,
<a href="#Module:trace/5">Module:trace/5</a>
is called instead.</p><a name="example"></a><h4>Erl Tracer Module Example</h4><p>In this example, a tracer module with a NIF back end sends a
message for each <strong>send</strong> trace tag containing only the sender and
receiver. Using this tracer module, a much more lightweight message
tracer is used, which only records who sent messages to who.</p><p>The following is an example session using it on Linux:</p><pre>
$ gcc -I erts-8.0/include/ -fPIC -shared -o erl_msg_tracer.so erl_msg_tracer.c
$ erl
Erlang/OTP 19 [DEVELOPMENT] [erts-8.0] [source-ed2b56b] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V8.0  (abort with ^G)
1&gt; c(erl_msg_tracer), erl_msg_tracer:load().
ok
2&gt; Tracer = spawn(fun F() -&gt; receive M -&gt; io:format("~p~n",[M]), F() end end).
&lt;0.37.0&gt;
3&gt; erlang:trace(new, true, [send,{tracer, erl_msg_tracer, Tracer}]).
0
{trace,&lt;0.39.0&gt;,&lt;0.27.0&gt;}
4&gt; {ok, D} = file:open("/tmp/tmp.data",[write]).
{trace,#Port&lt;0.486&gt;,&lt;0.40.0&gt;}
{trace,&lt;0.40.0&gt;,&lt;0.21.0&gt;}
{trace,#Port&lt;0.487&gt;,&lt;0.4.0&gt;}
{trace,#Port&lt;0.488&gt;,&lt;0.4.0&gt;}
{trace,#Port&lt;0.489&gt;,&lt;0.4.0&gt;}
{trace,#Port&lt;0.490&gt;,&lt;0.4.0&gt;}
{ok,&lt;0.40.0&gt;}
{trace,&lt;0.41.0&gt;,&lt;0.27.0&gt;}
5&gt;</pre><p><strong>erl_msg_tracer.erl</strong>:</p><pre>
-module(erl_msg_tracer).

-export([enabled/3, trace/5, load/0]).

load() -&gt;
    erlang:load_nif("erl_msg_tracer", []).

enabled(_, _, _) -&gt;
    error.

trace(_, _, _, _, _) -&gt;
    error.</pre><p><strong>erl_msg_tracer.c</strong>:</p><pre>
#include &lt;erl_nif.h&gt;

/* NIF interface declarations */
static int load(ErlNifEnv* env, void** priv_data, ERL_NIF_TERM load_info);
static int upgrade(ErlNifEnv* env, void** priv_data, void** old_priv_data, ERL_NIF_TERM load_info);
static void unload(ErlNifEnv* env, void* priv_data);

/* The NIFs: */
static ERL_NIF_TERM enabled(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);
static ERL_NIF_TERM trace(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);

static ErlNifFunc nif_funcs[] = {
    {"enabled", 3, enabled},
    {"trace", 5, trace}
};

ERL_NIF_INIT(erl_msg_tracer, nif_funcs, load, NULL, upgrade, unload)

static int load(ErlNifEnv* env, void** priv_data, ERL_NIF_TERM load_info)
{
    *priv_data = NULL;
    return 0;
}

static void unload(ErlNifEnv* env, void* priv_data)
{

}

static int upgrade(ErlNifEnv* env, void** priv_data, void** old_priv_data,
		   ERL_NIF_TERM load_info)
{
    if (*old_priv_data != NULL || *priv_data != NULL) {
	return -1; /* Don't know how to do that */
    }
    if (load(env, priv_data, load_info)) {
	return -1;
    }
    return 0;
}

/*
 * argv[0]: TraceTag
 * argv[1]: TracerState
 * argv[2]: Tracee
 */
static ERL_NIF_TERM enabled(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
    ErlNifPid to_pid;
    if (enif_get_local_pid(env, argv[1], &amp;to_pid))
        if (!enif_is_process_alive(env, &amp;to_pid))
            if (enif_is_identical(enif_make_atom(env, "trace_status"), argv[0]))
                /* tracer is dead so we should remove this tracepoint */
                return enif_make_atom(env, "remove");
            else
                return enif_make_atom(env, "discard");

    /* Only generate trace for when tracer != tracee */
    if (enif_is_identical(argv[1], argv[2]))
        return enif_make_atom(env, "discard");

    /* Only trigger trace messages on 'send' */
    if (enif_is_identical(enif_make_atom(env, "send"), argv[0]))
        return enif_make_atom(env, "trace");

    /* Have to answer trace_status */
    if (enif_is_identical(enif_make_atom(env, "trace_status"), argv[0]))
        return enif_make_atom(env, "trace");

    return enif_make_atom(env, "discard");
}

/*
 * argv[0]: TraceTag, should only be 'send'
 * argv[1]: TracerState, process to send {Tracee, Recipient} to
 * argv[2]: Tracee
 * argv[3]: Message
 * argv[4]: Options, map containing Recipient
 */
static ERL_NIF_TERM trace(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
    ErlNifPid to_pid;
    ERL_NIF_TERM recipient, msg;

    if (enif_get_local_pid(env, argv[1], &amp;to_pid)) {
      if (enif_get_map_value(env, argv[4], enif_make_atom(env, "extra"), &amp;recipient)) {
        msg = enif_make_tuple3(env, enif_make_atom(env, "trace"), argv[2], recipient);
        enif_send(env, &amp;to_pid, NULL, msg);
      }
    }

    return enif_make_atom(env, "ok");
}</pre><h3>erts_alloc</h3><p>An Erlang runtime system internal memory allocator library.
</p><p><strong>erts_alloc</strong> is an Erlang runtime system internal memory
allocator library. <strong>erts_alloc</strong> provides the Erlang
runtime system with a number of memory allocators.</p><h4>Allocators</h4><a name="allocators"></a><p>The following allocators are present:</p><dl><dt><strong>temp_alloc</strong></dt><dd>Allocator used for temporary allocations.</dd><dt><strong>eheap_alloc</strong></dt><dd>Allocator used for Erlang heap data, such as Erlang process heaps. </dd><dt><strong>binary_alloc</strong></dt><dd>Allocator used for Erlang binary data.</dd><dt><strong>ets_alloc</strong></dt><dd>Allocator used for <strong>ets</strong> data.</dd><dt><strong>driver_alloc</strong></dt><dd>Allocator used for driver data.</dd><dt><strong>literal_alloc</strong></dt><dd>Allocator used for constant terms in Erlang code.</dd><dt><strong>sl_alloc</strong></dt><dd>Allocator used for memory blocks that are expected to be short-lived.</dd><dt><strong>ll_alloc</strong></dt><dd>Allocator used for memory blocks that are expected to be long-lived, for example, Erlang code.</dd><dt><strong>fix_alloc</strong></dt><dd>A fast allocator used for some frequently used fixed size data types.</dd><dt><strong>exec_alloc</strong></dt><dd>Allocator used by the <a href="./HiPE_app">hipe/HiPE_app</a> application for native executable code.</dd><dt><strong>std_alloc</strong></dt><dd>Allocator used for most memory blocks not allocated through any of the other allocators described above.</dd><dt><strong>sys_alloc</strong></dt><dd>This is normally the default <strong>malloc</strong> implementation used on the specific OS.</dd><dt><strong>mseg_alloc</strong></dt><dd>A memory segment allocator. It is used by other allocators for allocating memory segments and is only available on systems that have the <strong>mmap</strong> system call. Memory segments that are deallocated are kept for a while in a segment cache before they are destroyed. When segments are allocated, cached segments are used if possible instead of creating new segments. This to reduce the number of system calls made.</dd></dl><p><strong>sys_alloc</strong>, <strong>literal_alloc</strong> and <strong>temp_alloc</strong> are always
enabled and cannot be disabled. <strong>exec_alloc</strong> is only available if it
is needed and cannot be disabled. <strong>mseg_alloc</strong> is always enabled if it is
available and an allocator that uses it is enabled. All other
allocators can be <a href="#M_e">enabled or disabled</a>.
By default all allocators are enabled.
When an allocator is disabled, <strong>sys_alloc</strong> is used instead of
the disabled allocator.</p><p>The main idea with the <strong>erts_alloc</strong> library is to separate
memory blocks that are used differently into different memory
areas, to achieve less memory fragmentation. By
putting less effort in finding a good fit for memory blocks that
are frequently allocated than for those less frequently
allocated, a performance gain can be achieved.</p><a name="alloc_util"></a><h4>The alloc_util Framework</h4><p>Internally a framework called <strong>alloc_util</strong> is used for
implementing allocators. <strong>sys_alloc</strong> and
<strong>mseg_alloc</strong> do not use this framework, so the
following does <em>not</em> apply to them.</p><p>An allocator manages multiple areas, called carriers, in which
memory blocks are placed. A carrier is either placed in a
separate memory segment (allocated through <strong>mseg_alloc</strong>), or in
the heap segment (allocated through <strong>sys_alloc</strong>).</p><ul><li> <p>Multiblock carriers are used for storage of several blocks.</p> </li><li> <p>Singleblock carriers are used for storage of one block.</p> </li><li> <p>Blocks that are larger than the value of the singleblock carrier
threshold (<a href="#M_sbct">M_sbct</a>) parameter
are placed in singleblock carriers.</p> </li><li> <p>Blocks that are smaller than the value of parameter <strong>sbct</strong>
are placed in multiblock carriers.</p></li></ul><p>Normally an allocator creates a "main multiblock
carrier". Main multiblock carriers are never deallocated. The
size of the main multiblock carrier is determined by the value of
parameter <a href="#M_mmbcs">M_mmbcs</a>.</p><p><a name="mseg_mbc_sizes"></a>Sizes of multiblock carriers
allocated through <strong>mseg_alloc</strong> are decided based on the
following parameters:</p><ul><li>The values of the largest multiblock carrier size (<a href="#M_lmbcs">M_lmbcs</a>)</li><li>The smallest multiblock carrier size (<a href="#M_smbcs">M_smbcs</a>)</li><li>The multiblock carrier growth stages (<a href="#M_mbcgs">M_mbcgs</a>)</li></ul><p>If <strong>nc</strong> is the current number of multiblock carriers (the main
multiblock carrier excluded) managed by an allocator, the size
of the next <strong>mseg_alloc</strong> multiblock carrier allocated by
this allocator is roughly
<strong>smbcs+nc*(lmbcs-smbcs)/mbcgs</strong> when
<strong>nc &lt;= mbcgs</strong>,
and <strong>lmbcs</strong> when <strong>nc &gt; mbcgs</strong>. If the value of
parameter <strong>sbct</strong> is larger than the value of parameter
<strong>lmbcs</strong>, the allocator may have to create
multiblock carriers that are larger than the value of
parameter <strong>lmbcs</strong>, though.
Singleblock carriers allocated through <strong>mseg_alloc</strong> are sized
to whole pages.</p><p>Sizes of carriers allocated through <strong>sys_alloc</strong> are
decided based on the value of the <strong>sys_alloc</strong> carrier size
(<a href="#Muycs">Muycs</a>) parameter. The size of
a carrier is the least number of multiples of the value of
parameter <strong>ycs</strong> satisfying the request.</p><p>Coalescing of free blocks are always performed immediately.
Boundary tags (headers and footers) in free blocks are used,
which makes the time complexity for coalescing constant.</p><p><a name="strategy"></a>The memory allocation strategy
used for multiblock carriers by an allocator can be
configured using parameter <a href="#M_as">M_as</a>.
The following strategies are available:</p><dl><dt>Best fit</dt><dd> <p>Strategy: Find the smallest block satisfying the
requested block size.</p> <p>Implementation: A balanced binary search tree is
used. The time complexity is proportional to log N, where
N is the number of sizes of free blocks.</p> </dd><dt>Address order best fit</dt><dd> <p>Strategy: Find the smallest block satisfying the
requested block size. If multiple blocks are found, choose
the one with the lowest address.</p> <p>Implementation: A balanced binary search tree is
used. The time complexity is proportional to log N, where
N is the number of free blocks.</p> </dd><dt>Address order first fit</dt><dd> <p>Strategy: Find the block with the lowest address satisfying the
requested block size.</p> <p>Implementation: A balanced binary search tree is
used. The time complexity is proportional to log N, where
N is the number of free blocks.</p> </dd><dt>Address order first fit carrier best fit</dt><dd> <p>Strategy: Find the <em>carrier</em> with the lowest address that
can satisfy the requested block size, then find a block within
that carrier using the "best fit" strategy.</p> <p>Implementation: Balanced binary search trees are
used. The time complexity is proportional to log N, where
N is the number of free blocks.</p> </dd><dt>Address order first fit carrier address order best fit</dt><dd> <p>Strategy: Find the <em>carrier</em> with the lowest address that
can satisfy the requested block size, then find a block within
that carrier using the "address order best fit" strategy.</p> <p>Implementation: Balanced binary search trees are
used. The time complexity is proportional to log N, where
N is the number of free blocks.</p> </dd><dt>Age order first fit carrier address order first fit</dt><dd> <p>Strategy: Find the <em>oldest carrier</em> that
can satisfy the requested block size, then find a block within
that carrier using the "address order first fit" strategy.</p> <p>Implementation: A balanced binary search tree is
used. The time complexity is proportional to log N, where
N is the number of free blocks.</p> </dd><dt>Age order first fit carrier best fit</dt><dd> <p>Strategy: Find the <em>oldest carrier</em> that
can satisfy the requested block size, then find a block within
that carrier using the "best fit" strategy.</p> <p>Implementation: Balanced binary search trees are
used. The time complexity is proportional to log N, where
N is the number of free blocks.</p> </dd><dt>Age order first fit carrier address order best fit</dt><dd> <p>Strategy: Find the <em>oldest carrier</em> that
can satisfy the requested block size, then find a block within
that carrier using the "address order best fit" strategy.</p> <p>Implementation: Balanced binary search trees are
used. The time complexity is proportional to log N, where
N is the number of free blocks.</p> </dd><dt>Good fit</dt><dd> <p>Strategy: Try to find the best fit, but settle for the best fit
found during a limited search.</p> <p>Implementation: The implementation uses segregated free
lists with a maximum block search depth (in each list)
to find a good fit fast. When the maximum block
search depth is small (by default 3), this implementation
has a time complexity that is constant. The maximum block
search depth can be configured using parameter
<a href="#M_mbsd">M_mbsd</a>.</p> </dd><dt>A fit</dt><dd> <p>Strategy: Do not search for a fit, inspect only one free
block to see if it satisfies the request. This strategy is
only intended to be used for temporary allocations.</p> <p>Implementation: Inspect the first block in a free-list.
If it satisfies the request, it is used, otherwise a new
carrier is created. The implementation has a time
complexity that is constant.</p> <p>As from ERTS 5.6.1 the emulator refuses to
use this strategy on other allocators than <strong>temp_alloc</strong>.
This because it only causes problems for other allocators.</p> </dd></dl><p>Apart from the ordinary allocators described above, some
pre-allocators are used for some specific data types. These
pre-allocators pre-allocate a fixed amount of memory for certain data
types when the runtime system starts. As long as pre-allocated memory
is available, it is used. When no pre-allocated memory is
available, memory is allocated in ordinary allocators. These
pre-allocators are typically much faster than the ordinary allocators,
but can only satisfy a limited number of requests.</p><a name="flags"></a><h4>System Flags Effecting erts_alloc</h4><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Only use these flags if you are sure what you are
doing. Unsuitable settings can cause serious performance
degradation and even a system crash at any time during
operation.</p></div><p>Memory allocator system flags have the following syntax:
<strong>+M&lt;S&gt;&lt;P&gt; &lt;V&gt;</strong>,
where <strong>&lt;S&gt;</strong> is a letter identifying a subsystem,
<strong>&lt;P&gt;</strong> is a parameter, and <strong>&lt;V&gt;</strong> is the
value to use. The flags can be passed to the Erlang emulator
(<a href="erl">erl</a>) as command-line
arguments.</p><p>System flags effecting specific allocators have an uppercase
letter as <strong>&lt;S&gt;</strong>. The following letters are used for
the allocators:</p><ul><li><strong>B: binary_alloc</strong></li><li><strong>D: std_alloc</strong></li><li><strong>E: ets_alloc</strong></li><li><strong>F: fix_alloc</strong></li><li><strong>H: eheap_alloc</strong></li><li><strong>I: literal_alloc</strong></li><li><strong>L: ll_alloc</strong></li><li><strong>M: mseg_alloc</strong></li><li><strong>R: driver_alloc</strong></li><li><strong>S: sl_alloc</strong></li><li><strong>T: temp_alloc</strong></li><li><strong>X: exec_alloc</strong></li><li><strong>Y: sys_alloc</strong></li></ul><h4>Flags for Configuration of mseg_alloc</h4><dl><dt><a name="MMamcbf"></a><strong>+MMamcbf &lt;size&gt;</strong></dt><dd> <p>Absolute maximum cache bad fit (in kilobytes). A segment in the
memory segment cache is not reused if its size exceeds the
requested size with more than the value of this
parameter. Defaults to <strong>4096</strong>.</p> </dd><dt><a name="MMrmcbf"></a><strong>+MMrmcbf &lt;ratio&gt;</strong></dt><dd> <p>Relative maximum cache bad fit (in percent). A segment in the
memory segment cache is not reused if its size exceeds the
requested size with more than relative maximum cache bad fit
percent of the requested size. Defaults to <strong>20</strong>.</p> </dd><dt><a name="MMsco"></a><strong>+MMsco true|false</strong></dt><dd> <p>Sets <a href="#MMscs">super carrier</a> only flag.
Defaults to <strong>true</strong>. When a super carrier is used and this
flag is <strong>true</strong>, <strong>mseg_alloc</strong> only creates carriers in
the super carrier. Notice that the <strong>alloc_util</strong> framework can
create <strong>sys_alloc</strong> carriers, so if you want all carriers to
be created in the super carrier, you therefore want to disable use
of <strong>sys_alloc</strong> carriers by also passing
<a href="#Musac">Musac</a>. When
the flag is <strong>false</strong>, <strong>mseg_alloc</strong> tries to create carriers
outside of the super carrier when the super carrier is full.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Setting this flag to <strong>false</strong> is not supported
on all systems. The flag is then ignored.</p></div> </dd><dt><a name="MMscrfsd"></a><strong>+MMscrfsd &lt;amount&gt;</strong></dt><dd> <p>Sets <a href="#MMscs">super carrier</a> reserved
free segment descriptors. Defaults to <strong>65536</strong>.
This parameter determines the amount of memory to reserve for
free segment descriptors used by the super carrier. If the system
runs out of reserved memory for free segment descriptors, other
memory is used. This can however cause fragmentation issues,
so you want to ensure that this never happens. The maximum amount
of free segment descriptors used can be retrieved from the
<strong>erts_mmap</strong> tuple part of the result from calling
<a href="../erts/erlang#system_info_allocator_tuple">erts/erlang#system_info_allocator_tuple</a>.</p> </dd><dt><a name="MMscrpm"></a><strong>+MMscrpm true|false</strong></dt><dd> <p>Sets <a href="#MMscs">super carrier</a> reserve
physical memory flag. Defaults to <strong>true</strong>. When this flag is
<strong>true</strong>, physical memory is reserved for the whole super
carrier at once when it is created. The reservation is after that
left unchanged. When this flag is set to <strong>false</strong>, only virtual
address space is reserved for the super carrier upon creation.
The system attempts to reserve physical memory upon carrier
creations in the super carrier, and attempt to unreserve physical
memory upon carrier destructions in the super carrier.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>What reservation of physical memory means, highly
depends on the operating system, and how it is configured. For
example, different memory overcommit settings on Linux drastically
change the behavior.</p><p>Setting this flag to <strong>false</strong> is possibly not supported on
all systems. The flag is then ignored.</p></div> </dd><dt><a name="MMscs"></a><strong>+MMscs &lt;size in MB&gt;</strong></dt><dd> <p>Sets super carrier size (in MB). Defaults to <strong>0</strong>, that is,
the super carrier is by default disabled. The super
carrier is a large continuous area in the virtual address space.
<strong>mseg_alloc</strong> always tries to create new carriers in the super
carrier if it exists. Notice that the <strong>alloc_util</strong> framework
can create <strong>sys_alloc</strong> carriers. For more information, see
<a href="#MMsco">MMsco</a>.</p> </dd><dt><a name="MMmcs"></a><strong>+MMmcs &lt;amount&gt;</strong></dt><dd> <p>Maximum cached segments. The maximum number of memory segments
stored in the memory segment cache. Valid range is <strong>[0, 30]</strong>.
Defaults to <strong>10</strong>.</p> </dd></dl><h4>Flags for Configuration of sys_alloc</h4><dl><dt><a name="MYe"></a><strong>+MYe true</strong></dt><dd> <p>Enables <strong>sys_alloc</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><strong>sys_alloc</strong> cannot be disabled.</p></div> </dd><dt><a name="MYm"></a><strong>+MYm libc</strong></dt><dd> <p><strong>malloc</strong> library to use. Only
<strong>libc</strong> is available. <strong>libc</strong> enables the standard
<strong>libc</strong> <strong>malloc</strong> implementation. By default <strong>libc</strong>
is used.</p> </dd><dt><a name="MYtt"></a><strong>+MYtt &lt;size&gt;</strong></dt><dd> <p>Trim threshold size (in kilobytes). This is the maximum amount
of free memory at the top of the heap (allocated by
<strong>sbrk</strong>) that is kept by <strong>malloc</strong> (not
released to the operating system). When the amount of free
memory at the top of the heap exceeds the trim threshold,
<strong>malloc</strong> releases it (by calling <strong>sbrk</strong>).
Trim threshold is specified in kilobytes.
Defaults to <strong>128</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag has effect only when the emulator is linked with
the GNU C library, and uses its <strong>malloc</strong> implementation.</p></div> </dd><dt><a name="MYtp"></a><strong>+MYtp &lt;size&gt;</strong></dt><dd> <p>Top pad size (in kilobytes). This is the amount of extra
memory that is allocated by <strong>malloc</strong> when
<strong>sbrk</strong> is called to get more memory from the operating
system. Defaults to <strong>0</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag has effect only when the emulator is linked with
the GNU C library, and uses its <strong>malloc</strong> implementation.</p></div> </dd></dl><h4>Flags for Configuration of Allocators Based on alloc_util</h4><p>If <strong>u</strong> is used as subsystem identifier (that is,
<strong>&lt;S&gt; = u</strong>), all allocators based on
<strong>alloc_util</strong> are effected. If <strong>B</strong>, <strong>D</strong>, <strong>E</strong>,
<strong>F</strong>, <strong>H</strong>, <strong>L</strong>, <strong>R</strong>, <strong>S</strong>, or <strong>T</strong> is used
as subsystem identifier, only the specific allocator identifier is
effected.</p><dl><dt><a name="M_acul"></a><strong>+M&lt;S&gt;acul &lt;utilization&gt;|de</strong> </dt><dd> <p>Abandon carrier utilization limit. A valid
<strong>&lt;utilization&gt;</strong> is an integer in the range
<strong>[0, 100]</strong> representing utilization in percent. When a
utilization value &gt; 0 is used, allocator instances
are allowed to abandon multiblock carriers. If <strong>de</strong> (default
enabled) is passed instead of a <strong>&lt;utilization&gt;</strong>,
a recommended non-zero utilization value is used. The value
chosen depends on the allocator type and can be changed between
ERTS versions. Defaults to <strong>de</strong>, but this
can be changed in the future.</p> <p>Carriers are abandoned when
memory utilization in the allocator instance falls below the
utilization value used. Once a carrier is abandoned, no new
allocations are made in it. When an allocator instance gets an
increased multiblock carrier need, it first tries to fetch an
abandoned carrier from another allocator instance. If no abandoned
carrier can be fetched, it creates a new empty carrier. When an
abandoned carrier has been fetched, it will function as an ordinary
carrier. This feature has special requirements on the
<a href="#M_as">allocation strategy</a> used. Only
the strategies <strong>aoff</strong>, <strong>aoffcbf</strong>, <strong>aoffcaobf</strong>,
<strong>ageffcaoff</strong>m, <strong>ageffcbf</strong> and <strong>ageffcaobf</strong>
support abandoned carriers.</p> <p>This feature also requires
<a href="#M_t">multiple thread specific instances</a>
to be enabled. When enabling this feature, multiple thread-specific
instances are enabled if not already enabled, and the
<strong>aoffcbf</strong> strategy is enabled if the current strategy does not
support abandoned carriers. This feature can be enabled on all
allocators based on the <strong>alloc_util</strong> framework, except
<strong>temp_alloc</strong> (which would be pointless).</p> </dd><dt><a name="M_acfml"></a><strong>+M&lt;S&gt;acfml &lt;bytes&gt;</strong> </dt><dd> <p>Abandon carrier free block min limit. A valid <strong>&lt;bytes&gt;</strong>
is a positive integer representing a block size limit. The largest
free block in a carrier must be at least <strong>bytes</strong> large, for the
carrier to be abandoned. The default is zero but can be changed
in the future.</p> <p>See also <a href="#M_acul">M_acul</a>.</p> </dd><dt><a name="M_acnl"></a><strong>+M&lt;S&gt;acnl &lt;amount&gt;</strong> </dt><dd> <p>Abandon carrier number limit. A valid <strong>&lt;amount&gt;</strong>
is a positive integer representing max number of abandoned carriers per
allocator instance. Defaults to 1000 which will practically disable
the limit, but this can be changed in the future.</p> <p>See also <a href="#M_acul">M_acul</a>.</p> </dd><dt><a name="M_as"></a> <strong>+M&lt;S&gt;as bf|aobf|aoff|aoffcbf|aoffcaobf|ageffcaoff|ageffcbf|ageffcaobf|gf|af</strong></dt><dd> <p>Allocation strategy. The following strategies are valid:</p> <ul><li><strong>bf</strong> (best fit)</li><li><strong>aobf</strong> (address order best fit)</li><li><strong>aoff</strong> (address order first fit)</li><li><strong>aoffcbf</strong> (address order first fit carrier best fit) </li><li><strong>aoffcaobf</strong> (address order first fit carrier address order best fit)</li><li><strong>ageffcaoff</strong> (age order first fit carrier address order first fit)</li><li><strong>ageffcbf</strong> (age order first fit carrier best fit) </li><li><strong>ageffcaobf</strong> (age order first fit carrier address order best fit)</li><li><strong>gf</strong> (good fit)</li><li><strong>af</strong> (a fit)</li></ul> <p>See the description of allocation strategies in section
<a href="#strategy">The alloc_util Framework</a>.</p> </dd><dt><a name="M_asbcst"></a><strong>+M&lt;S&gt;asbcst &lt;size&gt;</strong></dt><dd> <p>Absolute singleblock carrier shrink threshold (in
kilobytes). When a block located in an
<strong>mseg_alloc</strong> singleblock carrier is shrunk, the carrier
is left unchanged if the amount of unused memory is less
than this threshold, otherwise the carrier is shrunk.
See also <a href="#M_rsbcst">M_rsbcst</a>.</p> </dd><dt><a name="M_atags"></a><strong>+M&lt;S&gt;atags true|false</strong></dt><dd> <p>Adds a small tag to each allocated block that contains basic
information about what it is and who allocated it. Use the
<a href="./instrument">tools/instrument</a>
module to inspect this information.</p> <p>The runtime overhead is one word per allocation when enabled. This
may change at any time in the future.</p> <p>The default is <strong>true</strong> for <strong>binary_alloc</strong> and
<strong>driver_alloc</strong>, and <strong>false</strong> for the other allocator
types.</p> </dd><dt><a name="M_e"></a><strong>+M&lt;S&gt;e true|false</strong></dt><dd> <p>Enables allocator <strong>&lt;S&gt;</strong>.</p> </dd><dt><a name="M_lmbcs"></a><strong>+M&lt;S&gt;lmbcs &lt;size&gt;</strong></dt><dd> <p>Largest (<strong>mseg_alloc</strong>) multiblock carrier size (in kilobytes).
See the description on how sizes for <strong>mseg_alloc</strong> multiblock
carriers are decided in section
<a href="#mseg_mbc_sizes"> The alloc_util Framework</a>. On
32-bit Unix style OS this limit cannot be set &gt; 64 MB.</p> </dd><dt><a name="M_mbcgs"></a><strong>+M&lt;S&gt;mbcgs &lt;ratio&gt;</strong></dt><dd> <p>(<strong>mseg_alloc</strong>) multiblock carrier growth stages.
See the description on how sizes for <strong>mseg_alloc</strong> multiblock
carriers are decided in section
<a href="#mseg_mbc_sizes"> The alloc_util Framework</a>.</p> </dd><dt><a name="M_mbsd"></a><strong>+M&lt;S&gt;mbsd &lt;depth&gt;</strong></dt><dd> <p>Maximum block search depth. This flag has effect only if the
good fit strategy is selected for allocator
<strong>&lt;S&gt;</strong>. When the good fit strategy is used, free
blocks are placed in segregated free-lists. Each free-list
contains blocks of sizes in a specific range. The maxiumum block
search depth sets a limit on the maximum number of blocks to
inspect in a free-list during a search for suitable block
satisfying the request.</p> </dd><dt><a name="M_mmbcs"></a><strong>+M&lt;S&gt;mmbcs &lt;size&gt;</strong></dt><dd> <p>Main multiblock carrier size. Sets the size of the main
multiblock carrier for allocator <strong>&lt;S&gt;</strong>. The main
multiblock carrier is allocated through <strong>sys_alloc</strong>
and is never deallocated.</p> </dd><dt><a name="M_mmmbc"></a><strong>+M&lt;S&gt;mmmbc &lt;amount&gt;</strong></dt><dd> <p>Maximum <strong>mseg_alloc</strong> multiblock carriers. Maximum number of
multiblock carriers allocated through <strong>mseg_alloc</strong> by
allocator <strong>&lt;S&gt;</strong>. When this limit is reached,
new multiblock carriers are allocated through
<strong>sys_alloc</strong>.</p> </dd><dt><a name="M_mmsbc"></a><strong>+M&lt;S&gt;mmsbc &lt;amount&gt;</strong></dt><dd> <p>Maximum <strong>mseg_alloc</strong> singleblock carriers. Maximum number of
singleblock carriers allocated through <strong>mseg_alloc</strong> by
allocator <strong>&lt;S&gt;</strong>. When this limit is reached,
new singleblock carriers are allocated through
<strong>sys_alloc</strong>.</p> </dd><dt><a name="M_ramv"></a><strong>+M&lt;S&gt;ramv &lt;bool&gt;</strong></dt><dd> <p>Realloc always moves. When enabled, reallocate operations are
more or less translated into an allocate, copy, free sequence.
This often reduces memory fragmentation, but costs performance.</p> </dd><dt><a name="M_rmbcmt"></a><strong>+M&lt;S&gt;rmbcmt &lt;ratio&gt;</strong></dt><dd> <p>Relative multiblock carrier move threshold (in percent). When
a block located in a multiblock carrier is shrunk,
the block is moved if the ratio of the size of the returned
memory compared to the previous size is more than this threshold,
otherwise the block is shrunk at the current location.</p> </dd><dt><a name="M_rsbcmt"></a><strong>+M&lt;S&gt;rsbcmt &lt;ratio&gt;</strong></dt><dd> <p>Relative singleblock carrier move threshold (in percent). When
a block located in a singleblock carrier is shrunk to
a size smaller than the value of parameter
<a href="#M_sbct">M_sbct</a>,
the block is left unchanged in the singleblock carrier if
the ratio of unused memory is less than this threshold,
otherwise it is moved into a multiblock carrier.</p> </dd><dt><a name="M_rsbcst"></a><strong>+M&lt;S&gt;rsbcst &lt;ratio&gt;</strong></dt><dd> <p>Relative singleblock carrier shrink threshold (in
percent). When a block located in an <strong>mseg_alloc</strong>
singleblock carrier is shrunk, the carrier is left
unchanged if the ratio of unused memory is less than this
threshold, otherwise the carrier is shrunk.
See also <a href="#M_asbcst">M_asbcst</a>.</p> </dd><dt><a name="M_sbct"></a><strong>+M&lt;S&gt;sbct &lt;size&gt;</strong></dt><dd> <p>Singleblock carrier threshold (in kilobytes). Blocks larger than this
threshold are placed in singleblock carriers. Blocks
smaller than this threshold are placed in multiblock
carriers. On 32-bit Unix style OS this threshold cannot be set
&gt; 8 MB.</p> </dd><dt><a name="M_smbcs"></a><strong>+M&lt;S&gt;smbcs &lt;size&gt;</strong></dt><dd> <p>Smallest (<strong>mseg_alloc</strong>) multiblock carrier size (in
kilobytes). See the description on how sizes for <strong>mseg_alloc</strong>
multiblock carriers are decided in section
<a href="#mseg_mbc_sizes"> The alloc_util Framework</a>.</p> </dd><dt><a name="M_t"></a><strong>+M&lt;S&gt;t true|false</strong></dt><dd> <p>Multiple, thread-specific instances of the allocator.
This option has only effect on the runtime system
with SMP support. Default behavior on the runtime system with
SMP support is <strong>NoSchedulers+1</strong> instances. Each scheduler
uses a lock-free instance of its own and other threads use
a common instance.</p> <p>Before ERTS 5.9 it was possible to configure
a smaller number of thread-specific instances than schedulers.
This is, however, not possible anymore.</p> </dd></dl><h4>Flags for Configuration of alloc_util</h4><p>All allocators based on <strong>alloc_util</strong> are effected.</p><dl><dt><a name="Muycs"></a><strong>+Muycs &lt;size&gt;</strong></dt><dd> <p><strong>sys_alloc</strong> carrier size. Carriers allocated through
<strong>sys_alloc</strong> are allocated in sizes that are
multiples of the <strong>sys_alloc</strong> carrier size. This is not
true for main multiblock carriers and carriers allocated
during a memory shortage, though.</p> </dd><dt><a name="Mummc"></a><strong>+Mummc &lt;amount&gt;</strong></dt><dd> <p>Maximum <strong>mseg_alloc</strong> carriers. Maximum number of carriers
placed in separate memory segments. When this limit is
reached, new carriers are placed in memory retrieved from
<strong>sys_alloc</strong>.</p> </dd><dt><a name="Musac"></a><strong>+Musac &lt;bool&gt;</strong></dt><dd> <p>Allow <strong>sys_alloc</strong> carriers. Defaults to <strong>true</strong>.
If set to <strong>false</strong>, <strong>sys_alloc</strong> carriers are never
created by allocators using the <strong>alloc_util</strong> framework.</p> </dd></dl><h4>Special Flag for literal_alloc</h4><dl><dt><a name="MIscs"></a><strong>+MIscs &lt;size in MB&gt;</strong></dt><dd> <p><strong>literal_alloc</strong> super carrier size (in MB). The amount of
<em>virtual</em> address space reserved for literal terms in
Erlang code on 64-bit architectures. Defaults to <strong>1024</strong>
(that is, 1 GB), which is usually sufficient.
The flag is ignored on 32-bit architectures.</p> </dd></dl><h4>Instrumentation Flags</h4><dl><dt><strong>+M&lt;S&gt;atags</strong></dt><dd> <p>Adds a small tag to each allocated block that contains basic
information about what it is and who allocated it. See
<a href="#M_atags">M_atags</a> for a
more complete description.</p> </dd><dt><a name="Mit"></a><strong>+Mit X</strong></dt><dd> <p>Reserved for future use. Do <em>not</em> use this flag.</p> </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>When instrumentation of the emulator is enabled, the emulator
uses more memory and runs slower.</p></div><h4>Other Flags</h4><dl><dt><a name="Mea"></a><strong>+Mea min|max|r9c|r10b|r11b|config</strong></dt><dd> <p>Options:</p> <dl><dt><strong>min</strong></dt><dd> <p>Disables all allocators that can be disabled.</p> </dd><dt><strong>max</strong></dt><dd> <p>Enables all allocators (default).</p> </dd><dt><strong>r9c|r10b|r11b</strong></dt><dd> <p>Configures all allocators as they were configured in respective
Erlang/OTP release. These will eventually be removed.</p> </dd><dt><strong>config</strong></dt><dd> <p>Disables features that cannot be enabled while creating an
allocator configuration with
<a href="./erts_alloc_config">runtime_tools/erts_alloc_config</a>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This option is to be used only while running
<strong>erts_alloc_config(3)</strong>, <em>not</em> when
using the created configuration.</p></div> </dd></dl> </dd><dt><a name="Mlpm"></a><strong>+Mlpm all|no</strong></dt><dd> <p>Lock physical memory. Defaults to <strong>no</strong>, that is,
no physical memory is locked. If set to <strong>all</strong>, all
memory mappings made by the runtime system are locked into
physical memory. If set to <strong>all</strong>, the runtime system fails to
start if this feature is not supported, the user has not got enough
privileges, or the user is not allowed to lock enough physical
memory. The runtime system also fails with an out of memory
condition if the user limit on the amount of locked memory is
reached.</p> </dd></dl><h4>Notes</h4><p>Only some default values have been presented here. For information
about the currently used settings and the current status of the
allocators, see
<a href="../erts/erlang#system_info_allocator">erts/erlang#system_info_allocator</a> and
<a href="../erts/erlang#system_info_allocator_tuple">erts/erlang#system_info_allocator_tuple</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Most of these flags are highly implementation-dependent and
can be changed or removed without prior notice.</p><p><strong>erts_alloc</strong> is not obliged to strictly use the settings that
have been passed to it (it can even ignore them).</p></div><p>The <a href="./erts_alloc_config">runtime_tools/erts_alloc_config</a>
tool can be used to aid creation of an
<strong>erts_alloc</strong> configuration that is suitable for a limited
number of runtime scenarios.</p><h4>See Also</h4><p><a href="erl">erl</a>,
<a href="erlang">erlang</a>,
<a href="./erts_alloc_config">runtime_tools/erts_alloc_config</a>,
<a href="./instrument">tools/instrument</a></p><h3>escript</h3><p>Erlang scripting support</p><p><strong>escript</strong> provides support for running short Erlang programs
without having to compile them first, and an easy way to retrieve the
command-line arguments.It is possible to bundle <strong>escript</strong>(s) with an Erlang
runtime system to make it self-sufficient and relocatable. In such
a standalone system, the <strong>escript</strong>(s) should be located in
the top <strong>bin</strong> directory of the standalone system and given
<strong>.escript</strong> as file extension. Further the (built-in)
<strong>escript</strong> program should be copied to the same directory and
given the scripts original name (without the <strong>.escript</strong>
extension). This will enable use of the bundled Erlang runtime
system.The (built-in) <strong>escript</strong> program first determines which
Erlang runtime system to use and then starts it to execute your
script. Usually the runtime system is located in the same Erlang
installation as the <strong>escript</strong> program itself. But for
standalone systems with one or more escripts it may be the case
that the <strong>escript</strong> program in your path actually starts the
runtime system bundled with the escript. This is intentional, and
typically happens when the standalone system <strong>bin</strong> directory is not
in the execution path (as it may cause its <strong>erl</strong> program to
override the desired one) and the <strong>escript</strong>(s) are referred to via
symbolic links from a <strong>bin</strong> directory in the path.</p><h3>Functions</h3><h4>script-name script-arg1 script-arg2...</h4><h4>escript escript-flags script-name script-arg1 script-arg2...</h4><p>Run a script written in Erlang.</p><p><strong>escript</strong> runs a script written in Erlang.</p><p>Example:</p><pre>
$ <span class="input">chmod u+x factorial</span>
$ <span class="input">cat factorial</span>
#!/usr/bin/env escript
%% -*- erlang -*-
%%! -smp enable -sname factorial -mnesia debug verbose
main([String]) -&gt;
    try
        N = list_to_integer(String),
        F = fac(N),
        io:format("factorial ~w = ~w\n", [N,F])
    catch
        _:_ -&gt;
            usage()
    end;
main(_) -&gt;
    usage().

usage() -&gt;
    io:format("usage: factorial integer\n"),
    halt(1).

fac(0) -&gt; 1;
fac(N) -&gt; N * fac(N-1).
$ <span class="input">./factorial 5</span>
factorial 5 = 120
$ <span class="input">./factorial</span>
usage: factorial integer
$ <span class="input">./factorial five</span>
usage: factorial integer</pre><p>The header of the Erlang script in the example differs from
a normal Erlang module. The first line is intended to be the
interpreter line, which invokes <strong>escript</strong>.</p><p>However, if you invoke the <strong>escript</strong> as follows,
the contents of the first line does not matter, but it
cannot contain Erlang code as it will be ignored:</p><pre>
$ <span class="input">escript factorial 5</span></pre><p>The second line in the example contains an optional
directive to the <strong>Emacs</strong> editor, which causes it to
enter the major mode for editing Erlang source files. If the
directive is present, it must be located on the second
line.</p><p>If a comment selecting the <a href="../stdlib/epp#encoding">encoding</a> exists, it can be
located on the second line.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The encoding specified by the above mentioned comment
applies to the script itself. The encoding of the
I/O-server, however, must be set explicitly as follows:</p><pre><code class="">
io:setopts([{encoding, unicode}])</code></pre><p>The default encoding of the I/O-server for <strong>standard_io</strong>
is <strong>latin1</strong>, as the script runs in a non-interactive terminal
(see section
<a href="../stdlib/unicode_usage#unicode_options_summary"> Summary of Options</a>) in the STDLIB User's Guide.</p></div><p>On the third line (or second line depending on the presence
of the Emacs directive), arguments can be specified to
the emulator, for example:</p><pre>
%%! -smp enable -sname factorial -mnesia debug verbose</pre><p>Such an argument line must start with <strong>%%!</strong> and the
remaining line is interpreted as arguments to the emulator.</p><p>If you know the location of the <strong>escript</strong> executable, the first
line can directly give the path to <strong>escript</strong>, for example:</p><pre>
#!/usr/local/bin/escript</pre><p>As any other type of scripts, Erlang scripts do not work on
Unix platforms if the execution bit for the script file is not set.
(To turn on the execution bit, use <strong>chmod +x script-name</strong>.)</p><p>The remaining Erlang script file can either contain
Erlang <em>source code</em>, an <em>inlined beam file</em>, or an
<em>inlined archive file</em>.</p><p>An Erlang script file must always contain the <strong>main/1</strong>
function. When the script is run, the
<strong>main/1</strong> function is called with a list
of strings representing the arguments specified to the script (not
changed or interpreted in any way).</p><p>If the <strong>main/1</strong> function in the script returns successfully,
the exit status for the script is <strong>0</strong>. If an exception is
generated during execution, a short message is printed and the script
terminates with exit status <strong>127</strong>.</p><p>To return your own non-zero exit code, call <strong>halt(ExitCode)</strong>,
for example:</p><pre>
halt(1).</pre><p>
To retrieve the pathname of the script, call
<a href="#script_name-0">script_name-0</a>
from your script
(the pathname is usually, but not always, absolute).</p><p>If the file contains source code (as in the example above),
it is processed by the
<a href="./epp">stdlib/epp</a> preprocessor.
This means that you, for example, can use predefined macros
(such as <strong>?MODULE</strong>) and include directives like
the <strong>-include_lib</strong> directive. For example, use</p><pre>
-include_lib("kernel/include/file.hrl").</pre><p>to include the record definitions for the records used by function
<a href="../kernel/file#read_link_info/1">kernel/file#read_link_info/1</a>. You can also select
encoding by including an encoding comment here, but if
a valid encoding comment exists on the second line, it takes
precedence.</p><p>The script is checked for syntactic and semantic
correctness before it is run. If there are warnings (such as
unused variables), they are printed and the script will
still be run. If there are errors, they are printed and
the script will not be run and its exit status is
<strong>127</strong>.</p><p>Both the module declaration and the export declaration of
the <strong>main/1</strong> function are optional.</p><p>By default, the script will be interpreted. You can force
it to be compiled by including the following line somewhere
in the script file:</p><pre>
-mode(compile).</pre><p>Execution of interpreted code is slower than compiled code.
If much of the execution takes place in interpreted code, it
can be worthwhile to compile it, although the compilation
itself takes a little while. Also, <strong>native</strong> can be supplied
instead of <strong>compile</strong>. This compiles the script
using the native flag and may or may not be worthwhile
depending on the escript characteristics.</p><p>As mentioned earlier, a script can
contains precompiled <strong>beam</strong> code. In a precompiled
script, the interpretation of the script header is
the same as in a script containing source code. This means
that you can make a <strong>beam</strong> file executable by
prepending the file with the lines starting with <strong>#!</strong>
and <strong>%%!</strong> mentioned above. In a precompiled script, the
<strong>main/1</strong> function must be exported.</p><p>Another option is to have an entire
Erlang archive in the script. In an archive script, the
interpretation of the script header is the same as
in a script containing source code. This means that you can
make an archive file executable by prepending the file with
the lines starting with <strong>#!</strong> and <strong>%%!</strong> mentioned
above. In an archive script, the <strong>main/1</strong> function must
be exported. By default the <strong>main/1</strong> function in the
module with the same name as the basename of the
<strong>escript</strong> file is invoked. This behavior can be
overridden by setting flag <strong>-escript main Module</strong>
as one of the emulator flags. <strong>Module</strong> must be the
name of a module that has an exported <strong>main/1</strong>
function. For more information about archives and code loading, see
<a href="./code">kernel/code</a>.</p><p>It is often very convenient to have a header in
the escript, especially on Unix platforms. However, the header
is optional, so you directly can "execute"
an Erlang module, Beam file, or archive file without adding
any header to them. But then you have to invoke the script
as follows:</p><pre>
$ <span class="input">escript factorial.erl 5</span>
factorial 5 = 120
$ <span class="input">escript factorial.beam 5</span>
factorial 5 = 120
$ <span class="input">escript factorial.zip 5</span>
factorial 5 = 120</pre><a name="create-2"></a><h4>escript:create(FileOrBin, Sections) -&gt; ok | {ok, binary()} |
        {error, term()}</h4><p>Create an escript.</p><ul><li><span class="v">FileOrBin = filename() | 'binary'</span></li><li><span class="v">Sections = [Header] Body | Body</span></li><li><span class="v">Header = shebang | {shebang, Shebang} Â Â Â | comment | {comment, Comment} Â Â Â | {emu_args, EmuArgs}</span></li><li><span class="v">Shebang = string() | 'default' | 'undefined'</span></li><li><span class="v">Comment = string() | 'default' | 'undefined'</span></li><li><span class="v">EmuArgs = string() | 'undefined'</span></li><li><span class="v">Body = {source, SourceCode} | {beam, BeamCode} Â Â Â | {archive, ZipArchive} Â Â Â | {archive, ZipFiles, ZipOptions}</span></li><li><span class="v">SourceCode = BeamCode = file:filename() | binary()</span></li><li><span class="v">ZipArchive =  | binary()</span></li><li><span class="v">ZipFiles = [ZipFile]</span></li><li><span class="v">ZipFile = file:filename() Â Â Â | {file:filename(), binary()} Â Â Â | {file:filename(), binary(), file:file_info()}</span></li><li><span class="v">ZipOptions = []</span></li></ul><p>
Creates an escript from a list of sections. The
sections can be specified in any order. An escript begins with an
optional <strong>Header</strong> followed by a mandatory <strong>Body</strong>. If
the header is present, it does always begin with a
<strong>shebang</strong>, possibly followed by a <strong>comment</strong> and
<strong>emu_args</strong>. The <strong>shebang</strong> defaults to
<strong>"/usr/bin/env escript"</strong>. The <strong>comment</strong> defaults to
<strong>"This is an -*- erlang -*- file"</strong>. The created escript
can either be returned as a binary or written to file.</p><p>As an example of how the function can be used, we create an
interpreted escript that uses <strong>emu_args</strong> to set some emulator
flag. In this case, it happens to disable the <strong>smp_support</strong>. We
also extract the different sections from the newly created script:</p><pre>
&gt; <span class="input">Source = "%% Demo\nmain(_Args) -&gt;\n    io:format(erlang:system_info(smp_support)).\n".</span>
"%% Demo\nmain(_Args) -&gt;\n    io:format(erlang:system_info(smp_support)).\n"
&gt; <span class="input">io:format("~s\n", [Source]).</span>
%% Demo
main(_Args) -&gt;
    io:format(erlang:system_info(smp_support)).

ok
&gt; <span class="input">{ok, Bin} = escript:create(binary, [shebang, comment, {emu_args, "-smp disable"}, {source, list_to_binary(Source)}]).</span>
{ok,&lt;&lt;"#!/usr/bin/env escript\n%% This is an -*- erlang -*- file\n%%!-smp disabl"...&gt;&gt;}
&gt; <span class="input">file:write_file("demo.escript", Bin).</span>
ok
&gt; <span class="input">os:cmd("escript demo.escript").</span>
"false"
&gt; <span class="input">escript:extract("demo.escript", []).</span>
{ok,[{shebang,default}, {comment,default}, {emu_args,"-smp disable"},
     {source,&lt;&lt;"%% Demo\nmain(_Args) -&gt;\n    io:format(erlang:system_info(smp_su"...&gt;&gt;}]}</pre><p>An escript without header can be created as follows:</p><pre>
&gt; <span class="input">file:write_file("demo.erl", ["%% demo.erl\n-module(demo).\n-export([main/1]).\n\n", Source]).</span>
ok
&gt; <span class="input">{ok, _, BeamCode} = compile:file("demo.erl", [binary, debug_info]).</span>
{ok,demo,
    &lt;&lt;70,79,82,49,0,0,2,208,66,69,65,77,65,116,111,109,0,0,0,
      79,0,0,0,9,4,100,...&gt;&gt;}
&gt; <span class="input">escript:create("demo.beam", [{beam, BeamCode}]).</span>
ok
&gt; <span class="input">escript:extract("demo.beam", []).</span>
{ok,[{shebang,undefined}, {comment,undefined}, {emu_args,undefined},
     {beam,&lt;&lt;70,79,82,49,0,0,3,68,66,69,65,77,65,116,
             111,109,0,0,0,83,0,0,0,9,...&gt;&gt;}]}
&gt; <span class="input">os:cmd("escript demo.beam").</span>
"true"</pre><p>Here we create an archive script containing both Erlang
code and Beam code, then we iterate over all files in
the archive and collect their contents and some information about
them:</p><pre>
&gt; <span class="input">{ok, SourceCode} = file:read_file("demo.erl").</span>
{ok,&lt;&lt;"%% demo.erl\n-module(demo).\n-export([main/1]).\n\n%% Demo\nmain(_Arg"...&gt;&gt;}
&gt; <span class="input">escript:create("demo.escript", [shebang, {archive, [{"demo.erl", SourceCode}, {"demo.beam", BeamCode}], []}]).</span>
ok
&gt; <span class="input">{ok, [{shebang,default}, {comment,undefined}, {emu_args,undefined}, {archive, ArchiveBin}]} = escript:extract("demo.escript", []).</span>
{ok,[{shebang,default}, {comment,undefined}, {emu_args,undefined},
     {{archive,&lt;&lt;80,75,3,4,20,0,0,0,8,0,118,7,98,60,105,
                152,61,93,107,0,0,0,118,0,...&gt;&gt;}]}
&gt; <span class="input">file:write_file("demo.zip", ArchiveBin).</span>
ok
&gt; <span class="input">zip:foldl(fun(N, I, B, A) -&gt; [{N, I(), B()} | A] end, [], "demo.zip").</span>
{ok,[{"demo.beam",
      {file_info,748,regular,read_write,
                 {{2010,3,2},{0,59,22}},
                 {{2010,3,2},{0,59,22}},
                 {{2010,3,2},{0,59,22}},
                 54,1,0,0,0,0,0},
      &lt;&lt;70,79,82,49,0,0,2,228,66,69,65,77,65,116,111,109,0,0,0,
        83,0,0,...&gt;&gt;},
     {"demo.erl",
      {file_info,118,regular,read_write,
                 {{2010,3,2},{0,59,22}},
                 {{2010,3,2},{0,59,22}},
                 {{2010,3,2},{0,59,22}},
                 54,1,0,0,0,0,0},
      &lt;&lt;"%% demo.erl\n-module(demo).\n-export([main/1]).\n\n%% Demo\nmain(_Arg"...&gt;&gt;}]}</pre><a name="extract-2"></a><h4>escript:extract(File, Options) -&gt; {ok, Sections} |
        {error, term()}</h4><p>Parse an escript and extract its sections.</p><ul><li><span class="v">File = filename()</span></li><li><span class="v">Options = [] | [compile_source]</span></li><li><span class="v">Sections = Headers Body</span></li><li><span class="v">Headers =  {shebang, Shebang} {comment, Comment} {emu_args, EmuArgs}</span></li><li><span class="v">Shebang = string() | 'default' | 'undefined'</span></li><li><span class="v">Comment = string() | 'default' | 'undefined'</span></li><li><span class="v">EmuArgs = string() | 'undefined'</span></li><li><span class="v">Body = {source, SourceCode} Â Â Â | {source, BeamCode} Â Â Â | {beam, BeamCode} Â Â Â | {archive, ZipArchive}</span></li><li><span class="v">SourceCode = BeamCode = ZipArchive = binary()</span></li></ul><p>
Parses an escript and extracts its sections.
This is the reverse of
<a href="#create-2">create-2</a>.
</p><p>All sections are returned even if they do not exist in the
escript. If a particular section happens to have the same
value as the default value, the extracted value is set to the
atom <strong>default</strong>. If a section is missing, the extracted
value is set to the atom <strong>undefined</strong>.</p><p>Option <strong>compile_source</strong> only affects the result if
the escript contains <strong>source</strong> code. In this case the
Erlang code is automatically compiled and <strong>{source, BeamCode}</strong> is returned instead of <strong>{source, SourceCode}</strong>.</p><p>Example:</p><pre>
&gt; <span class="input">escript:create("demo.escript", [shebang, {archive, [{"demo.erl", SourceCode}, {"demo.beam", BeamCode}], []}]).</span>
ok
&gt; <span class="input">{ok, [{shebang,default}, {comment,undefined}, {emu_args,undefined}, {archive, ArchiveBin}]} = escript:extract("demo.escript", []).</span>
{ok,[{{archive,&lt;&lt;80,75,3,4,20,0,0,0,8,0,118,7,98,60,105,
                152,61,93,107,0,0,0,118,0,...&gt;&gt;}
     {emu_args,undefined}]}</pre><a name="script_name-0"></a><h4>escript:script_name() -&gt; File</h4><p>Return the name of an escript.</p><ul><li><span class="v">File = filename()</span></li></ul><p>
Returns the name of the escript that is executed.
If the function is invoked outside the context
of an escript, the behavior is undefined.</p><h4>Options Accepted By escript</h4><dl><dt><strong>-c</strong></dt><dd>Compiles the escript regardless of the value of the mode attribute. </dd><dt><strong>-d</strong></dt><dd>Debugs the escript. Starts the debugger, loads the module containing the <strong>main/1</strong> function into the debugger, sets a breakpoint in <strong>main/1</strong>, and invokes <strong>main/1</strong>. If the module is precompiled, it must be explicitly compiled with option <strong>debug_info</strong>. </dd><dt><strong>-i</strong></dt><dd>Interprets the escript regardless of the value of the mode attribute. </dd><dt><strong>-s</strong></dt><dd>Performs a syntactic and semantic check of the script file. Warnings and errors (if any) are written to the standard output, but the script will not be run. The exit status is <strong>0</strong> if any errors are found, otherwise <strong>127</strong>. </dd><dt><strong>-n</strong></dt><dd>Compiles the escript using flag <strong>+native</strong>. </dd></dl><h3>init</h3><p>Coordination of system startup.</p><p>This module is preloaded and contains the code for
the <strong>init</strong> system process that coordinates the startup of
the system. The first function evaluated at startup is
<strong>boot(BootArgs)</strong>, where <strong>BootArgs</strong> is a list of
command-line arguments supplied to the Erlang runtime system from
the local operating system; see
<a href="./erl">erts/erl</a>.<strong>init</strong> reads the boot script, which contains instructions on
how to initiate the system. For more information about boot scripts, see
<a href="./script">sasl/script</a>.<strong>init</strong> also contains functions to restart, reboot, and stop
the system.</p><h3>Functions</h3><h4>boot/1</h4><p>Start the Erlang runtime system.</p><p>Starts the Erlang runtime system. This function is called
when the emulator is started and coordinates system startup.</p><p><strong><span class="anno">BootArgs</span></strong> are all command-line arguments except
the emulator flags, that is, flags and plain arguments; see
<a href="./erl">erts/erl</a>.</p><p><strong>init</strong> interprets some of the flags, see section
<a href="#flags">Command-Line Flags</a> below.
The remaining flags ("user flags") and plain arguments are
passed to the <strong>init</strong> loop and can be retrieved by calling
<a href="#get_arguments/0">get_arguments/0</a>
and <a href="#get_plain_arguments/0">get_plain_arguments/0</a>, respectively.</p><h4>get_argument/1</h4><p>Get the values associated with a command-line user flag. </p><p>Returns all values associated with the command-line user flag
<strong><span class="anno">Flag</span></strong>. If <strong><span class="anno">Flag</span></strong> is provided
several times, each <strong><span class="anno">Values</span></strong> is returned in
preserved order. Example:</p><pre>
% <span class="input">erl -a b c -a d</span>
...
1&gt; <span class="input">init:get_argument(a).</span>
{ok,[["b","c"],["d"]]}</pre><p>The following flags are defined
automatically and can be retrieved using this function:</p><dl><dt><strong>root</strong></dt><dd> <p>The installation directory of Erlang/OTP, <strong>$ROOT</strong>:</p> <pre>
2&gt; <span class="input">init:get_argument(root).</span>
{ok,[["/usr/local/otp/releases/otp_beam_solaris8_r10b_patched"]]}</pre> </dd><dt><strong>progname</strong></dt><dd> <p>The name of the program which started Erlang:</p> <pre>
3&gt; <span class="input">init:get_argument(progname).</span>
{ok,[["erl"]]}</pre> </dd><dt><strong>home</strong></dt><dd> <p>The home directory:</p> <pre>
4&gt; <span class="input">init:get_argument(home).</span>
{ok,[["/home/harry"]]}</pre> </dd></dl><p>Returns <strong>error</strong> if no value is associated with <strong>Flag</strong>.</p><h4>get_arguments/0</h4><p>Get all command-line user flags.</p><p>Returns all command-line flags and the system-defined flags, see
<a href="#get_argument/1">get_argument/1</a>.</p><h4>get_plain_arguments/0</h4><p>Get all non-flag command-line arguments.</p><p>Returns any plain command-line arguments as a list of strings
(possibly empty).</p><h4>get_status/0</h4><p>Get system status information.</p><ul><li>internal_status</li></ul><p>The current status of the <strong>init</strong> process can be
inspected. During system startup (initialization),
<strong><span class="anno">InternalStatus</span></strong> is <strong>starting</strong>, and
<strong><span class="anno">ProvidedStatus</span></strong> indicates how far the boot
script has been interpreted. Each <strong>{progress, Info}</strong> term
interpreted in the boot script affects
<strong><span class="anno">ProvidedStatus</span></strong>, that is,
<strong><span class="anno">ProvidedStatus</span></strong> gets the value of <strong>Info</strong>.</p><h4>reboot/0</h4><p>Take down and restart an Erlang node smoothly.</p><p>All applications are taken down smoothly, all code is
unloaded, and all ports are closed before the system
terminates. If command-line flag <strong>-heart</strong> was specified,
the <strong>heart</strong> program tries to reboot the system. For more
information, see
<a href="./heart">kernel/heart</a>.</p><p>To limit the shutdown time, the time <strong>init</strong> is allowed
to spend taking down applications, command-line flag
<strong>-shutdown_time</strong> is to be used.</p><h4>restart/0</h4><p>Restart the running Erlang node.</p><p>The system is restarted <em>inside</em> the running Erlang
node, which means that the emulator is not restarted. All
applications are taken down smoothly, all code is unloaded,
and all ports are closed before the system is booted again in
the same way as initially started. The same <strong>BootArgs</strong>
are used again.</p><p>To limit the shutdown time, the time <strong>init</strong> is allowed
to spend taking down applications, command-line flag
<strong>-shutdown_time</strong> is to be used.</p><h4>script_id/0</h4><p>Get the identity of the used boot script.</p><p>Gets the identity of the boot script used to boot the system.
<strong><span class="anno">Id</span></strong> can be any Erlang term. In the delivered boot
scripts, <strong><span class="anno">Id</span></strong> is <strong>{Name, Vsn}</strong>. <strong>Name</strong>
and <strong>Vsn</strong> are strings.</p><h4>stop/0</h4><p>Take down an Erlang node smoothly.</p><p>The same as
<a href="#stop/1">stop/1</a>.</p><h4>stop/1</h4><p>Take down an Erlang node smoothly.</p><p>All applications are taken down smoothly, all code is
unloaded, and all ports are closed before the system
terminates by calling <strong>halt(<span class="anno">Status</span>)</strong>. If
command-line flag <strong>-heart</strong> was specified, the <strong>heart</strong>
program is terminated before the Erlang node terminates.
For more information, see
<a href="./heart">kernel/heart</a>.</p><p>To limit the shutdown time, the time <strong>init</strong> is allowed
to spend taking down applications, command-line flag
<strong>-shutdown_time</strong> is to be used.</p><a name="flags"></a><h4>Command-Line Flags</h4><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>The support for loading of code from archive files is
experimental. The only purpose of releasing it before it is ready
is to obtain early feedback. The file format, semantics,
interfaces, and so on, can  be changed in a future release. The
<strong>-code_path_choice</strong> flag is also experimental.</p></div><p>The <strong>init</strong> module interprets the following command-line flags:</p><dl><dt><strong>--</strong></dt><dd> <p>Everything following <strong>--</strong> up to the next flag is
considered plain arguments and can be retrieved using
<a href="#get_plain_arguments/0">get_plain_arguments/0</a>.</p> </dd><dt><strong>-code_path_choice Choice</strong></dt><dd> <p>Can be set to <strong>strict</strong> or <strong>relaxed</strong>. It controls how each
directory in the code path is to be interpreted:</p> <ul><li> <p>Strictly as it appears in the <strong>boot script</strong>, or</p> </li><li> <p><strong>init</strong> is to be more relaxed and try to find a suitable
directory if it can choose from a regular <strong>ebin</strong> directory
and an <strong>ebin</strong> directory in an archive file.</p> </li></ul> <p>This flag is particular
useful when you want to elaborate with code loading from
archives without editing the <strong>boot script</strong>. For more
information about interpretation of boot scripts, see
<a href="./script">sasl/script</a>.
The flag has also a similar effect on how the code server works; see
<a href="./code">kernel/code</a>.</p> </dd><dt><strong>-epmd_module Module</strong></dt><dd> <p>Specifies the module to use for registration and lookup of
node names.  Defaults to <strong>erl_epmd</strong>.</p> </dd><dt><strong>-eval Expr</strong></dt><dd> <p>Scans, parses, and evaluates an arbitrary expression
<strong>Expr</strong> during system initialization. If any of these
steps fail (syntax error, parse error, or exception during
evaluation), Erlang stops with an error message. In the following
example Erlang is used as a hexadecimal calculator:</p> <pre>
% <span class="input">erl -noshell -eval 'R = 16#1F+16#A0, io:format("~.16B~n", [R])' \\</span>
<span class="input">-s erlang halt</span>
BF</pre> <p>If multiple <strong>-eval</strong> expressions are specified, they
are evaluated sequentially in the order specified.
<strong>-eval</strong> expressions are evaluated sequentially with
<strong>-s</strong> and <strong>-run</strong> function calls (this also in
the order specified). As with <strong>-s</strong> and <strong>-run</strong>, an
evaluation that does not terminate blocks the system
initialization process.</p> </dd><dt><strong>-extra</strong></dt><dd> <p>Everything following <strong>-extra</strong> is considered plain
arguments and can be retrieved using
<a href="#get_plain_arguments/0">get_plain_arguments/0</a>.</p> </dd><dt><strong>-run Mod [Func [Arg1, Arg2, ...]]</strong></dt><dd> <p>Evaluates the specified function call during system
initialization. <strong>Func</strong> defaults to <strong>start</strong>. If no
arguments are provided, the function is assumed to be of arity
0. Otherwise it is assumed to be of arity 1, taking the list
<strong>[Arg1,Arg2,...]</strong> as argument. All arguments are passed
as strings. If an exception is raised, Erlang stops with an
error message.</p> <p>Example:</p> <pre>
% <span class="input">erl -run foo -run foo bar -run foo bar baz 1 2</span></pre> <p>This starts the Erlang runtime system and evaluates
the following functions:</p> <pre><code class="">
foo:start()
foo:bar()
foo:bar(["baz", "1", "2"]).</code></pre> <p>The functions are executed sequentially in an initialization
process, which then terminates normally and passes control to
the user. This means that a <strong>-run</strong> call that does not
return blocks further processing; to avoid this, use
some variant of <strong>spawn</strong> in such cases.</p> </dd><dt><strong>-s Mod [Func [Arg1, Arg2, ...]]</strong></dt><dd> <p>Evaluates the specified function call during system
initialization. <strong>Func</strong> defaults to <strong>start</strong>. If no
arguments are provided, the function is assumed to be of arity
0. Otherwise it is assumed to be of arity 1, taking the list
<strong>[Arg1,Arg2,...]</strong> as argument. All arguments are passed
as atoms. If an exception is raised, Erlang stops with an
error message.</p> <p>Example:</p> <pre>
% <span class="input">erl -s foo -s foo bar -s foo bar baz 1 2</span></pre> <p>This starts the Erlang runtime system and evaluates
the following functions:</p> <pre><code class="">
foo:start()
foo:bar()
foo:bar([baz, '1', '2']).</code></pre> <p>The functions are executed sequentially in an initialization
process, which then terminates normally and passes control to
the user. This means that a <strong>-s</strong> call that does not
return blocks further processing; to avoid this, use
some variant of <strong>spawn</strong> in such cases.</p> <p>Because of the limited length of atoms, it is recommended to
use <strong>-run</strong> instead.</p> </dd></dl><h4>Example</h4><pre>
% <span class="input">erl -- a b -children thomas claire -ages 7 3 -- x y</span>
...

1&gt; <span class="input">init:get_plain_arguments().</span>
["a","b","x","y"]
2&gt; <span class="input">init:get_argument(children).</span>
{ok,[["thomas","claire"]]}
3&gt; <span class="input">init:get_argument(ages).</span>
{ok, [["7","3"]]}
4&gt; <span class="input">init:get_argument(silly).</span>
error</pre><h4>See Also</h4><p><a href="erl_prim_loader">erl_prim_loader</a>, 
<a href="./heart">kernel/heart</a></p><h3>net</h3><p>Network interface.</p><p>This module provides an API for the network interface.</p><h3>Data Types</h3><span class="name">address_info</span><span class="name">name_info</span><span class="name">name_info_flags</span><span class="name">name_info_flag</span><span class="name">name_info_flag_ext</span><span class="name">network_interface_name</span><span class="name">network_interface_index</span><h3>Functions</h3><h4>gethostname/0</h4><p>Get hostname.</p><p>Returns the name of the current host.</p><h4>getnameinfo/1</h4><h4>getnameinfo/2</h4><p>Address-to-name transaltion.</p><p>Address-to-name translation in a protocol-independant manner.</p><p>This function is the inverse of
<a href="#getaddrinfo/1">getaddrinfo/1</a>.
It converts a socket address to a corresponding host and service.</p><h4>getaddrinfo/1</h4><h4>getaddrinfo/2</h4><h4>getaddrinfo/2</h4><h4>getaddrinfo/2</h4><p>Network address and service transation.</p><p>Network address and service translation.</p><p>This function is the inverse of
<a href="#getnameinfo/1">getnameinfo/1</a>.
It converts host and service to a corresponding socket address.</p><p>One of the <strong>Host</strong> and <strong>Service</strong> may be <strong>undefined</strong>
but <em>not</em> both.</p><h4>if_name2index/1</h4><p>Mappings between network interface names and indexes.</p><p>Mappings between network interface names and indexes.</p><h4>if_index2name/1</h4><p>Mappings between network interface index and names.</p><p>Mappings between network interface index and names.</p><h4>if_names/0</h4><p>Get network interface names and indexes.</p><p>Get network interface names and indexes.</p><h3>persistent_term</h3><p>Persistent terms.</p><p>This module is similar to <a href="./ets">stdlib/ets</a> in that it provides a
storage for Erlang terms that can be accessed in constant time,
but with the difference that <strong>persistent_term</strong> has been
highly optimized for reading terms at the expense of writing and
updating terms. When a persistent term is updated or deleted, a
global garbage collection pass is run to scan all processes for
the deleted term, and to copy it into each process that still uses
it. Therefore, <strong>persistent_term</strong> is suitable for storing
Erlang terms that are frequently accessed but never or
infrequently updated.Term lookup (using <a href="#get/1">get/1</a>), is done in constant time
and without taking any locks, and the term is <span class="strong">not</span>
copied to the heap (as is the case with terms stored in ETS
tables).Storing or updating a term (using <a href="#put/2">put/2</a>) is proportional to the
number of already created persistent terms because the hash table
holding the keys will be copied. In addition, the term itself will
be copied.When a (complex) term is deleted (using <a href="#erase/1">erase/1</a>) or replaced by another
(using <a href="#put/2">put/2</a>), a global
garbage collection is initiated. It works like this:<ul><li><p>All processes in the system will be scheduled to run a
scan of their heaps for the term that has been deleted.  While
such scan is relatively light-weight, if there are many
processes, the system can become less responsive until all
process have scanned their heaps.</p></li><li><p>If the deleted term (or any part of it) is still used
by a process, that process will do a major (fullsweep) garbage
collection and copy the term into the process. However, at most
two processes at a time will be scheduled to do that kind of
garbage collection.</p></li></ul>Deletion of atoms and other terms that fit in one machine word
is specially optimized to avoid doing a global GC. It is still not
recommended to update persistent terms with such values too
frequently because the hash table holding the keys is copied every
time a persistent term is updated.Some examples are suitable uses for persistent terms are:<ul><li><p>Storing of configuration data that must be easily
accessible by all processes.</p></li><li><p>Storing of references for NIF resources.</p></li><li><p>Storing of references for efficient counters.</p></li><li><p>Storing an atom to indicate a logging level or whether debugging
is turned on.</p></li></ul></p><h4>Storing Huge Persistent Terms</h4><p>The current implementation of persistent terms uses the literal
<a href="erts_alloc">allocator</a> also used for
literals (constant terms) in BEAM code.  By default, 1 GB of
virtual address space is reserved for literals in BEAM code and
persistent terms. The amount of virtual address space reserved for
literals can be changed by using the <a href="./erts_alloc#MIscs">erts_alloc#MIscs</a> when
starting the emulator.</p><p>Here is an example how the reserved virtual address space for literals
can be raised to 2 GB (2048 MB):</p><pre>
    erl +MIscs 2048</pre><h4>Best Practices for Using Persistent Terms</h4><p>It is recommended to use keys like <strong>?MODULE</strong> or
<strong>{?MODULE,SubKey}</strong> to avoid name collisions.</p><p>Prefer creating a few large persistent terms to creating many
small persistent terms. The execution time for storing a
persistent term is proportional to the number of already existing
terms.</p><p>Updating a persistent term with the same value as it already
has is specially optimized to do nothing quickly; thus, there is
no need compare the old and new values and avoid calling
<a href="#put/2">put/2</a> if the values
are equal.</p><p>When atoms or other terms that fit in one machine word are
deleted, no global GC is needed. Therefore, persistent terms that
have atoms as their values can be updated more frequently, but
note that updating such persistent terms is still much more
expensive than reading them.</p><p>Updating or deleting a persistent term will trigger a global GC
if the term does not fit in one machine word. Processes will be
scheduled as usual, but all processes will be made runnable at
once, which will make the system less responsive until all process
have run and scanned their heaps for the deleted terms. One way to
minimize the effects on responsiveness could be to minimize the
number of processes on the node before updating or deleting a
persistent term. It would also be wise to avoid updating terms
when the system is at peak load.</p><p>Avoid storing a retrieved persistent term in a process if that
persistent term could be deleted or updated in the future. If a
process holds a reference to a persistent term when the term is
deleted, the process will be garbage collected and the term copied
to process.</p><p>Avoid updating or deleting more than one persistent term at a
time.  Each deleted term will trigger its own global GC. That
means that deleting N terms will make the system less responsive N
times longer than deleting a single persistent term. Therefore,
terms that are to be updated at the same time should be collected
into a larger term, for example, a map or a tuple.</p><h4>Example</h4><p>The following example shows how lock contention for ETS tables
can be minimized by having one ETS table for each scheduler. The
table identifiers for the ETS tables are stored as a single
persistent term:</p><pre>
    %% There is one ETS table for each scheduler.
    Sid = erlang:system_info(scheduler_id),
    Tid = element(Sid, persistent_term:get(?MODULE)),
    ets:update_counter(Tid, Key, 1).</pre><h3>Data Types</h3><span class="name">key</span><p>Any Erlang term.</p><span class="name">value</span><p>Any Erlang term.</p><h3>Functions</h3><h4>erase/1</h4><p>Erase the name for a persistent term.</p><p>Erase the name for the persistent term with key
<strong><span class="anno">Key</span></strong>. The return value will be <strong>true</strong>
if there was a persistent term with the key
<strong><span class="anno">Key</span></strong>, and <strong>false</strong> if there was no
persistent term associated with the key.</p><p>If there existed a previous persistent term associated with
key <strong><span class="anno">Key</span></strong>, a global GC has been initiated
when <strong>erase/1</strong> returns. See <a href="#description">Description</a>.</p><h4>get/0</h4><p>Get all persistent terms.</p><p>Retrieve the keys and values for all persistent terms.
The keys will be copied to the heap for the process calling
<strong>get/0</strong>, but the values will not.</p><h4>get/1</h4><p>Get the value for a persistent term.</p><p>Retrieve the value for the persistent term associated with
the key <strong><span class="anno">Key</span></strong>. The lookup will be made in
constant time and the value will not be copied to the heap
of the calling process.</p><p>This function fails with a <strong>badarg</strong> exception if no
term has been stored with the key
<strong><span class="anno">Key</span></strong>.</p><p>If the calling process holds on to the value of the
persistent term and the persistent term is deleted in the future,
the term will be copied to the process.</p><h4>get/2</h4><p>Get the value for a persistent term.</p><p>Retrieve the value for the persistent term associated with
the key <strong><span class="anno">Key</span></strong>. The lookup will be made in
constant time and the value will not be copied to the heap
of the calling process.</p><p>This function returns <strong><span class="anno">Default</span></strong> if no
term has been stored with the key <strong><span class="anno">Key</span></strong>.</p><p>If the calling process holds on to the value of the
persistent term and the persistent term is deleted in the future,
the term will be copied to the process.</p><h4>info/0</h4><p>Get information about persistent terms.</p><p>Return information about persistent terms in a map. The map
has the following keys:</p><dl><dt><strong>count</strong></dt><dd><p>The number of persistent terms.</p></dd><dt><strong>memory</strong></dt><dd><p>The total amount of memory (measured in bytes)
used by all persistent terms.</p></dd></dl><h4>put/2</h4><p>Store a term.</p><p>Store the value <strong><span class="anno">Value</span></strong> as a persistent term and
associate it with the key <strong><span class="anno">Key</span></strong>.</p><p>If the value <strong><span class="anno">Value</span></strong> is equal to the value
previously stored for the key, <strong>put/2</strong> will do nothing and return
quickly.</p><p>If there existed a previous persistent term associated with
key <strong><span class="anno">Key</span></strong>, a global GC has been initiated
when <strong>put/2</strong> returns. See <a href="#description">Description</a>.</p><h3>run_erl</h3><p>Redirect Erlang input and output streams on Unix systems.</p><p>The <strong>run_erl</strong> program is specific to Unix systems.
This program redirects the standard input and standard
output streams so that all output can be logged. It also lets the
program <strong>to_erl</strong> connect to the Erlang console, making
it possible to monitor and debug an embedded system remotely.For more information about the use, see the
<a href="./embedded_solaris"> Embedded System User's Guide</a> in System Documentation.</p><h3>Functions</h3><h4>run_erl [-daemon] pipe_dir/ log_dir "exec command
        arg1 arg2 ..."</h4><p>Start the Erlang emulator without attached terminal.</p><p>Arguments:</p><dl><dt><strong>-daemon</strong></dt><dd> <p>This option is highly recommended. It makes <strong>run_erl</strong> run
in the background completely detached from any controlling
terminal and the command returns to the caller immediately.
Without this option, <strong>run_erl</strong> must be started using several
tricks in the shell to detach it completely from the
terminal in use when starting it. The option must be the
first argument to <strong>run_erl</strong> on the command line.</p> </dd><dt><strong>pipe_dir</strong></dt><dd> <p>The named pipe, usually <strong>/tmp/</strong>. It must be
suffixed by a <strong>/</strong> (slash), that is,
<strong>/tmp/epipes/</strong>, not
<strong>/tmp/epipes</strong>.</p> </dd><dt><strong>log_dir</strong></dt><dd> <p>The log files, that is:</p> <ul><li> <p>One log file, <strong>run_erl.log</strong>, which logs
progress and warnings from the <strong>run_erl</strong>
program itself.</p> </li><li> <p>Up to five log files at maximum 100 KB each with the content
of the standard streams from and to the command. (Both the
number of logs and sizes can be changed by environment
variables, see section <a href="#environment_variables">Environment Variables</a>
below.)</p> <p>When the logs are full, <strong>run_erl</strong> deletes
and reuses the oldest log file.</p> </li></ul> </dd><dt><strong>"exec command arg1 arg2 ..."</strong></dt><dd> <p>A space-separated string specifying the program to be executed.
The second field is typically a command name such as <strong>erl</strong>.</p> </dd></dl><h4>Notes concerning the Log Files</h4><p>While running, <strong>run_erl</strong> sends all output,
uninterpreted, to a log file. The file is named
<strong>erlang.log.N</strong>, where <strong>N</strong> is an integer. When the
log is "full" (default log size is 100 KB), <strong>run_erl</strong> starts to log
in file <strong>erlang.log.(N+1)</strong>, until <strong>N</strong> reaches a
certain number (default 5), whereupon <strong>N</strong> starts at 1 again and
the oldest files start getting overwritten.</p><p>If no output comes from the Erlang shell, but
the Erlang machine still seems to be alive, an "ALIVE" message is
written to the log; it is a time stamp and is written, by default,
after 15 minutes of inactivity. Also, if output from Erlang is
logged, but more than 5 minutes (default) has passed since last time
we got anything from Erlang, a time stamp is written in the
log. The "ALIVE" messages look as follows:</p><pre><code class="">
===== ALIVE &lt;date-time-string&gt;    </code></pre><p>The other time stamps look as follows:</p><pre><code class="">
===== &lt;date-time-string&gt;    </code></pre><p><strong>date-time-string</strong> is the date and time the message is
written, default in local time (can be changed to UTC if needed).
It is formatted with the ANSI-C function <strong>strftime</strong>
using the format string <strong>%a %b %e %T %Z %Y</strong>, which
produces messages like
<strong>===== ALIVE Thu May 15 10:13:36 MEST 2003</strong>; this can
be changed, see the next section.</p><a name="environment_variables"></a><h4>Environment Variables</h4><p>The following environment variables are recognized by <strong>run_erl</strong>
and change the logging behavior. For more information, see the previous
section.</p><dl><dt><strong>RUN_ERL_LOG_ALIVE_MINUTES</strong></dt><dd> <p>How long to wait for output (in minutes) before writing an
"ALIVE" message to the log. Defaults to 15, minimum is 1.</p> </dd><dt><strong>RUN_ERL_LOG_ACTIVITY_MINUTES</strong></dt><dd> <p>How long Erlang needs to be inactive before output is
preceded with a time stamp. Defaults to
<strong>RUN_ERL_LOG_ALIVE_MINUTES div 3</strong>, minimum is 1.</p> </dd><dt><strong>RUN_ERL_LOG_ALIVE_FORMAT</strong></dt><dd> <p>Specifies another format string to be used in the <strong>strftime</strong>
C library call. That is, specifying this to
<strong>"%e-%b-%Y, %T %Z"</strong> gives
log messages with time stamps like
<strong>15-May-2003, 10:23:04 MET</strong>. For more information,
see the documentation for the C library function <strong>strftime</strong>.
Defaults to <strong>"%a %b %e %T %Z %Y"</strong>.</p> </dd><dt><strong>RUN_ERL_LOG_ALIVE_IN_UTC</strong></dt><dd> <p>If set to anything else than <strong>0</strong>, it makes all
times displayed by <strong>run_erl</strong> to be in UTC (GMT, CET, MET,
without Daylight Saving Time), rather than in local time.
This does not affect data coming from Erlang,
only the logs output directly by <strong>run_erl</strong>. Application
SASL can be modified accordingly by setting the Erlang
application variable <strong>utc_log</strong> to
<strong>true</strong>.</p> </dd><dt><strong>RUN_ERL_LOG_GENERATIONS</strong></dt><dd> <p>Controls the number of log files written before older
files are reused. Defaults to 5, minimum is 2, maximum is 1000.</p> <p>Note that, as a way to indicate the newest file, <strong>run_erl</strong> will
delete the oldest log file to maintain a "hole" in the file
sequences. For example, if log files #1, #2, #4 and #5 exists, that
means #2 is the latest and #4 is the oldest. You will therefore at most
get one less log file than the value set by
<strong>RUN_ERL_LOG_GENERATIONS</strong>.</p> </dd><dt><strong>RUN_ERL_LOG_MAXSIZE</strong></dt><dd> <p>The size, in bytes, of a log file before switching to a
new log file. Defaults to 100000, minimum is 1000, maximum is
about 2^30.</p> </dd><dt><strong>RUN_ERL_DISABLE_FLOWCNTRL</strong></dt><dd> <p>If defined, disables input and output flow control for the pty
opend by <strong>run_erl</strong>. Useful if you want to remove any risk of
accidentally blocking the flow control by using Ctrl-S (instead of
Ctrl-D to detach), which can result in blocking of the entire Beam
process, and in the case of running heart as supervisor even the
heart process becomes blocked when writing log message to terminal,
leaving the heart process unable to do its work.</p> </dd></dl><h4>See Also</h4><p><a href="start">start</a>,
<a href="start_erl">start_erl</a></p><h3>socket</h3><p>Socket interface.</p><p>This module provides an API for the socket interface.
It is used to create, delete and manipulate sockets,
send and receive data.The idea is that it shall be as "close as possible" to the OS
level socket interface. The only significant addition is that some of
the functions,
e.g. <a href="#recv/3">recv/3</a>, 
has a timeout argument. </p><h3>Data Types</h3><span class="name">domain</span><span class="name">type</span><span class="name">protocol</span><span class="name">socket()</span><p>As returned by
<a href="#open/2">open/2</a> and
<a href="#accept/1">accept/1</a>.</p><span class="name">ip4_address</span><span class="name">ip6_address</span><span class="name">ip_address</span><span class="name">sockaddr</span><span class="name">sockaddr_in4</span><span class="name">sockaddr_in6</span><span class="name">sockaddr_un</span><span class="name">port_number</span><span class="name">in6_flow_info</span><span class="name">in6_scope_id</span><span class="name">accept_flags</span><span class="name">accept_flag</span><span class="name">send_flags</span><span class="name">send_flag</span><span class="name">recv_flags</span><span class="name">recv_flag</span><span class="name">shutdown_how</span><span class="name">sockopt_level</span><span class="name">otp_socket_option</span><span class="name">socket_option</span><span class="name">ip_socket_option</span><span class="name">ipv6_socket_option</span><span class="name">tcp_socket_option</span><span class="name">udp_socket_option</span><span class="name">sctp_socket_option</span><span class="name">timeval</span><span class="name">ip_tos</span><span class="name">ip_mreq</span><span class="name">ip_mreq_source</span><span class="name">ip_pmtudisc</span><span class="name">ip_msfilter_mode</span><span class="name">ip_msfilter</span><span class="name">ip_pktinfo</span><span class="name">ipv6_mreq</span><span class="name">ipv6_pmtudisc</span><span class="name">ipv6_pktinfo</span><span class="name">sctp_assoc_id</span><span class="name">sctp_sndrcvinfo</span><span class="name">sctp_event_subscribe</span><span class="name">sctp_assocparams</span><span class="name">sctp_initmsg</span><span class="name">sctp_rtoinfo</span><span class="name">msghdr_flag</span><span class="name">msghdr_flags</span><span class="name">msghdr</span><span class="name">cmsghdr_level</span><span class="name">cmsghdr_type</span><span class="name">cmsghdr_recv</span><span class="name">cmsghdr_send</span><span class="name">uint8</span><span class="name">uint16</span><span class="name">uint20</span><span class="name">uint32</span><span class="name">int32</span><span class="name">supports_options_socket</span><span class="name">supports_options_ip</span><span class="name">supports_options_ipv6</span><span class="name">supports_options_tcp</span><span class="name">supports_options_udp</span><span class="name">supports_options_sctp</span><span class="name">supports_options</span><h3>Functions</h3><h4>accept/1</h4><h4>accept/2</h4><p>Accept a connection on a socket.</p><p>Accept a connection on a socket.</p><p>This call is used with connection-based socket types
(<strong>stream</strong> or <strong>seqpacket</strong>). It extracs the first pending
connection request for the listen socket and returns the (newly)
connected socket.</p><h4>bind/2</h4><p>Bind a name to a socket.</p><p>Bind a name to a socket.</p><p>When a socket is created
(with <a href="#open/2">open/2</a>),
it has no address assigned to it. <strong>bind</strong> assigns the
address specified by the <strong>Addr</strong> argument.</p><p>The rules used for name binding vary between domains.</p><h4>close/1</h4><p>Close a socket.</p><p>Closes the socket.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that for e.g. <strong>protocol</strong> = <strong>tcp</strong>, most implementations
doing a close does not guarantee that any data sent is delivered to
the recipient before the close is detected at the remote side. </p><p>One way to handle this is to use the
<a href="#shutdown/2">shutdown/2</a>
function
(<strong>socket:shutdown(Socket, write)</strong>) to signal that no more data is
to be sent and then wait for the read side of the socket to be closed.</p></div><h4>connect/2</h4><h4>connect/3</h4><p>Initiate a connection on a socket.</p><p>This function connects the socket to the address
specied by the <strong>SockAddr</strong> argument.</p><h4>getopt/3</h4><h4>getopt/3</h4><h4>getopt/3</h4><h4>getopt/3</h4><h4>getopt/3</h4><h4>getopt/3</h4><h4>getopt/3</h4><p>Get an option on a socket.</p><p>Get an option on a socket.</p><p>What properties are valid depend  both on <strong>Level</strong> and
on what kind of socket it is (<strong>domain</strong>, <strong>type</strong> and
<strong>protocol</strong>).</p><p>See the
<a href="./socket_usage#socket_options">socket options</a>
chapter of the users guide for more info. </p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Not all options are valid on all platforms. That is,
even if "we" support an option, that does not mean that the
underlying OS does.</p></div><h4>getopt/3</h4><p>Get an option on a socket.</p><p>Get an option on a socket.</p><p>What properties are valid depend  both on <strong>Level</strong> and
on what kind of socket it is (<strong>domain</strong>, <strong>type</strong> and
<strong>protocol</strong>).</p><p>When specifying <strong>Level</strong> as an integer, and therefor
using "native mode", it is *currently* up to the caller to
know how to interpret the result.</p><p>See the
<a href="./socket_usage#socket_options">socket options</a>
chapter of the users guide for more info. </p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Not all options are valid on all platforms. That is,
even if "we" support an option, that does not mean that the
underlying OS does.</p></div><h4>listen/1</h4><h4>listen/2</h4><p>Listen for connections on a socket.</p><p>Listen for connections on a socket.</p><h4>open/2</h4><h4>open/3</h4><h4>open/4</h4><p>Create an endpoint for communication.</p><p>Creates an endpoint (socket) for communication.</p><p>For some <strong>types</strong> there is a default protocol, which will
be used if no protocol is specified: </p><ul><li><p><strong>stream</strong>: <strong>tcp</strong></p></li><li><p><strong>dgram</strong>: <strong>udp</strong></p></li><li><p><strong>seqpacket</strong>: <strong>sctp</strong></p></li></ul><p>The <strong>Extra</strong> argument is intended for "obscure" options.
Currently the only supported option is <strong>netns</strong>, which
is only supported on the linux platform.</p><h4>peername/1</h4><p>Get name of connected socket peer.</p><p>Returns the address of the peer connected to the socket.</p><h4>recv/1</h4><h4>recv/2</h4><h4>recv/3</h4><h4>recv/3</h4><h4>recv/4</h4><p>Receive a message from a socket.</p><p>Receive a message from a socket.</p><p>There is a special case for the argument <strong>Length</strong>.
If it is set to zero (0), it means "give me everything you 
currently have".</p><h4>recvfrom/1</h4><h4>recvfrom/2</h4><h4>recvfrom/3</h4><h4>recvfrom/3</h4><h4>recvfrom/3</h4><h4>recvfrom/4</h4><p>Receive a message from a socket.</p><p>Receive a message from a socket.</p><p>This function reads "messages", which means that regardless of
how much we want to read, it returns when we get a message.</p><p>The <strong>BufSz</strong> argument basically defines the size of the
receive buffer. By setting the value to zero (0), the configured
size (setopt with <strong>Level</strong> = <strong>otp</strong> and <strong>Key</strong> = <strong>rcvbuf</strong>)
is used.</p><p>It may be impossible to know what (buffer) size is appropriate
"in advance", and in those cases it may be convenient to use the
(recv) 'peek' flag. When this flag is provided, the message is *not*
"consumed" from the underlying buffers, so another recvfrom call
is needed, possibly with a then adjusted buffer size.</p><h4>recvmsg/1</h4><h4>recvmsg/2</h4><h4>recvmsg/2</h4><h4>recvmsg/3</h4><h4>recvmsg/3</h4><h4>recvmsg/5</h4><p>Receive a message from a socket.</p><p>Receive a message from a socket.</p><p>This function reads "messages", which means that regardless of
how much we want to read, it returns when we get a message.</p><p>The message will be delivered in the form of a <strong>msghdr()</strong>,
which may contain the source address (if socket not connected),
a list of <strong>cmsghdr_recv()</strong> (depends on what socket options have
been set and what the protocol and platform supports) and
also a set of flags, providing further info about the read. </p><p>The <strong>BufSz</strong> argument basically defines the size of the
receive buffer. By setting the value to zero (0), the configured
size (setopt with <strong>Level</strong> = <strong>otp</strong> and <strong>Key</strong> = <strong>rcvbuf</strong>)
is used.</p><p>The <strong>CtrlSz</strong> argument basically defines the size of the
receive buffer for the control messages.
By setting the value to zero (0), the configured size (setopt
with <strong>Level</strong> = <strong>otp</strong>) is used.</p><p>It may be impossible to know what (buffer) size is appropriate
"in advance", and in those cases it may be convenient to use the
(recv) 'peek' flag. When this flag is provided, the message is *not*
"consumed" from the underlying buffers, so another recvmsg call
is needed, possibly with a then adjusted buffer size.</p><h4>send/2</h4><h4>send/3</h4><h4>send/3</h4><h4>send/4</h4><p>Send a message on a socket.</p><p>Send a message on a connected socket.</p><h4>sendmsg/2</h4><h4>sendmsg/3</h4><h4>sendmsg/3</h4><h4>sendmsg/4</h4><p>Send a message on a socket.</p><p>Send a message on a socket. The destination, if needed
(socket <em>not</em> connected) is provided in the <strong>MsgHdr</strong>,
which also contains the message to send,
The <strong>MsgHdr</strong> may also contain an list of optional <strong>cmsghdr_send()</strong>
(depends on what the protocol and platform supports).</p><p>Unlike the <a href="#send/2">send/2</a> function,
this one sends <em>one message</em>.
This means that if, for whatever reason, its not possible to send the
message in one go, the function will instead return with the
<em>remaining</em> data (<strong>{ok, Remaining}</strong>). Thereby leaving it
up to the caller to decide what to do (retry with the remaining data
of give up). </p><h4>sendto/3</h4><h4>sendto/4</h4><h4>sendto/4</h4><h4>sendto/5</h4><p>Send a message on a socket.</p><p>Send a message on a socket, to the specified destination.</p><h4>setopt/4</h4><h4>setopt/4</h4><h4>setopt/4</h4><h4>setopt/4</h4><h4>setopt/4</h4><h4>setopt/4</h4><h4>setopt/4</h4><p>Set options on a socket.</p><p>Set options on a socket.</p><p>What properties are valid depend both on <strong>Level</strong> and on
what kind of socket it is (<strong>domain</strong>, <strong>type</strong> and
<strong>protocol</strong>).</p><p>See the
<a href="./socket_usage#socket_options">socket options</a>
chapter of the users guide for more info. </p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Not all options are valid on all platforms. That is,
even if "we" support an option, that does not mean that the
underlying OS does.</p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Sockets are set 'non-blocking' when created, so this option
is *not* available (as it would adversely effect the Erlang VM
to set a socket 'blocking').</p></div><h4>setopt/4</h4><p>Set options on a socket.</p><p>Set options on a socket.</p><p>What properties are valid depend both on <strong>Level</strong> and on
what kind of socket it is (<strong>domain</strong>, <strong>type</strong> and
<strong>protocol</strong>).</p><p>See the
<a href="./socket_usage#socket_options">socket options</a>
chapter of the users guide for more info. </p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Not all options are valid on all platforms. That is,
even if "we" support an option, that does not mean that the
underlying OS does.</p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Sockets are set 'non-blocking' when created, so this option
is *not* available (as it would adversely effect the Erlang VM
to set a socket 'blocking').</p></div><h4>shutdown/2</h4><p>Shut down part of a full-duplex connection.</p><p>Shut down all or part of a full-duplex connection.</p><h4>sockname/1</h4><p>Get socket name.</p><p>Returns the current address to which the socket is bound.</p><h4>supports/0</h4><h4>supports/1</h4><h4>supports/1</h4><h4>supports/1</h4><h4>supports/1</h4><h4>supports/2</h4><h4>supports/2</h4><h4>supports/2</h4><h4>supports/2</h4><h4>supports/2</h4><h4>supports/2</h4><h4>supports/2</h4><h4>supports/3</h4><h4>supports/3</h4><h4>supports/3</h4><h4>supports/3</h4><h4>supports/3</h4><h4>supports/3</h4><h4>supports/3</h4><p>Report info about what the platform supports.</p><p>This function intends to retreive information about what the
platform supports. Such as if SCTP is supported. Or which socket
options are supported. </p><h4>Examples</h4><a name="examples"></a><pre><code class="">
client(Addr, SAddr, SPort) -&gt;
   {ok, Sock} = socket:open(inet, stream, tcp),
   {ok, _} = socket:bind(Sock, #{family =&gt; inet,
                                 addr   =&gt; Addr}),
   ok = socket:connect(Sock, #{family =&gt; inet,
                               addr   =&gt; SAddr,
			       port   =&gt; SPort}),
   Msg = list_to_binary("hello"),
   ok = socket:send(Sock, Msg),
   ok = socket:shutdown(Sock, write),
   {ok, Msg} = socket:recv(Sock),
   ok = socket:close(Sock).

server(Addr, Port) -&gt;  
   {ok, LSock} = socket:open(inet, stream, tcp),
   {ok, _} = socket:bind(LSock, #{family =&gt; inet,
                                  port   =&gt; Port,
		 	          addr   =&gt; Addr}),
   ok = socket:listen(LSock),
   {ok, Sock} = socket:accept(LSock),
   {ok, Msg} = socket:recv(Sock),
   ok = socket:send(Sock, Msg),
   ok = socket:shutdown(Sock, write),
   ok = socket:close(Sock),
   ok = socket:close(LSock).
    </code></pre><h3>start</h3><p>OTP start script example for Unix.</p><p>The <strong>start</strong> script is an example script on
how to start up the Erlang system in embedded mode on Unix.For more information about the use, see the
<a href="./embedded_solaris"> Embedded System User's Guide</a> in System Documentation.</p><h3>Functions</h3><h4>start [ data_file ]</h4><p>Example script on how to start up the Erlang system in embedded mode on Unix.</p><p>Argument:</p><dl><dt><strong>data_file</strong></dt><dd> <p>Optional. Specifies what <strong>start_erl.data</strong> file
to use.</p> </dd></dl><p>Environment variable <strong>RELDIR</strong> can
be set before calling this example, which sets the directory
where to find the release files.</p><h4>See Also</h4><p><a href="run_erl">run_erl</a>,
<a href="start_erl">start_erl</a></p><h3>start_erl</h3><p>Start Erlang for embedded systems on Windows systems.</p><p>The <strong>start_erl</strong> program is specific to
Windows NT/2000/XP (and later versions of Windows).
Although there are programs with the same name on other
platforms, their functionality is different.This program is distributed both in compiled
form (under &lt;Erlang root&gt;\\erts-&lt;version&gt;\\bin) and
in source form (under &lt;Erlang root&gt;\\erts-&lt;version&gt;\\src).
The purpose of the source code is to ease customization of the
program for local needs, such as cyclic restart
detection. There is also a "make"-file, written for the
<strong>nmake</strong> program distributed with Microsoft Visual
C++. This program can, however, be compiled with
any Win32 C compiler (possibly with minor modifications).This program aids release handling on Windows systems.
The program is to be called by the
<strong>erlsrv</strong> program, read up the release data file
<strong>start_erl.data</strong>, and start Erlang. Some options to
<strong>start_erl</strong> are added and removed by the release handler
during upgrade with emulator restart (more specifically option
<strong>-data</strong>).</p><h3>Functions</h3><h4>start_erl [&lt;erl options&gt;] ++ [&lt;start_erl options&gt;]</h4><p>Start the Erlang emulator with the correct release data. </p><p>The <strong>start_erl</strong> program in its original form
recognizes the following options:</p><dl><dt><strong>++</strong></dt><dd> <p>Mandatory. Delimits <strong>start_erl</strong> options from normal Erlang
options. Everything on the command line <em>before</em>
<strong>++</strong> is interpreted as options to be sent to the
<strong>erl</strong> program. Everything <em>after</em>
<strong>++</strong> is interpreted as options to
<strong>start_erl</strong> itself.</p> </dd><dt><strong>-reldir &lt;release root&gt;</strong></dt><dd> <p>Mandatory if environment variable
<strong>RELDIR</strong> is not specified and no
<strong>-rootdir</strong> option is specified. Tells <strong>start_erl</strong> where
the root of the release tree is located in the file system
(typically &lt;Erlang root&gt;\\releases). The
<strong>start_erl.data</strong> file is expected to be
located in this directory (unless otherwise specified). If
only option <strong>-rootdir</strong> is specified, the directory is
assumed to be &lt;Erlang root&gt;\\releases.</p> </dd><dt><strong>-rootdir &lt;Erlang root directory&gt;</strong></dt><dd> <p>Mandatory if <strong>-reldir</strong> is not specified and no
<strong>RELDIR</strong> exists in the environment. This
specifies the Erlang installation root directory (under
which the <strong>lib</strong>, <strong>releases</strong>, and
<strong>erts-&lt;Version&gt;</strong> directories are located). If only
<strong>-reldir</strong> (or environment variable <strong>RELDIR</strong>)
is specified, the Erlang root is assumed to
be the directory exactly one level above the release
directory.</p> </dd><dt><strong>-data &lt;data file name&gt;</strong></dt><dd> <p>Optional. Specifies another data file than <strong>start_erl.data</strong>
in the &lt;release root&gt;. It is specified relative to the
&lt;release root&gt; or absolute (including drive letter, and so
on). This option is used by the release handler during
upgrade and is not to be used during normal
operation. Normally the release data file is not to be
named differently.</p> </dd><dt><strong>-bootflags &lt;boot flags file name&gt;</strong></dt><dd> <p>Optional. Specifies a file name relative to the release
directory (that is, the subdirectory of &lt;release root&gt;
where the <strong>.boot</strong> file and others are located).
The contents of this file is appended to the command line
when Erlang is started. This makes it easy to start the
emulator with different options for different releases.</p> </dd></dl><h4>Notes</h4><ul><li> <p>As the source code is distributed, it can easily be modified to
accept other options. The program must still accept option
<strong>-data</strong> with the semantics described above for the
release handler to work correctly.</p> </li><li> <p>The Erlang emulator is found by examining the registry keys for
the emulator version specified in the release data file. The new
emulator must be properly installed before the upgrade for
this to work.</p> </li><li> <p>Although the program is located together with files specific to the
emulator version, it is not expected to be specific to the
emulator version. The release handler does <em>not</em> change option
<strong>-machine</strong> to <strong>erlsrv</strong> during
emulator restart. Locate the (possibly customized)
<strong>start_erl</strong> program so that it is not overwritten
during upgrade.</p> </li><li> <p>The default options of the <strong>erlsrv</strong> program are not
sufficient for release handling. The machine started by
<strong>erlsrv</strong> is be specified as the
<strong>start_erl</strong> program and the arguments are to contain
<strong>++</strong> followed by the desired options.</p> </li></ul><h4>See Also</h4><p><a href="erlsrv">erlsrv</a>,
<a href="./release_handler">sasl/release_handler</a></p><h3>werl</h3><p>The Erlang Emulator</p><p>On Windows, the preferred way to start the Erlang system for interactive
use is as follows:<strong>werl &lt;arguments&gt;</strong>This starts Erlang in its own window, with fully
functioning command-line editing and scrollbars. All flags
except <strong>-oldshell</strong> work as they do for
<a href="erl">erl</a>.<ul><li> <p>To copy text to the clipboard, use <strong>Ctrl-C</strong>.</p> </li><li> <p>To paste text, use <strong>Ctrl-V</strong>.</p> </li><li> <p>To interrupt the runtime system or the shell process (depending
on what has been specified with system flag <strong>+B</strong>), use
<strong>Ctrl-Break</strong>.</p> </li></ul>In cases where you want to redirect standard input and/or
standard output or use Erlang in a pipeline, <strong>werl</strong> is
not suitable, and the <strong>erl</strong> program is to be used instead.The <strong>werl</strong> window is in many ways modeled after the <strong>xterm</strong>
window present on other platforms, as the <strong>xterm</strong> model
fits well with line-oriented command-based interaction. This
means that selecting text is line-oriented rather than
rectangle-oriented.<ul><li> <p>To select text in the <strong>werl</strong> window, press and hold
the left mouse button and drag the mouse over the text you want
to select. If the selection crosses line boundaries, the
selected text consists of complete lines where applicable
(just like in a word processor).</p> </li><li> <p>To select more text than fits
in the window, start by selecting a small part in the
beginning of the text you want, then use the scrollbar
to view the end of the desired selection, point to it, and press
the <em>right</em> mouse button. The whole area between your
first selection and the point where you right-clicked is
included in the selection.</p> </li><li> <p>To copy the selected text to the clipboard, either
use <strong>Ctrl-C</strong>, use the menu, or press the copy
button in the toolbar.</p> </li></ul>Pasted text is inserted at the current prompt position
and is interpreted by Erlang as usual keyboard input.<ul><li> <p>To retrieve previous command lines, press the <strong>Up arrow</strong> or
use <strong>Ctrl-P</strong>.</p> </li></ul>A drop-down box in the toolbar contains the command
history. Selecting a command in the drop-down box inserts the command
at the prompt, as if you used the keyboard to retrieve the
command.<ul><li> <p>To stop the Erlang emulator, close the <strong>werl</strong> window.</p> </li></ul></p><h3>zlib</h3><p>zlib compression interface.</p><p>This module provides an API for the zlib library
(<a href="http://www.zlib.net">www.zlib.net</a>).
It is used to compress and decompress data.
The data format is described by
<a href="https://www.ietf.org/rfc/rfc1950.txt">RFC 1950</a>,
<a href="https://www.ietf.org/rfc/rfc1951.txt">RFC 1951</a>, and
<a href="https://www.ietf.org/rfc/rfc1952.txt">RFC 1952</a>.A typical (compress) usage is as follows:<pre>
Z = zlib:open(),
ok = zlib:deflateInit(Z,default),

Compress = fun(end_of_data, _Cont) -&gt; [];
              (Data, Cont) -&gt;
                 [zlib:deflate(Z, Data)|Cont(Read(),Cont)]
           end,
Compressed = Compress(Read(),Compress),
Last = zlib:deflate(Z, [], finish),
ok = zlib:deflateEnd(Z),
zlib:close(Z),
list_to_binary([Compressed|Last])</pre>In all functions errors, <strong>{'EXIT',{Reason,Backtrace}}</strong>,
can be thrown, where <strong>Reason</strong> describes the error.Typical <strong>Reasons</strong>s:<dl><dt><strong>badarg</strong></dt><dd>Bad argument. </dd><dt><strong>not_initialized</strong></dt><dd>The stream hasn't been initialized, eg. if <a href="#inflateInit/1">inflateInit/1</a> wasn't called prior to a call to <a href="#inflate/2">inflate/2</a>. </dd><dt><strong>not_on_controlling_process</strong></dt><dd>The stream was used by a process that doesn't control it. Use <a href="#set_controlling_process/2">set_controlling_process/2</a> if you need to transfer a stream to a different process.</dd><dt><strong>data_error</strong></dt><dd>The data contains errors. </dd><dt><strong>stream_error</strong></dt><dd>Inconsistent stream state.</dd><dt><strong>{need_dictionary,Adler32}</strong></dt><dd>See <a href="#inflate/2">inflate/2</a>. </dd></dl></p><h3>Data Types</h3><span class="name">zstream</span><p>A zlib stream, see <a href="#open/0">open/0</a>.
</p><span class="name">zlevel</span><span class="name">zflush</span><span class="name">zmemlevel</span><span class="name">zmethod</span><span class="name">zstrategy</span><span class="name">zwindowbits</span><p>Normally in the range <strong>-15..-8 | 8..15</strong>.</p><h3>Functions</h3><h4>adler32/2</h4><p>Calculate the Adler checksum.</p><p>Calculates the Adler-32 checksum for <strong><span class="anno">Data</span></strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="../erts/erlang#adler32/1">erts/erlang#adler32/1</a> instead.</p></div><h4>adler32/3</h4><p>Calculate the Adler checksum.</p><p>Updates a running Adler-32 checksum for <strong><span class="anno">Data</span></strong>.
If <strong><span class="anno">Data</span></strong> is the empty binary or the empty iolist,
this function returns the required initial value for the checksum.</p><p>Example:</p><pre>
Crc = lists:foldl(fun(Data,Crc0) -&gt;
                      zlib:adler32(Z, Crc0, Data),
                  end, zlib:adler32(Z,&lt;&lt; &gt;&gt;), Datas)</pre><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="../erts/erlang#adler32/2">erts/erlang#adler32/2</a> instead.</p></div><h4>adler32_combine/4</h4><p>Combine two Adler-32 checksums.</p><p>Combines two Adler-32 checksums into one. For two binaries or
iolists, <strong>Data1</strong> and <strong>Data2</strong> with sizes of <strong>Size1</strong>
and <strong><span class="anno">Size2</span></strong>, with Adler-32 checksums
<strong><span class="anno">Adler1</span></strong> and <strong><span class="anno">Adler2</span></strong>.</p><p>This function returns the <strong><span class="anno">Adler</span></strong> checksum of
<strong>[Data1,Data2]</strong>, requiring only <strong><span class="anno">Adler1</span></strong>,
<strong><span class="anno">Adler2</span></strong>, and <strong><span class="anno">Size2</span></strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="../erts/erlang#adler32_combine/3">erts/erlang#adler32_combine/3</a> instead.</p></div><h4>close/1</h4><p>Close a stream.</p><p>Closes the stream referenced by <strong><span class="anno">Z</span></strong>.</p><h4>compress/1</h4><p>Compress data with standard zlib functionality.</p><p>Compresses data with zlib headers and checksum.</p><h4>crc32/1</h4><p>Get current CRC.</p><p>Gets the current calculated CRC checksum.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="../erts/erlang#crc32/1">erts/erlang#crc32/1</a> on the uncompressed data
instead.</p></div><h4>crc32/2</h4><p>Calculate CRC.</p><p>Calculates the CRC checksum for <strong><span class="anno">Data</span></strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="../erts/erlang#crc32/1">erts/erlang#crc32/1</a> instead.</p></div><h4>crc32/3</h4><p>Calculate CRC.</p><p>Updates a running CRC checksum for <strong><span class="anno">Data</span></strong>.
If <strong><span class="anno">Data</span></strong> is the empty binary or the empty iolist,
this function returns the required initial value for the CRC.</p><p>Example:</p><pre>
Crc = lists:foldl(fun(Data,Crc0) -&gt;
                      zlib:crc32(Z, Crc0, Data),
                  end, zlib:crc32(Z,&lt;&lt; &gt;&gt;), Datas)</pre><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="../erts/erlang#crc32/2">erts/erlang#crc32/2</a> instead.</p></div><h4>crc32_combine/4</h4><p>Combine two CRCs.</p><p>Combines two CRC checksums into one. For two binaries or iolists,
<strong>Data1</strong> and <strong>Data2</strong> with sizes of <strong>Size1</strong> and
<strong><span class="anno">Size2</span></strong>, with CRC checksums <strong><span class="anno">CRC1</span></strong>
and <strong><span class="anno">CRC2</span></strong>.</p><p>This function returns the <strong><span class="anno">CRC</span></strong> checksum of
<strong>[Data1,Data2]</strong>, requiring only <strong><span class="anno">CRC1</span></strong>,
<strong><span class="anno">CRC2</span></strong>, and <strong><span class="anno">Size2</span></strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="../erts/erlang#crc32_combine/3">erts/erlang#crc32_combine/3</a> instead.</p></div><h4>deflate/2</h4><p>Compress data.</p><p>Same as <strong>deflate(<span class="anno">Z</span>, <span class="anno">Data</span>, none)</strong>.</p><h4>deflate/3</h4><p>Compress data.</p><p>Compresses as much data as possible, and
stops when the input buffer becomes empty. It can introduce
some output latency (reading input without producing any
output) except when forced to flush.</p><p>If <strong><span class="anno">Flush</span></strong> is set to <strong>sync</strong>, all
pending output is flushed to the output buffer and the
output is aligned on a byte boundary, so that the
decompressor can get all input data available so far. 
Flushing can degrade compression for some compression algorithms;
thus, use it only when necessary.</p><p>If <strong><span class="anno">Flush</span></strong> is set to <strong>full</strong>, all output is
flushed as with <strong>sync</strong>, and the compression state is reset so
that decompression can restart from this point if previous compressed
data has been damaged or if random access is desired. Using
<strong>full</strong> too often can seriously degrade the compression.</p><p>If <strong><span class="anno">Flush</span></strong> is set to <strong>finish</strong>,
pending input is processed, pending output is flushed, and
<strong>deflate/3</strong> returns. Afterwards the only possible operations
on the stream are
<a href="#deflateReset/1">deflateReset/1</a> or
<a href="#deflateEnd/1">deflateEnd/1</a>.</p><p><strong><span class="anno">Flush</span></strong> can be set to <strong>finish</strong> immediately
after <a href="#deflateInit/1">deflateInit/1</a>
if all compression is to be done in one step.</p><p>Example:</p><pre>
zlib:deflateInit(Z),
B1 = zlib:deflate(Z,Data),
B2 = zlib:deflate(Z,&lt;&lt; &gt;&gt;,finish),
zlib:deflateEnd(Z),
list_to_binary([B1,B2])</pre><h4>deflateEnd/1</h4><p>End deflate session.</p><p>Ends the deflate session and cleans all data used. Notice that this
function throws a <strong>data_error</strong> exception if the last call to
<a href="#deflate/3">deflate/3</a>
was not called with <strong>Flush</strong> set to <strong>finish</strong>.</p><h4>deflateInit/1</h4><p>Initialize a session for compression.</p><p>Same as <strong>zlib:deflateInit(<span class="anno">Z</span>, default)</strong>.</p><h4>deflateInit/2</h4><p>Initialize a session for compression.</p><p>Initializes a zlib stream for compression.</p><p><strong><span class="anno">Level</span></strong> decides the compression level to be
used:</p><ul><li>0 (<strong>none</strong>), gives no compression</li><li>1 (<strong>best_speed</strong>) gives best speed</li><li>9 (<strong>best_compression</strong>) gives best compression</li></ul><h4>deflateInit/6</h4><p>Initialize a session for compression.</p><p>Initiates a zlib stream for compression.</p><dl><dt><strong><span class="anno">Level</span></strong></dt><dd> <p>Compression level to use:</p> <ul><li>0 (<strong>none</strong>), gives no compression</li><li>1 (<strong>best_speed</strong>) gives best speed</li><li>9 (<strong>best_compression</strong>) gives best compression</li></ul> </dd><dt><strong><span class="anno">Method</span></strong></dt><dd> <p>Compression method to use, currently the only supported method
is <strong>deflated</strong>.</p> </dd><dt><strong><span class="anno">WindowBits</span></strong></dt><dd> <p>The base two logarithm of the window size (the size of the
history buffer). It is to be in the range 8 through 15. Larger
values result in better compression at the expense of memory
usage. Defaults to 15 if <a href="#deflateInit/2">deflateInit/2</a> is used. A negative
<strong><span class="anno">WindowBits</span></strong> value suppresses the zlib header
(and checksum) from the stream. Notice that the zlib source
mentions this only as a undocumented feature.</p> <div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Due to a known bug in the underlying zlib library, <strong>WindowBits</strong> values 8 and -8
do not work as expected. In zlib versions before 1.2.9 values
8 and -8 are automatically changed to 9 and -9. <em>From zlib version 1.2.9 value -8 is rejected</em> causing <strong>zlib:deflateInit/6</strong> to fail
(8 is still changed to 9). It also seem possible that future versions
of zlib may fix this bug and start accepting 8 and -8 as is.</p><p>Conclusion: Avoid values 8 and -8 unless you know your zlib version supports them.</p></div> </dd><dt><strong><span class="anno">MemLevel</span></strong></dt><dd> <p>Specifies how much memory is to be allocated for the internal
compression state: <strong><span class="anno">MemLevel</span></strong>=1 uses minimum
memory but is slow and reduces compression ratio;
<strong><span class="anno">MemLevel</span></strong>=9 uses maximum memory for optimal
speed. Defaults to 8.</p> </dd><dt><strong><span class="anno">Strategy</span></strong></dt><dd> <p>Tunes the compression algorithm. Use the following values:</p> <ul><li><strong>default</strong> for normal data</li><li><strong>filtered</strong> for data produced by a filter (or predictor)</li><li><strong>huffman_only</strong> to force Huffman encoding only (no string match)</li><li><strong>rle</strong> to limit match distances to one (run-length encoding)</li></ul> <p>Filtered data consists mostly of small values with a somewhat
random distribution. In this case, the compression algorithm is
tuned to compress them better. The effect of <strong>filtered</strong> is to
force more Huffman coding and less string matching; it is somewhat
intermediate between <strong>default</strong> and <strong>huffman_only</strong>.
<strong>rle</strong> is designed to be almost as fast as
<strong>huffman_only</strong>, but gives better compression for PNG image
data.</p> <p><strong><span class="anno">Strategy</span></strong> affects only the compression ratio,
but not the correctness of the compressed output even if it is not
set appropriately.</p> </dd></dl><h4>deflateParams/3</h4><p>Dynamicly update deflate parameters.</p><p>Dynamically updates the compression level and compression
strategy. The interpretation of <strong><span class="anno">Level</span></strong> and
<strong><span class="anno">Strategy</span></strong> is as in
<a href="#deflateInit/6">deflateInit/6</a>.
This can be
used to switch between compression and straight copy of the
input data, or to switch to a different kind of input data
requiring a different strategy. If the compression level is
changed, the input available so far is compressed with the
old level (and can be flushed); the new level takes
effect only at the next call of
<a href="#deflate/3">deflate/3</a>.</p><p>Before the call of <strong>deflateParams</strong>, the stream state must be
set as for a call of <strong>deflate/3</strong>, as the currently available
input may have to be compressed and flushed.</p><h4>deflateReset/1</h4><p>Reset the deflate session.</p><p>Equivalent to
<a href="#deflateEnd/1">deflateEnd/1</a>
followed by
<a href="#deflateInit/1">deflateInit/1</a>,
but does not free and reallocate all the internal compression state.
The stream keeps the same compression level and any other
attributes.</p><h4>deflateSetDictionary/2</h4><p>Initialize the compression dictionary.</p><p>Initializes the compression dictionary from the specified byte
sequence without producing any compressed output.</p><p>This function must be called immediately after
<a href="#deflateInit/1">deflateInit/1</a> or
<a href="#deflateReset/1">deflateReset/1</a>,
before any call of
<a href="#deflate/3">deflate/3</a>.</p><p>The compressor and decompressor must use the same dictionary (see
<a href="#inflateSetDictionary/2">inflateSetDictionary/2</a>).</p><p>The Adler checksum of the dictionary is returned.</p><h4>getBufSize/1</h4><p>Get buffer size.</p><p>Gets the size of the intermediate buffer.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release.</p></div><h4>gunzip/1</h4><p>Uncompress data with gz header.</p><p>Uncompresses data with gz headers and checksum.</p><h4>gzip/1</h4><p>Compress data with gz header.</p><p>Compresses data with gz headers and checksum.</p><h4>inflate/2</h4><p>Decompress data.</p><p>Equivalent to
<a href="#inflate/3">inflate/3</a>
</p><h4>inflate/3</h4><p>Decompress data.</p><p>Decompresses as much data as possible. It can introduce some output
latency (reading input without producing any output).</p><p>Currently the only available option is
<strong>{exception_on_need_dict,boolean()}</strong> which controls whether the
function should throw an exception when a preset dictionary is
required for decompression. When set to false, a
<strong>need_dictionary</strong> tuple will be returned instead. See
<a href="#inflateSetDictionary/2">inflateSetDictionary/2</a> for details.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This option defaults to <strong>true</strong> for backwards compatibility
but we intend to remove the exception behavior in a future
release. New code that needs to handle dictionaries manually
should always specify <strong>{exception_on_need_dict,false}</strong>.</p></div><h4>inflateChunk/1</h4><p>Read next uncompressed chunk.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="#safeInflate/2">safeInflate/2</a> instead.</p></div><p>Reads the next chunk of uncompressed data, initialized by
<a href="#inflateChunk/2">inflateChunk/2</a>.</p><p>This function is to be repeatedly called, while it returns
<strong>{more, Decompressed}</strong>.</p><h4>inflateChunk/2</h4><p>Decompress data with limited output size.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="#safeInflate/2">safeInflate/2</a> instead.</p></div><p>Like <a href="#inflate/2">inflate/2</a>,
but decompresses no more data than will fit in the buffer configured
through <a href="#setBufSize/2">setBufSize/2</a>. Is is useful when decompressing a stream with a high
compression ratio, such that a small amount of compressed input can
expand up to 1000 times.</p><p>This function returns <strong>{more, Decompressed}</strong>, when there is
more output available, and
<a href="#inflateChunk/1">inflateChunk/1</a>
is to be used to read it.</p><p>This function can introduce some output latency (reading input
without producing any output).</p><p>An exception will be thrown if a preset dictionary is required for
further decompression. See
<a href="#inflateSetDictionary/2">inflateSetDictionary/2</a> for details.</p><p>Example:</p><pre>
walk(Compressed, Handler) -&gt;
    Z = zlib:open(),
    zlib:inflateInit(Z),
    % Limit single uncompressed chunk size to 512kb
    zlib:setBufSize(Z, 512 * 1024),
    loop(Z, Handler, zlib:inflateChunk(Z, Compressed)),
    zlib:inflateEnd(Z),
    zlib:close(Z).

loop(Z, Handler, {more, Uncompressed}) -&gt;
    Handler(Uncompressed),
    loop(Z, Handler, zlib:inflateChunk(Z));
loop(Z, Handler, Uncompressed) -&gt;
    Handler(Uncompressed).</pre><h4>inflateEnd/1</h4><p>End inflate session.</p><p>Ends the inflate session and cleans all data used. Notice
that this function throws a <strong>data_error</strong> exception
if no end of stream was found (meaning that not all data
has been uncompressed).</p><h4>inflateGetDictionary/1</h4><p>Return the decompression dictionary.</p><p>Returns the decompression dictionary currently in use
by the stream. This function must be called between
<a href="#inflateInit/1">inflateInit/1</a>
and <a href="#inflateEnd/1">inflateEnd/1</a>.</p><p>Only supported if ERTS was compiled with zlib &gt;= 1.2.8.</p><h4>inflateInit/1</h4><p>Initialize a session for decompression.</p><p>Initializes a zlib stream for decompression.</p><h4>inflateInit/2</h4><p>Initialize a session for decompression.</p><p>Initializes a decompression session on zlib stream.</p><p><strong><span class="anno">WindowBits</span></strong> is the base two logarithm
of the maximum window size (the size of the history buffer).
It is to be in the range 8 through 15. Default to 15 if
<a href="#inflateInit/1">inflateInit/1</a>
is used.</p><p>If a compressed stream with a larger window size is specified as
input, <a href="#inflate/2">inflate/2</a>
throws the <strong>data_error</strong> exception.</p><p>A negative <strong><span class="anno">WindowBits</span></strong> value makes zlib
ignore the zlib header (and checksum) from the stream. Notice that
the zlib source mentions this only as a undocumented feature.</p><h4>inflateReset/1</h4><p>&gt;Reset the inflate session.</p><p>Equivalent to
<a href="#inflateEnd/1">inflateEnd/1</a>
followed by
<a href="#inflateInit/1">inflateInit/1</a>,
but does not free and reallocate all the internal decompression state.
The stream will keep attributes that could have been set by
<strong>inflateInit/1,2</strong>.</p><h4>inflateSetDictionary/2</h4><p>Initialize the decompression dictionary.</p><p>Initializes the decompression dictionary from the specified
uncompressed byte sequence. This function must be called as a
response to an inflate operation (eg.
<a href="#safeInflate/2">safeInflate/2</a>)
returning <strong>{need_dictionary,Adler,Output}</strong> or in the case of
deprecated functions, throwing an
<strong>{'EXIT',{{need_dictionary,Adler},_StackTrace}}</strong> exception.</p><p>The dictionary chosen by the compressor can be determined from the
Adler value returned or thrown by the call to the inflate function.
The compressor and decompressor must use the same dictionary (See
<a href="#deflateSetDictionary/2">deflateSetDictionary/2</a>).</p><p>After setting the dictionary the inflate operation should be
retried without new input.</p><p>Example:</p><pre>
deprecated_unpack(Z, Compressed, Dict) -&gt;
     case catch zlib:inflate(Z, Compressed) of
          {'EXIT',{{need_dictionary,_DictID},_}} -&gt;
                 ok = zlib:inflateSetDictionary(Z, Dict),
                 Uncompressed = zlib:inflate(Z, []);
          Uncompressed -&gt;
                 Uncompressed
     end.

new_unpack(Z, Compressed, Dict) -&gt;
    case zlib:inflate(Z, Compressed, [{exception_on_need_dict, false}]) of
        {need_dictionary, _DictId, Output} -&gt;
            ok = zlib:inflateSetDictionary(Z, Dict),
            [Output | zlib:inflate(Z, [])];
        Uncompressed -&gt;
            Uncompressed
    end.</pre><h4>open/0</h4><p>Open a stream and return a stream reference.</p><p>Opens a zlib stream.</p><h4>safeInflate/2</h4><p>Decompress data with limited output size.</p><p>Like <a href="#inflate/2">inflate/2</a>,
but returns once it has expanded beyond a small 
implementation-defined threshold. It's useful when decompressing
untrusted input which could have been maliciously crafted to expand
until the system runs out of memory.</p><p>This function returns <strong>{continue | finished, Output}</strong>, where
<span class="anno">Output</span> is the data that was decompressed in this call.
New input can be queued up on each call if desired, and the function
will return <strong>{finished, Output}</strong> once all queued data has been
decompressed.</p><p>This function can introduce some output latency (reading
input without producing any output).</p><p>If a preset dictionary is required for further decompression, this
function returns a <strong>need_dictionary</strong> tuple. See
<a href="#inflateSetDictionary/2">inflateSetDictionary/2</a>) for details.</p><p>Example:</p><pre>
walk(Compressed, Handler) -&gt;
    Z = zlib:open(),
    zlib:inflateInit(Z),
    loop(Z, Handler, zlib:safeInflate(Z, Compressed)),
    zlib:inflateEnd(Z),
    zlib:close(Z).

loop(Z, Handler, {continue, Output}) -&gt;
    Handler(Output),
    loop(Z, Handler, zlib:safeInflate(Z, []));
loop(Z, Handler, {finished, Output}) -&gt;
    Handler(Output).</pre><h4>setBufSize/2</h4><p>Set buffer size.</p><p>Sets the intermediate buffer size.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release.</p></div><h4>set_controlling_process/2</h4><p>Transfers ownership of a zlib stream.</p><p>Changes the controlling process of <strong><span class="anno">Z</span></strong> to
<strong><span class="anno">Pid</span></strong>, which must be a local process.</p><h4>uncompress/1</h4><p>Uncompress data with standard zlib functionality.</p><p>Uncompresses data with zlib headers and checksum.</p><h4>unzip/1</h4><p>Uncompress data without the zlib headers.</p><p>Uncompresses data without zlib headers and checksum.</p><h4>zip/1</h4><p>Compress data without the zlib headers.</p><p>Compresses data without zlib headers and checksum.</p></body></html>