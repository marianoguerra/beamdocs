<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>atomics</h1><h1>atomics</h1><p>Atomic Functions</p><p>This module provides a set of functions to do atomic operations towards
mutable atomic variables. The implementation utilizes only
atomic hardware instructions without any software level locking, which makes
it very efficient for concurrent access. The atomics are organized into
arrays with the following semantics:<ul><li> <p>Atomics are 64 bit integers.</p> </li><li> <p>Atomics can be represented as either signed or unsigned.</p> </li><li> <p>Atomics wrap around at overflow and underflow operations.</p> </li><li> <p>All operations guarantee atomicity. No intermediate results can be
seen. The result of one mutation can only be the input to one
following mutation.</p> </li><li> <p>All atomic operations are mutually ordered. If atomic B is updated
<em>after</em> atomic A, then that is how it will appear to any
concurrent readers. No one can read the new value of B and then read the
old value of A.</p> </li><li> <p>Indexes into atomic arrays are one-based. An atomic array of
arity N contains N atomics with index from 1 to N.</p> </li></ul></p><h1>Data Types</h1><span class="name">atomics_ref</span><p>Identifies an atomic array returned from
<a href="#new/2">new/2</a>.</p><h1>Functions</h1><h2>new/2</h2><p>Create atomic array</p><p>Create a new atomic array of <strong><span class="anno">Arity</span></strong> atomics.</p><p>Argument <strong><span class="anno">Opts</span></strong> is a list of the following possible
options:</p><dl><dt><strong>{signed, boolean()}</strong></dt><dd><p>Indicate if the elements of the array will be treated
as signed or unsigned integers. Default is <strong>true</strong> (signed).</p> <p>The integer interval for signed atomics are from <strong>-(1 bsl 63)</strong>
to <strong>(1 bsl 63)-1</strong> and for unsigned atomics from <strong>0</strong> to <strong>(1 bsl 64)-1</strong>.</p> </dd></dl><p>Atomics are not tied to the current process and are automatically
garbage collected when they are no longer referenced.</p><h2>put/3</h2><p>Set atomic value</p><p>Set atomic to <strong><span class="anno">Value</span></strong>.</p><h2>get/2</h2><p>Read atomic value</p><p>Read atomic value.</p><h2>add/3</h2><p>Add to atomic</p><p>Add <strong><span class="anno">Incr</span></strong> to atomic.</p><h2>add_get/3</h2><p>Atomic add and get</p><p>Atomic addition and return of the result.</p><h2>sub/3</h2><p>Subtract from atomic</p><p>Subtract <strong><span class="anno">Decr</span></strong> from atomic.</p><h2>sub_get/3</h2><p>Atomic sub and get</p><p>Atomic subtraction and return of the result.</p><h2>exchange/3</h2><p>Atomic exchange.</p><p>Atomically replaces the value of the atomic with
<strong><span class="anno">Desired</span></strong> and returns the value it held
previously.</p><h2>compare_exchange/4</h2><p>Atomic compare and exchange.</p><p>Atomically compares the atomic with <strong><span class="anno">Expected</span></strong>,
and if those are equal, set atomic to <strong><span class="anno">Desired</span></strong>.
Returns <strong>ok</strong> if <strong><span class="anno">Desired</span></strong> was written. Returns
the actual atomic value if not equal to <strong><span class="anno">Expected</span></strong>.</p><h2>info/1</h2><p>Get information about atomic array.</p><p>Return information about an atomic array in a map. The map
has the following keys:</p><dl><dt><strong>size</strong></dt><dd><p>The number of atomics in the array.</p></dd><dt><strong>max</strong></dt><dd><p>The highest possible value an atomic in this array can
hold.</p></dd><dt><strong>min</strong></dt><dd><p>The lowest possible value an atomic in this array can
hold.</p></dd><dt><strong>memory</strong></dt><dd><p>Approximate memory consumption for the array in
bytes.</p></dd></dl></body></html>