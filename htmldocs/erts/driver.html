<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>How to Implement a Driver</h1><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This section was written a long time ago. Most of it is still
valid, as it explains important concepts, but this was
written for an older driver interface so the examples do not
work anymore. The reader is encouraged to read the
<a href="erl_driver">erl_driver</a> and
<a href="driver_entry">driver_entry</a>
documentation also.</p></div><h2>Introduction</h2><p>This section describes how to build your own driver for Erlang.</p><p>A driver in Erlang is a library written in C, which is linked to
the Erlang emulator and called from Erlang. Drivers can be used
when C is more suitable than Erlang, to speed up things, or to
provide access to OS resources not directly accessible from Erlang.</p><p>A driver can be dynamically loaded, as a shared library (known as
a DLL on Windows), or statically loaded, linked with the emulator
when it is compiled and linked. Only dynamically loaded drivers
are described here, statically linked drivers are beyond the scope
of this section.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>When a driver is loaded it is executed in the context of the
emulator, shares the same memory and the same thread. This means
that all operations in the driver must be non-blocking, and that
any crash in the driver brings the whole emulator down. In short,
be careful.</p></div><h2>Sample Driver</h2><p>This section describes a simple driver for accessing a postgres
database using the libpq C client library. Postgres
is used because it is free and open source. For information on postgres,
see <a href="http://www.postgres.org">www.postgres.org</a>.</p><p>The driver is synchronous, it uses the synchronous calls of
the client library. This is only for simplicity, but not good, as it
halts the emulator while waiting for the database.
This is improved below with an asynchronous sample driver.</p><p>The code is straightforward: all
communication between Erlang and the driver
is done with <strong>port_control/3</strong>, and the
driver returns data back using the <strong>rbuf</strong>.</p><p>An Erlang driver only exports one function: the driver
entry function. This is defined with a macro,
<strong>DRIVER_INIT</strong>, which returns a pointer to a
C <strong>struct</strong> containing the entry points that are
called from the emulator. The <strong>struct</strong> defines the
entries that the emulator calls to call the driver, with
a <strong>NULL</strong> pointer for entries that are not defined
and used by the driver.</p><p>The <strong>start</strong> entry is called when the driver
is opened as a port with <strong>open_port/2</strong>. Here
we allocate memory for a user data structure.
This user data is passed every time the emulator
calls us. First we store the driver handle, as it
is needed in later calls. We allocate memory for
the connection handle that is used by LibPQ. We also
set the port to return allocated driver binaries, by
setting flag <strong>PORT_CONTROL_FLAG_BINARY</strong>, calling
<strong>set_port_control_flags</strong>. (This is because
we do not know if our data will fit in the
result buffer of <strong>control</strong>, which has a default size,
64 bytes, set up by the emulator.)</p><p>An entry <strong>init</strong> is called when
the driver is loaded. However, we do not use this, as
it is executed only once, and we want to have the
possibility of several instances of the driver.</p><p>The <strong>stop</strong> entry is called when the port
is closed.</p><p>The <strong>control</strong> entry is called from the emulator
when the Erlang code calls <strong>port_control/3</strong>,
to do the actual work. We have defined a simple set of
commands: <strong>connect</strong> to log in to the database,
<strong>disconnect</strong> to log out, and <strong>select</strong>
to send a SQL-query and get the result.
All results are returned through <strong>rbuf</strong>.
The library <strong>ei</strong> in <strong>erl_interface</strong> is
used to encode data in binary term format. The result is returned
to the emulator as binary terms, so <strong>binary_to_term</strong>
is called in Erlang to convert the result to term form.</p><p>The code is available in <strong>pg_sync.c</strong> in the
<strong>sample</strong> directory of <strong>erts</strong>.</p><p>The driver entry contains the functions that
will be called by the emulator. In this example,
only <strong>start</strong>, <strong>stop</strong>,
and <strong>control</strong> are provided:</p><pre><code class="">
/* Driver interface declarations */
static ErlDrvData start(ErlDrvPort port, char *command);
static void stop(ErlDrvData drv_data);
static int control(ErlDrvData drv_data, unsigned int command, char *buf, 
                   int len, char **rbuf, int rlen); 

static ErlDrvEntry pq_driver_entry = {
    NULL,                        /* init */
    start,
    stop,
    NULL,                        /* output */
    NULL,                        /* ready_input */
    NULL,                        /* ready_output */
    "pg_sync",                   /* the name of the driver */
    NULL,                        /* finish */
    NULL,                        /* handle */
    control,
    NULL,                        /* timeout */
    NULL,                        /* outputv */
    NULL,                        /* ready_async */
    NULL,                        /* flush */
    NULL,                        /* call */
    NULL                         /* event */
};
    </code></pre><p>We have a structure to store state needed by the driver,
in this case we only need to keep the database connection:</p><pre><code class="">
typedef struct our_data_s {
    PGconn* conn;
} our_data_t;
    </code></pre><p>The control codes that we have defined are as follows:</p><pre><code class="">
/* Keep the following definitions in alignment with the
 * defines in erl_pq_sync.erl
 */

#define DRV_CONNECT             'C'
#define DRV_DISCONNECT          'D'
#define DRV_SELECT              'S'
    </code></pre><p>This returns the driver structure. The macro
<strong>DRIVER_INIT</strong> defines the only exported function.
All the other functions are static, and will not be exported
from the library.</p><pre><code class="">
/* INITIALIZATION AFTER LOADING */

/* 
 * This is the init function called after this driver has been loaded.
 * It must *not* be declared static. Must return the address to 
 * the driver entry.
 */

DRIVER_INIT(pq_drv)
{
    return &amp;pq_driver_entry;
}
    </code></pre><p>Here some initialization is done, <strong>start</strong> is called from
<strong>open_port</strong>. The data will be passed to
<strong>control</strong> and <strong>stop</strong>.</p><pre><code class="">
/* DRIVER INTERFACE */
static ErlDrvData start(ErlDrvPort port, char *command)
{ 
    our_data_t* data;

    data = (our_data_t*)driver_alloc(sizeof(our_data_t));
    data-&gt;conn = NULL;
    set_port_control_flags(port, PORT_CONTROL_FLAG_BINARY);
    return (ErlDrvData)data;
}
    </code></pre><p>We call disconnect to log out from the database.
(This should have been done from Erlang, but just in case.)</p><pre><code class="">
static int do_disconnect(our_data_t* data, ei_x_buff* x);

static void stop(ErlDrvData drv_data)
{
    our_data_t* data = (our_data_t*)drv_data;

    do_disconnect(data, NULL);
    driver_free(data);
}
    </code></pre><p>We use the binary format only to return data to the emulator;
input data is a string parameter for <strong>connect</strong> and
<strong>select</strong>. The returned data consists of Erlang terms.</p><p>The functions <strong>get_s</strong> and
<strong>ei_x_to_new_binary</strong> are utilities that are used to
make the code shorter. <strong>get_s</strong>
duplicates the string and zero-terminates it, as the
postgres client library wants that. <strong>ei_x_to_new_binary</strong>
takes an <strong>ei_x_buff</strong> buffer, allocates a binary, and
copies the data there. This binary is returned in
<strong>*rbuf</strong>.
(Notice that this binary is freed by the emulator, not by us.)</p><pre><code class="">
static char* get_s(const char* buf, int len);
static int do_connect(const char *s, our_data_t* data, ei_x_buff* x);
static int do_select(const char* s, our_data_t* data, ei_x_buff* x);

/* As we are operating in binary mode, the return value from control
 * is irrelevant, as long as it is not negative.
 */
static int control(ErlDrvData drv_data, unsigned int command, char *buf, 
                   int len, char **rbuf, int rlen)
{
    int r;
    ei_x_buff x;
    our_data_t* data = (our_data_t*)drv_data;
    char* s = get_s(buf, len);
    ei_x_new_with_version(&amp;x);
    switch (command) {
        case DRV_CONNECT:    r = do_connect(s, data, &amp;x);  break;
        case DRV_DISCONNECT: r = do_disconnect(data, &amp;x);  break;
        case DRV_SELECT:     r = do_select(s, data, &amp;x);   break;
        default:             r = -1;        break;
    }
    *rbuf = (char*)ei_x_to_new_binary(&amp;x);
    ei_x_free(&amp;x);
    driver_free(s);
    return r;
}
    </code></pre><p><strong>do_connect</strong> is where we log in to the database. If the
connection was successful, we store the connection handle in the driver
data, and return <strong>'ok'</strong>. Otherwise, we return the error message
from postgres and store <strong>NULL</strong> in the driver data.</p><pre><code class="">
static int do_connect(const char *s, our_data_t* data, ei_x_buff* x)
{
    PGconn* conn = PQconnectdb(s);
    if (PQstatus(conn) != CONNECTION_OK) {
        encode_error(x, conn);
        PQfinish(conn);
        conn = NULL;
    } else {
        encode_ok(x);
    }
    data-&gt;conn = conn;
    return 0;
}
    </code></pre><p>If we are connected (and if the connection handle is not
<strong>NULL</strong>),
we log out from the database. We need to check if we should
encode an <strong>'ok'</strong>, as we can get here from function
<strong>stop</strong>, which does not return data to the emulator:</p><pre><code class="">
static int do_disconnect(our_data_t* data, ei_x_buff* x)
{
    if (data-&gt;conn == NULL)
        return 0;
    PQfinish(data-&gt;conn);
    data-&gt;conn = NULL;
    if (x != NULL)
        encode_ok(x);
    return 0;
}
    </code></pre><p>We execute a query and encode the result. Encoding is done in
another C module, <strong>pg_encode.c</strong>, which is also provided
as sample code.</p><pre><code class="">
static int do_select(const char* s, our_data_t* data, ei_x_buff* x)
{
   PGresult* res = PQexec(data-&gt;conn, s);
    encode_result(x, res, data-&gt;conn);
    PQclear(res);
    return 0;
}
    </code></pre><p>Here we check the result from postgres.
If it is data, we encode it as lists of lists with
column data. Everything from postgres is C strings,
so we use <strong>ei_x_encode_string</strong> to send
the result as strings to Erlang. (The head of the list
contains the column names.)</p><pre><code class="">
void encode_result(ei_x_buff* x, PGresult* res, PGconn* conn)
{
    int row, n_rows, col, n_cols;
    switch (PQresultStatus(res)) {
    case PGRES_TUPLES_OK: 
        n_rows = PQntuples(res); 
        n_cols = PQnfields(res); 
        ei_x_encode_tuple_header(x, 2);
        encode_ok(x);
        ei_x_encode_list_header(x, n_rows+1);
        ei_x_encode_list_header(x, n_cols);
        for (col = 0; col &lt; n_cols; ++col) {
            ei_x_encode_string(x, PQfname(res, col));
        }
        ei_x_encode_empty_list(x); 
        for (row = 0; row &lt; n_rows; ++row) {
            ei_x_encode_list_header(x, n_cols);
            for (col = 0; col &lt; n_cols; ++col) {
                ei_x_encode_string(x, PQgetvalue(res, row, col));
            }
            ei_x_encode_empty_list(x);
        }
        ei_x_encode_empty_list(x); 
        break; 
    case PGRES_COMMAND_OK:
        ei_x_encode_tuple_header(x, 2);
        encode_ok(x);
        ei_x_encode_string(x, PQcmdTuples(res));
        break;
    default:
        encode_error(x, conn);
        break;
    }
}
    </code></pre><h2>Compiling and Linking the Sample Driver</h2><p>The driver is to be compiled and linked to a shared
library (DLL on Windows). With gcc, this is done with
link flags <strong>-shared</strong> and <strong>-fpic</strong>.
As we use the <strong>ei</strong> library, we should include
it too. There are several versions of <strong>ei</strong>, compiled
for debug or non-debug and multi-threaded or single-threaded.
In the makefile for the samples, the <strong>obj</strong> directory
is used for the <strong>ei</strong> library, meaning that we use
the non-debug, single-threaded version.</p><h2>Calling a Driver as a Port in Erlang</h2><p>Before a driver can be called from Erlang, it must be
loaded and opened. Loading is done using the <strong>erl_ddll</strong>
module (the <strong>erl_ddll</strong> driver that loads dynamic
driver is actually a driver itself). If loading is successfull,
the port can be opened with <strong>open_port/2</strong>. The port
name must match the name of the shared library and
the name in the driver entry structure.</p><p>When the port has been opened, the driver can be called. In
the <strong>pg_sync</strong> example, we do not have any data from
the port, only the return value from the
<strong>port_control</strong>.</p><p>The following code is the Erlang part of the synchronous
postgres driver, <strong>pg_sync.erl</strong>:</p><pre><code class="">
-module(pg_sync).

-define(DRV_CONNECT, 1).
-define(DRV_DISCONNECT, 2).
-define(DRV_SELECT, 3).

-export([connect/1, disconnect/1, select/2]).

connect(ConnectStr) -&gt;
    case erl_ddll:load_driver(".", "pg_sync") of
        ok -&gt; ok;
        {error, already_loaded} -&gt; ok;
        E -&gt; exit({error, E})
    end,
    Port = open_port({spawn, ?MODULE}, []),
    case binary_to_term(port_control(Port, ?DRV_CONNECT, ConnectStr)) of
        ok -&gt; {ok, Port};
        Error -&gt; Error
    end.

disconnect(Port) -&gt;
    R = binary_to_term(port_control(Port, ?DRV_DISCONNECT, "")),
    port_close(Port),
    R.

select(Port, Query) -&gt;
    binary_to_term(port_control(Port, ?DRV_SELECT, Query)).
    </code></pre><p>The API is simple:</p><ul><li> <p><strong>connect/1</strong> loads the driver, opens it,
and logs on to the database, returning the Erlang port
if successful.</p> </li><li> <p><strong>select/2</strong> sends a query to the driver
and returns the result.</p> </li><li> <p><strong>disconnect/1</strong> closes the database
connection and the driver. (However, it does not unload it.)</p> </li></ul><p>The connection string is to be a connection string for postgres.</p><p>The driver is loaded with <strong>erl_ddll:load_driver/2</strong>.
If this is successful, or if it is already loaded,
it is opened. This will call the <strong>start</strong> function
in the driver.</p><p>We use the <strong>port_control/3</strong> function for all
calls into the driver. The result from the driver is
returned immediately and converted to terms by calling
<strong>binary_to_term/1</strong>. (We trust that the terms returned
from the driver are well-formed, otherwise the
<strong>binary_to_term</strong> calls could be contained in a
<strong>catch</strong>.)</p><h2>Sample Asynchronous Driver</h2><p>Sometimes database queries can take a long time to
complete, in our <strong>pg_sync</strong> driver, the emulator
halts while the driver is doing its job. This is
often not acceptable, as no other Erlang process
gets a chance to do anything. To improve on our
postgres driver, we re-implement it using the asynchronous
calls in LibPQ.</p><p>The asynchronous version of the driver is in the sample files
<strong>pg_async.c</strong> and <strong>pg_asyng.erl</strong>.</p><pre><code class="">
/* Driver interface declarations */
static ErlDrvData start(ErlDrvPort port, char *command);
static void stop(ErlDrvData drv_data);
static int control(ErlDrvData drv_data, unsigned int command, char *buf, 
                   int len, char **rbuf, int rlen); 
static void ready_io(ErlDrvData drv_data, ErlDrvEvent event);

static ErlDrvEntry pq_driver_entry = {
    NULL,                     /* init */
    start, 
    stop, 
    NULL,                     /* output */
    ready_io,                 /* ready_input */
    ready_io,                 /* ready_output */ 
    "pg_async",               /* the name of the driver */
    NULL,                     /* finish */
    NULL,                     /* handle */
    control, 
    NULL,                     /* timeout */
    NULL,                     /* outputv */
    NULL,                     /* ready_async */
    NULL,                     /* flush */
    NULL,                     /* call */
    NULL                      /* event */
};

typedef struct our_data_t {
    PGconn* conn;
    ErlDrvPort port;
    int socket;
    int connecting;
} our_data_t;
    </code></pre><p>Some things have changed from <strong>pg_sync.c</strong>: we use
the entry <strong>ready_io</strong> for <strong>ready_input</strong>
and <strong>ready_output</strong>, which is called from the emulator
only when there is input to be read from the socket. (Actually, the
socket is used in a <strong>select</strong> function inside
the emulator, and when the socket is signaled,
indicating there is data to read, the <strong>ready_input</strong>
entry is called. More about this below.)</p><p>Our driver data is also extended, we keep track of the
socket used for communication with postgres, and also
the port, which is needed when we send data to the port with
<strong>driver_output</strong>. We have a flag
<strong>connecting</strong> to tell
whether the driver is waiting for a connection or waiting
for the result of a query. (This is needed, as the entry
<strong>ready_io</strong> is called both when connecting and
when there is a query result.)</p><pre><code class="">
static int do_connect(const char *s, our_data_t* data)
{
    PGconn* conn = PQconnectStart(s);
    if (PQstatus(conn) == CONNECTION_BAD) {
        ei_x_buff x;
        ei_x_new_with_version(&amp;x);
        encode_error(&amp;x, conn);
        PQfinish(conn);
        conn = NULL;
        driver_output(data-&gt;port, x.buff, x.index);
        ei_x_free(&amp;x);
    }
    PQconnectPoll(conn);
    int socket = PQsocket(conn);
    data-&gt;socket = socket;
    driver_select(data-&gt;port, (ErlDrvEvent)socket, DO_READ, 1);
    driver_select(data-&gt;port, (ErlDrvEvent)socket, DO_WRITE, 1);
    data-&gt;conn = conn;
    data-&gt;connecting = 1;
    return 0;
}
    </code></pre><p>The <strong>connect</strong> function looks a bit different too. We
connect using the asynchronous <strong>PQconnectStart</strong> function.
After the connection is started, we retrieve the socket for the connection
with <strong>PQsocket</strong>. This socket is used with the
<strong>driver_select</strong> function to wait for connection. When
the socket is ready for input or for output, the
<strong>ready_io</strong> function is called.</p><p>Notice that we only return data (with <strong>driver_output</strong>)
if there
is an error here, otherwise we wait for the connection to be completed,
in which case our <strong>ready_io</strong> function is called.</p><pre><code class="">
static int do_select(const char* s, our_data_t* data)
{
    data-&gt;connecting = 0;
    PGconn* conn = data-&gt;conn;
    /* if there's an error return it now */
    if (PQsendQuery(conn, s) == 0) {
        ei_x_buff x;
        ei_x_new_with_version(&amp;x);
        encode_error(&amp;x, conn);
        driver_output(data-&gt;port, x.buff, x.index);
        ei_x_free(&amp;x);
    }
    /* else wait for ready_output to get results */
    return 0;
}
    </code></pre><p>The <strong>do_select</strong> function initiates a select, and returns
if there is no immediate error. The result is returned
when <strong>ready_io</strong> is called.</p><pre><code class="">
static void ready_io(ErlDrvData drv_data, ErlDrvEvent event)
{
    PGresult* res = NULL;
    our_data_t* data = (our_data_t*)drv_data;
    PGconn* conn = data-&gt;conn;
    ei_x_buff x;
    ei_x_new_with_version(&amp;x);
    if (data-&gt;connecting) {
        ConnStatusType status;
        PQconnectPoll(conn);
        status = PQstatus(conn);
        if (status == CONNECTION_OK)
            encode_ok(&amp;x);
        else if (status == CONNECTION_BAD)
            encode_error(&amp;x, conn);
    } else {
        PQconsumeInput(conn);
        if (PQisBusy(conn))
            return;
        res = PQgetResult(conn);
        encode_result(&amp;x, res, conn);
        PQclear(res);
        for (;;) {
            res = PQgetResult(conn);
            if (res == NULL)
                break;
            PQclear(res);
        }
    }
    if (x.index &gt; 1) {
        driver_output(data-&gt;port, x.buff, x.index);
        if (data-&gt;connecting) 
            driver_select(data-&gt;port, (ErlDrvEvent)data-&gt;socket, DO_WRITE, 0);
    }
    ei_x_free(&amp;x);
}
    </code></pre><p>The <strong>ready_io</strong> function is called when the socket
we got from postgres is ready for input or output. Here
we first check if we are connecting to the database. In that
case, we check connection status and return OK if the 
connection is successful, or error if it is not. If the
connection is not yet established, we simply return;
<strong>ready_io</strong> is called again.</p><p>If we have a result from a connect, indicated by having data in
the <strong>x</strong> buffer, we no longer need to select on
output (<strong>ready_output</strong>), so we remove this by calling
<strong>driver_select</strong>.</p><p>If we are not connecting, we wait for results from a
<strong>PQsendQuery</strong>, so we get the result and return it. The
encoding is done with the same functions as in the earlier
example.</p><p>Error handling is to be added here, for example, checking
that the socket is still open, but this is only a simple example.</p><p>The Erlang part of the asynchronous driver consists of the
sample file <strong>pg_async.erl</strong>.</p><pre><code class="">
-module(pg_async).

-define(DRV_CONNECT, $C).
-define(DRV_DISCONNECT, $D).
-define(DRV_SELECT, $S).

-export([connect/1, disconnect/1, select/2]).

connect(ConnectStr) -&gt;
    case erl_ddll:load_driver(".", "pg_async") of
        ok -&gt; ok;
        {error, already_loaded} -&gt; ok;
        _ -&gt; exit({error, could_not_load_driver})
    end,
    Port = open_port({spawn, ?MODULE}, [binary]),
    port_control(Port, ?DRV_CONNECT, ConnectStr),
    case return_port_data(Port) of
        ok -&gt; 
            {ok, Port};
        Error -&gt;
            Error
    end.    

disconnect(Port) -&gt;
    port_control(Port, ?DRV_DISCONNECT, ""),
    R = return_port_data(Port),
    port_close(Port),
    R.

select(Port, Query) -&gt;
    port_control(Port, ?DRV_SELECT, Query),
    return_port_data(Port).

return_port_data(Port) -&gt;
    receive
        {Port, {data, Data}} -&gt;
            binary_to_term(Data)
    end.
    </code></pre><p>The Erlang code is slightly different, as we do not
return the result synchronously from <strong>port_control</strong>,
instead we get it from <strong>driver_output</strong> as data in the
message queue. The function <strong>return_port_data</strong> above
receives data from the port. As the data is in
binary format, we use <strong>binary_to_term/1</strong> to convert
it to an Erlang term. Notice that the driver is opened in
binary mode (<strong>open_port/2</strong> is called with option
<strong>[binary]</strong>). This means that data sent from the driver
to the emulator is sent as binaries. Without option
<strong>binary</strong>, they would have been lists of integers.</p><h2>An Asynchronous Driver Using driver_async</h2><p>As a final example we demonstrate the use of
<strong>driver_async</strong>.
We also use the driver term interface. The driver is written
in C++. This enables us to use an algorithm from STL. We use
the <strong>next_permutation</strong> algorithm to get the next
permutation of a list of integers. For large lists (&gt; 100,000
elements), this takes some time, so we perform this
as an asynchronous task.</p><p>The asynchronous API for drivers is complicated. First,
the work must be prepared. In the example, this is done in
<strong>output</strong>. We could have used <strong>control</strong>,
but we want some variation in the examples. In our driver, we allocate
a structure that contains anything that is needed for the asynchronous
task to do the work. This is done in the main emulator thread.
Then the asynchronous function is called from a driver thread,
separate from the main emulator thread. Notice that the driver functions
are not re-entrant, so they are not to be used.
Finally, after the function is completed, the driver callback
<strong>ready_async</strong> is called from the main emulator thread,
this is where we return the result to Erlang. (We cannot
return the result from within the asynchronous function, as
we cannot call the driver functions.)</p><p>The following code is from the sample file
<strong>next_perm.cc</strong>. The driver entry looks like before,
but also contains the callback <strong>ready_async</strong>.</p><pre><code class="">
static ErlDrvEntry next_perm_driver_entry = {
    NULL,                        /* init */
    start,
    NULL,                        /* stop */
    output,
    NULL,                        /* ready_input */
    NULL,                        /* ready_output */ 
    "next_perm",                 /* the name of the driver */
    NULL,                        /* finish */
    NULL,                        /* handle */
    NULL,                        /* control */
    NULL,                        /* timeout */
    NULL,                        /* outputv */
    ready_async,
    NULL,                        /* flush */
    NULL,                        /* call */
    NULL                         /* event */
};
    </code></pre><p>The <strong>output</strong> function allocates the work area of the
asynchronous function. As we use C++, we use a struct,
and stuff the data in it. We must copy the original data,
it is not valid after we have returned from the <strong>output</strong>
function, and the <strong>do_perm</strong> function is called
later, and from another thread. We return no data here, instead it
is sent later from the <strong>ready_async</strong> callback.</p><p>The <strong>async_data</strong> is passed to the
<strong>do_perm</strong> function. We do not use a
<strong>async_free</strong> function (the last argument to
<strong>driver_async</strong>), it is only used if the task is cancelled
programmatically.</p><pre><code class="">
struct our_async_data {
    bool prev;
    vector&lt;int&gt; data;
    our_async_data(ErlDrvPort p, int command, const char* buf, int len);
};

our_async_data::our_async_data(ErlDrvPort p, int command,
                               const char* buf, int len)
    : prev(command == 2),
      data((int*)buf, (int*)buf + len / sizeof(int))
{
}

static void do_perm(void* async_data);

static void output(ErlDrvData drv_data, char *buf, int len)
{
    if (*buf &lt; 1 || *buf &gt; 2) return;
    ErlDrvPort port = reinterpret_cast&lt;ErlDrvPort&gt;(drv_data);
    void* async_data = new our_async_data(port, *buf, buf+1, len);
    driver_async(port, NULL, do_perm, async_data, do_free);
}
    </code></pre><p>In the <strong>do_perm</strong> we do the work, operating
on the structure that was allocated in <strong>output</strong>.</p><pre><code class="">
static void do_perm(void* async_data)
{
    our_async_data* d = reinterpret_cast&lt;our_async_data*&gt;(async_data);
    if (d-&gt;prev)
        prev_permutation(d-&gt;data.begin(), d-&gt;data.end());
    else
        next_permutation(d-&gt;data.begin(), d-&gt;data.end());
}
    </code></pre><p>In the <strong>ready_async</strong> function the output is sent back
to the
emulator. We use the driver term format instead of <strong>ei</strong>.
This is the only way to send Erlang terms directly to a driver, without
having the Erlang code to call <strong>binary_to_term/1</strong>. In
the simple example this works well, and we do not need to use
<strong>ei</strong> to handle the binary term format.</p><p>When the data is returned, we deallocate our data.</p><pre><code class="">
static void ready_async(ErlDrvData drv_data, ErlDrvThreadData async_data)
{
    ErlDrvPort port = reinterpret_cast&lt;ErlDrvPort&gt;(drv_data);
    our_async_data* d = reinterpret_cast&lt;our_async_data*&gt;(async_data);
    int n = d-&gt;data.size(), result_n = n*2 + 3;
    ErlDrvTermData *result = new ErlDrvTermData[result_n], *rp = result;
    for (vector&lt;int&gt;::iterator i = d-&gt;data.begin();
         i != d-&gt;data.end(); ++i) {
        *rp++ = ERL_DRV_INT;
        *rp++ = *i;
    }
    *rp++ = ERL_DRV_NIL;
    *rp++ = ERL_DRV_LIST;
    *rp++ = n+1;
    driver_output_term(port, result, result_n);    
    delete[] result;
    delete d;
}
    </code></pre><p>This driver is called like the others from Erlang. However, as
we use <strong>driver_output_term</strong>, there is no need to call
<strong>binary_to_term</strong>. The Erlang code is in the sample file
<strong>next_perm.erl</strong>.</p><p>The input is changed into a list of integers and sent to
the driver.</p><pre><code class="">
-module(next_perm).

-export([next_perm/1, prev_perm/1, load/0, all_perm/1]).

load() -&gt;
    case whereis(next_perm) of
        undefined -&gt;
            case erl_ddll:load_driver(".", "next_perm") of
                ok -&gt; ok;
                {error, already_loaded} -&gt; ok;
                E -&gt; exit(E)
            end,
            Port = open_port({spawn, "next_perm"}, []),
            register(next_perm, Port);
        _ -&gt;
            ok
    end.

list_to_integer_binaries(L) -&gt;
    [&lt;&lt;I:32/integer-native&gt;&gt; || I &lt;- L].

next_perm(L) -&gt;
    next_perm(L, 1).

prev_perm(L) -&gt;
    next_perm(L, 2).

next_perm(L, Nxt) -&gt;
    load(),
    B = list_to_integer_binaries(L),
    port_control(next_perm, Nxt, B),
    receive
        Result -&gt;
            Result
    end.

all_perm(L) -&gt;
    New = prev_perm(L),
    all_perm(New, L, [New]).

all_perm(L, L, Acc) -&gt;
    Acc;
all_perm(L, Orig, Acc) -&gt;
    New = prev_perm(L),
    all_perm(New, Orig, [New | Acc]).
    </code></pre></body></html>