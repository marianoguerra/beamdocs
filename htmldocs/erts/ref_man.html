<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>ERTS Reference Manual</h1><h2>atomics</h2><p>Atomic Functions</p><p>This module provides a set of functions to do atomic operations towards
mutable atomic variables. The implementation utilizes only
atomic hardware instructions without any software level locking, which makes
it very efficient for concurrent access. The atomics are organized into
arrays with the following semantics:<ul><li> <p>Atomics are 64 bit integers.</p> </li><li> <p>Atomics can be represented as either signed or unsigned.</p> </li><li> <p>Atomics wrap around at overflow and underflow operations.</p> </li><li> <p>All operations guarantee atomicity. No intermediate results can be
seen. The result of one mutation can only be the input to one
following mutation.</p> </li><li> <p>All atomic operations are mutually ordered. If atomic B is updated
<em>after</em> atomic A, then that is how it will appear to any
concurrent readers. No one can read the new value of B and then read the
old value of A.</p> </li><li> <p>Indexes into atomic arrays are one-based. An atomic array of
arity N contains N atomics with index from 1 to N.</p> </li></ul></p><h2>Data Types</h2><span class="name">atomics_ref</span><p>Identifies an atomic array returned from
<a href="#new/2">new/2</a>.</p><h2>Functions</h2><h3>new/2</h3><p>Create atomic array</p><p>Create a new atomic array of <strong><span class="anno">Arity</span></strong> atomics.</p><p>Argument <strong><span class="anno">Opts</span></strong> is a list of the following possible
options:</p><dl><dt><strong>{signed, boolean()}</strong></dt><dd><p>Indicate if the elements of the array will be treated
as signed or unsigned integers. Default is <strong>true</strong> (signed).</p> <p>The integer interval for signed atomics are from <strong>-(1 bsl 63)</strong>
to <strong>(1 bsl 63)-1</strong> and for unsigned atomics from <strong>0</strong> to <strong>(1 bsl 64)-1</strong>.</p> </dd></dl><p>Atomics are not tied to the current process and are automatically
garbage collected when they are no longer referenced.</p><h3>put/3</h3><p>Set atomic value</p><p>Set atomic to <strong><span class="anno">Value</span></strong>.</p><h3>get/2</h3><p>Read atomic value</p><p>Read atomic value.</p><h3>add/3</h3><p>Add to atomic</p><p>Add <strong><span class="anno">Incr</span></strong> to atomic.</p><h3>add_get/3</h3><p>Atomic add and get</p><p>Atomic addition and return of the result.</p><h3>sub/3</h3><p>Subtract from atomic</p><p>Subtract <strong><span class="anno">Decr</span></strong> from atomic.</p><h3>sub_get/3</h3><p>Atomic sub and get</p><p>Atomic subtraction and return of the result.</p><h3>exchange/3</h3><p>Atomic exchange.</p><p>Atomically replaces the value of the atomic with
<strong><span class="anno">Desired</span></strong> and returns the value it held
previously.</p><h3>compare_exchange/4</h3><p>Atomic compare and exchange.</p><p>Atomically compares the atomic with <strong><span class="anno">Expected</span></strong>,
and if those are equal, set atomic to <strong><span class="anno">Desired</span></strong>.
Returns <strong>ok</strong> if <strong><span class="anno">Desired</span></strong> was written. Returns
the actual atomic value if not equal to <strong><span class="anno">Expected</span></strong>.</p><h3>info/1</h3><p>Get information about atomic array.</p><p>Return information about an atomic array in a map. The map
has the following keys:</p><dl><dt><strong>size</strong></dt><dd><p>The number of atomics in the array.</p></dd><dt><strong>max</strong></dt><dd><p>The highest possible value an atomic in this array can
hold.</p></dd><dt><strong>min</strong></dt><dd><p>The lowest possible value an atomic in this array can
hold.</p></dd><dt><strong>memory</strong></dt><dd><p>Approximate memory consumption for the array in
bytes.</p></dd></dl><h2>counters</h2><p>Counter Functions</p><p>This module provides a set of functions to do operations towards
shared mutable counter variables. The implementation does not utilize any
software level locking, which makes it very efficient for concurrent
access. The counters are organized into arrays with the following
semantics:<ul><li> <p>Counters are 64 bit signed integers.</p> </li><li> <p>Counters wrap around at overflow and underflow operations.</p> </li><li><p>Counters are initialized to zero and can then only be written to
by adding or subtracting.</p> </li><li> <p>Write operations guarantee atomicity. No intermediate results can be
seen from a single write operation.</p> </li><li> <p>Two types of counter arrays can be created with options <strong>atomics</strong> or
<strong>write_concurrency</strong>. The <strong>atomics</strong> counters have good allround
performance with nice consistent semantics while
<strong>write_concurrency</strong> counters offers even better concurrent
write performance at the expense of some potential read
inconsistencies. See <a href="#new/2">new/2</a>.</p> </li><li> <p>Indexes into counter arrays are one-based. A counter array of
size N contains N counters with index from 1 to N.</p> </li></ul></p><h2>Data Types</h2><span class="name">counters_ref</span><p>Identifies a counter array returned from
<a href="#new/2">new/2</a>.</p><h2>Functions</h2><h3>new/2</h3><p>Create counter array</p><p>Create a new counter array of <strong><span class="anno">Size</span></strong> counters.</p><p>Argument <strong><span class="anno">Opts</span></strong> is a list of the following possible
options:</p><dl><dt><strong>atomics</strong> (Default)</dt><dd><p>Counters will be sequentially consistent. If write
operation A is done sequentially before write operation B, then a concurrent reader
may see none of them, only A, or both A and B. It cannot see only B.</p> </dd><dt><strong>write_concurrency</strong></dt><dd><p>This is an optimization to achieve very efficient concurrent
<a href="#add/3">add/3</a> and <a href="#sub/3">sub/3</a> operations at the expense of potential read
inconsistency and memory consumption per counter.</p> <p>Read operations may see sequentially inconsistent results with
regard to concurrent write operations. Even if write operation A is done
sequentially before write operation B, a concurrent reader may see any
combination of A and B, including only B. A read operation is only
guaranteed to see all writes done sequentially before the read. No writes
are ever lost, but will eventually all be seen.</p> <p>The typical use case for <strong>write_concurrency</strong> is when
concurrent calls to <a href="#add/3">add/3</a> and
<a href="#sub/3">sub/3</a> toward the same counters
are very frequent, while calls to <a href="#get/2">get/2</a> and <a href="#put/3">put/3</a> are much
less frequent. The lack of absolute read consistency must also be
acceptable.</p> </dd></dl><p>Counters are not tied to the current process and are automatically
garbage collected when they are no longer referenced.</p><h3>get/2</h3><p>Read counter value</p><p>Read counter value.</p><h3>add/3</h3><p>Add to counter</p><p>Add <strong><span class="anno">Incr</span></strong> to counter at index
<strong><span class="anno">Ix</span></strong>.</p><h3>sub/3</h3><p>Subtract from counter</p><p>Subtract <strong><span class="anno">Decr</span></strong> from counter at index
<strong><span class="anno">Ix</span></strong>.</p><h3>put/3</h3><p>Set counter to value</p><p>Write <strong><span class="anno">Value</span></strong> to counter at index
<strong><span class="anno">Ix</span></strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Despite its name, the <strong>write_concurrency</strong> optimization does not
improve <strong>put</strong>. A call to <strong>put</strong> is a relatively heavy
operation compared to the very lightweight and scalable <a href="#add/3">add/3</a> and <a href="#sub/3">sub/3</a>. The cost for a <strong>put</strong> with
<strong>write_concurrency</strong> is like a <a href="#get/2">get/2</a> plus a <strong>put</strong> without <strong>write_concurrency</strong>.</p></div><h3>info/1</h3><p>Get information about counter array.</p><p>Return information about a counter array in a map. The map
has the following keys (at least):</p><dl><dt><strong>size</strong></dt><dd><p>The number of counters in the array.</p></dd><dt><strong>memory</strong></dt><dd><p>Approximate memory consumption for the array in
bytes.</p></dd></dl><h2>driver_entry</h2><p>The driver-entry structure used by Erlang drivers.</p><p><a name="WARNING"></a>As from ERTS 5.9 (Erlang/OTP R15B) the driver interface
has been changed with larger types for the callbacks
<a href="#output">output</a>,
<a href="#control">control</a>, and
<a href="#call">call</a>.
See driver <a href="./erl_driver#version_management"> version management</a> in
<a href="erl_driver">erl_driver</a>.The <strong>driver_entry</strong> structure is a C struct that all Erlang
drivers define. It contains entry points for the Erlang driver,
which are called by the Erlang emulator when Erlang code accesses
the driver.<a name="emulator"></a>
The <a href="erl_driver">erl_driver</a> driver
API functions need a port handle
that identifies the driver instance (and the port in the
emulator). This is only passed to the <strong>start</strong> function, but
not to the other functions. The <strong>start</strong> function returns a
driver-defined handle that is passed to the other functions. A
common practice is to have the <strong>start</strong> function allocate
some application-defined structure and stash the <strong>port</strong>
handle in it, to use it later with the driver API functions.The driver callback functions are called synchronously from the
Erlang emulator. If they take too long before completing, they
can cause time-outs in the emulator. Use the queue or
asynchronous calls if necessary, as the emulator must be
responsive.The driver structure contains the driver name and some
15 function pointers, which are called at different
times by the emulator.The only exported function from the driver is
<strong>driver_init</strong>. This function returns the <strong>driver_entry</strong>
structure that points to the other functions in the driver. The
<strong>driver_init</strong> function is declared with a macro,
<strong>DRIVER_INIT(drivername)</strong>. (This is because different
operating systems have different names for it.)When writing a driver in C++, the driver entry is to be of
<strong>"C"</strong> linkage. One way to do this is to put the
following line somewhere before the driver entry:<pre>
extern "C" DRIVER_INIT(drivername);</pre>When the driver has passed the <strong>driver_entry</strong> over to
the emulator, the driver is <em>not</em> allowed to modify the
<strong>driver_entry</strong>.If compiling a driver for static inclusion through
<strong>--enable-static-drivers</strong>, you must define
<strong>STATIC_ERLANG_DRIVER</strong> before the <strong>DRIVER_INIT</strong> declaration.</p><h3>Data Types</h3><p><strong>ErlDrvEntry</strong></p><pre><code class="">
typedef struct erl_drv_entry {
    int (*init)(void);          /* Called at system startup for statically
                                   linked drivers, and after loading for
                                   dynamically loaded drivers */
#ifndef ERL_SYS_DRV
    ErlDrvData (*start)(ErlDrvPort port, char *command);
                                /* Called when open_port/2 is invoked,
                                   return value -1 means failure */
#else
    ErlDrvData (*start)(ErlDrvPort port, char *command, SysDriverOpts* opts);
                                /* Special options, only for system driver */
#endif
    void (*stop)(ErlDrvData drv_data);
                                /* Called when port is closed, and when the
                                   emulator is halted */
    void (*output)(ErlDrvData drv_data, char *buf, ErlDrvSizeT len);
                                /* Called when we have output from Erlang to
                                   the port */
    void (*ready_input)(ErlDrvData drv_data, ErlDrvEvent event); 
                                /* Called when we have input from one of
                                   the driver's handles */
    void (*ready_output)(ErlDrvData drv_data, ErlDrvEvent event);  
                                /* Called when output is possible to one of
                                   the driver's handles */
    char *driver_name;          /* Name supplied as command in
                                   erlang:open_port/2 */
    void (*finish)(void);       /* Called before unloading the driver -
                                   dynamic drivers only */
    void *handle;               /* Reserved, used by emulator internally */
    ErlDrvSSizeT (*control)(ErlDrvData drv_data, unsigned int command,
                            char *buf, ErlDrvSizeT len,
			    char **rbuf, ErlDrvSizeT rlen);
                                /* "ioctl" for drivers - invoked by
                                   port_control/3 */
    void (*timeout)(ErlDrvData drv_data);
                                /* Handling of time-out in driver */
    void (*outputv)(ErlDrvData drv_data, ErlIOVec *ev);
                                /* Called when we have output from Erlang
                                   to the port */
    void (*ready_async)(ErlDrvData drv_data, ErlDrvThreadData thread_data);
    void (*flush)(ErlDrvData drv_data);
                                /* Called when the port is about to be
                                   closed, and there is data in the
                                   driver queue that must be flushed
                                   before 'stop' can be called */
    ErlDrvSSizeT (*call)(ErlDrvData drv_data, unsigned int command,
                         char *buf, ErlDrvSizeT len,
			 char **rbuf, ErlDrvSizeT rlen, unsigned int *flags);
                                /* Works mostly like 'control', a synchronous
                                   call into the driver */
    void* unused_event_callback;
    int extended_marker;        /* ERL_DRV_EXTENDED_MARKER */
    int major_version;          /* ERL_DRV_EXTENDED_MAJOR_VERSION */
    int minor_version;          /* ERL_DRV_EXTENDED_MINOR_VERSION */
    int driver_flags;           /* ERL_DRV_FLAGs */
    void *handle2;              /* Reserved, used by emulator internally */
    void (*process_exit)(ErlDrvData drv_data, ErlDrvMonitor *monitor);
                                /* Called when a process monitor fires */
    void (*stop_select)(ErlDrvEvent event, void* reserved);
                                /* Called to close an event object */
 } ErlDrvEntry;</code></pre><dl><dt><a name="init"></a><strong>int (*init)(void)</strong></dt><dd>        <p>Called directly after the driver has been loaded by
<a href="../kernel/erl_ddll#load_driver/2">kernel/erl_ddll#load_driver/2</a> (actually when the driver is
added to the driver list). The driver is to return <strong>0</strong>, or, if
the driver cannot initialize, <strong>-1</strong>.</p> </dd><dt><a name="start"></a> <strong>ErlDrvData (*start)(ErlDrvPort port, char* command)</strong></dt><dd> <p>Called when the driver is instantiated, when
<a href="./erlang#open_port/2">erlang#open_port/2</a> is called.
The driver is to return a number &gt;= 0 or a pointer, or, if the
driver cannot be started, one of three error codes:</p> <dl><dt><strong>ERL_DRV_ERROR_GENERAL</strong></dt><dd>General error, no error code</dd><dt><strong>ERL_DRV_ERROR_ERRNO</strong></dt><dd>Error with error code in <strong>errno</strong></dd><dt><strong>ERL_DRV_ERROR_BADARG</strong></dt><dd>Error, <strong>badarg</strong></dd></dl> <p>If an error code is returned, the port is not started.</p> </dd><dt><a name="stop"></a><strong>void (*stop)(ErlDrvData drv_data)</strong></dt><dd> <p>Called when the port is closed, with
<a href="./erlang#port_close/1">erlang#port_close/1</a> or <strong>Port ! {self(), close}</strong>.
Notice that terminating the port owner process also closes the
port. If <strong>drv_data</strong> is a pointer to memory allocated in
<strong>start</strong>, then <strong>stop</strong> is the place to deallocate that
memory.</p> </dd><dt><a name="output"></a> <strong>void (*output)(ErlDrvData drv_data, char *buf, ErlDrvSizeT len)</strong> </dt><dd> <p>Called when an Erlang process has sent data to the port. The data is
pointed to by <strong>buf</strong>, and is <strong>len</strong> bytes. Data is sent to
the port with <strong>Port ! {self(), {command, Data}}</strong> or with
<strong>erlang:port_command/2</strong>. Depending on how the port was
opened, it is to be either a list of integers <strong>0...255</strong> or a
binary. See <a href="./erlang#open_port/2">erlang#open_port/2</a> and
<a href="./erlang#port_command/2">erlang#port_command/2</a>.</p> </dd><dt><a name="ready_input"></a> <strong>void (*ready_input)(ErlDrvData drv_data, ErlDrvEvent event)</strong> </dt><dd></dd><dt><a name="ready_output"></a> <strong>void (*ready_output)(ErlDrvData drv_data, ErlDrvEvent event)</strong> </dt><dd> <p>Called when a driver event (specified in parameter
<strong>event</strong>) is signaled. This is used to help
asynchronous drivers "wake up" when something occurs.</p> <p>On Unix the <strong>event</strong> is a pipe or socket handle (or
something that the <strong>select</strong> system call understands).</p> <p>On Windows the <strong>event</strong> is an <strong>Event</strong> or <strong>Semaphore</strong>
(or something that the <strong>WaitForMultipleObjects</strong> API
function understands). (Some trickery in the emulator allows
more than the built-in limit of 64 <strong>Events</strong> to be used.)</p> <p>To use this with threads and asynchronous routines, create a
pipe on Unix and an <strong>Event</strong> on Windows. When the routine
completes, write to the pipe (use <strong>SetEvent</strong> on
Windows), this makes the emulator call
<strong>ready_input</strong> or <strong>ready_output</strong>.</p> <p>False events can occur. That is, calls to <strong>ready_input</strong>
or <strong>ready_output</strong> although no real events are signaled. In
reality, it is rare (and OS-dependant), but a robust driver
must nevertheless be able to handle such cases.</p> </dd><dt><a name="driver_name"></a><strong>char *driver_name</strong></dt><dd> <p>The driver name. It must correspond to the atom used in
<a href="./erlang#open_port/2">erlang#open_port/2</a>, and the name of the driver
library file (without the extension).</p> </dd><dt><a name="finish"></a><strong>void (*finish)(void)</strong></dt><dd> <p>Called by the <strong>erl_ddll</strong> driver when the
driver is unloaded. (It is only called in dynamic drivers.)</p> <p>The driver is only unloaded as a result of calling
<a href="../kernel/erl_ddll#unload_driver/1">kernel/erl_ddll#unload_driver/1</a>,
or when the emulator halts.</p> </dd><dt><strong>void *handle</strong></dt><dd> <p>This field is reserved for the emulator's internal use. The
emulator will modify this field, so it is important
that the <strong>driver_entry</strong> is not declared <strong>const</strong>.</p>  </dd><dt><a name="control"></a> <strong>ErlDrvSSizeT (*control)(ErlDrvData drv_data, unsigned int command, char *buf, ErlDrvSizeT len, char **rbuf, ErlDrvSizeT rlen)</strong></dt><dd> <p>A special routine invoked with
<a href="./erlang#port_control/3">erlang#port_control/3</a>.
It works a little like an "ioctl" for
Erlang drivers. The data specified to <strong>port_control/3</strong>
arrives in <strong>buf</strong> and <strong>len</strong>. The driver can send
data back, using <strong>*rbuf</strong> and <strong>rlen</strong>.</p> <p>This is the fastest way of calling a driver and get a
response. It makes no context switch in the Erlang
emulator and requires no message passing. It is suitable
for calling C function to get faster execution, when Erlang
is too slow.</p> <p>If the driver wants to return data, it is to return it in
<strong>rbuf</strong>. When <strong>control</strong> is called,
<strong>*rbuf</strong> points to a default buffer of <strong>rlen</strong> bytes, which
can be used to return data. Data is returned differently depending on
the port control flags (those that are set with
<a href="./erl_driver#set_port_control_flags">erl_driver#set_port_control_flags</a>).</p> <p>If the flag is set to <strong>PORT_CONTROL_FLAG_BINARY</strong>,
a binary is returned. Small binaries can be returned by writing
the raw data into the default buffer. A binary can also be
returned by setting <strong>*rbuf</strong> to point to a binary allocated with
<a href="./erl_driver#driver_alloc_binary">erl_driver#driver_alloc_binary</a>.
This binary is freed automatically after <strong>control</strong> has returned.
The driver can retain the binary for <em>read only</em> access with
<a href="./erl_driver#driver_binary_inc_refc">erl_driver#driver_binary_inc_refc</a> to be freed later
with <a href="./erl_driver#driver_free_binary">erl_driver#driver_free_binary</a>.
It is never allowed to change the binary after <strong>control</strong> has
returned. If <strong>*rbuf</strong> is set to <strong>NULL</strong>, an empty list is
returned.</p> <p>If the flag is set to <strong>0</strong>, data is returned as a
list of integers. Either use the default buffer or set
<strong>*rbuf</strong> to point to a larger buffer allocated with
<a href="./erl_driver#driver_alloc">erl_driver#driver_alloc</a>. The
buffer is freed automatically after <strong>control</strong> has returned.</p> <p>Using binaries is faster if more than a few bytes are returned.</p> <p>The return value is the number of bytes returned in <strong>*rbuf</strong>.</p> </dd><dt><a name="timeout"></a><strong>void (*timeout)(ErlDrvData drv_data)</strong> </dt><dd> <p>Called any time after the driver's timer reaches <strong>0</strong>.
The timer is activated with
<a href="./erl_driver#driver_set_timer">erl_driver#driver_set_timer</a>. No priorities or
ordering exist among drivers, so if several drivers time out at
the same time, anyone of them is called first.</p> </dd><dt><a name="outputv"></a> <strong>void (*outputv)(ErlDrvData drv_data, ErlIOVec *ev)</strong></dt><dd> <p>Called whenever the port is written to. If
it is <strong>NULL</strong>, the <strong>output</strong> function is called
instead. This function is faster than <strong>output</strong>, as
it takes an <strong>ErlIOVec</strong> directly, which requires no
copying of the data. The port is to be in binary mode, see
<a href="./erlang#open_port/2">erlang#open_port/2</a>.</p> <p><strong>ErlIOVec</strong> contains both a <strong>SysIOVec</strong>,
suitable for <strong>writev</strong>, and one or more binaries. If
these binaries are to be retained when the driver returns
from <strong>outputv</strong>, they can be queued (using, for example,
<a href="./erl_driver#driver_enq_bin">erl_driver#driver_enq_bin</a>)
or, if they are kept in a static or global
variable, the reference counter can be incremented.</p> </dd><dt><a name="ready_async"></a> <strong>void (*ready_async)(ErlDrvData drv_data, ErlDrvThreadData thread_data)</strong></dt><dd> <p>Called after an asynchronous call has completed.
The asynchronous call is started with
<a href="./erl_driver#driver_async">erl_driver#driver_async</a>.
This function is called from the Erlang emulator thread, as
opposed to the asynchronous function, which is called in
some thread (if multi-threading is enabled).</p> </dd><dt><strong>void (*flush)(ErlDrvData drv_data)</strong></dt><dd> <p>Called when the port is about to be closed,
and there is data in the driver queue that must be flushed
before 'stop' can be called.</p> </dd><dt><a name="call"></a><strong>ErlDrvSSizeT (*call)(ErlDrvData drv_data, unsigned int command, char *buf, ErlDrvSizeT len, char **rbuf, ErlDrvSizeT rlen, unsigned int *flags)</strong></dt><dd> <p>Called from <a href="./erlang#port_call/3">erlang#port_call/3</a>.
It works a lot like the <strong>control</strong> callback, but uses the
external term format for input and output.</p> <p><strong>command</strong> is an integer, obtained from the call from
Erlang (the second argument to <strong>erlang:port_call/3</strong>).</p> <p><strong>buf</strong> and <strong>len</strong> provide the arguments to the call
(the third argument to <strong>erlang:port_call/3</strong>). They can
be decoded using <strong>ei</strong> functions.</p> <p><strong>rbuf</strong> points to a return buffer, <strong>rlen</strong> bytes
long. The return data is to be a valid Erlang term in the
external (binary) format. This is converted to an Erlang
term and returned by <strong>erlang:port_call/3</strong> to the
caller. If more space than <strong>rlen</strong> bytes is needed to
return data, <strong>*rbuf</strong> can be set to memory allocated with
<a href="./erl_driver#driver_alloc">erl_driver#driver_alloc</a>.
This memory is freed automatically after <strong>call</strong> has returned.</p> <p>The return value is the number of bytes returned in
<strong>*rbuf</strong>. If <strong>ERL_DRV_ERROR_GENERAL</strong> is returned
(or in fact, anything &lt; 0), <strong>erlang:port_call/3</strong>
throws a <strong>BAD_ARG</strong>.</p> </dd><dt><strong>void (*event)(ErlDrvData drv_data, ErlDrvEvent event, ErlDrvEventData event_data)</strong></dt><dd> <p>Intentionally left undocumented.</p> </dd><dt><a name="extended_marker"></a><strong>int extended_marker</strong></dt><dd> <p>This field is either to be equal to <strong>ERL_DRV_EXTENDED_MARKER</strong>
or <strong>0</strong>. An old driver (not aware of the extended driver
interface) is to set this field to <strong>0</strong>. If this field is
<strong>0</strong>, all the following fields <em>must</em> also be <strong>0</strong>,
or <strong>NULL</strong> if it is a pointer field.</p> </dd><dt><strong>int major_version</strong></dt><dd> <p>This field is to equal <strong>ERL_DRV_EXTENDED_MAJOR_VERSION</strong> if
field <strong>extended_marker</strong> equals
<strong>ERL_DRV_EXTENDED_MARKER</strong>.</p>  </dd><dt><strong>int minor_version</strong></dt><dd> <p>This field is to equal <strong>ERL_DRV_EXTENDED_MINOR_VERSION</strong> if
field <strong>extended_marker</strong> equals
<strong>ERL_DRV_EXTENDED_MARKER</strong>.</p> </dd><dt><a name="driver_flags"></a><strong>int driver_flags</strong></dt><dd> <p>This field is used to pass driver capability and other
information to the runtime system. If
field <strong>extended_marker</strong> equals <strong>ERL_DRV_EXTENDED_MARKER</strong>,
it is to contain <strong>0</strong> or driver flags (<strong>ERL_DRV_FLAG_*</strong>)
OR'ed bitwise. The following driver flags exist:</p> <dl><dt><strong>ERL_DRV_FLAG_USE_PORT_LOCKING</strong></dt><dd> <p>The runtime system uses port-level locking on
all ports executing this driver instead of driver-level
locking when the driver is run in a runtime
system with SMP support. For more information, see
<a href="./erl_driver#smp_support">erl_driver#smp_support</a>.</p> </dd><dt><strong>ERL_DRV_FLAG_SOFT_BUSY</strong></dt><dd> <p>Marks that driver instances can handle being called
in the <a href="#output">output</a> and/or
<a href="#outputv">outputv</a> callbacks
although a driver instance has marked itself as busy (see
<a href="./erl_driver#set_busy_port">erl_driver#set_busy_port</a>).
As from ERTS 5.7.4 this flag is required for drivers used
by the Erlang distribution (the behavior has always been
required by drivers used by the distribution).</p> </dd><dt><strong>ERL_DRV_FLAG_NO_BUSY_MSGQ</strong></dt><dd> <p>Disables busy port message queue functionality. For
more information, see
<a href="./erl_driver#erl_drv_busy_msgq_limits">erl_driver#erl_drv_busy_msgq_limits</a>.</p> </dd><dt><strong>ERL_DRV_FLAG_USE_INIT_ACK</strong></dt><dd> <p>When this flag is specified, the linked-in driver must manually
acknowledge that the port has been successfully started using
<a href="./erl_driver#erl_drv_init_ack">erl_driver#erl_drv_init_ack</a>.
This allows the implementor to make the
<strong>erlang:open_port</strong> exit with <strong>badarg</strong> after some
initial asynchronous initialization has been done.</p> </dd></dl> </dd><dt><strong>void *handle2</strong></dt><dd> <p>This field is reserved for the emulator's internal use. The
emulator modifies this field, so it is important
that the <strong>driver_entry</strong> is not declared <strong>const</strong>.</p> </dd><dt><a name="process_exit"></a> <strong>void (*process_exit)(ErlDrvData drv_data, ErlDrvMonitor *monitor)</strong> </dt><dd> <p>Called when a monitored process exits. The
<strong>drv_data</strong> is the data associated with the port for which
the process is monitored (using
<a href="./erl_driver#driver_monitor_process">erl_driver#driver_monitor_process</a>)
and the <strong>monitor</strong> corresponds to the <strong>ErlDrvMonitor</strong>
structure filled
in when creating the monitor. The driver interface function
<a href="./erl_driver#driver_get_monitored_process">erl_driver#driver_get_monitored_process</a>
can be used to retrieve the process ID of the exiting process as
an <strong>ErlDrvTermData</strong>.</p> </dd><dt><a name="stop_select"></a> <strong>void (*stop_select)(ErlDrvEvent event, void* reserved)</strong></dt><dd> <p>Called on behalf of
<a href="./erl_driver#driver_select">erl_driver#driver_select</a>
when it is safe to close an event object.</p> <p>A typical implementation on Unix is to do
<strong>close((int)event)</strong>.</p> <p>Argument <strong>reserved</strong> is intended for future use and is to be
ignored.</p> <p>In contrast to most of the other callback functions,
<strong>stop_select</strong> is called independent of any port. No
<strong>ErlDrvData</strong> argument is passed to the function. No
driver lock or port lock is guaranteed to be held. The port that
called <strong>driver_select</strong> can even be closed at the
time <strong>stop_select</strong> is called. But it can also be
the case that <strong>stop_select</strong> is called directly by
<strong>erl_driver:driver_select</strong>.</p> <p>It is not allowed to call any functions in the
<a href="erl_driver">driver API</a> from
<strong>stop_select</strong>. This strict limitation is because the
volatile context that <strong>stop_select</strong> can be called.</p> </dd></dl><h3>See Also</h3><p><a href="erl_driver">erl_driver</a>,
<a href="erlang">erlang</a>,
<a href="./erl_ddll">kernel/erl_ddll</a></p><h2>epmd</h2><p>Erlang Port Mapper Daemon</p><p><dl><dt><strong>epmd [-d|-debug] [DbgExtra...] [-address Addresses] [-port No] [-daemon] [-relaxed_command_check]</strong></dt><dd> <p>Starts the port mapper daemon.</p> </dd><dt><strong>epmd [-d|-debug] [-port No] [-names|-kill|-stop Name]</strong></dt><dd> <p>Communicates with a running port mapper daemon.</p> </dd></dl>This daemon acts as a name server on all hosts involved in
distributed Erlang computations. When an Erlang node starts,
the node has a name and it obtains an address from the host
OS kernel. The name and address are sent to the
<strong>epmd</strong> daemon running on the local host.
In a TCP/IP environment, the address consists
of the IP address and a port number. The node name is
an atom on the form of <strong>Name@Node</strong>.
The job of the <strong>epmd</strong> daemon is to keep track of which
node name listens on which address. Hence, <strong>epmd</strong> maps
symbolic node names to machine addresses.The TCP/IP <strong>epmd</strong> daemon only keeps track of
the <strong>Name</strong> (first) part of an Erlang node name. The <strong>Host</strong>
part (whatever is after the <strong>@</strong>) is implicit in the
node name where the <strong>epmd</strong> daemon was contacted,
as is the IP address where the Erlang node can be
reached. Consistent and correct TCP naming services are
therefore required for an Erlang network to function
correctly.<dl><dt>Starting the port mapper daemon</dt><dd> <p>The daemon is started automatically by command
<a href="erl">erl</a>
if the node is to be distributed and no running
instance is present. If automatically launched
environment variables must be used to change the behavior
of the daemon; see section
<a href="#environment_variables">Environment Variables</a>.</p> <p>If argument <strong>-daemon</strong> is not specified,
<strong>epmd</strong> runs as a normal program with the
controlling terminal of the shell in which it is
started. Normally, it is to be run as a daemon.</p> <p>Regular startup options are described in section
<a href="#daemon_flags">Regular Options</a>.</p> <p>The <strong>DbgExtra</strong> options are described in section
<a href="#debug_flags">DbgExtra Options</a>.</p> </dd><dt>Communicating with a running port mapper daemon</dt><dd> <p>Communicating with the running <strong>epmd</strong> daemon by the
<strong>epmd</strong> program is done primarily for debugging purposes.</p> <p>The different queries are described in section <a href="#interactive_flags">Interactive options</a>.</p> </dd></dl></p><a name="daemon_flags"></a><h3>Regular Options</h3><p>These options are available when starting the name server. The name
server is normally started automatically by command
<a href="erl">erl</a> (if not already available),
but it can also be started at system startup.</p><dl><dt><strong>-address List</strong></dt><dd> <p>Lets this instance of <strong>epmd</strong> listen only on the
comma-separated list of IP addresses and on the loopback address
(which is implicitly added to the list if it has not been
specified). This can also be set using environment variable
<strong>ERL_EPMD_ADDRESS</strong>; see section <a href="#environment_variables">Environment Variables</a>.</p> </dd><dt><strong>-port No</strong></dt><dd> <p>Lets this instance of <strong>epmd</strong> listen to another TCP port than
default 4369. This can also be set using environment variable
<strong>ERL_EPMD_PORT</strong>; see section <a href="#environment_variables">Environment Variables</a>.</p> </dd><dt><strong>-d | -debug</strong></dt><dd> <p>Enables debug output. The more <strong>-d</strong> flags specified, the more
debug output you will get (to a certain limit). This option is  most
useful when the <strong>epmd</strong> daemon is not started as a daemon.</p> </dd><dt><strong>-daemon</strong></dt><dd> <p>Starts <strong>epmd</strong> detached from the controlling terminal. Logging
ends up in syslog when available and correctly configured. If the
<strong>epmd</strong> daemon is started at boot, this option is definitely
to be used. It is also used when command <strong>erl</strong> automatically
starts <strong>epmd</strong>.</p> </dd><dt><strong>-relaxed_command_check</strong></dt><dd> <p>Starts the <strong>epmd</strong> program with relaxed command checking
(mostly for backward compatibility). This affects the following:</p> <ul><li> <p>With relaxed command checking, the <strong>epmd</strong> daemon can be
killed from the local host with, for example, command
<strong>epmd -kill</strong> even if active nodes are registered. Normally
only daemons with an empty node database can be killed with
<strong>epmd -kill</strong>.</p> </li><li> <p>Command <strong>epmd -stop</strong> (and the corresponding messages to
<strong>epmd</strong>, as can be specified using <a href="./ei">erl_interface/ei</a>) is
normally always ignored. This because it can cause a strange
situation where two nodes of the same name can be alive at the
same time. A node unregisters itself by only closing the
connection to <strong>epmd</strong>, which is why command <strong>stop</strong>
was only intended for use in debugging situations.</p> <p>With relaxed command checking enabled, you can forcibly
unregister live nodes.</p> </li></ul> <p>Relaxed command checking can also be enabled by setting environment
variable <strong>ERL_EPMD_RELAXED_COMMAND_CHECK</strong> before starting
<strong>epmd</strong>.</p> <p>Use relaxed command checking only on systems with very limited
interactive usage.</p> </dd></dl><a name="debug_flags"></a><h3>DbgExtra Options</h3><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>These options are only for debugging and testing <strong>epmd</strong> clients.
They are not to be used in normal operation.</p></div><dl><dt><strong>-packet_timeout Seconds</strong></dt><dd> <p>Sets the number of seconds a connection can be
inactive before <strong>epmd</strong> times out and closes the
connection. Defaults to 60.</p> </dd><dt><strong>-delay_accept Seconds</strong></dt><dd> <p>To simulate a busy server, you can insert a delay between when
<strong>epmd</strong> gets notified that a new connection is requested and
when the connection gets accepted.</p> </dd><dt><strong>-delay_write Seconds</strong></dt><dd> <p>Also a simulation of a busy server. Inserts
a delay before a reply is sent.</p> </dd></dl><a name="interactive_flags"></a><h3>Interactive Options</h3><p>These options make <strong>epmd</strong> run as an interactive command,
displaying the results of sending queries to an already running
instance of <strong>epmd</strong>. The <strong>epmd</strong> contacted is always on the
local node, but option <strong>-port</strong> can be used to select between
instances if several are running using different ports on the host.</p><dl><dt><strong>-port No</strong></dt><dd> <p>Contacts the <strong>epmd</strong> listening on the specified TCP port
number (default 4369). This can also be set using environment
variable <strong>ERL_EPMD_PORT</strong>; see section <a href="#environment_variables">Environment Variables</a>.</p> </dd><dt><strong>-names</strong></dt><dd> <p>Lists names registered with the currently running <strong>epmd</strong>.</p> </dd><dt><strong>-kill</strong></dt><dd> <p>Kills the currently running <strong>epmd</strong>.</p> <p>Killing the running <strong>epmd</strong> is only allowed if
<strong>epmd -names</strong> shows an empty database or if
<strong>-relaxed_command_check</strong> was specified when the running
instance of <strong>epmd</strong> was started.</p> <p>Notice that <strong>-relaxed_command_check</strong> is specified when
starting the daemon that is to accept killing when it has live
nodes registered. When running <strong>epmd</strong> interactively,
<strong>-relaxed_command_check</strong> has no effect. A daemon that is
started without relaxed command checking must be killed using,
for example, signals or some other OS-specific method if it has
active clients registered.</p> </dd><dt><strong>-stop Name</strong></dt><dd> <p>Forcibly unregisters a live node from the <strong>epmd</strong> database.</p> <p>This command can only be used when contacting <strong>epmd</strong>
instances started with flag <strong>-relaxed_command_check</strong>.</p> <p>Notice that relaxed command checking must enabled for the
<strong>epmd</strong> daemon contacted. When running <strong>epmd</strong>
interactively, <strong>-relaxed_command_check</strong> has no effect.</p> </dd></dl><a name="environment_variables"></a><h3>Environment Variables</h3><dl><dt><strong>ERL_EPMD_ADDRESS</strong></dt><dd> <p>Can be set to a comma-separated
list of IP addresses, in which case the <strong>epmd</strong> daemon
will listen only on the specified address(es) and on the
loopback address (which is implicitly added to the list if it
has not been specified). The default behavior is to listen on
all available IP addresses.</p> </dd><dt><strong>ERL_EPMD_PORT</strong></dt><dd> <p>Can contain the port number <strong>epmd</strong> will use.
The default port will work fine in most cases. A different port can
be specified to allow several instances of <strong>epmd</strong>, representing
independent clusters of nodes, to co-exist on the same host.
All nodes in a cluster must use the same <strong>epmd</strong> port number.</p> </dd><dt><strong>ERL_EPMD_RELAXED_COMMAND_CHECK</strong></dt><dd> <p>If set before start, the <strong>epmd</strong> daemon behaves
as if option <strong>-relaxed_command_check</strong> was specified at
startup. Consequently, if this option is set before starting
the Erlang virtual machine, the automatically started
<strong>epmd</strong> accepts the <strong>-kill</strong> and <strong>-stop</strong>
commands without restrictions.</p> </dd></dl><h3>Logging</h3><p>On some operating systems <em>syslog</em> will be used for
error reporting when <strong>epmd</strong> runs as a daemon. To enable
the error logging, you must edit the
<span class="path">/etc/syslog.conf</span> file and add an
entry:</p><pre><code class="">
  !epmd
  *.*&lt;TABs&gt;/var/log/epmd.log
</code></pre><p>where <strong>&lt;TABs&gt;</strong> are at least one real tab character.
Spaces are silently ignored.</p><h3>Access Restrictions</h3><p>The <strong>epmd</strong> daemon accepts messages from both the local host and
remote hosts. However, only the query commands are answered (and
acted upon) if the query comes from a remote host. It is always an
error to try to register a node name if the client is not a process
on the same host as the <strong>epmd</strong> instance is running on. Such
requests are considered hostile and the connection is closed
immediately.</p><p>The following queries are accepted from remote nodes:</p><ul><li> <p>Port queries, that is, on which port the node with a specified
name listens</p> </li><li> <p>Name listing, that is, gives a list of all names registered on
the host</p> </li></ul><p>To restrict access further, firewall software must be used.</p><h2>erl</h2><p>The Erlang emulator.</p><p>The <strong>erl</strong> program starts an Erlang runtime system.
The exact details (for example, whether <strong>erl</strong> is a
script or a program and which other programs it calls) are
system-dependent.Windows users probably want to use the <strong>werl</strong> program
instead, which runs in its own window with scrollbars and supports
command-line editing. The <strong>erl</strong> program on Windows
provides no line editing in its shell, and on Windows 95 there is no way
to scroll back to text that has scrolled off the screen. The
<strong>erl</strong> program must be used, however, in pipelines or if
you want to redirect standard input or output.</p><h2>Functions</h2><h3>erl &lt;arguments&gt;</h3><p>Start an Erlang runtime system.</p><p>Starts an Erlang runtime system.</p><p>The arguments can be divided into <em>emulator flags</em>,
<em>flags</em>, and <em>plain arguments</em>:</p><ul><li> <p>Any argument starting with character <strong>+</strong> is
interpreted as an
<a href="#emu_flags">emulator flag</a>.</p> <p>As indicated by the name, emulator flags control
the behavior of the emulator.</p> </li><li> <p>Any argument starting with character <strong>-</strong>
(hyphen) is interpreted as a
<a href="#init_flags">flag</a>, which is to
be passed to the Erlang part of the runtime system, more
specifically to the <strong>init</strong> system process, see
<a href="init">init</a>.</p> <p>The <strong>init</strong> process itself interprets some of
these flags, the <em>init flags</em>. It also stores any
remaining flags, the <em>user flags</em>. The latter can be
retrieved by calling <strong>init:get_argument/1</strong>.</p> <p>A small number of "-" flags exist, which now actually are
emulator flags, see the description below.</p> </li><li> <p>Plain arguments are not interpreted in any way. They are also
stored by the <strong>init</strong> process and can be retrieved
by calling <strong>init:get_plain_arguments/0</strong>.
Plain arguments can occur before the first flag, or after a
<strong>--</strong> flag. Also, the <strong>-extra</strong>
flag causes everything that follows to become plain arguments.</p> </li></ul><p><em>Examples:</em></p><pre>
% <span class="input">erl +W w -sname arnie +R 9 -s my_init -extra +bertie</span>
(arnie@host)1&gt; <span class="input">init:get_argument(sname).</span>
{ok,[["arnie"]]}
(arnie@host)2&gt; <span class="input">init:get_plain_arguments().</span>
["+bertie"]</pre><p>Here <strong>+W w</strong> and <strong>+R 9</strong> are
emulator flags. <strong>-s my_init</strong> is an init flag,
interpreted by <strong>init</strong>.
<strong>-sname arnie</strong> is a user flag, stored by
<strong>init</strong>. It is read by Kernel and causes the
Erlang runtime system to become distributed. Finally, everything after
<strong>-extra</strong> (that is, <strong>+bertie</strong>) is
considered as plain arguments.</p><pre>
% <span class="input">erl -myflag 1</span>
1&gt; <span class="input">init:get_argument(myflag).</span>
{ok,[["1"]]}
2&gt; <span class="input">init:get_plain_arguments().</span>
[]</pre><p>Here the user flag <strong>-myflag 1</strong> is passed to and
stored by the <strong>init</strong> process. It is a user-defined
flag, presumably used by some user-defined application.</p><a name="init_flags"></a><h3>Flags</h3><p>In the following list, init flags are marked "(init flag)".
Unless otherwise specified, all other flags are user flags, for
which the values can be retrieved by calling
<strong>init:get_argument/1</strong>. Notice that the list of user
flags is not exhaustive, there can be more application-specific
flags that instead are described in the corresponding
application documentation.</p><dl><dt><strong>--</strong> (init flag)</dt><dd> <p>Everything following <strong>--</strong> up to the next flag
(<strong>-flag</strong> or <strong>+flag</strong>) is considered
plain arguments and can be retrieved using
<strong>init:get_plain_arguments/0</strong>.</p> </dd><dt><strong>-Application Par Val</strong></dt><dd> <p>Sets the application configuration parameter <strong>Par</strong>
to the value <strong>Val</strong> for the application
<strong>Application</strong>; see
<a href="./app">kernel/app</a> and
<a href="./application">kernel/application</a>.</p> </dd><dt><a name="args_file"></a><strong>-args_file FileName</strong></dt><dd> <p>Command-line arguments are read from the file
<strong>FileName</strong>. The arguments read from the file replace
flag '<strong>-args_file FileName</strong>' on the resulting
command line.</p> <p>The file <strong>FileName</strong> is to be a plain text file and
can contain comments and command-line arguments. A comment begins
with a <strong>#</strong> character and continues until the next end of line
character. Backslash (\\) is used as quoting character. All
command-line arguments accepted by <strong>erl</strong> are allowed,
also flag <strong>-args_file FileName</strong>. Be careful not to
cause circular dependencies between files containing flag
<strong>-args_file</strong>, though.</p> <p>The flag <strong>-extra</strong> is treated in special way. Its
scope ends at the end of the file. Arguments following an
<strong>-extra</strong> flag are moved on the command line into the
<strong>-extra</strong> section, that is, the end of the command
line following after an <strong>-extra</strong> flag.</p> </dd><dt><strong>-async_shell_start</strong></dt><dd> <p>The initial Erlang shell does not read user input until
the system boot procedure has been completed (Erlang/OTP 5.4 and
later). This flag disables the start synchronization feature
and lets the shell start in parallel with the rest of
the system.</p> </dd><dt><strong>-boot File</strong></dt><dd> <p>Specifies the name of the boot file, <strong>File.boot</strong>,
which is used to start the system; see
<a href="init">init</a>. Unless
<strong>File</strong> contains an absolute path, the system searches
for <strong>File.boot</strong> in the current and 
<strong>$ROOT/bin</strong> directories.</p> <p>Defaults to <strong>$ROOT/bin/start.boot</strong>.</p> </dd><dt><strong>-boot_var Var Dir</strong></dt><dd> <p>If the boot script contains a path variable <strong>Var</strong>
other than <strong>$ROOT</strong>, this variable is expanded to
<strong>Dir</strong>. Used when applications are installed in
another directory than <strong>$ROOT/lib</strong>; see
<a href="../sasl/systools#make_script/1">sasl/systools#make_script/1</a> in SASL.</p> </dd><dt><strong>-code_path_cache</strong></dt><dd> <p>Enables the code path cache of the code server; see
<a href="./code">kernel/code</a>.</p> </dd><dt><strong>-compile Mod1 Mod2 ...</strong></dt><dd> <p>Compiles the specified modules and then terminates (with
non-zero exit code if the compilation of some file did not
succeed). Implies <strong>-noinput</strong>.</p> <p>Not recommended; use <a href="erlc">erlc</a>
instead.</p> </dd><dt><strong>-config Config</strong></dt><dd> <p>Specifies the name of a configuration file,
<strong>Config.config</strong>, which is used to configure
applications; see
<a href="./app">kernel/app</a> and
<a href="./application">kernel/application</a>.</p> </dd><dt><a name="connect_all"></a><strong>-connect_all false</strong></dt><dd> <p>If this flag is present, <strong>global</strong> does not maintain
a fully connected network of distributed Erlang nodes, and then
global name registration cannot be used; see
<a href="./global">kernel/global</a>.</p> </dd><dt><strong>-cookie Cookie</strong></dt><dd> <p>Obsolete flag without any effect and common misspelling for
<strong>-setcookie</strong>. Use <strong>-setcookie</strong>
instead.</p> </dd><dt><strong>-detached</strong></dt><dd> <p>Starts the Erlang runtime system detached from the system
console. Useful for running daemons and backgrounds processes. Implies
<strong>-noinput</strong>.</p> </dd><dt><strong>-emu_args</strong></dt><dd> <p>Useful for debugging. Prints the arguments sent to the emulator.</p> </dd><dt><strong>-emu_type Type</strong></dt><dd> <p>Start an emulator of a different type. For example, to start
the lock-counter emualator, use <strong>-emu_type lcnt</strong>. (The emulator
must already be built. Use the <strong>configure</strong> option
<strong>--enable-lock-counter</strong> to build the lock-counter emulator.)</p> </dd><dt><strong>-env Variable Value</strong></dt><dd> <p>Sets the host OS environment variable <strong>Variable</strong> to
the value <strong>Value</strong> for the Erlang runtime system.
Example:</p> <pre>
% <span class="input">erl -env DISPLAY gin:0</span></pre> <p>In this example, an Erlang runtime system is started with
environment variable <strong>DISPLAY</strong> set to
<strong>gin:0</strong>.</p> </dd><dt><strong>-epmd_module Module</strong> (init flag)</dt><dd> <p>Configures the module responsible to communicate to
<a href="epmd">epmd</a>. Defaults to <strong>erl_epmd</strong>.</p> </dd><dt><strong>-eval Expr</strong> (init flag)</dt><dd> <p>Makes <strong>init</strong> evaluate the expression
<strong>Expr</strong>; see
<a href="init">init</a>.</p> </dd><dt><strong>-extra</strong> (init flag)</dt><dd> <p>Everything following <strong>-extra</strong> is considered plain
arguments and can be retrieved using
<strong>init:get_plain_arguments/0</strong>.</p> </dd><dt><strong>-heart</strong></dt><dd> <p>Starts heartbeat monitoring of the Erlang runtime system;
see <a href="./heart">kernel/heart</a>.</p> </dd><dt><strong>-hidden</strong></dt><dd> <p>Starts the Erlang runtime system as a hidden node, if it is
run as a distributed node. Hidden nodes always establish
hidden connections to all other nodes except for nodes in the
same global group. Hidden connections are not published on
any of the connected nodes, that is, none of the connected
nodes are part of the result from <strong>nodes/0</strong> on the
other node. See also hidden global groups;
<a href="./global_group">kernel/global_group</a>.</p> </dd><dt><strong>-hosts Hosts</strong></dt><dd> <p>Specifies the IP addresses for the hosts on which Erlang boot servers
are running, see <a href="./erl_boot_server">kernel/erl_boot_server</a>. This flag
is mandatory if flag <strong>-loader inet</strong> is present.</p> <p>The IP addresses must be specified in the standard form (four
decimal numbers separated by periods, for example,
<strong>"150.236.20.74"</strong>. Hosts names are not acceptable,
but a broadcast address (preferably limited to the local network)
is.</p> </dd><dt><strong>-id Id</strong></dt><dd> <p>Specifies the identity of the Erlang runtime system. If it is
run as a distributed node, <strong>Id</strong> must be identical to
the name supplied together with flag <strong>-sname</strong> or
<strong>-name</strong>.</p> </dd><dt><strong>-init_debug</strong></dt><dd> <p>Makes <strong>init</strong> write some debug information while
interpreting the boot script.</p> </dd><dt><a name="instr"></a><strong>-instr</strong> (emulator flag)</dt><dd> <p>Selects an instrumented Erlang runtime system (virtual
machine) to run, instead of the ordinary one. When running an
instrumented runtime system, some resource usage data can be
obtained and analyzed using the <strong>instrument</strong> module.
Functionally, it behaves exactly like an ordinary Erlang
runtime system.</p> </dd><dt><strong>-loader Loader</strong></dt><dd> <p>Specifies the method used by <strong>erl_prim_loader</strong> to
load Erlang modules into the system; see
<a href="erl_prim_loader">erl_prim_loader</a>.
Two <strong>Loader</strong> methods are supported:</p> <ul><li> <p><strong>efile</strong>, which means use the local file system,
this is the default.</p> </li><li> <p><strong>inet</strong>, which means use a boot server on
another machine. The flags <strong>-id</strong>,
<strong>-hosts</strong> and <strong>-setcookie</strong> must
also be specified.</p> </li></ul> <p>If <strong>Loader</strong> is something else, the user-supplied
<strong>Loader</strong> port program is started.</p> </dd><dt><strong>-make</strong></dt><dd> <p>Makes the Erlang runtime system invoke <strong>make:all()</strong>
in the current working directory and then terminate; see
<a href="./make">tools/make</a>. Implies
<strong>-noinput</strong>.</p> </dd><dt><strong>-man Module</strong></dt><dd> <p>Displays the manual page for the Erlang module
<strong>Module</strong>. Only supported on Unix.</p> </dd><dt><strong>-mode interactive | embedded</strong></dt><dd> <p>Modules are auto loaded when they are first referenced if the
runtime system runs in <strong>interactive</strong> mode, which is
the default. In <strong>embedded</strong> mode modules are not auto
loaded. The latter is recommended when the boot script preloads all
modules, as conventionally happens in OTP releases. See
<a href="./code">kernel/code</a></p>. </dd><dt><strong>-name Name</strong></dt><dd> <p>Makes the Erlang runtime system into a distributed node.
This flag invokes all network servers necessary for a node to
become distributed; see <a href="./net_kernel">kernel/net_kernel</a>. It is also ensured that
<strong>epmd</strong> runs on the current host before Erlang is
started; see <a href="epmd">epmd</a>.and the
<a href="#start_epmd">start_epmd</a> option.</p> <p>The node name will be <strong>Name@Host</strong>, where
<strong>Host</strong> is the fully qualified host name of the
current host. For short names, use flag <strong>-sname</strong>
instead.</p> <div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>
Starting a distributed node without also specifying
<a href="#proto_dist">proto_dist</a>
will expose the node to attacks that may give the attacker
complete access to the node and in extension the cluster.
When using un-secure distributed nodes, make sure that the
network is configured to keep potential attackers out.
</p></div> </dd><dt><strong>-noinput</strong></dt><dd> <p>Ensures that the Erlang runtime system never tries to read
any input. Implies <strong>-noshell</strong>.</p> </dd><dt><strong>-noshell</strong></dt><dd> <p>Starts an Erlang runtime system with no shell. This flag
makes it possible to have the Erlang runtime system as a
component in a series of Unix pipes.</p> </dd><dt><strong>-nostick</strong></dt><dd> <p>Disables the sticky directory facility of the Erlang code
server; see
<a href="./code">kernel/code</a>.</p> </dd><dt><strong>-oldshell</strong></dt><dd> <p>Invokes the old Erlang shell from Erlang/OTP 3.3. The old shell
can still be used.</p> </dd><dt><strong>-pa Dir1 Dir2 ...</strong></dt><dd> <p>Adds the specified directories to the beginning of the code
path, similar to <a href="../kernel/code#add_pathsa/1">kernel/code#add_pathsa/1</a>. Note that the
order of the given directories will be reversed in the
resulting path.</p> <p>As an alternative to <strong>-pa</strong>, if several directories are
to be prepended to the code path and the directories have a
common parent directory, that parent directory can be
specified in environment variable <strong>ERL_LIBS</strong>; see
<a href="./code">kernel/code</a>.</p> </dd><dt><strong>-pz Dir1 Dir2 ...</strong></dt><dd> <p>Adds the specified directories to the end of the code path,
similar to <strong>code:add_pathsz/1</strong>; see
<a href="./code">kernel/code</a>.</p> </dd><dt><strong>-path Dir1 Dir2 ...</strong></dt><dd> <p>Replaces the path specified in the boot script; see
<a href="./script">sasl/script</a>.</p> </dd><dt><strong>-proto_dist Proto</strong></dt><dd> <a name="proto_dist"></a> <p>Specifies a protocol for Erlang distribution:</p> <dl><dt><strong>inet_tcp</strong></dt><dd>TCP over IPv4 (the default)</dd><dt><strong>inet_tls</strong></dt><dd>Distribution over TLS/SSL, See the <a href="./ssl_distribution"> Using SSL for Erlang Distribution</a> User's Guide for details on how to setup a secure distributed node. </dd><dt><strong>inet6_tcp</strong></dt><dd>TCP over IPv6</dd></dl> <p>For example, to start up IPv6 distributed nodes:</p> <pre>
% <span class="input">erl -name test@ipv6node.example.com -proto_dist inet6_tcp</span></pre> </dd><dt><strong>-remsh Node</strong></dt><dd> <p>Starts Erlang with a remote shell connected to
<strong>Node</strong>. Requires either <strong>-name</strong>
or <strong>-sname</strong> to be given. If <strong>Node</strong>
does not contain a hostname, one is automatically taken from
<strong>-name</strong> or <strong>-sname</strong></p> </dd><dt><strong>-rsh Program</strong></dt><dd> <p>Specifies an alternative to <strong>ssh</strong> for starting a
slave node on a remote host; see
<a href="./slave">stdlib/slave</a>.</p> </dd><dt><strong>-run Mod [Func [Arg1, Arg2, ...]]</strong> (init flag)</dt><dd> <p>Makes <strong>init</strong> call the specified function.
<strong>Func</strong> defaults to <strong>start</strong>.
If no arguments are provided, the function is assumed to be of
arity 0. Otherwise it is assumed to be of arity 1, taking the list
<strong>[Arg1,Arg2,...]</strong> as argument. All arguments are
passed as strings. See <a href="init">init</a>.</p> </dd><dt><strong>-s Mod [Func [Arg1, Arg2, ...]]</strong> (init flag)</dt><dd> <p>Makes <strong>init</strong> call the specified function.
<strong>Func</strong> defaults to <strong>start</strong>.
If no arguments are provided, the function is assumed to be of
arity 0. Otherwise it is assumed to be of arity 1, taking the list
<strong>[Arg1,Arg2,...]</strong> as argument. All arguments are
passed as atoms. See <a href="init">init</a>.</p> </dd><dt><strong>-setcookie Cookie</strong></dt><dd> <p>Sets the magic cookie of the node to <strong>Cookie</strong>; see
<a href="./erlang#set_cookie/2">erlang#set_cookie/2</a>.</p> </dd><dt><strong>-shutdown_time Time</strong></dt><dd> <p>Specifies how long time (in milliseconds) the <strong>init</strong>
process is allowed to spend shutting down the system. If
<strong>Time</strong> milliseconds have elapsed, all processes still
existing are killed. Defaults to <strong>infinity</strong>.</p> </dd><dt><strong>-sname Name</strong></dt><dd> <p>Makes the Erlang runtime system into a distributed node, similar to
<strong>-name</strong>, but the host name portion of the node
name <strong>Name@Host</strong> will be the short name, not fully
qualified.</p> <p>This is sometimes the only way to run distributed Erlang if
the Domain Name System (DNS) is not running. No communication can
exist between nodes running with flag <strong>-sname</strong>
and those running with flag <strong>-name</strong>, as node
names must be unique in distributed Erlang systems.</p> <div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>
Starting a distributed node without also specifying
<a href="#proto_dist">proto_dist</a>
will expose the node to attacks that may give the attacker
complete access to the node and in extension the cluster.
When using un-secure distributed nodes, make sure that the
network is configured to keep potential attackers out.
</p></div> </dd><dt><a name="start_epmd"></a><strong>-start_epmd true | false</strong></dt><dd> <p>Specifies whether Erlang should start
<a href="epmd">epmd</a> on startup. By default
this is <strong>true</strong>, but if you prefer to start epmd
manually, set this to <strong>false</strong>.</p> <p>This only applies if Erlang is started as a distributed node,
i.e. if <strong>-name</strong> or <strong>-sname</strong> is specified. Otherwise,
epmd is not started even if <strong>-start_epmd true</strong> is given.</p> <p>Note that a distributed node will fail to start if epmd is
not running.</p> </dd><dt><strong>-version</strong> (emulator flag)</dt><dd> <p>Makes the emulator print its version number. The same
as <strong>erl +V</strong>.</p> </dd></dl><a name="emu_flags"></a><h3>Emulator Flags</h3><p><strong>erl</strong> invokes the code for the Erlang emulator (virtual
machine), which supports the following flags:</p><dl><dt><a name="async_thread_stack_size"></a> <strong>+a size</strong></dt><dd> <p>Suggested stack size, in kilowords, for threads in the
async thread pool. Valid range is 16-8192 kilowords. The
default suggested stack size is 16 kilowords, that is, 64
kilobyte on 32-bit architectures. This small default size
has been chosen because the number of async threads can
be large. The default size is enough for drivers
delivered with Erlang/OTP, but might not be large
enough for other dynamically linked-in drivers that use the
<a href="./erl_driver#driver_async">erl_driver#driver_async</a> functionality.
Notice that the value passed is only a suggestion,
and it can even be ignored on some platforms.</p> </dd><dt><a name="async_thread_pool_size"></a><strong>+A size</strong></dt><dd> <p>Sets the number of threads in async thread pool. Valid range
is 0-1024. Defaults to 1.</p> </dd><dt><strong>+B [c | d | i]</strong></dt><dd> <p>Option <strong>c</strong> makes <strong>Ctrl-C</strong>
interrupt the current shell instead of invoking the emulator break
handler. Option <strong>d</strong> (same as specifying
<strong>+B</strong> without an extra option) disables the break
handler. Option <strong>i</strong> makes the emulator ignore any
break signal.</p> <p>If option <strong>c</strong> is used with
<strong>oldshell</strong> on Unix, <strong>Ctrl-C</strong> will
restart the shell process rather than interrupt it.</p> <p>Notice that on Windows, this flag is only applicable for
<strong>werl</strong>, not <strong>erl</strong>
(<strong>oldshell</strong>). Notice also that
<strong>Ctrl-Break</strong> is used instead of
<strong>Ctrl-C</strong> on Windows.</p> </dd><dt><a name="+c"></a><strong>+c true | false</strong></dt><dd> <p>Enables or disables
<a href="./time_correction#Time_Correction">time correction</a>:</p> <dl><dt><strong>true</strong></dt><dd>Enables time correction. This is the default if time correction is supported on the specific platform.</dd><dt><strong>false</strong></dt><dd>Disables time correction.</dd></dl> <p>For backward compatibility, the boolean value can be omitted.
This is interpreted as <strong>+c false</strong>.</p> </dd><dt><a name="+C_"></a><strong>+C no_time_warp | single_time_warp | multi_time_warp</strong></dt><dd> <p>Sets <a href="./time_correction#Time_Warp_Modes">time warp mode</a>:</p> <dl><dt><strong>no_time_warp</strong></dt><dd><a href="./time_correction#No_Time_Warp_Mode"> No time warp mode</a> (the default)</dd><dt><strong>single_time_warp</strong></dt><dd><a href="./time_correction#Single_Time_Warp_Mode"> Single time warp mode</a></dd><dt><strong>multi_time_warp</strong></dt><dd><a href="./time_correction#Multi_Time_Warp_Mode"> Multi-time warp mode</a></dd></dl> </dd><dt><strong>+d</strong></dt><dd> <p>If the emulator detects an internal error (or runs out of memory),
it, by default, generates both a crash dump and a core dump.
The core dump is, however, not very useful as the content
of process heaps is destroyed by the crash dump generation.</p> <p>Option <strong>+d</strong> instructs the emulator to produce only a
core dump and no crash dump if an internal error is detected.</p> <p>Calling <a href="./erlang#halt/1">erlang#halt/1</a> with a string argument still
produces a crash dump. On Unix systems, sending an emulator process
a <strong>SIGUSR1</strong> signal also forces a crash dump.</p> </dd><dt><a name="+dcg"></a><strong>+rg DecentralizedCounterGroupsLimit</strong></dt><dd> <p>Limits the number of decentralized counter groups used by
decentralized counters optimized for update operations in the
Erlang runtime system. By default, the limit is 256.</p> <p>When the number of schedulers is less than or equal to the
limit, each scheduler has its own group. When the
number of schedulers is larger than the groups limit,
schedulers share groups. Shared groups degrade
the performance for updating counters while many reader groups
degrade the performance for reading counters. So, the limit is a tradeoff
between performance for update operations and performance for
read operations. Each group consumes 64 bytes in each
counter.</p> <p>Notice that a runtime system using decentralized
counter groups benefits from <a href="#+sbt">binding schedulers to logical processors</a>, as the groups are
distributed better between schedulers with this option.</p> <p>This option only affects decentralized counters used for
the counters that are keeping track of the memory consumption
and the number of terms in ETS tables of type ordered_set with
the write_concurrency option activated.</p> </dd><dt><a name="+e"></a><strong>+e Number</strong></dt><dd> <p>Sets the maximum number of ETS tables. This limit is
<a href="../stdlib/ets#max_ets_tables">partially obsolete</a>.
</p> </dd><dt><strong>+ec</strong></dt><dd> <p>Forces option <strong>compressed</strong> on all ETS tables.
Only intended for test and evaluation.</p> </dd><dt><a name="file_name_encoding"></a> <strong>+fnl</strong></dt><dd> <p>The virtual machine works with filenames as if they are encoded
using the ISO Latin-1 encoding, disallowing Unicode characters with
code points &gt; 255.</p> <p>For more information about Unicode filenames, see section
<a href="../stdlib/unicode_usage#unicode_file_names">Unicode Filenames</a> in the STDLIB User's Guide. Notice that
this value also applies to command-line parameters and environment
variables (see section <a href="../stdlib/unicode_usage#unicode_in_environment_and_parameters"> Unicode in Environment and Parameters</a> in the STDLIB
User's Guide).</p> </dd><dt><strong>+fnu[{w|i|e}]</strong></dt><dd> <p>The virtual machine works with filenames as if they are encoded
using UTF-8 (or some other system-specific Unicode encoding). This is
the default on operating systems that enforce Unicode encoding, that
is, Windows and MacOS X.</p> <p>The <strong>+fnu</strong> switch can be followed by <strong>w</strong>, <strong>i</strong>, or
<strong>e</strong> to control how wrongly encoded filenames are to be
reported:</p> <ul><li> <p><strong>w</strong> means that a warning is sent to the <strong>error_logger</strong>
whenever a wrongly encoded filename is "skipped" in directory
listings. This is the default.</p> </li><li> <p><strong>i</strong> means that those wrongly encoded filenames are silently
ignored.</p> </li><li> <p><strong>e</strong> means that the API function returns an error whenever a
wrongly encoded filename (or directory name) is encountered.</p> </li></ul> <p>Notice that <a href="../kernel/file#read_link/1">kernel/file#read_link/1</a> always returns an error if the link
points to an invalid filename.</p> <p>For more information about Unicode filenames, see section
<a href="../stdlib/unicode_usage#unicode_file_names">Unicode Filenames</a> in the STDLIB User's Guide. Notice that
this value also applies to command-line parameters and environment
variables (see section <a href="../stdlib/unicode_usage#unicode_in_environment_and_parameters"> Unicode in Environment and Parameters</a> in the STDLIB
User's Guide).</p> </dd><dt><strong>+fna[{w|i|e}]</strong></dt><dd> <p>Selection between <strong>+fnl</strong> and <strong>+fnu</strong> is done based
on the current locale settings in the OS. This means that if you
have set your terminal for UTF-8 encoding, the filesystem is
expected to use the same encoding for filenames. This is
default on all operating systems, except MacOS X and Windows.</p> <p>The <strong>+fna</strong> switch can be followed by <strong>w</strong>, <strong>i</strong>, or
<strong>e</strong>. This has effect if the locale settings cause the behavior
of <strong>+fnu</strong> to be selected; see the description of <strong>+fnu</strong>
above. If the locale settings cause the behavior of <strong>+fnl</strong> to be
selected, then <strong>w</strong>, <strong>i</strong>, or <strong>e</strong> have no effect.</p> <p>For more information about Unicode filenames, see section
<a href="../stdlib/unicode_usage#unicode_file_names">Unicode Filenames</a> in the STDLIB User's Guide. Notice that
this value also applies to command-line parameters and environment
variables (see section <a href="../stdlib/unicode_usage#unicode_in_environment_and_parameters"> Unicode in Environment and Parameters</a> in the STDLIB
User's Guide).</p> </dd><dt><strong>+hms Size</strong></dt><dd> <p>Sets the default heap size of processes to the size
<strong>Size</strong>.</p> </dd><dt><strong>+hmbs Size</strong></dt><dd> <p>Sets the default binary virtual heap size of processes to the size
<strong>Size</strong>.</p> </dd><dt><a name="+hmax"></a><strong>+hmax Size</strong></dt><dd> <p>Sets the default maximum heap size of processes to the size
<strong>Size</strong>. Defaults to <strong>0</strong>, which means that no
maximum heap size is used. For more information, see
<a href="./erlang#process_flag_max_heap_size">erlang#process_flag_max_heap_size</a>.</p> </dd><dt><a name="+hmaxel"></a><strong>+hmaxel true|false</strong></dt><dd> <p>Sets whether to send an error logger message or not for processes
reaching the maximum heap size. Defaults to <strong>true</strong>.
For more information, see
<a href="./erlang#process_flag_max_heap_size">erlang#process_flag_max_heap_size</a>.</p> </dd><dt><a name="+hmaxk"></a><strong>+hmaxk true|false</strong></dt><dd> <p>Sets whether to kill processes reaching the maximum heap size or not.
Default to <strong>true</strong>. For more information, see
<a href="./erlang#process_flag_max_heap_size">erlang#process_flag_max_heap_size</a>.</p> </dd><dt><strong>+hpds Size</strong></dt><dd> <p>Sets the initial process dictionary size of processes to the size
<strong>Size</strong>.</p> </dd><dt><a name="+hmqd"></a><strong>+hmqd off_heap|on_heap</strong></dt><dd> <p>Sets the default value for process flag <strong>message_queue_data</strong>.
Defaults to <strong>on_heap</strong>. If <strong>+hmqd</strong> is not
passed, <strong>on_heap</strong> will be the default. For more information, see
<a href="./erlang#process_flag_message_queue_data">erlang#process_flag_message_queue_data</a>.</p> </dd><dt><a name="+IOp"></a><strong>+IOp PollSets</strong></dt><dd> <p>Sets the number of IO pollsets to use when polling for I/O.
This option is only used on platforms that support concurrent
updates of a pollset, otherwise the same number of pollsets
are used as IO poll threads.
The default is 1.
</p> </dd><dt><a name="+IOt"></a><strong>+IOt PollThreads</strong></dt><dd> <p>Sets the number of IO poll threads to use when polling for I/O.
The maximum number of poll threads allowed is 1024. The default is 1.
</p> <p>A good way to check if more IO poll threads are needed is to use
<a href="./msacc">microstate accounting</a>
and see what the load of the IO poll thread is. If it is high it could
be a good idea to add more threads.</p> </dd><dt><a name="+IOPp"></a><strong>+IOPp PollSetsPercentage</strong></dt><dd> <p>Similar to <a href="#+IOp">+IOp</a> but uses
percentages to set the number of IO pollsets to create, based on the
number of poll threads configured. If both <strong>+IOPp</strong> and <strong>+IOp</strong>
are used, <strong>+IOPp</strong> is ignored.
</p> </dd><dt><a name="+IOPt"></a><strong>+IOPt PollThreadsPercentage</strong></dt><dd> <p>Similar to <a href="#+IOt">+IOt</a> but uses
percentages to set the number of IO poll threads to create, based on
the number of schedulers configured. If both <strong>+IOPt</strong> and
<strong>+IOt</strong> are used, <strong>+IOPt</strong> is ignored.
</p> </dd><dt><strong>+l</strong></dt><dd> <p>Enables autoload tracing, displaying information while loading
code.</p> </dd><dt><strong>+L</strong></dt><dd> <p>Prevents loading information about source filenames and line
numbers. This saves some memory, but exceptions do not contain
information about the filenames and line numbers.</p> </dd><dt><a name="erts_alloc"></a><strong>+MFlag Value</strong></dt><dd> <p>Memory allocator-specific flags. For more information, see
<a href="erts_alloc">erts_alloc</a>.</p> </dd><dt><a name="+pc"></a><a name="printable_character_range"></a> <strong>+pc Range</strong></dt><dd> <p>Sets the range of characters that the system considers printable in
heuristic detection of strings. This typically affects the shell,
debugger, and <strong>io:format</strong> functions (when <strong>~tp</strong> is used in
the format string).</p>  <p>Two values are supported for <strong>Range</strong>:</p> <dl><dt><strong>latin1</strong></dt><dd>The default. Only characters in the ISO Latin-1 range can be considered printable. This means that a character with a code point &gt; 255 is never considered printable and that lists containing such characters are displayed as lists of integers rather than text strings by tools.</dd><dt><strong>unicode</strong></dt><dd>All printable Unicode characters are considered when determining if a list of integers is to be displayed in string syntax. This can give unexpected results if, for example, your font does not cover all Unicode characters.</dd></dl> <p>See also <a href="../stdlib/io#printable_range/0">stdlib/io#printable_range/0</a> in STDLIB.</p> </dd><dt><a name="+P"></a><a name="max_processes"></a><strong>+P Number</strong></dt><dd> <p>Sets the maximum number of simultaneously existing processes for this
system if a <strong>Number</strong> is passed as value. Valid range for
<strong>Number</strong> is <strong>[1024-134217727]</strong></p> <p><em>NOTE</em>: The actual maximum chosen may be much larger than
the <strong>Number</strong> passed. Currently the runtime system often,
but not always, chooses a value that is a power of 2. This might,
however, be changed in the future. The actual value chosen can be
checked by calling
<a href="./erlang#system_info_process_limit">erlang:system_info(process_limit)</a>.</p> <p>The default value is <strong>262144</strong></p> </dd><dt><a name="+Q"></a><a name="max_ports"></a><strong>+Q Number</strong></dt><dd> <p>Sets the maximum number of simultaneously existing ports for this
system if a Number is passed as value. Valid range for <strong>Number</strong>
is <strong>[1024-134217727]</strong></p> <p><em>NOTE</em>: The actual maximum chosen may be much larger than
the actual <strong>Number</strong> passed. Currently the runtime system often,
but not always, chooses a value that is a power of 2. This might,
however, be changed in the future. The actual value chosen can be
checked by calling
<a href="./erlang#system_info_port_limit">erlang:system_info(port_limit)</a>.</p> <p>The default value used is normally <strong>65536</strong>. However, if
the runtime system is able to determine maximum amount of file
descriptors that it is allowed to open and this value is larger
than <strong>65536</strong>, the chosen value will increased to a value
larger or equal to the maximum amount of file descriptors that
can be opened.</p> <p>On Windows the default value is set to <strong>8196</strong> because the
normal OS limitations are set higher than most machines can handle.</p> </dd><dt><a name="compat_rel"></a><strong>+R ReleaseNumber</strong></dt><dd> <p>Sets the compatibility mode.</p> <p>The distribution mechanism is not backward compatible by
default. This flag sets the emulator in compatibility mode
with an earlier Erlang/OTP release <strong>ReleaseNumber</strong>.
The release number must be in the range
<strong>&lt;current release&gt;-2..&lt;current release&gt;</strong>. This
limits the emulator, making it possible for it to communicate
with Erlang nodes (as well as C- and Java nodes) running that
earlier release.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Ensure that all nodes (Erlang-,  C-, and Java nodes) of
a distributed Erlang system is of the same Erlang/OTP release,
or from two different Erlang/OTP releases X and Y, where
<em>all</em> Y nodes have compatibility mode X.</p></div> </dd><dt><strong>+r</strong></dt><dd> <p>Forces ETS memory block to be moved on realloc.</p> </dd><dt><a name="+rg"></a><strong>+rg ReaderGroupsLimit</strong></dt><dd> <p>Limits the number of reader groups used by read/write locks
optimized for read operations in the Erlang runtime system. By
default the reader groups limit is 64.</p> <p>When the number of schedulers is less than or equal to the reader
groups limit, each scheduler has its own reader group. When the
number of schedulers is larger than the reader groups limit,
schedulers share reader groups. Shared reader groups degrade
read lock and read unlock performance while many
reader groups degrade write lock performance. So, the limit is a
tradeoff between performance for read operations and performance
for write operations. Each reader group consumes 64 byte
in each read/write lock.</p> <p>Notice that a runtime system using shared reader groups benefits from
<a href="#+sbt">binding schedulers to logical processors</a>, as the reader groups are distributed better
between schedulers.</p> </dd><dt><a name="+S"></a> <strong>+S Schedulers:SchedulerOnline</strong></dt><dd> <p>Sets the number of scheduler threads to create and scheduler threads
to set online. The maximum for both
values is 1024. If the Erlang runtime system is able to determine the
number of logical processors configured and logical processors
available, <strong>Schedulers</strong> defaults to logical processors
configured, and <strong>SchedulersOnline</strong> defaults to logical processors
available; otherwise the default values are 1. <strong>Schedulers</strong> can
be omitted if <strong>:SchedulerOnline</strong> is not and conversely. The
number of schedulers online can be changed at runtime through
<a href="./erlang#system_flag_schedulers_online">erlang#system_flag_schedulers_online</a>.</p> <p>If <strong>Schedulers</strong> or <strong>SchedulersOnline</strong> is specified as a
negative number, the value is subtracted from the default number of
logical processors configured or logical processors available,
respectively.</p> <p>Specifying value <strong>0</strong> for <strong>Schedulers</strong> or
<strong>SchedulersOnline</strong> resets the number of scheduler threads or
scheduler threads online, respectively, to its default value.</p> </dd><dt><a name="+SP"></a><strong>+SP SchedulersPercentage:SchedulersOnlinePercentage</strong></dt><dd> <p>Similar to <a href="#+S">+S</a> but uses
percentages to set the number of scheduler threads to create, based
on logical processors configured, and scheduler threads to set online,
based on logical processors available.
Specified values must be &gt; 0. For example,
<strong>+SP 50:25</strong> sets the number of scheduler threads to 50% of the
logical processors configured, and the number of scheduler threads
online to 25% of the logical processors available.
<strong>SchedulersPercentage</strong> can be omitted if
<strong>:SchedulersOnlinePercentage</strong> is not and conversely. The number
of schedulers online can be changed at runtime through
<a href="./erlang#system_flag_schedulers_online">erlang#system_flag_schedulers_online</a>.</p> <p>This option interacts with <a href="#+S">+S</a>
settings. For example, on a system with 8 logical cores configured
and 8 logical cores available, the combination of the options
<strong>+S 4:4 +SP 50:25</strong> (in either order) results in 2 scheduler
threads (50% of 4) and 1 scheduler thread online (25% of 4).</p> </dd><dt><a name="+SDcpu"></a><strong>+SDcpu DirtyCPUSchedulers:DirtyCPUSchedulersOnline</strong></dt><dd> <p>Sets the number of dirty CPU scheduler threads to create and dirty
CPU scheduler threads to set online.
The maximum for both values is 1024, and each value is
further limited by the settings for normal schedulers:</p> <ul><li>The number of dirty CPU scheduler threads created cannot exceed the number of normal scheduler threads created.</li><li>The number of dirty CPU scheduler threads online cannot exceed the number of normal scheduler threads online.</li></ul> <p>For details, see the <a href="#+S">+S</a> and
<a href="#+SP">+SP</a>. By default, the number
of dirty CPU scheduler threads created equals the number of normal
scheduler threads created, and the number of dirty CPU scheduler
threads online equals the number of normal scheduler threads online.
<strong>DirtyCPUSchedulers</strong> can be omitted if
<strong>:DirtyCPUSchedulersOnline</strong> is not and conversely. The number of
dirty CPU schedulers online can be changed at runtime through
<a href="./erlang#system_flag_dirty_cpu_schedulers_online">erlang#system_flag_dirty_cpu_schedulers_online</a>.</p> <p>The amount of dirty CPU schedulers is limited by the amount of
normal schedulers in order to limit the effect on processes
executing on ordinary schedulers. If the amount of dirty CPU
schedulers was allowed to be unlimited, dirty CPU bound jobs would
potentially starve normal jobs.</p> </dd><dt><a name="+SDPcpu"></a><strong>+SDPcpu DirtyCPUSchedulersPercentage:DirtyCPUSchedulersOnlinePercentage</strong></dt><dd> <p>Similar to <a href="#+SDcpu">+SDcpu</a> but
uses percentages to set the number of dirty CPU scheduler threads to
create and the number of dirty CPU scheduler threads to set online.
Specified values must be
&gt; 0. For example, <strong>+SDPcpu 50:25</strong> sets the number of dirty
CPU scheduler threads to 50% of the logical processors configured
and the number of dirty CPU scheduler threads online to 25% of the
logical processors available. <strong>DirtyCPUSchedulersPercentage</strong> can
be omitted if <strong>:DirtyCPUSchedulersOnlinePercentage</strong> is not and
conversely. The number of dirty CPU schedulers online can be changed
at runtime through
<a href="./erlang#system_flag_dirty_cpu_schedulers_online">erlang#system_flag_dirty_cpu_schedulers_online</a>.</p> <p>This option interacts with <a href="#+SDcpu">+SDcpu</a> settings. For example, on a
system with 8 logical cores configured and 8 logical cores available,
the combination of the options <strong>+SDcpu 4:4 +SDPcpu 50:25</strong> (in
either order) results in 2 dirty CPU scheduler threads (50% of 4) and
1 dirty CPU scheduler thread online (25% of 4).</p> </dd><dt><a name="+SDio"></a><strong>+SDio DirtyIOSchedulers</strong></dt><dd> <p>Sets the number of dirty I/O scheduler threads to create.
Valid range is 0-1024. By
default, the number of dirty I/O scheduler threads created is 10,
same as the default number of threads in the <a href="#async_thread_pool_size">async thread pool</a>.</p> <p>The amount of dirty IO schedulers is not limited by the amount of
normal schedulers <a href="#+SDcpu">like the amount of dirty CPU schedulers</a>. This since only I/O bound work is
expected to execute on dirty I/O schedulers. If the user should schedule CPU
bound jobs on dirty I/O schedulers, these jobs might starve ordinary
jobs executing on ordinary schedulers.</p> </dd><dt><strong>+sFlag Value</strong></dt><dd> <p>Scheduling specific flags.</p> <dl><dt><a name="+sbt"></a><strong>+sbt BindType</strong></dt><dd> <p>Sets scheduler bind type.</p> <p>Schedulers can also be bound using flag
<a href="#+stbt">+stbt</a>. The only
difference between these two flags is how the following errors
are handled:</p> <ul><li>Binding of schedulers is not supported on the specific platform.</li><li>No available CPU topology. That is, the runtime system was not able to detect the CPU topology automatically, and no <a href="#+sct">user-defined CPU topology</a> was set.</li></ul> <p>If any of these errors occur when <strong>+sbt</strong> has been passed,
the runtime system prints an error message, and refuses to
start. If any of these errors occur when <strong>+stbt</strong> has been
passed, the runtime system silently ignores the error, and
start up using unbound schedulers.</p> <p>Valid <strong>BindType</strong>s:</p> <dl><dt><strong>u</strong></dt><dd><strong>unbound</strong> - Schedulers are not bound to logical processors, that is, the operating system decides where the scheduler threads execute, and when to migrate them. This is the default. </dd><dt><strong>ns</strong></dt><dd><strong>no_spread</strong> - Schedulers with close scheduler identifiers are bound as close as possible in hardware. </dd><dt><strong>ts</strong></dt><dd><strong>thread_spread</strong> - Thread refers to hardware threads (such as Intel's hyper-threads). Schedulers with low scheduler identifiers, are bound to the first hardware thread of each core, then schedulers with higher scheduler identifiers are bound to the second hardware thread of each core,and so on. </dd><dt><strong>ps</strong></dt><dd><strong>processor_spread</strong> - Schedulers are spread like <strong>thread_spread</strong>, but also over physical processor chips. </dd><dt><strong>s</strong></dt><dd><strong>spread</strong> - Schedulers are spread as much as possible. </dd><dt><strong>nnts</strong></dt><dd><strong>no_node_thread_spread</strong> - Like <strong>thread_spread</strong>, but if multiple Non-Uniform Memory Access (NUMA) nodes exist, schedulers are spread over one NUMA node at a time, that is, all logical processors of one NUMA node are bound to schedulers in sequence. </dd><dt><strong>nnps</strong></dt><dd><strong>no_node_processor_spread</strong> - Like <strong>processor_spread</strong>, but if multiple NUMA nodes exist, schedulers are spread over one NUMA node at a time, that is, all logical processors of one NUMA node are bound to schedulers in sequence. </dd><dt><strong>tnnps</strong></dt><dd><strong>thread_no_node_processor_spread</strong> - A combination of <strong>thread_spread</strong>, and <strong>no_node_processor_spread</strong>. Schedulers are spread over hardware threads across NUMA nodes, but schedulers are only spread over processors internally in one NUMA node at a time. </dd><dt><strong>db</strong></dt><dd><strong>default_bind</strong> - Binds schedulers the default way. Defaults to <strong>thread_no_node_processor_spread</strong> (which can change in the future). </dd></dl> <p>Binding of schedulers is only supported on newer
Linux, Solaris, FreeBSD, and Windows systems.</p> <p>If no CPU topology is available when flag <strong>+sbt</strong>
is processed and <strong>BindType</strong> is any other type than
<strong>u</strong>, the runtime system fails to start. CPU
topology can be defined using flag
<a href="#+sct">+sct</a>. Notice
that flag <strong>+sct</strong> can have to be passed before flag
<strong>+sbt</strong> on the command line (if no CPU topology
has been automatically detected).</p> <p>The runtime system does by default <em>not</em> bind schedulers
to logical processors.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If the Erlang runtime system is the only operating system
process that binds threads to logical processors, this
improves the performance of the runtime system. However,
if other operating system processes (for example
another Erlang runtime system) also bind threads to
logical processors, there can be a performance penalty
instead. This performance penalty can sometimes be
severe. If so, you are advised not to
bind the schedulers.</p></div> <p>How schedulers are bound matters. For example, in
situations when there are fewer running processes than
schedulers online, the runtime system tries to migrate
processes to schedulers with low scheduler identifiers.
The more the schedulers are spread over the hardware,
the more resources are available to the runtime
system in such situations.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If a scheduler fails to bind, this is
often silently ignored, as it is not always
possible to verify valid logical processor identifiers. If
an error is reported, it is reported to the
<strong>error_logger</strong>. If you want to verify that the
schedulers have bound as requested, call
<a href="./erlang#system_info_scheduler_bindings">erlang#system_info_scheduler_bindings</a>.</p></div> </dd><dt><a name="+sbwt"></a> <strong>+sbwt none|very_short|short|medium|long|very_long</strong></dt><dd> <p>Sets scheduler busy wait threshold. Defaults to <strong>medium</strong>.
The threshold determines how long schedulers are to busy
wait when running out of work before going to sleep.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag can be removed or changed at any time
without prior notice.</p></div> </dd><dt><a name="+sbwtdcpu"></a> <strong>+sbwtdcpu none|very_short|short|medium|long|very_long</strong></dt><dd> <p>As <a href="#+sbwt">+sbwt</a> but affects
dirty CPU schedulers. Defaults to <strong>short</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag can be removed or changed at any time
without prior notice.</p></div> </dd><dt><a name="+sbwtdio"></a> <strong>+sbwtdio none|very_short|short|medium|long|very_long</strong></dt><dd> <p>As <a href="#+sbwt">+sbwt</a> but affects
dirty IO schedulers. Defaults to <strong>short</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag can be removed or changed at any time
without prior notice.</p></div> </dd><dt><a name="+scl"></a><strong>+scl true|false</strong></dt><dd> <p>Enables or disables scheduler compaction of load. By default
scheduler compaction of load is enabled. When enabled, load
balancing strives for a load distribution, which causes
as many scheduler threads as possible to be fully loaded (that is,
not run out of work). This is accomplished by migrating load
(for example, runnable processes) into a smaller set of schedulers
when schedulers frequently run out of work. When disabled,
the frequency with which schedulers run out of work is
not taken into account by the load balancing logic.</p> <p><strong>+scl false</strong> is similar to
<a href="#+sub">+sub</a>, but
<strong>+sub true</strong> also balances scheduler utilization
between schedulers.</p> </dd><dt><a name="+sct"></a><strong>+sct CpuTopology</strong></dt><dd> <ul><li><strong>&lt;Id&gt; = integer(); when 0 =&lt; &lt;Id&gt; =&lt; 65535</strong> </li><li><strong>&lt;IdRange&gt; = &lt;Id&gt;-&lt;Id&gt;</strong></li><li><strong>&lt;IdOrIdRange&gt; = &lt;Id&gt; | &lt;IdRange&gt;</strong></li><li><strong>&lt;IdList&gt; = &lt;IdOrIdRange&gt;,&lt;IdOrIdRange&gt; | &lt;IdOrIdRange&gt;</strong></li><li><strong>&lt;LogicalIds&gt; = L&lt;IdList&gt;</strong></li><li><strong>&lt;ThreadIds&gt; = T&lt;IdList&gt; | t&lt;IdList&gt;</strong> </li><li><strong>&lt;CoreIds&gt; = C&lt;IdList&gt; | c&lt;IdList&gt;</strong></li><li><strong>&lt;ProcessorIds&gt; = P&lt;IdList&gt; | p&lt;IdList&gt;</strong> </li><li><strong>&lt;NodeIds&gt; = N&lt;IdList&gt; | n&lt;IdList&gt;</strong></li><li><strong>&lt;IdDefs&gt; = &lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;ProcessorIds&gt;&lt;NodeIds&gt; | &lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;NodeIds&gt;&lt;ProcessorIds&gt;</strong> </li><li><strong>CpuTopology = &lt;IdDefs&gt;:&lt;IdDefs&gt; | &lt;IdDefs&gt;</strong></li></ul> <p>Sets a user-defined CPU topology. The user-defined
CPU topology overrides any automatically detected
CPU topology. The CPU topology is used when
<a href="#+sbt">binding schedulers to logical processors</a>.</p> <p>Uppercase letters signify real identifiers and lowercase
letters signify fake identifiers only used for description
of the topology. Identifiers passed as real identifiers can
be used by the runtime system when trying to access specific
hardware; if they are incorrect the behavior is
undefined. Faked logical CPU identifiers are not accepted,
as there is no point in defining the CPU topology without
real logical CPU identifiers. Thread, core, processor, and
node identifiers can be omitted. If omitted, the thread ID
defaults to <strong>t0</strong>, the core ID defaults to <strong>c0</strong>,
the processor ID defaults to <strong>p0</strong>, and the node ID is
left undefined. Either each logical processor must 
belong to only one NUMA node, or no logical
processors must belong to any NUMA nodes.</p> <p>Both increasing and decreasing <strong>&lt;IdRange&gt;</strong>s
are allowed.</p> <p>NUMA node identifiers are system wide. That is, each NUMA
node on the system must have a unique identifier. Processor
identifiers are also system wide. Core identifiers are
processor wide. Thread identifiers are core wide.</p> <p>The order of the identifier types implies the hierarchy of the
CPU topology. The valid orders are as follows:</p> <ul><li> <p><strong>&lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;ProcessorIds&gt;&lt;NodeIds&gt;</strong>,
that is, thread is part of a core that is part of a processor,
which is part of a NUMA node.</p> </li><li> <p><strong>&lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;NodeIds&gt;&lt;ProcessorIds&gt;</strong>,
that is, thread is part of a core that is part of a NUMA node,
which is part of a processor.</p> </li></ul> <p>A CPU topology can consist of both processor external, and
processor internal NUMA nodes as long as each logical processor
belongs to only one NUMA node. If
<strong>&lt;ProcessorIds&gt;</strong> is omitted, its default position
is before <strong>&lt;NodeIds&gt;</strong>. That is, the default is
processor external NUMA nodes.</p> <p>If a list of identifiers is used in an
<strong>&lt;IdDefs&gt;</strong>:</p> <ul><li><strong>&lt;LogicalIds&gt;</strong> must be a list of identifiers.</li><li>At least one other identifier type besides <strong>&lt;LogicalIds&gt;</strong> must also have a list of identifiers.</li><li>All lists of identifiers must produce the same number of identifiers.</li></ul> <p>A simple example. A single quad core processor can be
described as follows:</p> <pre>
% <span class="input">erl +sct L0-3c0-3</span>
1&gt; <span class="input">erlang:system_info(cpu_topology).</span>
[{processor,[{core,{logical,0}},
             {core,{logical,1}},
             {core,{logical,2}},
             {core,{logical,3}}]}]</pre> <p>A more complicated example with two quad core
processors, each processor in its own NUMA node.
The ordering of logical processors is a bit weird.
This to give a better example of identifier lists:</p> <pre>
% <span class="input">erl +sct L0-1,3-2c0-3p0N0:L7,4,6-5c0-3p1N1</span>
1&gt; <span class="input">erlang:system_info(cpu_topology).</span>
[{node,[{processor,[{core,{logical,0}},
                    {core,{logical,1}},
                    {core,{logical,3}},
                    {core,{logical,2}}]}]},
 {node,[{processor,[{core,{logical,7}},
                    {core,{logical,4}},
                    {core,{logical,6}},
                    {core,{logical,5}}]}]}]</pre> <p>As long as real identifiers are correct, it is OK
to pass a CPU topology that is not a correct
description of the CPU topology. When used with
care this can be very useful. This
to trick the emulator to bind its schedulers
as you want. For example, if you want to run multiple
Erlang runtime systems on the same machine, you
want to reduce the number of schedulers used and
manipulate the CPU topology so that they bind to
different logical CPUs. An example, with two Erlang
runtime systems on a quad core machine:</p> <pre>
% <span class="input">erl +sct L0-3c0-3 +sbt db +S3:2 -detached -noinput -noshell -sname one</span>
% <span class="input">erl +sct L3-0c0-3 +sbt db +S3:2 -detached -noinput -noshell -sname two</span></pre> <p>In this example, each runtime system have two
schedulers each online, and all schedulers online
will run on different cores. If we change to one
scheduler online on one runtime system, and three
schedulers online on the other, all schedulers
online will still run on different cores.</p> <p>Notice that a faked CPU topology that does not reflect
how the real CPU topology looks like is likely to
decrease the performance of the runtime system.</p> <p>For more information, see
<a href="./erlang#system_info_cpu_topology">erlang#system_info_cpu_topology</a>.</p> </dd><dt><a name="+sfwi"></a><strong>+sfwi Interval</strong></dt><dd> <p>Sets scheduler-forced wakeup interval. All run queues are
scanned each <strong>Interval</strong> milliseconds. While there are
sleeping schedulers in the system, one scheduler is woken
for each non-empty run queue found. <strong>Interval</strong> default
to <strong>0</strong>, meaning this feature is disabled.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This feature has been introduced as a temporary workaround
for long-executing native code, and native code that does not
bump reductions properly in OTP. When these bugs have be fixed,
this flag will be removed.</p></div> </dd><dt><a name="+spp"></a><strong>+spp Bool</strong></dt><dd> <p>Sets default scheduler hint for port parallelism. If set to
<strong>true</strong>, the virtual machine schedules port tasks when it
improves parallelism in the system. If set to <strong>false</strong>, the
virtual machine tries to perform port tasks immediately,
improving latency at the expense of parallelism. Default to
<strong>false</strong>. The default used can be inspected in runtime by
calling <a href="./erlang#system_info_port_parallelism">erlang#system_info_port_parallelism</a>.
The default can be overridden on port creation by passing option
<a href="./erlang#open_port_parallelism">erlang#open_port_parallelism</a> to
<a href="./erlang#open_port/2">erlang#open_port/2</a></p>. </dd><dt><a name="sched_thread_stack_size"></a> <strong>+sss size</strong></dt><dd> <p>Suggested stack size, in kilowords, for scheduler threads.
Valid range is 20-8192 kilowords. The default suggested
stack size is 128 kilowords.</p> </dd><dt><a name="dcpu_sched_thread_stack_size"></a> <strong>+sssdcpu size</strong></dt><dd> <p>Suggested stack size, in kilowords, for dirty CPU scheduler
threads. Valid range is 20-8192 kilowords. The default
suggested stack size is 40 kilowords.</p> </dd><dt><a name="dio_sched_thread_stack_size"></a> <strong>+sssdio size</strong></dt><dd> <p>Suggested stack size, in kilowords, for dirty IO scheduler
threads. Valid range is 20-8192 kilowords. The default
suggested stack size is 40 kilowords.</p> </dd><dt><a name="+stbt"></a><strong>+stbt BindType</strong></dt><dd> <p>Tries to set the scheduler bind type. The same as flag
<a href="#+sbt">+sbt</a> except
how some errors are handled. For more information, see
<a href="#+sbt">+sbt</a>.</p> </dd><dt><a name="+sub"></a><strong>+sub true|false</strong></dt><dd> <p>Enables or disables
<a href="../erts/erlang#statistics_scheduler_wall_time"> scheduler utilization</a> balancing of load. By default
scheduler utilization balancing is disabled and instead scheduler
compaction of load is enabled, which strives for a load
distribution that causes as many scheduler threads as possible
to be fully loaded (that is, not run out of work). When scheduler
utilization balancing is enabled, the system instead tries to
balance scheduler utilization between schedulers. That is,
strive for equal scheduler utilization on all schedulers.</p> <p><strong>+sub true</strong> is only supported on systems where the runtime
system detects and uses a monotonically increasing high-resolution
clock. On other systems, the runtime system fails to start.</p> <p><strong>+sub true</strong> implies <a href="#+scl">+scl</a>. The difference between
<strong>+sub true</strong> and <strong>+scl false</strong> is that <strong>+scl false</strong>
does not try to balance the scheduler utilization.</p> </dd><dt><a name="+swct"></a> <strong>+swct very_eager|eager|medium|lazy|very_lazy</strong></dt><dd> <p>Sets scheduler wake cleanup threshold. Defaults to <strong>medium</strong>.
Controls how eager schedulers are to be requesting
wakeup because of certain cleanup operations. When a lazy setting
is used, more outstanding cleanup operations can be left undone
while a scheduler is idling. When an eager setting is used,
schedulers are more frequently woken, potentially increasing
CPU-utilization.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag can be removed or changed at any time without prior
notice.</p></div> </dd><dt><a name="+sws"></a><strong>+sws default|legacy</strong></dt><dd> <p>Sets scheduler wakeup strategy. Default strategy changed in
ERTS 5.10 (Erlang/OTP R16A). This strategy was known as
<strong>proposal</strong> in Erlang/OTP R15. The <strong>legacy</strong> strategy
was used as default from R13 up to and including R15.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag can be removed or changed at any time without prior
notice.</p></div> </dd><dt><a name="+swt"></a> <strong>+swt very_low|low|medium|high|very_high</strong></dt><dd> <p>Sets scheduler wakeup threshold. Defaults to <strong>medium</strong>.
The threshold determines when to wake up sleeping schedulers
when more work than can be handled by currently awake schedulers
exists. A low threshold causes earlier wakeups, and a high
threshold causes later wakeups. Early wakeups distribute work
over multiple schedulers faster, but work does more easily bounce
between schedulers.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag can be removed or changed at any time without prior
notice.</p></div> </dd><dt><a name="+swtdcpu"></a> <strong>+swtdcpu very_low|low|medium|high|very_high</strong></dt><dd> <p>As <a href="#+swt">+swt</a> but
affects dirty CPU schedulers. Defaults to <strong>medium</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag can be removed or changed at any time
without prior notice.</p></div> </dd><dt><a name="+swtdio"></a> <strong>+swtdio very_low|low|medium|high|very_high</strong></dt><dd> <p>As <a href="#+swt">+swt</a> but affects
dirty IO schedulers. Defaults to <strong>medium</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag can be removed or changed at any time
without prior notice.</p></div> </dd></dl> </dd><dt><a name="+t"></a><strong>+t size</strong></dt><dd> <p>Sets the maximum number of atoms the virtual machine can handle.
Defaults to 1,048,576.</p> </dd><dt><a name="+T"></a><strong>+T Level</strong></dt><dd> <p>Enables modified timing and sets the modified timing level. Valid
range is 0-9. The timing of the runtime system is changed. A high
level usually means a greater change than a low level. Changing the
timing can be very useful for finding timing-related bugs.</p> <p>Modified timing affects the following:</p> <dl><dt>Process spawning</dt><dd>A process calling <strong>spawn</strong>, <strong>spawn_link</strong>, <strong>spawn_monitor</strong>, or <strong>spawn_opt</strong> is scheduled out immediately after completing the call. When higher modified timing levels are used, the caller also sleeps for a while after it is scheduled out. </dd><dt>Context reductions</dt><dd>The number of reductions a process is allowed to use before it is scheduled out is increased or reduced. </dd><dt>Input reductions</dt><dd>The number of reductions performed before checking I/O is increased or reduced. </dd></dl> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Performance suffers when modified timing is enabled. This flag is
<em>only</em> intended for testing and debugging.</p><p><strong>return_to</strong> and <strong>return_from</strong>
trace messages are lost when tracing on the spawn BIFs.</p><p>This flag can be removed or changed at any time without prior
notice.</p></div> </dd><dt><strong>+v</strong></dt><dd> <p>Verbose.</p> </dd><dt><strong>+V</strong></dt><dd> <p>Makes the emulator print its version number.</p> </dd><dt><strong>+W w | i | e</strong></dt><dd> <p>Sets the mapping of warning messages for
<strong>error_logger</strong>. Messages sent to the error logger
using one of the warning routines can be mapped to errors
(<strong>+W e</strong>), warnings (<strong>+W w</strong>), or
information reports (<strong>+W i</strong>). Defaults to warnings.
The current mapping can be retrieved using
<strong>error_logger:warning_map/0</strong>. For more information,
see <a href="../kernel/error_logger#warning_map/0">kernel/error_logger#warning_map/0</a> in Kernel.</p> </dd><dt><strong>+zFlag Value</strong></dt><dd> <p>Miscellaneous flags:</p> <dl><dt><a name="+zdbbl"></a><strong>+zdbbl size</strong></dt><dd> <p>Sets the distribution buffer busy limit
(<a href="./erlang#system_info_dist_buf_busy_limit">erlang#system_info_dist_buf_busy_limit</a>)
in kilobytes. Valid range is 1-2097151. Defaults to 1024.</p> <p>A larger buffer limit allows processes to buffer
more outgoing messages over the distribution. When the
buffer limit has been reached, sending processes will be
suspended until the buffer size has shrunk. The buffer
limit is per distribution channel. A higher limit
gives lower latency and higher throughput at the expense
of higher memory use.</p> </dd><dt><a name="+zdntgc"></a><strong>+zdntgc time</strong></dt><dd> <p>Sets the delayed node table garbage collection time
(<a href="./erlang#system_info_delayed_node_table_gc">erlang#system_info_delayed_node_table_gc</a>)
in seconds. Valid values are either <strong>infinity</strong> or
an integer in the range 0-100000000. Defaults to 60.</p> <p>Node table entries that are not referred linger
in the table for at least the amount of time that this
parameter determines. The lingering prevents repeated
deletions and insertions in the tables from occurring.</p> </dd></dl> </dd></dl><a name="environment_variables"></a><h3>Environment Variables</h3><dl><dt><strong>ERL_CRASH_DUMP</strong></dt><dd> <p>If the emulator needs to write a crash dump, the value of this
variable is the filename of the crash dump file.
If the variable is not set, the name of the crash dump file is
<strong>erl_crash.dump</strong> in the current directory.</p> </dd><dt><strong>ERL_CRASH_DUMP_NICE</strong></dt><dd> <p><em>Unix systems</em>: If the emulator needs to write a crash dump,
it uses the value of this variable to set the nice value
for the process, thus lowering its priority. Valid range is
1-39 (higher values are replaced with 39). The highest
value, 39, gives the process the lowest priority.</p> </dd><dt><strong>ERL_CRASH_DUMP_SECONDS</strong></dt><dd> <p><em>Unix systems</em>: This variable gives the number of seconds
that the emulator is allowed to spend writing a crash dump. When the
given number of seconds have elapsed, the emulator is terminated.</p> <dl><dt><strong>ERL_CRASH_DUMP_SECONDS=0</strong></dt><dd>If the variable is set to <strong>0</strong> seconds, the runtime system does not even attempt to write the crash dump file. It only terminates. This is the default if option <strong>-heart</strong> is passed to <strong>erl</strong> and <strong>ERL_CRASH_DUMP_SECONDS</strong> is not set. </dd><dt><strong>ERL_CRASH_DUMP_SECONDS=S</strong></dt><dd>If the variable is set to a positive value <strong>S</strong>, wait for <strong>S</strong> seconds to complete the crash dump file and then terminates the runtime system with a <strong>SIGALRM</strong> signal. </dd><dt><strong>ERL_CRASH_DUMP_SECONDS=-1</strong></dt><dd>A negative value causes the termination of the runtime system to wait indefinitely until the crash dump file has been completly written. This is the default if option <strong>-heart</strong> is <em>not</em> passed to <strong>erl</strong> and <strong>ERL_CRASH_DUMP_SECONDS</strong> is not set. </dd></dl> <p>See also <a href="./heart">kernel/heart</a>.</p> </dd><dt><strong>ERL_CRASH_DUMP_BYTES</strong></dt><dd> <p>This variable sets the maximum size of a crash dump file in bytes.
The crash dump will be truncated if this limit is exceeded. If the
variable is not set, no size limit is enforced by default. If the
variable is set to <strong>0</strong>, the runtime system does not even attempt
to write a crash dump file.</p> <p>Introduced in ERTS 8.1.2 (Erlang/OTP 19.2).</p> </dd><dt><a name="ERL_AFLAGS"></a><strong>ERL_AFLAGS</strong></dt><dd> <p>The content of this variable is added to the beginning of the
command line for <strong>erl</strong>.</p> <p>Flag <strong>-extra</strong> is treated in a special way. Its
scope ends at the end of the environment variable content. Arguments
following an <strong>-extra</strong> flag are moved on the command
line into section <strong>-extra</strong>, that is, the end of the
command line following an <strong>-extra</strong> flag.</p> </dd><dt><a name="ERL_ZFLAGS"></a><strong>ERL_ZFLAGS</strong> and <a name="ERL_FLAGS"></a><strong>ERL_FLAGS</strong></dt><dd> <p>The content of these variables are added to the end of the command
line for <strong>erl</strong>.</p> <p>Flag <strong>-extra</strong> is treated in a special way. Its
scope ends at the end of the environment variable content. Arguments
following an <strong>-extra</strong> flag are moved on the command
line into section <strong>-extra</strong>, that is, the end of the
command line following an <strong>-extra</strong> flag.</p> </dd><dt><strong>ERL_LIBS</strong></dt><dd> <p>Contains a list of additional library directories that the code
server searches for applications and adds to the code path; see
<a href="./code">kernel/code</a>.</p> </dd><dt><strong>ERL_EPMD_ADDRESS</strong></dt><dd> <p>Can be set to a comma-separated list of IP addresses, in which case
the <a href="epmd">epmd</a> daemon listens only
on the specified address(es) and on the loopback address (which is
implicitly added to the list if it has not been specified).</p> </dd><dt><strong>ERL_EPMD_PORT</strong></dt><dd> <p>Can contain the port number to use when communicating with
<a href="epmd">epmd</a>. The default port works
fine in most cases. A different port can be specified
to allow nodes of independent clusters to co-exist on the same host.
All nodes in a cluster must use the same <strong>epmd</strong> port number.</p> </dd></dl><a name="signals"></a><h3>Signals</h3><p>On Unix systems, the Erlang runtime will interpret two types of signals.</p><dl><dt><strong>SIGUSR1</strong></dt><dd> <p>A <strong>SIGUSR1</strong> signal forces a crash dump.</p> </dd><dt><strong>SIGTERM</strong></dt><dd> <p>A <strong>SIGTERM</strong> will produce a <strong>stop</strong> message to the <strong>init</strong> process.
This is equivalent to a <strong>init:stop/0</strong> call.</p> <p>Introduced in ERTS 8.3 (Erlang/OTP 19.3)</p> </dd></dl><p>The signal <strong>SIGUSR2</strong> is reserved for internal usage. No other signals are handled.</p><a name="configuration"></a><h3>Configuration</h3><p>The standard Erlang/OTP system can be reconfigured to change the default
behavior on startup.</p><dl><dt>The <strong>.erlang</strong> startup file</dt><dd> <p>When Erlang/OTP is started, the system searches for a file named
<strong>.erlang</strong> in the user's home directory.</p> <p>If an <strong>.erlang</strong> file is found, it is assumed to contain valid
Erlang expressions. These expressions are evaluated as if they were
input to the shell.</p> <p>A typical <strong>.erlang</strong> file contains a set of search paths, for
example:</p> <pre><code class="">
io:format("executing user profile in HOME/.erlang\n",[]).
code:add_path("/home/calvin/test/ebin").
code:add_path("/home/hobbes/bigappl-1.2/ebin").
io:format(".erlang rc finished\n",[]).    </code></pre> </dd><dt>user_default and shell_default</dt><dd> <p>Functions in the shell that are not prefixed by a module name are
assumed to be functional objects (funs), built-in functions (BIFs),
or belong to the module <strong>user_default</strong> or
<strong>shell_default</strong>.</p> <p>To include private shell commands, define them in a module
<strong>user_default</strong> and add the following argument as the first line
in the <strong>.erlang</strong> file:</p> <pre><code class="">
code:load_abs("..../user_default").    </code></pre> </dd><dt>erl</dt><dd> <p>If the contents of <strong>.erlang</strong> are changed and a private version
of <strong>user_default</strong> is defined, the Erlang/OTP environment can be
customized. More powerful changes can be made by supplying
command-line arguments in the startup script <strong>erl</strong>. For more
information, see <a href="init">init</a>.</p> </dd></dl><h3>See Also</h3><p><a href="epmd">epmd</a>,
<a href="erl_prim_loader">erl_prim_loader</a>,
<a href="erts_alloc">erts_alloc</a>,
<a href="init">init</a>,
<a href="./application">kernel/application</a>,
<a href="./auth">kernel/auth</a>,
<a href="./code">kernel/code</a>,
<a href="./erl_boot_server">kernel/erl_boot_server</a>,
<a href="./heart">kernel/heart</a>,
<a href="./net_kernel">kernel/net_kernel</a>,
<a href="./make">tools/make</a></p><h2>erlang</h2><p>The Erlang BIFs.</p><p>By convention, most Built-In Functions (BIFs) are included
in this module. Some of the BIFs are viewed more
or less as part of the Erlang programming language and are
<em>auto-imported</em>. Thus, it is not necessary to specify the
module name. For example, the calls <strong>atom_to_list(erlang)</strong>
and <strong>erlang:atom_to_list(erlang)</strong> are identical.Auto-imported BIFs are listed without module prefix.
BIFs listed with module prefix are not auto-imported.BIFs can fail for various reasons. All BIFs fail with
reason <strong>badarg</strong> if they are called with arguments of an
incorrect type. The other reasons are described in the
description of each individual BIF.Some BIFs can be used in guard tests and are marked with
"Allowed in guard tests".</p><h2>Data Types</h2><span class="name">ext_binary</span><p>A binary data object, structured according to
the Erlang external term format.</p><span class="name">iovec</span><p>A list of binaries. This datatype is useful to use
together with <a href="./erl_nif#enif_inspect_iovec">erl_nif#enif_inspect_iovec</a>.</p><span class="name">message_queue_data</span><p>See <a href="#process_flag_message_queue_data">process_flag_message_queue_data</a>.</p><span class="name">timestamp</span><p>See <a href="#timestamp/0">timestamp/0</a>.</p><span class="name">time_unit</span><a name="type_time_unit"></a><p>Supported time unit representations:</p><dl><dt><strong>PartsPerSecond :: integer() &gt;= 1</strong></dt><dd> <p>Time unit expressed in parts per second. That is,
the time unit equals <strong>1/PartsPerSecond</strong> second.</p> </dd><dt><strong>second</strong></dt><dd> <p>Symbolic representation of the time unit
represented by the integer <strong>1</strong>.</p> </dd><dt><strong>millisecond</strong></dt><dd> <p>Symbolic representation of the time unit
represented by the integer <strong>1000</strong>.</p> </dd><dt><strong>microsecond</strong></dt><dd> <p>Symbolic representation of the time unit
represented by the integer <strong>1000000</strong>.</p> </dd><dt><strong>nanosecond</strong></dt><dd> <p>Symbolic representation of the time unit
represented by the integer <strong>1000000000</strong>.</p> </dd><dt><strong>native</strong></dt><dd> <p>Symbolic representation of the native time unit
used by the Erlang runtime system.</p> <p>The <strong>native</strong> time unit is determined at
runtime system start, and remains the same until
the runtime system terminates. If a runtime system
is stopped and then started again (even on the same
machine), the <strong>native</strong> time unit of the new
runtime system instance can differ from the
<strong>native</strong> time unit of the old runtime system
instance.</p> <p>One can get an approximation of the <strong>native</strong>
time unit by calling
<a href="#convert_time_unit/3">convert_time_unit/3</a>.
The result equals the number
of whole <strong>native</strong> time units per second. If
the number of <strong>native</strong> time units per second does not
add up to a whole number, the result is rounded downwards.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The value of the <strong>native</strong> time unit gives
you more or less no information about the
quality of time values. It sets a limit for the
<a href="./time_correction#Time_Resolution"> resolution</a> and for the
<a href="./time_correction#Time_Precision"> precision</a> of time values,
but it gives no information about the
<a href="./time_correction#Time_Accuracy"> accuracy</a> of time values. The resolution of
the <strong>native</strong> time unit and the resolution of time
values can differ significantly.</p></div> </dd><dt><strong>perf_counter</strong></dt><dd> <p>Symbolic representation of the performance counter
time unit used by the Erlang runtime system.</p> <p>The <strong>perf_counter</strong> time unit behaves much in the same way
as the <strong>native</strong> time unit. That is, it can differ between
runtime restarts. To get values of this type, call
<a href="../kernel/os#perf_counter/0">kernel/os#perf_counter/0</a>.</p> </dd><dt><a href="#type_deprecated_time_unit">type_deprecated_time_unit</a></dt><dd><p>
Deprecated symbolic representations kept for backwards-compatibility.
</p></dd></dl><p>The <strong>time_unit/0</strong> type can be extended.
To convert time values between time units, use
<a href="#convert_time_unit/3">convert_time_unit/3</a>.</p><span class="name">deprecated_time_unit</span><a name="type_deprecated_time_unit"></a><p>The <a href="#type_time_unit">type_time_unit</a>
type also consist of the following <em>deprecated</em> symbolic
time units:</p><dl><dt><strong>seconds</strong></dt><dd><p>Same as <a href="#type_time_unit">type_time_unit</a>.</p></dd><dt><strong>milli_seconds</strong></dt><dd><p>Same as <a href="#type_time_unit">type_time_unit</a>.</p></dd><dt><strong>micro_seconds</strong></dt><dd><p>Same as <a href="#type_time_unit">type_time_unit</a>.</p></dd><dt><strong>nano_seconds</strong></dt><dd><p>Same as <a href="#type_time_unit">type_time_unit</a>.</p></dd></dl><span class="name">dist_handle</span><p>An opaque handle identifing a distribution channel.</p><span class="name">nif_resource</span><p>An opaque handle identifing a
<a href="./erl_nif#resource_objects">NIF resource object </a>.</p><h2>Functions</h2><h3>abs/1</h3><h3>abs/1</h3><p>Arithmetical absolute value.</p><p>Returns an integer or float that is the arithmetical
absolute value of <strong><span class="anno">Float</span></strong> or
<strong><span class="anno">Int</span></strong>, for example:</p><pre>
&gt; <span class="input">abs(-3.33).</span>
3.33
&gt; <span class="input">abs(-3).</span>
3</pre><p>Allowed in guard tests.</p><h3>adler32/1</h3><p>Compute adler32 checksum.</p><p>Computes and returns the adler32 checksum for
<strong><span class="anno">Data</span></strong>.</p><h3>adler32/2</h3><p>Compute adler32 checksum.</p><p>Continues computing the adler32 checksum by combining 
the previous checksum, <strong><span class="anno">OldAdler</span></strong>, with
the checksum of <strong><span class="anno">Data</span></strong>.</p><p>The following code:</p><pre><code class="">
X = erlang:adler32(Data1),
Y = erlang:adler32(X,Data2).</code></pre><p>assigns the same value to <strong>Y</strong> as this:</p><pre><code class="">
Y = erlang:adler32([Data1,Data2]).</code></pre><h3>adler32_combine/3</h3><p>Combine two adler32 checksums.</p><p>Combines two previously computed adler32 checksums.
This computation requires the size of the data object for
the second checksum to be known.</p><p>The following code:</p><pre><code class="">
Y = erlang:adler32(Data1),
Z = erlang:adler32(Y,Data2).</code></pre><p>assigns the same value to <strong>Z</strong> as this:</p><pre><code class="">
X = erlang:adler32(Data1),
Y = erlang:adler32(Data2),
Z = erlang:adler32_combine(X,Y,iolist_size(Data2)).</code></pre><h3>append_element/2</h3><p>Append an extra element to a tuple.</p><p>Returns a new tuple that has one element more than
<strong><span class="anno">Tuple1</span></strong>, and contains the elements in
<strong><span class="anno">Tuple1</span></strong>
followed by <strong><span class="anno">Term</span></strong> as the last element.
Semantically equivalent to
<strong>list_to_tuple(tuple_to_list(<span class="anno">Tuple1</span>) ++ [<span class="anno">Term</span>])</strong>, but much faster. Example:</p><pre>
&gt; <span class="input">erlang:append_element({one, two}, three).</span>
{one,two,three}</pre><h3>apply/2</h3><p>Apply a function to an argument list.</p><p>Calls a fun, passing the elements in <strong><span class="anno">Args</span></strong>
as arguments.</p><p>If the number of elements in the arguments are known at
compile time, the call is better written as
<strong><span class="anno">Fun</span>(Arg1, Arg2, ... ArgN)</strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Earlier, <strong><span class="anno">Fun</span></strong> could also be specified as
<strong>{Module, Function}</strong>, equivalent to
<strong>apply(Module, Function, Args)</strong>. <em>This use is deprecated and will stop working in a future release.</em></p></div><h3>apply/3</h3><p>Apply a function to an argument list.</p><p>Returns the result of applying <strong>Function</strong> in
<strong><span class="anno">Module</span></strong> to <strong><span class="anno">Args</span></strong>.
The applied function must
be exported from <strong>Module</strong>. The arity of the function is
the length of <strong>Args</strong>. Example:</p><pre>
&gt; <span class="input">apply(lists, reverse, [[a, b, c]]).</span>
[c,b,a]
&gt; <span class="input">apply(erlang, atom_to_list, ['Erlang']).</span>
"Erlang"</pre><p>If the number of arguments are known at compile time,
the call is better written as
<strong><span class="anno">Module</span>:<span class="anno">Function</span>(Arg1, Arg2, ..., ArgN)</strong>.</p><p>Failure: <a href="../kernel/error_handler#undefined_function/3">kernel/error_handler#undefined_function/3</a> is called
if the applied function is not exported. The error handler
can be redefined (see
<a href="#process_flag/2">process_flag/2</a>).
If <strong>error_handler</strong> is undefined, or if the user has
redefined the default <strong>error_handler</strong> so the replacement
module is undefined, an error with reason <strong>undef</strong>
is generated.</p><h3>atom_to_binary/2</h3><p>Return the binary representation of an atom.</p><p>Returns a binary corresponding to the text
representation of <strong><span class="anno">Atom</span></strong>.
If <strong><span class="anno">Encoding</span></strong>
is <strong>latin1</strong>, one byte exists for each character
in the text representation. If <strong><span class="anno">Encoding</span></strong> is
<strong>utf8</strong> or
<strong>unicode</strong>, the characters are encoded using UTF-8 where
characters may require multiple bytes.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from Erlang/OTP 20, atoms can contain any Unicode character
and <strong>atom_to_binary(<span class="anno">Atom</span>, latin1)</strong> may fail if the
text representation for <strong><span class="anno">Atom</span></strong> contains a Unicode
character &gt; 255.</p></div><p>Example:</p><pre>
&gt; <span class="input">atom_to_binary('Erlang', latin1).</span>
&lt;&lt;"Erlang"&gt;&gt;</pre><h3>atom_to_list/1</h3><p>Text representation of an atom.</p><p>Returns a string corresponding to the text
representation of <strong><span class="anno">Atom</span></strong>, for example:</p><pre>
&gt; <span class="input">atom_to_list('Erlang').</span>
"Erlang"</pre><h3>binary_part/2</h3><p>Extract a part of a binary.</p><p>Extracts the part of the binary described by
<strong><span class="anno">PosLen</span></strong>.</p><p>Negative length can be used to extract bytes at the end
of a binary, for example:</p><pre><code class="">
1&gt; Bin = &lt;&lt;1,2,3,4,5,6,7,8,9,10&gt;&gt;.
2&gt; binary_part(Bin,{byte_size(Bin), -5}).
&lt;&lt;6,7,8,9,10&gt;&gt;</code></pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">PosLen</span></strong> in any way
references outside the binary.</p><p><strong><span class="anno">Start</span></strong> is zero-based, that is:</p><pre><code class="">
1&gt; Bin = &lt;&lt;1,2,3&gt;&gt;
2&gt; binary_part(Bin,{0,2}).
&lt;&lt;1,2&gt;&gt;</code></pre><p>For details about the <strong><span class="anno">PosLen</span></strong> semantics, see
<a href="./binary">stdlib/binary</a>.</p><p>Allowed in guard tests.</p><h3>binary_part/3</h3><p>Extract a part of a binary.</p><p>The same as <strong>binary_part(<span class="anno">Subject</span>, {<span class="anno">Start</span>, <span class="anno">Length</span>})</strong>.</p><p>Allowed in guard tests.</p><h3>binary_to_atom/2</h3><p>Convert from text representation to an atom.</p><p>Returns the atom whose text representation is
<strong><span class="anno">Binary</span></strong>.
If <strong><span class="anno">Encoding</span></strong> is <strong>latin1</strong>, no
translation of bytes in the binary is done.
If <strong><span class="anno">Encoding</span></strong>
is <strong>utf8</strong> or <strong>unicode</strong>, the binary must contain
valid UTF-8 sequences.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from Erlang/OTP 20, <strong>binary_to_atom(<span class="anno">Binary</span>, utf8)</strong>
is capable of encoding any Unicode character. Earlier versions would
fail if the binary contained Unicode characters &gt; 255.
For more information about Unicode support in atoms, see the
<a href="./erl_ext_dist#utf8_atoms">note on UTF-8 encoded atoms</a>
in section "External Term Format" in the User's Guide.</p></div><p>Examples:</p><pre>
&gt; <span class="input">binary_to_atom(&lt;&lt;"Erlang"&gt;&gt;, latin1).</span>
'Erlang'
&gt; <span class="input">binary_to_atom(&lt;&lt;1024/utf8&gt;&gt;, utf8).</span>
''</pre><h3>binary_to_existing_atom/2</h3><p>Convert from text representation to an atom.</p><p>As
<a href="#binary_to_atom/2">binary_to_atom/2</a>,
but the atom must exist.</p><p>Failure: <strong>badarg</strong> if the atom does not exist.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that the compiler may optimize away atoms. For
example, the compiler will rewrite
<strong>atom_to_list(some_atom)</strong> to <strong>"some_atom"</strong>. If
that expression is the only mention of the atom
<strong>some_atom</strong> in the containing module, the atom will not
be created when the module is loaded, and a subsequent call
to <strong>binary_to_existing_atom(&lt;&lt;"some_atom"&gt;&gt;, utf8)</strong>
will fail.</p></div><h3>binary_to_float/1</h3><p>Convert from text representation to a float.</p><p>Returns the float whose text representation is
<strong><span class="anno">Binary</span></strong>, for example:</p><pre>
&gt; <span class="input">binary_to_float(&lt;&lt;"2.2017764e+0"&gt;&gt;).</span>
2.2017764</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Binary</span></strong> contains a bad
representation of a float.</p><h3>binary_to_integer/1</h3><p>Convert from text representation to an integer.</p><p>Returns an integer whose text representation is
<strong><span class="anno">Binary</span></strong>, for example:</p><pre>
&gt; <span class="input">binary_to_integer(&lt;&lt;"123"&gt;&gt;).</span>
123</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Binary</span></strong> contains a bad
representation of an integer.</p><h3>binary_to_integer/2</h3><p>Convert from text representation to an integer.</p><p>Returns an integer whose text representation in base
<strong><span class="anno">Base</span></strong> is <strong><span class="anno">Binary</span></strong>, for
example:</p><pre>
&gt; <span class="input">binary_to_integer(&lt;&lt;"3FF"&gt;&gt;, 16).</span>
1023</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Binary</span></strong> contains a bad
representation of an integer.</p><h3>binary_to_list/1</h3><p>Convert a binary to a list.</p><p>Returns a list of integers corresponding to the bytes of
<strong><span class="anno">Binary</span></strong>.</p><h3>binary_to_list/3</h3><p>Convert part of a binary to a list.</p><dl><dt>Start</dt><dd>1..byte_size(<strong><span class="anno">Binary</span></strong>) </dd></dl><p>As <strong>binary_to_list/1</strong>, but returns a list of integers
corresponding to the bytes from position <strong><span class="anno">Start</span></strong> to
position <strong><span class="anno">Stop</span></strong> in <strong><span class="anno">Binary</span></strong>.
The positions in the
binary are numbered starting from 1.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><em>The one-based indexing for binaries used by this function is deprecated.</em> New code is to use
<a href="../stdlib/binary#bin_to_list/3">stdlib/binary#bin_to_list/3</a>
in STDLIB instead. All functions in module
<strong>binary</strong> consistently use zero-based indexing.</p></div><h3>binary_to_term/1</h3><p>Decode an Erlang external term format binary.</p><p>Returns an Erlang term that is the result of decoding
binary object <strong><span class="anno">Binary</span></strong>, which must be encoded
according to the <a href="./erl_ext_dist"> Erlang external term format</a>.</p><pre>
&gt; <span class="input">Bin = term_to_binary(hello).</span>
&lt;&lt;131,100,0,5,104,101,108,108,111&gt;&gt;
&gt; <span class="input">hello = binary_to_term(Bin).</span>
hello
</pre><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>When decoding binaries from untrusted sources,
consider using <strong>binary_to_term/2</strong> to prevent Denial
of Service attacks.</p></div><p>See also
<a href="#term_to_binary/1">term_to_binary/1</a>
and <a href="#binary_to_term/2">binary_to_term/2</a>.</p><h3>binary_to_term/2</h3><p>Decode an Erlang external term format binary.</p><p>As <strong>binary_to_term/1</strong>, but takes these options:</p><dl><dt><strong>safe</strong></dt><dd> <p>Use this option when receiving binaries from an untrusted
source.</p> <p>When enabled, it prevents decoding data that can be used to
attack the Erlang system. In the event of receiving unsafe
data, decoding fails with a <strong>badarg</strong> error.</p> <p>This prevents creation of new atoms directly,
creation of new atoms indirectly (as they are embedded in
certain structures, such as process identifiers,
refs, and funs), and
creation of new external function references.
None of those resources are garbage collected, so unchecked
creation of them can exhaust available memory.</p> <pre>
&gt; <span class="input">binary_to_term(&lt;&lt;131,100,0,5,"hello"&gt;&gt;, [safe]).</span>
** exception error: bad argument
&gt; <span class="input">hello.</span>
hello
&gt; <span class="input">binary_to_term(&lt;&lt;131,100,0,5,"hello"&gt;&gt;, [safe]).</span>
hello
</pre> </dd><dt><strong>used</strong></dt><dd> <p>Changes the return value to <strong>{Term, Used}</strong> where <strong>Used</strong>
is the number of bytes actually read from <strong>Binary</strong>.</p> <pre>
&gt; <span class="input">Input = &lt;&lt;131,100,0,5,"hello","world"&gt;&gt;.</span>
&lt;&lt;131,100,0,5,104,101,108,108,111,119,111,114,108,100&gt;&gt;
&gt; <span class="input">{Term, Used} = binary_to_term(Input, [used]).</span>
{hello, 9}
&gt; <span class="input">split_binary(Input, Used).</span>
{&lt;&lt;131,100,0,5,104,101,108,108,111&gt;&gt;, &lt;&lt;"world"&gt;&gt;}
</pre> </dd></dl><p>Failure: <strong>badarg</strong> if <strong>safe</strong> is specified and unsafe
data is decoded.</p><p>See also
<a href="#term_to_binary/1">term_to_binary/1</a>,
<a href="#binary_to_term/1">binary_to_term/1</a>, and
<a href="#list_to_existing_atom/1">list_to_existing_atom/1</a>.</p><h3>bit_size/1</h3><p>Return the size of a bitstring.</p><p>Returns an integer that is the size in bits of
<strong><span class="anno">Bitstring</span></strong>, for example:</p><pre>
&gt; <span class="input">bit_size(&lt;&lt;433:16,3:3&gt;&gt;).</span>
19
&gt; <span class="input">bit_size(&lt;&lt;1,2,3&gt;&gt;).</span>
24</pre><p>Allowed in guard tests.</p><h3>bitstring_to_list/1</h3><p>Convert a bitstring to a list.</p><p>Returns a list of integers corresponding to the bytes of
<strong><span class="anno">Bitstring</span></strong>. If the number of bits in the binary
is not divisible by 8, the last element of the list is a bitstring
containing the remaining 1-7 bits.</p><h3>bump_reductions/1</h3><p>Increment the reduction counter.</p><p>This implementation-dependent function increments
the reduction counter for the calling process. In the Beam
emulator, the reduction counter is normally incremented by
one for each function and BIF call. A context switch is
forced when the counter reaches the maximum number of
reductions for a process (2000 reductions in Erlang/OTP R12B).</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF can be removed in a future version of the Beam
machine without prior warning. It is unlikely to be
implemented in other Erlang implementations.</p></div><h3>byte_size/1</h3><p>Return the size of a bitstring (or binary).</p><p>Returns an integer that is the number of bytes needed to
contain <strong><span class="anno">Bitstring</span></strong>. That is, if the number of bits
in <strong><span class="anno">Bitstring</span></strong> is not divisible by 8, the resulting
number of bytes is rounded <em>up</em>. Examples:</p><pre>
&gt; <span class="input">byte_size(&lt;&lt;433:16,3:3&gt;&gt;).</span>
3
&gt; <span class="input">byte_size(&lt;&lt;1,2,3&gt;&gt;).</span>
3</pre><p>Allowed in guard tests.</p><h3>cancel_timer/1</h3><p>Cancel a timer.</p><p>Cancels a timer. The same as calling
<a href="#cancel_timer/2">cancel_timer/2</a>.</p><h3>cancel_timer/2</h3><p>Cancel a timer.</p><p>Cancels a timer that has been created by
<a href="#start_timer/4">start_timer/4</a> or
<a href="#send_after/4">send_after/4</a>.
<strong><span class="anno">TimerRef</span></strong> identifies the timer, and
was returned by the BIF that created the timer.</p><p><strong><span class="anno">Option</span></strong>s:</p><dl><dt><strong>{async, Async}</strong></dt><dd> <p>Asynchronous request for cancellation. <strong>Async</strong>
defaults to <strong>false</strong>, which causes the
cancellation to be performed synchronously. When
<strong>Async</strong> is set to <strong>true</strong>, the cancel
operation is performed asynchronously. That is,
<strong>cancel_timer()</strong> sends an asynchronous
request for cancellation to the timer service that
manages the timer, and then returns <strong>ok</strong>.</p> </dd><dt><strong>{info, Info}</strong></dt><dd> <p>Requests information about the <strong><span class="anno">Result</span></strong>
of the cancellation. <strong>Info</strong> defaults to <strong>true</strong>,
which means the <strong><span class="anno">Result</span></strong> is
given. When <strong>Info</strong> is set to <strong>false</strong>, no
information about the result of the cancellation
is given.</p> <ul><li> <p>When <strong>Async</strong> is <strong>false</strong>:
if <strong>Info</strong> is <strong>true</strong>, the <strong>Result</strong> is
returned by <strong>erlang:cancel_timer()</strong>. otherwise
<strong>ok</strong> is returned.</p> </li><li> <p>When <strong>Async</strong> is <strong>true</strong>:
if <strong>Info</strong> is <strong>true</strong>, a message on the form
<strong>{cancel_timer, <span class="anno">TimerRef</span>, <span class="anno">Result</span>}</strong> is sent to the
caller of <strong>erlang:cancel_timer()</strong> when the
cancellation operation has been performed, otherwise
no message is sent.</p> </li></ul> </dd></dl><p>More <strong><span class="anno">Option</span></strong>s may be added in the future.</p><p>If <strong><span class="anno">Result</span></strong> is an integer, it represents
the time in milliseconds left until the canceled timer would
have expired.</p><p>If <strong><span class="anno">Result</span></strong> is <strong>false</strong>, a
timer corresponding to <strong><span class="anno">TimerRef</span></strong> could not
be found. This can be either because the timer had expired,
already had been canceled, or because <strong><span class="anno">TimerRef</span></strong>
never corresponded to a timer. Even if the timer had expired,
it does not tell you if the time-out message has
arrived at its destination yet.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The timer service that manages the timer can be co-located
with another scheduler than the scheduler that the calling
process is executing on. If so, communication
with the timer service takes much longer time than if it
is located locally. If the calling process is in critical
path, and can do other things while waiting for the result
of this operation, or is not interested in the result of
the operation, you want to use option <strong>{async, true}</strong>.
If using option <strong>{async, false}</strong>, the calling
process blocks until the operation has been performed.</p></div><p>See also
<a href="#send_after/4">send_after/4</a>,
<a href="#start_timer/4">start_timer/4</a>, and
<a href="#read_timer/2">read_timer/2</a>.</p><h3>ceil/1</h3><p>Returns the smallest integer not less than the argument</p><p>Returns the smallest integer not less than
<strong><span class="anno">Number</span></strong>.
For example:</p><pre>
&gt; <span class="input">ceil(5.5).</span>
6</pre><p>Allowed in guard tests.</p><h3>check_old_code/1</h3><p>Check if a module has old code.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Module</span></strong> has old code,
otherwise <strong>false</strong>.</p><p>See also <a href="./code">kernel/code</a>.</p><h3>check_process_code/2</h3><p>Check if a process executes old code for a module.</p><p>The same as
<a href="#check_process_code/3">check_process_code/3</a>.</p><h3>check_process_code/3</h3><p>Check if a process executes old code for a module.</p><p>Checks if the node local process identified by
<strong><span class="anno">Pid</span></strong>
executes old code for <strong><span class="anno">Module</span></strong>.</p><p><strong><span class="anno">Option</span></strong>s:</p><dl><dt><strong>{allow_gc, boolean()}</strong></dt><dd> <p>Determines if garbage collection is allowed when performing
the operation. If <strong>{allow_gc, false}</strong> is passed, and
a garbage collection is needed to determine the
result of the operation, the operation is aborted (see
information on <strong><span class="anno">CheckResult</span></strong> below).
The default is to allow garbage collection, that is,
<strong>{allow_gc, true}</strong>.</p> </dd><dt><strong>{async, RequestId}</strong></dt><dd> <p>The function <strong>check_process_code/3</strong> returns
the value <strong>async</strong> immediately after the request
has been sent. When the request has been processed, the
process that called this function is passed a
message on the form <strong>{check_process_code, <span class="anno">RequestId</span>, <span class="anno">CheckResult</span>}</strong>.</p> </dd></dl><p>If <strong><span class="anno">Pid</span></strong> equals <strong>self()</strong>, and
no <strong>async</strong> option has been passed, the operation
is performed at once. Otherwise a request for
the operation is sent to the process identified by
<strong><span class="anno">Pid</span></strong>, and is handled when
appropriate. If no <strong>async</strong> option has been passed,
the caller blocks until <strong><span class="anno">CheckResult</span></strong>
is available and can be returned.</p><p><strong><span class="anno">CheckResult</span></strong> informs about the result of
the request as follows:</p><dl><dt><strong>true</strong></dt><dd> <p>The process identified by <strong><span class="anno">Pid</span></strong>
executes old code for <strong><span class="anno">Module</span></strong>.
That is, the current call of the process executes old
code for this module, or the process has references
to old code for this module, or the process contains
funs that references old code for this module.</p> </dd><dt><strong>false</strong></dt><dd> <p>The process identified by <strong><span class="anno">Pid</span></strong> does
not execute old code for <strong><span class="anno">Module</span></strong>.</p> </dd><dt><strong>aborted</strong></dt><dd> <p>The operation was aborted, as the process needed to
be garbage collected to determine the operation result,
and the operation was requested
by passing option <strong>{allow_gc, false}</strong>.</p> </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Up until ERTS version 8.*, the check process code operation
checks for all types of references to the old code. That is,
direct references (e.g. return addresses on the process
stack), indirect references (<strong>fun</strong>s in process
context), and references to literals in the code.
</p><p>
As of ERTS version 9.0, the check process code operation
only checks for direct references to the code. Indirect
references via <strong>fun</strong>s will be ignored. If such
<strong>fun</strong>s exist and are used after a purge of the old
code, an exception will be raised upon usage (same as
the case when the <strong>fun</strong> is received by the process
after the purge). Literals will be taken care of (copied)
at a  later stage. This behavior can as of ERTS version
8.1 be enabled when
<a href="../doc/installation_guide/INSTALL#Advanced-configuration-and-build-of-ErlangOTP_Configuring">building OTP</a>,
and will automatically be enabled if dirty scheduler
support is enabled.
</p></div><p>See also <a href="./code">kernel/code</a>.</p><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">Pid</span></strong> is not a node local process identifier. </dd><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">Module</span></strong> is not an atom. </dd><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">OptionList</span></strong> is an invalid list of options. </dd></dl><h3>convert_time_unit/3</h3><p>Convert time unit of a time value.</p><p>Converts the <strong><span class="anno">Time</span></strong> value of time unit
<strong><span class="anno">FromUnit</span></strong> to the corresponding
<strong><span class="anno">ConvertedTime</span></strong> value of time unit
<strong><span class="anno">ToUnit</span></strong>. The result is rounded
using the floor function.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>You can lose accuracy and precision when converting
between time units. To minimize such loss, collect all
data at <strong>native</strong> time unit and do the conversion on the end
result.</p></div><h3>crc32/1</h3><p>Compute crc32 (IEEE 802.3) checksum.</p><p>Computes and returns the crc32 (IEEE 802.3 style) checksum
for <strong><span class="anno">Data</span></strong>.</p><h3>crc32/2</h3><p>Compute crc32 (IEEE 802.3) checksum.</p><p>Continues computing the crc32 checksum by combining
the previous checksum, <strong><span class="anno">OldCrc</span></strong>, with the checksum
of <strong><span class="anno">Data</span></strong>.</p><p>The following code:</p><pre><code class="">
X = erlang:crc32(Data1),
Y = erlang:crc32(X,Data2).</code></pre><p>assigns the same value to <strong>Y</strong> as this:</p><pre><code class="">
Y = erlang:crc32([Data1,Data2]).</code></pre><h3>crc32_combine/3</h3><p>Combine two crc32 (IEEE 802.3) checksums.</p><p>Combines two previously computed crc32 checksums.
This computation requires the size of the data object for
the second checksum to be known.</p><p>The following code:</p><pre><code class="">
Y = erlang:crc32(Data1),
Z = erlang:crc32(Y,Data2).</code></pre><p>assigns the same value to <strong>Z</strong> as this:</p><pre><code class="">
X = erlang:crc32(Data1),
Y = erlang:crc32(Data2),
Z = erlang:crc32_combine(X,Y,iolist_size(Data2)).</code></pre><h3>date/0</h3><p>Current date.</p><p>Returns the current date as <strong>{Year, Month, Day}</strong>.</p><p>The time zone and Daylight Saving Time correction depend on
the underlying OS. Example:</p><pre>
&gt; <span class="input">date().</span>
{1995,2,19}</pre><h3>decode_packet/3</h3><p>Extract a protocol packet from a binary.</p><p>Decodes the binary <strong><span class="anno">Bin</span></strong> according to the packet
protocol specified by <strong><span class="anno">Type</span></strong>. Similar to the packet
handling done by sockets with option
<strong>{packet,<span class="anno">Type</span>}.</strong></p><p>If an entire packet is contained in <strong><span class="anno">Bin</span></strong>, it is
returned together with the remainder of the binary as
<strong>{ok,<span class="anno">Packet</span>,<span class="anno">Rest</span>}</strong>.</p><p>If <strong><span class="anno">Bin</span></strong> does not contain the entire packet,
<strong>{more,<span class="anno">Length</span>}</strong> is returned.
<strong><span class="anno">Length</span></strong> is either the
expected <em>total size</em> of the packet, or <strong>undefined</strong>
if the expected packet size is unknown. <strong>decode_packet</strong>
can then be called again with more data added.</p><p>If the packet does not conform to the protocol format,
<strong>{error,<span class="anno">Reason</span>}</strong> is returned.</p><p><strong>Type</strong>s:</p><dl><dt><strong>raw | 0</strong></dt><dd> <p>No packet handling is done. The entire binary is
returned unless it is empty.</p> </dd><dt><strong>1 | 2 | 4</strong></dt><dd> <p>Packets consist of a header specifying the number of
bytes in the packet, followed by that number of bytes.
The length of the header can be one, two, or four bytes;
the order of the bytes is big-endian. The header
is stripped off when the packet is returned.</p> </dd><dt><strong>line</strong></dt><dd> <p>A packet is a line-terminated by a delimiter byte,
default is the latin-1 newline character. The delimiter
byte is included in the returned packet unless the line
was truncated according to option <strong>line_length</strong>.</p> </dd><dt><strong>asn1 | cdr | sunrm | fcgi | tpkt</strong></dt><dd> <p>The header is <em>not</em> stripped off.</p> <p>The meanings of the packet types are as follows:</p> <dl><dt><strong>asn1</strong> - ASN.1 BER</dt><dd></dd><dt><strong>sunrm</strong> - Sun's RPC encoding</dt><dd></dd><dt><strong>cdr</strong> - CORBA (GIOP 1.1)</dt><dd></dd><dt><strong>fcgi</strong> - Fast CGI</dt><dd></dd><dt><strong>tpkt</strong> - TPKT format [RFC1006]</dt><dd></dd></dl> </dd><dt><strong>http | httph | http_bin | httph_bin</strong></dt><dd> <p>The Hypertext Transfer Protocol. The packets
are returned with the format according to
<strong><span class="anno">HttpPacket</span></strong> described earlier.
A packet is either a
request, a response, a header, or an end of header
mark. Invalid lines are returned as
<strong><span class="anno">HttpError</span></strong>.</p> <p>Recognized request methods and header fields are returned
as atoms. Others are returned as strings. Strings of
unrecognized header fields are formatted with only
capital letters first and after hyphen characters, for
example, <strong>"Sec-Websocket-Key"</strong>.</p> <p>The protocol type <strong>http</strong> is only to be used for
the first line when an <strong><span class="anno">HttpRequest</span></strong> or an
<strong><span class="anno">HttpResponse</span></strong> is expected.
The following calls are to use <strong>httph</strong> to get
<strong><span class="anno">HttpHeader</span></strong>s until
<strong>http_eoh</strong> is returned, which marks the end of the
headers and the beginning of any following message body.</p>  <p>The variants <strong>http_bin</strong> and <strong>httph_bin</strong> return
strings (<strong>HttpString</strong>) as binaries instead of lists.</p> </dd></dl><p>Options:</p><dl><dt><strong>{packet_size, integer() &gt;= 0}</strong></dt><dd><p>Sets the maximum allowed size of the packet body.
If the packet header indicates that the length of the
packet is longer than the maximum allowed length, the
packet is considered invalid. Defaults to 0, which means
no size limit.</p> </dd><dt><strong>{line_length, integer() &gt;= 0}</strong></dt><dd> <p>For packet type <strong>line</strong>, lines longer than
the indicated length are truncated.</p> <p>Option <strong>line_length</strong> also applies to <strong>http*</strong>
packet types as an alias for option <strong>packet_size</strong>
if <strong>packet_size</strong> itself is not set. This use is
only intended for backward compatibility.</p> </dd><dt><strong>{line_delimiter, 0 =&lt; byte() =&lt; 255}</strong></dt><dd><p>For packet type <strong>line</strong>, sets the delimiting byte.
Default is the latin-1 character <strong>$\n</strong>.</p> </dd></dl><p>Examples:</p><pre>
&gt; <span class="input">erlang:decode_packet(1,&lt;&lt;3,"abcd"&gt;&gt;,[]).</span>
{ok,&lt;&lt;"abc"&gt;&gt;,&lt;&lt;"d"&gt;&gt;}
&gt; <span class="input">erlang:decode_packet(1,&lt;&lt;5,"abcd"&gt;&gt;,[]).</span>
{more,6}</pre><h3>delete_element/2</h3><p>Delete element at index in a tuple.</p><dl><dt>Index</dt><dd>1..tuple_size(<span class="anno">Tuple1</span>)</dd></dl><p>Returns a new tuple with element at <strong><span class="anno">Index</span></strong>
removed from tuple <strong><span class="anno">Tuple1</span></strong>, for example:</p><pre>
&gt; <span class="input">erlang:delete_element(2, {one, two, three}).</span>
{one,three}</pre><h3>delete_module/1</h3><p>Make the current code for a module old.</p><p>Makes the current code for <strong><span class="anno">Module</span></strong> become old
code and deletes all references for this module from the export table.
Returns <strong>undefined</strong> if the module does not exist,
otherwise <strong>true</strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for the code server (see
<a href="./code">kernel/code</a>)
and is not to be used elsewhere.</p></div><p>Failure: <strong>badarg</strong> if there already is an old version of
<strong>Module</strong>.</p><h3>demonitor/1</h3><p>Stop monitoring.</p><p>If <strong><span class="anno">MonitorRef</span></strong> is a reference that the
calling process obtained by calling
<a href="#monitor/2">monitor/2</a>,
this monitoring is turned off. If the monitoring is already
turned off, nothing happens.</p><p>Once <strong>demonitor(<span class="anno">MonitorRef</span>)</strong> has returned, it is
guaranteed that no <strong>{'DOWN', <span class="anno">MonitorRef</span>, _, _, _}</strong> message,
because of the monitor, will be placed in the caller message queue
in the future. However, a <strong>{'DOWN', <span class="anno">MonitorRef</span>, _, _, _}</strong> message
can have been placed in the caller message queue before
the call. It is therefore usually advisable
to remove such a <strong>'DOWN'</strong> message from the message queue
after monitoring has been stopped.
<a href="#demonitor/2">demonitor/2</a>
can be used instead of <strong>demonitor(<span class="anno">MonitorRef</span>)</strong>
if this cleanup is wanted.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Before Erlang/OTP R11B (ERTS 5.5) <strong>demonitor/1</strong>
behaved completely asynchronously, that is, the monitor was active
until the "demonitor signal" reached the monitored entity. This
had one undesirable effect. You could never know when
you were guaranteed <em>not</em> to receive a <strong>DOWN</strong> message
because of the monitor.</p><p>The current behavior can be viewed as two combined operations:
asynchronously send a "demonitor signal" to the monitored entity
and ignore any future results of the monitor.</p></div><p>Failure: It is an error if <strong><span class="anno">MonitorRef</span></strong> refers to a
monitoring started by another process. Not all such cases are
cheap to check. If checking is cheap, the call fails with
<strong>badarg</strong>, for example if <strong><span class="anno">MonitorRef</span></strong> is a
remote reference.</p><h3>demonitor/2</h3><p>Stop monitoring.</p><p>The returned value is <strong>true</strong> unless <strong>info</strong> is part
of <strong><span class="anno">OptionList</span></strong>.</p><p><strong>demonitor(<span class="anno">MonitorRef</span>, [])</strong> is equivalent to
<a href="#demonitor/1">demonitor/1</a>.</p><p><strong><span class="anno">Option</span></strong>s:</p><dl><dt><strong>flush</strong></dt><dd> <p>Removes (one) <strong>{_, <span class="anno">MonitorRef</span>, _, _, _}</strong> message,
if there is one, from the caller message queue after
monitoring has been stopped.</p> <p>Calling <strong>demonitor(<span class="anno">MonitorRef</span>, [flush])</strong>
is equivalent to the following, but more efficient:</p> <pre><code class="">
demonitor(MonitorRef),
receive
    {_, MonitorRef, _, _, _} -&gt;
        true
after 0 -&gt;
        true
end</code></pre> </dd><dt><strong>info</strong></dt><dd> <p>The returned value is one of the following:</p> <dl><dt><strong>true</strong></dt><dd><p>The monitor was found and removed. In this case,
no <strong>'DOWN'</strong> message corresponding to this
monitor has been delivered and will not be delivered.</p> </dd><dt><strong>false</strong></dt><dd><p>The monitor was not found and could not be removed.
This probably because someone already has placed a
<strong>'DOWN'</strong> message corresponding to this monitor
in the caller message queue.</p> </dd></dl> <p>If option <strong>info</strong> is combined with option <strong>flush</strong>,
<strong>false</strong> is returned if a flush was needed,
otherwise <strong>true</strong>.</p> </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>More options can be added in a future release.</p></div><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">OptionList</span></strong> is not a list. </dd><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">Option</span></strong> is an invalid option. </dd><dt><strong>badarg</strong></dt><dd>The same failure as for <a href="#demonitor/1">demonitor/1</a>. </dd></dl><h3>disconnect_node/1</h3><p>Force the disconnection of a node.</p><p>Forces the disconnection of a node. This appears to
the node <strong><span class="anno">Node</span></strong> as if the local node has crashed.
This BIF is mainly used in the Erlang network authentication
protocols.</p><p>Returns <strong>true</strong> if disconnection succeeds,
otherwise <strong>false</strong>. If the local node is not alive,
<strong>ignored</strong> is returned.</p><h3>display/1</h3><p>Print a term on standard output.</p><p>Prints a text representation of <strong><span class="anno">Term</span></strong> on the
standard output.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for debugging only.</p></div><h3>dist_ctrl_get_data/1</h3><p>Get distribution channel data to pass to another node.</p><p>
Get distribution channel data from the local node that is
to be passed to the remote node. The distribution channel
is identified by <strong><span class="anno">DHandle</span></strong>. If no data
is available, the atom <strong>none</strong> is returned. One
can request to be informed by a message when more
data is available by calling
<a href="./erlang#dist_ctrl_get_data_notification/1">erlang#dist_ctrl_get_data_notification/1</a>.
</p><p>The returned value when there are data available depends
on the value of the <strong>get_size</strong> option configured on the
distribution channel identified by <strong><span class="anno">DHandle</span></strong>.
For more information see the documentation of the <strong>get_size</strong>
option for the
<a href="#dist_ctrl_set_opt/3">dist_ctrl_set_opt/3</a>
function.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Only the process registered as distribution
controller for the distribution channel identified by
<strong><span class="anno">DHandle</span></strong> is allowed to call this
function.
</p></div><p>
This function is used when implementing an alternative
distribution carrier using processes as distribution
controllers. <strong><span class="anno">DHandle</span></strong> is retrived
via the callback
<a href="../erts/alt_dist#hs_data_f_handshake_complete">erts/alt_dist#hs_data_f_handshake_complete</a>.
More information can be found in the documentation of
<a href="../erts/alt_dist#distribution_module">ERTS User's Guide  How to implement an Alternative Carrier for the Erlang Distribution  Distribution Module</a>.
</p><h3>dist_ctrl_get_opt/2</h3><p>Get value of the get_size option on a distribution channel</p><p>Returns the value of the <strong>get_size</strong> option on the distribution channel
identified by <strong><span class="anno">DHandle</span></strong>. For more information see the
documentation of the <strong>get_size</strong> option for the
<a href="#dist_ctrl_set_opt/3">dist_ctrl_set_opt/3</a>
function.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Only the process registered as distribution
controller for the distribution channel identified by
<strong><span class="anno">DHandle</span></strong> is allowed to call this
function.
</p></div><p>
This function is used when implementing an alternative
distribution carrier using processes as distribution
controllers. <strong><span class="anno">DHandle</span></strong> is retrived
via the callback
<a href="../erts/alt_dist#hs_data_f_handshake_complete">erts/alt_dist#hs_data_f_handshake_complete</a>.
More information can be found in the documentation of
<a href="../erts/alt_dist#distribution_module">ERTS User's Guide  How to implement an Alternative Carrier for the Erlang Distribution  Distribution Module</a>.
</p><h3>dist_ctrl_get_data_notification/1</h3><p>Request notification about available outgoing distribution channel data.</p><p>
Request notification when more data is available to
fetch using
<a href="./erlang#dist_ctrl_get_data/1">erlang#dist_ctrl_get_data/1</a>
for the distribution channel identified by
<strong><span class="anno">DHandle</span></strong>. When more data is present,
the caller will be sent the message <strong>dist_data</strong>.
Once a <strong>dist_data</strong> messages has been sent, no
more <strong>dist_data</strong> messages will be sent until
the <strong>dist_ctrl_get_data_notification/1</strong> function has been called
again.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Only the process registered as distribution
controller for the distribution channel identified by
<strong><span class="anno">DHandle</span></strong> is allowed to call this
function.
</p></div><p>
This function is used when implementing an alternative
distribution carrier using processes as distribution
controllers. <strong><span class="anno">DHandle</span></strong> is retrived
via the callback
<a href="../erts/alt_dist#hs_data_f_handshake_complete">erts/alt_dist#hs_data_f_handshake_complete</a>.
More information can be found in the documentation of
<a href="../erts/alt_dist#distribution_module">ERTS User's Guide  How to implement an Alternative Carrier for the Erlang Distribution  Distribution Module</a>.
</p><h3>dist_ctrl_input_handler/2</h3><p>Register distribution channel input handler process.</p><p>
Register an alternate input handler process for the
distribution channel identified by <strong><span class="anno">DHandle</span></strong>.
Once this function has been called, <strong><span class="anno">InputHandler</span></strong>
is the only process allowed to call
<a href="./erlang#dist_ctrl_put_data/2">erlang#dist_ctrl_put_data/2</a>
with the <strong><span class="anno">DHandle</span></strong> identifing this distribution
channel.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Only the process registered as distribution
controller for the distribution channel identified by
<strong><span class="anno">DHandle</span></strong> is allowed to call this
function.
</p></div><p>
This function is used when implementing an alternative
distribution carrier using processes as distribution
controllers. <strong><span class="anno">DHandle</span></strong> is retrived
via the callback
<a href="../erts/alt_dist#hs_data_f_handshake_complete">erts/alt_dist#hs_data_f_handshake_complete</a>.
More information can be found in the documentation of
<a href="../erts/alt_dist#distribution_module">ERTS User's Guide  How to implement an Alternative Carrier for the Erlang Distribution  Distribution Module</a>.
</p><h3>dist_ctrl_put_data/2</h3><p>Pass data into the VM from a distribution channel.</p><p>
Deliver distribution channel data from a remote node to the
local node.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Only the process registered as distribution
controller for the distribution channel identified by
<strong><span class="anno">DHandle</span></strong> is allowed to call this
function unless an alternate input handler process
has been registered using
<a href="./erlang#dist_ctrl_input_handler/2">erlang#dist_ctrl_input_handler/2</a>.
If an alternate input handler has been registered, only
the registered input handler process is allowed to call
this function.
</p></div><p>
This function is used when implementing an alternative
distribution carrier using processes as distribution
controllers. <strong><span class="anno">DHandle</span></strong> is retrived
via the callback
<a href="../erts/alt_dist#hs_data_f_handshake_complete">erts/alt_dist#hs_data_f_handshake_complete</a>.
More information can be found in the documentation of
<a href="../erts/alt_dist#distribution_module">ERTS User's Guide  How to implement an Alternative Carrier for the Erlang Distribution  Distribution Module</a>.
</p><h3>dist_ctrl_set_opt/3</h3><p>Set value of the get_size option on a distribution channel</p><p>Sets the value of the <strong>get_size</strong> option on the distribution channel
identified by <strong><span class="anno">DHandle</span></strong>. This option controls the return
value of calls to
<a href="#dist_ctrl_get_data/1">erlang:dist_ctrl_get_data()</a>
where <strong><span class="anno">DHandle</span></strong> equals <strong><span class="anno">DHandle</span></strong> used
when setting this option.
When the <strong>get_size</strong> option is:</p><dl><dt><strong>false</strong></dt><dd> and there are distribution data available, a call to <strong>erlang:dist_ctrl_get_data(<span class="anno">DHandle</span>)</strong> will just return <strong>Data</strong> to pass over the channel. This is the default value of the <strong>get_size</strong> option. </dd><dt><strong>true</strong></dt><dd> and there are distribution data available, a call to <strong>erlang:dist_ctrl_get_data(<span class="anno">DHandle</span>)</strong> will return <strong>Data</strong> to pass over the channel as well as the <strong>Size</strong> of <strong>Data</strong> in bytes. This is returned as a tuple on the form <strong>{Size, Data}</strong>. </dd></dl><p>All options are set to default when a channel is closed.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Only the process registered as distribution
controller for the distribution channel identified by
<strong><span class="anno">DHandle</span></strong> is allowed to call this
function.
</p></div><p>
This function is used when implementing an alternative
distribution carrier using processes as distribution
controllers. <strong><span class="anno">DHandle</span></strong> is retrived
via the callback
<a href="../erts/alt_dist#hs_data_f_handshake_complete">erts/alt_dist#hs_data_f_handshake_complete</a>.
More information can be found in the documentation of
<a href="../erts/alt_dist#distribution_module">ERTS User's Guide  How to implement an Alternative Carrier for the Erlang Distribution  Distribution Module</a>.
</p><h3>element/2</h3><p>Return the Nth element of a tuple.</p><dl><dt>N</dt><dd>1..tuple_size(<span class="anno">Tuple</span>)</dd></dl><p>Returns the <strong><span class="anno">N</span></strong>th element (numbering from 1) of
<strong><span class="anno">Tuple</span></strong>, for example:</p><pre>
&gt; <span class="input">element(2, {a, b, c}).</span>
b</pre><p>Allowed in guard tests.</p><h3>erase/0</h3><p>Return and delete the process dictionary.</p><p>Returns the process dictionary and deletes it, for
example:</p><pre>
&gt; <span class="input">put(key1, {1, 2, 3}),</span>
<span class="input">put(key2, [a, b, c]),</span>
<span class="input">erase().</span>
[{key1,{1,2,3}},{key2,[a,b,c]}]</pre><h3>erase/1</h3><p>Return and delete a value from the process dictionary. </p><p>Returns the value <strong><span class="anno">Val</span></strong> associated with
<strong><span class="anno">Key</span></strong> and deletes it from the process dictionary.
Returns <strong>undefined</strong> if no value is associated with
<strong><span class="anno">Key</span></strong>. Example:</p><pre>
&gt; <span class="input">put(key1, {merry, lambs, are, playing}),</span>
<span class="input">X = erase(key1),</span>
<span class="input">{X, erase(key1)}.</span>
{{merry,lambs,are,playing},undefined}</pre><h3>error/1</h3><p>Stop execution with a specified reason.</p><p>Stops the execution of the calling process with the reason
<strong><span class="anno">Reason</span></strong>, where <strong><span class="anno">Reason</span></strong>
is any term. The exit reason is
<strong>{<span class="anno">Reason</span>, Where}</strong>, where <strong>Where</strong>
is a list of the functions most recently called (the current
function first). As evaluating this function causes
the process to terminate, it has no return value. Example:</p><pre>
&gt; <span class="input">catch error(foobar).</span>
{'EXIT',{foobar,[{shell,apply_fun,3,
                        [{file,"shell.erl"},{line,906}]},
                 {erl_eval,do_apply,6,[{file,"erl_eval.erl"},{line,677}]},
                 {erl_eval,expr,5,[{file,"erl_eval.erl"},{line,430}]},
                 {shell,exprs,7,[{file,"shell.erl"},{line,687}]},
                 {shell,eval_exprs,7,[{file,"shell.erl"},{line,642}]},
                 {shell,eval_loop,3,[{file,"shell.erl"},{line,627}]}]}}
</pre><h3>error/2</h3><p>Stop execution with a specified reason.</p><p>Stops the execution of the calling process with the reason
<strong><span class="anno">Reason</span></strong>, where <strong><span class="anno">Reason</span></strong>
is any term. The exit reason is
<strong>{<span class="anno">Reason</span>, Where}</strong>, where <strong>Where</strong>
is a list of the functions most recently called (the current
function first). <strong><span class="anno">Args</span></strong> is expected to be the
list of arguments for the current function; in Beam it is used
to provide the arguments for the current function in
the term <strong>Where</strong>. As evaluating this function causes
the process to terminate, it has no return value.</p><h3>exit/1</h3><p>Stop execution with a specified reason.</p><p>Stops the execution of the calling process with exit reason
<strong><span class="anno">Reason</span></strong>, where <strong><span class="anno">Reason</span></strong>
is any term. As
evaluating this function causes the process to terminate, it
has no return value. Example:</p><pre>
&gt; <span class="input">exit(foobar).</span>
** exception exit: foobar
&gt; <span class="input">catch exit(foobar).</span>
{'EXIT',foobar}</pre><h3>exit/2</h3><p>Send an exit signal to a process or a port.</p><p>Sends an exit signal with exit reason <strong><span class="anno">Reason</span></strong> to
the process or port identified by <strong><span class="anno">Pid</span></strong>.</p><p>The following behavior applies if <strong><span class="anno">Reason</span></strong>
is any term, except <strong>normal</strong> or <strong>kill</strong>:</p><ul><li><p>If <strong><span class="anno">Pid</span></strong> is not trapping exits,
<strong><span class="anno">Pid</span></strong>
itself exits with exit reason <strong><span class="anno">Reason</span></strong>.</p> </li><li><p>If <strong><span class="anno">Pid</span></strong> is trapping exits, the exit
signal is transformed into a message
<strong>{'EXIT', From, <span class="anno">Reason</span>}</strong>
and delivered to the message queue of <strong><span class="anno">Pid</span></strong>.</p> </li><li><p><strong>From</strong> is the process identifier of the process
that sent the exit signal. See also
<a href="#process_flag/2">process_flag/2</a>.</p> </li></ul><p>If <strong><span class="anno">Reason</span></strong> is the atom <strong>normal</strong>,
<strong><span class="anno">Pid</span></strong>
does not exit. If it is trapping exits, the exit signal is
transformed into a message <strong>{'EXIT', From, normal}</strong>
and delivered to its message queue.</p><p>If <strong><span class="anno">Reason</span></strong> is the atom <strong>kill</strong>,
that is, if <strong>exit(<span class="anno">Pid</span>, kill)</strong> is called,
an untrappable exit signal is sent to <strong><span class="anno">Pid</span></strong>,
which unconditionally exits with exit reason <strong>killed</strong>.</p><h3>external_size/1</h3><p>Calculate the maximum size for a term encoded in the Erlang external term format.</p><p>Calculates, without doing the encoding, the maximum byte size for
a term encoded in the Erlang external term format. The following
condition applies always:</p><pre>
&gt; <span class="input">Size1 = byte_size(term_to_binary()),</span>
&gt; <span class="input">Size2 = erlang:external_size(),</span>
&gt; <span class="input">true = Size1 =&lt; Size2.</span>
true</pre><p>This is equivalent to a call to:</p><pre><code class="">
erlang:external_size(<span class="anno">Term</span>, [])</code></pre><h3>external_size/2</h3><p>Calculate the maximum size for a term encoded in the Erlang external term format.</p><p>Calculates, without doing the encoding, the maximum byte size for
a term encoded in the Erlang external term format. The following
condition applies always:</p><pre>
&gt; <span class="input">Size1 = byte_size(term_to_binary(, )),</span>
&gt; <span class="input">Size2 = erlang:external_size(, ),</span>
&gt; <span class="input">true = Size1 =&lt; Size2.</span>
true</pre><p>Option <strong>{minor_version, <span class="anno">Version</span>}</strong> specifies how
floats are encoded. For a detailed description, see
<a href="#term_to_binary/2">term_to_binary/2</a>.</p><h3>float/1</h3><p>Convert a number to a float.</p><p>Returns a float by converting <strong><span class="anno">Number</span></strong> to a float,
for example:</p><pre>
&gt; <span class="input">float(55).</span>
55.0</pre><p>Allowed in guard tests.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If used on the top level in a guard, it tests whether the
argument is a floating point number; for clarity, use
<a href="#is_float/1">is_float/1</a>
instead.</p><p>When <strong>float/1</strong> is used in an expression in a guard,
such as '<strong>float(A) == 4.0</strong>', it converts a number as
described earlier.</p></div><h3>float_to_binary/1</h3><p>Text representation of a float.</p><p>The same as
<strong>float_to_binary(<span class="anno">Float</span>,[{scientific,20}])</strong>.</p><h3>float_to_binary/2</h3><p>Text representation of a float formatted using specified options.</p><p>Returns a binary corresponding to the text
representation of <strong><span class="anno">Float</span></strong> using fixed decimal 
point formatting. <strong><span class="anno">Options</span></strong> behaves in the same
way as <a href="#float_to_list/2">float_to_list/2</a>. Examples:</p><pre>
&gt; <span class="input">float_to_binary(7.12, [{decimals, 4}]).</span>
&lt;&lt;"7.1200"&gt;&gt;
&gt; <span class="input">float_to_binary(7.12, [{decimals, 4}, compact]).</span>
&lt;&lt;"7.12"&gt;&gt;</pre><h3>float_to_list/1</h3><p>Text representation of a float.</p><p>The same as
<strong>float_to_list(<span class="anno">Float</span>,[{scientific,20}])</strong>.</p><h3>float_to_list/2</h3><p>Text representation of a float formatted using specified options.</p><p>Returns a string corresponding to the text representation
of <strong>Float</strong> using fixed decimal point formatting.</p><p>Available options:</p><ul><li><p>If option <strong>decimals</strong> is specified, the returned value
contains at most <strong>Decimals</strong> number of digits past the
decimal point. If the number does not fit in the internal
static buffer of 256 bytes, the function throws <strong>badarg</strong>.</p> </li><li><p>If option <strong>compact</strong> is specified, the trailing zeros
at the end of the list are truncated. This option is only
meaningful together with option <strong>decimals</strong>.</p> </li><li><p>If option <strong>scientific</strong> is specified, the float is
formatted using scientific notation with <strong>Decimals</strong>
digits of precision.</p> </li><li><p>If <strong>Options</strong> is <strong>[]</strong>, the function behaves as
<a href="#float_to_list/1">float_to_list/1</a>.</p> </li></ul><p>Examples:</p><pre>
&gt; <span class="input">float_to_list(7.12, [{decimals, 4}]).</span>
"7.1200"
&gt; <span class="input">float_to_list(7.12, [{decimals, 4}, compact]).</span>
"7.12"</pre><h3>floor/1</h3><p>Returns the largest integer not greater than the argument</p><p>Returns the largest integer not greater than
<strong><span class="anno">Number</span></strong>.
For example:</p><pre>
&gt; <span class="input">floor(-10.5).</span>
-11</pre><p>Allowed in guard tests.</p><h3>fun_info/1</h3><p>Information about a fun.</p><p>Returns a list with information about the fun
<strong><span class="anno">Fun</span></strong>. Each list element is a tuple. The order
of the tuples is undefined, and more tuples can be added in a
future release.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is mainly intended for debugging, but it can
sometimes be useful in library functions that need
to verify, for example, the arity of a fun.</p></div><p>Two types of funs have slightly different semantics:</p><ul><li><p>A fun created by <strong>fun M:F/A</strong> is called an
<em>external</em> fun. Calling it will always call the
function <strong>F</strong> with arity <strong>A</strong> in the latest code for
module <strong>M</strong>. Notice that module <strong>M</strong> does not even
need to be loaded when the fun <strong>fun M:F/A</strong> is created.</p> </li><li><p>All other funs are called <em>local</em>. When a local fun
is called, the same version of the code that created the fun
is called (even if a newer version of the module has been
loaded).</p> </li></ul><p>The following elements are always present in the list
for both local and external funs:</p><dl><dt><strong>{type, Type}</strong></dt><dd> <p><strong>Type</strong> is <strong>local</strong> or <strong>external</strong>.</p> </dd><dt><strong>{module, Module}</strong></dt><dd> <p><strong>Module</strong> (an atom) is the module name.</p> <p>If <strong>Fun</strong> is a local fun, <strong>Module</strong> is the module
in which the fun is defined.</p> <p>If <strong>Fun</strong> is an external fun, <strong>Module</strong> is the
module that the fun refers to.</p> </dd><dt><strong>{name, Name}</strong></dt><dd> <p><strong>Name</strong> (an atom) is a function name.</p> <p>If <strong>Fun</strong> is a local fun, <strong>Name</strong> is the name
of the local function that implements the fun.
(This name was generated by the compiler, and is
only of informational use. As it is a local function, it
cannot be called directly.)
If no code is currently loaded for the fun, <strong>[]</strong>
is returned instead of an atom.</p> <p>If <strong>Fun</strong> is an external fun, <strong>Name</strong> is the name
of the exported function that the fun refers to.</p> </dd><dt><strong>{arity, Arity}</strong></dt><dd> <p><strong>Arity</strong> is the number of arguments that the fun
is to be called with.</p> </dd><dt><strong>{env, Env}</strong></dt><dd> <p><strong>Env</strong> (a list) is the environment or free variables
for the fun. For external funs, the returned list is
always empty.</p> </dd></dl><p>The following elements are only present in the list if
<strong>Fun</strong> is local:</p><dl><dt><strong>{pid, Pid}</strong></dt><dd> <p><strong>Pid</strong> is the process identifier of the process
that originally created the fun.</p> <p>It might point to the <strong>init</strong> process if the
<strong>Fun</strong> was statically allocated when module was
loaded (this optimisation is performed for local
functions that do not capture the enviornment).</p> </dd><dt><strong>{index, Index}</strong></dt><dd> <p><strong>Index</strong> (an integer) is an index into the module
fun table.</p> </dd><dt><strong>{new_index, Index}</strong></dt><dd> <p><strong>Index</strong> (an integer) is an index into the module
fun table.</p> </dd><dt><strong>{new_uniq, Uniq}</strong></dt><dd> <p><strong>Uniq</strong> (a binary) is a unique value for this fun. It
is calculated from the compiled code for the entire module.</p> </dd><dt><strong>{uniq, Uniq}</strong></dt><dd> <p><strong>Uniq</strong> (an integer) is a unique value for this fun.
As from Erlang/OTP R15, this integer is calculated from the
compiled code for the entire module. Before Erlang/OTP R15, this
integer was based on only the body of the fun.</p> </dd></dl><h3>fun_info/2</h3><p>Information about a fun.</p><ul><li>fun_info_item</li></ul><p>Returns information about <strong><span class="anno">Fun</span></strong> as specified by
<strong><span class="anno">Item</span></strong>, in the form
<strong>{<span class="anno">Item</span>,<span class="anno">Info</span>}</strong>.</p><p>For any fun, <strong><span class="anno">Item</span></strong> can be any of the atoms
<strong>module</strong>, <strong>name</strong>, <strong>arity</strong>, <strong>env</strong>, or
<strong>type</strong>.</p><p>For a local fun, <strong><span class="anno">Item</span></strong> can also be any of the
atoms <strong>index</strong>, <strong>new_index</strong>, <strong>new_uniq</strong>,
<strong>uniq</strong>, and <strong>pid</strong>. For an external fun, the value
of any of these items is always the atom <strong>undefined</strong>.</p><p>See
<a href="#fun_info/1">fun_info/1</a>.</p><h3>fun_to_list/1</h3><p>Text representation of a fun.</p><p>Returns a string corresponding to the text
representation of <strong><span class="anno">Fun</span></strong>.</p><h3>function_exported/3</h3><p>Check if a function is exported and loaded.</p><p>Returns <strong>true</strong> if the module <strong><span class="anno">Module</span></strong> is
loaded and contains an exported function
<strong><span class="anno">Function</span>/<span class="anno">Arity</span></strong>,
or if there is a BIF (a built-in function implemented in C)
with the specified name, otherwise returns <strong>false</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function used to return <strong>false</strong> for BIFs
before Erlang/OTP 18.0.</p></div><h3>garbage_collect/0</h3><p>Force an immediate garbage collection of the calling process. </p><p>Forces an immediate garbage collection of the
executing process. The function is not to be used unless
it has been noticed (or there are good reasons to suspect)
that the spontaneous garbage collection will occur too late
or not at all.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Improper use can seriously degrade system performance.</p></div><h3>garbage_collect/1</h3><p>Garbage collect a process.</p><p>The same as
<a href="#garbage_collect/2">garbage_collect/2</a>.</p><h3>garbage_collect/2</h3><p>Garbage collect a process.</p><p>Garbage collects the node local process identified by
<strong><span class="anno">Pid</span></strong>.</p><p><strong><span class="anno">Option</span></strong>:</p><dl><dt><strong>{async, RequestId}</strong></dt><dd>The function <strong>garbage_collect/2</strong> returns the value <strong>async</strong> immediately after the request has been sent. When the request has been processed, the process that called this function is passed a message on the form <strong>{garbage_collect, <span class="anno">RequestId</span>, <span class="anno">GCResult</span>}</strong>. </dd><dt><strong>{type, 'major' | 'minor'}</strong></dt><dd>Triggers garbage collection of requested type. Default value is <strong>'major'</strong>, which would trigger a fullsweep GC. The option <strong>'minor'</strong> is considered a hint and may lead to either minor or major GC run.</dd></dl><p>If <strong><span class="anno">Pid</span></strong> equals <strong>self()</strong>, and
no <strong>async</strong> option has been passed, the garbage
collection is performed at once, that is, the same as calling
<a href="#garbage_collect/0">garbage_collect/0</a>.
Otherwise a request for garbage collection
is sent to the process identified by <strong><span class="anno">Pid</span></strong>,
and will be handled when appropriate. If no <strong>async</strong>
option has been passed, the caller blocks until
<strong><span class="anno">GCResult</span></strong> is available and can be returned.</p><p><strong><span class="anno">GCResult</span></strong> informs about the result of
the garbage collection request as follows:</p><dl><dt><strong>true</strong></dt><dd> The process identified by <strong><span class="anno">Pid</span></strong> has been garbage collected. </dd><dt><strong>false</strong></dt><dd> No garbage collection was performed, as the process identified by <strong><span class="anno">Pid</span></strong> terminated before the request could be satisfied. </dd></dl><p>Notice that the same caveats apply as for
<a href="#garbage_collect/0">garbage_collect/0</a>.</p><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Pid</span></strong> is not a node local process identifier. </dd><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">OptionList</span></strong> is an invalid list of options. </dd></dl><h3>get/0</h3><p>Return the process dictionary.</p><p>Returns the process dictionary as a list of
<strong>{<span class="anno">Key</span>, <span class="anno">Val</span>}</strong> tuples, for example:</p><pre>
&gt; <span class="input">put(key1, merry),</span>
<span class="input">put(key2, lambs),</span>
<span class="input">put(key3, {are, playing}),</span>
<span class="input">get().</span>
[{key1,merry},{key2,lambs},{key3,{are,playing}}]</pre><h3>get/1</h3><p>Return a value from the process dictionary.</p><p>Returns the value <strong><span class="anno">Val</span></strong> associated with
<strong><span class="anno">Key</span></strong> in the process dictionary, or <strong>undefined</strong>
if <strong><span class="anno">Key</span></strong> does not exist. Example:</p><pre>
&gt; <span class="input">put(key1, merry),</span>
<span class="input">put(key2, lambs),</span>
<span class="input">put({any, [valid, term]}, {are, playing}),</span>
<span class="input">get({any, [valid, term]}).</span>
{are,playing}</pre><h3>get_cookie/0</h3><p>Get the magic cookie of the local node.</p><p>Returns the magic cookie of the local node if the node is
alive, otherwise the atom <strong>nocookie</strong>.</p><h3>get_keys/0</h3><p>Return a list of all keys from the process dictionary. </p><p>Returns a list of all keys present in the process dictionary,
for example:</p><pre>
&gt; <span class="input">put(dog, {animal,1}),</span>
<span class="input">put(cow, {animal,2}),</span>
<span class="input">put(lamb, {animal,3}),</span>
<span class="input">get_keys().</span>
[dog,cow,lamb]</pre><h3>get_keys/1</h3><p>Return a list of keys from the process dictionary.</p><p>Returns a list of keys that are associated with the value
<strong><span class="anno">Val</span></strong> in the process dictionary, for example:</p><pre>
&gt; <span class="input">put(mary, {1, 2}),</span>
<span class="input">put(had, {1, 2}),</span>
<span class="input">put(a, {1, 2}),</span>
<span class="input">put(little, {1, 2}),</span>
<span class="input">put(dog, {1, 3}),</span>
<span class="input">put(lamb, {1, 2}),</span>
<span class="input">get_keys({1, 2}).</span>
[mary,had,a,little,lamb]</pre><h3>get_stacktrace/0</h3><p>Get the call stack back-trace of the last exception.</p><ul><li>stack_item</li></ul><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p><strong>erlang:get_stacktrace/0</strong> is deprecated and will stop working
in a future release.</p></div><p>Instead of using <strong>erlang:get_stacktrace/0</strong> to retrieve
the call stack back-trace, use the following syntax:</p><pre>
try Expr
catch
  Class:Reason:Stacktrace -&gt;
   {Class,Reason,Stacktrace}
end</pre><p><strong>erlang:get_stacktrace/0</strong> retrieves the call stack back-trace
(<em>stacktrace</em>) for an exception that has just been
caught in the calling process as a list of
<strong>{<span class="anno">Module</span>,<span class="anno">Function</span>,<span class="anno">Arity</span>,<span class="anno">Location</span>}</strong>
tuples. Field <strong><span class="anno">Arity</span></strong> in the first tuple can
be the argument list of that function call instead of an arity
integer, depending on the exception.</p><p>If there has not been any exceptions in a process, the
stacktrace is <strong>[]</strong>. After a code change for the process,
the stacktrace can also be reset to <strong>[]</strong>.</p><p>The stacktrace is the same data as operator <strong>catch</strong>
returns, for example:</p><pre>
{'EXIT',{badarg,Stacktrace}} = catch abs(x)</pre><p><strong><span class="anno">Location</span></strong> is a (possibly empty) list
of two-tuples that
can indicate the location in the source code of the function.
The first element is an atom describing the type of
information in the second element. The following
items can occur:</p><dl><dt><strong>file</strong></dt><dd>The second element of the tuple is a string (list of characters) representing the filename of the source file of the function. </dd><dt><strong>line</strong></dt><dd>The second element of the tuple is the line number (an integer &gt; 0) in the source file where the exception occurred or the function was called. </dd></dl><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Developers should rely on stacktrace entries only for
debugging purposes.</p><p>The VM performs tail call optimization, which
does not add new entries to the stacktrace, and also limits stacktraces
to a certain depth. Furthermore, compiler options, optimizations and
future changes may add or remove stacktrace entries, causing any code
that expects the stacktrace to be in a certain order or contain specific
items to fail.</p><p>The only exception to this rule is <strong>error:undef</strong> which
guarantees to include the <span class="anno">Module</span>, <span class="anno">Function</span> and <span class="anno">Arity</span>
of the attempted function as the first stacktrace entry.</p></div><p>See also
<a href="#error/1">error/1</a> and
<a href="#error/2">error/2</a>.</p><h3>group_leader/0</h3><p>Get the group leader for the calling process.</p><p>Returns the process identifier of the group leader for the
process evaluating the function.</p><p>Every process is a member of some process group and all
groups have a <em>group leader</em>. All I/O from the group
is channeled to the group leader. When a new process is
spawned, it gets the same group leader as the spawning
process. Initially, at system startup, <strong>init</strong> is both
its own group leader and the group leader of all processes.</p><h3>group_leader/2</h3><p>Set the group leader for a process.</p><p>Sets the group leader of <strong><span class="anno">Pid</span></strong>
to <strong><span class="anno">GroupLeader</span></strong>.
Typically, this is used when a process started from a
certain shell is to have another group leader than
<strong>init</strong>.</p><p>The group leader should be rarely changed in
applications with a supervision tree, because OTP
assumes the group leader of their processes is
their application master.</p><p>See also
<a href="#group_leader/0">group_leader/0</a>
and <a href="../doc/design_principles/applications#stopping">OTP design principles</a> related to starting and stopping
applications.</p><h3>halt/0</h3><p>Halt the Erlang runtime system and indicate normal exit to the calling environment.</p><p>The same as
<a href="#halt/2">halt/2</a>. Example:</p><pre>
&gt; <span class="input">halt().</span>
os_prompt%</pre><h3>halt/1</h3><p>Halt the Erlang runtime system.</p><p>The same as <a href="#halt/2">halt/2</a>. Example:</p><pre>
&gt; <span class="input">halt(17).</span>
os_prompt% <span class="input">echo $?</span>
17
os_prompt%</pre><h3>halt/2</h3><p>Halt the Erlang runtime system.</p><p><strong><span class="anno">Status</span></strong> must be a non-negative integer, a string,
or the atom <strong>abort</strong>.
Halts the Erlang runtime system. Has no return value.
Depending on <strong><span class="anno">Status</span></strong>, the following occurs:</p><dl><dt>integer()</dt><dd>The runtime system exits with integer value <strong><span class="anno">Status</span></strong> as status code to the calling environment (OS). <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>On many platforms, the OS supports only status
codes 0-255. A too large status code is truncated by clearing
the high bits.</p></div> </dd><dt>string()</dt><dd>An Erlang crash dump is produced with <strong><span class="anno">Status</span></strong> as slogan. Then the runtime system exits with status code <strong>1</strong>. The string will be truncated if longer than 200 characters. <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Before ERTS 9.1 (OTP-20.1) only code points in the range 0-255
was accepted in the string. Now any unicode string is valid.</p></div> </dd><dt><strong>abort</strong></dt><dd>The runtime system aborts producing a core dump, if that is enabled in the OS. </dd></dl><p>For integer <strong><span class="anno">Status</span></strong>, the Erlang runtime system
closes all ports and allows async threads to finish their
operations before exiting. To exit without such flushing, use
<strong><span class="anno">Option</span></strong> as <strong>{flush,false}</strong>.</p><p>For statuses <strong>string()</strong> and <strong>abort</strong>, option
<strong>flush</strong> is ignored and flushing is <em>not</em> done.</p><h3>hd/1</h3><p>Head of a list.</p><p>Returns the head of <strong><span class="anno">List</span></strong>, that is,
the first element, for example:</p><pre>
&gt; <span class="input">hd([1,2,3,4,5]).</span>
1</pre><p>Allowed in guard tests.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">List</span></strong> is the empty
list <strong>[]</strong>.</p><h3>hibernate/3</h3><p>Hibernate a process until a message is sent to it.</p><p>Puts the calling process into a wait state where its memory
allocation has been reduced as much as possible. This is
useful if the process does not expect to receive any messages
soon.</p><p>The process is awaken when a message is sent to it, and control
resumes in <strong><span class="anno">Module</span>:<span class="anno">Function</span></strong> with
the arguments specified by <strong><span class="anno">Args</span></strong> with the call
stack emptied, meaning that the process terminates when that
function returns. Thus <strong>erlang:hibernate/3</strong> never
returns to its caller.</p><p>If the process has any message in its message queue,
the process is awakened immediately in the same way as
described earlier.</p><p>In more technical terms, <strong>erlang:hibernate/3</strong>
discards the call stack for the process,
and then garbage collects the process. After this,
all live data is in one continuous heap. The heap
is then shrunken to the exact same size as the live data
that it holds (even if that size is less than the minimum
heap size for the process).</p><p>If the size of the live data in the process is less than
the minimum heap size, the first garbage collection occurring
after the process is awakened ensures that the heap
size is changed to a size not smaller than the minimum heap
size.</p><p>Notice that emptying the call stack means that any surrounding
<strong>catch</strong> is removed and must be re-inserted after
hibernation. One effect of this is that processes started
using <strong>proc_lib</strong> (also indirectly, such as
<strong>gen_server</strong> processes), are to use
<a href="../stdlib/proc_lib#hibernate/3">stdlib/proc_lib#hibernate/3</a>
instead, to ensure that the exception handler continues to work
when the process wakes up.</p><h3>insert_element/3</h3><p>Insert an element at index in a tuple.</p><dl><dt>Index</dt><dd>1..tuple_size(<span class="anno">Tuple1</span>) + 1</dd></dl><p>Returns a new tuple with element <strong><span class="anno">Term</span></strong>
inserted at position
<strong><span class="anno">Index</span></strong> in tuple <strong><span class="anno">Tuple1</span></strong>.
All elements from position <strong><span class="anno">Index</span></strong> and upwards are
pushed one step higher in the new tuple <strong><span class="anno">Tuple2</span></strong>.
Example:</p><pre>
&gt; <span class="input">erlang:insert_element(2, {one, two, three}, new).</span>
{one,new,two,three}</pre><h3>integer_to_binary/1</h3><p>Text representation of an integer.</p><p>Returns a binary corresponding to the text
representation of <strong><span class="anno">Integer</span></strong>, for example:</p><pre>
&gt; <span class="input">integer_to_binary(77).</span>
&lt;&lt;"77"&gt;&gt;</pre><h3>integer_to_binary/2</h3><p>Text representation of an integer.</p><p>Returns a binary corresponding to the text
representation of <strong><span class="anno">Integer</span></strong> in base
<strong><span class="anno">Base</span></strong>, for example:</p><pre>
&gt; <span class="input">integer_to_binary(1023, 16).</span>
&lt;&lt;"3FF"&gt;&gt;</pre><h3>integer_to_list/1</h3><p>Text representation of an integer.</p><p>Returns a string corresponding to the text
representation of <strong><span class="anno">Integer</span></strong>, for example:</p><pre>
&gt; <span class="input">integer_to_list(77).</span>
"77"</pre><h3>integer_to_list/2</h3><p>Text representation of an integer.</p><p>Returns a string corresponding to the text
representation of <strong><span class="anno">Integer</span></strong> in base
<strong><span class="anno">Base</span></strong>, for example:</p><pre>
&gt; <span class="input">integer_to_list(1023, 16).</span>
"3FF"</pre><h3>iolist_size/1</h3><p>Size of an iolist.</p><p>Returns an integer, that is the size in bytes,
of the binary that would be the result of
<strong>iolist_to_binary(<span class="anno">Item</span>)</strong>, for example:</p><pre>
&gt; <span class="input">iolist_size([1,2|&lt;&lt;3,4&gt;&gt;]).</span>
4</pre><h3>iolist_to_binary/1</h3><p>Convert an iolist to a binary.</p><p>Returns a binary that is made from the integers and
binaries in <strong><span class="anno">IoListOrBinary</span></strong>, for example:</p><pre>
&gt; <span class="input">Bin1 = &lt;&lt;1,2,3&gt;&gt;.</span>
&lt;&lt;1,2,3&gt;&gt;
&gt; <span class="input">Bin2 = &lt;&lt;4,5&gt;&gt;.</span>
&lt;&lt;4,5&gt;&gt;
&gt; <span class="input">Bin3 = &lt;&lt;6&gt;&gt;.</span>
&lt;&lt;6&gt;&gt;
&gt; <span class="input">iolist_to_binary([Bin1,1,[2,3,Bin2],4|Bin3]).</span>
&lt;&lt;1,2,3,1,2,3,4,5,4,6&gt;&gt;</pre><h3>iolist_to_iovec/1</h3><p>Converts an iolist to a iovec.</p><p>Returns an iovec that is made from the integers and binaries in
<strong><span class="anno">IoListOrBinary</span></strong>.</p><h3>is_alive/0</h3><p>Check whether the local node is alive.</p><p>Returns <strong>true</strong> if the local node is alive (that is, if
the node can be part of a distributed system), otherwise
<strong>false</strong>.</p><h3>is_atom/1</h3><p>Check whether a term is an atom.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is an atom,
otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h3>is_binary/1</h3><p>Check whether a term is a binary.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a binary,
otherwise <strong>false</strong>.</p><p>A binary always contains a complete number of bytes.</p><p>Allowed in guard tests.</p><h3>is_bitstring/1</h3><p>Check whether a term is a bitstring.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a
bitstring (including a binary), otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h3>is_boolean/1</h3><p>Check whether a term is a boolean.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is the
atom <strong>true</strong> or the atom <strong>false</strong> (that is, a boolean).
Otherwise returns <strong>false</strong>.</p><p>Allowed in guard tests.</p><h3>is_builtin/3</h3><p>Check if a function is a BIF implemented in C.</p><p>This BIF is useful for builders of cross-reference tools.</p><p>Returns <strong>true</strong> if
<strong><span class="anno">Module</span>:<span class="anno">Function</span>/<span class="anno">Arity</span></strong>
is a BIF implemented in C, otherwise <strong>false</strong>.</p><h3>is_float/1</h3><p>Check whether a term is a float.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a floating point
number, otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h3>is_function/1</h3><p>Check whether a term is a fun.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a fun, otherwise
<strong>false</strong>.</p><p>Allowed in guard tests.</p><h3>is_function/2</h3><p>Check whether a term is a fun with a specified given arity. </p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a fun that can be
applied with <strong><span class="anno">Arity</span></strong> number of arguments, otherwise
<strong>false</strong>.</p><p>Allowed in guard tests.</p><h3>is_integer/1</h3><p>Check whether a term is an integer.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is an integer,
otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h3>is_list/1</h3><p>Check whether a term is a list.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a list with
zero or more elements, otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h3>is_map/1</h3><p>Check whether a term is a map.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a map,
otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h3>is_map_key/2</h3><p>Returns <strong>true</strong> if map <strong><span class="anno">Map</span></strong> contains
<strong><span class="anno">Key</span></strong> and returns <strong>false</strong> if it does not
contain the <strong><span class="anno">Key</span></strong>.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">Map</span></strong> is not a map.</p><p><em>Example:</em></p><pre><code class="">
&gt; Map = #{"42" =&gt; value}.
#{"42" =&gt; value}
&gt; is_map_key("42",Map).
true
&gt; is_map_key(value,Map).
false</code></pre><h3>is_number/1</h3><p>Check whether a term is a number.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is an integer or a
floating point number. Otherwise returns <strong>false</strong>.</p><p>Allowed in guard tests.</p><h3>is_pid/1</h3><p>Check whether a term is a process identifier.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a process
identifier, otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h3>is_port/1</h3><p>Check whether a term is a port.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a port identifier,
otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h3>is_process_alive/1</h3><p>Check whether a process is alive.</p><p><strong><span class="anno">Pid</span></strong> must refer to a process at the local
node.</p><p>Returns <strong>true</strong> if the process exists and is alive, that
is, is not exiting and has not exited. Otherwise returns
<strong>false</strong>.</p><h3>is_record/2</h3><p>Check whether a term appears to be a record.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a tuple and its
first element is <strong><span class="anno">RecordTag</span></strong>.
Otherwise returns <strong>false</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Normally the compiler treats calls to <strong>is_record/2</strong>
especially. It emits code to verify that <strong><span class="anno">Term</span></strong>
is a tuple, that its first element is
<strong><span class="anno">RecordTag</span></strong>, and that the
size is correct. However, if <strong><span class="anno">RecordTag</span></strong> is
not a literal atom, the BIF <strong>is_record/2</strong> is called
instead and the size of the tuple is not verified.</p></div><p>Allowed in guard tests, if <strong><span class="anno">RecordTag</span></strong> is
a literal atom.</p><h3>is_record/3</h3><p>Check whether a term appears to be a record.</p><p><strong><span class="anno">RecordTag</span></strong> must be an atom.</p><p>Returns <strong>true</strong> if
<strong><span class="anno">Term</span></strong> is a tuple,
its first element is <strong><span class="anno">RecordTag</span></strong>,
and its size is <strong><span class="anno">Size</span></strong>.
Otherwise returns <strong>false</strong>.</p><p>Allowed in guard tests if <strong><span class="anno">RecordTag</span></strong> is
a literal atom and <strong>Size</strong> is a literal integer.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This BIF is documented for completeness. Usually
<strong>is_record/2</strong> is to be used.</p></div><h3>is_reference/1</h3><p>Check whether a term is a reference.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a reference,
otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h3>is_tuple/1</h3><p>Check whether a term is a tuple.</p><p>Returns <strong>true</strong> if <strong><span class="anno">Term</span></strong> is a tuple,
otherwise <strong>false</strong>.</p><p>Allowed in guard tests.</p><h3>length/1</h3><p>Length of a list.</p><p>Returns the length of <strong><span class="anno">List</span></strong>, for example:</p><pre>
&gt; <span class="input">length([1,2,3,4,5,6,7,8,9]).</span>
9</pre><p>Allowed in guard tests.</p><h3>link/1</h3><p>Create a link to another process (or port).</p><p>Creates a link between the calling process and another
process (or port) <strong><span class="anno">PidOrPort</span></strong>, if there is
not such a link
already. If a process attempts to create a link to itself,
nothing is done. Returns <strong>true</strong>.</p><p>If <strong><span class="anno">PidOrPort</span></strong> does not exist, the behavior
of the BIF
depends on if the calling process is trapping exits or not (see
<a href="#process_flag/2">process_flag/2</a>):</p><ul><li><p>If the calling process is not trapping exits, and
checking <strong><span class="anno">PidOrPort</span></strong> is cheap
(that is, if <strong><span class="anno">PidOrPort</span></strong>
is local), <strong>link/1</strong> fails with reason <strong>noproc</strong>.</p></li><li><p>Otherwise, if the calling process is trapping exits,
and/or <strong><span class="anno">PidOrPort</span></strong> is remote, <strong>link/1</strong>
returns <strong>true</strong>, but an exit signal with reason <strong>noproc</strong>
is sent to the calling process.</p></li></ul><h3>list_to_atom/1</h3><p>Convert from text representation to an atom.</p><p>Returns the atom whose text representation is
<strong><span class="anno">String</span></strong>.</p><p>As from Erlang/OTP 20, <strong><span class="anno">String</span></strong> may contain
any Unicode character. Earlier versions allowed only ISO-latin-1
characters as the implementation did not allow Unicode characters
above 255. For more information on Unicode support in atoms, see
<a href="./erl_ext_dist#utf8_atoms">note on UTF-8 encoded atoms</a>
in section "External Term Format" in the User's Guide.</p><p>Example:</p><pre>
&gt; <span class="input">list_to_atom("Erlang").</span>
'Erlang'</pre><h3>list_to_binary/1</h3><p>Convert a list to a binary.</p><p>Returns a binary that is made from the integers and
binaries in <strong><span class="anno">IoList</span></strong>, for example:</p><pre>
&gt; <span class="input">Bin1 = &lt;&lt;1,2,3&gt;&gt;.</span>
&lt;&lt;1,2,3&gt;&gt;
&gt; <span class="input">Bin2 = &lt;&lt;4,5&gt;&gt;.</span>
&lt;&lt;4,5&gt;&gt;
&gt; <span class="input">Bin3 = &lt;&lt;6&gt;&gt;.</span>
&lt;&lt;6&gt;&gt;
&gt; <span class="input">list_to_binary([Bin1,1,[2,3,Bin2],4|Bin3]).</span>
&lt;&lt;1,2,3,1,2,3,4,5,4,6&gt;&gt;</pre><h3>list_to_bitstring/1</h3><p>Convert a list to a bitstring.</p><ul><li>bitstring_list</li></ul><p>Returns a bitstring that is made from the integers and
bitstrings in <strong><span class="anno">BitstringList</span></strong>. (The last tail in
<strong><span class="anno">BitstringList</span></strong> is allowed to be a bitstring.)
Example:</p><pre>
&gt; <span class="input">Bin1 = &lt;&lt;1,2,3&gt;&gt;.</span>
&lt;&lt;1,2,3&gt;&gt;
&gt; <span class="input">Bin2 = &lt;&lt;4,5&gt;&gt;.</span>
&lt;&lt;4,5&gt;&gt;
&gt; <span class="input">Bin3 = &lt;&lt;6,7:4&gt;&gt;.</span>
&lt;&lt;6,7:4&gt;&gt;
&gt; <span class="input">list_to_bitstring([Bin1,1,[2,3,Bin2],4|Bin3]).</span>
&lt;&lt;1,2,3,1,2,3,4,5,4,6,7:4&gt;&gt;</pre><h3>list_to_existing_atom/1</h3><p>Convert from text representation to an atom.</p><p>Returns the atom whose text representation is
<strong><span class="anno">String</span></strong>,
but only if there already exists such atom.</p><p>Failure: <strong>badarg</strong> if there does not already exist an atom
whose text representation is <strong><span class="anno">String</span></strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that the compiler may optimize away atoms. For
example, the compiler will rewrite
<strong>atom_to_list(some_atom)</strong> to <strong>"some_atom"</strong>. If
that expression is the only mention of the atom
<strong>some_atom</strong> in the containing module, the atom will not
be created when the module is loaded, and a subsequent call
to <strong>list_to_existing_atom("some_atom")</strong> will fail.</p></div><h3>list_to_float/1</h3><p>Convert from text representation to a float.</p><p>Returns the float whose text representation is
<strong><span class="anno">String</span></strong>, for example:</p><pre>
&gt; <span class="input">list_to_float("2.2017764e+0").</span>
2.2017764</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">String</span></strong> contains a bad
representation of a float.</p><h3>list_to_integer/1</h3><p>Convert from text representation to an integer.</p><p>Returns an integer whose text representation is
<strong><span class="anno">String</span></strong>, for example:</p><pre>
&gt; <span class="input">list_to_integer("123").</span>
123</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">String</span></strong> contains a bad
representation of an integer.</p><h3>list_to_integer/2</h3><p>Convert from text representation to an integer.</p><p>Returns an integer whose text representation in base
<strong><span class="anno">Base</span></strong> is <strong><span class="anno">String</span></strong>,
for example:</p><pre>
&gt; <span class="input">list_to_integer("3FF", 16).</span>
1023</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">String</span></strong> contains a bad
representation of an integer.</p><h3>list_to_pid/1</h3><p>Convert from text representation to a pid.</p><p>Returns a process identifier whose text representation is a 
<strong><span class="anno">String</span></strong>, for example:</p><pre>
&gt; <span class="input">list_to_pid("&lt;0.4.1&gt;").</span>
&lt;0.4.1&gt;</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">String</span></strong> contains a bad
representation of a process identifier.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for debugging and is not to be used
in application programs.</p></div><h3>list_to_port/1</h3><p>Convert from text representation to a port.</p><p>Returns a port identifier whose text representation is a
<strong><span class="anno">String</span></strong>, for example:</p><pre>
&gt; <span class="input">list_to_port("#Port&lt;0.4&gt;").</span>
#Port&lt;0.4&gt;</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">String</span></strong> contains a bad
representation of a port identifier.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for debugging and is not to be used
in application programs.</p></div><h3>list_to_ref/1</h3><p>Convert from text representation to a ref.</p><p>Returns a reference whose text representation is a
<strong><span class="anno">String</span></strong>, for example:</p><pre>
&gt; <span class="input">list_to_ref("#Ref&lt;0.4192537678.4073193475.71181&gt;").</span>
#Ref&lt;0.4192537678.4073193475.71181&gt;</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">String</span></strong> contains a bad
representation of a reference.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for debugging and is not to be used
in application programs.</p></div><h3>list_to_tuple/1</h3><p>Convert a list to a tuple.</p><p>Returns a tuple corresponding to <strong><span class="anno">List</span></strong>,
for example</p><pre>
&gt; <span class="input">list_to_tuple([share, ['Ericsson_B', 163]]).</span>
{share, ['Ericsson_B', 163]}</pre><p><strong><span class="anno">List</span></strong> can contain any Erlang terms.</p><h3>load_module/2</h3><p>Load object code for a module.</p><p>If <strong><span class="anno">Binary</span></strong> contains the object code for module
<strong><span class="anno">Module</span></strong>, this BIF loads that object code. If
the code for module <strong><span class="anno">Module</span></strong> already exists, all
export references are replaced so they point to the newly
loaded code. The previously loaded code is kept in the system
as old code, as there can still be processes executing
that code.</p><p>Returns either <strong>{module, <span class="anno">Module</span>}</strong>, or
<strong>{error, <span class="anno">Reason</span>}</strong> if loading fails.
<strong><span class="anno">Reason</span></strong> is one of the following:</p><dl><dt><strong>badfile</strong></dt><dd>The object code in <strong><span class="anno">Binary</span></strong> has an incorrect format <em>or</em> the object code contains code for another module than <strong><span class="anno">Module</span></strong>. </dd><dt><strong>not_purged</strong></dt><dd><strong><span class="anno">Binary</span></strong> contains a module that cannot be loaded because old code for this module already exists. </dd></dl><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for the code server (see
<a href="./code">kernel/code</a>)
and is not to be used elsewhere.</p></div><h3>load_nif/2</h3><p>Load NIF library.</p><p>Loads and links a dynamic library containing native
implemented functions (NIFs) for a module. <strong><span class="anno">Path</span></strong>
is a file path to the shareable object/dynamic library file minus
the OS-dependent file extension (<strong>.so</strong> for Unix and
<strong>.dll</strong> for Windows). Notice that on most OSs the library has
to have a different name on disc when an upgrade of the nif is
done. If the name is the same, but the contents differ, the
old library may be loaded instead. For information on how to
implement a NIF library, see
<a href="erl_nif">erl_nif</a>.</p><p><strong><span class="anno">LoadInfo</span></strong> can be any term. It is passed on to
the library as part of the initialization. A good practice is
to include a module version number to support future code
upgrade scenarios.</p><p>The call to <strong>load_nif/2</strong> must be made
<em>directly</em> from the Erlang code of the module that the
NIF library belongs to. It returns either <strong>ok</strong>, or
<strong>{error,{<span class="anno">Reason</span>,Text}}</strong> if loading fails.
<strong><span class="anno">Reason</span></strong> is one of the following atoms
while <strong><span class="anno">Text</span></strong> is a human readable string that
can give more information about the failure:</p><dl><dt><strong>load_failed</strong></dt><dd>The OS failed to load the NIF library. </dd><dt><strong>bad_lib</strong></dt><dd>The library did not fulfill the requirements as a NIF library of the calling module. </dd><dt><strong>load | upgrade</strong></dt><dd>The corresponding library callback was unsuccessful. </dd><dt><strong>reload</strong></dt><dd>A NIF library is already loaded for this module instance. The previously deprecated <strong>reload</strong> feature was removed in OTP 20. </dd><dt><strong>old_code</strong></dt><dd>The call to <strong>load_nif/2</strong> was made from the old code of a module that has been upgraded; this is not allowed. </dd><dt><strong>notsup</strong></dt><dd>Lack of support. Such as loading NIF library for a HiPE compiled module. </dd></dl><h3>loaded/0</h3><p>List all loaded modules.</p><p>Returns a list of all loaded Erlang modules (current and
old code), including preloaded modules.</p><p>See also <a href="./code">kernel/code</a>.</p><h3>localtime/0</h3><p>Current local date and time.</p><p>Returns the current local date and time,
<strong>{{Year, Month, Day}, {Hour, Minute, Second}}</strong>,
for example:</p><pre>
&gt; <span class="input">erlang:localtime().</span>
{{1996,11,6},{14,45,17}}</pre><p>The time zone and Daylight Saving Time correction depend
on the underlying OS.</p><h3>localtime_to_universaltime/1</h3><p>Convert from local to Universal Time Coordinated (UTC) date and time.</p><p>Converts local date and time to Universal Time Coordinated
(UTC), if supported by the underlying OS. Otherwise
no conversion is done and <strong><span class="anno">Localtime</span></strong>
is returned. Example:</p><pre>
&gt; <span class="input">erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}).</span>
{{1996,11,6},{13,45,17}}</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Localtime</span></strong> denotes an
invalid date and time.</p><h3>localtime_to_universaltime/2</h3><p>Convert from local to Universal Time Coordinated (UTC) date and time.</p><p>Converts local date and time to Universal Time Coordinated
(UTC) as <strong>erlang:localtime_to_universaltime/1</strong>,
but the caller decides if Daylight Saving Time is active.</p><p>If <strong><span class="anno">IsDst</span> == true</strong>, <strong><span class="anno">Localtime</span></strong>
is during Daylight Saving Time, if <strong><span class="anno">IsDst</span> == false</strong>
it is not. If <strong><span class="anno">IsDst</span> == undefined</strong>, the underlying
OS can guess, which is the same as calling
<strong>erlang:localtime_to_universaltime(<span class="anno">Localtime</span>)</strong>.</p><p>Examples:</p><pre>
&gt; <span class="input">erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, true).</span>
{{1996,11,6},{12,45,17}}
&gt; <span class="input">erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, false).</span>
{{1996,11,6},{13,45,17}}
&gt; <span class="input">erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, undefined).</span>
{{1996,11,6},{13,45,17}}</pre><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Localtime</span></strong> denotes an
invalid date and time.</p><h3>make_ref/0</h3><p>Return a unique reference.</p><p>Returns a
<a href="../doc/efficiency_guide/advanced#unique_references"> unique reference</a>. The reference is unique among
connected nodes.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Known issue: When a node is restarted multiple
times with the same node name, references created
on a newer node can be mistaken for a reference
created on an older node with the same node name.</p></div><h3>make_tuple/2</h3><p>Create a new tuple of a specified arity.</p><p>Creates a new tuple of the specified <strong><span class="anno">Arity</span></strong>, where
all elements are <strong><span class="anno">InitialValue</span></strong>, for example:</p><pre>
&gt; <span class="input">erlang:make_tuple(4, []).</span>
{[],[],[],[]}</pre><h3>make_tuple/3</h3><p>Create a new tuple with specifed arity and contents.</p><p>Creates a tuple of size <strong><span class="anno">Arity</span></strong>, where each element
has value <strong><span class="anno">DefaultValue</span></strong>, and then fills in
values from <strong><span class="anno">InitList</span></strong>.
Each list element in <strong><span class="anno">InitList</span></strong>
must be a two-tuple, where the first element is a position in the
newly created tuple and the second element is any term. If a
position occurs more than once in the list, the term corresponding
to the last occurrence is used. Example:</p><pre>
&gt; <span class="input">erlang:make_tuple(5, [], [{2,ignored},{5,zz},{2,aa}]).</span>
{[],aa,[],[],zz}</pre><h3>map_get/2</h3><p>Extract a value from a map</p><p>Returns value <strong><span class="anno">Value</span></strong> associated with
<strong><span class="anno">Key</span></strong> if <strong><span class="anno">Map</span></strong> contains
<strong><span class="anno">Key</span></strong>.</p><p>The call fails with a <strong>{badmap,Map}</strong> exception if
<strong><span class="anno">Map</span></strong> is not a map, or with a <strong>{badkey,Key}</strong>
exception if no value is associated with <strong><span class="anno">Key</span></strong>.</p><p><em>Example:</em></p><pre><code class="">
&gt; Key = 1337,
  Map = #{42 =&gt; value_two,1337 =&gt; "value one","a" =&gt; 1},
  map_get(Key,Map).
"value one"</code></pre><h3>map_size/1</h3><p>Return the size of a map.</p><p>Returns an integer, which is the number of key-value pairs
in <strong><span class="anno">Map</span></strong>, for example:</p><pre>
&gt; <span class="input">map_size(#{a=&gt;1, b=&gt;2, c=&gt;3}).</span>
3</pre><p>Allowed in guard tests.</p><h3>match_spec_test/3</h3><p>Test that a match specification works.</p><p>Tests a match specification used in calls to
<a href="../stdlib/ets#select/2">stdlib/ets#select/2</a>
and <a href="#trace_pattern/3">trace_pattern/3</a>.
The function tests both a match specification for "syntactic"
correctness and runs the match specification against the object. If
the match specification contains errors, the tuple <strong>{error, Errors}</strong> is returned, where <strong>Errors</strong> is a list of natural
language descriptions of what was wrong with the match
specification.</p><p>If <strong><span class="anno">Type</span></strong> is <strong>table</strong>, the object to match
against is to be a tuple. The function then returns
<strong>{ok,Result,[],Warnings}</strong>, where <strong>Result</strong> is what would
have been the result in a real <strong>ets:select/2</strong> call, or
<strong>false</strong> if the match specification does not match the object
tuple.</p><p>If <strong><span class="anno">Type</span></strong> is <strong>trace</strong>, the object to match
against is to be a list. The function returns
<strong>{ok, Result, Flags, Warnings}</strong>, where <strong>Result</strong> is one of
the following:</p><ul><li><strong>true</strong> if a trace message is to be emitted</li><li><strong>false</strong> if a trace message is not to be emitted</li><li>The message term to be appended to the trace message</li></ul><p><strong>Flags</strong> is a list containing all the trace flags to be enabled,
currently this is only <strong>return_trace</strong>.</p><p>This is a useful debugging and test tool, especially when writing
complicated match specifications.</p><p>See also
<a href="../stdlib/ets#test_ms/2">stdlib/ets#test_ms/2</a>.</p><h3>max/2</h3><p>Return the largest of two terms.</p><p>Returns the largest of <strong><span class="anno">Term1</span></strong> and
<strong><span class="anno">Term2</span></strong>.
If the terms are equal, <strong><span class="anno">Term1</span></strong> is returned.</p><h3>md5/1</h3><p>Compute an MD5 message digest.</p><p>Computes an MD5 message digest from <strong><span class="anno">Data</span></strong>, where
the length of the digest is 128 bits (16 bytes).
<strong><span class="anno">Data</span></strong>
is a binary or a list of small integers and binaries.</p><p>For more information about MD5, see
<a href="https://www.ietf.org/rfc/rfc1321.txt"> RFC 1321 - The MD5 Message-Digest Algorithm</a>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>The MD5 Message-Digest Algorithm is <em>not</em> considered
safe for code-signing or software-integrity purposes.</p></div><h3>md5_final/1</h3><p>Finish the update of an MD5 context and return the computed MD5 message digest.</p><p>Finishes the update of an MD5 <strong><span class="anno">Context</span></strong> and returns
the computed <strong>MD5</strong> message digest.</p><h3>md5_init/0</h3><p>Create an MD5 context.</p><p>Creates an MD5 context, to be used in the following calls to
<strong>md5_update/2</strong>.</p><h3>md5_update/2</h3><p>Update an MD5 context with data and return a new context. </p><p>Update an MD5 <strong><span class="anno">Context</span></strong> with
<strong><span class="anno">Data</span></strong> and returns a
<strong><span class="anno">NewContext</span></strong>.</p><h3>memory/0</h3><p>Information about dynamically allocated memory.</p><ul><li>memory_type</li></ul><p>Returns a list with information about memory
dynamically allocated by the Erlang emulator. Each list
element is a tuple <strong>{Type, Size}</strong>. The first element
<strong><span class="anno">Type</span></strong> is an atom describing memory type. The second
element <strong><span class="anno">Size</span></strong> is the memory size in bytes.</p><p>Memory types:</p><dl><dt><strong>total</strong></dt><dd> <p>The total amount of memory currently allocated. This is
the same as the sum of the memory size for <strong>processes</strong>
and <strong>system</strong>.</p> </dd><dt><strong>processes</strong></dt><dd> <p>The total amount of memory currently allocated for
the Erlang processes.</p> </dd><dt><strong>processes_used</strong></dt><dd> <p>The total amount of memory currently used by the Erlang
processes. This is part of the memory presented as
<strong>processes</strong> memory.</p> </dd><dt><strong>system</strong></dt><dd> <p>The total amount of memory currently allocated for
the emulator that is not directly related to any Erlang
process. Memory presented as <strong>processes</strong> is not
included in this memory. <a href="./instrument">tools/instrument</a> can be used to
get a more detailed breakdown of what memory is part
of this type.</p> </dd><dt><strong>atom</strong></dt><dd> <p>The total amount of memory currently allocated for atoms.
This memory is part of the memory presented as
<strong>system</strong> memory.</p> </dd><dt><strong>atom_used</strong></dt><dd> <p>The total amount of memory currently used for atoms.
This memory is part of the memory presented as
<strong>atom</strong> memory.</p> </dd><dt><strong>binary</strong></dt><dd> <p>The total amount of memory currently allocated for
binaries. This memory is part of the memory presented
as <strong>system</strong> memory.</p> </dd><dt><strong>code</strong></dt><dd> <p>The total amount of memory currently allocated for
Erlang code. This memory is part of the memory presented
as <strong>system</strong> memory.</p> </dd><dt><strong>ets</strong></dt><dd> <p>The total amount of memory currently allocated for ETS
tables. This memory is part of the memory presented as
<strong>system</strong> memory.</p> </dd><dt><strong>low</strong></dt><dd> <p>Only on 64-bit halfword emulator.
The total amount of memory allocated in low memory areas
that are restricted to &lt; 4 GB, although
the system can have more memory.</p> <p>Can be removed in a future release of the halfword
emulator.</p> </dd><dt><strong>maximum</strong></dt><dd> <p>The maximum total amount of memory allocated since
the emulator was started. This tuple is only present
when the emulator is run with instrumentation.</p> <p>For information on how to run the emulator with
instrumentation, see
<a href="./instrument">tools/instrument</a>
and/or <a href="erl">erl</a>.</p> </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The <strong>system</strong> value is not complete. Some allocated
memory that is to be part of this value is not.</p><p>When the emulator is run with instrumentation,
the <strong>system</strong> value is more accurate, but memory
directly allocated for <strong>malloc</strong> (and friends) is still
not part of the <strong>system</strong> value. Direct calls to
<strong>malloc</strong> are only done from OS-specific runtime
libraries and perhaps from user-implemented Erlang drivers
that do not use the memory allocation functions in
the driver interface.</p><p>As the <strong>total</strong> value is the sum of <strong>processes</strong>
and <strong>system</strong>, the error in <strong>system</strong> propagates
to the <strong>total</strong> value.</p><p>The different amounts of memory that are summed are
<em>not</em> gathered atomically, which introduces
an error in the result.</p></div><p>The different values have the following relation to each
other. Values beginning with an uppercase letter is not part
of the result.</p><pre><code class="">
total      = processes + system
processes  = processes_used + ProcessesNotUsed
system     = atom + binary + code + ets + OtherSystem
atom       = atom_used + AtomNotUsed
RealTotal  = processes + RealSystem
RealSystem = system + MissedSystem</code></pre><p>More tuples in the returned list can be added in a
future release.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The <strong>total</strong> value is supposed to be the total amount
of memory dynamically allocated by the emulator. Shared
libraries, the code of the emulator itself, and
the emulator stacks are not supposed to be included. That
is, the <strong>total</strong> value is <em>not</em> supposed to be
equal to the total size of all pages mapped to the emulator.</p><p>Also, because of fragmentation and prereservation of
memory areas, the size of the memory segments containing
the dynamically allocated memory blocks can be much
larger than the total size of the dynamically allocated
memory blocks.</p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from ERTS 5.6.4, <strong>erlang:memory/0</strong> requires that
all <a href="./erts_alloc">erts/erts_alloc</a>
allocators are enabled (default behavior).</p></div><p>Failure: <strong>notsup</strong> if an
<a href="./erts_alloc">erts/erts_alloc</a>
allocator has been disabled.</p><h3>memory/1</h3><h3>memory/1</h3><p>Information about dynamically allocated memory.</p><ul><li>memory_type</li></ul><p>Returns the memory size in bytes allocated for memory of type
<strong><span class="anno">Type</span></strong>. The argument can also be specified as a list
of <strong>memory_type()</strong> atoms, in which case a corresponding list of
<strong>{memory_type(), Size :: integer &gt;= 0}</strong> tuples is returned.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from ERTS 5.6.4,
<strong>erlang:memory/1</strong> requires that
all <a href="erts_alloc">erts_alloc</a>
allocators are enabled (default behavior).</p></div><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Type</span></strong> is not one of the memory types listed in the description of <a href="#memory/0">memory/0</a>. </dd><dt><strong>badarg</strong></dt><dd> If <strong>maximum</strong> is passed as <strong><span class="anno">Type</span></strong> and the emulator is not run in instrumented mode. </dd><dt><strong>notsup</strong></dt><dd> If an <a href="erts_alloc">erts_alloc</a> allocator has been disabled. </dd></dl><p>See also
<a href="#memory/0">memory/0</a>.</p><h3>min/2</h3><p>Return the smallest of two terms.</p><p>Returns the smallest of <strong><span class="anno">Term1</span></strong> and
<strong><span class="anno">Term2</span></strong>.
If the terms are equal, <strong><span class="anno">Term1</span></strong> is returned.</p><h3>module_loaded/1</h3><p>Check if a module is loaded.</p><p>Returns <strong>true</strong> if the module <strong><span class="anno">Module</span></strong>
is loaded, otherwise <strong>false</strong>. It does not attempt to load
the module.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for the code server (see
<a href="./code">kernel/code</a>)
and is not to be used elsewhere.</p></div><h3>monitor/2</h3><h3>monitor/2</h3><h3>monitor/2</h3><p>Start monitoring.</p><ul><li>registered_name</li></ul><ul><li>registered_process_identifier</li></ul><ul><li>monitor_process_identifier</li></ul><ul><li>monitor_port_identifier</li></ul><p>Sends a monitor request of type <strong><span class="anno">Type</span></strong> to the
entity identified by <strong><span class="anno">Item</span></strong>. If the monitored entity
does not exist or it changes monitored state, the caller of
<strong>monitor/2</strong> is notified by a message on the following format:</p><pre><code class="">
{Tag, <span class="anno">MonitorRef</span>, <span class="anno">Type</span>, Object, Info}</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The monitor request is an asynchronous signal. That is, it
takes time before the signal reaches its destination.</p></div><p><strong><span class="anno">Type</span></strong> can be one of the following atoms:
<strong>process</strong>, <strong>port</strong> or <strong>time_offset</strong>.</p><p>A <strong>process</strong> or <strong>port</strong> monitor is triggered only once,
after that it is removed from both monitoring process and
the monitored entity. Monitors are fired when the monitored process
or port terminates, does not exist at the moment of creation,
or if the connection to it is lost. If the connection to it is lost,
we do not know if it still exists. The monitoring is also turned off
when <a href="#demonitor/1">demonitor/1</a> is
called.</p><p>A <strong>process</strong> or <strong>port</strong> monitor by name
resolves the <strong>RegisteredName</strong> to <strong>pid()</strong> or <strong>port()</strong>
only once at the moment of monitor instantiation, later changes to
the name registration will not affect the existing monitor.</p><p>When a <strong>process</strong> or <strong>port</strong> monitor is triggered,
a <strong>'DOWN'</strong> message is sent that has the following pattern:</p><pre><code class="">
{'DOWN', MonitorRef, Type, Object, Info}</code></pre><p>In the monitor message <strong>MonitorRef</strong> and <strong>Type</strong> are the
same as described earlier, and:</p><dl><dt><strong>Object</strong></dt><dd> <p>The monitored entity, which triggered the event. When monitoring
a local process or port, <strong>Object</strong> will be equal to the
<strong>pid()</strong> or <strong>port()</strong> that was being monitored. When
monitoring process or port by name, <strong>Object</strong> will have format
<strong>{RegisteredName, Node}</strong> where <strong>RegisteredName</strong> is the
name which has been used with <strong>monitor/2</strong> call and
<strong>Node</strong> is local or remote node name (for ports monitored by
name, <strong>Node</strong> is always local node name).</p> </dd><dt><strong>Info</strong></dt><dd> <p>Either the exit reason of the process, <strong>noproc</strong>
(process or port did not exist at the time of monitor creation),
or <strong>noconnection</strong> (no connection to the node where the
monitored process resides). </p></dd></dl><dl><dt>Monitoring a <a name="monitor_process"></a><strong>process</strong></dt><dd> <p>Creates monitor between the current process and another
process identified by <strong><span class="anno">Item</span></strong>, which can be a
<strong>pid()</strong> (local or remote), an atom <strong>RegisteredName</strong> or
a tuple <strong>{RegisteredName, Node}</strong> for a registered process,
located elsewhere.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Before ERTS 10.0 (OTP 21.0), monitoring a process could fail with
<strong>badarg</strong> if the monitored process resided on a primitive node
(such as erl_interface or jinterface), where remote process monitoring
is not implemented.</p><p>Now, such a call to <strong>monitor</strong> will instead succeed and a
monitor is created. But the monitor will only supervise the
connection. That is, a <strong>{'DOWN', _, process, _, noconnection}</strong> is
the only message that may be received, as the primitive node have no
way of reporting the status of the monitored process.</p></div> </dd><dt>Monitoring a <a name="monitor_port"></a><strong>port</strong></dt><dd> <p>Creates monitor between the current process and a port
identified by <strong><span class="anno">Item</span></strong>, which can be a
<strong>port()</strong> (only local), an atom <strong>RegisteredName</strong> or
a tuple <strong>{RegisteredName, Node}</strong> for a registered port,
located on this node. Note, that attempt to monitor a remote port
will result in <strong>badarg</strong>.</p> </dd><dt>Monitoring a <a name="monitor_time_offset"></a><strong>time_offset</strong></dt><dd> <p>Monitors changes in
<a href="#time_offset/0">time_offset/0</a>
between
<a href="./time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a> and
<a href="./time_correction#Erlang_System_Time">Erlang system time</a>. One valid <strong><span class="anno">Item</span></strong>
exists in combination with the
<strong>time_offset <span class="anno">Type</span></strong>, namely the atom
<strong>clock_service</strong>. Notice that the atom <strong>clock_service</strong> is
<em>not</em> the registered name of a process. In this
case it serves as an identifier of the runtime system internal
clock service at current runtime system instance.</p> <p>The monitor is triggered when the time offset is changed.
This either if the time offset value is changed, or if the
offset is changed from preliminary to final during
<a href="#system_flag_time_offset">finalization of the time offset</a> when the
<a href="./time_correction#Single_Time_Warp_Mode">single time warp mode</a> is used. When a change from preliminary
to final time offset is made, the monitor is triggered once
regardless of whether the time offset value was changed
or not.</p> <p>If the runtime system is in
<a href="./time_correction#Multi_Time_Warp_Mode">multi time warp mode</a>, the time offset is changed when
the runtime system detects that the
<a href="./time_correction#OS_System_Time">OS system time</a> has changed. The runtime system does, however,
not detect this immediately when it occurs. A task checking
the time offset is scheduled to execute at least once a minute,
so under normal operation this is to be detected within a
minute, but during heavy load it can take longer time.</p> <p>The monitor is <em>not</em> automatically removed
after it has been triggered. That is, repeated changes of
the time offset trigger the monitor repeatedly.</p> <p>When the monitor is triggered a <strong>'CHANGE'</strong> message is
sent to the monitoring process. A <strong>'CHANGE'</strong> message has
the following pattern:</p> <pre><code class="">
{'CHANGE', MonitorRef, Type, Item, NewTimeOffset}</code></pre> <p>where <strong>MonitorRef</strong>, <strong><span class="anno">Type</span></strong>, and
<strong><span class="anno">Item</span></strong> are the same as described above, and
<strong>NewTimeOffset</strong> is the new time offset.</p> <p>When the <strong>'CHANGE'</strong> message has been received you are
guaranteed not to retrieve the old time offset when calling
<a href="#time_offset/0">time_offset/0</a>.
Notice that you can observe the change of the time offset
when calling <strong>erlang:time_offset()</strong> before you
get the <strong>'CHANGE'</strong> message.</p> </dd></dl><p>Making several calls to <strong>monitor/2</strong> for the same
<strong><span class="anno">Item</span></strong> and/or <strong><span class="anno">Type</span></strong> is not
an error; it results in as many independent monitoring instances.</p><p>The monitor functionality is expected to be extended. That is,
other <strong><span class="anno">Type</span></strong>s and <strong><span class="anno">Item</span></strong>s
are expected to be supported in a future release.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If or when <strong>monitor/2</strong> is extended, other
possible values for <strong>Tag</strong>, <strong>Object</strong>, and
<strong>Info</strong> in the monitor message will be introduced.</p></div><h3>monitor_node/2</h3><p>Monitor the status of a node.</p><p>Monitor the status of the node <strong><span class="anno">Node</span></strong>.
If <strong><span class="anno">Flag</span></strong>
is <strong>true</strong>, monitoring is turned on. If <strong><span class="anno">Flag</span></strong>
is <strong>false</strong>, monitoring is turned off.</p><p>Making several calls to <strong>monitor_node(Node, true)</strong> for
the same <strong><span class="anno">Node</span></strong> is not an error; it results
in as many independent monitoring instances.</p><p>If <strong><span class="anno">Node</span></strong> fails or does not exist, the message
<strong>{nodedown, Node}</strong> is delivered to the process. If a
process has made two calls to <strong>monitor_node(Node, true)</strong>
and <strong><span class="anno">Node</span></strong> terminates, two <strong>nodedown</strong> messages
are delivered to the process. If there is no connection to
<strong><span class="anno">Node</span></strong>, an attempt is made to create one.
If this fails, a <strong>nodedown</strong> message is delivered.</p><p>Nodes connected through hidden connections can be monitored
as any other nodes.</p><p>Failure: <strong>badarg</strong> if the local node is not alive.</p><h3>monitor_node/3</h3><p>Monitor the status of a node.</p><p>Behaves as
<a href="#monitor_node/2">monitor_node/2</a>
except that it allows an
extra option to be specified, namely <strong>allow_passive_connect</strong>.
This option allows the BIF to wait the normal network connection
time-out for the <em>monitored node</em> to connect itself,
even if it cannot be actively connected from this node
(that is, it is blocked). The state where this can be useful
can only be achieved by using the Kernel option
<strong>dist_auto_connect once</strong>. If that option is not
used, option <strong>allow_passive_connect</strong> has no effect.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Option <strong>allow_passive_connect</strong> is used
internally and is seldom needed in applications where the
network topology and the Kernel options in effect
are known in advance.</p></div><p>Failure: <strong>badarg</strong> if the local node is not alive or the
option list is malformed.</p><h3>monotonic_time/0</h3><p>Current Erlang monotonic time.</p><p>Returns the current
<a href="./time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a> in <strong>native</strong>
<a href="#type_time_unit">time unit</a>. This
is a monotonically increasing time since some unspecified point in
time.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This is a
<a href="./time_correction#Monotonically_Increasing"> monotonically increasing</a> time, but <em>not</em> a
<a href="./time_correction#Strictly_Monotonically_Increasing"> strictly monotonically increasing</a>
time. That is, consecutive calls to
<strong>erlang:monotonic_time/0</strong> can produce the same result.</p><p>Different runtime system instances will use different unspecified
points in time as base for their Erlang monotonic clocks.
That is, it is <em>pointless</em> comparing monotonic times from
different runtime system instances. Different runtime system
instances can also place this unspecified point in time different
relative runtime system start. It can be placed in the future (time
at start is a negative value), the past (time at start is a
positive value), or the runtime system start (time at start is
zero). The monotonic time at runtime system start can be
retrieved by calling
<a href="#system_info_start_time">system_info_start_time</a>.</p></div><h3>monotonic_time/1</h3><p>Current Erlang monotonic time.</p><p>Returns the current
<a href="./time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a> converted
into the <strong><span class="anno">Unit</span></strong> passed as argument.</p><p>Same as calling
<a href="#convert_time_unit/3">convert_time_unit/3</a><strong>(</strong><a href="#monotonic_time/0">monotonic_time/0</a><strong>, native, <span class="anno">Unit</span>)</strong>,
however optimized for commonly used <strong><span class="anno">Unit</span></strong>s.</p><h3>nif_error/1</h3><p>Stop execution with a specified reason.</p><p>Works exactly like
<a href="#error/1">error/1</a>, but
Dialyzer thinks that this BIF will return an arbitrary
term. When used in a stub function for a NIF to generate an
exception when the NIF library is not loaded, Dialyzer
does not generate false warnings.</p><h3>nif_error/2</h3><p>Stop execution with a specified reason.</p><p>Works exactly like
<a href="#error/2">error/2</a>, but
Dialyzer thinks that this BIF will return an arbitrary
term. When used in a stub function for a NIF to generate an
exception when the NIF library is not loaded, Dialyzer
does not generate false warnings.</p><h3>node/0</h3><p>Name of the local node.</p><p>Returns the name of the local node. If the node is not alive,
<strong>nonode@nohost</strong> is returned instead.</p><p>Allowed in guard tests.</p><h3>node/1</h3><p>At which node a pid, port, or reference originates.</p><p>Returns the node where <strong><span class="anno">Arg</span></strong> originates.
<strong><span class="anno">Arg</span></strong> can
be a process identifier, a reference, or a port.
If the local node is not
alive, <strong>nonode@nohost</strong> is returned.</p><p>Allowed in guard tests.</p><h3>nodes/0</h3><p>All visible nodes in the system.</p><p>Returns a list of all visible nodes in the system, except
the local node. Same as <strong>nodes(visible)</strong>.</p><h3>nodes/1</h3><p>All nodes of a certain type in the system.</p><p>Returns a list of nodes according to the argument specified.
The returned result, when the argument is a list, is the list
of nodes satisfying the disjunction(s) of the list elements.</p><p><strong><span class="anno">NodeType</span></strong>s:</p><dl><dt><strong>visible</strong></dt><dd> <p>Nodes connected to this node through normal connections.</p> </dd><dt><strong>hidden</strong></dt><dd> <p>Nodes connected to this node through hidden connections.</p> </dd><dt><strong>connected</strong></dt><dd> <p>All nodes connected to this node.</p> </dd><dt><strong>this</strong></dt><dd> <p>This node.</p> </dd><dt><strong>known</strong></dt><dd> <p>Nodes that are known to this node. That is, connected
nodes and nodes referred to by process identifiers, port
identifiers, and references located on this node.
The set of known nodes is garbage collected. Notice that
this garbage collection can be delayed. For more
information, see
<a href="./erlang#system_info_delayed_node_table_gc">erlang#system_info_delayed_node_table_gc</a>.</p> </dd></dl><p>Some equalities: <strong>[node()] = nodes(this)</strong>,
<strong>nodes(connected) = nodes([visible, hidden])</strong>, and
<strong>nodes() = nodes(visible)</strong>.</p><h3>now/0</h3><p>Elapsed time since 00:00 GMT.</p><ul><li>timestamp</li></ul><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p><em>This function is deprecated. Do not use it.</em></p><p>For more information, see section
<a href="time_correction">Time and Time Correction</a>
in the User's Guide. Specifically, section
<a href="./time_correction#Dos_and_Donts"> Dos and Dont's</a> describes what to use instead of
<strong>erlang:now/0</strong>.</p></div><p>Returns the tuple <strong>{MegaSecs, Secs, MicroSecs}</strong>, which is
the elapsed time since 00:00 GMT, January 1, 1970 (zero hour),
if provided by the underlying OS.
Otherwise some other point in time is chosen. It is also
guaranteed that the following calls to this BIF return
continuously increasing values. Hence, the return value from
<strong>erlang:now/0</strong> can be used to generate unique time stamps.
If it is called in a tight loop on a fast machine,
the time of the node can become skewed.</p><p>Can only be used to check the local time of day if
the time-zone information of the underlying OS is
properly configured.</p><h3>open_port/2</h3><p>Open a port.</p><p>Returns a port identifier as the result of opening a
new Erlang port. A port can be seen as an external Erlang
process.</p><p>The name of the executable as well as the arguments
specifed in <strong>cd</strong>, <strong>env</strong>, <strong>args</strong>, and <strong>arg0</strong> are
subject to Unicode filename translation if the system is running
in Unicode filename mode. To avoid
translation or to force, for example UTF-8, supply the executable
and/or arguments as a binary in the correct
encoding. For details, see the module
<a href="./file">kernel/file</a>, the
function <a href="../kernel/file#native_name_encoding/0">kernel/file#native_name_encoding/0</a> in Kernel, and
the <a href="./unicode_usage">stdlib/unicode_usage</a> User's Guide.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The characters in the name (if specified as a list) can
only be &gt; 255 if the Erlang virtual machine is started
in Unicode filename translation mode. Otherwise the name
of the executable is limited to the ISO Latin-1
character set.</p></div><p><strong><span class="anno">PortName</span></strong>s:</p><dl><dt><strong>{spawn, <span class="anno">Command</span>}</strong></dt><dd> <p>Starts an external program. <strong><span class="anno">Command</span></strong>
is the name of the external program to be run.
<strong><span class="anno">Command</span></strong>
runs outside the Erlang work space unless an Erlang
driver with the name <strong><span class="anno">Command</span></strong> is found.
If found, that driver is started. A driver runs in the Erlang
work space, which means that it is linked with the Erlang
runtime system.</p> <p>For external programs, <strong>PATH</strong> is searched
(or an equivalent method is used to find programs,
depending on the OS). This is done by invoking
the shell on certain platforms. The first space-separated
token of the command is considered as the
name of the executable (or driver). This (among other
things) makes this option unsuitable for running
programs with spaces in filenames or directory names.
If spaces in executable filenames are desired, use
<strong>{spawn_executable, <span class="anno">Command</span>}</strong> instead.</p> </dd><dt><strong>{spawn_driver, <span class="anno">Command</span>}</strong></dt><dd> <p>Works like <strong>{spawn, <span class="anno">Command</span>}</strong>, but demands
the first (space-separated) token of the command to be the name
of a loaded driver. If no driver with that name is loaded, a
<strong>badarg</strong> error is raised.</p> </dd><dt><strong>{spawn_executable, <span class="anno">FileName</span>}</strong></dt><dd> <p>Works like <strong>{spawn, <span class="anno">FileName</span>}</strong>, but only runs
external executables. <strong><span class="anno">FileName</span></strong> in its whole
is used as the name of the executable, including any spaces.
If arguments are to be passed, the
<strong><span class="anno">PortSettings</span></strong>
<strong>args</strong> and <strong>arg0</strong> can be used.</p> <p>The shell is usually not invoked to start the
program, it is executed directly. <strong>PATH</strong> (or
equivalent) is not searched. To find a program
in <strong>PATH</strong> to execute, use
<a href="../kernel/os#find_executable/1">kernel/os#find_executable/1</a>.</p> <p>Only if a shell script or <strong>.bat</strong> file is
executed, the appropriate command interpreter is
invoked implicitly, but there is still no
command-argument expansion or implicit <strong>PATH</strong> search.</p> <p>If <strong><span class="anno">FileName</span></strong> cannot be run, an error
exception is raised, with the POSIX error code as the reason.
The error reason can differ between OSs.
Typically the error <strong>enoent</strong> is raised when an
attempt is made to run a program that is not found and
<strong>eacces</strong> is raised when the specified file is not
executable.</p> </dd><dt><strong>{fd, <span class="anno">In</span>, <span class="anno">Out</span>}</strong></dt><dd> <p>Allows an Erlang process to access any currently opened
file descriptors used by Erlang. The file descriptor
<strong><span class="anno">In</span></strong> can be used for standard input, and the
file descriptor <strong><span class="anno">Out</span></strong> for standard output.
It is only used for various servers in the Erlang OS (<strong>shell</strong>
and <strong>user</strong>). Hence, its use is limited.</p> </dd></dl><p><strong><span class="anno">PortSettings</span></strong> is a list of settings for the port.
The valid settings are as follows:</p><dl><dt><strong>{packet, <span class="anno">N</span>}</strong></dt><dd> <p>Messages are preceded by their length, sent in
<strong><span class="anno">N</span></strong>
bytes, with the most significant byte first. The valid values
for <strong>N</strong> are 1, 2, and 4.</p> </dd><dt><strong>stream</strong></dt><dd> <p>Output messages are sent without packet lengths. A
user-defined protocol must be used between the Erlang
process and the external object.</p> </dd><dt><strong>{line, <span class="anno">L</span>}</strong></dt><dd> <p>Messages are delivered on a per line basis. Each line
(delimited by the OS-dependent newline sequence) is
delivered in a single message. The message data format
is <strong>{Flag, Line}</strong>, where <strong>Flag</strong> is
<strong>eol</strong> or <strong>noeol</strong>, and <strong>Line</strong> is the
data delivered (without the newline sequence).</p> <p><strong><span class="anno">L</span></strong> specifies the maximum line length in bytes.
Lines longer than this are delivered in more than one
message, with <strong>Flag</strong> set to <strong>noeol</strong> for all
but the last message. If end of file is encountered
anywhere else than immediately following a newline
sequence, the last line is also delivered with
<strong>Flag</strong> set to <strong>noeol</strong>. Otherwise
lines are delivered with <strong>Flag</strong> set to <strong>eol</strong>.</p> <p>The <strong>{packet, <span class="anno">N</span>}</strong> and <strong>{line, <span class="anno">L</span>}</strong> settings are mutually exclusive.</p> </dd><dt><strong>{cd, <span class="anno">Dir</span>}</strong></dt><dd> <p>Only valid for <strong>{spawn, <span class="anno">Command</span>}</strong> and
<strong>{spawn_executable, <span class="anno">FileName</span>}</strong>.
The external program starts using <strong><span class="anno">Dir</span></strong> as its
working directory. <strong><span class="anno">Dir</span></strong> must be a string.</p> </dd><dt><strong>{env, <span class="anno">Env</span>}</strong></dt><dd> <p>
Types:<br/>
<strong><span class="anno">Name</span> = </strong><a href="../kernel/os#type-env_var_name">kernel/os#type-env_var_name</a><br/>
<strong><span class="anno">Val</span> = </strong><a href="../kernel/os#type-env_var_value">kernel/os#type-env_var_value</a><strong> | false</strong><br/>
<strong>Env = [{<span class="anno">Name</span>, <span class="anno">Val</span>}]</strong>
</p> <p>Only valid for <strong>{spawn, <span class="anno">Command</span>}</strong>, and
<strong>{spawn_executable, <span class="anno">FileName</span>}</strong>.
The environment of the started process is extended using
the environment specifications in <strong><span class="anno">Env</span></strong>.</p> <p><strong><span class="anno">Env</span></strong> is to be a list of tuples
<strong>{<span class="anno">Name</span>, <span class="anno">Val</span>}</strong>,
where <strong><span class="anno">Name</span></strong> is the name of an
environment variable, and <strong><span class="anno">Val</span></strong> is the
value it is to have in the spawned
port process. Both <strong><span class="anno">Name</span></strong> and
<strong><span class="anno">Val</span></strong> must be strings. The one
exception is <strong><span class="anno">Val</span></strong> being the atom
<strong>false</strong> (in analogy with
<a href="../kernel/os#getenv/1">kernel/os#getenv/1</a>,
which removes the environment variable.
</p> <p>
For information about encoding requirements, see documentation
of the types for <strong><span class="anno">Name</span></strong> and
<strong><span class="anno">Val</span></strong>.
</p> </dd><dt><strong>{args, [ string() | binary() ]}</strong></dt><dd> <p>Only valid for <strong>{spawn_executable, <span class="anno">FileName</span>}</strong>
and specifies arguments to the executable. Each argument
is specified as a separate string and (on Unix) eventually
ends up as one element each in the argument vector. On
other platforms, a similar behavior is mimicked.</p> <p>The arguments are not expanded by the shell before
they are supplied to the executable. Most notably this
means that file wildcard expansion does not occur.
To expand wildcards for the arguments, use
<a href="../stdlib/filelib#wildcard/1">stdlib/filelib#wildcard/1</a>.
Notice that even if
the program is a Unix shell script, meaning that the
shell ultimately is invoked, wildcard expansion
does not occur, and the script is provided with the
untouched arguments. On Windows, wildcard expansion
is always up to the program itself, therefore this is
not an issue.</p> <p>The executable name (also known as <strong>argv[0]</strong>)
is not to be specified in this list. The proper executable name
is automatically used as <strong>argv[0]</strong>, where applicable.</p> <p>If you explicitly want to set the
program name in the argument vector, option <strong>arg0</strong>
can be used.</p> </dd><dt><strong>{arg0, string() | binary()}</strong></dt><dd> <p>Only valid for <strong>{spawn_executable, <span class="anno">FileName</span>}</strong>
and explicitly specifies the program name argument when
running an executable. This can in some circumstances,
on some OSs, be desirable. How the program
responds to this is highly system-dependent and no specific
effect is guaranteed.</p> </dd><dt><strong>exit_status</strong></dt><dd> <p>Only valid for <strong>{spawn, <span class="anno">Command</span>}</strong>, where
<strong><span class="anno">Command</span></strong> refers to an external program, and
for <strong>{spawn_executable, <span class="anno">FileName</span>}</strong>.</p> <p>When the external process connected to the port exits, a
message of the form <strong>{Port,{exit_status,Status}}</strong> is
sent to the connected process, where <strong>Status</strong> is the
exit status of the external process. If the program
aborts on Unix, the same convention is used as the shells
do (that is, 128+signal).</p> <p>If option <strong>eof</strong> is specified also, the messages <strong>eof</strong>
and <strong>exit_status</strong> appear in an unspecified order.</p> <p>If the port program closes its <strong>stdout</strong> without exiting,
option <strong>exit_status</strong> does not work.</p> </dd><dt><strong>use_stdio</strong></dt><dd> <p>Only valid for <strong>{spawn, <span class="anno">Command</span>}</strong> and
<strong>{spawn_executable, <span class="anno">FileName</span>}</strong>. It
allows the standard input and output (file descriptors 0
and 1) of the spawned (Unix) process for communication
with Erlang.</p> </dd><dt><strong>nouse_stdio</strong></dt><dd> <p>The opposite of <strong>use_stdio</strong>. It uses file descriptors
3 and 4 for communication with Erlang.</p> </dd><dt><strong>stderr_to_stdout</strong></dt><dd> <p>Affects ports to external programs. The executed program
gets its standard error file redirected to its standard
output file. <strong>stderr_to_stdout</strong> and
<strong>nouse_stdio</strong> are mutually exclusive.</p> </dd><dt><strong>overlapped_io</strong></dt><dd> <p>Affects ports to external programs on Windows only. The
standard input and standard output handles of the port program
are, if this option is supplied, opened with flag
<strong>FILE_FLAG_OVERLAPPED</strong>, so that the port program can
(and must) do
overlapped I/O on its standard handles. This is not normally
the case for simple port programs, but an option of value for the
experienced Windows programmer. <em>On all other platforms, this option is silently discarded.</em></p> </dd><dt><strong>in</strong></dt><dd> <p>The port can only be used for input.</p> </dd><dt><strong>out</strong></dt><dd> <p>The port can only be used for output.</p> </dd><dt><strong>binary</strong></dt><dd> <p>All I/O from the port is binary data objects as opposed
to lists of bytes.</p> </dd><dt><strong>eof</strong></dt><dd> <p>The port is not closed at the end of the file and does not
produce an exit signal. Instead, it remains open and
a <strong>{Port, eof}</strong> message is sent to the process
holding the port.</p> </dd><dt><strong>hide</strong></dt><dd> <p>When running on Windows, suppresses creation of a new
console window when spawning the port program.
(This option has no effect on other platforms.)</p> </dd><dt><strong>{parallelism, Boolean}</strong></dt><dd> <a name="open_port_parallelism"></a> <p>Sets scheduler hint for port parallelism. If set to
<strong>true</strong>, the virtual machine schedules port tasks;
when doing so, it improves parallelism in the system. If set
to <strong>false</strong>, the virtual machine tries to
perform port tasks immediately, improving latency at the
expense of parallelism. The default can be set at system startup
by passing command-line argument
<a href="./erl#+spp">erl#+spp</a> to
<strong>erl(1)</strong>.</p> </dd></dl><p>Default is <strong>stream</strong> for all port types and
<strong>use_stdio</strong> for spawned ports.</p><p>Failure: if the port cannot be opened, the exit reason is
<strong>badarg</strong>, <strong>system_limit</strong>, or the POSIX error code that
most closely describes the error, or <strong>einval</strong> if no POSIX
code is appropriate:</p><dl><dt><strong>badarg</strong></dt><dd>Bad input arguments to <strong>open_port</strong>. </dd><dt><strong>system_limit</strong></dt><dd>All available ports in the Erlang emulator are in use. </dd><dt><strong>enomem</strong></dt><dd>Not enough memory to create the port. </dd><dt><strong>eagain</strong></dt><dd>No more available OS processes. </dd><dt><strong>enametoolong</strong></dt><dd>Too long external command. </dd><dt><strong>emfile</strong></dt><dd>No more available file descriptors (for the OS process that the Erlang emulator runs in). </dd><dt><strong>enfile</strong></dt><dd>Full file table (for the entire OS). </dd><dt><strong>eacces</strong></dt><dd><strong>Command</strong> specified in <strong>{spawn_executable, Command}</strong> does not point out an executable file. </dd><dt><strong>enoent</strong></dt><dd><strong><span class="anno">FileName</span></strong> specified in <strong>{spawn_executable, <span class="anno">FileName</span>}</strong> does not point out an existing file. </dd></dl><p>During use of a port opened using <strong>{spawn, Name}</strong>,
<strong>{spawn_driver, Name}</strong>, or <strong>{spawn_executable, Name}</strong>,
errors arising when sending messages to it are reported to
the owning process using signals of the form
<strong>{'EXIT', Port, PosixCode}</strong>. For the possible values of
<strong>PosixCode</strong>, see
<a href="./file">kernel/file</a>.</p><p>The maximum number of ports that can be open at the same
time can be configured by passing command-line flag
<a href="./erl#max_ports">erl#max_ports</a> to
<strong>erl(1)</strong>.</p><h3>phash/2</h3><p>Portable hash function.</p><dl><dt>Range</dt><dd>Range = 1..2^32, Hash = 1..Range</dd></dl><p>Portable hash function that gives the same hash for
the same Erlang term regardless of machine architecture and
ERTS version (the BIF was introduced in ERTS 4.9.1.1).
The function returns a hash value for
<strong><span class="anno">Term</span></strong> within the range
<strong>1..<span class="anno">Range</span></strong>. The maximum value for
<strong><span class="anno">Range</span></strong> is 2^32.</p><h3>phash2/1</h3><h3>phash2/2</h3><p>Portable hash function.</p><dl><dt>Range</dt><dd>1..2^32</dd></dl><dl><dt>Hash</dt><dd>0..Range-1</dd></dl><p>Portable hash function that gives the same hash for
the same Erlang term regardless of machine architecture and
ERTS version (the BIF was introduced in ERTS 5.2).
The function returns a hash value for
<strong><span class="anno">Term</span></strong> within the range
<strong>0..<span class="anno">Range</span>-1</strong>. The maximum value for
<strong><span class="anno">Range</span></strong> is 2^32. When without argument
<strong><span class="anno">Range</span></strong>, a value in the range
0..2^27-1 is returned.</p><p>This BIF is always to be used for hashing terms. It
distributes small integers better than <strong>phash/2</strong>, and
it is faster for bignums and binaries.</p><p>Notice that the range <strong>0..<span class="anno">Range</span>-1</strong> is
different from the range of <strong>phash/2</strong>, which is
<strong>1..<span class="anno">Range</span></strong>.</p><h3>pid_to_list/1</h3><p>Text representation of a pid.</p><p>Returns a string corresponding to the text
representation of <strong><span class="anno">Pid</span></strong>.</p><h3>port_call/3</h3><p>Perform a synchronous call to a port with term data.</p><p>Performs a synchronous call to a port. The meaning of
<strong><span class="anno">Operation</span></strong> and <strong><span class="anno">Data</span></strong>
depends on the port, that is,
on the port driver. Not all port drivers support this feature.</p><p><strong><span class="anno">Port</span></strong> is a port identifier,
referring to a driver.</p><p><strong><span class="anno">Operation</span></strong> is an integer, which is passed on to
the driver.</p><p><strong><span class="anno">Data</span></strong> is any Erlang term. This data is converted
to binary term format and sent to the port.</p><p>Returns a term from the driver. The meaning of the returned
data also depends on the port driver.</p><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Port</span></strong> is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by <strong><span class="anno">Port</span></strong>, the exit signal from the port is guaranteed to be delivered before this <strong>badarg</strong> exception occurs. </dd><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Operation</span></strong> does not fit in a 32-bit integer. </dd><dt><strong>badarg</strong></dt><dd> If the port driver does not support synchronous control operations. </dd><dt><strong>badarg</strong></dt><dd> <p>If the port driver so decides for any reason (probably
something wrong with <strong><span class="anno">Operation</span></strong>
or <strong><span class="anno">Data</span></strong>).</p> <div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Do not call <strong>port_call</strong> with an unknown
<strong><span class="anno">Port</span></strong> identifier and expect <strong>badarg</strong>
exception. Any undefined behavior is possible (including node
crash) depending on how the port driver interprets the supplied
arguments.</p></div> </dd></dl><h3>port_close/1</h3><p>Close an open port.</p><p>Closes an open port. Roughly the same as <strong><span class="anno">Port</span> ! {self(), close}</strong> except for the error behavior
(see below), being synchronous, and that the port does
<em>not</em> reply with <strong>{Port, closed}</strong>. Any process can
close a port with <strong>port_close/1</strong>, not only the port owner
(the connected process). If the calling process is linked to
the port identified by <strong><span class="anno">Port</span></strong>, the exit
signal from the port is guaranteed to be delivered before
<strong>port_close/1</strong> returns.</p><p>For comparison: <strong><span class="anno">Port</span> ! {self(), close}</strong>
only fails with <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> does
not refer to a port or a process. If <strong><span class="anno">Port</span></strong>
is a closed port, nothing happens. If <strong><span class="anno">Port</span></strong>
is an open port and the calling process is the port owner,
the port replies with <strong>{Port, closed}</strong> when all buffers
have been flushed and the port really closes. If the calling
process is not the port owner, the <em>port owner</em> fails
with <strong>badsig</strong>.</p><p>Notice that any process can close a port using
<strong><span class="anno">Port</span> ! {PortOwner, close}</strong> as if it itself was
the port owner, but the reply always goes to the port owner.</p><p>As from Erlang/OTP R16,
<strong><span class="anno">Port</span> ! {PortOwner, close}</strong> is truly
asynchronous. Notice that this operation has always been
documented as an asynchronous operation, while the underlying
implementation has been synchronous. <strong>port_close/1</strong> is
however still fully synchronous because of its error behavior.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not an
identifier of an open port, or the registered name of an open port.
If the calling process was previously linked to the closed
port, identified by <strong><span class="anno">Port</span></strong>, the exit
signal from the port is guaranteed to be delivered before
this <strong>badarg</strong> exception occurs.</p><h3>port_command/2</h3><p>Send data to a port.</p><p>Sends data to a port. Same as
<strong><span class="anno">Port</span> ! {PortOwner, {command, Data}}</strong> except for
the error behavior and being synchronous (see below). Any process
can send data to a port with <strong>port_command/2</strong>, not only the
port owner (the connected process).</p><p>For comparison: <strong><span class="anno">Port</span> ! {PortOwner, {command, Data}}</strong> only fails with <strong>badarg</strong> if <strong><span class="anno">Port</span></strong>
does not refer to a port or a process. If <strong><span class="anno">Port</span></strong> is
a closed port, the data message disappears 
without a sound. If <strong><span class="anno">Port</span></strong> is open and the calling
process is not the port owner, the <em>port owner</em> fails
with <strong>badsig</strong>. The port owner fails with <strong>badsig</strong>
also if <strong><span class="anno">Data</span></strong> is an invalid I/O list.</p><p>Notice that any process can send to a port using
<strong><span class="anno">Port</span> ! {PortOwner, {command, <span class="anno">Data</span>}}</strong>
as if it itself was the port owner.</p><p>If the port is busy, the calling process is suspended
until the port is not busy any more.</p><p>As from Erlang/OTP R16,
<strong><span class="anno">Port</span> ! {PortOwner, {command, Data}}</strong>
is truly asynchronous. Notice that this operation has always been
documented as an asynchronous operation, while the underlying
implementation has been synchronous. <strong>port_command/2</strong> is
however still fully synchronous because of its error behavior.</p><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> <p>If <strong><span class="anno">Port</span></strong> is not an identifier of an open
port, or the registered name of an open port. If the
calling process was previously linked to the closed port,
identified by <strong><span class="anno">Port</span></strong>, the exit signal
from the port is guaranteed to be delivered before this
<strong>badarg</strong> exception occurs.</p> </dd><dt><strong>badarg</strong></dt><dd> <p>If <strong><span class="anno">Data</span></strong> is an invalid I/O list.</p> </dd></dl><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Do not send data to an unknown port. Any undefined behavior is
possible (including node crash) depending on how the port driver
interprets the data.</p></div><h3>port_command/3</h3><p>Send data to a port.</p><p>Sends data to a port. <strong>port_command(Port, Data, [])</strong>
equals <strong>port_command(Port, Data)</strong>.</p><p>If the port command is aborted, <strong>false</strong> is returned,
otherwise <strong>true</strong>.</p><p>If the port is busy, the calling process is suspended
until the port is not busy anymore.</p><p><strong><span class="anno">Option</span></strong>s:</p><dl><dt><strong>force</strong></dt><dd>The calling process is not suspended if the port is busy, instead the port command is forced through. The call fails with a <strong>notsup</strong> exception if the driver of the port does not support this. For more information, see driver flag <a href="./driver_entry#driver_flags">driver_entry#driver_flags</a>. </dd><dt><strong>nosuspend</strong></dt><dd>The calling process is not suspended if the port is busy, instead the port command is aborted and <strong>false</strong> is returned.  </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>More options can be added in a future release.</p></div><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Port</span></strong> is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by <strong><span class="anno">Port</span></strong>, the exit signal from the port is guaranteed to be delivered before this <strong>badarg</strong> exception occurs. </dd><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Data</span></strong> is an invalid I/O list. </dd><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">OptionList</span></strong> is an invalid option list. </dd><dt><strong>notsup</strong></dt><dd> If option <strong>force</strong> has been passed, but the driver of the port does not allow forcing through a busy port. </dd></dl><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Do not send data to an unknown port. Any undefined behavior is
possible (including node crash) depending on how the port driver
interprets the data.</p></div><h3>port_connect/2</h3><p>Set the owner of a port.</p><p>Sets the port owner (the connected port) to <strong><span class="anno">Pid</span></strong>.
Roughly the same as
<strong><span class="anno">Port</span> ! {Owner, {connect, <span class="anno">Pid</span>}}</strong>
except for the following:</p><ul><li> <p>The error behavior differs, see below.</p> </li><li> <p>The port does <em>not</em> reply with
<strong>{Port,connected}</strong>.</p> </li><li> <p><strong>port_connect/1</strong> is synchronous, see below.</p> </li><li> <p>The new port owner gets linked to the port.</p> </li></ul><p>The old port owner stays linked to the port and must call
<strong>unlink(Port)</strong> if this is not desired. Any process can
set the port owner to be any process with
<strong>port_connect/2</strong>.</p><p>For comparison:
<strong><span class="anno">Port</span> ! {self(), {connect, <span class="anno">Pid</span>}}</strong>
only fails with <strong>badarg</strong> if <strong><span class="anno">Port</span></strong>
does not refer to a port or a process. If
<strong><span class="anno">Port</span></strong> is a closed port, nothing happens.
If <strong><span class="anno">Port</span></strong>
is an open port and the calling process is the port owner,
the port replies with <strong>{Port, connected}</strong> to the old
port owner. Notice that the old port owner is still linked to
the port, while the new is not. If <strong><span class="anno">Port</span></strong> is an open
port and the calling process is not the port owner,
the <em>port owner</em> fails with <strong>badsig</strong>. The port
owner fails with <strong>badsig</strong> also if <strong><span class="anno">Pid</span></strong> is not
an existing local process identifier.</p><p>Notice that any process can set the port owner using
<strong><span class="anno">Port</span> ! {PortOwner, {connect, <span class="anno">Pid</span>}}</strong>
as if it itself was the port owner, but the reply always goes to
the port owner.</p><p>As from Erlang/OTP R16,
<strong><span class="anno">Port</span> ! {PortOwner, {connect, <span class="anno">Pid</span>}}</strong>
is truly asynchronous. Notice that this operation has always been
documented as an asynchronous operation, while the underlying
implementation has been synchronous. <strong>port_connect/2</strong> is
however still fully synchronous because of its error behavior.</p><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Port</span></strong> is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by <strong><span class="anno">Port</span></strong>, the exit signal from the port is guaranteed to be delivered before this <strong>badarg</strong> exception occurs. </dd><dt><strong>badarg</strong></dt><dd>If the process identified by <strong>Pid</strong> is not an existing local process.</dd></dl><h3>port_control/3</h3><p>Perform a synchronous control operation on a port.</p><p>Performs a synchronous control operation on a port.
The meaning of <strong><span class="anno">Operation</span></strong> and
<strong><span class="anno">Data</span></strong> depends on
the port, that is, on the port driver. Not all port drivers
support this control feature.</p><p>Returns a list of integers in the range 0..255, or a
binary, depending on the port driver. The meaning of
the returned data also depends on the port driver.</p><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Port</span></strong> is not an open port or the registered name of an open port. </dd><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Operation</span></strong> cannot fit in a 32-bit integer. </dd><dt><strong>badarg</strong></dt><dd> If the port driver does not support synchronous control operations. </dd><dt><strong>badarg</strong></dt><dd> If the port driver so decides for any reason (probably something wrong with <strong><span class="anno">Operation</span></strong> or <strong><span class="anno">Data</span></strong>). <div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Do not call <strong>port_control/3</strong> with an unknown
<strong><span class="anno">Port</span></strong> identifier and expect <strong>badarg</strong>
exception. Any undefined behavior is possible (including node
crash) depending on how the port driver interprets the supplied
arguments.</p></div> </dd></dl><h3>port_info/1</h3><p>Information about a port.</p><p>Returns a list containing tuples with information about
<strong><span class="anno">Port</span></strong>, or <strong>undefined</strong> if the port is not open.
The order of the tuples is undefined, and all the
tuples are not mandatory.
If the port is closed and the calling process
was previously linked to the port, the exit signal from the
port is guaranteed to be delivered before <strong>port_info/1</strong>
returns <strong>undefined</strong>.</p><p>The result contains information about the following
<strong>Item</strong>s:</p><ul><li><strong>registered_name</strong> (if the port has a registered name)</li><li><strong>id</strong></li><li><strong>connected</strong></li><li><strong>links</strong></li><li><strong>name</strong></li><li><strong>input</strong></li><li><strong>output</strong></li></ul><p>For more information about the different <strong>Item</strong>s, see
<a href="#port_info/2">port_info/2</a>.</p><p>Failure: <strong>badarg</strong> if <strong>Port</strong> is not a local port
identifier, or an atom.</p><h3>port_info/2</h3><p>Information about the connected process of a port.</p><p><strong><span class="anno">Pid</span></strong> is the process identifier of the process
connected to the port.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h3>port_info/2</h3><p>Information about the internal index of a port.</p><p><strong><span class="anno">Index</span></strong> is the internal index of the port. This
index can be used to separate ports.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h3>port_info/2</h3><p>Information about the input of a port.</p><p><strong><span class="anno">Bytes</span></strong> is the total number of bytes
read from the port.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h3>port_info/2</h3><p>Information about the links of a port.</p><p><strong><span class="anno">Pids</span></strong> is a list of the process identifiers
of the processes that the port is linked to.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h3>port_info/2</h3><p>Information about the locking of a port.</p><p><strong><span class="anno">Locking</span></strong> is one of the following:</p><ul><li><strong>port_level</strong> (port-specific locking)</li><li><strong>driver_level</strong> (driver-specific locking)</li></ul><p>Notice that these results are highly implementation-specific
and can change in a future release.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h3>port_info/2</h3><p>Information about the memory size of a port.</p><a name="port_info_memory"></a><p><strong><span class="anno">Bytes</span></strong> is the total number of
bytes allocated for this port by the runtime system. The
port itself can have allocated memory that is not
included in <strong><span class="anno">Bytes</span></strong>.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h3>port_info/2</h3><p>Information about the monitors of a port.</p><p><strong><span class="anno">Monitors</span></strong> represent processes monitored by
this port.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h3>port_info/2</h3><p>Which processes are monitoring this port.</p><p>Returns list of pids that are monitoring given port at the
moment.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h3>port_info/2</h3><p>Information about the name of a port.</p><p><strong><span class="anno">Name</span></strong> is the command name set by
<a href="#open_port/2">open_port/2</a>.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h3>port_info/2</h3><p>Information about the OS pid of a port.</p><p><strong><span class="anno">OsPid</span></strong> is the process identifier (or equivalent)
of an OS process created with
<a href="#open_port/2">open_port/2</a>. If the port is not the result of
spawning an OS process, the value is <strong>undefined</strong>.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h3>port_info/2</h3><p>Information about the output of a port.</p><p><strong><span class="anno">Bytes</span></strong> is the total number of bytes written
to the port from Erlang processes using
<a href="#port_command/2">port_command/2</a>,
<a href="#port_command/3">port_command/3</a>,
or <strong><span class="anno">Port</span> ! {Owner, {command, Data}</strong>.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h3>port_info/2</h3><p>Information about the parallelism hint of a port.</p><p><strong><span class="anno">Boolean</span></strong> corresponds to the port parallelism
hint used by this port. For more information, see option
<a href="#open_port_parallelism">open_port_parallelism</a>
of <a href="#open_port/2">open_port/2</a>.</p><h3>port_info/2</h3><p>Information about the queue size of a port.</p><p><strong><span class="anno">Bytes</span></strong> is the total number
of bytes queued by the port using the ERTS driver queue
implementation.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h3>port_info/2</h3><p>Information about the registered name of a port.</p><p><strong><span class="anno">RegisteredName</span></strong> is the registered name of
the port. If the port has no registered name, <strong>[]</strong> is
returned.</p><p>If the port identified by <strong><span class="anno">Port</span></strong> is not open,
<strong>undefined</strong> is returned. If the port is closed and the
calling process was previously linked to the port, the exit
signal from the port is guaranteed to be delivered before
<strong>port_info/2</strong> returns <strong>undefined</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Port</span></strong> is not a local
port identifier, or an atom.</p><h3>port_to_list/1</h3><p>Text representation of a port identifier.</p><p>Returns a string corresponding to the text
representation of the port identifier <strong><span class="anno">Port</span></strong>.</p><h3>ports/0</h3><p>List all existing ports.</p><p>Returns a list of port identifiers corresponding to all the
ports existing on the local node.</p><p>Notice that an exiting port exists, but is not open.</p><h3>pre_loaded/0</h3><p>List all preloaded modules.</p><p>Returns a list of Erlang modules that are preloaded in
the system. As all loading of code is done through the file
system, the file system must have been loaded previously.
Hence, at least the module <strong>init</strong> must be preloaded.</p><h3>process_display/2</h3><p>Write information about a local process on standard error. </p><p>Writes information about the local process <strong><span class="anno">Pid</span></strong> on
standard error. The only allowed value for the atom
<strong><span class="anno">Type</span></strong> is <strong>backtrace</strong>, which shows the contents
of the call stack, including information about the call chain, with
the current function printed first. The format of the output
is not further defined.</p><h3>process_flag/2</h3><p>Set process flag trap_exit for the calling process.</p><p>When <strong>trap_exit</strong> is set to <strong>true</strong>, exit signals
arriving to a process are converted to <strong>{'EXIT', From, Reason}</strong>
messages, which can be received as ordinary
messages. If <strong>trap_exit</strong> is set to <strong>false</strong>, the
process exits if it receives an exit signal other than
<strong>normal</strong> and the exit signal is propagated to its
linked processes. Application processes are normally
not to trap exits.</p><p>Returns the old value of the flag.</p><p>See also <a href="#exit/2">exit/2</a>.</p><h3>process_flag/2</h3><p>Set process flag error_handler for the calling process. </p><p>Used by a process to redefine the error handler
for undefined function calls and undefined registered
processes. Inexperienced users are not to use this flag,
as code auto-loading depends on the correct
operation of the error handling module.</p><p>Returns the old value of the flag.</p><h3>process_flag/2</h3><p>Set process flag min_heap_size for the calling process. </p><p>Changes the minimum heap size for the calling process.</p><p>Returns the old value of the flag.</p><h3>process_flag/2</h3><p>Set process flag min_bin_vheap_size for the calling process. </p><p>Changes the minimum binary virtual heap size for the calling
process.</p><p>Returns the old value of the flag.</p><h3>process_flag/2</h3><p>Set process flag max_heap_size for the calling process. </p><ul><li>max_heap_size</li></ul><p>This flag sets the maximum heap size for the calling process.
If <strong><span class="anno">MaxHeapSize</span></strong> is an integer, the system default
values for <strong>kill</strong> and <strong>error_logger</strong> are used.
</p><dl><dt><strong>size</strong></dt><dd> <p>The maximum size in words of the process. If set to zero, the
heap size limit is disabled. <strong>badarg</strong> is be thrown if the
value is smaller than <a href="#process_flag_min_heap_size">process_flag_min_heap_size</a>. The size check is only done when
a garbage collection is triggered.</p> <p><strong>size</strong> is the entire heap of the process when garbage collection
is triggered. This includes all generational heaps, the process stack, 
any <a href="#process_flag_message_queue_data"> messages that are considered to be part of the heap</a>, and any
extra memory that the garbage collector needs during collection.</p> <p><strong>size</strong> is the same as can be retrieved using
<a href="#process_info_total_heap_size">process_info_total_heap_size</a>,
or by adding <strong>heap_block_size</strong>, <strong>old_heap_block_size</strong>
and <strong>mbuf_size</strong> from <a href="#process_info_garbage_collection_info">process_info_garbage_collection_info</a>.</p> </dd><dt><strong>kill</strong></dt><dd> <p>When set to <strong>true</strong>, the runtime system sends an
untrappable exit signal with reason <strong>kill</strong> to the process
if the maximum heap size is reached. The garbage collection
that triggered the <strong>kill</strong> is not completed, instead the
process exits as soon as possible. When set to <strong>false</strong>,
no exit signal is sent to the process, instead it continues
executing.</p> <p>If <strong>kill</strong> is not defined in the map,
the system default will be used. The default system default
is <strong>true</strong>. It can be changed by either option
<a href="./erl#+hmaxk">+hmaxk</a> in <strong>erl(1)</strong>,
or <a href="#system_flag_max_heap_size">system_flag_max_heap_size</a>.</p> </dd><dt><strong>error_logger</strong></dt><dd> <p>When set to <strong>true</strong>, the runtime system logs an
error event via <a href="./logger">kernel/logger</a>,
containing details about the process when the maximum
heap size is reached. One log event is sent
each time the limit is reached.</p> <p>If <strong>error_logger</strong> is not defined in the map, the system
default is used. The default system default is <strong>true</strong>.
It can be changed by either the option
<a href="./erl#+hmaxel">+hmaxel</a> int <strong>erl(1)</strong>,
or <a href="#system_flag_max_heap_size">system_flag_max_heap_size</a>.</p> </dd></dl><p>The heap size of a process is quite hard to predict, especially the
amount of memory that is used during the garbage collection. When
contemplating using this option, it is recommended to first run
it in production with <strong>kill</strong> set to <strong>false</strong> and inspect
the log events to see what the normal peak sizes
of the processes in the system is and then tune the value
accordingly.
</p><h3>process_flag/2</h3><p>Set process flag message_queue_data for the calling process. </p><ul><li>message_queue_data</li></ul><p>This flag determines how messages in the message queue
are stored, as follows:</p><dl><dt><strong>off_heap</strong></dt><dd> <p><em>All</em> messages in the message queue will be stored
outside of the process heap. This implies that <em>no</em>
messages in the message queue will be part of a garbage
collection of the process.</p> </dd><dt><strong>on_heap</strong></dt><dd> <p>All messages in the message queue will eventually be
placed on heap. They can however temporarily be stored
off heap. This is how messages always have been stored
up until ERTS 8.0.</p> </dd></dl><p>The default <strong>message_queue_data</strong> process flag is determined
by command-line argument <a href="./erl#+hmqd">erl#+hmqd</a> in <strong>erl(1)</strong>.</p><p>If the process potentially can get many messages in its queue,
you are advised to set the flag to <strong>off_heap</strong>. This
because a garbage collection with many messages placed on
the heap can become extremely expensive and the process can
consume large amounts of memory. Performance of the
actual message passing is however generally better when not
using flag <strong>off_heap</strong>.</p><p>When changing this flag messages will be moved. This work
has been initiated but not completed when this function
call returns.</p><p>Returns the old value of the flag.</p><h3>process_flag/2</h3><p>Set process flag priority for the calling process.</p><ul><li>priority_level</li></ul><p>
Sets the process priority. <strong><span class="anno">Level</span></strong> is an atom.
Four priority levels exist: <strong>low</strong>,
<strong>normal</strong>, <strong>high</strong>, and <strong>max</strong>. Default
is <strong>normal</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Priority level <strong>max</strong> is reserved for internal use in
the Erlang runtime system, and is <em>not</em> to be used
by others.</p></div><p>Internally in each priority level, processes are scheduled
in a round robin fashion.</p><p>Execution of processes on priority <strong>normal</strong> and
<strong>low</strong> are interleaved. Processes on priority
<strong>low</strong> are selected for execution less
frequently than processes on priority <strong>normal</strong>.</p><p>When runnable processes on priority <strong>high</strong> exist,
no processes on priority <strong>low</strong> or <strong>normal</strong> are
selected for execution. Notice however that this does
<em>not</em> mean that no processes on priority <strong>low</strong>
or <strong>normal</strong> can run when processes
are running on priority <strong>high</strong>. When using multiple
schedulers, more processes can be running
in parallel than processes on priority <strong>high</strong>. That is,
a <strong>low</strong> and a <strong>high</strong> priority process can
execute at the same time.</p><p>When runnable processes on priority <strong>max</strong> exist,
no processes on priority <strong>low</strong>, <strong>normal</strong>, or
<strong>high</strong> are selected for execution. As with priority
<strong>high</strong>, processes on lower priorities can
execute in parallel with processes on priority <strong>max</strong>.</p><p>Scheduling is pre-emptive. Regardless of priority, a process
is pre-empted when it has consumed more than a certain number
of reductions since the last time it was selected for
execution.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Do not depend on the scheduling
to remain exactly as it is today. Scheduling is likely to be
changed in a future release to use available processor cores better.</p></div><p>There is <em>no</em> automatic mechanism for
avoiding priority inversion, such as priority inheritance
or priority ceilings. When using priorities,
take this into account and handle such scenarios by
yourself.</p><p>Making calls from a <strong>high</strong> priority process into code
that you has no control over can cause the <strong>high</strong>
priority process to wait for a process with lower
priority. That is, effectively decreasing the priority of the
<strong>high</strong> priority process during the call. Even if this
is not the case with one version of the code that you have no
control over, it can be the case in a future
version of it. This can, for example, occur if a
<strong>high</strong> priority process triggers code loading, as
the code server runs on priority <strong>normal</strong>.</p><p>Other priorities than <strong>normal</strong> are normally not needed.
When other priorities are used, use them with care,
<em>especially</em> priority <strong>high</strong>. A
process on priority <strong>high</strong> is only
to perform work for short periods. Busy looping for
long periods in a <strong>high</strong> priority process causes
most likely problems, as important OTP servers
run on priority <strong>normal</strong>.</p><p>Returns the old value of the flag.</p><h3>process_flag/2</h3><p>Set process flag save_calls for the calling process.</p><p><strong><span class="anno">N</span></strong> must be an integer in the interval 0..10000.
If <strong><span class="anno">N</span></strong> &gt; 0, call saving is made
active for the
process. This means that information about the <strong><span class="anno">N</span></strong>
most recent global function calls, BIF calls, sends, and
receives made by the process are saved in a list, which
can be retrieved with
<strong>process_info(Pid, last_calls)</strong>. A global function
call is one in which the module of the function is
explicitly mentioned. Only a fixed amount of information
is saved, as follows:</p><ul><li><p>A tuple <strong>{Module, Function, Arity}</strong> for
function calls</p></li><li><p>The atoms <strong>send</strong>, <strong>'receive'</strong>, and
<strong>timeout</strong> for sends and receives (<strong>'receive'</strong>
when a message is received and <strong>timeout</strong> when a
receive times out)</p></li></ul><p>If <strong>N</strong> = 0,
call saving is disabled for the process, which is the
default. Whenever the size of the call saving list is set,
its contents are reset.</p><p>Returns the old value of the flag.</p><h3>process_flag/2</h3><p>Set process flag sensitive for the calling process.</p><p>Sets or clears flag <strong>sensitive</strong> for the current process.
When a process has been marked as sensitive by calling
<strong>process_flag(sensitive, true)</strong>, features in the runtime
system that can be used for examining the data or inner working
of the process are silently disabled.</p><p>Features that are disabled include (but are not limited to)
the following:</p><ul><li><p>Tracing. Trace flags can still be set for the process,
but no trace messages of any kind are generated. (If flag
<strong>sensitive</strong> is turned off, trace messages are again
generated if any trace flags are set.)</p></li><li><p>Sequential tracing. The sequential trace token is
propagated as usual, but no sequential trace messages are
generated.</p></li></ul><p><strong>process_info/1,2</strong> cannot be used to read out the
message queue or the process dictionary (both are returned
as empty lists).</p><p>Stack back-traces cannot be displayed for the process.</p><p>In crash dumps, the stack, messages, and the process dictionary
are omitted.</p><p>If <strong>{save_calls,N}</strong> has been set for the process, no
function calls are saved to the call saving list.
(The call saving list is not cleared. Also, send, receive,
and time-out events are still added to the list.)</p><p>Returns the old value of the flag.</p><h3>process_flag/3</h3><p>Set process flags for a process.</p><p>Sets certain flags for the process <strong><span class="anno">Pid</span></strong>,
in the same manner as
<a href="#process_flag/2">process_flag/2</a>.
Returns the old value of the flag. The valid values for
<strong><span class="anno">Flag</span></strong> are only a subset of those allowed in
<strong>process_flag/2</strong>, namely <strong>save_calls</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Pid</span></strong>
is not a local process.</p><h3>process_info/1</h3><p>Information about a process.</p><ul><li>process_info_result_item</li></ul><ul><li>priority_level</li></ul><ul><li>stack_item</li></ul><ul><li>max_heap_size</li></ul><ul><li>message_queue_data</li></ul><p>Returns a list containing <strong><span class="anno">InfoTuple</span></strong>s with
miscellaneous information about the process identified by
<strong>Pid</strong>, or <strong>undefined</strong> if the process is not alive.</p><p>The order of the <strong><span class="anno">InfoTuple</span></strong>s is undefined and
all <strong><span class="anno">InfoTuple</span></strong>s are not mandatory.
The <strong><span class="anno">InfoTuple</span></strong>s
part of the result can be changed without prior notice.</p><p>The <strong><span class="anno">InfoTuple</span></strong>s with the following items
are part of the result:</p><ul><li><strong>current_function</strong></li><li><strong>initial_call</strong></li><li><strong>status</strong></li><li><strong>message_queue_len</strong></li><li><strong>links</strong></li><li><strong>dictionary</strong></li><li><strong>trap_exit</strong></li><li><strong>error_handler</strong></li><li><strong>priority</strong></li><li><strong>group_leader</strong></li><li><strong>total_heap_size</strong></li><li><strong>heap_size</strong></li><li><strong>stack_size</strong></li><li><strong>reductions</strong></li><li><strong>garbage_collection</strong></li></ul><p>If the process identified by <strong><span class="anno">Pid</span></strong> has a
registered name,
also an <strong><span class="anno">InfoTuple</span></strong> with item <strong>registered_name</strong>
is included.</p><p>For information about specific <strong><span class="anno">InfoTuple</span></strong>s, see
<a href="#process_info/2">process_info/2</a>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for <em>debugging only</em>. For
all other purposes, use <a href="#process_info/2">process_info/2</a>.</p></div><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Pid</span></strong> is not a
local process.</p><h3>process_info/2</h3><h3>process_info/2</h3><p>Information about a process.</p><ul><li>process_info_item</li></ul><ul><li>process_info_result_item</li></ul><ul><li>stack_item</li></ul><ul><li>priority_level</li></ul><ul><li>max_heap_size</li></ul><ul><li>message_queue_data</li></ul><p>Returns information about the process identified by
<strong><span class="anno">Pid</span></strong>, as specified by
<strong><span class="anno">Item</span></strong> or <strong><span class="anno">ItemList</span></strong>.
Returns <strong>undefined</strong> if the process is not alive.</p><p>If the process is alive and a single <strong><span class="anno">Item</span></strong>
is specified, the returned value is the corresponding
<strong><span class="anno">InfoTuple</span></strong>, unless <strong>Item =:= registered_name</strong>
and the process has no registered name. In this case,
<strong>[]</strong> is returned. This strange behavior is because of
historical reasons, and is kept for backward compatibility.</p><p>If <strong><span class="anno">ItemList</span></strong> is specified, the result is
<strong><span class="anno">InfoTupleList</span></strong>.
The <strong><span class="anno">InfoTuple</span></strong>s in
<strong><span class="anno">InfoTupleList</span></strong> are included with the corresponding
<strong><span class="anno">Item</span></strong>s in the same order as the
<strong><span class="anno">Item</span></strong>s were included
in <strong><span class="anno">ItemList</span></strong>. Valid <strong><span class="anno">Item</span></strong>s can
be included multiple times in <strong><span class="anno">ItemList</span></strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If <strong>registered_name</strong> is part of <strong><span class="anno">ItemList</span></strong>
and the process has no name registered, a
<strong>{registered_name, []}</strong>, <strong><span class="anno">InfoTuple</span></strong>
<em>will</em> be included in the resulting
<strong><span class="anno">InfoTupleList</span></strong>. This
behavior is different when a single
<strong>Item =:= registered_name</strong> is specified, and when
<strong>process_info/1</strong> is used.</p></div><p>Valid <strong><span class="anno">InfoTuple</span></strong>s with corresponding
<strong><span class="anno">Item</span></strong>s:</p><dl><dt><strong>{backtrace, <span class="anno">Bin</span>}</strong></dt><dd> <p>Binary <strong><span class="anno">Bin</span></strong> contains the same information
as the output from
<strong>erlang:process_display(<span class="anno">Pid</span>, backtrace)</strong>. Use
<strong>binary_to_list/1</strong> to obtain the string of characters
from the binary.</p> </dd><dt><strong>{binary, <span class="anno">BinInfo</span>}</strong></dt><dd> <p><strong><span class="anno">BinInfo</span></strong> is a list containing miscellaneous
information about binaries on the heap of this
process.
This <strong><span class="anno">InfoTuple</span></strong> can be changed or
removed without prior notice. In the current implementation
<strong><span class="anno">BinInfo</span></strong> is a list of tuples. The tuples
contain; <strong>BinaryId</strong>, <strong>BinarySize</strong>, <strong>BinaryRefcCount</strong>.</p> <p>The message queue is on the heap depending on the
process flag <a href="#process_flag_message_queue_data">process_flag_message_queue_data</a>.</p> </dd><dt><strong>{catchlevel, <span class="anno">CatchLevel</span>}</strong></dt><dd> <p><strong><span class="anno">CatchLevel</span></strong> is the number of currently active
catches in this process. This <strong><span class="anno">InfoTuple</span></strong> can be
changed or removed without prior notice.</p> </dd><dt><strong>{current_function, {<span class="anno">Module</span>, <span class="anno">Function</span>, Arity} | undefined}</strong></dt><dd> <p><strong><span class="anno">Module</span></strong>, <strong><span class="anno">Function</span></strong>,
<strong><span class="anno">Arity</span></strong> is
the current function call of the process. The value
<strong>undefined</strong> can be returned if the process is
currently executing native compiled code.</p> </dd><dt><strong>{current_location, {<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Arity</span>, <span class="anno">Location</span>}}</strong></dt><dd> <p><strong><span class="anno">Module</span></strong>, <strong><span class="anno">Function</span></strong>,
<strong><span class="anno">Arity</span></strong> is
the current function call of the process.
<strong><span class="anno">Location</span></strong> is a list of two-tuples describing
the location in the source code.</p> </dd><dt><strong>{current_stacktrace, <span class="anno">Stack</span>}</strong></dt><dd> <p>Returns the current call stack back-trace (<em>stacktrace</em>)
of the process. The stack has the same format as returned by
<a href="#get_stacktrace/0">get_stacktrace/0</a>. The depth of the
stacktrace is truncated according to the <strong>backtrace_depth</strong>
system flag setting.</p> </dd><dt><strong>{dictionary, <span class="anno">Dictionary</span>}</strong></dt><dd> <p><strong><span class="anno">Dictionary</span></strong> is the process dictionary.</p> </dd><dt><strong>{error_handler, <span class="anno">Module</span>}</strong></dt><dd> <p><strong><span class="anno">Module</span></strong> is the error handler module used by
the process (for undefined function calls, for example).</p> </dd><dt><strong>{garbage_collection, <span class="anno">GCInfo</span>}</strong></dt><dd> <p><strong><span class="anno">GCInfo</span></strong> is a list containing miscellaneous
information about garbage collection for this process.
The content of <strong><span class="anno">GCInfo</span></strong> can be changed without
prior notice.</p> </dd><dt> <a name="process_info_garbage_collection_info"></a> <strong>{garbage_collection_info, <span class="anno">GCInfo</span>}</strong> </dt><dd> <p><strong><span class="anno">GCInfo</span></strong> is a list containing miscellaneous
detailed information about garbage collection for this process.
The content of <strong><span class="anno">GCInfo</span></strong> can be changed without
prior notice. For details about the meaning of each item, see
<a href="#gc_minor_start">gc_minor_start</a>
in <a href="#trace/3">trace/3</a>.</p> </dd><dt><strong>{group_leader, <span class="anno">GroupLeader</span>}</strong></dt><dd> <p><strong><span class="anno">GroupLeader</span></strong> is the group leader for the I/O
of the process.</p> </dd><dt><strong>{heap_size, <span class="anno">Size</span>}</strong></dt><dd> <p><strong><span class="anno">Size</span></strong> is the size in words of the youngest
heap generation of the process. This generation includes
the process stack. This information is highly
implementation-dependent, and can change if the
implementation changes.</p> </dd><dt><strong>{initial_call, {<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Arity</span>}}</strong></dt><dd> <p><strong><span class="anno">Module</span></strong>, <strong><span class="anno">Function</span></strong>,
<strong><span class="anno">Arity</span></strong> is
the initial function call with which the process was
spawned.</p> </dd><dt><strong>{links, <span class="anno">PidsAndPorts</span>}</strong></dt><dd> <p><strong><span class="anno">PidsAndPorts</span></strong> is a list of process identifiers
and port identifiers, with processes or ports to which the process
has a link.</p> </dd><dt><strong>{last_calls, false|Calls}</strong></dt><dd> <p>The value is <strong>false</strong> if call saving is not active
for the process (see <a href="#process_flag/3">process_flag/3</a>).
If call saving is active, a list is returned, in which
the last element is the most recent called.</p> </dd><dt><strong>{memory, <span class="anno">Size</span>}</strong></dt><dd> <a name="process_info_memory"></a> <p><strong><span class="anno">Size</span></strong> is the size in bytes of the process.
This includes call stack, heap, and internal structures.</p> </dd><dt><strong>{message_queue_len, <span class="anno">MessageQueueLen</span>}</strong></dt><dd> <p><strong><span class="anno">MessageQueueLen</span></strong> is the number of messages
currently in the message queue of the process. This is the
length of the list <strong><span class="anno">MessageQueue</span></strong> returned as
the information item <strong>messages</strong> (see below).</p> </dd><dt><strong>{messages, <span class="anno">MessageQueue</span>}</strong></dt><dd> <p><strong><span class="anno">MessageQueue</span></strong> is a list of the messages to
the process, which have not yet been processed.</p> </dd><dt><strong>{min_heap_size, <span class="anno">MinHeapSize</span>}</strong></dt><dd> <p><strong><span class="anno">MinHeapSize</span></strong> is the minimum heap size
for the process.</p> </dd><dt><strong>{min_bin_vheap_size, <span class="anno">MinBinVHeapSize</span>}</strong></dt><dd> <p><strong><span class="anno">MinBinVHeapSize</span></strong> is the minimum binary virtual
heap size for the process.</p> </dd><dt><strong>{monitored_by, <span class="anno">MonitoredBy</span>}</strong></dt><dd> <p>A list of identifiers for all the processes, ports and NIF
resources, that are monitoring the process.</p> </dd><dt><strong>{monitors, <span class="anno">Monitors</span>}</strong></dt><dd> <p>A list of monitors (started by <strong>monitor/2</strong>)
that are active for the process. For a local process
monitor or a remote process monitor by a process
identifier, the list consists of:</p> <dl><dt><strong>{process, <span class="anno">Pid</span>}</strong></dt><dd>Process is monitored by pid.</dd><dt><strong>{process, {<span class="anno">RegName</span>, <span class="anno">Node</span>}}</strong></dt><dd>Local or remote process is monitored by name.</dd><dt><strong>{port, PortId}</strong></dt><dd>Local port is monitored by port id.</dd><dt><strong>{port, {<span class="anno">RegName</span>, <span class="anno">Node</span>}}</strong></dt><dd>Local port is monitored by name. Please note, that remote port monitors are not supported, so <strong>Node</strong> will always be the local node name.</dd></dl> </dd><dt><strong>{message_queue_data, <span class="anno">MQD</span>}</strong></dt><dd> <p>Returns the current state of process flag
<strong>message_queue_data</strong>. <strong><span class="anno">MQD</span></strong> is either
<strong>off_heap</strong> or <strong>on_heap</strong>. For more
information, see the documentation of
<a href="#process_flag_message_queue_data">process_flag_message_queue_data</a>.</p> </dd><dt><strong>{priority, <span class="anno">Level</span>}</strong></dt><dd> <p><strong><span class="anno">Level</span></strong> is the current priority level for
the process. For more information on priorities, see
<a href="#process_flag_priority">process_flag_priority</a>.</p> </dd><dt><strong>{reductions, <span class="anno">Number</span>}</strong></dt><dd> <p><strong><span class="anno">Number</span></strong> is the number of reductions executed
by the process.</p> </dd><dt><strong>{registered_name, <span class="anno">Atom</span>}</strong></dt><dd> <p><strong><span class="anno">Atom</span></strong> is the registered process name.
If the process has no registered name, this tuple is not
present in the list.</p> </dd><dt><strong>{sequential_trace_token, [] | <span class="anno">SequentialTraceToken</span>}</strong></dt><dd> <p><strong><span class="anno">SequentialTraceToken</span></strong> is the sequential trace
token for the process. This <strong><span class="anno">InfoTuple</span></strong> can be
changed or removed without prior notice.</p> </dd><dt><strong>{stack_size, <span class="anno">Size</span>}</strong></dt><dd> <p><strong><span class="anno">Size</span></strong> is the stack size, in words,
of the process.</p> </dd><dt><strong>{status, <span class="anno">Status</span>}</strong></dt><dd> <p><strong><span class="anno">Status</span></strong> is the status of the process and is
one of the following:</p> <ul><li><strong>exiting</strong></li><li><strong>garbage_collecting</strong></li><li><strong>waiting</strong> (for a message)</li><li><strong>running</strong></li><li><strong>runnable</strong> (ready to run, but another process is running)</li><li><strong>suspended</strong> (suspended on a "busy" port or by the BIF <strong>erlang:suspend_process/1,2</strong>)</li></ul> </dd><dt><strong>{suspending, <span class="anno">SuspendeeList</span>}</strong></dt><dd> <p><strong><span class="anno">SuspendeeList</span></strong> is a list of
<strong>{<span class="anno">Suspendee</span>, <span class="anno">ActiveSuspendCount</span>, <span class="anno">OutstandingSuspendCount</span>}</strong> tuples.
<strong><span class="anno">Suspendee</span></strong> is the process identifier of a
process that has been, or is to be,
suspended by the process identified by <strong><span class="anno">Pid</span></strong>
through the BIF <a href="#suspend_process/2">suspend_process/2</a> or
<a href="#suspend_process/1">suspend_process/1</a>.</p> <p><strong><span class="anno">ActiveSuspendCount</span></strong> is the number of
times <strong><span class="anno">Suspendee</span></strong> has been suspended by
<strong><span class="anno">Pid</span></strong>.
<strong><span class="anno">OutstandingSuspendCount</span></strong> is the number of not
yet completed suspend requests sent by <strong><span class="anno">Pid</span></strong>,
that is:</p> <ul><li> <p>If <strong><span class="anno">ActiveSuspendCount</span> =/= 0</strong>,
<strong><span class="anno">Suspendee</span></strong> is
currently in the suspended state.</p> </li><li> <p>If <strong><span class="anno">OutstandingSuspendCount</span> =/= 0</strong>,
option <strong>asynchronous</strong> of <strong>erlang:suspend_process/2</strong>
has been used and the suspendee has not yet been
suspended by <strong><span class="anno">Pid</span></strong>.</p> </li></ul> <p>Notice that <strong><span class="anno">ActiveSuspendCount</span></strong> and
<strong><span class="anno">OutstandingSuspendCount</span></strong> are not the
total suspend count on <strong><span class="anno">Suspendee</span></strong>,
only the parts contributed by <strong><span class="anno">Pid</span></strong>.</p> </dd><dt> <a name="process_info_total_heap_size"></a> <strong>{total_heap_size, <span class="anno">Size</span>}</strong> </dt><dd> <p><strong><span class="anno">Size</span></strong> is the total size, in words, of all heap
fragments of the process. This includes the process stack and
any unreceived messages that are considered to be part of the
heap.</p> </dd><dt><strong>{trace, <span class="anno">InternalTraceFlags</span>}</strong></dt><dd> <p><strong><span class="anno">InternalTraceFlags</span></strong> is an integer
representing the internal trace flag for this process.
This <strong><span class="anno">InfoTuple</span></strong>
can be changed or removed without prior notice.</p> </dd><dt><strong>{trap_exit, <span class="anno">Boolean</span>}</strong></dt><dd> <p><strong><span class="anno">Boolean</span></strong> is <strong>true</strong> if the process
is trapping exits, otherwise <strong>false</strong>.</p> </dd></dl><p>Notice that not all implementations support all
these <strong><span class="anno">Item</span></strong>s.</p><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">Pid</span></strong> is not a local process.</dd><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">Item</span></strong> is an invalid item.</dd></dl><h3>processes/0</h3><p>All processes.</p><p>Returns a list of process identifiers corresponding to
all the processes currently existing on the local node.</p><p>Notice that an exiting process exists, but is not alive.
That is, <strong>is_process_alive/1</strong> returns <strong>false</strong>
for an exiting process, but its process identifier is part
of the result returned from <strong>processes/0</strong>.</p><p>Example:</p><pre>
&gt; <span class="input">processes().</span>
[&lt;0.0.0&gt;,&lt;0.2.0&gt;,&lt;0.4.0&gt;,&lt;0.5.0&gt;,&lt;0.7.0&gt;,&lt;0.8.0&gt;]</pre><h3>purge_module/1</h3><p>Remove old code for a module.</p><p>Removes old code for <strong><span class="anno">Module</span></strong>.
Before this BIF is used,
<a href="#check_process_code/2">check_process_code/2</a>is to be called to check
that no processes execute old code in the module.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for the code server (see
<a href="./code">kernel/code</a>)
and is not to be used elsewhere.</p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from ERTS 8.0 (Erlang/OTP 19), any lingering processes
that still execute the old code is killed by this function.
In earlier versions, such incorrect use could cause much
more fatal failures, like emulator crash.</p></div><p>Failure: <strong>badarg</strong> if there is no old code for
<strong><span class="anno">Module</span></strong>.</p><h3>put/2</h3><p>Add a new value to the process dictionary.</p><p>Adds a new <strong><span class="anno">Key</span></strong> to the process dictionary,
associated with the value <strong><span class="anno">Val</span></strong>, and returns
<strong>undefined</strong>. If <strong><span class="anno">Key</span></strong> exists, the old
value is deleted and replaced by <strong><span class="anno">Val</span></strong>, and
the function returns the old value. Example:</p><pre>
&gt; <span class="input">X = put(name, walrus), Y = put(name, carpenter),</span>
<span class="input">Z = get(name),</span>
<span class="input">{X, Y, Z}.</span>
{undefined,walrus,carpenter}</pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The values stored when <strong>put</strong> is evaluated within
the scope of a <strong>catch</strong> are not retracted if a
<strong>throw</strong> is evaluated, or if an error occurs.</p></div><h3>raise/3</h3><p>Stop execution with an exception of specified class, reason, and call stack backtrace.</p><ul><li>raise_stacktrace</li></ul><p>Stops the execution of the calling process with an
exception of the specified class, reason, and call stack backtrace
(<em>stacktrace</em>).</p><p><strong><span class="anno">Class</span></strong> is <strong>error</strong>, <strong>exit</strong>, or
<strong>throw</strong>. So, if it were not for the stacktrace,
<strong>erlang:raise(<span class="anno">Class</span>, <span class="anno">Reason</span>, <span class="anno">Stacktrace</span>)</strong> is equivalent to
<strong>erlang:<span class="anno">Class</span>(<span class="anno">Reason</span>)</strong>.</p><p><strong><span class="anno">Reason</span></strong> is any term.
<strong><span class="anno">Stacktrace</span></strong> is a list as
returned from <strong>get_stacktrace()</strong>, that is, a list of
four-tuples <strong>{Module, Function, Arity | Args, Location}</strong>, where <strong>Module</strong> and <strong>Function</strong>
are atoms, and the third element is an integer arity or an
argument list. The stacktrace can also contain <strong>{Fun, Args, Location}</strong> tuples, where <strong>Fun</strong> is a local
fun and <strong>Args</strong> is an argument list.</p><p>Element <strong>Location</strong> at the end is optional.
Omitting it is equivalent to specifying an empty list.</p><p>The stacktrace is used as the exception stacktrace for the
calling process; it is truncated to the current
maximum stacktrace depth.</p><p>As evaluating this function causes the process to
terminate, it has no return value unless the arguments are
invalid, in which case the function <em>returns the error reason</em> <strong>badarg</strong>. If you want to be
sure not to return, you can call
<strong>error(erlang:raise(<span class="anno">Class</span>, <span class="anno">Reason</span>, <span class="anno">Stacktrace</span>))</strong>
and hope to distinguish exceptions later.</p><h3>read_timer/1</h3><p>Read the state of a timer.</p><p>Reads the state of a timer. The same as calling
<a href="#read_timer/2">read_timer/2</a>.</p><h3>read_timer/2</h3><p>Read the state of a timer.</p><p>Reads the state of a timer that has been created by either
<a href="#start_timer/4">start_timer/4</a>
or <a href="#send_after/4">send_after/4</a>.
<strong><span class="anno">TimerRef</span></strong> identifies the timer, and
was returned by the BIF that created the timer.</p><p><strong><span class="anno">Option</span>s</strong>:</p><dl><dt><strong>{async, Async}</strong></dt><dd> <p>Asynchronous request for state information. <strong>Async</strong>
defaults to <strong>false</strong>, which causes the operation
to be performed synchronously. In this case, the <strong>Result</strong>
is returned by <strong>erlang:read_timer</strong>. When
<strong>Async</strong> is <strong>true</strong>, <strong>erlang:read_timer</strong>
sends an asynchronous request for the state information
to the timer service that manages the timer, and then returns
<strong>ok</strong>. A message on the format <strong>{read_timer, <span class="anno">TimerRef</span>, <span class="anno">Result</span>}</strong> is
sent to the caller of <strong>erlang:read_timer</strong> when the
operation has been processed.</p> </dd></dl><p>More <strong><span class="anno">Option</span></strong>s can be added in the future.</p><p>If <strong><span class="anno">Result</span></strong> is an integer, it represents the
time in milliseconds left until the timer expires.</p><p>If <strong><span class="anno">Result</span></strong> is <strong>false</strong>, a
timer corresponding to <strong><span class="anno">TimerRef</span></strong> could not
be found. This because the timer had expired,
or been canceled, or because <strong><span class="anno">TimerRef</span></strong>
never has corresponded to a timer. Even if the timer has expired,
it does not tell you whether or not the time-out message has
arrived at its destination yet.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The timer service that manages the timer can be co-located
with another scheduler than the scheduler that the calling
process is executing on. If so, communication
with the timer service takes much longer time than if it
is located locally. If the calling process is in a critical
path, and can do other things while waiting for the result
of this operation, you want to use option <strong>{async, true}</strong>.
If using option <strong>{async, false}</strong>, the calling
process is blocked until the operation has been performed.</p></div><p>See also 
<a href="#send_after/4">send_after/4</a>,
<a href="#start_timer/4">start_timer/4</a>, and
<a href="#cancel_timer/2">cancel_timer/2</a>.</p><h3>ref_to_list/1</h3><p>Text representation of a reference.</p><p>Returns a string corresponding to the text
representation of <strong><span class="anno">Ref</span></strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for debugging and is not to be used
in application programs.</p></div><h3>register/2</h3><p>Register a name for a pid (or port).</p><p>Associates the name <strong><span class="anno">RegName</span></strong> with a process
identifier (pid) or a port identifier.
<strong><span class="anno">RegName</span></strong>, which must be an atom, can be used
instead of the pid or port identifier in send operator
(<strong><span class="anno">RegName</span> ! Message</strong>). Example:</p><pre>
&gt; <span class="input">register(db, Pid).</span>
true</pre><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">PidOrPort</span></strong> is not an existing local process or port.</dd><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">RegName</span></strong> is already in use.</dd><dt><strong>badarg</strong></dt><dd>If the process or port is already registered (already has a name).</dd><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">RegName</span></strong> is the atom <strong>undefined</strong>.</dd></dl><h3>registered/0</h3><p>All registered names.</p><p>Returns a list of names that have been registered using
<a href="#register/2">register/2</a>, for
example:</p><pre>
&gt; <span class="input">registered().</span>
[code_server, file_server, init, user, my_db]</pre><h3>resume_process/1</h3><p>Resume a suspended process.</p><p>Decreases the suspend count on the process identified by
<strong><span class="anno">Suspendee</span></strong>. <strong><span class="anno">Suspendee</span></strong>
is previously to have been suspended through
<a href="#suspend_process/2">suspend_process/2</a> or
<a href="#suspend_process/1">suspend_process/1</a>
by the process calling
<strong>erlang:resume_process(<span class="anno">Suspendee</span>)</strong>. When the
suspend count on <strong><span class="anno">Suspendee</span></strong> reaches zero,
<strong><span class="anno">Suspendee</span></strong> is resumed, that is, its state
is changed from suspended into the state it had before it was
suspended.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for debugging only.</p></div><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Suspendee</span></strong> is not a process identifier. </dd><dt><strong>badarg</strong></dt><dd> If the process calling <strong>erlang:resume_process/1</strong> had not previously increased the suspend count on the process identified by <strong><span class="anno">Suspendee</span></strong>. </dd><dt><strong>badarg</strong></dt><dd> If the process identified by <strong><span class="anno">Suspendee</span></strong> is not alive. </dd></dl><h3>round/1</h3><p>Return an integer by rounding a number.</p><p>Returns an integer by rounding <strong><span class="anno">Number</span></strong>,
for example:</p><pre>
<span class="input">round(5.5).</span>
6</pre><p>Allowed in guard tests.</p><h3>self/0</h3><p>Return pid of the calling process.</p><p>Returns the process identifier of the calling process, for
example:</p><pre>
&gt; <span class="input">self().</span>
&lt;0.26.0&gt;</pre><p>Allowed in guard tests.</p><h3>send/2</h3><p>Send a message.</p><ul><li>dst</li></ul><p>Sends a message and returns <strong><span class="anno">Msg</span></strong>. This
is the same as using the <a href="../doc/reference_manual/expressions#send"> send operator</a>:
<strong><span class="anno">Dest</span> ! <span class="anno">Msg</span></strong>.</p><p><strong><span class="anno">Dest</span></strong> can be a remote or local process identifier,
a (local) port, a locally registered name, or a tuple
<strong>{<span class="anno">RegName</span>, <span class="anno">Node</span>}</strong>
for a registered name at another node.</p><p>The function fails with a <strong>badarg</strong> run-time error if
<strong><span class="anno">Dest</span></strong> is an atom name, but this name is not
registered. This is the only case when <strong>send</strong> fails for an
unreachable destination <strong><span class="anno">Dest</span></strong> (of correct type).</p><h3>send/3</h3><p>Send a message conditionally.</p><ul><li>dst</li></ul><p>Either sends a message and returns <strong>ok</strong>, or does not send
the message but returns something else (see below).
Otherwise the same as
<a href="#send/2">send/2</a>.
For more detailed explanation and warnings, see
<a href="#send_nosuspend/2">send_nosuspend/2</a>.</p><p>Options:</p><dl><dt><strong>nosuspend</strong></dt><dd>If the sender would have to be suspended to do the send, <strong>nosuspend</strong> is returned instead. </dd><dt><strong>noconnect</strong></dt><dd> If the destination node would have to be auto-connected to do the send, <strong>noconnect</strong> is returned instead. </dd></dl><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>As with <strong>erlang:send_nosuspend/2,3</strong>: use with extreme
care.</p></div><h3>send_after/3</h3><p>Start a timer.</p><p>Starts a timer. The same as calling
<a href="#send_after/4">send_after/4</a>.</p><h3>send_after/4</h3><p>Start a timer.</p><p>Starts a timer. When the timer expires, the message
<strong><span class="anno">Msg</span></strong> is sent to the process
identified by <strong><span class="anno">Dest</span></strong>. Apart from
the format of the time-out message, this function works exactly as
<a href="#start_timer/4">start_timer/4</a>.</p><h3>send_nosuspend/2</h3><p>Try to send a message without ever blocking.</p><ul><li>dst</li></ul><p>The same as
<a href="#send/3">send/3</a>,
but returns <strong>true</strong> if
the message was sent and <strong>false</strong> if the message was not
sent because the sender would have had to be suspended.</p><p>This function is intended for send operations to an
unreliable remote node without ever blocking the sending
(Erlang) process. If the connection to the remote node
(usually not a real Erlang node, but a node written in C or
Java) is overloaded, this function <em>does not send the message</em>
and returns <strong>false</strong>.</p><p>The same occurs if <strong><span class="anno">Dest</span></strong> refers to a local port
that is busy. For all other destinations (allowed for the ordinary
send operator <strong>'!'</strong>), this function sends the message and
returns <strong>true</strong>.</p><p>This function is only to be used in rare circumstances
where a process communicates with Erlang nodes that can
disappear without any trace, causing the TCP buffers and
the drivers queue to be over-full before the node is
shut down (because of tick time-outs) by <strong>net_kernel</strong>.
The normal reaction to take when this occurs is some kind of
premature shutdown of the other node.</p><p>Notice that ignoring the return value from this function would
result in an <em>unreliable</em> message passing, which is
contradictory to the Erlang programming model. The message is
<em>not</em> sent if this function returns <strong>false</strong>.</p><p>In many systems, transient states of
overloaded queues are normal. Although this function
returns <strong>false</strong> does not mean that the other
node is guaranteed to be non-responsive, it could be a
temporary overload. Also, a return value of <strong>true</strong> does
only mean that the message can be sent on the (TCP) channel
without blocking; the message is not guaranteed to
arrive at the remote node. For a disconnected
non-responsive node, the return value is <strong>true</strong> (mimics
the behavior of operator <strong>!</strong>). The expected
behavior and the actions to take when the function
returns <strong>false</strong> are application- and hardware-specific.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Use with extreme care.</p></div><h3>send_nosuspend/3</h3><p>Try to send a message without ever blocking.</p><ul><li>dst</li></ul><p>The same as
<a href="#send/3">send/3</a>,
but with a Boolean return value.</p><p>This function behaves like
<a href="#send_nosuspend/2">send_nosuspend/2</a>,
but takes a third parameter, a list of options.
The only option is <strong>noconnect</strong>, which
makes the function return <strong>false</strong> if
the remote node is not currently reachable by the local
node. The normal behavior is to try to connect to the node,
which can stall the process during a short period. The use of
option <strong>noconnect</strong> makes it possible to be
sure not to get the slightest delay when
sending to a remote process. This is especially useful when
communicating with nodes that expect to always be
the connecting part (that is, nodes written in C or Java).</p><p>Whenever the function returns <strong>false</strong> (either when a
suspend would occur or when <strong>noconnect</strong> was specified and
the node was not already connected), the message is guaranteed
<em>not</em> to have been sent.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Use with extreme care.</p></div><h3>set_cookie/2</h3><p>Set the magic cookie of a node.</p><p>Sets the magic cookie of <strong><span class="anno">Node</span></strong> to the atom
<strong><span class="anno">Cookie</span></strong>. If <strong><span class="anno">Node</span></strong> is the
local node, the function
also sets the cookie of all other unknown nodes to
<strong><span class="anno">Cookie</span></strong> (see section
<a href="./distributed"> Distributed Erlang</a>
in the Erlang Reference Manual in System Documentation).</p><p>Failure: <strong>function_clause</strong> if the local node is not
alive.</p><h3>setelement/3</h3><p>Set the Nth element of a tuple.</p><dl><dt>Index</dt><dd>1..tuple_size(<span class="anno">Tuple1</span></dd></dl><p>Returns a tuple that is a copy of argument
<strong><span class="anno">Tuple1</span></strong>
with the element specified by integer argument
<strong><span class="anno">Index</span></strong>
(the first element is the element with index 1) replaced by
argument <strong><span class="anno">Value</span></strong>, for example:</p><pre>
&gt; <span class="input">setelement(2, {10, green, bottles}, red).</span>
{10,red,bottles}</pre><h3>size/1</h3><p>Size of a tuple or binary.</p><p>Returns the number of elements in a tuple or the number of
bytes in a binary or bitstring, for example:</p><pre>
&gt; <span class="input">size({morni, mulle, bwange}).</span>
3
&gt; <span class="input">size(&lt;&lt;11, 22, 33&gt;&gt;).</span>
3</pre><p>For bitstrings, the number of whole bytes is returned.
That is, if the number of bits
in the bitstring is not divisible by 8, the resulting
number of bytes is rounded <em>down</em>.</p><p>Allowed in guard tests.</p><p>See also
<a href="#tuple_size/1">tuple_size/1</a>,
<a href="#byte_size/1">byte_size/1</a>, and
<a href="#bit_size/1">bit_size/1</a>.</p><h3>spawn/1</h3><p>Create a new process with a fun as entry point.</p><p>Returns the process identifier of a new process started by the
application of <strong><span class="anno">Fun</span></strong> to the empty list
<strong>[]</strong>. Otherwise
works like <a href="#spawn/3">spawn/3</a>.</p><h3>spawn/2</h3><p>Create a new process with a fun as entry point on a specified node.</p><p>Returns the process identifier of a new process started
by the application of <strong><span class="anno">Fun</span></strong> to the
empty list <strong>[]</strong> on <strong><span class="anno">Node</span></strong>. If
<strong><span class="anno">Node</span></strong> does not exist, a useless pid is
returned. Otherwise works like
<a href="#spawn/3">spawn/3</a>.</p><h3>spawn/3</h3><p>Create a new process with a function as entry point.</p><p>Returns the process identifier of a new process started by
the application of <strong><span class="anno">Module</span>:<span class="anno">Function</span></strong>
to <strong><span class="anno">Args</span></strong>.</p><p><strong>error_handler:undefined_function(<span class="anno">Module</span>, <span class="anno">Function</span>, <span class="anno">Args</span>)</strong>
is evaluated by the new process if
<strong><span class="anno">Module</span>:<span class="anno">Function</span>/Arity</strong>
does not exist (where <strong>Arity</strong> is the length of
<strong><span class="anno">Args</span></strong>). The error handler
can be redefined (see
<a href="#process_flag/2">process_flag/2</a>).
If <strong>error_handler</strong> is undefined, or the user has
redefined the default <strong>error_handler</strong> and its replacement is
undefined, a failure with reason <strong>undef</strong> occurs.</p><p>Example:</p><pre>
&gt; <span class="input">spawn(speed, regulator, [high_speed, thin_cut]).</span>
&lt;0.13.1&gt;</pre><h3>spawn/4</h3><p>Create a new process with a function as entry point on a specified node.</p><p>Returns the process identifier (pid) of a new process started
by the application
of <strong><span class="anno">Module</span>:<span class="anno">Function</span></strong>
to <strong><span class="anno">Args</span></strong> on <strong><span class="anno">Node</span></strong>. If
<strong><span class="anno">Node</span></strong> does not exist, a useless pid is returned.
Otherwise works like
<a href="#spawn/3">spawn/3</a>.</p><h3>spawn_link/1</h3><p>Create and link to a new process with a fun as entry point. </p><p>Returns the process identifier of a new process started by
the application of <strong><span class="anno">Fun</span></strong> to the empty list
<strong>[]</strong>. A link is created between
the calling process and the new process, atomically.
Otherwise works like
<a href="#spawn/3">spawn/3</a>.</p><h3>spawn_link/2</h3><p>Create and link to a new process with a fun as entry point on a specified node.</p><p>Returns the process identifier (pid) of a new process started
by the application of <strong><span class="anno">Fun</span></strong> to the empty
list <strong>[]</strong> on <strong><span class="anno">Node</span></strong>. A link is
created between the calling process and the new process,
atomically. If <strong><span class="anno">Node</span></strong> does not exist,
a useless pid is returned and an exit signal with
reason <strong>noconnection</strong> is sent to the calling
process. Otherwise works like <a href="#spawn/3">spawn/3</a>.</p><h3>spawn_link/3</h3><p>Create and link to a new process with a function as entry point. </p><p>Returns the process identifier of a new process started by
the application of <strong><span class="anno">Module</span>:<span class="anno">Function</span></strong>
to <strong><span class="anno">Args</span></strong>. A link is created
between the calling process and the new process, atomically.
Otherwise works like
<a href="#spawn/3">spawn/3</a>.</p><h3>spawn_link/4</h3><p>Create and link to a new process with a function as entry point on a specified node.</p><p>Returns the process identifier (pid) of a new process
started by the application
of <strong><span class="anno">Module</span>:<span class="anno">Function</span></strong>
to <strong><span class="anno">Args</span></strong> on <strong><span class="anno">Node</span></strong>. A
link is created between the calling process and the new
process, atomically. If <strong><span class="anno">Node</span></strong> does
not exist, a useless pid is returned and an exit signal with
reason <strong>noconnection</strong> is sent to the calling
process. Otherwise works like <a href="#spawn/3">spawn/3</a>.</p><h3>spawn_monitor/1</h3><p>Create and monitor a new process with a fun as entry point. </p><p>Returns the process identifier of a new process, started by
the application of <strong><span class="anno">Fun</span></strong> to the empty list
<strong>[]</strong>,
and a reference for a monitor created to the new process.
Otherwise works like
<a href="#spawn/3">spawn/3</a>.</p><h3>spawn_monitor/3</h3><p>Create and monitor a new process with a function as entry point. </p><p>A new process is started by the application
of <strong><span class="anno">Module</span>:<span class="anno">Function</span></strong>
to <strong><span class="anno">Args</span></strong>. The process is
monitored at the same time. Returns the process identifier
and a reference for the monitor. Otherwise works like
<a href="#spawn/3">spawn/3</a>.</p><h3>spawn_opt/2</h3><p>Create a new process with a fun as entry point.</p><ul><li>priority_level</li></ul><ul><li>max_heap_size</li></ul><ul><li>message_queue_data</li></ul><ul><li>spawn_opt_option</li></ul><p>Returns the process identifier (pid) of a new process
started by the application of <strong><span class="anno">Fun</span></strong>
to the empty list <strong>[]</strong>. Otherwise works like
<a href="#spawn_opt/4">spawn_opt/4</a>.</p><p>If option <strong>monitor</strong> is specified, the newly created
process is monitored, and both the pid and reference for
the monitor are returned.</p><h3>spawn_opt/3</h3><p>Create a new process with a fun as entry point on a specified node.</p><ul><li>priority_level</li></ul><ul><li>max_heap_size</li></ul><ul><li>message_queue_data</li></ul><ul><li>spawn_opt_option</li></ul><p>Returns the process identifier (pid) of a new process started
by the application of <strong><span class="anno">Fun</span></strong> to the
empty list <strong>[]</strong> on <strong><span class="anno">Node</span></strong>. If
<strong><span class="anno">Node</span></strong> does not exist, a useless pid is
returned. Otherwise works like
<a href="#spawn_opt/4">spawn_opt/4</a>.</p><h3>spawn_opt/4</h3><p>Create a new process with a function as entry point.</p><ul><li>priority_level</li></ul><ul><li>max_heap_size</li></ul><ul><li>message_queue_data</li></ul><ul><li>spawn_opt_option</li></ul><p>Works as
<a href="#spawn/3">spawn/3</a>, except that an
extra option list is specified when creating the process.</p><p>If option <strong>monitor</strong> is specified, the newly created
process is monitored, and both the pid and reference for
the monitor are returned.</p><p>Options:</p><dl><dt><strong>link</strong></dt><dd> <p>Sets a link to the parent process (like
<a href="#spawn_link/3">spawn_link/3</a>
does).</p> </dd><dt><strong>monitor</strong></dt><dd> <p>Monitors the new process (like
<a href="#monitor/2">monitor/2</a> does).</p> </dd><dt><strong>{priority, <span class="anno">Level</span>}</strong></dt><dd> <p>Sets the priority of the new process. Equivalent to
executing <a href="#process_flag_priority">process_flag_priority</a>
in the start function of the new process,
except that the priority is set before the process is
selected for execution for the first time. For more
information on priorities, see
<a href="#process_flag_priority">process_flag_priority</a>.</p> </dd><dt><strong>{fullsweep_after, <span class="anno">Number</span>}</strong></dt><dd> <p>Useful only for performance tuning. Do not use this
option unless you
know that there is problem with execution times or
memory consumption, and ensure
that the option improves matters.</p> <p>The Erlang runtime system uses a generational garbage
collection scheme, using an "old heap" for data that has
survived at least one garbage collection. When there is
no more room on the old heap, a fullsweep garbage
collection is done.</p> <p>Option <strong>fullsweep_after</strong> makes it possible to
specify the maximum number of generational collections
before forcing a fullsweep, even if there is room on
the old heap. Setting the number to zero
disables the general collection algorithm, that is,
all live data is copied at every garbage collection.</p> <p>A few cases when it can be useful to change
<strong>fullsweep_after</strong>:</p> <ul><li><p>If binaries that are no longer used are to be
thrown away as soon as possible. (Set
<strong><span class="anno">Number</span></strong> to zero.)</p> </li><li><p>A process that mostly have short-lived data is
fullsweeped seldom or never, that is, the old heap
contains mostly garbage. To ensure a fullsweep
occasionally, set <strong><span class="anno">Number</span></strong> to a
suitable value, such as 10 or 20.</p> </li><li>In embedded systems with a limited amount of RAM and no virtual memory, you might want to preserve memory by setting <strong><span class="anno">Number</span></strong> to zero. (The value can be set globally, see <a href="#system_flag/2">system_flag/2</a>.) </li></ul> </dd><dt><strong>{min_heap_size, <span class="anno">Size</span>}</strong></dt><dd> <p>Useful only for performance tuning. Do not use this
option unless you know that there is problem with
execution times or memory consumption, and
ensure that the option improves matters.</p> <p>Gives a minimum heap size, in words. Setting this value
higher than the system default can speed up some
processes because less garbage collection is done.
However, setting a too high value can waste memory and
slow down the system because of worse data locality.
Therefore, use this option only for
fine-tuning an application and to measure the execution
time with various <strong><span class="anno">Size</span></strong> values.</p> </dd><dt><strong>{min_bin_vheap_size, <span class="anno">VSize</span>}</strong></dt><dd> <p>Useful only for performance tuning. Do not use this
option unless you know that there is problem with
execution times or memory consumption, and
ensure that the option improves matters.</p> <p>Gives a minimum binary virtual heap size, in words.
Setting this value
higher than the system default can speed up some
processes because less garbage collection is done.
However, setting a too high value can waste memory.
Therefore, use this option only for
fine-tuning an application and to measure the execution
time with various <strong><span class="anno">VSize</span></strong> values.</p> </dd><dt><strong>{max_heap_size, <span class="anno">Size</span>}</strong></dt><dd> <p>Sets the <strong>max_heap_size</strong> process flag. The default
<strong>max_heap_size</strong> is determined by command-line argument
<a href="./erl#+hmax">erl#+hmax</a>
in <strong>erl(1)</strong>. For more information, see the
documentation of <a href="#process_flag_max_heap_size">process_flag_max_heap_size</a>.
</p> </dd><dt><strong>{message_queue_data, <span class="anno">MQD</span>}</strong></dt><dd> <p>Sets the state of the <strong>message_queue_data</strong> process
flag. <strong><span class="anno">MQD</span></strong> is to be either <strong>off_heap</strong>
or <strong>on_heap</strong>. The default
<strong>message_queue_data</strong> process flag is determined by
command-line argument <a href="./erl#+hmqd">erl#+hmqd</a> in <strong>erl(1)</strong>.
For more information, see the documentation of
<a href="#process_flag_message_queue_data">process_flag_message_queue_data</a>.</p> </dd></dl><h3>spawn_opt/5</h3><p>Create a new process with a function as entry point on a specified node.</p><ul><li>priority_level</li></ul><ul><li>max_heap_size</li></ul><ul><li>message_queue_data</li></ul><ul><li>spawn_opt_option</li></ul><p>Returns the process identifier (pid) of a new process started
by the application
of <strong><span class="anno">Module</span>:<span class="anno">Function</span></strong> to
<strong><span class="anno">Args</span></strong> on <strong><span class="anno">Node</span></strong>. If
<strong><span class="anno">Node</span></strong> does not exist, a useless pid is returned.
Otherwise works like
<a href="#spawn_opt/4">spawn_opt/4</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Option <strong>monitor</strong> is not supported by
<strong>spawn_opt/5</strong>.</p></div><h3>split_binary/2</h3><p>Split a binary into two.</p><dl><dt>Pos</dt><dd>0..byte_size(Bin)</dd></dl><p>Returns a tuple containing the binaries that are the result
of splitting <strong><span class="anno">Bin</span></strong> into two parts at
position <strong><span class="anno">Pos</span></strong>.
This is not a destructive operation. After the operation,
there are three binaries altogether. Example:</p><pre>
&gt; <span class="input">B = list_to_binary("0123456789").</span>
&lt;&lt;"0123456789"&gt;&gt;
&gt; <span class="input">byte_size(B).</span>
10
&gt; <span class="input">{B1, B2} = split_binary(B,3).</span>
{&lt;&lt;"012"&gt;&gt;,&lt;&lt;"3456789"&gt;&gt;}
&gt; <span class="input">byte_size(B1).</span>
3
&gt; <span class="input">byte_size(B2).</span>
7</pre><h3>start_timer/3</h3><p>Start a timer.</p><p>Starts a timer. The same as calling
<a href="#start_timer/4">start_timer/4</a>.</p><h3>start_timer/4</h3><p>Start a timer.</p><p>Starts a timer. When the timer expires, the message
<strong>{timeout, <span class="anno">TimerRef</span>, <span class="anno">Msg</span>}</strong>
is sent to the process identified by <strong><span class="anno">Dest</span></strong>.</p><p><strong><span class="anno">Option</span></strong>s:</p><dl><dt><strong>{abs, false}</strong></dt><dd> <p>This is the default. It means the
<strong><span class="anno">Time</span></strong> value is interpreted
as a time in milliseconds <em>relative</em> current
<a href="./time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a>.</p> </dd><dt><strong>{abs, true}</strong></dt><dd> <p>Absolute <strong><span class="anno">Time</span></strong> value. The
<strong><span class="anno">Time</span></strong> value is interpreted as an
absolute Erlang monotonic time in milliseconds.</p> </dd></dl><p>More <strong><span class="anno">Option</span></strong>s can be added in the future.</p><p>The absolute point in time, the timer is set to expire on,
must be in the interval
<strong>[</strong><a href="#system_info_start_time">system_info_start_time</a><strong>, </strong><a href="#system_info_end_time">system_info_end_time</a><strong>]</strong>.
If a relative time is specified, the <strong><span class="anno">Time</span></strong>
value is not allowed to be negative.</p><p>If <strong><span class="anno">Dest</span></strong> is a <strong>pid()</strong>, it must
be a <strong>pid()</strong> of a process created on the current
runtime system instance. This process has either terminated
or not. If <strong><span class="anno">Dest</span></strong> is an
<strong>atom()</strong>, it is interpreted as the name of a
locally registered process. The process referred to by the
name is looked up at the time of timer expiration. No error
is returned if the name does not refer to a process.</p><p>If <strong><span class="anno">Dest</span></strong> is a <strong>pid()</strong>, the timer is
automatically canceled if the process referred to by the
<strong>pid()</strong> is not alive, or if the process exits. This
feature was introduced in ERTS 5.4.11. Notice that
timers are not automatically canceled when
<strong><span class="anno">Dest</span></strong> is an <strong>atom()</strong>.</p><p>See also
<a href="#send_after/4">send_after/4</a>,
<a href="#cancel_timer/2">cancel_timer/2</a>, and
<a href="#read_timer/2">read_timer/2</a>.</p><p>Failure: <strong>badarg</strong> if the arguments do not satisfy
the requirements specified here.</p><h3>statistics/1</h3><p>Information about active processes and ports.</p><p>Returns the same as
<a href="#statistics_active_tasks_all">statistics_active_tasks_all</a>
with the exception that no information about the dirty
IO run queue and its associated schedulers is part of
the result. That is, only tasks that are expected to be
CPU bound are part of the result.</p><h3>statistics/1</h3><p>Information about active processes and ports.</p><p>Returns a list where each element represents the amount
of active processes and ports on each run queue and its
associated schedulers. That is, the number of processes and
ports that are ready to run, or are currently running.
Values for normal run queues and their associated schedulers
are located first in the resulting list. The first element
corresponds to scheduler number 1 and so on. If support for
dirty schedulers exist, an element with the value for the
dirty CPU run queue and its associated dirty CPU schedulers
follow and then as last element the value for the the dirty
IO run queue and its associated dirty IO schedulers follow.
The information is <em>not</em> gathered atomically. That is,
the result is not necessarily a consistent snapshot of the
state, but instead quite efficiently gathered.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Each normal scheduler has one run queue that it
manages. If dirty schedulers schedulers are supported, all
dirty CPU schedulers share one run queue, and all dirty IO
schedulers share one run queue. That is, we have multiple
normal run queues, one dirty CPU run queue and one dirty
IO run queue. Work can <em>not</em> migrate between the
different types of run queues. Only work in normal run
queues can migrate to other normal run queues. This has
to be taken into account when evaluating the result.</p></div><p>See also
<a href="#statistics_total_active_tasks">statistics_total_active_tasks</a>,
<a href="#statistics_run_queue_lengths">statistics_run_queue_lengths</a>,
<a href="#statistics_run_queue_lengths_all">statistics_run_queue_lengths_all</a>,
<a href="#statistics_total_run_queue_lengths">statistics_total_run_queue_lengths</a>, and
<a href="#statistics_total_run_queue_lengths_all">statistics_total_run_queue_lengths_all</a>.</p><h3>statistics/1</h3><p>Information about context switches.</p><p>Returns the total number of context switches since the
system started.</p><h3>statistics/1</h3><p>Information about exact reductions.</p><p>Returns the number of exact reductions.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><strong>statistics(exact_reductions)</strong> is
a more expensive operation than
<a href="#statistics_reductions"> statistics(reductions)</a>.</p></div><h3>statistics/1</h3><p>Information about garbage collection.</p><p>Returns information about garbage collection, for example:</p><pre>
&gt; <span class="input">statistics(garbage_collection).</span>
{85,23961,0}</pre><p>This information can be invalid for some implementations.</p><h3>statistics/1</h3><p>Information about I/O.</p><p>Returns <strong><span class="anno">Input</span></strong>,
which is the total number of bytes
received through ports, and <strong><span class="anno">Output</span></strong>,
which is the total number of bytes output to ports.</p><h3>statistics/1</h3><p>Information about microstate accounting.</p><p>Microstate accounting can be used to measure how much time the Erlang
runtime system spends doing various tasks. It is designed to be as
lightweight as possible, but some overhead exists when this
is enabled. Microstate accounting is meant to be a profiling tool
to help finding performance bottlenecks.
To <strong>start</strong>/<strong>stop</strong>/<strong>reset</strong> microstate accounting, use
system flag <a href="#system_flag_microstate_accounting">system_flag_microstate_accounting</a>.</p><p><strong>statistics(microstate_accounting)</strong> returns a list of maps
representing some of the OS threads within ERTS. Each map
contains <strong>type</strong> and <strong>id</strong> fields that can be used to
identify what
thread it is, and also a counters field that contains data about how
much time has been spent in the various states.</p><p>Example:</p><pre>
&gt; <span class="input">erlang:statistics(microstate_accounting).</span>
[#{counters =&gt; #{aux =&gt; 1899182914,
                 check_io =&gt; 2605863602,
                 emulator =&gt; 45731880463,
                 gc =&gt; 1512206910,
                 other =&gt; 5421338456,
                 port =&gt; 221631,
                 sleep =&gt; 5150294100},
   id =&gt; 1,
   type =&gt; scheduler}|...]</pre><p>The time unit is the same as returned by
<a href="../kernel/os#perf_counter/0">kernel/os#perf_counter/0</a>.
So, to convert it to milliseconds, you can do something like this:</p><pre>
lists:map(
  fun(#{ counters := Cnt } = M) -&gt;
          MsCnt = maps:map(fun(_K, PerfCount) -&gt;
                                   erlang:convert_time_unit(PerfCount, perf_counter, 1000)
                           end, Cnt),
         M#{ counters := MsCnt }
  end, erlang:statistics(microstate_accounting)).</pre><p>Notice that these values are not guaranteed to be
the exact time spent in each state. This is because of various
optimisation done to keep the overhead as small as possible.</p><p><strong><span class="anno">MSAcc_Thread_Type</span></strong>s:</p><dl><dt><strong>scheduler</strong></dt><dd>The main execution threads that do most of the work. See <a href="../erts/erl#+S">erl +S</a> for more details.</dd><dt><strong>dirty_cpu_scheduler</strong></dt><dd>The threads for long running cpu intensive work. See <a href="../erts/erl#+SDcpu">erl +SDcpu</a> for more details.</dd><dt><strong>dirty_io_scheduler</strong></dt><dd>The threads for long running I/O work. See <a href="../erts/erl#+SDio">erl +SDio</a> for more details.</dd><dt><strong>async</strong></dt><dd>Async threads are used by various linked-in drivers (mainly the file drivers) do offload non-CPU intensive work. See <a href="../erts/erl#async_thread_pool_size">erl +A</a> for more details.</dd><dt><strong>aux</strong></dt><dd>Takes care of any work that is not specifically assigned to a scheduler.</dd><dt><strong>poll</strong></dt><dd>Does the IO polling for the emulator. See <a href="../erts/erl#+IOt">erl +IOt</a> for more details.</dd></dl><p>The following <strong><span class="anno">MSAcc_Thread_State</span></strong>s are available.
All states are exclusive, meaning that a thread cannot be in two
states at once. So, if you add the numbers of all counters in a
thread, you get the total runtime for that thread.</p><dl><dt><strong>aux</strong></dt><dd>Time spent handling auxiliary jobs.</dd><dt><strong>check_io</strong></dt><dd>Time spent checking for new I/O events.</dd><dt><strong>emulator</strong></dt><dd>Time spent executing Erlang processes.</dd><dt><strong>gc</strong></dt><dd>Time spent doing garbage collection. When extra states are enabled this is the time spent doing non-fullsweep garbage collections.</dd><dt><strong>other</strong></dt><dd>Time spent doing unaccounted things.</dd><dt><strong>port</strong></dt><dd>Time spent executing ports.</dd><dt><strong>sleep</strong></dt><dd>Time spent sleeping.</dd></dl><p>More fine-grained <strong><span class="anno">MSAcc_Thread_State</span></strong>s can
be added through configure (such as
<strong>./configure --with-microstate-accounting=extra</strong>).
Enabling these states causes performance degradation when
microstate accounting is turned off and increases the overhead when
it is turned on.</p><dl><dt><strong>alloc</strong></dt><dd>Time spent managing memory. Without extra states this time is spread out over all other states.</dd><dt><strong>bif</strong></dt><dd>Time spent in BIFs. Without extra states this time is part of the <strong>emulator</strong> state.</dd><dt><strong>busy_wait</strong></dt><dd>Time spent busy waiting. This is also the state where a scheduler no longer reports that it is active when using <a href="#statistics_scheduler_wall_time">statistics_scheduler_wall_time</a>. So, if you add all other states but this and sleep, and then divide that by all time in the thread, you should get something very similar to the <strong>scheduler_wall_time</strong> fraction. Without extra states this time is part of the <strong>other</strong> state.</dd><dt><strong>ets</strong></dt><dd>Time spent executing ETS BIFs. Without extra states this time is part of the <strong>emulator</strong> state.</dd><dt><strong>gc_full</strong></dt><dd>Time spent doing fullsweep garbage collection. Without extra states this time is part of the <strong>gc</strong> state.</dd><dt><strong>nif</strong></dt><dd>Time spent in NIFs. Without extra states this time is part of the <strong>emulator</strong> state.</dd><dt><strong>send</strong></dt><dd>Time spent sending messages (processes only). Without extra states this time is part of the <strong>emulator</strong> state.</dd><dt><strong>timers</strong></dt><dd>Time spent managing timers. Without extra states this time is part of the <strong>other</strong> state.</dd></dl><p>The utility module
<a href="./msacc">runtime_tools/msacc</a>
can be used to more easily analyse these statistics.</p><p>Returns <strong>undefined</strong> if system flag
<a href="#system_flag_microstate_accounting">system_flag_microstate_accounting</a> is turned off.</p><p>The list of thread information is unsorted and can appear in
different order between calls.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The threads and states are subject to change without any
prior notice.</p></div><h3>statistics/1</h3><p>Information about reductions.</p><p>Returns information about reductions, for example:</p><pre>
&gt; <span class="input">statistics(reductions).</span>
{2046,11}</pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from ERTS 5.5 (Erlang/OTP R11B),
this value does not include reductions performed in current
time slices of currently scheduled processes. If an
exact value is wanted, use
<a href="#statistics_exact_reductions">statistics_exact_reductions</a>.</p></div><h3>statistics/1</h3><p>Information about the run-queues.</p><p>Returns the total length of all normal run-queues. That is, the number
of processes and ports that are ready to run on all available
normal run-queues. Dirty run queues are not part of the
result. The information is gathered atomically. That
is, the result is a consistent snapshot of the state, but
this operation is much more expensive compared to
<a href="#statistics_total_run_queue_lengths">statistics_total_run_queue_lengths</a>,
especially when a large amount of schedulers is used.</p><h3>statistics/1</h3><p>Information about the run-queue lengths.</p><p>Returns the same as
<a href="#statistics_run_queue_lengths_all">statistics_run_queue_lengths_all</a>
with the exception that no information about the dirty
IO run queue is part of the result. That is, only
run queues with work that is expected to be CPU bound
is part of the result.</p><h3>statistics/1</h3><p>Information about the run-queue lengths.</p><p>Returns a list where each element represents the amount
of processes and ports ready to run for each run queue.
Values for normal run queues are located first in the
resulting list. The first element corresponds to the
normal run queue of scheduler number 1 and so on. If
support for dirty schedulers exist, values for the dirty
CPU run queue and the dirty IO run queue follow (in that
order) at the end. The information is <em>not</em>
gathered atomically. That is, the result is not
necessarily a consistent snapshot of the state, but
instead quite efficiently gathered.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Each normal scheduler has one run queue that it
manages. If dirty schedulers schedulers are supported, all
dirty CPU schedulers share one run queue, and all dirty IO
schedulers share one run queue. That is, we have multiple
normal run queues, one dirty CPU run queue and one dirty
IO run queue. Work can <em>not</em> migrate between the
different types of run queues. Only work in normal run
queues can migrate to other normal run queues. This has
to be taken into account when evaluating the result.</p></div><p>See also
<a href="#statistics_run_queue_lengths">statistics_run_queue_lengths</a>,
<a href="#statistics_total_run_queue_lengths_all">statistics_total_run_queue_lengths_all</a>,
<a href="#statistics_total_run_queue_lengths">statistics_total_run_queue_lengths</a>,
<a href="#statistics_active_tasks">statistics_active_tasks</a>,
<a href="#statistics_active_tasks_all">statistics_active_tasks_all</a>, and
<a href="#statistics_total_active_tasks">statistics_total_active_tasks</a>,
<a href="#statistics_total_active_tasks_all">statistics_total_active_tasks_all</a>.</p><h3>statistics/1</h3><p>Information about runtime.</p><p>Returns information about runtime, in milliseconds.</p><p>This is the sum of the runtime for all threads
in the Erlang runtime system and can therefore be greater
than the wall clock time.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This value might wrap due to limitations in the
underlying functionality provided by the operating system
that is used.</p></div><p>Example:</p><pre>
&gt; <span class="input">statistics(runtime).</span>
{1690,1620}</pre><h3>statistics/1</h3><p>Information about each schedulers work time.</p><p>Returns a list of tuples with
<strong>{<span class="anno">SchedulerId</span>, <span class="anno">ActiveTime</span>, <span class="anno">TotalTime</span>}</strong>, where
<strong><span class="anno">SchedulerId</span></strong> is an integer ID of the scheduler,
<strong><span class="anno">ActiveTime</span></strong> is
the duration the scheduler has been busy, and
<strong><span class="anno">TotalTime</span></strong> is the total time duration since
<a href="#system_flag_scheduler_wall_time">system_flag_scheduler_wall_time</a>
activation for the specific scheduler. Note that
activation time can differ significantly between
schedulers. Currently dirty schedulers are activated
at system start while normal schedulers are activated
some time after the <strong>scheduler_wall_time</strong>
functionality is enabled. The time unit is undefined
and can be subject to change between releases, OSs,
and system restarts. <strong>scheduler_wall_time</strong> is only
to be used to calculate relative values for scheduler
utilization. <strong><span class="anno">ActiveTime</span></strong> can never
exceed <strong><span class="anno">TotalTime</span></strong>.</p><p>The definition of a busy scheduler is when it is not idle
and is not scheduling (selecting) a process or port,
that is:</p><ul><li>Executing process code</li><li>Executing linked-in driver or NIF code</li><li>Executing BIFs, or any other runtime handling</li><li>Garbage collecting</li><li>Handling any other memory management</li></ul><p>Notice that a scheduler can also be busy even if the
OS has scheduled out the scheduler thread.</p><p>Returns <strong>undefined</strong> if system flag
<a href="#system_flag_scheduler_wall_time">system_flag_scheduler_wall_time</a> is turned off.</p><p>The list of scheduler information is unsorted and can
appear in different order between calls.</p><p>As of ERTS version 9.0, also dirty CPU schedulers will
be included in the result. That is, all scheduler threads
that are expected to handle CPU bound work. If you also
want information about dirty I/O schedulers, use
<a href="#statistics_scheduler_wall_time_all">statistics_scheduler_wall_time_all</a>
instead.</p><p>Normal schedulers will have scheduler identifiers in
the range <strong>1 =&lt; <span class="anno">SchedulerId</span> =&lt; </strong><a href="#system_info_schedulers">system_info_schedulers</a>.
Dirty CPU schedulers will have scheduler identifiers in
the range <strong>erlang:system_info(schedulers) &lt; <span class="anno">SchedulerId</span> =&lt; erlang:system_info(schedulers) + </strong><a href="#system_info_dirty_cpu_schedulers">system_info_dirty_cpu_schedulers</a>.
</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The different types of schedulers handle
specific types of jobs. Every job is assigned to a specific
scheduler type. Jobs can migrate between different schedulers
of the same type, but never between schedulers of different
types. This fact has to be taken under consideration when
evaluating the result returned.</p></div><p>Using <strong>scheduler_wall_time</strong> to calculate
scheduler utilization:</p><pre>
&gt; <span class="input">erlang:system_flag(scheduler_wall_time, true).</span>
false
&gt; <span class="input">Ts0 = lists:sort(erlang:statistics(scheduler_wall_time)), ok.</span>
ok</pre><p>Some time later the user takes another snapshot and calculates
scheduler utilization per scheduler, for example:</p><pre>
&gt; <span class="input">Ts1 = lists:sort(erlang:statistics(scheduler_wall_time)), ok.</span>
ok
&gt; <span class="input">lists:map(fun({{I, A0, T0}, {I, A1, T1}}) -&gt; {I, (A1 - A0)/(T1 - T0)} end, lists:zip(Ts0,Ts1)).</span>
[{1,0.9743474730177548},
 {2,0.9744843782751444},
 {3,0.9995902361669045},
 {4,0.9738012596572161},
 {5,0.9717956667018103},
 {6,0.9739235846420741},
 {7,0.973237033077876},
 {8,0.9741297293248656}]</pre><p>Using the same snapshots to calculate a total
scheduler utilization:</p><pre>
&gt; <span class="input">{A, T} = lists:foldl(fun({{_, A0, T0}, {_, A1, T1}}, {Ai,Ti}) -&gt; {Ai + (A1 - A0), Ti + (T1 - T0)} end, {0, 0}, lists:zip(Ts0,Ts1)), TotalSchedulerUtilization = A/T.</span>
0.9769136803764825</pre><p>Total scheduler utilization will equal <strong>1.0</strong> when
all schedulers have been active all the time between the
two measurements.</p><p>Another (probably more) useful value is to calculate
total scheduler utilization weighted against maximum amount
of available CPU time:</p><pre>
&gt; <span class="input">WeightedSchedulerUtilization = (TotalSchedulerUtilization * (erlang:system_info(schedulers) + erlang:system_info(dirty_cpu_schedulers))) / erlang:system_info(logical_processors_available).</span>
0.9769136803764825</pre><p>This weighted scheduler utilization will reach <strong>1.0</strong>
when schedulers are active the same amount of time as
maximum available CPU time. If more schedulers exist
than available logical processors, this value may
be greater than <strong>1.0</strong>.</p><p>As of ERTS version 9.0, the Erlang runtime system
will as default have more schedulers than logical processors.
This due to the dirty schedulers.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><strong>scheduler_wall_time</strong> is by default disabled. To
enable it, use
<strong>erlang:system_flag(scheduler_wall_time, true)</strong>.</p></div><h3>statistics/1</h3><p>Information about each schedulers work time.</p><p>The same as
<a href="#statistics_scheduler_wall_time">statistics_scheduler_wall_time</a>,
except that it also include information about all dirty I/O
schedulers.</p><p>Dirty IO schedulers will have scheduler identifiers in
the range
<a href="#system_info_schedulers">system_info_schedulers</a><strong> + </strong><a href="#system_info_dirty_cpu_schedulers">system_info_dirty_cpu_schedulers</a><strong> &lt; <span class="anno">SchedulerId</span> =&lt; erlang:system_info(schedulers) + erlang:system_info(dirty_cpu_schedulers) + </strong><a href="#system_info_dirty_io_schedulers">system_info_dirty_io_schedulers</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that work executing on dirty I/O schedulers
are expected to mainly wait for I/O. That is, when you
get high scheduler utilization on dirty I/O schedulers,
CPU utilization is <em>not</em> expected to be high due to
this work.</p></div><h3>statistics/1</h3><p>Information about active processes and ports.</p><p>The same as calling
<strong>lists:sum(</strong><a href="#statistics_active_tasks">statistics_active_tasks</a><strong>)</strong>,
but more efficient.</p><h3>statistics/1</h3><p>Information about active processes and ports.</p><p>The same as calling
<strong>lists:sum(</strong><a href="#statistics_active_tasks_all">statistics_active_tasks_all</a><strong>)</strong>,
but more efficient.</p><h3>statistics/1</h3><p>Information about the run-queue lengths.</p><p>The same as calling
<strong>lists:sum(</strong><a href="#statistics_run_queue_lengths">statistics_run_queue_lengths</a><strong>)</strong>,
but more efficient.</p><h3>statistics/1</h3><p>Information about the run-queue lengths.</p><p>The same as calling
<strong>lists:sum(</strong><a href="#statistics_run_queue_lengths_all">statistics_run_queue_lengths_all</a><strong>)</strong>,
but more efficient.</p><h3>statistics/1</h3><p>Information about wall clock.</p><p>Returns information about wall clock. <strong>wall_clock</strong> can
be used in the same manner as
<strong>runtime</strong>, except that real time is measured as
opposed to runtime or CPU time.</p><h3>suspend_process/1</h3><p>Suspend a process.</p><p>Suspends the process identified by
<strong><span class="anno">Suspendee</span></strong>. The same as calling
<a href="#suspend_process/2">suspend_process/2</a>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for debugging only.</p></div><h3>suspend_process/2</h3><p>Suspend a process.</p><p>Increases the suspend count on the process identified by
<strong><span class="anno">Suspendee</span></strong> and puts it in the suspended
state if it is not
already in that state. A suspended process is not
scheduled for execution until the process has been resumed.</p><p>A process can be suspended by multiple processes and can
be suspended multiple times by a single process. A suspended
process does not leave the suspended state until its suspend 
count reaches zero. The suspend count of
<strong><span class="anno">Suspendee</span></strong> is decreased when
<a href="#resume_process/1">resume_process/1</a>
is called by the same process that called
<strong>erlang:suspend_process(<span class="anno">Suspendee</span>)</strong>.
All increased suspend
counts on other processes acquired by a process are automatically
decreased when the process terminates.</p><p>Options (<strong><span class="anno">Opt</span></strong>s):</p><dl><dt><strong>asynchronous</strong></dt><dd> <p>A suspend request is sent to the process identified by
<strong><span class="anno">Suspendee</span></strong>. <strong><span class="anno">Suspendee</span></strong>
eventually suspends
unless it is resumed before it could suspend. The caller
of <strong>erlang:suspend_process/2</strong> returns immediately,
regardless of whether <strong><span class="anno">Suspendee</span></strong> has
suspended yet or not. The point in time when
<strong><span class="anno">Suspendee</span></strong> suspends cannot be deduced
from other events in the system. It is only guaranteed that
<strong><span class="anno">Suspendee</span></strong> <em>eventually</em> suspends
(unless it
is resumed). If no <strong>asynchronous</strong> options has
been passed, the caller of <strong>erlang:suspend_process/2</strong> is
blocked until <strong><span class="anno">Suspendee</span></strong> has suspended.</p> </dd><dt><strong>{asynchronous, ReplyTag}</strong></dt><dd> <p>A suspend request is sent to the process identified by
<strong><span class="anno">Suspendee</span></strong>. When the suspend request
has been processed, a reply message is sent to the caller
of this function. The reply is on the form <strong>{ReplyTag, State}</strong> where <strong>State</strong> is either:</p> <dl><dt><strong>exited</strong></dt><dd> <p>
<strong><span class="anno">Suspendee</span></strong> has exited.
</p> </dd><dt><strong>suspended</strong></dt><dd> <p>
<strong><span class="anno">Suspendee</span></strong> is now suspended.
</p> </dd><dt><strong>not_suspended</strong></dt><dd> <p>
<strong><span class="anno">Suspendee</span></strong> is not suspended.
This can only happen when the process that
issued this request, have called
<strong>resume_process(<span class="anno">Suspendee</span>)</strong>
before getting the reply.
</p> </dd></dl> <p>
Appart from the reply message, the <strong>{asynchronous, ReplyTag}</strong> option behaves exactly the same as the
<strong>asynchronous</strong> option without reply tag.
</p> </dd><dt><strong>unless_suspending</strong></dt><dd> <p>The process identified by <strong><span class="anno">Suspendee</span></strong> is
suspended unless the calling process already is suspending
<strong><span class="anno">Suspendee</span></strong>.
If <strong>unless_suspending</strong> is combined
with option <strong>asynchronous</strong>, a suspend request is
sent unless the calling process already is suspending
<strong><span class="anno">Suspendee</span></strong> or if a suspend request
already has been sent and is in transit. If the calling
process already is suspending <strong><span class="anno">Suspendee</span></strong>,
or if combined with option <strong>asynchronous</strong>
and a send request already is in transit,
<strong>false</strong> is returned and the suspend count on
<strong><span class="anno">Suspendee</span></strong> remains unchanged.</p> </dd></dl><p>If the suspend count on the process identified by
<strong><span class="anno">Suspendee</span></strong> is increased, <strong>true</strong>
is returned, otherwise <strong>false</strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This BIF is intended for debugging only.</p></div><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>You can easily create deadlocks if processes suspends
each other (directly or in circles). In ERTS versions prior
to ERTS version 10.0, the runtime system prevented such
deadlocks, but this prevention has now been removed due
to performance reasons.</p></div><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">Suspendee</span></strong> is not a process identifier. </dd><dt><strong>badarg</strong></dt><dd> If the process identified by <strong><span class="anno">Suspendee</span></strong> is the same process as the process calling <strong>erlang:suspend_process/2</strong>. </dd><dt><strong>badarg</strong></dt><dd> If the process identified by <strong><span class="anno">Suspendee</span></strong> is not alive. </dd><dt><strong>badarg</strong></dt><dd> If the process identified by <strong><span class="anno">Suspendee</span></strong> resides on another node. </dd><dt><strong>badarg</strong></dt><dd> If <strong><span class="anno">OptList</span></strong> is not a proper list of valid <strong><span class="anno">Opt</span></strong>s. </dd><dt><strong>system_limit</strong></dt><dd> If the process identified by <strong><span class="anno">Suspendee</span></strong> has been suspended more times by the calling process than can be represented by the currently used internal data structures. The system limit is &gt; 2,000,000,000 suspends and will never be lower. </dd></dl><h3>system_flag/2</h3><p>Set system flag <strong>backtrace_depth</strong>.</p><p>Sets the maximum depth of call stack back-traces in the
exit reason element of <strong>'EXIT'</strong> tuples. The flag
also limits the stacktrace depth returned by <strong>process_info</strong>
item <strong>current_stacktrace.</strong></p><p>Returns the old value of the flag.</p><h3>system_flag/2</h3><p>Set system flag <strong>cpu_topology</strong>.</p><ul><li>cpu_topology</li></ul><ul><li>level_entry</li></ul><ul><li>level_tag</li></ul><ul><li>sub_level</li></ul><ul><li>info_list</li></ul><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>
<em>This argument is deprecated.</em>
Instead of using this argument, use command-line argument
<a href="../erts/erl#+sct">erts/erl#+sct</a> in
<strong>erl(1)</strong>.</p><p>When this argument is removed, a final CPU topology
to use is determined at emulator boot time.</p></div><p>Sets the user-defined <strong><span class="anno">CpuTopology</span></strong>.
The user-defined
CPU topology overrides any automatically detected
CPU topology. By passing <strong>undefined</strong> as
<strong><span class="anno">CpuTopology</span></strong>,
the system reverts to the CPU topology automatically
detected. The returned value equals the value returned
from <strong>erlang:system_info(cpu_topology)</strong> before the
change was made.</p><p>Returns the old value of the flag.</p><p>The CPU topology is used when binding schedulers to logical
processors. If schedulers are already bound when the CPU
topology is changed, the schedulers are sent a request
to rebind according to the new CPU topology.</p><p>The user-defined CPU topology can also be set by passing
command-line argument
<a href="../erts/erl#+sct">erts/erl#+sct</a> to
<strong>erl(1)</strong>.</p><p>For information on type <strong><span class="anno">CpuTopology</span></strong>
and more, see
<a href="#system_info_cpu_topology">system_info_cpu_topology</a>
as well as command-line flags
<a href="../erts/erl#+sct">erts/erl#+sct</a> and
<a href="../erts/erl#+sbt">erts/erl#+sbt</a> in
<strong>erl(1)</strong>.</p><h3>system_flag/2</h3><p>Set system_flag_dirty_cpu_schedulers_online.</p><p>
Sets the number of dirty CPU schedulers online. Range is
<strong>1 &lt;= DirtyCPUSchedulersOnline &lt;= N</strong>, where <strong>N</strong>
is the smallest of the return values of
<strong>erlang:system_info(dirty_cpu_schedulers)</strong> and
<strong>erlang:system_info(schedulers_online)</strong>.</p><p>Returns the old value of the flag.</p><p>The number of dirty CPU schedulers online can change if the
number of schedulers online changes. For example, if 12
schedulers and 6 dirty CPU schedulers are online, and
<strong>system_flag/2</strong> is used to set the number of
schedulers online to 6, then the number of dirty CPU
schedulers online is automatically decreased by half as well,
down to 3. Similarly, the number of dirty CPU schedulers
online increases proportionally to increases in the number of
schedulers online.</p><p>For more information, see
<a href="#system_info_dirty_cpu_schedulers">system_info_dirty_cpu_schedulers</a> and
<a href="#system_info_dirty_cpu_schedulers_online">system_info_dirty_cpu_schedulers_online</a>.</p><h3>system_flag/2</h3><p>Set system flag for erts_alloc.</p><p>Sets system flags for
<a href="./erts_alloc">erts/erts_alloc</a>.
<strong><span class="anno">Alloc</span></strong> is the allocator to affect, for example
<strong>binary_alloc</strong>. <strong><span class="anno">F</span></strong> is the flag to change and
<strong><span class="anno">V</span></strong> is the new value.</p><p>Only a subset of all <strong>erts_alloc</strong> flags can be changed
at run time. This subset is currently only the flag
<a href="../erts/erts_alloc#M_sbct">erts/erts_alloc#M_sbct</a>.</p><p>Returns <strong>ok</strong> if the flag was set or <strong>notsup</strong> if not
supported by <strong>erts_alloc</strong>.</p><h3>system_flag/2</h3><p>Set system flag fullsweep_after.</p><p>Sets system flag <strong>fullsweep_after</strong>.
<strong><span class="anno">Number</span></strong> is a non-negative integer indicating
how many times generational garbage collections can be
done without forcing a fullsweep collection. The value
applies to new processes, while processes already running are
not affected.</p><p>Returns the old value of the flag.</p><p>In low-memory systems (especially without virtual
memory), setting the value to <strong>0</strong> can help to conserve
memory.</p><p>This value can also be set through (OS)
environment variable <strong>ERL_FULLSWEEP_AFTER</strong>.</p><h3>system_flag/2</h3><p>Set system flag microstate_accounting.</p><p>
Turns on/off microstate accounting measurements. When passing reset,
all counters are reset to 0.</p><p>For more information see
<a href="#statistics_microstate_accounting">statistics_microstate_accounting</a>.</p><h3>system_flag/2</h3><p>Set system flag min_heap_size.</p><p>Sets the default minimum heap size for processes. The size
is specified in words. The new <strong>min_heap_size</strong> effects
only processes spawned after the change of
<strong>min_heap_size</strong> has been made. <strong>min_heap_size</strong>
can be set for individual processes by using
<a href="#spawn_opt/4">spawn_opt/4</a> or
<a href="#process_flag/2">process_flag/2</a>.</p><p>Returns the old value of the flag.</p><h3>system_flag/2</h3><p>Set system flag min_bin_vheap_size.</p><p>Sets the default minimum binary virtual heap size for
processes. The size is specified in words.
The new <strong>min_bin_vhheap_size</strong> effects only
processes spawned after the change of
<strong>min_bin_vheap_size</strong> has been made.
<strong>min_bin_vheap_size</strong> can be set for individual
processes by using
<a href="#spawn_opt/4">spawn_opt/4</a> or
<a href="#process_flag/2">process_flag/2</a>.</p><p>Returns the old value of the flag.</p><h3>system_flag/2</h3><p>Set system flag max_heap_size.</p><ul><li>max_heap_size</li></ul><p>
Sets the default maximum heap size settings for processes.
The size is specified in words. The new <strong>max_heap_size</strong>
effects only processes spawned efter the change has been made.
<strong>max_heap_size</strong> can be set for individual processes using
<a href="#spawn_opt/4">spawn_opt/4</a> or
<a href="#process_flag_max_heap_size">process_flag_max_heap_size</a>.</p><p>Returns the old value of the flag.</p><h3>system_flag/2</h3><p>Set system flag multi_scheduling.</p><p>
If multi-scheduling is enabled, more than one scheduler
thread is used by the emulator. Multi-scheduling can be
blocked in two different ways. Either all schedulers but
one is blocked, or all <em>normal</em> schedulers but
one is blocked. When only normal schedulers are blocked,
dirty schedulers are free to continue to schedule
processes.</p><p>If <strong><span class="anno">BlockState</span> =:= block</strong>, multi-scheduling is
blocked. That is, one and only one scheduler thread will
execute. If <strong><span class="anno">BlockState</span> =:= unblock</strong> and no one
else blocks multi-scheduling, and this process has
blocked only once, multi-scheduling is unblocked.</p><p>If <strong><span class="anno">BlockState</span> =:= block_normal</strong>, normal
multi-scheduling is blocked. That is, only one normal scheduler
thread will execute, but multiple dirty schedulers can execute.
If <strong><span class="anno">BlockState</span> =:= unblock_normal</strong> and no one
else blocks normal multi-scheduling, and this process has
blocked only once, normal multi-scheduling is unblocked.</p><p>One process can block multi-scheduling and normal
multi-scheduling multiple times. If a process has blocked
multiple times, it must unblock exactly as many times as it
has blocked before it has released its multi-scheduling
block. If a process that has blocked multi-scheduling or normal
multi-scheduling exits, it automatically releases its blocking
of multi-scheduling and normal multi-scheduling.</p><p>The return values are <strong>disabled</strong>, <strong>blocked</strong>,
<strong>blocked_normal</strong>, or <strong>enabled</strong>. The returned value
describes the state just after the call to
<strong>erlang:system_flag(multi_scheduling, <span class="anno">BlockState</span>)</strong>
has been made. For information about the return values, see
<a href="#system_info_multi_scheduling">system_info_multi_scheduling</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Blocking of multi-scheduling and normal multi-scheduling
is normally not needed. If you feel that you need to use these
features, consider it a few more times again. Blocking
multi-scheduling is only to be used as a last resort, as it is
most likely a <em>very inefficient</em> way to solve the problem.</p></div><p>See also
<a href="#system_info_multi_scheduling">system_info_multi_scheduling</a>,
<a href="#system_info_normal_multi_scheduling_blockers">system_info_normal_multi_scheduling_blockers</a>,
<a href="#system_info_multi_scheduling_blockers">system_info_multi_scheduling_blockers</a>, and
<a href="#system_info_schedulers">system_info_schedulers</a>.</p><h3>system_flag/2</h3><p>Set system flag scheduler_bind_type.</p><ul><li>scheduler_bind_type</li></ul><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>
<em>This argument is deprecated.</em>
Instead of using this argument, use command-line argument
<a href="../erts/erl#+sbt">erts/erl#+sbt</a> in
<strong>erl(1)</strong>. When this argument is removed, a final scheduler bind
type to use is determined at emulator boot time.</p></div><p>Controls if and how schedulers are bound to logical
processors.</p><p>When <strong>erlang:system_flag(scheduler_bind_type, <span class="anno">How</span>)</strong>
is called, an asynchronous signal is sent to all schedulers
online, causing them to try to bind or unbind as requested.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If a scheduler fails to bind, this is often silently
ignored, as it is not always possible to verify valid
logical processor identifiers. If an error is reported,
an error event is logged. To verify that the
schedulers have bound as requested, call
<a href="#system_info_scheduler_bindings">system_info_scheduler_bindings</a>.</p></div><p>Schedulers can be bound on newer Linux,
Solaris, FreeBSD, and Windows systems, but more systems will be
supported in future releases.</p><p>In order for the runtime system to be able to bind schedulers,
the CPU topology must be known. If the runtime system fails
to detect the CPU topology automatically, it can be defined.
For more information on how to define the CPU topology, see
command-line flag <a href="../erts/erl#+sct">erts/erl#+sct</a> in <strong>erl(1)</strong>.</p><p>The runtime system does by default <em>not</em> bind schedulers
to logical processors.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If the Erlang runtime system is the only OS
process binding threads to logical processors, this
improves the performance of the runtime system. However,
if other OS processes (for example, another Erlang
runtime system) also bind threads to logical processors,
there can be a performance penalty instead. Sometimes this
performance penalty can be severe. If so, it is recommended
to not bind the schedulers.</p></div><p>Schedulers can be bound in different ways. Argument
<strong><span class="anno">How</span></strong> determines how schedulers are
bound and can be any of the following:</p><dl><dt><strong>unbound</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd><dt><strong>no_spread</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd><dt><strong>thread_spread</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd><dt><strong>processor_spread</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd><dt><strong>spread</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd><dt><strong>no_node_thread_spread</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd><dt><strong>no_node_processor_spread</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd><dt><strong>thread_no_node_processor_spread</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd><dt><strong>default_bind</strong></dt><dd>Same as command-line argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> in <strong>erl(1)</strong>. </dd></dl><p>The returned value equals <strong><span class="anno">How</span></strong> before flag
<strong>scheduler_bind_type</strong> was changed.</p><p>Failures:</p><dl><dt><strong>notsup</strong></dt><dd>If binding of schedulers is not supported. </dd><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">How</span></strong> is not one of the documented alternatives. </dd><dt><strong>badarg</strong></dt><dd>If CPU topology information is unavailable. </dd></dl><p>The scheduler bind type can also be set by passing command-line
argument <a href="../erts/erl#+sbt">erts/erl#+sbt</a> to <strong>erl(1)</strong>.</p><p>For more information, see
<a href="#system_info_scheduler_bind_type">system_info_scheduler_bind_type</a>,
<a href="#system_info_scheduler_bindings">system_info_scheduler_bindings</a>,
as well as command-line flags
<a href="../erts/erl#+sbt">erts/erl#+sbt</a>
and <a href="../erts/erl#+sct">erts/erl#+sct</a>
in <strong>erl(1)</strong>.</p><h3>system_flag/2</h3><p>Set system flag scheduler_wall_time.</p><p>
Turns on or off scheduler wall time measurements.</p><p>For more information, see
<a href="#statistics_scheduler_wall_time">statistics_scheduler_wall_time</a>.</p><h3>system_flag/2</h3><p>Set system flag schedulers_online.</p><p>
Sets the number of schedulers online. Range is
<strong>1 &lt;= SchedulersOnline &lt;= erlang:system_info(schedulers)</strong>.</p><p>Returns the old value of the flag.</p><p>If the emulator was built with support for
<a href="#system_flag_dirty_cpu_schedulers_online"> dirty schedulers</a>,
changing the number of schedulers online can also change the
number of dirty CPU schedulers online. For example, if 12
schedulers and 6 dirty CPU schedulers are online, and
<strong>system_flag/2</strong> is used to set the number of schedulers
online to 6, then the number of dirty CPU schedulers online
is automatically decreased by half as well, down to 3.
Similarly, the number of dirty CPU schedulers online increases
proportionally to increases in the number of schedulers online.</p><p>For more information, see
<a href="#system_info_schedulers">system_info_schedulers</a> and
<a href="#system_info_schedulers_online">system_info_schedulers_online</a>.</p><h3>system_flag/2</h3><p>Set system logger process.</p><p>Sets the process that will receive the logging
messages generated by ERTS. If set to <strong>undefined</strong>,
all logging messages generated by ERTS will be dropped.
The messages will be in the format:</p><pre><code class="">
{log,Level,Format,ArgList,Metadata} where

Level = atom(),
Format = string(),
ArgList = list(term()),
Metadata = #{ pid =&gt; pid(),
   group_leader =&gt; pid(),
   time := logger:timestamp(),
   error_logger := #{ emulator := true, tag := atom() }
        </code></pre><p>If the <strong>system_logger</strong> process dies,
this flag will be reset to <strong>logger</strong>.</p><p>The default is the process named <strong>logger</strong>.</p><p>Returns the old value of the flag.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is designed to be used by the
KERNEL <a href="./logger">kernel/logger</a>.
Be careful if you change it to something else as
log messages may be lost. If you want to intercept
emulator log messages, do it by adding a specialized handler
to the KERNEL logger.</p></div><h3>system_flag/2</h3><p>Set system flag trace_control_word.</p><p>Sets the value of the node trace control word to
<strong><span class="anno">TCW</span></strong>, which is to be an unsigned integer.
For more information, see function
<a href="../erts/match_spec#set_tcw">erts/match_spec#set_tcw</a>
in section "Match Specifications in Erlang" in the
User's Guide.</p><p>Returns the old value of the flag.</p><h3>system_flag/2</h3><p>Finalize the time offset.</p><p>
Finalizes the <a href="#time_offset/0">time offset</a>
when <a href="./time_correction#Single_Time_Warp_Mode">single time warp mode</a> is used. If another time warp mode
is used, the time offset state is left unchanged.</p><p>Returns the old state identifier, that is:</p><ul><li><p>If <strong>preliminary</strong> is returned, finalization was
performed and the time offset is now final.</p> </li><li><p>If <strong>final</strong> is returned, the time offset was
already in the final state. This either because another
<strong>erlang:system_flag(time_offset, finalize)</strong> call or
because <a href="./time_correction#No_Time_Warp_Mode">no time warp mode</a> is used.</p> </li><li><p>If <strong>volatile</strong> is returned, the time offset
cannot be finalized because
<a href="./time_correction#Multi_Time_Warp_Mode">multi-time warp mode</a> is used.</p> </li></ul><h3>system_info/1</h3><p>System info overview.</p><p>Returns information about the current system.
The documentation of this function is broken into the following
sections in order to make it easier to navigate.</p><dl><dt><a href="#system_info_allocator">system_info_allocator</a></dt><dd> <p>
<a href="#system_info_allocated_areas">system_info_allocated_areas</a>,
<a href="#system_info_allocator">system_info_allocator</a>,
<a href="#system_info_alloc_util_allocators">system_info_alloc_util_allocators</a>,
<a href="#system_info_allocator_sizes">system_info_allocator_sizes</a>,
<a href="#system_info_elib_malloc">system_info_elib_malloc</a>
</p> </dd><dt><a href="#system_info_cpu_topology">system_info_cpu_topology</a></dt><dd> <p>
<a href="#system_info_cpu_topology">system_info_cpu_topology</a>,
<a href="#system_info_logical_processors">system_info_logical_processors</a>,
<a href="#system_info_update_cpu_info">system_info_update_cpu_info</a>
</p> </dd><dt><a href="#system_info_process">system_info_process</a></dt><dd> <p>
<a href="#system_info_fullsweep_after">system_info_fullsweep_after</a>,
<a href="#system_info_garbage_collection">system_info_garbage_collection</a>,
<a href="#system_info_heap_sizes">system_info_heap_sizes</a>,
<a href="#system_info_heap_type">system_info_heap_type</a>,
<a href="#system_info_max_heap_size">system_info_max_heap_size</a>,
<a href="#system_info_message_queue_data">system_info_message_queue_data</a>,
<a href="#system_info_min_heap_size">system_info_min_heap_size</a>,
<a href="#system_info_min_bin_vheap_size">system_info_min_bin_vheap_size</a>,
<a href="#system_info_procs">system_info_procs</a>
</p> </dd><dt><a href="#system_info_limits">system_info_limits</a></dt><dd> <p>
<a href="#system_info_atom_count">system_info_atom_count</a>,
<a href="#system_info_atom_limit">system_info_atom_limit</a>,
<a href="#system_info_ets_count">system_info_ets_count</a>,
<a href="#system_info_ets_limit">system_info_ets_limit</a>,
<a href="#system_info_port_count">system_info_port_count</a>,
<a href="#system_info_port_limit">system_info_port_limit</a>,
<a href="#system_info_process_count">system_info_process_count</a>,
<a href="#system_info_process_limit">system_info_process_limit</a>
</p> </dd><dt><a href="#system_info_time">system_info_time</a></dt><dd> <p>
<a href="#system_info_end_time">system_info_end_time</a>,
<a href="#system_info_os_monotonic_time_source">system_info_os_monotonic_time_source</a>,
<a href="#system_info_os_system_time_source">system_info_os_system_time_source</a>,
<a href="#system_info_start_time">system_info_start_time</a>,
<a href="#system_info_time_correction">system_info_time_correction</a>,
<a href="#system_info_time_offset">system_info_time_offset</a>,
<a href="#system_info_time_warp_mode">system_info_time_warp_mode</a>,
<a href="#system_info_tolerant_timeofday">system_info_tolerant_timeofday</a>
</p> </dd><dt><a href="#system_info_scheduler">system_info_scheduler</a></dt><dd> <p>
<a href="#system_info_dirty_cpu_schedulers">system_info_dirty_cpu_schedulers</a>,
<a href="#system_info_dirty_cpu_schedulers_online">system_info_dirty_cpu_schedulers_online</a>,
<a href="#system_info_dirty_io_schedulers">system_info_dirty_io_schedulers</a>,
<a href="#system_info_multi_scheduling">system_info_multi_scheduling</a>,
<a href="#system_info_multi_scheduling_blockers">system_info_multi_scheduling_blockers</a>,
<a href="#system_info_normal_multi_scheduling_blockers">system_info_normal_multi_scheduling_blockers</a>,
<a href="#system_info_scheduler_bind_type">system_info_scheduler_bind_type</a>,
<a href="#system_info_scheduler_bindings">system_info_scheduler_bindings</a>,
<a href="#system_info_scheduler_id">system_info_scheduler_id</a>,
<a href="#system_info_schedulers">system_info_schedulers</a>,
<a href="#system_info_smp_support">system_info_smp_support</a>,
<a href="#system_info_threads">system_info_threads</a>,
<a href="#system_info_thread_pool_size">system_info_thread_pool_size</a>
</p> </dd><dt><a href="#system_info_dist">system_info_dist</a></dt><dd> <p>
<a href="#system_info_creation">system_info_creation</a>,
<a href="#system_info_delayed_node_table_gc">system_info_delayed_node_table_gc</a>,
<a href="#system_info_dist">system_info_dist</a>,
<a href="#system_info_dist_buf_busy_limit">system_info_dist_buf_busy_limit</a>,
<a href="#system_info_dist_ctrl">system_info_dist_ctrl</a>
</p> </dd><dt><a href="#system_info_misc">system_info_misc</a></dt><dd> <p>
<a href="#system_info_build_type">system_info_build_type</a>,
<a href="#system_info_c_compiler_used">system_info_c_compiler_used</a>,
<a href="#system_info_check_io">system_info_check_io</a>,
<a href="#system_info_compat_rel">system_info_compat_rel</a>,
<a href="#system_info_debug_compiled">system_info_debug_compiled</a>,
<a href="#system_info_driver_version">system_info_driver_version</a>,
<a href="#system_info_dynamic_trace">system_info_dynamic_trace</a>,
<a href="#system_info_dynamic_trace_probes">system_info_dynamic_trace_probes</a>,
<a href="#system_info_info">system_info_info</a>,
<a href="#system_info_kernel_poll">system_info_kernel_poll</a>,
<a href="#system_info_loaded">system_info_loaded</a>,
<a href="#system_info_machine">system_info_machine</a>,
<a href="#system_info_modified_timing_level">system_info_modified_timing_level</a>,
<a href="#system_info_nif_version">system_info_nif_version</a>,
<a href="#system_info_otp_release">system_info_otp_release</a>,
<a href="#system_info_port_parallelism">system_info_port_parallelism</a>,
<a href="#system_info_system_architecture">system_info_system_architecture</a>,
<a href="#system_info_system_logger">system_info_system_logger</a>,
<a href="#system_info_system_version">system_info_system_version</a>,
<a href="#system_info_trace_control_word">system_info_trace_control_word</a>,
<a href="#system_info_version">system_info_version</a>,
<a href="#system_info_wordsize">system_info_wordsize</a>
</p> </dd></dl><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><p>Information about the system allocators.</p><ul><li>Allocator</li></ul><ul><li>Version</li></ul><ul><li>Features</li></ul><ul><li>Settings</li></ul><ul><li>Alloc</li></ul><a name="system_info_allocator_tags"></a><p>Returns various information about the memory allocators
of the current system (emulator) as specified by
<strong><span class="anno">Item</span></strong>:</p><a name="system_info_allocated_areas"></a><dl><dt><a name="system_info_allocated_areas"></a> <strong>allocated_areas</strong></dt><dd> <p>Returns a list of tuples with information about
miscellaneous allocated memory areas.</p> <p>Each tuple contains an atom describing the type of
memory as first element and the amount of allocated
memory in bytes as second element. When information
about allocated and used memory is present, also a
third element is present, containing the amount of
used memory in bytes.</p> <p><strong>erlang:system_info(allocated_areas)</strong> is intended
for debugging, and the content is highly
implementation-dependent. The content of the results
therefore changes when needed without prior notice.</p> <p>Notice that the sum of these values is <em>not</em>
the total amount of memory allocated by the emulator.
Some values are part of other values, and some memory
areas are not part of the result. For information about
the total amount of memory allocated by the emulator, see
<a href="#memory/0">memory/0</a>.</p> </dd><dt><a name="system_info_allocator"></a> <strong>allocator</strong></dt><dd> <p>Returns <strong>{<span class="anno">Allocator</span>, <span class="anno">Version</span>, <span class="anno">Features</span>, <span class="anno">Settings</span></strong>, where:</p> <ul><li> <p><strong><span class="anno">Allocator</span></strong> corresponds to the
<strong>malloc()</strong> implementation used. If
<strong><span class="anno">Allocator</span></strong> equals
<strong>undefined</strong>, the <strong>malloc()</strong> implementation
used cannot be identified. <strong>glibc</strong> can be
identified.</p> </li><li> <p><strong><span class="anno">Version</span></strong> is a list of integers
(but not a string) representing the version of
the <strong>malloc()</strong> implementation used.</p> </li><li> <p><strong><span class="anno">Features</span></strong> is a list of atoms
representing the allocation features used.</p> </li><li> <p><strong><span class="anno">Settings</span></strong> is a list of subsystems,
their configurable parameters, and used values. Settings
can differ between different combinations of
platforms, allocators, and allocation features.
Memory sizes are given in bytes.</p> </li></ul> <p>See also "System Flags Effecting erts_alloc" in
<a href="../erts/erts_alloc#flags">erts/erts_alloc#flags</a>.</p> </dd><dt><a name="system_info_allocator_tuple"></a> <strong>{allocator, <span class="anno">Alloc</span>}</strong></dt><dd> <p>Returns information about the specified allocator.
As from ERTS 5.6.1, the return value is a list
of <strong>{instance, InstanceNo, InstanceInfo}</strong> tuples,
where <strong>InstanceInfo</strong> contains information about
a specific instance of the allocator.
If <strong><span class="anno">Alloc</span></strong> is not a
recognized allocator, <strong>undefined</strong> is returned.
If <strong><span class="anno">Alloc</span></strong> is disabled,
<strong>false</strong> is returned.</p> <p>Notice that the information returned is highly
implementation-dependent and can be changed or removed
at any time without prior notice. It was initially
intended as a tool when developing new allocators, but
as it can be of interest for others it has been
briefly documented.</p> <p>The recognized allocators are listed in
<a href="./erts_alloc">erts/erts_alloc</a>.
Information about super carriers can be obtained from
ERTS 8.0 with <strong>{allocator, erts_mmap}</strong> or from
ERTS 5.10.4; the returned list when calling with
<strong>{allocator, mseg_alloc}</strong> also includes an
<strong>{erts_mmap, _}</strong> tuple as one element in the list.</p> <p>After reading the <strong>erts_alloc(3)</strong> documentation,
the returned information
more or less speaks for itself, but it can be worth
explaining some things. Call counts are presented by two
values, the first value is giga calls, and the second
value is calls. <strong>mbcs</strong> and <strong>sbcs</strong> denote
multi-block carriers, and single-block carriers,
respectively. Sizes are presented in bytes. When a
size is not presented, it is the amount of something.
Sizes and amounts are often presented by three values:</p> <ul><li>The first is the current value.</li><li>The second is the maximum value since the last call to <strong>erlang:system_info({allocator, Alloc})</strong>.</li><li>The third is the maximum value since the emulator was started.</li></ul> <p>If only one value is present, it is the current value.
<strong>fix_alloc</strong> memory block types are presented by two
values. The first value is the memory pool size and
the second value is the used memory size.</p> </dd><dt><a name="system_info_alloc_util_allocators"></a> <strong>alloc_util_allocators</strong></dt><dd> <p>Returns a list of the names of all allocators using
the ERTS internal <strong>alloc_util</strong> framework
as atoms. For more information, see section
<a href="../erts/erts_alloc#alloc_util">The alloc_util framework</a>
in <strong>erts_alloc(3)</strong>.</p> </dd><dt><a name="system_info_allocator_sizes"></a> <strong>{allocator_sizes, <span class="anno">Alloc</span>}</strong></dt><dd> <p>Returns various size information for the specified
allocator. The information returned is a subset of the
information returned by
<a href="#system_info_allocator_tuple">system_info_allocator_tuple</a>.</p> </dd><dt><a name="system_info_elib_malloc"></a> <strong>elib_malloc</strong></dt><dd> <p>This option will be removed in a future release.
The return value will always be <strong>false</strong>, as the
<strong>elib_malloc</strong> allocator has been removed.</p> </dd></dl><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><p>Information about the CPU topology of the system.</p><ul><li>cpu_topology</li></ul><ul><li>level_entry</li></ul> All <strong><span class="anno">LevelEntry</span></strong>s of a list must contain the same <strong><span class="anno">LevelTag</span></strong>, except on the top level where both <strong>node</strong> and <strong>processor</strong> <strong><span class="anno">LevelTag</span></strong>s can coexist.  <strong>{<span class="anno">LevelTag</span>, <span class="anno">SubLevel</span>} == {<span class="anno">LevelTag</span>, [], <span class="anno">SubLevel</span>}</strong> <ul><li>level_tag</li></ul> More <strong><span class="anno">LevelTag</span></strong>s can be introduced in a future release. <ul><li>sub_level</li></ul><ul><li>info_list</li></ul> The <strong>info_list()</strong> can be extended in a future release. <a name="system_info_cpu_topology_tags"></a><p>Returns various information about the CPU topology of
the current system (emulator) as specified by
<strong><span class="anno">Item</span></strong>:</p><dl><dt><a name="system_info_cpu_topology"></a> <strong>cpu_topology</strong></dt><dd> <p>Returns the <strong><span class="anno">CpuTopology</span></strong> currently used by
the emulator. The CPU topology is used when binding schedulers
to logical processors. The CPU topology used is the
<a href="./erlang#system_info_cpu_topology_defined"> user-defined CPU topology</a>,
if such exists, otherwise the
<a href="./erlang#system_info_cpu_topology_detected"> automatically detected CPU topology</a>,
if such exists. If no CPU topology
exists, <strong>undefined</strong> is returned.</p> <p><strong>node</strong> refers to Non-Uniform Memory Access (NUMA)
nodes. <strong>thread</strong> refers to hardware threads
(for example, Intel hyper-threads).</p> <p>A level in term <strong><span class="anno">CpuTopology</span></strong> can be
omitted if only one entry exists and
<strong><span class="anno">InfoList</span></strong> is empty.</p> <p><strong>thread</strong> can only be a sublevel to <strong>core</strong>.
<strong>core</strong> can be a sublevel to <strong>processor</strong>
or <strong>node</strong>. <strong>processor</strong> can be on the
top level or a sublevel to <strong>node</strong>. <strong>node</strong>
can be on the top level or a sublevel to
<strong>processor</strong>. That is, NUMA nodes can be processor
internal or processor external. A CPU topology can
consist of a mix of processor internal and external
NUMA nodes, as long as each logical CPU belongs to
<em>one</em> NUMA node. Cache hierarchy is not part of
the <strong><span class="anno">CpuTopology</span></strong> type, but will be in a
future release. Other things can also make it into the CPU
topology in a future release. So, expect the
<strong><span class="anno">CpuTopology</span></strong> type to change.</p> </dd><dt><strong>{cpu_topology, defined}</strong></dt><dd> <a name="system_info_cpu_topology_defined"></a> <p>Returns the user-defined <strong><span class="anno">CpuTopology</span></strong>.
For more information, see command-line flag
<a href="../erts/erl#+sct">erts/erl#+sct</a> in
<strong>erl(1)</strong> and argument
<a href="#system_info_cpu_topology">system_info_cpu_topology</a>.</p> </dd><dt><strong>{cpu_topology, detected}</strong></dt><dd> <a name="system_info_cpu_topology_detected"></a> <p>Returns the automatically detected
<strong><span class="anno">CpuTopology</span>y</strong>. The
emulator detects the CPU topology on some newer
Linux, Solaris, FreeBSD, and Windows systems.
On Windows system with more than 32 logical processors,
the CPU topology is not detected.</p> <p>For more information, see argument
<a href="#system_info_cpu_topology">system_info_cpu_topology</a>.</p> </dd><dt><strong>{cpu_topology, used}</strong></dt><dd> <p>Returns <strong><span class="anno">CpuTopology</span></strong> used by the emulator.
For more information, see argument
<a href="#system_info_cpu_topology">system_info_cpu_topology</a>.</p> </dd><dt><a name="system_info_logical_processors"></a> <strong>logical_processors</strong></dt><dd> <p>Returns the detected number of logical processors configured
in the system. The return value is either an integer, or
the atom <strong>unknown</strong> if the emulator cannot
detect the configured logical processors.</p> </dd><dt><a name="system_info_logical_processors_available"></a> <strong>logical_processors_available</strong></dt><dd> <p>Returns the detected number of logical processors available
to the Erlang runtime system. The return value is either an
integer, or the atom <strong>unknown</strong> if the emulator
cannot detect the available logical processors. The number
of available logical processors is less than or equal to
the number of <a href="#system_info_logical_processors_online"> logical processors online</a>.</p> </dd><dt><a name="system_info_logical_processors_online"></a> <strong>logical_processors_online</strong></dt><dd> <p>Returns the detected number of logical processors online on
the system. The return value is either an integer,
or the atom <strong>unknown</strong> if the emulator cannot
detect logical processors online. The number of logical
processors online is less than or equal to the number of
<a href="#system_info_logical_processors">logical processors configured</a>.</p> </dd><dt><a name="system_info_update_cpu_info"></a> <strong>update_cpu_info</strong></dt><dd> <p>The runtime system rereads the CPU information available
and updates its internally stored information about the
<a href="#system_info_cpu_topology_detected">detected CPU topology</a> and the number of logical processors
<a href="#system_info_logical_processors">configured</a>,
<a href="#system_info_logical_processors_online">online</a>,
and <a href="#system_info_logical_processors_available"> available</a>.</p> <p>If the CPU information has changed since the last time
it was read, the atom <strong>changed</strong> is returned, otherwise
the atom <strong>unchanged</strong>. If the CPU information has changed,
you probably want to
<a href="#system_flag_schedulers_online">adjust the number of schedulers online</a>. You typically want
to have as many schedulers online as
<a href="#system_info_logical_processors_available">logical processors available</a>.</p> </dd></dl><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><p>Information about the default process heap settings.</p><ul><li>message_queue_data</li></ul><ul><li>max_heap_size</li></ul><a name="system_info_process_tags"></a><p>Returns information about the default process heap settings:</p><dl><dt><a name="system_info_fullsweep_after"></a> <strong>fullsweep_after</strong></dt><dd> <p>Returns <strong>{fullsweep_after, integer() &gt;= 0}</strong>, which is
the <strong>fullsweep_after</strong> garbage collection setting used
by default. For more information, see
<strong>garbage_collection</strong> described below.</p> </dd><dt><a name="system_info_garbage_collection"></a> <strong>garbage_collection</strong></dt><dd> <p>Returns a list describing the default garbage collection
settings. A process spawned on the local node by a
<strong>spawn</strong> or <strong>spawn_link</strong> uses these
garbage collection settings. The default settings can be
changed by using
<a href="#system_flag/2">system_flag/2</a>.
<a href="#spawn_opt/4">spawn_opt/4</a>
can spawn a process that does not use the default
settings.</p> </dd><dt><a name="system_info_heap_sizes"></a> <strong>heap_sizes</strong></dt><dd> <p>Returns a list of integers representing valid heap sizes 
in words. All Erlang heaps are sized from sizes in this
list.</p> </dd><dt><a name="system_info_heap_type"></a> <strong>heap_type</strong></dt><dd> <p>Returns the heap type used by the current emulator. One
heap type exists:</p> <dl><dt><strong>private</strong></dt><dd> Each process has a heap reserved for its use and no references between heaps of different processes are allowed. Messages passed between processes are copied between heaps. </dd></dl> </dd><dt><a name="system_info_max_heap_size"></a> <strong>max_heap_size</strong></dt><dd> <p>Returns <strong>{max_heap_size, <span class="anno">MaxHeapSize</span>}</strong>,
where <strong><span class="anno">MaxHeapSize</span></strong> is the current
system-wide maximum heap size settings for spawned processes.
This setting can be set using the command-line flags
<a href="./erl#+hmax">erl#+hmax</a>,
<a href="./erl#+hmaxk">erl#+hmaxk</a> and
<a href="./erl#+hmaxel">erl#+hmaxel</a> in
<strong>erl(1)</strong>. It can also be changed at runtime using
<a href="#system_flag_max_heap_size">system_flag_max_heap_size</a>.
For more details about the <strong>max_heap_size</strong> process flag,
see <a href="#process_flag_max_heap_size">process_flag_max_heap_size</a>.</p> </dd><dt><a name="system_info_message_queue_data"></a> <strong>message_queue_data</strong></dt><dd> <p>Returns the default value of the <strong>message_queue_data</strong>
process flag, which is either <strong>off_heap</strong> or <strong>on_heap</strong>.
This default is set by command-line argument
<a href="./erl#+hmqd">erl#+hmqd</a> in
<strong>erl(1)</strong>. For more information on the
<strong>message_queue_data</strong> process flag, see documentation of
<a href="#process_flag_message_queue_data">process_flag_message_queue_data</a>.</p> </dd><dt><a name="system_info_min_heap_size"></a> <strong>min_heap_size</strong></dt><dd> <p>Returns <strong>{min_heap_size, <span class="anno">MinHeapSize</span>}</strong>,
where <strong><span class="anno">MinHeapSize</span></strong> is the current
system-wide minimum heap size for spawned processes.</p> </dd><dt><a name="system_info_min_bin_vheap_size"></a> <strong>min_bin_vheap_size</strong></dt><dd> <p>Returns <strong>{min_bin_vheap_size, <span class="anno">MinBinVHeapSize</span>}</strong>, where
<strong><span class="anno">MinBinVHeapSize</span></strong> is the current system-wide
minimum binary virtual heap size for spawned processes.</p> </dd><dt><a name="system_info_procs"></a> <strong>procs</strong></dt><dd> <p>Returns a binary containing a string of process and port
information formatted as in Erlang crash dumps. For more
information, see section <a href="./crash_dump"> How to interpret the Erlang crash dumps</a>
in the User's Guide.</p> </dd></dl><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><p>Information about various system limits.</p><a name="system_info_limits"></a><p>Returns information about the current system
(emulator) limits as specified by <strong><span class="anno">Item</span></strong>:</p><dl><dt><a name="system_info_atom_count"></a> <strong>atom_count</strong></dt><dd> <p>Returns the number of atoms currently existing at the
local node. The value is given as an integer.</p> </dd><dt><a name="system_info_atom_limit"></a> <strong>atom_limit</strong></dt><dd> <p>Returns the maximum number of atoms allowed.
This limit can be increased at startup by passing
command-line flag
<a href="../erts/erl#+t">erts/erl#+t</a> to
<strong>erl(1)</strong>.
</p> </dd><dt><a name="system_info_ets_count"></a> <strong>ets_count</strong></dt><dd> <p>Returns the number of ETS tables currently existing at the
local node.</p> </dd><dt><a name="system_info_ets_limit"></a> <strong>ets_limit</strong></dt><dd> <p>Returns the limit for number of ETS tables. This limit is
<a href="../stdlib/ets#max_ets_tables">partially obsolete</a>
and number of tables are only limited by available memory.</p> </dd><dt><a name="system_info_port_count"></a><strong>port_count</strong></dt><dd> <p>Returns the number of ports currently existing at the
local node. The value is given as an integer. This is
the same value as returned by
<strong>length(erlang:ports())</strong>, but more efficient.</p> </dd><dt><a name="system_info_port_limit"></a> <strong>port_limit</strong></dt><dd> <p>Returns the maximum number of simultaneously existing
ports at the local node as an integer. This limit can be
configured at startup by using command-line flag
<a href="./erl#+Q">erl#+Q</a> in <strong>erl(1)</strong>.</p> </dd><dt><a name="system_info_process_count"></a> <strong>process_count</strong></dt><dd> <p>Returns the number of processes currently existing at the
local node. The value is given as an integer. This is
the same value as returned by
<strong>length(processes())</strong>, but more efficient.</p> </dd><dt><a name="system_info_process_limit"></a> <strong>process_limit</strong></dt><dd> <p>Returns the maximum number of simultaneously existing
processes at the local node. The value is given as an
integer. This limit can be configured at startup by using
command-line flag <a href="./erl#+P">erl#+P</a>
in <strong>erl(1)</strong>.</p> </dd></dl><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><p>Information about system time.</p><a name="system_info_time_tags"></a><p>Returns information about the current system
(emulator) time as specified by <strong><span class="anno">Item</span></strong>:</p><dl><dt><a name="system_info_end_time"></a><strong>end_time</strong></dt><dd> <p>The last <a href="#monotonic_time/0">Erlang monotonic time</a> in <strong>native</strong>
<a href="#type_time_unit">time unit</a> that
can be represented internally in the current Erlang runtime system
instance. The time between the
<a href="#system_info_start_time">start time</a> and
the end time is at least a quarter of a millennium.</p> </dd><dt><a name="system_info_os_monotonic_time_source"></a> <strong>os_monotonic_time_source</strong></dt><dd> <p>Returns a list containing information about the source of
<a href="../erts/time_correction#OS_Monotonic_Time">OS monotonic time</a> that is used by the runtime system.</p> <p>If <strong>[]</strong> is returned, no OS monotonic time is
available. The list contains two-tuples with <strong>Key</strong>s
as first element, and <strong>Value</strong>s as second element. The
order of these tuples is undefined. The following
tuples can be part of the list, but more tuples can be
introduced in the future:</p> <dl><dt><strong>{function, Function}</strong></dt><dd><p><strong>Function</strong> is the name of the function
used. This tuple always exists if OS monotonic time is
available to the runtime system.</p> </dd><dt><strong>{clock_id, ClockId}</strong></dt><dd><p>This tuple only exists if <strong>Function</strong>
can be used with different clocks. <strong>ClockId</strong>
corresponds to the clock identifier used when calling
<strong>Function</strong>.</p> </dd><dt><strong>{resolution, OsMonotonicTimeResolution}</strong></dt><dd><p>Highest possible
<a href="./time_correction#Time_Resolution"> resolution</a>
of current OS monotonic time source as parts per
second. If no resolution information can be retrieved
from the OS, <strong>OsMonotonicTimeResolution</strong> is
set to the resolution of the time unit of
<strong>Function</strong>s return value. That is, the actual
resolution can be lower than
<strong>OsMonotonicTimeResolution</strong>. Notice that
the resolution does not say anything about the
<a href="./time_correction#Time_Accuracy"> accuracy</a> or whether the
<a href="./time_correction#Time_Precision"> precision</a> aligns with the resolution. You do,
however, know that the precision is not better than
<strong>OsMonotonicTimeResolution</strong>.</p> </dd><dt><strong>{extended, Extended}</strong></dt><dd><p><strong>Extended</strong> equals <strong>yes</strong> if
the range of time values has been extended;
otherwise <strong>Extended</strong> equals <strong>no</strong>. The
range must be extended if <strong>Function</strong>
returns values that wrap fast. This typically
is the case when the return value is a 32-bit value.</p> </dd><dt><strong>{parallel, Parallel}</strong></dt><dd><p><strong>Parallel</strong> equals <strong>yes</strong> if
<strong>Function</strong> is called in parallel from multiple
threads. If it is not called in parallel, because
calls must be serialized, <strong>Parallel</strong> equals
<strong>no</strong>.</p> </dd><dt><strong>{time, OsMonotonicTime}</strong></dt><dd><p><strong>OsMonotonicTime</strong> equals current OS
monotonic time in <strong>native</strong>
<a href="#type_time_unit">time unit</a>.</p> </dd></dl> </dd><dt><a name="system_info_os_system_time_source"></a> <strong>os_system_time_source</strong></dt><dd> <p>Returns a list containing information about the source of
<a href="../erts/time_correction#OS_System_Time">OS system time</a> that is used by the runtime system.</p> <p>The list contains two-tuples with <strong>Key</strong>s
as first element, and <strong>Value</strong>s as second element. The
order of these tuples is undefined. The following
tuples can be part of the list, but more tuples can be
introduced in the future:</p> <dl><dt><strong>{function, Function}</strong></dt><dd><p><strong>Function</strong> is the name of the funcion used.</p> </dd><dt><strong>{clock_id, ClockId}</strong></dt><dd><p>Exists only if <strong>Function</strong>
can be used with different clocks. <strong>ClockId</strong>
corresponds to the clock identifier used when calling
<strong>Function</strong>.</p> </dd><dt><strong>{resolution, OsSystemTimeResolution}</strong></dt><dd><p>Highest possible
<a href="./time_correction#Time_Resolution"> resolution</a>
of current OS system time source as parts per
second. If no resolution information can be retrieved
from the OS, <strong>OsSystemTimeResolution</strong> is
set to the resolution of the time unit of
<strong>Function</strong>s return value. That is, the actual
resolution can be lower than
<strong>OsSystemTimeResolution</strong>. Notice that
the resolution does not say anything about the
<a href="./time_correction#Time_Accuracy"> accuracy</a> or whether the
<a href="./time_correction#Time_Precision"> precision</a> do align with the resolution. You do,
however, know that the precision is not better than
<strong>OsSystemTimeResolution</strong>.</p> </dd><dt><strong>{parallel, Parallel}</strong></dt><dd><p><strong>Parallel</strong> equals <strong>yes</strong> if
<strong>Function</strong> is called in parallel from multiple
threads. If it is not called in parallel, because
calls needs to be serialized, <strong>Parallel</strong> equals
<strong>no</strong>.</p> </dd><dt><strong>{time, OsSystemTime}</strong></dt><dd><p><strong>OsSystemTime</strong> equals current OS
system time in <strong>native</strong>
<a href="#type_time_unit">time unit</a>.</p> </dd></dl> </dd><dt><a name="system_info_start_time"></a><strong>start_time</strong></dt><dd> <p>The <a href="#monotonic_time/0">Erlang monotonic time</a> in <strong>native</strong>
<a href="#type_time_unit">time unit</a> at the
time when current Erlang runtime system instance started.</p> <p>See also <a href="#system_info_end_time">system_info_end_time</a>.</p> </dd><dt><a name="system_info_time_correction"></a> <strong>time_correction</strong></dt><dd> <p>Returns a boolean value indicating whether
<a href="./time_correction#Time_Correction"> time correction</a> is enabled or not.</p> </dd><dt><a name="system_info_time_offset"></a> <strong>time_offset</strong></dt><dd> <p>Returns the state of the time offset:</p> <dl><dt><strong>preliminary</strong></dt><dd> <p>The time offset is preliminary, and will be changed
and finalized later. The preliminary time offset
is used during the preliminary phase of the
<a href="./time_correction#Single_Time_Warp_Mode"> single time warp mode</a>.</p> </dd><dt><strong>final</strong></dt><dd> <p>The time offset is final. This either because
<a href="./time_correction#No_Time_Warp_Mode"> no time warp mode</a> is used, or because the time
offset have been finalized when
<a href="./time_correction#Single_Time_Warp_Mode"> single time warp mode</a> is used.</p> </dd><dt><strong>volatile</strong></dt><dd> <p>The time offset is volatile. That is, it can
change at any time. This is because
<a href="./time_correction#Multi_Time_Warp_Mode"> multi-time warp mode</a> is used.</p> </dd></dl> </dd><dt><a name="system_info_time_warp_mode"></a> <strong>time_warp_mode</strong></dt><dd> <p>Returns a value identifying the
<a href="./time_correction#Time_Warp_Modes"> time warp mode</a> that is used:</p> <dl><dt><strong>no_time_warp</strong></dt><dd>The <a href="./time_correction#No_Time_Warp_Mode"> no time warp mode</a> is used. </dd><dt><strong>single_time_warp</strong></dt><dd>The <a href="./time_correction#Single_Time_Warp_Mode"> single time warp mode</a> is used. </dd><dt><strong>multi_time_warp</strong></dt><dd>The <a href="./time_correction#Multi_Time_Warp_Mode"> multi-time warp mode</a> is used. </dd></dl> </dd><dt><a name="system_info_tolerant_timeofday"></a> <strong>tolerant_timeofday</strong></dt><dd> <p>Returns whether a pre ERTS 7.0 backwards compatible
compensation for sudden changes of system time is <strong>enabled</strong>
or <strong>disabled</strong>. Such compensation is <strong>enabled</strong> when the
<a href="#system_info_time_offset">time offset</a>
is <strong>final</strong>, and
<a href="#system_info_time_correction"> time correction</a> is enabled.</p> </dd></dl><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><p>Information about system schedulers.</p><a name="system_info_scheduler_tags"></a><p>Returns information about schedulers, scheduling and threads in the
current system as specified by <strong><span class="anno">Item</span></strong>:</p><dl><dt><a name="system_info_dirty_cpu_schedulers"></a> <strong>dirty_cpu_schedulers</strong></dt><dd> <p>Returns the number of dirty CPU scheduler threads used by
the emulator. Dirty CPU schedulers execute CPU-bound
native functions, such as NIFs, linked-in driver code,
and BIFs that cannot be managed cleanly by the normal
emulator schedulers.</p> <p>The number of dirty CPU scheduler threads is determined
at emulator boot time and cannot be changed after that.
However, the number of dirty CPU scheduler threads online
can be changed at any time. The number of dirty CPU
schedulers can be set at startup by passing
command-line flag
<a href="../erts/erl#+SDcpu">erts/erl#+SDcpu</a> or
<a href="../erts/erl#+SDPcpu">erts/erl#+SDPcpu</a> in
<strong>erl(1)</strong>.</p> <p>See also
<a href="#system_flag_dirty_cpu_schedulers_online">system_flag_dirty_cpu_schedulers_online</a>,
<a href="#system_info_dirty_cpu_schedulers_online">system_info_dirty_cpu_schedulers_online</a>,
<a href="#system_info_dirty_io_schedulers">system_info_dirty_io_schedulers</a>,
<a href="#system_info_schedulers">system_info_schedulers</a>,
<a href="#system_info_schedulers_online">system_info_schedulers_online</a>, and
<a href="#system_flag_schedulers_online">system_flag_schedulers_online</a>.</p> </dd><dt><a name="system_info_dirty_cpu_schedulers_online"></a> <strong>dirty_cpu_schedulers_online</strong></dt><dd> <p>Returns the number of dirty CPU schedulers online.
The return value satisfies
<strong>1 &lt;= DirtyCPUSchedulersOnline &lt;= N</strong>,
where <strong>N</strong> is the smallest of the return values of
<strong>erlang:system_info(dirty_cpu_schedulers)</strong> and
<strong>erlang:system_info(schedulers_online)</strong>.</p> <p>The number of dirty CPU schedulers online can be set at
startup by passing command-line flag
<a href="../erts/erl#+SDcpu">erts/erl#+SDcpu</a> in
<strong>erl(1)</strong>.</p> <p>For more information, see
<a href="#system_info_dirty_cpu_schedulers">system_info_dirty_cpu_schedulers</a>,
<a href="#system_info_dirty_io_schedulers">system_info_dirty_io_schedulers</a>,
<a href="#system_info_schedulers_online">system_info_schedulers_online</a>, and
<a href="#system_flag_dirty_cpu_schedulers_online">system_flag_dirty_cpu_schedulers_online</a>.</p> </dd><dt><a name="system_info_dirty_io_schedulers"></a> <strong>dirty_io_schedulers</strong></dt><dd> <p>Returns the number of dirty I/O schedulers as an integer.
Dirty I/O schedulers execute I/O-bound native functions,
such as NIFs and linked-in driver code, which cannot be
managed cleanly by the normal emulator schedulers.</p> <p>This value can be set at startup by passing command-line
argument <a href="../erts/erl#+SDio">erts/erl#+SDio</a>
in <strong>erl(1)</strong>.</p> <p>For more information, see
<a href="#system_info_dirty_cpu_schedulers">system_info_dirty_cpu_schedulers</a>,
<a href="#system_info_dirty_cpu_schedulers_online">system_info_dirty_cpu_schedulers_online</a>,
and <a href="#system_flag_dirty_cpu_schedulers_online">system_flag_dirty_cpu_schedulers_online</a>.</p> </dd><dt><a name="system_info_multi_scheduling"></a> <strong>multi_scheduling</strong></dt><dd> <p>Returns one of the following:</p> <dl><dt><strong>disabled</strong></dt><dd> <p>The emulator has been started with only one scheduler thread.</p> </dd><dt><strong>blocked</strong></dt><dd> <p>The emulator has more than one scheduler thread,
but all scheduler threads except one are blocked.
That is, only one scheduler thread schedules
Erlang processes and executes Erlang code.</p> </dd><dt><strong>blocked_normal</strong></dt><dd> <p>The emulator has more than one scheduler thread,
but all normal scheduler threads except one are
blocked. Notice that dirty schedulers are not
blocked, and can schedule Erlang processes and
execute native code.</p> </dd><dt><strong>enabled</strong></dt><dd> <p>The emulator has more than one scheduler thread,
and no scheduler threads are blocked. That is,
all available scheduler threads schedule
Erlang processes and execute Erlang code.</p> </dd></dl> <p>See also
<a href="#system_flag_multi_scheduling">system_flag_multi_scheduling</a>,
<a href="#system_info_multi_scheduling_blockers">system_info_multi_scheduling_blockers</a>,
<a href="#system_info_normal_multi_scheduling_blockers">system_info_normal_multi_scheduling_blockers</a>,
and <a href="#system_info_schedulers">system_info_schedulers</a>.</p> </dd><dt><a name="system_info_multi_scheduling_blockers"></a> <strong>multi_scheduling_blockers</strong></dt><dd> <p>Returns a list of <strong><span class="anno">Pid</span></strong>s when
multi-scheduling is blocked, otherwise the empty list is
returned. The <strong><span class="anno">Pid</span></strong>s in the list
represent all the processes currently
blocking multi-scheduling. A <strong><span class="anno">Pid</span></strong> occurs
only once in the list, even if the corresponding
process has blocked multiple times.</p> <p>See also
<a href="#system_flag_multi_scheduling">system_flag_multi_scheduling</a>,
<a href="#system_info_multi_scheduling">system_info_multi_scheduling</a>,
<a href="#system_info_normal_multi_scheduling_blockers">system_info_normal_multi_scheduling_blockers</a>,
and <a href="#system_info_schedulers">system_info_schedulers</a>.</p> </dd><dt><a name="system_info_normal_multi_scheduling_blockers"></a> <strong>normal_multi_scheduling_blockers</strong></dt><dd> <p>Returns a list of <strong><span class="anno">Pid</span></strong>s when
normal multi-scheduling is blocked (that is, all normal schedulers
but one is blocked), otherwise the empty list is returned.
The <strong><span class="anno">Pid</span></strong>s in the list represent all the
processes currently blocking normal multi-scheduling.
A <strong><span class="anno">Pid</span></strong> occurs only once in the list, even if
the corresponding process has blocked multiple times.</p> <p>See also
<a href="#system_flag_multi_scheduling">system_flag_multi_scheduling</a>,
<a href="#system_info_multi_scheduling">system_info_multi_scheduling</a>,
<a href="#system_info_multi_scheduling_blockers">system_info_multi_scheduling_blockers</a>,
and <a href="#system_info_schedulers">system_info_schedulers</a>.</p> </dd><dt><a name="system_info_scheduler_bind_type"></a> <strong>scheduler_bind_type</strong></dt><dd> <p>Returns information about how the user has requested
schedulers to be bound or not bound.</p> <p>Notice that although a user has requested
schedulers to be bound, they can silently have failed
to bind. To inspect the scheduler bindings, call
<a href="#system_info_scheduler_bindings">system_info_scheduler_bindings</a>.</p> <p>For more information, see command-line argument
<a href="../erts/erl#+sbt">erts/erl#+sbt</a>
in <strong>erl(1)</strong> and
<a href="#system_info_scheduler_bindings">system_info_scheduler_bindings</a>.</p> </dd><dt><a name="system_info_scheduler_bindings"></a> <strong>scheduler_bindings</strong></dt><dd> <p>Returns information about the currently used scheduler
bindings.</p> <p>A tuple of a size equal to
<a href="#system_info_schedulers">system_info_schedulers</a>
is returned. The tuple elements are integers
or the atom <strong>unbound</strong>. Logical processor identifiers
are represented as integers. The <strong>N</strong>th
element of the tuple equals the current binding for
the scheduler with the scheduler identifier equal to
<strong>N</strong>. For example, if the schedulers are bound,
<strong>element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))</strong> returns
the identifier of the logical processor that the calling
process is executing on.</p> <p>Notice that only schedulers online can be bound to logical
processors.</p> <p>For more information, see command-line argument
<a href="../erts/erl#+sbt">erts/erl#+sbt</a>
in <strong>erl(1)</strong> and
<a href="#system_info_schedulers_online">system_info_schedulers_online</a>.</p> </dd><dt><a name="system_info_scheduler_id"></a> <strong>scheduler_id</strong></dt><dd> <p>Returns the scheduler ID (<strong>SchedulerId</strong>) of the
scheduler thread that the calling process is executing
on. <strong><span class="anno">SchedulerId</span></strong> is a positive integer,
where <strong>1 &lt;= SchedulerId &lt;= erlang:system_info(schedulers)</strong>.</p> <p>See also
<a href="#system_info_schedulers">system_info_schedulers</a>.</p> </dd><dt><a name="system_info_schedulers"></a> <strong>schedulers</strong></dt><dd> <p>Returns the number of scheduler threads used by
the emulator. Scheduler threads online schedules Erlang
processes and Erlang ports, and execute Erlang code
and Erlang linked-in driver code.</p> <p>The number of scheduler threads is determined at
emulator boot time and cannot be changed later.
However, the number of schedulers online can
be changed at any time.</p> <p>See also
<a href="#system_flag_schedulers_online">system_flag_schedulers_online</a>,
<a href="#system_info_schedulers_online">system_info_schedulers_online</a>,
<a href="#system_info_scheduler_id">system_info_scheduler_id</a>,
<a href="#system_flag_multi_scheduling">system_flag_multi_scheduling</a>,
<a href="#system_info_multi_scheduling">system_info_multi_scheduling</a>,
<a href="#system_info_normal_multi_scheduling_blockers">system_info_normal_multi_scheduling_blockers</a>
and <a href="#system_info_multi_scheduling_blockers">system_info_multi_scheduling_blockers</a>.
</p> </dd><dt><a name="system_info_schedulers_online"></a> <strong>schedulers_online</strong></dt><dd> <p>Returns the number of schedulers online. The scheduler
identifiers of schedulers online satisfy the relationship
<strong>1 &lt;= SchedulerId &lt;= erlang:system_info(schedulers_online)</strong>.</p> <p>For more information, see
<a href="#system_info_schedulers">system_info_schedulers</a> and
<a href="#system_flag_schedulers_online">system_flag_schedulers_online</a>.</p> </dd><dt><a name="system_info_smp_support"></a> <strong>smp_support</strong></dt><dd> <p>Returns <strong>true</strong>.</p> </dd><dt><a name="system_info_threads"></a> <strong>threads</strong></dt><dd> <p>Returns <strong>true</strong>.</p> </dd><dt><a name="system_info_thread_pool_size"></a> <strong>thread_pool_size</strong></dt><dd> <a name="system_info_thread_pool_size"></a> <p>Returns the number of async threads in the async thread
pool used for asynchronous driver calls
(<a href="../erts/erl_driver#driver_async">erts/erl_driver#driver_async</a>).
The value is given as an integer.</p> </dd></dl><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><p>Information about erlang distribution.</p><a name="system_info_dist_tags"></a><p>Returns information about Erlang Distribution in the
current system as specified by <strong><span class="anno">Item</span></strong>:</p><dl><dt><a name="system_info_creation"></a> <strong>creation</strong></dt><dd> <p>Returns the creation of the local node as an integer.
The creation is changed when a node is restarted. The
creation of a node is stored in process identifiers, port
identifiers, and references. This makes it (to some
extent) possible to distinguish between identifiers from
different incarnations of a node. The valid
creations are integers in the range 1..3, but this will
probably change in a future release. If the node is not
alive, <strong>0</strong> is returned.</p> </dd><dt><a name="system_info_delayed_node_table_gc"></a> <strong>delayed_node_table_gc</strong></dt><dd> <p>Returns the amount of time in seconds garbage collection
of an entry in a node table is delayed. This limit can be set
on startup by passing command-line flag
<a href="../erts/erl#+zdntgc">erts/erl#+zdntgc</a>
to <strong>erl(1)</strong>. For more information, see the documentation of
the command-line flag.</p> </dd><dt><a name="system_info_dist"></a> <strong>dist</strong></dt><dd> <p>Returns a binary containing a string of distribution
information formatted as in Erlang crash dumps. For more
information, see section <a href="./crash_dump"> How to interpret the Erlang crash dumps</a>
in the User's Guide.</p> </dd><dt><a name="system_info_dist_buf_busy_limit"></a> <strong>dist_buf_busy_limit</strong></dt><dd> <p>Returns the value of the distribution buffer busy limit
in bytes. This limit can be set at startup by passing
command-line flag
<a href="../erts/erl#+zdbbl">erts/erl#+zdbbl</a>
to <strong>erl(1)</strong>.</p> </dd><dt><a name="system_info_dist_ctrl"></a> <strong>dist_ctrl</strong></dt><dd> <p>Returns a list of tuples
<strong>{<span class="anno">Node</span>, <span class="anno">ControllingEntity</span>}</strong>,
one entry for each connected remote node.
<strong><span class="anno">Node</span></strong> is the node name
and <strong><span class="anno">ControllingEntity</span></strong> is the port or process
identifier responsible for the communication to that node.
More specifically, <strong><span class="anno">ControllingEntity</span></strong> for
nodes connected through TCP/IP (the normal case) is the socket
used in communication with the specific node.</p> </dd></dl><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><h3>system_info/1</h3><p>Information about the system.</p><a name="system_info_misc_tags"></a><p>Returns various information about the current system
(emulator) as specified by <strong><span class="anno">Item</span></strong>:</p><dl><dt><a name="system_info_build_type"></a> <strong>build_type</strong></dt><dd> <p>Returns an atom describing the build type of the runtime
system. This is normally the atom <strong>opt</strong> for optimized.
Other possible return values are <strong>debug</strong>, <strong>purify</strong>,
<strong>quantify</strong>, <strong>purecov</strong>, <strong>gcov</strong>, <strong>valgrind</strong>,
<strong>gprof</strong>, and <strong>lcnt</strong>. Possible return values
can be added or removed at any time without prior notice.</p> </dd><dt><a name="system_info_c_compiler_used"></a> <strong>c_compiler_used</strong></dt><dd> <p>Returns a two-tuple describing the C compiler used when
compiling the runtime system. The first element is an
atom describing the name of the compiler, or <strong>undefined</strong>
if unknown. The second element is a term describing the
version of the compiler, or <strong>undefined</strong> if unknown.</p> </dd><dt><a name="system_info_check_io"></a> <strong>check_io</strong></dt><dd> <p>Returns a list containing miscellaneous information
about the emulators internal I/O checking. Notice that
the content of the returned list can vary between
platforms and over time. It is only guaranteed
that a list is returned.</p> </dd><dt><a name="system_info_compat_rel"></a> <strong>compat_rel</strong></dt><dd> <p>Returns the compatibility mode of the local node as
an integer. The integer returned represents the
Erlang/OTP release that the current emulator has been
set to be backward compatible with. The compatibility
mode can be configured at startup by using command-line flag
<a href="../erts/erl#compat_rel">erts/erl#compat_rel</a> in
<strong>erl(1)</strong>.</p> </dd><dt><a name="system_info_debug_compiled"></a> <strong>debug_compiled</strong></dt><dd> <p>Returns <strong>true</strong> if the emulator has been
debug-compiled, otherwise <strong>false</strong>.</p> </dd><dt><a name="system_info_driver_version"></a> <strong>driver_version</strong></dt><dd> <p>Returns a string containing the Erlang driver version
used by the runtime system. It has the form
<a href="../erts/erl_driver#version_management"> "&lt;major ver&gt;.&lt;minor ver&gt;"</a>.</p> </dd><dt><a name="system_info_dynamic_trace"></a> <strong>dynamic_trace</strong></dt><dd> <p>Returns an atom describing the dynamic trace framework
compiled into the virtual machine. It can be
<strong>dtrace</strong>, <strong>systemtap</strong>, or <strong>none</strong>. For a
commercial or standard build, it is always <strong>none</strong>.
The other return values indicate a custom configuration
(for example, <strong>./configure --with-dynamic-trace=dtrace</strong>).
For more information about dynamic tracing, see
<a href="./dyntrace">runtime_tools/dyntrace</a> manual page and the
<strong>README.dtrace</strong>/<strong>README.systemtap</strong> files in the
Erlang source code top directory.</p> </dd><dt><a name="system_info_dynamic_trace_probes"></a> <strong>dynamic_trace_probes</strong></dt><dd> <p>Returns a <strong>boolean()</strong> indicating if dynamic trace
probes (<strong>dtrace</strong> or <strong>systemtap</strong>) are built into
the emulator. This can only be <strong>true</strong> if the virtual
machine was built for dynamic tracing (that is,
<strong>system_info(dynamic_trace)</strong> returns
<strong>dtrace</strong> or <strong>systemtap</strong>).</p> </dd><dt><a name="system_info_info"></a> <strong>info</strong></dt><dd> <p>Returns a binary containing a string of miscellaneous
system information formatted as in Erlang crash dumps.
For more information, see section
<a href="./crash_dump"> How to interpret the Erlang crash dumps</a>
in the User's Guide.</p> </dd><dt><a name="system_info_kernel_poll"></a> <strong>kernel_poll</strong></dt><dd> <p>Returns <strong>true</strong> if the emulator uses some kind of
kernel-poll implementation, otherwise <strong>false</strong>.</p> </dd><dt><a name="system_info_loaded"></a> <strong>loaded</strong></dt><dd> <p>Returns a binary containing a string of loaded module
information formatted as in Erlang crash dumps. For more
information, see section
<a href="./crash_dump">How to interpret the Erlang crash dumps</a> in the User's Guide.</p> </dd><dt><a name="system_info_machine"></a> <strong>machine</strong></dt><dd> <p>Returns a string containing the Erlang machine name.</p> </dd><dt><a name="system_info_modified_timing_level"></a> <strong>modified_timing_level</strong></dt><dd> <p>Returns the modified timing-level (an integer) if
modified timing is enabled, otherwise <strong>undefined</strong>.
For more information about modified timing, see
command-line flag
<a href="../erts/erl#+T">erts/erl#+T</a>
in <strong>erl(1)</strong></p> </dd><dt><a name="system_info_nif_version"></a> <strong>nif_version</strong></dt><dd> <p>Returns a string containing the version of the Erlang NIF
interface used by the runtime system. It is on the form
"&lt;major ver&gt;.&lt;minor ver&gt;".</p> </dd><dt><a name="system_info_otp_release"></a> <strong>otp_release</strong></dt><dd> <a name="system_info_otp_release"></a> <p>Returns a string containing the OTP release number of the
OTP release that the currently executing ERTS application
is part of.</p> <p>As from Erlang/OTP 17, the OTP release number corresponds to
the major OTP version number. No
<strong>erlang:system_info()</strong> argument gives the exact OTP
version. This is because the exact OTP version in the general case
is difficult to determine. For more information, see the
description of versions in
<a href="./versions"> System principles</a> in System Documentation.</p> </dd><dt><a name="system_info_port_parallelism"></a> <strong>port_parallelism</strong></dt><dd> <p>Returns the default port parallelism scheduling hint used.
For more information, see command-line argument
<a href="./erl#+spp">erl#+spp</a>
in <strong>erl(1)</strong>.</p> </dd><dt><a name="system_info_system_architecture"></a> <strong>system_architecture</strong></dt><dd> <p>Returns a string containing the processor and OS
architecture the emulator is built for.</p> </dd><dt><a name="system_info_system_logger"></a> <strong>system_logger</strong></dt><dd> <p>Returns the current <strong>system_logger</strong> as set by
<a href="#system_flag/2">system_flag/2</a>.</p> </dd><dt><a name="system_info_system_version"></a> <strong>system_version</strong></dt><dd> <p>Returns a string containing version number and
some important properties, such as the number of schedulers.</p> </dd><dt><a name="system_info_trace_control_word"></a> <strong>trace_control_word</strong></dt><dd> <p>Returns the value of the node trace control word. For
more information, see function <strong>get_tcw</strong> in section
<a href="../erts/match_spec#get_tcw"> Match Specifications in Erlang</a> in the User's Guide.</p> </dd><dt><a name="system_info_version"></a> <strong>version</strong></dt><dd> <p>Returns a string containing the version number of the
emulator.</p> </dd><dt><a name="system_info_wordsize"></a> <strong>wordsize</strong></dt><dd> <p>Same as <strong>{wordsize, internal}</strong>.</p> </dd><dt><strong>{wordsize, internal}</strong></dt><dd> <p>Returns the size of Erlang term words in bytes as an
integer, that is, 4 is returned on a 32-bit architecture,
and 8 is returned on a pure 64-bit architecture. On a
halfword 64-bit emulator, 4 is returned, as the Erlang
terms are stored using a virtual word size of half the
system word size.</p> </dd><dt><strong>{wordsize, external}</strong></dt><dd> <p>Returns the true word size of the emulator, that is,
the size of a pointer. The value is given in bytes
as an integer. On a pure 32-bit architecture, 4 is
returned. On both a half word and on a pure
64-bit architecture, 8 is returned.</p> </dd></dl><h3>system_monitor/0</h3><p>Current system performance monitoring settings.</p><ul><li>system_monitor_option</li></ul><p>Returns the current system monitoring settings set by
<a href="#system_monitor/2">system_monitor/2</a>
as <strong>{<span class="anno">MonitorPid</span>, <span class="anno">Options</span>}</strong>,
or <strong>undefined</strong> if no settings exist. The order of the
options can be different from the one that was set.</p><h3>system_monitor/1</h3><p>Set or clear system performance monitoring options.</p><ul><li>system_monitor_option</li></ul><p>When called with argument <strong>undefined</strong>, all
system performance monitoring settings are cleared.</p><p>Calling the function with <strong>{<span class="anno">MonitorPid</span>, <span class="anno">Options</span>}</strong> as argument is the same as calling
<a href="#system_monitor/2">system_monitor/2</a>.</p><p>Returns the previous system monitor settings just like
<a href="#system_monitor/0">system_monitor/0</a>.</p><h3>system_monitor/2</h3><p>Set system performance monitoring options.</p><ul><li>system_monitor_option</li></ul><p>Sets the system performance monitoring options.
<strong><span class="anno">MonitorPid</span></strong> is a local process identifier (pid)
receiving system monitor messages. The
second argument is a list of monitoring options:</p><dl><dt><strong>{long_gc, Time}</strong></dt><dd> <p>If a garbage collection in the system takes at least
<strong>Time</strong> wall clock milliseconds, a message
<strong>{monitor, GcPid, long_gc, Info}</strong> is sent to
<strong><span class="anno">MonitorPid</span></strong>. <strong>GcPid</strong> is the pid that
was garbage collected. <strong>Info</strong> is a list of two-element
tuples describing the result of the garbage collection.</p> <p>One of the tuples is <strong>{timeout, GcTime}</strong>, where
<strong>GcTime</strong> is the time for the garbage
collection in milliseconds. The other tuples are
tagged with <strong>heap_size</strong>, <strong>heap_block_size</strong>,
<strong>stack_size</strong>, <strong>mbuf_size</strong>, <strong>old_heap_size</strong>,
and <strong>old_heap_block_size</strong>. These tuples are
explained in the description of trace message
<a href="#gc_minor_start">gc_minor_start</a>
(see <a href="#trace/3">trace/3</a>).
New tuples can be added, and the order of the tuples in
the <strong>Info</strong> list can be changed at any time without
prior notice.</p> </dd><dt><strong>{long_schedule, Time}</strong></dt><dd> <p>If a process or port in the system runs uninterrupted
for at least <strong>Time</strong> wall clock milliseconds, a
message <strong>{monitor, PidOrPort, long_schedule, Info}</strong>
is sent to <strong>MonitorPid</strong>. <strong>PidOrPort</strong> is the
process or port that was running. <strong>Info</strong> is a
list of two-element tuples describing the event.</p> <p>If a <strong>pid()</strong>, the tuples <strong>{timeout, Millis}</strong>,
<strong>{in, Location}</strong>, and <strong>{out, Location}</strong> are
present, where <strong>Location</strong> is either an MFA
(<strong>{Module, Function, Arity}</strong>) describing the
function where the process was scheduled in/out, or the
atom <strong>undefined</strong>.</p> <p>If a <strong>port()</strong>, the
tuples <strong>{timeout, Millis}</strong> and <strong>{port_op,Op}</strong>
are present. <strong>Op</strong> is one of <strong>proc_sig</strong>,
<strong>timeout</strong>, <strong>input</strong>, <strong>output</strong>,
<strong>event</strong>, or <strong>dist_cmd</strong>, depending on which
driver callback was executing.</p> <p><strong>proc_sig</strong> is an
internal operation and is never to appear, while the
others represent the corresponding driver callbacks
<strong>timeout</strong>, <strong>ready_input</strong>, <strong>ready_output</strong>,
<strong>event</strong>, and <strong>outputv</strong> (when the port
is used by distribution). Value <strong>Millis</strong> in
tuple <strong>timeout</strong> informs about the
uninterrupted execution time of the process or port, which
always is equal to or higher than the <strong>Time</strong> value
supplied when starting the trace. New tuples can be
added to the <strong>Info</strong> list in a future release. The
order of the tuples in the list can be changed at any
time without prior notice.</p> <p>This can be used to detect problems with NIFs or
drivers that take too long to execute. 1 ms is
considered a good maximum time for a driver callback
or a NIF. However, a time-sharing system is usually to
consider everything &lt; 100 ms as "possible" and
fairly "normal". However, longer schedule times can
indicate swapping or a misbehaving NIF/driver.
Misbehaving NIFs and drivers can cause bad resource
utilization and bad overall system performance.</p> </dd><dt><strong>{large_heap, Size}</strong></dt><dd> <p>If a garbage collection in the system results in
the allocated size of a heap being at least <strong>Size</strong>
words, a message <strong>{monitor, GcPid, large_heap, Info}</strong>
is sent to <strong><span class="anno">MonitorPid</span></strong>.
<strong>GcPid</strong> and <strong>Info</strong>
are the same as for <strong>long_gc</strong> earlier, except that
the tuple tagged with <strong>timeout</strong> is not present.</p> <p>The monitor message is sent if the sum of the sizes of
all memory blocks allocated for all heap generations after
a garbage collection is equal to or higher than <strong>Size</strong>.</p> <p>When a process is killed by
<a href="#process_flag_max_heap_size">process_flag_max_heap_size</a>, it is killed before the
garbage collection is complete and thus no large heap message
is sent.</p> </dd><dt><strong>busy_port</strong></dt><dd> <p>If a process in the system gets suspended because it
sends to a busy port, a message
<strong>{monitor, SusPid, busy_port, Port}</strong> is sent to
<strong><span class="anno">MonitorPid</span></strong>. <strong>SusPid</strong> is the pid
that got suspended when sending to <strong>Port</strong>.</p> </dd><dt><strong>busy_dist_port</strong></dt><dd> <p>If a process in the system gets suspended because it
sends to a process on a remote node whose inter-node
communication was handled by a busy port, a message
<strong>{monitor, SusPid, busy_dist_port, Port}</strong> is sent to
<strong><span class="anno">MonitorPid</span></strong>. <strong>SusPid</strong> is the pid
that got suspended when sending through the inter-node
communication port <strong>Port</strong>.</p> </dd></dl><p>Returns the previous system monitor settings just like
<a href="#system_monitor/0">system_monitor/0</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If a monitoring process gets so large that it itself
starts to cause system monitor messages when garbage
collecting, the messages enlarge the process
message queue and probably make the problem worse.</p><p>Keep the monitoring process neat and do not set the system
monitor limits too tight.</p></div><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">MonitorPid</span></strong> does not exist.</dd><dt><strong>badarg</strong></dt><dd>If <strong><span class="anno">MonitorPid</span></strong> is not a local process.</dd></dl><h3>system_profile/0</h3><p>Current system profiling settings.</p><ul><li>system_profile_option</li></ul><p>Returns the current system profiling settings set by
<a href="#system_profile/2">system_profile/2</a>
as <strong>{<span class="anno">ProfilerPid</span>, <span class="anno">Options</span>}</strong>,
or <strong>undefined</strong> if there
are no settings. The order of the options can be different
from the one that was set.</p><h3>system_profile/2</h3><p>Current system profiling settings.</p><ul><li>system_profile_option</li></ul><p>Sets system profiler options. <strong><span class="anno">ProfilerPid</span></strong>
is a local process identifier (pid) or port receiving profiling
messages. The receiver is excluded from all profiling.
The second argument is a list of profiling options:</p><dl><dt><strong>exclusive</strong></dt><dd> <p>If a synchronous call to a port from a process is done, the
calling process is considered not runnable during the call
runtime to the port. The calling process is notified as
<strong>inactive</strong>, and later <strong>active</strong> when the port
callback returns.</p> </dd><dt><strong>monotonic_timestamp</strong></dt><dd> <p>Time stamps in profile messages use
<a href="./time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a>. The time stamp (Ts) has the same
format and value as produced by
<strong>erlang:monotonic_time(nanosecond)</strong>.</p> </dd><dt><strong>runnable_procs</strong></dt><dd> <p>If a process is put into or removed from the run queue, a
message, <strong>{profile, Pid, State, Mfa, Ts}</strong>, is sent to
<strong><span class="anno">ProfilerPid</span></strong>. Running processes that
are reinserted into the run queue after having been
pre-empted do not trigger this message.</p> </dd><dt><strong>runnable_ports</strong></dt><dd> <p>If a port is put into or removed from the run queue, a 
message, <strong>{profile, Port, State, 0, Ts}</strong>, is sent to
<strong><span class="anno">ProfilerPid</span></strong>.</p> </dd><dt><strong>scheduler</strong></dt><dd> <p>If a scheduler is put to sleep or awoken, a message,
<strong>{profile, scheduler, Id, State, NoScheds, Ts}</strong>, is
sent to <strong><span class="anno">ProfilerPid</span></strong>.</p> </dd><dt><strong>strict_monotonic_timestamp</strong></dt><dd> <p>Time stamps in profile messages consist of
<a href="./time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a> and a monotonically increasing
integer. The time stamp (Ts) has the same format and value
as produced by <strong>{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}</strong>.</p> </dd><dt><strong>timestamp</strong></dt><dd> <p>Time stamps in profile messages include a
time stamp (Ts) that has the same form as returned by
<strong>erlang:now()</strong>. This is also the default if no
time stamp flag is specified. If <strong>cpu_timestamp</strong> has
been enabled through
<a href="#trace/3">trace/3</a>,
this also effects the time stamp produced in profiling messages
when flag <strong>timestamp</strong> is enabled.</p> </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><strong>erlang:system_profile</strong> behavior can change
in a future release.</p></div><h3>system_time/0</h3><p>Current Erlang system time.</p><p>Returns current
<a href="./time_correction#Erlang_System_Time"> Erlang system time</a> in <strong>native</strong>
<a href="#type_time_unit">time unit</a>.</p><p>Calling <strong>erlang:system_time()</strong> is equivalent to
<a href="#monotonic_time/0">monotonic_time/0</a><strong> + </strong><a href="#time_offset/0">time_offset/0</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This time is <em>not</em> a monotonically increasing time
in the general case. For more information, see the documentation of
<a href="./time_correction#Time_Warp_Modes"> time warp modes</a> in the User's Guide.</p></div><h3>system_time/1</h3><p>Current Erlang system time.</p><p>Returns current
<a href="./time_correction#Erlang_System_Time"> Erlang system time</a>
converted into the <strong><span class="anno">Unit</span></strong> passed as argument.</p><p>Calling <strong>erlang:system_time(<span class="anno">Unit</span>)</strong> is equivalent
to <a href="#convert_time_unit/3">convert_time_unit/3</a><strong>(</strong><a href="#system_time/0">system_time/0</a><strong>, native, <span class="anno">Unit</span>)</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This time is <em>not</em> a monotonically increasing time
in the general case. For more information, see the documentation of
<a href="./time_correction#Time_Warp_Modes"> time warp modes</a> in the User's Guide.</p></div><h3>term_to_binary/1</h3><p>Encode a term to an Erlang external term format binary. </p><p>Returns a binary data object that is the result of encoding
<strong><span class="anno">Term</span></strong> according to the
<a href="./erl_ext_dist">Erlang external term format.</a></p><p>This can be used for various purposes, for example,
writing a term to a file in an efficient way, or sending an
Erlang term to some type of communications channel not
supported by distributed Erlang.</p><pre>
&gt; <span class="input">Bin = term_to_binary(hello).</span>
&lt;&lt;131,100,0,5,104,101,108,108,111&gt;&gt;
&gt; <span class="input">hello = binary_to_term(Bin).</span>
hello
</pre><p>See also <a href="#binary_to_term/1">binary_to_term/1</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>There is no guarantee that this function will return
the same encoded representation for the same term.</p></div><h3>term_to_binary/2</h3><p>Encode a term to en Erlang external term format binary. </p><p>Returns a binary data object that is the result of encoding
<strong><span class="anno">Term</span></strong> according to the Erlang external
term format.</p><p>If option <strong>compressed</strong> is provided, the external term
format is compressed. The compressed format is automatically
recognized by <strong>binary_to_term/1</strong> as from Erlang/OTP R7B.</p><p>A compression level can be specified by giving option
<strong>{compressed, <span class="anno">Level</span>}</strong>.
<strong><span class="anno">Level</span></strong> is an integer
with range 0..9, where:</p><ul><li><p><strong>0</strong> - No compression is done (it is the same as
giving no <strong>compressed</strong> option).</p></li><li><p><strong>1</strong> - Takes least time but may not compress
as well as the higher levels.</p></li><li><p><strong>6</strong> - Default level when option <strong>compressed</strong>
is provided.</p></li><li><p><strong>9</strong> - Takes most time and tries to produce a smaller
result. Notice "tries" in the preceding sentence; depending
on the input term, level 9 compression either does or does
not produce a smaller result than level 1 compression.</p></li></ul><p>Option <strong>{minor_version, <span class="anno">Version</span>}</strong>
can be used to control some
encoding details. This option was introduced in Erlang/OTP R11B-4.
The valid values for <strong><span class="anno">Version</span></strong> are:</p><dl><dt><strong>0</strong></dt><dd> <p>Floats are encoded using a textual representation.
This option is useful to ensure that releases before Erlang/OTP
R11B-4 can decode resulting binary.</p> <p>This version encode atoms that can be represented by a
latin1 string using latin1 encoding while only atoms that
cannot be represented by latin1 are encoded using utf8.</p> </dd><dt><strong>1</strong></dt><dd> <p>This is as of Erlang/OTP 17.0 the default. It forces any floats
in the term to be encoded in a more space-efficient and exact way
(namely in the 64-bit IEEE format, rather than converted to a
textual representation). As from Erlang/OTP R11B-4,
<strong>binary_to_term/1</strong> can decode this representation.</p> <p>This version encode atoms that can be represented by a
latin1 string using latin1 encoding while only atoms that
cannot be represented by latin1 are encoded using utf8.</p> </dd><dt><strong>2</strong></dt><dd> <p>Drops usage of the latin1 atom encoding and unconditionally
use utf8 encoding for all atoms. This will be changed to the
default in a future major release of Erlang/OTP. Erlang/OTP
systems as of R16B can decode this representation.</p> </dd></dl><p>See also <a href="#binary_to_term/1">binary_to_term/1</a>.</p><h3>throw/1</h3><p>Throw an exception.</p><p>A non-local return from a function. If evaluated within a
<strong>catch</strong>, <strong>catch</strong> returns value <strong><span class="anno">Any</span></strong>.
Example:</p><pre>
&gt; <span class="input">catch throw({hello, there}).</span>
{hello,there}</pre><p>Failure: <strong>nocatch</strong> if not evaluated within a catch.</p><h3>time/0</h3><p>Current time.</p><p>Returns the current time as <strong>{Hour, Minute, Second}</strong>.</p><p>The time zone and Daylight Saving Time correction depend on
the underlying OS. Example:</p><pre>
&gt; <span class="input">time().</span>
{9,42,44}</pre><h3>time_offset/0</h3><p>Current time offset.</p><p>Returns the current time offset between
<a href="./time_correction#Erlang_Monotonic_Time"> Erlang monotonic time</a> and
<a href="./time_correction#Erlang_System_Time"> Erlang system time</a> in
<strong>native</strong> <a href="#type_time_unit">time unit</a>.
Current time offset added to an Erlang monotonic time gives
corresponding Erlang system time.</p><p>The time offset may or may not change during operation depending
on the <a href="./time_correction#Time_Warp_Modes">time warp mode</a> used.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>A change in time offset can be observed at slightly
different points in time by different processes.</p><p>If the runtime system is in
<a href="./time_correction#Multi_Time_Warp_Mode">multi-time warp mode</a>, the time offset is changed when
the runtime system detects that the
<a href="./time_correction#OS_System_Time">OS system time</a> has changed. The runtime system will, however,
not detect this immediately when it occurs. A task checking
the time offset is scheduled to execute at least once a minute;
so, under normal operation this is to be detected within a
minute, but during heavy load it can take longer time.</p></div><h3>time_offset/1</h3><p>Current time offset.</p><p>Returns the current time offset between
<a href="./time_correction#Erlang_Monotonic_Time"> Erlang monotonic time</a> and
<a href="./time_correction#Erlang_System_Time"> Erlang system time</a>
converted into the <strong><span class="anno">Unit</span></strong> passed as argument.</p><p>Same as calling
<a href="#convert_time_unit/3">convert_time_unit/3</a><strong>(</strong><a href="#time_offset/0">time_offset/0</a><strong>, native, <span class="anno">Unit</span>)</strong>
however optimized for commonly used <strong><span class="anno">Unit</span></strong>s.</p><h3>timestamp/0</h3><p>Current Erlang System time.</p><ul><li>timestamp</li></ul><p>Returns current
<a href="./time_correction#Erlang_System_Time"> Erlang system time</a>
on the format <strong>{MegaSecs, Secs, MicroSecs}</strong>. This format is 
the same as <a href="../kernel/os#timestamp/0">kernel/os#timestamp/0</a>
and the deprecated <a href="#now/0">now/0</a>
use. The reason for the existence of <strong>erlang:timestamp()</strong> is
purely to simplify use for existing code that assumes this time stamp
format. Current Erlang system time can more efficiently be retrieved
in the time unit of your choice using
<a href="#system_time/1">system_time/1</a>.</p><p>The <strong>erlang:timestamp()</strong> BIF is equivalent to:</p><pre><code class="">
timestamp() -&gt;
    ErlangSystemTime = erlang:system_time(microsecond),
    MegaSecs = ErlangSystemTime div 1000000000000,
    Secs = ErlangSystemTime div 1000000 - MegaSecs*1000000,
    MicroSecs = ErlangSystemTime rem 1000000,
    {MegaSecs, Secs, MicroSecs}.</code></pre><p>It, however, uses a native implementation that does
not build garbage on the heap and with slightly better
performance.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This time is <em>not</em> a monotonically increasing time
in the general case. For more information, see the documentation of
<a href="./time_correction#Time_Warp_Modes"> time warp modes</a> in the User's Guide.</p></div><h3>tl/1</h3><p>Tail of a list.</p><p>Returns the tail of <strong><span class="anno">List</span></strong>, that is,
the list minus the first element, for example:</p><pre>
&gt; <span class="input">tl([geesties, guilies, beasties]).</span>
[guilies, beasties]</pre><p>Allowed in guard tests.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">List</span></strong>
is the empty list <strong>[]</strong>.</p><h3>trace/3</h3><p>Set trace flags for a process or processes.</p><ul><li>trace_flag</li></ul><p>Turns on (if <strong><span class="anno">How</span> == true</strong>) or off (if
<strong><span class="anno">How</span> == false</strong>) the trace flags in
<strong><span class="anno">FlagList</span></strong> for
the process or processes represented by
<strong><span class="anno">PidPortSpec</span></strong>.</p><p><strong><span class="anno">PidPortSpec</span></strong> is either a process identifier
(pid) for a local process, a port identifier,
or one of the following atoms:</p><dl><dt><strong>all</strong></dt><dd>All currently existing processes and ports and all that will be created in the future. </dd><dt><strong>processes</strong></dt><dd>All currently existing processes and all that will be created in the future. </dd><dt><strong>ports</strong></dt><dd>All currently existing ports and all that will be created in the future. </dd><dt><strong>existing</strong></dt><dd>All currently existing processes and ports. </dd><dt><strong>existing_processes</strong></dt><dd>All currently existing processes. </dd><dt><strong>existing_ports</strong></dt><dd>All currently existing ports. </dd><dt><strong>new</strong></dt><dd>All processes and ports that will be created in the future. </dd><dt><strong>new_processes</strong></dt><dd>All processes that will be created in the future. </dd><dt><strong>new_ports</strong></dt><dd>All ports that will be created in the future. </dd></dl><p><strong><span class="anno">FlagList</span></strong> can contain any number of the
following flags (the "message tags" refers to the list of
<a href="#trace_3_trace_messages">trace_3_trace_messages</a>):</p><dl><dt><strong>all</strong></dt><dd> <p>Sets all trace flags except <strong>tracer</strong> and
<strong>cpu_timestamp</strong>, which are in their nature different
than the others.</p> </dd><dt><strong>send</strong></dt><dd> <p>Traces sending of messages.</p> <p>Message tags:
<a href="#trace_3_trace_messages_send">trace_3_trace_messages_send</a> and
<a href="#trace_3_trace_messages_send_to_non_existing_process">trace_3_trace_messages_send_to_non_existing_process</a>.</p> </dd><dt><strong>'receive'</strong></dt><dd> <p>Traces receiving of messages.</p> <p>Message tags:
<a href="#trace_3_trace_messages_receive">trace_3_trace_messages_receive</a>.</p> </dd><dt><strong>call</strong></dt><dd> <p>Traces certain function calls. Specify which function
calls to trace by calling <a href="#trace_pattern/3">trace_pattern/3</a>.</p> <p>Message tags:
<a href="#trace_3_trace_messages_call">trace_3_trace_messages_call</a> and
<a href="#trace_3_trace_messages_return_from">trace_3_trace_messages_return_from</a>.</p> </dd><dt><strong>silent</strong></dt><dd> <p>Used with the <strong>call</strong> trace flag.
The <strong>call</strong>, <strong>return_from</strong>, and <strong>return_to</strong>
trace messages are inhibited if this flag is set, but they
are executed as normal if there are match specifications.</p> <p>Silent mode is inhibited by executing
<strong>erlang:trace(_, false, [silent|_])</strong>,
or by a match specification executing the function
<strong>{silent, false}</strong>.</p> <p>The <strong>silent</strong> trace flag facilitates setting up
a trace on many or even all processes in the system.
The trace can then be activated and deactivated using the match
specification function <strong>{silent,Bool}</strong>, giving
a high degree of control of which functions with which 
arguments that trigger the trace.</p> <p>Message tags:
<a href="#trace_3_trace_messages_call">trace_3_trace_messages_call</a>,
<a href="#trace_3_trace_messages_return_from">trace_3_trace_messages_return_from</a>, and
<a href="#trace_3_trace_messages_return_to">trace_3_trace_messages_return_to</a>. Or rather, the absence of.</p> </dd><dt><strong>return_to</strong></dt><dd> <p>Used with the <strong>call</strong> trace flag.
Traces the return from a traced function back to
its caller. Only works for functions traced with
option <strong>local</strong> to <a href="#trace_pattern/3">trace_pattern/3</a>.</p> <p>The semantics is that a trace message is sent when a
call traced function returns, that is, when a
chain of tail recursive calls ends. Only one trace
message is sent per chain of tail recursive calls,
so the properties of tail recursiveness for
function calls are kept while tracing with this flag.
Using <strong>call</strong> and <strong>return_to</strong> trace together
makes it possible to know exactly in which function a
process executes at any time.</p> <p>To get trace messages containing return values from
functions, use the <strong>{return_trace}</strong> match
specification action instead.</p> <p>Message tags:
<a href="#trace_3_trace_messages_return_to">trace_3_trace_messages_return_to</a>.</p> </dd><dt><strong>procs</strong></dt><dd> <p>Traces process-related events.</p> <p>Message tags:
<a href="#trace_3_trace_messages_spawn">trace_3_trace_messages_spawn</a>,
<a href="#trace_3_trace_messages_spawned">trace_3_trace_messages_spawned</a>,
<a href="#trace_3_trace_messages_exit">trace_3_trace_messages_exit</a>,
<a href="#trace_3_trace_messages_register">trace_3_trace_messages_register</a>,
<a href="#trace_3_trace_messages_unregister">trace_3_trace_messages_unregister</a>,
<a href="#trace_3_trace_messages_link">trace_3_trace_messages_link</a>,
<a href="#trace_3_trace_messages_unlink">trace_3_trace_messages_unlink</a>,
<a href="#trace_3_trace_messages_getting_linked">trace_3_trace_messages_getting_linked</a>, and
<a href="#trace_3_trace_messages_getting_unlinked">trace_3_trace_messages_getting_unlinked</a>.</p> </dd><dt><strong>ports</strong></dt><dd> <p>Traces port-related events.</p> <p>Message tags:
<a href="#trace_3_trace_messages_open">trace_3_trace_messages_open</a>,
<a href="#trace_3_trace_messages_closed">trace_3_trace_messages_closed</a>,
<a href="#trace_3_trace_messages_register">trace_3_trace_messages_register</a>,
<a href="#trace_3_trace_messages_unregister">trace_3_trace_messages_unregister</a>,
<a href="#trace_3_trace_messages_getting_linked">trace_3_trace_messages_getting_linked</a>, and
<a href="#trace_3_trace_messages_getting_unlinked">trace_3_trace_messages_getting_unlinked</a>.</p> </dd><dt><strong>running</strong></dt><dd> <p>Traces scheduling of processes.</p> <p>Message tags:
<a href="#trace_3_trace_messages_in_proc">trace_3_trace_messages_in_proc</a> and
<a href="#trace_3_trace_messages_out_proc">trace_3_trace_messages_out_proc</a>.</p> </dd><dt><strong>exiting</strong></dt><dd> <p>Traces scheduling of exiting processes.</p> <p>Message tags:
<a href="#trace_3_trace_messages_in_exiting_proc">trace_3_trace_messages_in_exiting_proc</a>,
<a href="#trace_3_trace_messages_out_exiting_proc">trace_3_trace_messages_out_exiting_proc</a>, and
<a href="#trace_3_trace_messages_out_exited_proc">trace_3_trace_messages_out_exited_proc</a>.</p> </dd><dt><strong>running_procs</strong></dt><dd> <p>Traces scheduling of processes just like <strong>running</strong>.
However, this option also includes schedule events when the
process executes within the context of a port without
being scheduled out itself.</p> <p>Message tags:
<a href="#trace_3_trace_messages_in_proc">trace_3_trace_messages_in_proc</a> and
<a href="#trace_3_trace_messages_out_proc">trace_3_trace_messages_out_proc</a>.</p> </dd><dt><strong>running_ports</strong></dt><dd> <p>Traces scheduling of ports.</p> <p>Message tags:
<a href="#trace_3_trace_messages_in_port">trace_3_trace_messages_in_port</a> and
<a href="#trace_3_trace_messages_out_port">trace_3_trace_messages_out_port</a>.</p> </dd><dt><strong>garbage_collection</strong></dt><dd> <p>Traces garbage collections of processes.</p> <p>Message tags:
<a href="#trace_3_trace_messages_gc_minor_start">trace_3_trace_messages_gc_minor_start</a>,
<a href="#trace_3_trace_messages_gc_max_heap_size">trace_3_trace_messages_gc_max_heap_size</a>, and
<a href="#trace_3_trace_messages_gc_minor_end">trace_3_trace_messages_gc_minor_end</a>.</p> </dd><dt><strong>timestamp</strong></dt><dd> <p>Includes a time stamp in all trace messages. The
time stamp (Ts) has the same form as returned by
<strong>erlang:now()</strong>.</p> </dd><dt><strong>cpu_timestamp</strong></dt><dd> <p>A global trace flag for the Erlang node that makes all
trace time stamps using flag <strong>timestamp</strong> to be
in CPU time, not wall clock time. That is, <strong>cpu_timestamp</strong>
is not be used if <strong>monotonic_timestamp</strong> or
<strong>strict_monotonic_timestamp</strong> is enabled.
Only allowed with <strong><span class="anno">PidPortSpec</span>==all</strong>. If the
host machine OS does not support high-resolution
CPU time measurements, <strong>trace/3</strong> exits with
<strong>badarg</strong>. Notice that most OS do
not synchronize this value across cores, so be prepared
that time can seem to go backwards when using this option.</p> </dd><dt><strong>monotonic_timestamp</strong></dt><dd> <p>Includes an
<a href="./time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a> time stamp in all trace messages. The
time stamp (Ts) has the same format and value as produced by
<a href="#monotonic_time-1">monotonic_time-1</a>.
This flag overrides flag <strong>cpu_timestamp</strong>.</p> </dd><dt><strong>strict_monotonic_timestamp</strong></dt><dd> <p>Includes an time stamp consisting of
<a href="./time_correction#Erlang_Monotonic_Time">Erlang monotonic time</a> and a monotonically increasing
integer in all trace messages. The time stamp (Ts) has the
same format and value as produced by <strong>{</strong>
<a href="#monotonic_time-1">monotonic_time-1</a><strong>,</strong>
<a href="#unique_integer-1">unique_integer-1</a><strong>}</strong>.
This flag overrides flag <strong>cpu_timestamp</strong>.</p> </dd><dt><strong>arity</strong></dt><dd> <p>Used with the <strong>call</strong> trace flag.
<strong>{M, F, Arity}</strong> is specified instead of
<strong>{M, F, Args}</strong> in call trace messages.</p> </dd><dt><strong>set_on_spawn</strong></dt><dd> <p>Makes any process created by a traced process inherit
its trace flags, including flag <strong>set_on_spawn</strong>.</p> </dd><dt><strong>set_on_first_spawn</strong></dt><dd> <p>Makes the first process created by a traced process
inherit its trace flags, excluding flag
<strong>set_on_first_spawn</strong>.</p> </dd><dt><strong>set_on_link</strong></dt><dd> <p>Makes any process linked by a traced process inherit its
trace flags, including flag <strong>set_on_link</strong>.</p> </dd><dt><strong>set_on_first_link</strong></dt><dd> <p>Makes the first process linked to by a traced process
inherit its trace flags, excluding flag
<strong>set_on_first_link</strong>.</p> </dd><dt><strong>{tracer, Tracer}</strong></dt><dd> <p>Specifies where to send the trace messages. <strong>Tracer</strong>
must be the process identifier of a local process
or the port identifier of a local port.</p> </dd><dt><strong>{tracer, TracerModule, TracerState}</strong></dt><dd> <p>Specifies that a tracer module is to be called
instead of sending a trace message. The tracer module
can then ignore or change the trace message. For more details
on how to write a tracer module, see
<a href="./erl_tracer">erts/erl_tracer</a>.</p> </dd></dl><p>If no <strong>tracer</strong> is specified, the calling process
receives all the trace messages.</p><p>The effect of combining <strong>set_on_first_link</strong> with
<strong>set_on_link</strong> is the same as
<strong>set_on_first_link</strong> alone. Likewise for
<strong>set_on_spawn</strong> and <strong>set_on_first_spawn</strong>.</p><p>The tracing process receives the <em>trace messages</em> described
in the following list. <strong>Pid</strong> is the process identifier of the
traced process in which the traced event has occurred. The
third tuple element is the message tag.</p><p>If flag <strong>timestamp</strong>, <strong>strict_monotonic_timestamp</strong>, or
<strong>monotonic_timestamp</strong> is specified, the first tuple
element is <strong>trace_ts</strong> instead, and the time stamp
is added as an extra element last in the message tuple. If
multiple time stamp flags are passed, <strong>timestamp</strong> has
precedence over <strong>strict_monotonic_timestamp</strong>, which
in turn has precedence over <strong>monotonic_timestamp</strong>. All
time stamp flags are remembered, so if two are passed
and the one with highest precedence later is disabled,
the other one becomes active.</p><p>Trace messages:</p><a name="trace_3_trace_messages"></a><dl><dt> <a name="trace_3_trace_messages_send"></a> <strong>{trace, PidPort, send, Msg, To}</strong> </dt><dd> <p>When <strong>PidPort</strong> sends message <strong>Msg</strong> to
process <strong>To</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_send_to_non_existing_process"></a> <strong>{trace, PidPort, send_to_non_existing_process, Msg, To}</strong> </dt><dd> <p>When <strong>PidPort</strong> sends message <strong>Msg</strong> to
the non-existing process <strong>To</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_receive"></a> <strong>{trace, PidPort, 'receive', Msg}</strong> </dt><dd> <p>When <strong>PidPort</strong> receives message <strong>Msg</strong>.
If <strong>Msg</strong> is set to time-out, a receive
statement can have timed out, or the process received
a message with the payload <strong>timeout</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_call"></a> <strong>{trace, Pid, call, {M, F, Args}}</strong> </dt><dd> <p>When <strong>Pid</strong> calls a traced function. The return
values of calls are never supplied, only the call and its
arguments.</p> <p>Trace flag <strong>arity</strong> can be used to
change the contents of this message, so that <strong>Arity</strong>
is specified instead of <strong>Args</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_return_to"></a> <strong>{trace, Pid, return_to, {M, F, Arity}}</strong> </dt><dd> <p>When <strong>Pid</strong> returns <em>to</em> the specified
function. This trace message is sent if both
the flags <strong>call</strong> and <strong>return_to</strong> are set,
and the function is set to be traced on <em>local</em>
function calls. The message is only sent when returning
from a chain of tail recursive function calls, where at
least one call generated a <strong>call</strong> trace message
(that is, the functions match specification matched, and
<strong>{message, false}</strong> was not an action).</p> </dd><dt> <a name="trace_3_trace_messages_return_from"></a> <strong>{trace, Pid, return_from, {M, F, Arity}, ReturnValue}</strong> </dt><dd> <p>When <strong>Pid</strong> returns <em>from</em> the specified
function. This trace message is sent if flag <strong>call</strong>
is set, and the function has a match specification
with a <strong>return_trace</strong> or <strong>exception_trace</strong> action.</p> </dd><dt> <a name="trace_3_trace_messages_exception_from"></a> <strong>{trace, Pid, exception_from, {M, F, Arity}, {Class, Value}}</strong> </dt><dd> <p>When <strong>Pid</strong> exits <em>from</em> the specified
function because of an exception. This trace message is
sent if flag <strong>call</strong> is set, and the function has 
a match specification with an <strong>exception_trace</strong> action.</p> </dd><dt> <a name="trace_3_trace_messages_spawn"></a> <strong>{trace, Pid, spawn, Pid2, {M, F, Args}}</strong> </dt><dd> <p>When <strong>Pid</strong> spawns a new process <strong>Pid2</strong> with
the specified function call as entry point.</p> <p><strong>Args</strong> is supposed to be the argument list,
but can be any term if the spawn is erroneous.</p> </dd><dt> <a name="trace_3_trace_messages_spawned"></a> <strong>{trace, Pid, spawned, Pid2, {M, F, Args}}</strong> </dt><dd> <p>When <strong>Pid</strong> is spawned by process <strong>Pid2</strong> with
the specified function call as entry point.</p> <p><strong>Args</strong> is supposed to be the argument list,
but can be any term if the spawn is erroneous.</p> </dd><dt> <a name="trace_3_trace_messages_exit"></a> <strong>{trace, Pid, exit, Reason}</strong> </dt><dd> <p>When <strong>Pid</strong> exits with reason <strong>Reason</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_register"></a> <strong>{trace, PidPort, register, RegName}</strong> </dt><dd> <p>When <strong>PidPort</strong> gets the name <strong>RegName</strong> registered.</p> </dd><dt> <a name="trace_3_trace_messages_unregister"></a> <strong>{trace, PidPort, unregister, RegName}</strong> </dt><dd> <p>When <strong>PidPort</strong> gets the name <strong>RegName</strong> unregistered.
This is done automatically when a registered
process or port exits.</p> </dd><dt> <a name="trace_3_trace_messages_link"></a> <strong>{trace, Pid, link, Pid2}</strong> </dt><dd> <p>When <strong>Pid</strong> links to a process <strong>Pid2</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_unlink"></a> <strong>{trace, Pid, unlink, Pid2}</strong> </dt><dd> <p>When <strong>Pid</strong> removes the link from a process
<strong>Pid2</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_getting_linked"></a> <strong>{trace, PidPort, getting_linked, Pid2}</strong> </dt><dd> <p>When <strong>PidPort</strong> gets linked to a process <strong>Pid2</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_getting_unlinked"></a> <strong>{trace, PidPort, getting_unlinked, Pid2}</strong> </dt><dd> <p>When <strong>PidPort</strong> gets unlinked from a process <strong>Pid2</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_exit"></a> <strong>{trace, Pid, exit, Reason}</strong> </dt><dd> <p>When <strong>Pid</strong> exits with reason <strong>Reason</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_open"></a> <strong>{trace, Port, open, Pid, Driver}</strong> </dt><dd> <p>When <strong>Pid</strong> opens a new port <strong>Port</strong> with
the running <strong>Driver</strong>.</p> <p><strong>Driver</strong> is the name of the driver as an atom.</p> </dd><dt> <a name="trace_3_trace_messages_closed"></a> <strong>{trace, Port, closed, Reason}</strong> </dt><dd> <p>When <strong>Port</strong> closes with <strong>Reason</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_in_proc"></a> <a name="trace_3_trace_messages_in_exiting_proc"></a> <strong>{trace, Pid, in | in_exiting, {M, F, Arity} | 0}</strong> </dt><dd> <p>When <strong>Pid</strong> is scheduled to run. The process
runs in function <strong>{M, F, Arity}</strong>. On some rare
occasions, the current function cannot be determined,
then the last element is <strong>0</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_out_proc"></a> <a name="trace_3_trace_messages_out_exiting_proc"></a> <a name="trace_3_trace_messages_out_exited_proc"></a> <strong>{trace, Pid, out | out_exiting | out_exited, {M, F, Arity} | 0}</strong> </dt><dd> <p>When <strong>Pid</strong> is scheduled out. The process was
running in function {M, F, Arity}. On some rare occasions,
the current function cannot be determined, then the last
element is <strong>0</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_in_port"></a> <strong>{trace, Port, in, Command | 0}</strong> </dt><dd> <p>When <strong>Port</strong> is scheduled to run. <strong>Command</strong> is the
first thing the port will execute, it can however run several
commands before being scheduled out. On some rare
occasions, the current function cannot be determined,
then the last element is <strong>0</strong>.</p> <p>The possible commands are <strong>call</strong>, <strong>close</strong>,
<strong>command</strong>, <strong>connect</strong>, <strong>control</strong>, <strong>flush</strong>,
<strong>info</strong>, <strong>link</strong>, <strong>open</strong>, and <strong>unlink</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_out_port"></a> <strong>{trace, Port, out, Command | 0}</strong> </dt><dd> <p>When <strong>Port</strong> is scheduled out. The last command run
was <strong>Command</strong>. On some rare occasions,
the current function cannot be determined, then the last
element is <strong>0</strong>. <strong>Command</strong> can contain the same
commands as <strong>in</strong></p> </dd><dt> <a name="trace_3_trace_messages_gc_minor_start"></a> <strong>{trace, Pid, gc_minor_start, Info}</strong> </dt><dd> <a name="gc_minor_start"></a> <p>Sent when a young garbage collection is about to be started.
<strong>Info</strong> is a list of two-element tuples, where
the first element is a key, and the second is the value.
Do not depend on any order of the tuples.
The following keys are defined:</p> <dl><dt><strong>heap_size</strong></dt><dd>The size of the used part of the heap.</dd><dt><strong>heap_block_size</strong></dt><dd>The size of the memory block used for storing the heap and the stack.</dd><dt><strong>old_heap_size</strong></dt><dd>The size of the used part of the old heap.</dd><dt><strong>old_heap_block_size</strong></dt><dd>The size of the memory block used for storing the old heap.</dd><dt><strong>stack_size</strong></dt><dd>The size of the stack.</dd><dt><strong>recent_size</strong></dt><dd>The size of the data that survived the previous garbage collection.</dd><dt><strong>mbuf_size</strong></dt><dd>The combined size of message buffers associated with the process.</dd><dt><strong>bin_vheap_size</strong></dt><dd>The total size of unique off-heap binaries referenced from the process heap.</dd><dt><strong>bin_vheap_block_size</strong></dt><dd>The total size of binaries allowed in the virtual heap in the process before doing a garbage collection.</dd><dt><strong>bin_old_vheap_size</strong></dt><dd>The total size of unique off-heap binaries referenced from the process old heap.</dd><dt><strong>bin_old_vheap_block_size</strong></dt><dd>The total size of binaries allowed in the virtual old heap in the process before doing a garbage collection.</dd></dl> <p>All sizes are in words.</p> </dd><dt> <a name="trace_3_trace_messages_gc_max_heap_size"></a> <strong>{trace, Pid, gc_max_heap_size, Info}</strong> </dt><dd> <p>Sent when the <a href="#process_flag_max_heap_size">process_flag_max_heap_size</a>
is reached during garbage collection. <strong>Info</strong> contains the
same kind of list as in message <strong>gc_start</strong>,
but the sizes reflect the sizes that triggered
<strong>max_heap_size</strong> to be reached.</p> </dd><dt> <a name="trace_3_trace_messages_gc_minor_end"></a> <strong>{trace, Pid, gc_minor_end, Info}</strong> </dt><dd> <p>Sent when young garbage collection is finished. <strong>Info</strong>
contains the same kind of list as in message
<strong>gc_minor_start</strong>,
but the sizes reflect the new sizes after
garbage collection.</p> </dd><dt> <a name="trace_3_trace_messages_gc_major_start"></a> <strong>{trace, Pid, gc_major_start, Info}</strong> </dt><dd> <p>Sent when fullsweep garbage collection is about to be started.
<strong>Info</strong> contains the same kind of list as in message
<strong>gc_minor_start</strong>.</p> </dd><dt> <a name="trace_3_trace_messages_gc_major_end"></a> <strong>{trace, Pid, gc_major_end, Info}</strong> </dt><dd> <p>Sent when fullsweep garbage collection is finished. <strong>Info</strong>
contains the same kind of list as in message
<strong>gc_minor_start</strong>, but the sizes reflect the new sizes after
a fullsweep garbage collection.</p> </dd></dl><p>If the tracing process/port dies or the tracer module returns
<strong>remove</strong>, the flags are silently removed.</p><p>Each process can only be traced by one tracer. Therefore,
attempts to trace an already traced process fail.</p><p>Returns a number indicating the number of processes that
matched <strong><span class="anno">PidPortSpec</span></strong>.
If <strong><span class="anno">PidPortSpec</span></strong> is a process
identifier, the return value is <strong>1</strong>.
If <strong><span class="anno">PidPortSpec</span></strong>
is <strong>all</strong> or <strong>existing</strong>, the return value is
the number of processes running.
If <strong><span class="anno">PidPortSpec</span></strong> is <strong>new</strong>, the return value is
<strong>0</strong>.</p><p>Failure: <strong>badarg</strong> if the specified arguments are
not supported. For example, <strong>cpu_timestamp</strong> is not
supported on all platforms.</p><h3>trace_delivered/1</h3><p>Notification when trace has been delivered.</p><p>The delivery of trace messages (generated by
<a href="#trace/3">trace/3</a>,
<a href="./seq_trace">kernel/seq_trace</a>,
or <a href="#system_profile/2">system_profile/2</a>)
is dislocated on the time-line
compared to other events in the system. If you know that
<strong><span class="anno">Tracee</span></strong> has passed some specific point
in its execution,
and you want to know when at least all trace messages
corresponding to events up to this point have reached the
tracer, use <strong>erlang:trace_delivered(<span class="anno">Tracee</span>)</strong>.</p><p>When it is guaranteed that all trace messages are delivered to
the tracer up to the point that <strong><span class="anno">Tracee</span></strong> reached
at the time of the call to
<strong>erlang:trace_delivered(<span class="anno">Tracee</span>)</strong>, then a
<strong>{trace_delivered, <span class="anno">Tracee</span>, <span class="anno">Ref</span>}</strong>
message is sent to the caller of
<strong>erlang:trace_delivered(<span class="anno">Tracee</span>)</strong> .</p><p>Notice that message <strong>trace_delivered</strong> does <em>not</em>
imply that trace messages have been delivered.
Instead it implies that all trace messages that
<em>are to be delivered</em> have been delivered.
It is not an error if <strong><span class="anno">Tracee</span></strong> is not, and
has not been traced by someone, but if this is the case,
<em>no</em> trace messages have been delivered when the
<strong>trace_delivered</strong> message arrives.</p><p>Notice that <strong><span class="anno">Tracee</span></strong> must refer
to a process currently
or previously existing on the same node as the caller of
<strong>erlang:trace_delivered(<span class="anno">Tracee</span>)</strong> resides on.
The special <strong><span class="anno">Tracee</span></strong> atom <strong>all</strong>
denotes all processes that currently are traced in the node.</p><p>When used together with a <a href="./erl_tracer"> Tracer Module</a>, any message sent in the trace callback
is guaranteed to have reached its recipient before the
<strong>trace_delivered</strong> message is sent.</p><p>Example: Process <strong>A</strong> is <strong><span class="anno">Tracee</span></strong>,
port <strong>B</strong> is tracer, and process <strong>C</strong> is the port
owner of <strong>B</strong>. <strong>C</strong> wants to close <strong>B</strong> when
<strong>A</strong> exits. To ensure that the trace is not truncated,
<strong>C</strong> can call <strong>erlang:trace_delivered(A)</strong> when
<strong>A</strong> exits, and wait for message <strong>{trace_delivered, A, <span class="anno">Ref</span>}</strong> before closing <strong>B</strong>.</p><p>Failure: <strong>badarg</strong> if <strong><span class="anno">Tracee</span></strong>
does not refer to a
process (dead or alive) on the same node as the caller of
<strong>erlang:trace_delivered(<span class="anno">Tracee</span>)</strong> resides on.</p><h3>trace_info/2</h3><p>Trace information about a process or function.</p><ul><li>trace_info_return</li></ul><ul><li>trace_info_item_result</li></ul><ul><li>trace_info_flag</li></ul><ul><li>trace_match_spec</li></ul><ul><li>match_variable</li></ul> Approximation of '$1' | '$2' | '$3' | ... <p>Returns trace information about a port, process, function, or
event.</p><p><em>To get information about a port or process</em>,
<strong><span class="anno">PidPortFuncEvent</span></strong> is to
be a process identifier (pid), port identifier, or one of
the atoms <strong>new</strong>, <strong>new_processes</strong>, or <strong>new_ports</strong>. The
atom <strong>new</strong> or <strong>new_processes</strong> means that the default trace
state for processes to be created is returned. The atom
<strong>new_ports</strong> means that the default trace state for ports to be
created is returned.</p><p>Valid <strong>Item</strong>s for ports and processes:</p><dl><dt><strong>flags</strong></dt><dd> <p>Returns a list of atoms indicating what kind of traces is
enabled for the process. The list is empty if no
traces are enabled, and one or more of the followings
atoms if traces are enabled: <strong>send</strong>,
<strong>'receive'</strong>, <strong>set_on_spawn</strong>, <strong>call</strong>,
<strong>return_to</strong>, <strong>procs</strong>, <strong>ports</strong>,
<strong>set_on_first_spawn</strong>,
<strong>set_on_link</strong>, <strong>running</strong>, <strong>running_procs</strong>,
<strong>running_ports</strong>, <strong>silent</strong>, <strong>exiting</strong>,
<strong>monotonic_timestamp</strong>, <strong>strict_monotonic_timestamp</strong>,
<strong>garbage_collection</strong>, <strong>timestamp</strong>, and
<strong>arity</strong>. The order is arbitrary.</p> </dd><dt><strong>tracer</strong></dt><dd> <p>Returns the identifier for process, port, or a tuple containing
the tracer module and tracer state tracing this
process. If this process is not traced, the return
value is <strong>[]</strong>.</p> </dd></dl><p><em>To get information about a function</em>,
<strong><span class="anno">PidPortFuncEvent</span></strong> is to
be the three-element tuple <strong>{Module, Function, Arity}</strong> or
the atom <strong>on_load</strong>. No wildcards are allowed. Returns
<strong>undefined</strong> if the function does not exist, or
<strong>false</strong> if the function is not traced.
If <strong><span class="anno">PidPortFuncEvent</span></strong>
is <strong>on_load</strong>, the information returned refers to
the default value for code that will be loaded.</p><p>Valid <strong>Item</strong>s for functions:</p><dl><dt><strong>traced</strong></dt><dd> <p>Returns <strong>global</strong> if this function is traced on
global function calls, <strong>local</strong> if this function is
traced on local function calls (that is, local and global
function calls), and <strong>false</strong> if local or
global function calls are not traced.</p> </dd><dt><strong>match_spec</strong></dt><dd> <p>Returns the match specification for this function, if it
has one. If the function is locally or globally traced but
has no match specification defined, the returned value
is <strong>[]</strong>.</p> </dd><dt><strong>meta</strong></dt><dd> <p>Returns the meta-trace tracer process, port, or trace module
for this function, if it has one. If the function is not
meta-traced, the returned value is <strong>false</strong>. If
the function is meta-traced but has once detected that
the tracer process is invalid, the returned value is
<strong>[]</strong>.</p> </dd><dt><strong>meta_match_spec</strong></dt><dd> <p>Returns the meta-trace match specification for this
function, if it has one. If the function is meta-traced
but has no match specification defined, the returned
value is <strong>[]</strong>.</p> </dd><dt><strong>call_count</strong></dt><dd> <p>Returns the call count value for this function or
<strong>true</strong> for the pseudo function <strong>on_load</strong> if call
count tracing is active. Otherwise <strong>false</strong> is returned.</p> <p>See also <a href="#trace_pattern/3">trace_pattern/3</a>.</p> </dd><dt><strong>call_time</strong></dt><dd> <p>Returns the call time values for this function or
<strong>true</strong> for the pseudo function <strong>on_load</strong> if call
time tracing is active. Otherwise <strong>false</strong> is returned.
The call time values returned, <strong>[{Pid, Count, S, Us}]</strong>,
is a list of each process that executed the function
and its specific counters.</p> <p>See also
<a href="#trace_pattern/3">trace_pattern/3</a>.</p> </dd><dt><strong>all</strong></dt><dd> <p>Returns a list containing the
<strong>{<span class="anno">Item</span>, Value}</strong> tuples
for all other items, or returns <strong>false</strong> if no tracing
is active for this function.</p> </dd></dl><p><em>To get information about an event</em>,
<strong><span class="anno">PidPortFuncEvent</span></strong> is to
be one of the atoms <strong>send</strong> or <strong>'receive'</strong>.</p><p>One valid <strong>Item</strong> for events exists:</p><dl><dt><strong>match_spec</strong></dt><dd> <p>Returns the match specification for this event, if it
has one, or <strong>true</strong> if no match specification has been
set.</p> </dd></dl><p>The return value is <strong>{<span class="anno">Item</span>, Value}</strong>, where
<strong>Value</strong> is the requested information as described earlier.
If a pid for a dead process was specified, or the name of a
non-existing function, <strong>Value</strong> is <strong>undefined</strong>.</p><h3>trace_pattern/2</h3><p>Set trace patterns for call, send, or 'receive' tracing. </p><ul><li>trace_pattern_mfa</li></ul><ul><li>trace_match_spec</li></ul> Approximation of '$1' | '$2' | '$3' | ... <ul><li>match_variable</li></ul><p>The same as
<a href="#trace_pattern/3">trace_pattern/3</a>,
retained for backward compatibility.</p><h3>trace_pattern/3</h3><p>Set trace pattern for message sending.</p><ul><li>trace_match_spec</li></ul><ul><li>match_variable</li></ul> Approximation of '$1' | '$2' | '$3' | ... <p>Sets trace pattern for <em>message sending</em>.
Must be combined with
<a href="#trace/3">trace/3</a>
to set the <strong>send</strong> trace flag for one or more processes.
By default all messages sent from <strong>send</strong> traced processes
are traced. To limit
traced send events based on the message content, the sender
and/or the receiver, use <strong>erlang:trace_pattern/3</strong>.</p><p>Argument <strong><span class="anno">MatchSpec</span></strong> can take the
following forms:</p><dl><dt><strong><span class="anno">MatchSpecList</span></strong></dt><dd> <p>A list of match specifications. The matching is done
on the list <strong>[Receiver, Msg]</strong>. <strong>Receiver</strong>
is the process or port identity of the receiver and
<strong>Msg</strong> is the message term. The pid of the sending
process can be accessed with the guard function
<strong>self/0</strong>. An empty list is the same as <strong>true</strong>.
For more information, see section
<a href="./match_spec"> Match Specifications in Erlang</a> in the User's Guide.</p> </dd><dt><strong>true</strong></dt><dd> <p>Enables tracing for all sent messages (from <strong>send</strong>
traced processes). Any match specification is
removed. <em>This is the default</em>.</p> </dd><dt><strong>false</strong></dt><dd> <p>Disables tracing for all sent messages.
Any match specification is removed.</p> </dd></dl><p>Argument <strong><span class="anno">FlagList</span></strong> must be <strong>[]</strong>
for send tracing.</p><p>The return value is always <strong>1</strong>.</p><p>Examples:</p><p>Only trace messages to a specific process <strong>Pid</strong>:</p><pre>
&gt; <span class="input">erlang:trace_pattern(send, [{[Pid, '_'],[],[]}], []).</span>
1</pre><p>Only trace messages matching <strong>{reply, _}</strong>:</p><pre>
&gt; <span class="input">erlang:trace_pattern(send, [{['_', {reply,'_'}],[],[]}], []).</span>
1</pre><p>Only trace messages sent to the sender itself:</p><pre>
&gt; <span class="input">erlang:trace_pattern(send, [{['$1', '_'],[{'=:=','$1',{self}}],[]}], []).</span>
1</pre><p>Only trace messages sent to other nodes:</p><pre>
&gt; <span class="input">erlang:trace_pattern(send, [{['$1', '_'],[{'=/=',{node,'$1'},{node}}],[]}], []).</span>
1</pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>A match specification for <strong>send</strong> trace can use
all guard and body functions except <strong>caller</strong>.</p></div><h3>trace_pattern/3</h3><p>Set trace pattern for tracing of message receiving.</p><ul><li>trace_match_spec</li></ul><ul><li>match_variable</li></ul> Approximation of '$1' | '$2' | '$3' | ... <p>Sets trace pattern for <em>message receiving</em>.
Must be combined with
<a href="#trace/3">trace/3</a>
to set the <strong>'receive'</strong> trace flag for one or more processes.
By default all messages received by <strong>'receive'</strong> traced
processes are traced. To limit
traced receive events based on the message content, the sender
and/or the receiver, use <strong>erlang:trace_pattern/3</strong>.</p><p>Argument <strong><span class="anno">MatchSpec</span></strong> can take the
following forms:</p><dl><dt><strong><span class="anno">MatchSpecList</span></strong></dt><dd> <p>A list of match specifications. The matching is done
on the list <strong>[Node, Sender, Msg]</strong>. <strong>Node</strong>
is the node name of the sender. <strong>Sender</strong> is the
process or port identity of the sender, or the atom
<strong>undefined</strong> if the sender is not known (which can
be the case for remote senders). <strong>Msg</strong> is the
message term. The pid of the receiving process can be
accessed with the guard function <strong>self/0</strong>. An empty
list is the same as <strong>true</strong>. For more information, see
section <a href="./match_spec"> Match Specifications in Erlang</a> in the User's Guide.</p> </dd><dt><strong>true</strong></dt><dd> <p>Enables tracing for all received messages (to <strong>'receive'</strong>
traced processes). Any match specification is
removed. <em>This is the default</em>.</p> </dd><dt><strong>false</strong></dt><dd> <p>Disables tracing for all received messages.
Any match specification is removed.</p> </dd></dl><p>Argument <strong><span class="anno">FlagList</span></strong> must be <strong>[]</strong>
for receive tracing.</p><p>The return value is always <strong>1</strong>.</p><p>Examples:</p><p>Only trace messages from a specific process <strong>Pid</strong>:</p><pre>
&gt; <span class="input">erlang:trace_pattern('receive', [{['_',Pid, '_'],[],[]}], []).</span>
1</pre><p>Only trace messages matching <strong>{reply, _}</strong>:</p><pre>
&gt; <span class="input">erlang:trace_pattern('receive', [{['_','_', {reply,'_'}],[],[]}], []).</span>
1</pre><p>Only trace messages from other nodes:</p><pre>
&gt; <span class="input">erlang:trace_pattern('receive', [{['$1', '_', '_'],[{'=/=','$1',{node}}],[]}], []).</span>
1</pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>A match specification for <strong>'receive'</strong> trace can
use all guard and body functions except <strong>caller</strong>,
<strong>is_seq_trace</strong>, <strong>get_seq_token</strong>, <strong>set_seq_token</strong>,
<strong>enable_trace</strong>, <strong>disable_trace</strong>, <strong>trace</strong>,
<strong>silent</strong>, and <strong>process_dump</strong>.</p></div><h3>trace_pattern/3</h3><p>Set trace patterns for tracing of function calls.</p><ul><li>trace_pattern_mfa</li></ul><ul><li>trace_match_spec</li></ul><ul><li>trace_pattern_flag</li></ul><ul><li>match_variable</li></ul> Approximation of '$1' | '$2' | '$3' | ... <p>Enables or disables <em>call tracing</em> for one or more functions.
Must be combined with
<a href="#trace/3">trace/3</a>
to set the <strong>call</strong> trace flag
for one or more processes.</p><p>Conceptually, call tracing works as follows. Inside
the Erlang virtual machine, a set of processes and
a set of functions are to be traced. If a traced process
calls a traced function, the trace action is taken.
Otherwise, nothing happens.</p><p>To add or remove one or more processes to the set of traced
processes, use
<a href="#trace/3">trace/3</a>.</p><p>To add or remove functions to the set of traced
functions, use <strong>erlang:trace_pattern/3</strong>.</p><p>The BIF <strong>erlang:trace_pattern/3</strong> can also add match
specifications to a function. A match specification
comprises a pattern that the function arguments must
match, a guard expression that must evaluate to <strong>true</strong>,
and an action to be performed. The default action is to send a
trace message. If the pattern does not match or the guard
fails, the action is not executed.</p><p>Argument <strong><span class="anno">MFA</span></strong> is to be a tuple, such as
<strong>{Module, Function, Arity}</strong>, or the atom <strong>on_load</strong>
(described below). It can be the module, function,
and arity for a function (or a BIF in any module).
The atom <strong>'_'</strong> can be used as a wildcard in any of the
following ways:</p><dl><dt><strong>{Module,Function,'_'}</strong></dt><dd> <p>All functions of any arity named <strong>Function</strong>
in module <strong>Module</strong>.</p> </dd><dt><strong>{Module,'_','_'}</strong></dt><dd> <p>All functions in module <strong>Module</strong>.</p> </dd><dt><strong>{'_','_','_'}</strong></dt><dd> <p>All functions in all loaded modules.</p> </dd></dl><p>Other combinations, such as <strong>{Module,'_',Arity}</strong>, are
not allowed. Local functions match wildcards only if
option <strong>local</strong> is in <strong><span class="anno">FlagList</span></strong>.</p><p>If argument <strong><span class="anno">MFA</span></strong> is the atom <strong>on_load</strong>,
the match specification and flag list are used on all
modules that are newly loaded.</p><p>Argument <strong><span class="anno">MatchSpec</span></strong> can take the
following forms:</p><dl><dt><strong>false</strong></dt><dd> <p>Disables tracing for the matching functions.
Any match specification is removed.</p> </dd><dt><strong>true</strong></dt><dd> <p>Enables tracing for the matching functions.
Any match specification is removed.</p> </dd><dt><strong><span class="anno">MatchSpecList</span></strong></dt><dd> <p>A list of match specifications. An empty list is
equivalent to <strong>true</strong>. For a description of match
specifications, see section <a href="./match_spec"> Match Specifications in Erlang</a> in the User's Guide.</p> </dd><dt><strong>restart</strong></dt><dd> <p>For the <strong><span class="anno">FlagList</span></strong> options <strong>call_count</strong>
and <strong>call_time</strong>: restarts
the existing counters. The behavior is undefined
for other <strong><span class="anno">FlagList</span></strong> options.</p> </dd><dt><strong>pause</strong></dt><dd> <p>For the <strong><span class="anno">FlagList</span></strong> options
<strong>call_count</strong> and <strong>call_time</strong>: pauses
the existing counters. The behavior is undefined for
other <strong><span class="anno">FlagList</span></strong> options.</p> </dd></dl><p>Parameter <strong><span class="anno">FlagList</span></strong> is a list of options.
The following are the valid options:</p><dl><dt><strong>global</strong></dt><dd> <p>Turns on or off call tracing for global function calls
(that is, calls specifying the module explicitly). Only
exported functions match and only global calls
generate trace messages. <em>This is the default</em>.</p> </dd><dt><strong>local</strong></dt><dd> <p>Turns on or off call tracing for all types of function
calls. Trace messages are sent whenever any of
the specified functions are called, regardless of how they
are called. If flag <strong>return_to</strong> is set for
the process, a <strong>return_to</strong> message is also sent
when this function returns to its caller.</p> </dd><dt><strong>meta | {meta, <span class="anno">Pid</span>} | {meta, <span class="anno">TracerModule</span>, <span class="anno">TracerState</span>}</strong> </dt><dd> <p>Turns on or off meta-tracing for all types of function
calls. Trace messages are sent to the tracer whenever any of
the specified functions are called. If no tracer is specified,
<strong>self()</strong> is used as a default tracer process.</p> <p>Meta-tracing traces all processes and does not care
about the process trace flags set by <strong>erlang:trace/3</strong>,
the trace flags are instead fixed to
<strong>[call, timestamp]</strong>.</p> <p>The match specification function <strong>{return_trace}</strong>
works with meta-trace and sends its trace message to the
same tracer.</p> </dd><dt><strong>call_count</strong></dt><dd> <p>Starts (<strong><span class="anno">MatchSpec</span> == true</strong>) or stops
(<strong><span class="anno">MatchSpec</span> == false</strong>)
call count tracing for all
types of function calls. For every function, a counter is
incremented when the function is called, in any process.
No process trace flags need to be activated.</p> <p>If call count tracing is started while already running,
the count is restarted from zero. To pause running
counters, use <strong><span class="anno">MatchSpec</span> == pause</strong>.
Paused and running counters can be restarted from zero with
<strong><span class="anno">MatchSpec</span> == restart</strong>.</p> <p>To read the counter value, use
<a href="#trace_info/2">trace_info/2</a>.</p> </dd><dt><strong>call_time</strong></dt><dd> <p>Starts (<strong><span class="anno">MatchSpec</span> == true</strong>) or stops
(<strong><span class="anno">MatchSpec</span> == false</strong>) call time
tracing for all
types of function calls. For every function, a counter is
incremented when the function is called.
Time spent in the function is accumulated in
two other counters, seconds and microseconds.
The counters are stored for each call traced process.</p> <p>If call time tracing is started while already running,
the count and time restart from zero. To pause
running counters, use <strong><span class="anno">MatchSpec</span> == pause</strong>.
Paused and running counters can be restarted from zero with
<strong><span class="anno">MatchSpec</span> == restart</strong>.</p> <p>To read the counter value, use
<a href="#trace_info/2">trace_info/2</a>.</p> </dd></dl><p>The options <strong>global</strong> and <strong>local</strong> are mutually
exclusive, and <strong>global</strong> is the default (if no options are
specified). The options <strong>call_count</strong> and <strong>meta</strong>
perform a kind of local tracing, and cannot be combined
with <strong>global</strong>. A function can be globally or
locally traced. If global tracing is specified for a
set of functions, then local, meta, call time, and call count
tracing for the matching set of local functions is
disabled, and conversely.</p><p>When disabling trace, the option must match the type of trace
set on the function. That is, local tracing must be
disabled with option <strong>local</strong> and global tracing with
option <strong>global</strong> (or no option), and so on.</p><p>Part of a match specification list cannot be changed directly.
If a function has a match specification, it can be replaced
with a new one. To change an existing match specification,
use the BIF
<a href="#trace_info/2">trace_info/2</a>
to retrieve the existing match specification.</p><p>Returns the number of functions matching
argument <strong><span class="anno">MFA</span></strong>. This is zero if none matched.</p><h3>trunc/1</h3><p>Return an integer by truncating a number.</p><p>Returns an integer by truncating <strong><span class="anno">Number</span></strong>,
for example:</p><pre>
&gt; <span class="input">trunc(5.5).</span>
5</pre><p>Allowed in guard tests.</p><h3>tuple_size/1</h3><p>Return the size of a tuple.</p><p>Returns an integer that is the number of elements in
<strong><span class="anno">Tuple</span></strong>, for example:</p><pre>
&gt; <span class="input">tuple_size({morni, mulle, bwange}).</span>
3</pre><p>Allowed in guard tests.</p><h3>tuple_to_list/1</h3><p>Convert a tuple to a list.</p><p>Returns a list corresponding to <strong><span class="anno">Tuple</span></strong>.
<strong><span class="anno">Tuple</span></strong> can contain any Erlang terms.
Example:</p><pre>
&gt; <span class="input">tuple_to_list({share, {'Ericsson_B', 163}}).</span>
[share,{'Ericsson_B',163}]</pre><h3>unique_integer/0</h3><p>Get a unique integer value.</p><p>Generates and returns an
<a href="../doc/efficiency_guide/advanced#unique_integers"> integer unique on current runtime system instance</a>.
The same as calling
<a href="#unique_integer/1">unique_integer/1</a>.</p><h3>unique_integer/1</h3><p>Get a unique integer value.</p><p>Generates and returns an
<a href="../doc/efficiency_guide/advanced#unique_integers"> integer unique on current runtime system instance</a>. The integer is unique in the
sense that this BIF, using the same set of
modifiers, does not return the same integer more
than once on the current runtime system instance.
Each integer value can of course be constructed
by other means.</p><p>By default, when <strong>[]</strong> is passed as
<strong><span class="anno">ModifierList</span></strong>, both negative and
positive integers can be returned. This
to use the range of integers that do
not need heap memory allocation as much as possible.
By default the returned integers are also only
guaranteed to be unique, that is, any returned integer
can be smaller or larger than previously
returned integers.</p><p><strong><span class="anno">Modifier</span></strong>s:</p><dl><dt>positive</dt><dd> <p>Returns only positive integers.</p> <p>Notice that by passing the <strong>positive</strong> modifier
you will get heap allocated integers (bignums) quicker.</p> </dd><dt>monotonic</dt><dd> <p>Returns <a href="./time_correction#Strictly_Monotonically_Increasing"> strictly monotonically increasing</a> integers
corresponding to creation time. That is, the integer
returned is always larger than previously
returned integers on the current runtime system
instance.</p> <p>These values can be used to determine order between events
on the runtime system instance. That is, if both
<strong>X = erlang:unique_integer([monotonic])</strong> and
<strong>Y = erlang:unique_integer([monotonic])</strong> are
executed by different processes (or the same
process) on the same runtime system instance and
<strong>X &lt; Y</strong>, we know that <strong>X</strong> was created
before <strong>Y</strong>.</p> <div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Strictly monotonically increasing values
are inherently quite expensive to generate and scales
poorly. This is because the values need to be synchronized
between CPU cores. That is, do not pass the <strong>monotonic</strong>
modifier unless you really need strictly monotonically
increasing values.</p></div> </dd></dl><p>All valid <strong><span class="anno">Modifier</span></strong>s
can be combined. Repeated (valid)
<strong><span class="anno">Modifier</span></strong>s in the <strong>ModifierList</strong>
are ignored.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The set of integers returned by
<strong>erlang:unique_integer/1</strong> using different sets of
<strong><span class="anno">Modifier</span></strong>s <em>will overlap</em>.
For example, by calling <strong>unique_integer([monotonic])</strong>,
and <strong>unique_integer([positive, monotonic])</strong>
repeatedly, you will eventually see some integers that are
returned by both calls.</p></div><p>Failures:</p><dl><dt><strong>badarg</strong></dt><dd>if <strong><span class="anno">ModifierList</span></strong> is not a proper list.</dd><dt><strong>badarg</strong></dt><dd>if <strong><span class="anno">Modifier</span></strong> is not a valid modifier.</dd></dl><h3>universaltime/0</h3><p>Current date and time according to Universal Time Coordinated (UTC).</p><p>Returns the current date and time according to Universal
Time Coordinated (UTC) in the form
<strong>{{Year, Month, Day}, {Hour, Minute, Second}}</strong> if
supported by the underlying OS.
Otherwise <strong>erlang:universaltime()</strong> is equivalent to
<strong>erlang:localtime()</strong>. Example:</p><pre>
&gt; <span class="input">erlang:universaltime().</span>
{{1996,11,6},{14,18,43}}</pre><h3>universaltime_to_localtime/1</h3><p>Convert from Universal Time Coordinated (UTC) to local date and time.</p><p>Converts Universal Time Coordinated (UTC) date and time to
local date and time in the form
<strong>{{Year, Month, Day}, {Hour, Minute, Second}}</strong> if
supported by the underlying OS.
Otherwise no conversion is done, and
<strong><span class="anno">Universaltime</span></strong> is returned. Example:</p><pre>
&gt; <span class="input">erlang:universaltime_to_localtime({{1996,11,6},{14,18,43}}).</span>
{{1996,11,7},{15,18,43}}</pre><p>Failure: <strong>badarg</strong> if <strong>Universaltime</strong> denotes
an invalid date and time.</p><h3>unlink/1</h3><p>Remove a link to another process or port.</p><p>Removes the link, if there is one, between the calling
process and the process or port referred to by
<strong><span class="anno">Id</span></strong>.</p><p>Returns <strong>true</strong> and does not fail, even if there is no
link to <strong><span class="anno">Id</span></strong>, or if <strong><span class="anno">Id</span></strong>
does not exist.</p><p>Once <strong>unlink(<span class="anno">Id</span>)</strong> has returned,
it is guaranteed that
the link between the caller and the entity referred to by
<strong><span class="anno">Id</span></strong> has no effect on the caller
in the future (unless
the link is setup again). If the caller is trapping exits, an
<strong>{'EXIT', <span class="anno">Id</span>, _}</strong> message from the link
can have been placed in the caller's message queue before
the call.</p><p>Notice that the <strong>{'EXIT', <span class="anno">Id</span>, _}</strong>
message can be the
result of the link, but can also be the result of <strong>Id</strong>
calling <strong>exit/2</strong>. Therefore, it <em>can</em> be
appropriate to clean up the message queue when trapping exits
after the call to <strong>unlink(<span class="anno">Id</span>)</strong>, as follows:</p><pre><code class="">
unlink(Id),
receive
    {'EXIT', Id, _} -&gt;
        true
after 0 -&gt;
        true
end</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Before Erlang/OTP R11B (ERTS 5.5) <strong>unlink/1</strong>
behaved completely asynchronously, that is, the link was active
until the "unlink signal" reached the linked entity. This
had an undesirable effect, as you could never know when
you were guaranteed <em>not</em> to be effected by the link.</p><p>The current behavior can be viewed as two combined operations:
asynchronously send an "unlink signal" to the linked entity
and ignore any future results of the link.</p></div><h3>unregister/1</h3><p>Remove the registered name for a process (or port).</p><p>Removes the registered name <strong><span class="anno">RegName</span></strong>
associated with a
process identifier or a port identifier, for example:</p><pre>
&gt; <span class="input">unregister(db).</span>
true</pre><p>Users are advised not to unregister system processes.</p><p>Failure: <strong>badarg</strong> if <strong>RegName</strong> is not a registered
name.</p><h3>whereis/1</h3><p>Get the pid (or port) with a specified registered name. </p><p>Returns the process identifier or port identifier with
the registered name <strong>RegName</strong>. Returns <strong>undefined</strong>
if the name is not registered. Example:</p><pre>
&gt; <span class="input">whereis(db).</span>
&lt;0.43.0&gt;</pre><h3>yield/0</h3><p>Let other processes get a chance to execute.</p><p>Voluntarily lets other processes (if any) get a chance to
execute. Using this function is similar to
<strong>receive after 1 -&gt; ok end</strong>, except that <strong>yield()</strong>
is faster.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>There is seldom or never any need to use this BIF
as other processes have a chance to run in another scheduler
thread anyway.
Using this BIF without a thorough grasp of how the scheduler
works can cause performance degradation.</p></div><h2>erlc</h2><p>Compiler</p><p>The <strong>erlc</strong> program provides a common way to run
all compilers in the Erlang system.
Depending on the extension of each input file, <strong>erlc</strong>
invokes the appropriate compiler.
Regardless of which compiler is used, the same flags are used to provide
parameters, such as include paths and output directory.The current working directory, <strong>"."</strong>, is not included
in the code path when running the compiler. This to avoid loading
Beam files from the current working directory that could potentially
be in conflict with the compiler or the Erlang/OTP system used by the
compiler.</p><h2>Functions</h2><h3>erlc flags file1.ext file2.ext...</h3><p>Compile files.</p><p>Compiles one or more files. The files must include the extension,
for example, <strong>.erl</strong> for Erlang source code, or
<strong>.yrl</strong> for Yecc source code.
<strong>Erlc</strong> uses the extension to invoke the correct
compiler.</p><h3>Generally Useful Flags</h3><p>The following flags are supported:</p><dl><dt><strong>-I &lt;Directory&gt;</strong></dt><dd> <p>Instructs the compiler to search for include files in
the <strong>Directory</strong>. When encountering an
<strong>-include</strong> or <strong>-include_lib</strong>
directive, the compiler searches for header files in the following
directories:</p> <ul><li> <p><strong>"."</strong>, the current working directory of the
file server</p> </li><li> <p>The base name of the compiled file</p> </li><li> <p>The directories specified using option <strong>-I</strong>;
the directory specified last is searched first</p> </li></ul> </dd><dt><strong>-o &lt;Directory&gt;</strong></dt><dd> <p>The directory where the compiler is to place the output files.
Defaults to the current working directory.</p> </dd><dt><strong>-D&lt;Name&gt;</strong></dt><dd> <p>Defines a macro.</p> </dd><dt><strong>-D&lt;Name&gt;=&lt;Value&gt;</strong></dt><dd> <p>Defines a macro with the specified value.
The value can be any Erlang term.
Depending on the platform, the value may need to be
quoted if the shell itself interprets certain characters.
On Unix, terms containing tuples and lists
must be quoted. Terms containing spaces
must be quoted on all platforms.</p> </dd><dt><strong>-W&lt;Error&gt;</strong></dt><dd> <p>Makes all warnings into errors.</p> </dd><dt><strong>-W&lt;Number&gt;</strong></dt><dd> <p>Sets warning level to <strong>Number</strong>. Defaults to
<strong>1</strong>. To turn off warnings,
use <strong>-W0</strong>.</p> </dd><dt><strong>-W</strong></dt><dd> <p>Same as <strong>-W1</strong>. Default.</p> </dd><dt><strong>-v</strong></dt><dd> <p>Enables verbose output.</p> </dd><dt><strong>-b &lt;Output_type&gt;</strong></dt><dd> <p>Specifies the type of output file.
<strong>Output_type</strong> is the same as the file extension
of the output file, but without the period.
This option is ignored by compilers that have
a single output format.</p> </dd><dt><strong>-smp</strong></dt><dd> <p>Compiles using the SMP emulator. This is mainly useful
for compiling native code, which must be compiled with the same
runtime system that it is to be run on.</p> </dd><dt><strong>-M</strong></dt><dd> <p>Produces a Makefile rule to track header dependencies. The
rule is sent to <strong>stdout</strong>. No object file is produced.</p> </dd><dt><strong>-MMD</strong></dt><dd> <p>Generate dependencies as a side-effect. The object file
will be produced as normal. This option overrides the
option <strong>-M</strong>.</p> </dd><dt><strong>-MF &lt;Makefile&gt;</strong></dt><dd> <p>As option <strong>-M</strong>, except that the
Makefile is written to <strong>Makefile</strong>. No object
file is produced.</p> </dd><dt><strong>-MD</strong></dt><dd> <p>Same as <strong>-M -MF &lt;File&gt;.Pbeam</strong>.</p> </dd><dt><strong>-MT &lt;Target&gt;</strong></dt><dd> <p>In conjunction with option <strong>-M</strong> or
<strong>-MF</strong>, changes the name of the rule emitted
to <strong>Target</strong>.</p> </dd><dt><strong>-MQ &lt;Target&gt;</strong></dt><dd> <p>As option <strong>-MT</strong>, except that characters special to
<strong>make/1</strong> are quoted.</p> </dd><dt><strong>-MP</strong></dt><dd> <p>In conjunction with option <strong>-M</strong> or
<strong>-MF</strong>, adds a phony target for each dependency.</p> </dd><dt><strong>-MG</strong></dt><dd> <p>In conjunction with option <strong>-M</strong> or
<strong>-MF</strong>, considers missing headers as generated
files and adds them to the dependencies.</p> </dd><dt><strong>--</strong></dt><dd> <p>Signals that no more options will follow.
The rest of the arguments is treated as filenames,
even if they start with hyphens.</p> </dd><dt><strong>+&lt;Term&gt;</strong></dt><dd> <p>A flag starting with a plus (<strong>+</strong>) rather than a hyphen
is converted to an Erlang term and passed unchanged to
the compiler.
For example, option <strong>export_all</strong> for the Erlang
compiler can be specified as follows:</p> <pre>
erlc +export_all file.erl</pre> <p>Depending on the platform, the value may need to be
quoted if the shell itself interprets certain characters.
On Unix, terms containing tuples and lists
must be quoted. Terms containing spaces
must be quoted on all platforms.</p> </dd></dl><h3>Special Flags</h3><p>The following flags are useful in special situations,
such as rebuilding the OTP system:</p><dl><dt><strong>-pa &lt;Directory&gt;</strong></dt><dd> <p>Appends <strong>Directory</strong> to the front of the code path in
the invoked Erlang emulator.
This can be used to invoke another
compiler than the default one.</p> </dd><dt><strong>-pz &lt;Directory&gt;</strong></dt><dd> <p>Appends <strong>Directory</strong> to the code path in
the invoked Erlang emulator.</p> </dd></dl><h3>Supported Compilers</h3><p>The following compilers are supported:</p><dl><dt><strong>.erl</strong></dt><dd> <p>Erlang source code. It generates a <strong>.beam</strong> file.</p> <p>Options <strong>-P</strong>, <strong>-E</strong>, and <strong>-S</strong> are equivalent to
<strong>+'P'</strong>, <strong>+'E'</strong>, and <strong>+'S'</strong>, except that it is not
necessary to include the single quotes to protect them from the
shell.</p> <p>Supported options: <strong>-I</strong>, <strong>-o</strong>, <strong>-D</strong>, <strong>-v</strong>,
<strong>-W</strong>, <strong>-b</strong>.</p> </dd><dt><strong>.S</strong></dt><dd> <p>Erlang assembler source code. It generates a <strong>.beam</strong>
file.</p> <p>Supported options: same as for <strong>.erl</strong>.</p> </dd><dt><strong>.core</strong></dt><dd> <p>Erlang core source code. It generates a <strong>.beam</strong>
file.</p> <p>Supported options: same as for <strong>.erl</strong>.</p> </dd><dt><strong>.yrl</strong></dt><dd> <p>Yecc source code. It generates an <strong>.erl</strong> file.</p> <p>Use option <strong>-I</strong> with the name of a file to use that file
as a customized prologue file (option
<strong>includefile</strong>).</p> <p>Supported options: <strong>-o</strong>, <strong>-v</strong>, <strong>-I</strong>, <strong>-W</strong>.</p> </dd><dt><strong>.mib</strong></dt><dd> <p>MIB for SNMP. It generates a <strong>.bin</strong> file.</p> <p>Supported options: <strong>-I</strong>, <strong>-o</strong>, <strong>-W</strong>.</p> </dd><dt><strong>.bin</strong></dt><dd> <p>A compiled MIB for SNMP. It generates a <strong>.hrl</strong>
file.</p> <p>Supported options: <strong>-o</strong>, <strong>-v</strong>.</p> </dd><dt><strong>.rel</strong></dt><dd> <p>Script file. It generates a boot file.</p> <p>Use option <strong>-I</strong> to name directories to be searched for
application files (equivalent to the <strong>path</strong> in the
option list for <strong>systools:make_script/2</strong>).</p> <p>Supported option: <strong>-o</strong>.</p> </dd><dt><strong>.asn1</strong></dt><dd> <p>ASN1 file. It creates an <strong>.erl</strong>,
<strong>.hrl</strong>, and <strong>.asn1db</strong> file from
an <strong>.asn1</strong> file. Also compiles the
<strong>.erl</strong> using the Erlang compiler unless option
<strong>+noobj</strong> is specified.</p> <p>Supported options: <strong>-I</strong>, <strong>-o</strong>, <strong>-b</strong>, <strong>-W</strong>.</p> </dd><dt><strong>.idl</strong></dt><dd> <p>IC file. It runs the IDL compiler.</p> <p>Supported options: <strong>-I</strong>, <strong>-o</strong>.</p> </dd></dl><h3>Environment Variables</h3><dl><dt><strong>ERLC_EMULATOR</strong></dt><dd>The command for starting the emulator. Defaults to <strong>erl</strong> in the same directory as the <strong>erlc</strong> program itself, or, if it does not exist, <strong>erl</strong> in any of the directories specified in environment variable <strong>PATH</strong>.</dd></dl><h3>See Also</h3><p><a href="erl">erl</a>,
<a href="./compile">compiler/compile</a>,
<a href="./yecc">parsetools/yecc</a>,
<a href="./snmp">snmp/snmp</a></p><h2>erl_driver</h2><p>API functions for an Erlang driver.</p><p>An Erlang driver is a library containing a set of native driver
callback functions that the Erlang Virtual Machine calls when certain
events occur. There can be multiple instances of a driver, each
instance is associated with an Erlang port.<a name="WARNING"></a>As from ERTS 5.5.3 the driver interface has been extended
(see <a href="./driver_entry#extended_marker">driver_entry#extended_marker</a>). The extended interface introduces
<a href="#version_management">version management</a>,
the possibility to pass capability flags (see
<a href="./driver_entry#driver_flags">driver_entry#driver_flags</a>) to the runtime system at driver
initialization, and some new driver API functions.The driver calls back to the emulator, using the API
functions declared in <strong>erl_driver.h</strong>. They are used for
outputting data from the driver, using timers, and so on.Each driver instance is associated with a port. Every port
has a port owner process. Communication with the port is normally
done through the port owner process. Most of the functions take
the <strong>port</strong> handle as an argument. This identifies the driver
instance. Notice that this port handle must be stored by the driver,
it is not given when the driver is called from the emulator (see
<a href="./driver_entry#emulator">driver_entry#emulator</a>).Some of the functions take a parameter of type
<strong>ErlDrvBinary</strong>, a driver binary. It is to be both
allocated and freed by the caller. Using a binary directly avoids
one extra copying of data.Many of the output functions have a "header buffer", with
<strong>hbuf</strong> and <strong>hlen</strong> parameters. This buffer is sent as a
list before the binary (or list, depending on port mode) that is
sent. This is convenient when matching on messages received from
the port. (Although in the latest Erlang versions there is
the binary syntax, which enables you to match on the beginning of
a binary.)<a name="smp_support"></a>In the runtime system with
SMP support, drivers are locked either on driver level
or port level (driver instance level). By default
driver level locking will be used, that is, only one emulator thread
will execute code in the driver at a time. If port level locking
is used, multiple emulator threads can execute code in the driver
at the same time. Only one thread at a time will call
driver callbacks corresponding to the same port, though.
To enable port level locking, set the <strong>ERL_DRV_FLAG_USE_PORT_LOCKING</strong>
<a href="./driver_entry#driver_flags">driver flag</a> in
the <a href="driver_entry">driver_entry</a>
used by the driver. When port level locking is used,
the driver writer is responsible for synchronizing all accesses
to data shared by the ports (driver instances).Most drivers written before the runtime system with SMP
support existed can run in the runtime system
with SMP support, without being rewritten, if driver
level locking is used.Previously, in the runtime system without SMP support,
specific driver callbacks were always called from the same
thread. This is <em>not</em> the case in the runtime system
with SMP support. Regardless of locking scheme used, calls
to driver callbacks can be made from different threads. For example,
two consecutive calls to exactly the same callback for exactly
the same port can be made from two different threads. This
is for <em>most</em> drivers not a problem, but it can be.
Drivers that depend on all callbacks that are called in the
same thread, <em>must</em> be rewritten before they are used
in the runtime system with SMP support.Most functions in this API are <em>not</em> thread-safe, that is,
they <em>cannot</em> be called from arbitrary threads. Functions
that are not documented as thread-safe can only be called from
driver callbacks or function calls descending from a driver
callback call. Notice that driver callbacks can be called from
different threads. This, however, is not a problem for any
function in this API, as the emulator has control over
these threads.<a name="lengthy_work"></a>
As mentioned in the <a href="#WARNING">warning</a> text at
the beginning of this section, it is of vital importance that a driver
callback returns relatively fast. It is difficult to give an exact
maximum amount of time that a driver callback is allowed to work, but
usually a well-behaving driver callback is to return within 1 millisecond.
This can be achieved using different approaches.
If you have full control over the code to execute in the driver
callback, the best approach is to divide the work into multiple chunks of
work, and trigger multiple calls to the
<a href="./driver_entry#timeout">time-out callback</a> using
zero time-outs. Function <a href="#erl_drv_consume_timeslice">erl_drv_consume_timeslice</a> can be useful to
determine when to trigger such time-out callback calls. However, sometimes
it cannot be implemented this way, for example when calling
third-party libraries. In this case, you typically want to dispatch the
work to another thread. Information about thread primitives is provided
below.</p><h3>Functionality</h3><p>All functions that a driver needs to do with Erlang are
performed through driver API functions. Functions exist
for the following functionality:</p><dl><dt>Timer functions</dt><dd> <p>Control the timer that a driver can use. The timer has the
emulator call the <a href="./driver_entry#timeout">driver_entry#timeout</a> entry function after a specified time.
Only one timer is available for each driver instance.</p> </dd><dt>Queue handling</dt><dd> <p>Every driver instance has an associated queue. This queue is a
<strong>SysIOVec</strong>, which works as a buffer. It is mostly used for
the driver to buffer data that is to be written to a device,
it is a byte stream. If the port owner process closes the
driver, and the queue is not empty, the driver is not
closed. This enables the driver to flush its buffers before
closing.</p> <p>The queue can be manipulated from any threads if
a port data lock is used. For more information, see
<a href="#ErlDrvPDL">ErlDrvPDL</a>.</p> </dd><dt>Output functions</dt><dd> <p>With these functions, the driver sends data back to the emulator.
The data is received as messages by the port owner process, see
<a href="./erlang#open_port/2">erlang#open_port/2</a>. The vector function and the
function taking a driver binary are faster, as they avoid
copying the data buffer. There is also a fast way of sending
terms from the driver, without going through the binary term
format.</p></dd><dt>Failure</dt><dd> <p>The driver can exit and signal errors up to Erlang. This is
only for severe errors, when the driver cannot possibly keep
open.</p> </dd><dt>Asynchronous calls</dt><dd> <p>Erlang/OTP R7B and later versions have provision for
asynchronous function calls, using a thread pool provided by
Erlang. There is also a select call, which can be used for
asynchronous drivers.</p> </dd><dt><a name="multi_threading"></a>Multi-threading</dt><dd> <p>A POSIX thread like API for multi-threading is provided. The
Erlang driver thread API only provides a subset of the functionality
provided by the POSIX thread API. The subset provided is
more or less the basic functionality needed for multi-threaded
programming:</p> <ul><li><a href="#ErlDrvTid">Threads</a></li><li><a href="#ErlDrvMutex">Mutexes</a></li><li><a href="#ErlDrvCond"> Condition variables</a></li><li><a href="#ErlDrvRWLock"> Read/write locks</a></li><li><a href="#ErlDrvTSDKey"> Thread-specific data</a></li></ul> <p>The Erlang driver thread API can be used in conjunction with
the POSIX thread API on UN-ices and with the Windows native thread
API on Windows. The Erlang driver thread API has the advantage of
being portable, but there can exist situations where you want to
use functionality from the POSIX thread API or the Windows
native thread API.</p> <p>The Erlang driver thread API only returns error codes when it is
reasonable to recover from an error condition. If it is not reasonable
to recover from an error condition, the whole runtime system is
terminated. For example, if a create mutex operation fails, an error
code is returned, but if a lock operation on a mutex fails, the
whole runtime system is terminated.</p> <p>Notice that there is no "condition variable wait with time-out" in
the Erlang driver thread API. This because of issues with
<strong>pthread_cond_timedwait</strong>. When the system clock suddenly
is changed, it is not always guaranteed that you will wake up from
the call as expected. An Erlang runtime system must be able to
cope with sudden changes of the system clock. Therefore, we have
omitted it from the Erlang driver thread API. In the Erlang driver
case, time-outs can and are to be handled with the timer functionality
of the Erlang driver API.</p> <p>In order for the Erlang driver thread API to function, thread
support must be enabled in the runtime system. An Erlang driver
can check if thread support is enabled by use of
<a href="#driver_system_info">driver_system_info</a>.
Notice that some functions in the Erlang driver API are thread-safe
only when the runtime system has SMP support, also this
information can be retrieved through
<a href="#driver_system_info">driver_system_info</a>.
Also notice that many functions in the Erlang driver API are
<em>not</em> thread-safe, regardless of whether SMP support is
enabled or not. If a function is not documented as thread-safe, it
is <em>not</em> thread-safe.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>When executing in an emulator thread, it is
<em>very important</em> that you unlock <em>all</em> locks you
have locked before letting the thread out of your control;
otherwise you are <em>very likely</em> to deadlock the whole
emulator.</p><p>If you need to use thread-specific data in an emulator
thread, only have the thread-specific data set while the thread is
under your control, and clear the thread-specific data before
you let the thread out of your control.</p></div> <p>In the future, debug functionality will probably be
integrated with the Erlang driver thread API. All functions
that create entities take a <strong>name</strong> argument. Currently
the <strong>name</strong> argument is unused, but it will be used when
the debug functionality is implemented. If you name all
entities created well, the debug functionality will be able
to give you better error reports.</p> </dd><dt>Adding/removing drivers</dt><dd> <p>A driver can add and later remove drivers.</p> </dd><dt>Monitoring processes</dt><dd> <p>A driver can monitor a process that does not own a port.</p> </dd><dt><a name="version_management"></a>Version management</dt><dd> <p>Version management is enabled for drivers that have set the
<a href="./driver_entry#extended_marker">driver_entry#extended_marker</a> field of their
<a href="driver_entry">driver_entry</a>
to <strong>ERL_DRV_EXTENDED_MARKER</strong>. <strong>erl_driver.h</strong> defines:</p> <ul><li> <p><strong>ERL_DRV_EXTENDED_MARKER</strong></p> </li><li> <p><strong>ERL_DRV_EXTENDED_MAJOR_VERSION</strong>, which is incremented when
driver incompatible changes are made to the Erlang runtime
system. Normally it suffices to recompile drivers when
<strong>ERL_DRV_EXTENDED_MAJOR_VERSION</strong> has changed, but it
can, under rare circumstances, mean that drivers must
be slightly modified. If so, this will of course be
documented.</p> </li><li> <p><strong>ERL_DRV_EXTENDED_MINOR_VERSION</strong>, which is incremented when
new features are added. The runtime system uses the minor version
of the driver to determine what features to use.</p> </li></ul> <p>The runtime system normally refuses to load a driver if the major
versions differ, or if the major versions are equal and the
minor version used by the driver is greater than the one used
by the runtime system. Old drivers with lower major versions
are however allowed after a bump of the major version during
a transition period of two major releases. Such old drivers can,
however, fail if deprecated features are used.</p> <p>The emulator refuses to load a driver that does not use
the extended driver interface, to allow for 64-bit capable drivers,
as incompatible type changes for the callbacks
<a href="./driver_entry#output">driver_entry#output</a>,
<a href="./driver_entry#control">driver_entry#control</a>, and
<a href="./driver_entry#call">driver_entry#call</a>
were introduced in Erlang/OTP R15B. A driver written
with the old types would compile with warnings and when
called return garbage sizes to the emulator, causing it
to read random memory and create huge incorrect result blobs.</p> <p>Therefore it is not enough to only recompile drivers written with
version management for pre R15B types; the types must be changed
in the driver suggesting other rewrites, especially regarding size
variables. <em>Investigate all warnings when recompiling.</em></p> <p>Also, the API driver functions <strong>driver_output*</strong> and
<strong>driver_vec_to_buf</strong>, <strong>driver_alloc/realloc*</strong>, and the
<strong>driver_*</strong> queue functions were changed to have
larger length arguments and return values. This is a
lesser problem, as code that passes smaller types
gets them auto-converted in the calls, and as long as
the driver does not handle sizes that overflow an <strong>int</strong>,
all will work as before.</p> </dd><dt><a name="time_measurement"></a>Time measurement</dt><dd> <p>Support for time measurement in drivers:</p> <ul><li><a href="#ErlDrvTime">ErlDrvTime</a></li><li><a href="#ErlDrvTimeUnit">ErlDrvTimeUnit</a></li><li><a href="#erl_drv_monotonic_time">erl_drv_monotonic_time</a></li><li><a href="#erl_drv_time_offset">erl_drv_time_offset</a></li><li><a href="#erl_drv_convert_time_unit">erl_drv_convert_time_unit</a></li></ul> </dd></dl><a name="rewrites_for_64_bits"></a><h3>Rewrites for 64-Bit Driver Interface</h3><p>ERTS 5.9 introduced two new integer types,
<a href="#ErlDrvSizeT">ErlDrvSizeT</a> and
<a href="#ErlDrvSSizeT">ErlDrvSSizeT</a>,
which can hold 64-bit sizes if necessary.</p><p>To not update a driver and only recompile, it probably works
when building for a 32-bit machine creating a false sense of security.
Hopefully that will generate many important warnings.
But when recompiling the same driver later on for a 64-bit machine,
there <em>will</em> be warnings and almost certainly crashes.
So it is a <em>bad</em> idea to postpone updating the driver and
not fixing the warnings.</p><p>When recompiling with <strong>gcc</strong>, use flag <strong>-Wstrict-prototypes</strong>
to get better warnings. Try to find a similar flag if you use
another compiler.</p><p>The following is a checklist for rewriting a pre ERTS 5.9 driver,
most important first:</p><dl><dt>Return types for driver callbacks</dt><dd> <p>Rewrite driver callback
<a href="./driver_entry#control">driver_entry#control</a>
to use return type <strong>ErlDrvSSizeT</strong> instead of <strong>int</strong>.</p> <p>Rewrite driver callback
<a href="./driver_entry#call">driver_entry#call</a>
to use return type <strong>ErlDrvSSizeT</strong> instead of <strong>int</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>These changes are essential not to crash the emulator
or worse cause malfunction.
Without them a driver can return garbage in the high 32 bits
to the emulator, causing it to build a huge result from random
bytes, either crashing on memory allocation or succeeding with
a random result from the driver call.</p></div> </dd><dt>Arguments to driver callbacks</dt><dd> <p>Driver callback
<a href="./driver_entry#output">driver_entry#output</a>
now gets <strong>ErlDrvSizeT</strong> as 3rd argument instead
of previously <strong>int</strong>.</p> <p>Driver callback
<a href="./driver_entry#control">driver_entry#control</a>
now gets <strong>ErlDrvSizeT</strong> as 4th and 6th arguments instead
of previously <strong>int</strong>.</p> <p>Driver callback
<a href="./driver_entry#call">driver_entry#call</a>
now gets <strong>ErlDrvSizeT</strong> as 4th and 6th arguments instead
of previously <strong>int</strong>.</p> <p>Sane compiler's calling conventions probably make these changes
necessary only for a driver to handle data chunks that require
64-bit size fields (mostly larger than 2 GB, as that is what
an <strong>int</strong> of 32 bits can hold). But it is possible to think
of non-sane calling conventions that would make the driver
callbacks mix up the arguments causing malfunction.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The argument type change is from signed to unsigned. This
can cause problems for, for example, loop termination conditions or
error conditions if you only change the types all over the place.
</p></div> </dd><dt>Larger <strong>size</strong> field in <strong>ErlIOVec</strong></dt><dd> <p>The <strong>size</strong> field in
<a href="#ErlIOVec">ErlIOVec</a>
has been changed to <strong>ErlDrvSizeT</strong> from <strong>int</strong>.
Check all code that use that field.</p> <p>Automatic type-casting probably makes these changes necessary only
for a driver that encounters sizes &gt; 32 bits.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The <strong>size</strong> field changed from signed to unsigned. This
can cause problems for, for example, loop termination conditions or
error conditions if you only change the types all over the place.
</p></div> </dd><dt>Arguments and return values in the driver API</dt><dd> <p>Many driver API functions have changed argument type
and/or return value to <strong>ErlDrvSizeT</strong> from mostly <strong>int</strong>.
Automatic type-casting probably makes these changes necessary only
for a driver that encounters sizes &gt; 32 bits.</p> <dl><dt><a href="#driver_output">driver_output</a></dt><dd>3rd argument</dd><dt><a href="#driver_output2">driver_output2</a></dt><dd>3rd and 5th arguments</dd><dt><a href="#driver_output_binary">driver_output_binary</a></dt><dd>3rd, 5th, and 6th arguments</dd><dt><a href="#driver_outputv">driver_outputv</a></dt><dd>3rd and 5th arguments</dd><dt><a href="#driver_vec_to_buf">driver_vec_to_buf</a></dt><dd>3rd argument and return value</dd><dt><a href="#driver_alloc">driver_alloc</a></dt><dd>1st argument</dd><dt><a href="#driver_realloc">driver_realloc</a></dt><dd>2nd argument</dd><dt><a href="#driver_alloc_binary">driver_alloc_binary</a></dt><dd>1st argument</dd><dt><a href="#driver_realloc_binary">driver_realloc_binary</a></dt><dd>2nd argument</dd><dt><a href="#driver_enq">driver_enq</a></dt><dd>3rd argument</dd><dt><a href="#driver_pushq">driver_pushq</a></dt><dd>3rd argument</dd><dt><a href="#driver_deq">driver_deq</a></dt><dd>2nd argument and return value</dd><dt><a href="#driver_sizeq">driver_sizeq</a></dt><dd>Return value</dd><dt><a href="#driver_enq_bin">driver_enq_bin</a></dt><dd>3rd and 4th arguments</dd><dt><a href="#driver_pushq_bin">driver_pushq_bin</a></dt><dd>3rd and 4th arguments</dd><dt><a href="#driver_enqv">driver_enqv</a></dt><dd>3rd argument</dd><dt><a href="#driver_pushqv">driver_pushqv</a></dt><dd>3rd argument</dd><dt><a href="#driver_peekqv">driver_peekqv</a></dt><dd>Return value</dd></dl> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This is a change from signed to unsigned. This can cause
problems for, for example, loop termination conditions and error
conditions if you only change the types all over the place.</p></div> </dd></dl><h3>Data Types</h3><dl><dt><a name="ErlDrvSizeT"></a><strong>ErlDrvSizeT</strong></dt><dd> <p>An unsigned integer type to be used as <strong>size_t</strong>.</p> </dd><dt><a name="ErlDrvSSizeT"></a><strong>ErlDrvSSizeT</strong></dt><dd> <p>A signed integer type, the size of <strong>ErlDrvSizeT</strong>.</p> </dd><dt><a name="ErlDrvSysInfo"></a><strong>ErlDrvSysInfo</strong></dt><dd> <pre><code class="">
typedef struct ErlDrvSysInfo {
   int driver_major_version;
   int driver_minor_version;
   char *erts_version;
   char *otp_release;
   int thread_support;
   int smp_support;
   int async_threads;
   int scheduler_threads;
   int nif_major_version;
   int nif_minor_version;
   int dirty_scheduler_support;
} ErlDrvSysInfo;</code></pre> <p>The <strong>ErlDrvSysInfo</strong> structure is used for storage of
information about the Erlang runtime system.
<a href="#driver_system_info">driver_system_info</a>
writes the system information when passed a reference to
a <strong>ErlDrvSysInfo</strong> structure. The fields in the structure
are as follows:</p> <dl><dt><strong>driver_major_version</strong></dt><dd> <p>The value of <a href="#version_management">version_management</a>
when the runtime system was compiled. This value is the same
as the value of <a href="#version_management">version_management</a>
used when compiling the driver; otherwise the runtime system
would have refused to load the driver.</p> </dd><dt><strong>driver_minor_version</strong></dt><dd> <p>The value of <a href="#version_management">version_management</a>
when the runtime system was compiled. This value can differ
from the value of <a href="#version_management">version_management</a>
used when compiling the driver.</p> </dd><dt><strong>erts_version</strong></dt><dd> <p>A string containing the version number of the runtime system
(the same as returned by
<a href="./erlang#system_info_version">erlang#system_info_version</a>).</p> </dd><dt><strong>otp_release</strong></dt><dd> <p>A string containing the OTP release number
(the same as returned by
<a href="./erlang#system_info_otp_release">erlang#system_info_otp_release</a>).</p> </dd><dt><strong>thread_support</strong></dt><dd> <p>A value <strong>!= 0</strong> if the runtime system has thread support;
otherwise <strong>0</strong>.</p> </dd><dt><strong>smp_support</strong></dt><dd> <p>A value <strong>!= 0</strong> if the runtime system has SMP support;
otherwise <strong>0</strong>.</p> </dd><dt><strong>async_threads</strong></dt><dd> <p>The number of async threads in the async thread pool used by
<a href="#driver_async">driver_async</a>
(the same as returned by
<a href="./erlang#system_info_thread_pool_size">erlang#system_info_thread_pool_size</a>).</p> </dd><dt><strong>scheduler_threads</strong></dt><dd> <p>The number of scheduler threads used by the runtime system
(the same as returned by
<a href="./erlang#system_info_schedulers">erlang#system_info_schedulers</a>).</p> </dd><dt><strong>nif_major_version</strong></dt><dd> <p>The value of <strong>ERL_NIF_MAJOR_VERSION</strong> when the runtime
system was compiled.</p> </dd><dt><strong>nif_minor_version</strong></dt><dd> <p>The value of <strong>ERL_NIF_MINOR_VERSION</strong> when the runtime
system was compiled.</p> </dd><dt><strong>dirty_scheduler_support</strong></dt><dd> <p>A value <strong>!= 0</strong> if the runtime system has support for dirty
scheduler threads; otherwise <strong>0</strong>.</p> </dd></dl> </dd><dt><a name="ErlDrvBinary"></a><strong>ErlDrvBinary</strong></dt><dd> <pre><code class="">
typedef struct ErlDrvBinary {
   ErlDrvSint orig_size;
   char orig_bytes[];
} ErlDrvBinary;</code></pre> <p>The <strong>ErlDrvBinary</strong> structure is a binary, as sent
between the emulator and the driver. All binaries are
reference counted; when <strong>driver_binary_free</strong> is called,
the reference count is decremented, when it reaches zero,
the binary is deallocated. <strong>orig_size</strong> is the binary size
and <strong>orig_bytes</strong> is the buffer.
<strong>ErlDrvBinary</strong> has not a fixed size, its size is
<strong>orig_size + 2 * sizeof(int)</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The <strong>refc</strong> field has been removed. The reference count of
an <strong>ErlDrvBinary</strong> is now stored elsewhere. The
reference count of an <strong>ErlDrvBinary</strong> can be accessed through
<a href="#driver_binary_get_refc">driver_binary_get_refc</a>,
<a href="#driver_binary_inc_refc">driver_binary_inc_refc</a>, and
<a href="#driver_binary_dec_refc">driver_binary_dec_refc</a>.</p></div> <p>Some driver calls, such as <strong>driver_enq_binary</strong>,
increment the driver reference count, and others, such as
<strong>driver_deq</strong> decrement it.</p> <p>Using a driver binary instead of a normal buffer is often
faster, as the emulator needs not to copy the data,
only the pointer is used.</p> <p>A driver binary allocated in the driver, with
<strong>driver_alloc_binary</strong>, is to be freed in the driver
(unless otherwise stated)
with <strong>driver_free_binary</strong>. (Notice that this does not
necessarily deallocate it, if the driver is still referred
in the emulator, the ref-count will not go to zero.)</p> <p>Driver binaries are used in the <strong>driver_output2</strong> and
<strong>driver_outputv</strong> calls, and in the queue. Also the
driver callback <a href="./driver_entry#outputv">driver_entry#outputv</a> uses driver binaries.</p> <p>If the driver for some reason wants to keep a
driver binary around, for example in a static variable, the
reference count is to be incremented, and the binary can later
be freed in the <a href="./driver_entry#stop">driver_entry#stop</a> callback, with <strong>driver_free_binary</strong>.</p> <p>Notice that as a driver binary is shared by the driver and
the emulator. A binary received from the emulator or sent to
the emulator must not be changed by the driver.</p> <p>Since ERTS 5.5 (Erlang/OTP R11B), <strong>orig_bytes</strong> is
guaranteed to be properly aligned for storage of an array of
doubles (usually 8-byte aligned).</p> </dd><dt><strong>ErlDrvData</strong></dt><dd> <p>A handle to driver-specific data,
passed to the driver callbacks. It is a pointer, and is
most often type cast to a specific pointer in the driver.</p> </dd><dt><strong>SysIOVec</strong></dt><dd> <p>A system I/O vector, as used by <strong>writev</strong> on
Unix and <strong>WSASend</strong> on Win32. It is used in
<strong>ErlIOVec</strong>.</p> </dd><dt><a name="ErlIOVec"></a><strong>ErlIOVec</strong></dt><dd> <pre><code class="">
typedef struct ErlIOVec {
  int vsize;
  ErlDrvSizeT size;
  SysIOVec* iov;
  ErlDrvBinary** binv;
} ErlIOVec;</code></pre> <p>The I/O vector used by the emulator and drivers is a list
of binaries, with a <strong>SysIOVec</strong> pointing to the buffers
of the binaries. It is used in <strong>driver_outputv</strong> and the
<a href="./driver_entry#outputv">driver_entry#outputv</a>
driver callback. Also, the driver queue is an
<strong>ErlIOVec</strong>.</p> </dd><dt><strong>ErlDrvMonitor</strong></dt><dd> <p>When a driver creates a monitor for a process, a
<strong>ErlDrvMonitor</strong> is filled in. This is an opaque
data type that can be assigned to, but not compared without
using the supplied compare function (that is, it behaves like
a struct).</p> <p>The driver writer is to provide the memory for storing the
monitor when calling <a href="#driver_monitor_process">driver_monitor_process</a>. The
address of the data is not stored outside of the driver, so
<strong>ErlDrvMonitor</strong> can be used as any other data, it
can be copied, moved in memory, forgotten, and so on.</p> </dd><dt><a name="ErlDrvNowData"></a><strong>ErlDrvNowData</strong></dt><dd> <p>The <strong>ErlDrvNowData</strong> structure holds a time stamp
consisting of three values measured from some arbitrary
point in the past. The three structure members are:</p> <dl><dt><strong>megasecs</strong></dt><dd>The number of whole megaseconds elapsed since the arbitrary point in time</dd><dt><strong>secs</strong></dt><dd>The number of whole seconds elapsed since the arbitrary point in time</dd><dt><strong>microsecs</strong></dt><dd>The number of whole microseconds elapsed since the arbitrary point in time</dd></dl> </dd><dt><a name="ErlDrvPDL"></a><strong>ErlDrvPDL</strong></dt><dd> <p>If certain port-specific data must be accessed from other
threads than those calling the driver callbacks, a port data lock
can be used to synchronize the operations on the data.
Currently, the only port-specific data that the emulator
associates with the port data lock is the driver queue.</p> <p>Normally a driver instance has no port data lock. If
the driver instance wants to use a port data lock, it must
create the port data lock by calling
<a href="#driver_pdl_create">driver_pdl_create</a>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Once the port data lock has been created, every
access to data associated with the port data lock must be done
while the port data lock is locked. The port data lock is
locked and unlocked by
<a href="#driver_pdl_lock">driver_pdl_lock</a>, and
<a href="#driver_pdl_unlock">driver_pdl_unlock</a>, respectively.</p></div> <p>A port data lock is reference counted, and when the reference
count reaches zero, it is destroyed. The emulator at
least increments the reference count once when the lock is
created and decrements it once the port associated with
the lock terminates. The emulator also increments the
reference count when an async job is enqueued and decrements
it when an async job has been invoked.
Also, the driver is responsible for ensuring that
the reference count does not reach zero before the last use
of the lock by the driver has been made. The reference count
can be read, incremented, and decremented by
<a href="#driver_pdl_get_refc">driver_pdl_get_refc</a>,
<a href="#driver_pdl_inc_refc">driver_pdl_inc_refc</a>, and
<a href="#driver_pdl_dec_refc">driver_pdl_dec_refc</a>, respectively.</p> </dd><dt><a name="ErlDrvTid"></a><strong>ErlDrvTid</strong></dt><dd> <p>Thread identifier.</p> <p>See also <a href="#erl_drv_thread_create">erl_drv_thread_create</a>,
<a href="#erl_drv_thread_exit">erl_drv_thread_exit</a>,
<a href="#erl_drv_thread_join">erl_drv_thread_join</a>,
<a href="#erl_drv_thread_self">erl_drv_thread_self</a>, and
<a href="#erl_drv_equal_tids">erl_drv_equal_tids</a>.</p> </dd><dt><a name="ErlDrvThreadOpts"></a><strong>ErlDrvThreadOpts</strong></dt><dd> <pre><code class="">
int suggested_stack_size;</code></pre> <p>Thread options structure passed to
<a href="#erl_drv_thread_create">erl_drv_thread_create</a>.
The following field exists:</p> <dl><dt><strong>suggested_stack_size</strong></dt><dd>A suggestion, in kilowords, on how large a stack to use. A value &lt; 0 means default size. </dd></dl> <p>See also <a href="#erl_drv_thread_opts_create">erl_drv_thread_opts_create</a>,
<a href="#erl_drv_thread_opts_destroy">erl_drv_thread_opts_destroy</a>, and
<a href="#erl_drv_thread_create">erl_drv_thread_create</a>.</p> </dd><dt><a name="ErlDrvMutex"></a><strong>ErlDrvMutex</strong></dt><dd> <p>Mutual exclusion lock. Used for synchronizing access to shared data.
Only one thread at a time can lock a mutex.</p> <p>See also <a href="#erl_drv_mutex_create">erl_drv_mutex_create</a>,
<a href="#erl_drv_mutex_destroy">erl_drv_mutex_destroy</a>,
<a href="#erl_drv_mutex_lock">erl_drv_mutex_lock</a>,
<a href="#erl_drv_mutex_trylock">erl_drv_mutex_trylock</a>, and
<a href="#erl_drv_mutex_unlock">erl_drv_mutex_unlock</a>.</p> </dd><dt><a name="ErlDrvCond"></a><strong>ErlDrvCond</strong></dt><dd> <p>Condition variable. Used when threads must wait for a specific
condition to appear before continuing execution. Condition variables
must be used with associated mutexes.</p> <p>See also <a href="#erl_drv_cond_create">erl_drv_cond_create</a>,
<a href="#erl_drv_cond_destroy">erl_drv_cond_destroy</a>,
<a href="#erl_drv_cond_signal">erl_drv_cond_signal</a>,
<a href="#erl_drv_cond_broadcast">erl_drv_cond_broadcast</a>, and
<a href="#erl_drv_cond_wait">erl_drv_cond_wait</a>.</p> </dd><dt><a name="ErlDrvRWLock"></a><strong>ErlDrvRWLock</strong></dt><dd> <p>Read/write lock. Used to allow multiple threads to read shared data
while only allowing one thread to write the same data. Multiple
threads can read lock an rwlock at the same time, while only
one thread can read/write lock an rwlock at a time.</p> <p>See also <a href="#erl_drv_rwlock_create">erl_drv_rwlock_create</a>,
<a href="#erl_drv_rwlock_destroy">erl_drv_rwlock_destroy</a>,
<a href="#erl_drv_rwlock_rlock">erl_drv_rwlock_rlock</a>,
<a href="#erl_drv_rwlock_tryrlock">erl_drv_rwlock_tryrlock</a>,
<a href="#erl_drv_rwlock_runlock">erl_drv_rwlock_runlock</a>,
<a href="#erl_drv_rwlock_rwlock">erl_drv_rwlock_rwlock</a>,
<a href="#erl_drv_rwlock_tryrwlock">erl_drv_rwlock_tryrwlock</a>, and
<a href="#erl_drv_rwlock_rwunlock">erl_drv_rwlock_rwunlock</a>.</p> </dd><dt><a name="ErlDrvTSDKey"></a><strong>ErlDrvTSDKey</strong></dt><dd> <p>Key that thread-specific data can be associated with.</p> <p>See also <a href="#erl_drv_tsd_key_create">erl_drv_tsd_key_create</a>,
<a href="#erl_drv_tsd_key_destroy">erl_drv_tsd_key_destroy</a>,
<a href="#erl_drv_tsd_set">erl_drv_tsd_set</a>, and
<a href="#erl_drv_tsd_get">erl_drv_tsd_get</a>.</p> </dd><dt><a name="ErlDrvTime"></a><strong>ErlDrvTime</strong></dt><dd> <p>A signed 64-bit integer type for time representation.</p> </dd><dt><a name="ErlDrvTimeUnit"></a><strong>ErlDrvTimeUnit</strong></dt><dd> <p>An enumeration of time units supported by the driver API:</p> <dl><dt><strong>ERL_DRV_SEC</strong></dt><dd>Seconds</dd><dt><strong>ERL_DRV_MSEC</strong></dt><dd>Milliseconds</dd><dt><strong>ERL_DRV_USEC</strong></dt><dd>Microseconds</dd><dt><strong>ERL_DRV_NSEC</strong></dt><dd>Nanoseconds</dd></dl> </dd></dl><h2>Functions</h2><h3>add_driver_entry(ErlDrvEntry
        *de):void</h3><p>Add a driver entry.</p><a name="add_driver_entry"></a><p>Adds a driver entry to the list of drivers known by Erlang.
The <a href="./driver_entry#init">driver_entry#init</a>
function of parameter <strong>de</strong> is called.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>To use this function for adding drivers residing in
dynamically loaded code is dangerous. If the driver code
for the added driver resides in the same dynamically
loaded module (that is, <strong>.so</strong> file) as a normal
dynamically loaded driver (loaded with the <strong>erl_ddll</strong>
interface), the caller is to call
<a href="#driver_lock_driver">driver_lock_driver</a> before
adding driver entries.</p><p><em>Use of this function is generally deprecated.</em></p></div><h3>driver_alloc(ErlDrvSizeT size):void *</h3><p>Allocate memory.</p><a name="driver_alloc"></a><p>Allocates a memory block of the size specified
in <strong>size</strong>, and returns it. This fails only on out of
memory, in which case <strong>NULL</strong> is returned. (This is most
often a wrapper for <strong>malloc</strong>).</p><p>Memory allocated must be explicitly freed with a corresponding
call to <a href="#driver_free">driver_free</a>
(unless otherwise stated).</p><p>This function is thread-safe.</p><h3>driver_alloc_binary(ErlDrvSizeT size):ErlDrvBinary *</h3><p>Allocate a driver binary.</p><a name="driver_alloc_binary"></a><p>Allocates a driver binary with a memory block
of at least <strong>size</strong> bytes, and returns a pointer to it,
or <strong>NULL</strong> on failure (out of memory). When a driver binary has
been sent to the emulator, it must not be changed. Every
allocated binary is to be freed by a corresponding call to
<a href="#driver_free_binary">driver_free_binary</a> (unless otherwise stated).</p><p>Notice that a driver binary has an internal reference counter.
This means that calling <strong>driver_free_binary</strong>, it may not
actually dispose of it. If it is sent to the emulator, it can
be referenced there.</p><p>The driver binary has a field, <strong>orig_bytes</strong>, which
marks the start of the data in the binary.</p><p>This function is thread-safe.</p><h3>driver_async(ErlDrvPort port, unsigned
        int* key, void (*async_invoke)(void*), void* async_data, void
        (*async_free)(void*)):long</h3><p>Perform an asynchronous call within a driver.</p><a name="driver_async"></a><p>Performs an asynchronous call. The function
<strong>async_invoke</strong> is invoked in a thread separate from the
emulator thread. This enables the driver to perform
time-consuming, blocking operations without blocking the
emulator.</p><p>The async thread pool size can be set with command-line argument
<a href="./erl#async_thread_pool_size">erl#async_thread_pool_size</a>
in <a href="erl">erl</a>.
If an async thread pool is unavailable, the call is made
synchronously in the thread calling <strong>driver_async</strong>. The
current number of async threads in the async thread pool can be
retrieved through <a href="#driver_system_info">driver_system_info</a>.</p><p>If a thread pool is available, a thread is used.
If argument <strong>key</strong> is <strong>NULL</strong>, the threads from the
pool are used in a round-robin way, each call to
<strong>driver_async</strong> uses the next thread in the pool. With
argument <strong>key</strong> set, this behavior is changed. The two
same values of <strong>*key</strong> always get the same thread.</p><p>To ensure that a driver instance always uses the same
thread, the following call can be used:</p><pre><code class="">
unsigned int myKey = driver_async_port_key(myPort);

r = driver_async(myPort, &amp;myKey, myData, myFunc);    </code></pre><p>It is enough to initialize <strong>myKey</strong> once for each
driver instance.</p><p>If a thread is already working, the calls are
queued up and executed in order. Using the same thread for
each driver instance ensures that the calls are made in sequence.</p><p>The <strong>async_data</strong> is the argument to the functions
<strong>async_invoke</strong> and <strong>async_free</strong>. It is typically a
pointer to a structure containing a pipe or event that
can be used to signal that the async operation completed.
The data is to be freed in <strong>async_free</strong>.</p><p>When the async operation is done,
<a href="./driver_entry#ready_async">driver_entry#ready_async</a> driver
entry function is called. If <strong>ready_async</strong> is <strong>NULL</strong> in
the driver entry, the <strong>async_free</strong> function is called
instead.</p><p>The return value is <strong>-1</strong> if the <strong>driver_async</strong> call
fails.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>As from ERTS 5.5.4.3 the default stack size for
threads in the async-thread pool is 16 kilowords,
that is, 64 kilobyte on 32-bit architectures.
This small default size has been chosen because the
amount of async-threads can be quite large. The
default stack size is enough for drivers delivered
with Erlang/OTP, but is possibly not sufficiently large
for other dynamically linked-in drivers that use the
<strong>driver_async</strong> functionality. A suggested stack size
for threads in the async-thread pool can be configured
through command-line argument
<a href="./erl#async_thread_stack_size">erl#async_thread_stack_size</a>
in <a href="erl">erl</a>.</p></div><h3>driver_async_port_key(ErlDrvPort
        port):unsigned int</h3><p>Calculate an async key from an ErlDrvPort.</p><a name="driver_async_port_key"></a><p>Calculates a key for later use in <a href="#driver_async">driver_async</a>. The keys are
evenly distributed so that a fair mapping between port IDs
and async thread IDs is achieved.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Before Erlang/OTP R16, the port ID could be used as a key
with proper casting, but after the rewrite of the port
subsystem, this is no longer the case. With this function, you
can achieve the same distribution based on port IDs as before
Erlang/OTP R16.</p></div><h3>driver_binary_dec_refc(ErlDrvBinary *bin):long</h3><p>Decrement the reference count of a driver binary.</p><a name="driver_binary_dec_refc"></a><p>Decrements the reference count on <strong>bin</strong> and returns
the reference count reached after the decrement.</p><p>This function is thread-safe.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The reference count of driver binary is normally to be decremented
by calling <a href="#driver_free_binary">driver_free_binary</a>.</p><p><strong>driver_binary_dec_refc</strong> does <em>not</em> free
the binary if the reference count reaches zero. <em>Only</em>
use <strong>driver_binary_dec_refc</strong> when you are sure
<em>not</em> to reach a reference count of zero.</p></div><h3>driver_binary_get_refc(ErlDrvBinary *bin):long</h3><p>Get the reference count of a driver binary.</p><a name="driver_binary_get_refc"></a><p>Returns the current reference count on <strong>bin</strong>.</p><p>This function is thread-safe.</p><h3>driver_binary_inc_refc(ErlDrvBinary *bin):long</h3><p>Increment the reference count of a driver binary.</p><a name="driver_binary_inc_refc"></a><p>Increments the reference count on <strong>bin</strong> and returns
the reference count reached after the increment.</p><p>This function is thread-safe.</p><h3>driver_caller(ErlDrvPort
        port):ErlDrvTermData</h3><p>Return the process making the driver call.</p><a name="driver_caller"></a><p>Returns the process ID of the process that
made the current call to the driver. The process ID can be used with
<a href="#driver_send_term">driver_send_term</a>
to send back data to the caller.
<strong>driver_caller</strong> only returns valid data
when currently executing in one of the following driver callbacks:</p><dl><dt><a href="./driver_entry#start">driver_entry#start</a></dt><dd>Called from <a href="./erlang#open_port/2">erlang#open_port/2</a>.</dd><dt><a href="./driver_entry#output">driver_entry#output</a></dt><dd>Called from <a href="./erlang#send/2">erlang#send/2</a> and <a href="./erlang#port_command/2">erlang#port_command/2</a>.</dd><dt><a href="./driver_entry#outputv">driver_entry#outputv</a></dt><dd>Called from <a href="./erlang#send/2">erlang#send/2</a> and <a href="./erlang#port_command/2">erlang#port_command/2</a>.</dd><dt><a href="./driver_entry#control">driver_entry#control</a></dt><dd>Called from <a href="./erlang#port_control/3">erlang#port_control/3</a>.</dd><dt><a href="./driver_entry#call">driver_entry#call</a></dt><dd>Called from <a href="./erlang#port_call/3">erlang#port_call/3</a>.</dd></dl><p>Notice that this function is <em>not</em> thread-safe, not
even when the emulator with SMP support is used.</p><h3>driver_cancel_timer(ErlDrvPort port):int</h3><p>Cancel a previously set timer.</p><a name="driver_cancel_timer"></a><p>Cancels a timer set with
<a href="#driver_set_timer">driver_set_timer</a>.</p><p>The return value is <strong>0</strong>.</p><h3>driver_compare_monitors(const ErlDrvMonitor
        *monitor1, const ErlDrvMonitor *monitor2):int</h3><p>Compare two monitors.</p><a name="driver_compare_monitors"></a><p>Compares two <strong>ErlDrvMonitor</strong>s.
Can also be used to imply some artificial order on monitors,
for whatever reason.</p><p>Returns <strong>0</strong> if <strong>monitor1</strong> and <strong>monitor2</strong> are equal,
&lt; <strong>0</strong> if <strong>monitor1</strong> &lt; <strong>monitor2</strong>, and
&gt; <strong>0</strong> if <strong>monitor1</strong> &gt; <strong>monitor2</strong>.</p><h3>driver_connected(ErlDrvPort
        port):ErlDrvTermData</h3><p>Return the port owner process.</p><a name="driver_connected"></a><p>Returns the port owner process.</p><p>Notice that this function is <em>not</em> thread-safe, not
even when the emulator with SMP support is used.</p><h3>driver_create_port(ErlDrvPort port,
        ErlDrvTermData owner_pid, char* name,
        ErlDrvData drv_data):ErlDrvPort</h3><p>Create a new port (driver instance).</p><p>Creates a new port executing the same driver
code as the port creating the new port.</p><dl><dt><strong>port</strong></dt><dd>The port handle of the port (driver instance) creating the new port.</dd><dt><strong>owner_pid</strong></dt><dd>The process ID of the Erlang process to become owner of the new port. This process will be linked to the new port. You usually want to use <strong>driver_caller(port)</strong> as <strong>owner_pid</strong>.</dd><dt><strong>name</strong></dt><dd>The port name of the new port. You usually want to use the same port name as the driver name (<a href="./driver_entry#driver_name">driver_entry#driver_name</a> field of the <a href="driver_entry">driver_entry</a>). </dd><dt><strong>drv_data</strong></dt><dd>The driver-defined handle that is passed in later calls to driver callbacks. Notice that the <a href="./driver_entry#start">driver start callback</a> is not called for this new driver instance. The driver-defined handle is normally created in the <a href="./driver_entry#start">driver start callback</a> when a port is created through <a href="./erlang#open_port/2">erlang#open_port/2</a>. </dd></dl><p>The caller of <strong>driver_create_port</strong> is allowed to
manipulate the newly created port when <strong>driver_create_port</strong>
has returned. When
<a href="#smp_support">port level locking</a>
is used, the creating port is only allowed to
manipulate the newly created port until the current driver
callback, which was called by the emulator, returns.</p><h3>driver_demonitor_process(ErlDrvPort port,
        const ErlDrvMonitor *monitor):int</h3><p>Stop monitoring a process from a driver.</p><a name="driver_demonitor_process"></a><p>Cancels a monitor created earlier.</p><p>Returns <strong>0</strong> if a monitor was removed and &gt; 0 if the monitor
no longer exists.</p><h3>driver_deq(ErlDrvPort port,
        ErlDrvSizeT size):ErlDrvSizeT</h3><p>Dequeue data from the head of the driver queue.</p><a name="driver_deq"></a><p>Dequeues data by moving the head pointer
forward in the driver queue by <strong>size</strong> bytes. The data
in the queue is deallocated.</p><p>Returns the number of bytes remaining in the queue on success,
otherwise <strong>-1</strong>.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><h3>driver_enq(ErlDrvPort port, char* buf,
        ErlDrvSizeT len):int</h3><p>Enqueue data in the driver queue.</p><a name="driver_enq"></a><p>Enqueues data in the driver queue. The data in
<strong>buf</strong> is copied (<strong>len</strong> bytes) and placed at the
end of the driver queue. The driver queue is normally used
in a FIFO way.</p><p>The driver queue is available to queue output from the
emulator to the driver (data from the driver to the emulator
is queued by the emulator in normal Erlang message
queues). This can be useful if the driver must wait for
slow devices, and so on, and wants to yield back to the
emulator. The driver queue is implemented as an <strong>ErlIOVec</strong>.</p><p>When the queue contains data, the driver does not close until
the queue is empty.</p><p>The return value is <strong>0</strong>.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><h3>driver_enq_bin(ErlDrvPort port,
        ErlDrvBinary *bin, ErlDrvSizeT offset, ErlDrvSizeT len):int</h3><p>Enqueue binary in the driver queue.</p><a name="driver_enq_bin"></a><p>Enqueues a driver binary in the driver
queue. The data in <strong>bin</strong> at <strong>offset</strong> with length
<strong>len</strong> is placed at the end of the queue. This function
is most often faster than
<a href="#driver_enq">driver_enq</a>,
because no data must be copied.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><p>The return value is <strong>0</strong>.</p><h3>driver_enqv(ErlDrvPort port, ErlIOVec *ev,
        ErlDrvSizeT skip):int</h3><p>Enqueue vector in the driver queue.</p><a name="driver_enqv"></a><p>Enqueues the data in <strong>ev</strong>, skipping the
first <strong>skip</strong> bytes of it, at the end of the driver
queue. It is faster than
<a href="#driver_enq">driver_enq</a>,
because no data must be copied.</p><p>The return value is <strong>0</strong>.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><h3>driver_failure(ErlDrvPort port, int
        error):int</h3><h3>driver_failure_atom(ErlDrvPort port, char
        *string):int</h3><h3>driver_failure_posix(ErlDrvPort port, int
        error):int</h3><p>Fail with error.</p><a name="driver_failure_atom"></a><a name="driver_failure_posix"></a><a name="driver_failure"></a><p>Signals to Erlang that the driver has
encountered an error and is to be closed. The port is
closed and the tuple <strong>{'EXIT', error, Err}</strong> is sent to
the port owner process, where error is an error atom
(<strong>driver_failure_atom</strong> and
<strong>driver_failure_posix</strong>) or an integer
(<strong>driver_failure</strong>).</p><p>The driver is to fail only when in severe error situations,
when the driver cannot possibly keep open, for example,
buffer allocation gets out of memory. For normal errors
it is more appropriate to send error codes with
<a href="#driver_output">driver_output</a>.</p><p>The return value is <strong>0</strong>.</p><h3>driver_failure_eof(ErlDrvPort
        port):int</h3><p>Fail with EOF.</p><a name="driver_failure_eof"></a><p>Signals to Erlang that the driver has
encountered an EOF and is to be closed, unless the port was
opened with option <strong>eof</strong>, in which case <strong>eof</strong> is sent
to the port. Otherwise the port is closed and an
<strong>'EXIT'</strong> message is sent to the port owner process.</p><p>The return value is <strong>0</strong>.</p><h3>driver_free(void *ptr):void</h3><p>Free an allocated memory block.</p><a name="driver_free"></a><p>Frees the memory pointed to by <strong>ptr</strong>. The
memory is to have been allocated with
<strong>driver_alloc</strong>. All allocated memory is to be
deallocated, only once. There is no garbage collection in
drivers.</p><p>This function is thread-safe.</p><h3>driver_free_binary(ErlDrvBinary *bin):void</h3><p>Free a driver binary.</p><a name="driver_free_binary"></a><p>Frees a driver binary <strong>bin</strong>, allocated previously with
<a href="#driver_alloc_binary">driver_alloc_binary</a>. As binaries
in Erlang are reference counted, the binary can still be around.</p><p>This function is thread-safe.</p><h3>driver_get_monitored_process(ErlDrvPort port, const
        ErlDrvMonitor *monitor):ErlDrvTermData</h3><p>Retrieve the process ID from a monitor.</p><a name="driver_get_monitored_process"></a><p>Returns the process ID associated with a living
monitor. It can be used in the
<a href="./driver_entry#process_exit">driver_entry#process_exit</a> callback to
get the process identification for the exiting process.</p><p>Returns <strong>driver_term_nil</strong> if the monitor no longer exists.</p><h3>driver_get_now(ErlDrvNowData *now):int</h3><p>Read a system time stamp.</p><a name="driver_get_now"></a><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p><em>This function is deprecated. Do not use it.</em> Use
<a href="#erl_drv_monotonic_time">erl_drv_monotonic_time</a> (perhaps in combination with
<a href="#erl_drv_time_offset">erl_drv_time_offset</a>) instead.</p></div><p>Reads a time stamp into the memory pointed to by
parameter <strong>now</strong>. For information about specific fields, see
<a href="#ErlDrvNowData">ErlDrvNowData</a>.</p><p>The return value is <strong>0</strong>, unless the <strong>now</strong> pointer is
invalid, in which case it is &lt; <strong>0</strong>.</p><h3>driver_lock_driver(ErlDrvPort
        port):int</h3><p>Ensure the driver is never unloaded.</p><a name="driver_lock_driver"></a><p>Locks the driver used by the port <strong>port</strong>
in memory for the rest of the emulator process'
lifetime. After this call, the driver behaves as one of Erlang's
statically linked-in drivers.</p><h3>driver_mk_atom(char*
        string):ErlDrvTermData</h3><p>Make an atom from a name.</p><a name="driver_mk_atom"></a><p>Returns an atom given a name
<strong>string</strong>. The atom is created and does not change, so the
return value can be saved and reused, which is faster than
looking up the atom several times.</p><p>Notice that this function is <em>not</em> thread-safe, not
even when the emulator with SMP support is used.</p><h3>driver_mk_port(ErlDrvPort
        port):ErlDrvTermData</h3><p>Make an Erlang term port from a port.</p><a name="driver_mk_port"></a><p>Converts a port handle to the Erlang term format, usable in
<a href="#erl_drv_output_term">erl_drv_output_term</a> and 
<a href="#erl_drv_send_term">erl_drv_send_term</a>.</p><p>Notice that this function is <em>not</em> thread-safe, not
even when the emulator with SMP support is used.</p><h3>driver_monitor_process(ErlDrvPort port,
        ErlDrvTermData process, ErlDrvMonitor *monitor):int</h3><p>Monitor a process from a driver.</p><a name="driver_monitor_process"></a><p>Starts monitoring a process from a driver. When a process is
monitored, a process exit results in a call to the provided
<a href="./driver_entry#process_exit">driver_entry#process_exit</a> callback
in the <a href="driver_entry">driver_entry</a>
structure. The <strong>ErlDrvMonitor</strong> structure is filled in, for later
removal or compare.</p><p>Parameter <strong>process</strong> is to be the return value of an
earlier call to <a href="#driver_caller">driver_caller</a> or
<a href="#driver_connected">driver_connected</a>
call.</p><p>Returns <strong>0</strong> on success, &lt; 0 if no callback is
provided, and &gt; 0 if the process is no longer alive.</p><h3>driver_output(ErlDrvPort port, char *buf,
        ErlDrvSizeT len):int</h3><p>Send data from driver to port owner.</p><a name="driver_output"></a><p>Sends data from the driver up to the emulator. The data is received
as terms or binary data, depending on how the driver port was
opened.</p><p>The data is queued in the port owner process' message
queue. Notice that this does not yield to the emulator (as
the driver and the emulator run in the same thread).</p><p>Parameter <strong>buf</strong> points to the data to send, and
<strong>len</strong> is the number of bytes.</p><p>The return value for all output functions is <strong>0</strong> for normal use.
If the driver is used for distribution, it can fail and return
<strong>-1</strong>.</p><h3>driver_output_binary(ErlDrvPort port, char
        *hbuf, ErlDrvSizeT hlen, ErlDrvBinary* bin, ErlDrvSizeT offset,
        ErlDrvSizeT len):int</h3><p>Send data from a driver binary to port owner.</p><a name="driver_output_binary"></a><p>Sends data to a port owner process from a
driver binary. It has a header buffer (<strong>hbuf</strong>
and <strong>hlen</strong>) just like
<a href="#driver_output2">driver_output2</a>.
Parameter <strong>hbuf</strong> can be <strong>NULL</strong>.</p><p>Parameter <strong>offset</strong> is an offset into the binary and
<strong>len</strong> is the number of bytes to send.</p><p>Driver binaries are created with
<a href="#driver_alloc_binary">driver_alloc_binary</a>.</p><p>The data in the header is sent as a list and the binary as
an Erlang binary in the tail of the list.</p><p>For example, if <strong>hlen</strong> is <strong>2</strong>, the port owner process
receives <strong>[H1, H2 | &lt;&lt;T&gt;&gt;]</strong>.</p><p>The return value is <strong>0</strong> for normal use.</p><p>Notice that, using the binary syntax in Erlang, the driver
application can match the header directly from the binary,
so the header can be put in the binary, and <strong>hlen</strong> can be set
to <strong>0</strong>.</p><h3>driver_output_term(ErlDrvPort port,
        ErlDrvTermData* term, int n):int</h3><p>Send term data from driver to port owner.</p><a name="driver_output_term"></a><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p><em>This function is deprecated.</em>
Use <a href="#erl_drv_send_term">erl_drv_send_term</a>instead.</p></div><p>Parameters <strong>term</strong> and <strong>n</strong> work as in
<a href="#erl_drv_output_term">erl_drv_output_term</a>.</p><p>Notice that this function is <em>not</em> thread-safe, not
even when the emulator with SMP support is used.</p><h3>driver_output2(ErlDrvPort port, char *hbuf,
        ErlDrvSizeT hlen, char *buf, ErlDrvSizeT len):int</h3><p>Send data and binary data to port owner.</p><a name="driver_output2"></a><p>First sends <strong>hbuf</strong>
(length in <strong>hlen</strong>) data as a list, regardless of port
settings. Then sends <strong>buf</strong> as a binary or list.
For example, if <strong>hlen</strong> is <strong>3</strong>, the port owner process
receives <strong>[H1, H2, H3 | T]</strong>.</p><p>The point of sending data as a list header, is to facilitate
matching on the data received.</p><p>The return value is <strong>0</strong> for normal use.</p><h3>driver_outputv(ErlDrvPort port, char* hbuf,
        ErlDrvSizeT hlen, ErlIOVec *ev, ErlDrvSizeT skip):int</h3><p>Send vectorized data to port owner.</p><a name="driver_outputv"></a><p>Sends data from an I/O vector, <strong>ev</strong>, to
the port owner process. It has a header buffer (<strong>hbuf</strong>
and <strong>hlen</strong>), just like <a href="#driver_output2">driver_output2</a>.</p><p>Parameter <strong>skip</strong> is a number of bytes to skip of
the <strong>ev</strong> vector from the head.</p><p>You get vectors of <strong>ErlIOVec</strong> type from the driver
queue (see below), and the
<a href="./driver_entry#outputv">driver_entry#outputv</a>
driver entry function. You can also make them yourself, if you want to
send several <strong>ErlDrvBinary</strong> buffers at once. Often
it is faster to use
<a href="#driver_output">driver_output</a> or
<a href="#driver_output_binary">driver_output_binary</a>.</p><p>For example, if <strong>hlen</strong> is <strong>2</strong> and <strong>ev</strong> points to an
array of three binaries, the port owner process receives
<strong>[H1, H2, &lt;&lt;B1&gt;&gt;, &lt;&lt;B2&gt;&gt; | &lt;&lt;B3&gt;&gt;]</strong>.</p><p>The return value is <strong>0</strong> for normal use.</p><p>The comment for <strong>driver_output_binary</strong> also applies for
<strong>driver_outputv</strong>.</p><h3>driver_pdl_create(ErlDrvPort port):ErlDrvPDL</h3><p>Create a port data lock.</p><a name="driver_pdl_create"></a><p>Creates a port data lock associated with the <strong>port</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Once a port data lock has been created, it must be locked during
all operations on the driver queue of the <strong>port</strong>.</p></div><p>Returns a newly created port data lock on success,
otherwise <strong>NULL</strong>. The function fails
if <strong>port</strong> is invalid or if a port data lock already has
been associated with the <strong>port</strong>.</p><h3>driver_pdl_dec_refc(ErlDrvPDL
        pdl):long</h3><a name="driver_pdl_dec_refc"></a><p>Decrements the reference count of
the port data lock passed as argument (<strong>pdl</strong>).</p><p>The current reference count after the decrement has
been performed is returned.</p><p>This function is thread-safe.</p><h3>driver_pdl_get_refc(ErlDrvPDL pdl):long</h3><a name="driver_pdl_get_refc"></a><p>Returns the current reference count of
the port data lock passed as argument (<strong>pdl</strong>).</p><p>This function is thread-safe.</p><h3>driver_pdl_inc_refc(ErlDrvPDL pdl):long</h3><a name="driver_pdl_inc_refc"></a><p>Increments the reference count of
the port data lock passed as argument (<strong>pdl</strong>).</p><p>The current reference count after the increment has
been performed is returned.</p><p>This function is thread-safe.</p><h3>driver_pdl_lock(ErlDrvPDL pdl):void</h3><p>Lock port data lock.</p><a name="driver_pdl_lock"></a><p>Locks the port data lock passed as argument (<strong>pdl</strong>).</p><p>This function is thread-safe.</p><h3>driver_pdl_unlock(ErlDrvPDL pdl):void</h3><p>Unlock port data lock.</p><a name="driver_pdl_unlock"></a><p>Unlocks the port data lock passed as argument (<strong>pdl</strong>).</p><p>This function is thread-safe.</p><h3>driver_peekq(ErlDrvPort port, int
        *vlen):SysIOVec *</h3><p>Get the driver queue as a vector.</p><a name="driver_peekq"></a><p>Retrieves the driver queue as a pointer to an
array of <strong>SysIOVec</strong>s. It also returns the number of
elements in <strong>vlen</strong>. This is one of two ways to get data
out of the queue.</p><p>Nothing is removed from the queue by this function, that must be done
with <a href="#driver_deq">driver_deq</a>.</p><p>The returned array is suitable to use with the Unix system
call <strong>writev</strong>.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><h3>driver_peekqv(ErlDrvPort port,
        ErlIOVec *ev):ErlDrvSizeT</h3><p>Get the driver queue as an I/O vector.</p><a name="driver_peekqv"></a><p>Retrieves the driver queue into a supplied
<strong>ErlIOVec</strong> <strong>ev</strong>. It also returns the queue size.
This is one of two ways to get data out of the queue.</p><p>If <strong>ev</strong> is <strong>NULL</strong>, all ones that is <strong>-1</strong> type cast to
<strong>ErlDrvSizeT</strong> are returned.</p><p>Nothing is removed from the queue by this function, that must be done
with <a href="#driver_deq">driver_deq</a>.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><h3>driver_pushq(ErlDrvPort port, char* buf,
        ErlDrvSizeT len):int</h3><p>Push data at the head of the driver queue.</p><a name="driver_pushq"></a><p>Puts data at the head of the driver queue. The
data in <strong>buf</strong> is copied (<strong>len</strong> bytes) and placed
at the beginning of the queue.</p><p>The return value is <strong>0</strong>.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><h3>driver_pushq_bin(ErlDrvPort port,
        ErlDrvBinary *bin, ErlDrvSizeT offset, ErlDrvSizeT len):int</h3><p>Push binary at the head of the driver queue.</p><a name="driver_pushq_bin"></a><p>Puts data in the binary <strong>bin</strong>, at
<strong>offset</strong> with length <strong>len</strong> at the head of the
driver queue. It is most often faster than
<a href="#driver_pushq">driver_pushq</a>,
because no data must be copied.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><p>The return value is <strong>0</strong>.</p><h3>driver_pushqv(ErlDrvPort port, ErlIOVec
        *ev, ErlDrvSizeT skip):int</h3><p>Push vector at the head of the driver queue.</p><a name="driver_pushqv"></a><p>Puts the data in <strong>ev</strong>, skipping the first
<strong>skip</strong> bytes of it, at the head of the driver queue.
It is faster than
<a href="#driver_pushq">driver_pushq</a>,
because no data must be copied.</p><p>The return value is <strong>0</strong>.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><h3>driver_read_timer(ErlDrvPort port, unsigned
        long *time_left):int</h3><p>Read the time left before time-out.</p><a name="driver_read_timer"></a><p>Reads the current time of a timer, and places
the result in <strong>time_left</strong>. This is the time in
milliseconds, before the time-out occurs.</p><p>The return value is <strong>0</strong>.</p><h3>driver_realloc(void *ptr, ErlDrvSizeT size):void *</h3><p>Resize an allocated memory block.</p><a name="driver_realloc"></a><p>Resizes a memory block, either in place, or by
allocating a new block, copying the data, and freeing the old
block. A pointer is returned to the reallocated memory. On
failure (out of memory), <strong>NULL</strong> is returned. (This is
most often a wrapper for <strong>realloc</strong>.)</p><p>This function is thread-safe.</p><h3>driver_realloc_binary(ErlDrvBinary *bin, ErlDrvSizeT size)
:ErlDrvBinary *</h3><p>Resize a driver binary.</p><a name="driver_realloc_binary"></a><p>Resizes a driver binary, while keeping the data.</p><p>Returns the resized driver binary on success. Returns <strong>NULL</strong>
on failure (out of memory).</p><p>This function is thread-safe.</p><h3>driver_select(ErlDrvPort port, ErlDrvEvent
        event, int mode, int on):int</h3><p>Provides an event for having the emulator call the driver. </p><a name="driver_select"></a><p>This function is used by drivers to provide the emulator with
events to check for. This enables the emulator to call the driver
when something has occurred asynchronously.</p><p>Parameter <strong>event</strong> identifies an OS-specific event object.
On Unix systems, the functions <strong>select</strong>/<strong>poll</strong> are used.
The event object must be a socket or pipe (or other object that
<strong>select</strong>/<strong>poll</strong> can use).
On Windows, the Win32 API function <strong>WaitForMultipleObjects</strong>
is used. This places other restrictions on the event object;
see the Win32 SDK documentation.</p><p>Parameter <strong>on</strong> is to be <strong>1</strong> for setting events
and <strong>0</strong> for clearing them.</p><p>Parameter <strong>mode</strong> is a bitwise OR combination of
<strong>ERL_DRV_READ</strong>, <strong>ERL_DRV_WRITE</strong>, and <strong>ERL_DRV_USE</strong>.
The first two specify whether to wait for read events and/or write
events. A fired read event calls
<a href="./driver_entry#ready_input">driver_entry#ready_input</a> and a fired write event calls
<a href="./driver_entry#ready_output">driver_entry#ready_output</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Some OS (Windows) do not differentiate between read and write
events. The callback for a fired event then only depends on the
value of <strong>mode</strong>.</p></div><p><strong>ERL_DRV_USE</strong> specifies if we are using the event object or
if we want to close it.
On an emulator with SMP support, it is not safe to clear all events
and then close the event object after <strong>driver_select</strong> has
returned. Another thread can still be using the event object
internally. To safely close an event object, call
<strong>driver_select</strong> with <strong>ERL_DRV_USE</strong> and <strong>on==0</strong>, which
clears all events and then either calls
<a href="./driver_entry#stop_select">driver_entry#stop_select</a>
or schedules it to be called when it is safe to close the event
object. <strong>ERL_DRV_USE</strong> is to be set together with the first event
for an event object. It is harmless to set <strong>ERL_DRV_USE</strong>
even if it already has been done. Clearing all events but keeping
<strong>ERL_DRV_USE</strong> set indicates that we are using the event
object and probably will set events for it again.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><strong>ERL_DRV_USE</strong> was added in Erlang/OTP R13. Old drivers still
work as before, but it is recommended to update them to use
<strong>ERL_DRV_USE</strong> and <strong>stop_select</strong> to ensure that event
objects are closed in a safe way.</p></div><p>The return value is <strong>0</strong>, unless
<strong>ready_input</strong>/<strong>ready_output</strong> is <strong>NULL</strong>, in which case
it is <strong>-1</strong>.</p><h3>driver_send_term(ErlDrvPort port,
        ErlDrvTermData receiver, ErlDrvTermData* term, int n):int</h3><p>Send term data to other process than port owner process. </p><a name="driver_send_term"></a><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p><em>This function is deprecated.</em>
Use <a href="#erl_drv_send_term">erl_drv_send_term</a> instead.</p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The parameters of this function
cannot be properly checked by the runtime system when
executed by arbitrary threads. This can cause the
function not to fail when it should.</p></div><p>Parameters <strong>term</strong> and <strong>n</strong> work as in
<a href="#erl_drv_output_term">erl_drv_output_term</a>.</p><p>This function is only thread-safe when the emulator with SMP
support is used.</p><h3>driver_set_timer(ErlDrvPort port, unsigned
        long time):int</h3><p>Set a timer to call the driver.</p><a name="driver_set_timer"></a><p>Sets a timer on the driver, which will count
down and call the driver when it is timed out. Parameter
<strong>time</strong> is the time in milliseconds before the timer expires.</p><p>When the timer reaches <strong>0</strong> and expires, the driver entry
function <a href="./driver_entry#timeout">driver_entry#timeout</a> is called.</p><p>Notice that only one timer exists on each driver instance;
setting a new timer replaces an older one.</p><p>Return value is <strong>0</strong>, unless the <strong>timeout</strong>
driver function is <strong>NULL</strong>, in which case it is <strong>-1</strong>.</p><h3>driver_sizeq(ErlDrvPort port):ErlDrvSizeT</h3><p>Return the size of the driver queue.</p><a name="driver_sizeq"></a><p>Returns the number of bytes currently in the driver queue.</p><p>This function can be called from any thread if a
<a href="#ErlDrvPDL">port data lock</a>
associated with the <strong>port</strong> is locked by the calling
thread during the call.</p><h3>driver_system_info(ErlDrvSysInfo
        *sys_info_ptr, size_t size):void</h3><p>Get information about the Erlang runtime system.</p><a name="driver_system_info"></a><p>Writes information about the Erlang runtime system into the
<a href="#ErlDrvSysInfo">ErlDrvSysInfo</a>
structure referred to by the first argument. The second
argument is to be the size of the
<a href="#ErlDrvSysInfo">ErlDrvSysInfo</a>
structure, that is, <strong>sizeof(ErlDrvSysInfo)</strong>.</p><p>For information about specific fields, see
<a href="#ErlDrvSysInfo">ErlDrvSysInfo</a>.</p><h3>driver_vec_to_buf(ErlIOVec *ev,
        char *buf, ErlDrvSizeT len):ErlDrvSizeT</h3><p>Collect data segments into a buffer.</p><a name="driver_vec_to_buf"></a><p>Collects several segments of data, referenced
by <strong>ev</strong>, by copying them in order to the buffer
<strong>buf</strong>, of the size <strong>len</strong>.</p><p>If the data is to be sent from the driver to the port owner
process, it is faster to use
<a href="#driver_outputv">driver_outputv</a>.</p><p>The return value is the space left in the buffer, that is, if
<strong>ev</strong> contains less than <strong>len</strong> bytes it is the
difference, and if <strong>ev</strong> contains <strong>len</strong> bytes or more,
it is <strong>0</strong>. This is faster if there is more than one header byte,
as the binary syntax can construct integers directly from
the binary.</p><h3>erl_drv_busy_msgq_limits(ErlDrvPort port,
        ErlDrvSizeT *low, ErlDrvSizeT *high):void</h3><p>Set and get limits for busy port message queue.</p><a name="erl_drv_busy_msgq_limits"></a><p>Sets and gets limits that will be used for controlling the
busy state of the port message queue.</p><p>The port message queue is set into a busy
state when the amount of command data queued on the
message queue reaches the <strong>high</strong> limit. The port
message queue is set into a not busy state when the
amount of command data queued on the message queue falls
below the <strong>low</strong> limit. Command data is in this
context data passed to the port using either
<strong>Port ! {Owner, {command, Data}}</strong> or
<strong>port_command/[2,3]</strong>. Notice that these limits
only concerns command data that have not yet reached the
port. The <a href="#set_busy_port">busy port</a>
feature can be used for data that has reached the port.</p><p>Valid limits are values in the range
<strong>[ERL_DRV_BUSY_MSGQ_LIM_MIN, ERL_DRV_BUSY_MSGQ_LIM_MAX]</strong>.
Limits are automatically adjusted to be sane. That is,
the system adjusts values so that the low limit used is
lower than or equal to the high limit used. By default the high
limit is 8 kB and the low limit is 4 kB.</p><p>By passing a pointer to an integer variable containing
the value <strong>ERL_DRV_BUSY_MSGQ_READ_ONLY</strong>, the currently used
limit is read and written back to the integer variable.
A new limit can be set by passing a pointer to an integer
variable containing a valid limit. The passed value is
written to the internal limit. The internal limit is then
adjusted. After this the adjusted limit is written
back to the integer variable from which the new value was
read. Values are in bytes.</p><p>The busy message queue feature can be disabled either
by setting the <strong>ERL_DRV_FLAG_NO_BUSY_MSGQ</strong>
<a href="./driver_entry#driver_flags">driver flag</a>
in the <a href="driver_entry">driver_entry</a>
used by the driver, or by calling this function with
<strong>ERL_DRV_BUSY_MSGQ_DISABLED</strong> as a limit (either low or
high). When this feature has been disabled, it cannot be
enabled again. When reading the limits, both are
<strong>ERL_DRV_BUSY_MSGQ_DISABLED</strong> if this
feature has been disabled.</p><p>Processes sending command data to the port are suspended
if either the port is busy or if the port message queue is
busy. Suspended processes are resumed when neither the
port or the port message queue is busy.</p><p>For information about busy port functionality, see
<a href="#set_busy_port">set_busy_port</a>.</p><h3>erl_drv_cond_broadcast(ErlDrvCond
        *cnd):void</h3><p>Broadcast on a condition variable.</p><a name="erl_drv_cond_broadcast"></a><p>Broadcasts on a condition variable. That is, if
other threads are waiting on the condition variable being
broadcast on, <em>all</em> of them are woken.</p><p><strong>cnd</strong> is a pointer to a condition variable to broadcast on.</p><p>This function is thread-safe.</p><h3>erl_drv_cond_create(char
        *name):ErlDrvCond *</h3><p>Create a condition variable.</p><a name="erl_drv_cond_create"></a><p>Creates a condition variable and returns a pointer to it.</p><p><strong>name</strong> is a string identifying the created condition variable.
It is used to identify the condition variable in planned
future debug functionality.</p><p>Returns <strong>NULL</strong> on failure. The driver
creating the condition variable is responsible for
destroying it before the driver is unloaded.</p><p>This function is thread-safe.</p><h3>erl_drv_cond_destroy(ErlDrvCond
        *cnd):void</h3><p>Destroy a condition variable.</p><a name="erl_drv_cond_destroy"></a><p>Destroys a condition variable previously created by
<a href="#erl_drv_cond_create">erl_drv_cond_create</a>.</p><p><strong>cnd</strong> is a pointer to a condition variable to destroy.</p><p>This function is thread-safe.</p><h3>erl_drv_cond_name(ErlDrvCond
        *cnd):char *</h3><p>Get name of driver mutex.</p><a name="erl_drv_cnd_name"></a><p>Returns a pointer to the name of the condition.</p><p><strong>cnd</strong> is a  pointer to an initialized condition.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is intended for debugging purposes only.</p></div><h3>erl_drv_cond_signal(ErlDrvCond
        *cnd):void</h3><p>Signal on a condition variable.</p><a name="erl_drv_cond_signal"></a><p>Signals on a condition variable. That is, if
other threads are waiting on the condition variable being
signaled, <em>one</em> of them is woken.</p><p><strong>cnd</strong> is a pointer to a condition variable to signal on.</p><p>This function is thread-safe.</p><h3>erl_drv_cond_wait(ErlDrvCond *cnd,
        ErlDrvMutex *mtx):void</h3><p>Wait on a condition variable.</p><a name="erl_drv_cond_wait"></a><p>Waits on a condition variable. The calling
thread is blocked until another thread wakes it by signaling
or broadcasting on the condition variable. Before the calling
thread is blocked, it unlocks the mutex passed as argument.
When the calling thread is woken, it locks the same mutex before
returning. That is, the mutex currently must be locked by
the calling thread when calling this function.</p><p><strong>cnd</strong> is a pointer to a condition variable to wait on.
<strong>mtx</strong> is a pointer to a mutex to unlock while waiting.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><strong>erl_drv_cond_wait</strong> can return even if
no one has signaled or broadcast on the condition
variable. Code calling <strong>erl_drv_cond_wait</strong> is
always to be prepared for <strong>erl_drv_cond_wait</strong>
returning even if the condition that the thread was
waiting for has not occurred. That is, when returning from
<strong>erl_drv_cond_wait</strong>, always check if the condition
has occurred, and if not call <strong>erl_drv_cond_wait</strong>  again.</p></div><p>This function is thread-safe.</p><h3>erl_drv_consume_timeslice(ErlDrvPort port,
        int percent):int</h3><p>Give the runtime system a hint about how much CPU time the current driver callback call has consumed.</p><a name="erl_drv_consume_timeslice"></a><p>Gives the runtime system a hint about how much CPU time the current
driver callback call has consumed since the last hint, or since the
the start of the callback if no previous hint has been given.</p><dl><dt><strong>port</strong></dt><dd>Port handle of the executing port.</dd><dt><strong>percent</strong></dt><dd>Approximate consumed fraction of a full time-slice in percent.</dd></dl><p>The time is specified as a fraction, in percent, of a full time-slice
that a port is allowed to execute before it is to surrender the
CPU to other runnable ports or processes. Valid range is
<strong>[1, 100]</strong>. The scheduling time-slice is not an exact entity,
but can usually be approximated to about 1 millisecond.</p><p>Notice that it is up to the runtime system to determine if and
how to use this information. Implementations on some platforms
can use other means to determine the consumed fraction
of the time-slice. Lengthy driver callbacks should, regardless of
this, frequently call this function to determine if it is allowed
to continue execution or not.</p><p>This function returns a non-zero value
if the time-slice has been exhausted, and zero if the callback is
allowed to continue execution. If a non-zero value is
returned, the driver callback is to return as soon as possible in
order for the port to be able to yield.</p><p>This function is provided to better support co-operative scheduling,
improve system responsiveness, and to make it easier to prevent
misbehaviors of the VM because of a port monopolizing a scheduler
thread. It can be used when dividing lengthy work into some repeated
driver callback calls, without the need to use threads.</p><p>See also the important <a href="#WARNING">warning</a>
text at the beginning of this manual page.</p><h3>erl_drv_convert_time_unit(ErlDrvTime
        val, ErlDrvTimeUnit from, ErlDrvTimeUnit to):ErlDrvTime</h3><p>Convert time unit of a time value.</p><a name="erl_drv_convert_time_unit"></a><p>Converts the <strong>val</strong> value of time unit <strong>from</strong> to
the corresponding value of time unit <strong>to</strong>. The result is
rounded using the floor function.</p><dl><dt><strong>val</strong></dt><dd>Value to convert time unit for.</dd><dt><strong>from</strong></dt><dd>Time unit of <strong>val</strong>.</dd><dt><strong>to</strong></dt><dd>Time unit of returned value.</dd></dl><p>Returns <strong>ERL_DRV_TIME_ERROR</strong> if called with an invalid
time unit argument.</p><p>See also <a href="#ErlDrvTime">ErlDrvTime</a> and
<a href="#ErlDrvTimeUnit">ErlDrvTimeUnit</a>.</p><h3>erl_drv_equal_tids(ErlDrvTid tid1,
        ErlDrvTid tid2):int</h3><p>Compare thread identifiers for equality.</p><a name="erl_drv_equal_tids"></a><p>Compares two thread identifiers, <strong>tid1</strong> and <strong>tid2</strong>,
for equality.</p><p>Returns <strong>0</strong> it they are not equal, and a value not equal to
<strong>0</strong> if they are equal.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>A thread identifier can be reused very quickly after
a thread has terminated. Therefore, if a thread
corresponding to one of the involved thread identifiers
has terminated since the thread identifier was saved,
the result of <strong>erl_drv_equal_tids</strong> does possibly not give
the expected result.</p></div><p>This function is thread-safe.</p><h3>erl_drv_getenv(const char *key, char
        *value, size_t *value_size):int</h3><p>Get the value of an environment variable.</p><a name="erl_drv_getenv"></a><p>Retrieves the value of an environment variable.</p><dl><dt><strong>key</strong></dt><dd>A <strong>NULL</strong>-terminated string containing the name of the environment variable.</dd><dt><strong>value</strong></dt><dd>A pointer to an output buffer.</dd><dt><strong>value_size</strong></dt><dd>A pointer to an integer. The integer is used both for passing input and output sizes (see below).</dd></dl><p>When this function is called, <strong>*value_size</strong> is to contain the
size of the <strong>value</strong> buffer.</p><p>On success, <strong>0</strong> is returned,
the value of the environment variable has been written to
the <strong>value</strong> buffer, and <strong>*value_size</strong> contains the
string length (excluding the terminating <strong>NULL</strong> character) of
the value written to the <strong>value</strong> buffer.</p><p>On failure, that is, no such environment variable was found,
a value &lt; <strong>0</strong> is returned. When the size of the <strong>value</strong>
buffer is too small, a value &gt; <strong>0</strong> is returned and
<strong>*value_size</strong> has been set to the buffer size needed.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function reads the emulated environment used by
<a href="../kernel/os#getenv/1">kernel/os#getenv/1</a> and not
the environment used by libc's <strong>getenv(3)</strong> or similar. Drivers
that <em>require</em> that these are in sync will need to do so
themselves, but keep in mind that they are segregated for a reason;
<strong>getenv(3)</strong> and its friends are <em>not thread-safe</em> and
may cause unrelated code to misbehave or crash the emulator.</p></div><p>This function is thread-safe.</p><h3>erl_drv_init_ack(ErlDrvPort port,
        ErlDrvData res):void</h3><p>Acknowledge the start of the port.</p><a name="erl_drv_init_ack"></a><p>Acknowledges the start of the port.</p><dl><dt><strong>port</strong></dt><dd>The port handle of the port (driver instance) doing the acknowledgment. </dd><dt><strong>res</strong></dt><dd>The result of the port initialization. Can be the same values as the return value of <a href="./driver_entry#start">driver_entry#start</a>, that is, any of the error codes or the <strong>ErlDrvData</strong> that is to be used for this port. </dd></dl><p>When this function is called the initiating <strong>erlang:open_port</strong>
call is returned as if the <a href="./driver_entry#start">driver_entry#start</a> function had just been called. It can only be
used when flag <a href="./driver_entry#driver_flags">driver_entry#driver_flags</a>
has been set on the linked-in driver.</p><h3>erl_drv_monotonic_time(ErlDrvTimeUnit time_unit):ErlDrvTime</h3><p>Get Erlang monotonic time.</p><a name="erl_drv_monotonic_time"></a><p>Returns <a href="./time_correction#Erlang_Monotonic_Time"> Erlang monotonic time</a>. Notice that negative values are
not uncommon.</p><p><strong>time_unit</strong> is time unit of returned value.</p><p>Returns <strong>ERL_DRV_TIME_ERROR</strong> if called with an invalid
time unit argument, or if called from a thread that is not a
scheduler thread.</p><p>See also <a href="#ErlDrvTime">ErlDrvTime</a>
and <a href="#ErlDrvTimeUnit">ErlDrvTimeUnit</a>.</p><h3>erl_drv_mutex_create(char
        *name):ErlDrvMutex *</h3><p>Create a mutex.</p><a name="erl_drv_mutex_create"></a><p>Creates a mutex and returns a pointer to it.</p><p><strong>name</strong> is a string identifying the created mutex. It is used
to identify the mutex in planned future debug functionality.</p><p>Returns <strong>NULL</strong> on failure. The driver creating the mutex is
responsible for destroying it before the driver is unloaded.</p><p>This function is thread-safe.</p><h3>erl_drv_mutex_destroy(ErlDrvMutex
        *mtx):void</h3><p>Destroy a mutex.</p><a name="erl_drv_mutex_destroy"></a><p>Destroys a mutex previously created by
<a href="#erl_drv_mutex_create">erl_drv_mutex_create</a>.
The mutex must be in an unlocked state before it is destroyed.</p><p><strong>mtx</strong> is a pointer to a mutex to destroy.</p><p>This function is thread-safe.</p><h3>erl_drv_mutex_lock(ErlDrvMutex
        *mtx):void</h3><p>Lock a mutex.</p><a name="erl_drv_mutex_lock"></a><p>Locks a mutex. The calling thread is blocked until the mutex has
been locked. A thread that has currently locked the mutex
<em>cannot</em> lock the same mutex again.</p><p><strong>mtx</strong> is a pointer to a mutex to lock.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If you leave a mutex locked in an emulator thread
when you let the thread out of your control, you will
<em>very likely</em> deadlock the whole emulator.</p></div><p>This function is thread-safe.</p><h3>erl_drv_mutex_name(ErlDrvMutex
        *mtx):char *</h3><p>Get name of driver mutex.</p><a name="erl_drv_mutex_name"></a><p>Returns a pointer to the mutex name.</p><p><strong>mtx</strong> is a pointer to an initialized mutex.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is intended for debugging purposes only.</p></div><h3>erl_drv_mutex_trylock(ErlDrvMutex
        *mtx):int</h3><p>Try lock a mutex.</p><a name="erl_drv_mutex_trylock"></a><p>Tries to lock a mutex. A thread that has currently locked the mutex
<em>cannot</em> try to lock the same mutex again.</p><p><strong>mtx</strong> is a pointer to a mutex to try to lock.</p><p>Returns <strong>0</strong> on success, otherwise <strong>EBUSY</strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If you leave a mutex locked in an emulator thread
when you let the thread out of your control, you will
<em>very likely</em> deadlock the whole emulator.</p></div><p>This function is thread-safe.</p><h3>erl_drv_mutex_unlock(ErlDrvMutex
        *mtx):void</h3><p>Unlock a mutex.</p><a name="erl_drv_mutex_unlock"></a><p>Unlocks a mutex. The mutex currently must be
locked by the calling thread.</p><p><strong>mtx</strong> is a pointer to a mutex to unlock.</p><p>This function is thread-safe.</p><h3>erl_drv_output_term(ErlDrvTermData port,
        ErlDrvTermData* term, int n):int</h3><p>Send term data from driver to port owner.</p><a name="erl_drv_output_term"></a><p>Sends data in the special driver term
format to the port owner process. This is a fast way to
deliver term data from a driver. It needs no binary
conversion, so the port owner process receives data as
normal Erlang terms. The <a href="#erl_drv_send_term">erl_drv_send_term</a>
functions can be used for sending to any process
on the local node.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Parameter <strong>port</strong> is <em>not</em>
an ordinary port handle, but a port handle converted using
<a href="#driver_mk_port">driver_mk_port</a>.</p></div><p>Parameter <strong>term</strong> points to an array of
<strong>ErlDrvTermData</strong> with <strong>n</strong> elements. This array
contains terms described in the driver term format. Every
term consists of 1-4 elements in the array. The
first term has a term type and then arguments.
Parameter <strong>port</strong> specifies the sending port.</p><p>Tuples, maps, and lists (except strings, see below)
are built in reverse polish notation, so that to build a
tuple, the elements are specified first, and then the tuple
term, with a count. Likewise for lists and maps.</p><ul><li> <p>A tuple must be specified with the number of elements. (The
elements precede the <strong>ERL_DRV_TUPLE</strong> term.)</p> </li><li> <p>A map must be specified with the number of key-value pairs
<strong>N</strong>. The key-value pairs must precede the <strong>ERL_DRV_MAP</strong>
in this order: <strong>key1,value1,key2,value2,...,keyN,valueN</strong>.
Duplicate keys are not allowed.</p> </li><li> <p>A list must be specified with the number of elements,
including the tail, which is the last term preceding
<strong>ERL_DRV_LIST</strong>.</p> </li></ul><p>The special term <strong>ERL_DRV_STRING_CONS</strong> is used to
"splice" in a string in a list, a string specified this way is
not a list in itself, but the elements are elements of the
surrounding list.</p><pre>
Term type            Arguments
---------            ---------
ERL_DRV_NIL
ERL_DRV_ATOM         ErlDrvTermData atom (from driver_mk_atom(char *string))
ERL_DRV_INT          ErlDrvSInt integer
ERL_DRV_UINT         ErlDrvUInt integer
ERL_DRV_INT64        ErlDrvSInt64 *integer_ptr
ERL_DRV_UINT64       ErlDrvUInt64 *integer_ptr
ERL_DRV_PORT         ErlDrvTermData port (from driver_mk_port(ErlDrvPort port))
ERL_DRV_BINARY       ErlDrvBinary *bin, ErlDrvUInt len, ErlDrvUInt offset
ERL_DRV_BUF2BINARY   char *buf, ErlDrvUInt len
ERL_DRV_STRING       char *str, int len
ERL_DRV_TUPLE        int sz
ERL_DRV_LIST         int sz
ERL_DRV_PID          ErlDrvTermData pid (from driver_connected(ErlDrvPort port)
                     or driver_caller(ErlDrvPort port))
ERL_DRV_STRING_CONS  char *str, int len
ERL_DRV_FLOAT        double *dbl
ERL_DRV_EXT2TERM     char *buf, ErlDrvUInt len
ERL_DRV_MAP          int sz</pre><p>The unsigned integer data type <strong>ErlDrvUInt</strong> and the
signed integer data type <strong>ErlDrvSInt</strong> are 64 bits wide
on a 64-bit runtime system and 32 bits wide on a 32-bit
runtime system. They were introduced in ERTS 5.6
and replaced some of the <strong>int</strong> arguments in the list above.</p><p>The unsigned integer data type <strong>ErlDrvUInt64</strong> and the
signed integer data type <strong>ErlDrvSInt64</strong> are always 64 bits
wide. They were introduced in ERTS 5.7.4.</p><p>To build the tuple <strong>{tcp, Port, [100 | Binary]}</strong>, the
following call can be made.</p><pre><code class="">
ErlDrvBinary* bin = ...
ErlDrvPort port = ...
ErlDrvTermData spec[] = {
    ERL_DRV_ATOM, driver_mk_atom("tcp"),
    ERL_DRV_PORT, driver_mk_port(drvport),
        ERL_DRV_INT, 100,
        ERL_DRV_BINARY, bin, 50, 0,
        ERL_DRV_LIST, 2,
    ERL_DRV_TUPLE, 3,
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));    </code></pre><p>Here <strong>bin</strong> is a driver binary of length at least 50 and
<strong>drvport</strong> is a port handle. Notice that <strong>ERL_DRV_LIST</strong>
comes after the elements of the list, likewise
<strong>ERL_DRV_TUPLE</strong>.</p><p>The <strong>ERL_DRV_STRING_CONS</strong> term is a way to construct
strings. It works differently from how <strong>ERL_DRV_STRING</strong>
works. <strong>ERL_DRV_STRING_CONS</strong> builds a string list in
reverse order (as opposed to how <strong>ERL_DRV_LIST</strong>
works), concatenating the strings added to a list. The tail
must be specified before <strong>ERL_DRV_STRING_CONS</strong>.</p><p><strong>ERL_DRV_STRING</strong> constructs a string, and ends
it. (So it is the same as <strong>ERL_DRV_NIL</strong> followed by
<strong>ERL_DRV_STRING_CONS</strong>.)</p><pre><code class="">
/* to send [x, "abc", y] to the port: */
ErlDrvTermData spec[] = {
    ERL_DRV_ATOM, driver_mk_atom("x"),
    ERL_DRV_STRING, (ErlDrvTermData)"abc", 3,
    ERL_DRV_ATOM, driver_mk_atom("y"),
    ERL_DRV_NIL,
    ERL_DRV_LIST, 4
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));    </code></pre><pre><code class="">
/* to send "abc123" to the port: */
ErlDrvTermData spec[] = {
    ERL_DRV_NIL,        /* with STRING_CONS, the tail comes first */
    ERL_DRV_STRING_CONS, (ErlDrvTermData)"123", 3,
    ERL_DRV_STRING_CONS, (ErlDrvTermData)"abc", 3,
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));    </code></pre><p>The <strong>ERL_DRV_EXT2TERM</strong> term type is used for passing a
term encoded with the
<a href="erl_ext_dist">external format</a>,
that is, a term that has been encoded by
<a href="./erlang#term_to_binary/2">erlang#term_to_binary/2</a>,
<a href="./ei">erl_interface/ei</a>,
and so on.
For example, if <strong>binp</strong> is a pointer to an <strong>ErlDrvBinary</strong>
that contains term <strong>{17, 4711}</strong> encoded with the
<a href="erl_ext_dist">external format</a>,
and you want to wrap it in a two-tuple with the tag <strong>my_tag</strong>,
that is, <strong>{my_tag, {17, 4711}}</strong>, you can do as follows:</p><pre><code class="">
ErlDrvTermData spec[] = {
        ERL_DRV_ATOM, driver_mk_atom("my_tag"),
        ERL_DRV_EXT2TERM, (ErlDrvTermData) binp-&gt;orig_bytes, binp-&gt;orig_size
    ERL_DRV_TUPLE, 2,
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));    </code></pre><p>To build the map <strong>#{key1 =&gt; 100, key2 =&gt; {200, 300}}</strong>, the
following call can be made.</p><pre><code class="">
ErlDrvPort port = ...
ErlDrvTermData spec[] = {
    ERL_DRV_ATOM, driver_mk_atom("key1"),
        ERL_DRV_INT, 100,
    ERL_DRV_ATOM, driver_mk_atom("key2"),
        ERL_DRV_INT, 200,
        ERL_DRV_INT, 300,
    ERL_DRV_TUPLE, 2,
    ERL_DRV_MAP, 2
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));    </code></pre><p>If you want to pass a binary and do not already have the content
of the binary in an <strong>ErlDrvBinary</strong>, you can benefit from using
<strong>ERL_DRV_BUF2BINARY</strong> instead of creating an <strong>ErlDrvBinary</strong>
through <a href="#driver_alloc_binary">driver_alloc_binary</a> and then pass the binary through
<strong>ERL_DRV_BINARY</strong>. The runtime system often allocates
binaries smarter if <strong>ERL_DRV_BUF2BINARY</strong> is used.
However, if the content of the binary to pass already resides in
an <strong>ErlDrvBinary</strong>, it is normally better to pass the binary using
<strong>ERL_DRV_BINARY</strong> and the <strong>ErlDrvBinary</strong> in question.</p><p>The <strong>ERL_DRV_UINT</strong>, <strong>ERL_DRV_BUF2BINARY</strong>, and
<strong>ERL_DRV_EXT2TERM</strong> term types were introduced in
ERTS 5.6.</p><p>This function is only thread-safe when the emulator with SMP
support is used.</p><h3>erl_drv_putenv(const char *key, char
        *value):int</h3><p>Set the value of an environment variable.</p><a name="erl_drv_putenv"></a><p>Sets the value of an environment variable.</p><p><strong>key</strong> is a <strong>NULL</strong>-terminated string containing the
name of the environment variable.</p><p><strong>value</strong> is a <strong>NULL</strong>-terminated string containing the
new value of the environment variable.</p><p>Returns <strong>0</strong> on success, otherwise a value <strong>!= 0</strong>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The result of passing the empty string (<strong>""</strong>) as a value
is platform-dependent. On some platforms the variable value
is set to the empty string, on others the
environment variable is removed.</p></div><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function modifies the emulated environment used by
<a href="../kernel/os#putenv/2">kernel/os#putenv/2</a> and not
the environment used by libc's <strong>putenv(3)</strong> or similar. Drivers
that <em>require</em> that these are in sync will need to do so
themselves, but keep in mind that they are segregated for a reason;
<strong>putenv(3)</strong> and its friends are <em>not thread-safe</em> and
may cause unrelated code to misbehave or crash the emulator.</p></div><p>This function is thread-safe.</p><h3>erl_drv_rwlock_create(char
        *name):ErlDrvRWLock *</h3><p>Create an rwlock.</p><a name="erl_drv_rwlock_create"></a><p>Creates an rwlock and returns a pointer to it.</p><p><strong>name</strong> is a string identifying the created rwlock.
It is used to identify the rwlock in planned future
debug functionality.</p><p>Returns <strong>NULL</strong> on failure. The driver creating the rwlock
is responsible for destroying it before the driver is unloaded.</p><p>This function is thread-safe.</p><h3>erl_drv_rwlock_destroy(ErlDrvRWLock
        *rwlck):void</h3><p>Destroy an rwlock.</p><a name="erl_drv_rwlock_destroy"></a><p>Destroys an rwlock previously created by
<a href="#erl_drv_rwlock_create">erl_drv_rwlock_create</a>.
The rwlock must be in an unlocked state before it is destroyed.</p><p><strong>rwlck</strong> is a pointer to an rwlock to destroy.</p><p>This function is thread-safe.</p><h3>erl_drv_rwlock_name(ErlDrvRWLock
        *rwlck):char *</h3><p>Get name of driver mutex.</p><a name="erl_drv_rwlock_name"></a><p>Returns a pointer to the name of the rwlock.</p><p><strong>rwlck</strong> is a pointer to an initialized rwlock.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is intended for debugging purposes only.</p></div><h3>erl_drv_rwlock_rlock(ErlDrvRWLock
        *rwlck):void</h3><p>Read lock an rwlock.</p><a name="erl_drv_rwlock_rlock"></a><p>Read locks an rwlock. The calling thread is
blocked until the rwlock has been read locked. A thread
that currently has read or read/write locked the rwlock
<em>cannot</em> lock the same rwlock again.</p><p><strong>rwlck</strong> is a pointer to the rwlock to read lock.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If you leave an rwlock locked in an emulator thread
when you let the thread out of your control, you will
<em>very likely</em> deadlock the whole emulator.</p></div><p>This function is thread-safe.</p><h3>erl_drv_rwlock_runlock(ErlDrvRWLock
        *rwlck):void</h3><p>Read unlock an rwlock.</p><a name="erl_drv_rwlock_runlock"></a><p>Read unlocks an rwlock. The rwlock currently must
be read locked by the calling thread.</p><p><strong>rwlck</strong> is a pointer to an rwlock to read unlock.</p><p>This function is thread-safe.</p><h3>erl_drv_rwlock_rwlock(ErlDrvRWLock
        *rwlck):void</h3><p>Read/write lock an rwlock.</p><a name="erl_drv_rwlock_rwlock"></a><p>Read/write locks an rwlock. The calling thread
is blocked until the rwlock has been read/write locked.
A thread that currently has read or read/write locked the
rwlock <em>cannot</em> lock the same rwlock again.</p><p><strong>rwlck</strong> is a pointer to an rwlock to read/write lock.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If you leave an rwlock locked in an emulator thread
when you let the thread out of your control, you will
<em>very likely</em> deadlock the whole emulator.</p></div><p>This function is thread-safe.</p><h3>erl_drv_rwlock_rwunlock(ErlDrvRWLock
        *rwlck):void</h3><p>Read/write unlock an rwlock.</p><a name="erl_drv_rwlock_rwunlock"></a><p>Read/write unlocks an rwlock. The rwlock currently must be
read/write locked by the calling thread.</p><p><strong>rwlck</strong> is a pointer to an rwlock to read/write unlock.</p><p>This function is thread-safe.</p><h3>erl_drv_rwlock_tryrlock(ErlDrvRWLock
        *rwlck):int</h3><p>Try to read lock an rwlock.</p><a name="erl_drv_rwlock_tryrlock"></a><p>Tries to read lock an rwlock.</p><p><strong>rwlck</strong> is a pointer to an rwlock to try to read lock.</p><p>Returns <strong>0</strong> on success, otherwise <strong>EBUSY</strong>.
A thread that currently has read or read/write locked the
rwlock <em>cannot</em> try to lock the same rwlock again.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If you leave an rwlock locked in an emulator thread
when you let the thread out of your control, you will
<em>very likely</em> deadlock the whole emulator.</p></div><p>This function is thread-safe.</p><h3>erl_drv_rwlock_tryrwlock(ErlDrvRWLock
        *rwlck):int</h3><p>Try to read/write lock an rwlock.</p><a name="erl_drv_rwlock_tryrwlock"></a><p>Tries to read/write lock an rwlock.
A thread that currently has read or read/write locked the
rwlock <em>cannot</em> try to lock the same rwlock again.</p><p><strong>rwlck</strong>is pointer to an rwlock to try to read/write lock.</p><p>Returns <strong>0</strong> on success, otherwise <strong>EBUSY</strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If you leave an rwlock locked in an emulator thread
when you let the thread out of your control, you will
<em>very likely</em> deadlock the whole emulator.</p></div><p>This function is thread-safe.</p><h3>erl_drv_send_term(ErlDrvTermData port,
        ErlDrvTermData receiver, ErlDrvTermData* term, int n):int</h3><p>Send term data to other process than port owner process. </p><a name="erl_drv_send_term"></a><p>This function is the only way for a driver to send data to
<em>other</em> processes than the port owner process. Parameter
<strong>receiver</strong> specifies the process to receive the data.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Parameter <strong>port</strong> is <em>not</em> an ordinary port handle, but
a port handle converted using
<a href="#driver_mk_port">driver_mk_port</a>.</p></div><p>Parameters <strong>port</strong>, <strong>term</strong>, and <strong>n</strong> work as in
<a href="#erl_drv_output_term">erl_drv_output_term</a>.</p><p>This function is only thread-safe when the emulator with SMP
support is used.</p><h3>erl_drv_set_os_pid(ErlDrvPort port,
        ErlDrvSInt pid):void</h3><p>Set the os_pid for the port.</p><a name="erl_drv_set_os_pid"></a><p>Sets the <strong>os_pid</strong> seen when doing
<a href="./erlang#port_info/2">erlang#port_info/2</a> on this port.</p><p><strong>port</strong> is the port handle of the port (driver instance) to set
the pid on. <strong>pid</strong>is the pid to set.</p><h3>erl_drv_thread_create(char *name, ErlDrvTid
        *tid, void * (*func)(void *), void *arg, ErlDrvThreadOpts
        *opts):int</h3><p>Create a thread.</p><a name="erl_drv_thread_create"></a><p>Creates a new thread.</p><dl><dt><strong>name</strong></dt><dd>A string identifying the created thread. It is used to identify the thread in planned future debug functionality. </dd><dt><strong>tid</strong></dt><dd>A pointer to a thread identifier variable.</dd><dt><strong>func</strong></dt><dd>A pointer to a function to execute in the created thread.</dd><dt><strong>arg</strong></dt><dd>A pointer to argument to the <strong>func</strong> function.</dd><dt><strong>opts</strong></dt><dd>A pointer to thread options to use or <strong>NULL</strong>.</dd></dl><p>Returns <strong>0</strong> on success,
otherwise an <strong>errno</strong> value is returned to indicate the error.
The newly created thread begins executing in the function pointed
to by <strong>func</strong>, and <strong>func</strong> is passed <strong>arg</strong> as
argument. When <strong>erl_drv_thread_create</strong> returns, the thread
identifier of the newly created thread is available in
<strong>*tid</strong>. <strong>opts</strong> can be either a <strong>NULL</strong> pointer, or a
pointer to an
<a href="#ErlDrvThreadOpts">ErlDrvThreadOpts</a>
structure. If <strong>opts</strong> is a <strong>NULL</strong> pointer, default options
are used, otherwise the passed options are used.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>You are not allowed to allocate the
<a href="#ErlDrvThreadOpts">ErlDrvThreadOpts</a> structure by yourself.
It must be allocated and initialized by
<a href="#erl_drv_thread_opts_create">erl_drv_thread_opts_create</a>.</p></div><p>The created thread terminates either when <strong>func</strong> returns or if
<a href="#erl_drv_thread_exit">erl_drv_thread_exit</a>
is called by the thread. The exit value of the thread is either
returned from <strong>func</strong> or passed as argument to
<a href="#erl_drv_thread_exit">erl_drv_thread_exit</a>.
The driver creating the thread is responsible for joining the
thread, through <a href="#erl_drv_thread_join">erl_drv_thread_join</a>,
before the driver is unloaded. "Detached" threads cannot be created,
that is, threads that do not need to be joined.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>All created threads must be joined by the driver before
it is unloaded. If the driver fails to join all threads
created before it is unloaded, the runtime system
most likely crashes when the driver code is unloaded.</p></div><p>This function is thread-safe.</p><h3>erl_drv_thread_exit(void
        *exit_value):void</h3><p>Terminate calling thread.</p><a name="erl_drv_thread_exit"></a><p>Terminates the calling thread with the exit value passed as
argument. <strong>exit_value</strong> is a pointer to an exit value or
<strong>NULL</strong>.</p><p>You are only allowed to terminate threads created with
<a href="#erl_drv_thread_create">erl_drv_thread_create</a>.</p><p>The exit value can later be retrieved by another thread through
<a href="#erl_drv_thread_join">erl_drv_thread_join</a>.</p><p>This function is thread-safe.</p><h3>erl_drv_thread_join(ErlDrvTid tid, void
        **exit_value):int</h3><p>Join with another thread.</p><a name="erl_drv_thread_join"></a><p>Joins the calling thread with another thread, that is,
the calling thread is blocked until the thread identified by
<strong>tid</strong> has terminated.</p><p><strong>tid</strong> is the thread identifier of the thread to join.
<strong>exit_value</strong> is a pointer to a pointer to an exit value,
or <strong>NULL</strong>.</p><p>Returns <strong>0</strong> on success, otherwise an <strong>errno</strong>
value is returned to indicate the error.</p><p>A thread can only be joined once. The behavior of joining
more than once is undefined, an emulator crash is likely. If
<strong>exit_value == NULL</strong>, the exit value of the terminated thread
is ignored, otherwise the exit value of the terminated thread
is stored at <strong>*exit_value</strong>.</p><p>This function is thread-safe.</p><h3>erl_drv_thread_name(ErlDrvTid
        tid):char *</h3><p>Get name of driver mutex.</p><a name="erl_drv_rwlock_name"></a><p>Returns a pointer to the name of the thread.</p><p><strong>tid</strong> is a thread identifier.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This function is intended for debugging purposes only.</p></div><h3>erl_drv_thread_opts_create(char *name):ErlDrvThreadOpts *</h3><p>Create thread options.</p><a name="erl_drv_thread_opts_create"></a><p>Allocates and initializes a thread option structure.</p><p><strong>name</strong> is a string identifying the created thread options.
It is used to identify the thread options in planned future debug
functionality.</p><p>Returns <strong>NULL</strong> on failure. A thread option
structure is used for passing options to
<a href="#erl_drv_thread_create">erl_drv_thread_create</a>.
If the structure is not modified before it is passed to
<a href="#erl_drv_thread_create">erl_drv_thread_create</a>,
the default values are used.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>You are not allowed to allocate the
<a href="#ErlDrvThreadOpts">ErlDrvThreadOpts</a>
structure by yourself. It must be allocated and initialized by
<strong>erl_drv_thread_opts_create</strong>.</p></div><p>This function is thread-safe.</p><h3>erl_drv_thread_opts_destroy(ErlDrvThreadOpts *opts):void</h3><p>Destroy thread options.</p><a name="erl_drv_thread_opts_destroy"></a><p>Destroys thread options previously created by
<a href="#erl_drv_thread_opts_create">erl_drv_thread_opts_create</a>.</p><p><strong>opts</strong> is a pointer to thread options to destroy.</p><p>This function is thread-safe.</p><h3>erl_drv_thread_self(void):ErlDrvTid</h3><p>Get the thread identifier of the current thread.</p><a name="erl_drv_thread_self"></a><p>Returns the thread identifier of the calling thread.</p><p>This function is thread-safe.</p><h3>erl_drv_time_offset(ErlDrvTimeUnit
        time_unit):ErlDrvTime</h3><p>Get current time offset.</p><a name="erl_drv_time_offset"></a><p>Returns the current time offset between
<a href="./time_correction#Erlang_Monotonic_Time"> Erlang monotonic time</a> and
<a href="./time_correction#Erlang_System_Time"> Erlang system time</a>
converted into the <strong>time_unit</strong> passed as argument.</p><p><strong>time_unit</strong> is time unit of returned value.</p><p>Returns <strong>ERL_DRV_TIME_ERROR</strong> if called with an invalid
time unit argument, or if called from a thread that is not a
scheduler thread.</p><p>See also <a href="#ErlDrvTime">ErlDrvTime</a> and
<a href="#ErlDrvTimeUnit">ErlDrvTimeUnit</a>.</p><h3>erl_drv_tsd_get(ErlDrvTSDKey
        key):void *</h3><p>Get thread-specific data.</p><a name="erl_drv_tsd_get"></a><p>Returns the thread-specific data
associated with <strong>key</strong> for the calling thread.</p><p><strong>key</strong> is a thread-specific data key.</p><p>Returns <strong>NULL</strong> if no data has been associated
with <strong>key</strong> for the calling thread.</p><p>This function is thread-safe.</p><h3>erl_drv_tsd_key_create(char *name,
        ErlDrvTSDKey *key):int</h3><p>Create a thread-specific data key.</p><a name="erl_drv_tsd_key_create"></a><p>Creates a thread-specific data key.</p><p><strong>name</strong> is a string identifying the created key. It is used
to identify the key in planned future debug functionality.</p><p><strong>key</strong> is a pointer to a thread-specific data key variable.</p><p>Returns <strong>0</strong> on success, otherwise an <strong>errno</strong> value is
returned to indicate the error. The driver creating the key is
responsible for destroying it before the driver is unloaded.</p><p>This function is thread-safe.</p><h3>erl_drv_tsd_key_destroy(ErlDrvTSDKey
        key):void</h3><p>Destroy a thread-specific data key.</p><a name="erl_drv_tsd_key_destroy"></a><p>Destroys a thread-specific data key previously created by
<a href="#erl_drv_tsd_key_create">erl_drv_tsd_key_create</a>.
All thread-specific data using this key in all threads
must be cleared (see <a href="#erl_drv_tsd_set">erl_drv_tsd_set</a>)
before the call to <strong>erl_drv_tsd_key_destroy</strong>.</p><p><strong>key</strong> is a thread-specific data key to destroy.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>A destroyed key is very likely to be reused soon.
Therefore, if you fail to clear the thread-specific
data using this key in a thread before destroying
the key, you will <em>very likely</em> get unexpected
errors in other parts of the system.</p></div><p>This function is thread-safe.</p><h3>erl_drv_tsd_set(ErlDrvTSDKey key, void
        *data):void</h3><p>Set thread-specific data.</p><a name="erl_drv_tsd_set"></a><p>Sets thread-specific data associated with
<strong>key</strong> for the calling thread. You are only allowed to set
thread-specific data for threads while they are fully under your
control. For example, if you set thread-specific data in a thread
calling a driver callback function, it must be cleared, that is,
set to <strong>NULL</strong>, before returning from the driver callback
function.</p><p><strong>key</strong> is a thread-specific data key.</p><p><strong>data</strong> is a pointer to data to associate with <strong>key</strong>
in the calling thread.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>If you fail to clear thread-specific data in an
emulator thread before letting it out of your control,
you might never be able to clear this data with
later unexpected errors in other parts of the system as
a result.</p></div><p>This function is thread-safe.</p><h3>erl_errno_id(int error):char *</h3><p>Get Erlang error atom name from error number.</p><a name="erl_errno_id"></a><p>Returns the atom name of the Erlang error,
given the error number in <strong>error</strong>. The error atoms are
<strong>einval</strong>, <strong>enoent</strong>, and so on. It can be used to make
error terms from the driver.</p><h3>remove_driver_entry(ErlDrvEntry
        *de):int</h3><p>Remove a driver entry.</p><a name="remove_driver_entry"></a><p>Removes a driver entry <strong>de</strong> previously added with
<a href="#add_driver_entry">add_driver_entry</a>.</p><p>Driver entries added by the <strong>erl_ddll</strong> Erlang interface
cannot be removed by using this interface.</p><h3>set_busy_port(ErlDrvPort port, int
        on):void</h3><p>Signal or unsignal port as busy.</p><a name="set_busy_port"></a><p>Sets and unsets the busy state of the port. If
<strong>on</strong> is non-zero, the port is set to busy. If it is zero,
the port is set to not busy. You typically want to combine
this feature with the <a href="#erl_drv_busy_msgq_limits"> busy port message queue</a> functionality.</p><p>Processes sending command data to the port are suspended
if either the port or the port message queue
is busy. Suspended processes are resumed when neither the
port or the port message queue is busy. Command data
is in this context data passed to the port using either
<strong>Port ! {Owner, {command, Data}}</strong> or
<strong>port_command/[2,3]</strong>.</p><p>If the <a href="./driver_entry#driver_flags"> ERL_DRV_FLAG_SOFT_BUSY</a> has been set in the
<a href="driver_entry">driver_entry</a>,
data can be forced into the driver through
<a href="./erlang#port_command/3">erlang#port_command/3</a>
even if the driver has signaled that it is busy.</p><p>For information about busy port message queue functionality, see
<a href="#erl_drv_busy_msgq_limits">erl_drv_busy_msgq_limits</a>.</p><h3>set_port_control_flags(ErlDrvPort port,
        int flags):void</h3><p>Set flags on how to handle control entry function.</p><a name="set_port_control_flags"></a><p>Sets flags for how the <a href="./driver_entry#control">driver_entry#control</a> driver entry
function will return data to the port owner process.
(The <strong>control</strong> function is called from
<a href="./erlang#port_control/3">erlang#port_control/3</a>.)</p><p>Currently there are only two meaningful values for
<strong>flags</strong>: <strong>0</strong> means that data is returned in a list,
and <strong>PORT_CONTROL_FLAG_BINARY</strong> means data is returned as
a binary from <strong>control</strong>.</p><h3>See Also</h3><p><a href="driver_entry">driver_entry</a>,
<a href="erlang">erlang</a>,
<a href="./erl_ddll">kernel/erl_ddll</a>,
section <a href="alt_dist">How to Implement an Alternative Carrier for the Erlang Distribution</a> in the User's Guide</p><h2>erl_nif</h2><p>API functions for an Erlang NIF library.</p><p>A NIF library contains native implementation of some functions
of an Erlang module. The native implemented functions (NIFs) are
called like any other functions without any difference to the
caller. Each NIF must have an implementation in Erlang that
is invoked if the function is called before the NIF library
is successfully loaded. A typical such stub implementation
is to throw an exception. But it can also be used as a fallback
implementation if the NIF library is not implemented for some
architecture.A minimal example of a NIF library can look as follows:<pre><code class="">
/* niftest.c */
#include &lt;erl_nif.h&gt;

static ERL_NIF_TERM hello(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
    return enif_make_string(env, "Hello world!", ERL_NIF_LATIN1);
}

static ErlNifFunc nif_funcs[] =
{
    {"hello", 0, hello}
};

ERL_NIF_INIT(niftest,nif_funcs,NULL,NULL,NULL,NULL)</code></pre>The Erlang module can look as follows:<pre><code class="">
-module(niftest).

-export([init/0, hello/0]).

init() -&gt;
      erlang:load_nif("./niftest", 0).

hello() -&gt;
      "NIF library not loaded".</code></pre>Compile and test can look as follows (on Linux):<pre><code class="">
$&gt; gcc -fPIC -shared -o niftest.so niftest.c -I $ERL_ROOT/usr/include/
$&gt; erl

1&gt; c(niftest).
{ok,niftest}
2&gt; niftest:hello().
"NIF library not loaded"
3&gt; niftest:init().
ok
4&gt; niftest:hello().
"Hello world!"</code></pre>A better solution for a real module is to take advantage of the new
directive <strong>on_load</strong> (see section
<a href="../doc/reference_manual/code_loading#on_load">Running a Function When a Module is Loaded</a> in the Erlang Reference
Manual) to load the NIF library automatically when the module is
loaded.Once loaded, a NIF library is persistent. It will not be unloaded
until the module code version that it belongs to is purged.</p><h3>Functionality</h3><p>All interaction between NIF code and the Erlang runtime system is
performed by calling NIF API functions. Functions exist
for the following functionality:</p><dl><dt>Read and write Erlang terms</dt><dd> <p>Any Erlang terms can be passed to a NIF as function arguments and
be returned as function return values. The terms are of C-type
<a href="#ERL_NIF_TERM">ERL_NIF_TERM</a> and can
only be read or written using API functions. Most functions to read
the content of a term are prefixed <strong>enif_get_</strong> and usually return
<strong>true</strong> (or <strong>false</strong>) if the term is of the expected type (or
not). The functions to write terms are all prefixed <strong>enif_make_</strong>
and usually
return the created <strong>ERL_NIF_TERM</strong>. There are also some functions
to query terms, like <strong>enif_is_atom</strong>, <strong>enif_is_identical</strong>,
and <strong>enif_compare</strong>.</p> <p>All terms of type <strong>ERL_NIF_TERM</strong> belong to an environment of
type <a href="#ErlNifEnv">ErlNifEnv</a>. The
lifetime of a term is controlled by the lifetime of its environment
object. All API functions that read or write terms has the
environment that the term belongs to as the first function
argument.</p> </dd><dt>Binaries</dt><dd> <p>Terms of type binary are accessed with the help of struct type
<a href="#ErlNifBinary">ErlNifBinary</a>,
which contains a pointer (<strong>data</strong>) to the raw binary data and the
length (<strong>size</strong>) of the data in bytes. Both <strong>data</strong> and
<strong>size</strong> are read-only and are only to be written using calls to
API functions. Instances of <strong>ErlNifBinary</strong> are, however, always
allocated by the user (usually as local variables).</p> <p>The raw data pointed to by <strong>data</strong> is only mutable after a call
to <a href="#enif_alloc_binary">enif_alloc_binary</a> or
<a href="#enif_realloc_binary">enif_realloc_binary</a>. All other functions that
operate on a binary leave the data as read-only.
A mutable binary must in the end either be freed with
<a href="#enif_release_binary">enif_release_binary</a>
or made read-only by transferring it to an Erlang term with
<a href="#enif_make_binary">enif_make_binary</a>.
However, it does not have to occur in the same NIF call. Read-only
binaries do not have to be released.</p> <p><a href="#enif_make_new_binary">enif_make_new_binary</a> can be used as a shortcut to
allocate and return a binary in the same NIF call.</p> <p>Binaries are sequences of whole bytes. Bitstrings with an arbitrary
bit length have no support yet.</p> </dd><dt><a name="resource_objects"></a>Resource objects</dt><dd> <p>The use of resource objects is a safe way to return pointers to
native data structures from a NIF. A resource object is
only a block of memory allocated with
<a href="#enif_alloc_resource">enif_alloc_resource</a>.
A handle ("safe pointer") to this memory block can then be returned
to Erlang by the use of
<a href="#enif_make_resource">enif_make_resource</a>.
The term returned by <strong>enif_make_resource</strong> is opaque in nature.
It can be stored and passed between processes, but
the only real end usage is to pass it back as an argument to a NIF.
The NIF can then call <a href="#enif_get_resource">enif_get_resource</a> and get back a pointer to the
memory block, which is guaranteed to still be valid. A resource
object is not deallocated until the last handle term
is garbage collected by the VM and the resource is released with
<a href="#enif_release_resource">enif_release_resource</a>
(not necessarily in that order).</p> <p>All resource objects are created as instances of some <em>resource type</em>. This makes resources from different modules to be
distinguishable. A resource type is created by calling
<a href="#enif_open_resource_type">enif_open_resource_type</a> when a library is loaded.
Objects of that resource type can then later be allocated and
<strong>enif_get_resource</strong> verifies that the resource is of the
expected type. A resource type can have a user-supplied destructor
function, which is automatically called when resources of that type
are released (by either the garbage collector or
<strong>enif_release_resource</strong>). Resource types are uniquely identified
by a supplied name string and the name of the implementing module.</p> <a name="enif_resource_example"></a> <p>The following is a template example of how to create and return a
resource object.</p> <pre><code class="">
ERL_NIF_TERM term;
MyStruct* obj = enif_alloc_resource(my_resource_type, sizeof(MyStruct));

/* initialize struct ... */

term = enif_make_resource(env, obj);

if (keep_a_reference_of_our_own) {
    /* store 'obj' in static variable, private data or other resource object */
}
else {
    enif_release_resource(obj);
    /* resource now only owned by "Erlang" */
}
return term;</code></pre> <p>Notice that once <strong>enif_make_resource</strong> creates the term to
return to Erlang, the code can choose to either keep its own
native pointer to the allocated struct and release it later, or
release it immediately and rely only on the garbage collector
to deallocate the resource object eventually when it collects
the term.</p>  <p>Another use of resource objects is to create binary terms with
user-defined memory management.
<a href="#enif_make_resource_binary">enif_make_resource_binary</a>
creates a binary term that is connected to a resource object. The
destructor of the resource is called when the binary is garbage
collected, at which time the binary data can be released. An example
of this can be a binary term consisting of data from a <strong>mmap</strong>'ed
file. The destructor can then do <strong>munmap</strong> to release the memory
region.</p> <p>Resource types support upgrade in runtime by allowing a loaded NIF
library to take over an already existing resource type and by that
"inherit" all existing objects of that type. The destructor of the
new library is thereafter called for the inherited objects and the
library with the old destructor function can be safely unloaded.
Existing resource objects, of a module that is upgraded, must either
be deleted or taken over by the new NIF library. The unloading of a
library is postponed as long as there exist resource objects with a
destructor function in the library.</p> </dd><dt>Module upgrade and static data</dt><dd> <p>A loaded NIF library is tied to the Erlang module instance
that loaded it. If the module is upgraded, the new module instance
needs to load its own NIF library (or maybe choose not to). The new
module instance can, however, choose to load the exact same NIF library
as the old code if it wants to. Sharing the dynamic library means that
static data defined by the library is shared as well. To avoid
unintentionally shared static data between module instances, each Erlang
module version can keep its own private data. This private data can be
set when the NIF library is loaded and later retrieved by calling
<a href="#enif_priv_data">enif_priv_data</a>.</p> </dd><dt>Threads and concurrency</dt><dd> <p>A NIF is thread-safe without any explicit synchronization as
long as it acts as a pure function and only reads the supplied
arguments. When you write to a shared state either through
static variables or <a href="#enif_priv_data">enif_priv_data</a>, you need to supply your own explicit
synchronization. This includes terms in process independent
environments that are shared between threads. Resource objects also
require synchronization if you treat them as mutable.</p> <p>The library initialization callbacks <strong>load</strong> and
<strong>upgrade</strong> are thread-safe even for shared state data.</p> </dd><dt><a name="version_management"></a>Version Management</dt><dd> <p>When a NIF library is built, information about the NIF API version
is compiled into the library. When a NIF library is loaded, the
runtime system verifies that the library is of a compatible version.
<strong>erl_nif.h</strong> defines the following:</p> <dl><dt><strong>ERL_NIF_MAJOR_VERSION</strong></dt><dd> <p>Incremented when NIF library incompatible changes are made to the
Erlang runtime system. Normally it suffices to recompile the NIF
library when the <strong>ERL_NIF_MAJOR_VERSION</strong> has changed, but it
can, under rare circumstances, mean that NIF libraries must be
slightly modified. If so, this will of course be documented.</p> </dd><dt><strong>ERL_NIF_MINOR_VERSION</strong></dt><dd> <p>Incremented when new features are added. The runtime system uses
the minor version to determine what features to use.</p> </dd></dl> <p>The runtime system normally refuses to load a NIF library if
the major versions differ, or if the major versions are equal and
the minor version used by the NIF library is greater than the one
used by the runtime system. Old NIF libraries with lower major
versions are, however, allowed after a bump of the major version
during a transition period of two major releases. Such old NIF
libraries can however fail if deprecated features are used.</p> </dd><dt><a name="time_measurement"></a>Time Measurement</dt><dd> <p>Support for time measurement in NIF libraries:</p> <ul><li><a href="#ErlNifTime">ErlNifTime</a></li><li><a href="#ErlNifTimeUnit">ErlNifTimeUnit</a></li><li><a href="#enif_monotonic_time">enif_monotonic_time</a></li><li><a href="#enif_time_offset">enif_time_offset</a></li><li><a href="#enif_convert_time_unit">enif_convert_time_unit</a></li></ul> </dd><dt><a name="enif_ioq"></a>I/O Queues</dt><dd> <p>The Erlang nif library contains function for easily working
with I/O vectors as used by the unix system call <strong>writev</strong>.
The I/O Queue is not thread safe, so some other synchronization
mechanism has to be used.</p> <ul><li><a href="#SysIOVec">SysIOVec</a></li><li><a href="#ErlNifIOVec">ErlNifIOVec</a></li><li><a href="#enif_ioq_create">enif_ioq_create</a></li><li><a href="#enif_ioq_destroy">enif_ioq_destroy</a></li><li><a href="#enif_ioq_enq_binary">enif_ioq_enq_binary</a></li><li><a href="#enif_ioq_enqv">enif_ioq_enqv</a></li><li><a href="#enif_ioq_deq">enif_ioq_deq</a></li><li><a href="#enif_ioq_peek">enif_ioq_peek</a></li><li><a href="#enif_ioq_peek_head">enif_ioq_peek_head</a></li><li><a href="#enif_inspect_iovec">enif_inspect_iovec</a></li><li><a href="#enif_free_iovec">enif_free_iovec</a></li></ul> <p>Typical usage when writing to a file descriptor looks like this:</p> <pre><code class="">
int writeiovec(ErlNifEnv *env, ERL_NIF_TERM term, ERL_NIF_TERM *tail,
               ErlNifIOQueue *q, int fd) {

    ErlNifIOVec vec, *iovec = &amp;vec;
    SysIOVec *sysiovec;
    int saved_errno;
    int iovcnt, n;

    if (!enif_inspect_iovec(env, 64, term, tail, &amp;iovec))
        return -2;

    if (enif_ioq_size(q) &gt; 0) {
        /* If the I/O queue contains data we enqueue the iovec and
           then peek the data to write out of the queue. */
        if (!enif_ioq_enqv(q, iovec, 0))
            return -3;

        sysiovec = enif_ioq_peek(q, &amp;iovcnt);
    } else {
        /* If the I/O queue is empty we skip the trip through it. */
        iovcnt = iovec-&gt;iovcnt;
        sysiovec = iovec-&gt;iov;
    }

    /* Attempt to write the data */
    n = writev(fd, sysiovec, iovcnt);
    saved_errno = errno;

    if (enif_ioq_size(q) == 0) {
        /* If the I/O queue was initially empty we enqueue any
           remaining data into the queue for writing later. */
        if (n &gt;= 0 &amp;&amp; !enif_ioq_enqv(q, iovec, n))
            return -3;
    } else {
        /* Dequeue any data that was written from the queue. */
        if (n &gt; 0 &amp;&amp; !enif_ioq_deq(q, n, NULL))
            return -4;
    }

    /* return n, which is either number of bytes written or -1 if
       some error happened */
    errno = saved_errno;
    return n;
}</code></pre> </dd><dt><a name="lengthy_work"></a>Long-running NIFs</dt><dd> <p>As mentioned in the <a href="#WARNING">warning</a> text
at the beginning of this manual page, it is of <em>vital importance</em> that a native function returns relatively fast. It is
difficult to give an exact maximum amount of time that a native
function is allowed to work, but usually a well-behaving native
function is to return to its caller within 1 millisecond. This can be
achieved using different approaches. If you have full control over the
code to execute in the native function, the best approach is to
divide the work into multiple chunks of work and call the native
function multiple times. This is, however, not always possible, for
example when calling third-party libraries.</p> <p>The <a href="#enif_consume_timeslice">enif_consume_timeslice</a> function can be used to
inform the runtime system about the length of the NIF call.
It is typically always to be used unless the NIF executes very
fast.</p> <p>If the NIF call is too lengthy, this must be handled in one of
the following ways to avoid degraded responsiveness, scheduler load
balancing problems, and other strange behaviors:</p> <dl><dt>Yielding NIF</dt><dd> <p>If the functionality of a long-running NIF can be split so that
its work can be achieved through a series of shorter NIF calls,
the application has two options:</p> <ul><li> <p>Make that series of NIF calls from the Erlang level.</p> </li><li> <p>Call a NIF that first performs a chunk of the work, then
invokes the <a href="#enif_schedule_nif">enif_schedule_nif</a> function to schedule
another NIF call to perform the next chunk. The final call
scheduled in this manner can then return the overall
result.</p> </li></ul> <p>Breaking up a long-running function in this manner enables the
VM to regain control between calls to the NIFs.</p> <p>This approach is always preferred over the other alternatives
described below. This both from a performance perspective and
a system characteristics perspective.</p> </dd><dt>Threaded NIF</dt><dd> <p>This is accomplished by dispatching the work to another thread
managed by the NIF library, return from the NIF, and wait for
the result. The thread can send the result back to the Erlang
process using <a href="#enif_send">enif_send</a>.
Information about thread primitives is provided below.</p> </dd><dt><a name="dirty_nifs"></a>Dirty NIF</dt><dd> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Dirty NIF support is available only when the emulator is
configured with dirty scheduler support. As of ERTS version
9.0, dirty scheduler support is enabled by default on the
runtime system with SMP support. The Erlang runtime without
SMP support does <em>not</em> support dirty schedulers even
when the dirty scheduler support is explicitly enabled. To
check at runtime for the presence of dirty scheduler threads,
code can use the <a href="#enif_system_info">enif_system_info</a> API function.</p></div> <p>A NIF that cannot be split and cannot execute in a millisecond
or less is called a "dirty NIF", as it performs work that the
ordinary schedulers of the Erlang runtime system cannot handle cleanly.
Applications that make use of such functions must indicate to the
runtime that the functions are dirty so they can be handled 
specially. This is handled by executing dirty jobs on a separate
set of schedulers called dirty schedulers. A dirty NIF executing
on a dirty scheduler does not have the same duration restriction
as a normal NIF.
</p> <p>
It is important to classify the dirty job correct. An I/O bound
job should be classified as such, and a CPU bound job should be
classified as such. If you should classify CPU bound jobs
as I/O bound jobs, dirty I/O schedulers might starve ordinary
schedulers. I/O bound jobs are expected to either block waiting
for I/O, and/or spend a limited amount of time moving data.
</p> <p>
To schedule a dirty NIF for execution, the application has two options:</p> <ul><li> <p>Set the appropriate flags value for the dirty NIF in its
<a href="#ErlNifFunc">ErlNifFunc</a>
entry.</p> </li><li> <p>Call <a href="#enif_schedule_nif">enif_schedule_nif</a>, pass to it a pointer
to the dirty NIF to be executed, and indicate with argument
<strong>flags</strong> whether it expects the operation to be CPU-bound
or I/O-bound.</p> </li></ul> <p>A job that alternates between I/O bound and CPU bound can be
reclassified and rescheduled using <strong>enif_schedule_nif</strong> so
that it executes on the correct type of dirty scheduler at all
times. For more information see the documentation of the
<strong>erl(1)</strong> command line arguments
<a href="./erl#+SDcpu">erl#+SDcpu</a>,
and <a href="./erl#+SDio">erl#+SDio</a>.</p> <p>While a process executes a dirty NIF, some operations that
communicate with it can take a very long time to complete.
Suspend or garbage collection of a process executing a dirty
NIF cannot be done until the dirty NIF has returned. Thus, other
processes waiting for such operations to complete might
have to wait for a very long time. Blocking multi-scheduling, that
is, calling <a href="./erlang#system_flag_multi_scheduling">erlang#system_flag_multi_scheduling</a>, can
also take a very long time to complete. This is because all ongoing
dirty operations on all dirty schedulers must complete before
the block operation can complete.</p> <p>Many operations communicating with a process executing a
dirty NIF can, however, complete while it executes the
dirty NIF. For example, retrieving information about it through
<a href="./erlang#process_info/1">erlang#process_info/1</a>, setting its group leader,
register/unregister its name, and so on.</p> <p>Termination of a process executing a dirty NIF can only be
completed up to a certain point while it executes the dirty NIF.
All Erlang resources, such as its registered name and its ETS
tables, are released. All links and monitors are triggered. The
execution of the NIF is, however, <em>not</em> stopped. The NIF
can safely continue execution, allocate heap memory, and so on,
but it is of course better to stop executing as soon as possible.
The NIF can check whether a current process is alive using
<a href="#enif_is_current_process_alive">enif_is_current_process_alive</a>. Communication
using <a href="#enif_send">enif_send</a> and
<a href="#enif_port_command">enif_port_command</a> is also dropped when the
sending process is not alive. Deallocation of certain internal
resources, such as process heap and process control block, is
delayed until the dirty NIF has completed.</p> </dd></dl> </dd></dl><h3>Initialization</h3><dl><dt><a name="ERL_NIF_INIT"></a><strong>ERL_NIF_INIT(MODULE, ErlNifFunc funcs[], load, NULL, upgrade, unload)</strong></dt><dd> <p>This is the magic macro to initialize a NIF library. It
is to be evaluated in global file scope.</p> <p><strong>MODULE</strong> is the name of the Erlang module as an
identifier without string quotations. It is stringified by
the macro.</p> <p><strong>funcs</strong> is a static array of function descriptors for
all the implemented NIFs in this library.</p> <p><strong>load</strong>, <strong>upgrade</strong> and <strong>unload</strong>
are pointers to functions. One of <strong>load</strong> or
<strong>upgrade</strong> is called to initialize the library.
<strong>unload</strong> is called to release the library. All are
described individually below.</p> <p>The fourth argument <strong>NULL</strong> is ignored. It
was earlier used for the deprecated <strong>reload</strong> callback
which is no longer supported since OTP 20.</p> <p>If compiling a NIF for static inclusion through
<strong>--enable-static-nifs</strong>, you must define <strong>STATIC_ERLANG_NIF</strong>
before the <strong>ERL_NIF_INIT</strong> declaration.</p> </dd><dt><a name="load"></a><strong>int (*load)(ErlNifEnv* caller_env, void** priv_data, ERL_NIF_TERM load_info)</strong></dt><dd> <p><strong>load</strong> is called when the NIF library is loaded
and no previously loaded library exists for this module.</p> <p><strong>*priv_data</strong> can be set to point to some private data
if the library needs to keep a state between NIF
calls. <strong>enif_priv_data</strong> returns this pointer.
<strong>*priv_data</strong> is initialized to <strong>NULL</strong> when <strong>load</strong> is
called.</p>  <p><strong>load_info</strong> is the second argument to <a href="./erlang#load_nif-2">erlang#load_nif-2</a>.</p> <p>The library fails to load if <strong>load</strong> returns
anything other than <strong>0</strong>. <strong>load</strong> can be <strong>NULL</strong> if
initialization is not needed.</p>  </dd><dt><a name="upgrade"></a><strong>int (*upgrade)(ErlNifEnv* caller_env, void** priv_data, void** old_priv_data, ERL_NIF_TERM load_info)</strong></dt><dd> <p><strong>upgrade</strong> is called when the NIF library is loaded
and there is old code of this module with a loaded NIF library.</p> <p>Works as <strong>load</strong>, except that <strong>*old_priv_data</strong> already
contains the value set by the last call to <strong>load</strong> or
<strong>upgrade</strong> for the old module code. <strong>*priv_data</strong> is
initialized to <strong>NULL</strong> when <strong>upgrade</strong> is called. It is
allowed to write to both <strong>*priv_data</strong> and
<strong>*old_priv_data.</strong></p>  <p>The library fails to load if <strong>upgrade</strong> returns
anything other than <strong>0</strong> or if <strong>upgrade</strong> is <strong>NULL</strong>.</p> </dd><dt><a name="unload"></a><strong>void (*unload)(ErlNifEnv* caller_env, void* priv_data)</strong></dt><dd> <p><strong>unload</strong> is called when the module code that
the NIF library belongs to is purged as old. New code of the same
module may or may not exist.</p> </dd></dl><h3>Data Types</h3><dl><dt><a name="ERL_NIF_TERM"></a><strong>ERL_NIF_TERM</strong></dt><dd> <p>Variables of type <strong>ERL_NIF_TERM</strong> can refer to any Erlang term.
This is an opaque type and values of it can only by used either as
arguments to API functions or as return values from NIFs. All
<strong>ERL_NIF_TERM</strong>s belong to an environment
(<a href="#ErlNifEnv">ErlNifEnv</a>).
A term cannot be destructed individually, it is valid until its
environment is destructed.</p> </dd><dt><a name="ErlNifEnv"></a><strong>ErlNifEnv</strong></dt><dd> <p><strong>ErlNifEnv</strong> represents an environment that can host Erlang
terms. All terms in an environment are valid as long as the
environment is valid. <strong>ErlNifEnv</strong> is an opaque type; pointers to
it can only be passed on to API functions. Three types of environments
exist:</p> <dl><dt>Process bound environment</dt><dd> <p>Passed as the first argument to all NIFs. All function arguments
passed to a NIF belong to that environment. The return value from
a NIF must also be a term belonging to the same environment.</p> <p>A process bound environment contains transient information
about the calling Erlang process. The environment is only valid
in the thread where it was supplied as argument until the NIF
returns. It is thus useless and dangerous to store pointers to
process bound environments between NIF calls.</p> </dd><dt>Callback environment</dt><dd> <p>Passed as the first argument to all the non-NIF callback functions
(<a href="#load">load</a>,
<a href="#upgrade">upgrade</a>,
<a href="#unload">unload</a>,
<a href="#ErlNifResourceDtor">ErlNifResourceDtor</a>,
<a href="#ErlNifResourceDown">ErlNifResourceDown</a> and
<a href="#ErlNifResourceStop">ErlNifResourceStop</a>).
Works like a process bound environment but with a temporary
pseudo process that "terminates" when the callback has
returned. Terms may be created in this environment but they will
only be accessible during the callback.</p> </dd><dt>Process independent environment</dt><dd> <p>Created by calling <a href="#enif_alloc_env">enif_alloc_env</a>. This environment can be
used to store terms between NIF calls and to send terms with
<a href="#enif_send">enif_send</a>. A
process independent environment with all its terms is valid until
you explicitly invalidate it with
<a href="#enif_free_env">enif_free_env</a>
or <strong>enif_send</strong>.</p> </dd></dl> <p>All contained terms of a list/tuple/map must belong to the same
environment as the list/tuple/map itself. Terms can be copied between
environments with
<a href="#enif_make_copy">enif_make_copy</a>.</p> </dd><dt><a name="ErlNifFunc"></a><strong>ErlNifFunc</strong></dt><dd> <pre><code class="">
typedef struct {
    const char* name;
    unsigned arity;
    ERL_NIF_TERM (*fptr)(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);
    unsigned flags;
} ErlNifFunc;</code></pre> <p>Describes a NIF by its name, arity, and implementation.</p> <dl><dt><strong>fptr</strong></dt><dd> <p>A pointer to the function that implements the NIF.</p> </dd><dt><strong>argv</strong></dt><dd> <p>Contains the function arguments passed to the NIF.</p> </dd><dt><strong>argc</strong></dt><dd> <p>The array length, that is, the function arity. <strong>argv[N-1]</strong>
thus denotes the Nth argument to the NIF. Notice that the argument
<strong>argc</strong> allows for the same C function to implement several
Erlang functions with different arity (but probably with the same
name).</p> </dd><dt><strong>flags</strong></dt><dd> <p>Is <strong>0</strong> for a regular NIF (and so its value can be omitted
for statically initialized <strong>ErlNifFunc</strong> instances).</p> <p><strong>flags</strong> can be used to indicate that the NIF is a
<a href="#dirty_nifs">dirty NIF</a> that is to be
executed on a dirty scheduler thread.</p> <p>If the dirty NIF is expected to be CPU-bound, its <strong>flags</strong>
field is to be set to <strong>ERL_NIF_DIRTY_JOB_CPU_BOUND</strong> or
<strong>ERL_NIF_DIRTY_JOB_IO_BOUND</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>If one of the <strong>ERL_NIF_DIRTY_JOB_*_BOUND</strong> flags is set,
and the runtime system has no support for dirty schedulers,
the runtime system refuses to load the NIF library.</p></div> </dd></dl> </dd><dt><a name="ErlNifBinary"></a><strong>ErlNifBinary</strong></dt><dd> <pre><code class="">
typedef struct {
    unsigned size;
    unsigned char* data;
} ErlNifBinary;</code></pre> <p><strong>ErlNifBinary</strong> contains transient information about an
inspected binary term. <strong>data</strong> is a pointer to a buffer
of <strong>size</strong> bytes with the raw content of the binary.</p> <p>Notice that <strong>ErlNifBinary</strong> is a semi-opaque type and you are
only allowed to read fields <strong>size</strong> and <strong>data</strong>.</p> </dd><dt><a name="ErlNifBinaryToTerm"></a><strong>ErlNifBinaryToTerm</strong></dt><dd> <p>An enumeration of the options that can be specified to
<a href="#enif_binary_to_term">enif_binary_to_term</a>.
For default behavior, use value <strong>0</strong>.</p> <p>When receiving data from untrusted sources, use option
<strong>ERL_NIF_BIN2TERM_SAFE</strong>.</p> </dd><dt><a name="ErlNifMonitor"></a><strong>ErlNifMonitor</strong></dt><dd> <p>This is an opaque data type that identifies a monitor.</p> <p>The nif writer is to provide the memory for storing the
monitor when calling <a href="#enif_monitor_process">enif_monitor_process</a>. The
address of the data is not stored by the runtime system, so
<strong>ErlNifMonitor</strong> can be used as any other data, it
can be copied, moved in memory, forgotten, and so on.
To compare two monitors, <a href="#enif_compare_monitors">enif_compare_monitors</a> must be used.</p> </dd><dt><a name="ErlNifPid"></a><strong>ErlNifPid</strong></dt><dd> <p>A process identifier (pid). In contrast to pid terms (instances of
<strong>ERL_NIF_TERM</strong>), <strong>ErlNifPid</strong>s are self-contained and not
bound to any <a href="#ErlNifEnv">environment</a>.
<strong>ErlNifPid</strong> is an opaque type. It can be copied, moved
in memory, forgotten, and so on.</p> </dd><dt><a name="ErlNifPort"></a><strong>ErlNifPort</strong></dt><dd> <p>A port identifier. In contrast to port ID terms (instances of
<strong>ERL_NIF_TERM</strong>), <strong>ErlNifPort</strong>s are self-contained and not
bound to any <a href="#ErlNifEnv">environment</a>.
<strong>ErlNifPort</strong> is an opaque type. It can be copied, moved
in memory, forgotten, and so on.</p> </dd><dt><a name="ErlNifResourceType"></a><strong>ErlNifResourceType</strong></dt><dd> <p>Each instance of <strong>ErlNifResourceType</strong> represents a class of
memory-managed resource objects that can be garbage collected.
Each resource type has a unique name and a destructor function that
is called when objects of its type are released.</p> </dd><dt><a name="ErlNifResourceTypeInit"></a><strong>ErlNifResourceTypeInit</strong></dt><dd> <pre><code class="">
typedef struct {
    ErlNifResourceDtor* dtor;
    ErlNifResourceStop* stop;
    ErlNifResourceDown* down;
} ErlNifResourceTypeInit;</code></pre> <p>Initialization structure read by <a href="#enif_open_resource_type_x"> enif_open_resource_type_x</a>.</p> </dd><dt><a name="ErlNifResourceDtor"></a><strong>ErlNifResourceDtor</strong></dt><dd> <pre><code class="">
typedef void ErlNifResourceDtor(ErlNifEnv* caller_env, void* obj);</code></pre> <p>The function prototype of a resource destructor function.</p> <p>The <strong>obj</strong> argument is a pointer to the resource. The only
allowed use for the resource in the destructor is to access its
user data one final time. The destructor is guaranteed to be the
last callback before the resource is deallocated.</p> </dd><dt><a name="ErlNifResourceDown"></a><strong>ErlNifResourceDown</strong></dt><dd> <pre><code class="">
typedef void ErlNifResourceDown(ErlNifEnv* caller_env, void* obj, ErlNifPid* pid, ErlNifMonitor* mon);</code></pre> <p>The function prototype of a resource down function,
called on the behalf of <a href="#enif_monitor_process"> enif_monitor_process</a>. <strong>obj</strong> is the resource, <strong>pid</strong>
is the identity of the monitored process that is exiting, and <strong>mon</strong>
is the identity of the monitor.
</p> </dd><dt><a name="ErlNifResourceStop"></a><strong>ErlNifResourceStop</strong></dt><dd> <pre><code class="">
typedef void ErlNifResourceStop(ErlNifEnv* caller_env, void* obj, ErlNifEvent event, int is_direct_call);</code></pre> <p>The function prototype of a resource stop function,
called on the behalf of <a href="#enif_select"> enif_select</a>. <strong>obj</strong> is the resource, <strong>event</strong> is OS event,
<strong>is_direct_call</strong> is true if the call is made directly from <strong>enif_select</strong>
or false if it is a scheduled call (potentially from another thread).</p> </dd><dt><a name="ErlNifCharEncoding"></a><strong>ErlNifCharEncoding</strong></dt><dd> <pre><code class="">
typedef enum {
    ERL_NIF_LATIN1
}ErlNifCharEncoding;</code></pre> <p>The character encoding used in strings and atoms. The only
supported encoding is <strong>ERL_NIF_LATIN1</strong> for
ISO Latin-1 (8-bit ASCII).</p> </dd><dt><a name="ErlNifSysInfo"></a><strong>ErlNifSysInfo</strong></dt><dd> <p>Used by <a href="#enif_system_info">enif_system_info</a> to return information about the
runtime system. Contains the same content as
<a href="./erl_driver#ErlDrvSysInfo">erl_driver#ErlDrvSysInfo</a>.</p> </dd><dt><a name="ErlNifSInt64"></a><strong>ErlNifSInt64</strong></dt><dd> <p>A native signed 64-bit integer type.</p> </dd><dt><a name="ErlNifUInt64"></a><strong>ErlNifUInt64</strong></dt><dd> <p>A native unsigned 64-bit integer type.</p> </dd><dt><a name="ErlNifTime"></a><strong>ErlNifTime</strong></dt><dd> <p>A signed 64-bit integer type for representation of time.</p> </dd><dt><a name="ErlNifTimeUnit"></a><strong>ErlNifTimeUnit</strong></dt><dd> <p>An enumeration of time units supported by the NIF API:</p> <dl><dt><strong>ERL_NIF_SEC</strong></dt><dd>Seconds</dd><dt><strong>ERL_NIF_MSEC</strong></dt><dd>Milliseconds</dd><dt><strong>ERL_NIF_USEC</strong></dt><dd>Microseconds</dd><dt><strong>ERL_NIF_NSEC</strong></dt><dd>Nanoseconds</dd></dl> </dd><dt><a name="ErlNifUniqueInteger"></a><strong>ErlNifUniqueInteger</strong></dt><dd> <p>An enumeration of the properties that can be requested from
<a href="#enif_make_unique_integer">enif_make_unique_integer</a>.
For default properties, use value <strong>0</strong>.</p> <dl><dt><strong>ERL_NIF_UNIQUE_POSITIVE</strong></dt><dd> <p>Return only positive integers.</p> </dd><dt><strong>ERL_NIF_UNIQUE_MONOTONIC</strong></dt><dd> <p>Return only <a href="./time_correction#Strictly_Monotonically_Increasing"> strictly monotonically increasing</a> integer corresponding
to creation time.</p> </dd></dl> </dd><dt><a name="ErlNifHash"></a><strong>ErlNifHash</strong></dt><dd> <p>An enumeration of the supported hash types that can be generated
using <a href="#enif_hash">enif_hash</a>.
</p> <dl><dt><strong>ERL_NIF_INTERNAL_HASH</strong></dt><dd> <p>Non-portable hash function that only guarantees the same hash
for the same term within one Erlang VM instance.</p> <p>It takes 32-bit salt values and generates hashes within <strong>0..2^32-1</strong>.</p> </dd><dt><strong>ERL_NIF_PHASH2</strong></dt><dd> <p>Portable hash function that gives the same hash for the
same Erlang term regardless of machine architecture and ERTS version.</p> <p><em>It ignores salt values</em> and generates hashes within <strong>0..2^27-1</strong>.</p> <p>Slower than <strong>ERL_NIF_INTERNAL_HASH.</strong>
It corresponds to <a href="./erlang#phash2-1">erlang#phash2-1</a>.
</p> </dd></dl> </dd><dt><a name="SysIOVec"></a><strong>SysIOVec</strong></dt><dd> <p>A system I/O vector, as used by <strong>writev</strong> on
Unix and <strong>WSASend</strong> on Win32. It is used in
<strong>ErlNifIOVec</strong> and by
<a href="#enif_ioq_peek">enif_ioq_peek</a>.</p> </dd><dt><a name="ErlNifIOVec"></a><strong>ErlNifIOVec</strong></dt><dd> <pre><code class="">
typedef struct {
  int iovcnt;
  size_t size;
  SysIOVec* iov;
} ErlNifIOVec;</code></pre> <p>An I/O vector containing <strong>iovcnt</strong> <strong>SysIOVec</strong>s
pointing to the data. It is used by
<a href="#enif_inspect_iovec">enif_inspect_iovec</a> and
<a href="#enif_ioq_enqv">enif_ioq_enqv</a>.</p> </dd><dt><a name="ErlNifIOQueueOpts"></a><strong>ErlNifIOQueueOpts</strong></dt><dd> Options to configure a <strong>ErlNifIOQueue</strong>. <dl><dt>ERL_NIF_IOQ_NORMAL</dt><dd><p>Create a normal I/O Queue</p></dd></dl> </dd></dl><h2>Functions</h2><h3>enif_alloc(size_t size):void *</h3><p>Allocate dynamic memory.</p><p>Allocates memory of <strong>size</strong> bytes.</p><p>Returns <strong>NULL</strong> if the allocation fails.</p><p>The returned pointer is suitably aligned for any built-in type that
fit in the allocated memory.</p><h3>enif_alloc_binary(size_t size, ErlNifBinary* bin):int</h3><p>Create a new binary.</p><p>Allocates a new binary of size <strong>size</strong> bytes.
Initializes the structure pointed to by <strong>bin</strong> to
refer to the allocated binary. The binary must either be released by
<a href="#enif_release_binary">enif_release_binary</a> 
or ownership transferred to an Erlang term with
<a href="#enif_make_binary">enif_make_binary</a>.
An allocated (and owned) <strong>ErlNifBinary</strong> can be kept between NIF
calls.</p><p>If you do not need to reallocate or keep the data alive across NIF
calls, consider using <a href="#enif_make_new_binary">enif_make_new_binary</a> instead as it will allocate
small binaries on the process heap when possible.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if allocation
fails.</p><h3>enif_alloc_env():ErlNifEnv *</h3><p>Create a new environment.</p><p>Allocates a new process independent environment. The environment can
be used to hold terms that are not bound to any process. Such terms
can later be copied to a process environment with
<a href="#enif_make_copy">enif_make_copy</a> or
be sent to a process as a message with <a href="#enif_send">enif_send</a>.</p><p>Returns pointer to the new environment.</p><h3>enif_alloc_resource(ErlNifResourceType*
        type, unsigned size):void *</h3><p>Allocate a memory-managed resource object.</p><p>Allocates a memory-managed resource object of type <strong>type</strong> and
size <strong>size</strong> bytes.</p><h3>enif_binary_to_term(ErlNifEnv *env,
        const unsigned char* data, size_t size, ERL_NIF_TERM *term,
        ErlNifBinaryToTerm opts):size_t</h3><p>Create a term from the external format.</p><p>Creates a term that is the result of decoding the binary data at
<strong>data</strong>, which must be encoded according to the Erlang external
term format. No more than <strong>size</strong> bytes are read from <strong>data</strong>.
Argument <strong>opts</strong> corresponds to the second argument to
<a href="./erlang#binary_to_term-2">erlang#binary_to_term-2</a> and must be either <strong>0</strong>
or <strong>ERL_NIF_BIN2TERM_SAFE</strong>.</p><p>On success, stores the resulting term at <strong>*term</strong> and returns
the number of bytes read. Returns <strong>0</strong> if decoding fails or if
<strong>opts</strong> is invalid.</p><p>See also <a href="#ErlNifBinaryToTerm">ErlNifBinaryToTerm</a>,
<a href="./erlang#binary_to_term-2">erlang#binary_to_term-2</a>, and
<a href="#enif_term_to_binary">enif_term_to_binary</a>.</p><h3>enif_clear_env(ErlNifEnv* env):void</h3><p>Clear an environment for reuse.</p><p>Frees all terms in an environment and clears it for reuse.
The environment must have been allocated with
<a href="#enif_alloc_env">enif_alloc_env</a>.</p><h3>enif_compare(ERL_NIF_TERM lhs, ERL_NIF_TERM rhs):int</h3><p>Compare two terms.</p><p>Returns an integer &lt; <strong>0</strong> if <strong>lhs</strong> &lt; <strong>rhs</strong>,
<strong>0</strong> if <strong>lhs</strong> = <strong>rhs</strong>, and &gt; <strong>0</strong> if
<strong>lhs</strong> &gt; <strong>rhs</strong>. Corresponds to the Erlang
operators <strong>==</strong>, <strong>/=</strong>, <strong>=&lt;</strong>, <strong>&lt;</strong>,
<strong>&gt;=</strong>, and <strong>&gt;</strong> (but <em>not</em> <strong>=:=</strong> or
<strong>=/=</strong>).</p><h3>enif_compare_monitors(const ErlNifMonitor
        *monitor1, const ErlNifMonitor *monitor2):int</h3><p>Compare two monitors.</p><a name="enif_compare_monitors"></a><p>Compares two <a href="#ErlNifMonitor">ErlNifMonitor</a>s.
Can also be used to imply some artificial order on monitors,
for whatever reason.</p><p>Returns <strong>0</strong> if <strong>monitor1</strong> and <strong>monitor2</strong> are equal,
&lt; <strong>0</strong> if <strong>monitor1</strong> &lt; <strong>monitor2</strong>, and
&gt; <strong>0</strong> if <strong>monitor1</strong> &gt; <strong>monitor2</strong>.</p><h3>enif_compare_pids(const ErlNifPid *pid1, const ErlNifPid *pid2)
:int</h3><p>Compare two pids.</p><p>Compares two <a href="#ErlNifPid">ErlNifPid</a>s according to term order.</p><p>Returns <strong>0</strong> if <strong>pid1</strong> and <strong>pid2</strong> are equal,
&lt; <strong>0</strong> if <strong>pid1</strong> &lt; <strong>pid2</strong>, and
&gt; <strong>0</strong> if <strong>pid1</strong> &gt; <strong>pid2</strong>.</p><h3>enif_cond_broadcast(ErlNifCond *cnd):void</h3><p>Same as <a href="./erl_driver#erl_drv_cond_broadcast">erl_driver#erl_drv_cond_broadcast</a>.</p><h3>enif_cond_create(char *name):ErlNifCond *</h3><p>Same as <a href="./erl_driver#erl_drv_cond_create">erl_driver#erl_drv_cond_create</a>.</p><h3>enif_cond_destroy(ErlNifCond *cnd):void</h3><p>Same as <a href="./erl_driver#erl_drv_cond_destroy">erl_driver#erl_drv_cond_destroy</a>.</p><h3>enif_cond_name(ErlNifCond* cnd):char*</h3><p>Same as <a href="./erl_driver#erl_drv_cond_name">erl_driver#erl_drv_cond_name</a>.</p><h3>enif_cond_signal(ErlNifCond *cnd):void</h3><p>Same as <a href="./erl_driver#erl_drv_cond_signal">erl_driver#erl_drv_cond_signal</a>.</p><h3>enif_cond_wait(ErlNifCond *cnd, ErlNifMutex *mtx):void</h3><p>Same as <a href="./erl_driver#erl_drv_cond_wait">erl_driver#erl_drv_cond_wait</a>.</p><h3>enif_consume_timeslice(ErlNifEnv *env, int percent):int</h3><p>Gives the runtime system a hint about how much CPU time the current
NIF call has consumed since the last hint, or since the start of the
NIF if no previous hint has been specified. The time is specified as a
percent of the timeslice that a process is allowed to execute
Erlang code until it can be suspended to give time for other runnable
processes. The scheduling timeslice is not an exact entity, but can
usually be approximated to about 1 millisecond.</p><p>Notice that it is up to the runtime system to determine if and how
to use this information. Implementations on some platforms can use
other means to determine consumed CPU time. Lengthy NIFs should
regardless of this frequently call <strong>enif_consume_timeslice</strong> to
determine if it is allowed to continue execution.</p><p>Argument <strong>percent</strong> must be an integer between 1 and 100. This
function must only be called from a NIF-calling thread, and argument
<strong>env</strong> must be the environment of the calling process.</p><p>Returns <strong>1</strong> if the timeslice is exhausted, otherwise <strong>0</strong>.
If <strong>1</strong> is returned, the NIF is to return as soon as possible in
order for the process to yield.</p><p>This function is provided to better support co-operative scheduling,
improve system responsiveness, and make it easier to prevent
misbehaviors of the VM because of a NIF monopolizing a scheduler
thread. It can be used to divide <a href="#lengthy_work"> length work</a> into a number of repeated NIF calls without the
need to create threads.</p><p>See also the <a href="#WARNING">warning</a> text at
the beginning of this manual page.</p><h3>enif_convert_time_unit(ErlNifTime
        val, ErlNifTimeUnit from, ErlNifTimeUnit to):ErlNifTime</h3><p>Convert time unit of a time value.</p><a name="enif_convert_time_unit"></a><p>Converts the <strong>val</strong> value of time unit <strong>from</strong> to
the corresponding value of time unit <strong>to</strong>. The result is
rounded using the floor function.</p><dl><dt><strong>val</strong></dt><dd>Value to convert time unit for.</dd><dt><strong>from</strong></dt><dd>Time unit of <strong>val</strong>.</dd><dt><strong>to</strong></dt><dd>Time unit of returned value.</dd></dl><p>Returns <strong>ERL_NIF_TIME_ERROR</strong> if called with an invalid
time unit argument.</p><p>See also <a href="#ErlNifTime">ErlNifTime</a>
and
<a href="#ErlNifTimeUnit">ErlNifTimeUnit</a>.</p><h3>enif_cpu_time(ErlNifEnv *):ERL_NIF_TERM</h3><p>Returns the CPU time in the same format as
<a href="./erlang#timestamp-0">erlang#timestamp-0</a>.
The CPU time is the time the current logical CPU has spent executing
since some arbitrary point in the past. If the OS does not support
fetching this value, <strong>enif_cpu_time</strong> invokes
<a href="#enif_make_badarg">enif_make_badarg</a>.</p><h3>enif_demonitor_process(ErlNifEnv* caller_env,
      void* obj, const ErlNifMonitor* mon):int</h3><p>Cancel a process monitor.</p><a name="enif_demonitor_process"></a><p>Cancels a monitor created earlier with <a href="#enif_monitor_process">enif_monitor_process</a>. Argument <strong>obj</strong> is a pointer
to the resource holding the monitor and	<strong>*mon</strong> identifies the
monitor.</p><p>Argument <strong>caller_env</strong> is the environment of the calling process
or callback. Must only be NULL if calling from a custom thread.</p><p>Returns <strong>0</strong> if the monitor was successfully identified and removed.
Returns	a non-zero value if the monitor could not be identified, which means
it was either</p><ul><li>never created for this resource</li><li>already cancelled</li><li>already triggered</li><li>just about to be triggered by a concurrent thread</li></ul><p>This function is only thread-safe when the emulator with SMP support
is used. It can only be used in a non-SMP emulator from a NIF-calling
thread.</p><h3>enif_equal_tids(ErlNifTid tid1, ErlNifTid tid2):int</h3><p>Same as <a href="./erl_driver#erl_drv_equal_tids">erl_driver#erl_drv_equal_tids</a>.</p><h3>enif_fprintf(FILE *stream, const char *format, ...):int</h3><p>Format strings and Erlang terms.</p><p>Similar to <strong>fprintf</strong> but this format string also accepts
<strong>"%T"</strong>, which formats Erlang terms of type
<a href="#ERL_NIF_TERM">ERL_NIF_TERM</a>.</p><p>This function is primarily intended for debugging purpose. It is not
recommended to print very large terms with <strong>%T</strong>. The function may
change <strong>errno</strong>, even if successful.</p><h3>enif_free(void* ptr):void</h3><p>Free dynamic memory.</p><p>Frees memory allocated by
<a href="#enif_alloc">enif_alloc</a>.</p><h3>enif_free_env(ErlNifEnv* env):void</h3><p>Free an environment allocated with enif_alloc_env.</p><p>Frees an environment allocated with
<a href="#enif_alloc_env">enif_alloc_env</a>.
All terms created in the environment are freed as well.</p><h3>enif_free_iovec(ErlNifIOvec* iov):void</h3><p>Free an ErlIOVec</p><p>Frees an io vector returned from
<a href="#enif_inspect_iovec">enif_inspect_iovec</a>.
This is needed only if a <strong>NULL</strong> environment is passed to
<a href="#enif_inspect_iovec">enif_inspect_iovec</a>.</p><pre><code class="">
ErlNifIOVec *iovec = NULL;
size_t max_elements = 128;
ERL_NIF_TERM tail;
if (!enif_inspect_iovec(NULL, max_elements, term, &amp;tail, &amp;iovec))
  return 0;

// Do things with the iovec

/* Free the iovector, possibly in another thread or nif function call */
enif_free_iovec(iovec);</code></pre><h3>enif_get_atom(ErlNifEnv* env, ERL_NIF_TERM
        term, char* buf, unsigned size, ErlNifCharEncoding encode):int</h3><p>Get the text representation of an atom term.</p><p>Writes a <strong>NULL</strong>-terminated string in the buffer pointed to by
<strong>buf</strong> of size <strong>size</strong>, consisting of the string
representation of the atom <strong>term</strong> with encoding
<a href="#ErlNifCharEncoding">encode</a>.</p><p>Returns the number of bytes written (including terminating
<strong>NULL</strong> character) or <strong>0</strong> if <strong>term</strong> is not an atom with
maximum length of <strong>size-1</strong>.</p><h3>enif_get_atom_length(ErlNifEnv* env,
        ERL_NIF_TERM term, unsigned* len, ErlNifCharEncoding encode):int</h3><p>Get the length of atom <strong>term</strong>.</p><p>Sets <strong>*len</strong> to the length (number of bytes excluding
terminating <strong>NULL</strong> character) of the atom <strong>term</strong> with
encoding <strong>encode</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is not
an atom.</p><h3>enif_get_double(ErlNifEnv* env,
        ERL_NIF_TERM term, double* dp):int</h3><p>Read a floating-point number term.</p><p>Sets <strong>*dp</strong> to the floating-point value of <strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is not
a float.</p><h3>enif_get_int(ErlNifEnv* env, ERL_NIF_TERM
        term, int* ip):int</h3><p>Read an integer term.</p><p>Sets <strong>*ip</strong> to the integer value of <strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is not
an integer or is outside the bounds of type <strong>int</strong>.</p><h3>enif_get_int64(ErlNifEnv* env, ERL_NIF_TERM
        term, ErlNifSInt64* ip):int</h3><p>Read a 64-bit integer term.</p><p>Sets <strong>*ip</strong> to the integer value of <strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is not
an integer or is outside the bounds of a signed 64-bit integer.</p><h3>enif_get_local_pid(ErlNifEnv* env,
        ERL_NIF_TERM term, ErlNifPid* pid):int</h3><p>Read a local pid term.</p><p>If <strong>term</strong> is the pid of a node local process, this function
initializes the pid variable <strong>*pid</strong> from it and returns
<strong>true</strong>. Otherwise returns <strong>false</strong>. No check is done to see
if the process is alive.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><strong>enif_get_local_pid</strong> will return false if argument
<strong>term</strong> is the atom <a href="#enif_make_pid">enif_make_pid</a>.</p></div><h3>enif_get_local_port(ErlNifEnv* env,
        ERL_NIF_TERM term, ErlNifPort* port_id):int</h3><p>Read a local port term.</p><p>If <strong>term</strong> identifies a node local port, this function
initializes the port variable <strong>*port_id</strong> from it and returns
<strong>true</strong>. Otherwise returns <strong>false</strong>. No check is done to see
if the port is alive.</p><h3>enif_get_list_cell(ErlNifEnv* env,
        ERL_NIF_TERM list, ERL_NIF_TERM* head, ERL_NIF_TERM* tail):int</h3><p>Get head and tail from a list.</p><p>Sets <strong>*head</strong> and <strong>*tail</strong> from list <strong>list</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if it is
not a list or the list is empty.</p><h3>enif_get_list_length(ErlNifEnv* env,
        ERL_NIF_TERM term, unsigned* len):int</h3><p>Get the length of list <strong>term</strong>.</p><p>Sets <strong>*len</strong> to the length of list <strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is
not a proper list.</p><h3>enif_get_long(ErlNifEnv* env, ERL_NIF_TERM
        term, long int* ip):int</h3><p>Read a long integer term.</p><p>Sets <strong>*ip</strong> to the long integer value of <strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is
not an integer or is outside the bounds of type <strong>long int</strong>.</p><h3>enif_get_map_size(ErlNifEnv* env,
        ERL_NIF_TERM term, size_t *size):int</h3><p>Read the size of a map term.</p><p>Sets <strong>*size</strong> to the number of key-value pairs in the map
<strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is
not a map.</p><h3>enif_get_map_value(ErlNifEnv* env,
        ERL_NIF_TERM map, ERL_NIF_TERM key, ERL_NIF_TERM* value):int</h3><p>Get the value of a key in a map.</p><p>Sets <strong>*value</strong> to the value associated with <strong>key</strong> in the
map <strong>map</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>map</strong> is not
a map or if <strong>map</strong> does not contain <strong>key</strong>.</p><h3>enif_get_resource(ErlNifEnv* env,
        ERL_NIF_TERM term, ErlNifResourceType* type, void** objp):int</h3><p>Get the pointer to a resource object.</p><p>Sets <strong>*objp</strong> to point to the resource object referred to by
<strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is
not a handle to a resource object of type <strong>type</strong>.</p><h3>enif_get_string(ErlNifEnv* env,
        ERL_NIF_TERM list, char* buf, unsigned size,
        ErlNifCharEncoding encode):int</h3><p>Get a C-string from a list.</p><p>Writes a <strong>NULL</strong>-terminated string in the buffer pointed to by
<strong>buf</strong> with size <strong>size</strong>, consisting of the characters
in the string <strong>list</strong>. The characters are written using encoding
<a href="#ErlNifCharEncoding">encode</a>.</p><p>Returns one of the following:</p><ul><li>The number of bytes written (including terminating <strong>NULL</strong> character)</li><li><strong>-size</strong> if the string was truncated because of buffer space</li><li><strong>0</strong> if <strong>list</strong> is not a string that can be encoded with <strong>encode</strong> or if <strong>size</strong> was &lt; <strong>1</strong>.</li></ul><p>The written string is always <strong>NULL</strong>-terminated, unless buffer
<strong>size</strong> is &lt; <strong>1</strong>.</p><h3>enif_get_tuple(ErlNifEnv* env, ERL_NIF_TERM
        term, int* arity, const ERL_NIF_TERM** array):int</h3><p>Inspect the elements of a tuple.</p><p>If <strong>term</strong> is a tuple, this function sets <strong>*array</strong> to point
to an array containing the elements of the tuple, and sets
<strong>*arity</strong> to the number of elements. Notice that the array
is read-only and <strong>(*array)[N-1]</strong> is the Nth element of
the tuple. <strong>*array</strong> is undefined if the arity of the tuple
is zero.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is
not a tuple.</p><h3>enif_get_uint(ErlNifEnv* env, ERL_NIF_TERM
        term, unsigned int* ip):int</h3><p>Read an unsigned integer term.</p><p>Sets <strong>*ip</strong> to the unsigned integer value of <strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is
not an unsigned integer or is outside the bounds of type
<strong>unsigned int</strong>.</p><h3>enif_get_uint64(ErlNifEnv* env,
        ERL_NIF_TERM term, ErlNifUInt64* ip):int</h3><p>Read an unsigned 64-bit integer term.</p><p>Sets <strong>*ip</strong> to the unsigned integer value of <strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is
not an unsigned integer or is outside the bounds of an unsigned
64-bit integer.</p><h3>enif_get_ulong(ErlNifEnv* env, ERL_NIF_TERM
        term, unsigned long* ip):int</h3><p>Read an unsigned integer term.</p><p>Sets <strong>*ip</strong> to the unsigned long integer value of
<strong>term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>term</strong> is
not an unsigned integer or is outside the bounds of type
<strong>unsigned long</strong>.</p><h3>enif_getenv(const char* key, char* value,
        size_t *value_size):int</h3><p>Get the value of an environment variable.</p><p>Same as <a href="./erl_driver#erl_drv_getenv">erl_driver#erl_drv_getenv</a>.</p><h3>enif_has_pending_exception(ErlNifEnv* env,
        ERL_NIF_TERM* reason):int</h3><p>Check if an exception has been raised.</p><p>Returns <strong>true</strong> if a pending exception is associated with the
environment <strong>env</strong>. If <strong>reason</strong> is a <strong>NULL</strong> pointer,
ignore it. Otherwise, if a pending exception associated with
<strong>env</strong> exists, set <strong>*reason</strong> to the value of the exception
term. For example, if <a href="#enif_make_badarg">enif_make_badarg</a> is called to set a pending
<strong>badarg</strong> exception, a later call to
<strong>enif_has_pending_exception(env, &amp;reason)</strong> sets
<strong>*reason</strong> to the atom <strong>badarg</strong>, then return <strong>true</strong>.</p><p>See also <a href="#enif_make_badarg">enif_make_badarg</a> and
<a href="#enif_raise_exception">enif_raise_exception</a>.</p><h3>enif_hash(ErlNifHash type, ERL_NIF_TERM term, ErlNifUInt64 salt):ErlNifUInt64</h3><p>Hash terms.</p><p>Hashes <strong>term</strong> according to the specified
<a href="#ErlNifHash">ErlNifHash</a> <strong>type</strong>.</p><p>Ranges of taken salt (if any) and returned value depend on the hash type.</p><h3>enif_inspect_binary(ErlNifEnv* env,
        ERL_NIF_TERM bin_term, ErlNifBinary* bin):int</h3><p>Inspect the content of a binary.</p><p>Initializes the structure pointed to by <strong>bin</strong> with information
about binary term <strong>bin_term</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>bin_term</strong>
is not a binary.</p><h3>enif_inspect_iolist_as_binary(ErlNifEnv*
        env, ERL_NIF_TERM term, ErlNifBinary* bin):int</h3><p>Inspect the content of an iolist.</p><p>Initializes the structure pointed to by <strong>bin</strong> with a
continuous buffer with the same byte content as <strong>iolist</strong>. As
with <strong>inspect_binary</strong>, the data pointed to by <strong>bin</strong> is
transient and does not need to be released.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>iolist</strong> is
not an iolist.</p><h3>enif_inspect_iovec(ErlNifEnv*
        env, size_t max_elements, ERL_NIF_TERM iovec_term, ERL_NIF_TERM* tail,
        ErlNifIOVec** iovec):int</h3><p>Inspect a list of binaries as an ErlNifIOVec.</p><p>Fills <strong>iovec</strong> with the list of binaries provided in
<strong>iovec_term</strong>. The number of elements handled in the call is
limited to <strong>max_elements</strong>, and <strong>tail</strong> is set to the
remainder of the list. Note that the output may be longer than
<strong>max_elements</strong> on some platforms.
</p><p>To create a list of binaries from an arbitrary iolist, use
<a href="../erts/erlang#iolist_to_iovec/1">erts/erlang#iolist_to_iovec/1</a>.</p><p>When calling this function, <strong>iovec</strong> should contain a pointer to
<strong>NULL</strong> or a ErlNifIOVec structure that should be used if
possible. e.g.
</p><pre><code class="">
/* Don't use a pre-allocated structure */
ErlNifIOVec *iovec = NULL;
enif_inspect_iovec(env, max_elements, term, &amp;tail, &amp;iovec);

/* Use a stack-allocated vector as an optimization for vectors with few elements */
ErlNifIOVec vec, *iovec = &amp;vec;
enif_inspect_iovec(env, max_elements, term, &amp;tail, &amp;iovec);
</code></pre><p>The contents of the <strong>iovec</strong> is valid until the called nif
function returns. If the <strong>iovec</strong> should be valid after the nif
call returns, it is possible to call this function with a
<strong>NULL</strong> environment. If no environment is given the <strong>iovec</strong>
owns the data in the vector and it has to be explicitly freed using
<a href="#enif_free_iovec">enif_free_iovec</a>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>iovec_term</strong>
not an iovec.</p><h3>enif_ioq_create(ErlNifIOQueueOpts opts):ErlNifIOQueue *</h3><p>Create a new IO Queue</p><p>Create a new I/O Queue that can be used to store data.
<strong>opts</strong> has to be set to <strong>ERL_NIF_IOQ_NORMAL</strong>.
</p><h3>enif_ioq_destroy(ErlNifIOQueue *q):void</h3><p>Destroy an IO Queue and free it's content</p><p>Destroy the I/O queue and free all of it's contents</p><h3>enif_ioq_deq(ErlNifIOQueue *q, size_t count, size_t *size):int</h3><p>Dequeue count bytes from the IO Queue</p><p>Dequeue <strong>count</strong> bytes from the I/O queue.
If <strong>size</strong> is not <strong>NULL</strong>, the new size of the queue
is placed there.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if the I/O does
not contain <strong>count</strong> bytes. On failure the queue is left un-altered.</p><h3>enif_ioq_enq_binary(ErlNifIOQueue *q, ErlNifBinary *bin, size_t skip):int</h3><p>Enqueue the binary into the IO Queue</p><p>Enqueue the <strong>bin</strong> into <strong>q</strong> skipping the first <strong>skip</strong> bytes.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>skip</strong> is greater
than the size of <strong>bin</strong>. Any ownership of the binary data is transferred
to the queue and <strong>bin</strong> is to be considered read-only for the rest of the NIF
call and then as released.</p><h3>enif_ioq_enqv(ErlNifIOQueue *q, ErlNifIOVec *iovec, size_t skip):int</h3><p>Enqueue the iovec into the IO Queue</p><p>Enqueue the <strong>iovec</strong> into <strong>q</strong> skipping the first <strong>skip</strong> bytes.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>skip</strong> is greater
than the size of <strong>iovec</strong>.</p><h3>enif_ioq_peek(ErlNifIOQueue *q, int *iovlen):SysIOVec *</h3><p>Peek inside the IO Queue</p><p>Get the I/O queue as a pointer to an array of <strong>SysIOVec</strong>s.
It also returns the number of elements in <strong>iovlen</strong>.</p><p>Nothing is removed from the queue by this function, that must be done
with <a href="#enif_ioq_deq">enif_ioq_deq</a>.</p><p>The returned array is suitable to use with the Unix system
call <strong>writev</strong>.</p><h3>enif_ioq_peek_head(ErlNifEnv *env, ErlNifIOQueue *q, size_t *size, ERL_NIF_TERM *bin_term):int</h3><p>Peek the head of the IO Queue.</p><p>Get the head of the IO Queue as a binary term.</p><p>If <strong>size</strong> is not <strong>NULL</strong>, the size of the head is placed
there.</p><p>Nothing is removed from the queue by this function, that must be done
with <a href="#enif_ioq_deq">enif_ioq_deq</a>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if the queue is
empty.</p><h3>enif_ioq_size(ErlNifIOQueue *q):size_t</h3><p>Get the current size of the IO Queue</p><p>Get the size of <strong>q</strong>.</p><h3>enif_is_atom(ErlNifEnv* env, ERL_NIF_TERM term):int</h3><p>Determine if a term is an atom.</p><p>Returns <strong>true</strong> if <strong>term</strong> is an atom.</p><h3>enif_is_binary(ErlNifEnv* env, ERL_NIF_TERM term):int</h3><p>Determine if a term is a binary.</p><p>Returns <strong>true</strong> if <strong>term</strong> is a binary.</p><h3>enif_is_current_process_alive(ErlNifEnv* env):int</h3><p>Determine if currently executing process is alive.</p><p>Returns <strong>true</strong> if the currently executing process is currently
alive, otherwise <strong>false</strong>.</p><p>This function can only be used from a NIF-calling thread, and with
an environment corresponding to currently executing processes.</p><h3>enif_is_empty_list(ErlNifEnv* env,
        ERL_NIF_TERM term):int</h3><p>Determine if a term is an empty list.</p><p>Returns <strong>true</strong> if <strong>term</strong> is an empty list.</p><h3>enif_is_exception(ErlNifEnv* env,
        ERL_NIF_TERM term):int</h3><p>Determine if a term is an exception.</p><a name="enif_is_exception"></a><p>Return true if <strong>term</strong> is an exception.</p><h3>enif_is_fun(ErlNifEnv* env, ERL_NIF_TERM
        term):int</h3><p>Determine if a term is a fun.</p><p>Returns <strong>true</strong> if <strong>term</strong> is a fun.</p><h3>enif_is_identical(ERL_NIF_TERM lhs,
        ERL_NIF_TERM rhs):int</h3><p>Erlang operator =:=.</p><p>Returns <strong>true</strong> if the two terms are identical. Corresponds to
the Erlang operators <strong>=:=</strong> and <strong>=/=</strong>.</p><h3>enif_is_list(ErlNifEnv* env, ERL_NIF_TERM term):int</h3><p>Determine if a term is a list.</p><p>Returns <strong>true</strong> if <strong>term</strong> is a list.</p><h3>enif_is_map(ErlNifEnv* env, ERL_NIF_TERM
        term):int</h3><p>Determine if a term is a map.</p><p>Returns <strong>true</strong> if <strong>term</strong> is a map, otherwise
<strong>false</strong>.</p><h3>enif_is_number(ErlNifEnv* env, ERL_NIF_TERM
        term):int</h3><p>Determine if a term is a number (integer or float).</p><p>Returns <strong>true</strong> if <strong>term</strong> is a number.</p><h3>enif_is_pid(ErlNifEnv* env, ERL_NIF_TERM term):int</h3><p>Determine if a term is a pid.</p><p>Returns <strong>true</strong> if <strong>term</strong> is a pid.</p><h3>enif_is_pid_undefined(const ErlNifPid* pid):int</h3><p>Determine if pid is undefined.</p><p>Returns <strong>true</strong> if <strong>pid</strong> has been set as undefined by
<a href="#enif_set_pid_undefined">enif_set_pid_undefined</a>.</p><h3>enif_is_port(ErlNifEnv* env, ERL_NIF_TERM term):int</h3><p>Determine if a term is a port.</p><p>Returns <strong>true</strong> if <strong>term</strong> is a port.</p><h3>enif_is_port_alive(ErlNifEnv* env,
        ErlNifPort *port_id):int</h3><p>Determine if a local port is alive.</p><p>Returns <strong>true</strong> if <strong>port_id</strong> is alive.</p><p>This function is only thread-safe when the emulator with SMP support
is used. It can only be used in a non-SMP emulator from a NIF-calling
thread.</p><h3>enif_is_process_alive(ErlNifEnv* env,
        ErlNifPid *pid):int</h3><p>Determine if a local process is alive.</p><p>Returns <strong>true</strong> if <strong>pid</strong> is alive.</p><p>This function is only thread-safe when the emulator with SMP support
is used. It can only be used in a non-SMP emulator from a NIF-calling
thread.</p><h3>enif_is_ref(ErlNifEnv* env, ERL_NIF_TERM term):int</h3><p>Determine if a term is a reference.</p><p>Returns <strong>true</strong> if <strong>term</strong> is a reference.</p><h3>enif_is_tuple(ErlNifEnv* env, ERL_NIF_TERM term):int</h3><p>Determine if a term is a tuple.</p><p>Returns <strong>true</strong> if <strong>term</strong> is a tuple.</p><h3>enif_keep_resource(void* obj):int</h3><p>Add a reference to a resource object.</p><p>Adds a reference to resource object <strong>obj</strong> obtained from
<a href="#enif_alloc_resource">enif_alloc_resource</a>. Each call to
<strong>enif_keep_resource</strong> for an object must be balanced by a call to
<a href="#enif_release_resource">enif_release_resource</a>
before the object is destructed.</p><h3>enif_make_atom(ErlNifEnv* env, const char* name):ERL_NIF_TERM</h3><p>Create an atom term.</p><p>Creates an atom term from the <strong>NULL</strong>-terminated C-string
<strong>name</strong> with ISO Latin-1 encoding. If the length of <strong>name</strong>
exceeds the maximum length allowed for an atom (255 characters),
<strong>enif_make_atom</strong> invokes <a href="#enif_make_badarg">enif_make_badarg</a>.</p><h3>enif_make_atom_len(ErlNifEnv* env,
        const char* name, size_t len):ERL_NIF_TERM</h3><p>Create an atom term.</p><p>Create an atom term from the string <strong>name</strong> with length
<strong>len</strong>. <strong>NULL</strong> characters are treated as any other
characters. If <strong>len</strong> exceeds the maximum length
allowed for an atom (255 characters), <strong>enif_make_atom</strong> invokes
<a href="#enif_make_badarg">enif_make_badarg</a>.</p><h3>enif_make_badarg(ErlNifEnv* env):ERL_NIF_TERM</h3><p>Make a badarg exception.</p><p>Makes a <strong>badarg</strong> exception to be returned from a NIF, and
associates it with environment <strong>env</strong>. Once a NIF or any function
it calls invokes <strong>enif_make_badarg</strong>, the runtime ensures that a
<strong>badarg</strong> exception is raised when the NIF returns, even if the
NIF attempts to return a non-exception term instead.</p><p>The return value from <strong>enif_make_badarg</strong> can be used only as
the return value from the NIF that invoked it (directly or indirectly)
or be passed to <a href="#enif_is_exception">enif_is_exception</a>, but not to any other NIF API
function.</p><p>See also <a href="#enif_has_pending_exception">enif_has_pending_exception</a> and
<a href="#enif_raise_exception">enif_raise_exception</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Before ERTS 7.0 (Erlang/OTP 18), the return value
from <strong>enif_make_badarg</strong> had to be returned from the NIF. This
requirement is now lifted as the return value from the NIF is
ignored if <strong>enif_make_badarg</strong> has been invoked.</p></div><h3>enif_make_binary(ErlNifEnv* env, ErlNifBinary* bin):ERL_NIF_TERM</h3><p>Make a binary term.</p><p>Makes a binary term from <strong>bin</strong>. Any ownership of
the binary data is transferred to the created term and
<strong>bin</strong> is to be considered read-only for the rest of the NIF
call and then as released.</p><h3>enif_make_copy(ErlNifEnv* dst_env,
        ERL_NIF_TERM src_term):ERL_NIF_TERM</h3><p>Make a copy of a term.</p><p>Makes a copy of term <strong>src_term</strong>. The copy is created in
environment <strong>dst_env</strong>. The source term can be located in any
environment.</p><h3>enif_make_double(ErlNifEnv* env, double d):ERL_NIF_TERM</h3><p>Create a floating-point term.</p><p>Creates a floating-point term from a <strong>double</strong>. If argument
<strong>double</strong> is not finite or is NaN, <strong>enif_make_double</strong>
invokes <a href="#enif_make_badarg">enif_make_badarg</a>.</p><h3>enif_make_existing_atom(ErlNifEnv* env,
        const char* name, ERL_NIF_TERM* atom, ErlNifCharEncoding
        encode):int</h3><p>Create an existing atom term.</p><p>Tries to create the term of an already existing atom from
the <strong>NULL</strong>-terminated C-string <strong>name</strong> with encoding
<a href="#ErlNifCharEncoding">encode</a>.</p><p>If the atom already exists, this function stores the term in
<strong>*atom</strong> and returns <strong>true</strong>, otherwise <strong>false</strong>.
Also returns <strong>false</strong> if the length of <strong>name</strong> exceeds the
maximum length allowed for an atom (255 characters).</p><h3>enif_make_existing_atom_len(ErlNifEnv* env,
        const char* name, size_t len, ERL_NIF_TERM* atom, ErlNifCharEncoding
        encoding):int</h3><p>Create an existing atom term.</p><p>Tries to create the term of an already existing atom from the
string <strong>name</strong> with length <strong>len</strong> and encoding
<a href="#ErlNifCharEncoding">encode</a>. <strong>NULL</strong>
characters are treated as any other characters.</p><p>If the atom already exists, this function stores the term in
<strong>*atom</strong> and returns <strong>true</strong>, otherwise <strong>false</strong>.
Also returns <strong>false</strong> if <strong>len</strong> exceeds the maximum length
allowed for an atom (255 characters).</p><h3>enif_make_int(ErlNifEnv* env, int i):ERL_NIF_TERM</h3><p>Create an integer term.</p><p>Creates an integer term.</p><h3>enif_make_int64(ErlNifEnv* env, ErlNifSInt64 i):ERL_NIF_TERM</h3><p>Create an integer term.</p><p>Creates an integer term from a signed 64-bit integer.</p><h3>enif_make_list(ErlNifEnv* env, unsigned cnt, ...):ERL_NIF_TERM</h3><p>Create a list term.</p><p>Creates an ordinary list term of length <strong>cnt</strong>. Expects
<strong>cnt</strong> number of arguments (after <strong>cnt</strong>) of type
<strong>ERL_NIF_TERM</strong> as the elements of the list.</p><p>Returns an empty list if <strong>cnt</strong> is 0.</p><h3>enif_make_list1(ErlNifEnv* env, ERL_NIF_TERM e1):ERL_NIF_TERM</h3><h3>enif_make_list2(ErlNifEnv* env,
        ERL_NIF_TERM e1, ERL_NIF_TERM e2):ERL_NIF_TERM</h3><h3>enif_make_list3(ErlNifEnv* env,
        ERL_NIF_TERM e1, ERL_NIF_TERM e2, ERL_NIF_TERM e3):ERL_NIF_TERM</h3><h3>enif_make_list4(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e4):ERL_NIF_TERM</h3><h3>enif_make_list5(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e5):ERL_NIF_TERM</h3><h3>enif_make_list6(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e6):ERL_NIF_TERM</h3><h3>enif_make_list7(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e7):ERL_NIF_TERM</h3><h3>enif_make_list8(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e8):ERL_NIF_TERM</h3><h3>enif_make_list9(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e9):ERL_NIF_TERM</h3><p>Create a list term.</p><p>Creates an ordinary list term with length indicated by the
function name. Prefer these functions (macros) over the variadic
<strong>enif_make_list</strong> to get a compile-time error if the number of
arguments does not match.</p><h3>enif_make_list_cell(ErlNifEnv*
        env, ERL_NIF_TERM head, ERL_NIF_TERM tail):ERL_NIF_TERM</h3><p>Create a list cell.</p><p>Creates a list cell <strong>[head | tail]</strong>.</p><h3>enif_make_list_from_array(ErlNifEnv* env, const ERL_NIF_TERM
          arr[], unsigned cnt):ERL_NIF_TERM</h3><p>Create a list term from an array.</p><p>Creates an ordinary list containing the elements of array <strong>arr</strong>
of length <strong>cnt</strong>.</p><p>Returns an empty list if <strong>cnt</strong> is 0.</p><h3>enif_make_long(ErlNifEnv* env, long int i):ERL_NIF_TERM</h3><p>Create an integer term from a long int.</p><p>Creates an integer term from a <strong>long int</strong>.</p><h3>enif_make_map_put(ErlNifEnv* env,
        ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM value,
        ERL_NIF_TERM* map_out):int</h3><p>Insert key-value pair in map.</p><p>Makes a copy of map <strong>map_in</strong> and inserts <strong>key</strong> with
<strong>value</strong>. If <strong>key</strong> already exists in <strong>map_in</strong>, the old
associated value is replaced by <strong>value</strong>.</p><p>If successful, this function sets <strong>*map_out</strong> to the new map and
returns <strong>true</strong>. Returns <strong>false</strong> if <strong>map_in</strong> is not a
map.</p><p>The <strong>map_in</strong> term must belong to environment <strong>env</strong>.</p><h3>enif_make_map_remove(ErlNifEnv* env,
        ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM* map_out):int</h3><p>Remove key from map.</p><p>If map <strong>map_in</strong> contains <strong>key</strong>, this function makes a copy
of <strong>map_in</strong> in <strong>*map_out</strong>, and removes <strong>key</strong> and the
associated value. If map <strong>map_in</strong> does not contain <strong>key</strong>,
<strong>*map_out</strong> is set to <strong>map_in</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if <strong>map_in</strong> is
not a map.</p><p>The <strong>map_in</strong> term must belong to environment <strong>env</strong>.</p><h3>enif_make_map_update(ErlNifEnv* env,
        ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM new_value,
        ERL_NIF_TERM* map_out):int</h3><p>Replace value for key in map.</p><p>Makes a copy of map <strong>map_in</strong> and replace the old associated
value for <strong>key</strong> with <strong>new_value</strong>.</p><p>If successful, this function sets <strong>*map_out</strong> to the new map and
returns <strong>true</strong>. Returns <strong>false</strong> if <strong>map_in</strong> is not a
map or if it does not contain <strong>key</strong>.</p><p>The <strong>map_in</strong> term must belong to environment <strong>env</strong>.</p><h3>enif_make_map_from_arrays(ErlNifEnv* env, ERL_NIF_TERM keys[],
        ERL_NIF_TERM values[], size_t cnt, ERL_NIF_TERM *map_out):int</h3><p>Make map term from the given keys and values.</p><p>Makes a map term from the given keys and values.</p><p>If successful, this function sets <strong>*map_out</strong> to the new map and
returns <strong>true</strong>. Returns <strong>false</strong> there are any duplicate
keys.</p><p>All keys and values must belong to <strong>env</strong>.</p><h3>enif_make_monitor_term(ErlNifEnv* env, const ErlNifMonitor* mon):ERL_NIF_TERM</h3><p>Make monitor term from the given monitor identifier.</p><p>Creates a term identifying the given monitor received from
<a href="#enif_monitor_process">enif_monitor_process</a>.</p><p>This function is primarily intended for debugging purpose.</p><h3>enif_make_new_binary(ErlNifEnv*
        env, size_t size, ERL_NIF_TERM* termp):unsigned char *</h3><p>Allocate and create a new binary term.</p><p>Allocates a binary of size <strong>size</strong> bytes and creates an owning
term. The binary data is mutable until the calling NIF returns.
This is a quick way to create a new binary without having to use
<a href="#ErlNifBinary">ErlNifBinary</a>.
The drawbacks are that the binary cannot be kept between NIF calls
and it cannot be reallocated.</p><p>Returns a pointer to the raw binary data and sets
<strong>*termp</strong> to the binary term.</p><h3>enif_make_new_map(ErlNifEnv* env):ERL_NIF_TERM</h3><p>Make an empty map term.</p><p>Makes an empty map term.</p><h3>enif_make_pid(ErlNifEnv* env, const ErlNifPid* pid):ERL_NIF_TERM</h3><p>Make a pid term.</p><p>Makes a pid term or the atom <a href="#enif_set_pid_undefined">enif_set_pid_undefined</a> from <strong>*pid</strong>.</p><h3>enif_make_ref(ErlNifEnv* env):ERL_NIF_TERM</h3><p>Create a reference.</p><p>Creates a reference like <a href="./erlang#make_ref-0">erlang#make_ref-0</a>.</p><h3>enif_make_resource(ErlNifEnv* env, void* obj):ERL_NIF_TERM</h3><p>Create an opaque handle to a resource object.</p><p>Creates an opaque handle to a memory-managed resource object
obtained by <a href="#enif_alloc_resource">enif_alloc_resource</a>. No ownership transfer is done,
as the resource object still needs to be released by
<a href="#enif_release_resource">enif_release_resource</a>. However, notice that the call
to <strong>enif_release_resource</strong> can occur immediately after obtaining
the term from <strong>enif_make_resource</strong>, in which case the resource
object is deallocated when the term is garbage collected. For more
details, see the <a href="#enif_resource_example">example of creating and returning a resource object</a> in the User's
Guide.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Since ERTS 9.0 (OTP-20.0), resource terms have a defined behavior
when compared and serialized through <strong>term_to_binary</strong> or passed
between nodes.</p><ul><li> <p>Two resource terms will compare equal if and only if they
would yield the same resource object pointer when passed to
<a href="#enif_get_resource">enif_get_resource</a>.</p> </li><li> <p>A resource term can be serialized with <strong>term_to_binary</strong> and later
be fully recreated if the resource object is still alive when
<strong>binary_to_term</strong> is called. A <em>stale</em> resource term will be
returned from <strong>binary_to_term</strong> if the resource object has
been deallocated. <a href="#enif_get_resource">enif_get_resource</a>
will return false for stale resource terms.</p> <p>The same principles of serialization apply when passing
resource terms in messages to remote nodes and back again. A
resource term will act stale on all nodes except the node where
its resource object is still alive in memory.</p> </li></ul><p>Before ERTS 9.0 (OTP-20.0), all resource terms did
compare equal to each other and to empty binaries (<strong>&lt;&lt;&gt;&gt;</strong>).
If serialized, they would be recreated as plain empty binaries.</p></div><h3>enif_make_resource_binary(ErlNifEnv* env, void* obj, const
        void* data, size_t size):ERL_NIF_TERM</h3><p>Create a custom binary term.</p><p>Creates a binary term that is memory-managed by a resource object
<strong>obj</strong> obtained by <a href="#enif_alloc_resource">enif_alloc_resource</a>. The returned binary term
consists of <strong>size</strong> bytes pointed to by <strong>data</strong>. This raw
binary data must be kept readable and unchanged until the destructor
of the resource is called. The binary data can be stored external to
the resource object, in which case the destructor is responsible
for releasing the data.</p><p>Several binary terms can be managed by the same resource object. The
destructor is not called until the last binary is garbage collected.
This can be useful to return different parts of a larger binary
buffer.</p><p>As with <a href="#enif_make_resource">enif_make_resource</a>, no ownership transfer is done.
The resource still needs to be released with
<a href="#enif_release_resource">enif_release_resource</a>.</p><h3>enif_make_reverse_list(ErlNifEnv* env, ERL_NIF_TERM list_in,
        ERL_NIF_TERM *list_out):int</h3><p>Create the reverse of a list.</p><p>Sets <strong>*list_out</strong> to the reverse list of the list <strong>list_in</strong>
and returns <strong>true</strong>, or returns <strong>false</strong> if <strong>list_in</strong> is
not a list.</p><p>This function is only to be used on short lists, as a copy is
created of the list, which is not released until after the NIF
returns.</p><p>The <strong>list_in</strong> term must belong to environment <strong>env</strong>.</p><h3>enif_make_string(ErlNifEnv* env,
        const char* string, ErlNifCharEncoding encoding):ERL_NIF_TERM</h3><p>Create a string.</p><p>Creates a list containing the characters of the
<strong>NULL</strong>-terminated string <strong>string</strong> with encoding
<a href="#ErlNifCharEncoding">encoding</a>.</p><h3>enif_make_string_len(ErlNifEnv*
        env, const char* string, size_t len, ErlNifCharEncoding
        encoding):ERL_NIF_TERM</h3><p>Create a string.</p><p>Creates a list containing the characters of the string <strong>string</strong>
with length <strong>len</strong> and encoding
<a href="#ErlNifCharEncoding">encoding</a>.
<strong>NULL</strong> characters are treated as any other characters.</p><h3>enif_make_sub_binary(ErlNifEnv*
        env, ERL_NIF_TERM bin_term, size_t pos, size_t size):ERL_NIF_TERM</h3><p>Make a subbinary term.</p><p>Makes a subbinary of binary <strong>bin_term</strong>, starting at
zero-based position <strong>pos</strong> with a length of <strong>size</strong> bytes.
<strong>bin_term</strong> must be a binary or bitstring. <strong>pos+size</strong> must
be less or equal to the number of whole bytes in <strong>bin_term</strong>.</p><h3>enif_make_tuple(ErlNifEnv* env,
        unsigned cnt, ...):ERL_NIF_TERM</h3><p>Creates a tuple term.</p><p>Creates a tuple term of arity <strong>cnt</strong>. Expects <strong>cnt</strong> number
of arguments (after <strong>cnt</strong>) of type <strong>ERL_NIF_TERM</strong> as the
elements of the tuple.</p><h3>enif_make_tuple1(ErlNifEnv* env,
        ERL_NIF_TERM e1):ERL_NIF_TERM</h3><h3>enif_make_tuple2(ErlNifEnv* env,
        ERL_NIF_TERM e1, ERL_NIF_TERM e2):ERL_NIF_TERM</h3><h3>enif_make_tuple3(ErlNifEnv* env,
        ERL_NIF_TERM e1, ERL_NIF_TERM e2, ERL_NIF_TERM e3):ERL_NIF_TERM</h3><h3>enif_make_tuple4(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e4):ERL_NIF_TERM</h3><h3>enif_make_tuple5(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e5):ERL_NIF_TERM</h3><h3>enif_make_tuple6(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e6):ERL_NIF_TERM</h3><h3>enif_make_tuple7(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e7):ERL_NIF_TERM</h3><h3>enif_make_tuple8(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e8):ERL_NIF_TERM</h3><h3>enif_make_tuple9(ErlNifEnv* env,
        ERL_NIF_TERM e1, ..., ERL_NIF_TERM e9):ERL_NIF_TERM</h3><p>Create a tuple term.</p><p>Creates a tuple term with length indicated by the
function name. Prefer these functions (macros) over the variadic
<strong>enif_make_tuple</strong> to get a compile-time error if the number of
arguments does not match.</p><h3>enif_make_tuple_from_array(ErlNifEnv* env, const ERL_NIF_TERM
        arr[], unsigned cnt):ERL_NIF_TERM</h3><p>Create a tuple term from an array.</p><p>Creates a tuple containing the elements of array <strong>arr</strong>
of length <strong>cnt</strong>.</p><h3>enif_make_uint(ErlNifEnv* env, unsigned int i):ERL_NIF_TERM</h3><p>Create an unsigned integer term.</p><p>Creates an integer term from an <strong>unsigned int</strong>.</p><h3>enif_make_uint64(ErlNifEnv* env, ErlNifUInt64 i):ERL_NIF_TERM</h3><p>Create an unsigned integer term.</p><p>Creates an integer term from an unsigned 64-bit integer.</p><h3>enif_make_ulong(ErlNifEnv* env, unsigned long i):ERL_NIF_TERM</h3><p>Create an integer term from an unsigned long int.</p><p>Creates an integer term from an <strong>unsigned long int</strong>.</p><h3>enif_make_unique_integer(ErlNifEnv
        *env, ErlNifUniqueInteger properties):ERL_NIF_TERM</h3><p>Returns a unique integer with the same properties as specified by
<a href="./erlang#unique_integer-1">erlang#unique_integer-1</a>.</p><p><strong>env</strong> is the environment to create the integer in.</p><p><strong>ERL_NIF_UNIQUE_POSITIVE</strong> and <strong>ERL_NIF_UNIQUE_MONOTONIC</strong>
can be passed as the second argument to change the properties of the
integer returned. They can be combined by OR:ing the two values
together.</p><p>See also <a href="#ErlNifUniqueInteger">ErlNifUniqueInteger</a>.</p><h3>enif_map_iterator_create(ErlNifEnv *env,
        ERL_NIF_TERM map, ErlNifMapIterator *iter, ErlNifMapIteratorEntry
        entry):int</h3><p>Create a map iterator.</p><p>Creates an iterator for the map <strong>map</strong> by initializing the
structure pointed to by <strong>iter</strong>. Argument <strong>entry</strong> determines
the start position of the iterator: <strong>ERL_NIF_MAP_ITERATOR_FIRST</strong>
or <strong>ERL_NIF_MAP_ITERATOR_LAST</strong>.</p><p>Returns <strong>true</strong> on success, or false if <strong>map</strong> is not a
map.</p><p>A map iterator is only useful during the lifetime of environment
<strong>env</strong> that the <strong>map</strong> belongs to. The iterator must be
destroyed by calling <a href="#enif_map_iterator_destroy">enif_map_iterator_destroy</a>:</p><pre><code class="">
ERL_NIF_TERM key, value;
ErlNifMapIterator iter;
enif_map_iterator_create(env, my_map, &amp;iter, ERL_NIF_MAP_ITERATOR_FIRST);

while (enif_map_iterator_get_pair(env, &amp;iter, &amp;key, &amp;value)) {
    do_something(key,value);
    enif_map_iterator_next(env, &amp;iter);
}
enif_map_iterator_destroy(env, &amp;iter);</code></pre><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The key-value pairs of a map have no defined iteration order.
The only guarantee is that the iteration order of a single map
instance is preserved during the lifetime of the environment that
the map belongs to.</p></div><h3>enif_map_iterator_destroy(ErlNifEnv *env,
        ErlNifMapIterator *iter):void</h3><p>Destroy a map iterator.</p><p>Destroys a map iterator created by
<a href="#enif_map_iterator_create">enif_map_iterator_create</a>.</p><h3>enif_map_iterator_get_pair(ErlNifEnv *env,
        ErlNifMapIterator *iter, ERL_NIF_TERM *key, ERL_NIF_TERM
        *value):int</h3><p>Get key and value at current map iterator position.</p><p>Gets key and value terms at the current map iterator position.</p><p>On success, sets <strong>*key</strong> and <strong>*value</strong> and returns
<strong>true</strong>. Returns <strong>false</strong> if the iterator is positioned at
head (before first entry) or tail (beyond last entry).</p><h3>enif_map_iterator_is_head(ErlNifEnv *env,
        ErlNifMapIterator *iter):int</h3><p>Check if map iterator is positioned before first.</p><p>Returns <strong>true</strong> if map iterator <strong>iter</strong> is positioned
before the first entry.</p><h3>enif_map_iterator_is_tail(ErlNifEnv *env,
        ErlNifMapIterator *iter):int</h3><p>Check if map iterator is positioned after last.</p><p>Returns <strong>true</strong> if map iterator <strong>iter</strong> is positioned
after the last entry.</p><h3>enif_map_iterator_next(ErlNifEnv *env,
        ErlNifMapIterator *iter):int</h3><p>Increment map iterator to point to next entry.</p><p>Increments map iterator to point to the next key-value entry.</p><p>Returns <strong>true</strong> if the iterator is now positioned at a valid
key-value entry, or <strong>false</strong> if the iterator is positioned at
the tail (beyond the last entry).</p><h3>enif_map_iterator_prev(ErlNifEnv *env,
        ErlNifMapIterator *iter):int</h3><p>Decrement map iterator to point to previous entry.</p><p>Decrements map iterator to point to the previous key-value entry.</p><p>Returns <strong>true</strong> if the iterator is now positioned at a valid
key-value entry, or <strong>false</strong> if the iterator is positioned at
the head (before the first entry).</p><h3>enif_monitor_process(ErlNifEnv* caller_env,
      void* obj, const ErlNifPid* target_pid, ErlNifMonitor* mon):int</h3><p>Monitor a process from a resource.</p><a name="enif_monitor_process"></a><p>Starts monitoring a process from a resource. When a process is
monitored, a process exit results in a call to the provided
<a href="#ErlNifResourceDown">ErlNifResourceDown</a> callback associated with the resource type.</p><p>Argument <strong>obj</strong> is pointer to the resource to hold the monitor and
<strong>*target_pid</strong> identifies the local process to be monitored.</p><p>If <strong>mon</strong> is not <strong>NULL</strong>, a successful call stores the
identity of the monitor	in the
<a href="#ErlNifMonitor">ErlNifMonitor</a>
struct pointed to by <strong>mon</strong>. This identifier is used to refer to the
monitor for later removal with
<a href="#enif_demonitor_process">enif_demonitor_process</a>
or compare with
<a href="#enif_compare_monitors">enif_compare_monitors</a>.
A monitor is automatically removed when it triggers or when
the resource is deallocated.</p><p>Argument <strong>caller_env</strong> is the environment of the calling process
or callback. Must only be NULL if calling from a custom thread.</p><p>Returns <strong>0</strong> on success, &lt; 0 if no <strong>down</strong> callback is
provided, and &gt; 0 if the process is no longer alive or if
<strong>target_pid</strong> is <a href="#enif_set_pid_undefined"> undefined</a>.</p><p>This function is only thread-safe when the emulator with SMP support
is used. It can only be used in a non-SMP emulator from a NIF-calling
thread.</p><h3>enif_monotonic_time(ErlNifTimeUnit time_unit):ErlNifTime</h3><p>Get Erlang monotonic time.</p><a name="enif_monotonic_time"></a><p>Returns the current
<a href="./time_correction#Erlang_Monotonic_Time"> Erlang monotonic time</a>. Notice that it is not uncommon with
negative values.</p><p><strong>time_unit</strong> is the time unit of the returned value.</p><p>Returns <strong>ERL_NIF_TIME_ERROR</strong> if called with an invalid time
unit argument, or if called from a thread that is not a scheduler
thread.</p><p>See also <a href="#ErlNifTime">ErlNifTime</a>
and <a href="#ErlNifTimeUnit">ErlNifTimeUnit</a>.
</p><h3>enif_mutex_create(char *name):ErlNifMutex *</h3><p>Same as <a href="./erl_driver#erl_drv_mutex_create">erl_driver#erl_drv_mutex_create</a>.</p><h3>enif_mutex_destroy(ErlNifMutex *mtx):void</h3><p>Same as <a href="./erl_driver#erl_drv_mutex_destroy">erl_driver#erl_drv_mutex_destroy</a>.</p><h3>enif_mutex_lock(ErlNifMutex *mtx):void</h3><p>Same as <a href="./erl_driver#erl_drv_mutex_lock">erl_driver#erl_drv_mutex_lock</a>.</p><h3>enif_mutex_name(ErlNifMutex* mtx):char*</h3><p>Same as <a href="./erl_driver#erl_drv_mutex_name">erl_driver#erl_drv_mutex_name</a>.</p><h3>enif_mutex_trylock(ErlNifMutex *mtx):int</h3><p>Same as <a href="./erl_driver#erl_drv_mutex_trylock">erl_driver#erl_drv_mutex_trylock</a>.</p><h3>enif_mutex_unlock(ErlNifMutex *mtx):void</h3><p>Same as <a href="./erl_driver#erl_drv_mutex_unlock">erl_driver#erl_drv_mutex_unlock</a>.</p><h3>enif_now_time(ErlNifEnv *env):ERL_NIF_TERM</h3><p>Returns an <a href="./erlang#now-0">erlang#now-0</a> time stamp.</p><p><em>This function is deprecated.</em></p><h3>enif_open_resource_type(ErlNifEnv* env, const char*
        module_str, const char* name, ErlNifResourceDtor* dtor,
        ErlNifResourceFlags flags, ErlNifResourceFlags* tried):ErlNifResourceType *</h3><p>Create or takeover a resource type.</p><p>Creates or takes over a resource type identified by the string
<strong>name</strong> and gives it the destructor function pointed to by
<a href="#ErlNifResourceDtor">ErlNifResourceDtor</a>.
Argument <strong>flags</strong> can have the following values:</p><dl><dt><strong>ERL_NIF_RT_CREATE</strong></dt><dd>Creates a new resource type that does not already exist.</dd><dt><strong>ERL_NIF_RT_TAKEOVER</strong></dt><dd>Opens an existing resource type and takes over ownership of all its instances. The supplied destructor <strong>dtor</strong> is called both for existing instances and new instances not yet created by the calling NIF library.</dd></dl><p>The two flag values can be combined with bitwise OR. The resource
type name is local to the calling module. Argument <strong>module_str</strong>
is not (yet) used and must be <strong>NULL</strong>. <strong>dtor</strong> can be
<strong>NULL</strong> if no destructor is needed.</p><p>On success, the function returns a pointer to the resource type and
<strong>*tried</strong> is set to either <strong>ERL_NIF_RT_CREATE</strong> or
<strong>ERL_NIF_RT_TAKEOVER</strong> to indicate what was done. On failure,
returns <strong>NULL</strong> and sets <strong>*tried</strong> to <strong>flags</strong>.
It is allowed to set <strong>tried</strong> to <strong>NULL</strong>.</p><p>Notice that <strong>enif_open_resource_type</strong> is only allowed to be
called in the two callbacks
<a href="#load">load</a> and
<a href="#upgrade">upgrade</a>.</p><p>See also <a href="#enif_open_resource_type_x">enif_open_resource_type_x</a>.</p><h3>enif_open_resource_type_x(ErlNifEnv* env, const char* name,
	const ErlNifResourceTypeInit* init,
        ErlNifResourceFlags flags, ErlNifResourceFlags* tried):ErlNifResourceType *</h3><p>Create or takeover a resource type.</p><p>Same as <a href="#enif_open_resource_type">enif_open_resource_type</a>
except it accepts additional callback functions for resource types that are
used together with <a href="#enif_select">enif_select</a>
and <a href="#enif_monitor_process">enif_monitor_process</a>.</p><p>Argument <strong>init</strong> is a pointer to an
<a href="#ErlNifResourceTypeInit">ErlNifResourceTypeInit</a>
structure that contains the function pointers for destructor, down and stop callbacks
for the resource type.</p><h3>enif_port_command(ErlNifEnv* env, const
       ErlNifPort* to_port, ErlNifEnv *msg_env, ERL_NIF_TERM msg):int</h3><p>Send a port_command to to_port.</p><p>Works as <a href="./erlang#port_command-2">erlang#port_command-2</a>,
except that it is always completely asynchronous.</p><dl><dt><strong>env</strong></dt><dd>The environment of the calling process. Must not be <strong>NULL</strong>.</dd><dt><strong>*to_port</strong></dt><dd>The port ID of the receiving port. The port ID is to refer to a port on the local node.</dd><dt><strong>msg_env</strong></dt><dd>The environment of the message term. Can be a process independent environment allocated with <a href="#enif_alloc_env">enif_alloc_env</a> or <strong>NULL</strong>.</dd><dt><strong>msg</strong></dt><dd>The message term to send. The same limitations apply as on the payload to <a href="./erlang#port_command-2">erlang#port_command-2</a>.</dd></dl><p>Using a <strong>msg_env</strong> of <strong>NULL</strong> is an optimization, which
groups together calls to <strong>enif_alloc_env</strong>, <strong>enif_make_copy</strong>,
<strong>enif_port_command</strong>, and <strong>enif_free_env</strong> into one call.
This optimization is only useful when a majority of the terms are to
be copied from <strong>env</strong> to <strong>msg_env</strong>.</p><p>Returns <strong>true</strong> if the command is successfully sent. Returns
<strong>false</strong> if the command fails, for example:</p><ul><li><strong>*to_port</strong> does not refer to a local port.</li><li>The currently executing process (that is, the sender) is not alive.</li><li><strong>msg</strong> is invalid.</li></ul><p>See also <a href="#enif_get_local_port">enif_get_local_port</a>.</p><h3>enif_priv_data(ErlNifEnv* env):void *</h3><p>Get the private data of a NIF library.</p><p>Returns the pointer to the private data that was set by
<a href="#load">load</a> or
<a href="#upgrade">upgrade</a>.</p><h3>enif_raise_exception(ErlNifEnv*
        env, ERL_NIF_TERM reason):ERL_NIF_TERM</h3><p>Raise a NIF error exception.</p><p>Creates an error exception with the term <strong>reason</strong> to be
returned from a NIF, and associates it with environment <strong>env</strong>.
Once a NIF or any function it calls invokes
<strong>enif_raise_exception</strong>, the runtime ensures that the exception
it creates is raised when the NIF returns, even if the NIF attempts
to return a non-exception term instead.</p><p>The return value from <strong>enif_raise_exception</strong> can only be used
as the return value from the NIF that invoked it (directly or
indirectly) or be passed to <a href="#enif_is_exception">enif_is_exception</a>, but not to any other NIF API
function.</p><p>See also <a href="#enif_has_pending_exception">enif_has_pending_exception</a> and
<a href="#enif_make_badarg">enif_make_badarg</a>.</p><h3>enif_realloc(void* ptr, size_t size):void *</h3><p>Reallocate dynamic memory.</p><p>Reallocates memory allocated by
<a href="#enif_alloc">enif_alloc</a> to
<strong>size</strong> bytes.</p><p>Returns <strong>NULL</strong> if the reallocation fails.</p><p>The returned pointer is suitably aligned for any built-in type that
fit in the allocated memory.</p><h3>enif_realloc_binary(ErlNifBinary* bin, size_t size):int</h3><p>Change the size of a binary.</p><p>Changes the size of a binary <strong>bin</strong>. The source binary
can be read-only, in which case it is left untouched and
a mutable copy is allocated and assigned to <strong>*bin</strong>.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if memory allocation
failed.</p><h3>enif_release_binary(ErlNifBinary* bin):void</h3><p>Release a binary.</p><p>Releases a binary obtained from
<a href="#enif_alloc_binary">enif_alloc_binary</a>.</p><h3>enif_release_resource(void* obj):void</h3><p>Release a resource object.</p><p>Removes a reference to resource object <strong>obj</strong> obtained from
<a href="#enif_alloc_resource">enif_alloc_resource</a>.
The resource object is destructed when the last reference is removed.
Each call to <strong>enif_release_resource</strong> must correspond to a
previous call to <strong>enif_alloc_resource</strong> or
<a href="#enif_keep_resource">enif_keep_resource</a>.
References made by <a href="#enif_make_resource">enif_make_resource</a>
can only be removed by the garbage collector.</p><h3>enif_rwlock_create(char *name):ErlNifRWLock *</h3><p>Same as <a href="./erl_driver#erl_drv_rwlock_create">erl_driver#erl_drv_rwlock_create</a>.</p><h3>enif_rwlock_destroy(ErlNifRWLock *rwlck):void</h3><p>Same as <a href="./erl_driver#erl_drv_rwlock_destroy">erl_driver#erl_drv_rwlock_destroy</a>.</p><h3>enif_rwlock_name(ErlNifRWLock* rwlck):char*</h3><p>Same as <a href="./erl_driver#erl_drv_rwlock_name">erl_driver#erl_drv_rwlock_name</a>.</p><h3>enif_rwlock_rlock(ErlNifRWLock *rwlck):void</h3><p>Same as <a href="./erl_driver#erl_drv_rwlock_rlock">erl_driver#erl_drv_rwlock_rlock</a>.</p><h3>enif_rwlock_runlock(ErlNifRWLock *rwlck):void</h3><p>Same as <a href="./erl_driver#erl_drv_rwlock_runlock">erl_driver#erl_drv_rwlock_runlock</a>.</p><h3>enif_rwlock_rwlock(ErlNifRWLock *rwlck):void</h3><p>Same as <a href="./erl_driver#erl_drv_rwlock_rwlock">erl_driver#erl_drv_rwlock_rwlock</a>.</p><h3>enif_rwlock_rwunlock(ErlNifRWLock *rwlck):void</h3><p>Same as <a href="./erl_driver#erl_drv_rwlock_rwunlock">erl_driver#erl_drv_rwlock_rwunlock</a>.</p><h3>enif_rwlock_tryrlock(ErlNifRWLock *rwlck):int</h3><p>Same as <a href="./erl_driver#erl_drv_rwlock_tryrlock">erl_driver#erl_drv_rwlock_tryrlock</a>.</p><h3>enif_rwlock_tryrwlock(ErlNifRWLock *rwlck):int</h3><p>Same as <a href="./erl_driver#erl_drv_rwlock_tryrwlock">erl_driver#erl_drv_rwlock_tryrwlock</a>.</p><h3>enif_schedule_nif(ErlNifEnv* env,
        const char* fun_name, int flags, ERL_NIF_TERM (*fp)(ErlNifEnv* env, int
        argc, const ERL_NIF_TERM argv[]), int argc, const ERL_NIF_TERM
        argv[]):ERL_NIF_TERM</h3><p>Schedule a NIF for execution.</p><p>Schedules NIF <strong>fp</strong> to execute. This function allows an
application to break up long-running work into multiple regular NIF
calls or to schedule a <a href="#dirty_nifs"> dirty NIF</a> to execute on a dirty scheduler thread.</p><dl><dt><strong>fun_name</strong></dt><dd> <p>Provides a name for the NIF that is scheduled for execution.
If it cannot be converted to an atom, <strong>enif_schedule_nif</strong>
returns a <strong>badarg</strong> exception.</p> </dd><dt><strong>flags</strong></dt><dd> <p>Must be set to <strong>0</strong> for a regular NIF. If the emulator was
built with dirty scheduler support enabled,
<strong>flags</strong> can be set to either
<strong>ERL_NIF_DIRTY_JOB_CPU_BOUND</strong> if the job is expected to be
CPU-bound, or <strong>ERL_NIF_DIRTY_JOB_IO_BOUND</strong> for
jobs that will be I/O-bound. If dirty scheduler threads are not
available in the emulator, an attempt to schedule such a job
results in a <strong>notsup</strong> exception.</p> </dd><dt><strong>argc</strong> and <strong>argv</strong></dt><dd> <p>Can either be the originals passed into the calling NIF,
or can be values created by the calling NIF.</p> </dd></dl><p>The calling NIF must use the return value of
<strong>enif_schedule_nif</strong> as its own return value.</p><p>Be aware that <strong>enif_schedule_nif</strong>, as its name implies, only
schedules the NIF for future execution. The calling NIF does not
block waiting for the scheduled NIF to execute and return. This means
that the calling NIF cannot expect to receive the scheduled NIF
return value and use it for further operations.</p><h3>enif_select(ErlNifEnv* env, ErlNifEvent event, enum ErlNifSelectFlags mode,
	void* obj, const ErlNifPid* pid, ERL_NIF_TERM ref):int</h3><p>Manage subscription on IO event.</p><p>This function can be used to receive asynchronous notifications
when OS-specific event objects become ready for either read or write operations.</p><p>Argument <strong>event</strong> identifies the event object. On Unix
systems, the functions <strong>select</strong>/<strong>poll</strong> are used. The event
object must be a socket, pipe or other file descriptor object that
<strong>select</strong>/<strong>poll</strong> can use.</p><p>Argument <strong>mode</strong> describes the type of events to wait for. It can be
<strong>ERL_NIF_SELECT_READ</strong>, <strong>ERL_NIF_SELECT_WRITE</strong> or a bitwise
OR combination to wait for both. It can also be <strong>ERL_NIF_SELECT_STOP</strong>
or <strong>ERL_NIF_SELECT_CANCEL</strong> which are described further
below. When a read or write event is triggered,
a notification message like this is sent to the process identified by
<strong>pid</strong>:</p><pre><code class="">{select, Obj, Ref, ready_input | ready_output}</code></pre><p><strong>ready_input</strong> or <strong>ready_output</strong> indicates if the event object
is ready for reading or writing.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>For complete control over the message format use the newer functions
<a href="#enif_select_read">enif_select_read</a> or
<a href="#enif_select_write">enif_select_write</a>
introduced in erts-11.0 (OTP-22.0).</p></div><p>Argument <strong>pid</strong> may be <strong>NULL</strong> to indicate the calling
process. It must not be set as <a href="#enif_set_pid_undefined"> undefined</a>.</p><p>Argument <strong>obj</strong> is a resource object obtained from
<a href="#enif_alloc_resource">enif_alloc_resource</a>.
The purpose of the resource objects is as a container of the event object
to manage its state and lifetime. A handle to the resource is received
in the notification message as <strong>Obj</strong>.</p><p>Argument <strong>ref</strong> must be either a reference obtained from
<a href="./erlang#make_ref-0">erlang#make_ref-0</a>
or the atom <strong>undefined</strong>. It will be passed as <strong>Ref</strong> in the notifications.
If a selective <strong>receive</strong> statement is used to wait for the notification
then a reference created just before the <strong>receive</strong> will exploit a runtime
optimization that bypasses all earlier received messages in the
queue.</p><p>The notifications are one-shot only. To receive further notifications of the same
type (read or write), repeated calls to <strong>enif_select</strong> must be made
after receiving each notification.</p><p><strong>ERL_NIF_SELECT_CANCEL</strong> can be used to cancel previously
selected events. It must be used in a bitwise OR combination with
<strong>ERL_NIF_SELECT_READ</strong> and/or <strong>ERL_NIF_SELECT_WRITE</strong> to
indicate which type of event to cancel. Arguments <strong>pid</strong> and
<strong>ref</strong> are ignored when <strong>ERL_NIF_SELECT_CANCEL</strong> is specified.
The return value will tell if the event was actualy cancelled or if a
notification may already have been sent.</p><p>Use <strong>ERL_NIF_SELECT_STOP</strong> as <strong>mode</strong> in order to safely
close an event object that has been passed to <strong>enif_select</strong>. The
<a href="#ErlNifResourceStop">ErlNifResourceStop</a> callback
of the resource <strong>obj</strong> will be called when it is safe to close
the event object. This safe way of closing event objects must be used
even if all notifications have been received (or cancelled) and no
further calls to <strong>enif_select</strong> have been made.
<strong>ERL_NIF_SELECT_STOP</strong> will first cancel any selected events
before it calls or schedules the <strong>stop</strong> callback. Arguments
<strong>pid</strong> and <strong>ref</strong> are ignored when <strong>ERL_NIF_SELECT_STOP</strong>
is specified.</p><p>The first call to <strong>enif_select</strong> for a specific OS <strong>event</strong> will establish
a relation between the event object and the containing resource. All subsequent calls
for an <strong>event</strong> must pass its containing resource as argument
<strong>obj</strong>. The relation is dissolved when <strong>enif_select</strong> has
been called with <strong>mode</strong> as <strong>ERL_NIF_SELECT_STOP</strong> and the
corresponding <strong>stop</strong> callback has returned. A resource can contain
several event objects but one event object can only be contained within
one resource. A resource will not be destructed until all its contained relations
have been dissolved.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Use <a href="#enif_monitor_process">enif_monitor_process</a>
together with <strong>enif_select</strong> to detect failing Erlang
processes and prevent them from causing permanent leakage of resources
and their contained OS event objects.</p></div><p>Returns a non-negative value on success where the following bits can be set:</p><dl><dt><strong>ERL_NIF_SELECT_STOP_CALLED</strong></dt><dd>The stop callback was called directly by <strong>enif_select</strong>.</dd><dt><strong>ERL_NIF_SELECT_STOP_SCHEDULED</strong></dt><dd>The stop callback was scheduled to run on some other thread or later by this thread.</dd><dt><strong>ERL_NIF_SELECT_READ_CANCELLED</strong></dt><dd>A read event was cancelled by <strong>ERL_NIF_SELECT_CANCEL</strong> or <strong>ERL_NIF_SELECT_STOP</strong> and is guaranteed not to generate a <strong>ready_input</strong> notification message.</dd><dt><strong>ERL_NIF_SELECT_WRITE_CANCELLED</strong></dt><dd>A write event was cancelled by <strong>ERL_NIF_SELECT_CANCEL</strong> or <strong>ERL_NIF_SELECT_STOP</strong> and is guaranteed not to generate a <strong>ready_output</strong> notification message.</dd></dl><p>Returns a negative value if the call failed where the following bits can be set:</p><dl><dt><strong>ERL_NIF_SELECT_INVALID_EVENT</strong></dt><dd>Argument <strong>event</strong> is not a valid OS event object.</dd><dt><strong>ERL_NIF_SELECT_FAILED</strong></dt><dd>The system call failed to add the event object to the poll set.</dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Use bitwise AND to test for specific bits in the return value.
New significant bits may be added in future releases to give more detailed
information for both failed and successful calls. Do NOT use equality tests
like <strong>==</strong>, as that may cause your application to stop working.</p><p>Example:</p><pre><code class="">
retval = enif_select(env, fd, ERL_NIF_SELECT_STOP, resource, ref);
if (retval &lt; 0) {
    /* handle error */
}
/* Success! */
if (retval &amp; ERL_NIF_SELECT_STOP_CALLED) {
    /* ... */
}
</code></pre></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The mode flag <strong>ERL_NIF_SELECT_CANCEL</strong> and the return flags
<strong>ERL_NIF_SELECT_READ_CANCELLED</strong> and
<strong>ERL_NIF_SELECT_WRITE_CANCELLED</strong> were introduced in erts-11.0
(OTP-22.0).</p></div><h3>enif_select_read(ErlNifEnv* env, ErlNifEvent event, void* obj,
      const ErlNifPid* pid, ERL_NIF_TERM msg, ErlNifEnv* msg_env):int</h3><h3>enif_select_write(ErlNifEnv* env, ErlNifEvent event, void* obj,
      const ErlNifPid* pid, ERL_NIF_TERM msg, ErlNifEnv* msg_env):int</h3><p>Manage subscription on IO event.</p><p>These are variants of <a href="#enif_select">enif_select</a>
where you can supply your own message term <strong>msg</strong> that will be sent to
the process instead of the predefined tuple <strong>{select,_,_,_}.</strong></p><p>Argument <strong>msg_env</strong> must either be <strong>NULL</strong> or the environment of
<strong>msg</strong> allocated with <a href="#enif_alloc_env">enif_alloc_env</a>. If argument <strong>msg_env</strong> is
<strong>NULL</strong> the term <strong>msg</strong> will be copied, otherwise both
<strong>msg</strong> and <strong>msg_env</strong> will be invalidated by a successful call
to <strong>enif_select_read</strong> or <strong>enif_select_write</strong>. The environment
is then to either be freed with <a href="#enif_free_env">enif_free_env</a> or cleared for reuse with
<a href="#enif_clear_env">enif_clear_env</a>. An
unsuccessful call will leave <strong>msg</strong> and <strong>msg_env</strong> still valid.</p><p>Apart from the message format <strong>enif_select_read</strong> and
<strong>enif_select_write</strong> behaves exactly the same as <a href="#enif_select">enif_select</a> with argument <strong>mode</strong> as
either <strong>ERL_NIF_SELECT_READ</strong> or <strong>ERL_NIF_SELECT_WRITE</strong>. To
cancel or close events use <a href="#enif_select">enif_select</a>.</p><h3>enif_self(ErlNifEnv* caller_env, ErlNifPid* pid):ErlNifPid *</h3><p>Get the pid of the calling process.</p><p>Initializes the <a href="#ErlNifPid">ErlNifPid</a>
variable at <strong>*pid</strong> to represent the calling process.</p><p>Returns <strong>pid</strong> if successful, or NULL if <strong>caller_env</strong> is not
a <a href="#ErlNifEnv">process bound environment</a>.</p><h3>enif_send(ErlNifEnv* caller_env,
      ErlNifPid* to_pid, ErlNifEnv* msg_env, ERL_NIF_TERM msg):int</h3><p>Send a message to a process.</p><p>Sends a message to a process.</p><dl><dt><strong>caller_env</strong></dt><dd>The environment of the calling process or callback. Must be <strong>NULL</strong> only if calling from a custom thread not spawned by ERTS.</dd><dt><strong>*to_pid</strong></dt><dd>The pid of the receiving process. The pid is to refer to a process on the local node.</dd><dt><strong>msg_env</strong></dt><dd>The environment of the message term. Must be a process independent environment allocated with <a href="#enif_alloc_env">enif_alloc_env</a> or NULL.</dd><dt><strong>msg</strong></dt><dd>The message term to send.</dd></dl><p>Returns <strong>true</strong> if the message is successfully sent. Returns
<strong>false</strong> if the send operation fails, that is:</p><ul><li><strong>*to_pid</strong> does not refer to an alive local process.</li><li>The currently executing process (that is, the sender) is not alive.</li></ul><p>The message environment <strong>msg_env</strong> with all its terms (including
<strong>msg</strong>) is invalidated by a successful call to <strong>enif_send</strong>.
The environment is to either be freed with
<a href="#enif_free_env">enif_free_env</a> or cleared for reuse with
<a href="#enif_clear_env">enif_clear_env</a>. An
unsuccessful call will leave <strong>msg</strong> and <strong>msg_env</strong> still valid.</p><p>If <strong>msg_env</strong> is set to <strong>NULL</strong>, the <strong>msg</strong> term is
copied and the original term and its environment is still valid after
the call.</p><p>This function is only thread-safe when the emulator with SMP support
is used. It can only be used in a non-SMP emulator from a NIF-calling
thread.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Passing <strong>msg_env</strong> as <strong>NULL</strong> is only supported as from
ERTS 8.0 (Erlang/OTP 19).</p></div><h3>enif_set_pid_undefined(ErlNifPid* pid):void</h3><p>Set pid as undefined.</p><p>Sets an <a href="#ErlNifPid">ErlNifPid</a>
variable as undefined. See <a href="#enif_is_pid_undefined">enif_is_pid_undefined</a>.</p><h3>enif_sizeof_resource(void* obj):unsigned</h3><p>Get the byte size of a resource object.</p><p>Gets the byte size of resource object <strong>obj</strong> obtained by
<a href="#enif_alloc_resource">enif_alloc_resource</a>.</p><h3>enif_snprintf(char *str, size_t size, const
        char *format, ...):int</h3><p>Format strings and Erlang terms.</p><p>Similar to <strong>snprintf</strong> but this format string also accepts
<strong>"%T"</strong>, which formats Erlang terms of type
<a href="#ERL_NIF_TERM">ERL_NIF_TERM</a>.</p><p>This function is primarily intended for debugging purpose. It is not
recommended to print very large terms with <strong>%T</strong>. The function may
change <strong>errno</strong>, even if successful.</p><h3>enif_system_info(ErlNifSysInfo
        *sys_info_ptr, size_t size):void</h3><p>Get information about the Erlang runtime system.</p><p>Same as <a href="./erl_driver#driver_system_info">erl_driver#driver_system_info</a>.</p><h3>enif_term_to_binary(ErlNifEnv *env,
        ERL_NIF_TERM term, ErlNifBinary *bin):int</h3><p>Convert a term to the external format.</p><p>Allocates a new binary with <a href="#enif_alloc_binary">enif_alloc_binary</a> and stores the result of encoding
<strong>term</strong> according to the Erlang external term format.</p><p>Returns <strong>true</strong> on success, or <strong>false</strong> if the allocation
fails.</p><p>See also <a href="./erlang#term_to_binary-1">erlang#term_to_binary-1</a> and
<a href="#enif_binary_to_term">enif_binary_to_term</a>.</p><h3>enif_term_type(ErlNifEnv *env, ERL_NIF_TERM term):ErlNifTermType</h3><p>Determine the type of a term.</p><p>Determines the type of the given term. The term must be an ordinary
Erlang term and not one of the special terms returned by
<a href="#enif_raise_exception">enif_raise_exception</a>,
<a href="#enif_schedule_nif">enif_schedule_nif</a>, or similar.</p><p>The following types are defined at the moment:</p><dl><dt><strong>ERL_NIF_TERM_TYPE_ATOM</strong></dt><dd></dd><dt><strong>ERL_NIF_TERM_TYPE_BITSTRING</strong></dt><dd><p>A bitstring or binary</p></dd><dt><strong>ERL_NIF_TERM_TYPE_FLOAT</strong></dt><dd></dd><dt><strong>ERL_NIF_TERM_TYPE_FUN</strong></dt><dd></dd><dt><strong>ERL_NIF_TERM_TYPE_INTEGER</strong></dt><dd></dd><dt><strong>ERL_NIF_TERM_TYPE_LIST</strong></dt><dd><p>A list, empty or not</p></dd><dt><strong>ERL_NIF_TERM_TYPE_MAP</strong></dt><dd></dd><dt><strong>ERL_NIF_TERM_TYPE_PID</strong></dt><dd></dd><dt><strong>ERL_NIF_TERM_TYPE_PORT</strong></dt><dd></dd><dt><strong>ERL_NIF_TERM_TYPE_REFERENCE</strong></dt><dd></dd><dt><strong>ERL_NIF_TERM_TYPE_TUPLE</strong></dt><dd></dd></dl><p>Note that new types may be added in the future, so the caller must
be prepared to handle unknown types.</p><h3>enif_thread_create(char *name,ErlNifTid
        *tid,void * (*func)(void *),void *args,ErlNifThreadOpts
        *opts):int</h3><p>Same as <a href="./erl_driver#erl_drv_thread_create">erl_driver#erl_drv_thread_create</a>.</p><h3>enif_thread_exit(void *resp):void</h3><p>Same as <a href="./erl_driver#erl_drv_thread_exit">erl_driver#erl_drv_thread_exit</a>.</p><h3>enif_thread_join(ErlNifTid, void **respp):int</h3><p>Same as <a href="./erl_driver#erl_drv_thread_join">erl_driver#erl_drv_thread_join</a>.</p><h3>enif_thread_name(ErlNifTid tid):char*</h3><p>Thread name</p><p>Same as <a href="./erl_driver#erl_drv_thread_name">erl_driver#erl_drv_thread_name</a>.</p><h3>enif_thread_opts_create(char *name):ErlNifThreadOpts *</h3><p>Same as <a href="./erl_driver#erl_drv_thread_opts_create">erl_driver#erl_drv_thread_opts_create</a>.</p><h3>enif_thread_opts_destroy(ErlNifThreadOpts *opts):void</h3><p>Same as <a href="./erl_driver#erl_drv_thread_opts_destroy">erl_driver#erl_drv_thread_opts_destroy</a>.</p><h3>enif_thread_self(void):ErlNifTid</h3><p>Same as <a href="./erl_driver#erl_drv_thread_self">erl_driver#erl_drv_thread_self</a>.</p><h3>enif_thread_type(void):int</h3><p>Determine type of current thread</p><p>Determine the type of currently executing thread. A positive value
indicates a scheduler thread while a negative value or zero indicates
another type of thread. Currently the following specific types exist
(which may be extended in the future):</p><dl><dt><strong>ERL_NIF_THR_UNDEFINED</strong></dt><dd><p>Undefined thread that is not a scheduler thread.</p></dd><dt><strong>ERL_NIF_THR_NORMAL_SCHEDULER</strong></dt><dd><p>A normal scheduler thread.</p></dd><dt><strong>ERL_NIF_THR_DIRTY_CPU_SCHEDULER</strong></dt><dd><p>A dirty CPU scheduler thread.</p></dd><dt><strong>ERL_NIF_THR_DIRTY_IO_SCHEDULER</strong></dt><dd><p>A dirty I/O scheduler thread.</p></dd></dl><h3>enif_time_offset(ErlNifTimeUnit time_unit):ErlNifTime</h3><p>Get current time offset.</p><a name="enif_time_offset"></a><p>Returns the current time offset between
<a href="./time_correction#Erlang_Monotonic_Time"> Erlang monotonic time</a> and
<a href="./time_correction#Erlang_System_Time"> Erlang system time</a>
converted into the <strong>time_unit</strong> passed as argument.</p><p><strong>time_unit</strong> is the time unit of the returned value.</p><p>Returns <strong>ERL_NIF_TIME_ERROR</strong> if called with an invalid
time unit argument or if called from a thread that is not a
scheduler thread.</p><p>See also <a href="#ErlNifTime">ErlNifTime</a>
and
<a href="#ErlNifTimeUnit">ErlNifTimeUnit</a>.</p><h3>enif_tsd_get(ErlNifTSDKey key):void *</h3><p>Same as <a href="./erl_driver#erl_drv_tsd_get">erl_driver#erl_drv_tsd_get</a>.</p><h3>enif_tsd_key_create(char *name, ErlNifTSDKey *key):int</h3><p>Same as <a href="./erl_driver#erl_drv_tsd_key_create">erl_driver#erl_drv_tsd_key_create</a>.</p><h3>enif_tsd_key_destroy(ErlNifTSDKey key):void</h3><p>Same as <a href="./erl_driver#erl_drv_tsd_key_destroy">erl_driver#erl_drv_tsd_key_destroy</a>.</p><h3>enif_tsd_set(ErlNifTSDKey key, void *data):void</h3><p>Same as <a href="./erl_driver#erl_drv_tsd_set">erl_driver#erl_drv_tsd_set</a>.</p><h3>enif_vfprintf(FILE *stream, const char *format, va_list ap)
:int</h3><p>Format strings and Erlang terms.</p><p>Equivalent to <a href="#enif_fprintf">enif_fprintf</a>
except that its called with a <strong>va_list</strong> instead of a variable number of
arguments.</p><h3>enif_vsnprintf(char *str, size_t size, const char *format, va_list ap)
:int</h3><p>Format strings and Erlang terms.</p><p>Equivalent to <a href="#enif_snprintf">enif_snprintf</a>
except that its called with a <strong>va_list</strong> instead of a variable number of
arguments.</p><h3>enif_whereis_pid(ErlNifEnv *env,
          ERL_NIF_TERM name, ErlNifPid *pid):int</h3><p>Looks up a process by its registered name.</p><p>Looks up a process by its registered name.</p><dl><dt><strong>env</strong></dt><dd>The environment of the calling process. Must be <strong>NULL</strong> only if calling from a created thread.</dd><dt><strong>name</strong></dt><dd>The name of a registered process, as an atom.</dd><dt><strong>*pid</strong></dt><dd>The <a href="#ErlNifPid">ErlNifPid</a> in which the resolved process id is stored.</dd></dl><p>On success, sets <strong>*pid</strong> to the local process registered with
<strong>name</strong> and returns <strong>true</strong>. If <strong>name</strong> is not a
registered process, or is not an atom, <strong>false</strong> is returned and
<strong>*pid</strong> is unchanged.</p><p>Works as <a href="./erlang#whereis-1">erlang#whereis-1</a>, but restricted to processes. See
<a href="#enif_whereis_port">enif_whereis_port</a>
to resolve registered ports.</p><h3>enif_whereis_port(ErlNifEnv *env,
          ERL_NIF_TERM name, ErlNifPort *port):int</h3><p>Looks up a port by its registered name.</p><p>Looks up a port by its registered name.</p><dl><dt><strong>env</strong></dt><dd>The environment of the calling process. Must be <strong>NULL</strong> only if calling from a created thread.</dd><dt><strong>name</strong></dt><dd>The name of a registered port, as an atom.</dd><dt><strong>*port</strong></dt><dd>The <a href="#ErlNifPort">ErlNifPort</a> in which the resolved port id is stored.</dd></dl><p>On success, sets <strong>*port</strong> to the port registered with
<strong>name</strong> and returns <strong>true</strong>. If <strong>name</strong> is not a
registered port, or is not an atom, <strong>false</strong> is returned and
<strong>*port</strong> is unchanged.</p><p>Works as <a href="./erlang#whereis-1">erlang#whereis-1</a>, but restricted to ports. See
<a href="#enif_whereis_pid">enif_whereis_pid</a>
to resolve registered processes.</p><h3>See Also</h3><p><a href="./erlang#load_nif-2">erlang#load_nif-2</a></p><h2>erl_prim_loader</h2><p>Low-level Erlang loader.</p><p>This module is used to load all Erlang modules into
the system. The start script is also fetched with this low-level
loader.<strong>erl_prim_loader</strong> knows about the environment and how to
fetch modules.Command-line flag <strong>-loader Loader</strong> can be used to
choose the method used by <strong>erl_prim_loader</strong>. Two
<strong>Loader</strong> methods are supported by the Erlang runtime system:
<strong>efile</strong> and <strong>inet</strong>.</p><h2>Functions</h2><h3>get_file/1</h3><p>Get a file.</p><p>Fetches a file using the low-level loader.
<strong><span class="anno">Filename</span></strong> is either an absolute filename or only
the name of the file, for example, <strong>"lists.beam"</strong>. If an internal
path is set to the loader, this path is used to find the file.
<strong><span class="anno">FullName</span></strong> is the complete name of the fetched file.
<strong><span class="anno">Bin</span></strong> is the contents of the file as a binary.</p><p><strong><span class="anno">Filename</span></strong> can also be a file in an archive,
for example,
<strong>$OTPROOT/lib/</strong><strong>mnesia-4.4.7.ez/mnesia-4.4.7/ebin/</strong><strong>mnesia.beam</strong>.
For information about archive files, see
<a href="./code">kernel/code</a>.</p><h3>get_path/0</h3><p>Get the path set in the loader.</p><p>Gets the path set in the loader. The path is
set by the <a href="init">init</a>
process according to information found in the start script.</p><h3>list_dir/1</h3><p>List files in a directory.</p><p>Lists all the files in a directory. Returns
<strong>{ok, <span class="anno">Filenames</span>}</strong> if successful, otherwise
<strong>error</strong>. <strong><span class="anno">Filenames</span></strong> is a list of
the names of all the files in the directory. The names are
not sorted.</p><p><strong><span class="anno">Dir</span></strong> can also be a directory in an archive,
for example,
<strong>$OTPROOT/lib/</strong><strong>mnesia-4.4.7.ez/mnesia-4.4.7/ebin</strong>.
For information about archive files, see
<a href="./code">kernel/code</a>.</p><h3>read_file_info/1</h3><p>Get information about a file.</p><p>Retrieves information about a file. Returns
<strong>{ok, <span class="anno">FileInfo</span>}</strong> if successful, otherwise
<strong>error</strong>. <strong><span class="anno">FileInfo</span></strong> is a record
<strong>file_info</strong>, defined in the Kernel include file
<strong>file.hrl</strong>. Include the following directive in the module
from which the function is called:</p><pre><code class="">
-include_lib("kernel/include/file.hrl").</code></pre><p>For more information about the record <strong>file_info</strong>, see
<a href="./file">kernel/file</a>.</p><p><strong><span class="anno">Filename</span></strong> can also be a file in an archive,
for example,
<strong>$OTPROOT/lib/</strong><strong>mnesia-4.4.7.ez/mnesia-4.4.7/ebin/</strong><strong>mnesia</strong>.
For information about archive files, see
<a href="./code">kernel/code</a>.</p><h3>read_link_info/1</h3><p>Get information about a link or file.</p><p>Works like
<a href="#read_file_info/1">read_file_info/1</a>
except that if <strong><span class="anno">Filename</span></strong> is a symbolic link,
information about the link is returned in the <strong>file_info</strong>
record and the <strong>type</strong> field of the record is set to
<strong>symlink</strong>.</p><p>If <strong><span class="anno">Filename</span></strong> is not a symbolic link, this function
returns exactly the same result as <strong>read_file_info/1</strong>.
On platforms that do not support symbolic links, this function
is always equivalent to <strong>read_file_info/1</strong>.</p><h3>set_path/1</h3><p>Set the path of the loader.</p><p>Sets the path of the loader if
<a href="init">init</a>
interprets a <strong>path</strong> command in the start script.</p><h3>Command-Line Flags</h3><p>The <strong>erl_prim_loader</strong> module interprets the following
command-line flags:</p><dl><dt><strong>-loader Loader</strong></dt><dd> <p>Specifies the name of the loader used by
<strong>erl_prim_loader</strong>. <strong>Loader</strong> can be <strong>efile</strong>
(use the local file system) or <strong>inet</strong> (load using
the <strong>boot_server</strong> on another Erlang node).</p> <p>If flag <strong>-loader</strong> is omitted, it defaults to
<strong>efile</strong>.</p> </dd><dt><strong>-loader_debug</strong></dt><dd> <p>Makes the <strong>efile</strong> loader write some debug information,
such as the reason for failures, while it handles files.</p> </dd><dt><strong>-hosts Hosts</strong></dt><dd> <p>Specifies which other Erlang nodes the <strong>inet</strong> loader
can use. This flag is mandatory if flag <strong>-loader inet</strong>
is present. On each host, there must be on Erlang node
with the <a href="./erl_boot_server">kernel/erl_boot_server</a>,
which handles the load requests.
<strong>Hosts</strong> is a list of IP addresses (hostnames
are not acceptable).</p> </dd><dt><strong>-setcookie Cookie</strong></dt><dd> <p>Specifies the cookie of the Erlang runtime system. This flag
is mandatory if flag <strong>-loader inet</strong> is present.</p> </dd></dl><h3>See Also</h3><p><a href="init">init</a>,
<a href="./erl_boot_server">kernel/erl_boot_server</a></p><h2>erlsrv</h2><p>Run the Erlang emulator as a service on Windows</p><p>This utility is specific to Windows NT/2000/XP (and later
versions of Windows). It allows Erlang
emulators to run as services on the Windows system, allowing embedded
systems to start without any user needing to log on. The
emulator started in this way can be manipulated through the
Windows services applet in a manner similar to other services.Notice that <strong>erlsrv</strong> is not a general service utility for Windows,
but designed for embedded Erlang systems.<strong>erlsrv</strong> also provides a command-line interface for registering,
changing, starting, and stopping services.To manipulate services, the logged on user is to have
administrator privileges on the machine. The Erlang machine
itself is (default) run as the local administrator. This can be
changed with the Services applet in Windows.The processes created by the service can, as opposed to normal
services, be "killed" with the task manager. Killing an emulator
that is started by a service triggers the "OnFail" action
specified for that service, which can be a reboot.The following parameters can be specified for each Erlang service:<dl><dt><strong>StopAction</strong></dt><dd> <p>Tells <strong>erlsrv</strong> how to stop
the Erlang emulator. Default is to kill it (Win32
TerminateProcess), but this action can specify any Erlang
shell command that will be executed in the emulator to make
it stop. The emulator is expected to stop within 30 seconds
after the command is issued in the shell. If the emulator is
not stopped, it reports a running state to the service
manager.</p> </dd><dt><strong>OnFail</strong></dt><dd> <p>Can be one of the following:</p> <dl><dt><strong>reboot</strong></dt><dd> <p>The Windows system is rebooted whenever the emulator stops
(a more simple form of watchdog). This can be useful for
less critical systems, otherwise use the heart functionality
to accomplish this.</p> </dd><dt><strong>restart</strong></dt><dd> <p>Makes the Erlang emulator be
restarted (with whatever parameters are registered for the
service at the occasion) when it stops. If the emulator
stops again within 10 seconds, it is not restarted to avoid
an infinite loop, which could hang the Windows system.</p> </dd><dt><strong>restart_always</strong></dt><dd> <p>Similar to <strong>restart</strong>, but does
not try to detect cyclic restarts; it is expected that
some other mechanism is present to avoid the problem.</p> </dd><dt><strong>ignore</strong> (the default)</dt><dd> <p>Reports the service as stopped to the service manager
whenever it fails; it must be manually restarted.</p> </dd></dl> <p>On a system where release handling is used,
this is always to be set to <strong>ignore</strong>. Use
<strong>heart</strong> to restart the service on failure
instead.</p> </dd><dt><strong>Machine</strong></dt><dd> <p>The location of the Erlang emulator.
The default is the <strong>erl.exe</strong> located in the same
directory as <strong>erlsrv.exe</strong>. Do not specify
<strong>werl.exe</strong> as this emulator, it will not work.</p> <p>If the system uses release handling, this is to be set to a
program similar to <strong>start_erl.exe</strong>.</p> </dd><dt><strong>Env</strong></dt><dd> <p>Specifies an <em>extra</em> environment
for the emulator. The environment variables specified
here are added to the system-wide environment block that is
normally present when a service starts up. Variables present
in both the system-wide environment and in the service
environment specification will be set to the value specified
in the service.</p> </dd><dt><strong>WorkDir</strong></dt><dd> <p>The working directory for the Erlang emulator.
Must be on a local drive (no network drives are mounted when a
service starts). Default working directory for services is
<strong>%SystemDrive%%SystemPath%</strong>.
Debug log files will be placed in this directory.</p> </dd><dt><strong>Priority</strong></dt><dd> <p>The process priority of the emulator. Can be one of the
following:</p> <dl><dt><strong>realtime</strong></dt><dd> <p>Not recommended, as the machine will possibly be
inaccessible to interactive users.</p> </dd><dt><strong>high</strong></dt><dd> <p>Can be used if two Erlang nodes are to reside on one dedicated
system and one is to have precedence over the other.</p> </dd><dt><strong>low</strong></dt><dd> <p>Can be used if interactive performance is not to be affected
by the emulator process.</p> </dd><dt><strong>default</strong> (the default&gt;</dt><dd> </dd></dl> </dd><dt><strong>SName or Name</strong></dt><dd> <p>Specifies the short or long
node name of the Erlang emulator. The Erlang services are
always distributed. Default is to use the service name as
(short) nodename.</p> </dd><dt><strong>DebugType</strong></dt><dd> <p>Specifies that output from the Erlang shell is to be
sent to a "debug log". The log file is named
&lt;servicename&gt;<strong>.debug</strong> or
&lt;servicename&gt;<strong>.debug.</strong>&lt;N&gt;,
where &lt;N&gt; is an integer from 1 through 99.
The log file is placed in the working directory of the
service (as specified in <strong>WorkDir</strong>).</p> <p>Can be one of the following:</p> <dl><dt><strong>new</strong></dt><dd> <p>Uses a separate log file for every invocation of the service
(&lt;servicename&gt;<strong>.debug.</strong>&lt;N&gt;).</p> </dd><dt><strong>reuse</strong></dt><dd> <p>Reuses the same log file
(&lt;servicename&gt;<strong>.debug</strong>).</p> </dd><dt><strong>console</strong></dt><dd> <p>Opens an interactive Windows console window for the Erlang
shell of the service. Automatically disables the
<strong>StopAction</strong>. A service started with an
interactive console window does not survive logouts.
<strong>OnFail</strong> actions do not work with
debug consoles either.</p> </dd><dt><strong>none</strong> (the default)</dt><dd> <p>The output of the Erlang shell is discarded.</p> </dd></dl> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The <strong>console</strong> option is <em>not</em> intended
for production. It is <em>only</em> a convenient way to debug
Erlang services during development.</p><p>The <strong>new</strong> and <strong>reuse</strong> options
might seem convenient in a production system, but consider that
the logs grow indefinitely during the system lifetime and cannot
be truncated, except if the service is restarted.</p><p>In short, the <strong>DebugType</strong> is
intended for debugging only. Logs during production are
better produced with the standard Erlang logging facilities.</p></div> </dd><dt><strong>Args</strong></dt><dd> <p>Passes extra arguments to the emulator startup program
<strong>erl.exe</strong> (or <strong>start_erl.exe</strong>).
Arguments that cannot be specified here are
<strong>-noinput</strong> (<strong>StopActions</strong> would not work),
<strong>-name</strong>, and <strong>-sname</strong> (they are
specified in any way). The most common use is for specifying cookies
and flags to be passed to <strong>init:boot()</strong>
(<strong>-s</strong>).</p> </dd><dt><strong>InternalServiceName</strong></dt><dd> <p>Specifies the Windows-internal service name (not the display name,
which is the one <strong>erlsrv</strong> uses to identify the service).</p> <p>This internal name cannot be changed, it is fixed even if the
service is renamed. <strong>erlsrv</strong> generates a unique internal name
when a service is created. It is recommended to keep to the default
if release handling is to be used for the application.</p> <p>The internal service name can be seen in the Windows service
manager if viewing <strong>Properties</strong> for an Erlang service.</p> </dd><dt><strong>Comment</strong></dt><dd> <p>A textual comment describing the service. Not mandatory, but shows
up as the service description in the Windows service manager.</p> </dd></dl><a name="001"></a>
The naming of the service in a system that
uses release handling must follow the convention
<em>NodeName</em>_<em>Release</em>, where <em>NodeName</em> is
the first part of the Erlang node name (up to, but not including
the "@") and <em>Release</em> is the current release of the
application.</p><h2>Functions</h2><h3>erlsrv {set | add} &lt;service-name&gt; [&lt;service options&gt;]</h3><p>Add or modify an Erlang service.</p><p>The <strong>set</strong> and <strong>add</strong> commands modifies or adds an Erlang
service, respectively. The simplest form of an <strong>add</strong> command is
without any options in which case all default values
(described above) apply. The service name is mandatory.</p><p>Every option can be specified without parameters, the
default value is then applied. Values to the options are
supplied <em>only</em> when the default is not to be used.
For example, <strong>erlsrv set myservice -prio -arg</strong>
sets the default priority and removes all arguments.</p><p>Service options:</p><dl><dt><strong>-st[opaction] [&lt;erlang shell command&gt;]</strong></dt><dd> <p>Defines the <strong>StopAction</strong>, the command given
to the Erlang shell when the service is stopped.
Default is none.</p> </dd><dt><strong>-on[fail] [{reboot | restart | restart_always}]</strong></dt><dd> <p>The action to take when the Erlang emulator
stops unexpectedly. Default is to ignore.</p> </dd><dt><strong>-m[achine] [&lt;erl-command&gt;]</strong></dt><dd> <p>The complete path to the Erlang emulator. Never use the
<strong>werl</strong> program for this. Defaults to the
<strong>erl.exe</strong> in the same directory as
<strong>erlsrv.exe</strong>. When release handling
is used, this is to be set to a program similar to
<strong>start_erl.exe</strong>.</p> </dd><dt><strong>-e[nv] [&lt;variable&gt;[=&lt;value&gt;]] ...</strong></dt><dd> <p>Edits the environment block for the service. Every
environment variable specified is added to the system
environment block. If a variable specified here has the same
name as a system-wide environment variable, the specified
value overrides the system-wide. Environment variables are
added to this list by specifying
&lt;variable&gt;=&lt;value&gt; and deleted from the list by
specifying &lt;variable&gt; alone. The environment block is
automatically sorted. Any number of <strong>-env</strong>
options can be specified in one command. Default is to use the
system environment block unmodified (except for two additions,
see section <a href="#002">Environment</a>
below).</p> </dd><dt><strong>-w[orkdir] [&lt;directory&gt;]</strong></dt><dd> <p>The initial working directory of the Erlang
emulator. Defaults to the system directory.</p> </dd><dt><strong>-p[riority] [{low|high|realtime}]</strong></dt><dd> <p>The priority of the Erlang emulator. Default to the
Windows default priority.</p> </dd><dt><strong>{-sn[ame] | -n[ame]} [&lt;node-name&gt;]</strong></dt><dd> <p>The node name of the Erlang machine. Distribution is mandatory.
Defaults to <strong>-sname &lt;service name&gt;</strong>.</p> </dd><dt><strong>-d[ebugtype] [{new|reuse|console}]</strong></dt><dd> <p>Specifies where shell output is to be sent.
Default is that shell output is discarded.
To be used only for debugging.</p> </dd><dt><strong>-ar[gs] [&lt;limited erl arguments&gt;]</strong></dt><dd> <p>Extra arguments to the Erlang emulator. Avoid
<strong>-noinput</strong>, <strong>-noshell</strong>, and
<strong>-sname</strong>/<strong>-name</strong>. Default is
no extra arguments. Remember that the services cookie file is not
necessarily the same as the interactive users. The service
runs as the local administrator. Specify all arguments
together in one string, use double quotes (") to specify an
argument string containing spaces, and use quoted quotes (\")
to specify a quote within the argument string if necessary.</p> </dd><dt><strong>-i[nternalservicename] [&lt;internal name&gt;]</strong></dt><dd> <p><em>Only</em> allowed for <strong>add</strong>. Specifies a
Windows-internal service name for the service, which by
default is set to something unique (prefixed with the
original service name) by <strong>erlsrv</strong> when adding a new
service. Specifying this is a purely cosmethic action and is
<em>not</em> recommended if release handling is to be
performed. The internal service name cannot be changed once
the service is created. The internal name is <em>not</em> to
be confused with the ordinary service name, which is the name
used to identify a service to <strong>erlsrv</strong>.</p> </dd><dt><strong>-c[omment] [&lt;short description&gt;]</strong></dt><dd> <p>Specifies a textual comment describing the
service. This comment shows up as the service description
in the Windows service manager.</p> </dd></dl><h3>erlsrv {start | start_disabled | stop | disable |
        enable} &lt;service-name&gt;</h3><p>Manipulate the current service status.</p><p>These commands are only added for convenience, the normal
way to manipulate the state of a service is through the
control panels services applet.</p><p>The <strong>start</strong> and
<strong>stop</strong> commands communicates
with the service manager for starting and stopping a
service. The commands wait until the service is
started or stopped. When disabling a service, it is not
stopped, the disabled state does not take effect until the
service is stopped. Enabling a service sets it in
automatic mode, which is started at boot. This command cannot
set the service to manual.</p><p>The <strong>start_disabled</strong> command operates on a service
regardless of if it is enabled/disabled or started/stopped. It
does this by first enabling it (regardless of if it is enabled
or not), then starting it (if not already started), and
then disabling it. The result is a disabled but started
service, regardless of its earlier state. This is useful for
starting services temporarily during a release upgrade. The
difference between using <strong>start_disabled</strong> and the
sequence <strong>enable</strong>, <strong>start</strong>, and <strong>disable</strong> is
that all other <strong>erlsrv</strong> commands are locked out during
the sequence of operations in <strong>start_disable</strong>, making the
operation atomic from an <strong>erlsrv</strong> user's point of view.</p><h3>erlsrv remove &lt;service-name&gt;</h3><p>Remove the service.</p><p>Removes the service completely with all its registered
options. It is stopped before it is removed.</p><h3>erlsrv list [&lt;service-name&gt;]</h3><p>List all Erlang services or all options for one service. </p><p>If no service name is specified, a brief listing of all Erlang
services is presented. If a service name is supplied, all options
for that service are presented.</p><h3>erlsrv help</h3><p>Display a brief help text.</p><p>Displays a brief help text.</p><h3>Environment</h3><p><a name="002"></a>
The environment of an Erlang machine started
as a service contains two special variables:</p><dl><dt><strong>ERLSRV_SERVICE_NAME</strong></dt><dd>The name of the service that started the machine.</dd><dt><strong>ERLSRV_EXECUTABLE</strong></dt><dd>The full path to the <strong>erlsrv.exe</strong>, which can be used to manipulate the service. This comes in handy when defining a heart command for your service.</dd></dl><p>A command file for restarting a service looks as follows:</p><pre><code class="">
@echo off
%ERLSRV_EXECUTABLE% stop %ERLSRV_SERVICE_NAME%
%ERLSRV_EXECUTABLE% start %ERLSRV_SERVICE_NAME%    </code></pre><p>This command file is then set as heart command.</p><p>The environment variables can also be used to detect that we
are running as a service and make port programs react correctly
to the control events generated on logout (see the next section).</p><h3>Port Programs</h3><p>When a program runs in
the service context, it must handle the control events that are
sent to every program in the system when the interactive user
logs off. This is done in different ways for programs running in
the console subsystem and programs running as window
applications. An application running in the console subsystem
(normal for port programs) uses the win32 function
<strong>SetConsoleCtrlHandler</strong> to register a control handler
that returns <strong>true</strong> in answer to the
<strong>CTRL_LOGOFF_EVENT</strong>
and <strong>CTRL_SHUTDOWN_EVENT</strong> events. Other applications
only forward <strong>WM_ENDSESSION</strong> and
<strong>WM_QUERYENDSESSION</strong> to the default window procedure.</p><p>A brief example in C of how to set the console control handler:</p><pre><code class="">
#include &lt;windows.h&gt;
/* 
** A Console control handler that ignores the log off events,
** and lets the default handler take care of other events.
*/   
BOOL WINAPI service_aware_handler(DWORD ctrl){
    if(ctrl == CTRL_LOGOFF_EVENT)
        return TRUE;
    if(ctrl == CTRL_SHUTDOWN_EVENT)
        return TRUE;
    return FALSE;
}

void initialize_handler(void){
    char buffer[2];
    /* 
     * We assume we are running as a service if this  
     * environment variable is defined.
     */
    if(GetEnvironmentVariable("ERLSRV_SERVICE_NAME",buffer,
                              (DWORD) 2)){
        /*
        ** Actually set the control handler
        */
        SetConsoleCtrlHandler(&amp;service_aware_handler, TRUE);
    }
}    </code></pre><h3>Notes</h3><p>Although the options are described in a Unix-like format, the case of
the options or commands is not relevant, and both character "/" and "-"
can be used for options.</p><p>Notice that the program resides in the emulator's <strong>bin</strong>
directory, not in the <strong>bin</strong> directory directly under
the Erlang root. The reasons for this are the subtle problem of
upgrading the emulator on a running system, where a new version of
the runtime system should not need to overwrite existing (and probably
used) executables.</p><p>To manipulate the Erlang services easily, put
the <strong>&lt;erlang_root&gt;\erts-&lt;version&gt;\bin</strong> directory in
the path instead of <strong>&lt;erlang_root&gt;\bin</strong>. The
<strong>erlsrv</strong> program can be found from inside Erlang by using the
<strong>os:find_executable/1</strong> Erlang function.</p><p>For release handling to work, use <strong>start_erl</strong> as the
Erlang machine. As stated <a href="#001">above</a>,
the service name is significant.</p><h3>See Also</h3><p><a href="start_erl">start_erl</a>,
<a href="./release_handler">sasl/release_handler</a></p><h2>erl_tracer</h2><p>Erlang tracer behavior.</p><p>This behavior module implements the back end of the Erlang
tracing system. The functions in this module are called whenever
a trace probe is triggered. Both the <strong>enabled</strong> and <strong>trace</strong>
functions are called in the context of the entity that triggered the
trace probe.
This means that the overhead by having the tracing enabled is
greatly effected by how much time is spent in these functions. So, do as
little work as possible in these functions.</p><h2>Data Types</h2><span class="name">trace_tag_call</span><span class="name">trace_tag_gc</span><span class="name">trace_tag_ports</span><span class="name">trace_tag_procs</span><span class="name">trace_tag_receive</span><span class="name">trace_tag_running_ports</span><span class="name">trace_tag_running_procs</span><span class="name">trace_tag_send</span><span class="name">trace_tag</span><p>The different trace tags that the tracer is called with.
Each trace tag is described in detail in
<a href="#Module:trace/5">Module:trace/5</a>.</p><span class="name">tracee</span><p>The process or port that the trace belongs to.</p><span class="name">trace_opts</span><p>The options for the tracee:</p><dl><dt><strong>timestamp</strong></dt><dd>If set the tracer has been requested to include a time stamp.</dd><dt><strong>extra</strong></dt><dd>If set the tracepoint has included additional data about the trace event. What the additional data is depends on which <strong>TraceTag</strong> has been triggered. The <strong>extra</strong> trace data corresponds to the fifth element in the trace tuples described in <a href="./erlang#trace_3_trace_messages"> erlang:trace/3</a>.</dd><dt><strong>match_spec_result</strong></dt><dd>If set the tracer has been requested to include the output of a match specification that was run.</dd><dt><strong>scheduler_id</strong></dt><dd>If set the scheduler id is to be included by the tracer.</dd></dl><span class="name">tracer_state</span><p>The state specified when calling
<a href="./erlang#trace-3">erlang#trace-3</a>.
The tracer state is an immutable value that is passed to
<strong>erl_tracer</strong> callbacks and is to
contain all the data that is needed to generate the trace event.</p><h3>Callback Functions</h3><p>The following functions are to be exported from an <strong>erl_tracer</strong>
callback module:</p><dl><dt><a href="#Module:enabled/3">Module:enabled/3</a></dt><dd>Mandatory</dd><dt><a href="#Module:trace/5">Module:trace/5</a></dt><dd>Mandatory</dd><dt><a href="#Module:enabled_call/3">Module:enabled_call/3</a></dt><dd>Optional</dd><dt><a href="#Module:trace_call/5">Module:trace_call/5</a></dt><dd>Optional</dd><dt><a href="#Module:enabled_garbage_collection/3">Module:enabled_garbage_collection/3</a></dt><dd>Optional</dd><dt><a href="#Module:trace_garbage_collection/5">Module:trace_garbage_collection/5</a></dt><dd>Optional</dd><dt><a href="#Module:enabled_ports/3">Module:enabled_ports/3</a></dt><dd>Optional</dd><dt><a href="#Module:trace_ports/5">Module:trace_ports/5</a></dt><dd>Optional</dd><dt><a href="#Module:enabled_procs/3">Module:enabled_procs/3</a></dt><dd>Optional</dd><dt><a href="#Module:trace_procs/5">Module:trace_procs/5</a></dt><dd>Optional</dd><dt><a href="#Module:enabled_receive/3">Module:enabled_receive/3</a></dt><dd>Optional</dd><dt><a href="#Module:trace_receive/5">Module:trace_receive/5</a></dt><dd>Optional</dd><dt><a href="#Module:enabled_running_ports/3">Module:enabled_running_ports/3</a></dt><dd>Optional</dd><dt><a href="#Module:trace_running_ports/5">Module:trace_running_ports/5</a></dt><dd>Optional</dd><dt><a href="#Module:enabled_running_procs/3">Module:enabled_running_procs/3</a></dt><dd>Optional</dd><dt><a href="#Module:trace_running_procs/5">Module:trace_running_procs/5</a></dt><dd>Optional</dd><dt><a href="#Module:enabled_send/3">Module:enabled_send/3</a></dt><dd>Optional</dd><dt><a href="#Module:trace_send/5">Module:trace_send/5</a></dt><dd>Optional</dd></dl><h2>Functions</h2><h3>Module:enabled(TraceTag, TracerState, Tracee) -&gt; Result</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag =  | trace_status</span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint is triggered. It
allows the tracer to decide whether a trace is to be generated or not.
This check is made as early as possible to limit the amount of
overhead associated with tracing. If <strong>trace</strong> is returned, the
necessary trace data is created and the trace callback of the tracer
is called. If <strong>discard</strong> is returned, this trace call is
discarded and no call to trace is done.</p><p><strong>trace_status</strong> is a special type of <strong>TraceTag</strong>, which is
used to check if the tracer is still to be active. It is called in
multiple scenarios, but most significantly it is used when tracing
is started using this tracer. If <strong>remove</strong> is returned when the
<strong>trace_status</strong> is checked, the tracer is removed from the
tracee.</p><p>This function can be called multiple times per tracepoint, so it
is important that it is both fast and without side effects.</p><h3>Module:enabled_call(TraceTag, TracerState, Tracee) -&gt; Result</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint with trace flag
<a href="./erlang#trace-3">erlang#trace-3</a>
is triggered.</p><p>If <strong>enabled_call/3</strong> is undefined,
<a href="#Module:enabled/3">Module:enabled/3</a>
is called instead.</p><h3>Module:enabled_garbage_collection(TraceTag, TracerState, Tracee) -&gt; Result</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint with trace flag
<a href="./erlang#trace-3">erlang#trace-3</a>
is triggered.</p><p>If <strong>enabled_garbage_collection/3</strong> is undefined,
<a href="#Module:enabled/3">Module:enabled/3</a>
is called instead.</p><h3>Module:enabled_ports(TraceTag, TracerState, Tracee) -&gt; Result</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint with trace flag
<a href="./erlang#trace-3">erlang#trace-3</a>
is triggered.</p><p>If <strong>enabled_ports/3</strong> is undefined,
<a href="#Module:enabled/3">Module:enabled/3</a>
is called instead.</p><h3>Module:enabled_procs(TraceTag, TracerState, Tracee) -&gt; Result</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint with trace flag
<a href="./erlang#trace-3">erlang#trace-3</a>
is triggered.</p><p>If <strong>enabled_procs/3</strong> is undefined,
<a href="#Module:enabled/3">Module:enabled/3</a>
is called instead.</p><h3>Module:enabled_receive(TraceTag, TracerState, Tracee) -&gt; Result
</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint with trace flag
<a href="./erlang#trace-3">erlang#trace-3</a>
is triggered.</p><p>If <strong>enabled_receive/3</strong> is undefined,
<a href="#Module:enabled/3">Module:enabled/3</a>
is called instead.</p><h3>Module:enabled_running_ports(TraceTag, TracerState, Tracee) -&gt;
        Result</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint with trace flag
<a href="./erlang#trace-3">erlang#trace-3</a>
is triggered.</p><p>If <strong>enabled_running_ports/3</strong> is undefined,
<a href="#Module:enabled/3">Module:enabled/3</a>
is called instead.</p><h3>Module:enabled_running_procs(TraceTag, TracerState, Tracee) -&gt;
        Result</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint with trace flag
<a href="./erlang#trace-3">erlang#trace-3</a>
is triggered.</p><p>If <strong>enabled_running_procs/3</strong> is undefined,
<a href="#Module:enabled/3">Module:enabled/3</a>
is called instead.</p><h3>Module:enabled_send(TraceTag, TracerState, Tracee) -&gt; Result</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">Result = trace | discard | remove</span></li></ul><p>This callback is called whenever a tracepoint with trace flag
<a href="./erlang#trace-3">erlang#trace-3</a>
is triggered.</p><p>If <strong>enabled_send/3</strong> is undefined,
<a href="#Module:enabled/3">Module:enabled/3</a>
is called instead.</p><h3>Module:trace(TraceTag, TracerState, Tracee, TraceTerm,
        Opts) -&gt; Result</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled/3">Module:enabled/3</a>
callback returned <strong>trace</strong>. In it any side effects needed by
the tracer are to be done. The tracepoint payload is located in
the <strong>TraceTerm</strong>. The content of the <strong>TraceTerm</strong>
depends on which <strong>TraceTag</strong> is triggered.
<strong>TraceTerm</strong> corresponds to the
fourth element in the trace tuples described in
<a href="./erlang#trace_3_trace_messages">erlang#trace_3_trace_messages</a>.</p><p>If the trace tuple has five elements, the fifth element
will be sent as the <strong>extra</strong> value in the <strong>Opts</strong> maps.</p><h3>Module:trace(seq_trace, TracerState, Label,
        SeqTraceInfo, Opts) -&gt; Result</h3><p>Check if a sequence trace event is to be generated.</p><ul><li><span class="v">TracerState = term()</span></li><li><span class="v">Label = term()</span></li><li><span class="v">SeqTraceInfo = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>The <strong>TraceTag</strong> <strong>seq_trace</strong> is handled slightly
differently. There is no <strong>Tracee</strong> for <strong>seq_trace</strong>, instead
the <strong>Label</strong> associated with the <strong>seq_trace</strong> event is
specified.</p><p>For more information on what <strong>Label</strong> and <strong>SeqTraceInfo</strong>
can be, see <a href="./seq_trace">kernel/seq_trace</a>.</p><h3>Module:trace_call(TraceTag, TracerState, Tracee, TraceTerm,
          Opts) -&gt; Result</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled_call/3">Module:enabled_call/3</a>
callback returned <strong>trace</strong>.</p><p>If <strong>trace_call/5</strong> is undefined,
<a href="#Module:trace/5">Module:trace/5</a>
is called instead.</p><h3>Module:trace_garbage_collection(TraceTag, TracerState, Tracee,
        TraceTerm, Opts) -&gt; Result</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled_garbage_collection/3">Module:enabled_garbage_collection/3</a>
callback returned <strong>trace</strong>.</p><p>If <strong>trace_garbage_collection/5</strong> is undefined,
<a href="#Module:trace/5">Module:trace/5</a>
is called instead.</p><h3>Module:trace_ports(TraceTag, TracerState, Tracee, TraceTerm,
        Opts) -&gt; Result</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled_ports/3">Module:enabled_ports/3</a>
callback returned <strong>trace</strong>.</p><p>If <strong>trace_ports/5</strong> is undefined,
<a href="#Module:trace/5">Module:trace/5</a>
is called instead.</p><h3>Module:trace_procs(TraceTag, TracerState, Tracee, TraceTerm,
        Opts) -&gt; Result</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled_procs/3">Module:enabled_procs/3</a>
callback returned <strong>trace</strong>.</p><p>If <strong>trace_procs/5</strong> is undefined,
<a href="#Module:trace/5">Module:trace/5</a>
is called instead.</p><h3>Module:trace_receive(TraceTag, TracerState, Tracee, TraceTerm,
        Opts) -&gt; Result</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled_receive/3">Module:enabled_receive/3</a>
callback returned <strong>trace</strong>.</p><p>If <strong>trace_receive/5</strong> is undefined,
<a href="#Module:trace/5">Module:trace/5</a>
is called instead.</p><h3>Module:trace_running_ports(TraceTag, TracerState, Tracee,
        TraceTerm, Opts) -&gt; Result</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled_running_ports/3">Module:enabled_running_ports/3</a>
callback returned <strong>trace</strong>.</p><p>If <strong>trace_running_ports/5</strong> is undefined,
<a href="#Module:trace/5">Module:trace/5</a>
is called instead.</p><h3>Module:trace_running_procs(TraceTag, TracerState, Tracee,
        TraceTerm, Opts) -&gt; Result</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled_running_procs/3">Module:enabled_running_procs/3</a>
callback returned <strong>trace</strong>.</p><p>If <strong>trace_running_procs/5</strong> is undefined,
<a href="#Module:trace/5">Module:trace/5</a>
is called instead.</p><h3>Module:trace_send(TraceTag, TracerState, Tracee, TraceTerm,
        Opts) -&gt; Result</h3><p>Check if a trace event is to be generated.</p><ul><li><span class="v">TraceTag = </span></li><li><span class="v">TracerState = term()</span></li><li><span class="v">Tracee = </span></li><li><span class="v">TraceTerm = term()</span></li><li><span class="v">Opts = </span></li><li><span class="v">Result = ok</span></li></ul><p>This callback is called when a tracepoint is triggered and the
<a href="#Module:enabled_send/3">Module:enabled_send/3</a>
callback returned <strong>trace</strong>.</p><p>If <strong>trace_send/5</strong> is undefined,
<a href="#Module:trace/5">Module:trace/5</a>
is called instead.</p><a name="example"></a><h3>Erl Tracer Module Example</h3><p>In this example, a tracer module with a NIF back end sends a
message for each <strong>send</strong> trace tag containing only the sender and
receiver. Using this tracer module, a much more lightweight message
tracer is used, which only records who sent messages to who.</p><p>The following is an example session using it on Linux:</p><pre>
$ gcc -I erts-8.0/include/ -fPIC -shared -o erl_msg_tracer.so erl_msg_tracer.c
$ erl
Erlang/OTP 19 [DEVELOPMENT] [erts-8.0] [source-ed2b56b] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V8.0  (abort with ^G)
1&gt; c(erl_msg_tracer), erl_msg_tracer:load().
ok
2&gt; Tracer = spawn(fun F() -&gt; receive M -&gt; io:format("~p~n",[M]), F() end end).
&lt;0.37.0&gt;
3&gt; erlang:trace(new, true, [send,{tracer, erl_msg_tracer, Tracer}]).
0
{trace,&lt;0.39.0&gt;,&lt;0.27.0&gt;}
4&gt; {ok, D} = file:open("/tmp/tmp.data",[write]).
{trace,#Port&lt;0.486&gt;,&lt;0.40.0&gt;}
{trace,&lt;0.40.0&gt;,&lt;0.21.0&gt;}
{trace,#Port&lt;0.487&gt;,&lt;0.4.0&gt;}
{trace,#Port&lt;0.488&gt;,&lt;0.4.0&gt;}
{trace,#Port&lt;0.489&gt;,&lt;0.4.0&gt;}
{trace,#Port&lt;0.490&gt;,&lt;0.4.0&gt;}
{ok,&lt;0.40.0&gt;}
{trace,&lt;0.41.0&gt;,&lt;0.27.0&gt;}
5&gt;</pre><p><strong>erl_msg_tracer.erl</strong>:</p><pre>
-module(erl_msg_tracer).

-export([enabled/3, trace/5, load/0]).

load() -&gt;
    erlang:load_nif("erl_msg_tracer", []).

enabled(_, _, _) -&gt;
    error.

trace(_, _, _, _, _) -&gt;
    error.</pre><p><strong>erl_msg_tracer.c</strong>:</p><pre>
#include &lt;erl_nif.h&gt;

/* NIF interface declarations */
static int load(ErlNifEnv* env, void** priv_data, ERL_NIF_TERM load_info);
static int upgrade(ErlNifEnv* env, void** priv_data, void** old_priv_data, ERL_NIF_TERM load_info);
static void unload(ErlNifEnv* env, void* priv_data);

/* The NIFs: */
static ERL_NIF_TERM enabled(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);
static ERL_NIF_TERM trace(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);

static ErlNifFunc nif_funcs[] = {
    {"enabled", 3, enabled},
    {"trace", 5, trace}
};

ERL_NIF_INIT(erl_msg_tracer, nif_funcs, load, NULL, upgrade, unload)

static int load(ErlNifEnv* env, void** priv_data, ERL_NIF_TERM load_info)
{
    *priv_data = NULL;
    return 0;
}

static void unload(ErlNifEnv* env, void* priv_data)
{

}

static int upgrade(ErlNifEnv* env, void** priv_data, void** old_priv_data,
		   ERL_NIF_TERM load_info)
{
    if (*old_priv_data != NULL || *priv_data != NULL) {
	return -1; /* Don't know how to do that */
    }
    if (load(env, priv_data, load_info)) {
	return -1;
    }
    return 0;
}

/*
 * argv[0]: TraceTag
 * argv[1]: TracerState
 * argv[2]: Tracee
 */
static ERL_NIF_TERM enabled(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
    ErlNifPid to_pid;
    if (enif_get_local_pid(env, argv[1], &amp;to_pid))
        if (!enif_is_process_alive(env, &amp;to_pid))
            if (enif_is_identical(enif_make_atom(env, "trace_status"), argv[0]))
                /* tracer is dead so we should remove this tracepoint */
                return enif_make_atom(env, "remove");
            else
                return enif_make_atom(env, "discard");

    /* Only generate trace for when tracer != tracee */
    if (enif_is_identical(argv[1], argv[2]))
        return enif_make_atom(env, "discard");

    /* Only trigger trace messages on 'send' */
    if (enif_is_identical(enif_make_atom(env, "send"), argv[0]))
        return enif_make_atom(env, "trace");

    /* Have to answer trace_status */
    if (enif_is_identical(enif_make_atom(env, "trace_status"), argv[0]))
        return enif_make_atom(env, "trace");

    return enif_make_atom(env, "discard");
}

/*
 * argv[0]: TraceTag, should only be 'send'
 * argv[1]: TracerState, process to send {Tracee, Recipient} to
 * argv[2]: Tracee
 * argv[3]: Message
 * argv[4]: Options, map containing Recipient
 */
static ERL_NIF_TERM trace(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
    ErlNifPid to_pid;
    ERL_NIF_TERM recipient, msg;

    if (enif_get_local_pid(env, argv[1], &amp;to_pid)) {
      if (enif_get_map_value(env, argv[4], enif_make_atom(env, "extra"), &amp;recipient)) {
        msg = enif_make_tuple3(env, enif_make_atom(env, "trace"), argv[2], recipient);
        enif_send(env, &amp;to_pid, NULL, msg);
      }
    }

    return enif_make_atom(env, "ok");
}</pre><h2>erts_alloc</h2><p>An Erlang runtime system internal memory allocator library.
</p><p><strong>erts_alloc</strong> is an Erlang runtime system internal memory
allocator library. <strong>erts_alloc</strong> provides the Erlang
runtime system with a number of memory allocators.</p><h3>Allocators</h3><a name="allocators"></a><p>The following allocators are present:</p><dl><dt><strong>temp_alloc</strong></dt><dd>Allocator used for temporary allocations.</dd><dt><strong>eheap_alloc</strong></dt><dd>Allocator used for Erlang heap data, such as Erlang process heaps. </dd><dt><strong>binary_alloc</strong></dt><dd>Allocator used for Erlang binary data.</dd><dt><strong>ets_alloc</strong></dt><dd>Allocator used for <strong>ets</strong> data.</dd><dt><strong>driver_alloc</strong></dt><dd>Allocator used for driver data.</dd><dt><strong>literal_alloc</strong></dt><dd>Allocator used for constant terms in Erlang code.</dd><dt><strong>sl_alloc</strong></dt><dd>Allocator used for memory blocks that are expected to be short-lived.</dd><dt><strong>ll_alloc</strong></dt><dd>Allocator used for memory blocks that are expected to be long-lived, for example, Erlang code.</dd><dt><strong>fix_alloc</strong></dt><dd>A fast allocator used for some frequently used fixed size data types.</dd><dt><strong>exec_alloc</strong></dt><dd>Allocator used by the <a href="./HiPE_app">hipe/HiPE_app</a> application for native executable code.</dd><dt><strong>std_alloc</strong></dt><dd>Allocator used for most memory blocks not allocated through any of the other allocators described above.</dd><dt><strong>sys_alloc</strong></dt><dd>This is normally the default <strong>malloc</strong> implementation used on the specific OS.</dd><dt><strong>mseg_alloc</strong></dt><dd>A memory segment allocator. It is used by other allocators for allocating memory segments and is only available on systems that have the <strong>mmap</strong> system call. Memory segments that are deallocated are kept for a while in a segment cache before they are destroyed. When segments are allocated, cached segments are used if possible instead of creating new segments. This to reduce the number of system calls made.</dd></dl><p><strong>sys_alloc</strong>, <strong>literal_alloc</strong> and <strong>temp_alloc</strong> are always
enabled and cannot be disabled. <strong>exec_alloc</strong> is only available if it
is needed and cannot be disabled. <strong>mseg_alloc</strong> is always enabled if it is
available and an allocator that uses it is enabled. All other
allocators can be <a href="#M_e">enabled or disabled</a>.
By default all allocators are enabled.
When an allocator is disabled, <strong>sys_alloc</strong> is used instead of
the disabled allocator.</p><p>The main idea with the <strong>erts_alloc</strong> library is to separate
memory blocks that are used differently into different memory
areas, to achieve less memory fragmentation. By
putting less effort in finding a good fit for memory blocks that
are frequently allocated than for those less frequently
allocated, a performance gain can be achieved.</p><a name="alloc_util"></a><h3>The alloc_util Framework</h3><p>Internally a framework called <strong>alloc_util</strong> is used for
implementing allocators. <strong>sys_alloc</strong> and
<strong>mseg_alloc</strong> do not use this framework, so the
following does <em>not</em> apply to them.</p><p>An allocator manages multiple areas, called carriers, in which
memory blocks are placed. A carrier is either placed in a
separate memory segment (allocated through <strong>mseg_alloc</strong>), or in
the heap segment (allocated through <strong>sys_alloc</strong>).</p><ul><li> <p>Multiblock carriers are used for storage of several blocks.</p> </li><li> <p>Singleblock carriers are used for storage of one block.</p> </li><li> <p>Blocks that are larger than the value of the singleblock carrier
threshold (<a href="#M_sbct">M_sbct</a>) parameter
are placed in singleblock carriers.</p> </li><li> <p>Blocks that are smaller than the value of parameter <strong>sbct</strong>
are placed in multiblock carriers.</p></li></ul><p>Normally an allocator creates a "main multiblock
carrier". Main multiblock carriers are never deallocated. The
size of the main multiblock carrier is determined by the value of
parameter <a href="#M_mmbcs">M_mmbcs</a>.</p><p><a name="mseg_mbc_sizes"></a>Sizes of multiblock carriers
allocated through <strong>mseg_alloc</strong> are decided based on the
following parameters:</p><ul><li>The values of the largest multiblock carrier size (<a href="#M_lmbcs">M_lmbcs</a>)</li><li>The smallest multiblock carrier size (<a href="#M_smbcs">M_smbcs</a>)</li><li>The multiblock carrier growth stages (<a href="#M_mbcgs">M_mbcgs</a>)</li></ul><p>If <strong>nc</strong> is the current number of multiblock carriers (the main
multiblock carrier excluded) managed by an allocator, the size
of the next <strong>mseg_alloc</strong> multiblock carrier allocated by
this allocator is roughly
<strong>smbcs+nc*(lmbcs-smbcs)/mbcgs</strong> when
<strong>nc &lt;= mbcgs</strong>,
and <strong>lmbcs</strong> when <strong>nc &gt; mbcgs</strong>. If the value of
parameter <strong>sbct</strong> is larger than the value of parameter
<strong>lmbcs</strong>, the allocator may have to create
multiblock carriers that are larger than the value of
parameter <strong>lmbcs</strong>, though.
Singleblock carriers allocated through <strong>mseg_alloc</strong> are sized
to whole pages.</p><p>Sizes of carriers allocated through <strong>sys_alloc</strong> are
decided based on the value of the <strong>sys_alloc</strong> carrier size
(<a href="#Muycs">Muycs</a>) parameter. The size of
a carrier is the least number of multiples of the value of
parameter <strong>ycs</strong> satisfying the request.</p><p>Coalescing of free blocks are always performed immediately.
Boundary tags (headers and footers) in free blocks are used,
which makes the time complexity for coalescing constant.</p><p><a name="strategy"></a>The memory allocation strategy
used for multiblock carriers by an allocator can be
configured using parameter <a href="#M_as">M_as</a>.
The following strategies are available:</p><dl><dt>Best fit</dt><dd> <p>Strategy: Find the smallest block satisfying the
requested block size.</p> <p>Implementation: A balanced binary search tree is
used. The time complexity is proportional to log N, where
N is the number of sizes of free blocks.</p> </dd><dt>Address order best fit</dt><dd> <p>Strategy: Find the smallest block satisfying the
requested block size. If multiple blocks are found, choose
the one with the lowest address.</p> <p>Implementation: A balanced binary search tree is
used. The time complexity is proportional to log N, where
N is the number of free blocks.</p> </dd><dt>Address order first fit</dt><dd> <p>Strategy: Find the block with the lowest address satisfying the
requested block size.</p> <p>Implementation: A balanced binary search tree is
used. The time complexity is proportional to log N, where
N is the number of free blocks.</p> </dd><dt>Address order first fit carrier best fit</dt><dd> <p>Strategy: Find the <em>carrier</em> with the lowest address that
can satisfy the requested block size, then find a block within
that carrier using the "best fit" strategy.</p> <p>Implementation: Balanced binary search trees are
used. The time complexity is proportional to log N, where
N is the number of free blocks.</p> </dd><dt>Address order first fit carrier address order best fit</dt><dd> <p>Strategy: Find the <em>carrier</em> with the lowest address that
can satisfy the requested block size, then find a block within
that carrier using the "address order best fit" strategy.</p> <p>Implementation: Balanced binary search trees are
used. The time complexity is proportional to log N, where
N is the number of free blocks.</p> </dd><dt>Age order first fit carrier address order first fit</dt><dd> <p>Strategy: Find the <em>oldest carrier</em> that
can satisfy the requested block size, then find a block within
that carrier using the "address order first fit" strategy.</p> <p>Implementation: A balanced binary search tree is
used. The time complexity is proportional to log N, where
N is the number of free blocks.</p> </dd><dt>Age order first fit carrier best fit</dt><dd> <p>Strategy: Find the <em>oldest carrier</em> that
can satisfy the requested block size, then find a block within
that carrier using the "best fit" strategy.</p> <p>Implementation: Balanced binary search trees are
used. The time complexity is proportional to log N, where
N is the number of free blocks.</p> </dd><dt>Age order first fit carrier address order best fit</dt><dd> <p>Strategy: Find the <em>oldest carrier</em> that
can satisfy the requested block size, then find a block within
that carrier using the "address order best fit" strategy.</p> <p>Implementation: Balanced binary search trees are
used. The time complexity is proportional to log N, where
N is the number of free blocks.</p> </dd><dt>Good fit</dt><dd> <p>Strategy: Try to find the best fit, but settle for the best fit
found during a limited search.</p> <p>Implementation: The implementation uses segregated free
lists with a maximum block search depth (in each list)
to find a good fit fast. When the maximum block
search depth is small (by default 3), this implementation
has a time complexity that is constant. The maximum block
search depth can be configured using parameter
<a href="#M_mbsd">M_mbsd</a>.</p> </dd><dt>A fit</dt><dd> <p>Strategy: Do not search for a fit, inspect only one free
block to see if it satisfies the request. This strategy is
only intended to be used for temporary allocations.</p> <p>Implementation: Inspect the first block in a free-list.
If it satisfies the request, it is used, otherwise a new
carrier is created. The implementation has a time
complexity that is constant.</p> <p>As from ERTS 5.6.1 the emulator refuses to
use this strategy on other allocators than <strong>temp_alloc</strong>.
This because it only causes problems for other allocators.</p> </dd></dl><p>Apart from the ordinary allocators described above, some
pre-allocators are used for some specific data types. These
pre-allocators pre-allocate a fixed amount of memory for certain data
types when the runtime system starts. As long as pre-allocated memory
is available, it is used. When no pre-allocated memory is
available, memory is allocated in ordinary allocators. These
pre-allocators are typically much faster than the ordinary allocators,
but can only satisfy a limited number of requests.</p><a name="flags"></a><h3>System Flags Effecting erts_alloc</h3><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Only use these flags if you are sure what you are
doing. Unsuitable settings can cause serious performance
degradation and even a system crash at any time during
operation.</p></div><p>Memory allocator system flags have the following syntax:
<strong>+M&lt;S&gt;&lt;P&gt; &lt;V&gt;</strong>,
where <strong>&lt;S&gt;</strong> is a letter identifying a subsystem,
<strong>&lt;P&gt;</strong> is a parameter, and <strong>&lt;V&gt;</strong> is the
value to use. The flags can be passed to the Erlang emulator
(<a href="erl">erl</a>) as command-line
arguments.</p><p>System flags effecting specific allocators have an uppercase
letter as <strong>&lt;S&gt;</strong>. The following letters are used for
the allocators:</p><ul><li><strong>B: binary_alloc</strong></li><li><strong>D: std_alloc</strong></li><li><strong>E: ets_alloc</strong></li><li><strong>F: fix_alloc</strong></li><li><strong>H: eheap_alloc</strong></li><li><strong>I: literal_alloc</strong></li><li><strong>L: ll_alloc</strong></li><li><strong>M: mseg_alloc</strong></li><li><strong>R: driver_alloc</strong></li><li><strong>S: sl_alloc</strong></li><li><strong>T: temp_alloc</strong></li><li><strong>X: exec_alloc</strong></li><li><strong>Y: sys_alloc</strong></li></ul><h3>Flags for Configuration of mseg_alloc</h3><dl><dt><a name="MMamcbf"></a><strong>+MMamcbf &lt;size&gt;</strong></dt><dd> <p>Absolute maximum cache bad fit (in kilobytes). A segment in the
memory segment cache is not reused if its size exceeds the
requested size with more than the value of this
parameter. Defaults to <strong>4096</strong>.</p> </dd><dt><a name="MMrmcbf"></a><strong>+MMrmcbf &lt;ratio&gt;</strong></dt><dd> <p>Relative maximum cache bad fit (in percent). A segment in the
memory segment cache is not reused if its size exceeds the
requested size with more than relative maximum cache bad fit
percent of the requested size. Defaults to <strong>20</strong>.</p> </dd><dt><a name="MMsco"></a><strong>+MMsco true|false</strong></dt><dd> <p>Sets <a href="#MMscs">super carrier</a> only flag.
Defaults to <strong>true</strong>. When a super carrier is used and this
flag is <strong>true</strong>, <strong>mseg_alloc</strong> only creates carriers in
the super carrier. Notice that the <strong>alloc_util</strong> framework can
create <strong>sys_alloc</strong> carriers, so if you want all carriers to
be created in the super carrier, you therefore want to disable use
of <strong>sys_alloc</strong> carriers by also passing
<a href="#Musac">Musac</a>. When
the flag is <strong>false</strong>, <strong>mseg_alloc</strong> tries to create carriers
outside of the super carrier when the super carrier is full.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Setting this flag to <strong>false</strong> is not supported
on all systems. The flag is then ignored.</p></div> </dd><dt><a name="MMscrfsd"></a><strong>+MMscrfsd &lt;amount&gt;</strong></dt><dd> <p>Sets <a href="#MMscs">super carrier</a> reserved
free segment descriptors. Defaults to <strong>65536</strong>.
This parameter determines the amount of memory to reserve for
free segment descriptors used by the super carrier. If the system
runs out of reserved memory for free segment descriptors, other
memory is used. This can however cause fragmentation issues,
so you want to ensure that this never happens. The maximum amount
of free segment descriptors used can be retrieved from the
<strong>erts_mmap</strong> tuple part of the result from calling
<a href="../erts/erlang#system_info_allocator_tuple">erts/erlang#system_info_allocator_tuple</a>.</p> </dd><dt><a name="MMscrpm"></a><strong>+MMscrpm true|false</strong></dt><dd> <p>Sets <a href="#MMscs">super carrier</a> reserve
physical memory flag. Defaults to <strong>true</strong>. When this flag is
<strong>true</strong>, physical memory is reserved for the whole super
carrier at once when it is created. The reservation is after that
left unchanged. When this flag is set to <strong>false</strong>, only virtual
address space is reserved for the super carrier upon creation.
The system attempts to reserve physical memory upon carrier
creations in the super carrier, and attempt to unreserve physical
memory upon carrier destructions in the super carrier.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>What reservation of physical memory means, highly
depends on the operating system, and how it is configured. For
example, different memory overcommit settings on Linux drastically
change the behavior.</p><p>Setting this flag to <strong>false</strong> is possibly not supported on
all systems. The flag is then ignored.</p></div> </dd><dt><a name="MMscs"></a><strong>+MMscs &lt;size in MB&gt;</strong></dt><dd> <p>Sets super carrier size (in MB). Defaults to <strong>0</strong>, that is,
the super carrier is by default disabled. The super
carrier is a large continuous area in the virtual address space.
<strong>mseg_alloc</strong> always tries to create new carriers in the super
carrier if it exists. Notice that the <strong>alloc_util</strong> framework
can create <strong>sys_alloc</strong> carriers. For more information, see
<a href="#MMsco">MMsco</a>.</p> </dd><dt><a name="MMmcs"></a><strong>+MMmcs &lt;amount&gt;</strong></dt><dd> <p>Maximum cached segments. The maximum number of memory segments
stored in the memory segment cache. Valid range is <strong>[0, 30]</strong>.
Defaults to <strong>10</strong>.</p> </dd></dl><h3>Flags for Configuration of sys_alloc</h3><dl><dt><a name="MYe"></a><strong>+MYe true</strong></dt><dd> <p>Enables <strong>sys_alloc</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p><strong>sys_alloc</strong> cannot be disabled.</p></div> </dd><dt><a name="MYm"></a><strong>+MYm libc</strong></dt><dd> <p><strong>malloc</strong> library to use. Only
<strong>libc</strong> is available. <strong>libc</strong> enables the standard
<strong>libc</strong> <strong>malloc</strong> implementation. By default <strong>libc</strong>
is used.</p> </dd><dt><a name="MYtt"></a><strong>+MYtt &lt;size&gt;</strong></dt><dd> <p>Trim threshold size (in kilobytes). This is the maximum amount
of free memory at the top of the heap (allocated by
<strong>sbrk</strong>) that is kept by <strong>malloc</strong> (not
released to the operating system). When the amount of free
memory at the top of the heap exceeds the trim threshold,
<strong>malloc</strong> releases it (by calling <strong>sbrk</strong>).
Trim threshold is specified in kilobytes.
Defaults to <strong>128</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag has effect only when the emulator is linked with
the GNU C library, and uses its <strong>malloc</strong> implementation.</p></div> </dd><dt><a name="MYtp"></a><strong>+MYtp &lt;size&gt;</strong></dt><dd> <p>Top pad size (in kilobytes). This is the amount of extra
memory that is allocated by <strong>malloc</strong> when
<strong>sbrk</strong> is called to get more memory from the operating
system. Defaults to <strong>0</strong>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This flag has effect only when the emulator is linked with
the GNU C library, and uses its <strong>malloc</strong> implementation.</p></div> </dd></dl><h3>Flags for Configuration of Allocators Based on alloc_util</h3><p>If <strong>u</strong> is used as subsystem identifier (that is,
<strong>&lt;S&gt; = u</strong>), all allocators based on
<strong>alloc_util</strong> are effected. If <strong>B</strong>, <strong>D</strong>, <strong>E</strong>,
<strong>F</strong>, <strong>H</strong>, <strong>L</strong>, <strong>R</strong>, <strong>S</strong>, or <strong>T</strong> is used
as subsystem identifier, only the specific allocator identifier is
effected.</p><dl><dt><a name="M_acul"></a><strong>+M&lt;S&gt;acul &lt;utilization&gt;|de</strong> </dt><dd> <p>Abandon carrier utilization limit. A valid
<strong>&lt;utilization&gt;</strong> is an integer in the range
<strong>[0, 100]</strong> representing utilization in percent. When a
utilization value &gt; 0 is used, allocator instances
are allowed to abandon multiblock carriers. If <strong>de</strong> (default
enabled) is passed instead of a <strong>&lt;utilization&gt;</strong>,
a recommended non-zero utilization value is used. The value
chosen depends on the allocator type and can be changed between
ERTS versions. Defaults to <strong>de</strong>, but this
can be changed in the future.</p> <p>Carriers are abandoned when
memory utilization in the allocator instance falls below the
utilization value used. Once a carrier is abandoned, no new
allocations are made in it. When an allocator instance gets an
increased multiblock carrier need, it first tries to fetch an
abandoned carrier from another allocator instance. If no abandoned
carrier can be fetched, it creates a new empty carrier. When an
abandoned carrier has been fetched, it will function as an ordinary
carrier. This feature has special requirements on the
<a href="#M_as">allocation strategy</a> used. Only
the strategies <strong>aoff</strong>, <strong>aoffcbf</strong>, <strong>aoffcaobf</strong>,
<strong>ageffcaoff</strong>m, <strong>ageffcbf</strong> and <strong>ageffcaobf</strong>
support abandoned carriers.</p> <p>This feature also requires
<a href="#M_t">multiple thread specific instances</a>
to be enabled. When enabling this feature, multiple thread-specific
instances are enabled if not already enabled, and the
<strong>aoffcbf</strong> strategy is enabled if the current strategy does not
support abandoned carriers. This feature can be enabled on all
allocators based on the <strong>alloc_util</strong> framework, except
<strong>temp_alloc</strong> (which would be pointless).</p> </dd><dt><a name="M_acfml"></a><strong>+M&lt;S&gt;acfml &lt;bytes&gt;</strong> </dt><dd> <p>Abandon carrier free block min limit. A valid <strong>&lt;bytes&gt;</strong>
is a positive integer representing a block size limit. The largest
free block in a carrier must be at least <strong>bytes</strong> large, for the
carrier to be abandoned. The default is zero but can be changed
in the future.</p> <p>See also <a href="#M_acul">M_acul</a>.</p> </dd><dt><a name="M_acnl"></a><strong>+M&lt;S&gt;acnl &lt;amount&gt;</strong> </dt><dd> <p>Abandon carrier number limit. A valid <strong>&lt;amount&gt;</strong>
is a positive integer representing max number of abandoned carriers per
allocator instance. Defaults to 1000 which will practically disable
the limit, but this can be changed in the future.</p> <p>See also <a href="#M_acul">M_acul</a>.</p> </dd><dt><a name="M_as"></a> <strong>+M&lt;S&gt;as bf|aobf|aoff|aoffcbf|aoffcaobf|ageffcaoff|ageffcbf|ageffcaobf|gf|af</strong></dt><dd> <p>Allocation strategy. The following strategies are valid:</p> <ul><li><strong>bf</strong> (best fit)</li><li><strong>aobf</strong> (address order best fit)</li><li><strong>aoff</strong> (address order first fit)</li><li><strong>aoffcbf</strong> (address order first fit carrier best fit) </li><li><strong>aoffcaobf</strong> (address order first fit carrier address order best fit)</li><li><strong>ageffcaoff</strong> (age order first fit carrier address order first fit)</li><li><strong>ageffcbf</strong> (age order first fit carrier best fit) </li><li><strong>ageffcaobf</strong> (age order first fit carrier address order best fit)</li><li><strong>gf</strong> (good fit)</li><li><strong>af</strong> (a fit)</li></ul> <p>See the description of allocation strategies in section
<a href="#strategy">The alloc_util Framework</a>.</p> </dd><dt><a name="M_asbcst"></a><strong>+M&lt;S&gt;asbcst &lt;size&gt;</strong></dt><dd> <p>Absolute singleblock carrier shrink threshold (in
kilobytes). When a block located in an
<strong>mseg_alloc</strong> singleblock carrier is shrunk, the carrier
is left unchanged if the amount of unused memory is less
than this threshold, otherwise the carrier is shrunk.
See also <a href="#M_rsbcst">M_rsbcst</a>.</p> </dd><dt><a name="M_atags"></a><strong>+M&lt;S&gt;atags true|false</strong></dt><dd> <p>Adds a small tag to each allocated block that contains basic
information about what it is and who allocated it. Use the
<a href="./instrument">tools/instrument</a>
module to inspect this information.</p> <p>The runtime overhead is one word per allocation when enabled. This
may change at any time in the future.</p> <p>The default is <strong>true</strong> for <strong>binary_alloc</strong> and
<strong>driver_alloc</strong>, and <strong>false</strong> for the other allocator
types.</p> </dd><dt><a name="M_e"></a><strong>+M&lt;S&gt;e true|false</strong></dt><dd> <p>Enables allocator <strong>&lt;S&gt;</strong>.</p> </dd><dt><a name="M_lmbcs"></a><strong>+M&lt;S&gt;lmbcs &lt;size&gt;</strong></dt><dd> <p>Largest (<strong>mseg_alloc</strong>) multiblock carrier size (in kilobytes).
See the description on how sizes for <strong>mseg_alloc</strong> multiblock
carriers are decided in section
<a href="#mseg_mbc_sizes"> The alloc_util Framework</a>. On
32-bit Unix style OS this limit cannot be set &gt; 64 MB.</p> </dd><dt><a name="M_mbcgs"></a><strong>+M&lt;S&gt;mbcgs &lt;ratio&gt;</strong></dt><dd> <p>(<strong>mseg_alloc</strong>) multiblock carrier growth stages.
See the description on how sizes for <strong>mseg_alloc</strong> multiblock
carriers are decided in section
<a href="#mseg_mbc_sizes"> The alloc_util Framework</a>.</p> </dd><dt><a name="M_mbsd"></a><strong>+M&lt;S&gt;mbsd &lt;depth&gt;</strong></dt><dd> <p>Maximum block search depth. This flag has effect only if the
good fit strategy is selected for allocator
<strong>&lt;S&gt;</strong>. When the good fit strategy is used, free
blocks are placed in segregated free-lists. Each free-list
contains blocks of sizes in a specific range. The maxiumum block
search depth sets a limit on the maximum number of blocks to
inspect in a free-list during a search for suitable block
satisfying the request.</p> </dd><dt><a name="M_mmbcs"></a><strong>+M&lt;S&gt;mmbcs &lt;size&gt;</strong></dt><dd> <p>Main multiblock carrier size. Sets the size of the main
multiblock carrier for allocator <strong>&lt;S&gt;</strong>. The main
multiblock carrier is allocated through <strong>sys_alloc</strong>
and is never deallocated.</p> </dd><dt><a name="M_mmmbc"></a><strong>+M&lt;S&gt;mmmbc &lt;amount&gt;</strong></dt><dd> <p>Maximum <strong>mseg_alloc</strong> multiblock carriers. Maximum number of
multiblock carriers allocated through <strong>mseg_alloc</strong> by
allocator <strong>&lt;S&gt;</strong>. When this limit is reached,
new multiblock carriers are allocated through
<strong>sys_alloc</strong>.</p> </dd><dt><a name="M_mmsbc"></a><strong>+M&lt;S&gt;mmsbc &lt;amount&gt;</strong></dt><dd> <p>Maximum <strong>mseg_alloc</strong> singleblock carriers. Maximum number of
singleblock carriers allocated through <strong>mseg_alloc</strong> by
allocator <strong>&lt;S&gt;</strong>. When this limit is reached,
new singleblock carriers are allocated through
<strong>sys_alloc</strong>.</p> </dd><dt><a name="M_ramv"></a><strong>+M&lt;S&gt;ramv &lt;bool&gt;</strong></dt><dd> <p>Realloc always moves. When enabled, reallocate operations are
more or less translated into an allocate, copy, free sequence.
This often reduces memory fragmentation, but costs performance.</p> </dd><dt><a name="M_rmbcmt"></a><strong>+M&lt;S&gt;rmbcmt &lt;ratio&gt;</strong></dt><dd> <p>Relative multiblock carrier move threshold (in percent). When
a block located in a multiblock carrier is shrunk,
the block is moved if the ratio of the size of the returned
memory compared to the previous size is more than this threshold,
otherwise the block is shrunk at the current location.</p> </dd><dt><a name="M_rsbcmt"></a><strong>+M&lt;S&gt;rsbcmt &lt;ratio&gt;</strong></dt><dd> <p>Relative singleblock carrier move threshold (in percent). When
a block located in a singleblock carrier is shrunk to
a size smaller than the value of parameter
<a href="#M_sbct">M_sbct</a>,
the block is left unchanged in the singleblock carrier if
the ratio of unused memory is less than this threshold,
otherwise it is moved into a multiblock carrier.</p> </dd><dt><a name="M_rsbcst"></a><strong>+M&lt;S&gt;rsbcst &lt;ratio&gt;</strong></dt><dd> <p>Relative singleblock carrier shrink threshold (in
percent). When a block located in an <strong>mseg_alloc</strong>
singleblock carrier is shrunk, the carrier is left
unchanged if the ratio of unused memory is less than this
threshold, otherwise the carrier is shrunk.
See also <a href="#M_asbcst">M_asbcst</a>.</p> </dd><dt><a name="M_sbct"></a><strong>+M&lt;S&gt;sbct &lt;size&gt;</strong></dt><dd> <p>Singleblock carrier threshold (in kilobytes). Blocks larger than this
threshold are placed in singleblock carriers. Blocks
smaller than this threshold are placed in multiblock
carriers. On 32-bit Unix style OS this threshold cannot be set
&gt; 8 MB.</p> </dd><dt><a name="M_smbcs"></a><strong>+M&lt;S&gt;smbcs &lt;size&gt;</strong></dt><dd> <p>Smallest (<strong>mseg_alloc</strong>) multiblock carrier size (in
kilobytes). See the description on how sizes for <strong>mseg_alloc</strong>
multiblock carriers are decided in section
<a href="#mseg_mbc_sizes"> The alloc_util Framework</a>.</p> </dd><dt><a name="M_t"></a><strong>+M&lt;S&gt;t true|false</strong></dt><dd> <p>Multiple, thread-specific instances of the allocator.
This option has only effect on the runtime system
with SMP support. Default behavior on the runtime system with
SMP support is <strong>NoSchedulers+1</strong> instances. Each scheduler
uses a lock-free instance of its own and other threads use
a common instance.</p> <p>Before ERTS 5.9 it was possible to configure
a smaller number of thread-specific instances than schedulers.
This is, however, not possible anymore.</p> </dd></dl><h3>Flags for Configuration of alloc_util</h3><p>All allocators based on <strong>alloc_util</strong> are effected.</p><dl><dt><a name="Muycs"></a><strong>+Muycs &lt;size&gt;</strong></dt><dd> <p><strong>sys_alloc</strong> carrier size. Carriers allocated through
<strong>sys_alloc</strong> are allocated in sizes that are
multiples of the <strong>sys_alloc</strong> carrier size. This is not
true for main multiblock carriers and carriers allocated
during a memory shortage, though.</p> </dd><dt><a name="Mummc"></a><strong>+Mummc &lt;amount&gt;</strong></dt><dd> <p>Maximum <strong>mseg_alloc</strong> carriers. Maximum number of carriers
placed in separate memory segments. When this limit is
reached, new carriers are placed in memory retrieved from
<strong>sys_alloc</strong>.</p> </dd><dt><a name="Musac"></a><strong>+Musac &lt;bool&gt;</strong></dt><dd> <p>Allow <strong>sys_alloc</strong> carriers. Defaults to <strong>true</strong>.
If set to <strong>false</strong>, <strong>sys_alloc</strong> carriers are never
created by allocators using the <strong>alloc_util</strong> framework.</p> </dd></dl><h3>Special Flag for literal_alloc</h3><dl><dt><a name="MIscs"></a><strong>+MIscs &lt;size in MB&gt;</strong></dt><dd> <p><strong>literal_alloc</strong> super carrier size (in MB). The amount of
<em>virtual</em> address space reserved for literal terms in
Erlang code on 64-bit architectures. Defaults to <strong>1024</strong>
(that is, 1 GB), which is usually sufficient.
The flag is ignored on 32-bit architectures.</p> </dd></dl><h3>Instrumentation Flags</h3><dl><dt><strong>+M&lt;S&gt;atags</strong></dt><dd> <p>Adds a small tag to each allocated block that contains basic
information about what it is and who allocated it. See
<a href="#M_atags">M_atags</a> for a
more complete description.</p> </dd><dt><a name="Mit"></a><strong>+Mit X</strong></dt><dd> <p>Reserved for future use. Do <em>not</em> use this flag.</p> </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>When instrumentation of the emulator is enabled, the emulator
uses more memory and runs slower.</p></div><h3>Other Flags</h3><dl><dt><a name="Mea"></a><strong>+Mea min|max|r9c|r10b|r11b|config</strong></dt><dd> <p>Options:</p> <dl><dt><strong>min</strong></dt><dd> <p>Disables all allocators that can be disabled.</p> </dd><dt><strong>max</strong></dt><dd> <p>Enables all allocators (default).</p> </dd><dt><strong>r9c|r10b|r11b</strong></dt><dd> <p>Configures all allocators as they were configured in respective
Erlang/OTP release. These will eventually be removed.</p> </dd><dt><strong>config</strong></dt><dd> <p>Disables features that cannot be enabled while creating an
allocator configuration with
<a href="./erts_alloc_config">runtime_tools/erts_alloc_config</a>.</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>This option is to be used only while running
<strong>erts_alloc_config(3)</strong>, <em>not</em> when
using the created configuration.</p></div> </dd></dl> </dd><dt><a name="Mlpm"></a><strong>+Mlpm all|no</strong></dt><dd> <p>Lock physical memory. Defaults to <strong>no</strong>, that is,
no physical memory is locked. If set to <strong>all</strong>, all
memory mappings made by the runtime system are locked into
physical memory. If set to <strong>all</strong>, the runtime system fails to
start if this feature is not supported, the user has not got enough
privileges, or the user is not allowed to lock enough physical
memory. The runtime system also fails with an out of memory
condition if the user limit on the amount of locked memory is
reached.</p> </dd></dl><h3>Notes</h3><p>Only some default values have been presented here. For information
about the currently used settings and the current status of the
allocators, see
<a href="../erts/erlang#system_info_allocator">erts/erlang#system_info_allocator</a> and
<a href="../erts/erlang#system_info_allocator_tuple">erts/erlang#system_info_allocator_tuple</a>.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Most of these flags are highly implementation-dependent and
can be changed or removed without prior notice.</p><p><strong>erts_alloc</strong> is not obliged to strictly use the settings that
have been passed to it (it can even ignore them).</p></div><p>The <a href="./erts_alloc_config">runtime_tools/erts_alloc_config</a>
tool can be used to aid creation of an
<strong>erts_alloc</strong> configuration that is suitable for a limited
number of runtime scenarios.</p><h3>See Also</h3><p><a href="erl">erl</a>,
<a href="erlang">erlang</a>,
<a href="./erts_alloc_config">runtime_tools/erts_alloc_config</a>,
<a href="./instrument">tools/instrument</a></p><h2>escript</h2><p>Erlang scripting support</p><p><strong>escript</strong> provides support for running short Erlang programs
without having to compile them first, and an easy way to retrieve the
command-line arguments.It is possible to bundle <strong>escript</strong>(s) with an Erlang
runtime system to make it self-sufficient and relocatable. In such
a standalone system, the <strong>escript</strong>(s) should be located in
the top <strong>bin</strong> directory of the standalone system and given
<strong>.escript</strong> as file extension. Further the (built-in)
<strong>escript</strong> program should be copied to the same directory and
given the scripts original name (without the <strong>.escript</strong>
extension). This will enable use of the bundled Erlang runtime
system.The (built-in) <strong>escript</strong> program first determines which
Erlang runtime system to use and then starts it to execute your
script. Usually the runtime system is located in the same Erlang
installation as the <strong>escript</strong> program itself. But for
standalone systems with one or more escripts it may be the case
that the <strong>escript</strong> program in your path actually starts the
runtime system bundled with the escript. This is intentional, and
typically happens when the standalone system <strong>bin</strong> directory is not
in the execution path (as it may cause its <strong>erl</strong> program to
override the desired one) and the <strong>escript</strong>(s) are referred to via
symbolic links from a <strong>bin</strong> directory in the path.</p><h2>Functions</h2><h3>script-name script-arg1 script-arg2...</h3><h3>escript escript-flags script-name script-arg1 script-arg2...</h3><p>Run a script written in Erlang.</p><p><strong>escript</strong> runs a script written in Erlang.</p><p>Example:</p><pre>
$ <span class="input">chmod u+x factorial</span>
$ <span class="input">cat factorial</span>
#!/usr/bin/env escript
%% -*- erlang -*-
%%! -smp enable -sname factorial -mnesia debug verbose
main([String]) -&gt;
    try
        N = list_to_integer(String),
        F = fac(N),
        io:format("factorial ~w = ~w\n", [N,F])
    catch
        _:_ -&gt;
            usage()
    end;
main(_) -&gt;
    usage().

usage() -&gt;
    io:format("usage: factorial integer\n"),
    halt(1).

fac(0) -&gt; 1;
fac(N) -&gt; N * fac(N-1).
$ <span class="input">./factorial 5</span>
factorial 5 = 120
$ <span class="input">./factorial</span>
usage: factorial integer
$ <span class="input">./factorial five</span>
usage: factorial integer</pre><p>The header of the Erlang script in the example differs from
a normal Erlang module. The first line is intended to be the
interpreter line, which invokes <strong>escript</strong>.</p><p>However, if you invoke the <strong>escript</strong> as follows,
the contents of the first line does not matter, but it
cannot contain Erlang code as it will be ignored:</p><pre>
$ <span class="input">escript factorial 5</span></pre><p>The second line in the example contains an optional
directive to the <strong>Emacs</strong> editor, which causes it to
enter the major mode for editing Erlang source files. If the
directive is present, it must be located on the second
line.</p><p>If a comment selecting the <a href="../stdlib/epp#encoding">encoding</a> exists, it can be
located on the second line.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>The encoding specified by the above mentioned comment
applies to the script itself. The encoding of the
I/O-server, however, must be set explicitly as follows:</p><pre><code class="">
io:setopts([{encoding, unicode}])</code></pre><p>The default encoding of the I/O-server for <strong>standard_io</strong>
is <strong>latin1</strong>, as the script runs in a non-interactive terminal
(see section
<a href="../stdlib/unicode_usage#unicode_options_summary"> Summary of Options</a>) in the STDLIB User's Guide.</p></div><p>On the third line (or second line depending on the presence
of the Emacs directive), arguments can be specified to
the emulator, for example:</p><pre>
%%! -smp enable -sname factorial -mnesia debug verbose</pre><p>Such an argument line must start with <strong>%%!</strong> and the
remaining line is interpreted as arguments to the emulator.</p><p>If you know the location of the <strong>escript</strong> executable, the first
line can directly give the path to <strong>escript</strong>, for example:</p><pre>
#!/usr/local/bin/escript</pre><p>As any other type of scripts, Erlang scripts do not work on
Unix platforms if the execution bit for the script file is not set.
(To turn on the execution bit, use <strong>chmod +x script-name</strong>.)</p><p>The remaining Erlang script file can either contain
Erlang <em>source code</em>, an <em>inlined beam file</em>, or an
<em>inlined archive file</em>.</p><p>An Erlang script file must always contain the <strong>main/1</strong>
function. When the script is run, the
<strong>main/1</strong> function is called with a list
of strings representing the arguments specified to the script (not
changed or interpreted in any way).</p><p>If the <strong>main/1</strong> function in the script returns successfully,
the exit status for the script is <strong>0</strong>. If an exception is
generated during execution, a short message is printed and the script
terminates with exit status <strong>127</strong>.</p><p>To return your own non-zero exit code, call <strong>halt(ExitCode)</strong>,
for example:</p><pre>
halt(1).</pre><p>
To retrieve the pathname of the script, call
<a href="#script_name-0">script_name-0</a>
from your script
(the pathname is usually, but not always, absolute).</p><p>If the file contains source code (as in the example above),
it is processed by the
<a href="./epp">stdlib/epp</a> preprocessor.
This means that you, for example, can use predefined macros
(such as <strong>?MODULE</strong>) and include directives like
the <strong>-include_lib</strong> directive. For example, use</p><pre>
-include_lib("kernel/include/file.hrl").</pre><p>to include the record definitions for the records used by function
<a href="../kernel/file#read_link_info/1">kernel/file#read_link_info/1</a>. You can also select
encoding by including an encoding comment here, but if
a valid encoding comment exists on the second line, it takes
precedence.</p><p>The script is checked for syntactic and semantic
correctness before it is run. If there are warnings (such as
unused variables), they are printed and the script will
still be run. If there are errors, they are printed and
the script will not be run and its exit status is
<strong>127</strong>.</p><p>Both the module declaration and the export declaration of
the <strong>main/1</strong> function are optional.</p><p>By default, the script will be interpreted. You can force
it to be compiled by including the following line somewhere
in the script file:</p><pre>
-mode(compile).</pre><p>Execution of interpreted code is slower than compiled code.
If much of the execution takes place in interpreted code, it
can be worthwhile to compile it, although the compilation
itself takes a little while. Also, <strong>native</strong> can be supplied
instead of <strong>compile</strong>. This compiles the script
using the native flag and may or may not be worthwhile
depending on the escript characteristics.</p><p>As mentioned earlier, a script can
contains precompiled <strong>beam</strong> code. In a precompiled
script, the interpretation of the script header is
the same as in a script containing source code. This means
that you can make a <strong>beam</strong> file executable by
prepending the file with the lines starting with <strong>#!</strong>
and <strong>%%!</strong> mentioned above. In a precompiled script, the
<strong>main/1</strong> function must be exported.</p><p>Another option is to have an entire
Erlang archive in the script. In an archive script, the
interpretation of the script header is the same as
in a script containing source code. This means that you can
make an archive file executable by prepending the file with
the lines starting with <strong>#!</strong> and <strong>%%!</strong> mentioned
above. In an archive script, the <strong>main/1</strong> function must
be exported. By default the <strong>main/1</strong> function in the
module with the same name as the basename of the
<strong>escript</strong> file is invoked. This behavior can be
overridden by setting flag <strong>-escript main Module</strong>
as one of the emulator flags. <strong>Module</strong> must be the
name of a module that has an exported <strong>main/1</strong>
function. For more information about archives and code loading, see
<a href="./code">kernel/code</a>.</p><p>It is often very convenient to have a header in
the escript, especially on Unix platforms. However, the header
is optional, so you directly can "execute"
an Erlang module, Beam file, or archive file without adding
any header to them. But then you have to invoke the script
as follows:</p><pre>
$ <span class="input">escript factorial.erl 5</span>
factorial 5 = 120
$ <span class="input">escript factorial.beam 5</span>
factorial 5 = 120
$ <span class="input">escript factorial.zip 5</span>
factorial 5 = 120</pre><a name="create-2"></a><h3>escript:create(FileOrBin, Sections) -&gt; ok | {ok, binary()} |
        {error, term()}</h3><p>Create an escript.</p><ul><li><span class="v">FileOrBin = filename() | 'binary'</span></li><li><span class="v">Sections = [Header] Body | Body</span></li><li><span class="v">Header = shebang | {shebang, Shebang} | comment | {comment, Comment} | {emu_args, EmuArgs}</span></li><li><span class="v">Shebang = string() | 'default' | 'undefined'</span></li><li><span class="v">Comment = string() | 'default' | 'undefined'</span></li><li><span class="v">EmuArgs = string() | 'undefined'</span></li><li><span class="v">Body = {source, SourceCode} | {beam, BeamCode} | {archive, ZipArchive} | {archive, ZipFiles, ZipOptions}</span></li><li><span class="v">SourceCode = BeamCode = file:filename() | binary()</span></li><li><span class="v">ZipArchive =  | binary()</span></li><li><span class="v">ZipFiles = [ZipFile]</span></li><li><span class="v">ZipFile = file:filename() | {file:filename(), binary()} | {file:filename(), binary(), file:file_info()}</span></li><li><span class="v">ZipOptions = []</span></li></ul><p>
Creates an escript from a list of sections. The
sections can be specified in any order. An escript begins with an
optional <strong>Header</strong> followed by a mandatory <strong>Body</strong>. If
the header is present, it does always begin with a
<strong>shebang</strong>, possibly followed by a <strong>comment</strong> and
<strong>emu_args</strong>. The <strong>shebang</strong> defaults to
<strong>"/usr/bin/env escript"</strong>. The <strong>comment</strong> defaults to
<strong>"This is an -*- erlang -*- file"</strong>. The created escript
can either be returned as a binary or written to file.</p><p>As an example of how the function can be used, we create an
interpreted escript that uses <strong>emu_args</strong> to set some emulator
flag. In this case, it happens to disable the <strong>smp_support</strong>. We
also extract the different sections from the newly created script:</p><pre>
&gt; <span class="input">Source = "%% Demo\nmain(_Args) -&gt;\n    io:format(erlang:system_info(smp_support)).\n".</span>
"%% Demo\nmain(_Args) -&gt;\n    io:format(erlang:system_info(smp_support)).\n"
&gt; <span class="input">io:format("~s\n", [Source]).</span>
%% Demo
main(_Args) -&gt;
    io:format(erlang:system_info(smp_support)).

ok
&gt; <span class="input">{ok, Bin} = escript:create(binary, [shebang, comment, {emu_args, "-smp disable"}, {source, list_to_binary(Source)}]).</span>
{ok,&lt;&lt;"#!/usr/bin/env escript\n%% This is an -*- erlang -*- file\n%%!-smp disabl"...&gt;&gt;}
&gt; <span class="input">file:write_file("demo.escript", Bin).</span>
ok
&gt; <span class="input">os:cmd("escript demo.escript").</span>
"false"
&gt; <span class="input">escript:extract("demo.escript", []).</span>
{ok,[{shebang,default}, {comment,default}, {emu_args,"-smp disable"},
     {source,&lt;&lt;"%% Demo\nmain(_Args) -&gt;\n    io:format(erlang:system_info(smp_su"...&gt;&gt;}]}</pre><p>An escript without header can be created as follows:</p><pre>
&gt; <span class="input">file:write_file("demo.erl", ["%% demo.erl\n-module(demo).\n-export([main/1]).\n\n", Source]).</span>
ok
&gt; <span class="input">{ok, _, BeamCode} = compile:file("demo.erl", [binary, debug_info]).</span>
{ok,demo,
    &lt;&lt;70,79,82,49,0,0,2,208,66,69,65,77,65,116,111,109,0,0,0,
      79,0,0,0,9,4,100,...&gt;&gt;}
&gt; <span class="input">escript:create("demo.beam", [{beam, BeamCode}]).</span>
ok
&gt; <span class="input">escript:extract("demo.beam", []).</span>
{ok,[{shebang,undefined}, {comment,undefined}, {emu_args,undefined},
     {beam,&lt;&lt;70,79,82,49,0,0,3,68,66,69,65,77,65,116,
             111,109,0,0,0,83,0,0,0,9,...&gt;&gt;}]}
&gt; <span class="input">os:cmd("escript demo.beam").</span>
"true"</pre><p>Here we create an archive script containing both Erlang
code and Beam code, then we iterate over all files in
the archive and collect their contents and some information about
them:</p><pre>
&gt; <span class="input">{ok, SourceCode} = file:read_file("demo.erl").</span>
{ok,&lt;&lt;"%% demo.erl\n-module(demo).\n-export([main/1]).\n\n%% Demo\nmain(_Arg"...&gt;&gt;}
&gt; <span class="input">escript:create("demo.escript", [shebang, {archive, [{"demo.erl", SourceCode}, {"demo.beam", BeamCode}], []}]).</span>
ok
&gt; <span class="input">{ok, [{shebang,default}, {comment,undefined}, {emu_args,undefined}, {archive, ArchiveBin}]} = escript:extract("demo.escript", []).</span>
{ok,[{shebang,default}, {comment,undefined}, {emu_args,undefined},
     {{archive,&lt;&lt;80,75,3,4,20,0,0,0,8,0,118,7,98,60,105,
                152,61,93,107,0,0,0,118,0,...&gt;&gt;}]}
&gt; <span class="input">file:write_file("demo.zip", ArchiveBin).</span>
ok
&gt; <span class="input">zip:foldl(fun(N, I, B, A) -&gt; [{N, I(), B()} | A] end, [], "demo.zip").</span>
{ok,[{"demo.beam",
      {file_info,748,regular,read_write,
                 {{2010,3,2},{0,59,22}},
                 {{2010,3,2},{0,59,22}},
                 {{2010,3,2},{0,59,22}},
                 54,1,0,0,0,0,0},
      &lt;&lt;70,79,82,49,0,0,2,228,66,69,65,77,65,116,111,109,0,0,0,
        83,0,0,...&gt;&gt;},
     {"demo.erl",
      {file_info,118,regular,read_write,
                 {{2010,3,2},{0,59,22}},
                 {{2010,3,2},{0,59,22}},
                 {{2010,3,2},{0,59,22}},
                 54,1,0,0,0,0,0},
      &lt;&lt;"%% demo.erl\n-module(demo).\n-export([main/1]).\n\n%% Demo\nmain(_Arg"...&gt;&gt;}]}</pre><a name="extract-2"></a><h3>escript:extract(File, Options) -&gt; {ok, Sections} |
        {error, term()}</h3><p>Parse an escript and extract its sections.</p><ul><li><span class="v">File = filename()</span></li><li><span class="v">Options = [] | [compile_source]</span></li><li><span class="v">Sections = Headers Body</span></li><li><span class="v">Headers =  {shebang, Shebang} {comment, Comment} {emu_args, EmuArgs}</span></li><li><span class="v">Shebang = string() | 'default' | 'undefined'</span></li><li><span class="v">Comment = string() | 'default' | 'undefined'</span></li><li><span class="v">EmuArgs = string() | 'undefined'</span></li><li><span class="v">Body = {source, SourceCode} | {source, BeamCode} | {beam, BeamCode} | {archive, ZipArchive}</span></li><li><span class="v">SourceCode = BeamCode = ZipArchive = binary()</span></li></ul><p>
Parses an escript and extracts its sections.
This is the reverse of
<a href="#create-2">create-2</a>.
</p><p>All sections are returned even if they do not exist in the
escript. If a particular section happens to have the same
value as the default value, the extracted value is set to the
atom <strong>default</strong>. If a section is missing, the extracted
value is set to the atom <strong>undefined</strong>.</p><p>Option <strong>compile_source</strong> only affects the result if
the escript contains <strong>source</strong> code. In this case the
Erlang code is automatically compiled and <strong>{source, BeamCode}</strong> is returned instead of <strong>{source, SourceCode}</strong>.</p><p>Example:</p><pre>
&gt; <span class="input">escript:create("demo.escript", [shebang, {archive, [{"demo.erl", SourceCode}, {"demo.beam", BeamCode}], []}]).</span>
ok
&gt; <span class="input">{ok, [{shebang,default}, {comment,undefined}, {emu_args,undefined}, {archive, ArchiveBin}]} = escript:extract("demo.escript", []).</span>
{ok,[{{archive,&lt;&lt;80,75,3,4,20,0,0,0,8,0,118,7,98,60,105,
                152,61,93,107,0,0,0,118,0,...&gt;&gt;}
     {emu_args,undefined}]}</pre><a name="script_name-0"></a><h3>escript:script_name() -&gt; File</h3><p>Return the name of an escript.</p><ul><li><span class="v">File = filename()</span></li></ul><p>
Returns the name of the escript that is executed.
If the function is invoked outside the context
of an escript, the behavior is undefined.</p><h3>Options Accepted By escript</h3><dl><dt><strong>-c</strong></dt><dd>Compiles the escript regardless of the value of the mode attribute. </dd><dt><strong>-d</strong></dt><dd>Debugs the escript. Starts the debugger, loads the module containing the <strong>main/1</strong> function into the debugger, sets a breakpoint in <strong>main/1</strong>, and invokes <strong>main/1</strong>. If the module is precompiled, it must be explicitly compiled with option <strong>debug_info</strong>. </dd><dt><strong>-i</strong></dt><dd>Interprets the escript regardless of the value of the mode attribute. </dd><dt><strong>-s</strong></dt><dd>Performs a syntactic and semantic check of the script file. Warnings and errors (if any) are written to the standard output, but the script will not be run. The exit status is <strong>0</strong> if any errors are found, otherwise <strong>127</strong>. </dd><dt><strong>-n</strong></dt><dd>Compiles the escript using flag <strong>+native</strong>. </dd></dl><h2>init</h2><p>Coordination of system startup.</p><p>This module is preloaded and contains the code for
the <strong>init</strong> system process that coordinates the startup of
the system. The first function evaluated at startup is
<strong>boot(BootArgs)</strong>, where <strong>BootArgs</strong> is a list of
command-line arguments supplied to the Erlang runtime system from
the local operating system; see
<a href="./erl">erts/erl</a>.<strong>init</strong> reads the boot script, which contains instructions on
how to initiate the system. For more information about boot scripts, see
<a href="./script">sasl/script</a>.<strong>init</strong> also contains functions to restart, reboot, and stop
the system.</p><h2>Functions</h2><h3>boot/1</h3><p>Start the Erlang runtime system.</p><p>Starts the Erlang runtime system. This function is called
when the emulator is started and coordinates system startup.</p><p><strong><span class="anno">BootArgs</span></strong> are all command-line arguments except
the emulator flags, that is, flags and plain arguments; see
<a href="./erl">erts/erl</a>.</p><p><strong>init</strong> interprets some of the flags, see section
<a href="#flags">Command-Line Flags</a> below.
The remaining flags ("user flags") and plain arguments are
passed to the <strong>init</strong> loop and can be retrieved by calling
<a href="#get_arguments/0">get_arguments/0</a>
and <a href="#get_plain_arguments/0">get_plain_arguments/0</a>, respectively.</p><h3>get_argument/1</h3><p>Get the values associated with a command-line user flag. </p><p>Returns all values associated with the command-line user flag
<strong><span class="anno">Flag</span></strong>. If <strong><span class="anno">Flag</span></strong> is provided
several times, each <strong><span class="anno">Values</span></strong> is returned in
preserved order. Example:</p><pre>
% <span class="input">erl -a b c -a d</span>
...
1&gt; <span class="input">init:get_argument(a).</span>
{ok,[["b","c"],["d"]]}</pre><p>The following flags are defined
automatically and can be retrieved using this function:</p><dl><dt><strong>root</strong></dt><dd> <p>The installation directory of Erlang/OTP, <strong>$ROOT</strong>:</p> <pre>
2&gt; <span class="input">init:get_argument(root).</span>
{ok,[["/usr/local/otp/releases/otp_beam_solaris8_r10b_patched"]]}</pre> </dd><dt><strong>progname</strong></dt><dd> <p>The name of the program which started Erlang:</p> <pre>
3&gt; <span class="input">init:get_argument(progname).</span>
{ok,[["erl"]]}</pre> </dd><dt><strong>home</strong></dt><dd> <p>The home directory:</p> <pre>
4&gt; <span class="input">init:get_argument(home).</span>
{ok,[["/home/harry"]]}</pre> </dd></dl><p>Returns <strong>error</strong> if no value is associated with <strong>Flag</strong>.</p><h3>get_arguments/0</h3><p>Get all command-line user flags.</p><p>Returns all command-line flags and the system-defined flags, see
<a href="#get_argument/1">get_argument/1</a>.</p><h3>get_plain_arguments/0</h3><p>Get all non-flag command-line arguments.</p><p>Returns any plain command-line arguments as a list of strings
(possibly empty).</p><h3>get_status/0</h3><p>Get system status information.</p><ul><li>internal_status</li></ul><p>The current status of the <strong>init</strong> process can be
inspected. During system startup (initialization),
<strong><span class="anno">InternalStatus</span></strong> is <strong>starting</strong>, and
<strong><span class="anno">ProvidedStatus</span></strong> indicates how far the boot
script has been interpreted. Each <strong>{progress, Info}</strong> term
interpreted in the boot script affects
<strong><span class="anno">ProvidedStatus</span></strong>, that is,
<strong><span class="anno">ProvidedStatus</span></strong> gets the value of <strong>Info</strong>.</p><h3>reboot/0</h3><p>Take down and restart an Erlang node smoothly.</p><p>All applications are taken down smoothly, all code is
unloaded, and all ports are closed before the system
terminates. If command-line flag <strong>-heart</strong> was specified,
the <strong>heart</strong> program tries to reboot the system. For more
information, see
<a href="./heart">kernel/heart</a>.</p><p>To limit the shutdown time, the time <strong>init</strong> is allowed
to spend taking down applications, command-line flag
<strong>-shutdown_time</strong> is to be used.</p><h3>restart/0</h3><p>Restart the running Erlang node.</p><p>The system is restarted <em>inside</em> the running Erlang
node, which means that the emulator is not restarted. All
applications are taken down smoothly, all code is unloaded,
and all ports are closed before the system is booted again in
the same way as initially started. The same <strong>BootArgs</strong>
are used again.</p><p>To limit the shutdown time, the time <strong>init</strong> is allowed
to spend taking down applications, command-line flag
<strong>-shutdown_time</strong> is to be used.</p><h3>script_id/0</h3><p>Get the identity of the used boot script.</p><p>Gets the identity of the boot script used to boot the system.
<strong><span class="anno">Id</span></strong> can be any Erlang term. In the delivered boot
scripts, <strong><span class="anno">Id</span></strong> is <strong>{Name, Vsn}</strong>. <strong>Name</strong>
and <strong>Vsn</strong> are strings.</p><h3>stop/0</h3><p>Take down an Erlang node smoothly.</p><p>The same as
<a href="#stop/1">stop/1</a>.</p><h3>stop/1</h3><p>Take down an Erlang node smoothly.</p><p>All applications are taken down smoothly, all code is
unloaded, and all ports are closed before the system
terminates by calling <strong>halt(<span class="anno">Status</span>)</strong>. If
command-line flag <strong>-heart</strong> was specified, the <strong>heart</strong>
program is terminated before the Erlang node terminates.
For more information, see
<a href="./heart">kernel/heart</a>.</p><p>To limit the shutdown time, the time <strong>init</strong> is allowed
to spend taking down applications, command-line flag
<strong>-shutdown_time</strong> is to be used.</p><a name="flags"></a><h3>Command-Line Flags</h3><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>The support for loading of code from archive files is
experimental. The only purpose of releasing it before it is ready
is to obtain early feedback. The file format, semantics,
interfaces, and so on, can  be changed in a future release. The
<strong>-code_path_choice</strong> flag is also experimental.</p></div><p>The <strong>init</strong> module interprets the following command-line flags:</p><dl><dt><strong>--</strong></dt><dd> <p>Everything following <strong>--</strong> up to the next flag is
considered plain arguments and can be retrieved using
<a href="#get_plain_arguments/0">get_plain_arguments/0</a>.</p> </dd><dt><strong>-code_path_choice Choice</strong></dt><dd> <p>Can be set to <strong>strict</strong> or <strong>relaxed</strong>. It controls how each
directory in the code path is to be interpreted:</p> <ul><li> <p>Strictly as it appears in the <strong>boot script</strong>, or</p> </li><li> <p><strong>init</strong> is to be more relaxed and try to find a suitable
directory if it can choose from a regular <strong>ebin</strong> directory
and an <strong>ebin</strong> directory in an archive file.</p> </li></ul> <p>This flag is particular
useful when you want to elaborate with code loading from
archives without editing the <strong>boot script</strong>. For more
information about interpretation of boot scripts, see
<a href="./script">sasl/script</a>.
The flag has also a similar effect on how the code server works; see
<a href="./code">kernel/code</a>.</p> </dd><dt><strong>-epmd_module Module</strong></dt><dd> <p>Specifies the module to use for registration and lookup of
node names.  Defaults to <strong>erl_epmd</strong>.</p> </dd><dt><strong>-eval Expr</strong></dt><dd> <p>Scans, parses, and evaluates an arbitrary expression
<strong>Expr</strong> during system initialization. If any of these
steps fail (syntax error, parse error, or exception during
evaluation), Erlang stops with an error message. In the following
example Erlang is used as a hexadecimal calculator:</p> <pre>
% <span class="input">erl -noshell -eval 'R = 16#1F+16#A0, io:format("~.16B~n", [R])' \\</span>
<span class="input">-s erlang halt</span>
BF</pre> <p>If multiple <strong>-eval</strong> expressions are specified, they
are evaluated sequentially in the order specified.
<strong>-eval</strong> expressions are evaluated sequentially with
<strong>-s</strong> and <strong>-run</strong> function calls (this also in
the order specified). As with <strong>-s</strong> and <strong>-run</strong>, an
evaluation that does not terminate blocks the system
initialization process.</p> </dd><dt><strong>-extra</strong></dt><dd> <p>Everything following <strong>-extra</strong> is considered plain
arguments and can be retrieved using
<a href="#get_plain_arguments/0">get_plain_arguments/0</a>.</p> </dd><dt><strong>-run Mod [Func [Arg1, Arg2, ...]]</strong></dt><dd> <p>Evaluates the specified function call during system
initialization. <strong>Func</strong> defaults to <strong>start</strong>. If no
arguments are provided, the function is assumed to be of arity
0. Otherwise it is assumed to be of arity 1, taking the list
<strong>[Arg1,Arg2,...]</strong> as argument. All arguments are passed
as strings. If an exception is raised, Erlang stops with an
error message.</p> <p>Example:</p> <pre>
% <span class="input">erl -run foo -run foo bar -run foo bar baz 1 2</span></pre> <p>This starts the Erlang runtime system and evaluates
the following functions:</p> <pre><code class="">
foo:start()
foo:bar()
foo:bar(["baz", "1", "2"]).</code></pre> <p>The functions are executed sequentially in an initialization
process, which then terminates normally and passes control to
the user. This means that a <strong>-run</strong> call that does not
return blocks further processing; to avoid this, use
some variant of <strong>spawn</strong> in such cases.</p> </dd><dt><strong>-s Mod [Func [Arg1, Arg2, ...]]</strong></dt><dd> <p>Evaluates the specified function call during system
initialization. <strong>Func</strong> defaults to <strong>start</strong>. If no
arguments are provided, the function is assumed to be of arity
0. Otherwise it is assumed to be of arity 1, taking the list
<strong>[Arg1,Arg2,...]</strong> as argument. All arguments are passed
as atoms. If an exception is raised, Erlang stops with an
error message.</p> <p>Example:</p> <pre>
% <span class="input">erl -s foo -s foo bar -s foo bar baz 1 2</span></pre> <p>This starts the Erlang runtime system and evaluates
the following functions:</p> <pre><code class="">
foo:start()
foo:bar()
foo:bar([baz, '1', '2']).</code></pre> <p>The functions are executed sequentially in an initialization
process, which then terminates normally and passes control to
the user. This means that a <strong>-s</strong> call that does not
return blocks further processing; to avoid this, use
some variant of <strong>spawn</strong> in such cases.</p> <p>Because of the limited length of atoms, it is recommended to
use <strong>-run</strong> instead.</p> </dd></dl><h3>Example</h3><pre>
% <span class="input">erl -- a b -children thomas claire -ages 7 3 -- x y</span>
...

1&gt; <span class="input">init:get_plain_arguments().</span>
["a","b","x","y"]
2&gt; <span class="input">init:get_argument(children).</span>
{ok,[["thomas","claire"]]}
3&gt; <span class="input">init:get_argument(ages).</span>
{ok, [["7","3"]]}
4&gt; <span class="input">init:get_argument(silly).</span>
error</pre><h3>See Also</h3><p><a href="erl_prim_loader">erl_prim_loader</a>, 
<a href="./heart">kernel/heart</a></p><h2>net</h2><p>Network interface.</p><p>This module provides an API for the network interface.</p><h2>Data Types</h2><span class="name">address_info</span><span class="name">name_info</span><span class="name">name_info_flags</span><span class="name">name_info_flag</span><span class="name">name_info_flag_ext</span><span class="name">network_interface_name</span><span class="name">network_interface_index</span><h2>Functions</h2><h3>gethostname/0</h3><p>Get hostname.</p><p>Returns the name of the current host.</p><h3>getnameinfo/1</h3><h3>getnameinfo/2</h3><p>Address-to-name transaltion.</p><p>Address-to-name translation in a protocol-independant manner.</p><p>This function is the inverse of
<a href="#getaddrinfo/1">getaddrinfo/1</a>.
It converts a socket address to a corresponding host and service.</p><h3>getaddrinfo/1</h3><h3>getaddrinfo/2</h3><h3>getaddrinfo/2</h3><h3>getaddrinfo/2</h3><p>Network address and service transation.</p><p>Network address and service translation.</p><p>This function is the inverse of
<a href="#getnameinfo/1">getnameinfo/1</a>.
It converts host and service to a corresponding socket address.</p><p>One of the <strong>Host</strong> and <strong>Service</strong> may be <strong>undefined</strong>
but <em>not</em> both.</p><h3>if_name2index/1</h3><p>Mappings between network interface names and indexes.</p><p>Mappings between network interface names and indexes.</p><h3>if_index2name/1</h3><p>Mappings between network interface index and names.</p><p>Mappings between network interface index and names.</p><h3>if_names/0</h3><p>Get network interface names and indexes.</p><p>Get network interface names and indexes.</p><h2>persistent_term</h2><p>Persistent terms.</p><p>This module is similar to <a href="./ets">stdlib/ets</a> in that it provides a
storage for Erlang terms that can be accessed in constant time,
but with the difference that <strong>persistent_term</strong> has been
highly optimized for reading terms at the expense of writing and
updating terms. When a persistent term is updated or deleted, a
global garbage collection pass is run to scan all processes for
the deleted term, and to copy it into each process that still uses
it. Therefore, <strong>persistent_term</strong> is suitable for storing
Erlang terms that are frequently accessed but never or
infrequently updated.Term lookup (using <a href="#get/1">get/1</a>), is done in constant time
and without taking any locks, and the term is <span class="strong">not</span>
copied to the heap (as is the case with terms stored in ETS
tables).Storing or updating a term (using <a href="#put/2">put/2</a>) is proportional to the
number of already created persistent terms because the hash table
holding the keys will be copied. In addition, the term itself will
be copied.When a (complex) term is deleted (using <a href="#erase/1">erase/1</a>) or replaced by another
(using <a href="#put/2">put/2</a>), a global
garbage collection is initiated. It works like this:<ul><li><p>All processes in the system will be scheduled to run a
scan of their heaps for the term that has been deleted.  While
such scan is relatively light-weight, if there are many
processes, the system can become less responsive until all
process have scanned their heaps.</p></li><li><p>If the deleted term (or any part of it) is still used
by a process, that process will do a major (fullsweep) garbage
collection and copy the term into the process. However, at most
two processes at a time will be scheduled to do that kind of
garbage collection.</p></li></ul>Deletion of atoms and other terms that fit in one machine word
is specially optimized to avoid doing a global GC. It is still not
recommended to update persistent terms with such values too
frequently because the hash table holding the keys is copied every
time a persistent term is updated.Some examples are suitable uses for persistent terms are:<ul><li><p>Storing of configuration data that must be easily
accessible by all processes.</p></li><li><p>Storing of references for NIF resources.</p></li><li><p>Storing of references for efficient counters.</p></li><li><p>Storing an atom to indicate a logging level or whether debugging
is turned on.</p></li></ul></p><h3>Storing Huge Persistent Terms</h3><p>The current implementation of persistent terms uses the literal
<a href="erts_alloc">allocator</a> also used for
literals (constant terms) in BEAM code.  By default, 1 GB of
virtual address space is reserved for literals in BEAM code and
persistent terms. The amount of virtual address space reserved for
literals can be changed by using the <a href="./erts_alloc#MIscs">erts_alloc#MIscs</a> when
starting the emulator.</p><p>Here is an example how the reserved virtual address space for literals
can be raised to 2 GB (2048 MB):</p><pre>
    erl +MIscs 2048</pre><h3>Best Practices for Using Persistent Terms</h3><p>It is recommended to use keys like <strong>?MODULE</strong> or
<strong>{?MODULE,SubKey}</strong> to avoid name collisions.</p><p>Prefer creating a few large persistent terms to creating many
small persistent terms. The execution time for storing a
persistent term is proportional to the number of already existing
terms.</p><p>Updating a persistent term with the same value as it already
has is specially optimized to do nothing quickly; thus, there is
no need compare the old and new values and avoid calling
<a href="#put/2">put/2</a> if the values
are equal.</p><p>When atoms or other terms that fit in one machine word are
deleted, no global GC is needed. Therefore, persistent terms that
have atoms as their values can be updated more frequently, but
note that updating such persistent terms is still much more
expensive than reading them.</p><p>Updating or deleting a persistent term will trigger a global GC
if the term does not fit in one machine word. Processes will be
scheduled as usual, but all processes will be made runnable at
once, which will make the system less responsive until all process
have run and scanned their heaps for the deleted terms. One way to
minimize the effects on responsiveness could be to minimize the
number of processes on the node before updating or deleting a
persistent term. It would also be wise to avoid updating terms
when the system is at peak load.</p><p>Avoid storing a retrieved persistent term in a process if that
persistent term could be deleted or updated in the future. If a
process holds a reference to a persistent term when the term is
deleted, the process will be garbage collected and the term copied
to process.</p><p>Avoid updating or deleting more than one persistent term at a
time.  Each deleted term will trigger its own global GC. That
means that deleting N terms will make the system less responsive N
times longer than deleting a single persistent term. Therefore,
terms that are to be updated at the same time should be collected
into a larger term, for example, a map or a tuple.</p><h3>Example</h3><p>The following example shows how lock contention for ETS tables
can be minimized by having one ETS table for each scheduler. The
table identifiers for the ETS tables are stored as a single
persistent term:</p><pre>
    %% There is one ETS table for each scheduler.
    Sid = erlang:system_info(scheduler_id),
    Tid = element(Sid, persistent_term:get(?MODULE)),
    ets:update_counter(Tid, Key, 1).</pre><h2>Data Types</h2><span class="name">key</span><p>Any Erlang term.</p><span class="name">value</span><p>Any Erlang term.</p><h2>Functions</h2><h3>erase/1</h3><p>Erase the name for a persistent term.</p><p>Erase the name for the persistent term with key
<strong><span class="anno">Key</span></strong>. The return value will be <strong>true</strong>
if there was a persistent term with the key
<strong><span class="anno">Key</span></strong>, and <strong>false</strong> if there was no
persistent term associated with the key.</p><p>If there existed a previous persistent term associated with
key <strong><span class="anno">Key</span></strong>, a global GC has been initiated
when <strong>erase/1</strong> returns. See <a href="#description">Description</a>.</p><h3>get/0</h3><p>Get all persistent terms.</p><p>Retrieve the keys and values for all persistent terms.
The keys will be copied to the heap for the process calling
<strong>get/0</strong>, but the values will not.</p><h3>get/1</h3><p>Get the value for a persistent term.</p><p>Retrieve the value for the persistent term associated with
the key <strong><span class="anno">Key</span></strong>. The lookup will be made in
constant time and the value will not be copied to the heap
of the calling process.</p><p>This function fails with a <strong>badarg</strong> exception if no
term has been stored with the key
<strong><span class="anno">Key</span></strong>.</p><p>If the calling process holds on to the value of the
persistent term and the persistent term is deleted in the future,
the term will be copied to the process.</p><h3>get/2</h3><p>Get the value for a persistent term.</p><p>Retrieve the value for the persistent term associated with
the key <strong><span class="anno">Key</span></strong>. The lookup will be made in
constant time and the value will not be copied to the heap
of the calling process.</p><p>This function returns <strong><span class="anno">Default</span></strong> if no
term has been stored with the key <strong><span class="anno">Key</span></strong>.</p><p>If the calling process holds on to the value of the
persistent term and the persistent term is deleted in the future,
the term will be copied to the process.</p><h3>info/0</h3><p>Get information about persistent terms.</p><p>Return information about persistent terms in a map. The map
has the following keys:</p><dl><dt><strong>count</strong></dt><dd><p>The number of persistent terms.</p></dd><dt><strong>memory</strong></dt><dd><p>The total amount of memory (measured in bytes)
used by all persistent terms.</p></dd></dl><h3>put/2</h3><p>Store a term.</p><p>Store the value <strong><span class="anno">Value</span></strong> as a persistent term and
associate it with the key <strong><span class="anno">Key</span></strong>.</p><p>If the value <strong><span class="anno">Value</span></strong> is equal to the value
previously stored for the key, <strong>put/2</strong> will do nothing and return
quickly.</p><p>If there existed a previous persistent term associated with
key <strong><span class="anno">Key</span></strong>, a global GC has been initiated
when <strong>put/2</strong> returns. See <a href="#description">Description</a>.</p><h2>run_erl</h2><p>Redirect Erlang input and output streams on Unix systems.</p><p>The <strong>run_erl</strong> program is specific to Unix systems.
This program redirects the standard input and standard
output streams so that all output can be logged. It also lets the
program <strong>to_erl</strong> connect to the Erlang console, making
it possible to monitor and debug an embedded system remotely.For more information about the use, see the
<a href="./embedded_solaris"> Embedded System User's Guide</a> in System Documentation.</p><h2>Functions</h2><h3>run_erl [-daemon] pipe_dir/ log_dir "exec command
        arg1 arg2 ..."</h3><p>Start the Erlang emulator without attached terminal.</p><p>Arguments:</p><dl><dt><strong>-daemon</strong></dt><dd> <p>This option is highly recommended. It makes <strong>run_erl</strong> run
in the background completely detached from any controlling
terminal and the command returns to the caller immediately.
Without this option, <strong>run_erl</strong> must be started using several
tricks in the shell to detach it completely from the
terminal in use when starting it. The option must be the
first argument to <strong>run_erl</strong> on the command line.</p> </dd><dt><strong>pipe_dir</strong></dt><dd> <p>The named pipe, usually <strong>/tmp/</strong>. It must be
suffixed by a <strong>/</strong> (slash), that is,
<strong>/tmp/epipes/</strong>, not
<strong>/tmp/epipes</strong>.</p> </dd><dt><strong>log_dir</strong></dt><dd> <p>The log files, that is:</p> <ul><li> <p>One log file, <strong>run_erl.log</strong>, which logs
progress and warnings from the <strong>run_erl</strong>
program itself.</p> </li><li> <p>Up to five log files at maximum 100 KB each with the content
of the standard streams from and to the command. (Both the
number of logs and sizes can be changed by environment
variables, see section <a href="#environment_variables">Environment Variables</a>
below.)</p> <p>When the logs are full, <strong>run_erl</strong> deletes
and reuses the oldest log file.</p> </li></ul> </dd><dt><strong>"exec command arg1 arg2 ..."</strong></dt><dd> <p>A space-separated string specifying the program to be executed.
The second field is typically a command name such as <strong>erl</strong>.</p> </dd></dl><h3>Notes concerning the Log Files</h3><p>While running, <strong>run_erl</strong> sends all output,
uninterpreted, to a log file. The file is named
<strong>erlang.log.N</strong>, where <strong>N</strong> is an integer. When the
log is "full" (default log size is 100 KB), <strong>run_erl</strong> starts to log
in file <strong>erlang.log.(N+1)</strong>, until <strong>N</strong> reaches a
certain number (default 5), whereupon <strong>N</strong> starts at 1 again and
the oldest files start getting overwritten.</p><p>If no output comes from the Erlang shell, but
the Erlang machine still seems to be alive, an "ALIVE" message is
written to the log; it is a time stamp and is written, by default,
after 15 minutes of inactivity. Also, if output from Erlang is
logged, but more than 5 minutes (default) has passed since last time
we got anything from Erlang, a time stamp is written in the
log. The "ALIVE" messages look as follows:</p><pre><code class="">
===== ALIVE &lt;date-time-string&gt;    </code></pre><p>The other time stamps look as follows:</p><pre><code class="">
===== &lt;date-time-string&gt;    </code></pre><p><strong>date-time-string</strong> is the date and time the message is
written, default in local time (can be changed to UTC if needed).
It is formatted with the ANSI-C function <strong>strftime</strong>
using the format string <strong>%a %b %e %T %Z %Y</strong>, which
produces messages like
<strong>===== ALIVE Thu May 15 10:13:36 MEST 2003</strong>; this can
be changed, see the next section.</p><a name="environment_variables"></a><h3>Environment Variables</h3><p>The following environment variables are recognized by <strong>run_erl</strong>
and change the logging behavior. For more information, see the previous
section.</p><dl><dt><strong>RUN_ERL_LOG_ALIVE_MINUTES</strong></dt><dd> <p>How long to wait for output (in minutes) before writing an
"ALIVE" message to the log. Defaults to 15, minimum is 1.</p> </dd><dt><strong>RUN_ERL_LOG_ACTIVITY_MINUTES</strong></dt><dd> <p>How long Erlang needs to be inactive before output is
preceded with a time stamp. Defaults to
<strong>RUN_ERL_LOG_ALIVE_MINUTES div 3</strong>, minimum is 1.</p> </dd><dt><strong>RUN_ERL_LOG_ALIVE_FORMAT</strong></dt><dd> <p>Specifies another format string to be used in the <strong>strftime</strong>
C library call. That is, specifying this to
<strong>"%e-%b-%Y, %T %Z"</strong> gives
log messages with time stamps like
<strong>15-May-2003, 10:23:04 MET</strong>. For more information,
see the documentation for the C library function <strong>strftime</strong>.
Defaults to <strong>"%a %b %e %T %Z %Y"</strong>.</p> </dd><dt><strong>RUN_ERL_LOG_ALIVE_IN_UTC</strong></dt><dd> <p>If set to anything else than <strong>0</strong>, it makes all
times displayed by <strong>run_erl</strong> to be in UTC (GMT, CET, MET,
without Daylight Saving Time), rather than in local time.
This does not affect data coming from Erlang,
only the logs output directly by <strong>run_erl</strong>. Application
SASL can be modified accordingly by setting the Erlang
application variable <strong>utc_log</strong> to
<strong>true</strong>.</p> </dd><dt><strong>RUN_ERL_LOG_GENERATIONS</strong></dt><dd> <p>Controls the number of log files written before older
files are reused. Defaults to 5, minimum is 2, maximum is 1000.</p> <p>Note that, as a way to indicate the newest file, <strong>run_erl</strong> will
delete the oldest log file to maintain a "hole" in the file
sequences. For example, if log files #1, #2, #4 and #5 exists, that
means #2 is the latest and #4 is the oldest. You will therefore at most
get one less log file than the value set by
<strong>RUN_ERL_LOG_GENERATIONS</strong>.</p> </dd><dt><strong>RUN_ERL_LOG_MAXSIZE</strong></dt><dd> <p>The size, in bytes, of a log file before switching to a
new log file. Defaults to 100000, minimum is 1000, maximum is
about 2^30.</p> </dd><dt><strong>RUN_ERL_DISABLE_FLOWCNTRL</strong></dt><dd> <p>If defined, disables input and output flow control for the pty
opend by <strong>run_erl</strong>. Useful if you want to remove any risk of
accidentally blocking the flow control by using Ctrl-S (instead of
Ctrl-D to detach), which can result in blocking of the entire Beam
process, and in the case of running heart as supervisor even the
heart process becomes blocked when writing log message to terminal,
leaving the heart process unable to do its work.</p> </dd></dl><h3>See Also</h3><p><a href="start">start</a>,
<a href="start_erl">start_erl</a></p><h2>socket</h2><p>Socket interface.</p><p>This module provides an API for the socket interface.
It is used to create, delete and manipulate sockets,
send and receive data.The idea is that it shall be as "close as possible" to the OS
level socket interface. The only significant addition is that some of
the functions,
e.g. <a href="#recv/3">recv/3</a>, 
has a timeout argument. </p><h2>Data Types</h2><span class="name">domain</span><span class="name">type</span><span class="name">protocol</span><span class="name">socket()</span><p>As returned by
<a href="#open/2">open/2</a> and
<a href="#accept/1">accept/1</a>.</p><span class="name">ip4_address</span><span class="name">ip6_address</span><span class="name">ip_address</span><span class="name">sockaddr</span><span class="name">sockaddr_in4</span><span class="name">sockaddr_in6</span><span class="name">sockaddr_un</span><span class="name">port_number</span><span class="name">in6_flow_info</span><span class="name">in6_scope_id</span><span class="name">accept_flags</span><span class="name">accept_flag</span><span class="name">send_flags</span><span class="name">send_flag</span><span class="name">recv_flags</span><span class="name">recv_flag</span><span class="name">shutdown_how</span><span class="name">sockopt_level</span><span class="name">otp_socket_option</span><span class="name">socket_option</span><span class="name">ip_socket_option</span><span class="name">ipv6_socket_option</span><span class="name">tcp_socket_option</span><span class="name">udp_socket_option</span><span class="name">sctp_socket_option</span><span class="name">timeval</span><span class="name">ip_tos</span><span class="name">ip_mreq</span><span class="name">ip_mreq_source</span><span class="name">ip_pmtudisc</span><span class="name">ip_msfilter_mode</span><span class="name">ip_msfilter</span><span class="name">ip_pktinfo</span><span class="name">ipv6_mreq</span><span class="name">ipv6_pmtudisc</span><span class="name">ipv6_pktinfo</span><span class="name">sctp_assoc_id</span><span class="name">sctp_sndrcvinfo</span><span class="name">sctp_event_subscribe</span><span class="name">sctp_assocparams</span><span class="name">sctp_initmsg</span><span class="name">sctp_rtoinfo</span><span class="name">msghdr_flag</span><span class="name">msghdr_flags</span><span class="name">msghdr</span><span class="name">cmsghdr_level</span><span class="name">cmsghdr_type</span><span class="name">cmsghdr_recv</span><span class="name">cmsghdr_send</span><span class="name">uint8</span><span class="name">uint16</span><span class="name">uint20</span><span class="name">uint32</span><span class="name">int32</span><span class="name">supports_options_socket</span><span class="name">supports_options_ip</span><span class="name">supports_options_ipv6</span><span class="name">supports_options_tcp</span><span class="name">supports_options_udp</span><span class="name">supports_options_sctp</span><span class="name">supports_options</span><h2>Functions</h2><h3>accept/1</h3><h3>accept/2</h3><p>Accept a connection on a socket.</p><p>Accept a connection on a socket.</p><p>This call is used with connection-based socket types
(<strong>stream</strong> or <strong>seqpacket</strong>). It extracs the first pending
connection request for the listen socket and returns the (newly)
connected socket.</p><h3>bind/2</h3><p>Bind a name to a socket.</p><p>Bind a name to a socket.</p><p>When a socket is created
(with <a href="#open/2">open/2</a>),
it has no address assigned to it. <strong>bind</strong> assigns the
address specified by the <strong>Addr</strong> argument.</p><p>The rules used for name binding vary between domains.</p><h3>close/1</h3><p>Close a socket.</p><p>Closes the socket.</p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Note that for e.g. <strong>protocol</strong> = <strong>tcp</strong>, most implementations
doing a close does not guarantee that any data sent is delivered to
the recipient before the close is detected at the remote side. </p><p>One way to handle this is to use the
<a href="#shutdown/2">shutdown/2</a>
function
(<strong>socket:shutdown(Socket, write)</strong>) to signal that no more data is
to be sent and then wait for the read side of the socket to be closed.</p></div><h3>connect/2</h3><h3>connect/3</h3><p>Initiate a connection on a socket.</p><p>This function connects the socket to the address
specied by the <strong>SockAddr</strong> argument.</p><h3>getopt/3</h3><h3>getopt/3</h3><h3>getopt/3</h3><h3>getopt/3</h3><h3>getopt/3</h3><h3>getopt/3</h3><h3>getopt/3</h3><p>Get an option on a socket.</p><p>Get an option on a socket.</p><p>What properties are valid depend  both on <strong>Level</strong> and
on what kind of socket it is (<strong>domain</strong>, <strong>type</strong> and
<strong>protocol</strong>).</p><p>See the
<a href="./socket_usage#socket_options">socket options</a>
chapter of the users guide for more info. </p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Not all options are valid on all platforms. That is,
even if "we" support an option, that does not mean that the
underlying OS does.</p></div><h3>getopt/3</h3><p>Get an option on a socket.</p><p>Get an option on a socket.</p><p>What properties are valid depend  both on <strong>Level</strong> and
on what kind of socket it is (<strong>domain</strong>, <strong>type</strong> and
<strong>protocol</strong>).</p><p>When specifying <strong>Level</strong> as an integer, and therefor
using "native mode", it is *currently* up to the caller to
know how to interpret the result.</p><p>See the
<a href="./socket_usage#socket_options">socket options</a>
chapter of the users guide for more info. </p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Not all options are valid on all platforms. That is,
even if "we" support an option, that does not mean that the
underlying OS does.</p></div><h3>listen/1</h3><h3>listen/2</h3><p>Listen for connections on a socket.</p><p>Listen for connections on a socket.</p><h3>open/2</h3><h3>open/3</h3><h3>open/4</h3><p>Create an endpoint for communication.</p><p>Creates an endpoint (socket) for communication.</p><p>For some <strong>types</strong> there is a default protocol, which will
be used if no protocol is specified: </p><ul><li><p><strong>stream</strong>: <strong>tcp</strong></p></li><li><p><strong>dgram</strong>: <strong>udp</strong></p></li><li><p><strong>seqpacket</strong>: <strong>sctp</strong></p></li></ul><p>The <strong>Extra</strong> argument is intended for "obscure" options.
Currently the only supported option is <strong>netns</strong>, which
is only supported on the linux platform.</p><h3>peername/1</h3><p>Get name of connected socket peer.</p><p>Returns the address of the peer connected to the socket.</p><h3>recv/1</h3><h3>recv/2</h3><h3>recv/3</h3><h3>recv/3</h3><h3>recv/4</h3><p>Receive a message from a socket.</p><p>Receive a message from a socket.</p><p>There is a special case for the argument <strong>Length</strong>.
If it is set to zero (0), it means "give me everything you 
currently have".</p><h3>recvfrom/1</h3><h3>recvfrom/2</h3><h3>recvfrom/3</h3><h3>recvfrom/3</h3><h3>recvfrom/3</h3><h3>recvfrom/4</h3><p>Receive a message from a socket.</p><p>Receive a message from a socket.</p><p>This function reads "messages", which means that regardless of
how much we want to read, it returns when we get a message.</p><p>The <strong>BufSz</strong> argument basically defines the size of the
receive buffer. By setting the value to zero (0), the configured
size (setopt with <strong>Level</strong> = <strong>otp</strong> and <strong>Key</strong> = <strong>rcvbuf</strong>)
is used.</p><p>It may be impossible to know what (buffer) size is appropriate
"in advance", and in those cases it may be convenient to use the
(recv) 'peek' flag. When this flag is provided, the message is *not*
"consumed" from the underlying buffers, so another recvfrom call
is needed, possibly with a then adjusted buffer size.</p><h3>recvmsg/1</h3><h3>recvmsg/2</h3><h3>recvmsg/2</h3><h3>recvmsg/3</h3><h3>recvmsg/3</h3><h3>recvmsg/5</h3><p>Receive a message from a socket.</p><p>Receive a message from a socket.</p><p>This function reads "messages", which means that regardless of
how much we want to read, it returns when we get a message.</p><p>The message will be delivered in the form of a <strong>msghdr()</strong>,
which may contain the source address (if socket not connected),
a list of <strong>cmsghdr_recv()</strong> (depends on what socket options have
been set and what the protocol and platform supports) and
also a set of flags, providing further info about the read. </p><p>The <strong>BufSz</strong> argument basically defines the size of the
receive buffer. By setting the value to zero (0), the configured
size (setopt with <strong>Level</strong> = <strong>otp</strong> and <strong>Key</strong> = <strong>rcvbuf</strong>)
is used.</p><p>The <strong>CtrlSz</strong> argument basically defines the size of the
receive buffer for the control messages.
By setting the value to zero (0), the configured size (setopt
with <strong>Level</strong> = <strong>otp</strong>) is used.</p><p>It may be impossible to know what (buffer) size is appropriate
"in advance", and in those cases it may be convenient to use the
(recv) 'peek' flag. When this flag is provided, the message is *not*
"consumed" from the underlying buffers, so another recvmsg call
is needed, possibly with a then adjusted buffer size.</p><h3>send/2</h3><h3>send/3</h3><h3>send/3</h3><h3>send/4</h3><p>Send a message on a socket.</p><p>Send a message on a connected socket.</p><h3>sendmsg/2</h3><h3>sendmsg/3</h3><h3>sendmsg/3</h3><h3>sendmsg/4</h3><p>Send a message on a socket.</p><p>Send a message on a socket. The destination, if needed
(socket <em>not</em> connected) is provided in the <strong>MsgHdr</strong>,
which also contains the message to send,
The <strong>MsgHdr</strong> may also contain an list of optional <strong>cmsghdr_send()</strong>
(depends on what the protocol and platform supports).</p><p>Unlike the <a href="#send/2">send/2</a> function,
this one sends <em>one message</em>.
This means that if, for whatever reason, its not possible to send the
message in one go, the function will instead return with the
<em>remaining</em> data (<strong>{ok, Remaining}</strong>). Thereby leaving it
up to the caller to decide what to do (retry with the remaining data
of give up). </p><h3>sendto/3</h3><h3>sendto/4</h3><h3>sendto/4</h3><h3>sendto/5</h3><p>Send a message on a socket.</p><p>Send a message on a socket, to the specified destination.</p><h3>setopt/4</h3><h3>setopt/4</h3><h3>setopt/4</h3><h3>setopt/4</h3><h3>setopt/4</h3><h3>setopt/4</h3><h3>setopt/4</h3><p>Set options on a socket.</p><p>Set options on a socket.</p><p>What properties are valid depend both on <strong>Level</strong> and on
what kind of socket it is (<strong>domain</strong>, <strong>type</strong> and
<strong>protocol</strong>).</p><p>See the
<a href="./socket_usage#socket_options">socket options</a>
chapter of the users guide for more info. </p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Not all options are valid on all platforms. That is,
even if "we" support an option, that does not mean that the
underlying OS does.</p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Sockets are set 'non-blocking' when created, so this option
is *not* available (as it would adversely effect the Erlang VM
to set a socket 'blocking').</p></div><h3>setopt/4</h3><p>Set options on a socket.</p><p>Set options on a socket.</p><p>What properties are valid depend both on <strong>Level</strong> and on
what kind of socket it is (<strong>domain</strong>, <strong>type</strong> and
<strong>protocol</strong>).</p><p>See the
<a href="./socket_usage#socket_options">socket options</a>
chapter of the users guide for more info. </p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Not all options are valid on all platforms. That is,
even if "we" support an option, that does not mean that the
underlying OS does.</p></div><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Sockets are set 'non-blocking' when created, so this option
is *not* available (as it would adversely effect the Erlang VM
to set a socket 'blocking').</p></div><h3>shutdown/2</h3><p>Shut down part of a full-duplex connection.</p><p>Shut down all or part of a full-duplex connection.</p><h3>sockname/1</h3><p>Get socket name.</p><p>Returns the current address to which the socket is bound.</p><h3>supports/0</h3><h3>supports/1</h3><h3>supports/1</h3><h3>supports/1</h3><h3>supports/1</h3><h3>supports/2</h3><h3>supports/2</h3><h3>supports/2</h3><h3>supports/2</h3><h3>supports/2</h3><h3>supports/2</h3><h3>supports/2</h3><h3>supports/3</h3><h3>supports/3</h3><h3>supports/3</h3><h3>supports/3</h3><h3>supports/3</h3><h3>supports/3</h3><h3>supports/3</h3><p>Report info about what the platform supports.</p><p>This function intends to retreive information about what the
platform supports. Such as if SCTP is supported. Or which socket
options are supported. </p><h3>Examples</h3><a name="examples"></a><pre><code class="">
client(Addr, SAddr, SPort) -&gt;
   {ok, Sock} = socket:open(inet, stream, tcp),
   {ok, _} = socket:bind(Sock, #{family =&gt; inet,
                                 addr   =&gt; Addr}),
   ok = socket:connect(Sock, #{family =&gt; inet,
                               addr   =&gt; SAddr,
			       port   =&gt; SPort}),
   Msg = list_to_binary("hello"),
   ok = socket:send(Sock, Msg),
   ok = socket:shutdown(Sock, write),
   {ok, Msg} = socket:recv(Sock),
   ok = socket:close(Sock).

server(Addr, Port) -&gt;  
   {ok, LSock} = socket:open(inet, stream, tcp),
   {ok, _} = socket:bind(LSock, #{family =&gt; inet,
                                  port   =&gt; Port,
		 	          addr   =&gt; Addr}),
   ok = socket:listen(LSock),
   {ok, Sock} = socket:accept(LSock),
   {ok, Msg} = socket:recv(Sock),
   ok = socket:send(Sock, Msg),
   ok = socket:shutdown(Sock, write),
   ok = socket:close(Sock),
   ok = socket:close(LSock).
    </code></pre><h2>start</h2><p>OTP start script example for Unix.</p><p>The <strong>start</strong> script is an example script on
how to start up the Erlang system in embedded mode on Unix.For more information about the use, see the
<a href="./embedded_solaris"> Embedded System User's Guide</a> in System Documentation.</p><h2>Functions</h2><h3>start [ data_file ]</h3><p>Example script on how to start up the Erlang system in embedded mode on Unix.</p><p>Argument:</p><dl><dt><strong>data_file</strong></dt><dd> <p>Optional. Specifies what <strong>start_erl.data</strong> file
to use.</p> </dd></dl><p>Environment variable <strong>RELDIR</strong> can
be set before calling this example, which sets the directory
where to find the release files.</p><h3>See Also</h3><p><a href="run_erl">run_erl</a>,
<a href="start_erl">start_erl</a></p><h2>start_erl</h2><p>Start Erlang for embedded systems on Windows systems.</p><p>The <strong>start_erl</strong> program is specific to
Windows NT/2000/XP (and later versions of Windows).
Although there are programs with the same name on other
platforms, their functionality is different.This program is distributed both in compiled
form (under &lt;Erlang root&gt;\\erts-&lt;version&gt;\\bin) and
in source form (under &lt;Erlang root&gt;\\erts-&lt;version&gt;\\src).
The purpose of the source code is to ease customization of the
program for local needs, such as cyclic restart
detection. There is also a "make"-file, written for the
<strong>nmake</strong> program distributed with Microsoft Visual
C++. This program can, however, be compiled with
any Win32 C compiler (possibly with minor modifications).This program aids release handling on Windows systems.
The program is to be called by the
<strong>erlsrv</strong> program, read up the release data file
<strong>start_erl.data</strong>, and start Erlang. Some options to
<strong>start_erl</strong> are added and removed by the release handler
during upgrade with emulator restart (more specifically option
<strong>-data</strong>).</p><h2>Functions</h2><h3>start_erl [&lt;erl options&gt;] ++ [&lt;start_erl options&gt;]</h3><p>Start the Erlang emulator with the correct release data. </p><p>The <strong>start_erl</strong> program in its original form
recognizes the following options:</p><dl><dt><strong>++</strong></dt><dd> <p>Mandatory. Delimits <strong>start_erl</strong> options from normal Erlang
options. Everything on the command line <em>before</em>
<strong>++</strong> is interpreted as options to be sent to the
<strong>erl</strong> program. Everything <em>after</em>
<strong>++</strong> is interpreted as options to
<strong>start_erl</strong> itself.</p> </dd><dt><strong>-reldir &lt;release root&gt;</strong></dt><dd> <p>Mandatory if environment variable
<strong>RELDIR</strong> is not specified and no
<strong>-rootdir</strong> option is specified. Tells <strong>start_erl</strong> where
the root of the release tree is located in the file system
(typically &lt;Erlang root&gt;\\releases). The
<strong>start_erl.data</strong> file is expected to be
located in this directory (unless otherwise specified). If
only option <strong>-rootdir</strong> is specified, the directory is
assumed to be &lt;Erlang root&gt;\\releases.</p> </dd><dt><strong>-rootdir &lt;Erlang root directory&gt;</strong></dt><dd> <p>Mandatory if <strong>-reldir</strong> is not specified and no
<strong>RELDIR</strong> exists in the environment. This
specifies the Erlang installation root directory (under
which the <strong>lib</strong>, <strong>releases</strong>, and
<strong>erts-&lt;Version&gt;</strong> directories are located). If only
<strong>-reldir</strong> (or environment variable <strong>RELDIR</strong>)
is specified, the Erlang root is assumed to
be the directory exactly one level above the release
directory.</p> </dd><dt><strong>-data &lt;data file name&gt;</strong></dt><dd> <p>Optional. Specifies another data file than <strong>start_erl.data</strong>
in the &lt;release root&gt;. It is specified relative to the
&lt;release root&gt; or absolute (including drive letter, and so
on). This option is used by the release handler during
upgrade and is not to be used during normal
operation. Normally the release data file is not to be
named differently.</p> </dd><dt><strong>-bootflags &lt;boot flags file name&gt;</strong></dt><dd> <p>Optional. Specifies a file name relative to the release
directory (that is, the subdirectory of &lt;release root&gt;
where the <strong>.boot</strong> file and others are located).
The contents of this file is appended to the command line
when Erlang is started. This makes it easy to start the
emulator with different options for different releases.</p> </dd></dl><h3>Notes</h3><ul><li> <p>As the source code is distributed, it can easily be modified to
accept other options. The program must still accept option
<strong>-data</strong> with the semantics described above for the
release handler to work correctly.</p> </li><li> <p>The Erlang emulator is found by examining the registry keys for
the emulator version specified in the release data file. The new
emulator must be properly installed before the upgrade for
this to work.</p> </li><li> <p>Although the program is located together with files specific to the
emulator version, it is not expected to be specific to the
emulator version. The release handler does <em>not</em> change option
<strong>-machine</strong> to <strong>erlsrv</strong> during
emulator restart. Locate the (possibly customized)
<strong>start_erl</strong> program so that it is not overwritten
during upgrade.</p> </li><li> <p>The default options of the <strong>erlsrv</strong> program are not
sufficient for release handling. The machine started by
<strong>erlsrv</strong> is be specified as the
<strong>start_erl</strong> program and the arguments are to contain
<strong>++</strong> followed by the desired options.</p> </li></ul><h3>See Also</h3><p><a href="erlsrv">erlsrv</a>,
<a href="./release_handler">sasl/release_handler</a></p><h2>werl</h2><p>The Erlang Emulator</p><p>On Windows, the preferred way to start the Erlang system for interactive
use is as follows:<strong>werl &lt;arguments&gt;</strong>This starts Erlang in its own window, with fully
functioning command-line editing and scrollbars. All flags
except <strong>-oldshell</strong> work as they do for
<a href="erl">erl</a>.<ul><li> <p>To copy text to the clipboard, use <strong>Ctrl-C</strong>.</p> </li><li> <p>To paste text, use <strong>Ctrl-V</strong>.</p> </li><li> <p>To interrupt the runtime system or the shell process (depending
on what has been specified with system flag <strong>+B</strong>), use
<strong>Ctrl-Break</strong>.</p> </li></ul>In cases where you want to redirect standard input and/or
standard output or use Erlang in a pipeline, <strong>werl</strong> is
not suitable, and the <strong>erl</strong> program is to be used instead.The <strong>werl</strong> window is in many ways modeled after the <strong>xterm</strong>
window present on other platforms, as the <strong>xterm</strong> model
fits well with line-oriented command-based interaction. This
means that selecting text is line-oriented rather than
rectangle-oriented.<ul><li> <p>To select text in the <strong>werl</strong> window, press and hold
the left mouse button and drag the mouse over the text you want
to select. If the selection crosses line boundaries, the
selected text consists of complete lines where applicable
(just like in a word processor).</p> </li><li> <p>To select more text than fits
in the window, start by selecting a small part in the
beginning of the text you want, then use the scrollbar
to view the end of the desired selection, point to it, and press
the <em>right</em> mouse button. The whole area between your
first selection and the point where you right-clicked is
included in the selection.</p> </li><li> <p>To copy the selected text to the clipboard, either
use <strong>Ctrl-C</strong>, use the menu, or press the copy
button in the toolbar.</p> </li></ul>Pasted text is inserted at the current prompt position
and is interpreted by Erlang as usual keyboard input.<ul><li> <p>To retrieve previous command lines, press the <strong>Up arrow</strong> or
use <strong>Ctrl-P</strong>.</p> </li></ul>A drop-down box in the toolbar contains the command
history. Selecting a command in the drop-down box inserts the command
at the prompt, as if you used the keyboard to retrieve the
command.<ul><li> <p>To stop the Erlang emulator, close the <strong>werl</strong> window.</p> </li></ul></p><h2>zlib</h2><p>zlib compression interface.</p><p>This module provides an API for the zlib library
(<a href="http://www.zlib.net">www.zlib.net</a>).
It is used to compress and decompress data.
The data format is described by
<a href="https://www.ietf.org/rfc/rfc1950.txt">RFC 1950</a>,
<a href="https://www.ietf.org/rfc/rfc1951.txt">RFC 1951</a>, and
<a href="https://www.ietf.org/rfc/rfc1952.txt">RFC 1952</a>.A typical (compress) usage is as follows:<pre>
Z = zlib:open(),
ok = zlib:deflateInit(Z,default),

Compress = fun(end_of_data, _Cont) -&gt; [];
              (Data, Cont) -&gt;
                 [zlib:deflate(Z, Data)|Cont(Read(),Cont)]
           end,
Compressed = Compress(Read(),Compress),
Last = zlib:deflate(Z, [], finish),
ok = zlib:deflateEnd(Z),
zlib:close(Z),
list_to_binary([Compressed|Last])</pre>In all functions errors, <strong>{'EXIT',{Reason,Backtrace}}</strong>,
can be thrown, where <strong>Reason</strong> describes the error.Typical <strong>Reasons</strong>s:<dl><dt><strong>badarg</strong></dt><dd>Bad argument. </dd><dt><strong>not_initialized</strong></dt><dd>The stream hasn't been initialized, eg. if <a href="#inflateInit/1">inflateInit/1</a> wasn't called prior to a call to <a href="#inflate/2">inflate/2</a>. </dd><dt><strong>not_on_controlling_process</strong></dt><dd>The stream was used by a process that doesn't control it. Use <a href="#set_controlling_process/2">set_controlling_process/2</a> if you need to transfer a stream to a different process.</dd><dt><strong>data_error</strong></dt><dd>The data contains errors. </dd><dt><strong>stream_error</strong></dt><dd>Inconsistent stream state.</dd><dt><strong>{need_dictionary,Adler32}</strong></dt><dd>See <a href="#inflate/2">inflate/2</a>. </dd></dl></p><h2>Data Types</h2><span class="name">zstream</span><p>A zlib stream, see <a href="#open/0">open/0</a>.
</p><span class="name">zlevel</span><span class="name">zflush</span><span class="name">zmemlevel</span><span class="name">zmethod</span><span class="name">zstrategy</span><span class="name">zwindowbits</span><p>Normally in the range <strong>-15..-8 | 8..15</strong>.</p><h2>Functions</h2><h3>adler32/2</h3><p>Calculate the Adler checksum.</p><p>Calculates the Adler-32 checksum for <strong><span class="anno">Data</span></strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="../erts/erlang#adler32/1">erts/erlang#adler32/1</a> instead.</p></div><h3>adler32/3</h3><p>Calculate the Adler checksum.</p><p>Updates a running Adler-32 checksum for <strong><span class="anno">Data</span></strong>.
If <strong><span class="anno">Data</span></strong> is the empty binary or the empty iolist,
this function returns the required initial value for the checksum.</p><p>Example:</p><pre>
Crc = lists:foldl(fun(Data,Crc0) -&gt;
                      zlib:adler32(Z, Crc0, Data),
                  end, zlib:adler32(Z,&lt;&lt; &gt;&gt;), Datas)</pre><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="../erts/erlang#adler32/2">erts/erlang#adler32/2</a> instead.</p></div><h3>adler32_combine/4</h3><p>Combine two Adler-32 checksums.</p><p>Combines two Adler-32 checksums into one. For two binaries or
iolists, <strong>Data1</strong> and <strong>Data2</strong> with sizes of <strong>Size1</strong>
and <strong><span class="anno">Size2</span></strong>, with Adler-32 checksums
<strong><span class="anno">Adler1</span></strong> and <strong><span class="anno">Adler2</span></strong>.</p><p>This function returns the <strong><span class="anno">Adler</span></strong> checksum of
<strong>[Data1,Data2]</strong>, requiring only <strong><span class="anno">Adler1</span></strong>,
<strong><span class="anno">Adler2</span></strong>, and <strong><span class="anno">Size2</span></strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="../erts/erlang#adler32_combine/3">erts/erlang#adler32_combine/3</a> instead.</p></div><h3>close/1</h3><p>Close a stream.</p><p>Closes the stream referenced by <strong><span class="anno">Z</span></strong>.</p><h3>compress/1</h3><p>Compress data with standard zlib functionality.</p><p>Compresses data with zlib headers and checksum.</p><h3>crc32/1</h3><p>Get current CRC.</p><p>Gets the current calculated CRC checksum.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="../erts/erlang#crc32/1">erts/erlang#crc32/1</a> on the uncompressed data
instead.</p></div><h3>crc32/2</h3><p>Calculate CRC.</p><p>Calculates the CRC checksum for <strong><span class="anno">Data</span></strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="../erts/erlang#crc32/1">erts/erlang#crc32/1</a> instead.</p></div><h3>crc32/3</h3><p>Calculate CRC.</p><p>Updates a running CRC checksum for <strong><span class="anno">Data</span></strong>.
If <strong><span class="anno">Data</span></strong> is the empty binary or the empty iolist,
this function returns the required initial value for the CRC.</p><p>Example:</p><pre>
Crc = lists:foldl(fun(Data,Crc0) -&gt;
                      zlib:crc32(Z, Crc0, Data),
                  end, zlib:crc32(Z,&lt;&lt; &gt;&gt;), Datas)</pre><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="../erts/erlang#crc32/2">erts/erlang#crc32/2</a> instead.</p></div><h3>crc32_combine/4</h3><p>Combine two CRCs.</p><p>Combines two CRC checksums into one. For two binaries or iolists,
<strong>Data1</strong> and <strong>Data2</strong> with sizes of <strong>Size1</strong> and
<strong><span class="anno">Size2</span></strong>, with CRC checksums <strong><span class="anno">CRC1</span></strong>
and <strong><span class="anno">CRC2</span></strong>.</p><p>This function returns the <strong><span class="anno">CRC</span></strong> checksum of
<strong>[Data1,Data2]</strong>, requiring only <strong><span class="anno">CRC1</span></strong>,
<strong><span class="anno">CRC2</span></strong>, and <strong><span class="anno">Size2</span></strong>.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="../erts/erlang#crc32_combine/3">erts/erlang#crc32_combine/3</a> instead.</p></div><h3>deflate/2</h3><p>Compress data.</p><p>Same as <strong>deflate(<span class="anno">Z</span>, <span class="anno">Data</span>, none)</strong>.</p><h3>deflate/3</h3><p>Compress data.</p><p>Compresses as much data as possible, and
stops when the input buffer becomes empty. It can introduce
some output latency (reading input without producing any
output) except when forced to flush.</p><p>If <strong><span class="anno">Flush</span></strong> is set to <strong>sync</strong>, all
pending output is flushed to the output buffer and the
output is aligned on a byte boundary, so that the
decompressor can get all input data available so far. 
Flushing can degrade compression for some compression algorithms;
thus, use it only when necessary.</p><p>If <strong><span class="anno">Flush</span></strong> is set to <strong>full</strong>, all output is
flushed as with <strong>sync</strong>, and the compression state is reset so
that decompression can restart from this point if previous compressed
data has been damaged or if random access is desired. Using
<strong>full</strong> too often can seriously degrade the compression.</p><p>If <strong><span class="anno">Flush</span></strong> is set to <strong>finish</strong>,
pending input is processed, pending output is flushed, and
<strong>deflate/3</strong> returns. Afterwards the only possible operations
on the stream are
<a href="#deflateReset/1">deflateReset/1</a> or
<a href="#deflateEnd/1">deflateEnd/1</a>.</p><p><strong><span class="anno">Flush</span></strong> can be set to <strong>finish</strong> immediately
after <a href="#deflateInit/1">deflateInit/1</a>
if all compression is to be done in one step.</p><p>Example:</p><pre>
zlib:deflateInit(Z),
B1 = zlib:deflate(Z,Data),
B2 = zlib:deflate(Z,&lt;&lt; &gt;&gt;,finish),
zlib:deflateEnd(Z),
list_to_binary([B1,B2])</pre><h3>deflateEnd/1</h3><p>End deflate session.</p><p>Ends the deflate session and cleans all data used. Notice that this
function throws a <strong>data_error</strong> exception if the last call to
<a href="#deflate/3">deflate/3</a>
was not called with <strong>Flush</strong> set to <strong>finish</strong>.</p><h3>deflateInit/1</h3><p>Initialize a session for compression.</p><p>Same as <strong>zlib:deflateInit(<span class="anno">Z</span>, default)</strong>.</p><h3>deflateInit/2</h3><p>Initialize a session for compression.</p><p>Initializes a zlib stream for compression.</p><p><strong><span class="anno">Level</span></strong> decides the compression level to be
used:</p><ul><li>0 (<strong>none</strong>), gives no compression</li><li>1 (<strong>best_speed</strong>) gives best speed</li><li>9 (<strong>best_compression</strong>) gives best compression</li></ul><h3>deflateInit/6</h3><p>Initialize a session for compression.</p><p>Initiates a zlib stream for compression.</p><dl><dt><strong><span class="anno">Level</span></strong></dt><dd> <p>Compression level to use:</p> <ul><li>0 (<strong>none</strong>), gives no compression</li><li>1 (<strong>best_speed</strong>) gives best speed</li><li>9 (<strong>best_compression</strong>) gives best compression</li></ul> </dd><dt><strong><span class="anno">Method</span></strong></dt><dd> <p>Compression method to use, currently the only supported method
is <strong>deflated</strong>.</p> </dd><dt><strong><span class="anno">WindowBits</span></strong></dt><dd> <p>The base two logarithm of the window size (the size of the
history buffer). It is to be in the range 8 through 15. Larger
values result in better compression at the expense of memory
usage. Defaults to 15 if <a href="#deflateInit/2">deflateInit/2</a> is used. A negative
<strong><span class="anno">WindowBits</span></strong> value suppresses the zlib header
(and checksum) from the stream. Notice that the zlib source
mentions this only as a undocumented feature.</p> <div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>Due to a known bug in the underlying zlib library, <strong>WindowBits</strong> values 8 and -8
do not work as expected. In zlib versions before 1.2.9 values
8 and -8 are automatically changed to 9 and -9. <em>From zlib version 1.2.9 value -8 is rejected</em> causing <strong>zlib:deflateInit/6</strong> to fail
(8 is still changed to 9). It also seem possible that future versions
of zlib may fix this bug and start accepting 8 and -8 as is.</p><p>Conclusion: Avoid values 8 and -8 unless you know your zlib version supports them.</p></div> </dd><dt><strong><span class="anno">MemLevel</span></strong></dt><dd> <p>Specifies how much memory is to be allocated for the internal
compression state: <strong><span class="anno">MemLevel</span></strong>=1 uses minimum
memory but is slow and reduces compression ratio;
<strong><span class="anno">MemLevel</span></strong>=9 uses maximum memory for optimal
speed. Defaults to 8.</p> </dd><dt><strong><span class="anno">Strategy</span></strong></dt><dd> <p>Tunes the compression algorithm. Use the following values:</p> <ul><li><strong>default</strong> for normal data</li><li><strong>filtered</strong> for data produced by a filter (or predictor)</li><li><strong>huffman_only</strong> to force Huffman encoding only (no string match)</li><li><strong>rle</strong> to limit match distances to one (run-length encoding)</li></ul> <p>Filtered data consists mostly of small values with a somewhat
random distribution. In this case, the compression algorithm is
tuned to compress them better. The effect of <strong>filtered</strong> is to
force more Huffman coding and less string matching; it is somewhat
intermediate between <strong>default</strong> and <strong>huffman_only</strong>.
<strong>rle</strong> is designed to be almost as fast as
<strong>huffman_only</strong>, but gives better compression for PNG image
data.</p> <p><strong><span class="anno">Strategy</span></strong> affects only the compression ratio,
but not the correctness of the compressed output even if it is not
set appropriately.</p> </dd></dl><h3>deflateParams/3</h3><p>Dynamicly update deflate parameters.</p><p>Dynamically updates the compression level and compression
strategy. The interpretation of <strong><span class="anno">Level</span></strong> and
<strong><span class="anno">Strategy</span></strong> is as in
<a href="#deflateInit/6">deflateInit/6</a>.
This can be
used to switch between compression and straight copy of the
input data, or to switch to a different kind of input data
requiring a different strategy. If the compression level is
changed, the input available so far is compressed with the
old level (and can be flushed); the new level takes
effect only at the next call of
<a href="#deflate/3">deflate/3</a>.</p><p>Before the call of <strong>deflateParams</strong>, the stream state must be
set as for a call of <strong>deflate/3</strong>, as the currently available
input may have to be compressed and flushed.</p><h3>deflateReset/1</h3><p>Reset the deflate session.</p><p>Equivalent to
<a href="#deflateEnd/1">deflateEnd/1</a>
followed by
<a href="#deflateInit/1">deflateInit/1</a>,
but does not free and reallocate all the internal compression state.
The stream keeps the same compression level and any other
attributes.</p><h3>deflateSetDictionary/2</h3><p>Initialize the compression dictionary.</p><p>Initializes the compression dictionary from the specified byte
sequence without producing any compressed output.</p><p>This function must be called immediately after
<a href="#deflateInit/1">deflateInit/1</a> or
<a href="#deflateReset/1">deflateReset/1</a>,
before any call of
<a href="#deflate/3">deflate/3</a>.</p><p>The compressor and decompressor must use the same dictionary (see
<a href="#inflateSetDictionary/2">inflateSetDictionary/2</a>).</p><p>The Adler checksum of the dictionary is returned.</p><h3>getBufSize/1</h3><p>Get buffer size.</p><p>Gets the size of the intermediate buffer.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release.</p></div><h3>gunzip/1</h3><p>Uncompress data with gz header.</p><p>Uncompresses data with gz headers and checksum.</p><h3>gzip/1</h3><p>Compress data with gz header.</p><p>Compresses data with gz headers and checksum.</p><h3>inflate/2</h3><p>Decompress data.</p><p>Equivalent to
<a href="#inflate/3">inflate/3</a>
</p><h3>inflate/3</h3><p>Decompress data.</p><p>Decompresses as much data as possible. It can introduce some output
latency (reading input without producing any output).</p><p>Currently the only available option is
<strong>{exception_on_need_dict,boolean()}</strong> which controls whether the
function should throw an exception when a preset dictionary is
required for decompression. When set to false, a
<strong>need_dictionary</strong> tuple will be returned instead. See
<a href="#inflateSetDictionary/2">inflateSetDictionary/2</a> for details.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This option defaults to <strong>true</strong> for backwards compatibility
but we intend to remove the exception behavior in a future
release. New code that needs to handle dictionaries manually
should always specify <strong>{exception_on_need_dict,false}</strong>.</p></div><h3>inflateChunk/1</h3><p>Read next uncompressed chunk.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="#safeInflate/2">safeInflate/2</a> instead.</p></div><p>Reads the next chunk of uncompressed data, initialized by
<a href="#inflateChunk/2">inflateChunk/2</a>.</p><p>This function is to be repeatedly called, while it returns
<strong>{more, Decompressed}</strong>.</p><h3>inflateChunk/2</h3><p>Decompress data with limited output size.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release. Use <a href="#safeInflate/2">safeInflate/2</a> instead.</p></div><p>Like <a href="#inflate/2">inflate/2</a>,
but decompresses no more data than will fit in the buffer configured
through <a href="#setBufSize/2">setBufSize/2</a>. Is is useful when decompressing a stream with a high
compression ratio, such that a small amount of compressed input can
expand up to 1000 times.</p><p>This function returns <strong>{more, Decompressed}</strong>, when there is
more output available, and
<a href="#inflateChunk/1">inflateChunk/1</a>
is to be used to read it.</p><p>This function can introduce some output latency (reading input
without producing any output).</p><p>An exception will be thrown if a preset dictionary is required for
further decompression. See
<a href="#inflateSetDictionary/2">inflateSetDictionary/2</a> for details.</p><p>Example:</p><pre>
walk(Compressed, Handler) -&gt;
    Z = zlib:open(),
    zlib:inflateInit(Z),
    % Limit single uncompressed chunk size to 512kb
    zlib:setBufSize(Z, 512 * 1024),
    loop(Z, Handler, zlib:inflateChunk(Z, Compressed)),
    zlib:inflateEnd(Z),
    zlib:close(Z).

loop(Z, Handler, {more, Uncompressed}) -&gt;
    Handler(Uncompressed),
    loop(Z, Handler, zlib:inflateChunk(Z));
loop(Z, Handler, Uncompressed) -&gt;
    Handler(Uncompressed).</pre><h3>inflateEnd/1</h3><p>End inflate session.</p><p>Ends the inflate session and cleans all data used. Notice
that this function throws a <strong>data_error</strong> exception
if no end of stream was found (meaning that not all data
has been uncompressed).</p><h3>inflateGetDictionary/1</h3><p>Return the decompression dictionary.</p><p>Returns the decompression dictionary currently in use
by the stream. This function must be called between
<a href="#inflateInit/1">inflateInit/1</a>
and <a href="#inflateEnd/1">inflateEnd/1</a>.</p><p>Only supported if ERTS was compiled with zlib &gt;= 1.2.8.</p><h3>inflateInit/1</h3><p>Initialize a session for decompression.</p><p>Initializes a zlib stream for decompression.</p><h3>inflateInit/2</h3><p>Initialize a session for decompression.</p><p>Initializes a decompression session on zlib stream.</p><p><strong><span class="anno">WindowBits</span></strong> is the base two logarithm
of the maximum window size (the size of the history buffer).
It is to be in the range 8 through 15. Default to 15 if
<a href="#inflateInit/1">inflateInit/1</a>
is used.</p><p>If a compressed stream with a larger window size is specified as
input, <a href="#inflate/2">inflate/2</a>
throws the <strong>data_error</strong> exception.</p><p>A negative <strong><span class="anno">WindowBits</span></strong> value makes zlib
ignore the zlib header (and checksum) from the stream. Notice that
the zlib source mentions this only as a undocumented feature.</p><h3>inflateReset/1</h3><p>&gt;Reset the inflate session.</p><p>Equivalent to
<a href="#inflateEnd/1">inflateEnd/1</a>
followed by
<a href="#inflateInit/1">inflateInit/1</a>,
but does not free and reallocate all the internal decompression state.
The stream will keep attributes that could have been set by
<strong>inflateInit/1,2</strong>.</p><h3>inflateSetDictionary/2</h3><p>Initialize the decompression dictionary.</p><p>Initializes the decompression dictionary from the specified
uncompressed byte sequence. This function must be called as a
response to an inflate operation (eg.
<a href="#safeInflate/2">safeInflate/2</a>)
returning <strong>{need_dictionary,Adler,Output}</strong> or in the case of
deprecated functions, throwing an
<strong>{'EXIT',{{need_dictionary,Adler},_StackTrace}}</strong> exception.</p><p>The dictionary chosen by the compressor can be determined from the
Adler value returned or thrown by the call to the inflate function.
The compressor and decompressor must use the same dictionary (See
<a href="#deflateSetDictionary/2">deflateSetDictionary/2</a>).</p><p>After setting the dictionary the inflate operation should be
retried without new input.</p><p>Example:</p><pre>
deprecated_unpack(Z, Compressed, Dict) -&gt;
     case catch zlib:inflate(Z, Compressed) of
          {'EXIT',{{need_dictionary,_DictID},_}} -&gt;
                 ok = zlib:inflateSetDictionary(Z, Dict),
                 Uncompressed = zlib:inflate(Z, []);
          Uncompressed -&gt;
                 Uncompressed
     end.

new_unpack(Z, Compressed, Dict) -&gt;
    case zlib:inflate(Z, Compressed, [{exception_on_need_dict, false}]) of
        {need_dictionary, _DictId, Output} -&gt;
            ok = zlib:inflateSetDictionary(Z, Dict),
            [Output | zlib:inflate(Z, [])];
        Uncompressed -&gt;
            Uncompressed
    end.</pre><h3>open/0</h3><p>Open a stream and return a stream reference.</p><p>Opens a zlib stream.</p><h3>safeInflate/2</h3><p>Decompress data with limited output size.</p><p>Like <a href="#inflate/2">inflate/2</a>,
but returns once it has expanded beyond a small 
implementation-defined threshold. It's useful when decompressing
untrusted input which could have been maliciously crafted to expand
until the system runs out of memory.</p><p>This function returns <strong>{continue | finished, Output}</strong>, where
<span class="anno">Output</span> is the data that was decompressed in this call.
New input can be queued up on each call if desired, and the function
will return <strong>{finished, Output}</strong> once all queued data has been
decompressed.</p><p>This function can introduce some output latency (reading
input without producing any output).</p><p>If a preset dictionary is required for further decompression, this
function returns a <strong>need_dictionary</strong> tuple. See
<a href="#inflateSetDictionary/2">inflateSetDictionary/2</a>) for details.</p><p>Example:</p><pre>
walk(Compressed, Handler) -&gt;
    Z = zlib:open(),
    zlib:inflateInit(Z),
    loop(Z, Handler, zlib:safeInflate(Z, Compressed)),
    zlib:inflateEnd(Z),
    zlib:close(Z).

loop(Z, Handler, {continue, Output}) -&gt;
    Handler(Output),
    loop(Z, Handler, zlib:safeInflate(Z, []));
loop(Z, Handler, {finished, Output}) -&gt;
    Handler(Output).</pre><h3>setBufSize/2</h3><p>Set buffer size.</p><p>Sets the intermediate buffer size.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>This function is deprecated and will be removed in a future
release.</p></div><h3>set_controlling_process/2</h3><p>Transfers ownership of a zlib stream.</p><p>Changes the controlling process of <strong><span class="anno">Z</span></strong> to
<strong><span class="anno">Pid</span></strong>, which must be a local process.</p><h3>uncompress/1</h3><p>Uncompress data with standard zlib functionality.</p><p>Uncompresses data with zlib headers and checksum.</p><h3>unzip/1</h3><p>Uncompress data without the zlib headers.</p><p>Uncompresses data without zlib headers and checksum.</p><h3>zip/1</h3><p>Compress data without the zlib headers.</p><p>Compresses data without zlib headers and checksum.</p></body></html>