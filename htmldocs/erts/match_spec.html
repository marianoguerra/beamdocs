<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Match Specifications in Erlang</h1><p>A "match specification" (<strong>match_spec</strong>) is an Erlang term describing a
small "program" that tries to match something. It can be used
to either control tracing with
<a href="./erlang#trace_pattern/3">erlang:trace_pattern/3</a>
or to search for objects in an ETS table with for example
<a href="../stdlib/ets#select/2">ets:select/2</a>.
The match specification in many ways works like a small function in Erlang,
but is interpreted/compiled by the Erlang runtime system to something much more
efficient than calling an Erlang function. The match specification is also
very limited compared to the expressiveness of real Erlang functions.</p><p>The most notable difference between a match specification and an Erlang
fun is the syntax. Match specifications are Erlang terms, not Erlang code.
Also, a match specification has a strange concept of exceptions:</p><ul><li> <p>An exception (such as <strong>badarg</strong>) in the
<strong>MatchCondition</strong> part, which resembles an Erlang guard,
generates immediate failure.</p> </li><li> <p>An exception in the <strong>MatchBody</strong> part, which resembles
the body of an Erlang function, is implicitly caught and results in the
single atom <strong>'EXIT'</strong>.</p> </li></ul><h2>Grammar</h2><p>A match specification used in tracing can be described in the following
<em>informal</em> grammar:</p><ul><li>MatchExpression ::= [ MatchFunction, ... ] </li><li>MatchFunction ::= { MatchHead, MatchConditions, MatchBody } </li><li>MatchHead ::=  MatchVariable | <strong>'_'</strong> | [ MatchHeadPart, ... ] </li><li>MatchHeadPart ::= term() | MatchVariable | <strong>'_'</strong> </li><li>MatchVariable ::= '$&lt;number&gt;' </li><li>MatchConditions ::= [ MatchCondition, ...] | <strong>[]</strong> </li><li>MatchCondition ::= { GuardFunction } | { GuardFunction, ConditionExpression, ... } </li><li>BoolFunction ::= <strong>is_atom</strong> | <strong>is_float</strong> | <strong>is_integer</strong> | <strong>is_list</strong> | <strong>is_number</strong> | <strong>is_pid</strong> | <strong>is_port</strong> | <strong>is_reference</strong> | <strong>is_tuple</strong> | <strong>is_map</strong> | <strong>is_map_key</strong> | <strong>is_binary</strong> | <strong>is_function</strong> | <strong>is_record</strong> | <strong>is_seq_trace</strong> | <strong>'and'</strong> | <strong>'or'</strong> | <strong>'not'</strong> | <strong>'xor'</strong> | <strong>'andalso'</strong> | <strong>'orelse'</strong> </li><li>ConditionExpression ::= ExprMatchVariable | { GuardFunction } | { GuardFunction, ConditionExpression, ... } | TermConstruct </li><li>ExprMatchVariable ::= MatchVariable (bound in the MatchHead) | <strong>'$_'</strong> | <strong>'$$'</strong> </li><li>TermConstruct = {{}} | {{ ConditionExpression, ... }} | <strong>[]</strong> | [ConditionExpression, ...] | <strong>#{}</strong> | #{term() =&gt; ConditionExpression, ...} | NonCompositeTerm | Constant </li><li>NonCompositeTerm ::= term() (not list or tuple or map) </li><li>Constant ::= {<strong>const</strong>, term()} </li><li>GuardFunction ::= BoolFunction | <strong>abs</strong> | <strong>element</strong> | <strong>hd</strong> | <strong>length</strong> | <strong>map_get</strong> | <strong>map_size</strong> | <strong>node</strong> | <strong>round</strong> | <strong>size</strong> | <strong>bit_size</strong> | <strong>tl</strong> | <strong>trunc</strong> | <strong>'+'</strong> | <strong>'-'</strong> | <strong>'*'</strong> | <strong>'div'</strong> | <strong>'rem'</strong> | <strong>'band'</strong> | <strong>'bor'</strong> | <strong>'bxor'</strong> | <strong>'bnot'</strong> | <strong>'bsl'</strong> | <strong>'bsr'</strong> | <strong>'&gt;'</strong> | <strong>'&gt;='</strong> | <strong>'&lt;'</strong> | <strong>'=&lt;'</strong> | <strong>'=:='</strong> | <strong>'=='</strong> | <strong>'=/='</strong> | <strong>'/='</strong> | <strong>self</strong> | <strong>get_tcw</strong> </li><li>MatchBody ::= [ ActionTerm ] </li><li>ActionTerm ::= ConditionExpression | ActionCall </li><li>ActionCall ::= {ActionFunction} | {ActionFunction, ActionTerm, ...} </li><li>ActionFunction ::= <strong>set_seq_token</strong> | <strong>get_seq_token</strong> | <strong>message</strong> | <strong>return_trace</strong> | <strong>exception_trace</strong> | <strong>process_dump</strong> | <strong>enable_trace</strong> | <strong>disable_trace</strong> | <strong>trace</strong> | <strong>display</strong> | <strong>caller</strong> | <strong>set_tcw</strong> | <strong>silent</strong> </li></ul><p>A match specification  used in
<a href="./ets">stdlib/ets</a>
can be described in the following <em>informal</em> grammar:</p><ul><li>MatchExpression ::= [ MatchFunction, ... ] </li><li>MatchFunction ::= { MatchHead, MatchConditions, MatchBody } </li><li>MatchHead ::=  MatchVariable | <strong>'_'</strong> | { MatchHeadPart, ... } </li><li>MatchHeadPart ::= term() | MatchVariable | <strong>'_'</strong> </li><li>MatchVariable ::= '$&lt;number&gt;' </li><li>MatchConditions ::= [ MatchCondition, ...] | <strong>[]</strong> </li><li>MatchCondition ::= { GuardFunction } | { GuardFunction, ConditionExpression, ... } </li><li>BoolFunction ::= <strong>is_atom</strong> | <strong>is_float</strong> | <strong>is_integer</strong> | <strong>is_list</strong> | <strong>is_number</strong> | <strong>is_pid</strong> | <strong>is_port</strong> | <strong>is_reference</strong> | <strong>is_tuple</strong> | <strong>is_map</strong> | <strong>map_is_key</strong> | <strong>is_binary</strong> | <strong>is_function</strong> | <strong>is_record</strong> | <strong>'and'</strong> | <strong>'or'</strong> | <strong>'not'</strong> | <strong>'xor'</strong> | <strong>'andalso'</strong> | <strong>'orelse'</strong> </li><li>ConditionExpression ::= ExprMatchVariable | { GuardFunction } | { GuardFunction, ConditionExpression, ... } | TermConstruct </li><li>ExprMatchVariable ::= MatchVariable (bound in the MatchHead) | <strong>'$_'</strong> | <strong>'$$'</strong> </li><li>TermConstruct = {{}} | {{ ConditionExpression, ... }} | <strong>[]</strong> | [ConditionExpression, ...] | #{} | #{term() =&gt; ConditionExpression, ...} | NonCompositeTerm | Constant </li><li>NonCompositeTerm ::= term() (not list or tuple or map) </li><li>Constant ::= {<strong>const</strong>, term()} </li><li>GuardFunction ::= BoolFunction | <strong>abs</strong> | <strong>element</strong> | <strong>hd</strong> | <strong>length</strong> | <strong>map_get</strong> | <strong>map_size</strong> | <strong>node</strong> | <strong>round</strong> | <strong>size</strong> | <strong>bit_size</strong> | <strong>tl</strong> | <strong>trunc</strong> | <strong>'+'</strong> | <strong>'-'</strong> | <strong>'*'</strong> | <strong>'div'</strong> | <strong>'rem'</strong> | <strong>'band'</strong> | <strong>'bor'</strong> | <strong>'bxor'</strong> | <strong>'bnot'</strong> | <strong>'bsl'</strong> | <strong>'bsr'</strong> | <strong>'&gt;'</strong> | <strong>'&gt;='</strong> | <strong>'&lt;'</strong> | <strong>'=&lt;'</strong> | <strong>'=:='</strong> | <strong>'=='</strong> | <strong>'=/='</strong> | <strong>'/='</strong> | <strong>self</strong> </li><li>MatchBody ::= [ ConditionExpression, ... ] </li></ul><h2>Function Descriptions</h2><h2>Functions Allowed in All Types of Match Specifications</h2><p>The functions allowed in <strong>match_spec</strong> work as
follows:</p><dl><dt><strong>is_atom</strong>, <strong>is_float</strong>, <strong>is_integer</strong>, <strong>is_list</strong>, <strong>is_number</strong>, <strong>is_pid</strong>, <strong>is_port</strong>, <strong>is_reference</strong>, <strong>is_tuple</strong>, <strong>is_map</strong>, <strong>is_binary</strong>, <strong>is_function</strong> </dt><dd> <p>Same as the corresponding guard tests in Erlang, return
<strong>true</strong> or <strong>false</strong>.</p> </dd><dt><strong>is_record</strong></dt><dd> <p>Takes an additional parameter, which <em>must</em> be the result
of <strong>record_info(size, &lt;record_type&gt;)</strong>, like in
<strong>{is_record, '$1', rectype, record_info(size, rectype)}</strong>.</p> </dd><dt><strong>'not'</strong></dt><dd> <p>Negates its single argument (anything other
than <strong>false</strong> gives <strong>false</strong>).</p> </dd><dt><strong>'and'</strong></dt><dd> <p>Returns <strong>true</strong> if all its arguments (variable
length argument list) evaluate to <strong>true</strong>, otherwise
<strong>false</strong>. Evaluation order is undefined.</p> </dd><dt><strong>'or'</strong></dt><dd> <p>Returns <strong>true</strong> if any of its arguments
evaluates to <strong>true</strong>. Variable length argument
list. Evaluation order is undefined.</p> </dd><dt><strong>'andalso'</strong></dt><dd> <p>Works as <strong>'and'</strong>, but quits evaluating its
arguments when one argument evaluates to something else
than <strong>true</strong>. Arguments are evaluated left to right.</p> </dd><dt><strong>'orelse'</strong></dt><dd> <p>Works as <strong>'or'</strong>, but quits evaluating as soon
as one of its arguments evaluates to <strong>true</strong>.
Arguments are evaluated left to right.</p> </dd><dt><strong>'xor'</strong></dt><dd> <p>Only two arguments, of which one must be <strong>true</strong> and the
other <strong>false</strong> to return <strong>true</strong>; otherwise
<strong>'xor'</strong> returns false.</p> </dd><dt><strong>abs</strong>, <strong>element</strong>, <strong>hd</strong>, <strong>length</strong>, <strong>map_get</strong>, <strong>map_size</strong>, <strong>node</strong>, <strong>round</strong>, <strong>size</strong>, <strong>bit_size</strong>, <strong>tl</strong>, <strong>trunc</strong>, <strong>'+'</strong>, <strong>'-'</strong>, <strong>'*'</strong>, <strong>'div'</strong>, <strong>'rem'</strong>, <strong>'band'</strong>, <strong>'bor'</strong>, <strong>'bxor'</strong>, <strong>'bnot'</strong>, <strong>'bsl'</strong>, <strong>'bsr'</strong>, <strong>'&gt;'</strong>, <strong>'&gt;='</strong>, <strong>'&lt;'</strong>, <strong>'=&lt;'</strong>, <strong>'=:='</strong>, <strong>'=='</strong>, <strong>'=/='</strong>, <strong>'/='</strong>, <strong>self</strong></dt><dd> <p>Same as the corresponding Erlang BIFs (or operators). In case of
bad arguments, the result depends on the context. In the
<strong>MatchConditions</strong> part of the expression, the test
fails immediately (like in an Erlang guard). In the
<strong>MatchBody</strong> part, exceptions are implicitly caught
and the call results in the atom <strong>'EXIT'</strong>.</p> </dd></dl><h2>Functions Allowed Only for Tracing</h2><p>The functions allowed only for tracing work as follows:</p><dl><dt><strong>is_seq_trace</strong></dt><dd> <p>Returns <strong>true</strong> if a sequential trace token is set
for the current process, otherwise <strong>false</strong>.</p> </dd><dt><strong>set_seq_token</strong></dt><dd> <p>Works as <strong>seq_trace:set_token/2</strong>, but returns
<strong>true</strong> on success, and <strong>'EXIT'</strong>
on error or bad argument. Only allowed in the
<strong>MatchBody</strong> part and only allowed when tracing.</p> </dd><dt><strong>get_seq_token</strong></dt><dd> <p>Same as <strong>seq_trace:get_token/0</strong> and only
allowed in the <strong>MatchBody</strong> part when tracing.</p> </dd><dt><strong>message</strong></dt><dd> <p>Sets an additional message appended to the
trace message sent. One can only set one additional message in
the body. Later calls replace the appended message.</p> <p>As a special case, <strong>{message, false}</strong> disables
sending of trace messages ('call' and 'return_to') for this function
call, just like if the match specification had not matched.
This can be useful if only the side effects of 
the <strong>MatchBody</strong> part are desired.</p> <p>Another special case is <strong>{message, true}</strong>, which
sets the default behavior, as if the function had no match
specification; trace message is sent with no extra information
(if no other calls to <strong>message</strong> are placed before
<strong>{message, true}</strong>, it is in fact a "noop").</p> <p>Takes one argument: the message. Returns <strong>true</strong>
and can only be used in the <strong>MatchBody</strong> part and
when tracing.</p> </dd><dt><strong>return_trace</strong></dt><dd> <p>Causes a <strong>return_from</strong> trace message to be sent
upon return from the current function. Takes no arguments, returns
<strong>true</strong> and can only be used in the
<strong>MatchBody</strong> part when tracing.
If the process trace flag <strong>silent</strong> is active, the
<strong>return_from</strong> trace message is inhibited.</p> <p><em>Warning:</em> If the traced function is tail-recursive, this
match specification function destroys that property. Hence, if a
match specification executing this function is used on a
perpetual server process, it can only be active for a limited
period of time, or the emulator will eventually use all memory in
the host machine and crash. If this match specification function is
inhibited using process trace flag <strong>silent</strong>,
tail-recursiveness still remains.</p> </dd><dt><strong>exception_trace</strong></dt><dd> <p>Works as <strong>return_trace</strong> plus; if the traced function exits
because of an exception,
an <strong>exception_from</strong> trace message is generated,
regardless of the exception is caught or not.</p> </dd><dt><strong>process_dump</strong></dt><dd> <p>Returns some textual information about
the current process as a binary. Takes no arguments and is only
allowed in the <strong>MatchBody</strong> part when tracing.</p> </dd><dt><strong>enable_trace</strong></dt><dd> <p>With one parameter this function turns on tracing like the Erlang
call <strong>erlang:trace(self(), true, [P2])</strong>, where
<strong>P2</strong> is the parameter to
<strong>enable_trace</strong>.</p> <p>With two parameters, the first parameter is to be either a process
identifier or the registered name of a process. In this case tracing
is turned on for the designated process in the same way as in the
Erlang call <strong>erlang:trace(P1, true, [P2])</strong>, where
<strong>P1</strong> is the first and <strong>P2</strong> is the second argument. The
process <strong>P1</strong> gets its trace messages sent to the
same tracer as the process executing the statement uses.
<strong>P1</strong> <em>cannot</em> be one of the atoms
<strong>all</strong>, <strong>new</strong> or 
<strong>existing</strong> (unless they are registered names).
<strong>P2</strong> <em>cannot</em> be
<strong>cpu_timestamp</strong> or <strong>tracer</strong>.</p> <p>Returns <strong>true</strong> and can only be used in
the <strong>MatchBody</strong> part when tracing.</p> </dd><dt><strong>disable_trace</strong></dt><dd> <p>With one parameter this function disables tracing like the Erlang
call <strong>erlang:trace(self(), false, [P2])</strong>, where
<strong>P2</strong> is the parameter to
<strong>disable_trace</strong>.</p> <p>With two parameters this function works as the Erlang call
<strong>erlang:trace(P1, false, [P2])</strong>, where <strong>P1</strong>
can be either a process identifier or a registered name and is
specified as the first argument to the match specification function.
<strong>P2</strong> <em>cannot</em> be
<strong>cpu_timestamp</strong> or <strong>tracer</strong>.</p> <p>Returns <strong>true</strong> and can only be used in the
<strong>MatchBody</strong> part when tracing.</p> </dd><dt><strong>trace</strong></dt><dd> <p>With two parameters this function takes a list
of trace flags to disable as first parameter and a list
of trace flags to enable as second parameter. Logically, the
disable list is applied first, but effectively all changes
are applied atomically. The trace flags
are the same as for <strong>erlang:trace/3</strong>,
not including <strong>cpu_timestamp</strong>, but including
<strong>tracer</strong>.</p> <p>If a tracer is specified in both lists, the tracer in the
enable list takes precedence. If no tracer is specified, the same
tracer as the process executing the match specification is used (not the meta tracer).
If that process doesn't have tracer either, then trace flags are ignored.</p> <p>When using a <a href="erl_tracer">tracer module</a>,
the module must be loaded before the match specification is
executed. If it is not loaded, the match fails.</p> <p>With three parameters to this function, the first is
either a process identifier or the registered name of a
process to set trace flags on, the second is the disable
list, and the third is the enable list.</p> <p>Returns <strong>true</strong> if any trace property was changed
for the trace target process, otherwise <strong>false</strong>.
Can only be used in the <strong>MatchBody</strong> part when
tracing.</p> </dd><dt><strong>caller</strong></dt><dd> <p>Returns the calling function as a tuple <strong>{Module, Function, Arity}</strong> or the atom <strong>undefined</strong> if the calling
function cannot be determined. Can only be used in the
<strong>MatchBody</strong> part when tracing.</p> <p>Notice that if a "technically built in function" (that is, a
function not written in Erlang) is traced, the
<strong>caller</strong> function sometimes returns the atom
<strong>undefined</strong>. The calling
Erlang function is not available during such calls.</p> </dd><dt><strong>display</strong></dt><dd> <p>For debugging purposes only. Displays the single argument as an
Erlang term on <strong>stdout</strong>, which is seldom what is wanted.
Returns <strong>true</strong> and can only be used in the
<strong>MatchBody</strong> part when tracing.</p> </dd><dt><a name="get_tcw"></a><strong>get_tcw</strong></dt><dd> <p>Takes no argument and returns the value of the node's trace
control word. The same is done by
<strong>erlang:system_info(trace_control_word)</strong>.</p> <p>The trace control word is a 32-bit unsigned integer intended for
generic trace control. The trace control word can be tested and
set both from within trace match specifications and with BIFs.
This call is only allowed when tracing.</p> </dd><dt><a name="set_tcw"></a><strong>set_tcw</strong></dt><dd> <p>Takes one unsigned integer argument, sets the value of
the node's trace control word to the value of the argument,
and returns the previous value. The same is done by
<strong>erlang:system_flag(trace_control_word, Value)</strong>.
It is only allowed to use <strong>set_tcw</strong> in the
<strong>MatchBody</strong> part when tracing.</p> </dd><dt><strong>silent</strong></dt><dd> <p>Takes one argument. If the argument is <strong>true</strong>,
the call trace message mode for the current process is set to
silent for this call and all later calls, that is, call trace
messages are inhibited even if
<strong>{message, true}</strong> is called in the
<strong>MatchBody</strong> part for a traced function.</p> <p>This mode can also be activated with flag
<strong>silent</strong> to
<strong>erlang:trace/3</strong>.</p> <p>If the argument is <strong>false</strong>, the call trace
message mode for the current process is set to normal
(non-silent) for this call and all later calls.</p> <p>If the argument is not <strong>true</strong> or
<strong>false</strong>, the call trace message mode is
unaffected.</p> </dd></dl><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>All "function calls" must be tuples, even if they take no arguments.
The value of <strong>self</strong> is the atom()
<strong>self</strong>, but the value of <strong>{self}</strong> is
the pid() of the current process.</p></div><a name="match_target"></a><h2>Match target</h2><p>Each execution of a match specification is done against
a match target term. The format and content of the target term
depends on the context in which the match is done. The match
target for ETS is always a full table tuple. The match target
for call trace is always a list of all function arguments. The
match target for event trace depends on the event type, see
table below.</p><table class="table table-bordered table-hover table-striped"><caption>Match target depending on context</caption><tbody><tr><td>Context</td><td>Type</td><td>Match target</td><td>Description</td></tr><tr><td>ETS</td><td></td><td>{Key, Value1, Value2, ...}</td><td>A table object</td></tr><tr><td>Trace</td><td>call</td><td>[Arg1, Arg2, ...]</td><td>Function arguments</td></tr><tr><td>Trace</td><td>send</td><td>[Receiver, Message]</td><td>Receiving process/port and message term</td></tr><tr><td>Trace</td><td>'receive'</td><td>[Node, Sender, Message]</td><td>Sending node, process/port and message term</td></tr></tbody></table><h2>Variables and Literals</h2><p>Variables take the form <strong>'$&lt;number&gt;'</strong>, where
<strong>&lt;number&gt;</strong> is an integer between 0 and
100,000,000 (1e+8). The behavior if the number is outside these limits
is <em>undefined</em>. In the <strong>MatchHead</strong> part, the
special variable <strong>'_'</strong> matches anything, and never gets
bound (like <strong>_</strong> in Erlang).</p><ul><li> <p>In the <strong>MatchCondition/MatchBody</strong> parts,
no unbound variables are allowed, so <strong>'_'</strong> is
interpreted as itself (an atom). Variables can only be bound in the
<strong>MatchHead</strong> part.</p> </li><li> <p>In the <strong>MatchBody</strong> and
<strong>MatchCondition</strong> parts, only variables bound
previously can be used.</p> </li><li> <p>As a special case, the following apply in the
<strong>MatchCondition/MatchBody</strong> parts:</p> <ul><li> <p>The variable <strong>'$_'</strong> expands to the whole
<a href="#match_target">match target</a> term.
</p> </li><li> <p>The variable <strong>'$$'</strong> expands to a list of the
values of all bound variables in order (that is,
<strong>['$1','$2', ...]</strong>).</p> </li></ul> </li></ul><p>In the <strong>MatchHead</strong> part, all literals (except the
variables above) are interpreted "as is".</p><p>In the <strong>MatchCondition/MatchBody</strong> parts, the
interpretation is in some ways different. Literals in these parts
can either be written "as is", which works for all literals except
tuples, or by using the special form <strong>{const, T}</strong>,
where <strong>T</strong> is any Erlang term.</p><p>For tuple literals in the match specification, double tuple parentheses
can also be used, that is, construct them as a tuple of
arity one containing a single tuple, which is the one to be
constructed. The "double tuple parenthesis" syntax is useful to
construct tuples from already bound variables, like in
<strong>{{'$1', [a,b,'$2']}}</strong>. Examples:</p><table class="table table-bordered table-hover table-striped"><caption>Literals in MatchCondition/MatchBody Parts of a Match
        Specification</caption><tbody><tr><td><em>Expression</em></td><td><em>Variable Bindings</em></td><td><em>Result</em></td></tr><tr><td>{{'$1','$2'}}</td><td>'$1' = a, '$2' = b</td><td>{a,b}</td></tr><tr><td>{const, {'$1', '$2'}}</td><td>Irrelevant</td><td>{'$1', '$2'}</td></tr><tr><td>a</td><td>Irrelevant</td><td>a</td></tr><tr><td>'$1'</td><td>'$1' = []</td><td>[]</td></tr><tr><td>['$1']</td><td>'$1' = []</td><td>[[]]</td></tr><tr><td>[{{a}}]</td><td>Irrelevant</td><td>[{a}]</td></tr><tr><td>42</td><td>Irrelevant</td><td>42</td></tr><tr><td>"hello"</td><td>Irrelevant</td><td>"hello"</td></tr><tr><td>$1</td><td>Irrelevant</td><td>49 (the ASCII value for character '1')</td></tr></tbody></table><h2>Execution of the Match</h2><p>The execution of the match expression, when the runtime system
decides whether a trace message is to be sent, is as follows:</p><p>For each tuple in the <strong>MatchExpression</strong> list and while
no match has succeeded:</p><ul><li> <p>Match the <strong>MatchHead</strong> part against the match target
term, binding the <strong>'$&lt;number&gt;'</strong> variables
(much like in <strong>ets:match/2</strong>). If the
<strong>MatchHead</strong> part cannot match the arguments, the
match fails.</p> </li><li> <p>Evaluate each <strong>MatchCondition</strong> (where only
<strong>'$&lt;number&gt;'</strong> variables previously bound in the
<strong>MatchHead</strong> part can occur) and expect it to return
the atom <strong>true</strong>. When a condition does not evaluate
to <strong>true</strong>, the match fails. If any BIF call
generates an exception, the match also fails.</p> </li><li> <p>Two cases can occur:</p> <ul><li> <p>If the match specification is executing when tracing:</p> <p>Evaluate each <strong>ActionTerm</strong> in the same way as
the <strong>MatchConditions</strong>, but ignore the return
values. Regardless of what happens in this part, the match has
succeeded.</p> </li><li> <p>If the match specification is executed when selecting objects
from an ETS table:</p> <p>Evaluate the expressions in order and return the value of
the last expression (typically there is only one expression
in this context).</p> </li></ul> </li></ul><a name="differences_ets_tracing"></a><h2>Differences between Match Specifications in ETS and Tracing</h2><p>ETS match specifications produce a return value.
Usually the <strong>MatchBody</strong> contains one single
<strong>ConditionExpression</strong> that defines the return value
without any side effects. Calls with side effects are not allowed in
the ETS context.</p><p>When tracing there is no return value to produce, the
match specification either matches or does not. The effect when the
expression matches is a trace message rather than a returned
term. The <strong>ActionTerm</strong>s are executed as in an imperative
language, that is, for their side effects. Functions with side effects
are also allowed when tracing.</p><h2>Tracing Examples</h2><p>Match an argument list of three, where the first and third arguments
are equal:</p><pre><code class="">
[{['$1', '_', '$1'],
  [],
  []}]
    </code></pre><p>Match an argument list of three, where the second argument is
a number &gt; 3:</p><pre><code class="">
[{['_', '$1', '_'],
  [{ '&gt;', '$1', 3}],
  []}]
    </code></pre><p>Match an argument list of three, where the third argument is
either a tuple containing argument one and two, <em>or</em> a list
beginning with argument one and two (that is,
<strong>[a,b,[a,b,c]]</strong> or <strong>[a,b,{a,b}]</strong>):</p><pre><code class="">
[{['$1', '$2', '$3'],
  [{'orelse', 
      {'=:=', '$3', {{'$1','$2'}}},
      {'and', 
        {'=:=', '$1', {hd, '$3'}},
        {'=:=', '$2', {hd, {tl, '$3'}}}}}],
  []}]
    </code></pre><p>The above problem can also be solved as follows:</p><pre><code class="">
[{['$1', '$2', {'$1', '$2}], [], []},
 {['$1', '$2', ['$1', '$2' | '_']], [], []}]
    </code></pre><p>Match two arguments, where the first is a tuple beginning with
a list that in turn begins with the second argument times
two (that is, <strong>[{[4,x],y},2]</strong> or <strong>[{[8], y, z},4])</strong>:</p><pre><code class="">
[{['$1', '$2'],[{'=:=', {'*', 2, '$2'}, {hd, {element, 1, '$1'}}}],
  []}]
    </code></pre><p>Match three arguments. When all three are equal and are
numbers, append the process dump to the trace message, otherwise
let the trace message be "as is", but set the sequential trace
token label to 4711:</p><pre><code class="">
[{['$1', '$1', '$1'],
  [{is_number, '$1'}],
  [{message, {process_dump}}]},
 {'_', [], [{set_seq_token, label, 4711}]}]
    </code></pre><p>As can be noted above, the parameter list can be matched against a
single <strong>MatchVariable</strong> or an <strong>'_'</strong>.
To replace the whole parameter list with a single variable is a special
case. In all other cases the <strong>MatchHead</strong> must be a
<em>proper</em> list.</p><p>Generate a trace message only if the trace control word is set to 1:</p><pre><code class="">
[{'_',
  [{'==',{get_tcw},{const, 1}}],
  []}]
    </code></pre><p>Generate a trace message only if there is a <strong>seq_trace</strong> token:</p><pre><code class="">
[{'_',
  [{'==',{is_seq_trace},{const, 1}}],
  []}]
    </code></pre><p>Remove the <strong>'silent'</strong> trace flag when the first argument is
<strong>'verbose'</strong>, and add it when it is <strong>'silent':</strong></p><pre><code class="">
[{'$1',
  [{'==',{hd, '$1'},verbose}],
  [{trace, [silent],[]}]},
 {'$1',
  [{'==',{hd, '$1'},silent}],
  [{trace, [],[silent]}]}]
    </code></pre><p>Add a <strong>return_trace</strong> message if the function is of arity 3:</p><pre><code class="">
[{'$1',
  [{'==',{length, '$1'},3}],
  [{return_trace}]},
 {'_',[],[]}]
    </code></pre><p>Generate a trace message only if the function is of arity 3 and the
first argument is <strong>'trace'</strong>:</p><pre><code class="">
[{['trace','$2','$3'],
  [],
  []},
 {'_',[],[]}]
    </code></pre><h2>ETS Examples</h2><p>Match all objects in an ETS table, where the first element is
the atom <strong>'strider'</strong> and the tuple arity is 3, and return the whole
object:</p><pre><code class="">
[{{strider,'_','_'},
  [],
  ['$_']}]
    </code></pre><p>Match all objects in an ETS table with arity &gt; 1 and the first
element is 'gandalf', and return element 2:</p><pre><code class="">
[{'$1',
  [{'==', gandalf, {element, 1, '$1'}},{'&gt;=',{size, '$1'},2}],
  [{element,2,'$1'}]}]
    </code></pre><p>In this example, if the first element had been the key, it is
much more efficient to match that key in the <strong>MatchHead</strong>
part than in the <strong>MatchConditions</strong> part.
The search space of the tables is restricted with regards to the
<strong>MatchHead</strong> so
that only objects with the matching key are searched.</p><p>Match tuples of three elements, where the second element is either
<strong>'merry'</strong> or <strong>'pippin'</strong>, and return the whole objects:</p><pre><code class="">
[{{'_',merry,'_'},
  [],
  ['$_']},
 {{'_',pippin,'_'},
  [],
  ['$_']}]
    </code></pre><p>Function <a href="../stdlib/ets#test_ms/2">stdlib/ets#test_ms/2</a>
can be useful for testing complicated ETS matches.</p></body></html>