<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Distribution Protocol</h1><p>This description is far from complete. It will be updated if the
protocol is updated. However, the protocols, both from Erlang
nodes to the Erlang Port Mapper Daemon (EPMD) and between Erlang nodes
are stable since many years.</p><p>The distribution protocol can be divided into four parts:</p><ul><li> <p>Low-level socket connection (1)</p> </li><li> <p>Handshake, interchange node name, and authenticate (2)</p> </li><li> <p>Authentication (done by <a href="./net_kernel">kernel/net_kernel</a>) (3)</p> </li><li> <p>Connected (4)</p>  </li></ul><p>A node fetches the port number of another node through the EPMD (at the
other host) to initiate a connection request.</p><p>For each host, where a distributed Erlang node is running, also an EPMD
is to be running. The EPMD can be started explicitly or automatically
as a result of the Erlang node startup.</p><p>By default the EPMD listens on port 4369.</p><p>(3) and (4) above are performed at the same level but the <strong>net_kernel</strong>
disconnects the other node if it communicates using an invalid cookie (after
1 second).</p><p>The integers in all multibyte fields are in big-endian order.</p><div class="alert alert-warning"><h4 class="alert-heading">Warning</h4><p>
The Erlang Distribution protocol is not by itself secure and does not
aim to be so. In order to get secure distribution the distributed nodes
should be configured to use distribution over tls.
See the <a href="./ssl_distribution"> Using SSL for Erlang Distribution</a> User's Guide
for details on how to setup a secure distributed node.
</p></div><h2>EPMD Protocol</h2><p>The requests served by the EPMD are summarized in the following
figure.</p><img src="erl_ext_fig.gif" title="Summary of EPMD Requests"></img><p>Each request <strong>*_REQ</strong> is preceded by a 2 byte length field.
Thus, the overall request format is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>Request Format</caption><tbody><tr><td>2</td><td>n</td></tr><tr><td><strong>Length</strong></td><td><strong>Request</strong></td></tr></tbody></table><h2>Register a Node in EPMD</h2><p>When a distributed node is started it registers itself in the EPMD.
The message <strong>ALIVE2_REQ</strong> described below is sent from the node to
the EPMD. The response from the EPMD is <strong>ALIVE2_RESP</strong>.</p><table class="table table-bordered table-hover table-striped"><caption>ALIVE2_REQ (120)</caption><tbody><tr><td>1</td><td>2</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>Nlen</td><td>2</td><td>Elen</td></tr><tr><td><strong>120</strong></td><td><strong>PortNo</strong></td><td><strong>NodeType</strong></td><td><strong>Protocol</strong></td><td><strong>HighestVersion</strong></td><td><strong>LowestVersion</strong></td><td><strong>Nlen</strong></td><td><strong>NodeName</strong></td><td><strong>Elen</strong></td><td><strong>Extra</strong></td></tr></tbody></table><dl><dt><strong>PortNo</strong></dt><dd> <p>The port number on which the node accept connection requests.</p> </dd><dt><strong>NodeType</strong></dt><dd> <p>77 = normal Erlang node, 72 = hidden node (C-node), ...</p> </dd><dt><strong>Protocol</strong></dt><dd> <p>0 = TCP/IPv4, ...</p> </dd><dt><strong>HighestVersion</strong></dt><dd> <p>The highest distribution version that this node can handle.
The value in Erlang/OTP R6B and later is 5.</p> </dd><dt><strong>LowestVersion</strong></dt><dd> <p>The lowest distribution version that this node can handle.
The value in Erlang/OTP R6B and later is 5.</p> </dd><dt><strong>Nlen</strong></dt><dd> <p>The length (in bytes) of field <strong>NodeName</strong>.</p> </dd><dt><strong>NodeName</strong></dt><dd> <p>The node name as an UTF-8 encoded string of <strong>Nlen</strong> bytes.</p> </dd><dt><strong>Elen</strong></dt><dd> <p>The length of field <strong>Extra</strong>.</p> </dd><dt><strong>Extra</strong></dt><dd> <p>Extra field of <strong>Elen</strong> bytes.</p> </dd></dl><p>The connection created to the EPMD must be kept as long as the
node is a distributed node. When the connection is closed,
the node is automatically unregistered from the EPMD.</p><p>The response message <strong>ALIVE2_RESP</strong> is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>ALIVE2_RESP (121)</caption><tbody><tr><td>1</td><td>1</td><td>2</td></tr><tr><td><strong>121</strong></td><td><strong>Result</strong></td><td><strong>Creation</strong></td></tr></tbody></table><p>Result = 0 -&gt; ok, result &gt; 0 -&gt; error.</p><h2>Unregister a Node from EPMD</h2><p>A node unregisters itself from the EPMD by closing the TCP
connection to EPMD established when the node was registered.</p><h2>Get the Distribution Port of Another Node</h2><p>When one node wants to connect to another node it starts with
a <strong>PORT_PLEASE2_REQ</strong> request to the EPMD on the host where the
node resides to get the distribution port that the node listens to.</p><table class="table table-bordered table-hover table-striped"><caption>PORT_PLEASE2_REQ (122)</caption><tbody><tr><td>1</td><td>N</td></tr><tr><td><strong>122</strong></td><td><strong>NodeName</strong></td></tr></tbody></table><p>where N = <strong>Length</strong> - 1.</p><table class="table table-bordered table-hover table-striped"><caption>PORT2_RESP (119) Response Indicating Error, Result > 0
</caption><tbody><tr><td>1</td><td>1</td></tr><tr><td><strong>119</strong></td><td><strong>Result</strong></td></tr></tbody></table><p>or</p><table class="table table-bordered table-hover table-striped"><caption>PORT2_RESP, Result = 0</caption><tbody><tr><td>1</td><td>1</td><td>2</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>Nlen</td><td>2</td><td>Elen</td></tr><tr><td><strong>119</strong></td><td><strong>Result</strong></td><td><strong>PortNo</strong></td><td><strong>NodeType</strong></td><td><strong>Protocol</strong></td><td><strong>HighestVersion</strong></td><td><strong>LowestVersion</strong></td><td><strong>Nlen</strong></td><td><strong>NodeName</strong></td><td><strong>Elen</strong></td><td>&gt;<strong>Extra</strong></td></tr></tbody></table><p>If <strong>Result</strong> &gt; 0, the packet only consists of
<strong>[119, Result]</strong>.</p><p>The EPMD closes the socket when it has sent the information.</p><h2>Get All Registered Names from EPMD</h2><p>This request is used through the Erlang function
<a href="../kernel/net_adm#names/1,2">kernel/net_adm#names/1,2</a>. A TCP connection is opened
to the  EPMD and this request is sent.</p><table class="table table-bordered table-hover table-striped"><caption>NAMES_REQ (110)</caption><tbody><tr><td>1</td></tr><tr><td><strong>110</strong></td></tr></tbody></table><p>The response for a <strong>NAMES_REQ</strong> is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>NAMES_RESP</caption><tbody><tr><td>4</td><td>Â </td></tr><tr><td><strong>EPMDPortNo</strong></td><td><strong>NodeInfo*</strong></td></tr></tbody></table><p><strong>NodeInfo</strong> is a string written for each active node.
When all <strong>NodeInfo</strong> has been written the connection is
closed by the EPMD.</p><p><strong>NodeInfo</strong> is, as expressed in Erlang:</p><pre><code class="">
io:format("name ~ts at port ~p~n", [NodeName, Port]).</code></pre><h2>Dump All Data from EPMD</h2><p>This request is not really used, it is to be regarded as a debug
feature.</p><table class="table table-bordered table-hover table-striped"><caption>DUMP_REQ</caption><tbody><tr><td>1</td></tr><tr><td><strong>100</strong></td></tr></tbody></table><p>The response for a <strong>DUMP_REQ</strong> is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>DUMP_RESP</caption><tbody><tr><td>4</td><td>Â </td></tr><tr><td><strong>EPMDPortNo</strong></td><td><strong>NodeInfo*</strong></td></tr></tbody></table><p><strong>NodeInfo</strong> is a string written for each node kept in the EPMD.
When all <strong>NodeInfo</strong> has been written the connection is
closed by the EPMD.</p><p><strong>NodeInfo</strong> is, as expressed in Erlang:</p><pre><code class="">
io:format("active name     ~ts at port ~p, fd = ~p~n",
          [NodeName, Port, Fd]).</code></pre><p>or</p><pre><code class="">
io:format("old/unused name ~ts at port ~p, fd = ~p ~n",
          [NodeName, Port, Fd]).</code></pre><h2>Kill EPMD</h2><p>This request kills the running EPMD. It is almost never used.</p><table class="table table-bordered table-hover table-striped"><caption>KILL_REQ</caption><tbody><tr><td>1</td></tr><tr><td><strong>107</strong></td></tr></tbody></table><p>The response for a <strong>KILL_REQ</strong> is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>KILL_RESP</caption><tbody><tr><td>2</td></tr><tr><td><strong>OKString</strong></td></tr></tbody></table><p>where <strong>OKString</strong> is "OK".</p><h2>STOP_REQ  (Not Used)</h2><table class="table table-bordered table-hover table-striped"><caption>STOP_REQ</caption><tbody><tr><td>1</td><td>n</td></tr><tr><td><strong>115</strong></td><td><strong>NodeName</strong></td></tr></tbody></table><p>where n = <strong>Length</strong> - 1.</p><p>The current implementation of Erlang does not care if the connection
to the EPMD is broken.</p><p>The response for a <strong>STOP_REQ</strong> is as follows:</p><table class="table table-bordered table-hover table-striped"><caption>STOP_RESP</caption><tbody><tr><td>7</td></tr><tr><td><strong>OKString</strong></td></tr></tbody></table><p>where <strong>OKString</strong> is "STOPPED".</p><p>A negative response can look as follows:</p><table class="table table-bordered table-hover table-striped"><caption>STOP_NOTOK_RESP</caption><tbody><tr><td>7</td></tr><tr><td><strong>NOKString</strong></td></tr></tbody></table><p>where <strong>NOKString</strong> is "NOEXIST".</p><a name="distribution_handshake"></a><h2>Distribution Handshake</h2><p>This section describes the distribution handshake protocol introduced
in Erlang/OTP R6. The handshake has remained almost the same since then.</p><h2>General</h2><p>The TCP/IP distribution uses a handshake that expects a
connection-based protocol, that is, the protocol does not include any
authentication after the handshake procedure.</p><p>This is not entirely safe, as it is vulnerable against takeover
attacks, but it is a tradeoff between fair safety and performance.</p><p>The cookies are never sent in cleartext and the handshake procedure
expects the client (called <strong>A</strong>) to be the first one to prove that
it can generate a sufficient digest. The digest is generated with the
MD5 message digest algorithm and the challenges are expected to be
random numbers.</p><h2>Definitions</h2><p>A challenge is a 32-bit integer in big-endian order. Below the function
<strong>gen_challenge()</strong> returns a random 32-bit integer used as a
challenge.</p><p>A digest is a (16 bytes) MD5 hash of the challenge (as text)
concatenated with the cookie (as text). Below, the function
<strong>gen_digest(Challenge, Cookie)</strong> generates a digest as described
above.</p><p>An <strong>out_cookie</strong> is the cookie used in outgoing communication to a
certain node, so that <strong>A</strong>'s <strong>out_cookie</strong> for <strong>B</strong> is to
correspond with <strong>B</strong>'s <strong>in_cookie</strong> for <strong>A</strong> and conversely.
<strong>A</strong>'s <strong>out_cookie</strong> for <strong>B</strong> and <strong>A</strong>'s
<strong>in_cookie</strong> for <strong>B</strong> need <em>not</em> be the same. Below the
function <strong>out_cookie(Node)</strong> returns the current node's
<strong>out_cookie</strong> for <strong>Node</strong>.</p><p>An <strong>in_cookie</strong> is the cookie expected to be used by another node
when communicating with us, so that <strong>A</strong>'s <strong>in_cookie</strong> for
<strong>B</strong> corresponds with <strong>B</strong>'s <strong>out_cookie</strong> for <strong>A</strong>.
Below the function <strong>in_cookie(Node)</strong> returns the current node's
<strong>in_cookie</strong> for <strong>Node</strong>.</p><p>The cookies are text strings that can be viewed as passwords.</p><p>Every message in the handshake starts with a 16-bit big-endian integer,
which contains the message length (not counting the two initial bytes).
In Erlang this corresponds to option <strong>{packet, 2}</strong> in
<a href="./gen_tcp">kernel/gen_tcp</a>.
Notice that after the handshake, the distribution switches to 4 byte
packet headers.</p><h2>The Handshake in Detail</h2><p>Imagine two nodes, <strong>A</strong> that initiates the handshake and <strong>B</strong>
that accepts the connection.</p><dl><dt>1) connect/accept</dt><dd> <p><strong>A</strong> connects to <strong>B</strong> through TCP/IP and <strong>B</strong> accepts
the connection.</p> </dd><dt>2) <strong>send_name</strong>/<strong>receive_name</strong></dt><dd> <p><strong>A</strong> sends an initial identification to <strong>B</strong>, which
receives the message. The message looks as follows (every "square"
is one byte and the packet header is removed):</p> <pre>
+---+--------+--------+-----+-----+-----+-----+-----+-----+-...-+-----+
|'n'|Version0|Version1|Flag0|Flag1|Flag2|Flag3|Name0|Name1| ... |NameN|
+---+--------+--------+-----+-----+-----+-----+-----+-----+-... +-----+</pre> <p>'n' is the message tag. 'Version0' and 'Version1' is the
distribution version selected by <strong>A</strong>, based on information
from the EPMD. (16-bit big-endian) 'Flag0' ... 'Flag3' are
capability flags, the capabilities are defined in
<strong>$ERL_TOP/lib/kernel/include/dist.hrl</strong>. (32-bit big-endian)
'Name0' ... 'NameN' is the full node name of <strong>A</strong>, as a string
of bytes (the packet length denotes how long it is).</p> </dd><dt>3) <strong>recv_status</strong>/<strong>send_status</strong></dt><dd> <p><strong>B</strong> sends a status message to <strong>A</strong>, which indicates if the
connection is allowed. The following status codes are defined:</p> <dl><dt><strong>ok</strong></dt><dd> <p>The handshake will continue.</p> </dd><dt><strong>ok_simultaneous</strong></dt><dd> <p>The handshake will continue, but <strong>A</strong> is informed that
<strong>B</strong> has another ongoing connection attempt that will be
shut down (simultaneous connect where <strong>A</strong>'s name is
greater than <strong>B</strong>'s name, compared literally).</p> </dd><dt><strong>nok</strong></dt><dd> <p>The handshake will not continue, as <strong>B</strong> already has an
ongoing handshake, which it itself has initiated (simultaneous
connect where <strong>B</strong>'s name is greater than <strong>A</strong>'s).</p> </dd><dt><strong>not_allowed</strong></dt><dd> <p>The connection is disallowed for some (unspecified) security
reason.</p> </dd><dt><strong>alive</strong></dt><dd> <p>A connection to the node is already active, which either means
that node <strong>A</strong> is confused or that the TCP connection
breakdown of a previous node with this name has not yet reached
node <strong>B</strong>. See step 3B below.</p> </dd></dl> <p>The format of the status message is as follows:</p> <pre>
+---+-------+-------+-...-+-------+
|'s'|Status0|Status1| ... |StatusN|
+---+-------+-------+-...-+-------+</pre> <p>'s' is the message tag. 'Status0' ... 'StatusN' is the status as a
string (not terminated).</p> </dd><dt>3B) <strong>send_status</strong>/<strong>recv_status</strong></dt><dd> <p>If status was <strong>alive</strong>, node <strong>A</strong> answers with another
status message containing either <strong>true</strong>, which means that the
connection is to continue (the old connection from this node is
broken), or <strong>false</strong>, which means that the connection is to be
closed (the connection attempt was a mistake.</p> </dd><dt>4) <strong>recv_challenge</strong>/<strong>send_challenge</strong></dt><dd> <p>If the status was <strong>ok</strong> or <strong>ok_simultaneous</strong>, the
handshake continues with <strong>B</strong> sending <strong>A</strong> another message,
the challenge. The challenge contains the same type of information
as the "name" message initially sent from <strong>A</strong> to <strong>B</strong>, plus
a 32-bit challenge:</p> <pre>
+---+--------+--------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-...-+-----+
|'n'|Version0|Version1|Flag0|Flag1|Flag2|Flag3|Chal0|Chal1|Chal2|Chal3|Name0|Name1| ... |NameN|
+---+--------+--------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-... +-----+</pre> <p>'Chal0' ... 'Chal3' is the challenge as a 32-bit big-endian integer
and the other fields are <strong>B</strong>'s version, flags, and full node
name.</p> </dd><dt>5) <strong>send_challenge_reply</strong>/<strong>recv_challenge_reply</strong></dt><dd> <p>Now <strong>A</strong> has generated a digest and its own challenge. Those
are sent together in a package to <strong>B</strong>:</p> <pre>
+---+-----+-----+-----+-----+-----+-----+-----+-----+-...-+------+
|'r'|Chal0|Chal1|Chal2|Chal3|Dige0|Dige1|Dige2|Dige3| ... |Dige15|
+---+-----+-----+-----+-----+-----+-----+-----+-----+-...-+------+</pre> <p>'r' is the tag. 'Chal0' ... 'Chal3' is <strong>A</strong>'s challenge for
<strong>B</strong> to handle. 'Dige0' ... 'Dige15' is the digest that <strong>A</strong>
constructed from the challenge <strong>B</strong> sent in the previous
step.</p> </dd><dt>6) <strong>recv_challenge_ack</strong>/<strong>send_challenge_ack</strong></dt><dd> <p><strong>B</strong> checks that the digest received from <strong>A</strong> is correct
and generates a digest from the challenge received from <strong>A</strong>.
The digest is then sent to <strong>A</strong>. The message is as follows:</p> <pre>
+---+-----+-----+-----+-----+-...-+------+
|'a'|Dige0|Dige1|Dige2|Dige3| ... |Dige15|
+---+-----+-----+-----+-----+-...-+------+</pre> <p>'a' is the tag. 'Dige0' ... 'Dige15' is the digest calculated by
<strong>B</strong> for <strong>A</strong>'s challenge.</p> </dd><dt>7) check</dt><dd> <p><strong>A</strong> checks the digest from <strong>B</strong> and the connection is
up.</p> </dd></dl><h2>Semigraphic View</h2><pre>
A (initiator)                                      B (acceptor)

TCP connect ------------------------------------&gt;
                                                   TCP accept

send_name --------------------------------------&gt;
                                                   recv_name

  &lt;---------------------------------------------- send_status
recv_status
(if status was 'alive'
 send_status - - - - - - - - - - - - - - - - - -&gt;
                                                   recv_status)
                                                   ChB = gen_challenge()
                          (ChB)
  &lt;---------------------------------------------- send_challenge
recv_challenge
ChA = gen_challenge(),
OCA = out_cookie(B),
DiA = gen_digest(ChB, OCA)
                          (ChA, DiA)
send_challenge_reply ---------------------------&gt;
                                                   recv_challenge_reply
                                                   ICB = in_cookie(A),
                                                   check:
                                                   DiA == gen_digest (ChB, ICB)?
                                                   - if OK:
                                                    OCB = out_cookie(A),
                                                    DiB = gen_digest (ChA, OCB)
                          (DiB)
  &lt;----------------------------------------------- send_challenge_ack
recv_challenge_ack                                  DONE
ICA = in_cookie(B),                                - else:
check:                                              CLOSE
DiB == gen_digest(ChA, ICA)?
- if OK:
 DONE
- else:
 CLOSE</pre><a name="dflags"></a><h2>Distribution Flags</h2><p>The following capability flags are defined:</p><dl><dt><strong>-define(DFLAG_PUBLISHED,16#1).</strong></dt><dd> <p>The node is to be published and part of the global namespace.</p> </dd><dt><strong>-define(DFLAG_ATOM_CACHE,16#2).</strong></dt><dd> <p>The node implements an atom cache (obsolete).</p> </dd><dt><strong>-define(DFLAG_EXTENDED_REFERENCES,16#4).</strong></dt><dd> <p>The node implements extended (3 Ã 32 bits) references. This
is required today. If not present, the  connection is refused.</p> </dd><dt><strong>-define(DFLAG_DIST_MONITOR,16#8).</strong></dt><dd> <p>The node implements distributed process monitoring.</p> </dd><dt><strong>-define(DFLAG_FUN_TAGS,16#10).</strong></dt><dd> <p>The node uses separate tag for funs (lambdas) in the distribution
protocol.</p> </dd><dt><strong>-define(DFLAG_DIST_MONITOR_NAME,16#20).</strong></dt><dd> <p>The node implements distributed named process monitoring.</p> </dd><dt><strong>-define(DFLAG_HIDDEN_ATOM_CACHE,16#40).</strong></dt><dd> <p>The (hidden) node implements atom cache (obsolete).</p> </dd><dt><strong>-define(DFLAG_NEW_FUN_TAGS,16#80).</strong></dt><dd> <p>The node understand new fun tags.</p> </dd><dt><strong>-define(DFLAG_EXTENDED_PIDS_PORTS,16#100).</strong></dt><dd> <p>The node can handle extended pids and ports. This is required
today. If not present, the connection is refused.</p> </dd><dt><strong>-define(DFLAG_EXPORT_PTR_TAG,16#200).</strong></dt><dd> </dd><dt><strong>-define(DFLAG_BIT_BINARIES,16#400).</strong></dt><dd> </dd><dt><strong>-define(DFLAG_NEW_FLOATS,16#800).</strong></dt><dd> <p>The node understands new float format.</p> </dd><dt><strong>-define(DFLAG_UNICODE_IO,16#1000).</strong></dt><dd> </dd><dt><strong>-define(DFLAG_DIST_HDR_ATOM_CACHE,16#2000).</strong></dt><dd> <p>The node implements atom cache in distribution header.</p> </dd><dt><strong>-define(DFLAG_SMALL_ATOM_TAGS, 16#4000).</strong></dt><dd> <p>The node understand the <strong>SMALL_ATOM_EXT</strong> tag.</p> </dd><dt><strong>-define(DFLAG_UTF8_ATOMS, 16#10000).</strong></dt><dd> <p>The node understand UTF-8 encoded atoms.</p> </dd><dt><strong>-define(DFLAG_MAP_TAG, 16#20000).</strong></dt><dd> <p>The node understand the map tag.</p> </dd><dt><strong>-define(DFLAG_BIG_CREATION, 16#40000).</strong></dt><dd> <p>The node understand big node creation.</p> </dd><dt><strong>-define(DFLAG_SEND_SENDER, 16#80000).</strong></dt><dd> <p>
Use the <strong>SEND_SENDER</strong>
<a href="#control_message">control message</a>
instead of the <strong>SEND</strong> control message and use the
<strong>SEND_SENDER_TT</strong> control message instead
of the <strong>SEND_TT</strong> control message.
</p> </dd><dt><strong>-define(DFLAG_BIG_SEQTRACE_LABELS, 16#100000).</strong></dt><dd> <p>The node understands any term as the seqtrace label.</p> </dd><dt><strong>-define(DFLAG_EXIT_PAYLOAD, 16#400000).</strong></dt><dd> <p>Use the <strong>PAYLOAD_EXIT</strong>, <strong>PAYLOAD_EXIT_TT</strong>,
<strong>PAYLOAD_EXIT2</strong>, <strong>PAYLOAD_EXIT2_TT</strong>
and <strong>PAYLOAD_MONITOR_P_EXIT</strong>
<a href="#control_message">control message</a>s
instead of the non-PAYLOAD variants.</p> </dd><dt><strong>-define(DFLAG_FRAGMENTS, 16#800000).</strong></dt><dd> <p>Use <a href="./erl_ext_dist#fragments">fragmented</a>
distribution messages to send large messages.</p> </dd></dl><p>
There is also function <strong>dist_util:strict_order_flags/0</strong>
returning all flags (bitwise or:ed together) corresponding to features
that require strict ordering of data over distribution channels.
</p><a name="connected_nodes"></a><h2>Protocol between Connected Nodes</h2><p>Since ERTS 5.7.2 (OTP R13B) the runtime system passes a distribution flag
in the handshake stage that enables the use of a
<a href="./erl_ext_dist#distribution_header">distribution header </a> on all messages passed. Messages passed between nodes have in
this case the following format:</p><table class="table table-bordered table-hover table-striped"><caption>Format of Messages Passed between Nodes (as from ERTS 5.7.2 (OTP R13B))
</caption><tbody><tr><td>4</td><td>d</td><td>n</td><td>m</td></tr><tr><td><strong>Length</strong></td><td><strong>DistributionHeader</strong></td><td><strong>ControlMessage</strong></td><td><strong>Message</strong></td></tr></tbody></table><dl><dt><strong>Length</strong></dt><dd> <p>Equal to d + n + m.</p> </dd><dt><strong>DistributionHeader</strong></dt><dd> <p>
<a href="./erl_ext_dist#distribution_header">Distribution header describing the atom cache and fragmented distribution messages. </a>
</p> </dd><dt><strong>ControlMessage</strong></dt><dd> <p>A tuple passed using the external format of Erlang.</p> </dd><dt><strong>Message</strong></dt><dd> <p>The message sent to another node using the '!'
or the reason for a EXIT, EXIT2 or DOWN signal using
the external term format.</p> </dd></dl><p>Notice that <a href="./erl_ext_dist#overall_format">the version number is omitted from the terms that follow a distribution header </a>.</p><p>Nodes with an ERTS version earlier than 5.7.2 (OTP R13B) does not pass the
distribution flag that enables the distribution header. Messages passed
between nodes have in this case the following format:</p><table class="table table-bordered table-hover table-striped"><caption>Format of Messages Passed between Nodes (before ERTS 5.7.2 (OTP R13B))
</caption><tbody><tr><td>4</td><td>1</td><td>n</td><td>m</td></tr><tr><td><strong>Length</strong></td><td><strong>Type</strong></td><td><strong>ControlMessage</strong></td><td><strong>Message</strong></td></tr></tbody></table><dl><dt><strong>Length</strong></dt><dd> <p>Equal to 1 + n + m.</p> </dd><dt><strong>Type</strong></dt><dd> <p>Equal to <strong>112</strong> (pass through).</p> </dd><dt><strong>ControlMessage</strong></dt><dd> <p>A tuple passed using the external format of Erlang.</p> </dd><dt><strong>Message</strong></dt><dd> <p>The message sent to another node using the '!' (in external format).
Notice that <strong>Message</strong> is only passed in combination with a
<strong>ControlMessage</strong> encoding a send ('!').</p> </dd></dl><a name="control_message"></a><p>The <strong>ControlMessage</strong> is a tuple, where the first element indicates
which distributed operation it encodes:</p><dl><dt><strong>LINK</strong></dt><dd> <p><strong>{1, FromPid, ToPid}</strong></p> </dd><dt><strong>SEND</strong></dt><dd> <p><strong>{2, Unused, ToPid}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p><strong>Unused</strong> is kept for backward compatibility.</p> </dd><dt><strong>EXIT</strong></dt><dd> <p><strong>{3, FromPid, ToPid, Reason}</strong></p> <p>This signal is sent when a link has been broken</p> </dd><dt><strong>UNLINK</strong></dt><dd> <p><strong>{4, FromPid, ToPid}</strong></p> </dd><dt><strong>NODE_LINK</strong></dt><dd> <p><strong>{5}</strong></p> </dd><dt><strong>REG_SEND</strong></dt><dd> <p><strong>{6, FromPid, Unused, ToName}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p><strong>Unused</strong> is kept for backward compatibility.</p> </dd><dt><strong>GROUP_LEADER</strong></dt><dd> <p><strong>{7, FromPid, ToPid}</strong></p> </dd><dt><strong>EXIT2</strong></dt><dd> <p><strong>{8, FromPid, ToPid, Reason}</strong></p> <p>This signal is sent by a call to the erlang:exit/2 bif</p> </dd></dl><h2>New Ctrlmessages for distrvsn = 1 (Erlang/OTP R4)</h2><dl><dt><strong>SEND_TT</strong></dt><dd> <p><strong>{12, Unused, ToPid, TraceToken}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p><strong>Unused</strong> is kept for backward compatibility.</p> </dd><dt><strong>EXIT_TT</strong></dt><dd> <p><strong>{13, FromPid, ToPid, TraceToken, Reason}</strong></p> </dd><dt><strong>REG_SEND_TT</strong></dt><dd> <p><strong>{16, FromPid, Unused, ToName, TraceToken}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p><strong>Unused</strong> is kept for backward compatibility.</p> </dd><dt><strong>EXIT2_TT</strong></dt><dd> <p><strong>{18, FromPid, ToPid, TraceToken, Reason}</strong></p> </dd></dl><h2>New Ctrlmessages for distrvsn = 2</h2><p><strong>distrvsn</strong> 2 was never used.</p><h2>New Ctrlmessages for distrvsn = 3 (Erlang/OTP R5C)</h2><p>None, but the version number was increased anyway.</p><h2>New Ctrlmessages for distrvsn = 4 (Erlang/OTP R6)</h2><p>These are only recognized by Erlang nodes, not by hidden nodes.</p><dl><dt><strong>MONITOR_P</strong></dt><dd> <p><strong>{19, FromPid, ToProc, Ref}</strong>, where
<strong>FromPid</strong> = monitoring process and
<strong>ToProc</strong> = monitored process pid or name (atom)</p> </dd><dt><strong>DEMONITOR_P</strong></dt><dd> <p><strong>{20, FromPid, ToProc, Ref}</strong>, where
<strong>FromPid</strong> = monitoring process and
<strong>ToProc</strong> = monitored process pid or name (atom)</p> <p>We include <strong>FromPid</strong> just in case we want to trace this.</p> </dd><dt><strong>MONITOR_P_EXIT</strong></dt><dd> <p><strong>{21, FromProc, ToPid, Ref, Reason}</strong>, where
<strong>FromProc</strong> = monitored process pid or name (atom),
<strong>ToPid</strong> = monitoring process, and
<strong>Reason</strong> = exit reason for the monitored process</p> </dd></dl><h2>New Ctrlmessages for Erlang/OTP 21</h2><dl><dt><strong>SEND_SENDER</strong></dt><dd> <p><strong>{22, FromPid, ToPid}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p>
This control message replaces the <strong>SEND</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Messages encoded before the connection has
been set up may still use the <strong>SEND</strong> control
message. However, once a <strong>SEND_SENDER</strong> or <strong>SEND_SENDER_TT</strong>
control message has been sent, no more <strong>SEND</strong>
control messages will be sent in the same direction
on the connection.
</p></div> </dd><dt><strong>SEND_SENDER_TT</strong></dt><dd> <p><strong>{23, FromPid, ToPid, TraceToken}</strong></p> <p>Followed by <strong>Message</strong>.</p> <p>
This control message replaces the <strong>SEND_TT</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> <div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Messages encoded before the connection has
been set up may still use the <strong>SEND_TT</strong> control
message. However, once a <strong>SEND_SENDER</strong> or <strong>SEND_SENDER_TT</strong>
control message has been sent, no more <strong>SEND_TT</strong>
control messages will be sent in the same direction
on the connection.
</p></div> </dd></dl><h2>New Ctrlmessages for Erlang/OTP 22</h2><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>
Messages encoded before the connection has
been set up may still use the non-PAYLOAD variant.
However, once a PAYLOAD control message has been sent,
no more non-PAYLOAD control messages will be sent in
the same direction on the connection.
</p></div><dl><dt><strong>PAYLOAD_EXIT</strong></dt><dd> <p><strong>{24, FromPid, ToPid}</strong></p> <p>Followed by <strong>Reason</strong>.</p> <p>
This control message replaces the <strong>EXIT</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> </dd><dt><strong>PAYLOAD_EXIT_TT</strong></dt><dd> <p><strong>{25, FromPid, ToPid}</strong></p> <p>Followed by <strong>Reason</strong>.</p> <p>
This control message replaces the <strong>EXIT_TT</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> </dd><dt><strong>PAYLOAD_EXIT2</strong></dt><dd> <p><strong>{26, FromPid, ToPid}</strong></p> <p>Followed by <strong>Reason</strong>.</p> <p>
This control message replaces the <strong>EXIT2</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> </dd><dt><strong>PAYLOAD_EXIT2_TT</strong></dt><dd> <p><strong>{27, FromPid, ToPid}</strong></p> <p>Followed by <strong>Reason</strong>.</p> <p>
This control message replaces the <strong>EXIT2_TT</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> </dd><dt><strong>PAYLOAD_MONITOR_P_EXIT</strong></dt><dd> <p><strong>{28, FromPid, ToPid, Ref}</strong></p> <p>Followed by <strong>Reason</strong>.</p> <p>
This control message replaces the <strong>MONITOR_P_EXIT</strong> control
message and will be sent when the distribution flag
<a href="./erl_dist_protocol#dflags">erl_dist_protocol#dflags</a>
has been negotiated in the connection setup handshake.
</p> </dd></dl></body></html>