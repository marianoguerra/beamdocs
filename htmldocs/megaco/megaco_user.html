<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>megaco_user</h1><h1>megaco_user</h1><p>Callback module for users of the Megaco application</p><p>This module defines the callback behaviour of Megaco users.  A
megaco_user compliant callback module must export the following
functions: <ul><li> <p><a href="#connect">handle_connect/2,3</a></p> </li><li> <p><a href="#disconnect">handle_disconnect/3</a></p> </li><li> <p><a href="#syntax_error">handle_syntax_error/3,4</a></p> </li><li> <p><a href="#message_error">handle_message_error/3,4</a></p> </li><li> <p><a href="#trans_request">handle_trans_request/3,4</a></p> </li><li> <p><a href="#trans_long_request">handle_trans_long_request/3,4</a></p> </li><li> <p><a href="#trans_reply">handle_trans_reply/4,5</a></p> </li><li> <p><a href="#trans_ack">handle_trans_ack/4,5</a></p> </li><li> <p><a href="#unexpected_trans">handle_unexpected_trans/3,4</a></p> </li><li> <p><a href="#request_abort">handle_trans_request_abort/4,5</a></p> </li><li> <p><a href="#segment_reply">handle_segment_reply/5,6</a></p> </li></ul>The semantics of them and their exact signatures are explained 
below. The <strong>user_args</strong> configuration parameter which may be used to
extend the argument list of the callback functions. For example,
the handle_connect function takes by default two arguments:<pre><code class="">
        handle_connect(Handle, Version)
    </code></pre>but if the <strong>user_args</strong> parameter is set to a longer
list, such as <strong>[SomePid,SomeTableRef]</strong>, the callback
function is expected to have these (in this case two) extra
arguments last in the argument list:<pre><code class="">
        handle_connect(Handle, Version, SomePid, SomeTableRef)
    </code></pre><a name="extra_argument"></a></p><h2>DATA TYPES</h2><pre><code class="">
action_request() = #'ActionRequest'{}
action_reply() = #'ActionReply'{}
error_desc() = #'ErrorDescriptor'{}
segment_no() = integer()
    </code></pre><pre><code class="">
conn_handle() = #megaco_conn_handle{}    </code></pre><p>The record initially returned by <strong>megaco:connect/4,5</strong>. 
It identifies a "virtual" connection and may be reused after a 
reconnect (disconnect + connect).</p><pre><code class="">
protocol_version() = integer()    </code></pre><p>Is the actual protocol version. In most cases the protocol
version is retrieved from the processed message, but there
are exceptions:</p><ul><li> <p>When <strong>handle_connect/2,3</strong> is triggered by an 
explicit call to <strong>megaco:connect/4,5</strong>.</p> </li><li> <p><strong>handle_disconnect/3</strong></p> </li><li> <p><strong>handle_syntax_error/3</strong></p> </li></ul><p>In these cases, the ProtocolVersion default
version is obtained from the static connection
configuration:</p><ul><li> <p><strong>megaco:conn_info(ConnHandle, protocol_version)</strong>.</p> </li></ul><a name="connect"></a><h1>Functions</h1><h2>handle_connect(ConnHandle, ProtocolVersion) -&gt; ok | error | {error,ErrorDescr}</h2><h2>handle_connect(ConnHandle, ProtocolVersion, Extra]) -&gt; ok | error | {error,ErrorDescr}</h2><p>Invoked when a new connection is established</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">ErrorDescr      = error_desc()</span></li><li><span class="v">Extra           = term()</span></li></ul><p>Invoked when a new connection is established</p><p>Connections may either be established by an explicit call to
megaco:connect/4 or implicitly at the first invocation of
megaco:receive_message/3.</p><p>Normally a Media Gateway (MG) connects explicitly while a Media
Gateway Controller (MGC) connects implicitly.</p><p>At the Media Gateway Controller (MGC) side it is possible to reject
a connection request (and send a message error reply to the gateway)
by returning <strong>{error, ErrorDescr}</strong> or simply <strong>error</strong> which
generates an error descriptor with code 402 (unauthorized) and 
reason "Connection refused by user" (this is also the case for all 
unknown results, such as exit signals or throw).</p><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_message_error/4</strong>. </p><p><strong>handle_connect/3</strong> (with <strong>Extra</strong>) 
can also be called as a result of a call to the 
<a href="./megaco#connect">megaco:connect/5</a> function
(if that function is called with the 
<strong>Extra</strong> argument different than <strong>ignore_extra</strong>. </p><a name="disconnect"></a><h2>handle_disconnect(ConnHandle, ProtocolVersion, Reason) -&gt; ok</h2><p>Invoked when a connection is teared down</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Invoked when a connection is teared down</p><p>The disconnect may either be made explicitly by a call to
megaco:disconnect/2 or implicitly when the control process
of the connection dies.</p><a name="syntax_error"></a><h2>handle_syntax_error(ReceiveHandle, ProtocolVersion, DefaultED) -&gt; reply | {reply, ED} | no_reply | {no_reply, ED}</h2><h2>handle_syntax_error(ReceiveHandle, ProtocolVersion, DefaultED, Extra) -&gt; reply | {reply, ED} | no_reply | {no_reply, ED}</h2><p>Invoked when a received message had syntax errors</p><ul><li><span class="v">ReceiveHandle    = receive_handle()</span></li><li><span class="v">ProtocolVersion  = protocol_version()</span></li><li><span class="v">DefaultED        = error_desc()</span></li><li><span class="v">ED               = error_desc()</span></li><li><span class="v">Extra            = term()</span></li></ul><p>Invoked when a received message had syntax errors</p><p>Incoming messages is delivered by megaco:receive_message/4
and normally decoded successfully. But if the decoding
failed this function is called in order to decide if the
originator should get a reply message (reply) or if the reply
silently should be discarded (no_reply).</p><p>Syntax errors are detected locally on this side of the
protocol and may have many causes, e.g. a malfunctioning
transport layer, wrong encoder/decoder selected, bad
configuration of the selected encoder/decoder etc.</p><p>The error descriptor defaults to <strong>DefaultED</strong>,
but can be overridden with an alternate one by
returning <strong>{reply,ED}</strong> or <strong>{no_reply,ED}</strong>
instead of <strong>reply</strong> and <strong>no_reply</strong> respectively.
</p><p>Any other return values (including exit signals or throw) and the
<strong>DefaultED</strong> will be used. </p><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_syntax_error/4</strong>. </p><a name="message_error"></a><h2>handle_message_error(ConnHandle, ProtocolVersion, ErrorDescr) -&gt; ok</h2><h2>handle_message_error(ConnHandle, ProtocolVersion, ErrorDescr, Extra) -&gt; ok</h2><p>Invoked when a received message just contains an error</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">ErrorDescr      = error_desc()</span></li><li><span class="v">Extra           = term()</span></li></ul><p>Invoked when a received message just contains an error
instead of a list of transactions.</p><p>Incoming messages is delivered by megaco:receive_message/4
and successfully decoded. Normally a message contains a list
of transactions, but it may instead contain an
ErrorDescriptor on top level of the message.</p><p>Message errors are detected remotely on the other side of
the protocol. And you probably don't want to reply to it,
but it may indicate that you have outstanding transactions
that not will get any response (request -&gt; reply; reply -&gt;
ack).</p><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_message_error/4</strong>. </p><a name="trans_request"></a><h2>handle_trans_request(ConnHandle, ProtocolVersion, ActionRequests) -&gt; pending() | reply() | ignore_trans_request</h2><h2>handle_trans_request(ConnHandle, ProtocolVersion, ActionRequests, Extra) -&gt; pending() | reply() | ignore_trans_request</h2><p>Invoked for each transaction request</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">ActionRequests  = [action_request()]</span></li><li><span class="v">Extra           = term()</span></li><li><span class="v">pending()       = {pending, req_data()}</span></li><li><span class="v">req_data()      = term()</span></li><li><span class="v">reply()         = {ack_action(), actual_reply()} | {ack_action(), actual_reply(), send_options()} </span></li><li><span class="v">ack_action()    = discard_ack | {handle_ack, ack_data()} | {handle_pending_ack, ack_data()} | {handle_sloppy_ack, ack_data()}</span></li><li><span class="v">actual_reply()  = [action_reply()] | error_desc()</span></li><li><span class="v">ack_data()      = term()</span></li><li><span class="v">send_options()  = [send_option()]</span></li><li><span class="v">send_option()   = {reply_timer, megaco_timer()} | {send_handle, term()} | {protocol_version, integer()}</span></li><li><span class="v">Extra           = term()</span></li></ul><p>Invoked for each transaction request</p><p>Incoming messages is delivered by megaco:receive_message/4
and successfully decoded. Normally a message contains a list
of transactions and this function is invoked for each
TransactionRequest in the message.</p><p>This function takes a list of 'ActionRequest' records and
has three main options:</p><dl><dt><strong>Return ignore_trans_request</strong></dt><dd> <p>Decide that these action requests shall be ignored
completely.</p> </dd><dt><strong>Return pending()</strong></dt><dd> <p>Decide that the processing of these action requests
will take a long time and that the originator should get
an immediate 'TransactionPending' reply as interim
response. The actual processing of these action requests
instead should be delegated to the the
handle_trans_long_request/3 callback function with the
req_data() as one of its arguments. </p> </dd><dt><strong>Return reply()</strong></dt><dd> <p>Process the action requests and either return an
error_descr() indicating some fatal error or a list of
action replies (wildcarded or not). </p> <p>If for some reason megaco is unable to deliver the reply,
the reason for this will be passed to the user via a call
to the callback function 
<a href="#trans_ack">handle_trans_ack</a>,
unless <strong>ack_action() = discard_ack</strong>. </p> <p>The ack_action() is  either:</p> <dl><dt><strong>discard_ack</strong></dt><dd> <p>Meaning that you don't care if the reply is
acknowledged or not.</p> </dd><dt><strong>{handle_ack, ack_data()} | {handle_ack, ack_data(), send_options()}</strong></dt><dd> <p>Meaning that you want an immediate acknowledgement
when the other part receives this transaction
reply. When the acknowledgement eventually is
received, the handle_trans_ack/4 callback function
will be invoked with the ack_data() as one of its
arguments. ack_data() may be any Erlang term.</p> </dd><dt><strong>{handle_pending_ack, ack_data()} | {handle_pending_ack, ack_data(), send_options()}</strong></dt><dd> <p>This has the same effect as the above, 
<em>if and only if</em> megaco has sent at least one 
pending message for this request (during the processing
of the request). If no pending message has been sent, then 
immediate acknowledgement will <em>not</em> be 
requested. </p> <p>Note that this only works as specified if the 
<strong>sent_pending_limit</strong> config option has been set to 
an integer value. </p> </dd><dt><strong>{handle_sloppy_ack, ack_data()}| {handle_sloppy_ack, ack_data(), send_options()}</strong></dt><dd> <p>Meaning that you want an acknowledgement <em>sometime</em>.
When the acknowledgement eventually is received, the 
handle_trans_ack/4 callback function will be invoked with 
the ack_data() as one of its arguments. ack_data() may be 
any Erlang term.</p> </dd></dl> </dd></dl><p>Any other return values (including exit signals or throw) will 
result in an error descriptor with code 500 (internal gateway error) 
and the module name (of the callback module) as reason. </p><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_trans_request/4</strong>. </p><a name="trans_long_request"></a><h2>handle_trans_long_request(ConnHandle, ProtocolVersion, ReqData) -&gt; reply()</h2><h2>handle_trans_long_request(ConnHandle, ProtocolVersion, ReqData, Extra) -&gt; reply()</h2><p>Optionally invoked for a time consuming transaction request</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">ReqData         = req_data()</span></li><li><span class="v">Extra           = term()</span></li><li><span class="v">req_data()      = term()</span></li><li><span class="v">reply()         = {ack_action(), actual_reply()} | {ack_action(), actual_reply(), send_options()}</span></li><li><span class="v">ack_action()    = discard_ack | {handle_ack, ack_data()} | {handle_sloppy_ack, ack_data()}</span></li><li><span class="v">actual_reply()  = [action_reply()] | error_desc()</span></li><li><span class="v">ack_data()      = term()</span></li><li><span class="v">send_options()  = [send_option()]</span></li><li><span class="v">send_option()   = {reply_timer, megaco_timer()} | {send_handle, term()} | {protocol_version, integer()}</span></li><li><span class="v">Extra           = term()</span></li></ul><p>Optionally invoked for a time consuming transaction request</p><p>If this function gets invoked or not is controlled by the
reply from the preceding call to handle_trans_request/3.
The handle_trans_request/3 function may decide to process
the action requests itself or to delegate the processing to
this function.</p><p>The req_data() argument to this function is the Erlang term
returned by handle_trans_request/3.</p><p>Any other return values (including exit signals or throw) will 
result in an error descriptor with code 500 (internal gateway error)
and the module name (of the callback module) as reason. </p><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_trans_long_request/4</strong>. </p><a name="trans_reply"></a><h2>handle_trans_reply(ConnHandle, ProtocolVersion, UserReply, ReplyData) -&gt; ok</h2><h2>handle_trans_reply(ConnHandle, ProtocolVersion, UserReply, ReplyData, Extra) -&gt; ok</h2><p>Optionally invoked for a transaction reply</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">UserReply       = success() | failure()</span></li><li><span class="v">success()       = {ok, result()} </span></li><li><span class="v">result()        = transaction_result() | segment_result()</span></li><li><span class="v">transaction_result() = action_reps()</span></li><li><span class="v">segment_result() = {segment_no(), last_segment(), action_reps()}</span></li><li><span class="v">action_reps()   = [action_reply()]</span></li><li><span class="v">failure()       = {error, reason()} | {error, ReplyNo, reason()}</span></li><li><span class="v">reason()  = transaction_reason() | segment_reason() | user_cancel_reason() | send_reason() | other_reason()</span></li><li><span class="v">transaction_reason() = error_desc()</span></li><li><span class="v">segment_reason() = {segment_no(), last_segment(), error_desc()}</span></li><li><span class="v">other_reason()   =  timeout | {segment_timeout, missing_segments()} | exceeded_recv_pending_limit | term()</span></li><li><span class="v">last_segment()  = bool()</span></li><li><span class="v">missing_segments() = [segment_no()]</span></li><li><span class="v">user_cancel_reason() = {user_cancel, reason_for_user_cancel()}</span></li><li><span class="v">reason_for_user_cancel() = term()</span></li><li><span class="v">send_reason() = send_cancelled_reason() | send_failed_reason()</span></li><li><span class="v">send_cancelled_reason() = {send_message_cancelled, reason_for_send_cancel()}</span></li><li><span class="v">reason_for_send_cancel() = term()</span></li><li><span class="v">send_failed_reason() = {send_message_failed, reason_for_send_failure()}</span></li><li><span class="v">reason_for_send_failure() = term()</span></li><li><span class="v">ReplyData       = reply_data()</span></li><li><span class="v">ReplyNo         = integer() &gt; 0</span></li><li><span class="v">reply_data()    = term()</span></li><li><span class="v">Extra           = term()</span></li></ul><p>Optionally invoked for a transaction reply</p><p>The sender of a transaction request has the option of
deciding, whether the originating Erlang process should
synchronously wait (<strong>megaco:call/3</strong>) for a reply or if the
message should be sent asynchronously (<strong>megaco:cast/3</strong>) and
the processing of the reply should be delegated this
callback function.</p><p>Note that if the reply is segmented (split into several smaller 
messages; segments), then some extra info, segment number and 
an indication if all segments of a reply has been received or
not, is also included in the <strong>UserReply</strong>. </p><p>The <strong>ReplyData</strong> defaults to 
<strong>megaco:lookup(ConnHandle, reply_data)</strong>, 
but may be explicitly overridden by a
<strong>megaco:cast/3</strong> option in order to forward info about the
calling context of the originating process.</p><p>At <strong>success()</strong>, the <strong>UserReply</strong> either contains:</p><ul><li> <p>A list of 'ActionReply' records possibly containing 
error indications.</p> </li><li> <p>A tuple of size three containing: 
the segment number, 
the <strong>last segment indicator</strong> and finally 
a list of 'ActionReply' records possibly containing error 
indications. This is of course only possible if the 
reply was segmented. </p> </li></ul><p><strong>failure()</strong> indicates an local or external error and
can be one of the following: </p><ul><li> <p>A <strong>transaction_reason()</strong>, indicates that the remote 
user has replied with an explicit transactionError.</p> </li><li> <p>A <strong>segment_reason()</strong>, indicates that the remote user 
has replied with an explicit transactionError for this 
segment. This is of course only possible if the reply was 
segmented. </p> </li><li> <p>A <strong>user_cancel_reason()</strong>, indicates that the request 
has been canceled by the user. <strong>reason_for_user_cancel()</strong> 
is the reason given in the call to the 
<a href="./megaco#cancel">cancel</a>
function.</p> </li><li> <p>A <strong>send_reason()</strong>, indicates that the transport module
<a href="./megaco_transport#send_message">send_message</a>
function did not send the message. The reason for this can be: </p> <ul><li> <p><strong>send_cancelled_reason()</strong> - the message sending was 
deliberately cancelled. <strong>reason_for_send_cancel()</strong> 
is the reason given in the <strong>cancel</strong> return
from the 
<a href="./megaco_transport#send_message">send_message</a> 
function. </p> </li><li> <p><strong>send_failed_reason()</strong> - an error occurred while attempting to 
send the message. </p> </li></ul> </li><li> <p>An <strong>other_reason()</strong>, indicates some other error such 
as: </p> <ul><li> <p><strong>timeout</strong> - the reply failed to arrive before the 
request timer expired.</p> </li><li> <p><strong>{segment_timeout, missing_segments()}</strong> - 
one or more segments
was not delivered before the expire of the segment 
timer.</p> </li><li> <p><strong>exceeded_recv_pending_limit</strong> - the pending
limit was exceeded for this request.</p> </li></ul> </li></ul><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_trans_reply/5</strong>. </p><a name="trans_ack"></a><h2>handle_trans_ack(ConnHandle, ProtocolVersion, AckStatus, AckData) -&gt; ok</h2><h2>handle_trans_ack(ConnHandle, ProtocolVersion, AckStatus, AckData, Extra) -&gt; ok</h2><p>Optionally invoked for a transaction acknowledgement</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">AckStatus       = ok | {error, reason()}</span></li><li><span class="v">reason() = user_cancel_reason() | send_reason() | other_reason()</span></li><li><span class="v">user_cancel_reason() = {user_cancel, reason_for_user_cancel()}</span></li><li><span class="v">send_reason()   = send_cancelled_reason() | send_failed_reason()</span></li><li><span class="v">send_cancelled_reason() = {send_message_cancelled, reason_for_send_cancel()}</span></li><li><span class="v">reason_for_send_cancel() = term()</span></li><li><span class="v">send_failed_reason() = {send_message_failed, reason_for_send_failure()}</span></li><li><span class="v">reason_for_send_failure() = term()</span></li><li><span class="v">other_reason()   = term()</span></li><li><span class="v">AckData          = ack_data()</span></li><li><span class="v">ack_data()       = term()</span></li><li><span class="v">Extra            = term()</span></li></ul><p>Optionally invoked for a transaction acknowledgement</p><p>If this function gets invoked or not, is controlled by the
reply from the preceding call to handle_trans_request/3.
The handle_trans_request/3 function may decide to return
{handle_ack, ack_data()} or {handle_sloppy_ack, ack_data()} 
meaning that you need an immediate acknowledgement of the 
reply and that this function should be invoked to handle the 
acknowledgement.</p><p>The ack_data() argument to this function is the Erlang term
returned by handle_trans_request/3.</p><p>If the AckStatus is ok, it is indicating that this is a
true acknowledgement of the transaction reply.</p><p>If the AckStatus is {error, Reason}, it is an indication that the
acknowledgement or even the reply (for which this is an 
acknowledgement) was not delivered, but there is no point in
waiting any longer for it to arrive. This happens when: </p><dl><dt><strong>reply_timer</strong></dt><dd> <p>The <strong>reply_timer</strong> eventually times out.</p> </dd><dt>reply send failure</dt><dd> <p>When megaco fails to send the reply (see
<a href="#trans_reply">handle_trans_reply</a>), 
for whatever reason. </p> </dd><dt>cancel</dt><dd> <p>The user has explicitly cancelled the wait 
(megaco:cancel/2).</p> </dd></dl><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_trans_ack/5</strong>. </p><a name="unexpected_trans"></a><a name="handle_unexpected_trans"></a><h2>handle_unexpected_trans(ConnHandle, ProtocolVersion, Trans) -&gt; ok</h2><h2>handle_unexpected_trans(ConnHandle, ProtocolVersion, Trans, Extra) -&gt; ok</h2><p>Invoked when an unexpected message is received</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">Trans           = #'TransactionPending'{} | #'TransactionReply'{} | #'TransactionResponseAck'{}</span></li><li><span class="v">Extra           = term()</span></li></ul><p>Invoked when a unexpected message is received</p><p>If a reply to a request is not received in time, the
megaco stack removes all info about the request from
its tables. If a reply should arrive after this has been
done the app has no way of knowing where to send this message.
The message is delivered to the "user" by calling this
function on the local node (the node which has the link).</p><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_unexpected_trans/4</strong>. </p><a name="request_abort"></a><h2>handle_trans_request_abort(ConnHandle, ProtocolVersion, TransNo, Pid) -&gt; ok</h2><h2>handle_trans_request_abort(ConnHandle, ProtocolVersion, TransNo, Pid, Extra) -&gt; ok</h2><p>Invoked when an transaction request has been aborted</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">TransNo         = integer()</span></li><li><span class="v">Pid             = undefined | pid()</span></li><li><span class="v">Extra           = term()</span></li></ul><p>Invoked when a transaction request has been aborted</p><p>This function is invoked if the originating pending limit
has been exceeded. This usually means that a request has taken 
abnormally long time to complete.</p><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_trans_request_abort/5</strong>. </p><a name="segment_reply"></a><h2>handle_segment_reply(ConnHandle, ProtocolVersion, TransNo, SegNo, SegCompl) -&gt; ok</h2><h2>handle_segment_reply(ConnHandle, ProtocolVersion, TransNo, SegNo, SegCompl, Extra) -&gt; ok</h2><p>Segment Reply Indication</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">TransNo         = integer()</span></li><li><span class="v">SegNo           = integer()</span></li><li><span class="v">SegCompl        = asn1_NOVALUE | 'NULL'</span></li><li><span class="v">Extra           = term()</span></li></ul><p>This function is called when a segment reply has been received
if the 
<a href="./megaco#conn_info">segment_reply_ind</a> 
config option has been set to true.</p><p>This is in effect a progress report.</p><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_segment_reply/6</strong>. </p></body></html>