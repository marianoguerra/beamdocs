<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Running the stack</h1><a name="starting"></a><h2>Starting</h2><p>A user may have a number of "virtual" connections to other
users. An MG is connected to at most one MGC, while an MGC may
be connected to any number of MG's. For each connection the user
selects a transport service, an encoding scheme and a user
callback module.</p><p>An MGC must initiate its transport service in order to listen
to MG's trying to connect. How the actual transport is initiated
is outside the scope of this application. However a send handle
(typically a socket id or host and port) must be provided from
the transport service in order to enable us to send the message
to the correct destination. We do however not assume anything
about this, from our point of view, opaque handle. Hopefully it
is rather small since it will passed around the system between
processes rather frequently.</p><p>A user may either be statically configured in a .config file
according to the application concept of Erlang/OTP or
dynamically started with the configuration settings as arguments
to megaco:start_user/2. These configuration settings may be
updated later on with megaco:update_conn_info/2.</p><p>The function megaco:connect/4 is used to tell the Megaco
application about which control process it should supervise,
which MID the remote user has, which callback module it should
use to send messages etc. When this "virtual" connection is
established the user may use megaco:call/3 and megaco:cast/3 in
order to send messages to the other side. Then it is up to the
MG to send its first Service Change Request message after
applying some clever algorithm in order to fight the problem
with startup avalanche (as discussed in the RFC).</p><p>The originating user will wait for a reply or a timeout
(defined by the request_timer). When it receives the reply this
will optionally be acknowledged (regulated by auto_ack), and
forwarded to the user.  If an interim pending reply is received,
the long_request_timer will be used instead of the usual
request_timer, in order to enable avoidance of spurious re-sends
of the request.</p><p>On the destination side the transport service waits for
messages. Each message is forwarded to the Megaco application
via the megaco:receive_message/4 callback function. The
transport service may or may not provide means for blocking and
unblocking the reception of the incoming messages.</p><p>If a message is received before the "virtual" connection has
been established, the connection will be setup automatically. An
MGC may be real open minded and dynamically decide which
encoding and transport service to use depending on how the
transport layer contact is performed. For IP transports two
ports are standardized, one for textual encoding and one for
binary encoding. If for example an UDP packet was received on
the text port it would be possible to decide encoding and
transport on the fly.</p><p>After decoding a message various user callback functions are
invoked in order to allow the user to act properly.  See the
megaco_user module for more info about the callback
arguments.</p><p>When the user has processed a transaction request in its
callback function, the Megaco application assembles a
transaction reply, encodes it using the selected encoding module
and sends the message back by invoking the callback
function:</p><ul><li> <p>SendMod:send_message(SendHandle, ErlangBinary)</p> </li></ul><p>Re-send of messages, handling pending transactions,
acknowledgements etc. is handled automatically by the Megaco
application but the user is free to override the default
behaviour by the various configuration possibilities. See
megaco:update_user_info/2 and megaco:update_conn_info/2 about
the possibilities.</p><p>When connections gets broken (that is explicitly by
megaco:disconnect/2 or when its controlling process dies) a user
callback function is invoked in order to allow the user to
re-establish the connection. The internal state of kept
messages, re-send timers etc. is not affected by this. A few
re-sends will of course fail while the connection is down, but
the automatic re-send algorithm does not bother about this and
eventually when the connection is up and running the messages
will be delivered if the timeouts are set to be long enough. The
user has the option of explicitly invoking megaco:cancel/2 to
cancel all messages for a connection.</p><a name="mgc_startup_call_flow"></a><h2>MGC startup call flow</h2><p>In order to prepare the MGC for the reception of the initial
message, hopefully a Service Change Request, the following needs
to be done:</p><ul><li> <p>Start the Megaco application.</p> </li><li> <p>Start the MGC user. This may either be done explicitly
with megaco:start_user/2 or implicitly by providing the -megaco
users configuration parameter.</p> </li><li> <p>Initiate the transport service and provide it with a
receive handle obtained from megaco:user_info/2.</p> </li></ul><p>When the initial message arrives the transport service
forwards it to the protocol engine which automatically
sets up the connection and invokes UserMod:handle_connect/2
before it invokes UserMod:handle_trans_request/3 with
the Service Change Request like this:</p><img src="MGC_startup_call_flow.gif" title="MGC Startup Call Flow"></img><a name="mg_startup_call_flow"></a><h2>MG startup call flow</h2><p>In order to prepare the MG for the sending of the initial
message, hopefully a Service Change Request, the following needs
to be done:</p><ul><li> <p>Start the Megaco application.</p> </li><li> <p>Start the MG user. This may either be done explicitly
with megaco:start_user/2 or implicitly by providing the -megaco
users configuration parameter.</p> </li><li> <p>Initiate the transport service and provide it with a
receive handle obtained from megaco:user_info/2.</p> </li><li> <p>Setup a connection to the MGC with megaco:connect/4 and
provide it with a receive handle obtained from
megaco:user_info/2.</p> </li></ul><p>If the MG has been provisioned with the MID of the MGC it can
be given as the RemoteMid parameter to megaco:connect/4 and the
call flow will look like this:</p><img src="MG_startup_call_flow.gif" title="MG Startup Call Flow"></img><p>If the MG cannot be provisioned with the MID of the MGC, the
MG can use the atom 'preliminary_mid' as the RemoteMid parameter
to megaco:connect/4 and the call flow will look like this:</p><img src="MG-startup_flow_noMID.gif" title="MG Startup Call Flow (no MID)"></img><a name="config_megaco"></a><h2>Configuring the Megaco stack</h2><p>There are three kinds of configuration:</p><ul><li> <p>User info - Information related to megaco users. Read/Write. </p> <p>A User is an entity identified by a MID, e.g. a MGC or a MG. </p> <p>This information can be retrieved using 
<a href="./megaco#user_info">megaco:user_info</a>. </p> </li><li> <p>Connection info - Information regarding connections. Read/Write.</p> <p>This information can be retrieved using 
<a href="./megaco#conn_info">megaco:conn_info</a>. </p> </li><li> <p>System info - System wide information. Read only.</p> <p>This information can be retrieved using 
<a href="./megaco#system_info">megaco:system_info</a>. </p> </li></ul><a name="initial_config"></a><h2>Initial configuration</h2><p>The initial configuration of the Megaco should be defined in the
Erlang system configuration file. The following configured parameters
are defined for the Megaco application:</p><ul><li> <p><strong>users = [{Mid, [user_config()]}].</strong></p> <p>Each user is represented by a tuple with the Mid of the user and a
list of config parameters (each parameter is in turn a tuple:
<strong>{Item, Value}</strong>).</p> </li><li> <p><strong>scanner = flex | {Module, Function, Arguments, Modules}</strong></p> <ul><li> <p><strong>flex</strong> will result in the start of the flex scanner with default 
options.</p> </li><li> <p>The MFA alternative makes it possible for Megaco to start and
supervise a scanner written by the user (see 
<strong>supervisor:start_child</strong> for an explanation of the 
parameters).</p> </li></ul> </li></ul><p>See also <a href="./megaco_encode#text_config">Configuration of text encoding module(s)</a> 
for more info. </p><a name="changing_config"></a><h2>Changing the configuration</h2><p>The configuration can be changed during runtime. This is done with
the functions <a href="./megaco#update_user_info">megaco:update_user_info</a> and 
<a href="./megaco#update_conn_info">megaco:update_conn_info</a></p><a name="transaction_sender"></a><h2>The transaction sender</h2><p>The transaction sender is a process (one per connection), which handle
all transaction sending, if so configured (see 
<a href="./megaco#user_info">megaco:user_info</a> and 
<a href="./megaco#conn_info">megaco:conn_info</a>).</p><p>The purpose of the transaction sender is to accumulate transactions 
for a more efficient message sending. The transactions that are 
accumulated are transaction request and transaction ack. For 
transaction ack's the benefit is quite large, since the transactions 
are small and it is possible to have ranges (which means that 
transaction acks for transactions 1, 2, 3 and 4 can be sent as a 
range 1-4 in one transaction ack, instead of four separate 
transactions). </p><p>There are a number of configuration parameter's that control the 
operation of the transaction sender. In principle, a message with 
everything stored (ack's and request's) is sent from the process 
when:</p><ul><li> <p>When <strong>trans_timer</strong> expires.</p> </li><li> <p>When <strong>trans_ack_maxcount</strong> number of ack's has been 
received.</p> </li><li> <p>When <strong>trans_req_maxcount</strong> number of requests's has 
been received.</p> </li><li> <p>When the size of all received requests exceeds 
<strong>trans_req_maxsize</strong>.</p> </li><li> <p>When a reply transaction is sent.</p> </li><li> <p>When a pending transaction is sent.</p> </li></ul><p>When something is to be sent, everything is packed into one message,  
unless the trigger was a reply transaction and the added size of the 
reply and all the requests is greater then 
<strong>trans_req_maxsize</strong>, in which case the stored 
transactions are sent first in a separate message and the reply in 
another message.</p><p>When the transaction sender receives a request which is already 
"in storage" (indicated by the transaction id) it is assumed to 
be a resend and everything stored is sent. This could happen if 
the values of the <strong>trans_timer</strong> and the
<strong>request_timer</strong> is not properly chosen.</p><a name="segment_reply"></a><h2>Segmentation of transaction replies</h2><p>In version 3 of the megaco standard the Segmentation package was
introduced. Simply, this package defines a procedure to segment 
megaco messages (transaction replies) when using a transport that 
does not automatically do this (e.g. UDP). See also
<a href="./megaco_encode#handling_versions">version3</a>.</p><p>Although it would be both pointless and counterproductive to use
segmentation on a transport that already does this (e.g. TCP), the 
megaco application does not check this. Instead, it is up to the 
user to configure this properly. </p><ul><li> <p>Receiving segmented messages: </p> <p>This is handled automatically by the megaco application. 
There is however one thing that need to be configured by the user, 
the 
<a href="./megaco#user_info">segment_recv_timer</a>
option. </p> <p>Note that the segments are delivered to the user differently 
depending on which function is used to issue the original request.
When issuing the request using the 
<a href="./megaco#cast">megaco:cast</a> function,
the segments are delivered to the user via the 
<a href="./megaco_user#trans_reply">handle_trans_reply</a>
callback function one at a time, as they arrive. But this obviously
doe not work for the 
<a href="./megaco#call">megaco:call</a> function. 
In this case, the segments are accumulated and then delivered
all at once as the function returns.</p> </li><li> <p>Sending segmented messages: </p> <p>This is also handled automatically by the megaco application. 
First of all, segmentation is only attempted if so configured, see 
the <a href="./megaco#user_info">segment_send</a> option.
Secondly, megaco relies on the ability of the used codec to
encode action replies, which is the smallest component the
megaco application handles when segmenting. Thirdly, the 
reply will be segmented only if the sum of the size of the
action replies (plus an arbitrary message header size) are greater
then the specified max message size (see the 
<a href="./megaco#user_info">max_pdu_size</a> option).
Finally, if segmentation is decided, then each action reply
will make up its own (segment) message.</p> </li></ul></body></html>