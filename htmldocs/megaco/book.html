<!doctype html>
<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"></head><body style="margin: 4em 10%"><h1>Megaco/H.248</h1><h1>Megaco/H.248</h1><p>The Megaco application is a framework for building
applications on top of the Megaco/H.248 protocol. </p><p>Megaco/H.248 is a protocol for control of elements in a
physically decomposed multimedia gateway, enabling separation of
call control from media conversion. A Media Gateway Controller
(MGC) controls one or more Media Gateways (MG).</p><p>This version of the stack supports version 1, 2 and 3 as 
defined by:</p><ul><li> <p>version 1 - RFC 3525 and H.248-IG (v10-v13)</p> </li><li> <p>version 2 - draft-ietf-megaco-h248v2-04 &amp; H.248.1 
v2 Corrigendum 1 (03/2004)</p> </li><li> <p>version 3: </p> <ul><li> <p>prev3a - as defined by TD-33 (except segments)</p> </li><li> <p>prev3b - TD-33 updated to be backward compatible with v2 
(except segments)</p> </li><li> <p>prev3c - As defined by ITU H.248.1 (09/2005) 
(except segments)</p> </li><li> <p>v3 - Full version 3 as defined by ITU H.248.1 (09/2005) 
(including segments)</p> </li></ul> </li></ul><p>The semantics of the protocol has jointly been defined by two
standardization bodies:</p><ul><li> <p>IETF - which calls the protocol Megaco</p> </li><li> <p>ITU  - which calls the protocol H.248</p> </li></ul><h4>Scope and Purpose</h4><p>This manual describes the Megaco application, as a component
of the Erlang/Open Telecom Platform development environment. It
is assumed that the reader is familiar with the Erlang
Development Environment, which is described in a separate User's
Guide.</p><h4>Prerequisites</h4><p>The following prerequisites is required for understanding the
material in the Megaco User's Guide:</p><ul><li> <p>the basics of the Megaco/H.248 protocol</p> </li><li> <p>the basics of the Abstract Syntax Notation One (ASN.1)</p> </li><li> <p>familiarity with the Erlang system and Erlang programming</p> </li></ul><p>The application requires Erlang/OTP release R10B or later.</p><h4>About This Manual</h4><p>In addition to this introductory chapter, the Megaco User's
Guide contains the following chapters:</p><ul><li> <p>Chapter 2: "Architecture" describes the architecture
and typical usage of the application.</p> </li><li> <p>Chapter 3: "Internal form and its encodings" describes
the internal form of Megaco/H.248 messages and its various
encodings.</p> </li><li> <p>Chapter 4: "Transport mechanisms" describes how
different mechanisms can be used to transport the
Megaco/H.248 messages.</p> </li><li> <p>Chapter 5: "Debugging" describes tracing and debugging.</p> </li></ul><h4>Where to Find More Information</h4><p>Refer to the following documentation for more information about
Megaco/H.248 and about the Erlang/OTP development system:</p><ul><li> <p><a href="http://www.erlang.org/project/megaco/standard/rfc3525.txt">version 1, RFC 3525</a></p> </li><li> <p><a href="http://www.ietf.org/rfc/rfc3015.txt">old version 1, RFC 3015</a></p> </li><li> <p><a href="http://www.erlang.org/project/megaco/standard/H.248.1-Corr1-200403.doc">Version 2 Corrigendum 1</a></p> </li><li> <p><a href="http://www.erlang.org/project/megaco/standard/draft-ietf-megaco-h248v2-04.txt">version 2, draft-ietf-megaco-h248v2-04</a></p> </li><li> <p><a href="http://www.itu.int/">TD-33 (Draft H.248.1 version 3)</a></p> </li><li> <p><a href="http://www.itu.int/">H.248.1 version 3</a></p> </li><li> <p>the ASN.1 application User's Guide</p> </li><li> <p>the Megaco application Reference Manual</p> </li><li> <p>Concurrent Programming in Erlang, 2nd Edition (1996),
Prentice-Hall, ISBN 0-13-508301-X.</p> </li></ul><h4>Network view</h4><p>Megaco is a (master/slave) protocol for control of gateway functions at 
the edge of the packet network. Examples of this is IP-PSTN trunking 
gateways and analog line gateways. The main function of Megaco is to 
allow gateway decomposition into a call agent (call control) part (known
as Media Gateway Controller, MGC) - master, and an gateway interface 
part (known as Media Gateway, MG) - slave. The MG has no call control 
knowledge and only handle making the connections and simple 
configurations.</p><p>SIP and H.323 are peer-to-peer protocols for call control (valid only 
for some of the protocols within H.323), or more generally multi-media 
session protocols. They both operate at a different level (call control) 
from Megaco in a decomposed network, and are therefor not aware of 
whether or not Megaco is being used underneath.</p><img src="megaco_sys_arch.gif" title="Network architecture"></img><p>Megaco and peer protocols are complementary in nature and entirely
compatible within the same system. At a system level, Megaco allows 
for</p><ul><li> <p>overall network cost and performance optimization</p> </li><li> <p>protection of investment by isolation of changes at the call 
control layer</p> </li><li> <p>freedom to geographically distribute both call function and 
gateway function</p> </li><li> <p>adaption of legacy equipment</p> </li></ul><h4>General</h4><p>This Erlang/OTP application supplies a framework for building
applications that needs to utilize the Megaco/H.248 protocol.</p><p>We have introduced the term "user" as a generic term for either
an MG or an MGC, since most of the functionality we support, is
common for both MG's and MGC's. A (local) user may be configured
in various ways and it may establish any number of connections
to its counterpart, the remote user. Once a connection has been
established, the connection is supervised and it may be used for
the purpose of sending messages. N.B. according to the standard
an MG is connected to at most one MGC, while an MGC may be
connected to any number of MG's.</p><p>For the purpose of managing "virtual MG's", one Erlang node may
host any number of MG's. In fact it may host a mix of MG's and
MGC's. You may say that an Erlang node may host any number of
"users".</p><p>The protocol engine uses callback modules to handle various
things:</p><ul><li> <p>encoding callback modules - handles the encoding and
decoding of messages. Several modules for handling different
encodings are included, such as ASN.1 BER, pretty well
indented text, compact text and some others. Others may be
written by you.</p> </li><li> <p>transport callback modules - handles sending and receiving
of messages. Transport modules for TCP/IP and UDP/IP are
included and others may be written by you.</p> </li><li> <p>user callback modules - the actual implementation of an MG
or MGC. Most of the functions are intended for handling of a
decoded transaction (request, reply, acknowledgement), but
there are others that handles connect, disconnect and
errors cases.</p> </li></ul><p>Each connection may have its own configuration of callback
modules, re-send timers, transaction id ranges etc. and they may
be re-configured on-the-fly.</p><p>In the API of Megaco, a user may explicitly send action
requests, but generation of transaction identifiers, the
encoding and actual transport of the message to the remote user
is handled automatically by the protocol engine according to the
actual connection configuration. Megaco messages are not exposed
in the API.</p><p>On the receiving side the transport module receives the message
and forwards it to the protocol engine, which decodes it and
invokes user callback functions for each transaction. When a
user has handled its action requests, it simply returns a list
of action replies (or a message error) and the protocol engine
uses the encoding module and transport module to compose and
forward the message to the originating user.</p><p>The protocol stack does also handle things like automatic
sending of acknowledgements, pending transactions, re-send of
messages, supervision of connections etc.</p><p>In order to provide a solution for scalable implementations of
MG's and MGC's, a user may be distributed over several Erlang
nodes. One of the Erlang nodes is connected to the physical
network interface, but messages may be sent from other nodes and
the replies are automatically forwarded back to the originating
node.</p><h4>Single node config</h4><p>Here a system configuration with an MG and MGC residing
in one Erlang node each is outlined:</p><img src="single_node_config.gif" title="Single node config"></img><h4>Distributed config</h4><p>In a larger system with a user (in this case an MGC)
distributed over several Erlang nodes, it looks a little bit
different. Here the encoding is performed on the originating
Erlang node (1) and the binary is forwarded to the node (2) with
the physical network interface. When the potential message reply
is received on the interface on node (2), it is decoded there
and then different actions will be taken for each transaction in
the message. The transaction reply will be forwarded in its
decoded form to the originating node (1) while the other types
of transactions will be handled locally on node (2).</p><p>Timers and re-send of messages will be handled on locally on
one node, that is node(1), in order to avoid unnecessary
transfer of data between the Erlang nodes.
</p><img src="distr_node_config.gif" title="Distributes node config"></img><h4>Message round-trip call flow</h4><p>The typical round-trip of a message can be viewed as
follows. Firstly we view the call flow on the originating
side:</p><img src="call_flow.gif" title="Message Call Flow (originating side)"></img><p>Then we continue with the call flow on the destination
side:</p><img src="call_flow_cont.gif" title="Message Call Flow (destination side)"></img><a name="starting"></a><h4>Starting</h4><p>A user may have a number of "virtual" connections to other
users. An MG is connected to at most one MGC, while an MGC may
be connected to any number of MG's. For each connection the user
selects a transport service, an encoding scheme and a user
callback module.</p><p>An MGC must initiate its transport service in order to listen
to MG's trying to connect. How the actual transport is initiated
is outside the scope of this application. However a send handle
(typically a socket id or host and port) must be provided from
the transport service in order to enable us to send the message
to the correct destination. We do however not assume anything
about this, from our point of view, opaque handle. Hopefully it
is rather small since it will passed around the system between
processes rather frequently.</p><p>A user may either be statically configured in a .config file
according to the application concept of Erlang/OTP or
dynamically started with the configuration settings as arguments
to megaco:start_user/2. These configuration settings may be
updated later on with megaco:update_conn_info/2.</p><p>The function megaco:connect/4 is used to tell the Megaco
application about which control process it should supervise,
which MID the remote user has, which callback module it should
use to send messages etc. When this "virtual" connection is
established the user may use megaco:call/3 and megaco:cast/3 in
order to send messages to the other side. Then it is up to the
MG to send its first Service Change Request message after
applying some clever algorithm in order to fight the problem
with startup avalanche (as discussed in the RFC).</p><p>The originating user will wait for a reply or a timeout
(defined by the request_timer). When it receives the reply this
will optionally be acknowledged (regulated by auto_ack), and
forwarded to the user.  If an interim pending reply is received,
the long_request_timer will be used instead of the usual
request_timer, in order to enable avoidance of spurious re-sends
of the request.</p><p>On the destination side the transport service waits for
messages. Each message is forwarded to the Megaco application
via the megaco:receive_message/4 callback function. The
transport service may or may not provide means for blocking and
unblocking the reception of the incoming messages.</p><p>If a message is received before the "virtual" connection has
been established, the connection will be setup automatically. An
MGC may be real open minded and dynamically decide which
encoding and transport service to use depending on how the
transport layer contact is performed. For IP transports two
ports are standardized, one for textual encoding and one for
binary encoding. If for example an UDP packet was received on
the text port it would be possible to decide encoding and
transport on the fly.</p><p>After decoding a message various user callback functions are
invoked in order to allow the user to act properly.  See the
megaco_user module for more info about the callback
arguments.</p><p>When the user has processed a transaction request in its
callback function, the Megaco application assembles a
transaction reply, encodes it using the selected encoding module
and sends the message back by invoking the callback
function:</p><ul><li> <p>SendMod:send_message(SendHandle, ErlangBinary)</p> </li></ul><p>Re-send of messages, handling pending transactions,
acknowledgements etc. is handled automatically by the Megaco
application but the user is free to override the default
behaviour by the various configuration possibilities. See
megaco:update_user_info/2 and megaco:update_conn_info/2 about
the possibilities.</p><p>When connections gets broken (that is explicitly by
megaco:disconnect/2 or when its controlling process dies) a user
callback function is invoked in order to allow the user to
re-establish the connection. The internal state of kept
messages, re-send timers etc. is not affected by this. A few
re-sends will of course fail while the connection is down, but
the automatic re-send algorithm does not bother about this and
eventually when the connection is up and running the messages
will be delivered if the timeouts are set to be long enough. The
user has the option of explicitly invoking megaco:cancel/2 to
cancel all messages for a connection.</p><a name="mgc_startup_call_flow"></a><h4>MGC startup call flow</h4><p>In order to prepare the MGC for the reception of the initial
message, hopefully a Service Change Request, the following needs
to be done:</p><ul><li> <p>Start the Megaco application.</p> </li><li> <p>Start the MGC user. This may either be done explicitly
with megaco:start_user/2 or implicitly by providing the -megaco
users configuration parameter.</p> </li><li> <p>Initiate the transport service and provide it with a
receive handle obtained from megaco:user_info/2.</p> </li></ul><p>When the initial message arrives the transport service
forwards it to the protocol engine which automatically
sets up the connection and invokes UserMod:handle_connect/2
before it invokes UserMod:handle_trans_request/3 with
the Service Change Request like this:</p><img src="MGC_startup_call_flow.gif" title="MGC Startup Call Flow"></img><a name="mg_startup_call_flow"></a><h4>MG startup call flow</h4><p>In order to prepare the MG for the sending of the initial
message, hopefully a Service Change Request, the following needs
to be done:</p><ul><li> <p>Start the Megaco application.</p> </li><li> <p>Start the MG user. This may either be done explicitly
with megaco:start_user/2 or implicitly by providing the -megaco
users configuration parameter.</p> </li><li> <p>Initiate the transport service and provide it with a
receive handle obtained from megaco:user_info/2.</p> </li><li> <p>Setup a connection to the MGC with megaco:connect/4 and
provide it with a receive handle obtained from
megaco:user_info/2.</p> </li></ul><p>If the MG has been provisioned with the MID of the MGC it can
be given as the RemoteMid parameter to megaco:connect/4 and the
call flow will look like this:</p><img src="MG_startup_call_flow.gif" title="MG Startup Call Flow"></img><p>If the MG cannot be provisioned with the MID of the MGC, the
MG can use the atom 'preliminary_mid' as the RemoteMid parameter
to megaco:connect/4 and the call flow will look like this:</p><img src="MG-startup_flow_noMID.gif" title="MG Startup Call Flow (no MID)"></img><a name="config_megaco"></a><h4>Configuring the Megaco stack</h4><p>There are three kinds of configuration:</p><ul><li> <p>User info - Information related to megaco users. Read/Write. </p> <p>A User is an entity identified by a MID, e.g. a MGC or a MG. </p> <p>This information can be retrieved using 
<a href="./megaco#user_info">megaco:user_info</a>. </p> </li><li> <p>Connection info - Information regarding connections. Read/Write.</p> <p>This information can be retrieved using 
<a href="./megaco#conn_info">megaco:conn_info</a>. </p> </li><li> <p>System info - System wide information. Read only.</p> <p>This information can be retrieved using 
<a href="./megaco#system_info">megaco:system_info</a>. </p> </li></ul><a name="initial_config"></a><h4>Initial configuration</h4><p>The initial configuration of the Megaco should be defined in the
Erlang system configuration file. The following configured parameters
are defined for the Megaco application:</p><ul><li> <p><strong>users = [{Mid, [user_config()]}].</strong></p> <p>Each user is represented by a tuple with the Mid of the user and a
list of config parameters (each parameter is in turn a tuple:
<strong>{Item, Value}</strong>).</p> </li><li> <p><strong>scanner = flex | {Module, Function, Arguments, Modules}</strong></p> <ul><li> <p><strong>flex</strong> will result in the start of the flex scanner with default 
options.</p> </li><li> <p>The MFA alternative makes it possible for Megaco to start and
supervise a scanner written by the user (see 
<strong>supervisor:start_child</strong> for an explanation of the 
parameters).</p> </li></ul> </li></ul><p>See also <a href="./megaco_encode#text_config">Configuration of text encoding module(s)</a> 
for more info. </p><a name="changing_config"></a><h4>Changing the configuration</h4><p>The configuration can be changed during runtime. This is done with
the functions <a href="./megaco#update_user_info">megaco:update_user_info</a> and 
<a href="./megaco#update_conn_info">megaco:update_conn_info</a></p><a name="transaction_sender"></a><h4>The transaction sender</h4><p>The transaction sender is a process (one per connection), which handle
all transaction sending, if so configured (see 
<a href="./megaco#user_info">megaco:user_info</a> and 
<a href="./megaco#conn_info">megaco:conn_info</a>).</p><p>The purpose of the transaction sender is to accumulate transactions 
for a more efficient message sending. The transactions that are 
accumulated are transaction request and transaction ack. For 
transaction ack's the benefit is quite large, since the transactions 
are small and it is possible to have ranges (which means that 
transaction acks for transactions 1, 2, 3 and 4 can be sent as a 
range 1-4 in one transaction ack, instead of four separate 
transactions). </p><p>There are a number of configuration parameter's that control the 
operation of the transaction sender. In principle, a message with 
everything stored (ack's and request's) is sent from the process 
when:</p><ul><li> <p>When <strong>trans_timer</strong> expires.</p> </li><li> <p>When <strong>trans_ack_maxcount</strong> number of ack's has been 
received.</p> </li><li> <p>When <strong>trans_req_maxcount</strong> number of requests's has 
been received.</p> </li><li> <p>When the size of all received requests exceeds 
<strong>trans_req_maxsize</strong>.</p> </li><li> <p>When a reply transaction is sent.</p> </li><li> <p>When a pending transaction is sent.</p> </li></ul><p>When something is to be sent, everything is packed into one message,  
unless the trigger was a reply transaction and the added size of the 
reply and all the requests is greater then 
<strong>trans_req_maxsize</strong>, in which case the stored 
transactions are sent first in a separate message and the reply in 
another message.</p><p>When the transaction sender receives a request which is already 
"in storage" (indicated by the transaction id) it is assumed to 
be a resend and everything stored is sent. This could happen if 
the values of the <strong>trans_timer</strong> and the
<strong>request_timer</strong> is not properly chosen.</p><a name="segment_reply"></a><h4>Segmentation of transaction replies</h4><p>In version 3 of the megaco standard the Segmentation package was
introduced. Simply, this package defines a procedure to segment 
megaco messages (transaction replies) when using a transport that 
does not automatically do this (e.g. UDP). See also
<a href="./megaco_encode#handling_versions">version3</a>.</p><p>Although it would be both pointless and counterproductive to use
segmentation on a transport that already does this (e.g. TCP), the 
megaco application does not check this. Instead, it is up to the 
user to configure this properly. </p><ul><li> <p>Receiving segmented messages: </p> <p>This is handled automatically by the megaco application. 
There is however one thing that need to be configured by the user, 
the 
<a href="./megaco#user_info">segment_recv_timer</a>
option. </p> <p>Note that the segments are delivered to the user differently 
depending on which function is used to issue the original request.
When issuing the request using the 
<a href="./megaco#cast">megaco:cast</a> function,
the segments are delivered to the user via the 
<a href="./megaco_user#trans_reply">handle_trans_reply</a>
callback function one at a time, as they arrive. But this obviously
doe not work for the 
<a href="./megaco#call">megaco:call</a> function. 
In this case, the segments are accumulated and then delivered
all at once as the function returns.</p> </li><li> <p>Sending segmented messages: </p> <p>This is also handled automatically by the megaco application. 
First of all, segmentation is only attempted if so configured, see 
the <a href="./megaco#user_info">segment_send</a> option.
Secondly, megaco relies on the ability of the used codec to
encode action replies, which is the smallest component the
megaco application handles when segmenting. Thirdly, the 
reply will be segmented only if the sum of the size of the
action replies (plus an arbitrary message header size) are greater
then the specified max message size (see the 
<a href="./megaco#user_info">max_pdu_size</a> option).
Finally, if segmentation is decided, then each action reply
will make up its own (segment) message.</p> </li></ul><p>This version of the stack is compliant with: </p><ul><li> <p>Megaco/H.248 version 1 (RFC3525)
updated according to Implementors Guide version 10-13.</p> </li><li> <p>Megaco/H.248 version 2 as defined by 
draft-ietf-megaco-h248v2-04
updated according to Implementors Guide version 10-13.</p> </li><li> <p>Megaco/H.248 version 3 as defined by 
ITU H.248.1 (09/2005).</p> </li></ul><h4>Internal form of messages</h4><p>We use the same internal form for both the binary and text
encoding.  Our internal form of Megaco/H.248 messages is heavily
influenced by the internal format used by ASN.1
encoders/decoders:</p><ul><li> <p>"SEQUENCE OF" is represented as a list.</p> </li><li> <p>"CHOICE" is represented as a tagged tuple with size 2.</p> </li><li> <p>"SEQUENCE" is represented as a record, defined in
"megaco/include/megaco_message_v1.hrl".</p> </li><li> <p>"OPTIONAL" is represented as an ordinary field in a
record which defaults to 'asn1_NOVALUE', meaning that the
field has no value.</p> </li><li> <p>"OCTET STRING" is represented as a list of unsigned integers.</p> </li><li> <p>"ENUMERATED" is represented as a single atom.</p> </li><li> <p>"BIT STRING" is represented as a list of atoms.</p> </li><li> <p>"BOOLEAN" is represented as the atom 'true' or 'false'.</p> </li><li> <p>"INTEGER" is represented as an integer.</p> </li><li> <p>"IA5String" is represented as a list of integers,
where each integer is the ASCII value of the corresponding
character.</p> </li><li> <p>"NULL" is represented as the atom 'NULL'.</p> </li></ul><p>In order to fully understand the internal form you must get
hold on a ASN.1 specification for the Megaco/H.248 protocol, 
and apply the rules above.
Please, see the documentation of the ASN.1 compiler in
Erlang/OTP for more details of the semantics in mapping between
ASN.1 and the corresponding internal form.</p><p>Observe that the 'TerminationId' record is not used in the
internal form. It has been replaced with a megaco_term_id record
(defined in "megaco/include/megaco.hrl").</p><h4>The different encodings</h4><p>The Megaco/H.248 standard defines both a plain text encoding
and a binary encoding (ASN.1 BER) and we have implemented
encoders and decoders for both. We do in fact supply five
different encoding/decoding modules.</p><p>In the text encoding, implementors have the choice of using a
mix of short and long keywords. It is also possible to add white
spaces to improve readability. We use the term compact for text
messages with the shortest possible keywords and no optional
white spaces, and the term pretty for a well indented text
format using long keywords and an indentation style like the
text examples in the Megaco/H.248 specification).</p><p>Here follows an example of a text message to give a feeling
of the difference between the pretty and compact versions of
text messages. First the pretty, well indented version with long
keywords:</p><pre>
   MEGACO/1 [124.124.124.222]
   Transaction = 9998 {
           Context = - {
                   ServiceChange = ROOT {
                           Services {
                                   Method = Restart,
                                   ServiceChangeAddress = 55555,
                                   Profile = ResGW/1,
                                   Reason = "901 Cold Boot"
                           }
                   }
           }
   }    </pre><p>Then the compact version without indentation and with short keywords:</p><pre>
 
   !/1 [124.124.124.222]
   T=9998{C=-{SC=ROOT{SV{MT=RS,AD=55555,PF=ResGW/1,RE="901 Cold Boot"}}}}    </pre><p>And the programmers view of the same message.
First a list of ActionRequest records are constructed and
then it is sent with one of the send functions in the API:</p><pre>
  Prof = #'ServiceChangeProfile'{profileName = "resgw", version = 1},
  Parm = #'ServiceChangeParm'{serviceChangeMethod  = restart,
                              serviceChangeAddress = {portNumber, 55555},
                              serviceChangeReason  = "901 Cold Boot",
                              serviceChangeProfile = Prof},
  Req = #'ServiceChangeRequest'{terminationID = [?megaco_root_termination_id],
                                serviceChangeParms = Parm},
  Actions = [#'ActionRequest'{contextId = ?megaco_null_context_id,
                              commandRequests = {serviceChangeReq, Req}}],
  megaco:call(ConnHandle, Actions, Config).    </pre><p>And finally a print-out of the entire internal form:</p><pre>
  {'MegacoMessage',
   asn1_NOVALUE,
   {'Message',
    1,
    {ip4Address,{'IP4Address', [124,124,124,222], asn1_NOVALUE}},
    {transactions,
     [
      {transactionRequest,
       {'TransactionRequest',
         9998,
         [{'ActionRequest',
           0,
           asn1_NOVALUE,
           asn1_NOVALUE,
           [
            {'CommandRequest',
             {serviceChangeReq,
              {'ServiceChangeRequest',
               [
                {megaco_term_id, false, ["root"]}],
                {'ServiceChangeParm',
                 restart,
                 {portNumber, 55555},
                 asn1_NOVALUE,
                 {'ServiceChangeProfile', "resgw", version = 1},
                 "901 MG Cold Boot",
                 asn1_NOVALUE,
                 asn1_NOVALUE,
                 asn1_NOVALUE
                }
              }
             },
             asn1_NOVALUE,
             asn1_NOVALUE
            }
           ]
          }
         ]
       }
      }
     ]
    }
   }
  }     </pre><p>The following encoding modules are provided:
</p><ul><li> <p>megaco_pretty_text_encoder - encodes messages into
pretty text format, decodes both pretty as well as compact
text.</p> </li><li> <p>megaco_compact_text_encoder - encodes messages into
compact text format, decodes both pretty as well as compact
text.</p> </li><li> <p>megaco_binary_encoder - encode/decode ASN.1 BER messages.
This encoder implements the fastest of the BER encoders/decoders.
Recommended binary codec.</p> </li><li> <p>megaco_ber_encoder - encode/decode ASN.1 BER 
messages.</p> </li><li> <p>megaco_per_encoder - encode/decode ASN.1 PER
messages. N.B. that this format is not included in the
Megaco standard.</p> </li><li> <p>megaco_erl_dist_encoder - encodes messages into Erlangs
distribution format. It is rather verbose but encoding and
decoding is blinding fast. N.B. that this format is not 
included in the Megaco standard.</p> </li></ul><a name="erl_dist_config"></a><h4>Configuration of Erlang distribution encoding module</h4><p>The encoding_config of the megaco_erl_dist_encoder module
may be one of these:</p><ul><li> <p><strong>[]</strong> - Encodes the messages to the standard distribution
format. It is rather verbose but encoding and decoding is
blinding fast.</p> </li><li> <p><strong>[megaco_compressed]</strong> - Encodes the messages to the
standard distribution format after an internal transformation. 
It is less verbose, but the total time of the encoding and 
decoding will on the other hand be somewhat slower (see the 
<a href="megaco_performance">performance</a> 
chapter for more info).</p> </li><li> <p><strong>[{megaco_compressed, Module}]</strong> - Works in the same
way as the megaco_compressed config parameter, only here the 
user provide their own compress module. This module must 
implement the 
<a href="megaco_edist_compress">megaco_edist_compress</a> 
behaviour.</p> </li><li> <p><strong>[compressed]</strong> - Encodes the messages to a compressed
form of the standard distribution format. It is less
verbose, but the encoding and decoding will on the other
hand be slower.</p> </li></ul><a name="text_config"></a><h4>Configuration of text encoding module(s)</h4><p>When using text encoding(s), there is actually two different
configs controlling what software to use:</p><ul><li> <p><strong>[]</strong> - An empty list indicates that the erlang
scanner should be used.</p> </li><li> <p><strong>[{flex, port()}]</strong> - Use the flex scanner when 
decoding (not optimized for SMP). See 
<a href="./megaco_run#initial_config">initial configuration</a> 
for more info.</p> </li><li> <p><strong>[{flex, ports()}]</strong> - Use the flex scanner when 
decoding (optimized for SMP). See 
<a href="./megaco_run#initial_config">initial configuration</a> 
for more info.</p> </li></ul><p>The Flex scanner is a Megaco scanner written as a linked in driver 
(in C). There are two ways to get this working:</p><ul><li> <p>Let the Megaco stack start the flex scanner 
(load the driver).</p> <p>To make this happen the megaco stack has to be configured: </p> <ul><li> <p>Add the <strong>{scanner, flex}</strong> (or similar) directive to an 
Erlang system config file for the megaco app (see 
<a href="./megaco_run#initial_config">initial configuration</a> 
chapter for details). </p> </li><li> <p>Retrieve the encoding-config using the
<a href="./megaco#system_info">system_info</a> 
function (with <strong>Item = text_config</strong>). </p> </li><li> <p>Update the receive handle with the encoding-config 
(the <strong>encoding_config</strong> field). </p> </li></ul> <p>The benefit of this is that Megaco handles the starting, holding
and the supervision of the driver and port.</p> </li><li> <p>The Megaco client (user) starts the flex scanner (load the driver).</p> <p>When starting the flex scanner a port to the linked in driver is 
created. This port has to be owned by a process. This process must not
die. If it does the port will also terminate. Therefor:</p>  <ul><li> <p>Create a permanent process. Make sure this process is
supervised (so that if it does die, this will be noticed).</p> </li><li> <p>Let this process start the flex scanner by calling the 
<strong>megaco_flex_scanner:start/0,1</strong> function.</p> </li><li> <p>Retrieve the encoding-config and when initiating
the <strong>megaco_receive_handle</strong>, set the 
field <strong>encoding_config</strong> accordingly.</p> </li><li> <p>Pass the <strong>megaco_receive_handle</strong> to the 
transport module.</p> </li></ul> </li></ul><a name="binary_config"></a><h4>Configuration of binary encoding module(s)</h4><p>When using binary encoding, the structure of the termination id's 
needs to be specified.</p><ul><li> <p><strong>[native]</strong> - skips the transformation phase, i.e. 
the decoded message(s) will not be transformed into our internal
form.</p> </li><li> <p><strong>[integer()]</strong> - A list containing the size (the number 
of bits) of each level. Example: <strong>[3,8,5,8]</strong>.</p> </li><li> <p><strong>integer()</strong> - Number of one byte (8 bits) levels.
N.B. This is currently converted into the previous config. 
Example: <strong>3</strong> (<strong>[8,8,8]</strong>).</p> </li></ul><a name="handling_versions"></a><h4>Handling megaco versions</h4><p>Since the version 3 implemented, in this version of the Megaco 
application, is preliminary, it is necessary to have a way
to handle different version 3 implementations. For this reason
the encoding config option <strong>{version3, version3()}</strong> has been 
introduced. This option, if present, has to be <em>first</em> in the 
encoding config list. Version 1 and 2 codec's ignore this option, if 
found. </p><pre><code class="">
version3() -&gt; prev3a | prev3b | prev3c | v3    </code></pre><ul><li> <p><em>prev3a</em></p> <p>Preliminary version 3, based on TD-33</p> </li><li> <p><em>prev3b</em></p> <p>Preliminary version 3, based on TD-33, but text encoding 
updated with the final solution for priority in 
<strong>contextProperty</strong> (which is backward compatible with v2).</p> </li><li> <p><em>prev3c</em></p> <p>Preliminary version 3, based on the final version of the 
v3-standard, but <em>excluding</em> segments!</p> </li><li> <p><em>v3</em></p> <p>Full version 3. Including segmentation. This is the default
version 3 variant (i.e. if a version 3 messages is to be 
encoded/decoded and no version3 encoding config is found, 
then v3 is assumed).</p> </li></ul><p>There are two ways to handle the different megaco encoding versions.
Either using <em>dynamic version detection</em> (only valid for
for incoming messages) or by <em>explicit version</em> setting in 
the connection info.</p><p>For incoming messages:</p><ul><li> <p>Dynamic version detection</p> <p>Set the protocol version in the megaco_receive_handle to 
<strong>dynamic</strong> (this is the default).
<br/>This works for those codecs that support partial decode of the 
version, currently <em>text</em>, and ber_bin 
(<strong>megaco_binary_encoder</strong> and <strong>megaco_ber_bin_encoder</strong>). 
<br/>This way the decoder will detect which version is used and 
then use the proper decoder. </p> </li><li> <p>Explicit version</p> <p>Explicitly set the actual protocol version in the 
megaco_receive_handle.
<br/>Start with version 1. When the initial service change has been 
performed and version 2 has been negotiated, upgrade the 
megaco_receive_handle of the transport process (control_pid) to 
version 2.
See 
<a href="./megaco_tcp#upgrade_receive_handle">megaco_tcp</a>
and 
<a href="./megaco_udp#upgrade_receive_handle">megaco_udp</a>.
<br/>Note that if <strong>udp</strong> is used, the same transport process 
could be used for several connections. This could make upgrading 
impossible.
<br/>For codecs that does not support partial decode of the version, 
currently <strong>megaco_ber_encoder</strong>, <strong>megaco_per_encoder</strong>
and <strong>megaco_per_bin_encoder</strong>, <strong>dynamic</strong> will revert to 
version 1.</p> </li></ul><p>For outgoing messages:</p><ul><li> <p>Update the connection info protocol_version.</p> </li><li> <p>Override protocol version when sending a message by adding the
item <strong>{protocol_version, integer()}</strong> to the Options.
See 
<a href="./megaco#call">call</a> or
<a href="./megaco#cast">cast</a>.
<br/>Note that this does not effect the messages that are sent
autonomously by the stack. They use the protocol_version of the
connection info.</p> </li></ul><h4>Encoder callback functions</h4><p>The encoder callback interface is defined by the <strong>megaco_encoder</strong> 
behaviour, see <a href="megaco_encoder">megaco_encoder</a>.</p><h4>Callback interface</h4><p>The callback interface of the transport module contains several
functions. Some of which are mandatory while others are only
optional: </p><ul><li> <p><strong>send_message</strong> - Send a message. <em>Mandatory</em></p> </li><li> <p><strong>block</strong> - Block the transport. <em>Optional</em></p> <p>This function is usefull for flow control.</p> </li><li> <p><strong>unblock</strong> - Unblock the transport. <em>Optional</em></p> </li></ul><p>For more detail, see the 
<a href="megaco_transport">megaco_transport</a>
behaviour definition.</p><h4>Examples</h4><p>The Megaco/H.248 application contains implementations
for the two protocols specified by the Megaco/H.248 standard;
UDP, see <a href="megaco_udp">megaco_udp</a>, 
and TCP/TPKT, see <a href="megaco_tcp">megaco_tcp</a>. </p><h4>A simple Media Gateway Controller</h4><p>In megaco/examples/simple/megaco_simple_mgc.erl there is an
example of a simple MGC that listens on both text and binary
standard ports and is prepared to handle a Service Change
Request message to arrive either via TCP/IP or UDP/IP. Messages
received on the text port are decoded using a text decoder and
messages received on the binary port are decoded using a binary
decoder.</p><p>The Service Change Reply is encoded in the same way as the
request and sent back to the MG with the same transport
mechanism UDP/IP or TCP/IP.</p><p>After this initial service change message the connection
between the MG and MGC is fully established and supervised.</p><p>The MGC, with its four listeners, may be started with:</p><pre>
      cd megaco/examples/simple
      erl -pa ../../../megaco/ebin -s megaco_filter -s megaco
      megaco_simple_mgc:start().
    </pre><p>or simply 'gmake mgc'.</p><p>The -s megaco_filter option to erl implies, the event tracing
mechanism to be enabled and an interactive sequence chart tool
to be started. This may be quite useful in order to visualize
how your MGC interacts with the Megaco/H.248 protocol stack.</p><p>The event traces may alternatively be directed to a file for
later analyze. By default the event tracing is disabled, but it
may dynamically be enabled without any need for re-compilation
of the code.
</p><h4>A simple Media Gateway</h4><p>In megaco/examples/simple/megaco_simple_mg.erl there is an
example of a simple MG that connects to an MGC, sends a Service
Change Request and waits synchronously for a reply.</p><p>After this initial service change message the connection
between the MG and MGC is fully established and supervised.</p><p>Assuming that the MGC is started on the local host, four
different MG's, using text over TCP/IP, binary over TCP/IP, text
over UDP/IP and binary over UDP/IP may be started on the same
Erlang node with:</p><pre>
      cd megaco/examples/simple
      erl -pa ../../../megaco/ebin -s megaco_filter -s megaco
      megaco_simple_mg:start().
    </pre><p>or simply 'gmake mg'.</p><p>If you "only" want to start a single MG which tries to connect
an MG on a host named "baidarka", you may use one of these
functions (instead of the megaco_simple_mg:start/0 above):</p><pre>
      megaco_simple_mg:start_tcp_text("baidarka", []).
      megaco_simple_mg:start_tcp_binary("baidarka", []).
      megaco_simple_mg:start_udp_text("baidarka", []).
      megaco_simple_mg:start_udp_binary("baidarka", []).
    </pre><p>The -s megaco_filter option to erl implies, the event tracing
mechanism to be enabled and an interactive sequence chart tool
to be started. This may be quite useful in order to visualize
how your MG interacts with the Megaco/H.248 protocol stack.</p><p>The event traces may alternatively be directed to a file for
later analyze. By default the event tracing is disabled, but it
may dynamically be enabled without any need for re-compilation
of the code.
</p><h4>Intro</h4><p>The Megaco mib is as of yet not standardized and our
implementation is based on
<em>draft-ietf-megaco-mib-04.txt</em>.  Almost all of the mib
cannot easily be implemented by the megaco application. Instead
these things should be implemented by a user (of the megaco
application). </p><p>So what part of the mib is implemented? Basically the relevant
statistic counters of the <em>MedGwyGatewayStatsEntry</em>.</p><h4>Statistics counters</h4><p>The implementation of the statistic counters is
lightweight. I.e.  the statistic counters are handled
separately by different entities of the application. For
instance our two transport module(s) (see <a href="./megaco_tcp#stats">megaco_tcp</a> and <a href="./megaco_udp#stats">megaco_udp</a>) maintain their
own counters and the application engine (see <a href="./megaco#stats">megaco</a>) maintain its own
counters.</p><p>This also means that if a user implement their own transport
service then it has to maintain its own statistics.</p><h4>Distribution</h4><p>Each megaco application maintains its own set of counters. So
in a large (distributed) MG/MGC it could be necessary to
collect the statistics from several nodes (each) running the
megaco application (only one of them with the transport).</p><h4>Comparison of encoder/decoders</h4><p>The Megaco/H.248 standard defines both a plain text encoding and a 
binary encoding (ASN.1 BER) and we have implemented encoders and 
decoders for both. We do supply a bunch of different encoding/decoding 
modules and the user may in fact implement their own (like our erl_dist 
module). Using a non-standard encoding format has its obvious drawbacks, 
but may be useful in some configurations.</p><p>We have made four different measurements of our Erlang/OTP 
implementation of the Megaco/H.248 protocol stack, in order to compare 
our different encoders/decoders. The result of each one is summarized 
in the table below.</p><p>The result above are the fastest 
of these configurations for each codec. The figures presented are 
the average of all used messages.</p><p>For comparison, also included are first, performance figures with
megaco (including the measurement software) and asn1 applications 
hipe-compiled (second figure in the time columns, note that per bin 
decode had some issues so those figures are not included), and second, 
performance figures where the flex driver was built as 
<strong>non-reentrant</strong> flex
(third figure in the time columns, 
only valid for text codecs using the flex-scanner, 
figures within parenthesis). </p><table class="table table-bordered table-hover table-striped"><caption>Codec performance</caption><tbody><tr><td><em>Codec and config</em></td><td><em>Size</em></td><td><em>Encode</em></td><td><em>Decode</em></td><td><em>Total</em></td></tr><tr><td>pretty</td><td>336</td><td>20 / 13</td><td>75 / 40</td><td>95 / 53</td></tr><tr><td>pretty [flex]</td><td>336</td><td>20 / 13 / 20</td><td>39 / 33 / 38</td><td>59 / 46 / 58</td></tr><tr><td>compact</td><td>181</td><td>17 / 10</td><td>62 / 35</td><td>79 / 45</td></tr><tr><td>compact [flex]</td><td>181</td><td>17 / 10 / 17</td><td>37 / 31 / 36</td><td>54 / 41 / 53</td></tr><tr><td>per bin</td><td>91</td><td>60 / 29</td><td>64 / -</td><td>124 / -</td></tr><tr><td>per bin [driver]</td><td>91</td><td>39 / 24</td><td>42 / 26</td><td>81 / 50</td></tr><tr><td>per bin [native]</td><td>91</td><td>45 / 21</td><td>48 / -</td><td>93 / -</td></tr><tr><td>per bin [driver,native]</td><td>91</td><td>25 / 15</td><td>27 / 18</td><td>52 / 33</td></tr><tr><td>ber bin</td><td>165</td><td>32 / 19</td><td>38 / 21</td><td>70 / 40</td></tr><tr><td>ber bin [driver]</td><td>165</td><td>32 / 19</td><td>33 / 20</td><td>65 / 39</td></tr><tr><td>ber bin [native]</td><td>165</td><td>17 / 11</td><td>25 / 13</td><td>42 / 24</td></tr><tr><td>ber bin [driver,native]</td><td>165</td><td>17 / 11</td><td>17 / 12</td><td>34 / 23</td></tr><tr><td>erl_dist</td><td>875</td><td>5  /  5</td><td>10 / 10</td><td>15 / 15</td></tr><tr><td>erl_dist [megaco_compressed]</td><td>405</td><td>6  / 4</td><td>7  / 4</td><td>13 / 8</td></tr><tr><td>erl_dist [compressed]</td><td>345</td><td>47 / 47</td><td>20 / 20</td><td>67 / 67</td></tr><tr><td>erl_dist [megaco_compressed,compressed]</td><td>200</td><td>34 / 33</td><td>11 /  9</td><td>45 / 42</td></tr></tbody></table><h4>System performance characteristics</h4><p>This is primarily a way to show the effects of using the 
reentrant flex scanner instead of the non-reentrant. </p><p>As can be seen from the figures above there is no real difference 
between a non-reentrant and an reentrant flex scanner when it 
comes to the decode times of an individual message. </p><p>The real difference is instead in system characteristics, which 
is best shown with the mstone1 test. </p><p>When running SMP erlang on a multi-core machine the "throughput"
is significantly higher. The mstone1 test is an extreme test,
but it shows what is gained by using the reentrant flex-scanner. </p><img src="mstone1.jpg" title="MStone1 with mstone1.sh -d flex -s 4"></img><h4>Description of encoders/decoders</h4><p>In Appendix A of the Megaco/H.248 specification (RFC 3525), there are 
about 30 messages that shows a representative call flow. We have also 
added a few extra version 1, version 2 and version 3 messages. 
We have used these messages as basis for our measurements. 
Our figures have not been weighted in regard to how frequent 
the different kinds of messages that are sent between the media 
gateway and its controller.</p><p>The test compares the following encoder/decoders:</p><ul><li> <p><em>pretty</em> - pretty printed text. In the text encoding, 
the protocol stack implementors have the choice of using a 
mix of short and long keywords. It is also possible to add 
white spaces to improve readability. The pretty text encoding 
utilizes long keywords and an indentation style like the 
text examples in the Megaco/H.248 specification.</p> </li><li> <p><em>compact</em> - the compact text encoding uses the shortest 
possible keywords and no optional white spaces.</p> </li><li> <p><em>ber</em> - ASN.1 BER.</p> </li><li> <p><em>per</em> - ASN.1 PER. Not standardized as a valid 
Megaco/H.248 encoding, but included for the matter of completeness 
as its encoding is extremely compact.</p> </li><li> <p><em>erl_dist</em> - Erlang's native distribution format. Not 
standardized as a valid Megaco/H.248 encoding, but included 
as a reference due to its well known performance characteristics. 
Erlang is a dynamically typed language and any Erlang data 
structure may be serialized to the erl_dist format by using 
built-in functions.</p> </li></ul><p>The actual encoded messages have been collected in one directory per 
encoding type, containing one file per encoded message.</p><p>Here follows an example of a text message to give a feeling of the 
difference between the pretty and compact versions of text messages. 
First the pretty printed, well indented version with long keywords:</p><pre>
MEGACO/1 [124.124.124.222] 
  Transaction = 9998 { 
    Context = - { 
      ServiceChange = ROOT { 
        Services { 
          Method = Restart, 
          ServiceChangeAddress = 55555, 
          Profile = ResGW/1, 
          Reason = "901 MG Cold Boot"
        }
      }  
    }
  }    </pre><p>Then the compact text version without indentation and with short 
keywords:</p><pre>
!/1 [124.124.124.222] T=9998{
  C=-{SC=ROOT{SV{MT=RS,AD=55555,PF=ResGW/1,RE="901 MG Cold Boot"}}}}    </pre><h4>Setup</h4><p>The measurements has been performed on a 
HP xw4600 Workstation with 
a Intel(R) Core(TM)2 Quad CPU Q9550 @ 2.83GHz, with 4 GB memory and 
running Ubuntu 10.04 x86_64, kernel 2.6.32-22-generic. 
Software versions was open source OTP R13B04 (megaco-3.14).</p><h4>Summary</h4><p>In our measurements we have seen that there are no significant 
differences in message sizes between ASN.1 BER and the compact 
text format. Some care should be taken when using the pretty text 
style (which is used in all the examples included in the protocol 
specification and preferred during debugging sessions) since the 
messages can then be quite large. If the message size really is a 
serious issue, our per encoder should be used, as the ASN.1 PER 
format is much more compact than all the other alternatives. Its 
major drawback is that it is has not been approved as a valid 
Megaco/H.248 message encoding.</p><p>When it comes to pure encode/decode performance, it turns out that:</p><ul><li> <p>our fastest binary encoder (ber) is about equal 
to our fastest text encoder (compact). </p> </li><li> <p>our fastest binary decoder (ber) is about 54% (61%) faster than our 
fastest text decoder (compact). </p> </li></ul><p>If the pure encode/decode performance really is a serious issue, our 
erl_dist encoder could be used, as the encoding/decoding of the 
erlang distribution format is much faster than all the other 
alternatives. Its major drawback is that it is has not been approved 
as a valid Megaco/H.248 message encoding.</p><p>There is no performance advantage of building (and using) a 
non-reentrant flex scanner over a reentrant flex scanner (if flex
supports building such a scanner). </p><div class="alert alert-info"><h4 class="alert-heading">Note</h4><p>Please, observe that these performance figures are related to our 
implementation in Erlang/OTP. Measurements of other implementations 
using other tools and techniques may of course result in other 
figures. </p></div><h4>Tracing</h4><p>We have instrumented our code in order to enable
tracing. Running the application with tracing deactivated,
causes a negligible performance overhead (an external call to a
function which returns an atom). Activation of tracing does not
require any recompilation of the code, since we rely on
Erlang/OTP's built in support for dynamic trace activation. In
our case tracing of calls to a given external function.</p><p>Event traces can be viewed in a generic message sequence chart
tool, <strong>et</strong>, or as standard output (events are written to stdio). </p><p>See <a href="./megaco#enable_trace">enable_trace</a>, 
<a href="./megaco#disable_trace">disable_trace</a> and
<a href="./megaco#set_trace">set_trace</a> for
more info. </p><h4>Measurement and transformation</h4><p>We have included some simple tool(s) for codec measurement (meas),
performance tests (mstone1 and mstone2) and message transformation.</p><p>The tool(s) are located in the example/meas directory.</p><h4>Requirement</h4><ul><li> <p>Erlang/OTP, version R13B01 or later.</p> </li><li> <p>Version 3.11 or later of <em>this</em> application.</p> </li><li> <p>Version 1.6.10 or later of the <em>asn1</em> application. </p> </li><li> <p>The flex libraries. Without it, the flex powered codecs cannot 
be used.</p> </li></ul><h4>Meas results</h4><p>The results from the measurement run (meas) is four 
excel-compatible textfiles: </p><ul><li> <p>decode_time.xls  -&gt; Decoding result</p> </li><li> <p>encode_time.xls  -&gt; Encoding result</p> </li><li> <p>total_time.xls   -&gt; Total (Decoding+encoding) result</p> </li><li> <p>message_size.xls -&gt; Message size</p> </li></ul><h4>Instruction</h4><p>The tool contain four things:
</p><ul><li> <p>The transformation module</p> </li><li> <p>The measurement (meas) module(s)</p> </li><li> <p>The mstone (mstone1 and mstone2) module(s)</p> </li><li> <p>The basic message file</p> </li></ul><h4>Message Transformation</h4><p>The messages used by the different tools are contained in 
single message package file (see below for more info). The messages
in this file is encoded with just one codec. During 
measurement initiation, the messages are read and then transformed to all
codec formats used in the measurement. </p><p>The message transformation is done by the transformation module.
It is used to transform a set of messages encoded with one codec 
into the other base codec's.</p><h4>Measurement(s)</h4><p>There are two different measurement tools: </p><ul><li> <p><em>meas</em>: </p> <p>Used to perform codec measurements. That is, to see what 
kind of performance can be expected by the different codecs 
provided by the megaco application. </p> <p>The measurement is done by iterating over the decode/encode 
function for approx 2 seconds per message and counting 
the number of decodes/encodes.</p> <p>Is best run by modifying the meas.sh.skel skeleton script
provided by the tool.</p> <p>To run it manually do the following: </p> <pre><code class="">
        % erl -pa &lt;path-megaco-ebin-dir&gt; -pa &lt;path-to-meas-module-dir&gt;
        Erlang (BEAM) emulator version 5.6 [source]

        Eshell V5.7.1  (abort with ^G)
        1&gt; megaco_codec_meas:start().
        ...
        2&gt; halt().
        </code></pre> <p>or to make it even easier, assuming a measure shall be 
done on all the codecs (as above):</p> <pre><code class="">
        % erl -noshell -pa &lt;path-megaco-ebin-dir&gt; \\
              -pa &lt;path-to-meas-module-dir&gt; \\
              -s megaco_codec_meas -s init stop
        </code></pre> <p>When run as above (this will take some time), the measurement 
process is done as follows:</p> <pre>
For each codec:
    For each message:
        Read the message from the file
            Detect message version
            Measure decode
                Measure encode
          Write results, encode, decode and total, to file
        </pre> </li><li> <p><em>mstone1 and mstone2</em>: </p> <p>These are two different SMP performance monitoring tool(s). </p> <p><em>mstone1</em> creates a process for each codec config supported by 
the megaco application and let them run for a specific 
time (all at the same time), encoding and decoding 
megaco messages. The number of messages processed in total 
is the mstone1(1) value. </p> <p>There are different ways to run the mstone1 tool, e.g. with or without 
the use of drivers, with <em>only</em> flex-empowered configs. </p> <p>Is best run by modifying the mstone1.sh.skel skeleton script
provided by the tool.</p> <p>The <em>mstone2</em> is similar to the <em>mstone1</em> tool,
but in this case, each created process makes only <em>one</em> run 
through the messages and then exits. A soon as a process exits,
a new process (with the same config and messages) is created to takes 
its place. 
The number of messages processed in total 
is the mstone2(1) value. </p> </li></ul><p>Both these tools use the message package (time_test.msgs) provided
with the tool(s), although it can run on any message package as long as
it has the same structure. </p><h4>Message package file</h4><p>This is simply an erlang compatible text-file with the following 
structure: <strong>{codec_name(), messages_list()}</strong>. </p><pre>
codec_name() = pretty | compact | ber | per | erlang      (how the messages are encoded)
messages_list() = [{message_name(), message()}]
message_name() = atom()
message() = binary()
</pre><p>The codec name is the name of the codec with which all messages in
the <strong>message_list()</strong> has been encoded. </p><p>This file can be <strong>exported</strong> to a file structure by calling the 
<a href="./megaco_codec_transform#export_messages">export_messages</a>
function. This can be usefull if a measurement shall be done with
an external tool. Exporting the messages creates a directory tree 
with the following structure:
</p><pre><code class="">
&lt;message package&gt;/pretty/&lt;message-files&gt;
                  compact/
                  per/
                  ber/&lt;message-files&gt;
                  erlang/
        </code></pre><p>The file includes both version 1, 2 and version 3 messages.</p><h4>Notes</h4><h4>Binary codecs</h4><p>There are two basic ways to use the binary encodings: 
With package related name and termination id transformation
(the 'native' encoding config) or without. This transformation 
converts package related names and termination id's to a more 
convenient internal form (equivalent with the decoded text message).</p><p>The transformation is done _after_ the actual decode has been 
done.</p><p>Furthermore, it is possible to make use of a linked in driver that 
performs some of the decode/encode, decode for ber and encode for per 
(the 'driver' encoding config).</p><p>Therefor in the tests, binary codecs are tested with four 
different encoding configs to determine exactly how the
different options effect the performance: with transformation and 
without driver ([]), without transformation and without driver 
([native]), with transformation and with driver ([driver]) and 
finally without transformation and with driver ([driver,native]).</p><h4>Included test messages</h4><p>Some of these messages are ripped from the call flow examples 
in an old version of the RFC and others are created to test
a specific feature of megaco. </p><h4>Measurement tool directory name</h4><p>Be sure <em>not</em> no name the directory containing the measurement
binaries starting with 'megaco-', e.g. megaco-meas. This will
confuse the erlang application loader (erlang applications
are named, e.g. megaco-1.0.2).</p><p>The Megaco application is a framework for building
applications on top of the Megaco/H.248 protocol. </p><h3>megaco</h3><p>Main API of the Megaco application</p><p>Interface module for the Megaco application</p><h4>DATA TYPES</h4><pre><code class="">
megaco_mid() = ip4Address() | ip6Address() | 
               domainName() | deviceName() | 
               mtpAddress() 
ip4Address() = #'IP4Address'{}
ip6Address() = #'IP6Address'{}
domainName() = #'DomainName'{}
deviceName() = pathName() 
pathName()   = ia5String(1..64)
mtpAddress() = octetString(2..4)

action_request() = #'ActionRequest'{}
action_reply() = #'ActionReply'{}
error_desc() = #'ErrorDescriptor'{}
transaction_reply() = #'TransactionReply'{}
segment_no() = integer()

resend_indication() = flag | boolean()

property_parm() = #'PropertyParm'{}
property_group() = [property_parm()]
property_groups() = [property_group()]

sdp() = sdp_c() | sdp_o() | sdp_s() | sdp_i() | sdp_u() | 
        sdp_e() | sdp_p() | sdp_b() | sdp_z() | sdp_k() | 
        sdp_a() | sdp_a_rtpmap() | sdp_a_ptime() | 
        sdp_t() | sdp_r() | sdp_m()
sdp_v() = #megaco_sdp_v{} (Protocol version)
sdp_o() = #megaco_sdp_o{} (Owner/creator and session identifier)
sdp_s() = #megaco_sdp_s{} (Session name)
sdp_i() = #megaco_sdp_i{} (Session information)
sdp_u() = #megaco_sdp_u{} (URI of description)
sdp_e() = #megaco_sdp_e{} (Email address)
sdp_p() = #megaco_sdp_p{} (Phone number)
sdp_c() = #megaco_sdp_c{} (Connection information)
sdp_b() = #megaco_sdp_b{} (Bandwidth information)
sdp_k() = #megaco_sdp_k{} (Encryption key)
sdp_a() = #megaco_sdp_a{} (Session attribute)
sdp_a_rtpmap() = #megaco_sdp_a_rtpmap{}
sdp_a_ptime() = #megaco_sdp_a_ptime{}
sdp_a_quality() = #megaco_sdp_a_quality{}
sdp_a_fmtp() = #megaco_sdp_a_fmtp{}
sdp_z() = #megaco_sdp_z{} (Time zone adjustment)
sdp_t() = #megaco_sdp_t{} (Time the session is active)
sdp_r() = #megaco_sdp_r{} (Repeat times)
sdp_m() = #megaco_sdp_m{} (Media name and transport address)
sdp_property_parm() = sdp() | property_parm()
sdp_property_group() = [sdp_property_parm()]
sdp_property_groups() = [sdp_property_group()]

megaco_timer() = infinity | integer() &gt;= 0 | megaco_incr_timer()
megaco_incr_timer() = #megaco_incr_timer{}
    </code></pre><p>The record <strong>megaco_incr_timer</strong> contains the following fields: </p><dl><dt><strong>wait_for = integer() &gt;= 0</strong></dt><dd> <p>The actual timer time.</p> </dd><dt><strong>factor = integer() &gt;= 0</strong></dt><dd> <p>The factor when calculating the new timer time 
(<strong>wait_for</strong>).</p> </dd><dt><strong>incr = integer()</strong></dt><dd> <p>The increment value when calculating the new timer time 
(<strong>wait_for</strong>). Note that this value <em>can</em> be negative
and that a timer restart can therefor lead to a <strong>wait_for</strong>
value of zero! It is up to the user to be aware of the 
consequences of a <strong>wait_for</strong> value of zero. </p> </dd><dt><strong>max_retries = infinity | infinity_restartable | integer() &gt;= 0</strong></dt><dd> <p>The maximum number of repetitions of the timer.</p> <p>There is a special case for this field. When the 
<strong>max_retries</strong> has the value <strong>infinity_restartable</strong>, 
it means that the timer is restartable as long as some 
external event occurs (e.g. receipt of a pending 
message for instance). But the timer will never be
restarted "by itself", i.e. when the timer expires 
(whatever the timeout time), so does the timer. 
Whenever the timer is restarted, the timeout time will 
be calculated in the usual way! Also, as mentioned 
above, beware the consequences of setting the value to
<strong>infinity</strong> if <em>incr</em> has been set to an 
negative value.</p> </dd></dl><a name="start"></a><h3>Functions</h3><h4>start() -&gt; ok | {error, Reason}</h4><p>Starts the Megaco application</p><ul><li><span class="v">Reason = term()</span></li></ul><p>Starts the Megaco application</p><p>Users may either explicitly be registered with
megaco:start_user/2 and/or be statically configured by
setting the application environment variable 'users' to a
list of {UserMid, Config} tuples. See the function
megaco:start_user/2 for details.</p><a name="stop"></a><h4>stop() -&gt; ok | {error, Reason}</h4><p>Stops the Megaco application</p><ul><li><span class="v">Reason = term()</span></li></ul><p>Stops the Megaco application</p><a name="start_user"></a><h4>start_user(UserMid, Config) -&gt; ok | {error, Reason}</h4><p>Initial configuration of a user</p><ul><li><span class="v">UserMid = megaco_mid()</span></li><li><span class="v">Config  = [{user_info_item(), user_info_value()}]</span></li><li><span class="v">Reason  = term()</span></li></ul><p>Initial configuration of a user</p><p>Requires the megaco application to be started. A user is
either a Media Gateway (MG) or a Media Gateway Controller
(MGC). One Erlang node may host many users.</p><p>A user is identified by its UserMid, which must be a legal
Megaco MID.</p><p>Config is a list of {Item, Value} tuples.  See
megaco:user_info/2 about which items and values that are valid.</p><a name="stop_user"></a><h4>stop_user(UserMid) -&gt; ok | {error, Reason}</h4><p>Delete the configuration of a user</p><ul><li><span class="v">UserMid = megaco_mid()</span></li><li><span class="v">Reason  = term()</span></li></ul><p>Delete the configuration of a user</p><p>Requires that the user does not have any active connection.</p><a name="user_info"></a><h4>user_info(UserMid) -&gt; [{Item, Value}]</h4><h4>user_info(UserMid, Item) -&gt; Value | exit(Reason)</h4><p>Lookup user information</p><ul><li><span class="v">Handle  = user_info_handle()</span></li><li><span class="v">UserMid = megaco_mid() </span></li><li><span class="v">Item    = user_info_item()</span></li><li><span class="v">Value   = user_info_value()</span></li><li><span class="v">Reason  = term()</span></li></ul><p>Lookup user information</p><p>The following Item's are valid:</p><a name="ui_connections"></a><dl><dt><strong>connections</strong></dt><dd> <p>Lists all active connections for this user. Returns a
list of megaco_conn_handle records.</p> <a name="ui_receive_handle"></a> </dd><dt><strong>receive_handle</strong></dt><dd> <p>Construct a megaco_receive_handle record from user config</p> <a name="ui_trans_id"></a> </dd><dt><strong>trans_id</strong></dt><dd> <p>Current transaction id. </p> <p>A positive integer or the atom 
<strong>undefined_serial</strong> (in case no messages has been sent).</p> <a name="ui_min_trans_id"></a> </dd><dt><strong>min_trans_id</strong></dt><dd> <p>First trans id. </p> <p>A positive integer, defaults to 1.</p> <a name="ui_max_trans_id"></a> </dd><dt><strong>max_trans_id</strong></dt><dd> <p>Last trans id. </p> <p>A positive integer or <strong>infinity</strong>, 
defaults to <strong>infinity</strong>.</p> <a name="ui_request_timer"></a> </dd><dt><strong>request_timer</strong></dt><dd> <p>Wait for reply. </p> <p>The timer is cancelled when a reply is received. </p> <p>When a pending message is received, the timer is 
cancelled and the <strong>long_request_timer</strong> is started instead 
(see below). No resends will be performed from this point 
(since we now know that the other side has received the 
request). </p> <p>When the timer reaches an intermediate expire, the request
is resent and the timer is restarted. </p> <p>When the timer reaches the final expire, either the function 
<strong>megaco:call</strong> will return with <strong>{error, timeout}</strong>
or the callback function <strong>handle_trans_reply</strong> will be 
called with <strong>UserReply = {error, timeout}</strong> (if 
<strong>megaco:cast</strong> was used).</p> <p>A Megaco Timer (see explanation above), 
defaults to <strong>#megaco_incr_timer{}</strong>.</p> <a name="ui_long_request_timer"></a> </dd><dt><strong>long_request_timer</strong></dt><dd> <p>Wait for reply after having received a pending message. </p> <p>When the timer reaches an intermediate expire, the timer 
is restarted. </p> <p>When a pending message is received, and the 
<strong>long_request_timer</strong>  
is <em>not</em> "on its final leg", the timer will be 
restarted, and, if <strong>long_request_resend = true</strong>, the
request will be re-sent. </p> <p>A Megaco Timer (see explanation above), 
defaults to <strong>60 seconds</strong>.</p> <a name="ui_long_request_resend"></a> </dd><dt><strong>long_request_resend</strong></dt><dd> <p>This option indicates weather the request should be 
resent until the reply is received,
<em>even</em> though a pending message has been received. </p> <p>Normally, after a pending message has been received, 
the request is not resent 
(since a pending message is an indication that the
request has been received). But since the reply (to the 
request) can be lost, this behaviour has its values.</p> <p>It is of course pointless to set this value to <em>true</em>
unless the <strong>long_request_timer</strong> (see above) is also set
to an incremental timer (<strong>#megaco_incr_timer{}</strong>). </p> <p>A <strong>boolean</strong>, 
defaults to <strong>false</strong>.</p> <a name="ui_reply_timer"></a> </dd><dt><strong>reply_timer</strong></dt><dd> <p>Wait for an ack. </p> <p>When a request is received, some info
related to the reply is store internally (e.g. the
binary of the reply). This info will live until either
an ack is received or this timer expires. For instance,
if the same request is received again (e.g. a request
with the same transaction id), the (stored) reply will
be (re-) sent automatically by megaco.</p> <p>If the timer is of type <strong>#megaco_incr_timer{}</strong>, 
then for each intermediate timout, the reply will be resent
(this is valid until the ack is received or 
the timer expires). </p> <p>A Megaco Timer (see explanation above), defaults to 30000.</p> <a name="ui_request_keep_alive_timeout"></a> </dd><dt><strong>request_keep_alive_timeout</strong></dt><dd> <p>Specifies the timeout time for the request-keep-alive timer. </p> <p>This timer is started when the <em>first</em> reply to an asynchronous
request (issued using the 
<a href="./megaco#cast">megaco:cast/3</a> function)
arrives. As long as this timer is running, replies will 
be delivered via the 
<a href="./megaco_user#trans_reply">handle_trans_reply/4,5</a> 
callback function, with their "arrival number" 
(see <strong>UserReply</strong> of the 
<a href="./megaco_user#trans_reply">handle_trans_reply/4,5</a> 
callback function). </p> <p>Replies arriving after the timer has expired, will be 
delivered using the 
<a href="./megaco_user#unexpected_trans">handle_unexpected_trans/3,4</a> 
callback function. </p> <p>The timeout time can have the values: 
<strong>plain | integer() &gt;= 0</strong>. </p> <p>Defaults to <strong>plain</strong>.</p> <a name="ui_call_proxy_gc_timeout"></a> </dd><dt><strong>call_proxy_gc_timeout</strong></dt><dd> <p>Timeout time for the call proxy. </p> <p>When a request is sent using the 
<a href="./megaco#call">call/3</a> function, 
a proxy process is started to handle
all replies. When the reply has been received and delivered 
to the user, the proxy process continue to exist for as long
as this option specifies. Any received messages, is passed on 
to the user via the 
<a href="./megaco_user#handle_unexpected_trans">handle_unexpected_trans</a> 
callback function. </p> <p>The timeout time is in milliseconds. A value of 0 (zero) means
that the proxy process will exit directly after the reply has 
been delivered. </p> <p>An integer &gt;= 0, defaults to 5000 (= 5 seconds).</p> <a name="ui_auto_ack"></a> </dd><dt><strong>auto_ack</strong></dt><dd> <p>Automatic send transaction ack when the transaction
reply has been received (see <strong>trans_ack</strong> below). </p> <p>This is used for <em>three-way-handshake</em>.</p> <p>A <strong>boolean</strong>, defaults to <strong>false</strong>.</p> <a name="ui_trans_ack"></a> </dd><dt><strong>trans_ack</strong></dt><dd> <p>Shall ack's be accumulated or not. </p> <p>This property is only valid if <strong>auto_ack</strong> is true.</p> <p>If <strong>auto_ack</strong> is true, then if <strong>trans_ack</strong> is
<strong>false</strong>, ack's will be sent immediately. 
If <strong>trans_ack</strong> is <strong>true</strong>, then 
ack's will instead be sent to the transaction 
sender process for accumulation and later sending 
(see <strong>trans_ack_maxcount</strong>, <strong>trans_req_maxcount</strong>, 
<strong>trans_req_maxsize</strong>, <strong>trans_ack_maxcount</strong> and 
<strong>trans_timer</strong>). </p> <p>See also <a href="./megaco_run#transaction_sender">transaction sender</a> for more info.</p> <p>An <strong>boolean</strong>, defaults to <strong>false</strong>.</p> <a name="ui_trans_ack_maxcount"></a> </dd><dt><strong>trans_ack_maxcount</strong></dt><dd> <p>Maximum number of accumulated ack's. At most this many ack's
will be accumulated by the transaction sender (if started and 
configured to accumulate ack's).</p> <p>See also <a href="./megaco_run#transaction_sender">transaction sender</a> for more info. </p> <p>An <strong>integer</strong>, defaults to 10.</p> <a name="ui_trans_req"></a> </dd><dt><strong>trans_req</strong></dt><dd> <p>Shall requests be accumulated or not. </p> <p>If <strong>trans_req</strong> is <strong>false</strong>, then request(s)
will be sent immediately (in its own message).</p> <p>If <strong>trans_req</strong> is true, then request(s) will 
instead be sent to the transaction sender process for 
accumulation and later sending 
(see <strong>trans_ack_maxcount</strong>, <strong>trans_req_maxcount</strong>, 
<strong>trans_req_maxsize</strong>, <strong>trans_ack_maxcount</strong> and 
<strong>trans_timer</strong>). </p> <p>See also <a href="./megaco_run#transaction_sender">transaction sender</a> for more info. </p> <p>An <strong>boolean</strong>, defaults to <strong>false</strong>.</p> <a name="ui_trans_req_maxcount"></a> </dd><dt><strong>trans_req_maxcount</strong></dt><dd> <p>Maximum number of accumulated requests. At most this many 
requests will be accumulated by the transaction sender 
(if started and configured to accumulate requests). </p> <p>See also <a href="./megaco_run#transaction_sender">transaction sender</a> for more info.</p> <p>An <strong>integer</strong>, defaults to 10.</p> <a name="ui_trans_req_maxsize"></a> </dd><dt><strong>trans_req_maxsize</strong></dt><dd> <p>Maximum size of the accumulated requests. At most this much
requests will be accumulated by the transaction sender 
(if started and configured to accumulate requests).</p> <p>See also <a href="./megaco_run#transaction_sender">transaction sender</a> for more info.</p> <p>An <strong>integer</strong>, defaults to 2048.</p> <a name="ui_trans_timer"></a> </dd><dt><strong>trans_timer</strong></dt><dd> <p>Transaction sender timeout time. Has two functions. First, if 
the value is 0, then transactions will not be accumulated 
(e.g. the transaction sender process will not be started). 
Second, if the value is greater then 0 and <strong>auto_ack</strong> 
and <strong>trans_ack</strong> are both true or 
if <strong>trans_req</strong> is true, 
then transaction sender will be started and transactions 
(which is depending on the values of <strong>auto_ack</strong>, 
<strong>trans_ack</strong> and <strong>trans_req</strong>) will be accumulated,
for later sending. </p> <p>See also <a href="./megaco_run#transaction_sender">transaction sender</a> for more info. </p> <p>An <strong>integer</strong>, defaults to 0.</p> <a name="ui_pending_timer"></a> </dd><dt><strong>pending_timer</strong></dt><dd> <p>Automatically send pending if the timer expires before a
transaction reply has been sent. This timer is also called 
provisional response timer. </p> <p>A Megaco Timer (see explanation above), defaults to 30000.</p> <a name="ui_sent_pending_limit"></a> </dd><dt><strong>sent_pending_limit</strong></dt><dd> <p>Sent pending limit (see the MGOriginatedPendingLimit
and the MGCOriginatedPendingLimit of the megaco root package).
This parameter specifies how many pending messages that can
be sent (for a given received transaction request).
When the limit is exceeded, the transaction is aborted
(see <a href="./megaco_user#request_abort">handle_trans_request_abort</a>) and an error message 
is sent to the other side. </p> <p>Note that this has no effect on the actual sending of
pending transactions. This is either implicit (e.g. when 
receiving a re-sent transaction request for a request which
is being processed) or controlled by the pending_timer,
see above. </p> <p>A positive integer or <strong>infinity</strong>, 
defaults to <strong>infinity</strong>.</p> <a name="ui_recv_pending_limit"></a> </dd><dt><strong>recv_pending_limit</strong></dt><dd> <p>Receive pending limit (see the MGOriginatedPendingLimit
and the MGCOriginatedPendingLimit of the megaco root package).
This parameter specifies how many pending messages that can
be received (for a sent transaction request).
When the limit is exceeded, the transaction is considered
lost, and an error returned to the user (through the call-back
function <em>handle_trans_reply</em>). </p> <p>A positive integer or <strong>infinity</strong>, 
defaults to <strong>infinity</strong>. </p> <a name="ui_send_mod"></a> </dd><dt><strong>send_mod</strong></dt><dd> <p>Send callback module which exports send_message/2. The
function SendMod:send_message(SendHandle, Binary) is
invoked when the bytes needs to be transmitted to the
remote user. </p> <p>An <strong>atom</strong>, defaults to <strong>megaco_tcp</strong>.</p> <a name="ui_encoding_mod"></a> </dd><dt><strong>encoding_mod</strong></dt><dd> <p>Encoding callback module which exports encode_message/2
and decode_message/2. The function
EncodingMod:encode_message(EncodingConfig,
MegacoMessage) is invoked whenever a 'MegacoMessage'
record needs to be translated into an Erlang binary. The
function EncodingMod:decode_message(EncodingConfig,
Binary) is invoked whenever an Erlang binary needs to be
translated into a 'MegacoMessage' record. </p> <p>An <strong>atom</strong>, defaults to <strong>megaco_pretty_text_encoder</strong>.</p> <a name="ui_encoding_config"></a> </dd><dt><strong>encoding_config</strong></dt><dd> <p>Encoding module config. </p> <p>A <strong>list</strong>, defaults to <strong>[]</strong>.</p> <a name="ui_protocol_version"></a> </dd><dt><strong>protocol_version</strong></dt><dd> <p>Actual protocol version. </p> <p>An <strong>integer</strong>, default is 1.</p> <a name="ui_strict_version"></a> </dd><dt><strong>strict_version</strong></dt><dd> <p>Strict version control, i.e. when a message is received,
verify that the version is that which was negotiated. </p> <p>An <strong>boolean</strong>, default is true.</p> <a name="ui_reply_data"></a> </dd><dt><strong>reply_data</strong></dt><dd> <p>Default reply data. </p> <p>Any term, defaults to the atom <strong>undefined</strong>.</p> <a name="ui_user_mod"></a> </dd><dt><strong>user_mod</strong></dt><dd> <p>Name of the user callback module. See the the reference
manual for megaco_user for more info.</p> <a name="ui_user_args"></a> </dd><dt><strong>user_args</strong></dt><dd> <p>List of extra arguments to the user callback
functions. See the the reference manual for megaco_user
for more info.</p> <a name="ui_threaded"></a> </dd><dt><strong>threaded</strong></dt><dd> <p>If a received message contains several transaction requests, 
this option indicates whether the requests should be handled
sequentially in the same process (<strong>false</strong>), or if each 
request should be handled by its own process (<strong>true</strong>
i.e. a separate process is spawned for each request). </p> <p>An <strong>boolean</strong>, defaults to <strong>false</strong>. </p> <a name="ui_resend_indication"></a> </dd><dt><strong>resend_indication</strong></dt><dd> <p>This option indicates weather the transport module
should be told if a message send is a resend or not. </p> <p>If <em>false</em>, megaco messages are sent using the
<a href="./megaco_transport#send_message">send_message</a> 
function. </p> <p>If <em>true</em>, megaco message <em>re-sends</em> are made using the
<a href="./megaco_transport#resend_message">resend_message</a> 
function. The initial message send is still done using the
<a href="./megaco_transport#send_message">send_message</a> 
function. </p> <p>The special value <em>flag</em> instead indicates that the 
function 
<a href="./megaco_transport#send_message">send_message/3</a> 
shall be used. </p> <p>A <strong>resend_indication()</strong>, 
defaults to <strong>false</strong>.</p> <a name="ui_segment_reply_ind"></a> </dd><dt><strong>segment_reply_ind</strong></dt><dd> <p>This option specifies if the user shall be notified of received
segment replies or not. </p> <p>See 
<a href="./megaco_user#segment_reply">handle_segment_reply</a> 
callback function for more information. </p> <p>A <strong>boolean</strong>, 
defaults to <strong>false</strong>. </p> <a name="ui_segment_recv_timer"></a> </dd><dt><strong>segment_recv_timer</strong></dt><dd> <p>This timer is started when the segment indicated by the
<strong>segmentation complete token</strong> is received, but all 
segments has not yet been received.</p> <p>When the timer finally expires, a "megaco segments not
received" (459) error message is sent to the other side
and the user is notified with a <strong>segment timeout</strong> <strong>UserReply</strong> in either the
<a href="./megaco_user#trans_reply">handle_trans_reply</a> callback function or 
the return value of the 
<a href="./megaco#call">call</a> function. </p> <p>A Megaco Timer (see explanation above),
defaults to <strong>10000</strong>. </p> <a name="ui_segment_send"></a> </dd><dt><strong>segment_send</strong></dt><dd> <p>Shall outgoing messages be segmented or not: </p> <dl><dt><strong>none</strong></dt><dd> <p>Do not segment outgoing reply messages. This is useful when
either it is known that messages are never to large or
that the transport protocol can handle such things
on its own (e.g. TCP or SCTP).</p> </dd><dt><strong>integer() &gt; 0</strong></dt><dd> <p>Outgoing reply messages will be segmented as needed 
(see <strong>max_pdu_size</strong> below). This value, K, indicate 
the outstanding window, i.e. how many segments can be 
outstanding (not acknowledged) at any given time. </p> </dd><dt><strong>infinity</strong></dt><dd> <p>Outgoing reply messages will be segmented as needed 
(see <strong>max_pdu_size</strong> below). Segment messages 
are sent all at once (i.e. no acknowledgement awaited 
before sending the next segment). </p> </dd></dl> <p>Defaults to <strong>none</strong>. </p> <a name="ui_max_pdu_size"></a> </dd><dt><strong>max_pdu_size</strong></dt><dd> <p>Max message size. If the encoded message (PDU) exceeds 
this size, the message should be segmented, and then 
encoded. </p> <p>A positive integer or <strong>infinity</strong>,
defaults to <strong>infinity</strong>. </p> </dd></dl><a name="update_user_info"></a><h4>update_user_info(UserMid, Item, Value) -&gt; ok | {error, Reason}</h4><p>Update information about a user</p><ul><li><span class="v">UserMid = megaco_mid() </span></li><li><span class="v">Item    = user_info_item()</span></li><li><span class="v">Value   = user_info_value()</span></li><li><span class="v">Reason  = term()</span></li></ul><p>Update information about a user</p><p>Requires that the user is started. See megaco:user_info/2
about which items and values that are valid.</p><a name="conn_info"></a><h4>conn_info(ConnHandle) -&gt; [{Item, Value}]</h4><h4>conn_info(ConnHandle, Item) -&gt; Value | exit(Reason)</h4><p>Lookup information about an active connection</p><ul><li><span class="v">ConnHandle = #megaco_conn_handle{}</span></li><li><span class="v">Item       = conn_info_item()</span></li><li><span class="v">Value      = conn_info_value()</span></li><li><span class="v">Reason     = {no_such_connection, ConnHandle} | term()</span></li></ul><p>Lookup information about an active connection</p><p>Requires that the connection is active.</p><a name="ci_control_pid"></a><dl><dt><strong>control_pid</strong></dt><dd> <p>The process identifier of the controlling process for a
connection.</p> <a name="ci_send_handle"></a> </dd><dt><strong>send_handle</strong></dt><dd> <p>Opaque send handle whose contents is internal for the
send module. May be any term.</p> <a name="ci_local_mid"></a> </dd><dt><strong>local_mid</strong></dt><dd> <p>The local mid (of the connection, i.e. the own mid). 
<strong>megaco_mid()</strong>.</p> <a name="ci_remote_mid"></a> </dd><dt><strong>remote_mid</strong></dt><dd> <p>The remote mid (of the connection). 
<strong>megaco_mid()</strong>.</p> <a name="ci_receive_handle"></a> </dd><dt><strong>receive_handle</strong></dt><dd> <p>Construct a megaco_receive_handle record.</p> <a name="ci_trans_id"></a> </dd><dt><strong>trans_id</strong></dt><dd> <p>Next transaction id. A positive integer or the atom 
<strong>undefined_serial</strong> (only in case of error). </p> <p>Note that transaction id's are (currently) maintained 
on a per user basis so there is no way to be sure that 
the value returned will actually be used for a transaction 
sent on this connection (in case a user has several 
connections, which is not at all unlikely). </p> <a name="ci_max_trans_id"></a> </dd><dt><strong>max_trans_id</strong></dt><dd> <p>Last trans id. </p> <p>A positive integer or <strong>infinity</strong>, 
defaults to <strong>infinity</strong>.</p> <a name="ci_request_time"></a> </dd><dt><strong>request_timer</strong></dt><dd> <p>Wait for reply. </p> <p>The timer is cancelled when a reply is received. </p> <p>When a pending message is received, the timer is 
cancelled and the <strong>long_request_timer</strong> is started instead 
(see below). No resends will be performed from this point 
(since we now know that the other side has received the 
request). </p> <p>When the timer reaches an intermediate expire, the request
is resent and the timer is restarted. </p> <p>When the timer reaches the final expire, either the function 
<strong>megaco:call</strong> will return with <strong>{error, timeout}</strong>
or the callback function <strong>handle_trans_reply</strong> will be 
called with <strong>UserReply = {error, timeout}</strong> (if 
<strong>megaco:cast</strong> was used).</p> <p>A Megaco Timer (see explanation above), 
defaults to #megaco_incr_timer{}.</p> <a name="ci_long_request_timer"></a> </dd><dt><strong>long_request_timer</strong></dt><dd> <p>Wait for reply after having received a pending message. </p> <p>When the timer reaches an intermediate expire, the timer 
restarted. </p> <p>When a pending message is received, and the 
<strong>long_request_timer</strong> 
is <em>not</em> "on its final leg", the timer will be 
restarted, and, if <strong>long_request_resend = true</strong>, the
request will be re-sent. </p> <p>A Megaco Timer (see explanation above), 
defaults to <strong>60 seconds</strong>.</p> <a name="ci_request_keep_alive_timeout"></a> </dd><dt><strong>request_keep_alive_timeout</strong></dt><dd> <p>Specifies the timeout time for the request-keep-alive timer. </p> <p>This timer is started when the <em>first</em> reply to an asynchronous
request (issued using the 
<a href="./megaco#cast">megaco:cast/3</a> function)
arrives. As long as this timer is running, replies will 
be delivered via the 
<a href="./megaco_user#trans_reply">handle_trans_reply/4,5</a> 
callback function, with their "arrival number" 
(see <strong>UserReply</strong> of the 
<a href="./megaco_user#trans_reply">handle_trans_reply/4,5</a> 
callback function). </p> <p>Replies arriving after the timer has expired, will be 
delivered using the 
<a href="./megaco_user#unexpected_trans">handle_unexpected_trans/3,4</a> 
callback function. </p> <p>The timeout time can have the values: 
<strong>plain | integer() &gt;= 0</strong>. </p> <p>Defaults to <strong>plain</strong>.</p> <a name="ci_long_request_resend"></a> </dd><dt><strong>long_request_resend</strong></dt><dd> <p>This option indicates weather the request should be 
resent until the reply is received,
<em>even</em> though a pending message has been received. </p> <p>Normally, after a pending message has been received, 
the request is not resent 
(since a pending message is an indication that the
request has been received). But since the reply (to the 
request) can be
lost, this behaviour has its values.</p> <p>It is of course pointless to set this value to <em>true</em>
unless the <strong>long_request_timer</strong> (see above) is also set
to an incremental timer (<strong>#megaco_incr_timer{}</strong>). </p> <p>A <strong>boolean</strong>, 
defaults to <strong>false</strong>.</p> <a name="ci_reply_timer"></a> </dd><dt><strong>reply_timer</strong></dt><dd> <p>Wait for an ack. </p> <p>When a request is received, some info
related to the reply is store internally (e.g. the
binary of the reply). This info will live until either
an ack is received or this timer expires. For instance,
if the same request is received again (e.g. a request
with the same transaction id), the (stored) reply will
be (re-) sent automatically by megaco.</p> <p>If the timer is of type <strong>#megaco_incr_timer{}</strong>, 
then for each intermediate timout, the reply will be resent
(this is valid until the ack is received or 
the timer expires). </p> <p>A Megaco Timer (see explanation above), defaults to 30000.</p> <a name="ci_call_proxy_gc_timeout"></a> </dd><dt><strong>call_proxy_gc_timeout</strong></dt><dd> <p>Timeout time for the call proxy. </p> <p>When a request is sent using the 
<a href="./megaco#call">call/3</a> function, 
a proxy process is started to handle
all replies. When the reply has been received and delivered 
to the user, the proxy process continue to exist for as long
as this option specifies. Any received messages, is passed on 
to the user via the 
<a href="./megaco_user#handle_unexpected_trans">handle_unexpected_trans</a> 
callback function. </p> <p>The timeout time is in milliseconds. A value of 0 (zero) means
that the proxy process will exit directly after the reply has 
been delivered. </p> <p>An integer &gt;= 0, defaults to 5000 (= 5 seconds).</p> <a name="ci_auto_ack"></a> </dd><dt><strong>auto_ack</strong></dt><dd> <p>Automatic send transaction ack when the transaction
reply has been received (see <strong>trans_ack</strong> below). </p> <p>This is used for <em>three-way-handshake</em>. </p> <p>A <strong>boolean</strong>, defaults to <strong>false</strong>.</p> <a name="ci_trans_ack"></a> </dd><dt><strong>trans_ack</strong></dt><dd> <p>Shall ack's be accumulated or not. </p> <p>This property is only valid if <strong>auto_ack</strong> is true. </p> <p>If <strong>auto_ack</strong> is true, then if <strong>trans_ack</strong> is
<strong>false</strong>, ack's will be sent immediately. 
If <strong>trans_ack</strong> is
<strong>true</strong>, then ack's will instead be sent to the transaction 
sender process for accumulation and later sending 
(see <strong>trans_ack_maxcount</strong>, <strong>trans_req_maxcount</strong>, 
<strong>trans_req_maxsize</strong>, <strong>trans_ack_maxcount</strong> and 
<strong>trans_timer</strong>). </p> <p>See also <a href="./megaco_run#transaction_sender">transaction sender</a> for more info. </p> <p>An <strong>boolean</strong>, defaults to <strong>false</strong>.</p> <a name="ci_trans_ack_maxcount"></a> </dd><dt><strong>trans_ack_maxcount</strong></dt><dd> <p>Maximum number of accumulated ack's. At most this many ack's
will be accumulated by the transaction sender (if started and 
configured to accumulate ack's).</p> <p>See also <a href="./megaco_run#transaction_sender">transaction sender</a> for more info.</p> <p>An integer, defaults to 10.</p> <a name="ci_trans_req"></a> </dd><dt><strong>trans_req</strong></dt><dd> <p>Shall requests be accumulated or not. </p> <p>If <strong>trans_req</strong> is <strong>false</strong>, then request(s)
will be sent immediately (in its own message). </p> <p>If <strong>trans_req</strong> is true, then request(s) will 
instead be sent to the transaction sender process for 
accumulation and later sending 
(see <strong>trans_ack_maxcount</strong>, <strong>trans_req_maxcount</strong>, 
<strong>trans_req_maxsize</strong>, <strong>trans_ack_maxcount</strong> and 
<strong>trans_timer</strong>). </p> <p>See also <a href="./megaco_run#transaction_sender">transaction sender</a> for more info. </p> <p>An <strong>boolean</strong>, defaults to <strong>false</strong>.</p> <a name="ci_trans_req_maxcount"></a> </dd><dt><strong>trans_req_maxcount</strong></dt><dd> <p>Maximum number of accumulated requests. At most this many 
requests will be accumulated by the transaction sender 
(if started and configured to accumulate requests). </p> <p>See also <a href="./megaco_run#transaction_sender">transaction sender</a> for more info. </p> <p>An <strong>integer</strong>, defaults to 10.</p> <a name="ci_trans_req_maxsize"></a> </dd><dt><strong>trans_req_maxsize</strong></dt><dd> <p>Maximum size of the accumulated requests. At most this much
requests will be accumulated by the transaction sender 
(if started and configured to accumulate requests). </p> <p>See also <a href="./megaco_run#transaction_sender">transaction sender</a> for more info. </p> <p>An <strong>integer</strong>, defaults to 2048.</p> <a name="ci_trans_timer"></a> </dd><dt><strong>trans_timer</strong></dt><dd> <p>Transaction sender timeout time. Has two functions. First, if 
the value is 0, then transactions will not be accumulated 
(e.g. the transaction sender process will not be started). 
Second, if the value is greater then 0 and <strong>auto_ack</strong> 
and <strong>trans_ack</strong> is true or if <strong>trans_req</strong> is true, 
then transaction sender will be started and transactions 
(which is depending on the values of <strong>auto_ack</strong>, 
<strong>trans_ack</strong> and <strong>trans_req</strong>) will be accumulated,
for later sending. </p> <p>See also <a href="./megaco_run#transaction_sender">transaction sender</a> for more info. </p> <p>An <strong>integer</strong>, defaults to 0.</p> <a name="ci_pending_timer"></a> </dd><dt><strong>pending_timer</strong></dt><dd> <p>Automatic send transaction pending if the timer expires
before a transaction reply has been sent. This timer is
also called provisional response timer. </p> <p>A Megaco Timer (see explanation above), defaults to 30000.</p> <a name="ci_sent_pending_limit"></a> </dd><dt><strong>sent_pending_limit</strong></dt><dd> <p>Sent pending limit (see the MGOriginatedPendingLimit
and the MGCOriginatedPendingLimit of the megaco root package).
This parameter specifies how many pending messages that can
be sent (for a given received transaction request).
When the limit is exceeded, the transaction is aborted
(see <a href="./megaco_user#request_abort">handle_trans_request_abort</a>) and an error message 
is sent to the other side. </p> <p>Note that this has no effect on the actual sending of
pending transactions. This is either implicit (e.g. when 
receiving a re-sent transaction request for a request which
is being processed) or controlled by the pending_timer,
see above. </p> <p>A positive integer or <strong>infinity</strong>, 
defaults to <strong>infinity</strong>.</p> <a name="ci_recv_pending_limit"></a> </dd><dt><strong>recv_pending_limit</strong></dt><dd> <p>Receive pending limit (see the MGOriginatedPendingLimit
and the MGCOriginatedPendingLimit of the megaco root package).
This parameter specifies how many pending messages that can
be received (for a sent transaction request).
When the limit is exceeded, the transaction is considered
lost, and an error returned to the user (through the call-back
function <em>handle_trans_reply</em>). </p> <p>A positive integer or <strong>infinity</strong>, 
defaults to <strong>infinity</strong>.</p> <a name="ci_send_mod"></a> </dd><dt><strong>send_mod</strong></dt><dd> <p>Send callback module which exports send_message/2. The
function SendMod:send_message(SendHandle, Binary) is
invoked when the bytes needs to be transmitted to
the remote user. </p> <p>An <strong>atom</strong>, defaults to <strong>megaco_tcp</strong>.</p> <a name="ci_encoding_mod"></a> </dd><dt><strong>encoding_mod</strong></dt><dd> <p>Encoding callback module which exports encode_message/2
and decode_message/2. The function
EncodingMod:encode_message(EncodingConfig, MegacoMessage)
is invoked whenever a 'MegacoMessage' record needs to be
translated into an Erlang binary. The function
EncodingMod:decode_message(EncodingConfig, Binary) is
invoked whenever an Erlang binary needs to be translated
into a 'MegacoMessage' record. </p> <p>An <strong>atom</strong>, 
defaults to <strong>megaco_pretty_text_encoder</strong>.</p> <a name="ci_encoding_confi"></a> </dd><dt><strong>encoding_config</strong></dt><dd> <p>Encoding module config. </p> <p>A <strong>list</strong>, defaults to [].</p> <a name="ci_protocol_version"></a> </dd><dt><strong>protocol_version</strong></dt><dd> <p>Actual protocol version. </p> <p>An positive integer, Current default is 1.</p> <a name="ci_strict_version"></a> </dd><dt><strong>strict_version</strong></dt><dd> <p>Strict version control, i.e. when a message is received,
verify that the version is that which was negotiated. </p> <p>An <strong>boolean</strong>, default is true.</p> <a name="ci_reply_data"></a> </dd><dt><strong>reply_data</strong></dt><dd> <p>Default reply data. </p> <p>Any term, defaults to the atom <strong>undefined</strong>.</p> <a name="ci_threaded"></a> </dd><dt><strong>threaded</strong></dt><dd> <p>If a received message contains several transaction requests, 
this option indicates whether the requests should be handled
sequentially in the same process (<strong>false</strong>), or if each 
request should be handled by its own process (<strong>true</strong>
i.e. a separate process is spawned for each request). </p> <p>An <strong>boolean</strong>, defaults to <strong>false</strong>. </p> <a name="ci_resend_indication"></a> </dd><dt><strong>resend_indication</strong></dt><dd> <p>This option indicates weather the transport module
should be told if a message send is a resend or not. </p> <p>If <em>false</em>, megaco messages are sent using the
<a href="./megaco_transport#send_message">send_message/2</a> 
function. </p> <p>If <em>true</em>, megaco message <em>re-sends</em> are made using the
<a href="./megaco_transport#resend_message">resend_message</a> 
function. The initial message send is still done using the
<a href="./megaco_transport#send_message">send_message</a> 
function. </p> <p>The special value <em>flag</em> instead indicates that the 
function 
<a href="./megaco_transport#send_message">send_message/3</a> 
shall be used. </p> <p>A <strong>resend_indication()</strong>, 
defaults to <strong>false</strong>.</p> <a name="ci_segment_reply_ind"></a> </dd><dt><strong>segment_reply_ind</strong></dt><dd> <p>This option specifies if the user shall be notified of received
segment replies or not. </p> <p>See 
<a href="./megaco_user#segment_reply">handle_segment_reply</a> 
callback function for more information. </p> <p>A <strong>boolean</strong>, 
defaults to <strong>false</strong>. </p> <a name="ci_segment_recv_timer"></a> </dd><dt><strong>segment_recv_timer</strong></dt><dd> <p>This timer is started when the segment indicated by the
<strong>segmentation complete token</strong> (e.g. the last of the segment
which makes up the reply) is received, but all 
segments has not yet been received.</p> <p>When the timer finally expires, a "megaco segments not
received" (459) error message is sent to the other side
and the user is notified with a 
<strong>segment timeout</strong> <strong>UserReply</strong> in either the
<a href="./megaco_user#trans_reply">handle_trans_reply</a> 
callback function or 
the return value of the 
<a href="./megaco#call">call</a> function. </p> <p>A Megaco Timer (see explanation above),
defaults to <strong>10000</strong>. </p> <a name="ci_segment_send"></a> </dd><dt><strong>segment_send</strong></dt><dd> <p>Shall outgoing messages be segmented or not: </p> <dl><dt><strong>none</strong></dt><dd> <p>Do not segment outgoing reply messages. This is useful when
either it is known that messages are never to large or
that the transport protocol can handle such things
on its own (e.g. TCP or SCTP).</p> </dd><dt><strong>integer() &gt; 0</strong></dt><dd> <p>Outgoing reply messages will be segmented as needed 
(see <strong>max_pdu_size</strong> below). This value, K, indicate 
the outstanding window, i.e. how many segments can be 
outstanding (not acknowledged) at any given time. </p> </dd><dt><strong>infinity</strong></dt><dd> <p>Outgoing reply messages will be segmented as needed 
(see <strong>max_pdu_size</strong> below). Segment messages 
are sent all at once (i.e. no acknowledgement awaited 
before sending the next segment). </p> </dd></dl> <p>Defaults to <strong>none</strong>. </p> <a name="ci_max_pdu_size"></a> </dd><dt><strong>max_pdu_size</strong></dt><dd> <p>Max message size. If the encoded message (PDU) exceeds 
this size, the message should be segmented, and then 
encoded. </p> <p>A positive integer or <strong>infinity</strong>,
defaults to <strong>infinity</strong>. </p> </dd></dl><a name="update_conn_info"></a><h4>update_conn_info(ConnHandle, Item, Value) -&gt; ok | {error, Reason}</h4><p>Update information about an active connection</p><ul><li><span class="v">ConnHandle = #megaco_conn_handle{}</span></li><li><span class="v">Item       = conn_info_item()</span></li><li><span class="v">Value      = conn_info_value()</span></li><li><span class="v">Reason     = term()</span></li></ul><p>Update information about an active connection</p><p>Requires that the connection is activated. See
megaco:conn_info/2 about which items and values that are
valid.</p><a name="system_info"></a><h4>system_info() -&gt; [{Item, Value}] | exit(Reason)</h4><h4>system_info(Item) -&gt; Value | exit(Reason)</h4><p>Lookup system information</p><ul><li><span class="v">Item = system_info_item()</span></li></ul><p>Lookup system information</p><p>The following items are valid:</p><dl><dt><strong>text_config</strong></dt><dd> <p>The text encoding config.</p> </dd><dt><strong>connections</strong></dt><dd> <p>Lists all active connections. Returns a list of
megaco_conn_handle records.</p> </dd><dt><strong>users</strong></dt><dd> <p>Lists all active users. Returns a list of
megaco_mid()'s.</p> </dd><dt><strong>n_active_requests</strong></dt><dd> <p>Returns an integer representing the number of requests
that has originated from this Erlang node and still are
active (and therefore consumes system resources).</p> </dd><dt><strong>n_active_replies</strong></dt><dd> <p>Returns an integer representing the number of replies
that has originated from this Erlang node and still are
active (and therefore consumes system resources).</p> </dd><dt><strong>n_active_connections</strong></dt><dd> <p>Returns an integer representing the number of active
connections.</p> </dd></dl><a name="info"></a><h4>info() -&gt; Info</h4><p>All the information of the application</p><ul><li><span class="v">Info = [{Key, Value}]</span></li></ul><p>This function produces a list of information about the megaco 
application. Such as users and their config, connections 
and their config, statistics and so on.</p><p>This information can be produced by the functions 
<a href="#user_info">user_info</a>, 
<a href="#conn_info">conn_info</a>, 
<a href="#system_info">system_info</a> and 
<a href="#get_stats">get_stats</a> 
but this is a simple way to get it all at once.</p><a name="connect"></a><h4>connect(ReceiveHandle, RemoteMid, SendHandle, ControlPid) -&gt; {ok, ConnHandle} | {error, Reason}</h4><h4>connect(ReceiveHandle, RemoteMid, SendHandle, ControlPid, Extra) -&gt; {ok, ConnHandle} | {error, Reason}</h4><p>Establish a "virtual" connection</p><ul><li><span class="v">ReceiveHandle = #megaco_receive_handle{}</span></li><li><span class="v">RemoteMid     = preliminary_mid | megaco_mid()</span></li><li><span class="v">SendHandle    = term()</span></li><li><span class="v">ControlPid    = pid()</span></li><li><span class="v">ConnHandle    = #megaco_conn_handle{}</span></li><li><span class="v">Reason        = connect_reason() | handle_connect_reason() | term()</span></li><li><span class="v">connect_reason() = {no_such_user, LocalMid} | {already_connected, ConnHandle} | term()</span></li><li><span class="v">handle_connect_error() = {connection_refused, ConnData, ErrorInfo} | term()</span></li><li><span class="v">LocalMid      = megaco_mid()</span></li><li><span class="v">ConnData      = term()</span></li><li><span class="v">ErrorInfo     = term()</span></li><li><span class="v">Extra         = term()</span></li></ul><p>Establish a "virtual" connection</p><p>Activates a connection to a remote user. When this is done
the connection can be used to send messages (with
SendMod:send_message/2). The ControlPid is the identifier
of a process that controls the connection. That process will
be supervised and if it dies, this will be detected and the
UserMod:handle_disconnect/2 callback function will be
invoked. See the megaco_user module for more info about the
callback arguments. The connection may also explicitly be
deactivated by invoking megaco:disconnect/2.</p><p>The ControlPid may be the identity of a process residing on
another Erlang node. This is useful when you want to
distribute a user over several Erlang nodes. In such a case
one of the nodes has the physical connection. When a user
residing on one of the other nodes needs to send a request
(with megaco:call/3 or megaco:cast/3), the message will
encoded on the originating Erlang node, and then be
forwarded to the node with the physical connection. When the
reply arrives, it will be forwarded back to the originator.
The distributed connection may explicitly be deactivated by
a local call to megaco:disconnect/2 or implicitly when
the physical connection is deactivated (with megaco:disconnect/2,
killing the controlling process, halting the other node, ...).</p><p>The call of this function will trigger the callback
function UserMod:handle_connect/2 to be invoked. See the
megaco_user module for more info about the callback
arguments.</p><p>A connection may be established in several ways:</p><dl><dt><strong>provisioned MID</strong></dt><dd> <p>The MG may explicitly invoke megaco:connect/4 and use
a provisioned MID of the MGC as the RemoteMid.</p> </dd><dt><strong>upgrade preliminary MID</strong></dt><dd> <p>The MG may explicitly invoke megaco:connect/4 with the
atom 'preliminary_mid' as a temporary MID of the MGC,
send an intial message, the Service Change Request, to
the MGC and then wait for an initial message, the
Service Change Reply. When the reply arrives, the Megaco
application will pick the MID of the MGC from the
message header and automatically upgrade the connection
to be a "normal" connection. By using this method of
establishing the connection, the callback function
UserMod:handle_connect/2 to be invoked twice. First with
a ConnHandle with the remote_mid-field set to
preliminary_mid, and then when the connection upgrade is
done with the remote_mid-field set to the actual MID of
the MGC.</p> </dd><dt><strong>automatic</strong></dt><dd> <p>When the MGC receives its first message, the Service
Change Request, the Megaco application will
automatically establish the connection by using the MG
MID found in the message header as remote mid.</p> </dd><dt><strong>distributed</strong></dt><dd> <p>When a user (MG/MGC) is distributed over several nodes,
it is required that the node hosting the connection
already has activated the connection and that it is
in the "normal" state. The RemoteMid must be a real
Megaco MID and not a preliminary_mid.</p> </dd></dl><p>An initial megaco_receive_handle record may be obtained
with megaco:user_info(UserMid, receive_handle)</p><p>The send handle is provided by the preferred transport
module, e.g. megaco_tcp, megaco_udp. Read the documentation
about each transport module about the details.</p><p>The connect is done in two steps: first an internal 
<strong>connection setup</strong> and then by calling the user 
<a href="./megaco_user#connect">handle_connect</a> 
callback function. The first step could result in 
an error with <strong>Reason = connect_reason()</strong> and the second 
an error with <strong>Reason = handle_connect_reason()</strong>: </p><dl><dt><strong>connect_reason()</strong></dt><dd> <p>An error with this reason is generated by the 
megaco application itself.</p> </dd><dt><strong>handle_connect_reason()</strong></dt><dd> <p>An error with this reason is caused by the user 
<a href="./megaco_user#connect">handle_connect</a> 
callback function either returning an error 
or an invalid value.</p> </dd></dl><p><strong>Extra</strong> can be any <strong>term()</strong> 
except the atom <strong>ignore_extra</strong>. 
It is passed (back) to the user via the callback function 
<a href="./megaco_user#connect">handle_connect/3</a>. </p><a name="disconnect"></a><h4>disconnect(ConnHandle, DiscoReason) -&gt; ok | {error, ErrReason}</h4><p>Tear down a "virtual" connection</p><ul><li><span class="v">ConnHandle  = conn_handle()</span></li><li><span class="v">DiscoReason =  term()</span></li><li><span class="v">ErrReason   =  term()</span></li></ul><p>Tear down a "virtual" connection</p><p>Causes the UserMod:handle_disconnect/2 callback function to
be invoked. See the megaco_user module for more info about
the callback arguments.</p><a name="call"></a><h4>call(ConnHandle, Actions, Options) -&gt; {ProtocolVersion, UserReply}</h4><p>Sends one or more transaction request(s) and waits for the reply</p><ul><li><span class="v">ConnHandle     = conn_handle()</span></li><li><span class="v">Actions        = action_reqs() | [action_reqs()]</span></li><li><span class="v">action_reqs()  = binary() | [action_request()]</span></li><li><span class="v">Options        = [send_option()]</span></li><li><span class="v">send_option()  = {request_timer, megaco_timer()} | {long_request_timer, megaco_timer()} | {send_handle, term()} | {protocol_version, integer()} | {call_proxy_gc_timeout, call_proxy_gc_timeout()}</span></li><li><span class="v">ProtocolVersion = integer()</span></li><li><span class="v">UserReply       = user_reply() | [user_reply()]</span></li><li><span class="v">user_reply()    = success() | failure()</span></li><li><span class="v">success()       = {ok, result()} | {ok, result(), extra()}</span></li><li><span class="v">result()        = message_result() | segment_result()</span></li><li><span class="v">message_result() = action_reps()</span></li><li><span class="v">segment_result() = segments_ok()</span></li><li><span class="v">failure()        = {error, reason()} | {error, reason(), extra()}</span></li><li><span class="v">reason()         = message_reason() | segment_reason() | user_cancel_reason() | send_reason() | other_reason()</span></li><li><span class="v">message_reason() = error_desc()</span></li><li><span class="v">segment_reason() = {segment, segments_ok(), segments_err()} | {segment_timeout, missing_segments(), segments_ok(), segments_err()}</span></li><li><span class="v">segments_ok()   = [segment_ok()]</span></li><li><span class="v">segment_ok()    = {segment_no(), action_reps()}</span></li><li><span class="v">segments_err()  = [segment_err()]</span></li><li><span class="v">segment_err()   = {segment_no(), error_desc()}</span></li><li><span class="v">missing_segments() = [segment_no()]</span></li><li><span class="v">user_cancel_reason() = {user_cancel, reason_for_user_cancel()}</span></li><li><span class="v">reason_for_user_cancel() = term()</span></li><li><span class="v">send_reason() = send_cancelled_reason() | send_failed_reason()</span></li><li><span class="v">send_cancelled_reason() = {send_message_cancelled, reason_for_send_cancel()}</span></li><li><span class="v">reason_for_send_cancel() = term()</span></li><li><span class="v">send_failed_reason()    = {send_message_failed, reason_for_send_failure()}</span></li><li><span class="v">reason_for_send_failure() = term()</span></li><li><span class="v">other_reason()   = {wrong_mid, WrongMid, RightMid, TR} | term()</span></li><li><span class="v">WrongMid = mid()</span></li><li><span class="v">RightMid = mid()</span></li><li><span class="v">TR = transaction_reply()</span></li><li><span class="v">action_reps()    = [action_reply()]</span></li><li><span class="v">call_proxy_gc_timeout() = integer() &gt;= 0</span></li><li><span class="v">extra()          = term()</span></li></ul><p>Sends one or more transaction request(s) and waits for the 
reply.</p><p>When sending one transaction in a message, <strong>Actions</strong> should be 
<strong>action_reqs()</strong> (<strong>UserReply</strong> will then be 
<strong>user_reply()</strong>). When sending several transactions in a message,
<strong>Actions</strong> should be <strong>[action_reqs()]</strong> (<strong>UserReply</strong> 
will then be <strong>[user_reply()]</strong>). Each element of the list is 
part of one transaction.</p><p>For some of <em>our</em> codecs (not binary), it is also possible 
to pre-encode the actions, in which case <strong>Actions</strong> will be 
either a <strong>binary()</strong> or <strong>[binary()]</strong>.</p><p>The function returns when the reply arrives, when the
request timer eventually times out or when the outstanding
requests are explicitly cancelled.</p><p>The default values of the send options are obtained by
<strong>megaco:conn_info(ConnHandle, Item)</strong>. But the send options 
above, may explicitly be overridden.</p><p>The <strong>ProtocolVersion</strong> version is the version actually encoded
in the reply message.</p><p>At <strong>success()</strong>, the <strong>UserReply</strong> contains a list of 
'ActionReply' records possibly containing error indications.</p><p>A <strong>message_error()</strong>, indicates that the remote user has
replied with an explicit transactionError.</p><p>A <strong>user_cancel_error()</strong>, indicates that the request has been
canceled by the user. <strong>reason_for_user_cancel()</strong> is the reason
given in the call to the <a href="#cancel">cancel</a>
function. </p><p>A <strong>send_error()</strong>, indicates that the send function of the 
megaco transport callback module failed to send the request. 
There are two separate cases: <strong>send_cancelled_reason()</strong> and 
<strong>send_failed_reason()</strong>. 
The first is the result of the send function returning 
<strong>{cancel, Reason}</strong> and the second is some other kind of 
erroneous return value. See the 
<a href="./megaco_transport#send_message">send_message</a>
function for more info. </p><p>An <strong>other_error()</strong>, indicates some other error such as 
timeout.</p><p>For more info about the <strong>extra()</strong> part of the 
result, see the 
<a href="./megaco_user#extra_argument">note</a>
in the user callback module documentation. </p><a name="cast"></a><h4>cast(ConnHandle, Actions, Options) -&gt; ok | {error, Reason}</h4><p>Sends one or more transaction request(s) but does NOT wait for a reply</p><ul><li><span class="v">ConnHandle     = conn_handle()</span></li><li><span class="v">Actions        = action_reqs() | [action_reqs()]</span></li><li><span class="v">action_reqs()  = binary() | [action_request()]</span></li><li><span class="v">Options        = [send_option()]</span></li><li><span class="v">send_option()  = {request_keep_alive_timeout, request_keep_alive_timeout()} | {request_timer, megaco_timer()} | {long_request_timer, megaco_timer()} | {send_handle, term()} | {reply_data, reply_data()} | {protocol_version, integer()}</span></li><li><span class="v">request_keep_alive_timeout() = plain | integer() &gt;= 0</span></li><li><span class="v">Reason         =  term()</span></li></ul><p>Sends one or more transaction request(s) but does NOT wait for a reply</p><p>When sending one transaction in a message, <strong>Actions</strong> should be 
<strong>action_reqs()</strong>. When sending several transactions in a message,
<strong>Actions</strong> should be <strong>[action_reqs()]</strong>. Each element of the 
list is part of one transaction.</p><p>For some of <em>our</em> codecs (not binary), it is also possible 
to pre-encode the actions, in which case <strong>Actions</strong> will be 
either a <strong>binary()</strong> or <strong>[binary()]</strong>.</p><p>The default values of the send options are obtained by
megaco:conn_info(ConnHandle, Item). But the send options above,
may explicitly be overridden.</p><p>The ProtocolVersion version is the version actually encoded
in the reply message.</p><p>The callback function UserMod:handle_trans_reply/4 is invoked
when the reply arrives, when the request timer eventually
times out or when the outstanding requests are explicitly
cancelled. See the megaco_user module for more info about
the callback arguments.</p><p>Given as UserData argument to UserMod:handle_trans_reply/4.</p><a name="encode_actions"></a><h4>encode_actions(ConnHandle, Actions, Options) -&gt; {ok, BinOrBins} | {error, Reason}</h4><p>Encode action requests for one or more transaction request(s)</p><ul><li><span class="v">ConnHandle     = conn_handle()</span></li><li><span class="v">Actions        = action_reqs() | [action_reqs()]</span></li><li><span class="v">action_reqs()  = [#'ActionRequest'{}]</span></li><li><span class="v">Options        = [send_option()]</span></li><li><span class="v">send_option()  = {request_timer, megaco_timer()} | {long_request_timer, megaco_timer()} | {send_handle, term()} | {protocol_version, integer()}</span></li><li><span class="v">BinOrBins      = binary() | [binary()]</span></li><li><span class="v">Reason         = term()</span></li></ul><p>Encodes lists of action requests for one or more transaction 
request(s).</p><p>When encoding action requests for one transaction, 
<strong>Actions</strong> should be <strong>action_reqs()</strong>. 
When encoding action requests for several transactions,
<strong>Actions</strong> should be <strong>[action_reqs()]</strong>. Each element 
of the list is part of one transaction.</p><a name="token_tag2string"></a><h4>token_tag2string(Tag) -&gt; Result</h4><h4>token_tag2string(Tag, EncoderMod) -&gt; Result</h4><h4>token_tag2string(Tag, EncoderMod, Version) -&gt; Result</h4><p>Convert a token tag to a string</p><ul><li><span class="v">Tag = atom()</span></li><li><span class="v">EncoderMod = pretty | compact | encoder_module()</span></li><li><span class="v">encoder_module() = megaco_pretty_text_encoder | megaco_compact_text_encoder | atom()</span></li><li><span class="v">Version = int_version() | atom_version()</span></li><li><span class="v">int_version() = 1 | 2 | 3</span></li><li><span class="v">atom_version() = v1 | v2 | v3 | prev3c | prev3b</span></li><li><span class="v">Result = string() | {error, Reason}</span></li><li><span class="v">Reason = term()</span></li></ul><p>Convert a token tag to a string</p><p>If no encoder module is given, the default is used 
(which is pretty).</p><p>If no or an unknown version is given, 
the <em>best</em> version is used (which is v3).</p><p>If no match is found for <strong>Tag</strong>, <strong>Result</strong> will be the 
empty string (<strong>[]</strong>).</p><a name="cancel"></a><h4>cancel(ConnHandle, CancelReason) -&gt; ok | {error, ErrReason}</h4><p>Cancel all outstanding messages for this connection</p><ul><li><span class="v">ConnHandle   = conn_handle()</span></li><li><span class="v">CancelReason =  term()</span></li><li><span class="v">ErrReason    =  term()</span></li></ul><p>Cancel all outstanding messages for this connection</p><p>This causes outstanding megaco:call/3 requests to return.
The callback functions UserMod:handle_reply/4 and
UserMod:handle_trans_ack/4 are also invoked where it
applies.  See the megaco_user module for more info about the
callback arguments.</p><a name="process_received_message"></a><h4>process_received_message(ReceiveHandle, ControlPid, SendHandle, BinMsg) -&gt; ok</h4><h4>process_received_message(ReceiveHandle, ControlPid, SendHandle, BinMsg, Extra) -&gt; ok</h4><p>Process a received message</p><ul><li><span class="v">ReceiveHandle = #megaco_receive_handle{}</span></li><li><span class="v">ControlPid    = pid()</span></li><li><span class="v">SendHandle    = term()</span></li><li><span class="v">BinMsg        = binary()</span></li><li><span class="v">Extra         = term()</span></li></ul><p>Process a received message</p><p>This function is intended to be invoked by some
transport modules when get an incoming message. Which
transport that actually is used is up to the user to
choose.</p><p>The message is delivered as an Erlang binary and is decoded
by the encoding module stated in the receive handle together
with its encoding config (also in the receive
handle). Depending of the outcome of the decoding various
callback functions will be invoked. See megaco_user for more
info about the callback arguments.</p><p>The argument <strong>Extra</strong> is just an opaque data structure passed to the user 
via the callback functions in the 
<a href="megaco_user">user callback module</a>. 
Note however that if <strong>Extra</strong> has the value 
<strong>extra_undefined</strong> the argument will be ignored (same as if 
<strong>process_received_message/4</strong> had been called). 
See the documentation for the behaviour of the callback module,
<a href="megaco_user">megaco_user</a>, for more info. </p><p>Note that all processing is done in the context of the calling 
process. A transport module could call this function via one of the
<strong>spawn</strong> functions (e.g. <strong>spawn_opt</strong>). See also 
<strong>receive_message/4,5</strong>.
</p><p>If the message cannot be decoded the following callback
function will be invoked:</p><ul><li> <p>UserMod:handle_syntax_error/3</p> </li></ul><p>If the decoded message instead of transactions contains a
message error, the following callback function will be
invoked:</p><ul><li> <p>UserMod:handle_message_error/3</p> </li></ul><p>If the decoded message happens to be received before the
connection is established, a new "virtual" connection is
established. This is typically the case for the Media
Gateway Controller (MGC) upon the first Service Change.
When this occurs the following callback function will be
invoked:</p><ul><li> <p>UserMod:handle_connect/2</p> </li></ul><p>For each transaction request in the decoded message the
following callback function will be invoked:</p><ul><li> <p>UserMod:handle_trans_request/3</p> </li></ul><p>For each transaction reply in the decoded message the reply
is returned to the user. Either the originating function
megaco:call/3 will return.  Or in case the originating
function was megaco:case/3 the following callback function
will be invoked:</p><ul><li> <p>UserMod:handle_trans_reply/4</p> </li></ul><p>When a transaction acknowledgement is received it is
possible that user has decided not to bother about the
acknowledgement. But in case the return value from
UserMod:handle_trans_request/3 indicates that the
acknowledgement is important the following callback function
will be invoked:</p><ul><li> <p>UserMod:handle_trans_ack/4</p> </li></ul><p>See the megaco_user module for more info about the callback
arguments.</p><a name="receive_message"></a><h4>receive_message(ReceiveHandle, ControlPid, SendHandle, BinMsg) -&gt; ok</h4><h4>receive_message(ReceiveHandle, ControlPid, SendHandle, BinMsg, Extra) -&gt; ok</h4><p>Process a received message</p><ul><li><span class="v">ReceiveHandle = #megaco_receive_handle{}</span></li><li><span class="v">ControlPid    = pid()</span></li><li><span class="v">SendHandle    = term()</span></li><li><span class="v">BinMsg        = binary()</span></li><li><span class="v">Extra         = term()</span></li></ul><p>Process a received message</p><p>This is a callback function intended to be invoked by some
transport modules when get an incoming message. Which
transport that actually is used is up to the user to
choose.</p><p>In principle, this function calls the 
<strong>process_received_message/4</strong> function via a <strong>spawn</strong> to
perform the actual processing.</p><p>For further information see the 
<a href="#process_received_message">process_received_message/4</a> 
function.</p><a name="parse_digit_map"></a><h4>parse_digit_map(DigitMapBody) -&gt; {ok, ParsedDigitMap} | {error, Reason}</h4><p>Parses a digit map body</p><ul><li><span class="v">DigitMapBody       = string()</span></li><li><span class="v">ParsedDigitMap     = parsed_digit_map()</span></li><li><span class="v">parsed_digit_map() = term()</span></li><li><span class="v">Reason             = term()</span></li></ul><p>Parses a digit map body</p><p>Parses a digit map body, represented as a list of
characters, into a list of state transitions suited to
be evaluated by megaco:eval_digit_map/1,2.</p><a name="eval_digit_map"></a><h4>eval_digit_map(DigitMap) -&gt; {ok, MatchResult} | {error, Reason}</h4><h4>eval_digit_map(DigitMap, Timers) -&gt; {ok, MatchResult} | {error, Reason}</h4><p>Collect digit map letters according to the digit map</p><ul><li><span class="v">DigitMap           = #'DigitMapValue'{} | parsed_digit_map()</span></li><li><span class="v">parsed_digit_map() = term()</span></li><li><span class="v">ParsedDigitMap     = term()</span></li><li><span class="v">Timers             = ignore() | reject()</span></li><li><span class="v">ignore()           = ignore | {ignore, digit_map_value()}</span></li><li><span class="v">reject()           = reject | {reject, digit_map_value()} | digit_map_value()</span></li><li><span class="v">MatchResult        = {Kind, Letters} | {Kind, Letters, Extra}</span></li><li><span class="v">Kind               = kind()</span></li><li><span class="v">kind()             = full | unambiguous</span></li><li><span class="v">Letters            = [letter()]</span></li><li><span class="v">letter()           = $0..$9 | $a .. $k</span></li><li><span class="v">Extra              = letter()</span></li><li><span class="v">Reason             = term()</span></li></ul><p>Collect digit map letters according to the digit map.</p><p>When evaluating a digit map, a state machine waits for
timeouts and letters reported by
megaco:report_digit_event/2. The length of the various
timeouts are defined in the digit_map_value() record.</p><p>When a complete sequence of valid events has been received,
the result is returned as a list of letters.</p><p>There are two options for handling syntax errors (that is
when an unexpected event is received when the digit map
evaluator is expecting some other event). The unexpected
events may either be ignored or rejected. The latter means
that the evaluation is aborted and an error is returned. </p><a name="report_digit_event"></a><h4>report_digit_event(DigitMapEvalPid, Events) -&gt; ok | {error, Reason}</h4><p>Send one or more events to the event collector process</p><ul><li><span class="v">DigitMapEvalPid = pid()</span></li><li><span class="v">Events          = Event | [Event]</span></li><li><span class="v">Event           = letter() | pause() | cancel()</span></li><li><span class="v">letter()        = $0..$9 | $a .. $k | $A .. $K</span></li><li><span class="v">pause()         = one_second() | ten_seconds()</span></li><li><span class="v">one_second()    = $s | $S</span></li><li><span class="v">ten_seconds()   = $l | $L</span></li><li><span class="v">cancel()        = $z | $Z | cancel</span></li><li><span class="v">Reason          = term()</span></li></ul><p>Send one or more events to the event collector process.</p><p>Send one or more events to a process that is evaluating a
digit map, that is a process that is executing
megaco:eval_digit_map/1,2.</p><p>Note that the events <strong>$s | $S</strong>, <strong>l | $L</strong> and
<strong>$z | $Z</strong> has nothing to do with the timers using
the same characters.</p><a name="test_digit_event"></a><h4>test_digit_event(DigitMap, Events) -&gt; {ok, Kind, Letters} | {error, Reason}</h4><p>Feed digit map collector with events and return the result</p><ul><li><span class="v">DigitMap           = #'DigitMapValue'{} | parsed_digit_map()</span></li><li><span class="v">parsed_digit_map() = term()</span></li><li><span class="v">ParsedDigitMap     = term()</span></li><li><span class="v">Timers             = ignore() | reject()</span></li><li><span class="v">ignore()           = ignore | {ignore, digit_map_value()}</span></li><li><span class="v">reject()           = reject | {reject, digit_map_value()} | digit_map_value()</span></li><li><span class="v">DigitMapEvalPid    = pid()</span></li><li><span class="v">Events             = Event | [Event]</span></li><li><span class="v">Event              = letter() | pause() | cancel()</span></li><li><span class="v">Kind               = kind()</span></li><li><span class="v">kind()             = full | unambiguous</span></li><li><span class="v">Letters            = [letter()]</span></li><li><span class="v">letter()           = $0..$9 | $a .. $k | $A .. $K</span></li><li><span class="v">pause()            = one_second() | ten_seconds()</span></li><li><span class="v">one_second()       = $s | $S</span></li><li><span class="v">ten_seconds()      = $l | $L</span></li><li><span class="v">cancel    ()       = $z | $Z | cancel</span></li><li><span class="v">Reason             = term()</span></li></ul><p>Feed digit map collector with events and return the result</p><p>This function starts the evaluation of a digit map with
megaco:eval_digit_map/1 and sends a sequence of events to it
megaco:report_digit_event/2 in order to simplify testing of
digit maps.</p><a name="encode_sdp"></a><h4>encode_sdp(SDP) -&gt; {ok, PP} | {error, Reason}</h4><p>Encode an SDP construct</p><ul><li><span class="v">SDP = sdp_property_parm() | sdp_property_group() | sdp_property_groups() | asn1_NOVALUE</span></li><li><span class="v">PP = property_parm() | property_group() | property_groups() | asn1_NOVALUE</span></li><li><span class="v">Reason = term()</span></li></ul><p>Encode (generate) an SDP construct.</p><p>If a <strong>property_parm()</strong> is found as part of the input
(<strong>SDP</strong>) then it is left unchanged.</p><p>This function performs the following transformation:</p><ul><li> <p>sdp()                 -&gt; property_parm()</p> </li><li> <p>sdp_property_group()  -&gt; property_group()</p> </li><li> <p>sdp_property_groups() -&gt; property_groups()</p> </li></ul><a name="decode_sdp"></a><h4>decode_sdp(PP) -&gt; {ok, SDP} | {error, Reason}</h4><p>Decode an property parameter construct</p><ul><li><span class="v">PP = property_parm() | property_group() | property_groups() | asn1_NOVALUE</span></li><li><span class="v">SDP = sdp() | decode_sdp_property_group() | decode_sdp_property_groups() | asn1_NOVALUE</span></li><li><span class="v">decode_sdp() = sdp() | {property_parm(), DecodeError}</span></li><li><span class="v">decode_sdp_property_group() = [decode_sdp()]</span></li><li><span class="v">decode_sdp_property_groups() = [decode_sdp_property_group()]</span></li><li><span class="v">DecodeError = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Decode (parse) a property parameter construct.</p><p>When decoding <strong>property_group()</strong> or 
<strong>property_groups()</strong>, 
those property parameter constructs that cannot be decoded
(either because of decode error or because they are unknown),
will be returned as a two-tuple. The first element of which 
will be the (undecoded) property parameter and the other the 
actual reason. 
This means that the caller of this function has to expect not 
only sdp-records, but also this two-tuple construct.</p><p>This function performs the following transformation:</p><ul><li> <p>property_parm()   -&gt; sdp()</p> </li><li> <p>property_group()  -&gt; sdp_property_group()</p> </li><li> <p>property_groups() -&gt; sdp_property_groups()</p> </li></ul><a name="get_sdp_record_from_PG"></a><h4>get_sdp_record_from_PropertGroup(Type, PG) -&gt; [sdp()]</h4><p>Get all sdp records of a certain type from a property group</p><ul><li><span class="v">Type = v | c | m | o | a | b | t | r | z | k | s | i | u | e | p</span></li><li><span class="v">PG = sdp_property_group()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retreive all the sdp records of type <strong>Type</strong> from the
property group <strong>PG</strong>.</p><a name="versions1"></a><a name="versions2"></a><h4>versions1() -&gt; {ok, VersionInfo} | {error, Reason}</h4><h4>versions2() -&gt; {ok, Info} | {error, Reason}</h4><p>Retreive various system and application info</p><ul><li><span class="v">VersionInfo = [version_info()]</span></li><li><span class="v">version_info() = term()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Utility functions used to retrieve some system and
application info.</p><p>The difference between the two functions is in how they get
the modules to check. <strong>versions1</strong> uses the 
app-file and <strong>versions2</strong> uses the function 
<strong>application:get_key</strong>.</p><a name="print_version_info"></a><h4>print_version_info() -&gt; void()</h4><h4>print_version_info(VersionInfo) -&gt; void()</h4><p>Formated print of result of the versions functions</p><ul><li><span class="v">VersionInfo = [version_info()]</span></li><li><span class="v">version_info() = term()</span></li></ul><p>Utility function to produce a formated printout of the versions 
info generated by the <strong>versions1</strong> and <strong>versions2</strong> 
functions.</p><p>The function print_version_info/0 uses the result of function
version1/0 as <strong>VersionInfo</strong>.</p><p>Example: </p><pre>
           {ok, V} = megaco:versions1(), megaco:format_versions(V). 
        </pre><a name="enable_trace"></a><h4>enable_trace(Level, Destination) -&gt; void()</h4><p>Start megaco tracing</p><ul><li><span class="v">Level       = max | min | 0 &lt;= integer() &lt;= 100</span></li><li><span class="v">Destination = File | Port | HandlerSpec | io</span></li><li><span class="v">File        = string()</span></li><li><span class="v">Port        = integer()</span></li><li><span class="v">HandleSpec  = {HandlerFun, Data}</span></li><li><span class="v">HandleFun   = fun() (two arguments)</span></li><li><span class="v">Data        = term()</span></li></ul><p>This function is used to start megaco tracing at a given 
<strong>Level</strong> and direct result to the given <strong>Destination</strong>.</p><p>It starts a tracer server and then sets the proper match spec 
(according to <strong>Level</strong>).</p><p>In the case when <strong>Destination</strong> is <strong>File</strong>, the printable 
megaco trace events will be printed to the file <strong>File</strong> using
plain <strong>io:format/2</strong>. </p><p>In the case when <strong>Destination</strong> is <strong>io</strong>, the printable 
megaco trace events will be printed on stdout using plain 
<strong>io:format/2</strong>. </p><p>See <strong>dbg</strong> for further information.</p><a name="disable_trace"></a><h4>disable_trace() -&gt; void()</h4><p>Stop megaco tracing</p><p>This function is used to stop megaco tracing.</p><a name="set_trace"></a><h4>set_trace(Level) -&gt; void()</h4><p>Change megaco trace level</p><ul><li><span class="v">Level = max | min | 0 &lt;= integer() &lt;= 100</span></li></ul><p>This function is used to change the megaco trace level.</p><p>It is assumed that tracing has already been enabled (see 
<strong>enable_trace</strong> above).</p><a name="stats"></a><a name="get_stats"></a><h4>get_stats() -&gt; {ok, TotalStats} | {error, Reason}</h4><h4>get_stats(GlobalCounter) -&gt; {ok, CounterStats} | {error, Reason}</h4><h4>get_stats(ConnHandle) -&gt; {ok, ConnHandleStats} | {error, Reason}</h4><h4>get_stats(ConnHandle, Counter) -&gt; {ok, integer()} | {error, Reason}</h4><ul><li><span class="v">TotalStats = [total_stats()]</span></li><li><span class="v">total_stats() = {conn_handle(), [stats()]} | {global_counter(), integer()}</span></li><li><span class="v">GlobalCounter = global_counter()</span></li><li><span class="v">GlobalCounterStats = integer()</span></li><li><span class="v">ConnHandle = conn_handle()</span></li><li><span class="v">ConnHandleStats = [stats()]</span></li><li><span class="v">stats() = {counter(), integer()}</span></li><li><span class="v">Counter = counter()</span></li><li><span class="v">counter() = medGwyGatewayNumTimerRecovery |  medGwyGatewayNumErrors</span></li><li><span class="v">global_counter() = medGwyGatewayNumErrors</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retreive the (SNMP) statistic counters maintained by the 
megaco application. The global
counters handle events that cannot be attributed to 
a single connection (e.g. protocol errors that occur 
before the connection has been properly setup).</p><a name="reset_stats"></a><h4>reset_stats() -&gt; void()</h4><h4>reset_stats(ConnHandle) -&gt; void()</h4><ul><li><span class="v">ConnHandle = conn_handle()</span></li></ul><p>Reset all related (SNMP) statistics counters.</p><a name="test_request"></a><h4>test_request(ConnHandle, Version, EncodingMod, EncodingConfig, Actions) -&gt; {MegaMsg, EncodeRes}</h4><p>Tests if the Actions argument is correct</p><ul><li><span class="v">ConnHandle     = conn_handle()</span></li><li><span class="v">Version        = integer()</span></li><li><span class="v">EncodingMod    = atom()</span></li><li><span class="v">EncodingConfig = Encoding configuration</span></li><li><span class="v">Actions        = A list</span></li><li><span class="v">MegaMsg        = #'MegacoMessage'{}</span></li><li><span class="v">EncodeRes      = {ok, Bin} | {error, Reason}</span></li><li><span class="v">Bin            = binary()</span></li><li><span class="v">Reason         = term()</span></li></ul><p>Tests if the Actions argument is correctly composed.</p><p>This function is only intended for testing purposes. It's
supposed to have a same kind of interface as the <a href="#call">call</a> or <a href="#cast">cast</a> functions (with the additions
of the <strong>EncodingMod</strong> and <strong>EncodingConfig</strong>
arguments). It composes a complete megaco message end
attempts to encode it. The return value, will be a tuple of
the composed megaco message and the encode result. </p><a name="test_reply"></a><h4>test_reply(ConnHandle, Version, EncodingMod, EncodingConfig, Reply) -&gt; {MegaMsg, EncodeRes}</h4><p>Tests if the Reply argument is correct</p><ul><li><span class="v">ConnHandle     = conn_handle()</span></li><li><span class="v">Version        = integer()</span></li><li><span class="v">EncodingMod    = atom()</span></li><li><span class="v">EncodingConfig = A list</span></li><li><span class="v">Reply          = actual_reply()</span></li><li><span class="v">MegaMsg        = #'MegacoMessage'{}</span></li><li><span class="v">EncodeRes      = {ok, Bin} | {error, Reason}</span></li><li><span class="v">Bin            = binary()</span></li><li><span class="v">Reason         = term()</span></li></ul><p>Tests if the Reply argument is correctly composed.</p><p>This function is only intended for testing purposes. It's
supposed to test the <strong>actual_reply()</strong> return value of
the callback functions 
<a href="./megaco_user#trans_request">handle_trans_request</a>
and 
<a href="./megaco_user#trans_long_request">handle_trans_long_request</a>
functions (with the additions of the <strong>EncodingMod</strong> and
<strong>EncodingConfig</strong> arguments). It composes a complete
megaco message end attempts to encode it. The return value,
will be a tuple of the composed megaco message and the
encode result.</p><h3>megaco_edist_compress</h3><p>Megaco erlang dist compress behaviour.</p><p>The following functions should be exported from a 
<strong>megaco_edist_compress</strong> callback module:</p><h3>Functions</h3><h4>Module:encode(R, Version) -&gt; T</h4><p>Encode (compress) a megaco component.</p><ul><li><span class="v">R = megaco_message() | transaction() | action_reply() | action_request() | command_request()</span></li><li><span class="v">Version = integer()</span></li><li><span class="v">T = term()</span></li></ul><p>Compress a megaco component. The erlang dist encoder makes no 
assumption on the how or even if the component is compressed. </p><h4>Module:decode(T, Version) -&gt; R</h4><p>Decode (decompress) a megaco component.</p><ul><li><span class="v">T = term()</span></li><li><span class="v">Version = integer()</span></li><li><span class="v">R = megaco_message() | transaction() | action_reply() | action_request() | command_request()</span></li></ul><p>Decompress a megaco component. </p><h3>megaco_encoder</h3><p>Megaco encoder behaviour.</p><p>The following functions should be exported from a 
<strong>megaco_encoder</strong> callback module:</p><h4>DATA TYPES</h4><pre><code class="">
megaco_message() = #'MegacoMessage{}'
transaction() = {transactionRequest,     transaction_request()}      |
                {transactionPending,     transaction_reply()}        |
                {transactionReply,       transaction_pending()}      |
                {transactionResponseAck, transaction_response_ack()} |
                {segmentReply,           segment_reply()}
transaction_request() = #'TransactionRequest'{}
transaction_pending() = #'TransactionPending'{}
transaction_reply() = #'TransactionReply'{}
transaction_response_ack() = [transaction_ack()]
transaction_ack() = #'TransactionAck'{}
segment_reply() = #'SegmentReply'{}
action_request() = #'ActionRequest'{}
action_reply() = #'ActionReply'{}
    </code></pre><a name="encode_message"></a><h3>Functions</h3><h4>Module:encode_message(EncodingConfig, Version, Message) -&gt; {ok, Bin} | Error</h4><p>Encode a megaco message.</p><ul><li><span class="v">EncodingConfig = list()</span></li><li><span class="v">Version = integer()</span></li><li><span class="v">Message = megaco_message()</span></li><li><span class="v">Bin = binary()</span></li><li><span class="v">Error = term()</span></li></ul><p>Encode a megaco message.</p><a name="decode_message"></a><h4>Module:decode_message(EncodingConfig, Version, Bin) -&gt; {ok, Message} | Error</h4><p>Decode a megaco message.</p><ul><li><span class="v">EncodingConfig = list()</span></li><li><span class="v">Version = integer() | dynamic</span></li><li><span class="v">Message = megaco_message()</span></li><li><span class="v">Bin = binary()</span></li><li><span class="v">Error = term()</span></li></ul><p>Decode a megaco message. </p><p>Note that if the Version argument is <strong>dynamic</strong>, the
decoder should try to figure out the actual version from the
message itself and then use the proper decoder, e.g. version 1.
<br/>If on the other hand the Version argument is an integer, 
it means that this is the expected version of the message and 
the decoder for that version should be used.</p><a name="decode_mini_message"></a><h4>Module:decode_mini_message(EncodingConfig, Version, Bin) -&gt; {ok, Message} | Error</h4><p>Perform a minimal decode of a megaco message.</p><ul><li><span class="v">EncodingConfig = list()</span></li><li><span class="v">Version = integer() | dynamic</span></li><li><span class="v">Message = megaco_message()</span></li><li><span class="v">Bin = binary()</span></li><li><span class="v">Error = term()</span></li></ul><p>Perform a minimal decode of a megaco message. </p><p>The purpose of this function is to do a minimal decode of
Megaco message. A successfull result is a <strong>'MegacoMessage'</strong> 
in which only version and mid has been initiated. This function 
is used by the megaco_messenger module when the 
<strong>decode_message/3</strong> function fails to figure out the mid 
(the actual sender) of the message.</p><p>Note again that a successfull decode only returns a
partially initiated message.</p><a name="encode_transaction"></a><h4>Module:encode_transaction(EncodingConfig, Version, Transaction) -&gt; OK | Error</h4><p>Encode a megaco transaction.</p><ul><li><span class="v">EncodingConfig = list()</span></li><li><span class="v">Version = integer()</span></li><li><span class="v">Transaction = transaction()</span></li><li><span class="v">OK = {ok, Bin}</span></li><li><span class="v">Bin = binary()</span></li><li><span class="v">Error = {error, Reason}</span></li><li><span class="v">Reason = not_implemented | OtherReason</span></li><li><span class="v">OtherReason = term()</span></li></ul><p>Encode a megaco transaction. If this, for whatever reason, 
is not supported, the function should return the error reason 
<strong>not_implemented</strong>. </p><p>This functionality is used both when the transaction sender is 
used and for segmentation. So, for either of those to work, this 
function <em>must</em> be fully supported! </p><a name="encode_action_requests"></a><h4>Module:encode_action_requests(EncodingConfig, Version, ARs) -&gt; OK | Error</h4><p>Encode megaco action requests.</p><ul><li><span class="v">EncodingConfig = list()</span></li><li><span class="v">Version = integer()</span></li><li><span class="v">ARs = action_requests()</span></li><li><span class="v">action_requests() = [action_request()]</span></li><li><span class="v">OK = {ok, Bin}</span></li><li><span class="v">Bin = binary()</span></li><li><span class="v">Error = {error, Reason}</span></li><li><span class="v">Reason = not_implemented | OtherReason</span></li><li><span class="v">OtherReason = term()</span></li></ul><p>Encode megaco action requests. This function is called when 
the user calls the function 
<a href="./megaco#encode_actions">encode_actions/3</a>.
If that function is never used or if the codec cannot support this
(the encoding of individual actions), then return with error reason 
<strong>not_implemented</strong>. </p><a name="encode_action_reply"></a><h4>Module:encode_action_reply(EncodingConfig, Version, AR) -&gt; OK | Error</h4><p>Encode a megaco action reply.</p><ul><li><span class="v">EncodingConfig = list()</span></li><li><span class="v">Version = integer()</span></li><li><span class="v">AR = action_reply()</span></li><li><span class="v">OK = {ok, Bin}</span></li><li><span class="v">Bin = binary()</span></li><li><span class="v">Error = {error, Reason}</span></li><li><span class="v">Reason = not_implemented | OtherReason</span></li><li><span class="v">OtherReason = term()</span></li></ul><p>Encode a megaco action reply. If this, for whatever reason, 
is not supported, the function should return the error reason 
<strong>not_implemented</strong>. </p><p>This function is used when segmentation has been configured. 
So, for this to work, this function <em>must</em> be fully 
supported! </p><h3>megaco_transport</h3><p>Megaco transport behaviour.</p><p>The following functions should be exported from a 
<strong>megaco_transport</strong> callback module:<ul><li> <p><a href="#send_message">send_message/2</a> [<strong>mandatory</strong>]</p> </li><li> <p><a href="#send_message">send_message/3</a> [<strong>optional</strong>]</p>  </li><li> <p><a href="#resend_message">resend_message/2</a> [<strong>optional</strong>]</p> </li><li> </li></ul><a name="send_message"></a></p><h3>Functions</h3><h4>Module:send_message(Handle, Msg) -&gt; ok | {cancel, Reason} | Error</h4><h4>Module:send_message(Handle, Msg, Resend) -&gt; ok | {cancel, Reason} | Error</h4><p>Send a megaco message.</p><ul><li><span class="v">Handle = term()</span></li><li><span class="v">Msg = binary() | iolist()</span></li><li><span class="v">Resend = boolean()</span></li><li><span class="v">Reason = term()</span></li><li><span class="v">Error = term()</span></li></ul><p>Send a megaco message. </p><p>If the function returns <strong>{cancel, Reason}</strong>, 
this means the transport module decided not to send the message. 
This is <em>not</em> an error. No error messages will be issued 
and no error counters incremented. 
What actions this will result in depends on what kind of
message was sent. 
</p><p>In the case of requests, megaco will cancel the message in much 
the same way as if <strong>megaco:cancel</strong> had been called 
(after a successfull send). The information will be propagated
back to the user differently depending on how the request(s) where
issued: For requests issued using 
<a href="./megaco#call">megaco:call</a>, the info
will be delivered in the return value. For requests issued 
using <strong>megaco:cast</strong> the info will be delivered 
via a call to the callback function 
<a href="./megaco_user#trans_reply">handle_trans_reply</a>. </p><p>In the case of reply, megaco will cancel the reply and information
of this will be returned to the user via a call to the 
callback function 
<a href="./megaco_user#trans_ack">handle_trans_ack</a>. </p><p>The function <strong>send_message/3</strong> will only be called if the 
<a href="./megaco#ui_resend_indication">resend_indication</a>
config option has been set to the value <strong>flag</strong>. The third 
argument, <strong>Resend</strong> then indicates if the message send is 
a resend or not. </p><a name="resend_message"></a><h4>Module:resend_message(Handle, Msg) -&gt; ok | {cancel, Reason} | Error</h4><p>Re-send a megaco message.</p><ul><li><span class="v">Handle = term()</span></li><li><span class="v">Msg = binary() | iolist()</span></li><li><span class="v">Reason = term()</span></li><li><span class="v">Error = term()</span></li></ul><p>Re-send a megaco message. </p><p>Note that this function will only be called if the user has set the 
<a href="./megaco#ui_resend_indication">resend_indication</a> 
config option to <strong>true</strong><em>and</em> it is in fact a message 
resend. If not <em>both</em> of these condition's are meet, 
<strong>send_message</strong> will be called. </p><p>If the function returns <strong>{cancel, Reason}</strong>, this means the 
transport module decided not to send the message. 
This is <em>not</em> an error. No error messages will be issued 
and no error counters incremented. 
What actions this will result in depends on what kind of
message was sent. </p><p>In the case of requests, megaco will cancel the message in much 
the same way as if <strong>megaco:cancel</strong> had been called 
(after a successfull send). The information will be propagated
back to the user differently depending on how the request(s) where
issued: For requests issued using 
<a href="./megaco#call">megaco:call</a>, the info
will be delivered in the return value. For requests issued 
using <strong>megaco:cast</strong> the info will be delivered via a call
to the callback function 
<a href="./megaco_user#trans_reply">handle_trans_reply</a>. </p><p>In the case of reply, megaco will cancel the reply and information
of this will be returned to the user via a call to the 
callback function 
<a href="./megaco_user#trans_ack">handle_trans_ack</a>. </p><h3>megaco_tcp</h3><p>Interface module to TPKT transport protocol for Megaco/H.248.</p><p>This module contains the public interface to the TPKT (TCP/IP) version
transport protocol for Megaco/H.248.</p><h3>Functions</h3><h4>start_transport() -&gt; {ok, TransportRef}</h4><ul><li><span class="v">TransportRef = pid()</span></li></ul><p>This function is used for starting the TCP/IP transport service.
Use exit(TransportRef, Reason) to stop the transport service.</p><h4>listen(TransportRef, ListenPortSpecList) -&gt; ok</h4><ul><li><span class="v">TransportRef = pid() | regname()</span></li><li><span class="v">OptionListPerPort = [Option]</span></li><li><span class="v">Option = {port, integer()} |{options, list()} |{receive_handle, term()}</span></li></ul><p>This function is used for starting new TPKT listening socket
for TCP/IP.  The option list contains the socket
definitions.</p><h4>connect(TransportRef, OptionList) -&gt; {ok, Handle, ControlPid} |  {error, Reason}</h4><ul><li><span class="v">TransportRef = pid() | regname()</span></li><li><span class="v">OptionList = [Option]</span></li><li><span class="v">Option = {host, Ipaddr} | {port, integer()}  |{options, list()} |{receive_handle, term()} |{module, atom()}</span></li><li><span class="v">Handle = socket_handle()</span></li><li><span class="v">ControlPid = pid()</span></li><li><span class="v">Reason = term()</span></li></ul><p>This function is used to open a TPKT connection.</p><p>The <strong>module</strong> option makes it possible for the user to provide
their own callback module. The <strong>receive_message/4</strong> or
<strong>process_received_message/4</strong> functions of this module is called 
when a new message is received (which one depends on the size of the 
message; small - receive_message, large - process_received_message). 
Default value is <em>megaco</em>.</p><h4>close(Handle) -&gt; ok</h4><ul><li><span class="v">Handle = socket_handle()</span></li></ul><p>This function is used for closing an active TPKT connection.</p><h4>socket(Handle) -&gt; Socket</h4><ul><li><span class="v">Handle = socket_handle()</span></li><li><span class="v">Socket = inet_socket()</span></li></ul><p>This function is used to convert a socket_handle() to
a inet_socket(). inet_socket() is a plain socket,
see the inet module for more info.</p><h4>send_message(Handle, Message) -&gt; ok</h4><ul><li><span class="v">Handle = socket_handle()</span></li><li><span class="v">Message = binary() | iolist()</span></li></ul><p>Sends a message on a connection.</p><h4>block(Handle) -&gt; ok</h4><ul><li><span class="v">Handle = socket_handle()</span></li></ul><p>Stop receiving incoming messages on the socket.</p><h4>unblock(Handle) -&gt; ok</h4><ul><li><span class="v">Handle = socket_handle()</span></li></ul><p>Starting to receive incoming messages from the socket again.</p><a name="upgrade_receive_handle"></a><h4>upgrade_receive_handle(ControlPid) -&gt; ok</h4><ul><li><span class="v">ControlPid = pid()</span></li></ul><p>Update the receive handle of the control process (e.g. after
having changed protocol version).</p><a name="stats"></a><h4>get_stats() -&gt; {ok, TotalStats} | {error, Reason}</h4><h4>get_stats(SendHandle) -&gt; {ok, SendHandleStats} | {error, Reason}</h4><h4>get_stats(SendHandle, Counter) -&gt; {ok, CounterStats} | {error, Reason}</h4><ul><li><span class="v">TotalStats = [send_handle_stats()]</span></li><li><span class="v">total_stats() = {send_handle(), [stats()]}</span></li><li><span class="v">SendHandle = send_handle()</span></li><li><span class="v">SendHandleStats = [stats()]</span></li><li><span class="v">Counter = tcp_stats_counter()</span></li><li><span class="v">CounterStats = integer()</span></li><li><span class="v">stats() = {tcp_stats_counter(), integer()}</span></li><li><span class="v">tcp_stats_counter() = medGwyGatewayNumInMessages |  medGwyGatewayNumInOctets | medGwyGatewayNumOutMessages | medGwyGatewayNumOutOctets | medGwyGatewayNumErrors</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retreive the TCP related (SNMP) statistics counters.</p><h4>reset_stats() -&gt; void()</h4><h4>reset_stats(SendHandle) -&gt; void()</h4><ul><li><span class="v">SendHandle = send_handle()</span></li></ul><p>Reset all TCP related (SNMP) statistics counters.</p><h3>megaco_udp</h3><p>Interface module to UDP transport protocol for Megaco/H.248.</p><p>This module contains the public interface to the UDP/IP version
transport protocol for Megaco/H.248.</p><h3>Functions</h3><h4>start_transport() -&gt; {ok, TransportRef}</h4><ul><li><span class="v">TransportRef = pid()</span></li></ul><p>This function is used for starting the UDP/IP transport service.
Use exit(TransportRef, Reason) to stop the transport service.</p><h4>open(TransportRef, OptionList) -&gt;  {ok, Handle, ControlPid} |  {error, Reason}</h4><ul><li><span class="v">TransportRef = pid() | regname()</span></li><li><span class="v">OptionList = [option()]</span></li><li><span class="v">option() = {port, integer()} |{options, list()} |{receive_handle, receive_handle()} |{module, atom()}</span></li><li><span class="v">Handle = socket_handle()</span></li><li><span class="v">receive_handle() = term()</span></li><li><span class="v">ControlPid = pid()</span></li><li><span class="v">Reason = term()</span></li></ul><p>This function is used to open an UDP/IP socket.</p><p>The <strong>module</strong> option makes it possible for the user to provide
their own callback module. The functions <strong>receive_message/4</strong> or
<strong>process_received_message/4</strong> of this module is called when a new 
message is received (which one depends on the size of the message; 
small - receive_message, large - process_received_message). 
Default value is <em>megaco</em>.</p><h4>close(Handle, Msg) -&gt; ok</h4><ul><li><span class="v">Handle = socket_handle()</span></li><li><span class="v">Msg</span></li></ul><p>This function is used for closing an active UDP socket.</p><h4>socket(Handle) -&gt; Socket</h4><ul><li><span class="v">Handle = socket_handle()</span></li><li><span class="v">Socket = inet_socket()</span></li></ul><p>This function is used to convert a socket_handle() to
a inet_socket(). inet_socket() is a plain socket,
see the inet module for more info.</p><h4>create_send_handle(Handle, Host, Port) -&gt; send_handle()</h4><ul><li><span class="v">Handle = socket_handle()</span></li><li><span class="v">Host = {A,B,C,D} | string()</span></li><li><span class="v">Port = integer()</span></li></ul><p>Creates a send handle from a transport handle.  The send
handle is intended to be used by megaco_udp:send_message/2.</p><h4>send_message(SendHandle, Msg) -&gt; ok</h4><ul><li><span class="v">SendHandle = send_handle()</span></li><li><span class="v">Message = binary() | iolist()</span></li></ul><p>Sends a message on a socket. The send handle is obtained by
megaco_udp:create_send_handle/3. Increments the NumOutMessages
and NumOutOctets counters if message successfully sent. In case
of a failure to send, the NumErrors counter is <em>not</em>
incremented. This is done elsewhere in the megaco app.</p><h4>block(Handle) -&gt; ok</h4><ul><li><span class="v">Handle = socket_handle()</span></li></ul><p>Stop receiving incoming messages on the socket.</p><h4>unblock(Handle) -&gt; ok</h4><ul><li><span class="v">Handle = socket_handle()</span></li></ul><p>Starting to receive incoming messages from the socket again.</p><a name="upgrade_receive_handle"></a><h4>upgrade_receive_handle(ControlPid, NewHandle) -&gt; ok</h4><ul><li><span class="v">ControlPid = pid()</span></li><li><span class="v">NewHandle = receive_handle()</span></li><li><span class="v">receive_handle() = term()</span></li></ul><p>Update the receive handle of the control process (e.g. after
having changed protocol version).</p><a name="stats"></a><h4>get_stats() -&gt; {ok, TotalStats} | {error, Reason}</h4><h4>get_stats(SendHandle) -&gt; {ok, SendHandleStats} | {error, Reason}</h4><h4>get_stats(SendHandle, Counter) -&gt; {ok, CounterStats} | {error, Reason}</h4><ul><li><span class="v">TotalStats = [total_stats()]</span></li><li><span class="v">total_stats() = {send_handle(), [stats()]}</span></li><li><span class="v">SendHandle = send_handle()</span></li><li><span class="v">SendHandleStats = [stats()]</span></li><li><span class="v">Counter = udp_stats_counter()</span></li><li><span class="v">CounterStats = integer()</span></li><li><span class="v">stats() = {udp_stats_counter(), integer()}</span></li><li><span class="v">tcp_stats_counter() = medGwyGatewayNumInMessages |  medGwyGatewayNumInOctets | medGwyGatewayNumOutMessages | medGwyGatewayNumOutOctets | medGwyGatewayNumErrors</span></li><li><span class="v">Reason = term()</span></li></ul><p>Retreive the UDP related (SNMP) statistics counters.</p><h4>reset_stats() -&gt; void()</h4><h4>reset_stats(SendHandle) -&gt; void()</h4><ul><li><span class="v">SendHandle = send_handle()</span></li></ul><p>Reset all TCP related (SNMP) statistics counters.</p><h3>megaco_user</h3><p>Callback module for users of the Megaco application</p><p>This module defines the callback behaviour of Megaco users.  A
megaco_user compliant callback module must export the following
functions: <ul><li> <p><a href="#connect">handle_connect/2,3</a></p> </li><li> <p><a href="#disconnect">handle_disconnect/3</a></p> </li><li> <p><a href="#syntax_error">handle_syntax_error/3,4</a></p> </li><li> <p><a href="#message_error">handle_message_error/3,4</a></p> </li><li> <p><a href="#trans_request">handle_trans_request/3,4</a></p> </li><li> <p><a href="#trans_long_request">handle_trans_long_request/3,4</a></p> </li><li> <p><a href="#trans_reply">handle_trans_reply/4,5</a></p> </li><li> <p><a href="#trans_ack">handle_trans_ack/4,5</a></p> </li><li> <p><a href="#unexpected_trans">handle_unexpected_trans/3,4</a></p> </li><li> <p><a href="#request_abort">handle_trans_request_abort/4,5</a></p> </li><li> <p><a href="#segment_reply">handle_segment_reply/5,6</a></p> </li></ul>The semantics of them and their exact signatures are explained 
below. The <strong>user_args</strong> configuration parameter which may be used to
extend the argument list of the callback functions. For example,
the handle_connect function takes by default two arguments:<pre><code class="">
        handle_connect(Handle, Version)
    </code></pre>but if the <strong>user_args</strong> parameter is set to a longer
list, such as <strong>[SomePid,SomeTableRef]</strong>, the callback
function is expected to have these (in this case two) extra
arguments last in the argument list:<pre><code class="">
        handle_connect(Handle, Version, SomePid, SomeTableRef)
    </code></pre><a name="extra_argument"></a></p><h4>DATA TYPES</h4><pre><code class="">
action_request() = #'ActionRequest'{}
action_reply() = #'ActionReply'{}
error_desc() = #'ErrorDescriptor'{}
segment_no() = integer()
    </code></pre><pre><code class="">
conn_handle() = #megaco_conn_handle{}    </code></pre><p>The record initially returned by <strong>megaco:connect/4,5</strong>. 
It identifies a "virtual" connection and may be reused after a 
reconnect (disconnect + connect).</p><pre><code class="">
protocol_version() = integer()    </code></pre><p>Is the actual protocol version. In most cases the protocol
version is retrieved from the processed message, but there
are exceptions:</p><ul><li> <p>When <strong>handle_connect/2,3</strong> is triggered by an 
explicit call to <strong>megaco:connect/4,5</strong>.</p> </li><li> <p><strong>handle_disconnect/3</strong></p> </li><li> <p><strong>handle_syntax_error/3</strong></p> </li></ul><p>In these cases, the ProtocolVersion default
version is obtained from the static connection
configuration:</p><ul><li> <p><strong>megaco:conn_info(ConnHandle, protocol_version)</strong>.</p> </li></ul><a name="connect"></a><h3>Functions</h3><h4>handle_connect(ConnHandle, ProtocolVersion) -&gt; ok | error | {error,ErrorDescr}</h4><h4>handle_connect(ConnHandle, ProtocolVersion, Extra]) -&gt; ok | error | {error,ErrorDescr}</h4><p>Invoked when a new connection is established</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">ErrorDescr      = error_desc()</span></li><li><span class="v">Extra           = term()</span></li></ul><p>Invoked when a new connection is established</p><p>Connections may either be established by an explicit call to
megaco:connect/4 or implicitly at the first invocation of
megaco:receive_message/3.</p><p>Normally a Media Gateway (MG) connects explicitly while a Media
Gateway Controller (MGC) connects implicitly.</p><p>At the Media Gateway Controller (MGC) side it is possible to reject
a connection request (and send a message error reply to the gateway)
by returning <strong>{error, ErrorDescr}</strong> or simply <strong>error</strong> which
generates an error descriptor with code 402 (unauthorized) and 
reason "Connection refused by user" (this is also the case for all 
unknown results, such as exit signals or throw).</p><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_message_error/4</strong>. </p><p><strong>handle_connect/3</strong> (with <strong>Extra</strong>) 
can also be called as a result of a call to the 
<a href="./megaco#connect">megaco:connect/5</a> function
(if that function is called with the 
<strong>Extra</strong> argument different than <strong>ignore_extra</strong>. </p><a name="disconnect"></a><h4>handle_disconnect(ConnHandle, ProtocolVersion, Reason) -&gt; ok</h4><p>Invoked when a connection is teared down</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Invoked when a connection is teared down</p><p>The disconnect may either be made explicitly by a call to
megaco:disconnect/2 or implicitly when the control process
of the connection dies.</p><a name="syntax_error"></a><h4>handle_syntax_error(ReceiveHandle, ProtocolVersion, DefaultED) -&gt; reply | {reply, ED} | no_reply | {no_reply, ED}</h4><h4>handle_syntax_error(ReceiveHandle, ProtocolVersion, DefaultED, Extra) -&gt; reply | {reply, ED} | no_reply | {no_reply, ED}</h4><p>Invoked when a received message had syntax errors</p><ul><li><span class="v">ReceiveHandle    = receive_handle()</span></li><li><span class="v">ProtocolVersion  = protocol_version()</span></li><li><span class="v">DefaultED        = error_desc()</span></li><li><span class="v">ED               = error_desc()</span></li><li><span class="v">Extra            = term()</span></li></ul><p>Invoked when a received message had syntax errors</p><p>Incoming messages is delivered by megaco:receive_message/4
and normally decoded successfully. But if the decoding
failed this function is called in order to decide if the
originator should get a reply message (reply) or if the reply
silently should be discarded (no_reply).</p><p>Syntax errors are detected locally on this side of the
protocol and may have many causes, e.g. a malfunctioning
transport layer, wrong encoder/decoder selected, bad
configuration of the selected encoder/decoder etc.</p><p>The error descriptor defaults to <strong>DefaultED</strong>,
but can be overridden with an alternate one by
returning <strong>{reply,ED}</strong> or <strong>{no_reply,ED}</strong>
instead of <strong>reply</strong> and <strong>no_reply</strong> respectively.
</p><p>Any other return values (including exit signals or throw) and the
<strong>DefaultED</strong> will be used. </p><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_syntax_error/4</strong>. </p><a name="message_error"></a><h4>handle_message_error(ConnHandle, ProtocolVersion, ErrorDescr) -&gt; ok</h4><h4>handle_message_error(ConnHandle, ProtocolVersion, ErrorDescr, Extra) -&gt; ok</h4><p>Invoked when a received message just contains an error</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">ErrorDescr      = error_desc()</span></li><li><span class="v">Extra           = term()</span></li></ul><p>Invoked when a received message just contains an error
instead of a list of transactions.</p><p>Incoming messages is delivered by megaco:receive_message/4
and successfully decoded. Normally a message contains a list
of transactions, but it may instead contain an
ErrorDescriptor on top level of the message.</p><p>Message errors are detected remotely on the other side of
the protocol. And you probably don't want to reply to it,
but it may indicate that you have outstanding transactions
that not will get any response (request -&gt; reply; reply -&gt;
ack).</p><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_message_error/4</strong>. </p><a name="trans_request"></a><h4>handle_trans_request(ConnHandle, ProtocolVersion, ActionRequests) -&gt; pending() | reply() | ignore_trans_request</h4><h4>handle_trans_request(ConnHandle, ProtocolVersion, ActionRequests, Extra) -&gt; pending() | reply() | ignore_trans_request</h4><p>Invoked for each transaction request</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">ActionRequests  = [action_request()]</span></li><li><span class="v">Extra           = term()</span></li><li><span class="v">pending()       = {pending, req_data()}</span></li><li><span class="v">req_data()      = term()</span></li><li><span class="v">reply()         = {ack_action(), actual_reply()} | {ack_action(), actual_reply(), send_options()} </span></li><li><span class="v">ack_action()    = discard_ack | {handle_ack, ack_data()} | {handle_pending_ack, ack_data()} | {handle_sloppy_ack, ack_data()}</span></li><li><span class="v">actual_reply()  = [action_reply()] | error_desc()</span></li><li><span class="v">ack_data()      = term()</span></li><li><span class="v">send_options()  = [send_option()]</span></li><li><span class="v">send_option()   = {reply_timer, megaco_timer()} | {send_handle, term()} | {protocol_version, integer()}</span></li><li><span class="v">Extra           = term()</span></li></ul><p>Invoked for each transaction request</p><p>Incoming messages is delivered by megaco:receive_message/4
and successfully decoded. Normally a message contains a list
of transactions and this function is invoked for each
TransactionRequest in the message.</p><p>This function takes a list of 'ActionRequest' records and
has three main options:</p><dl><dt><strong>Return ignore_trans_request</strong></dt><dd> <p>Decide that these action requests shall be ignored
completely.</p> </dd><dt><strong>Return pending()</strong></dt><dd> <p>Decide that the processing of these action requests
will take a long time and that the originator should get
an immediate 'TransactionPending' reply as interim
response. The actual processing of these action requests
instead should be delegated to the the
handle_trans_long_request/3 callback function with the
req_data() as one of its arguments. </p> </dd><dt><strong>Return reply()</strong></dt><dd> <p>Process the action requests and either return an
error_descr() indicating some fatal error or a list of
action replies (wildcarded or not). </p> <p>If for some reason megaco is unable to deliver the reply,
the reason for this will be passed to the user via a call
to the callback function 
<a href="#trans_ack">handle_trans_ack</a>,
unless <strong>ack_action() = discard_ack</strong>. </p> <p>The ack_action() is  either:</p> <dl><dt><strong>discard_ack</strong></dt><dd> <p>Meaning that you don't care if the reply is
acknowledged or not.</p> </dd><dt><strong>{handle_ack, ack_data()} | {handle_ack, ack_data(), send_options()}</strong></dt><dd> <p>Meaning that you want an immediate acknowledgement
when the other part receives this transaction
reply. When the acknowledgement eventually is
received, the handle_trans_ack/4 callback function
will be invoked with the ack_data() as one of its
arguments. ack_data() may be any Erlang term.</p> </dd><dt><strong>{handle_pending_ack, ack_data()} | {handle_pending_ack, ack_data(), send_options()}</strong></dt><dd> <p>This has the same effect as the above, 
<em>if and only if</em> megaco has sent at least one 
pending message for this request (during the processing
of the request). If no pending message has been sent, then 
immediate acknowledgement will <em>not</em> be 
requested. </p> <p>Note that this only works as specified if the 
<strong>sent_pending_limit</strong> config option has been set to 
an integer value. </p> </dd><dt><strong>{handle_sloppy_ack, ack_data()}| {handle_sloppy_ack, ack_data(), send_options()}</strong></dt><dd> <p>Meaning that you want an acknowledgement <em>sometime</em>.
When the acknowledgement eventually is received, the 
handle_trans_ack/4 callback function will be invoked with 
the ack_data() as one of its arguments. ack_data() may be 
any Erlang term.</p> </dd></dl> </dd></dl><p>Any other return values (including exit signals or throw) will 
result in an error descriptor with code 500 (internal gateway error) 
and the module name (of the callback module) as reason. </p><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_trans_request/4</strong>. </p><a name="trans_long_request"></a><h4>handle_trans_long_request(ConnHandle, ProtocolVersion, ReqData) -&gt; reply()</h4><h4>handle_trans_long_request(ConnHandle, ProtocolVersion, ReqData, Extra) -&gt; reply()</h4><p>Optionally invoked for a time consuming transaction request</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">ReqData         = req_data()</span></li><li><span class="v">Extra           = term()</span></li><li><span class="v">req_data()      = term()</span></li><li><span class="v">reply()         = {ack_action(), actual_reply()} | {ack_action(), actual_reply(), send_options()}</span></li><li><span class="v">ack_action()    = discard_ack | {handle_ack, ack_data()} | {handle_sloppy_ack, ack_data()}</span></li><li><span class="v">actual_reply()  = [action_reply()] | error_desc()</span></li><li><span class="v">ack_data()      = term()</span></li><li><span class="v">send_options()  = [send_option()]</span></li><li><span class="v">send_option()   = {reply_timer, megaco_timer()} | {send_handle, term()} | {protocol_version, integer()}</span></li><li><span class="v">Extra           = term()</span></li></ul><p>Optionally invoked for a time consuming transaction request</p><p>If this function gets invoked or not is controlled by the
reply from the preceding call to handle_trans_request/3.
The handle_trans_request/3 function may decide to process
the action requests itself or to delegate the processing to
this function.</p><p>The req_data() argument to this function is the Erlang term
returned by handle_trans_request/3.</p><p>Any other return values (including exit signals or throw) will 
result in an error descriptor with code 500 (internal gateway error)
and the module name (of the callback module) as reason. </p><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_trans_long_request/4</strong>. </p><a name="trans_reply"></a><h4>handle_trans_reply(ConnHandle, ProtocolVersion, UserReply, ReplyData) -&gt; ok</h4><h4>handle_trans_reply(ConnHandle, ProtocolVersion, UserReply, ReplyData, Extra) -&gt; ok</h4><p>Optionally invoked for a transaction reply</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">UserReply       = success() | failure()</span></li><li><span class="v">success()       = {ok, result()} </span></li><li><span class="v">result()        = transaction_result() | segment_result()</span></li><li><span class="v">transaction_result() = action_reps()</span></li><li><span class="v">segment_result() = {segment_no(), last_segment(), action_reps()}</span></li><li><span class="v">action_reps()   = [action_reply()]</span></li><li><span class="v">failure()       = {error, reason()} | {error, ReplyNo, reason()}</span></li><li><span class="v">reason()  = transaction_reason() | segment_reason() | user_cancel_reason() | send_reason() | other_reason()</span></li><li><span class="v">transaction_reason() = error_desc()</span></li><li><span class="v">segment_reason() = {segment_no(), last_segment(), error_desc()}</span></li><li><span class="v">other_reason()   =  timeout | {segment_timeout, missing_segments()} | exceeded_recv_pending_limit | term()</span></li><li><span class="v">last_segment()  = bool()</span></li><li><span class="v">missing_segments() = [segment_no()]</span></li><li><span class="v">user_cancel_reason() = {user_cancel, reason_for_user_cancel()}</span></li><li><span class="v">reason_for_user_cancel() = term()</span></li><li><span class="v">send_reason() = send_cancelled_reason() | send_failed_reason()</span></li><li><span class="v">send_cancelled_reason() = {send_message_cancelled, reason_for_send_cancel()}</span></li><li><span class="v">reason_for_send_cancel() = term()</span></li><li><span class="v">send_failed_reason() = {send_message_failed, reason_for_send_failure()}</span></li><li><span class="v">reason_for_send_failure() = term()</span></li><li><span class="v">ReplyData       = reply_data()</span></li><li><span class="v">ReplyNo         = integer() &gt; 0</span></li><li><span class="v">reply_data()    = term()</span></li><li><span class="v">Extra           = term()</span></li></ul><p>Optionally invoked for a transaction reply</p><p>The sender of a transaction request has the option of
deciding, whether the originating Erlang process should
synchronously wait (<strong>megaco:call/3</strong>) for a reply or if the
message should be sent asynchronously (<strong>megaco:cast/3</strong>) and
the processing of the reply should be delegated this
callback function.</p><p>Note that if the reply is segmented (split into several smaller 
messages; segments), then some extra info, segment number and 
an indication if all segments of a reply has been received or
not, is also included in the <strong>UserReply</strong>. </p><p>The <strong>ReplyData</strong> defaults to 
<strong>megaco:lookup(ConnHandle, reply_data)</strong>, 
but may be explicitly overridden by a
<strong>megaco:cast/3</strong> option in order to forward info about the
calling context of the originating process.</p><p>At <strong>success()</strong>, the <strong>UserReply</strong> either contains:</p><ul><li> <p>A list of 'ActionReply' records possibly containing 
error indications.</p> </li><li> <p>A tuple of size three containing: 
the segment number, 
the <strong>last segment indicator</strong> and finally 
a list of 'ActionReply' records possibly containing error 
indications. This is of course only possible if the 
reply was segmented. </p> </li></ul><p><strong>failure()</strong> indicates an local or external error and
can be one of the following: </p><ul><li> <p>A <strong>transaction_reason()</strong>, indicates that the remote 
user has replied with an explicit transactionError.</p> </li><li> <p>A <strong>segment_reason()</strong>, indicates that the remote user 
has replied with an explicit transactionError for this 
segment. This is of course only possible if the reply was 
segmented. </p> </li><li> <p>A <strong>user_cancel_reason()</strong>, indicates that the request 
has been canceled by the user. <strong>reason_for_user_cancel()</strong> 
is the reason given in the call to the 
<a href="./megaco#cancel">cancel</a>
function.</p> </li><li> <p>A <strong>send_reason()</strong>, indicates that the transport module
<a href="./megaco_transport#send_message">send_message</a>
function did not send the message. The reason for this can be: </p> <ul><li> <p><strong>send_cancelled_reason()</strong> - the message sending was 
deliberately cancelled. <strong>reason_for_send_cancel()</strong> 
is the reason given in the <strong>cancel</strong> return
from the 
<a href="./megaco_transport#send_message">send_message</a> 
function. </p> </li><li> <p><strong>send_failed_reason()</strong> - an error occurred while attempting to 
send the message. </p> </li></ul> </li><li> <p>An <strong>other_reason()</strong>, indicates some other error such 
as: </p> <ul><li> <p><strong>timeout</strong> - the reply failed to arrive before the 
request timer expired.</p> </li><li> <p><strong>{segment_timeout, missing_segments()}</strong> - 
one or more segments
was not delivered before the expire of the segment 
timer.</p> </li><li> <p><strong>exceeded_recv_pending_limit</strong> - the pending
limit was exceeded for this request.</p> </li></ul> </li></ul><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_trans_reply/5</strong>. </p><a name="trans_ack"></a><h4>handle_trans_ack(ConnHandle, ProtocolVersion, AckStatus, AckData) -&gt; ok</h4><h4>handle_trans_ack(ConnHandle, ProtocolVersion, AckStatus, AckData, Extra) -&gt; ok</h4><p>Optionally invoked for a transaction acknowledgement</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">AckStatus       = ok | {error, reason()}</span></li><li><span class="v">reason() = user_cancel_reason() | send_reason() | other_reason()</span></li><li><span class="v">user_cancel_reason() = {user_cancel, reason_for_user_cancel()}</span></li><li><span class="v">send_reason()   = send_cancelled_reason() | send_failed_reason()</span></li><li><span class="v">send_cancelled_reason() = {send_message_cancelled, reason_for_send_cancel()}</span></li><li><span class="v">reason_for_send_cancel() = term()</span></li><li><span class="v">send_failed_reason() = {send_message_failed, reason_for_send_failure()}</span></li><li><span class="v">reason_for_send_failure() = term()</span></li><li><span class="v">other_reason()   = term()</span></li><li><span class="v">AckData          = ack_data()</span></li><li><span class="v">ack_data()       = term()</span></li><li><span class="v">Extra            = term()</span></li></ul><p>Optionally invoked for a transaction acknowledgement</p><p>If this function gets invoked or not, is controlled by the
reply from the preceding call to handle_trans_request/3.
The handle_trans_request/3 function may decide to return
{handle_ack, ack_data()} or {handle_sloppy_ack, ack_data()} 
meaning that you need an immediate acknowledgement of the 
reply and that this function should be invoked to handle the 
acknowledgement.</p><p>The ack_data() argument to this function is the Erlang term
returned by handle_trans_request/3.</p><p>If the AckStatus is ok, it is indicating that this is a
true acknowledgement of the transaction reply.</p><p>If the AckStatus is {error, Reason}, it is an indication that the
acknowledgement or even the reply (for which this is an 
acknowledgement) was not delivered, but there is no point in
waiting any longer for it to arrive. This happens when: </p><dl><dt><strong>reply_timer</strong></dt><dd> <p>The <strong>reply_timer</strong> eventually times out.</p> </dd><dt>reply send failure</dt><dd> <p>When megaco fails to send the reply (see
<a href="#trans_reply">handle_trans_reply</a>), 
for whatever reason. </p> </dd><dt>cancel</dt><dd> <p>The user has explicitly cancelled the wait 
(megaco:cancel/2).</p> </dd></dl><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_trans_ack/5</strong>. </p><a name="unexpected_trans"></a><a name="handle_unexpected_trans"></a><h4>handle_unexpected_trans(ConnHandle, ProtocolVersion, Trans) -&gt; ok</h4><h4>handle_unexpected_trans(ConnHandle, ProtocolVersion, Trans, Extra) -&gt; ok</h4><p>Invoked when an unexpected message is received</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">Trans           = #'TransactionPending'{} | #'TransactionReply'{} | #'TransactionResponseAck'{}</span></li><li><span class="v">Extra           = term()</span></li></ul><p>Invoked when a unexpected message is received</p><p>If a reply to a request is not received in time, the
megaco stack removes all info about the request from
its tables. If a reply should arrive after this has been
done the app has no way of knowing where to send this message.
The message is delivered to the "user" by calling this
function on the local node (the node which has the link).</p><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_unexpected_trans/4</strong>. </p><a name="request_abort"></a><h4>handle_trans_request_abort(ConnHandle, ProtocolVersion, TransNo, Pid) -&gt; ok</h4><h4>handle_trans_request_abort(ConnHandle, ProtocolVersion, TransNo, Pid, Extra) -&gt; ok</h4><p>Invoked when an transaction request has been aborted</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">TransNo         = integer()</span></li><li><span class="v">Pid             = undefined | pid()</span></li><li><span class="v">Extra           = term()</span></li></ul><p>Invoked when a transaction request has been aborted</p><p>This function is invoked if the originating pending limit
has been exceeded. This usually means that a request has taken 
abnormally long time to complete.</p><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_trans_request_abort/5</strong>. </p><a name="segment_reply"></a><h4>handle_segment_reply(ConnHandle, ProtocolVersion, TransNo, SegNo, SegCompl) -&gt; ok</h4><h4>handle_segment_reply(ConnHandle, ProtocolVersion, TransNo, SegNo, SegCompl, Extra) -&gt; ok</h4><p>Segment Reply Indication</p><ul><li><span class="v">ConnHandle      = conn_handle()</span></li><li><span class="v">ProtocolVersion = protocol_version()</span></li><li><span class="v">TransNo         = integer()</span></li><li><span class="v">SegNo           = integer()</span></li><li><span class="v">SegCompl        = asn1_NOVALUE | 'NULL'</span></li><li><span class="v">Extra           = term()</span></li></ul><p>This function is called when a segment reply has been received
if the 
<a href="./megaco#conn_info">segment_reply_ind</a> 
config option has been set to true.</p><p>This is in effect a progress report.</p><p>See <a href="#extra_argument">note</a> 
above about the <strong>Extra</strong> argument in 
<strong>handle_segment_reply/6</strong>. </p><h3>megaco_flex_scanner</h3><p>Interface module to the flex scanner linked in driver.</p><p>This module contains the public interface to the flex scanner 
linked in driver. The flex scanner performs the scanning phase
of text message decoding.The flex scanner is written using a tool called <em>flex</em>. 
In order to be able to compile the flex scanner driver, this
tool has to be available. By default the flex scanner reports line-number of an error.
But it can be built without line-number reporting. Instead
token number is used. This will speed up the scanning some
5-10%. Use <strong>--disable-megaco-flex-scanner-lineno</strong> when
configuring the application.The scanner will, by default, be built as a reentrant scanner <em>if</em> the 
flex utility supports this (it depends on the version of flex). 
It is possible to explicitly disable this even when flex support this.
Use <strong>--disable-megaco-reentrant-flex-scanner</strong> when
configuring the application.</p><h4>DATA TYPES</h4><pre><code class="">

megaco_ports() = term()
megaco_version() = integer() &gt;= 1
 
    </code></pre><a name="start"></a><h3>Functions</h3><h4>start() -&gt; {ok, PortOrPorts} | {error, Reason}</h4><ul><li><span class="v">PortOrPorts = megaco_ports()</span></li><li><span class="v">Reason = term()</span></li></ul><p>This function is used to start the flex scanner. 
It locates the library and loads the linked in driver.</p><p>On a single core system or if it's a non-reentrant scanner,
a single port is created. On a multi-core system with a reentrant 
scanner, several ports will be created (one for each scheduler). </p><p>Note that the process that calls this function <em>must</em> 
be permanent. If it dies, the port(s) will exit and the driver unload.</p><a name="stop"></a><h4>stop(PortOrPorts) -&gt; stopped</h4><ul><li><span class="v">PortOrPorts = megaco_ports()</span></li></ul><p>This function is used to stop the flex scanner. It also
unloads the driver.</p><a name="is_reentrant_enabled"></a><h4>is_reentrant_enabled() -&gt; Boolean</h4><ul><li><span class="v">Boolean = boolean()</span></li></ul><p>Is the flex scanner reentrant or not.</p><a name="is_scanner_port"></a><h4>is_scanner_port(Port, PortOrPorts) -&gt; Boolean</h4><ul><li><span class="v">Port = port()</span></li><li><span class="v">PortOrPorts = megaco_ports()</span></li><li><span class="v">Boolean = boolean()</span></li></ul><p>Checks if a port is a flex scanner port or not (useful when
if a port exits). </p><a name="scan"></a><h4>scan(Binary, PortOrPorts) -&gt; {ok, Tokens, Version, LatestLine} | {error, Reason, LatestLine}</h4><ul><li><span class="v">Binary = binary()</span></li><li><span class="v">PortOrPorts = megaco_ports()</span></li><li><span class="v">Tokens = list()</span></li><li><span class="v">Version = megaco_version()</span></li><li><span class="v">LatestLine = integer()</span></li><li><span class="v">Reason = term()</span></li></ul><p>Scans a megaco message and generates a token list to be passed on the parser. </p><h3>megaco_codec_meas</h3><p>This module implements a simple megaco codec measurement tool.</p><p>This module implements a simple megaco codec measurement tool.Results are written to file (excel compatible text files) and on stdout.<em>Note</em> that this module is <em>not</em> included in the runtime part of 
the application.</p><h3>Functions</h3><h4>start() -&gt; void()</h4><h4>start(MessagePackage) -&gt; void()</h4><ul><li><span class="v">MessagePackageRaw = message_package()</span></li><li><span class="v">message_package() = atom()</span></li></ul><p>This function runs the measurement on all the <em>official</em> codecs;
pretty, compact, ber, per and erlang.</p><h3>megaco_codec_mstone1</h3><p>This module implements a simple megaco codec-based performance tool.</p><p>This module implements the <em>mstone1</em> tool, 
a simple megaco codec-based performance tool.The results, the mstone value(s), are written to stdout.<em>Note</em> that this module is <em>not</em> included in the runtime part of 
the application.</p><h3>Functions</h3><h4>start() -&gt; void()</h4><h4>start(MessagePackage) -&gt; void()</h4><h4>start(MessagePackage, Factor) -&gt; void()</h4><ul><li><span class="v">MessagePackage = message_package()</span></li><li><span class="v">message_package() = atom()</span></li><li><span class="v">Factor() = integer() &gt; 0</span></li></ul><p>This function starts the <em>mstone1</em> performance test with all codec configs. 
<strong>Factor</strong> (defaults to <strong>1</strong>) processes are started for every supported 
codec config. </p><p>Each process encodes and decodes their messages. 
The number of messages processed in total (for all processes) is the mstone value.</p><h4>start_flex() -&gt; void()</h4><h4>start_flex(MessagePackage) -&gt; void()</h4><h4>start_flex(MessagePackage, Factor) -&gt; void()</h4><ul><li><span class="v">MessagePackage = message_package()</span></li><li><span class="v">message_package() = atom()</span></li><li><span class="v">Factor() = integer() &gt; 0</span></li></ul><p>This function starts the <em>mstone1</em> performance test with only the
flex codec configs (i.e. <strong>pretty</strong> and <strong>compact</strong> with <strong>flex</strong>). 
The same number of processes are started as when running the standard
test (using the <strong>start/0,1</strong> function).
Each process encodes and decodes their messages. 
The number of messages processed in total (for all processes) is the mstone value.</p><h4>start_only_drv() -&gt; void()</h4><h4>start_only_drv(MessagePackage) -&gt; void()</h4><h4>start_only_drv(MessagePackage, Factor) -&gt; void()</h4><ul><li><span class="v">MessagePackage = message_package()</span></li><li><span class="v">message_package() = atom()</span></li><li><span class="v">Factor() = integer() &gt; 0</span></li></ul><p>This function starts the <em>mstone1</em> performance test with only the
driver using codec configs (i.e. <strong>pretty</strong> and <strong>compact</strong> 
with <strong>flex</strong>, and <strong>ber</strong> and <strong>per</strong> with <strong>driver</strong> 
and <strong>erlang</strong> with <strong>compressed</strong>). 
The same number of processes are started as when running the standard
test (using the <strong>start/0,1</strong> function).
Each process encodes and decodes their messages. 
The number of messages processed in total (for all processes) is the mstone value.</p><h4>start_no_drv() -&gt; void()</h4><h4>start_no_drv(MessagePackage) -&gt; void()</h4><h4>start_no_drv(MessagePackage, Factor) -&gt; void()</h4><ul><li><span class="v">MessagePackage = message_package()</span></li><li><span class="v">message_package() = atom()</span></li><li><span class="v">Factor() = integer() &gt; 0</span></li></ul><p>This function starts the <em>mstone1</em> performance test with codec configs
not using any drivers (i.e. <strong>pretty</strong> and <strong>compact</strong> without 
<strong>flex</strong>, <strong>ber</strong> and <strong>per</strong> without <strong>driver</strong> and 
<strong>erlang</strong> without <strong>compressed</strong>). 
The same number of processes are started as when running the standard
test (using the <strong>start/0,1</strong> function).
Each process encodes and decodes their messages. 
The number of messages processed in total (for all processes) is the mstone value.</p><h3>megaco_codec_mstone2</h3><p>This module implements a simple megaco codec-based performance tool.</p><p>This module implements the <em>mstone2</em> tool, 
a simple megaco codec-based performance tool.The results, the mstone value(s), are written to stdout.<em>Note</em> that this module is <em>not</em> included in the runtime part of 
the application.</p><h3>Functions</h3><h4>start() -&gt; void()</h4><h4>start(MessagePackage) -&gt; void()</h4><ul><li><span class="v">MessagePackage = message_package()</span></li><li><span class="v">message_package() = atom()</span></li></ul><p>This function starts the <em>mstone2</em> performance test with all codec configs. 
Processes are created dynamically. Each process make <em>one</em> run
through their messages (decoding and encoding messages) and then exits. 
When one process exits, a new is created with the same codec config and set 
of messages. </p><p>The number of messages processed in total (for all processes) is the mstone value.</p><h3>megaco_codec_transform</h3><p>Megaco message transformation utility.</p><p>This module implements a simple megaco message transformation utility.<em>Note</em> that this module is <em>not</em> included in the
runtime part of the application.<a name="export_messages"></a></p><h3>Functions</h3><h4>export_messages() -&gt; void()</h4><h4>export_messages(MessagePackage) -&gt; void()</h4><ul><li><span class="v">MessagePackage = atom()</span></li></ul><p>Export the messages in the <strong>MessagePackage</strong> (default 
is <strong>time_test</strong>). </p><p>The output produced by this function is a directory structure 
with the following structure: </p><pre><code class="">
&lt;message package&gt;/pretty/&lt;message-files&gt;
                  compact/&lt;message-files&gt;
                  per/&lt;message-files&gt;
                  ber/&lt;message-files&gt;
                  erlang/&lt;message-files&gt;
        </code></pre></body></html>