{above,
 {above,
  {above,
   {above,
    {above,
     {above,
      {above,
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {text,[16,35,32,67,111,109,109,111,110,32,67,97,118,101,97,116,115]},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,
               "fThis section lists a few modules and BIFs to watch out for, not only from a performance point of view."}],
             0,false}],
           0,true},
          null},
         null}}},
      {sep,
       [{above,
         {above,{above,{text,[0]},null},null},
         {above,
          {above,
           {text,[15,35,35,32,84,105,109,101,114,32,77,111,100,117,108,101]},
           null},
          null}},
        {above,
         {above,{above,{text,[0]},null},null},
         {above,
          {above,
           {sep,
            [{sep,
              [{sep,
                [{text,
                  [21,67,114,101,97,116,105,110,103,32,116,105,109,101,114,
                   115,32,117,115,105,110,103]}],
                0,false},
               {text,"2[erlang:send_after/3](../erts/erlang#send_after/3)"},
               {sep,[{text,[3,97,110,100]}],0,false},
               {text,"4[erlang:start_timer/3](../erts/erlang#start_timer/3)"},
               {sep,
                [{text,
                  ">, is much more efficient than using the timers provided by the"}],
                0,false},
               {text,
                [16,91,116,105,109,101,114,93,40,46,47,116,105,109,101,114,
                 41]},
               {sep,
                [{text,
                  [21,109,111,100,117,108,101,32,105,110,32,83,84,68,76,73,66,
                   46,32,84,104,101]}],
                0,false},
               {text,[7,42,116,105,109,101,114,42]},
               {sep,
                [{text,
                  "¾module uses a separate process to manage the timers. That process can easily become overloaded if many processes create and cancel timers frequently (especially when using the SMP emulator)."}],
                0,false}],
              0,false}],
            0,true},
           null},
          null}},
        {above,
         {above,{above,{text,[0]},null},null},
         {above,
          {above,
           {sep,
            [{sep,
              [{sep,
                [{text,
                  [20,84,104,101,32,102,117,110,99,116,105,111,110,115,32,105,
                   110,32,116,104,101]}],
                0,false},
               {text,[7,42,116,105,109,101,114,42]},
               {sep,
                [{text,")module that do not manage timers (such as"}],
                0,false},
               {text,"\f*timer:tc/3*"},
               {sep,[{text,[2,111,114]}],0,false},
               {text,
                [15,42,116,105,109,101,114,58,115,108,101,101,112,47,49,42]},
               {sep,
                [{text,
                  "C), do not call the timer-server process and are therefore harmless."}],
                0,false}],
              0,false}],
            0,true},
           null},
          null}}],
       0,false}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {text,
           [17,35,35,32,108,105,115,116,95,116,111,95,97,116,111,109,47,49]},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,
               "®Atoms are not garbage-collected. Once an atom is created, it is never removed. The emulator terminates if the limit for the number of atoms (1,048,576 by default) is reached."}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "¤Therefore, converting arbitrary input strings to atoms can be dangerous in a system that runs continuously. If only certain well-defined atoms are allowed as input,"}],
               0,false},
              {text,
               "A[list_to_existing_atom/1](../erts/erlang#list_to_existing_atom/1)"},
              {sep,
               [{text,
                 "Æcan be used to to guard against a denial-of-service attack. (All atoms that are allowed must have been created earlier, for example, by simply using all of them in a module and loading that module.)"}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,[5,85,115,105,110,103]}],0,false},
              {text,
               [16,42,108,105,115,116,95,116,111,95,97,116,111,109,47,49,42]},
              {sep,[{text,"&to construct an atom that is passed to"}],0,false},
              {text,"\t*apply/3*"},
              {sep,
               [{text,
                 "Ias follows, is quite expensive and not recommended in time-critical code:"}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {above,
           {above,
            {text,[6,96,96,96,101,114,108]},
            {sep,
             [{text,
               "3\napply(list_to_atom(\"some_prefix\"++Var), foo, Args)"}],
             0,true}},
           {text,[3,96,96,96]}},
          null},
         null}}],
      0,false}},
    {sep,
     [{above,
       {above,{above,{text,[0]},null},null},
       {above,{above,{text,"\v## length/1"},null},null}},
      {above,
       {above,{above,{text,[0]},null},null},
       {above,
        {above,
         {sep,
          [{sep,
            [{sep,
              [{text,
                "fThe time for calculating the length of a list is proportional to the length of the list, as opposed to"}],
              0,false},
             {text,[14,42,116,117,112,108,101,95,115,105,122,101,47,49,42]},
             {sep,[{text,[1,44]}],0,false},
             {text,"\r*byte_size/1*"},
             {sep,[{text,[5,44,32,97,110,100]}],0,false},
             {text,"\f*bit_size/1*"},
             {sep,[{text,"%, which all execute in constant time."}],0,false}],
            0,false}],
          0,true},
         null},
        null}},
      {above,
       {above,{above,{text,[0]},null},null},
       {above,
        {above,
         {sep,
          [{sep,
            [{sep,
              [{text,
                "6Normally, there is no need to worry about the speed of"}],
              0,false},
             {text,"\n*length/1*"},
             {sep,
              [{text,
                [145,44,32,98,101,99,97,117,115,101,32,105,116,32,105,115,32,
                 101,102,102,105,99,105,101,110,116,108,121,32,105,109,112,
                 108,101,109,101,110,116,101,100,32,105,110,32,67,46,32,73,
                 110,32,116,105,109,101,45,99,114,105,116,105,99,97,108,32,99,
                 111,100,101,44,32,121,111,117,32,109,105,103,104,116,32,119,
                 97,110,116,32,116,111,32,97,118,111,105,100,32,105,116,32,
                 105,102,32,116,104,101,32,105,110,112,117,116,32,108,105,115,
                 116,32,99,111,117,108,100,32,112,111,116,101,110,116,105,97,
                 108,108,121,32,98,101,32,118,101,114,121,32,108,111,110,103,
                 46]}],
              0,false}],
            0,false}],
          0,true},
         null},
        null}},
      {above,
       {above,{above,{text,[0]},null},null},
       {above,
        {above,
         {sep,
          [{sep,
            [{sep,[{text,"\fSome uses of"}],0,false},
             {text,"\n*length/1*"},
             {sep,
              [{text,
                "=can be replaced by matching. For example, the following code:"}],
              0,false}],
            0,false}],
          0,true},
         null},
        null}},
      {above,
       {above,{above,{text,[0]},null},null},
       {above,
        {above,
         {above,
          {above,
           {text,[6,96,96,96,101,114,108]},
           {sep,[{text,"&\nfoo(L) when length(L) >= 3 ->\n    ..."}],0,true}},
          {text,[3,96,96,96]}},
         null},
        null}},
      {above,
       {above,{above,{text,[0]},null},null},
       {above,
        {above,
         {sep,
          [{sep,
            [{text,
              [20,99,97,110,32,98,101,32,114,101,119,114,105,116,116,101,110,
               32,116,111,58]}],
            0,false}],
          0,true},
         null},
        null}},
      {above,
       {above,{above,{text,[0]},null},null},
       {above,
        {above,
         {above,
          {above,
           {text,[6,96,96,96,101,114,108]},
           {sep,[{text,"\e\nfoo([_,_,_|_]=L) ->\n   ..."}],0,true}},
          {text,[3,96,96,96]}},
         null},
        null}},
      {above,
       {above,{above,{text,[0]},null},null},
       {above,
        {above,
         {sep,
          [{sep,
            [{sep,
              [{text,
                [29,79,110,101,32,115,108,105,103,104,116,32,100,105,102,102,
                 101,114,101,110,99,101,32,105,115,32,116,104,97,116]}],
              0,false},
             {text,"\v*length(L)*"},
             {sep,[{text,"\bfails if"}],0,false},
             {text,[3,42,76,42]},
             {sep,
              [{text,
                "\\is an improper list, while the pattern in the second code fragment accepts an improper list."}],
              0,false}],
            0,false}],
          0,true},
         null},
        null}}],
     0,false}},
   {sep,
    [{above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,[15,35,35,32,115,101,116,101,108,101,109,101,110,116,47,51]},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,"+[setelement/3](../erts/erlang#setelement/3)"},
            {sep,
             [{text,
               "Icopies the tuple it modifies. Therefore, updating a tuple in a loop using"}],
             0,false},
            {text,[14,42,115,101,116,101,108,101,109,101,110,116,47,51,42]},
            {sep,
             [{text,"+creates a new copy of the tuple every time."}],
             0,false}],
           0,false}],
         0,true},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{sep,
             [{text,
               "ÅThere is one exception to the rule that the tuple is copied. If the compiler clearly can see that destructively updating the tuple would give the same result as if the tuple was copied, the call to"}],
             0,false},
            {text,[14,42,115,101,116,101,108,101,109,101,110,116,47,51,42]},
            {sep,[{text,"&is replaced with a special destructive"}],0,false},
            {text,"\f*setelement*"},
            {sep,
             [{text,
               "6instruction. In the following code sequence, the first"}],
             0,false},
            {text,[14,42,115,101,116,101,108,101,109,101,110,116,47,51,42]},
            {sep,
             [{text,"5call copies the tuple and modifies the ninth element:"}],
             0,false}],
           0,false}],
         0,true},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {above,
         {above,
          {text,[6,96,96,96,101,114,108]},
          {sep,
           [{text,
             [130,10,109,117,108,116,105,112,108,101,95,115,101,116,101,108,
              101,109,101,110,116,40,84,48,41,32,45,62,10,32,32,32,32,84,49,
              32,61,32,115,101,116,101,108,101,109,101,110,116,40,57,44,32,84,
              48,44,32,98,97,114,41,44,10,32,32,32,32,84,50,32,61,32,115,101,
              116,101,108,101,109,101,110,116,40,55,44,32,84,49,44,32,102,111,
              111,98,97,114,41,44,10,32,32,32,32,115,101,116,101,108,101,109,
              101,110,116,40,53,44,32,84,50,44,32,110,101,119,95,118,97,108,
              117,101,41,46]}],
           0,true}},
         {text,[3,96,96,96]}},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{sep,
             [{text,
               [17,84,104,101,32,116,119,111,32,102,111,108,108,111,119,105,
                110,103]}],
             0,false},
            {text,[14,42,115,101,116,101,108,101,109,101,110,116,47,51,42]},
            {sep,[{text," calls modify the tuple in place."}],0,false}],
           0,false}],
         0,true},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{sep,[{text,"#For the optimization to be applied,"}],0,false},
            {text,[7,42,42,97,108,108,42,42]},
            {sep,[{text,"'the followings conditions must be true:"}],0,false}],
           0,false}],
         0,true},
        null},
       null}},
     {above,
      {above,
       {above,
        {sep,
         [{text,[1,42]},
          {text,
           "CThe indices must be integer literals, not variables or expressions."}],
         0,false},
        {sep,
         [{text,[1,42]},
          {text,".The indices must be given in descending order."}],
         0,false}},
       {sep,
        [{text,[1,42]},
         {sep,
          [{sep,
            [{text,
              "BThere must be no calls to another function in between the calls to"}],
            0,false},
           {text,[14,42,115,101,116,101,108,101,109,101,110,116,47,51,42]},
           {sep,[{text,[1,46]}],0,false}],
          0,false}],
        0,false}},
      {sep,
       [{text,[1,42]},
        {sep,
         [{sep,[{text,"\eThe tuple returned from one"}],0,false},
          {text,[14,42,115,101,116,101,108,101,109,101,110,116,47,51,42]},
          {sep,
           [{text,"0call must only be used in the subsequent call to"}],
           0,false},
          {text,[14,42,115,101,116,101,108,101,109,101,110,116,47,51,42]},
          {sep,[{text,[1,46]}],0,false}],
         0,false}],
       0,false}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{sep,
             [{text,"*If the code cannot be structured as in the"}],
             0,false},
            {text,
             [23,42,109,117,108,116,105,112,108,101,95,115,101,116,101,108,
              101,109,101,110,116,47,49,42]},
            {sep,
             [{text,
               [150,101,120,97,109,112,108,101,44,32,116,104,101,32,98,101,
                115,116,32,119,97,121,32,116,111,32,109,111,100,105,102,121,
                32,109,117,108,116,105,112,108,101,32,101,108,101,109,101,110,
                116,115,32,105,110,32,97,32,108,97,114,103,101,32,116,117,112,
                108,101,32,105,115,32,116,111,32,99,111,110,118,101,114,116,
                32,116,104,101,32,116,117,112,108,101,32,116,111,32,97,32,108,
                105,115,116,44,32,109,111,100,105,102,121,32,116,104,101,32,
                108,105,115,116,44,32,97,110,100,32,99,111,110,118,101,114,
                116,32,105,116,32,98,97,99,107,32,116,111,32,97,32,116,117,
                112,108,101,46]}],
             0,false}],
           0,false}],
         0,true},
        null},
       null}}],
    0,false}},
  {sep,
   [{above,
     {above,{above,{text,[0]},null},null},
     {above,{above,{text,"\t## size/1"},null},null}},
    {above,
     {above,{above,{text,[0]},null},null},
     {above,
      {above,
       {sep,
        [{sep,
          [{text,"\b*size/1*"},
           {sep,
            [{text,".returns the size for both tuples and binaries."}],
            0,false}],
          0,false}],
        0,true},
       null},
      null}},
    {above,
     {above,{above,{text,[0]},null},null},
     {above,
      {above,
       {sep,
        [{sep,
          [{sep,
            [{text,[14,85,115,105,110,103,32,116,104,101,32,66,73,70,115]}],
            0,false},
           {text,[14,42,116,117,112,108,101,95,115,105,122,101,47,49,42]},
           {sep,[{text,[3,97,110,100]}],0,false},
           {text,"\r*byte_size/1*"},
           {sep,
            [{text,
              [150,103,105,118,101,115,32,116,104,101,32,99,111,109,112,105,
               108,101,114,32,97,110,100,32,116,104,101,32,114,117,110,116,
               105,109,101,32,115,121,115,116,101,109,32,109,111,114,101,32,
               111,112,112,111,114,116,117,110,105,116,105,101,115,32,102,111,
               114,32,111,112,116,105,109,105,122,97,116,105,111,110,46,32,65,
               110,111,116,104,101,114,32,97,100,118,97,110,116,97,103,101,32,
               105,115,32,116,104,97,116,32,116,104,101,32,66,73,70,115,32,
               103,105,118,101,32,68,105,97,108,121,122,101,114,32,109,111,
               114,101,32,116,121,112,101,32,105,110,102,111,114,109,97,116,
               105,111,110,46]}],
            0,false}],
          0,false}],
        0,true},
       null},
      null}}],
   0,false}},
 {sep,
  [{above,
    {above,{above,{text,[0]},null},null},
    {above,
     {above,
      {text,[17,35,35,32,115,112,108,105,116,95,98,105,110,97,114,121,47,50]},
      null},
     null}},
   {above,
    {above,{above,{text,[0]},null},null},
    {above,
     {above,
      {sep,
       [{sep,
         [{sep,
           [{text,
             "TIt is usually more efficient to split a binary using matching instead of calling the"}],
           0,false},
          {text,[16,42,115,112,108,105,116,95,98,105,110,97,114,121,47,50,42]},
          {sep,
           [{text,"5function. Furthermore, mixing bit syntax matching and"}],
           0,false},
          {text,[16,42,115,112,108,105,116,95,98,105,110,97,114,121,47,50,42]},
          {sep,
           [{text,"6can prevent some optimizations of bit syntax matching."}],
           0,false}],
         0,false}],
       0,true},
      null},
     null}},
   {above,
    {above,{above,{text,[0]},null},null},
    {above,
     {above,{sep,[{sep,[{text,[6,42,42,68,79,42,42]}],0,false}],0,true},null},
     null}},
   {above,
    {above,{above,{text,[0]},null},null},
    {above,
     {above,
      {above,
       {above,
        {text,[3,96,96,96]},
        {sep,
         [{text,"/\n        <<Bin1:Num/binary,Bin2/binary>> = Bin,"}],
         0,true}},
       {text,[3,96,96,96]}},
      null},
     null}},
   {above,
    {above,{above,{text,[0]},null},null},
    {above,
     {above,{sep,[{sep,[{text,"\n**DO NOT**"}],0,false}],0,true},null},
     null}},
   {above,
    {above,{above,{text,[0]},null},null},
    {above,
     {above,
      {above,
       {above,
        {text,[3,96,96,96]},
        {sep,
         [{text,"-\n        {Bin1,Bin2} = split_binary(Bin, Num)"}],
         0,true}},
       {text,[3,96,96,96]}},
      null},
     null}}],
  0,false}}
