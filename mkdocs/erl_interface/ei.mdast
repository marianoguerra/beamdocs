{above,
 {above,
  {above,
   {above,
    {above,
     {above,
      {above,
       {above,
        {above,{above,{text,[0]},null},null},
        {above,{above,{text,[4,35,32,101,105]},null},null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,{above,{text,[4,35,32,101,105]},null},null}}},
      {above,
       {above,{above,{text,[0]},null},null},
       {above,
        {above,
         {sep,
          [{sep,
            [{text,"4Routines for handling the Erlang binary term format."}],
            0,false}],
          0,true},
         null},
        null}}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{sep,
             [{above,
               {above,{above,{text,[0]},null},null},
               {above,
                {above,
                 {sep,
                  [{sep,
                    [{text,
                      "RThe support for VxWorks is deprecated as of OTP 22, and will be removed in OTP 23."}],
                    0,false}],
                  0,true},
                 null},
                null}}],
             0,false},
            {above,
             {above,{above,{text,[0]},null},null},
             {above,
              {above,
               {sep,
                [{sep,
                  [{sep,[{text,"\vThe library"}],0,false},
                   {text,[4,42,101,105,42]},
                   {sep,
                    [{text,
                      "Qcontains macros and functions to encode and decode the Erlang binary term format."}],
                    0,false}],
                  0,false}],
                0,true},
               null},
              null}},
            {above,
             {above,{above,{text,[0]},null},null},
             {above,
              {above,
               {sep,
                [{sep,
                  [{text,[4,42,101,105,42]},
                   {sep,
                    [{text,
                      [143,97,108,108,111,119,115,32,121,111,117,32,116,111,
                       32,99,111,110,118,101,114,116,32,97,116,111,109,115,44,
                       32,108,105,115,116,115,44,32,110,117,109,98,101,114,
                       115,44,32,97,110,100,32,98,105,110,97,114,105,101,115,
                       32,116,111,32,97,110,100,32,102,114,111,109,32,116,104,
                       101,32,98,105,110,97,114,121,32,102,111,114,109,97,116,
                       46,32,84,104,105,115,32,105,115,32,117,115,101,102,117,
                       108,32,119,104,101,110,32,119,114,105,116,105,110,103,
                       32,112,111,114,116,32,112,114,111,103,114,97,109,115,
                       32,97,110,100,32,100,114,105,118,101,114,115,46]}],
                    0,false},
                   {text,[4,42,101,105,42]},
                   {sep,
                    [{text,".uses a given buffer, no dynamic memory (except"}],
                    0,false},
                   {text,
                    [17,42,101,105,95,100,101,99,111,100,101,95,102,117,110,
                     40,41,42]},
                   {sep,
                    [{text,
                      [26,41,32,97,110,100,32,105,115,32,111,102,116,101,110,
                       32,113,117,105,116,101,32,102,97,115,116,46]}],
                    0,false}],
                  0,false}],
                0,true},
               null},
              null}},
            {above,
             {above,{above,{text,[0]},null},null},
             {above,
              {above,
               {sep,
                [{sep,
                  [{text,[4,42,101,105,42]},
                   {sep,
                    [{text,
                      "¡also handles C-nodes, C-programs that talks Erlang distribution with Erlang nodes (or other C-nodes) using the Erlang distribution format. The difference between"}],
                    0,false},
                   {text,[4,42,101,105,42]},
                   {sep,[{text,[3,97,110,100]}],0,false},
                   {text,
                    [15,42,101,114,108,95,105,110,116,101,114,102,97,99,101,
                     42]},
                   {sep,[{text,[7,105,115,32,116,104,97,116]}],0,false},
                   {text,[4,42,101,105,42]},
                   {sep,
                    [{text,
                      [153,117,115,101,115,32,116,104,101,32,98,105,110,97,
                       114,121,32,102,111,114,109,97,116,32,100,105,114,101,
                       99,116,108,121,32,119,104,101,110,32,115,101,110,100,
                       105,110,103,32,97,110,100,32,114,101,99,101,105,118,
                       105,110,103,32,116,101,114,109,115,46,32,73,116,32,105,
                       115,32,97,108,115,111,32,116,104,114,101,97,100,32,115,
                       97,102,101,44,32,97,110,100,32,117,115,105,110,103,32,
                       116,104,114,101,97,100,115,44,32,111,110,101,32,112,
                       114,111,99,101,115,115,32,99,97,110,32,104,97,110,100,
                       108,101,32,109,117,108,116,105,112,108,101,32,67,45,
                       110,111,100,101,115,46,32,84,104,101]}],
                    0,false},
                   {text,
                    [15,42,101,114,108,95,105,110,116,101,114,102,97,99,101,
                     42]},
                   {sep,
                    [{text,
                      [26,108,105,98,114,97,114,121,32,105,115,32,98,117,105,
                       108,116,32,111,110,32,116,111,112,32,111,102]}],
                    0,false},
                   {text,[4,42,101,105,42]},
                   {sep,
                    [{text,
                      "L, but of legacy reasons, it does not allow for multiple C-nodes. In general,"}],
                    0,false},
                   {text,[4,42,101,105,42]},
                   {sep,
                    [{text,"&is the preferred way of doing C-nodes."}],
                    0,false}],
                  0,false}],
                0,true},
               null},
              null}},
            {above,
             {above,{above,{text,[0]},null},null},
             {above,
              {above,
               {sep,
                [{sep,
                  [{text,
                    [320,84,104,101,32,100,101,99,111,100,101,32,97,110,100,
                     32,101,110,99,111,100,101,32,102,117,110,99,116,105,111,
                     110,115,32,117,115,101,32,97,32,98,117,102,102,101,114,
                     32,97,110,100,32,97,110,32,105,110,100,101,120,32,105,
                     110,116,111,32,116,104,101,32,98,117,102,102,101,114,44,
                     32,119,104,105,99,104,32,112,111,105,110,116,115,32,97,
                     116,32,116,104,101,32,112,111,105,110,116,32,119,104,101,
                     114,101,32,116,111,32,101,110,99,111,100,101,32,97,110,
                     100,32,100,101,99,111,100,101,46,32,84,104,101,32,105,
                     110,100,101,120,32,105,115,32,117,112,100,97,116,101,100,
                     32,116,111,32,112,111,105,110,116,32,114,105,103,104,116,
                     32,97,102,116,101,114,32,116,104,101,32,116,101,114,109,
                     32,101,110,99,111,100,101,100,47,100,101,99,111,100,101,
                     100,46,32,78,111,32,99,104,101,99,107,105,110,103,32,105,
                     115,32,100,111,110,101,32,119,104,101,116,104,101,114,32,
                     116,104,101,32,116,101,114,109,32,102,105,116,115,32,105,
                     110,32,116,104,101,32,98,117,102,102,101,114,32,111,114,
                     32,110,111,116,46,32,73,102,32,101,110,99,111,100,105,
                     110,103,32,103,111,101,115,32,111,117,116,115,105,100,
                     101,32,116,104,101,32,98,117,102,102,101,114,44,32,116,
                     104,101,32,112,114,111,103,114,97,109,32,99,97,110,32,99,
                     114,97,115,104,46]}],
                  0,false}],
                0,true},
               null},
              null}},
            {above,
             {above,{above,{text,[0]},null},null},
             {above,
              {above,
               {sep,
                [{sep,
                  [{text,"\"All functions take two parameters:"}],
                  0,false}],
                0,true},
               null},
              null}},
            {above,
             {sep,
              [{text,[1,42]},
               {sep,
                [{text,[5,42,98,117,102,42]},
                 {sep,
                  [{text,
                    "?is a pointer to the buffer where the binary data is or will be."}],
                  0,false}],
                0,false}],
              0,false},
             {sep,
              [{text,[1,42]},
               {sep,
                [{text,[7,42,105,110,100,101,120,42]},
                 {sep,
                  [{text,
                    "ris a pointer to an index into the buffer. This parameter is incremented with the size of the term decoded/encoded."}],
                  0,false}],
                0,false}],
              0,false}},
            {above,
             {above,{above,{text,[0]},null},null},
             {above,
              {above,
               {sep,
                [{sep,
                  [{sep,
                    [{text,
                      [19,84,104,101,32,100,97,116,97,32,105,115,32,116,104,
                       117,115,32,97,116]}],
                    0,false},
                   {text,"\r*buf[*index]*"},
                   {sep,[{text,[7,119,104,101,110,32,97,110]}],0,false},
                   {text,[4,42,101,105,42]},
                   {sep,
                    [{text,
                      [19,102,117,110,99,116,105,111,110,32,105,115,32,99,97,
                       108,108,101,100,46]}],
                    0,false}],
                  0,false}],
                0,true},
               null},
              null}},
            {above,
             {above,{above,{text,[0]},null},null},
             {above,
              {above,
               {sep,
                [{sep,
                  [{sep,
                    [{text,"$All encode functions assume that the"}],
                    0,false},
                   {text,[5,42,98,117,102,42]},
                   {sep,[{text,[3,97,110,100]}],0,false},
                   {text,[7,42,105,110,100,101,120,42]},
                   {sep,
                    [{text,
                      "uparameters point to a buffer large enough for the data. To get the size of an encoded term, without encoding it, pass"}],
                    0,false},
                   {text,[6,42,78,85,76,76,42]},
                   {sep,
                    [{text,"&instead of a buffer pointer. Parameter"}],
                    0,false},
                   {text,[7,42,105,110,100,101,120,42]},
                   {sep,
                    [{text,
                      "?is incremented, but nothing will be encoded. This is the way in"}],
                    0,false},
                   {text,[4,42,101,105,42]},
                   {sep,
                    [{text,
                      [29,116,111,32,34,112,114,101,102,108,105,103,104,116,
                       34,32,116,101,114,109,32,101,110,99,111,100,105,110,
                       103,46]}],
                    0,false}],
                  0,false}],
                0,true},
               null},
              null}},
            {above,
             {above,{above,{text,[0]},null},null},
             {above,
              {above,
               {sep,
                [{sep,
                  [{sep,
                    [{text,
                      "³There are also encode functions that use a dynamic buffer. It is often more convenient to use these to encode data. All encode functions comes in two versions; those starting with"}],
                    0,false},
                   {text,[6,42,101,105,95,120,42]},
                   {sep,
                    [{text,
                      [21,117,115,101,32,97,32,100,121,110,97,109,105,99,32,
                       98,117,102,102,101,114,46]}],
                    0,false}],
                  0,false}],
                0,true},
               null},
              null}},
            {above,
             {above,{above,{text,[0]},null},null},
             {above,
              {above,
               {sep,
                [{sep,
                  [{sep,
                    [{text,
                      [20,65,108,108,32,102,117,110,99,116,105,111,110,115,32,
                       114,101,116,117,114,110]}],
                    0,false},
                   {text,[3,42,48,42]},
                   {sep,
                    [{text,
                      [24,105,102,32,115,117,99,99,101,115,115,102,117,108,44,
                       32,111,116,104,101,114,119,105,115,101]}],
                    0,false},
                   {text,[4,42,45,49,42]},
                   {sep,
                    [{text,
                      "f(for example, if a term is not of the expected type, or the data to decode is an invalid Erlang term)."}],
                    0,false}],
                  0,false}],
                0,true},
               null},
              null}},
            {above,
             {above,{above,{text,[0]},null},null},
             {above,
              {above,
               {sep,
                [{sep,
                  [{sep,
                    [{text,
                      [132,83,111,109,101,32,111,102,32,116,104,101,32,100,
                       101,99,111,100,101,32,102,117,110,99,116,105,111,110,
                       115,32,110,101,101,100,32,97,32,112,114,101,45,97,108,
                       108,111,99,97,116,101,100,32,98,117,102,102,101,114,46,
                       32,84,104,105,115,32,98,117,102,102,101,114,32,109,117,
                       115,116,32,98,101,32,97,108,108,111,99,97,116,101,100,
                       32,108,97,114,103,101,32,101,110,111,117,103,104,44,32,
                       97,110,100,32,102,111,114,32,110,111,110,45,99,111,109,
                       112,111,117,110,100,32,116,121,112,101,115,32,116,104,
                       101]}],
                    0,false},
                   {text,
                    [15,42,101,105,95,103,101,116,95,116,121,112,101,40,41,
                     42]},
                   {sep,
                    [{text,
                      "[function returns the size required (notice that for strings an extra byte is needed for the"}],
                    0,false},
                   {text,[6,42,78,85,76,76,42]},
                   {sep,[{text,"\r-terminator)."}],0,false}],
                  0,false}],
                0,true},
               null},
              null}}],
           0,false}],
         0,true},
        null},
       null}}},
    {sep,
     [{above,
       {above,{above,{text,[0]},null},null},
       {above,{above,{text,"\r## Data Types"},null},null}},
      {above,
       {above,
        {text,[4,60,100,108,62]},
        {nest,4,
         {above,
          {above,
           {above,{above,{text,[0]},null},null},
           {above,
            {above,
             {sep,
              [{text,[4,60,100,116,62]},
               {sep,
                [{sep,
                  [{text,
                    [20,101,114,108,97,110,103,95,99,104,97,114,95,101,110,99,
                     111,100,105,110,103]},
                   {sep,
                    [{text,
                      [20,101,114,108,97,110,103,95,99,104,97,114,95,101,110,
                       99,111,100,105,110,103]}],
                    0,false}],
                  0,false}],
                0,false},
               {text,[5,60,47,100,116,62]}],
              0,true},
             null},
            null}},
          {above,
           {above,{above,{text,[0]},null},null},
           {above,
            {above,
             {sep,
              [{text,[4,60,100,100,62]},
               {sep,
                [{above,
                  {above,{above,{text,[0]},null},null},
                  {above,
                   {above,
                    {above,
                     {above,
                      {text,[3,96,96,96]},
                      {sep,
                       [{text,
                         "h\ntypedef enum {\n    ERLANG_ASCII = 1,\n    ERLANG_LATIN1 = 2,\n    ERLANG_UTF8 = 4\n} erlang_char_encoding;"}],
                       0,true}},
                     {text,[3,96,96,96]}},
                    null},
                   null}},
                 {above,
                  {above,{above,{text,[0]},null},null},
                  {above,
                   {above,
                    {sep,
                     [{sep,
                       [{sep,
                         [{text,"'The character encodings used for atoms."}],
                         0,false},
                        {text,"\fERLANG_ASCII"},
                        {sep,
                         [{text,
                           [334,114,101,112,114,101,115,101,110,116,115,32,55,
                            45,98,105,116,32,65,83,67,73,73,46,32,76,97,116,
                            105,110,45,49,32,97,110,100,32,85,84,70,45,56,32,
                            97,114,101,32,100,105,102,102,101,114,101,110,116,
                            32,101,120,116,101,110,115,105,111,110,115,32,111,
                            102,32,55,45,98,105,116,32,65,83,67,73,73,46,32,
                            65,108,108,32,55,45,98,105,116,32,65,83,67,73,73,
                            32,99,104,97,114,97,99,116,101,114,115,32,97,114,
                            101,32,118,97,108,105,100,32,76,97,116,105,110,45,
                            49,32,97,110,100,32,85,84,70,45,56,32,99,104,97,
                            114,97,99,116,101,114,115,46,32,65,83,67,73,73,32,
                            97,110,100,32,76,97,116,105,110,45,49,32,98,111,
                            116,104,32,114,101,112,114,101,115,101,110,116,32,
                            101,97,99,104,32,99,104,97,114,97,99,116,101,114,
                            32,98,121,32,111,110,101,32,98,121,116,101,46,32,
                            65,110,32,85,84,70,45,56,32,99,104,97,114,97,99,
                            116,101,114,32,99,97,110,32,99,111,110,115,105,
                            115,116,32,111,102,32,49,45,52,32,98,121,116,101,
                            115,46,32,78,111,116,105,99,101,32,116,104,97,116,
                            32,116,104,101,115,101,32,99,111,110,115,116,97,
                            110,116,115,32,97,114,101,32,98,105,116,45,102,
                            108,97,103,115,32,97,110,100,32,99,97,110,32,98,
                            101,32,99,111,109,98,105,110,101,100,32,119,105,
                            116,104,32,98,105,116,119,105,115,101,32,79,82,
                            46]}],
                         0,false}],
                       0,false}],
                     0,true},
                    null},
                   null}}],
                0,false},
               {text,[5,60,47,100,100,62]}],
              0,true},
             null},
            null}}}}},
       {text,[5,60,47,100,108,62]}}],
     0,false}},
   {sep,
    [{above,
      {above,{above,{text,[0]},null},null},
      {above,{above,{text,"\v# Functions"},null},null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,";## ei_decode_atom(const char *buf, int *index, char *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,[15,68,101,99,111,100,101,32,97,110,32,97,116,111,109,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,"+Decodes an atom from the binary format. The"}],
               0,false},
              {text,[6,42,78,85,76,76,42]},
              {sep,
               [{text,")-terminated name of the atom is placed at"}],
               0,false},
              {text,[3,42,112,42]},
              {sep,[{text,"\t. At most"}],0,false},
              {text,"\f*MAXATOMLEN*"},
              {sep,[{text,"\"bytes can be placed in the buffer."}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         [156,35,35,32,101,105,95,100,101,99,111,100,101,95,97,116,111,109,95,
          97,115,40,99,111,110,115,116,32,99,104,97,114,32,42,98,117,102,44,
          32,105,110,116,32,42,105,110,100,101,120,44,32,99,104,97,114,32,42,
          112,44,32,105,110,116,32,112,108,101,110,44,32,101,114,108,97,110,
          103,95,99,104,97,114,95,101,110,99,111,100,105,110,103,32,119,97,
          110,116,44,32,101,114,108,97,110,103,95,99,104,97,114,95,101,110,99,
          111,100,105,110,103,42,32,119,97,115,44,32,101,114,108,97,110,103,
          95,99,104,97,114,95,101,110,99,111,100,105,110,103,42,32,114,101,
          115,117,108,116,41,58,105,110,116]},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,[15,68,101,99,111,100,101,32,97,110,32,97,116,111,109,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,"+Decodes an atom from the binary format. The"}],
               0,false},
              {text,[6,42,78,85,76,76,42]},
              {sep,
               [{text,"3-terminated name of the atom is placed in buffer at"}],
               0,false},
              {text,[3,42,112,42]},
              {sep,[{text,"\tof length"}],0,false},
              {text,[6,42,112,108,101,110,42]},
              {sep,[{text,[6,98,121,116,101,115,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,"*The wanted string encoding is specified by"}],
               0,false},
              {text,"-[erlang_char_encoding](#erlang_char_encoding)"},
              {sep,
               [{text,
                 "Y. The original encoding used in the binary format (Latin-1 or UTF-8) can be obtained from"}],
               0,false},
              {text,[6,42,42,119,97,115,42]},
              {sep,
               [{text,
                 "\\. The encoding of the resulting string (7-bit ASCII, Latin-1, or UTF-8) can be obtained from"}],
               0,false},
              {text,"\t**result*"},
              {sep,[{text,[6,46,32,66,111,116,104]}],0,false},
              {text,[5,42,119,97,115,42]},
              {sep,[{text,[3,97,110,100]}],0,false},
              {text,"\b*result*"},
              {sep,[{text,[6,99,97,110,32,98,101]}],0,false},
              {text,[6,42,78,85,76,76,42]},
              {sep,[{text,[1,46]}],0,false},
              {text,"\t**result*"},
              {sep,
               [{text,
                 [15,99,97,110,32,100,105,102,102,101,114,32,102,114,111,
                  109]}],
               0,false},
              {text,[6,42,119,97,110,116,42]},
              {sep,[{text,[2,105,102]}],0,false},
              {text,[6,42,119,97,110,116,42]},
              {sep,[{text,"\"is a bitwise OR'd combination like"}],0,false},
              {text,"\e*ERLANG_LATIN1|ERLANG_UTF8*"},
              {sep,[{text,[5,111,114,32,105,102]}],0,false},
              {text,"\t**result*"},
              {sep,
               [{text,
                 "Jturns out to be pure 7-bit ASCII (compatible with both Latin-1 and UTF-8)."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "gThis function fails if the atom is too long for the buffer or if it cannot be represented with encoding"}],
               0,false},
              {text,[6,42,119,97,110,116,42]},
              {sep,[{text,[1,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,
               "^This function was introduced in Erlang/OTP R16 as part of a first step to support UTF-8 atoms."}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "?## ei_decode_bignum(const char *buf, int *index, mpz_t obj):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,[{text,")Decode a GMP arbitrary precision integer."}],0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,"0Decodes an integer in the binary format to a GMP"}],
               0,false},
              {text,[7,42,109,112,122,95,116,42]},
              {sep,[{text,"\"integer. To use this function, the"}],0,false},
              {text,[4,42,101,105,42]},
              {sep,
               [{text,
                 "?library must be configured and compiled to use the GMP library."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "H## ei_decode_binary(const char *buf, int *index, void *p, long *len):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [16,68,101,99,111,100,101,32,97,32,98,105,110,97,114,121,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,"2Decodes a binary from the binary format. Parameter"}],
               0,false},
              {text,[5,42,108,101,110,42]},
              {sep,
               [{text,
                 "4is set to the actual size of the binary. Notice that"}],
               0,false},
              {text,
               [20,42,101,105,95,100,101,99,111,100,101,95,98,105,110,97,114,
                121,40,41,42]},
              {sep,
               [{text,
                 "Uassumes that there is enough room for the binary. The size required can be fetched by"}],
               0,false},
              {text,
               [15,42,101,105,95,103,101,116,95,116,121,112,101,40,41,42]},
              {sep,[{text,[1,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "p## ei_decode_bitstring(const char *buf, int *index, const char **pp, unsigned int *bitoffsp, size_t *nbitsp):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [19,68,101,99,111,100,101,32,97,32,98,105,116,115,116,114,105,
              110,103,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,",Decodes a bit string from the binary format."}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,
         {text,[4,60,100,108,62]},
         {nest,4,
          {above,
           {above,
            {above,
             {above,
              {above,
               {above,
                {above,{above,{text,[0]},null},null},
                {above,
                 {above,
                  {sep,
                   [{text,[4,60,100,116,62]},
                    {sep,[{text,[2,112,112]}],0,false},
                    {text,[5,60,47,100,116,62]}],
                   0,true},
                  null},
                 null}},
               {above,
                {above,{above,{text,[0]},null},null},
                {above,
                 {above,
                  {sep,
                   [{text,[4,60,100,100,62]},
                    {above,
                     {above,{above,{text,[0]},null},null},
                     {above,
                      {above,
                       {sep,
                        [{sep,
                          [{sep,[{text,[6,69,105,116,104,101,114]}],0,false},
                           {text,[4,78,85,76,76]},
                           {sep,[{text,[2,111,114]}],0,false},
                           {text,[3,42,112,112]},
                           {sep,
                            [{text,
                              "~returns a pointer to the first byte of the bit string. The returned bit string is readable as long as the buffer pointed to by"}],
                            0,false},
                           {text,[3,98,117,102]},
                           {sep,
                            [{text,
                              [31,105,115,32,114,101,97,100,97,98,108,101,32,
                               97,110,100,32,110,111,116,32,119,114,105,116,
                               116,101,110,32,116,111,46]}],
                            0,false}],
                          0,false}],
                        0,true},
                       null},
                      null}},
                    {text,[5,60,47,100,100,62]}],
                   0,true},
                  null},
                 null}}},
              {above,
               {above,{above,{text,[0]},null},null},
               {above,
                {above,
                 {sep,
                  [{text,[4,60,100,116,62]},
                   {sep,[{text,"\bbitoffsp"}],0,false},
                   {text,[5,60,47,100,116,62]}],
                  0,true},
                 null},
                null}}},
             {above,
              {above,{above,{text,[0]},null},null},
              {above,
               {above,
                {sep,
                 [{text,[4,60,100,100,62]},
                  {above,
                   {above,{above,{text,[0]},null},null},
                   {above,
                    {above,
                     {sep,
                      [{sep,
                        [{sep,[{text,[6,69,105,116,104,101,114]}],0,false},
                         {text,[4,78,85,76,76]},
                         {sep,[{text,[2,111,114]}],0,false},
                         {text,"\t*bitoffsp"},
                         {sep,
                          [{text,
                            "Areturns the number of unused bits in the first byte pointed to by"}],
                          0,false},
                         {text,[3,42,112,112]},
                         {sep,
                          [{text,
                            [14,46,32,84,104,101,32,118,97,108,117,101,32,111,
                             102]}],
                          0,false},
                         {text,"\t*bitoffsp"},
                         {sep,
                          [{text,
                            "Pis between 0 and 7. Unused bits in the first byte are the most significant bits."}],
                          0,false}],
                        0,false}],
                      0,true},
                     null},
                    null}},
                  {text,[5,60,47,100,100,62]}],
                 0,true},
                null},
               null}}},
            {above,
             {above,{above,{text,[0]},null},null},
             {above,
              {above,
               {sep,
                [{text,[4,60,100,116,62]},
                 {sep,[{text,[6,110,98,105,116,115,112]}],0,false},
                 {text,[5,60,47,100,116,62]}],
                0,true},
               null},
              null}}},
           {above,
            {above,{above,{text,[0]},null},null},
            {above,
             {above,
              {sep,
               [{text,[4,60,100,100,62]},
                {above,
                 {above,{above,{text,[0]},null},null},
                 {above,
                  {above,
                   {sep,
                    [{sep,
                      [{sep,[{text,[6,69,105,116,104,101,114]}],0,false},
                       {text,[4,78,85,76,76]},
                       {sep,[{text,[2,111,114]}],0,false},
                       {text,[7,42,110,98,105,116,115,112]},
                       {sep,
                        [{text,"'returns the length of the bit string in"}],
                        0,false},
                       {text,[4,98,105,116,115]},
                       {sep,[{text,[1,46]}],0,false}],
                      0,false}],
                    0,true},
                   null},
                  null}},
                {text,[5,60,47,100,100,62]}],
               0,true},
              null},
             null}}}}},
        {text,[5,60,47,100,108,62]}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,[7,82,101,116,117,114,110,115]}],0,false},
              {text,[3,42,48,42]},
              {sep,
               [{text,
                 [28,105,102,32,105,116,32,119,97,115,32,97,32,98,105,116,32,
                  115,116,114,105,110,103,32,116,101,114,109,46]}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,"\rThe number of"}],0,false},
              {text,"\t**bytes**"},
              {sep,[{text,"\rpointed to by"}],0,false},
              {text,[5,42,42,112,112,42]},
              {sep,[{text,"&, which are part of the bit string, is"}],0,false},
              {text,
               [29,42,40,42,98,105,116,111,102,102,115,112,32,43,32,42,110,98,
                105,116,115,112,32,43,32,55,41,47,56,42]},
              {sep,[{text,[4,46,32,73,102]}],0,false},
              {text,
               [28,42,40,42,98,105,116,111,102,102,115,112,32,43,32,42,98,105,
                116,115,112,41,37,56,32,62,32,48,42]},
              {sep,[{text,"\tthen only"}],0,false},
              {text,
               [24,42,40,42,98,105,116,111,102,102,115,112,32,43,32,42,98,105,
                116,115,112,41,37,56,42]},
              {sep,
               [{text,
                 "\\bits of the last byte are used. Unused bits in the last byte are the least significant bits."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,
               "[The values of unused bits in the first and last byte are undefined and cannot be relied on."}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "GNumber of bits may be divisible by 8, which means a binary decodable by"}],
               0,false},
              {text,
               [18,42,101,105,95,100,101,99,111,100,101,95,98,105,110,97,114,
                121,42]},
              {sep,
               [{text,
                 [20,105,115,32,97,108,115,111,32,100,101,99,111,100,97,98,
                  108,101,32,98,121]}],
               0,false},
              {text,
               [21,42,101,105,95,100,101,99,111,100,101,95,98,105,116,115,116,
                114,105,110,103,42]},
              {sep,[{text,[1,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "=## ei_decode_boolean(const char *buf, int *index, int *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [17,68,101,99,111,100,101,32,97,32,98,111,111,108,101,97,110,
              46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "NDecodes a boolean value from the binary format. A boolean is actually an atom,"}],
               0,false},
              {text,[6,42,116,114,117,101,42]},
              {sep,[{text,"\rdecodes 1 and"}],0,false},
              {text,[7,42,102,97,108,115,101,42]},
              {sep,[{text,"\ndecodes 0."}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,";## ei_decode_char(const char *buf, int *index, char *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,[{text,"&Decode an 8-bit integer between 0-255."}],0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "{Decodes a char (8-bit) integer between 0-255 from the binary format. For historical reasons the returned integer is of type"}],
               0,false},
              {text,[6,42,99,104,97,114,42]},
              {sep,
               [{text,
                 "=. Your C code is to consider the returned value to be of type"}],
               0,false},
              {text,
               [15,42,117,110,115,105,103,110,101,100,32,99,104,97,114,42]},
              {sep,
               [{text,"-even if the C compilers and system can define"}],
               0,false},
              {text,[6,42,99,104,97,114,42]},
              {sep,[{text,"\rto be signed."}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "?## ei_decode_double(const char *buf, int *index, double *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [16,68,101,99,111,100,101,32,97,32,100,111,117,98,108,101,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,
               "QDecodes a double-precision (64-bit) floating point number from the binary format."}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "D## ei_decode_ei_term(const char* buf, int* index, ei_term* term):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,"2Decode a term, without previous knowledge of type."}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "ADecodes any term, or at least tries to. If the term pointed at by"}],
               0,false},
              {text,"\b**index*"},
              {sep,[{text,[2,105,110]}],0,false},
              {text,[5,42,98,117,102,42]},
              {sep,[{text,"\vfits in the"}],0,false},
              {text,[6,42,116,101,114,109,42]},
              {sep,
               [{text,"2union, it is decoded, and the appropriate field in"}],
               0,false},
              {text,"\r*term->value*"},
              {sep,[{text,"\vis set, and"}],0,false},
              {text,"\b**index*"},
              {sep,[{text," is incremented by the term size."}],0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 [20,84,104,101,32,102,117,110,99,116,105,111,110,32,114,101,
                  116,117,114,110,115]}],
               0,false},
              {text,[3,42,49,42]},
              {sep,
               [{text,
                 [23,111,110,32,115,117,99,99,101,115,115,102,117,108,32,100,
                  101,99,111,100,105,110,103,44]}],
               0,false},
              {text,[4,42,45,49,42]},
              {sep,[{text,"\ron error, and"}],0,false},
              {text,[3,42,48,42]},
              {sep,
               [{text,"2if the term seems alright, but does not fit in the"}],
               0,false},
              {text,[6,42,116,101,114,109,42]},
              {sep,[{text,"\rstructure. If"}],0,false},
              {text,[3,42,49,42]},
              {sep,
               [{text,
                 [16,105,115,32,114,101,116,117,114,110,101,100,44,32,116,104,
                  101]}],
               0,false},
              {text,[7,42,105,110,100,101,120,42]},
              {sep,
               [{text,
                 [19,105,115,32,105,110,99,114,101,109,101,110,116,101,100,44,
                  32,97,110,100]}],
               0,false},
              {text,[6,42,116,101,114,109,42]},
              {sep,
               [{text,
                 [26,99,111,110,116,97,105,110,115,32,116,104,101,32,100,101,
                  99,111,100,101,100,32,116,101,114,109,46]}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,[3,84,104,101]}],0,false},
              {text,[6,42,116,101,114,109,42]},
              {sep,
               [{text,
                 "°structure contains the arity for a tuple or list, size for a binary, string, or atom. It contains a term if it is any of the following: integer, float, atom, pid, port, or ref."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "@## ei_decode_fun(const char *buf, int *index, erlang_fun *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         [31,35,35,32,102,114,101,101,95,102,117,110,40,101,114,108,97,110,
          103,95,102,117,110,42,32,102,41,58,118,111,105,100]},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,{sep,[{sep,[{text,"\rDecode a fun."}],0,false}],0,true},null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,"/Decodes a fun from the binary format. Parameter"}],
               0,false},
              {text,[3,42,112,42]},
              {sep,[{text,"\bis to be"}],0,false},
              {text,[6,42,78,85,76,76,42]},
              {sep,
               [{text,
                 [14,111,114,32,112,111,105,110,116,32,116,111,32,97,110]}],
               0,false},
              {text,"\f*erlang_fun*"},
              {sep,
               [{text,
                 "Kstructure. This is the only decode function that allocates memory. When the"}],
               0,false},
              {text,"\f*erlang_fun*"},
              {sep,
               [{text,"+is no longer needed, it is to be freed with"}],
               0,false},
              {text,"\n*free_fun*"},
              {sep,
               [{text,
                 "H. (This has to do with the arbitrary size of the environment for a fun.)"}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "E## ei_decode_list_header(const char *buf, int *index, int *arity):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,[14,68,101,99,111,100,101,32,97,32,108,105,115,116,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "SDecodes a list header from the binary format. The number of elements is returned in"}],
               0,false},
              {text,[7,42,97,114,105,116,121,42]},
              {sep,[{text,[5,46,32,84,104,101]}],0,false},
              {text,"\t*arity+1*"},
              {sep,
               [{text,
                 "Relements follow (the last one is the tail of the list, normally an empty list). If"}],
               0,false},
              {text,[7,42,97,114,105,116,121,42]},
              {sep,[{text,[2,105,115]}],0,false},
              {text,[3,42,48,42]},
              {sep,
               [{text,
                 [22,44,32,105,116,32,105,115,32,97,110,32,101,109,112,116,
                  121,32,108,105,115,116,46]}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 [144,78,111,116,105,99,101,32,116,104,97,116,32,108,105,115,
                  116,115,32,97,114,101,32,101,110,99,111,100,101,100,32,97,
                  115,32,115,116,114,105,110,103,115,32,105,102,32,116,104,
                  101,121,32,99,111,110,115,105,115,116,32,101,110,116,105,
                  114,101,108,121,32,111,102,32,105,110,116,101,103,101,114,
                  115,32,105,110,32,116,104,101,32,114,97,110,103,101,32,48,
                  46,46,50,53,53,46,32,84,104,105,115,32,102,117,110,99,116,
                  105,111,110,32,100,111,32,110,111,116,32,100,101,99,111,100,
                  101,32,115,117,99,104,32,115,116,114,105,110,103,115,44,32,
                  117,115,101]}],
               0,false},
              {text,
               [20,42,101,105,95,100,101,99,111,100,101,95,115,116,114,105,
                110,103,40,41,42]},
              {sep,[{text,"\binstead."}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,";## ei_decode_long(const char *buf, int *index, long *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [15,68,101,99,111,100,101,32,105,110,116,101,103,101,114,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "SDecodes a long integer from the binary format. If the code is 64 bits, the function"}],
               0,false},
              {text,
               [18,42,101,105,95,100,101,99,111,100,101,95,108,111,110,103,40,
                41,42]},
              {sep,
               [{text,
                 [14,105,115,32,116,104,101,32,115,97,109,101,32,97,115]}],
               0,false},
              {text,
               [22,42,101,105,95,100,101,99,111,100,101,95,108,111,110,103,
                108,111,110,103,40,41,42]},
              {sep,[{text,[1,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "D## ei_decode_longlong(const char *buf, int *index, long long *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [15,68,101,99,111,100,101,32,105,110,116,101,103,101,114,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,"\rDecodes a GCC"}],0,false},
              {text,"\v*long long*"},
              {sep,[{text,"\ror Visual C++"}],0,false},
              {text,"\t*__int64*"},
              {sep,
               [{text,
                 "V(64-bit) integer from the binary format. This function is missing in the VxWorks port."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "D## ei_decode_map_header(const char *buf, int *index, int *arity):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,{sep,[{sep,[{text,"\rDecode a map."}],0,false}],0,true},null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "YDecodes a map header from the binary format. The number of key-value pairs is returned in"}],
               0,false},
              {text,"\b**arity*"},
              {sep,
               [{text,"'. Keys and values follow in this order:"}],
               0,false},
              {text,
               [29,42,75,49,44,32,86,49,44,32,75,50,44,32,86,50,44,32,46,46,
                46,44,32,75,110,44,32,86,110,42]},
              {sep,
               [{text,
                 [23,46,32,84,104,105,115,32,109,97,107,101,115,32,97,32,116,
                  111,116,97,108,32,111,102]}],
               0,false},
              {text,"\t*arity*2*"},
              {sep,[{text,"\tterms. If"}],0,false},
              {text,[7,42,97,114,105,116,121,42]},
              {sep,
               [{text,
                 "Ris zero, it is an empty map. A correctly encoded map does not have duplicate keys."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "@## ei_decode_pid(const char *buf, int *index, erlang_pid *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{sep,[{text,"\bDecode a"}],0,false},
            {text,[5,42,112,105,100,42]},
            {sep,[{text,[1,46]}],0,false}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,
               ":Decodes a process identifier (pid) from the binary format."}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "B## ei_decode_port(const char *buf, int *index, erlang_port *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,[14,68,101,99,111,100,101,32,97,32,112,111,114,116,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,"1Decodes a port identifier from the binary format."}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "@## ei_decode_ref(const char *buf, int *index, erlang_ref *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [19,68,101,99,111,100,101,32,97,32,114,101,102,101,114,101,110,
              99,101,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,"+Decodes a reference from the binary format."}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "=## ei_decode_string(const char *buf, int *index, char *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [16,68,101,99,111,100,101,32,97,32,115,116,114,105,110,103,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "¸Decodes a string from the binary format. A string in Erlang is a list of integers between 0 and 255. Notice that as the string is just a list, sometimes lists are encoded as strings by"}],
               0,false},
              {text,
               [18,42,116,101,114,109,95,116,111,95,98,105,110,97,114,121,47,
                49,42]},
              {sep,
               [{text,
                 [30,44,32,101,118,101,110,32,105,102,32,105,116,32,119,97,
                  115,32,110,111,116,32,105,110,116,101,110,100,101,100,46]}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 [23,84,104,101,32,115,116,114,105,110,103,32,105,115,32,99,
                  111,112,105,101,100,32,116,111]}],
               0,false},
              {text,[3,42,112,42]},
              {sep,
               [{text,
                 "<, and enough space must be allocated. The returned string is"}],
               0,false},
              {text,[6,42,78,85,76,76,42]},
              {sep,
               [{text,
                 "E-terminated, so you must add an extra byte to the memory requirement."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,";## ei_decode_term(const char *buf, int *index, void *t):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{sep,[{text,"\bDecode a"}],0,false},
            {text,[7,42,69,84,69,82,77,42]},
            {sep,[{text,[1,46]}],0,false}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "<Decodes a term from the binary format. The term is return in"}],
               0,false},
              {text,[3,42,116,42]},
              {sep,[{text,[4,97,115,32,97]}],0,false},
              {text,"\b*ETERM**"},
              {sep,[{text,[4,44,32,115,111]}],0,false},
              {text,[3,42,116,42]},
              {sep,
               [{text,[14,105,115,32,97,99,116,117,97,108,108,121,32,97,110]}],
               0,false},
              {text,"\t*ETERM***"},
              {sep,[{text,[4,40,115,101,101]}],0,false},
              {text,
               [22,91,101,114,108,95,101,116,101,114,109,93,40,101,114,108,95,
                101,116,101,114,109,41]},
              {sep,
               [{text,"'). The term is later to be deallocated."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {above,
           {above,
            {text,[15,33,33,33,32,105,110,102,111,32,34,78,111,116,101,34]},
            {sep,
             [{text,[4,32,32,32,32]},
              {sep,
               [{sep,
                 [{above,
                   {above,{above,{text,[0]},null},null},
                   {above,
                    {above,
                     {sep,
                      [{sep,
                        [{sep,
                          [{text,
                            "cThis function is deprecated as of OTP 22 and will be removed in OTP 23 together with the old legacy"}],
                          0,false},
                         {text,
                          [15,42,101,114,108,95,105,110,116,101,114,102,97,99,
                           101,42]},
                         {sep,
                          [{text,
                            [30,108,105,98,114,97,114,121,32,40,102,117,110,
                             99,116,105,111,110,115,32,119,105,116,104,32,112,
                             114,101,102,105,120]}],
                          0,false},
                         {text,[6,42,101,114,108,95,42]},
                         {sep,[{text,[2,41,46]}],0,false}],
                        0,false}],
                      0,true},
                     null},
                    null}}],
                 0,false}],
               0,true}],
             0,false}},
           {text,[0]}},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "D## ei_decode_trace(const char *buf, int *index, erlang_trace *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [21,68,101,99,111,100,101,32,97,32,116,114,97,99,101,32,116,111,
              107,101,110,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,"5Decodes an Erlang trace token from the binary format."}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "F## ei_decode_tuple_header(const char *buf, int *index, int *arity):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,[15,68,101,99,111,100,101,32,97,32,116,117,112,108,101,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "=Decodes a tuple header, the number of elements is returned in"}],
               0,false},
              {text,[7,42,97,114,105,116,121,42]},
              {sep,
               [{text,"3. The tuple elements follow in order in the buffer."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "E## ei_decode_ulong(const char *buf, int *index, unsigned long *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [24,68,101,99,111,100,101,32,117,110,115,105,103,110,101,100,32,
              105,110,116,101,103,101,114,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "]Decodes an unsigned long integer from the binary format. If the code is 64 bits, the function"}],
               0,false},
              {text,
               [19,42,101,105,95,100,101,99,111,100,101,95,117,108,111,110,
                103,40,41,42]},
              {sep,
               [{text,
                 [14,105,115,32,116,104,101,32,115,97,109,101,32,97,115]}],
               0,false},
              {text,
               [23,42,101,105,95,100,101,99,111,100,101,95,117,108,111,110,
                103,108,111,110,103,40,41,42]},
              {sep,[{text,[1,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "N## ei_decode_ulonglong(const char *buf, int *index, unsigned long long *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [24,68,101,99,111,100,101,32,117,110,115,105,103,110,101,100,32,
              105,110,116,101,103,101,114,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,"\rDecodes a GCC"}],0,false},
              {text,
               [20,42,117,110,115,105,103,110,101,100,32,108,111,110,103,32,
                108,111,110,103,42]},
              {sep,[{text,"\ror Visual C++"}],0,false},
              {text,
               [18,42,117,110,115,105,103,110,101,100,32,95,95,105,110,116,54,
                52,42]},
              {sep,
               [{text,
                 "V(64-bit) integer from the binary format. This function is missing in the VxWorks port."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "C## ei_decode_version(const char *buf, int *index, int *version):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{sep,
             [{text,
               [22,68,101,99,111,100,101,32,97,110,32,101,109,112,116,121,32,
                108,105,115,116,32,40]}],
             0,false},
            {text,[5,42,110,105,108,42]},
            {sep,[{text,[2,41,46]}],0,false}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,
               "pDecodes the version magic number for the Erlang binary term format. It must be the first token in a binary term."}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,";## ei_encode_atom(char *buf, int *index, const char *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "H## ei_encode_atom_len(char *buf, int *index, const char *p, int len):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"4## ei_x_encode_atom(ei_x_buff* x, const char *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "A## ei_x_encode_atom_len(ei_x_buff* x, const char *p, int len):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,[15,69,110,99,111,100,101,32,97,110,32,97,116,111,109,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,"/Encodes an atom in the binary format. Parameter"}],
               0,false},
              {text,[3,42,112,42]},
              {sep,
               [{text,
                 "7is the name of the atom in Latin-1 encoding. Only up to"}],
               0,false},
              {text,[14,42,77,65,88,65,84,79,77,76,69,78,45,49,42]},
              {sep,[{text,"$bytes are encoded. The name is to be"}],0,false},
              {text,[6,42,78,85,76,76,42]},
              {sep,[{text,"\e-terminated, except for the"}],0,false},
              {text,
               [24,42,101,105,95,120,95,101,110,99,111,100,101,95,97,116,111,
                109,95,108,101,110,40,41,42]},
              {sep,[{text,"\tfunction."}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "z## ei_encode_atom_as(char *buf, int *index, const char *p, erlang_char_encoding from_enc, erlang_char_encoding to_enc):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         [135,35,35,32,101,105,95,101,110,99,111,100,101,95,97,116,111,109,95,
          108,101,110,95,97,115,40,99,104,97,114,32,42,98,117,102,44,32,105,
          110,116,32,42,105,110,100,101,120,44,32,99,111,110,115,116,32,99,
          104,97,114,32,42,112,44,32,105,110,116,32,108,101,110,44,32,101,114,
          108,97,110,103,95,99,104,97,114,95,101,110,99,111,100,105,110,103,
          32,102,114,111,109,95,101,110,99,44,32,101,114,108,97,110,103,95,99,
          104,97,114,95,101,110,99,111,100,105,110,103,32,116,111,95,101,110,
          99,41,58,105,110,116]},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "s## ei_x_encode_atom_as(ei_x_buff* x, const char *p, erlang_char_encoding from_enc, erlang_char_encoding to_enc):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         [128,35,35,32,101,105,95,120,95,101,110,99,111,100,101,95,97,116,111,
          109,95,108,101,110,95,97,115,40,101,105,95,120,95,98,117,102,102,42,
          32,120,44,32,99,111,110,115,116,32,99,104,97,114,32,42,112,44,32,
          105,110,116,32,108,101,110,44,32,101,114,108,97,110,103,95,99,104,
          97,114,95,101,110,99,111,100,105,110,103,32,102,114,111,109,95,101,
          110,99,44,32,101,114,108,97,110,103,95,99,104,97,114,95,101,110,99,
          111,100,105,110,103,32,116,111,95,101,110,99,41,58,105,110,116]},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,[15,69,110,99,111,100,101,32,97,110,32,97,116,111,109,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,"/Encodes an atom in the binary format. Parameter"}],
               0,false},
              {text,[3,42,112,42]},
              {sep,
               [{text,"/is the name of the atom with character encoding"}],
               0,false},
              {text,"-[erlang_char_encoding](#erlang_char_encoding)"},
              {sep,
               [{text,"3(ASCII, Latin-1, or UTF-8). The name must either be"}],
               0,false},
              {text,[6,42,78,85,76,76,42]},
              {sep,
               [{text,"(-terminated or a function variant with a"}],
               0,false},
              {text,[5,42,108,101,110,42]},
              {sep,
               [{text,
                 [23,112,97,114,97,109,101,116,101,114,32,109,117,115,116,32,
                  98,101,32,117,115,101,100,46]}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 [21,84,104,101,32,101,110,99,111,100,105,110,103,32,102,97,
                  105,108,115,32,105,102]}],
               0,false},
              {text,[3,42,112,42]},
              {sep,[{text,"!is not a valid string in encoding"}],0,false},
              {text,"\n*from_enc*"},
              {sep,[{text,[1,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,"\bArgument"}],0,false},
              {text,"\b*to_enc*"},
              {sep,
               [{text,
                 "{is ignored. As from Erlang/OTP 20 the encoding is always done in UTF-8 which is readable by nodes as old as Erlang/OTP R16."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"9## ei_encode_bignum(char *buf, int *index, mpz_t obj):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"2## ei_x_encode_bignum(ei_x_buff *x, mpz_t obj):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,[{text,"&Encode an arbitrary precision integer."}],0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,"\rEncodes a GMP"}],0,false},
              {text,[7,42,109,112,122,95,116,42]},
              {sep,
               [{text,"3integer to binary format. To use this function, the"}],
               0,false},
              {text,[4,42,101,105,42]},
              {sep,
               [{text,
                 "?library must be configured and compiled to use the GMP library."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "G## ei_encode_binary(char *buf, int *index, const void *p, long len):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "@## ei_x_encode_binary(ei_x_buff* x, const void *p, long len):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [16,69,110,99,111,100,101,32,97,32,98,105,110,97,114,121,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "5Encodes a binary in the binary format. The data is at"}],
               0,false},
              {text,[3,42,112,42]},
              {sep,[{text,[4,44,32,111,102]}],0,false},
              {text,[5,42,108,101,110,42]},
              {sep,[{text,"\rbytes length."}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "^## ei_encode_bitstring(char *buf, int *index, const char *p, size_t bitoffs, size_t nbits):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "W## ei_x_encode_bitstring(ei_x_buff* x, const char *p, size_t bitoffs, size_t nbits):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [19,69,110,99,111,100,101,32,97,32,98,105,116,115,116,114,105,
              110,103,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,"*Encodes a bit string in the binary format."}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,[14,84,104,101,32,100,97,116,97,32,105,115,32,97,116]}],
               0,false},
              {text,[3,42,112,42]},
              {sep,[{text,"!. The length of the bit string is"}],0,false},
              {text,[7,42,110,98,105,116,115,42]},
              {sep,
               [{text,
                 [15,98,105,116,115,46,32,84,104,101,32,102,105,114,115,116]}],
               0,false},
              {text,"\t*bitoffs*"},
              {sep,
               [{text,
                 [19,98,105,116,115,32,111,102,32,116,104,101,32,100,97,116,
                  97,32,97,116]}],
               0,false},
              {text,[3,42,112,42]},
              {sep,
               [{text,
                 "=are unused. The first byte which is part of the bit string is"}],
               0,false},
              {text,[14,42,112,91,98,105,116,111,102,102,115,47,56,93,42]},
              {sep,[{text,[5,46,32,84,104,101]}],0,false},
              {text,"\v*bitoffs%8*"},
              {sep,
               [{text,"'most significant bits of the first byte"}],
               0,false},
              {text,[14,42,112,91,98,105,116,111,102,102,115,47,56,93,42]},
              {sep,[{text,"\vare unused."}],0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "6The number of bytes which is part of the bit string is"}],
               0,false},
              {text,
               [25,42,40,98,105,116,111,102,102,115,32,43,32,110,98,105,116,
                115,32,43,32,55,41,47,56,42]},
              {sep,[{text,[4,46,32,73,102]}],0,false},
              {text,
               [25,42,40,98,105,116,111,102,102,115,32,43,32,110,98,105,116,
                115,41,37,56,32,62,32,48,42]},
              {sep,[{text,"\tthen only"}],0,false},
              {text,
               [21,42,40,98,105,116,111,102,102,115,32,43,32,110,98,105,116,
                115,41,37,56,42]},
              {sep,
               [{text,
                 "\\bits of the last byte are used. Unused bits in the last byte are the least significant bits."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,
               "JThe values of unused bits are disregarded and does not need to be cleared."}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"6## ei_encode_boolean(char *buf, int *index, int p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,{text,"/## ei_x_encode_boolean(ei_x_buff* x, int p):int"},null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [17,69,110,99,111,100,101,32,97,32,98,111,111,108,101,97,110,
              46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,"#Encodes a boolean value as the atom"}],0,false},
              {text,[6,42,116,114,117,101,42]},
              {sep,[{text,[2,105,102]}],0,false},
              {text,[3,42,112,42]},
              {sep,
               [{text,
                 [15,105,115,32,110,111,116,32,122,101,114,111,44,32,111,
                  114]}],
               0,false},
              {text,[7,42,102,97,108,115,101,42]},
              {sep,[{text,[2,105,102]}],0,false},
              {text,[3,42,112,42]},
              {sep,[{text,"\bis zero."}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"4## ei_encode_char(char *buf, int *index, char p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,{text,"-## ei_x_encode_char(ei_x_buff* x, char p):int"},null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,[{text,"&Encode an 8-bit integer between 0-255."}],0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 [127,69,110,99,111,100,101,115,32,97,32,99,104,97,114,32,40,
                  56,45,98,105,116,41,32,97,115,32,97,110,32,105,110,116,101,
                  103,101,114,32,98,101,116,119,101,101,110,32,48,45,50,53,53,
                  32,105,110,32,116,104,101,32,98,105,110,97,114,121,32,102,
                  111,114,109,97,116,46,32,70,111,114,32,104,105,115,116,111,
                  114,105,99,97,108,32,114,101,97,115,111,110,115,32,116,104,
                  101,32,105,110,116,101,103,101,114,32,97,114,103,117,109,
                  101,110,116,32,105,115,32,111,102,32,116,121,112,101]}],
               0,false},
              {text,[6,42,99,104,97,114,42]},
              {sep,
               [{text,
                 "A. Your C code is to consider the specified argument to be of type"}],
               0,false},
              {text,
               [15,42,117,110,115,105,103,110,101,100,32,99,104,97,114,42]},
              {sep,
               [{text,"-even if the C compilers and system may define"}],
               0,false},
              {text,[6,42,99,104,97,114,42]},
              {sep,[{text,"\rto be signed."}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"8## ei_encode_double(char *buf, int *index, double p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"1## ei_x_encode_double(ei_x_buff* x, double p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [22,69,110,99,111,100,101,32,97,32,100,111,117,98,108,101,32,102,
              108,111,97,116,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,
               "OEncodes a double-precision (64-bit) floating point number in the binary format."}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,[7,82,101,116,117,114,110,115]}],0,false},
              {text,[4,42,45,49,42]},
              {sep,
               [{text,"+if the floating point number is not finite."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"2## ei_encode_empty_list(char* buf, int* index):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,{text,"+## ei_x_encode_empty_list(ei_x_buff* x):int"},null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{sep,
             [{text,
               [22,69,110,99,111,100,101,32,97,110,32,101,109,112,116,121,32,
                108,105,115,116,32,40]}],
             0,false},
            {text,[5,42,110,105,108,42]},
            {sep,[{text,[2,41,46]}],0,false}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,
               ">Encodes an empty list. It is often used at the tail of a list."}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "@## ei_encode_fun(char *buf, int *index, const erlang_fun *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,";## ei_x_encode_fun(ei_x_buff* x, const erlang_fun* fun):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,{sep,[{sep,[{text,"\rEncode a fun."}],0,false}],0,true},null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,"-Encodes a fun in the binary format. Parameter"}],
               0,false},
              {text,[3,42,112,42]},
              {sep,[{text,"\fpoints to an"}],0,false},
              {text,"\f*erlang_fun*"},
              {sep,
               [{text,
                 [14,115,116,114,117,99,116,117,114,101,46,32,84,104,101]}],
               0,false},
              {text,"\f*erlang_fun*"},
              {sep,
               [{text,
                 [31,105,115,32,110,111,116,32,102,114,101,101,100,32,97,117,
                  116,111,109,97,116,105,99,97,108,108,121,44,32,116,104,
                  101]}],
               0,false},
              {text,"\n*free_fun*"},
              {sep,
               [{text,
                 "8is to be called if the fun is not needed after encoding."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         ">## ei_encode_list_header(char *buf, int *index, int arity):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"7## ei_x_encode_list_header(ei_x_buff* x, int arity):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,[14,69,110,99,111,100,101,32,97,32,108,105,115,116,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "7Encodes a list header, with a specified arity. The next"}],
               0,false},
              {text,"\t*arity+1*"},
              {sep,[{text,"$terms are the elements (actually its"}],0,false},
              {text,[7,42,97,114,105,116,121,42]},
              {sep,
               [{text,
                 [129,99,111,110,115,32,99,101,108,108,115,41,32,97,110,100,
                  32,116,104,101,32,116,97,105,108,32,111,102,32,116,104,101,
                  32,108,105,115,116,46,32,76,105,115,116,115,32,97,110,100,
                  32,116,117,112,108,101,115,32,97,114,101,32,101,110,99,111,
                  100,101,100,32,114,101,99,117,114,115,105,118,101,108,121,
                  44,32,115,111,32,116,104,97,116,32,97,32,108,105,115,116,32,
                  99,97,110,32,99,111,110,116,97,105,110,32,97,110,111,116,
                  104,101,114,32,108,105,115,116,32,111,114,32,116,117,112,
                  108,101,46]}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 [31,70,111,114,32,101,120,97,109,112,108,101,44,32,116,111,
                  32,101,110,99,111,100,101,32,116,104,101,32,108,105,115,
                  116]}],
               0,false},
              {text,
               [17,42,91,99,44,32,100,44,32,91,101,32,124,32,102,93,93,42]},
              {sep,[{text,[1,58]}],0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {above,
           {above,
            {text,[3,96,96,96]},
            {sep,
             [{text,
               "Ý\nei_encode_list_header(buf, &i, 3);\nei_encode_atom(buf, &i, \"c\");\nei_encode_atom(buf, &i, \"d\");\nei_encode_list_header(buf, &i, 1);\nei_encode_atom(buf, &i, \"e\");\nei_encode_atom(buf, &i, \"f\");\nei_encode_empty_list(buf, &i);"}],
             0,true}},
           {text,[3,96,96,96]}},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {above,
           {above,
            {text,[15,33,33,33,32,105,110,102,111,32,34,78,111,116,101,34]},
            {sep,
             [{text,[4,32,32,32,32]},
              {sep,
               [{sep,
                 [{above,
                   {above,{above,{text,[0]},null},null},
                   {above,
                    {above,
                     {sep,
                      [{sep,
                        [{sep,
                          [{text,
                            [148,73,116,32,109,97,121,32,115,101,101,109,32,
                             116,104,97,116,32,116,104,101,114,101,32,105,115,
                             32,110,111,32,119,97,121,32,116,111,32,99,114,
                             101,97,116,101,32,97,32,108,105,115,116,32,119,
                             105,116,104,111,117,116,32,107,110,111,119,105,
                             110,103,32,116,104,101,32,110,117,109,98,101,114,
                             32,111,102,32,101,108,101,109,101,110,116,115,32,
                             105,110,32,97,100,118,97,110,99,101,46,32,66,117,
                             116,32,105,110,100,101,101,100,32,116,104,101,
                             114,101,32,105,115,32,97,32,119,97,121,46,32,78,
                             111,116,105,99,101,32,116,104,97,116,32,116,104,
                             101,32,108,105,115,116]}],
                          0,false},
                         {text,"\v*[a, b, c]*"},
                         {sep,
                          [{text,
                            [17,99,97,110,32,98,101,32,119,114,105,116,116,
                             101,110,32,97,115]}],
                          0,false},
                         {text,
                          [17,42,91,97,32,124,32,91,98,32,124,32,91,99,93,93,
                           93,42]},
                         {sep,
                          [{text,
                            ".. Using this, a list can be written as conses."}],
                          0,false}],
                        0,false}],
                      0,true},
                     null},
                    null}}],
                 0,false}],
               0,true}],
             0,false}},
           {text,[0]}},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,
               "7To encode a list, without knowing the arity in advance:"}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {above,
           {above,
            {text,[3,96,96,96]},
            {sep,
             [{text,
               [140,10,119,104,105,108,101,32,40,115,111,109,101,116,104,105,
                110,103,40,41,41,32,123,10,32,32,32,32,101,105,95,120,95,101,
                110,99,111,100,101,95,108,105,115,116,95,104,101,97,100,101,
                114,40,38,120,44,32,49,41,59,10,32,32,32,32,101,105,95,120,95,
                101,110,99,111,100,101,95,117,108,111,110,103,40,38,120,44,32,
                105,41,59,32,47,42,32,106,117,115,116,32,97,110,32,101,120,97,
                109,112,108,101,32,42,47,10,125,10,101,105,95,120,95,101,110,
                99,111,100,101,95,101,109,112,116,121,95,108,105,115,116,40,
                38,120,41,59]}],
             0,true}},
           {text,[3,96,96,96]}},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"4## ei_encode_long(char *buf, int *index, long p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,{text,"-## ei_x_encode_long(ei_x_buff* x, long p):int"},null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [15,69,110,99,111,100,101,32,105,110,116,101,103,101,114,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "QEncodes a long integer in the binary format. If the code is 64 bits, the function"}],
               0,false},
              {text,
               [18,42,101,105,95,101,110,99,111,100,101,95,108,111,110,103,40,
                41,42]},
              {sep,
               [{text,
                 [14,105,115,32,116,104,101,32,115,97,109,101,32,97,115]}],
               0,false},
              {text,
               [22,42,101,105,95,101,110,99,111,100,101,95,108,111,110,103,
                108,111,110,103,40,41,42]},
              {sep,[{text,[1,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "=## ei_encode_longlong(char *buf, int *index, long long p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"6## ei_x_encode_longlong(ei_x_buff* x, long long p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [15,69,110,99,111,100,101,32,105,110,116,101,103,101,114,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,"\rEncodes a GCC"}],0,false},
              {text,"\v*long long*"},
              {sep,[{text,"\ror Visual C++"}],0,false},
              {text,"\t*__int64*"},
              {sep,
               [{text,
                 "T(64-bit) integer in the binary format. This function is missing in the VxWorks port."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "=## ei_encode_map_header(char *buf, int *index, int arity):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"6## ei_x_encode_map_header(ei_x_buff* x, int arity):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,{sep,[{sep,[{text,"\rEncode a map."}],0,false}],0,true},null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "6Encodes a map header, with a specified arity. The next"}],
               0,false},
              {text,"\t*arity*2*"},
              {sep,
               [{text,
                 "Tterms encoded will be the keys and values of the map encoded in the following order:"}],
               0,false},
              {text,
               [29,42,75,49,44,32,86,49,44,32,75,50,44,32,86,50,44,32,46,46,
                46,44,32,75,110,44,32,86,110,42]},
              {sep,[{text,[1,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 [30,70,111,114,32,101,120,97,109,112,108,101,44,32,116,111,
                  32,101,110,99,111,100,101,32,116,104,101,32,109,97,112]}],
               0,false},
              {text," *#{a => \"Apple\", b => \"Banana\"}*"},
              {sep,[{text,[1,58]}],0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {above,
           {above,
            {text,[3,96,96,96]},
            {sep,
             [{text,
               [152,10,101,105,95,120,95,101,110,99,111,100,101,95,109,97,112,
                95,104,101,97,100,101,114,40,38,120,44,32,50,41,59,10,101,105,
                95,120,95,101,110,99,111,100,101,95,97,116,111,109,40,38,120,
                44,32,34,97,34,41,59,10,101,105,95,120,95,101,110,99,111,100,
                101,95,115,116,114,105,110,103,40,38,120,44,32,34,65,112,112,
                108,101,34,41,59,10,101,105,95,120,95,101,110,99,111,100,101,
                95,97,116,111,109,40,38,120,44,32,34,98,34,41,59,10,101,105,
                95,120,95,101,110,99,111,100,101,95,115,116,114,105,110,103,
                40,38,120,44,32,34,66,97,110,97,110,97,34,41,59]}],
             0,true}},
           {text,[3,96,96,96]}},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,"3A correctly encoded map cannot have duplicate keys."}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "@## ei_encode_pid(char *buf, int *index, const erlang_pid *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"9## ei_x_encode_pid(ei_x_buff* x, const erlang_pid *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,{sep,[{sep,[{text,"\rEncode a pid."}],0,false}],0,true},null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "JEncodes an Erlang process identifier (pid) in the binary format. Parameter"}],
               0,false},
              {text,[3,42,112,42]},
              {sep,[{text,"\fpoints to an"}],0,false},
              {text,"\f*erlang_pid*"},
              {sep,
               [{text,
                 "7structure (which should have been obtained earlier with"}],
               0,false},
              {text,
               [17,42,101,105,95,100,101,99,111,100,101,95,112,105,100,40,41,
                42]},
              {sep,[{text,[2,41,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "B## ei_encode_port(char *buf, int *index, const erlang_port *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,";## ei_x_encode_port(ei_x_buff* x, const erlang_port *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,[14,69,110,99,111,100,101,32,97,32,112,111,114,116,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "6Encodes an Erlang port in the binary format. Parameter"}],
               0,false},
              {text,[3,42,112,42]},
              {sep,[{text,"\vpoints to a"}],0,false},
              {text,"\r*erlang_port*"},
              {sep,
               [{text,
                 "7structure (which should have been obtained earlier with"}],
               0,false},
              {text,
               [18,42,101,105,95,100,101,99,111,100,101,95,112,111,114,116,40,
                41,42]},
              {sep,[{text,[2,41,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "@## ei_encode_ref(char *buf, int *index, const erlang_ref *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"9## ei_x_encode_ref(ei_x_buff* x, const erlang_ref *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,{sep,[{sep,[{text,"\rEncode a ref."}],0,false}],0,true},null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 ";Encodes an Erlang reference in the binary format. Parameter"}],
               0,false},
              {text,[3,42,112,42]},
              {sep,[{text,"\vpoints to a"}],0,false},
              {text,"\f*erlang_ref*"},
              {sep,
               [{text,
                 "7structure (which should have been obtained earlier with"}],
               0,false},
              {text,
               [17,42,101,105,95,100,101,99,111,100,101,95,114,101,102,40,41,
                42]},
              {sep,[{text,[2,41,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "=## ei_encode_string(char *buf, int *index, const char *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "J## ei_encode_string_len(char *buf, int *index, const char *p, int len):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"6## ei_x_encode_string(ei_x_buff* x, const char *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "C## ei_x_encode_string_len(ei_x_buff* x, const char* s, int len):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [16,69,110,99,111,100,101,32,97,32,115,116,114,105,110,103,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 [148,69,110,99,111,100,101,115,32,97,32,115,116,114,105,110,
                  103,32,105,110,32,116,104,101,32,98,105,110,97,114,121,32,
                  102,111,114,109,97,116,46,32,40,65,32,115,116,114,105,110,
                  103,32,105,110,32,69,114,108,97,110,103,32,105,115,32,97,32,
                  108,105,115,116,44,32,98,117,116,32,105,115,32,101,110,99,
                  111,100,101,100,32,97,115,32,97,32,99,104,97,114,97,99,116,
                  101,114,32,97,114,114,97,121,32,105,110,32,116,104,101,32,
                  98,105,110,97,114,121,32,102,111,114,109,97,116,46,41,32,84,
                  104,101,32,115,116,114,105,110,103,32,105,115,32,116,111,32,
                  98,101]}],
               0,false},
              {text,[6,42,78,85,76,76,42]},
              {sep,[{text,"\e-terminated, except for the"}],0,false},
              {text,
               [26,42,101,105,95,120,95,101,110,99,111,100,101,95,115,116,114,
                105,110,103,95,108,101,110,40,41,42]},
              {sep,[{text,"\tfunction."}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"5## ei_encode_term(char *buf, int *index, void *t):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,{text,".## ei_x_encode_term(ei_x_buff* x, void *t):int"},null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{sep,[{text,"\tEncode an"}],0,false},
            {text,[15,42,101,114,108,95,105,110,116,101,114,102,97,99,101,42]},
            {sep,[{text,[5,116,101,114,109,46]}],0,false}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,"\nEncodes an"}],0,false},
              {text,[7,42,69,84,69,82,77,42]},
              {sep,
               [{text,
                 [18,44,32,97,115,32,111,98,116,97,105,110,101,100,32,102,114,
                  111,109]}],
               0,false},
              {text,
               [15,42,101,114,108,95,105,110,116,101,114,102,97,99,101,42]},
              {sep,[{text,"\v. Parameter"}],0,false},
              {text,[3,42,116,42]},
              {sep,
               [{text,[14,105,115,32,97,99,116,117,97,108,108,121,32,97,110]}],
               0,false},
              {text,[7,42,69,84,69,82,77,42]},
              {sep,
               [{text,"(pointer. This function does not free the"}],
               0,false},
              {text,[7,42,69,84,69,82,77,42]},
              {sep,[{text,[1,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {above,
           {above,
            {text,[15,33,33,33,32,105,110,102,111,32,34,78,111,116,101,34]},
            {sep,
             [{text,[4,32,32,32,32]},
              {sep,
               [{sep,
                 [{above,
                   {above,{above,{text,[0]},null},null},
                   {above,
                    {above,
                     {sep,
                      [{sep,
                        [{sep,
                          [{text,
                            "fThese functions are deprecated as of OTP 22 and will be removed in OTP 23 together with the old legacy"}],
                          0,false},
                         {text,
                          [15,42,101,114,108,95,105,110,116,101,114,102,97,99,
                           101,42]},
                         {sep,
                          [{text,
                            [30,108,105,98,114,97,114,121,32,40,102,117,110,
                             99,116,105,111,110,115,32,119,105,116,104,32,112,
                             114,101,102,105,120]}],
                          0,false},
                         {text,[6,42,101,114,108,95,42]},
                         {sep,[{text,[2,41,46]}],0,false}],
                        0,false}],
                      0,true},
                     null},
                    null}}],
                 0,false}],
               0,true}],
             0,false}},
           {text,[0]}},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "D## ei_encode_trace(char *buf, int *index, const erlang_trace *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "=## ei_x_encode_trace(ei_x_buff* x, const erlang_trace *p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [21,69,110,99,111,100,101,32,97,32,116,114,97,99,101,32,116,111,
              107,101,110,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "=Encodes an Erlang trace token in the binary format. Parameter"}],
               0,false},
              {text,[3,42,112,42]},
              {sep,[{text,"\vpoints to a"}],0,false},
              {text,[14,42,101,114,108,97,110,103,95,116,114,97,99,101,42]},
              {sep,
               [{text,
                 "7structure (which should have been obtained earlier with"}],
               0,false},
              {text,
               [19,42,101,105,95,100,101,99,111,100,101,95,116,114,97,99,101,
                40,41,42]},
              {sep,[{text,[2,41,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "?## ei_encode_tuple_header(char *buf, int *index, int arity):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"8## ei_x_encode_tuple_header(ei_x_buff* x, int arity):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,[15,69,110,99,111,100,101,32,97,32,116,117,112,108,101,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "8Encodes a tuple header, with a specified arity. The next"}],
               0,false},
              {text,[7,42,97,114,105,116,121,42]},
              {sep,
               [{text,
                 [141,116,101,114,109,115,32,101,110,99,111,100,101,100,32,
                  119,105,108,108,32,98,101,32,116,104,101,32,101,108,101,109,
                  101,110,116,115,32,111,102,32,116,104,101,32,116,117,112,
                  108,101,46,32,84,117,112,108,101,115,32,97,110,100,32,108,
                  105,115,116,115,32,97,114,101,32,101,110,99,111,100,101,100,
                  32,114,101,99,117,114,115,105,118,101,108,121,44,32,115,111,
                  32,116,104,97,116,32,97,32,116,117,112,108,101,32,99,97,110,
                  32,99,111,110,116,97,105,110,32,97,110,111,116,104,101,114,
                  32,116,117,112,108,101,32,111,114,32,108,105,115,116,46]}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text," For example, to encode the tuple"}],0,false},
              {text,[14,42,123,97,44,32,123,98,44,32,123,125,125,125,42]},
              {sep,[{text,[1,58]}],0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {above,
           {above,
            {text,[3,96,96,96]},
            {sep,
             [{text,
               "¨\nei_encode_tuple_header(buf, &i, 2);\nei_encode_atom(buf, &i, \"a\");\nei_encode_tuple_header(buf, &i, 2);\nei_encode_atom(buf, &i, \"b\");\nei_encode_tuple_header(buf, &i, 0);"}],
             0,true}},
           {text,[3,96,96,96]}},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         ">## ei_encode_ulong(char *buf, int *index, unsigned long p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"7## ei_x_encode_ulong(ei_x_buff* x, unsigned long p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [24,69,110,99,111,100,101,32,117,110,115,105,103,110,101,100,32,
              105,110,116,101,103,101,114,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "[Encodes an unsigned long integer in the binary format. If the code is 64 bits, the function"}],
               0,false},
              {text,
               [19,42,101,105,95,101,110,99,111,100,101,95,117,108,111,110,
                103,40,41,42]},
              {sep,
               [{text,
                 [14,105,115,32,116,104,101,32,115,97,109,101,32,97,115]}],
               0,false},
              {text,
               [23,42,101,105,95,101,110,99,111,100,101,95,117,108,111,110,
                103,108,111,110,103,40,41,42]},
              {sep,[{text,[1,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "G## ei_encode_ulonglong(char *buf, int *index, unsigned long long p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "@## ei_x_encode_ulonglong(ei_x_buff* x, unsigned long long p):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [24,69,110,99,111,100,101,32,117,110,115,105,103,110,101,100,32,
              105,110,116,101,103,101,114,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,"\rEncodes a GCC"}],0,false},
              {text,
               [20,42,117,110,115,105,103,110,101,100,32,108,111,110,103,32,
                108,111,110,103,42]},
              {sep,[{text,"\ror Visual C++"}],0,false},
              {text,
               [18,42,117,110,115,105,103,110,101,100,32,95,95,105,110,116,54,
                52,42]},
              {sep,
               [{text,
                 "T(64-bit) integer in the binary format. This function is missing in the VxWorks port."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,{text,"/## ei_encode_version(char *buf, int *index):int"},null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,{text,"(## ei_x_encode_version(ei_x_buff* x):int"},null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [15,69,110,99,111,100,101,32,118,101,114,115,105,111,110,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,
               "_Encodes a version magic number for the binary format. Must be the first token in a binary term."}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "K## ei_get_type(const char *buf, const int *index, int *type, int *size):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,"+Fetch the type and size of an encoded term."}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 [19,82,101,116,117,114,110,115,32,116,104,101,32,116,121,112,
                  101,32,105,110]}],
               0,false},
              {text,[7,42,42,116,121,112,101,42]},
              {sep,[{text,"\vand size in"}],0,false},
              {text,[7,42,42,115,105,122,101,42]},
              {sep,
               [{text,
                 "Lof the encoded term. For strings and atoms, size is the number of characters"}],
               0,false},
              {text,[7,42,42,110,111,116,42,42]},
              {sep,
               [{text,
                 [25,105,110,99,108,117,100,105,110,103,32,116,104,101,32,116,
                  101,114,109,105,110,97,116,105,110,103]}],
               0,false},
              {text,[6,42,78,85,76,76,42]},
              {sep,
               [{text,
                 [30,46,32,70,111,114,32,98,105,110,97,114,105,101,115,32,97,
                  110,100,32,98,105,116,115,116,114,105,110,103,115,44]}],
               0,false},
              {text,[7,42,42,115,105,122,101,42]},
              {sep,
               [{text,"3is the number of bytes. For lists, tuples and maps,"}],
               0,false},
              {text,[7,42,42,115,105,122,101,42]},
              {sep,
               [{text,",is the arity of the object. For other types,"}],
               0,false},
              {text,[7,42,42,115,105,122,101,42]},
              {sep,
               [{text,
                 [19,105,115,32,48,46,32,73,110,32,97,108,108,32,99,97,115,
                  101,115,44]}],
               0,false},
              {text,[7,42,105,110,100,101,120,42]},
              {sep,
               [{text,
                 [18,105,115,32,108,101,102,116,32,117,110,99,104,97,110,103,
                  101,100,46]}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         [20,35,35,32,101,105,95,105,110,105,116,40,118,111,105,100,41,58,105,
          110,116]},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [26,73,110,105,116,105,97,108,105,122,101,32,116,104,101,32,101,
              105,32,108,105,98,114,97,114,121,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 [14,73,110,105,116,105,97,108,105,122,101,32,116,104,101]}],
               0,false},
              {text,[4,42,101,105,42]},
              {sep,
               [{text,
                 "jlibrary. This function should be called once (and only once) before calling any other functionality in the"}],
               0,false},
              {text,[4,42,101,105,42]},
              {sep,
               [{text,"+library. However, note the exception below."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,[6,73,102,32,116,104,101]}],0,false},
              {text,[4,42,101,105,42]},
              {sep,[{text,"!library is used together with the"}],0,false},
              {text,
               [15,42,101,114,108,95,105,110,116,101,114,102,97,99,101,42]},
              {sep,
               [{text,
                 [29,108,105,98,114,97,114,121,44,32,116,104,105,115,32,102,
                  117,110,99,116,105,111,110,32,115,104,111,117,108,100]}],
               0,false},
              {text,[7,42,42,110,111,116,42,42]},
              {sep,
               [{text,",be called directly. It will be called by the"}],
               0,false},
              {text,"\f*erl_init()*"},
              {sep,
               [{text,
                 "Yfunction which should be used to initialize the combination of the two libraries instead."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,
               "GOn success zero is returned. On failure a posix error code is returned."}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,";## ei_print_term(FILE* fp, const char* buf, int* index):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         "=## ei_s_print_term(char** s, const char* buf, int* index):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,[{sep,[{text,"\ePrint a term in clear text."}],0,false}],0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "6Prints a term, in clear text, to the file specified by"}],
               0,false},
              {text,[4,42,102,112,42]},
              {sep,
               [{text,
                 [29,44,32,111,114,32,116,104,101,32,98,117,102,102,101,114,
                  32,112,111,105,110,116,101,100,32,116,111,32,98,121]}],
               0,false},
              {text,[3,42,115,42]},
              {sep,
               [{text,
                 "=. It tries to resemble the term printing in the Erlang shell."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,[2,73,110]}],0,false},
              {text,
               [19,42,101,105,95,115,95,112,114,105,110,116,95,116,101,114,
                109,40,41,42]},
              {sep,[{text,"\v, parameter"}],0,false},
              {text,[3,42,115,42]},
              {sep,
               [{text,
                 "9is to point to a dynamically (malloc) allocated string of"}],
               0,false},
              {text,"\b*BUFSIZ*"},
              {sep,[{text,"\nbytes or a"}],0,false},
              {text,[6,42,78,85,76,76,42]},
              {sep,
               [{text,"+pointer. The string can be reallocated (and"}],
               0,false},
              {text,[4,42,42,115,42]},
              {sep,
               [{text,
                 ";can be updated) by this function if the result is more than"}],
               0,false},
              {text,"\b*BUFSIZ*"},
              {sep,[{text,"\"characters. The string returned is"}],0,false},
              {text,[6,42,78,85,76,76,42]},
              {sep,[{text,"\f-terminated."}],0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "NThe return value is the number of characters written to the file or string, or"}],
               0,false},
              {text,[4,42,45,49,42]},
              {sep,[{text,[2,105,102]}],0,false},
              {text,"\f*buf[index]*"},
              {sep,
               [{text,
                 ";does not contain a valid term. Unfortunately, I/O errors on"}],
               0,false},
              {text,[4,42,102,112,42]},
              {sep,
               [{text,
                 [15,105,115,32,110,111,116,32,99,104,101,99,107,101,100,46]}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,"\bArgument"}],0,false},
              {text,[7,42,105,110,100,101,120,42]},
              {sep,
               [{text,
                 "wis updated, that is, this function can be viewed as a decode function that decodes a term into a human-readable format."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,{text,")## ei_set_compat_rel(release_number):void"},null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,[{text,")Set the ei library in compatibility mode."}],0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{text,[1,42]},
       {sep,
        [{text,
          [24,117,110,115,105,103,110,101,100,32,114,101,108,101,97,115,101,
           95,110,117,109,98,101,114,59]}],
        0,false}],
      0,false},
     {sep,
      [{text,"1<a name=\"ei_set_compat_rel\">ei_set_compat_rel</a>"},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 [15,73,110,32,103,101,110,101,114,97,108,44,32,116,104,101]}],
               0,false},
              {text,[4,42,101,105,42]},
              {sep,
               [{text,
                 "ylibrary is guaranteed to be compatible with other Erlang/OTP components that are 2 major releases older or newer than the"}],
               0,false},
              {text,[4,42,101,105,42]},
              {sep,
               [{text,
                 [15,108,105,98,114,97,114,121,32,105,116,115,101,108,102,
                  46]}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "tSometimes an exception to the above rule has to be made to make new features (or even bug fixes) possible. A call to"}],
               0,false},
              {text,"#*ei_set_compat_rel(release_number)*"},
              {sep,[{text,"\bsets the"}],0,false},
              {text,[4,42,101,105,42]},
              {sep,
               [{text,",library in compatibility mode of OTP release"}],
               0,false},
              {text,
               [16,42,114,101,108,101,97,115,101,95,110,117,109,98,101,114,
                42]},
              {sep,[{text,[1,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 [25,84,104,101,32,111,110,108,121,32,117,115,101,102,117,108,
                  32,118,97,108,117,101,32,102,111,114]}],
               0,false},
              {text,
               [16,42,114,101,108,101,97,115,101,95,110,117,109,98,101,114,
                42]},
              {sep,[{text,"\fis currently"}],0,false},
              {text,[4,42,50,49,42]},
              {sep,
               [{text,"0. This will only be useful and have an effect if"}],
               0,false},
              {text,
               [15,42,42,98,105,116,32,115,116,114,105,110,103,115,42,42]},
              {sep,[{text,[2,111,114]}],0,false},
              {text,
               [15,42,42,101,120,112,111,114,116,32,102,117,110,115,42,42]},
              {sep,
               [{text,
                 "dare received from a connected node. Before OTP 22, bit strings and export funs were not supported by"}],
               0,false},
              {text,[4,42,101,105,42]},
              {sep,
               [{text,
                 "f. They were instead encoded using an undocumented fallback tuple format when sent from the emulator to"}],
               0,false},
              {text,[4,42,101,105,42]},
              {sep,[{text,[1,58]}],0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,
         {text,[4,60,100,108,62]},
         {nest,4,
          {above,
           {above,
            {above,
             {above,
              {above,{above,{text,[0]},null},null},
              {above,
               {above,
                {sep,
                 [{text,[4,60,100,116,62]},
                  {sep,[{text,"\nBit string"}],0,false},
                  {text,[5,60,47,100,116,62]}],
                 0,true},
                null},
               null}},
             {above,
              {above,{above,{text,[0]},null},null},
              {above,
               {above,
                {sep,
                 [{text,[4,60,100,100,62]},
                  {above,
                   {above,{above,{text,[0]},null},null},
                   {above,
                    {above,
                     {sep,
                      [{sep,
                        [{sep,[{text,"\bThe term"}],0,false},
                         {text,"\v<<42, 1:1>>"},
                         {sep,
                          [{text,
                            [14,119,97,115,32,101,110,99,111,100,101,100,32,
                             97,115]}],
                          0,false},
                         {text,
                          [16,123,60,60,52,50,44,32,49,50,56,62,62,44,32,49,
                           125]},
                         {sep,
                          [{text,
                            "ç. The first element of the tuple is a binary and the second element denotes how many bits of the last bytes are part of the bit string. In this example only the most significant bit of the last byte (128) is part of the bit string."}],
                          0,false}],
                        0,false}],
                      0,true},
                     null},
                    null}},
                  {text,[5,60,47,100,100,62]}],
                 0,true},
                null},
               null}}},
            {above,
             {above,{above,{text,[0]},null},null},
             {above,
              {above,
               {sep,
                [{text,[4,60,100,116,62]},
                 {sep,[{text,"\nExport fun"}],0,false},
                 {text,[5,60,47,100,116,62]}],
                0,true},
               null},
              null}}},
           {above,
            {above,{above,{text,[0]},null},null},
            {above,
             {above,
              {sep,
               [{text,[4,60,100,100,62]},
                {above,
                 {above,{above,{text,[0]},null},null},
                 {above,
                  {above,
                   {sep,
                    [{sep,
                      [{sep,[{text,"\bThe term"}],0,false},
                       {text,
                        [15,102,117,110,32,108,105,115,116,115,58,109,97,112,
                         47,50]},
                       {sep,
                        [{text,
                          [14,119,97,115,32,101,110,99,111,100,101,100,32,97,
                           115]}],
                        0,false},
                       {text,"\v{lists,map}"},
                       {sep,
                        [{text,
                          "8. A tuple with the module, function and a missing arity."}],
                        0,false}],
                      0,false}],
                    0,true},
                   null},
                  null}},
                {text,[5,60,47,100,100,62]}],
               0,true},
              null},
             null}}}}},
        {text,[5,60,47,100,108,62]}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,[2,73,102]}],0,false},
              {text,
               [23,42,101,105,95,115,101,116,95,99,111,109,112,97,116,95,114,
                101,108,40,50,49,41,42]},
              {sep,[{text,[2,105,115]}],0,false},
              {text,[7,42,42,110,111,116,42,42]},
              {sep,
               [{text,
                 "gcalled then a connected emulator will send bit strings and export funs correctly encoded. The functions"}],
               0,false},
              {text,"+[ei_decode_bitstring](#ei_decode_bitstring)"},
              {sep,[{text,[3,97,110,100]}],0,false},
              {text,
               [31,91,101,105,95,100,101,99,111,100,101,95,102,117,110,93,40,
                35,101,105,95,100,101,99,111,100,101,95,102,117,110,41]},
              {sep,
               [{text,",has to be used to decode such terms. Calling"}],
               0,false},
              {text,
               [23,42,101,105,95,115,101,116,95,99,111,109,112,97,116,95,114,
                101,108,40,50,49,41,42]},
              {sep,
               [{text,
                 "¤should only be done as a workaround to keep an old implementation alive, which expects to receive the undocumented tuple formats for bit strings and/or export funs."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {above,
           {above,
            {text,[15,33,33,33,32,105,110,102,111,32,34,78,111,116,101,34]},
            {sep,
             [{text,[4,32,32,32,32]},
              {sep,
               [{sep,
                 [{above,
                   {above,{above,{text,[0]},null},null},
                   {above,
                    {above,
                     {sep,
                      [{sep,
                        [{sep,
                          [{text,
                            "kIf this function is called, it can only be called once and must be called before any other functions in the"}],
                          0,false},
                         {text,[4,42,101,105,42]},
                         {sep,
                          [{text,
                            [19,108,105,98,114,97,114,121,32,97,114,101,32,99,
                             97,108,108,101,100,46]}],
                          0,false}],
                        0,false}],
                      0,true},
                     null},
                    null}}],
                 0,false}],
               0,true}],
             0,false}},
           {text,[0]}},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,{text,"0## ei_skip_term(const char* buf, int* index):int"},null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,{sep,[{sep,[{text,"\fSkip a term."}],0,false}],0,true},null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,
               "¦Skips a term in the specified buffer; recursively skips elements of lists and tuples, so that a full term is skipped. This is a way to get the size of an Erlang term."}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,[5,42,98,117,102,42]},
              {sep,
               [{text,
                 [14,105,115,32,116,104,101,32,98,117,102,102,101,114,46]}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,[7,42,105,110,100,101,120,42]},
              {sep,
               [{text,
                 "7is updated to point right after the term in the buffer."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {above,
           {above,
            {text,[15,33,33,33,32,105,110,102,111,32,34,78,111,116,101,34]},
            {sep,
             [{text,[4,32,32,32,32]},
              {sep,
               [{sep,
                 [{above,
                   {above,{above,{text,[0]},null},null},
                   {above,
                    {above,
                     {sep,
                      [{sep,
                        [{text,
                          "qThis can be useful when you want to hold arbitrary terms: skip them and copy the binary term data to some buffer."}],
                        0,false}],
                      0,true},
                     null},
                    null}}],
                 0,false}],
               0,true}],
             0,false}},
           {text,[0]}},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,[7,82,101,116,117,114,110,115]}],0,false},
              {text,[3,42,48,42]},
              {sep,
               [{text,
                 [21,111,110,32,115,117,99,99,101,115,115,44,32,111,116,104,
                  101,114,119,105,115,101]}],
               0,false},
              {text,[4,42,45,49,42]},
              {sep,[{text,[1,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"5## ei_x_append(ei_x_buff* x, const ei_x_buff* x2):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         ">## ei_x_append_buf(ei_x_buff* x, const char* buf, int len):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,[{sep,[{text,"\eAppend a buffer at the end."}],0,false}],0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,"!Appends data at the end of buffer"}],0,false},
              {text,[3,42,120,42]},
              {sep,[{text,[1,46]}],0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,"6## ei_x_format(ei_x_buff* x, const char* fmt, ...):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         ">## ei_x_format_wo_ver(ei_x_buff* x, const char *fmt, ... ):int"},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,"2Format a term from a format string and parameters."}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 "VFormats a term, given as a string, to a buffer. Works like a sprintf for Erlang terms."}],
               0,false},
              {text,[5,42,102,109,116,42]},
              {sep,
               [{text,"-contains a format string, with arguments like"}],
               0,false},
              {text,[4,42,126,100,42]},
              {sep,
               [{text,
                 "_, to insert terms from variables. The following formats are supported (with the C types given):"}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {above,
           {above,
            {text,[3,96,96,96]},
            {sep,
             [{text,
               "ð\n~a  An atom, char*\n~c  A character, char\n~s  A string, char*\n~i  An integer, int\n~l  A long integer, long int\n~u  A unsigned long integer, unsigned long int\n~f  A float, float\n~d  A double float, double float\n~p  An Erlang pid, erlang_pid*"}],
             0,true}},
           {text,[3,96,96,96]}},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,"/For example, to encode a tuple with some stuff:"}],
             0,false}],
           0,true},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {above,
           {above,
            {text,[3,96,96,96]},
            {sep,
             [{text,
               "Y\nei_x_format(\"{~a,~i,~d}\", \"numbers\", 12, 3.14159)\nencodes the tuple {numbers,12,3.14159}"}],
             0,true}},
           {text,[3,96,96,96]}},
          null},
         null}},
       {above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{text,
               [22,42,101,105,95,120,95,102,111,114,109,97,116,95,119,111,95,
                118,101,114,40,41,42]},
              {sep,
               [{text,
                 "8formats into a buffer, without the initial version byte."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         [30,35,35,32,101,105,95,120,95,102,114,101,101,40,101,105,95,120,95,
          98,117,102,102,42,32,120,41,58,105,110,116]},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,[14,70,114,101,101,32,97,32,98,117,102,102,101,114,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,[{text,"\bFrees an"}],0,false},
              {text,"\v*ei_x_buff*"},
              {sep,
               [{text,
                 "<buffer. The memory used by the buffer is returned to the OS."}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {text,
         [29,35,35,32,101,105,95,120,95,110,101,119,40,101,105,95,120,95,98,
          117,102,102,42,32,120,41,58,105,110,116]},
        null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,{text,"*## ei_x_new_with_version(ei_x_buff* x):int"},null},
       null}},
     {above,
      {above,{above,{text,[0]},null},null},
      {above,
       {above,
        {sep,
         [{sep,
           [{text,
             [22,65,108,108,111,99,97,116,101,32,97,32,110,101,119,32,98,117,
              102,102,101,114,46]}],
           0,false}],
         0,true},
        null},
       null}},
     {sep,
      [{above,
        {above,{above,{text,[0]},null},null},
        {above,
         {above,
          {sep,
           [{sep,
             [{sep,
               [{text,
                 [15,65,108,108,111,99,97,116,101,115,32,97,32,110,101,119]}],
               0,false},
              {text,"\v*ei_x_buff*"},
              {sep,
               [{text,
                 ";buffer. The fields of the structure pointed to by parameter"}],
               0,false},
              {text,[3,42,120,42]},
              {sep,
               [{text,"0is filled in, and a default buffer is allocated."}],
               0,false},
              {text,
               [25,42,101,105,95,120,95,110,101,119,95,119,105,116,104,95,118,
                101,114,115,105,111,110,40,41,42]},
              {sep,
               [{text,
                 "Nalso puts an initial version byte, which is used in the binary format (so that"}],
               0,false},
              {text,
               [23,42,101,105,95,120,95,101,110,99,111,100,101,95,118,101,114,
                115,105,111,110,40,41,42]},
              {sep,
               [{text,
                 [20,119,105,108,108,32,110,111,116,32,98,101,32,110,101,101,
                  100,101,100,46,41]}],
               0,false}],
             0,false}],
           0,true},
          null},
         null}}],
      0,false}],
    0,false}},
  {sep,
   [{above,
     {above,{above,{text,[0]},null},null},
     {above,
      {above,
       {text,
        [20,35,35,32,68,101,98,117,103,32,73,110,102,111,114,109,97,116,105,
         111,110]},
       null},
      null}},
    {above,
     {above,{above,{text,[0]},null},null},
     {above,
      {above,
       {sep,
        [{sep,
          [{text,
            "^Some tips on what to check when the emulator does not seem to receive the terms that you send:"}],
          0,false}],
        0,true},
       null},
      null}},
    {above,
     {above,
      {sep,
       [{text,[1,42]},
        {sep,
         [{sep,[{text,"'Be careful with the version header, use"}],0,false},
          {text,
           [25,42,101,105,95,120,95,110,101,119,95,119,105,116,104,95,118,101,
            114,115,105,111,110,40,41,42]},
          {sep,
           [{text,
             [17,119,104,101,110,32,97,112,112,114,111,112,114,105,97,116,101,
              46]}],
           0,false}],
         0,false}],
       0,false},
      {sep,
       [{text,[1,42]},
        {text,"0Turn on distribution tracing on the Erlang node."}],
       0,false}},
     {sep,
      [{text,[1,42]},
       {sep,
        [{sep,[{text,"\eCheck the result codes from"}],0,false},
         {text,
          [18,42,101,105,95,100,101,99,111,100,101,95,45,99,97,108,108,115,
           42]},
         {sep,[{text,[1,46]}],0,false}],
        0,false}],
      0,false}}],
   0,false}},
 {sep,
  [{above,
    {above,{above,{text,[0]},null},null},
    {above,{above,{text,"\v## See Also"},null},null}},
   {above,
    {above,{above,{text,[0]},null},null},
    {above,
     {above,
      {sep,
       [{sep,
         [{text,
           [22,91,101,114,108,95,101,116,101,114,109,93,40,101,114,108,95,101,
            116,101,114,109,41]}],
         0,false}],
       0,true},
      null},
     null}}],
  0,false}}
