
fn to_rst @public
case (Type, {}, 'NOT IMPLEMENTED'):
  ['Not Implemented: ', atom_to_list(Type)]
case Nodes:
  child_nodes(Nodes, fn root_nodes:1)
end

fn child_nodes case Nodes, Fn: child_nodes(Nodes, Fn, []) end

fn child_nodes
case Bin, _Fn, [] when is_binary(Bin):
  io.format("~p~n~p~n", [Bin, erlang.get_stacktrace()])
  [Bin]  
case [], _Fn, Accum:
  lists.reverse(Accum)
case (comment, _, _) :: Nodes, Fn, Accum:
  child_nodes(Nodes, Fn, Accum)
case Node :: Nodes, Fn, Accum:
  Result = Fn(Node)
  child_nodes(Nodes, Fn, Result :: Accum)
end

fn root_nodes
case (header, _, Nodes):
  IGNORED = child_nodes(Nodes, fn header_nodes:1)
  ''
case (module, _, Text):
  ['Module\n\t', Text, '\n']
case (modulesummary, _, Text):
  ['\n', Text, '\n\n']
case (lib, _, Text):
  ['Module\n\t', Text, '\n']
case (libsummary, _, Text):
  ['\n', Text, '\n\n']
case (com, _, Text):
  ['Module\n\t', Text, '\n']
case (comsummary, _, Text):
  ['\n', Text, '\n\n']
case (app, _, Text):
  ['Module\n\t', Text, '\n']
case (appsummary, _, Text):
  ['\n', Text, '\n\n']
case (file, _, Text):
  ['Module\n\t', Text, '\n']
case (filesummary, _, Text):
  ['\n', Text, '\n\n']

case (description, _, Nodes):
  child_nodes(Nodes, fn markup:1)
case (funcs, _, Items):
  [title('Functions', '-'), child_nodes(Items, fn func:1)]
case (datatypes, _, Items):
  [title('Data Types', '-'), child_nodes(Items, fn datatype:1)]
case (authors, _, Items):
  [title('Authors', '-'), [child_nodes(Items, fn author:1), '\n']]
case (section, _, Nodes):
  child_nodes(Nodes, fn section_nodes: 1)
case (include, {href=FilePath}, _):
  [':include:', FilePath, '\n\n']
case Other:
  io_lib.format(" ~p ", [Other])
end

fn datatype case (datatype, _, Nodes):
  child_nodes(Nodes, fn datatype_nodes:1)
end

fn datatype_nodes
case (name, {name=Name}, ''):
  [to_one_line(Name), '\n']
case (name, {}, Name):
  [to_one_line(Name), '\n']
case (desc, _, Nodes):
  ['\t', to_one_line(child_nodes(Nodes, fn markup:1)), '\n']
end

fn author case (author, _, Nodes):
  child_nodes(Nodes, fn author_nodes:1)
end

fn author_nodes
case (aname, _, Text): [Text, '\n']
case (email, _, Text): [Text, '\n']
end

fn func case (func, _, Nodes):
  child_nodes(Nodes, fn func_nodes:1)
end

fn func_nodes
case (name, {name=Name, arity=Arity}, ''):
  title([Name, '/', Arity], '.')
case (name, {}, Text): title(Text, '.')
case (fsummary, _, Text): [Text, '\n\n']
case (type, _, Nodes):
  ['\n::\n\n', child_nodes(Nodes, fn type:1), '\n\n']
case (type_desc, _, Nodes):
  ['\n::\n\n', child_nodes(Nodes, fn markup:1), '\n\n']
case (desc, _, Nodes):
  child_nodes(Nodes, fn markup:1)
end


fn type
case (v, _, Text): ['\t', Text, '\n']
case (d, _, Text): ['\t\t', Text, '\n']
end

fn section_nodes
case (marker, {id=Id}, _):
  ['\n.. _', Id, ':\n']
case (title, _, Text):
  #_ "TODO: thread level to support nested sections"
  title(Text, '-')
case Node:
  markup(Node)
end

fn to_one_line case IOList:
  nl_to_space(strip(IOList, iodata))
end

fn markup
case (text, _, Text): Text
case (input, _, Text): ['`', Text, '`']
case (pre, _, Nodes): ['\n::\n', indent(child_nodes(Nodes, fn markup:1), 1), '\n\n']
case (code, Attrs, Nodes):
  Type0 = maps.get(type, Attrs, 'erl')
  Type = when Type0 is 'none': 'erl' else: Type0 end
  ['\n.. code-block:: ', Type, '\n\n', indent(Nodes, 1), '\n\n']
case (em, _, Text): [' *', Text, '* ']
case (c, _, Nodes): [' *', child_nodes(Nodes, fn markup:1), '* ']
case (anno, _, Text): Text
case (i, _, Text): [' *', Text, '* ']
case (br, _, _): '\n\n'
case (list, _, Items):
  #_ "TODO: thread list nesting to support nested lists"
  R = for (list_item, _, LINodes) in Items:
    ['* ', to_one_line(child_nodes(LINodes, fn markup:1)), '\n']
  end
  [R, '\n']
case (taglist, _, Items):
  R = for Node in Items:
    match Node:
      case (tag, _, TagNodes):
        [child_nodes(TagNodes, fn markup:1), '\n']
      case (tagitem, _, TINodes):
        ['\t', to_one_line(child_nodes(TINodes, fn markup:1)), '\n']
      case _: ''
    end
  end
  ['\n', R, '\n']
case (p, _, Nodes):
  ['\n\n', child_nodes(Nodes, fn markup:1), '\n\n']
case (marker, {id=Id}, _): [':marker:', Id, '\n']
case (seealso, {marker=Id}, _): [':seealso:', Id,]
case (warning, _, Nodes):
  ['\n.. warning::\n\n\t', indent(child_nodes(Nodes, fn markup:1), 1), '\n\n']
case (note, _, Nodes):
  ['\n.. note::\n\n\t', indent(child_nodes(Nodes, fn markup:1), 1), '\n\n']

case Other:
  io_lib.format(" ~p ", [Other])
end

fn header_nodes
case (copyright, _, Nodes):
  Holders = accum_text(holder, Nodes)
  THolders = lists.join(', ', Holders)
  Years = accum_text(year, Nodes)
  TYears = lists.join(' - ', Years)
  ['Copyright ', THolders, ' ', TYears, '\n\n']
case (legalnotice, _, Text):
  [title('Legal Notice', '-'), '\n::\n\n', Text, '\n\n']
case (title, _, Text):
  ['\n', title(Text, '=')]
case (prepared, _, ''): ''
case (prepared, _, Text):
  ['Prepared\n\t', Text, '\n']
case (responsible, _, ''): ''
case (responsible, _, Text):
  ['Responsible\n\t', Text, '\n']
case (docno, _, ''): ''
case (docno, _, Text):
  ['Document Number\n\t', Text, '\n']
case (approved, _, ''): ''
case (approved, _, Text):
  ['Approved\n\t', Text, '\n']
case (checked, _, ''): ''
case (checked, _, Text):
  ['Checked\n\t', Text, '\n']
case (date, _, ''): ''
case (date, _, Text):
  ['Date\n\t', Text, '\n']
case (rev, _, ''): ''
case (rev, _, Text):
  ['Revision\n\t', Text, '\n']
case (file, _, ''): ''
case (file, _, Text):
  ['File\n\t', Text, '\n']
end

fn title case Text, Char:
  #_ "TODO: make it work for unicode"
  OLText = to_one_line(Text)
  Len = size(OLText)
  [OLText, '\n', lists.duplicate(Len, Char), '\n\n']
end

fn accum_text case Tag, Nodes:
  for (NTag, _, Text) in Nodes; when Tag is NTag: Text end
end

fn indent case IOList, Count:
  Indent = (#c "\n") :: lists.duplicate(Count, (#c "\t"))
  re.replace(IOList, "\n", Indent, [global, unicode, (return, binary)])
end

fn strip case IOList, RetType:
  re.replace(IOList, "(^(\n|\\s)+|(\n|\\s)+$)", "",
    [global, unicode, (return, RetType)])
end

fn nl_to_space case IOList:
  re.replace(IOList, "(\n|\\s)+", " ", [global, unicode, (return, binary)])
end
