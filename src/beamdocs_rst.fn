
fn to_rst @public
case (Type, {}, 'NOT IMPLEMENTED'):
  ['Not Implemented: ', atom_to_list(Type)]
case Nodes:
  child_nodes(Nodes, fn root_nodes:1)
end

fn child_nodes case Nodes, Fn: child_nodes(Nodes, Fn, []) end

fn child_nodes
case [], _Fn, Accum:
  lists.reverse(Accum)
case (comment, _, _) :: Nodes, Fn, Accum:
  child_nodes(Nodes, Fn, Accum)
case Node :: Nodes, Fn, Accum:
  Result = Fn(Node)
  child_nodes(Nodes, Fn, Result :: Accum)
end

fn root_nodes
case (header, _, Nodes):
  IGNORED = child_nodes(Nodes, fn header_nodes:1)
  ''
case (module, _, Text):
  title(Text, '=')
case (modulesummary, _, Text):
  ['\n', Text, '\n\n']
case (lib, _, Text):
  title(Text, '=')
case (libsummary, _, Text):
  ['\n', Text, '\n\n']
case (com, _, Text):
  title(Text, '=')
case (comsummary, _, Text):
  ['\n', Text, '\n\n']
case (app, _, Text):
  title(Text, '=')
case (appsummary, _, Text):
  ['\n', Text, '\n\n']
case (file, _, Text):
  title(Text, '=')
case (filesummary, _, Text):
  ['\n', Text, '\n\n']

case (description, _, Nodes):
  markup(Nodes)
case (funcs, _, Items):
  [title('Functions', '-'), child_nodes(Items, fn func:1)]
case (datatypes, _, Items):
  [title('Data Types', '-'), child_nodes(Items, fn datatype:1)]
case (authors, _, Items):
  [title('Authors', '-'), [child_nodes(Items, fn author:1), '\n']]
case (section, _, Nodes):
  child_nodes(Nodes, fn section_nodes: 1)
case (include, {href=FilePath}, _):
  [':include:', FilePath, '\n\n']
case Other:
  io_lib.format(" ~p ", [Other])
end

fn markup case Nodes:
  child_nodes(fix_markup(Nodes, []), fn markup_node:1)
end

fn fix_markup
case [], Accum:
  lists.reverse(Accum)
case (N1=(Tag, _, _)) :: N2 :: T, Accum
when Tag is c or Tag is em or Tag is i or Tag is input:
  fix_markup(N2 :: T, (text, {}, ' ') :: N1 :: Accum)
case H :: T, Accum:
  fix_markup(T, H :: Accum)
end

fn datatype case (datatype, _, Nodes):
  child_nodes(Nodes, fn datatype_nodes:1)
end

fn datatype_nodes
case (name, {name=Name}, ''):
  ['* ', to_one_line(Name), '\n']
case (name, {}, Name):
  ['* ', to_one_line(Name), '\n']
case (desc, _, Nodes):
  ['  + ', to_one_line(markup(Nodes)), '\n']
end

fn author case (author, _, Nodes):
  child_nodes(Nodes, fn author_nodes:1)
end

fn author_nodes
case (aname, _, Text): [Text, '\n']
case (email, _, Text): [Text, '\n']
end

fn func case (func, _, Nodes):
  child_nodes(Nodes, fn func_nodes:1)
end

fn func_nodes
case (name, {name=Name, arity=Arity}, ''):
  title([Name, '/', Arity], '.')
case (name, {}, Text): title(Text, '.')
case (fsummary, _, Nodes): [markup(Nodes), '\n\n']
case (type, {name=Name}, []):
  ['\n::\n\n\t', Name, '\n\n']
case (type, {variable=Name}, []):
  ['\n::\n\n\t', Name, '\n\n']
case (type, _, Nodes):
  ['\n::\n\n\t', child_nodes(Nodes, fn type:1), '\n\n']
case (type_desc, {variable=Name}, Nodes):
  ['\n::\n\n\t', Name, ': ', markup(Nodes), '\n\n']
case (type_desc, _, Nodes):
  ['\n::\n\n\t', markup(Nodes), '\n\n']
case (desc, _, Nodes):
 markup(Nodes) 
end


fn type
case (v, _, Text): ['\t', Text, '\n']
case (d, _, Nodes): ['\t\t', markup(Nodes), '\n']
end

fn section_nodes
case (marker, {id=Id}, _):
  ['\n.. _', Id, ':\n\n']
case (title, _, Text):
  #_ "TODO: thread level to support nested sections"
  title(Text, '-')
case (section, _, Nodes):
  #_ "seen in appup.xml"
  child_nodes(Nodes, fn section_nodes: 1)
case Node:
  markup_node(Node)
end

fn to_one_line case IOList:
  nl_to_space(strip(IOList, iodata))
end

fn markup_node
case (text, _, Text): escape_chars(Text)
case (input, _, Text): ['`', Text, '`']
case (pre, _, Nodes): ['\n::\n', indent(markup(Nodes), 1), '\n\n']
case (code, Attrs, Nodes):
  Type0 = maps.get(type, Attrs, 'erl')
  Type = when Type0 is 'none': 'erl' else: Type0 end
  ['\n.. code-block:: ', Type, '\n\n', indent(Nodes, 1), '\n\n']
case (em, _, Nodes): ['*', strip(markup(Nodes)), '*']
case (c, _, Nodes): ['**', strip(markup(Nodes)), '**']
case (anno, _, Text): Text
case (i, _, Text): ['*', strip(Text), '*']
case (br, _, _): '\n\n'
case (list, _, Items):
  #_ "TODO: thread list nesting to support nested lists"
  R = for (list_item, _, LINodes) in Items:
    ['* ', to_one_line(markup(LINodes)), '\n']
  end
  [R, '\n']
case (taglist, _, Items):
  R = for Node in Items:
    match Node:
      case (tag, _, TagNodes):
        ['\n', strip(markup(TagNodes)), '\n']
      case (tagitem, _, TINodes):
        ['\t', to_one_line(markup(TINodes)), '\n']
      case (comment, _, _): ''
    end
  end
  ['\n', R, '\n']
case (p, _, Nodes):
  ['\n\n', strip(markup(Nodes)), '\n\n']
case (marker, {id=Id}, _): ['\n.. _', Id, ':\n\n']
case (seealso, {marker=Id}, _): [':seealso:', Id,]
case (warning, _, Nodes):
  ['\n.. warning::\n\n\t', indent(markup(Nodes), 1), '\n\n']
case (note, _, Nodes):
  ['\n.. note::\n\n\t', indent(markup(Nodes), 1), '\n\n']

case Other:
  io_lib.format(" ~p ", [Other])
end

fn header_nodes
case (copyright, _, Nodes):
  Holders = accum_text(holder, Nodes)
  THolders = lists.join(', ', Holders)
  Years = accum_text(year, Nodes)
  TYears = lists.join(' - ', Years)
  ['Copyright ', THolders, ' ', TYears, '\n\n']
case (legalnotice, _, Text):
  [title('Legal Notice', '-'), '\n::\n\n', Text, '\n\n']
case (title, _, Text):
  ['\n', title(Text, '=')]
case (prepared, _, ''): ''
case (prepared, _, Text):
  ['Prepared\n\t', Text, '\n']
case (responsible, _, ''): ''
case (responsible, _, Text):
  ['Responsible\n\t', Text, '\n']
case (docno, _, ''): ''
case (docno, _, Text):
  ['Document Number\n\t', Text, '\n']
case (approved, _, ''): ''
case (approved, _, Text):
  ['Approved\n\t', Text, '\n']
case (checked, _, ''): ''
case (checked, _, Text):
  ['Checked\n\t', Text, '\n']
case (date, _, ''): ''
case (date, _, Text):
  ['Date\n\t', Text, '\n']
case (rev, _, ''): ''
case (rev, _, Text):
  ['Revision\n\t', Text, '\n']
case (file, _, ''): ''
case (file, _, Text):
  ['File\n\t', Text, '\n']
end

fn title case Text, Char:
  #_ "TODO: make it work for unicode"
  OLText = to_one_line(Text)
  Len = size(OLText)
  ['\n', OLText, '\n', lists.duplicate(Len, Char), '\n\n']
end

fn accum_text case Tag, Nodes:
  for (NTag, _, Text) in Nodes; when Tag is NTag: Text end
end

fn indent case IOList, Count:
  Indent = (#c "\n") :: lists.duplicate(Count, (#c "\t"))
  re.replace(["\n", strip(IOList)], "\n", Indent,
    [global, unicode, (return, binary)])
end

fn strip case IOList: strip(IOList, binary) end

fn strip case IOList, RetType:
  re.replace(IOList, "(^(\n|\\s)+|(\n|\\s)+$)", "",
    [global, unicode, (return, RetType)])
end

fn nl_to_space case IOList:
  re.replace(IOList, "(\n|\\s)+", " ", [global, unicode, (return, binary)])
end

fn escape_chars case Text:
  re.replace(Text, "(\\*|`)", "\\&", [global, unicode, (return, binary)])
end
