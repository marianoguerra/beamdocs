@import(prettypr, [above/2, beside/2, break/1, empty/0, nest/2, text/1, sep/1, par/1, follow/3])

fn from_ast @public case Doc:
  prettypr.format(layout_from_ast(Doc))
end

fn layout_from_ast @public case Doc:
  Ctx = new_ctx()
  to_layout(Doc, Ctx)
end

fn transform_pre @public case Nodes:
  Ctx = new_ctx()
  abovel((for Node in beamdocs_ast.transform(Nodes): to_layout(Node, Ctx) end))
end

fn transform @public case Nodes:
  Layout = transform_pre(Nodes)
  prettypr.format(Layout)
end

fn to_layout @public
case (div, _Attrs, Childs), Ctx:
  layout_items_beside(Childs, Ctx)
case (span, _Attrs, ''), Ctx:
  empty()
case (span, _Attrs, ['']), Ctx:
  empty()
case (span, _Attrs, Childs), Ctx:
  layout_items_beside(Childs, Ctx)
case (p, _Attrs, Childs), Ctx:
  above(raw_txt("\n"), layout_items_beside(Childs, Ctx))
case (hr, _Attrs, _Childs), _Ctx:
  text("\n\n***\n\n")
case (br, _Attrs, _Childs), _Ctx:
  text("\n\n")
case (empty, _Attrs, _Childs), _Ctx:
  empty()
case (h1, _Attrs, Childs), Ctx:
  wrap(Childs, Ctx, "\n# ", "\n", fn besidel:1)
case (h2, _Attrs, Childs), Ctx:
  wrap(Childs, Ctx, "\n## ", "\n", fn besidel:1)
case (h3, _Attrs, Childs), Ctx:
  wrap(Childs, Ctx, "\n### ", "\n", fn besidel:1)
case (h4, _Attrs, Childs), Ctx:
  wrap(Childs, Ctx, "\n#### ", "\n", fn besidel:1)
case (h5, _Attrs, Childs), Ctx:
  wrap(Childs, Ctx, "\n##### ", "\n", fn besidel:1)
case (h6, _Attrs, Childs), Ctx:
  wrap(Childs, Ctx, "\n###### ", "\n", fn besidel:1)
case (em, _Attrs, Childs), Ctx:
  wrap(Childs, Ctx, "**", "**")
case (strong, _Attrs, Childs), Ctx:
  wrap(Childs, Ctx, "*", "*")
case (u, _Attrs, Childs), Ctx:
  wrap(Childs, Ctx, "_", "_")
case (a, {name=Ref}, Childs), Ctx:
  wrap(Childs, Ctx, iol2b(["<a name=\"", Ref, "\">"]), "</a>")
case (a, {href=Ref}, Childs), Ctx:
  wrap(Childs, Ctx, "[", iol2b(["](", Ref, ")"]))
case (img, {src=Src, alt=Alt}, _Childs), Ctx:
  wrap([Alt], Ctx, "![", iol2b(["](", Src, ")"]))
case (img, {src=Src}, _Childs), Ctx:
  wrap(["image"], Ctx, "![", iol2b(["](", Src, ")"]))
case (code, Attrs, Childs), Ctx:
  Lang = maps.get(lang, Attrs, "")
  Prefix = iol2b(["\n```", Lang, "\n"])
  mdt(Childs, Ctx # {escape=false, plain=true}, Prefix, "\n```\n")
case (pre, _Attrs, Childs), Ctx:
  mdt(Childs, Ctx # {escape=false, plain=true}, "\n```\n", "\n```\n")
case (ul, _Attrs, Childs), Ctx:
  abovel(layout_items(Childs, Ctx))
case (ol, _Attrs, Childs), Ctx:
  #_ "TODO: number items"
  abovel(layout_items(Childs, Ctx))
case (li, _Attrs, Childs), Ctx:
  mdli(Childs, Ctx)

case (dialog, {type=Type, title=Title}, Childs), Ctx:
  AlertType = match Type:
  case danger: "danger"
  case warning: "warning"
  case success: "success"
  case info: "info"
  else: "info"
  end

  abovel([
    raw_txt(iol2b(["\n!!! ", AlertType, " \"", Title, "\""])),
    nestc(par(layout_items(Childs, Ctx)), Ctx),
    raw_txt("")])

case (dl, _Attrs, Childs), Ctx:
  abovel([
    raw_txt("<dl>"),
    nestc(abovel(layout_items(Childs, Ctx)), Ctx),
    raw_txt("</dl>"),
  ])
case (dt, _Attrs, Childs), Ctx:
  besidel([raw_txt("\n<dt>"), layout_items_beside(Childs, Ctx # {plain=true, escape=false}), raw_txt("</dt>\n")])
case (dd, _Attrs, Childs), Ctx:
  besidel([raw_txt("\n<dd>"), layout_items_beside(Childs, Ctx # {plain=true, escape=false}), raw_txt("</dd>\n")])

case (table, _, _), _Ctx:
  text("TODO: TABLE")

case Item, Ctx when is_binary(Item):
  txt(Item, Ctx)
end

fn mdli case Childs, Ctx:
  beside(raw_txt("* "), nestc(par(layout_items(Childs, Ctx)), Ctx))
end

fn mdt
case Childs, Ctx, Prefix, Suffix:
  besidel([raw_txt(Prefix), layout_items_beside(Childs, Ctx), raw_txt(Suffix)])
end

fn wrap case Childs, Ctx, Prefix, Suffix:
  wrap(Childs, Ctx, Prefix, Suffix, fn sepl:1)
end

fn wrap
case Childs, Ctx={plain=true}, _, _, JoinFn:
  JoinFn(layout_items(Childs, Ctx))
case Childs, Ctx, Prefix, Suffix, JoinFn:
  besidel([raw_txt(Prefix), JoinFn(layout_items(Childs, Ctx)), raw_txt(Suffix)])
end

fn sepl
case []: empty()
case Items: sep(Items)
end

fn joinl
case Items:
  besidel(lists.join(raw_txt(" "), Items))
end

fn layout_items
case Childs, Ctx when is_list(Childs):
  for Child in Childs: to_layout(Child, Ctx) end
case Child, Ctx:
  [to_layout(Child, Ctx)]
end

fn layout_items_beside
case Child, Ctx:
  besidel(layout_items(Child, Ctx))
end

fn abovel
case [Item]:
  Item
case Items:
  fnl(Items, fn prettypr.above:2)
end

fn besidel
case [Item]:
  Item
case Items:
  fnl(Items, fn prettypr.beside:2)
end

fn followl
case [Item]:
  Item
case Items:
  fnl(Items, fn prettypr.follow:2)
end

fn fnl
case [], _Fn:
  empty()
case Items, Fn:
  lists.foldl(nothing, Items) <<-
  case Item, nothing:
    Item
  case Item, AccumIn:
    Fn(AccumIn, Item)
  end
end

fn nestc case Doc, _Ctx:
  nest(4, Doc)
end

fn raw_txt
case V when is_binary(V):
  text(binary_to_list(V))
case V when is_list(V):
  text(V)
end

fn txt
case V, {escape=false} when is_binary(V):
  text(binary_to_list(V))
case V, {escape=false} when is_list(V):
  text(V)
case V, _Ctx when is_binary(V):
  text(escape_md(binary_to_list(V)))
case V, _Ctx when is_list(V):
  text(escape_md(V))
end

fn escape_md case Str:
  re.replace(Str, "[*_]", "\\\\&", [global, (return, list)])
end

fn iol2b case IOList:
  list_to_binary(lists.flatten(IOList))
end

fn new_ctx case:
  {escape: true, plain: false}
end
