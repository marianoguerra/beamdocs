
fn transform @public case Nodes:
  for Node in beamdocs_aft.transform(Nodes): to_md(Node) end
end

fn dl case (dl, _, Items):
  DDs =
  for (dd, _, (Name, Desc)) in Items:
    [inline(Name), '\n\t', to_md(Desc)]
  end
  bs(lists.join('\n\n', DDs))
end

fn list case (list, _, Items):
  bs(['\n',
  (for (li, _, Item) in Items:
    ['* ', inline(Item), '\n']
  end),
  '\n'])
end

fn pre case (pre, _, Nodes):
  bs(['\n```\n', plain_text(Nodes), '\n```\n'])
end

fn code case (code, {lang=Lang}, Nodes):
  bs(['\n```', Lang, '\n', plain_text(Nodes), '\n```\n'])
end

fn top_level_title case Items:
  for (Item=(title, _, _)) in Items: Item end
end

fn indent case IOList, Count:
  Indent = (#c "\n") :: lists.duplicate(Count, (#c "\t"))
  re.replace(["\n", IOList], "\n", Indent,
    [global, unicode, (return, binary)])
end

fn to_md
case (section, {t=T}, Nodes)
when T is warning or T is `do` or T is dont or T is note:
  (AlertType, Title) =
  match T:
    case warning: ('warning', 'Warning')
    case `do`: ('success', 'Do')
    case dont: ('danger', 'Don\'t')
    case note: ('info', 'Note')
  end

  bs(['\n!!! ', AlertType, ' ', Title, '\n', indent(to_md(Nodes), 1), '\n\n'])

case (section, {t=header}, Items):
  match top_level_title(Items):
    case [Title]:
      to_md(Title)
    case []:
      ''
  end

case (section, _, Nodes):
  for Node in Nodes: to_md(Node) end
case (p, _, Nodes):
  Content = p_childs(Nodes)
  wrap_non_empty('\n\n', Content)
case Node=(pre, _, _):
  pre(Node)
case Node=(code, _, _):
  code(Node)
case (title, {level=Level}, Nodes):
  title(Level, Nodes)
case Node=(list, _, _):
  list(Node)
case Node=(dl, _, _):
  dl(Node)
case Node=(table, _, _):
  beamdocs_html.table(Node)
case (ignore, _, _):
  ''
case Items when is_list(Items):
  for Item in Items: to_md(Item) end
case Other:
  inline(Other)
end

fn inline
case (br, _):
  '\n\n'
case (p, _, Nodes):
  inline(Nodes)
case (img, {ref=Ref}, Title):
  bs(['![', Title, '](', Ref, ')'])

case (marker, {ref=Id}, _):
  wrap('\n', beamdocs_html.wrap('a', ['name="', Id, '"'], ''))
case (link, {ref=Ref}, Nodes):
  bs(['[', plain_text(Nodes), '](', Ref, ')'])
case (em, _, Nodes):
  Content = em_childs(Nodes)
  wrap('_', Content)
case (strong, _, Nodes):
  Content = filter_childs(Nodes, fn strong_child:1)
  wrap('**', Content)
case Text when is_binary(Text):
  escape_chars(Text)
case List when is_list(List):
  match io_lib.deep_char_list(List):
    case true:
      bs(List)
    else:
      for Item in List: inline(Item) end
  end
case (ignore, _, _):
  ''
case (span, {t=T}, Nodes) when T is term or T is path or T is input:
  wrap_non_empty('`', plain_text(Nodes))
case (span, _, Nodes):
  inline(Nodes)
case Other:
  io.format("inline: ~p~n~n", [Other])
  plain_text(Other)
end

fn plain_text
case (p, _, Nodes):
  plain_text(Nodes)
case (em, _, Nodes):
  plain_text(Nodes)
case (strong, _, Nodes):
  plain_text(Nodes)
case (span, _, Nodes):
  plain_text(Nodes)
case (link, {ref=Ref}, Nodes):
  bs(['[', plain_text(Nodes), '](', Ref, ')'])
case Text when is_binary(Text):
  escape_chars(Text)
case (ignore, _, _):
  ''
case List when is_list(List):
  match io_lib.deep_char_list(List):
    case true:
      bs(List)
    else:
      for Item in List: plain_text(Item) end
  end
case Other:
  io.format("plain_text: ~p~n~n", [Other])
  ''
end

fn title
case Level, Nodes when Level > 0 and Level <= 6:
  bs([lists.duplicate(Level, '#'), ' ', plain_text(Nodes), '\n\n'])
case _, Nodes:
  title(6, Nodes)
end

fn wrap_non_empty
case _Wrap, '': ''
case Wrap, Content:
  wrap(Wrap, Content)
end

fn wrap case Wrap, Content:
  bs([Wrap, Content, Wrap])
end

fn filter_childs
case Nodes, Fn when is_list(Nodes):
  RItems =
  lists.foldl([], Nodes) <<- case Node, AccumIn:
    match Fn(Node):
      case ignore: AccumIn
      case ok, Res: Res :: AccumIn
    end
  end

  bs(lists.reverse(RItems))
case Node, Fn:
  filter_childs([Node], Fn)
end

fn em_childs case Nodes:
  filter_childs(Nodes, fn em_child:1)
end

fn p_childs case Nodes:
  filter_childs(Nodes, fn p_child:1)
end

fn em_child case Nodes: (ok, plain_text(Nodes)) end
fn strong_child case Nodes: (ok, plain_text(Nodes)) end
fn p_child
  case Node=(dl, _, _):
    (ok, dl(Node))
  case Node=(list, _, _):
    (ok, list(Node))
  case Node=(pre, _, _):
    (ok, pre(Node))
  case Node=(code, _, _):
    (ok, code(Node))
  case List when is_list(List):
    (ok, p_childs(List))
  case Nodes:
    (ok, inline(Nodes))
end

fn bs case V: unicode.characters_to_binary(V) end

fn escape_chars case Text:
  Text
    -> re.replace("(\\*|`|\\|)", "\\\\&", [global, unicode, (return, binary)])
    -> xmerl_lib.export_text()
end
