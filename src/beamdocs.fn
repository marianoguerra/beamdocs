

fn main @public
    case ["to-json", BasePath, OutDir]:
        to_json(filename.absname(BasePath), OutDir)
    case _Args:
        io.format("Usage: beamdocs to-json BaseSrcPath OutDir~n")
        erlang.halt(0)
end

fn to_json @public case BasePath, OutPath:
    AccIn = {files: [], base_path: BasePath, out_path: OutPath}
    Fn = fn file_to_json:2
    io.format("to-json ~p~n", [BasePath])
    filelib.fold_files(BasePath, ".*\\.erl$", true, Fn, AccIn)
end

fn file_to_json @public
    case FilePath, AccIn={files=Files, base_path=BasePath, out_path=OutPath}:
        BaseLen = length(BasePath)
        ShortPath = string.substr(FilePath, BaseLen + 2)

        io.format("process ~p~n", [ShortPath])

        ParseResult = epp.parse_file(FilePath, [], [])

        BaseModState = {
            path: list_to_binary(ShortPath),
            full_path: list_to_binary(FilePath),
            fns: [],
            exports: []
        }

        (_, Info) = match ParseResult:
            case ok, Ast:
                ast_walk.walk(Ast, fn walker:2, BaseModState)
            case error, Reason:
                io.format("Error: parsing ~p: ~p~n", [FilePath, Reason])
                BaseModState
        end

        FileOutPath = filename.join(OutPath, ShortPath ++ ".json")
        filelib.ensure_dir(FileOutPath)
        file.write_file(FileOutPath, jsone.encode(Info))

        AccIn#{files: [Info :: Files]}
end

fn walker
    case State={exports=Exps}, Node=(attribute, _Line, export, FunRefs):
        Fns = for (FnName, Arity) in FunRefs:
            {name: FnName, arity: Arity}
        end
        (Node, State#{exports=Fns ++ Exps})
    case State={fns=Fns}, Node=(function, Line, Name, Arity, Clauses):
        LastLine = last_line(Node)

        Fn = {
            name: Name,
            line: Line,
            arity: Arity,
            clauses_count: length(Clauses),
            lines: LastLine - Line
        }
        (Node, State#{fns=[Fn :: Fns]})
    case State, Node:
        (Node, State)
end

fn last_line
    @doc("Totally ad-hoc function to get an approx last line for an ast")

    case (function, _, _, _, Clauses):
        LastClause = lists.last(Clauses)
        (clause, _, _, _, Body) = LastClause
        LastLineAst = lists.last(Body)
        last_line(LastLineAst)
    case (`case`, _, _, Clauses):
        last_line(lists.last(Clauses))
    case (`receive`, _, Clauses=[_ :: _]):
        last_line(lists.last(Clauses))
    case (`receive`, _, Clauses=[_ :: _], _, []):
        last_line(lists.last(Clauses))
    case (`receive`, _, _, _, Clauses):
        last_line(lists.last(Clauses))
    case (`if`, _, Clauses):
        last_line(lists.last(Clauses))
    case (`try`, _, Clauses=[_ :: _], [], [], []):
        last_line(lists.last(Clauses))
    case (`try`, _, _, Clauses=[_ :: _], [], []):
        last_line(lists.last(Clauses))
    case (`try`, _, _, _, Clauses=[_ :: _], []):
        last_line(lists.last(Clauses))
    case (`try`, _, _, _, _, Clauses=[_ :: _]):
        last_line(lists.last(Clauses))
    case (`catch`, _, Body):
        last_line(Body)
    case (`block`, _, Body):
        last_line(Body)
    case (`fun`, _, (clauses, Clauses)):
        last_line(lists.last(Clauses))
    case (`fun`, _, (function, _, _, Node)):
        last_line(Node)
    case (lc, _, _, Items):
        last_line(lists.last(Items))
    case (bc, _, _, Items):
        last_line(lists.last(Items))
    case (generate, _, _, Node):
        last_line(Node)
    case (b_generate, _, _, Node):
        last_line(Node)
    case (bin_element, _, Node, _, _):
        last_line(Node)
    case (op, _, _, Node):
        last_line(Node)
    case (op, _, _, _, Node):
        last_line(Node)
    case (`match`, _, _, Node):
        last_line(Node)
    case (record, Line, _, []):
        Line
    case (record, _, _, Fields):
        last_line(lists.last(Fields))
    case (record, _, _, _, Fields):
        last_line(lists.last(Fields))
    case (record_field, _, _, Node):
        last_line(Node)
    case (record_field, _, _, _, Node):
        last_line(Node)
    case (clause, _, _, Body):
        last_line(lists.last(Body))
    case (clause, _, _, _, Body):
        last_line(lists.last(Body))
    case (bin, Line, []):
        Line
    case (bin, _, Items):
        last_line(lists.last(Items))
    case (tuple, Line, []):
        Line
    case (tuple, _, Items):
        last_line(lists.last(Items))
    case (map, Line, []):
        Line
    case (map, _, Items):
        last_line(lists.last(Items))
    case (call, Line, _, []):
        Line
    case (call, _, _, Args):
        last_line(lists.last(Args))
    case (cons, _, _, Tail):
        last_line(Tail)

    case Nodes when is_list(Nodes):
        last_line(lists.last(Nodes))
    case Node:
        element(2, Node)
end
