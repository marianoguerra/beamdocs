@include_lib("xmerl/include/xmerl.hrl")

fn main @public
  case ["to-json", BasePath, OutDir]:
    to_json(filename.absname(BasePath), OutDir)
  case ["docs-to-rst", BasePath, OutDir]:
    DocgenDir = code.priv_dir(erl_docgen)
    DtdPaths = [filename.join(DocgenDir, "dtd"),
      filename.join(DocgenDir, "dtd_html_entities")]
    docs_to_rst(filename.absname(BasePath), DtdPaths, OutDir)
  case ["to-index", BasePath, OutPath, RepoBaseUrl, Commit]:
    to_index(filename.absname(BasePath), OutPath, RepoBaseUrl, Commit)
  case _Args:
    io.format("Usage: beamdocs to-json BaseSrcPath OutDir~n")
    erlang.halt(0)
end

fn docs_to_rst @public case BasePath, DtdPaths, OutPath:
  AccIn = {base_path: BasePath, out_path: OutPath, dtd_paths: DtdPaths}
  Fn = fn doc_to_rst:2
  io.format("docs-to-json ~p~n", [BasePath])
  filelib.fold_files(BasePath, ".*\\.xml$", true, Fn, AccIn)
end

fn doc_to_rst @public
case FilePath, AccIn={base_path=BasePath, dtd_paths=DtdPaths, out_path=OutPath}:
  BaseLen = length(BasePath)
  _ShortPath = string.substr(FilePath, BaseLen + 2)
  #_ io.format("process ~p ~p~n", [ShortPath, FilePath])
  (ParsResult, _Misc) = xmerl_scan.file(FilePath, [(fetch_path, DtdPaths)])
  Info = beamdocs_xml.parse(ParsResult)
  Text = beamdocs_rst.to_rst(Info)
  write_to_file(Text, FilePath, OutPath, ".rst")
  AccIn
end

fn write_to_file case Data, InPath, OutDir, Extension:
  FileName = filename.basename(InPath)
  FileOutPath = filename.join(OutDir, FileName ++ Extension)
  filelib.ensure_dir(FileOutPath)
  file.write_file(FileOutPath, Data)
end

fn to_json @public case BasePath, OutPath:
  AccIn = {files: [], base_path: BasePath, out_path: OutPath}
  Fn = fn file_to_json:2
  io.format("to-json ~p~n", [BasePath])
  filelib.fold_files(BasePath, ".*\\.erl$", true, Fn, AccIn)
end

fn file_to_json @public
case FilePath, AccIn={files=Files, base_path=BasePath, out_path=OutPath}:
  BaseLen = length(BasePath)
  ShortPath = string.substr(FilePath, BaseLen + 2)

  io.format("process ~p~n", [ShortPath])

  ParseResult = epp.parse_file(FilePath, [], [])

  BaseModState = {
  path: list_to_binary(ShortPath),
  full_path: list_to_binary(FilePath),
  fns: [],
  exports: []
  }

  (_, Info) = match ParseResult:
    case ok, Ast:
      ast_walk.walk(Ast, fn walker:2, BaseModState)
    case error, Reason:
      io.format("Error: parsing ~p: ~p~n", [FilePath, Reason])
      BaseModState
    end

    FileOutPath = filename.join(OutPath, ShortPath ++ ".json")
    filelib.ensure_dir(FileOutPath)
    file.write_file(FileOutPath, jsone.encode(Info))

    AccIn#{files: Info :: Files}
end

fn walker
  case State={exports=Exps}, Node=(attribute, _Line, export, FunRefs):
    Fns = for (FnName, Arity) in FunRefs:
      {name: FnName, arity: Arity}
    end
    (Node, State#{exports=Fns ++ Exps})
  case State={fns=Fns}, Node=(function, Line, Name, Arity, Clauses):
    LastLine = last_line(Node)

    Fn = {
      name: Name,
      line: Line,
      arity: Arity,
      clauses_count: length(Clauses),
      lines: LastLine - Line + 1
    }
    (Node, State#{fns=Fn :: Fns})
  case State, Node:
    (Node, State)
end

fn to_index @public case BasePath, OutPath, RepoBaseUrl, Commit:
  AccIn = {}
  Fn = fn file_to_index:2
  io.format("to-index~p~n", [BasePath])
  AccOut = filelib.fold_files(BasePath, ".*\\.erl\\.json$", true, Fn, AccIn)
  Data = jsone.encode({
    mods: AccOut,
    repository: list_to_binary(RepoBaseUrl),
    commit: list_to_binary(Commit)
  })
  file.write_file(OutPath, Data)
end

fn file_to_index @public case FilePath, AccIn:
  io.format("processing ~p~n", [FilePath])
  (ok, Binary) = file.read_file(FilePath)
  Info = jsone.decode(Binary)
  Exports  = maps.get('exports', Info, [])
  Fns = maps.get('fns', Info, [])
  SrcPath = maps.get('path', Info, '')

  ExportsMap = maps.from_list((for {'arity'=Arity, 'name'=Name} in Exports:
    ExportName = io_lib.format("~s/~p", [Name, Arity]) -> list_to_binary()
    (ExportName, 1)
  end))

  FnsMap = maps.from_list((for {'arity'=Arity, 'name'=Name, 'line'=Line} in Fns:
    FnName = io_lib.format("~s/~p", [Name, Arity]) -> list_to_binary()
    IsPublic = maps.get(FnName, ExportsMap, 0)
    (FnName, [Line, IsPublic])
  end))

  ModName = filename.basename(FilePath, ".erl.json") -> list_to_binary()
  AccIn#{ModName: {fns: FnsMap, path: SrcPath}}
end

fn last_line
@doc("Totally ad-hoc function to get an approx last line for an ast")

  case (function, _, _, _, Clauses):
    LastClause = lists.last(Clauses)
    (clause, _, _, _, Body) = LastClause
    LastLineAst = lists.last(Body)
    last_line(LastLineAst)
  case (`case`, _, _, Clauses):
    last_line(lists.last(Clauses))
  case (`receive`, _, Clauses=_ :: _):
    last_line(lists.last(Clauses))
  case (`receive`, _, Clauses=_ :: _, _, []):
    last_line(lists.last(Clauses))
  case (`receive`, _, _, _, Clauses):
    last_line(lists.last(Clauses))
  case (`if`, _, Clauses):
    last_line(lists.last(Clauses))
  case (`try`, _, Clauses=_ :: _, [], [], []):
    last_line(lists.last(Clauses))
  case (`try`, _, _, Clauses=_ :: _, [], []):
    last_line(lists.last(Clauses))
  case (`try`, _, _, _, Clauses=_ :: _, []):
    last_line(lists.last(Clauses))
  case (`try`, _, _, _, _, Clauses=_ :: _):
    last_line(lists.last(Clauses))
  case (`catch`, _, Body):
    last_line(Body)
  case (`block`, _, Body):
    last_line(Body)
  case (`fun`, _, (clauses, Clauses)):
    last_line(lists.last(Clauses))
  case (`fun`, _, (function, _, _, Node)):
    last_line(Node)
  case (lc, _, _, Items):
    last_line(lists.last(Items))
  case (bc, _, _, Items):
    last_line(lists.last(Items))
  case (generate, _, _, Node):
    last_line(Node)
  case (b_generate, _, _, Node):
    last_line(Node)
  case (bin_element, _, Node, _, _):
    last_line(Node)
  case (op, _, _, Node):
    last_line(Node)
  case (op, _, _, _, Node):
    last_line(Node)
  case (`match`, _, _, Node):
    last_line(Node)
  case (record, Line, _, []):
    Line
  case (record, _, _, Fields):
    last_line(lists.last(Fields))
  case (record, _, _, _, Fields):
    last_line(lists.last(Fields))
  case (record_field, _, _, Node):
    last_line(Node)
  case (record_field, _, _, _, Node):
    last_line(Node)
  case (clause, _, _, Body):
    last_line(lists.last(Body))
  case (clause, _, _, _, Body):
    last_line(lists.last(Body))
  case (bin, Line, []):
    Line
  case (bin, _, Items):
    last_line(lists.last(Items))
  case (tuple, Line, []):
    Line
  case (tuple, _, Items):
    last_line(lists.last(Items))
  case (map, Line, []):
    Line
  case (map, _, Items):
    last_line(lists.last(Items))
  case (call, Line, _, []):
    Line
  case (call, _, _, Args):
    last_line(lists.last(Args))
  case (cons, _, _, Tail):
    last_line(Tail)

  case Nodes when is_list(Nodes):
    last_line(lists.last(Nodes))
  case Node:
    element(2, Node)
end
