@include_lib("xmerl/include/xmerl.hrl")

fn main @public
  case ["docs-to-json", BasePath, OutDir]:
    DocgenDir = code.priv_dir(erl_docgen)
    DtdPaths = [filename.join(DocgenDir, "dtd"),
      filename.join(DocgenDir, "dtd_html_entities")]
    docs_to_json(filename.absname(BasePath), DtdPaths, OutDir)
  case ["docs-to-rst", Path]:
    beamdocs_rst.file_to_rst(Path)
  case ["to-json", BasePath, OutDir]:
    to_json(filename.absname(BasePath), OutDir)
  case ["to-index", BasePath, OutPath, RepoBaseUrl, Commit]:
    to_index(filename.absname(BasePath), OutPath, RepoBaseUrl, Commit)
  case _Args:
    io.format("Usage: beamdocs to-json BaseSrcPath OutDir~n")
    erlang.halt(0)
end

fn docs_to_json @public case BasePath, DtdPaths, OutPath:
  AccIn = {files: [], base_path: BasePath, out_path: OutPath, dtd_paths: DtdPaths}
  Fn = fn doc_to_json:2
  io.format("docs-to-json ~p~n", [BasePath])
  filelib.fold_files(BasePath, ".*\\.xml$", true, Fn, AccIn)
end

fn doc_to_json @public
  case FilePath, AccIn={files=Files, base_path=BasePath, dtd_paths=DtdPaths,
  out_path=OutPath}:
    BaseLen = length(BasePath)
    ShortPath = string.substr(FilePath, BaseLen + 2)

    #_ io.format("process ~p ~p~n", [ShortPath, FilePath])
    (ParsResult, _Misc) = xmerl_scan.file(FilePath, [(fetch_path, DtdPaths)])

    BaseState = {
      path: list_to_binary(ShortPath),
      full_path: list_to_binary(FilePath),
      fns: [],
      exports: [],
      funcs: {},
      datatypes: {},
      sections: []
    }

    Info = xml_doc_to_json(ParsResult, BaseState)

    FileOutPath = filename.join(OutPath, ShortPath ++ ".json")
    filelib.ensure_dir(FileOutPath)
    try
      file.write_file(FileOutPath, jsone.encode(Info))
    catch case _, badarg:
      io.format("ERROR ~p~n", [Info])
    end

    AccIn#{files: Info :: Files}
end

fn xml_doc_to_json
  case [], State={sections=Sections}:
    State#{sections: lists.reverse(Sections)}
  case Node :: Nodes, State:
    State1 = xml_doc_to_json(Node, State)
    xml_doc_to_json(Nodes, State1)
  case #r.xmlElement {name: erlref, content: Content}, State:
    xml_doc_to_json(Content, State)
  case #r.xmlElement {name: chapter, content: Content}, State:
    xml_doc_to_json(Content, State)
  case #r.xmlElement {name: header, content: Content}, State:
    Header0 = maps.get(header, State, {})
    Header = xml_header_to_json(Content, Header0)
    State#{header: Header}
  case #r.xmlElement {name: module, content: [#r.xmlText {value: Name}]}, State:
    State#{module: to_bstr(Name)}
  case #r.xmlElement {name: modulesummary, content: [#r.xmlText {value: Value}]}, State:
    State#{modulesummary: to_bstr(Value)}
  case #r.xmlElement {name: description, content: Content}, State:
    Desc = for Node in Content: xml_desc_to_json(Node) end
    State#{description: Desc}
  case #r.xmlElement {name: section, content: Content}, State={sections=Sections}:
    Desc = for Node in Content: xml_desc_to_json(Node) end
    State#{sections: Desc :: Sections}
  case #r.xmlElement {name: datatypes, content: Content}, State:
    xml_datatypes_to_json(Content, State)
  case #r.xmlElement {name: funcs, content: Content}, State:
    xml_funcs_to_json(Content, State)
  case _Node, State:
    State
end

fn xml_desc_to_json
  case #r.xmlText {value: Value}:
    to_bstr(Value)
  case #r.xmlElement {name: Name, attributes: Attrs, content: Content}:
    Body = (for Node in Content: xml_desc_to_json(Node) end)
    MAttrs = lists.foldl({}, Attrs)
    <<- case #r.xmlAttribute {name: AName, value: AValue}, AIn:
      AIn#{to_bstr(AName): to_bstr(AValue)}
    end
    [to_bstr(Name), MAttrs, Body]
  case #r.xmlComment {value: Value}:
    ['//', {}, to_bstr(Value)]
end


fn xml_header_to_json
  case [], State:
    State
  case Node :: Nodes, State:
    State1 = xml_header_to_json(Node, State)
    xml_header_to_json(Nodes, State1)
  case #r.xmlElement {name: copyright, content: Content}, State:
    Copyright0 = maps.get(copyright, State, {years: []})
    Copyright = lists.foldl(Copyright0, Content) <<- case CRNode, CRIn:
      xml_copyright_to_json(CRNode, CRIn)
    end
    {years=Years} = Copyright
    State#{copyright: Copyright#{years: lists.reverse(Years)}}
  case #r.xmlElement {name: legalnotice, content: [#r.xmlText {value: Value}]},
  State:
    State#{legalnotice: to_bstr(Value)}
  case #r.xmlElement {name: title, content: [#r.xmlText {value: Name}]}, State:
    State#{title: to_bstr(Name)}
  case #r.xmlElement {name: docno, content: [#r.xmlText {value: Name}]}, State:
    State#{docno: to_bstr(Name)}
  case #r.xmlElement {name: prepared, content: [#r.xmlText {value: Name}]}, State:
    State#{prepared: to_bstr(Name)}
  case #r.xmlElement {name: responsible, content: [#r.xmlText {value: Name}]}, State:
    State#{responsible: to_bstr(Name)}
  case #r.xmlElement {name: approved, content: [#r.xmlText {value: Name}]}, State:
    State#{approved: to_bstr(Name)}
  case #r.xmlElement {name: checked, content: [#r.xmlText {value: Name}]}, State:
    State#{checked: to_bstr(Name)}
  case #r.xmlElement {name: date, content: [#r.xmlText {value: Name}]}, State:
    State#{date: to_bstr(Name)}
  case #r.xmlElement {name: rev, content: [#r.xmlText {value: Name}]}, State:
    State#{rev: to_bstr(Name)}
  case #r.xmlElement {name: file, content: [#r.xmlText {value: Name}]}, State:
    State#{file: to_bstr(Name)}
  case _Node, State:
    State
end

fn xml_copyright_to_json
  case #r.xmlElement {name: year, content: [#r.xmlText {value: Value}]},
  State={years=Years}:
    State#{years: to_bstr(Value) :: Years}
  case #r.xmlElement {name: holder, content: [#r.xmlText {value: Value}]}, State:
    State#{holder: to_bstr(Value)}
  case _Node, State:
    State
end

fn xml_funcs_to_json
  case [], State:
    State
  case Node :: Nodes, State:
    State1 = xml_funcs_to_json(Node, State)
    xml_funcs_to_json(Nodes, State1)
  case #r.xmlElement {name: func, content: Content}, State={funcs=Funcs}:
    Func = xml_func_to_json(Content, {name: '?', arity: []})
    FnName = maps.get(name, Func, '?')
    FnArities = maps.get(arity, Func, [0])
    FnAritiesStr = for Arity in FnArities: integer_to_list(Arity) end
    FnId = list_to_binary(binary_to_list(FnName) ++ "/" ++
      string.join(FnAritiesStr, "/"))
    State#{funcs: Funcs#{FnId: Func}}
  case _Node, State:
    State
end

fn xml_func_to_json
  case [], State={arity=Arity}:
    State#{arity: lists.reverse(Arity)}
  case Node :: Nodes, State:
    State1 = xml_func_to_json(Node, State)
    xml_func_to_json(Nodes, State1)
  case #r.xmlElement {name: name, content: [#r.xmlText {value: FnName}]}, State:
    State#{name: to_bstr(re.replace(FnName, "\n\s*", " "))}
  case #r.xmlElement {name: name, attributes: Attrs}, State={arity=Arity}:
    FnName = attr_value(Attrs, name, "?")
    FnArity = attr_value(Attrs, arity, "0")
    State#{name: to_bstr(FnName), arity: list_to_integer(FnArity) :: Arity}
  case #r.xmlElement {name: fsummary, content: [#r.xmlText {value: Value}]}, State:
    State#{fsummary: to_bstr(Value)}
  case #r.xmlElement {name: desc, content: Content}, State:
    Desc = for Node in Content: xml_desc_to_json(Node) end
    State#{desc: Desc}
  case _Node, State:
    State
end

fn xml_datatypes_to_json
  case [], State:
    State
  case Node :: Nodes, State:
    State1 = xml_datatypes_to_json(Node, State)
    xml_datatypes_to_json(Nodes, State1)
  case #r.xmlElement {name: datatype, content: Content}, State={datatypes=DataTypes}:
    DataType = xml_datatype_to_json(Content, {name: '?'})
    DataTypeName = maps.get(name, DataType, '?')
    State#{datatypes: DataTypes#{DataTypeName: DataType}}
  case _Node, State:
    State
end

fn xml_datatype_to_json
  case [], State:
    State
  case Node :: Nodes, State:
    State1 = xml_datatype_to_json(Node, State)
    xml_datatype_to_json(Nodes, State1)
  case #r.xmlElement {name: name, attributes: Attrs}, State:
    Name = attr_value(Attrs, name, "?")
    State#{name: to_bstr(Name)}
  case #r.xmlElement {name: desc, content: Content}, State:
    Desc = for Node in Content: xml_desc_to_json(Node) end
    State#{desc: Desc}
  case _Node, State:
    State
end

fn attr_value
  case [], _Name, Default:
    Default
  case #r.xmlAttribute {name: Name, value: Value} :: _Attrs, Name, _Default:
    Value
  case _ :: Attrs, Name, Default:
    attr_value(Attrs, Name, Default)
end

fn to_bstr
  case LStr when is_list(LStr): unicode.characters_to_binary(LStr, utf8)
  case BStr when is_binary(BStr): BStr
  case Atom when is_atom(Atom): Atom -> atom_to_list() -> to_bstr()
end

fn to_json @public case BasePath, OutPath:
  AccIn = {files: [], base_path: BasePath, out_path: OutPath}
  Fn = fn file_to_json:2
  io.format("to-json ~p~n", [BasePath])
  filelib.fold_files(BasePath, ".*\\.erl$", true, Fn, AccIn)
end

fn file_to_json @public
  case FilePath, AccIn={files=Files, base_path=BasePath, out_path=OutPath}:
    BaseLen = length(BasePath)
    ShortPath = string.substr(FilePath, BaseLen + 2)

    io.format("process ~p~n", [ShortPath])

    ParseResult = epp.parse_file(FilePath, [], [])

    BaseModState = {
    path: list_to_binary(ShortPath),
    full_path: list_to_binary(FilePath),
    fns: [],
    exports: []
    }

    (_, Info) = match ParseResult:
      case ok, Ast:
        ast_walk.walk(Ast, fn walker:2, BaseModState)
      case error, Reason:
        io.format("Error: parsing ~p: ~p~n", [FilePath, Reason])
        BaseModState
    end

    FileOutPath = filename.join(OutPath, ShortPath ++ ".json")
    filelib.ensure_dir(FileOutPath)
    file.write_file(FileOutPath, jsone.encode(Info))

    AccIn#{files: Info :: Files}
end

fn walker
  case State={exports=Exps}, Node=(attribute, _Line, export, FunRefs):
    Fns = for (FnName, Arity) in FunRefs:
      {name: FnName, arity: Arity}
    end
    (Node, State#{exports=Fns ++ Exps})
  case State={fns=Fns}, Node=(function, Line, Name, Arity, Clauses):
    LastLine = last_line(Node)

    Fn = {
      name: Name,
      line: Line,
      arity: Arity,
      clauses_count: length(Clauses),
      lines: LastLine - Line + 1
    }
    (Node, State#{fns=Fn :: Fns})
  case State, Node:
    (Node, State)
end

fn to_index @public case BasePath, OutPath, RepoBaseUrl, Commit:
  AccIn = {}
  Fn = fn file_to_index:2
  io.format("to-index~p~n", [BasePath])
  AccOut = filelib.fold_files(BasePath, ".*\\.erl\\.json$", true, Fn, AccIn)
  Data = jsone.encode({
    mods: AccOut,
    repository: list_to_binary(RepoBaseUrl),
    commit: list_to_binary(Commit)
  })
  file.write_file(OutPath, Data)
end

fn file_to_index @public case FilePath, AccIn:
  io.format("processing ~p~n", [FilePath])
  (ok, Binary) = file.read_file(FilePath)
  Info = jsone.decode(Binary)
  Exports  = maps.get('exports', Info, [])
  Fns = maps.get('fns', Info, [])
  SrcPath = maps.get('path', Info, '')

  ExportsMap = maps.from_list((for {'arity'=Arity, 'name'=Name} in Exports:
    ExportName = io_lib.format("~s/~p", [Name, Arity]) -> list_to_binary()
    (ExportName, 1)
  end))

  FnsMap = maps.from_list((for {'arity'=Arity, 'name'=Name, 'line'=Line} in Fns:
    FnName = io_lib.format("~s/~p", [Name, Arity]) -> list_to_binary()
    IsPublic = maps.get(FnName, ExportsMap, 0)
    (FnName, [Line, IsPublic])
  end))

  ModName = filename.basename(FilePath, ".erl.json") -> list_to_binary()
  AccIn#{ModName: {fns: FnsMap, path: SrcPath}}
end

fn last_line
@doc("Totally ad-hoc function to get an approx last line for an ast")

  case (function, _, _, _, Clauses):
    LastClause = lists.last(Clauses)
    (clause, _, _, _, Body) = LastClause
    LastLineAst = lists.last(Body)
    last_line(LastLineAst)
  case (`case`, _, _, Clauses):
    last_line(lists.last(Clauses))
  case (`receive`, _, Clauses=_ :: _):
    last_line(lists.last(Clauses))
  case (`receive`, _, Clauses=_ :: _, _, []):
    last_line(lists.last(Clauses))
  case (`receive`, _, _, _, Clauses):
    last_line(lists.last(Clauses))
  case (`if`, _, Clauses):
    last_line(lists.last(Clauses))
  case (`try`, _, Clauses=_ :: _, [], [], []):
    last_line(lists.last(Clauses))
  case (`try`, _, _, Clauses=_ :: _, [], []):
    last_line(lists.last(Clauses))
  case (`try`, _, _, _, Clauses=_ :: _, []):
    last_line(lists.last(Clauses))
  case (`try`, _, _, _, _, Clauses=_ :: _):
    last_line(lists.last(Clauses))
  case (`catch`, _, Body):
    last_line(Body)
  case (`block`, _, Body):
    last_line(Body)
  case (`fun`, _, (clauses, Clauses)):
    last_line(lists.last(Clauses))
  case (`fun`, _, (function, _, _, Node)):
    last_line(Node)
  case (lc, _, _, Items):
    last_line(lists.last(Items))
  case (bc, _, _, Items):
    last_line(lists.last(Items))
  case (generate, _, _, Node):
    last_line(Node)
  case (b_generate, _, _, Node):
    last_line(Node)
  case (bin_element, _, Node, _, _):
    last_line(Node)
  case (op, _, _, Node):
    last_line(Node)
  case (op, _, _, _, Node):
    last_line(Node)
  case (`match`, _, _, Node):
    last_line(Node)
  case (record, Line, _, []):
    Line
  case (record, _, _, Fields):
    last_line(lists.last(Fields))
  case (record, _, _, _, Fields):
    last_line(lists.last(Fields))
  case (record_field, _, _, Node):
    last_line(Node)
  case (record_field, _, _, _, Node):
    last_line(Node)
  case (clause, _, _, Body):
    last_line(lists.last(Body))
  case (clause, _, _, _, Body):
    last_line(lists.last(Body))
  case (bin, Line, []):
    Line
  case (bin, _, Items):
    last_line(lists.last(Items))
  case (tuple, Line, []):
    Line
  case (tuple, _, Items):
    last_line(lists.last(Items))
  case (map, Line, []):
    Line
  case (map, _, Items):
    last_line(lists.last(Items))
  case (call, Line, _, []):
    Line
  case (call, _, _, Args):
    last_line(lists.last(Args))
  case (cons, _, _, Tail):
    last_line(Tail)

  case Nodes when is_list(Nodes):
    last_line(lists.last(Nodes))
  case Node:
    element(2, Node)
end
