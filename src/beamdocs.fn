

fn main @public
    case ["to-json", BasePath, OutDir]:
        to_json(filename.absname(BasePath), OutDir)
    case _Args:
        io.format("Usage: beamdocs to-json BaseSrcPath OutDir~n")
        erlang.halt(0)
end

fn to_json @public case BasePath, OutPath:
    AccIn = {files: [], base_path: BasePath, out_path: OutPath}
    Fn = fn file_to_json:2
    io.format("to-json ~p~n", [BasePath])
    filelib.fold_files(BasePath, ".*\\.erl$", true, Fn, AccIn)
end

fn file_to_json @public
    case FilePath, AccIn={files=Files, base_path=BasePath, out_path=OutPath}:
        BaseLen = length(BasePath)
        ShortPath = string.substr(FilePath, BaseLen + 2)

        io.format("process ~p~n", [ShortPath])

        ParseResult = epp.parse_file(FilePath, [], [])

        BaseModState = {
            path: ShortPath,
            full_path: FilePath,
            fns: [],
            exports: []
        }

        (_, Info) = match ParseResult:
            case ok, Ast:
                ast_walk.walk(Ast, fn walker:2, BaseModState)
            case error, Reason:
                io.format("Error: parsing ~p: ~p~n", [FilePath, Reason])
                BaseModState
        end

        FileOutPath = filename.join(OutPath, ShortPath ++ ".json")
        filelib.ensure_dir(FileOutPath)
        file.write_file(FileOutPath, jsone.encode(Info))

        AccIn#{files: [Info :: Files]}
end

fn walker
    case State={exports=Exps}, Node=(attribute, _Line, export, FunRefs):
        Fns = for (FnName, Arity) in FunRefs:
            {name: FnName, arity: Arity}
        end
        (Node, State#{exports=Fns ++ Exps})
    case State={fns=Fns}, Node=(function, Line, Name, Arity, Clauses):
        LastClause = lists.last(Clauses)
        (clause, _, _, _, Body) = LastClause
        LastLineAst = lists.last(Body)
        LastLine = element(2, LastLineAst)

        Fn = {
            name: Name,
            line: Line,
            arity: Arity,
            clauses_count: length(Clauses),
            lines: LastLine - Line
        }
        (Node, State#{fns=[Fn :: Fns]})
    case State, Node:
        (Node, State)
end
